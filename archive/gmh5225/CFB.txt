Project Path: arc_gmh5225_CFB_hx9cmnm9

Source Tree:

```txt
arc_gmh5225_CFB_hx9cmnm9
├── Assets
│   └── img
│       └── logo
│           ├── Logo_v1.ai
│           ├── Logo_v1.png
│           ├── Logo_v1.svg
│           ├── Logo_v1.wmf
│           ├── Logo_v2.png
│           ├── Logo_v2_small.png
│           ├── bear.ico
│           └── logo.ico
├── Broker
│   ├── Broker.rc
│   ├── Broker.vcxproj
│   ├── Broker.vcxproj.filters
│   ├── CfbException.cpp
│   ├── CfbException.h
│   ├── Driver.cpp
│   ├── FrontEndServer.cpp
│   ├── FrontEndServer.h
│   ├── Irp.cpp
│   ├── Irp.h
│   ├── PipeTransportManager.cpp
│   ├── PipeTransportManager.h
│   ├── SafeHandle.cpp
│   ├── SafeHandle.h
│   ├── ServerTransportManager.h
│   ├── ServiceManager.cpp
│   ├── ServiceManager.h
│   ├── Session.cpp
│   ├── Session.h
│   ├── Task.cpp
│   ├── TaskManager.cpp
│   ├── TaskManager.h
│   ├── TcpSocketTransportManager.cpp
│   ├── TcpSocketTransportManager.h
│   ├── Utils.cpp
│   ├── Utils.h
│   ├── common.h
│   ├── driver.h
│   ├── json.hpp
│   ├── main.cc
│   ├── main.h
│   ├── nt.h
│   ├── resource.h
│   └── task.h
├── CFB.sln
├── Common
│   ├── Common.vcxproj
│   ├── Common.vcxproj.filters
│   ├── common.c
│   ├── common.h
│   ├── stdafx.c
│   ├── stdafx.h
│   └── targetver.h
├── Docs
│   ├── FAQ.md
│   ├── crash-analysis.md
│   └── fuzzing-vm-setup.md
├── Driver
│   ├── Common.h
│   ├── Driver.c
│   ├── Driver.h
│   ├── Driver.inf
│   ├── Driver.vcxproj
│   ├── Driver.vcxproj.filters
│   ├── HookedDrivers.c
│   ├── HookedDrivers.h
│   ├── InterceptedIrpHandler.c
│   ├── InterceptedIrpHandler.h
│   ├── IoAddDriver.c
│   ├── IoAddDriver.h
│   ├── IoEnableDisableDriverMonitoring.c
│   ├── IoEnableDisableDriverMonitoring.h
│   ├── IoEnableDisableMonitoring.c
│   ├── IoEnableDisableMonitoring.h
│   ├── IoGetDriverInfo.c
│   ├── IoGetDriverInfo.h
│   ├── IoRemoveDriver.c
│   ├── IoRemoveDriver.h
│   ├── IoSetEventPointer.c
│   ├── IoSetEventPointer.h
│   ├── IoStoreTestCase.c
│   ├── IoStoreTestCase.h
│   ├── IoctlCodes.h
│   ├── Queue.c
│   ├── Queue.h
│   ├── Utils.c
│   └── Utils.h
├── GUI
│   ├── App.xaml
│   ├── App.xaml.cs
│   ├── AppShell.xaml
│   ├── AppShell.xaml.cs
│   ├── Assets
│   │   ├── BadgeLogo.scale-100.png
│   │   ├── BadgeLogo.scale-125.png
│   │   ├── BadgeLogo.scale-150.png
│   │   ├── BadgeLogo.scale-200.png
│   │   ├── BadgeLogo.scale-400.png
│   │   ├── FuriousBeaver_AppIcon.altform-lightunplated_targetsize-16.png
│   │   ├── FuriousBeaver_AppIcon.altform-lightunplated_targetsize-24.png
│   │   ├── FuriousBeaver_AppIcon.altform-lightunplated_targetsize-256.png
│   │   ├── FuriousBeaver_AppIcon.altform-lightunplated_targetsize-32.png
│   │   ├── FuriousBeaver_AppIcon.altform-lightunplated_targetsize-48.png
│   │   ├── FuriousBeaver_AppIcon.altform-unplated_targetsize-16.png
│   │   ├── FuriousBeaver_AppIcon.altform-unplated_targetsize-24.png
│   │   ├── FuriousBeaver_AppIcon.altform-unplated_targetsize-256.png
│   │   ├── FuriousBeaver_AppIcon.altform-unplated_targetsize-32.png
│   │   ├── FuriousBeaver_AppIcon.altform-unplated_targetsize-48.png
│   │   ├── FuriousBeaver_AppIcon.scale-100.png
│   │   ├── FuriousBeaver_AppIcon.scale-125.png
│   │   ├── FuriousBeaver_AppIcon.scale-150.png
│   │   ├── FuriousBeaver_AppIcon.scale-200.png
│   │   ├── FuriousBeaver_AppIcon.scale-400.png
│   │   ├── FuriousBeaver_AppIcon.targetsize-16.png
│   │   ├── FuriousBeaver_AppIcon.targetsize-24.png
│   │   ├── FuriousBeaver_AppIcon.targetsize-256.png
│   │   ├── FuriousBeaver_AppIcon.targetsize-32.png
│   │   ├── FuriousBeaver_AppIcon.targetsize-48.png
│   │   ├── FuriousBeaver_SplashScreen.scale-100.png
│   │   ├── FuriousBeaver_SplashScreen.scale-125.png
│   │   ├── FuriousBeaver_SplashScreen.scale-150.png
│   │   ├── FuriousBeaver_SplashScreen.scale-200.png
│   │   ├── FuriousBeaver_SplashScreen.scale-400.png
│   │   ├── Square150x150Logo.scale-100.png
│   │   ├── Square150x150Logo.scale-125.png
│   │   ├── Square150x150Logo.scale-150.png
│   │   ├── Square150x150Logo.scale-200.png
│   │   ├── Square150x150Logo.scale-400.png
│   │   ├── StoreLogo.backup.png
│   │   ├── StoreLogo.scale-100.png
│   │   ├── StoreLogo.scale-125.png
│   │   ├── StoreLogo.scale-150.png
│   │   ├── StoreLogo.scale-200.png
│   │   ├── StoreLogo.scale-400.png
│   │   └── Wide310x150Logo.scale-200.png
│   ├── GUI.csproj
│   ├── Helpers
│   │   ├── Constants.cs
│   │   ├── ErrorCodes.cs
│   │   ├── Exceptions.cs
│   │   └── Utils.cs
│   ├── Models
│   │   ├── BrokerMessage.cs
│   │   ├── ConnectionManager.cs
│   │   ├── Constants.cs
│   │   ├── Device.cs
│   │   ├── Driver.cs
│   │   ├── Irp.cs
│   │   └── IrpDumper.cs
│   ├── Package.appxmanifest
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   └── Default.rd.xml
│   ├── Repositories
│   │   ├── DriverRepository.cs
│   │   ├── IAsyncDriverRepository.cs
│   │   ├── IAsyncIrpRepository.cs
│   │   └── IrpRepository.cs
│   ├── ScriptTemplates
│   │   ├── CTemplate.txt
│   │   ├── PowershellTemplate.txt
│   │   └── PythonTemplate.txt
│   ├── UserControls
│   │   ├── CollapsibleSearchBox.xaml
│   │   └── CollapsibleSearchBox.xaml.cs
│   ├── ViewModels
│   │   ├── BindableBase.cs
│   │   ├── BrokerConnectionViewModel.cs
│   │   ├── Converters.cs
│   │   ├── DriverListPageViewModel.cs
│   │   ├── DriverViewModel.cs
│   │   ├── IrpReplayViewModel.cs
│   │   ├── IrpViewModel.cs
│   │   ├── MonitoredIrpsViewModel.cs
│   │   ├── SaveLoadIrpsViewModel.cs
│   │   └── SessionInfoViewModel.cs
│   └── Views
│       ├── AboutPage.xaml
│       ├── AboutPage.xaml.cs
│       ├── DataGridHelper.cs
│       ├── DriverListPage.xaml
│       ├── DriverListPage.xaml.cs
│       ├── IrpInfoPage.xaml
│       ├── IrpInfoPage.xaml.cs
│       ├── LoadIrpsFromFilePage.xaml
│       ├── LoadIrpsFromFilePage.xaml.cs
│       ├── MonitoredIrpsPage.xaml
│       ├── MonitoredIrpsPage.xaml.cs
│       ├── ReplayIrpPage.xaml
│       ├── ReplayIrpPage.xaml.cs
│       ├── SaveIrpsToFilePage.xaml
│       ├── SaveIrpsToFilePage.xaml.cs
│       ├── SessionInfoPage.xaml
│       ├── SessionInfoPage.xaml.cs
│       ├── SettingsPage.xaml
│       └── SettingsPage.xaml.cs
└── README.md

```

`Assets/img/logo/Logo_v1.svg`:

```svg
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 925.54 527"><defs><style>.cls-1,.cls-6{fill:#fff;}.cls-1,.cls-10,.cls-2,.cls-3,.cls-4,.cls-7,.cls-8{stroke:#000;}.cls-1,.cls-10,.cls-2,.cls-3,.cls-4,.cls-7,.cls-8,.cls-9{stroke-miterlimit:10;}.cls-2,.cls-5,.cls-9{fill:none;}.cls-3{fill:#8b001b;}.cls-4{fill:#8c6239;}.cls-8{fill:#512e12;}.cls-9{stroke:#b91400;}.cls-10,.cls-9{stroke-width:2px;}.cls-11{font-size:57px;fill:#730006;font-family:MVBoli, MV Boli;}.cls-12{font-size:32px;}</style></defs><title>Logo_v1</title><text x="-51" y="-20"/><path class="cls-1" d="M743.5,160.5" transform="translate(-51 -20)"/><path class="cls-2" d="M627.5,128.5" transform="translate(-51 -20)"/><path class="cls-3" d="M17.5,263.5" transform="translate(-51 -20)"/><circle class="cls-4" cx="98" cy="49" r="48.5"/><circle class="cls-4" cx="409.5" cy="48.5" r="45"/><circle class="cls-4" cx="253.5" cy="273.5" r="253"/><path class="cls-5" d="M149,313" transform="translate(-51 -20)"/><path class="cls-6" d="M349,321.57c14.32,18.23,29.2,36.66,48.81,49.06s45.08,17.9,66.28,8.5c12.21-5.42,22-15.22,30.11-25.79,30.63-39.69,41.72-93.73,29.19-142.25l-.39-.79Q434.71,262,349.6,318.88" transform="translate(-51 -20)"/><path d="M347.94,322.63c14.33,18.22,29.26,36.78,49.11,49.3,17.85,11.25,40.75,17.22,61.42,10.89C479,376.54,493.69,358.54,504.6,341a169.14,169.14,0,0,0,23.12-62.12,171,171,0,0,0,2-36.23,167.48,167.48,0,0,0-1.93-17.86c-.8-4.86-1.32-10.74-3.49-15.22a1.52,1.52,0,0,0-2-.54Q434,260.74,348.84,317.59c-1.6,1.07-.1,3.67,1.51,2.59q85.09-56.82,173.41-108.59l-2-.53c1.81,3.73,2.21,8.86,2.92,12.93a159.9,159.9,0,0,1,2,17,167.85,167.85,0,0,1-19.79,90.14c-9.6,17.7-22.85,36.45-41.33,45.63-19.94,9.92-44,5.53-62.75-5-21.68-12.13-37.59-32.11-52.69-51.33-1.19-1.51-3.3.62-2.12,2.13Z" transform="translate(-51 -20)"/><ellipse class="cls-7" cx="347.52" cy="303" rx="21.53" ry="25.5"/><path class="cls-6" d="M260.45,317.57c-14.3,18.23-29.16,36.66-48.74,49.06s-45,17.9-66.18,8.5c-12.2-5.42-21.93-15.22-30.07-25.79-30.58-39.69-41.65-93.73-29.14-142.25l.38-.79Q174.87,258,259.85,314.88" transform="translate(-51 -20)"/><path d="M259.39,316.5c-13.46,17.15-27.38,34.63-45.6,47-17.71,12-40.78,18.9-61.85,12.44-20.43-6.26-35-24.9-45.52-42.51a168,168,0,0,1-23.56-91.6,159.91,159.91,0,0,1,1.71-18.67c.76-5,1.2-11.48,3.43-16.08l-2,.53q88.14,51.75,173.15,108.59c1.61,1.08,3.11-1.52,1.51-2.59Q175.65,256.77,87.46,205a1.52,1.52,0,0,0-2,.54c-1.86,3.83-2.34,8.71-3.08,12.86-.91,5.11-1.58,10.27-2,15.44a167.35,167.35,0,0,0,.62,33.49,171.38,171.38,0,0,0,19.32,61.35c9.91,18.3,23.8,37.83,43.06,47.07,19.54,9.37,42.53,6,61.37-3.42,23.68-11.9,40.79-33.28,56.82-53.7,1.18-1.51-.93-3.64-2.12-2.13Z" transform="translate(-51 -20)"/><ellipse class="cls-7" cx="160" cy="299" rx="21.5" ry="25.5"/><ellipse class="cls-8" cx="255.5" cy="364" rx="29" ry="21.5"/><path class="cls-2" d="M284.12,340l45.88.33A293,293,0,0,1,293.08,352l22.87-.13-30.84,4.31c12.29.69,24.79,1.62,36.73-.52" transform="translate(-51 -20)"/><path class="cls-9" d="M110.33,344.65l18-32.69,5.19,20.8a20.76,20.76,0,0,0,6.92-16.68,13,13,0,0,1,5,8.17c5.19,2.95,9.43,1.27,14.62,4.23" transform="translate(-51 -20)"/><path class="cls-9" d="M82,258.54l44-5.42-20.33,16.62a125.63,125.63,0,0,1,31-4.4" transform="translate(-51 -20)"/><path class="cls-9" d="M525.71,235.23a242.22,242.22,0,0,0-50.07,26.21l32.19.62-18.9,11.46,11.84,0a128.07,128.07,0,0,1-29.62,11.22l-2.25-4.14c-4.29-.45-8.83,1.46-10.42,4.38" transform="translate(-51 -20)"/><path class="cls-9" d="M505.31,327.87l-13.09-26.1-2.74,24.84L476.15,307.2c.09,4.74,0,9.93-3,13.55s-10.23,3.65-11.57-.89" transform="translate(-51 -20)"/><path d="M307.53,446.33a1.5,1.5,0,0,0,0-3,1.5,1.5,0,0,0,0,3Z" transform="translate(-51 -20)"/><path d="M307.53,447.16a1.5,1.5,0,0,0,0-3,1.5,1.5,0,0,0,0,3Z" transform="translate(-51 -20)"/><path d="M307.53,447.16a1.5,1.5,0,0,0,0-3,1.5,1.5,0,0,0,0,3Z" transform="translate(-51 -20)"/><path class="cls-2" d="M257.15,489.22" transform="translate(-51 -20)"/><path class="cls-1" d="M317.92,486a501.93,501.93,0,0,0-126.66,13.14c-11.78,2.77-26.28,5.2-34.25-3.74-3.93-4.41-5-10.51-5.81-16.31a251.35,251.35,0,0,1-1.7-47.57c.45-7.41,1.72-15.76,8.16-19.69,7.36-4.5,17-.68,25,2.59,39.6,16.19,86.6,13.94,124.4-5.94h1c37.8,19.88,84.8,22.13,124.4,5.94,8-3.27,17.47-7.2,24.83-2.7,6.43,3.94,7.84,12.39,8.29,19.8a251.35,251.35,0,0,1-1.7,47.57c-.76,5.8-1.88,11.9-5.81,16.31-8,8.94-22.47,6.51-34.25,3.74A501.93,501.93,0,0,0,297.14,486Z" transform="translate(-51 -20)"/><line class="cls-1" x1="372.01" y1="398.49" x2="372.83" y2="480.01"/><line class="cls-1" x1="342.63" y1="404.88" x2="343.45" y2="473.62"/><line class="cls-1" x1="310.8" y1="404.48" x2="313.25" y2="469.22"/><line class="cls-1" x1="201.44" y1="404.88" x2="201.44" y2="469.62"/><line class="cls-1" x1="169.61" y1="404.88" x2="170.43" y2="473.62"/><line class="cls-1" x1="141.05" y1="399.29" x2="140.23" y2="478.41"/><line class="cls-1" x1="397.31" y1="428.46" x2="282.24" y2="434.85"/><line class="cls-1" x1="116.56" y1="428.46" x2="231.64" y2="434.85"/><path class="cls-1" d="M307.94,510h22l2.45-91.11-25.3-10.39Q307.52,459.25,307.94,510Z" transform="translate(-51 -20)"/><path class="cls-1" d="M306.31,510h-22l-2.45-91.11,25.3-10.39Z" transform="translate(-51 -20)"/><polyline class="cls-1" points="406.29 390.9 397.31 429.26 397.31 434.06 402.21 478.81"/><polyline class="cls-1" points="106.77 481.21 115.89 435.5 116.2 430.64 107.22 392.28"/><ellipse class="cls-10" cx="294.38" cy="390.04" rx="7.77" ry="11.35" transform="translate(-245.2 378.94) rotate(-54)"/><ellipse class="cls-10" cx="319.62" cy="389.54" rx="12.46" ry="7.58" transform="matrix(0.81, -0.59, 0.59, 0.81, -218.93, 242.26)"/><path class="cls-1" d="M538.5,197.5a1457.34,1457.34,0,0,1-236,20,1457.39,1457.39,0,0,1-233-18,296.56,296.56,0,0,1,56-86,1737.83,1737.83,0,0,0,176,7,1736.77,1736.77,0,0,0,177-11,274.68,274.68,0,0,1,60,88Z" transform="translate(-51 -20)"/><text x="-51" y="-20"/><text class="cls-11" transform="translate(54.92 160.65)">C<tspan class="cls-12" x="33.93" y="0">anadian </tspan><tspan x="157.01" y="0">F</tspan><tspan class="cls-12" x="188.48" y="0">urious </tspan><tspan x="291.45" y="0">B</tspan><tspan class="cls-12" x="325.94" y="0">eaver</tspan></text></svg>
```

`Broker/Broker.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// CFB_DRIVER
//

IDR_CFB_DRIVER1         CFB_DRIVER              CFB_PATH_DRIVER_PATH_RSC //"..\\x64\\Debug\\IrpDumper.sys"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (Canada) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENC)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_CAN
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON3               ICON                    "..\\Assets\\img\\logo\\logo.ico"

#endif    // English (Canada) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Broker/Broker.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}</ProjectGuid>
    <RootNamespace>Broker</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_COLORIZE;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <AdditionalDependencies>ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;_UNICODE;UNICODE</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_COLORIZE;_DEBUG;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CfbException.cpp" />
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="FrontEndServer.cpp" />
    <ClCompile Include="Irp.cpp" />
    <ClCompile Include="main.cc" />
    <ClCompile Include="PipeTransportManager.cpp" />
    <ClCompile Include="SafeHandle.cpp" />
    <ClCompile Include="ServiceManager.cpp" />
    <ClCompile Include="Session.cpp" />
    <ClCompile Include="Task.cpp" />
    <ClCompile Include="TaskManager.cpp" />
    <ClCompile Include="TcpSocketTransportManager.cpp" />
    <ClCompile Include="Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CfbException.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="driver.h" />
    <ClInclude Include="FrontEndServer.h" />
    <ClInclude Include="Irp.h" />
    <ClInclude Include="json.hpp" />
    <ClInclude Include="main.h" />
    <ClInclude Include="nt.h" />
    <ClInclude Include="PipeTransportManager.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="SafeHandle.h" />
    <ClInclude Include="ServerTransportManager.h" />
    <ClInclude Include="ServiceManager.h" />
    <ClInclude Include="Session.h" />
    <ClInclude Include="Task.h" />
    <ClInclude Include="TaskManager.h" />
    <ClInclude Include="TcpSocketTransportManager.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Common\Common.vcxproj">
      <Project>{a1e1112d-966d-45ec-96de-b84371e803ee}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Broker.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Assets\img\logo\logo.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`Broker/Broker.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cc">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TaskManager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Task.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FrontEndServer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ServiceManager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Session.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CfbException.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Irp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TcpSocketTransportManager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PipeTransportManager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SafeHandle.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="TaskManager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Task.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FrontEndServer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ServiceManager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Session.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="json.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CfbException.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Irp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="TcpSocketTransportManager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ServerTransportManager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PipeTransportManager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SafeHandle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Broker.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Assets\img\logo\logo.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`Broker/CfbException.cpp`:

```cpp
#include "CfbException.h"


BaseException::BaseException(const char* filename, unsigned int line, const char* funct, const char* msg)
	: m_filename(filename), m_msg(msg),	m_function_name(funct),	m_line(line)
{
	std::ostringstream oss;
	oss << "[" << __func__ << " in " << m_filename << ":" << m_line << " - " << m_function_name <<"()]" << std::endl;
	oss << "Reason: " << m_msg << std::endl;
	oss << "GetLastError: 0x" << std::hex << ::GetLastError();
	m_report = oss.str();
}



const char* BaseException::what() const throw()
{
	return m_report.c_str();
}




```

`Broker/CfbException.h`:

```h
#pragma once

#include <Windows.h>

#include <exception>
#include <string>
#include <sstream>


#define RAISE_EXCEPTION(excpt, msg) throw excpt(__FILE__,  __LINE__, __FUNCTION__, msg)
#define RAISE_GENERIC_EXCEPTION(msg) throw BaseException(__FILE__,  __LINE__, __FUNCTION__, msg)


class BaseException :
	public std::exception
{

public:
	BaseException(const char* filename, unsigned int line, const char* funct, const char* msg);
	const char* what() const throw();


protected:
	std::string m_exception;
	std::string m_filename;
	std::string	m_msg;
	std::string m_function_name;
	std::string m_report;
	unsigned int m_line;
};


class BrokenPipeException: public BaseException
{
public:
	BrokenPipeException(const char* filename, unsigned int line, const char* funct, const char* msg) : BaseException(filename, line, funct, msg){}
};

class InvalidRequestException : public BaseException
{
public:
	InvalidRequestException(const char* filename, unsigned int line, const char* funct, const char* msg) : BaseException(filename, line, funct, msg) {}
};
```

`Broker/Driver.cpp`:

```cpp
#include "driver.h"


/*++

Routine Description:

Simple function to create and share the event associated with the userland notification 
that new data has been captured by the driver (and can be read).


Arguments:

	hDevice - a handle to the IrpDumper device

	
Return Value:

	Returns a handle to the event shared with the driver on success, INVALID_HANDLE_VALUE otherwise

--*/
static inline HANDLE ShareHandleWithDriver(_In_ HANDLE hDevice)
{
	DWORD dwNbBytesReturned;
	

	HANDLE hDataEvent = ::CreateEvent(
		NULL,
		TRUE,
		FALSE,
		NULL
	);

	if (!hDataEvent)
		return INVALID_HANDLE_VALUE;


	BOOL bRes = ::DeviceIoControl(
		hDevice,
		IOCTL_SetEventPointer,
		(byte*)&hDataEvent,
		sizeof(HANDLE),
		NULL,
		0,
		&dwNbBytesReturned,
		NULL
	);

	dbg(L"ShareHandleWithDriver() returned: %s\n", bRes ? L"TRUE" : L"FALSE");

	if (bRes)
		return hDataEvent;

	::CloseHandle(hDataEvent);

	return INVALID_HANDLE_VALUE;
}


/*++

Routine Description:

Fetch one IRP (metadata + data) temporarily from the IrpDumper driver, and stores it in memory.


Arguments:

	hDevice -

	hEvent - 

	Session -



Return Value:

	Returns ERROR_SUCCESS on success, GetLastError() otherwise

--*/
static DWORD FetchNextIrpFromDevice(_In_ HANDLE hDevice, _In_ HANDLE hEvent, _In_ Session& Session)
{
	DWORD dwBufferSize = 0, dwNumberOfBytesRead = 0;

	BOOL bRes = ::ReadFile(hDevice, nullptr, dwBufferSize, &dwNumberOfBytesRead, NULL);

	//
	// Retrieve the expected buffer size
	//
	dbg(L"ReadFile(hDevice=%p, dwBufferSize=%d, dwNumberOfBytesRead=%d) -> %d\n", hDevice, dwBufferSize, dwNumberOfBytesRead, bRes);

	if (bRes == FALSE)
	{
		DWORD errCode = ::GetLastError();
		if (errCode != ERROR_NO_MORE_ITEMS)
			PrintErrorWithFunctionName(L"ReadFile(GetBufferSize)");
		return errCode;
	}

	if (dwNumberOfBytesRead == 0)
		return ERROR_NO_MORE_ITEMS;

	//
	// Create a buffer of the correct size, and fetch the raw IRP
	//
	dbg(L"dwBufferSize=%u dwNumberOfBytesRead=%u\n", dwBufferSize, dwNumberOfBytesRead);
	dwBufferSize = dwNumberOfBytesRead;
	auto lpBuffer = std::make_unique<byte[]>(dwBufferSize);
	if (!lpBuffer)
		return ::GetLastError();

	bRes = ::ReadFile(hDevice, lpBuffer.get(), dwBufferSize, &dwNumberOfBytesRead, NULL);

	dbg(L"ReadFile2(hDevice=%p, dwBufferSize=%d, dwNumberOfBytesRead=%d) -> %d\n", hDevice, dwBufferSize, dwNumberOfBytesRead, bRes);

	if (bRes == FALSE)
	{
		PrintErrorWithFunctionName(L"ReadFile(GetBufferData)");
		return ::GetLastError();
	}

	if (dwBufferSize == dwNumberOfBytesRead && dwBufferSize >= sizeof(INTERCEPTED_IRP_HEADER))
	{
		PBYTE lpBufferOffset = lpBuffer.get();

		const PINTERCEPTED_IRP_HEADER pIrpHeader = (PINTERCEPTED_IRP_HEADER)lpBufferOffset;
		lpBufferOffset += sizeof(INTERCEPTED_IRP_HEADER);

		const PINTERCEPTED_IRP_BODY pIrpBodyIn = (PINTERCEPTED_IRP_BODY)lpBufferOffset;
		lpBufferOffset += pIrpHeader->InputBufferLength;

		const PINTERCEPTED_IRP_BODY pIrpBodyOut = (PINTERCEPTED_IRP_BODY)lpBufferOffset;
		/*
		dbg(L"New IRP received:\n"
			L" - timestamp:%llu\n"
			L" - IRQ level:%x\n"
			L" - Major type:%x\n"
			L" - IoctlCode:%x\n"
			L" - PID=%d / TID=%d\n"
			L" - Status=%u\n"
			L" - InputBufferLength=%u / OutputBufferLength=%u\n"
			L" - ProcessName:%s\n"
			L" - DriverName:%s\n"
			L" - DeviceName:%s\n",
			pIrpHeader->TimeStamp,
			pIrpHeader->Irql,
			pIrpHeader->Type,
			pIrpHeader->IoctlCode,
			pIrpHeader->Pid, pIrpHeader->Tid,
			pIrpHeader->Status,
			pIrpHeader->InputBufferLength, pIrpHeader->OutputBufferLength,
			pIrpHeader->ProcessName,
			pIrpHeader->DriverName,
			pIrpHeader->DeviceName
		);
		*/
		//
		// pushing new IRP to the session queue
		//
		Irp irp(pIrpHeader, pIrpBodyIn, pIrpBodyOut);

		std::unique_lock<std::mutex> mlock(Session.m_IrpMutex);
		Session.m_IrpQueue.push(irp);
		mlock.unlock();
	}

	//
	// Reset the event
	//
	ResetEvent(hEvent);

	return ERROR_SUCCESS;
}


/*++

Routine Description:

Fetch all the IRP stored in the IrpDumper driver, and stores it in memory.


Arguments:

	hDevice -

	hEvent -

	Session -



Return Value:

	Returns ERROR_SUCCESS on success, GetLastError() otherwise

--*/
DWORD FetchAllIrpFromDevice(_In_ HANDLE hDevice, _In_ HANDLE hEvent, _In_ Session& Session, _Out_ PDWORD lpdwNumberOfIrpDumped)
{
	DWORD dwRes = ERROR_SUCCESS;
	*lpdwNumberOfIrpDumped = 0;

	do
	{
		dwRes = FetchNextIrpFromDevice(hDevice, hEvent, Session);
		
		if (dwRes == ERROR_NO_MORE_ITEMS)
			break;

		(*lpdwNumberOfIrpDumped)++;

		if (dwRes != ERROR_SUCCESS)
			break;
	} 
	while (Session.IsRunning());

	return dwRes;
}


/*++

Routine Description:

This routine collects the IRP data from the driver.

Arguments:

	lpParameter -


Return Value:

	Returns 0 on success

--*/
DWORD IrpCollectorThreadRoutine(_In_ LPVOID lpParameter)
{
	Session& Sess = *(reinterpret_cast<Session*>(lpParameter));


	//
	// Get a handle to the device
	//
	SafeHandle hIrpDumperDevice(
		::CreateFile(
			CFB_USER_DEVICE_NAME,
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		)
	);

	if (hIrpDumperDevice==NULL || hIrpDumperDevice.Get()==INVALID_HANDLE_VALUE)
	{
		PrintErrorWithFunctionName(L"CreateFile(hDeviceObject)");
		return ERROR_DEVICE_NOT_AVAILABLE;
	}


	//
	// Create an event for the driver to notify the broker new data has arrived
	//
	SafeHandle hIrpDataEvent(
		ShareHandleWithDriver(hIrpDumperDevice.Get())
	);

	if (!hIrpDataEvent)
	{
		PrintErrorWithFunctionName(L"ShareHandleWithDriver()");
		return ERROR_INVALID_HANDLE;
	}


	const HANDLE Handles[2] = {
		Sess.m_hTerminationEvent,
		hIrpDataEvent.Get()
	};

	xlog(LOG_SUCCESS, L"[IrpCollectorThreadRoutine] listening for new IRPs from driver...\n");

	while (Sess.IsRunning())
	{
		DWORD dwWaitResult = ::WaitForMultipleObjects(_countof(Handles), Handles, FALSE, INFINITE);

		switch (dwWaitResult)
		{
		case WAIT_OBJECT_0:
			dbg(L"[IrpCollectorThreadRoutine] received termination Event\n");
			Sess.Stop();
			break;

		case WAIT_OBJECT_0 + 1:
		{
			dbg(L"new IRP data Event\n");

			DWORD dwNbIrpDumped = 0;
			DWORD dwRes = FetchAllIrpFromDevice(hIrpDumperDevice.Get(), hIrpDataEvent.Get(), Sess, &dwNbIrpDumped);
			
			dbg(L"fetched %d IRP from driver\n", dwNbIrpDumped);
			break;
		}

		default:
			PrintErrorWithFunctionName(L"WaitForMultipleObjects()");
			Sess.Stop();
			break;
		}
	}

	dbg(L"terminating thread TID=%d\n", GetThreadId(GetCurrentThread()));
	return ERROR_SUCCESS;
}


/*++

Routine Description:

Takes a request Task, and creates and send a valid DeviceIoControl() to the IrpDumper driver. The function
also builds a response Task from the response of the  DeviceIoControl().


--*/
static Task SendTaskToDriver(_In_ Task task, _In_ HANDLE hDevice)
{

	dbg(L"Sending to device Task=%d (Type: %s, Length: %d)\n", task.Id(), task.TypeAsString(), task.Length());

	byte* lpOutputBuffer = nullptr;
	DWORD dwOutputBufferSize = 0;
	DWORD dwNbBytesReturned = 0;
	DWORD dwErrCode;

	while (TRUE)
	{
		//
		// send the DeviceIoControl
		//
		BOOL bRes = ::DeviceIoControl(
			hDevice,
			task.IoctlCode(),
			task.Data(),
			task.Length(),
			lpOutputBuffer,
			dwOutputBufferSize,
			&dwNbBytesReturned,
			NULL
		);

		dwErrCode = ::GetLastError();
		dbg(L"DeviceIoControl(0x%x,%u) returned: %s (gle=0x%x,nbw=%lu)\n", task.IoctlCode(), dwOutputBufferSize, bRes ? L"TRUE" : L"FALSE", dwErrCode, dwNbBytesReturned);

		//
		// If the ioctl was ok, we exit
		//
		
		if (bRes)
		{
			dwErrCode = ERROR_SUCCESS;
			break;
		}
		
		//
		// If the buffer was too small, retry with the appropriate size
		//
		if (dwErrCode != ERROR_INSUFFICIENT_BUFFER) // STATUS_BUFFER_TOO_SMALL
			break;

		if (dwOutputBufferSize == 0)
			dwOutputBufferSize = 1024;
		else
			dwOutputBufferSize *= 2;

		dbg(L"DeviceIoControl(0x%x): resizing to output_buffer to %lu (%lu)\n", task.IoctlCode(), dwOutputBufferSize, dwNbBytesReturned);

		if (lpOutputBuffer)
			delete[] lpOutputBuffer;

		lpOutputBuffer = new byte[dwOutputBufferSize];
		::ZeroMemory(lpOutputBuffer, dwOutputBufferSize);
	}


	//
	// flag task as Completed, the task can finally be deleted
	//
	task.SetState(TaskState::Completed);

	//
	// If the IOCTL failed, free the associated output buffer as they won't be used anyway
	//
	if (dwErrCode != ERROR_SUCCESS)
	{
		delete[] lpOutputBuffer;
		lpOutputBuffer = nullptr;
		dwOutputBufferSize = 0;
	}

	//
	// Create the response task object, and specify the ioctl retcode
	//
	Task response_task(task.Type(), lpOutputBuffer, dwOutputBufferSize, dwErrCode, false);

	if (lpOutputBuffer)
		delete[] lpOutputBuffer;

	return response_task;
}


/*++

Routine Description:

Reads the new tasks received by the FrontEnd thread, and bounces thoses requests to the backend (i.e. the driver) 
via the IOCTL codes (which can be found in "Driver\Header Files\IoctlCodes.h" - imported by common.h).

The driver must acknowledge the request by sending a response (even if the result content is asynchronous).


Arguments:

	lpParameter - 


Return Value:
	
	Returns 0 on success

--*/
DWORD BackendConnectionHandlingThread(_In_ LPVOID lpParameter)
{
	Session& Sess = *(reinterpret_cast<Session*>(lpParameter));

	SafeHandle hIrpDumperDevice(
		::CreateFile(
			CFB_USER_DEVICE_NAME,
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		)
	);

	if (hIrpDumperDevice == NULL || hIrpDumperDevice.Get() == INVALID_HANDLE_VALUE)
	{
		PrintErrorWithFunctionName(L"CreateFile(hDeviceObject)");
		return ERROR_DEVICE_NOT_AVAILABLE;
	}

	const HANDLE Handles[2] = { 
		Sess.m_hTerminationEvent, 
		Sess.RequestTasks.m_hPushEvent
	};

	xlog(LOG_SUCCESS, L"[BackendConnectionHandlingThread] listening for new task events...\n");
	
	while ( Sess.IsRunning() )
	{
		//
		// Wait for a push event or a termination notification event
		//
		DWORD dwWaitResult = ::WaitForMultipleObjects(_countof(Handles), Handles, FALSE, INFINITE);

		switch (dwWaitResult)
		{
		case WAIT_OBJECT_0:
		{
			dbg(L"[BackendConnectionHandlingThread] received termination Event\n");
			Sess.Stop();
			continue;
		}

		case WAIT_OBJECT_0 + 1:
		{
			//
			// pop() from request task list. Although the pop is blocking, there should always be
			// some data available (because of the Event)
			//

			auto request_task = Sess.RequestTasks.pop();

			//
			// send the request to the driver
			//
			auto response_task = SendTaskToDriver(request_task, hIrpDumperDevice.Get());

			//
			// push to response task list
			//
			Sess.ResponseTasks.push(response_task);
			
			break;
		}

		default:
			PrintErrorWithFunctionName(L"WaitForMultipleObjects()");
			Sess.Stop();
			continue;
		}
	}

	dbg(L"terminating thread TID=%d\n", GetThreadId(GetCurrentThread()));
	return ERROR_SUCCESS;
}



/*++

Routine Description:

Start the thread responsible for the communcation between the broker and the backend (i.e.
the driver).


Arguments:

	lpThread -  a pointer to the handle of the created


Return Value:

	Returns TRUE if the thread was successfully created; FALSE in any other case

--*/
_Success_(return)
BOOL StartBackendManagerThread(_In_ PVOID lpParameter)
{
	HANDLE hThread;
	DWORD dwThreadId;
	Session& Sess = *(reinterpret_cast<Session*>(lpParameter));

	//
	// Starts the thread that communicates with the driver
	//
	hThread = ::CreateThread(
		NULL,
		0,
		BackendConnectionHandlingThread,
		lpParameter,
		CREATE_SUSPENDED,
		&dwThreadId
	);

	if (!hThread)
	{
		PrintError(L"CreateThread(Driver)");
		return FALSE;
	}

	dbg(L"CreateThread(Driver) created as TID=%d\n", dwThreadId);
	Sess.m_hBackendThread = hThread;


	//
	// Starts the thread that collects the IRP from the driver
	//
	hThread = ::CreateThread(
		NULL,
		0,
		IrpCollectorThreadRoutine,
		lpParameter,
		CREATE_SUSPENDED,
		&dwThreadId
	);

	if (!hThread)
	{
		PrintError(L"CreateThread(Irp)");
		return FALSE;
	}


	dbg(L"CreateThread(Irp) created as TID=%d\n", dwThreadId);
	Sess.m_hIrpFetcherThread = hThread;

	return TRUE;
}
```

`Broker/FrontEndServer.cpp`:

```cpp
#include "FrontEndServer.h"

#include <algorithm>
#include <iostream>
#include <locale>
#include <codecvt>
#include <optional>

#include "taskmanager.h"
#include "Session.h"
#include "task.h"
#include "Utils.h"


#include "json.hpp"
using json = nlohmann::json;





/*++
Routine Description:

Creates the FrontEndServer object.


Arguments:

	None


Return Value:
	May throw an exception if the the allocation failed.

--*/
FrontEndServer::FrontEndServer(_In_ Session& Session) noexcept(false)
	: m_Session(Session)
{
	if (!m_Transport.Initialize())
		RAISE_GENERIC_EXCEPTION("m_Transport.Initialize() failed");
}


/*++
Routine Description:

Destroys the FrontEndServer object.


Arguments:

	None


Return Value:
	May throw an exception if the the deallocation failed.

--*/
FrontEndServer::~FrontEndServer() noexcept(false)
{
	if (!m_Transport.Terminate())
		RAISE_GENERIC_EXCEPTION("m_Transport.Terminate() failed");
}



std::vector<Task> FrontEndServer::ProcessNextRequest()
{
	std::vector<Task> tasks;

	while (true)
	{
		//
		// read the bytes from the wire
		//
		auto RequestBufferRaw = m_Session.FrontEndServer.Receive();

		if (RequestBufferRaw.size() == 0)
			RAISE_EXCEPTION(InvalidRequestException, "Receive() should not be empty");

#ifdef _DEBUG
		SIZE_T dwRequestSize = RequestBufferRaw.size();
		dbg(L"new message from client (len=%lu)\n", dwRequestSize);
#endif // _DEBUG


		//
		// json messages can arrived fragmented, so we concat the data received to the data 
		// from potential previous read
		//
		std::move(RequestBufferRaw.begin(), RequestBufferRaw.end(), std::back_inserter(m_ReceivedBytes));

		// one message can contain multiple json, process for every one of them
		while (true)
		{
			if (auto json_request = GetNextJsonStringMessage())
			{
				auto t = ProcessJsonTask(*json_request);
				tasks.push_back(t);
			}
			else
			{
				break;
			}
		}

		//
		// if we've read everything, m_ReceivedBytes should be empty
		//
		if (m_ReceivedBytes.size() == 0)
			break;
	}

	dbg(L"got %d task(s)\n", tasks.size());

	return tasks;
}


/*++

Consume from m_ReceivedBytes until it receives a valid JSON message, or throws an exception if non available

--*/
std::optional<std::string> FrontEndServer::GetNextJsonStringMessage()
{
	unsigned int level = 0;
	size_t offset_current = 0;

	for (auto b : m_ReceivedBytes)
	{
		if (b == '{') level++;
		if (b == '}') level--;

		if (level == 0 && offset_current)
		{
			offset_current++;
			std::string jsonstr = std::string(m_ReceivedBytes.begin(), m_ReceivedBytes.begin() + offset_current);
			m_ReceivedBytes.erase(m_ReceivedBytes.begin(), m_ReceivedBytes.begin() + offset_current);
			return jsonstr;
		}

		offset_current++;
	}

	return {};
}



Task FrontEndServer::ProcessJsonTask(const std::string& json_request_as_string)
{
	// todo: catch json exception cleanly
	auto json_request = json::parse(json_request_as_string);
	const TaskType type = static_cast<TaskType>(json_request["header"]["type"]);
	DWORD dwDataLength = json_request["body"]["param_length"];
	auto data = json_request["body"]["param"].get<std::string>();
	auto lpData = Utils::base64_decode(data);

	assert(lpData.size() == dwDataLength);

	dbg(L"json request:\n%S\n", json_request.dump().c_str());


	//
	// build a Task object from the next message read from the pipe
	//
	Task task(type, lpData.data(), dwDataLength, -1, true);


	dbg(L"new request task (id=%d, type='%s', length=%d)\n", task.Id(), task.TypeAsString(), task.Length());

	switch (task.Type())
	{
	case TaskType::GetOsInfo:
		SendOsInfo();
		dbg(L"task %s done\n", task.TypeAsString());
		task.SetState(TaskState::Completed);
		break;

	case TaskType::GetInterceptedIrps:
		SendInterceptedIrps();
		task.SetState(TaskState::Completed);
		break;

	case TaskType::EnumerateDrivers:
		SendDriverList(); 
		task.SetState(TaskState::Completed);
		break;

	case TaskType::ReplayIrp:
		SendForgedIrp(json_request);
		task.SetState(TaskState::Completed);
		break;

	default:
		// push the task to request task list to be handled by the backend thread
		m_Session.RequestTasks.push(task);
	}

	return task;
}




DWORD FrontEndServer::SendReply(json& j)
{
	const std::string& str = j.dump();
	const std::vector<byte> raw(str.begin(), str.end());

	return m_Session.FrontEndServer.Send(raw)
		? ERROR_SUCCESS
		: ERROR_INVALID_DATA;
}



BOOL FrontEndServer::ForwardReply()
{
	//
	// pop the response task and build the json message
	//
	
	auto task = m_Session.ResponseTasks.pop();

	dbg(L"new response task (id=%d, type='%s', length=%d, gle=%d)\n", task.Id(), task.TypeAsString(), task.Length(), task.ErrCode());

	json json_response = {
		{"header", {
			{"is_success", task.ErrCode() == ERROR_SUCCESS},
			{"gle", task.ErrCode()},
		}
	} };


	//json_response["body"]["data_length"] = task.Length();

	switch (task.Type())
	{
	case TaskType::GetDriverInfo:
	{
		// data is HOOKED_DRIVER_INFO
		PHOOKED_DRIVER_INFO data = (PHOOKED_DRIVER_INFO)task.Data();
		if (task.Length() && data)
		{
			json_response["body"]["driver_info"]["driver"]["Address"] = data->DriverAddress;
			json_response["body"]["driver_info"]["driver"]["IsEnabled"] = data->Enabled;
			json_response["body"]["driver_info"]["driver"]["Name"] = Utils::WideStringToString(std::wstring(data->Name));
			json_response["body"]["driver_info"]["driver"]["NumberOfRequestIntercepted"] = data->NumberOfRequestIntercepted;
		}
		break;
	}

	case TaskType::GetNamesOfHookedDrivers:
	{
		auto driver_list_ws = std::wstring((wchar_t*)task.Data());
		auto driver_list_cs = Utils::WideStringToString(driver_list_ws);

		std::string delimiter = ";";
		size_t pos = 0;
		json_response["body"]["hooked_driver_list"]["drivers"] = json::array();
		while ((pos = driver_list_cs.find(delimiter)) != std::string::npos)
		{
			std::string drvname = driver_list_cs.substr(0, pos);
			json_response["body"]["hooked_driver_list"]["drivers"].push_back(drvname);
			driver_list_cs.erase(0, pos + delimiter.length());
		}

		break;
	}

	default:
	{
		// default = data needs no parsing, simply b64encode it
		json_response["body"]["data_length"] = task.Length();
		if (task.Length() > 0)
			json_response["body"]["data"] = Utils::base64_encode(task.Data(), task.Length());
		break;
	}
	}

	DWORD dwRes = SendReply(json_response);

	if (dwRes != ERROR_SUCCESS)
	{
		PrintErrorWithFunctionName(L"SendSynchronous(Ioctl)");
	}
	else
	{
		task.SetState(TaskState::Completed);
	}
	
	return true;
}





/*++

Routine Description:


Arguments:
	
	Session -


Return Value:

	Returns 0 on success, -1 on failure.

--*/
DWORD FrontEndServer::SendInterceptedIrps()
{
	json j = {
		{"header", {
			{"is_success", true},
			{"gle", ERROR_SUCCESS},
			{"type", TaskType::GetInterceptedIrps},
		}
	} };

	//
	// Make sure no element are being added concurrently
	//
	std::unique_lock<std::mutex> mlock(m_Session.m_IrpMutex);
	size_t i = 0;

	j["body"]["intercepted_irps"]["irps"] = json::array();

	while(!m_Session.m_IrpQueue.empty() && i < CFB_FRONTEND_MAX_ENTRIES)
	{
		//
		// pop an IRP
		//
		Irp irp(m_Session.m_IrpQueue.front());
		m_Session.m_IrpQueue.pop();

		//
		// format a new JSON entry
		//
		j["body"]["intercepted_irps"]["irps"].push_back(irp.ToJson());

		i++;
	}

	mlock.unlock();

	j["body"]["intercepted_irps"]["nb_irps"] = i;


	//
	// Write the data back
	//

	return SendReply(j);
}



/*++

Routine Description:

	Sends the list of drivers

Arguments:

	None

Return Value:

	Returns a ERROR_SUCCESS, or the corresponding WinError otherwise.

--*/
DWORD FrontEndServer::SendDriverList()
{
	json j = {
		{"header", {
			{"is_success", true},
			{"gle", ERROR_SUCCESS},
			{"type", TaskType::EnumerateDrivers}
		}
	}};

	j["body"]["driver_list"]["drivers"] = json::array();
	
	size_t nb_drivers = 0;
	std::vector<std::wstring> roots = { L"\\Driver" , L"\\FileSystem" };
	for (auto root : roots)
	{
		for (auto driver : Utils::EnumerateObjectDirectory(root))
		{
			std::wstring driver_abspath = root + std::wstring(L"\\") + driver.first;
			std::string driver_name = Utils::WideStringToString(driver_abspath);
			j["body"]["driver_list"]["drivers"].push_back(driver_name);
			nb_drivers++;
		}
	}

	j["body"]["driver_list"]["nb_drivers"] = nb_drivers;

	return SendReply(j);
}



/*++

Routine Description:

	Sends a IOCTL to the specified device, providing all the arguments from the JSON requests

Arguments:

	Task - 

Return Value:

	Returns a ERROR_SUCCESS, or the corresponding WinError otherwise.

--*/
DWORD FrontEndServer::SendForgedIrp(json& json_request)
{
	auto decoded_body = Utils::base64_decode(json_request["body"]["param"]);
	decoded_body.push_back(0);
	auto json_body = json::parse(decoded_body)["replay_irp"];

	auto DeviceName = json_body["device_name"].get<std::string>();
	auto IoctlCode = json_body["ioctl_code"];
	auto InputBufferLength = json_body["input_buffer_length"];
	auto OutputBufferLength = json_body["output_buffer_length"].get<DWORD>();
	auto InputBuffer = Utils::base64_decode(json_body["input_buffer"]);


	std::vector<byte> OutputBuffer;
	OutputBuffer.resize(OutputBufferLength);

	DWORD dwRes = Utils::Io::DeviceIoControlWrapper(
		DeviceName.c_str(),
		IoctlCode,
		InputBuffer.data(),
		InputBufferLength,
		OutputBuffer.data(),
		&OutputBufferLength
	);


	json json_response;

	json_response["header"]["is_success"] = dwRes == ERROR_SUCCESS;
	json_response["header"]["gle"] = dwRes;
	json_response["header"]["type"] = TaskType::ReplayIrp;

	json_response["body"]["replay_irp"]["output_buffer"] = OutputBuffer;
	json_response["body"]["replay_irp"]["output_buffer_length"] = OutputBufferLength;

	return SendReply(json_response);
}


DWORD FrontEndServer::SendOsInfo()
{
	//
	// OS version
	//
	OSVERSIONINFOW VersionInformation = { 0 };
	VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
	RtlGetVersion(&VersionInformation);

	DWORD dwVersionMajor, dwVersionMinor;
	dwVersionMajor = VersionInformation.dwMajorVersion;
	dwVersionMinor = VersionInformation.dwMinorVersion;

	std::wstring VersionBuild;
	Utils::Registry::ReadWString(
		HKEY_LOCAL_MACHINE,
		std::wstring(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
		std::wstring(L"CurrentBuildNumber"),
		VersionBuild
	);


	//
	// CPU info
	//
	SYSTEM_INFO si = { 0 };
	::GetNativeSystemInfo(&si);


	//
	// Process info
	//
	DWORD dwUserNameLength = MAX_USERNAME_SIZE;
	UCHAR lpBufferUserName[MAX_USERNAME_SIZE + 1] = { 0 };
	if (!::GetUserNameA((LPSTR)lpBufferUserName, &dwUserNameLength))
	{
		dwUserNameLength = sizeof("<unknown>");
		::RtlCopyMemory(lpBufferUserName, "<unknown>", dwUserNameLength);
	}

	std::string UserName(reinterpret_cast<char const*>(lpBufferUserName), dwUserNameLength-1);

	std::wstring IntegrityLevelName;
	if (Utils::Process::GetIntegrityLevel(IntegrityLevelName) != ERROR_SUCCESS)
		IntegrityLevelName = L"<unknown>";

	DWORD dwProcessId = ::GetCurrentProcessId();

	//
	// build and send response
	//
	json json_response;

	json_response["header"]["is_success"] = true;
	json_response["header"]["gle"] = ERROR_SUCCESS;
	json_response["header"]["type"] = TaskType::GetOsInfo;

	json_response["body"]["os_info"]["version_major"] = dwVersionMajor;
	json_response["body"]["os_info"]["version_minor"] = dwVersionMinor;
	json_response["body"]["os_info"]["version_build"] = Utils::WideStringToString(VersionBuild);

	json_response["body"]["os_info"]["cpu_num"] = si.dwNumberOfProcessors; 
	json_response["body"]["os_info"]["cpu_arch"] = si.wProcessorArchitecture;
	
	json_response["body"]["os_info"]["version"] = CFB_VERSION;
	json_response["body"]["os_info"]["username"] = UserName;
	json_response["body"]["os_info"]["pid"] = dwProcessId;
	json_response["body"]["os_info"]["integrity"] = Utils::WideStringToString(IntegrityLevelName);

	return SendReply(json_response);
}


/*++

Routine Description:

This routine handles the communication with the front-end of CFB (for now, the only one implemented
is the GUI).

Once a message from the frontend is received, it is parsed and pushed as an incoming Task, and notify
the BackEnd driver thread, then wait for an event from that same thread, notifying a response. Once the
response is popped from the outgoing Task list, the data is sent back to the frontend.


Arguments:

	lpParameter - the thread parameter


Return Value:

	Returns 0 the thread execution went successfully, the value from GetLastError() otherwise.

--*/
static DWORD ServerThreadRoutine(_In_ LPVOID lpParameter)
{
	Session& Sess = *(reinterpret_cast<Session*>(lpParameter));
	return Sess.FrontEndServer.RunForever();
}



/*++

Routine Description:

This function is a simple wrapper around CreateThread() to start the thread handling the conversation
with the frontend part of the application.


Arguments:

	lpParameter - a generic pointer to the global Session


Return Value:
	Returns TRUE upon successful creation of the thread, FALSE if any error occured.

--*/
_Success_(return)
BOOL FrontendThreadRoutine(_In_ LPVOID lpParameter)
{
	DWORD dwThreadId;

	HANDLE hThread = ::CreateThread(
		NULL,
		0,
		ServerThreadRoutine,
		lpParameter,
		CREATE_SUSPENDED,
		&dwThreadId
	);

	if (!hThread)
	{
		PrintErrorWithFunctionName(L"CreateThread(hThreadPipeIn)");
		return FALSE;
	}


#ifdef _DEBUG
	xlog(LOG_DEBUG, "Created frontend thread as TID=%d\n", dwThreadId);
#endif

	Session& Sess = *(reinterpret_cast<Session*>(lpParameter));
	Sess.m_hFrontendThread = hThread;

	return TRUE;
}


```

`Broker/FrontEndServer.h`:

```h
#pragma once

#include "common.h"

#include "TcpSocketTransportManager.h"
#include "PipeTransportManager.h"

class Session;
class Task;

#include <optional>
#include <string>
#include "json.hpp"
using json = nlohmann::json;

//
// Max number of JSON entries that can be served at a time
//
#define CFB_FRONTEND_MAX_ENTRIES 32


class FrontEndServer
{
public:
	FrontEndServer(_In_ Session& Session) noexcept(false);
	~FrontEndServer() noexcept(false);
	
	DWORD RunForever() { return m_Transport.RunForever(m_Session); }
	BOOL Send(_In_ const std::vector<byte>& data) { return m_Transport.SendSynchronous(data); }
	std::vector<byte> Receive() { return m_Transport.ReceiveSynchronous(); }
	std::vector<Task> ProcessNextRequest();
	BOOL ForwardReply();


private:
	//PipeTransportManager m_Transport;
	TcpSocketTransportManager m_Transport;
	Session& m_Session;
	std::vector<byte> m_ReceivedBytes;

	DWORD SendReply(json& j);
	Task ProcessJsonTask(const std::string& json_request_as_string);
	std::optional<std::string> GetNextJsonStringMessage();


	//
	// Commands handled by the FrontEndServer, and not passed to the backend driver
	//
	DWORD SendInterceptedIrps();
	DWORD SendDriverList();
	DWORD SendForgedIrp(json&);
	DWORD SendOsInfo();
};


_Success_(return) BOOL FrontendThreadRoutine(_In_ LPVOID lpParameter);
```

`Broker/Irp.cpp`:

```cpp
#include "Irp.h"


Irp::Irp(_In_ PINTERCEPTED_IRP_HEADER Header, _In_ PINTERCEPTED_IRP_BODY InputBuffer, _In_ PINTERCEPTED_IRP_BODY OutputBuffer)
{
	//dbg(L"new irp(header=%p, input=%p len=%d, output=%p len=%d)=%p\n", Header, InputBuffer, Header->InputBufferLength, OutputBuffer, Header->OutputBufferLength, this);

	PINTERCEPTED_IRP_HEADER hdr = &m_Header;
	::memcpy(hdr, Header, sizeof(INTERCEPTED_IRP_HEADER));

	for (DWORD i = 0; i < Header->InputBufferLength; i++)
		m_InputBuffer.push_back(((PBYTE)InputBuffer)[i]);

	for (DWORD i = 0; i < Header->OutputBufferLength; i++)
		m_OutputBuffer.push_back(((PBYTE)OutputBuffer)[i]);
}

Irp::Irp(const Irp& IrpOriginal) 
	:
	m_InputBuffer(IrpOriginal.m_InputBuffer),
	m_OutputBuffer(IrpOriginal.m_OutputBuffer)
{
	PINTERCEPTED_IRP_HEADER hdr = &m_Header;
	::memcpy(hdr, &IrpOriginal.m_Header, sizeof(INTERCEPTED_IRP_HEADER));
	//dbg(L"copy irp(%p -> %p)\n", &IrpOriginal, this);
}


Irp::~Irp()
{
	//dbg(L"del irp(%p)\n", this);
}


json Irp::IrpHeaderToJson()
{
	json header;
	header["TimeStamp"] = m_Header.TimeStamp.QuadPart;
	header["Irql"] = (uint32_t)m_Header.Irql;
	header["Type"] = (uint32_t)m_Header.Type;
	header["IsFastIo"] = (bool)(m_Header.Type & 0x80000000);
	header["IoctlCode"] = (uint32_t)m_Header.IoctlCode;
	header["ProcessId"] = (uint32_t)m_Header.Pid;
	header["ThreadId"] = (uint32_t)m_Header.Tid;
	header["Status"] = (uint32_t)m_Header.Status;
	header["InputBufferLength"] = m_Header.InputBufferLength;
	header["OutputBufferLength"] = m_Header.OutputBufferLength;
	header["DriverName"]  = Utils::WideStringToString(std::wstring(m_Header.DriverName));
	header["DeviceName"]  = Utils::WideStringToString(std::wstring(m_Header.DeviceName));
	header["ProcessName"] = Utils::WideStringToString(std::wstring(m_Header.ProcessName));
	return header;
}


json Irp::InputBufferToJson()
{
	//dbg(L"InputBufferToJson() -> %d\n", m_InputBuffer.size());
	json j(m_InputBuffer);
	return j;
}


json Irp::OutputBufferToJson()
{
	//dbg(L"OutputBufferToJson() -> %d\n", m_OutputBuffer.size());
	json j(m_OutputBuffer);
	return j;
}


json Irp::ToJson()
{
	json irp;
	irp["header"] = IrpHeaderToJson();
	irp["body"]["InputBuffer"] = InputBufferToJson();
	irp["body"]["OutputBuffer"] = OutputBufferToJson();
	return irp;
}


```

`Broker/Irp.h`:

```h
#pragma once

#include "common.h"
#include <string>
#include <sstream>

#include "json.hpp"
using json = nlohmann::json;

#include "Utils.h"


class Irp
{
public:
	Irp(_In_ PINTERCEPTED_IRP_HEADER Header, _In_ PINTERCEPTED_IRP_BODY InputBuffer, _In_ PINTERCEPTED_IRP_BODY OutputBuffer);
	Irp(const Irp& Original);
	~Irp();
	
	json IrpHeaderToJson();
	json InputBufferToJson();
	json OutputBufferToJson();
	json ToJson();


private:
	INTERCEPTED_IRP_HEADER m_Header = { 0, };
	std::vector<byte> m_InputBuffer;
	std::vector<byte> m_OutputBuffer;
};


```

`Broker/PipeTransportManager.cpp`:

```cpp
#include "PipeTransportManager.h"
#include "Session.h"

#include <aclapi.h>
#include <psapi.h>

#include "json.hpp"
using json = nlohmann::json;


/*++
Routine Description:

Create the named pipe responsible for the communication with the GUI. To do, a Security
Descriptor is created with Explicit Access set for Everyone (including remote clients),
to Read/Write the pipe.

Therefore, we must be careful about that as any user would be able to send some commands
to the broker pipe (and therefore to the kernel driver).


Arguments:

	None


Return Value:
	Returns TRUE upon successful creation of the pipe, FALSE if any error occured.

--*/
BOOL PipeTransportManager::CreatePipe()
{
	BOOL fSuccess = FALSE;
	SID_IDENTIFIER_AUTHORITY SidAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
	EXPLICIT_ACCESS ea[1] = { 0 };
	PACL pNewAcl = NULL;
	PSID pEveryoneSid = NULL;
	SECURITY_ATTRIBUTES SecurityAttributes = { 0 };
	SECURITY_DESCRIPTOR SecurityDescriptor = { 0 };

	do
	{
		dbg(L"Defining new SD for pipe\n");

		//
		// For now, SD is set for Everyone to have RW access 
		//

		if (!::AllocateAndInitializeSid(
			&SidAuthWorld,
			1,
			SECURITY_WORLD_RID,
			0, 0, 0, 0, 0, 0, 0,
			&pEveryoneSid
		)
			)
		{
			PrintErrorWithFunctionName(L"AllocateAndInitializeSid");
			fSuccess = FALSE;
			break;
		}


		//
		// Populate the EA entry
		//
		ea[0].grfAccessPermissions = GENERIC_ALL;
		ea[0].grfAccessMode = SET_ACCESS;
		ea[0].grfInheritance = NO_INHERITANCE;
		ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
		ea[0].Trustee.ptstrName = (LPTSTR)pEveryoneSid;


		//
		// Apply the EA to the ACL
		//
		if (::SetEntriesInAcl(1, ea, NULL, &pNewAcl) != ERROR_SUCCESS)
		{
			PrintErrorWithFunctionName(L"SetEntriesInAcl");
			fSuccess = FALSE;
			break;
		}


		//
		// Set the SD to new ACL
		//
		if (!::InitializeSecurityDescriptor(&SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION))
		{
			PrintErrorWithFunctionName(L"InitializeSecurityDescriptor");
			fSuccess = FALSE;
			break;
		}

		if (!::SetSecurityDescriptorDacl(&SecurityDescriptor, TRUE, pNewAcl, FALSE))
		{
			PrintErrorWithFunctionName(L"SetSecurityDescriptorDacl");
			fSuccess = FALSE;
			break;
		}


		//
		// Init the SA
		//
		SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
		SecurityAttributes.lpSecurityDescriptor = &SecurityDescriptor;
		SecurityAttributes.bInheritHandle = FALSE;


#ifdef _DEBUG
		xlog(LOG_DEBUG, L"Creating named pipe '%s'...\n", CFB_PIPE_NAME);
#endif

		//
		// create the overlapped pipe
		//
		HANDLE hServer = ::CreateNamedPipe(
			CFB_PIPE_NAME,
			PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
			PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_ACCEPT_REMOTE_CLIENTS | PIPE_WAIT,
			CFB_PIPE_MAXCLIENTS,
			CFB_PIPE_INBUFLEN,
			CFB_PIPE_OUTBUFLEN,
			0,
			&SecurityAttributes
		);

		if (hServer == INVALID_HANDLE_VALUE)
		{
			PrintErrorWithFunctionName(L"CreateNamedPipe()");
			fSuccess = FALSE;
			break;
		}

		m_hServer = hServer;

		m_oOverlap.hEvent = ::CreateEvent(nullptr, FALSE, TRUE, nullptr);
		if (!m_oOverlap.hEvent)
		{
			xlog(LOG_CRITICAL, L"failed to create an event object for frontend thread\n");
			return false;
		}


		//
		// last, connect to the named pipe
		//
		fSuccess = ConnectPipe();
	} while (false);

	if (pEveryoneSid)
		FreeSid(pEveryoneSid);

	if (pNewAcl)
		LocalFree(pNewAcl);


	return fSuccess;
}





/*++

Routine Description:

Flush all the data and close the pipe.


Arguments:

	None


Return Value:
	Returns TRUE upon successful termination of the pipe, FALSE if any error occured.

--*/
BOOL PipeTransportManager::ClosePipe()
{
	dbg(L"Closing NamedPipe '%s'...\n", CFB_PIPE_NAME);


	BOOL fSuccess = TRUE;

	do
	{
		if (m_hServer == INVALID_HANDLE_VALUE)
		{
			//
			// already closed
			//
			break;
		}

		if (m_dwServerState != ServerState::Disconnected)
		{
			//
			// Wait until all data was consumed
			//
			if (!::FlushFileBuffers(m_hServer))
			{
				PrintErrorWithFunctionName(L"FlushFileBuffers()");
				fSuccess = FALSE;
			}

			//
			// Then close down the named pipe
			//
			if (!::DisconnectNamedPipe(m_hServer))
			{
				PrintErrorWithFunctionName(L"DisconnectNamedPipe()");
				fSuccess = FALSE;
			}
		}

		fSuccess = ::CloseHandle(m_hServer);
		m_hServer = INVALID_HANDLE_VALUE;
	} while (false);

	return fSuccess;
}


/*++

Routine Description:


Arguments:


Return Value:

--*/
BOOL PipeTransportManager::DisconnectAndReconnect()
{
	if (!DisconnectNamedPipe(m_hServer))
	{
		PrintErrorWithFunctionName(L"DisconnectNamedPipe");
		return false;
	}

	if (!ConnectPipe())
	{
		xlog(LOG_ERROR, L"error in ConnectPipe()\n");
		return false;
	}

	return true;
}


/*++

Routine Description:


Arguments:


Return Value:

	Returns TRUE on success, FALSE otherwise
--*/
BOOL PipeTransportManager::ConnectPipe()
{
	dbg(L"Connecting NamedPipe '%s'...\n", CFB_PIPE_NAME);

	BOOL fSuccess = ::ConnectNamedPipe(m_hServer, &m_oOverlap);
	if (fSuccess)
	{
		PrintErrorWithFunctionName(L"ConnectNamedPipe");
		::DisconnectNamedPipe(m_hServer);
		return FALSE;
	}

	DWORD gle = ::GetLastError();

	switch (gle)
	{
	case ERROR_IO_PENDING:
		m_fPendingIo = TRUE;
		m_dwServerState = ServerState::Connecting;
		break;

	case ERROR_PIPE_CONNECTED:
		m_dwServerState = ServerState::ReadyToReadFromClient;
		::SetEvent(m_oOverlap.hEvent);
		break;

	default:
		m_dwServerState = ServerState::Disconnected;
		xlog(LOG_ERROR, L"ConnectNamedPipe failed with %d.\n", gle);
		fSuccess = false;
		break;
	}

	return TRUE;
}


/*++

Synchronous send for named pipe

--*/
BOOL PipeTransportManager::SendSynchronous(_In_ const std::vector<byte>& data)
{
	if (data.size() >= MAX_ACCEPTABLE_MESSAGE_SIZE)
		return false;

	DWORD dwDataLength = (DWORD)data.size(), dwNbByteWritten;
	BOOL fSuccess = ::WriteFile(m_hServer, data.data(), dwDataLength, &dwNbByteWritten, NULL);
	if (!fSuccess || dwDataLength != dwNbByteWritten)
		return false;

	return true;
}


/*++

Synchronous receive for named pipe

--*/
std::vector<byte> PipeTransportManager::ReceiveSynchronous()
{
	auto buf = std::make_unique<byte[]>(MAX_MESSAGE_SIZE);
	RtlZeroMemory(buf.get(), MAX_MESSAGE_SIZE);

	DWORD dwRequestSize;
	BOOL fSuccess = ::ReadFile(m_hServer, buf.get(), MAX_ACCEPTABLE_MESSAGE_SIZE, &dwRequestSize, NULL);
	if (!fSuccess)
		RAISE_GENERIC_EXCEPTION("ReceiveSynchronous");

	std::vector<byte> res;
	for (DWORD i = 0; i < dwRequestSize; i++) res.push_back(buf[i]);
	return res;
}


/*++

Routine Description:

	The MainLoop function for the NamedPipe connector.

Arguments:

	Sess - the current session


Return Value:

	Returns 0 the thread execution went successfully, the value from GetLastError() otherwise.

--*/
DWORD PipeTransportManager::RunForever(_In_ Session& Sess)
{
	DWORD dwIndexObject, cbRet;
	DWORD retcode = ERROR_SUCCESS;
	HANDLE hResEvent = Sess.ResponseTasks.m_hPushEvent;
	BOOL fSuccess;

	const HANDLE Handles[4] = {
		Sess.m_hTerminationEvent,
		m_oOverlap.hEvent,
		hResEvent,
		m_hServer
	};


	while (Sess.IsRunning())
	{
		//
		// Wait for the pipe to be written to, or a termination notification event
		//

		dwIndexObject = ::WaitForMultipleObjects(_countof(Handles), Handles, FALSE, INFINITE) - WAIT_OBJECT_0;

		if (dwIndexObject < 0 || dwIndexObject >= _countof(Handles))
		{
			PrintErrorWithFunctionName(L"WaitForMultipleObjects()");
			xlog(LOG_CRITICAL, L"WaitForMultipleObjects(FrontEnd) has failed, cannot proceed...\n");
			Sess.Stop();
			continue;
		}


		//
		// if we received a termination event, stop everything
		//
		if (dwIndexObject == 0)
		{
#ifdef _DEBUG
			xlog(LOG_DEBUG, L"received termination Event\n");
#endif // _DEBUG
			Sess.Stop();
			continue;
		}


		//
		// otherwise, start by checking for pending IOs and update the state if needed
		//

		if (m_dwServerState == ServerState::Connecting)
		{
			LPOVERLAPPED ov = &m_oOverlap;
			fSuccess = ::GetOverlappedResult(m_hServer, ov, &cbRet, FALSE);

			if (!fSuccess)
			{
				//
				// assume the connection has closed
				//
				DisconnectAndReconnect();
				continue;
			}

			dbg(L"new pipe connection\n");
			m_dwServerState = ServerState::ReadyToReadFromClient;
		}


		//
		// process the state itself
		//
		if (m_dwServerState == ServerState::ReadyToReadFromClient)
		{
			try
			{
				for (auto task : Sess.FrontEndServer.ProcessNextRequest())
				{
					switch (task.Type())
					{
					case TaskType::GetInterceptedIrps:	continue;
					case TaskType::EnumerateDrivers:	continue;
					case TaskType::ReplayIrp:			continue;
					}
				}
			}
			catch (BrokenPipeException&)
			{
				xlog(LOG_WARNING, L"Broken pipe detected...\n");
				DisconnectAndReconnect();
				continue;
			}
			catch (BaseException & e)
			{
				xlog(LOG_ERROR, L"An exception occured while processing incoming message:\n%S\n", e.what());
				DisconnectAndReconnect();
				continue;
			}
		}
		else if (m_dwServerState == ServerState::ReadyToReadFromServer)
		{
			try
			{
				if (!Sess.FrontEndServer.ForwardReply())
					RAISE_GENERIC_EXCEPTION("ForwardReply");

				// change the state
				m_dwServerState = ServerState::ReadyToReadFromClient;
			}
			catch (BrokenPipeException&)
			{
				xlog(LOG_WARNING, L"Broken pipe detected...\n");
				DisconnectAndReconnect();
				continue;
			}
			catch (BaseException & e)
			{
				xlog(LOG_ERROR, L"An exception occured while processing incoming message:\n%S\n", e.what());
				continue;
			}
		}
		else
		{
			xlog(LOG_WARNING, L"Unexpected state (state=%d, fd=%d), invalid?\n", m_dwServerState, dwIndexObject);
			DisconnectAndReconnect();
		}
	}

	dbg(L"terminating thread TID=%d\n", ::GetThreadId(::GetCurrentThread()));
	return ERROR_SUCCESS;
}
```

`Broker/PipeTransportManager.h`:

```h
#pragma once


#include "common.h"
#include "ServerTransportManager.h"


class Session;


/*++

Communication via remote named pipe.

--*/
class PipeTransportManager : public ServerTransportManager
{
public:
	BOOL Initialize() { return CreatePipe(); }
	BOOL Terminate() { return ClosePipe(); }
	BOOL Connect() { return ConnectPipe(); }
	BOOL Reconnect() { return DisconnectAndReconnect(); }
	DWORD RunForever(_In_ Session& CurrentSession);
	BOOL SendSynchronous(_In_ const std::vector<byte>& data);
	std::vector<byte> ReceiveSynchronous();

private:
	HANDLE m_hServer;
	OVERLAPPED m_oOverlap;
	bool m_fPendingIo = false;

	BOOL CreatePipe();
	BOOL ClosePipe();
	BOOL ConnectPipe();
	BOOL DisconnectAndReconnect();
};

```

`Broker/SafeHandle.cpp`:

```cpp
#include "SafeHandle.h"

```

`Broker/SafeHandle.h`:

```h
#pragma once

#include "common.h"


template <class T>
class GenericHandle
{
public:
	GenericHandle(T h = nullptr) :_h(h) {}

	~GenericHandle()
	{
		Close();
	}

	GenericHandle(const GenericHandle&) = delete;

	GenericHandle& operator=(const GenericHandle&) = delete;

	GenericHandle(GenericHandle&& other) noexcept : _h(other._h)
	{
		other._h = nullptr;
	}

	GenericHandle& operator=(GenericHandle&& other) noexcept
	{
		if (this != &other)
		{
			Close();
			_h = other._h;
			other._h = nullptr;
		}
		return*this;
	}

	operator bool() const
	{
		return _h != nullptr && _h != INVALID_HANDLE_VALUE;
	}

	T Get() const
	{
		return _h;
	}

	virtual void Close()
	{
		if (bool(_h))
		{
			::CloseHandle(_h);
			_h = nullptr;
		}
	}

protected:
	T _h;
};


/**
 * Default handle class
 */
class SafeHandle : public GenericHandle<HANDLE>
{
public:
	using GenericHandle<HANDLE>::GenericHandle;
};


```

`Broker/ServerTransportManager.h`:

```h
#pragma once

#include "common.h"

#include <vector>

#define MAX_ACCEPTABLE_MESSAGE_SIZE 65534
#define MAX_MESSAGE_SIZE (MAX_ACCEPTABLE_MESSAGE_SIZE+2)


class Session;


enum class ServerState
{
	Disconnected,
	Connecting,
	ReadyToReadFromClient,
	ReadyToReadFromServer
};


/*++

Base class for the transport abstraction layer: all transport medium must inherit this class.
Sub-classes *must* have an IFS compatible connection handle to support ReadFile() and WriteFile()

--*/
class ServerTransportManager
{
protected:
	ServerState m_dwServerState = ServerState::Disconnected;

public:
	virtual BOOL Initialize() = 0;
	virtual BOOL Terminate() = 0;
	virtual BOOL Connect() = 0;
	virtual BOOL Reconnect() = 0;
	virtual DWORD RunForever(_In_ Session& CurrentSession) = 0;
	virtual BOOL SendSynchronous(_In_ const std::vector<byte>& data) = 0;
	virtual std::vector<byte> ReceiveSynchronous() = 0;
};
```

`Broker/ServiceManager.cpp`:

```cpp
#include "main.h"

extern Session* Sess;


/*++

Class Description:

This class manages the IrpDumper driver stored in the PE resource section, and 
defines all the functions to properly:

- extract the driver to disk
- create / delete the service
- load / unload the driver
- delete the PE file from disk


CFB can also be installed as a process service to facilitate automation, using sc.exe:
	sc.exe create CFB_Broker binPath= "\path\to\Broker.exe --service" DisplayName= "Furious Beaver process service"
	
Then can be manipulated with the usual `sc start/stop`, and uninstalled with `sc delete`
--*/




/*++

Routine Description:

Creates the service manager object.


Arguments:

	None


Return Value:
	Nothing, throw an exception on any error

--*/
ServiceManager::ServiceManager()
{
	if (!ExtractDriverFromResource())
		RAISE_GENERIC_EXCEPTION("ExtractDriverFromResource() failed");

	bIsDriverExtracted = TRUE;

	if (!LoadDriver())
		RAISE_GENERIC_EXCEPTION("LoadDriver() failed");

	bIsDriverLoaded = TRUE;
}



/*++

Routine Description:

Destroy the service manager object.


Arguments:

	None


Return Value:
	Nothing, throw an exception on any error
	
--*/
ServiceManager::~ServiceManager() noexcept(false)
{
	if (bIsDriverLoaded)
	{
		if (!UnloadDriver())
			RAISE_GENERIC_EXCEPTION("UnloadDriver() failed");
	}

	if (bIsDriverExtracted)
	{
		if (!DeleteDriverFromDisk())
			RAISE_GENERIC_EXCEPTION("DeleteDriverFromDisk() failed");
	}
}


/*++

Routine Description:

Extracts the driver from the resources, and dump it to the location defined by
`CFB_DRIVER_LOCATION_DIRECTORY` in drivers.h


Arguments:

	None


Return Value:
	Returns TRUE upon successful extraction of the driver from the resource of the PE
	file, FALSE if any error occured.

--*/
BOOL ServiceManager::ExtractDriverFromResource()
{
	BOOL retcode = TRUE;

#ifdef _DEBUG
	xlog(LOG_DEBUG, L"Extracting driver from resources\n");
#endif

	HRSRC DriverRsc = FindResource(NULL, MAKEINTRESOURCE(IDR_CFB_DRIVER1), L"CFB_DRIVER");
	if (!DriverRsc)
	{
		PrintErrorWithFunctionName(L"FindResource()");
		return FALSE;
	}

	DWORD dwDriverSize = SizeofResource(NULL, DriverRsc);
	if (!dwDriverSize)
	{
		PrintErrorWithFunctionName(L"SizeofResource()");
		return FALSE;
	}

	HGLOBAL hgDriverRsc = LoadResource(NULL, DriverRsc);
	if (!hgDriverRsc)
	{
		PrintErrorWithFunctionName(L"LoadResource()");
		return FALSE;
	}


#ifdef _DEBUG
	xlog(LOG_DEBUG, L"Writing driver to '%s'\n", CFB_DRIVER_LOCATION_DIRECTORY);
#endif

	WCHAR lpszFilePath[MAX_PATH] = { 0, };
	GetDriverOnDiskFullPath(lpszFilePath);

	HANDLE hDriverFile = CreateFile(lpszFilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hDriverFile == INVALID_HANDLE_VALUE)
	{
		PrintErrorWithFunctionName(L"CreateFile()");
		return FALSE;
	}

	DWORD dwWritten;
	if (!::WriteFile(hDriverFile, hgDriverRsc, dwDriverSize, &dwWritten, NULL))
	{
		PrintErrorWithFunctionName(L"WriteFile()");
		retcode = FALSE;
	}

	::CloseHandle(hDriverFile);
	return retcode;
}


/*++

Routine Description:

Delete the driver extracted from the PE resources from the disk.


Arguments:

	None


Return Value:

	Returns TRUE upon successful deletion of the driver from the disk.

--*/
BOOL ServiceManager::DeleteDriverFromDisk()
{
	WCHAR lpszFilePath[MAX_PATH] = { 0, };
	GetDriverOnDiskFullPath(lpszFilePath);
	return DeleteFile(lpszFilePath);
}



/*++

Routine Description:

Creates and starts a service for the IrpDumper driver.


Arguments:

	None


Return Value:

	Returns TRUE if the service was successfully created, and the driver loaded;
	FALSE in any other case

--*/
BOOL ServiceManager::LoadDriver()
{
#ifdef _DEBUG
	xlog(LOG_DEBUG, L"Loading '%s'\n", CFB_DRIVER_NAME);
#endif

	hSCManager = ServiceManagerHandle( 
		::OpenSCManager(L"", SERVICES_ACTIVE_DATABASE, SC_MANAGER_CREATE_SERVICE)
	);

	if (!hSCManager)
	{
		PrintErrorWithFunctionName(L"OpenSCManager()");
		return FALSE;
	}

	WCHAR lpPath[MAX_PATH] = { 0, };
	GetDriverOnDiskFullPath(lpPath);

#ifdef _DEBUG
	xlog(LOG_DEBUG, L"Creating the service '%s' for kernel driver '%s'\n", CFB_SERVICE_NAME, lpPath);
#endif 
	
	hService = ServiceManagerHandle(
		::CreateService(
			hSCManager.Get(),
			CFB_SERVICE_NAME,
			CFB_SERVICE_DESCRIPTION,
			SERVICE_START | DELETE | SERVICE_STOP,
			SERVICE_KERNEL_DRIVER,
			SERVICE_DEMAND_START,
			SERVICE_ERROR_IGNORE,
			lpPath,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL
		)
	);

	//
	// if the service was already registered, just open it
	//
	if (!hService)
	{
		if (::GetLastError() != ERROR_SERVICE_EXISTS)
		{
			PrintErrorWithFunctionName(L"CreateService()");
			return FALSE;
		}

		hService = ServiceManagerHandle(
			::OpenService(hSCManager.Get(), CFB_SERVICE_NAME, SERVICE_START | DELETE | SERVICE_STOP)
		);
		if (!hSCManager)
		{
			PrintErrorWithFunctionName(L"OpenService()");
			return FALSE;
		}
	}

	//
	// start the service
	//
#ifdef _DEBUG
	xlog(LOG_DEBUG, L"Starting service '%s'\n", CFB_SERVICE_NAME);
#endif 

	if (!::StartService(hService.Get(), 0, NULL))
	{
		PrintErrorWithFunctionName(L"StartService()");
		return FALSE;
	}

	return TRUE;
}


/*++

Routine Description:

Unloads the driver.


Arguments:

	None


Return Value:

	Returns TRUE if the driver was successfully unloaded; FALSE in any other case

--*/
BOOL ServiceManager::UnloadDriver()
{
	SERVICE_STATUS DriverServiceStatus;

#ifdef _DEBUG
	xlog(LOG_DEBUG, L"Stopping service '%s'\n", CFB_SERVICE_NAME);
#endif
	if (!::ControlService(hService.Get(), SERVICE_CONTROL_STOP, &DriverServiceStatus))
	{
		PrintErrorWithFunctionName(L"ControlService");
		return FALSE;
	}

#ifdef _DEBUG
	xlog(LOG_DEBUG, L"Service '%s' stopped\n", CFB_SERVICE_NAME);
#endif
	if (!::DeleteService(hService.Get()))
	{
		PrintErrorWithFunctionName(L"DeleteService");
		return FALSE;
	}


	//::CloseServiceHandle(hService);
	//::CloseServiceHandle(hSCManager);

	return TRUE;
}



static VOID ServiceCtrlHandler(DWORD dwCtrlCode)
{
	ServiceManager& ServiceManager = Sess->ServiceManager;

	switch (dwCtrlCode)
	{
	case SERVICE_CONTROL_CONTINUE:
	case SERVICE_CONTROL_INTERROGATE:
	case SERVICE_CONTROL_PAUSE:
	case SERVICE_CONTROL_SHUTDOWN:
		xlog(LOG_ERROR, L"Unhandled control code: 0x%x\n", dwCtrlCode);
		break;

	case SERVICE_CONTROL_STOP:

		if (ServiceManager.m_ServiceStatus.dwCurrentState != SERVICE_RUNNING)
			break;

		ServiceManager.m_ServiceStatus.dwControlsAccepted = 0;
		ServiceManager.m_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
		ServiceManager.m_ServiceStatus.dwWin32ExitCode = 0;
		ServiceManager.m_ServiceStatus.dwCheckPoint = 4;

		if (::SetServiceStatus(ServiceManager.m_StatusHandle, &ServiceManager.m_ServiceStatus) == FALSE)
		{
			xlog(LOG_DEBUG, L"SetServiceStatus() failed");
			break;
		}
	
		::SetEvent(ServiceManager.m_ServiceStopEvent);
		Sess->Stop();
		break;

	default:
		break;
	}

	return;
}


/*++

Routine Description:

Static routine to initialize the own process service. 


Arguments:

	argc - 

	argv - 


Return Value:

	None

--*/
static VOID ServiceMain(DWORD argc, LPWSTR* argv)
{
	ServiceManager& ServiceManager = Sess->ServiceManager;

	do
	{

		ServiceManager.m_StatusHandle = ::RegisterServiceCtrlHandler(WIN32_SERVICE_NAME, ServiceCtrlHandler);
		if (!ServiceManager.m_StatusHandle)
		{
			xlog(LOG_ERROR, L"RegisterServiceCtrlHandler() failed\n");
			break;
		}

		::ZeroMemory(&ServiceManager.m_ServiceStatus, sizeof(ServiceManager.m_ServiceStatus));
		ServiceManager.m_ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
		ServiceManager.m_ServiceStatus.dwControlsAccepted = 0;
		ServiceManager.m_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
		ServiceManager.m_ServiceStatus.dwWin32ExitCode = 0;
		ServiceManager.m_ServiceStatus.dwServiceSpecificExitCode = 0;
		ServiceManager.m_ServiceStatus.dwCheckPoint = 0;

		if (::SetServiceStatus(ServiceManager.m_StatusHandle, &ServiceManager.m_ServiceStatus) == FALSE)
		{
			xlog(LOG_ERROR, L"SetServiceStatus() failed\n");
			break;
		}


		ServiceManager.m_ServiceStopEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
		if (ServiceManager.m_ServiceStopEvent == NULL)
		{
			ServiceManager.m_ServiceStatus.dwControlsAccepted = 0;
			ServiceManager.m_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
			ServiceManager.m_ServiceStatus.dwWin32ExitCode = ::GetLastError();
			ServiceManager.m_ServiceStatus.dwCheckPoint = 1;

			if (::SetServiceStatus(ServiceManager.m_StatusHandle, &ServiceManager.m_ServiceStatus) == FALSE)
			{
				xlog(LOG_ERROR, L"SetServiceStatus() failed\n");
			}
			break;
		}


		ServiceManager.m_ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
		ServiceManager.m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
		ServiceManager.m_ServiceStatus.dwWin32ExitCode = 0;
		ServiceManager.m_ServiceStatus.dwCheckPoint = 0;

		if (::SetServiceStatus(ServiceManager.m_StatusHandle, &ServiceManager.m_ServiceStatus) == FALSE)
		{
			xlog(LOG_ERROR, L"SetServiceStatus() failed\n");
			break;
		}

		dbg(L"CFB background service ready, starting thread...\n");


		//
		// Let's start CFB in background
		//

		HANDLE hThread = ::CreateThread(NULL, 0, RunForever, &ServiceManager.m_ServiceStopEvent, 0, NULL);
		if (!hThread)
		{
			xlog(LOG_ERROR, L"Failed to start the RunForever() thread\n");
			break;
		}

		::WaitForSingleObject(hThread, INFINITE);
		
		::CloseHandle(ServiceManager.m_ServiceStopEvent);

		//
		// Propagate the stop info to the service controller
		//
		ServiceManager.m_ServiceStatus.dwControlsAccepted = 0;
		ServiceManager.m_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
		ServiceManager.m_ServiceStatus.dwWin32ExitCode = 0;
		ServiceManager.m_ServiceStatus.dwCheckPoint = 3;

		if (::SetServiceStatus(ServiceManager.m_StatusHandle, &ServiceManager.m_ServiceStatus) == FALSE)
		{
			xlog(LOG_ERROR, L"SetServiceStatus() failed\n");
		}


		//
		// Delete the session (i.e. stop the process service and unload the driver)
		//
		delete Sess;

	} 
	while (0);


	return;
}


/*++

Routine Description:

Static routine to register the own process service.


Arguments:

	None


Return Value:

	None

--*/
BOOL ServiceManager::RegisterService()
{
	auto lpswServiceName = (LPWSTR)WIN32_SERVICE_NAME;

	SERVICE_TABLE_ENTRY ServiceTable[] =
	{
		{lpswServiceName, (LPSERVICE_MAIN_FUNCTION)ServiceMain},
		{NULL, NULL}
	};

	return ::StartServiceCtrlDispatcher(ServiceTable);
}
```

`Broker/ServiceManager.h`:

```h
#include "common.h"

#include "resource.h"
#include "CfbException.h"
#include "SafeHandle.h"


#define CFB_DRIVER_LOCATION_DIRECTORY L"C:\\Windows\\System32\\Drivers"
#define WIN32_SERVICE_NAME L"CFB_Broker"

#define GetDriverOnDiskFullPath(x){\
 	wcscat_s(x, MAX_PATH, CFB_DRIVER_LOCATION_DIRECTORY);\
	wcscat_s(x, MAX_PATH, L"\\");\
	wcscat_s(x, MAX_PATH, CFB_DRIVER_NAME);\
 }


class ServiceManagerHandle : public GenericHandle<SC_HANDLE>
{
public:
	using GenericHandle<SC_HANDLE>::GenericHandle;

	void Close() override
	{
		if (bool(_h))
		{
			::CloseServiceHandle(_h);
			_h = nullptr;
		}
	}
};


class ServiceManager 
{
public:
	ServiceManager() noexcept(false);
	~ServiceManager() noexcept(false);
	
	BOOL RegisterService();
	

	SERVICE_STATUS m_ServiceStatus = { 0 };
	SERVICE_STATUS_HANDLE m_StatusHandle = nullptr;
	HANDLE m_ServiceStopEvent = INVALID_HANDLE_VALUE;
	BOOL bRunInBackground = FALSE;


private:
	BOOL ExtractDriverFromResource();
	BOOL LoadDriver();

	BOOL UnloadDriver();
	BOOL DeleteDriverFromDisk();


	ServiceManagerHandle hService = nullptr;
	ServiceManagerHandle hSCManager = nullptr;

	BOOL bIsDriverLoaded = FALSE;
	BOOL bIsDriverExtracted = FALSE;

};



```

`Broker/Session.cpp`:

```cpp
#include "Session.h"


Session::Session()
	: FrontEndServer(*this)
{
	//
	// Initial state has to be idle
	//
	m_State = SessionState::Idle;


	//
	// Create the main event to stop the running threads
	//
	m_hTerminationEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);

	if(!m_hTerminationEvent)
		RAISE_GENERIC_EXCEPTION("CreateEvent(hTerminationEvent) failed");


	//
	// Defining some attributes
	//
	RequestTasks.SetName(L"RequestTaskManager");
	ResponseTasks.SetName(L"ResponseTaskManager");
}


Session::~Session()
{
	m_State = SessionState::Idle;
	::ResetEvent(m_hTerminationEvent);

	::CloseHandle(m_hTerminationEvent);

	if (m_hFrontendThread != INVALID_HANDLE_VALUE)
		::CloseHandle(m_hFrontendThread);

	if (m_hBackendThread != INVALID_HANDLE_VALUE)
		::CloseHandle(m_hBackendThread);
}


void Session::Start()
{
	m_State = SessionState::Running;
}


void Session::Stop()
{
	m_State = SessionState::Idle;
	::ResetEvent(m_hTerminationEvent);
	::SetEvent(m_hTerminationEvent);
}


BOOL Session::IsRunning()
{
	return m_State == SessionState::Running;
}
```

`Broker/Session.h`:

```h
#pragma once

#include "common.h"

#include <queue>

#include "TaskManager.h"
#include "ServiceManager.h"
#include "FrontEndServer.h"
#include "Irp.h"



enum class SessionState
{
	Idle,
	Running
};


class Session
{
public:
	Session();
	~Session();


	void Start();
	void Stop();
	BOOL IsRunning();


	//
	// The ServiceManager is responsible for managing the IrpDumper driver
	//
	ServiceManager ServiceManager;

	//
	// The FrontEndServer handles the communication with the frontend
	//
	FrontEndServer FrontEndServer;

	//
	// Those 2 task managers are used for dispatching requests from/to the frontend
	//
	TaskManager RequestTasks;
	TaskManager ResponseTasks;
	

	//
	// The termination Event: if set, everything must stop
	//
	HANDLE m_hTerminationEvent = INVALID_HANDLE_VALUE;


	//
	// Handle between frontend (GUI, TUI) and the broker
	// For now this is done with NamedPipes
	//
	HANDLE m_hFrontendThread = INVALID_HANDLE_VALUE;


	//
	// Handle between the broker and the IrpDumper driver
	// 
	HANDLE m_hBackendThread = INVALID_HANDLE_VALUE;

	//
	// Handle to the thread fetching the IRPs from the driver
	//
	HANDLE m_hIrpFetcherThread = INVALID_HANDLE_VALUE;

	//
	// This queue receives all the IRP intercepted by driver.
	//
	std::queue<Irp> m_IrpQueue;
	std::mutex m_IrpMutex;

private:
	//
	// The global state of the current session
	//
	SessionState m_State = SessionState::Idle;
};



```

`Broker/Task.cpp`:

```cpp
#include "Task.h"

#define ToString(x) case x: return L# x

static DWORD g_id = 0;
static std::mutex g_mutex;



Task::Task(const Task &t)
	:
	m_Type(t.m_Type),
	m_State(t.m_State),
	m_dwDataLength(t.m_dwDataLength),
	m_dwId(t.m_dwId),
	m_bIsRequest(t.m_bIsRequest),
	m_dwErrCode(t.m_dwErrCode)
{
	m_Data = new byte[t.m_dwDataLength];
	::memcpy(m_Data, t.m_Data, t.m_dwDataLength);
}


Task::Task(TaskType type, const byte* data, uint32_t datalen, uint32_t errcode, bool IsRequest)
	:
	m_Type(type), 
	m_State(TaskState::Initialized), 
	m_dwDataLength(datalen),
	m_bIsRequest(IsRequest),
	m_dwErrCode(errcode)
{
	m_Data = new byte[datalen];
	::memcpy(m_Data, data, datalen);

	std::lock_guard<std::mutex> guard(g_mutex);
	m_dwId = g_id++;
}


Task::~Task()
{
	//
	// the buffer associated with the Task can only be freeed when the 
	// task is completed.
	//
	if (m_State == TaskState::Completed)
	{
		delete[] m_Data;
	}
}


const wchar_t* Task::StateAsString()
{
	switch (m_State)
	{
		ToString(TaskState::Initialized);
		ToString(TaskState::Queued);
		ToString(TaskState::Delivered);
		ToString(TaskState::Completed);
	}

	throw std::runtime_error("Unknown Task State");
}


const wchar_t* Task::TypeAsString()
{
	switch (m_Type)
	{
		ToString(TaskType::GetOsInfo);
		ToString(TaskType::HookDriver);
		ToString(TaskType::UnhookDriver);
		ToString(TaskType::GetDriverInfo);
		ToString(TaskType::GetNumberOfDriver);
		ToString(TaskType::NotifyEventHandle);
		ToString(TaskType::EnableMonitoring);
		ToString(TaskType::DisableMonitoring);
		ToString(TaskType::GetInterceptedIrps);
		ToString(TaskType::ReplayIrp);
		ToString(TaskType::StoreTestCase);
		ToString(TaskType::EnumerateDrivers);
		ToString(TaskType::EnableDriver);
		ToString(TaskType::DisableDriver);
		ToString(TaskType::GetNamesOfHookedDrivers);
	}

	dbg(L"Undeclared TaskType %d\n", m_Type);
	return L"(UnknownType)";
}


const TaskType Task::Type()
{
	return m_Type;
}


const DWORD Task::IoctlCode()
{
	std::map<TaskType, DWORD>::iterator it = g_TaskIoctls.find(m_Type);
	if(it == g_TaskIoctls.end())
		return (DWORD)-1;

	return it->second;
}


void Task::SetState(TaskState s)
{
	m_State = s;
}


const uint32_t Task::Length()
{
	return m_dwDataLength;
}


byte* Task::Data()
{
	return m_Data;
}


const DWORD Task::Id()
{
	return m_dwId;
}


const DWORD Task::ErrCode()
{
	if (m_bIsRequest)
		return -1;

	return m_dwErrCode;
}

```

`Broker/TaskManager.cpp`:

```cpp
#include "TaskManager.h"

#include <optional>


TaskManager::TaskManager()
{
	m_hPushEvent = CreateEvent(NULL, FALSE,	FALSE, NULL);

	if(!m_hPushEvent)
		throw std::runtime_error("CreateEvent(hPushEvent) failed");

}



TaskManager::~TaskManager()
{
#ifdef _DEBUG
	xlog(LOG_DEBUG, L"deleting TaskManager '%s'\n", m_name.c_str());
#endif // _DEBUG

	CloseHandle(m_hPushEvent);
	m_hPushEvent = INVALID_HANDLE_VALUE;
}


void TaskManager::push(Task task)
{
#ifdef _DEBUG
	xlog(LOG_DEBUG, L"%s pushes '%s' task (id=%d)\n", m_name.c_str(), task.TypeAsString(), task.Id());
#endif // _DEBUG

	//
	// push a copy of the task to the queue
	// 
	std::unique_lock<std::mutex> mlock(m_mutex);
	m_task_queue.push(task);
	mlock.unlock();
	m_cond.notify_one();

	//
	// notify other threads an item has been pushed
	//
	SetEvent(m_hPushEvent);
	task.SetState(TaskState::Queued);
}


/*++

pop is should be blocking

--*/
Task TaskManager::pop()
{
	std::unique_lock<std::mutex> mlock(m_mutex);
	
	while (m_task_queue.empty())
		m_cond.wait(mlock);	

	//
	// copy-pop the top task, mark as delivered
	//
	Task t(m_task_queue.front());
	m_task_queue.pop();

	t.SetState(TaskState::Delivered);

#ifdef _DEBUG
	xlog(LOG_DEBUG, L"%s pops '%s' task ID=%d\n", m_name.c_str(), t.TypeAsString(), t.Id());
#endif // _DEBUG

	return t;
}



BOOL TaskManager::SetName(const std::wstring name)
{
	m_name = name;

#ifdef _DEBUG
	xlog(LOG_DEBUG, L"setting new name %s\n", m_name.c_str());
#endif // _DEBUG

	return TRUE;
}
```

`Broker/TaskManager.h`:

```h
#pragma once

#include "common.h"
#include "Task.h"

#include <queue>
#include <mutex>

class TaskManager
{
public:
	TaskManager();
	~TaskManager();

	void push(Task t);
	Task pop();
	BOOL SetName(const std::wstring name);

	HANDLE m_hPushEvent = INVALID_HANDLE_VALUE;


private:
	std::wstring m_name;
	std::queue<Task> m_task_queue;
	std::mutex m_mutex;
	std::condition_variable m_cond;
	
};
```

`Broker/TcpSocketTransportManager.cpp`:

```cpp
#include <WinSock2.h>
#include <ws2tcpip.h>

#include "TcpSocketTransportManager.h"

#include "Session.h"

#include "json.hpp"
using json = nlohmann::json;


TcpSocketTransportManager::TcpSocketTransportManager()
	: 
	m_ServerSocket(INVALID_SOCKET),
	m_ClientSocket(INVALID_SOCKET)
{
	WSADATA WsaData = { 0, };

	if (WSAStartup(MAKEWORD(2, 2), &WsaData))
		RAISE_GENERIC_EXCEPTION("TcpSocketTransportManager::WSAStartup()");

	if (LOBYTE(WsaData.wVersion) != 2 || HIBYTE(WsaData.wVersion) != 2)
		RAISE_GENERIC_EXCEPTION("TcpSocketTransportManager - version check");
}


TcpSocketTransportManager::~TcpSocketTransportManager()
{
	WSACleanup();
}


/*++

Prepare the socket: init + bind + listen

--*/
BOOL TcpSocketTransportManager::Initialize()
{
	WSAPROTOCOL_INFO info = { 0, };
	info.dwServiceFlags1 |= XP1_IFS_HANDLES;

	m_ServerSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_NO_HANDLE_INHERIT);
	if (m_ServerSocket == INVALID_SOCKET)
	{
		xlog(LOG_CRITICAL, L"Cannot create socket (WSAGetLastError=0x%x)\n", ::WSAGetLastError());
		return false;
	}

	return true;
}


/*++

Prepare the socket: bind + listen

--*/
BOOL TcpSocketTransportManager::Connect()
{
	SOCKADDR_IN sa = { 0, };
	InetPtonW(AF_INET, L"0.0.0.0", &sa.sin_addr.s_addr);
	sa.sin_family = AF_INET;
	sa.sin_port = htons(TCP_LISTEN_PORT);

	if (bind(m_ServerSocket, (PSOCKADDR)&sa, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		xlog(LOG_CRITICAL, L"Cannot bind socket (WSAGetLastError=0x%x)\n", ::WSAGetLastError());
		Terminate();
		return false;
	}

	if (listen(m_ServerSocket, SOMAXCONN_HINT(TCP_MAX_CONNECTIONS)))
	{
		xlog(LOG_CRITICAL, L"Cannot listen socket (WSAGetLastError=0x%x)\n", ::WSAGetLastError());
		Terminate();
		return false;
	}

	return true;
}


BOOL TcpSocketTransportManager::Terminate()
{
	BOOL res = closesocket(m_ServerSocket) == 0;
	WSACleanup();
	return res;
}


BOOL TcpSocketTransportManager::Reconnect()
{
	return Terminate() && Initialize() && Connect();
}


/*++



--*/
int CALLBACK ConditionAcceptFunc(
	LPWSABUF lpCallerId,
	LPWSABUF lpCallerData,
	LPQOS pQos,
	LPQOS lpGQOS,
	LPWSABUF lpCalleeId,
	LPWSABUF lpCalleeData,
	GROUP FAR* g,
	DWORD_PTR dwCallbackData
)
{
	// todo: harden
	return CF_ACCEPT;
}


/*++

Accept a client socket

--*/
SOCKET TcpSocketTransportManager::Accept()
{
	SOCKET ClientSocket = INVALID_SOCKET;
	SOCKADDR_IN SockInfoClient = { 0 };
	INT dwSockInfoClientSize = sizeof(SOCKADDR_IN);

	ClientSocket = ::WSAAccept(m_ServerSocket, (SOCKADDR*)&SockInfoClient, &dwSockInfoClientSize, ConditionAcceptFunc, 0);
	if (ClientSocket == INVALID_SOCKET)
	{
		xlog(LOG_ERROR, L"Cannot accept from server socket (WSAGetLastError=0x%x)\n", ::WSAGetLastError());
		return INVALID_SOCKET;
	}

	WCHAR lpswIpClient[256] = { 0, };
	InetNtopW(AF_INET, &SockInfoClient.sin_addr.s_addr, lpswIpClient, _countof(lpswIpClient));
	xlog(LOG_SUCCESS, L"New TCP client %s:%d (handle=%d)\n", lpswIpClient, ntohs(SockInfoClient.sin_port), ClientSocket);

	m_dwServerState = ServerState::ReadyToReadFromClient;
	return ClientSocket;
}



/*++

Synchronous send for TCP streams

--*/
BOOL TcpSocketTransportManager::SendSynchronous(_In_ const std::vector<byte>& data)
{
	if (m_ClientSocket == INVALID_SOCKET)
		RAISE_GENERIC_EXCEPTION("not ready");
	/*
	if (data.size() >= MAX_ACCEPTABLE_MESSAGE_SIZE)
		return false;
	*/
	DWORD dwNbSentBytes = 0, dwFlags = 0;
	WSABUF DataBuf = { 0 };
	DataBuf.len = (DWORD)data.size();
	DataBuf.buf = (char*)data.data();

	if (::WSASend(m_ClientSocket, &DataBuf, 1, &dwNbSentBytes, dwFlags, NULL, NULL) == SOCKET_ERROR)
		RAISE_GENERIC_EXCEPTION("SendSynchronous - WSASend:");

	return true;
}


/*++

Synchronous receive for TCP streams

--*/
std::vector<byte> TcpSocketTransportManager::ReceiveSynchronous()
{
	if(m_ClientSocket == INVALID_SOCKET)
		RAISE_GENERIC_EXCEPTION("ReceiveSynchronous - not ready: ");

	auto buf = std::make_unique<byte[]>(MAX_MESSAGE_SIZE);
	RtlZeroMemory(buf.get(), MAX_MESSAGE_SIZE);
	DWORD dwNbRecvBytes = 0, dwFlags = 0;
	WSABUF DataBuf = { 0 };
	DataBuf.len = MAX_MESSAGE_SIZE;
	DataBuf.buf = (char*)buf.get();

	int recv_result = ::WSARecv(m_ClientSocket, &DataBuf, 1, &dwNbRecvBytes, &dwFlags, NULL, NULL);
	if (recv_result == SOCKET_ERROR)
	{
		// check for overlapped data
		if (::WSAGetLastError() != WSAEWOULDBLOCK)
			RAISE_GENERIC_EXCEPTION("ReceiveSynchronous - WSARecv: ");

		WSAOVERLAPPED Overlapped = { 0 };

		recv_result = ::WSARecv(m_ClientSocket, &DataBuf, 1, &dwNbRecvBytes, &dwFlags, &Overlapped, NULL);
		if (::WSAGetLastError() != WSA_IO_PENDING)
			RAISE_GENERIC_EXCEPTION("ReceiveSynchronous - WSARecv: ");

		// we are in Overlapped I/O but the thread really needs the data from the client to proceed,
		// so just wait
		while (TRUE)
		{
			dwFlags = 0;
			DWORD dwIndex = ::WSAWaitForMultipleEvents(1, &Overlapped.hEvent, TRUE, WSA_INFINITE, FALSE);
			if (dwIndex == WSA_WAIT_FAILED || !Overlapped.hEvent)
				break;
			::WSAResetEvent(Overlapped.hEvent);
			::WSAGetOverlappedResult(m_ClientSocket, &Overlapped, &dwNbRecvBytes, FALSE, &dwFlags);
			ZeroMemory(&Overlapped, sizeof(WSAOVERLAPPED));
			break;
		}

	}

	std::vector<byte> res;
	for (DWORD i = 0; i < dwNbRecvBytes; i++) res.push_back(buf[i]);
	return res;
}


/*++

This function handles the client (GUI) session 

--*/
static DWORD ProcessTcpRequest(_In_ LPVOID lpParameter)
{
	PULONG_PTR lpParameters = (PULONG_PTR)lpParameter;
	Session& Sess = *(reinterpret_cast<Session*>(lpParameters[0]));
	SOCKET ClientSocket = (SOCKET)lpParameters[1];
	DWORD dwRetCode = ERROR_SUCCESS;

	dbg(L"in request handler\n");

	std::vector<HANDLE> handles;
	handles.push_back(Sess.m_hTerminationEvent);

	HANDLE hEvent = ::WSACreateEvent();
	if (hEvent==WSA_INVALID_EVENT || ::WSAEventSelect(ClientSocket, hEvent, FD_READ | FD_WRITE | FD_CLOSE) == SOCKET_ERROR)
	{
		DWORD gle = ::WSAGetLastError();
		xlog(LOG_ERROR, L"Cannot create event socket (WSAGetLastError=0x%x)\n", gle);
		return gle;
	}

	handles.push_back(hEvent);
	bool fContinue = true;

	while (Sess.IsRunning() && fContinue)
	{
		DWORD dwIndex = ::WSAWaitForMultipleEvents((DWORD)handles.size(), handles.data(), false, INFINITE, false) - WSA_WAIT_EVENT_0;

		if (dwIndex < 0 || dwIndex >= handles.size())
		{
			PrintErrorWithFunctionName(L"WSAWaitForMultipleEvents(TcpClient)");
			fContinue = false;
			dwRetCode = ::WSAGetLastError();
			continue;
		}

		//
		// reset the event
		//
		::WSAResetEvent(handles.at(dwIndex));

		if (dwIndex != 1)
		{
			if (dwIndex == 0)
			{
				dbg(L"received termination event\n");
				Sess.Stop();
			}
			fContinue = false;
			continue;
		}

		//
		// handle the data sent / recv
		//

		WSANETWORKEVENTS Events = { 0, };
		if (::WSAEnumNetworkEvents(ClientSocket, hEvent, &Events) == SOCKET_ERROR)
		{
			xlog(LOG_ERROR, L"WSAEnumNetworkEvents() failed with 0x%x\n", WSAGetLastError());
			continue;
		}


		if (Events.lNetworkEvents & FD_CLOSE)
		{
			dbg(L"gracefully disconnecting handle=0x%x\n", ClientSocket);
			fContinue = false;
			dwRetCode = ERROR_SUCCESS;
			xlog(LOG_SUCCESS, L"TCP client handle=%d disconnected\n", ClientSocket);
			continue;
		}

		try
		{
			if ( (Events.lNetworkEvents & FD_READ) != FD_READ)
				continue;

			//
			// if here, process the requests (there may be multiple task per read)
			//
			for (auto task : Sess.FrontEndServer.ProcessNextRequest())
			{
				switch (task.Type())
				{
				case TaskType::GetOsInfo:			continue;
				case TaskType::GetInterceptedIrps:	continue;
				case TaskType::EnumerateDrivers:	continue;
				case TaskType::ReplayIrp:			continue;
				}

				//
				// and send the response
				//
				if (!Sess.FrontEndServer.ForwardReply())
					RAISE_GENERIC_EXCEPTION("ForwardReply");
			}
		}
		catch (InvalidRequestException & e)
		{
			xlog(LOG_WARNING, L"InvalidRequestException raised: %S\n", e.what());
			continue;
		}
		catch (BaseException & e)
		{
			xlog(LOG_ERROR, L"exception %S\n", e.what());
			fContinue = false;
			dwRetCode = ERROR_INVALID_DATA;
			continue;
		}
	}

	::CloseHandle(hEvent);
	::closesocket(ClientSocket);
	
	dbg(L"terminating thread TID=%d\n", ::GetThreadId(::GetCurrentThread()));
	return dwRetCode;
}


DWORD TcpSocketTransportManager::RunForever(_In_ Session& CurrentSession)
{
	if (!Initialize())
		return ERROR_INVALID_PARAMETER;

	if (!Connect())
		return ERROR_INVALID_PARAMETER;

	dbg(L"TCP socket ready\n");

	DWORD retcode = ERROR_SUCCESS;
	HANDLE hEvent = INVALID_HANDLE_VALUE;

	std::vector<HANDLE> handles;
	handles.push_back(CurrentSession.m_hTerminationEvent);

	hEvent = ::WSACreateEvent();
	if(::WSAEventSelect(m_ServerSocket, hEvent, FD_ACCEPT | FD_CLOSE) == SOCKET_ERROR)
	{
		PrintErrorWithFunctionName(L"WSAEventSelect(TcpServer)");
		return ::WSAGetLastError();
	}
	handles.push_back(hEvent);


	while (CurrentSession.IsRunning())
	{
		SOCKET ClientSocket;
		HANDLE hClientThread;
		DWORD dwClientTid;

		DWORD dwIndex = ::WSAWaitForMultipleEvents((DWORD)handles.size(), handles.data(), false, INFINITE, false) - WSA_WAIT_EVENT_0;

		if (dwIndex < 0 || dwIndex >= handles.size())
		{
			PrintErrorWithFunctionName(L"WSAWaitForMultipleEvents(TcpServer)");
			CurrentSession.Stop();
			continue;
		}

		::WSAResetEvent(handles.at(dwIndex));

		dbg(L"TcpServer: event triggered %d\n", dwIndex);

		switch (dwIndex)
		{
		case 0:
			dbg(L"received termination event\n");
			CurrentSession.Stop();
			break;

		case 1:
		{
			WSANETWORKEVENTS Events = { 0, };
			::WSAEnumNetworkEvents(m_ServerSocket, hEvent, &Events);

			if (Events.lNetworkEvents & FD_CLOSE)
			{
				// is a an TCP_CLOSE ?
				::CloseHandle(handles.at(dwIndex));
			}
			else
			{
				// it's a TCP_SYN, so accept the connection and spawn the thread handling the requests
				ClientSocket = Accept();
				if (ClientSocket == INVALID_SOCKET)
					continue;

				m_ClientSocket = ClientSocket;
				m_dwServerState = ServerState::ReadyToReadFromClient;

				PULONG_PTR args[2] = {
					(PULONG_PTR)&CurrentSession,
					(PULONG_PTR)m_ClientSocket
				};

				// start a thread to handle the requests
				hClientThread = ::CreateThread(nullptr, 0, ProcessTcpRequest, args, 0, &dwClientTid);
				if (!hClientThread)
				{
					::closesocket(ClientSocket);
					m_ClientSocket = INVALID_SOCKET;
					PrintErrorWithFunctionName(L"CreateThread(TcpCli)");
					continue;
				}

				dbg(L"event on handle %d\n", dwIndex);
				handles.push_back(hClientThread);
			}
			break;
		}

		default:
			//
			// if here, we've received the event of EOL from the client thread, so we clean up and continue looping
			//
			dbg(L"default event_handle[%d], closing tcp client thread...\n", dwIndex);
			::CloseHandle(handles.at(dwIndex));
			handles.erase(handles.begin() + dwIndex);
			break;
		}
	}

	dbg(L"terminating thread TID=%d\n", ::GetThreadId(::GetCurrentThread()));
	return retcode;
}

```

`Broker/TcpSocketTransportManager.h`:

```h
#pragma once

#include "common.h"
#include "ServerTransportManager.h"

class Session;


/*++

Communication via TCP socket.

--*/

#define TCP_LISTEN_PORT 1337
#define TCP_MAX_CONNECTIONS 1


class TcpSocketTransportManager : public ServerTransportManager
{
public:
	TcpSocketTransportManager();
	~TcpSocketTransportManager();

	BOOL Initialize();
	BOOL Terminate();
	BOOL Connect();
	BOOL Reconnect();
	DWORD RunForever(_In_ Session& CurrentSession);
	BOOL SendSynchronous(_In_ const std::vector<byte>& data);
	std::vector<byte> ReceiveSynchronous();


private:
	SOCKET Accept();

	SOCKET m_ServerSocket;
	SOCKET m_ClientSocket;
};

```

`Broker/Utils.cpp`:

```cpp
#include "Utils.h"



/**
 *
 * adapted from base64.cpp and base64.h by René Nyffenegger
 *
 */

static const std::string base64_chars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz"
"0123456789+/";


static inline bool is_base64(unsigned char c) 
{
	return (isalnum(c) || (c == '+') || (c == '/'));
}


std::string Utils::base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) 
{
	std::string ret;
	int i = 0;
	int j = 0;
	unsigned char char_array_3[3];
	unsigned char char_array_4[4];

	while (in_len--) {
		char_array_3[i++] = *(bytes_to_encode++);
		if (i == 3) {
			char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
			char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
			char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
			char_array_4[3] = char_array_3[2] & 0x3f;

			for (i = 0; (i < 4); i++)
				ret += base64_chars[char_array_4[i]];
			i = 0;
		}
	}

	if (i)
	{
		for (j = i; j < 3; j++)
			char_array_3[j] = '\0';

		char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
		char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
		char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
		char_array_4[3] = char_array_3[2] & 0x3f;

		for (j = 0; (j < i + 1); j++)
			ret += base64_chars[char_array_4[j]];

		while ((i++ < 3))
			ret += '=';

	}

	return ret;
}


std::vector<BYTE> Utils::base64_decode(std::string const& encoded_string)
{
	size_t in_len = encoded_string.size();
	int i = 0;
	int j = 0;
	int in_ = 0;
	unsigned char char_array_4[4], char_array_3[3];
	std::vector<BYTE> ret;

	while (in_len-- && (encoded_string[in_] != '=') && is_base64(encoded_string[in_])) 
	{
		char_array_4[i++] = encoded_string[in_]; in_++;
		if (i == 4) 
		{
			for (i = 0; i < 4; i++)
				char_array_4[i] = base64_chars.find(char_array_4[i]) & 0xff;

			char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
			char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
			char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

			for (i = 0; (i < 3); i++)
				ret.push_back(char_array_3[i]);
			i = 0;
		}
	}

	if (i) 
	{
		for (j = i; j < 4; j++)
			char_array_4[j] = 0;

		for (j = 0; j < 4; j++)
			char_array_4[j] = base64_chars.find(char_array_4[j]) & 0xff;

		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
		char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
		char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

		for (j = 0; (j < i - 1); j++) 
			ret.push_back(char_array_3[j]);
	}

	return ret;
}



std::vector<std::string> Utils::EnumerateDrivers()
{
	DWORD cbNeeded=0, dwSize=0, dwNbDrivers=0;

	BOOL bRes = ::EnumDeviceDrivers(NULL, 0, &cbNeeded);
	if (!bRes)
	{
		if (::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			throw std::runtime_error("Unexpected result from EnumDeviceDrivers1");
	}

	dwSize = cbNeeded;

	LPVOID* lpDrivers = (LPVOID*)::LocalAlloc(LPTR, dwSize);
	if(!lpDrivers)
		throw std::runtime_error("LocalAlloc");

	bRes = ::EnumDeviceDrivers(lpDrivers, dwSize, &cbNeeded);

	if (!bRes || dwSize != cbNeeded)
	{
		::LocalFree(lpDrivers);
		throw std::runtime_error("EnumDeviceDrivers2 failed");
	}


	std::vector<std::string> DriverList;
	CHAR wszDriverBaseName[MAX_PATH] = { 0, };
	dwNbDrivers = dwSize / sizeof(LPVOID);

	for (DWORD i = 0; i < dwNbDrivers; i++)
	{
		memset(wszDriverBaseName, 0, sizeof(wszDriverBaseName));

		if (::GetDeviceDriverBaseNameA(lpDrivers[i], wszDriverBaseName, _countof(wszDriverBaseName)))
			DriverList.push_back(std::string(wszDriverBaseName));
	}

	::LocalFree(lpDrivers);

	return DriverList;
}



std::vector<std::pair<std::wstring, std::wstring>> Utils::EnumerateObjectDirectory(std::wstring const& Root = L"\\")
{
	std::vector<std::pair<std::wstring, std::wstring>> ObjectList;

	HANDLE hDirectory;
	OBJECT_ATTRIBUTES ObjAttr;
	UNICODE_STRING usName;

	RtlInitUnicodeString(&usName, Root.c_str());
	InitializeObjectAttributes(&ObjAttr, &usName, OBJ_CASE_INSENSITIVE, nullptr, nullptr);

	NTSTATUS Status = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY| DIRECTORY_TRAVERSE, &ObjAttr);
	if (!NT_SUCCESS(Status))
		RAISE_GENERIC_EXCEPTION("NtOpenDirectoryObject");


	ULONG ctx = 0;

	do 
	{
		ULONG rlen = 0;

		Status = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &rlen);
		if (Status != STATUS_BUFFER_TOO_SMALL) 
			break;

		POBJECT_DIRECTORY_INFORMATION pObjDirInfo = (POBJECT_DIRECTORY_INFORMATION)::LocalAlloc(LPTR, rlen);
		if (!pObjDirInfo)
			break;

		Status = NtQueryDirectoryObject(hDirectory, pObjDirInfo, rlen, TRUE, FALSE, &ctx, &rlen);
		if (NT_SUCCESS(Status))
		{
			for (ULONG i = 0; i < ctx; i++)
			{
				if (!pObjDirInfo[i].Name.Buffer || !pObjDirInfo[i].TypeName.Buffer)
					break;

				ObjectList.push_back(
					std::make_pair(
						std::wstring(pObjDirInfo[i].Name.Buffer),
						std::wstring(pObjDirInfo[i].TypeName.Buffer)
					)
				);
			}
		}
		else
		{
			::LocalFree(pObjDirInfo);
			break;
		}

		::LocalFree(pObjDirInfo);
	} 
	while (true);

	NtClose(hDirectory);


	return ObjectList;
}



/*++
  
  todo find better way

 --*/
std::string Utils::WideStringToString(const std::wstring& w)
{
	// std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter_ws2s; // non c++-17 friendly
	// converter_ws2s.to_bytes(wstr);


	// std::string s(w.begin(), w.end()); // tons of warning

	// below is ugly AF but there's no easy (+ms friendly) way for c++17
	// todo: eventually need to improve

	std::string s;
	for (auto c : w)
		s += (char)c;
	return s;
}


/*++

Simple wrapper to send ioctls

--*/
DWORD Utils::Io::DeviceIoControlWrapper(
	const char* lpszDeviceName,
	const DWORD dwIoctlCode,
	const PBYTE lpInputBuffer,
	const DWORD dwInputBufferLength,
	PBYTE lpOutputBuffer,
	LPDWORD lpdwOutputBufferLength
)
{
	HANDLE hDevice = INVALID_HANDLE_VALUE;
	DWORD dwRes = ERROR_SUCCESS;
	BOOL bResult = FALSE;
	DWORD lpBytesReturned = 0;

	do
	{
		dbg(L"CreateFileA(%S)\n", lpszDeviceName);
		hDevice = CreateFileA(
			lpszDeviceName,
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);

		if (hDevice == INVALID_HANDLE_VALUE)
			return ::GetLastError();

		dbg(L"DeviceIoControl(%x)\n", dwIoctlCode);
		bResult = DeviceIoControl(
			hDevice,
			dwIoctlCode,
			lpInputBuffer,
			dwInputBufferLength,
			lpOutputBuffer,
			*lpdwOutputBufferLength,
			&lpBytesReturned,
			(LPOVERLAPPED)NULL
		);

		if (bResult == FALSE)
		{
			dwRes = ::GetLastError();
			break;
		}

		*lpdwOutputBufferLength = lpBytesReturned;
	} 
	while (0);

	if (hDevice != INVALID_HANDLE_VALUE)
		CloseHandle(hDevice);

	return dwRes;
}


DWORD Utils::Registry::ReadDword(
	HKEY hKeyRoot, 
	const std::wstring& SubKey, 
	const std::wstring& KeyName, 
	PDWORD lpdwKeyValue
)
{
	HKEY hKey;
	LSTATUS lStatus = ::RegOpenKeyExW(hKeyRoot, SubKey.c_str(), 0, KEY_READ, &hKey);
	if (lStatus != ERROR_SUCCESS)
		return lStatus;

	DWORD dwKeyValueSize = sizeof(DWORD);
	
	lStatus = ::RegQueryValueExW(hKey,
		KeyName.c_str(),
		0,
		NULL,
		(PBYTE)lpdwKeyValue,
		&dwKeyValueSize
	);

	RegCloseKey(hKey);
	return lStatus;
}


BOOL Utils::Registry::ReadBool(
	HKEY hKeyRoot,
	const std::wstring& SubKey,
	const std::wstring& KeyName,
	PBOOL lpbKeyValue
)
{
	HKEY hKey;
	LSTATUS lStatus = ::RegOpenKeyExW(hKeyRoot, SubKey.c_str(), 0, KEY_READ, &hKey);
	if (lStatus != ERROR_SUCCESS)
		return lStatus;

	DWORD dwKeyValueSize = sizeof(BOOL);

	lStatus = ::RegQueryValueExW(hKey,
		KeyName.c_str(),
		0,
		NULL,
		(PBYTE)lpbKeyValue,
		&dwKeyValueSize
	);

	RegCloseKey(hKey);
	return lStatus;
}


DWORD Utils::Registry::ReadWString(
	HKEY hKeyRoot,
	const std::wstring& SubKey,
	const std::wstring& KeyName,
	std::wstring& KeyValue
)
{
	HKEY hKey;
	LSTATUS lStatus = ::RegOpenKeyExW(hKeyRoot, SubKey.c_str(), 0, KEY_READ, &hKey);
	if (lStatus != ERROR_SUCCESS)
		return lStatus;

	WCHAR lpwsBuffer[MAX_REGSZ_SIZE] = { 0 };
	DWORD dwBufferSize = MAX_REGSZ_SIZE;

	lStatus = ::RegQueryValueExW(hKey,
		KeyName.c_str(),
		0,
		NULL,
		(PBYTE)lpwsBuffer,
		&dwBufferSize
	);

	if (lStatus == ERROR_SUCCESS)
		KeyValue = lpwsBuffer;

	RegCloseKey(hKey);
	return lStatus;
}


DWORD Utils::Process::GetIntegrityLevel(std::wstring& IntegrityLevelName)
{
	HANDLE hProcessHandle = INVALID_HANDLE_VALUE;
	HANDLE hProcessToken = INVALID_HANDLE_VALUE;
	DWORD dwRes = ERROR_SUCCESS;
	PTOKEN_MANDATORY_LABEL pTIL = NULL;
	DWORD dwIntegrityLevel = SECURITY_MANDATORY_MEDIUM_RID;

	do
	{
		hProcessHandle = ::GetCurrentProcess();

		if (!::OpenProcessToken(hProcessHandle, TOKEN_QUERY, &hProcessToken))
		{
			dwRes = ::GetLastError();
			break;
		}

		DWORD dwLengthNeeded;

		if (!::GetTokenInformation(hProcessToken, TokenIntegrityLevel, NULL, 0, &dwLengthNeeded))
		{
			dwRes = ::GetLastError();
			if (dwRes != ERROR_INSUFFICIENT_BUFFER)
			{
				dwRes = ::GetLastError();
				break;
			}
		}

		pTIL = (PTOKEN_MANDATORY_LABEL)::LocalAlloc(LPTR, dwLengthNeeded);
		if(!pTIL)
		{
			dwRes = ::GetLastError();
			break;
		}


		if (!::GetTokenInformation(hProcessToken, TokenIntegrityLevel, pTIL, dwLengthNeeded, &dwLengthNeeded))
		{
			dwRes = ::GetLastError();
			if (dwRes != ERROR_INSUFFICIENT_BUFFER)
			{
				dwRes = ::GetLastError();
				break;
			}
		}

		dwIntegrityLevel = *::GetSidSubAuthority(
			pTIL->Label.Sid,
			(DWORD)(UCHAR)(*::GetSidSubAuthorityCount(pTIL->Label.Sid) - 1)
		);

		::LocalFree(pTIL);


		if (dwIntegrityLevel == SECURITY_MANDATORY_LOW_RID)
			IntegrityLevelName = L"Low";

		else if ( SECURITY_MANDATORY_MEDIUM_RID < dwIntegrityLevel && dwIntegrityLevel < SECURITY_MANDATORY_HIGH_RID)
			IntegrityLevelName = L"Medium";

		else if (dwIntegrityLevel >= SECURITY_MANDATORY_HIGH_RID)
			IntegrityLevelName = L"High";

		else if (dwIntegrityLevel >= SECURITY_MANDATORY_SYSTEM_RID)
			IntegrityLevelName = L"System";

	} while (0);

	if (hProcessToken != INVALID_HANDLE_VALUE)
		::CloseHandle(hProcessToken);

	if (hProcessHandle != INVALID_HANDLE_VALUE)
		::CloseHandle(hProcessHandle);

	return ERROR_SUCCESS;
}
```

`Broker/Utils.h`:

```h
#pragma once

#include "common.h"
#include "nt.h"

#include <string>
#include <vector>
#include <Psapi.h>
#include <stdlib.h>


#define MAX_REGSZ_SIZE 255
#define MAX_USERNAME_SIZE 255


namespace Utils
{
	std::string base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len);
	std::vector<BYTE> base64_decode(std::string const& encoded_string);
	std::string WideStringToString(const std::wstring& original);

	std::vector<std::string> EnumerateDrivers();
	std::vector<std::pair<std::wstring, std::wstring>> EnumerateObjectDirectory(const std::wstring& Root);

	namespace Io
	{
		DWORD DeviceIoControlWrapper(
			const char* lpszDeviceName,
			const DWORD dwIoctlCode,
			const PBYTE lpInputBuffer,
			const DWORD dwInputBufferLength,
			PBYTE lpOutputBuffer,
			PDWORD lpdwOutputBufferLength
		);
	}

	namespace Registry
	{

		DWORD ReadDword(
			HKEY hKeyRoot,
			const std::wstring& SubKey,
			const std::wstring& KeyName,
			PDWORD lpdwKeyValue
		);

		BOOL ReadBool(
			HKEY hKeyRoot,
			const std::wstring& SubKey,
			const std::wstring& KeyName,
			PBOOL lpbKeyValue
		);

		DWORD ReadWString(
			HKEY hKeyRoot,
			const std::wstring& SubKey,
			const std::wstring& KeyName,
			std::wstring& KeyValue
		);
	};

	namespace Process
	{
		DWORD GetIntegrityLevel(std::wstring& IntegrityLevelName);
	}
};


```

`Broker/common.h`:

```h
#pragma once

//
// We want to use the NTSTATUS codes from the broker, quiet down
// the compiler warnings
//
#pragma warning (push)
#pragma warning (disable: 4005)
#include <ntstatus.h>
#define WIN32_NO_STATUS
#define UMDF_USING_NTSTATUS
#pragma warning (pop)

#include <Windows.h>

#include <stdio.h>
#include <wchar.h>

extern "C"
{
#include "..\Common\Common.h"
#include "..\Driver\IoctlCodes.h"
}

#include "CfbException.h"
```

`Broker/driver.h`:

```h
#pragma once

#include <memory>

#include "common.h"
#include "Session.h"
#include "SafeHandle.h"


_Success_(return) BOOL StartBackendManagerThread(_In_ PVOID lpParameter);

```

`Broker/json.hpp`:

```hpp
/*
    __ _____ _____ _____
 __|  |   __|     |   | |  JSON for Modern C++
|  |  |__   |  |  | | | |  version 3.7.0
|_____|_____|_____|_|___|  https://github.com/nlohmann/json

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
SPDX-License-Identifier: MIT
Copyright (c) 2013-2019 Niels Lohmann <http://nlohmann.me>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef INCLUDE_NLOHMANN_JSON_HPP_
#define INCLUDE_NLOHMANN_JSON_HPP_

#define NLOHMANN_JSON_VERSION_MAJOR 3
#define NLOHMANN_JSON_VERSION_MINOR 7
#define NLOHMANN_JSON_VERSION_PATCH 0

#include <algorithm> // all_of, find, for_each
#include <cassert> // assert
#include <ciso646> // and, not, or
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#include <iosfwd> // istream, ostream
#include <iterator> // random_access_iterator_tag
#include <memory> // unique_ptr
#include <numeric> // accumulate
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap
#include <vector> // vector

// #include <nlohmann/adl_serializer.hpp>


#include <utility>

// #include <nlohmann/detail/conversions/from_json.hpp>


#include <algorithm> // transform
#include <array> // array
#include <ciso646> // and, not
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

// #include <nlohmann/detail/exceptions.hpp>


#include <exception> // exception
#include <stdexcept> // runtime_error
#include <string> // to_string

// #include <nlohmann/detail/input/position_t.hpp>

#pragma warning( disable : 26444 26451 28020 26495 )


#include <cstddef> // size_t

namespace nlohmann
{
namespace detail
{
/// struct to capture the start position of the current token
struct position_t
{
    /// the total number of characters read
    std::size_t chars_read_total = 0;
    /// the number of characters read in the current line
    std::size_t chars_read_current_line = 0;
    /// the number of lines read
    std::size_t lines_read = 0;

    /// conversion to size_t to preserve SAX interface
    constexpr operator size_t() const
    {
        return chars_read_total;
    }
};

} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>


#include <utility> // pair
// #include <nlohmann/thirdparty/hedley/hedley.hpp>
/* Hedley - https://nemequ.github.io/hedley
 * Created by Evan Nemerson <evan@nemerson.com>
 *
 * To the extent possible under law, the author(s) have dedicated all
 * copyright and related and neighboring rights to this software to
 * the public domain worldwide. This software is distributed without
 * any warranty.
 *
 * For details, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 * SPDX-License-Identifier: CC0-1.0
 */

#if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 9)
#if defined(JSON_HEDLEY_VERSION)
    #undef JSON_HEDLEY_VERSION
#endif
#define JSON_HEDLEY_VERSION 9

#if defined(JSON_HEDLEY_STRINGIFY_EX)
    #undef JSON_HEDLEY_STRINGIFY_EX
#endif
#define JSON_HEDLEY_STRINGIFY_EX(x) #x

#if defined(JSON_HEDLEY_STRINGIFY)
    #undef JSON_HEDLEY_STRINGIFY
#endif
#define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)

#if defined(JSON_HEDLEY_CONCAT_EX)
    #undef JSON_HEDLEY_CONCAT_EX
#endif
#define JSON_HEDLEY_CONCAT_EX(a,b) a##b

#if defined(JSON_HEDLEY_CONCAT)
    #undef JSON_HEDLEY_CONCAT
#endif
#define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)

#if defined(JSON_HEDLEY_VERSION_ENCODE)
    #undef JSON_HEDLEY_VERSION_ENCODE
#endif
#define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))

#if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)

#if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MINOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)

#if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
    #undef JSON_HEDLEY_VERSION_DECODE_REVISION
#endif
#define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)

#if defined(JSON_HEDLEY_GNUC_VERSION)
    #undef JSON_HEDLEY_GNUC_VERSION
#endif
#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#elif defined(__GNUC__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
#endif

#if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
    #undef JSON_HEDLEY_GNUC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GNUC_VERSION)
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION)
    #undef JSON_HEDLEY_MSVC_VERSION
#endif
#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
#elif defined(_MSC_FULL_VER)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
#elif defined(_MSC_VER)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
    #undef JSON_HEDLEY_MSVC_VERSION_CHECK
#endif
#if !defined(_MSC_VER)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
#else
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION)
    #undef JSON_HEDLEY_INTEL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
#elif defined(__INTEL_COMPILER)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_VERSION)
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION)
    #undef JSON_HEDLEY_PGI_VERSION
#endif
#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
    #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
    #undef JSON_HEDLEY_PGI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PGI_VERSION)
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #undef JSON_HEDLEY_SUNPRO_VERSION
#endif
#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
#elif defined(__SUNPRO_C)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
#elif defined(__SUNPRO_CC)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
    #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#endif
#if defined(__EMSCRIPTEN__)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION)
    #undef JSON_HEDLEY_ARM_VERSION
#endif
#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
    #undef JSON_HEDLEY_ARM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_ARM_VERSION)
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION)
    #undef JSON_HEDLEY_IBM_VERSION
#endif
#if defined(__ibmxl__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
#elif defined(__xlC__) && defined(__xlC_ver__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
#elif defined(__xlC__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
    #undef JSON_HEDLEY_IBM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IBM_VERSION)
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_VERSION)
    #undef JSON_HEDLEY_TI_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__)
    #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_VERSION)
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION)
    #undef JSON_HEDLEY_CRAY_VERSION
#endif
#if defined(_CRAYC)
    #if defined(_RELEASE_PATCHLEVEL)
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
    #else
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
    #undef JSON_HEDLEY_CRAY_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_CRAY_VERSION)
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IAR_VERSION)
    #undef JSON_HEDLEY_IAR_VERSION
#endif
#if defined(__IAR_SYSTEMS_ICC__)
    #if __VER__ > 1000
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
    #else
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(VER / 100, __VER__ % 100, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
    #undef JSON_HEDLEY_IAR_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IAR_VERSION)
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION)
    #undef JSON_HEDLEY_TINYC_VERSION
#endif
#if defined(__TINYC__)
    #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
    #undef JSON_HEDLEY_TINYC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION)
    #undef JSON_HEDLEY_DMC_VERSION
#endif
#if defined(__DMC__)
    #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
    #undef JSON_HEDLEY_DMC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_DMC_VERSION)
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #undef JSON_HEDLEY_COMPCERT_VERSION
#endif
#if defined(__COMPCERT_VERSION__)
    #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
    #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION)
    #undef JSON_HEDLEY_PELLES_VERSION
#endif
#if defined(__POCC__)
    #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
    #undef JSON_HEDLEY_PELLES_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PELLES_VERSION)
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_GCC_VERSION)
    #undef JSON_HEDLEY_GCC_VERSION
#endif
#if \
    defined(JSON_HEDLEY_GNUC_VERSION) && \
    !defined(__clang__) && \
    !defined(JSON_HEDLEY_INTEL_VERSION) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_ARM_VERSION) && \
    !defined(JSON_HEDLEY_TI_VERSION) && \
    !defined(__COMPCERT__)
    #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
#endif

#if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_BUILTIN)
    #undef JSON_HEDLEY_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GCC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_FEATURE)
    #undef JSON_HEDLEY_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
#else
    #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
    #undef JSON_HEDLEY_GNUC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
    #undef JSON_HEDLEY_GCC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_EXTENSION)
    #undef JSON_HEDLEY_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
#else
    #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GCC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_WARNING)
    #undef JSON_HEDLEY_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
#else
    #define JSON_HEDLEY_HAS_WARNING(warning) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
    #undef JSON_HEDLEY_GNUC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_WARNING)
    #undef JSON_HEDLEY_GCC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    defined(__clang__) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(6,0,0) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
    #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
#else
    #define JSON_HEDLEY_PRAGMA(value)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
    #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#endif
#if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
    #undef JSON_HEDLEY_DIAGNOSTIC_POP
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
    #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
#elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
#elif JSON_HEDLEY_TI_VERSION_CHECK(8,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH
    #define JSON_HEDLEY_DIAGNOSTIC_POP
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
#elif JSON_HEDLEY_TI_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
#elif JSON_HEDLEY_TI_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif

#if defined(JSON_HEDLEY_DEPRECATED)
    #undef JSON_HEDLEY_DEPRECATED
#endif
#if defined(JSON_HEDLEY_DEPRECATED_FOR)
    #undef JSON_HEDLEY_DEPRECATED_FOR
#endif
#if defined(__cplusplus) && (__cplusplus >= 201402L)
    #define JSON_HEDLEY_DEPRECATED(since) [[deprecated("Since " #since)]]
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) [[deprecated("Since " #since "; use " #replacement)]]
#elif \
    JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,3,0)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0)
    #define JSON_HEDLEY_DEPRECATED(since) _declspec(deprecated)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
#else
    #define JSON_HEDLEY_DEPRECATED(since)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
#endif

#if defined(JSON_HEDLEY_UNAVAILABLE)
    #undef JSON_HEDLEY_UNAVAILABLE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
#else
    #define JSON_HEDLEY_UNAVAILABLE(available_since)
#endif

#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT
#endif
#if defined(__cplusplus) && (__cplusplus >= 201703L)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT [[nodiscard]]
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
#elif defined(_Check_return_) /* SAL */
    #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
#else
    #define JSON_HEDLEY_WARN_UNUSED_RESULT
#endif

#if defined(JSON_HEDLEY_SENTINEL)
    #undef JSON_HEDLEY_SENTINEL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0)
    #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
#else
    #define JSON_HEDLEY_SENTINEL(position)
#endif

#if defined(JSON_HEDLEY_NO_RETURN)
    #undef JSON_HEDLEY_NO_RETURN
#endif
#if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NO_RETURN __noreturn
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
    #define JSON_HEDLEY_NO_RETURN _Noreturn
#elif defined(__cplusplus) && (__cplusplus >= 201103L)
    #define JSON_HEDLEY_NO_RETURN [[noreturn]]
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(18,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(17,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#elif JSON_HEDLEY_TI_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#else
    #define JSON_HEDLEY_NO_RETURN
#endif

#if defined(JSON_HEDLEY_UNREACHABLE)
    #undef JSON_HEDLEY_UNREACHABLE
#endif
#if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
    #undef JSON_HEDLEY_UNREACHABLE_RETURN
#endif
#if \
    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5)
    #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0)
    #define JSON_HEDLEY_UNREACHABLE() __assume(0)
#elif JSON_HEDLEY_TI_VERSION_CHECK(6,0,0)
    #if defined(__cplusplus)
        #define JSON_HEDLEY_UNREACHABLE() std::_nassert(0)
    #else
        #define JSON_HEDLEY_UNREACHABLE() _nassert(0)
    #endif
    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return value
#elif defined(EXIT_FAILURE)
    #define JSON_HEDLEY_UNREACHABLE() abort()
#else
    #define JSON_HEDLEY_UNREACHABLE()
    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return value
#endif
#if !defined(JSON_HEDLEY_UNREACHABLE_RETURN)
    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
#endif

#if defined(JSON_HEDLEY_ASSUME)
    #undef JSON_HEDLEY_ASSUME
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
#elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
    #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
#elif JSON_HEDLEY_TI_VERSION_CHECK(6,0,0)
    #if defined(__cplusplus)
        #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
    #else
        #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
    #endif
#elif \
    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && !defined(JSON_HEDLEY_ARM_VERSION)) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5)
    #define JSON_HEDLEY_ASSUME(expr) ((void) ((expr) ? 1 : (__builtin_unreachable(), 1)))
#else
    #define JSON_HEDLEY_ASSUME(expr) ((void) (expr))
#endif


JSON_HEDLEY_DIAGNOSTIC_PUSH
#if \
    JSON_HEDLEY_HAS_WARNING("-Wvariadic-macros") || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0)
    #if defined(__clang__)
        #pragma clang diagnostic ignored "-Wvariadic-macros"
    #elif defined(JSON_HEDLEY_GCC_VERSION)
        #pragma GCC diagnostic ignored "-Wvariadic-macros"
    #endif
#endif
#if defined(JSON_HEDLEY_NON_NULL)
    #undef JSON_HEDLEY_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
#else
    #define JSON_HEDLEY_NON_NULL(...)
#endif
JSON_HEDLEY_DIAGNOSTIC_POP

#if defined(JSON_HEDLEY_PRINTF_FORMAT)
    #undef JSON_HEDLEY_PRINTF_FORMAT
#endif
#if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
#elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
#else
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
#endif

#if defined(JSON_HEDLEY_CONSTEXPR)
    #undef JSON_HEDLEY_CONSTEXPR
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_CONSTEXPR constexpr
    #endif
#endif
#if !defined(JSON_HEDLEY_CONSTEXPR)
    #define JSON_HEDLEY_CONSTEXPR
#endif

#if defined(JSON_HEDLEY_PREDICT)
    #undef JSON_HEDLEY_PREDICT
#endif
#if defined(JSON_HEDLEY_LIKELY)
    #undef JSON_HEDLEY_LIKELY
#endif
#if defined(JSON_HEDLEY_UNLIKELY)
    #undef JSON_HEDLEY_UNLIKELY
#endif
#if defined(JSON_HEDLEY_UNPREDICTABLE)
    #undef JSON_HEDLEY_UNPREDICTABLE
#endif
#if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable(!!(expr))
#endif
#if \
  JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0)
#  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(expr, value, probability)
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) __builtin_expect_with_probability(!!(expr), 1, probability)
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) __builtin_expect_with_probability(!!(expr), 0, probability)
#  define JSON_HEDLEY_LIKELY(expr) __builtin_expect(!!(expr), 1)
#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
#if !defined(JSON_HEDLEY_BUILTIN_UNPREDICTABLE)
    #define JSON_HEDLEY_BUILTIN_UNPREDICTABLE(expr) __builtin_expect_with_probability(!!(expr), 1, 0.5)
#endif
#elif \
  JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27)
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
    (((probability) >= 0.9) ? __builtin_expect(!!(expr), (expected)) : (((void) (expected)), !!(expr)))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
    (__extension__ ({ \
        JSON_HEDLEY_CONSTEXPR double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
    }))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
    (__extension__ ({ \
        JSON_HEDLEY_CONSTEXPR double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
    }))
#  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
#else
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) (((void) (expected)), !!(expr))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
#  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
#endif
#if !defined(JSON_HEDLEY_UNPREDICTABLE)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
#endif

#if defined(JSON_HEDLEY_MALLOC)
    #undef JSON_HEDLEY_MALLOC
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))
    #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(14, 0, 0)
    #define JSON_HEDLEY_MALLOC __declspec(restrict)
#else
    #define JSON_HEDLEY_MALLOC
#endif

#if defined(JSON_HEDLEY_PURE)
    #undef JSON_HEDLEY_PURE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_PURE __attribute__((__pure__))
#elif JSON_HEDLEY_TI_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
#else
    #define JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_CONST)
    #undef JSON_HEDLEY_CONST
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_CONST __attribute__((__const__))
#else
    #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_RESTRICT)
    #undef JSON_HEDLEY_RESTRICT
#endif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT restrict
#elif \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    defined(__clang__)
    #define JSON_HEDLEY_RESTRICT __restrict
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT _Restrict
#else
    #define JSON_HEDLEY_RESTRICT
#endif

#if defined(JSON_HEDLEY_INLINE)
    #undef JSON_HEDLEY_INLINE
#endif
#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    (defined(__cplusplus) && (__cplusplus >= 199711L))
    #define JSON_HEDLEY_INLINE inline
#elif \
    defined(JSON_HEDLEY_GCC_VERSION) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
    #define JSON_HEDLEY_INLINE __inline__
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_INLINE __inline
#else
    #define JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_ALWAYS_INLINE)
    #undef JSON_HEDLEY_ALWAYS_INLINE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))
    #define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0)
    #define JSON_HEDLEY_ALWAYS_INLINE __forceinline
#elif JSON_HEDLEY_TI_VERSION_CHECK(7,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
#else
    #define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_NEVER_INLINE)
    #undef JSON_HEDLEY_NEVER_INLINE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))
    #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
#elif JSON_HEDLEY_TI_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#else
    #define JSON_HEDLEY_NEVER_INLINE
#endif

#if defined(JSON_HEDLEY_PRIVATE)
    #undef JSON_HEDLEY_PRIVATE
#endif
#if defined(JSON_HEDLEY_PUBLIC)
    #undef JSON_HEDLEY_PUBLIC
#endif
#if defined(JSON_HEDLEY_IMPORT)
    #undef JSON_HEDLEY_IMPORT
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
    #define JSON_HEDLEY_PRIVATE
    #define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
    #define JSON_HEDLEY_IMPORT   __declspec(dllimport)
#else
    #if \
        JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
        JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
        JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
        JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
        JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
        JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
        JSON_HEDLEY_TI_VERSION_CHECK(8,0,0) || \
        (JSON_HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_EABI__) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))
        #define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
        #define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
    #else
        #define JSON_HEDLEY_PRIVATE
        #define JSON_HEDLEY_PUBLIC
    #endif
    #define JSON_HEDLEY_IMPORT    extern
#endif

#if defined(JSON_HEDLEY_NO_THROW)
    #undef JSON_HEDLEY_NO_THROW
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
#else
    #define JSON_HEDLEY_NO_THROW
#endif

#if defined(JSON_HEDLEY_FALL_THROUGH)
    #undef JSON_HEDLEY_FALL_THROUGH
#endif
#if \
    defined(__cplusplus) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
    !defined(JSON_HEDLEY_PGI_VERSION)
    #if \
        (__cplusplus >= 201703L) || \
        ((__cplusplus >= 201103L) && JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough))
        #define JSON_HEDLEY_FALL_THROUGH [[fallthrough]]
    #elif (__cplusplus >= 201103L) && JSON_HEDLEY_HAS_CPP_ATTRIBUTE(clang::fallthrough)
        #define JSON_HEDLEY_FALL_THROUGH [[clang::fallthrough]]
    #elif (__cplusplus >= 201103L) && JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0)
        #define JSON_HEDLEY_FALL_THROUGH [[gnu::fallthrough]]
    #endif
#endif
#if !defined(JSON_HEDLEY_FALL_THROUGH)
    #if JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(fallthrough,7,0,0) && !defined(JSON_HEDLEY_PGI_VERSION)
        #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
    #elif defined(__fallthrough) /* SAL */
        #define JSON_HEDLEY_FALL_THROUGH __fallthrough
    #else
        #define JSON_HEDLEY_FALL_THROUGH
    #endif
#endif

#if defined(JSON_HEDLEY_RETURNS_NON_NULL)
    #undef JSON_HEDLEY_RETURNS_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
#elif defined(_Ret_notnull_) /* SAL */
    #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
#else
    #define JSON_HEDLEY_RETURNS_NON_NULL
#endif

#if defined(JSON_HEDLEY_ARRAY_PARAM)
    #undef JSON_HEDLEY_ARRAY_PARAM
#endif
#if \
    defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
    !defined(__STDC_NO_VLA__) && \
    !defined(__cplusplus) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
#else
    #define JSON_HEDLEY_ARRAY_PARAM(name)
#endif

#if defined(JSON_HEDLEY_IS_CONSTANT)
    #undef JSON_HEDLEY_IS_CONSTANT
#endif
#if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
    #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#endif
/* Note the double-underscore. For internal use only; no API
 * guarantees! */
#if defined(JSON_HEDLEY__IS_CONSTEXPR)
    #undef JSON_HEDLEY__IS_CONSTEXPR
#endif

#if \
    JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(6,1,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0)
    #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
#endif
#if !defined(__cplusplus)
#  if \
       JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
       JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
       JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY__IS_CONSTEXPR(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
#else
    #include <stdint.h>
    #define JSON_HEDLEY__IS_CONSTEXPR(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
#endif
#  elif \
       (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && !defined(JSON_HEDLEY_SUNPRO_VERSION) && !defined(JSON_HEDLEY_PGI_VERSION)) || \
       JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY__IS_CONSTEXPR(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
#else
    #include <stdint.h>
    #define JSON_HEDLEY__IS_CONSTEXPR(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
#endif
#  elif \
       defined(JSON_HEDLEY_GCC_VERSION) || \
       defined(JSON_HEDLEY_INTEL_VERSION) || \
       defined(JSON_HEDLEY_TINYC_VERSION) || \
       defined(JSON_HEDLEY_TI_VERSION) || \
       defined(__clang__)
#    define JSON_HEDLEY__IS_CONSTEXPR(expr) ( \
        sizeof(void) != \
        sizeof(*( \
                  1 ? \
                  ((void*) ((expr) * 0L) ) : \
((struct { char v[sizeof(void) * 2]; } *) 1) \
                ) \
              ) \
                                            )
#  endif
#endif
#if defined(JSON_HEDLEY__IS_CONSTEXPR)
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY__IS_CONSTEXPR(expr)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY__IS_CONSTEXPR(expr) ? (expr) : (-1))
#else
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
#endif

#if defined(JSON_HEDLEY_BEGIN_C_DECLS)
    #undef JSON_HEDLEY_BEGIN_C_DECLS
#endif
#if defined(JSON_HEDLEY_END_C_DECLS)
    #undef JSON_HEDLEY_END_C_DECLS
#endif
#if defined(JSON_HEDLEY_C_DECL)
    #undef JSON_HEDLEY_C_DECL
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
    #define JSON_HEDLEY_END_C_DECLS }
    #define JSON_HEDLEY_C_DECL extern "C"
#else
    #define JSON_HEDLEY_BEGIN_C_DECLS
    #define JSON_HEDLEY_END_C_DECLS
    #define JSON_HEDLEY_C_DECL
#endif

#if defined(JSON_HEDLEY_STATIC_ASSERT)
    #undef JSON_HEDLEY_STATIC_ASSERT
#endif
#if \
  !defined(__cplusplus) && ( \
      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
      JSON_HEDLEY_HAS_FEATURE(c_static_assert) || \
      JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
      defined(_Static_assert) \
    )
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
#elif \
  (defined(__cplusplus) && (__cplusplus >= 201703L)) || \
  JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
  (defined(__cplusplus) && JSON_HEDLEY_TI_VERSION_CHECK(8,3,0))
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) static_assert(expr, message)
#elif defined(__cplusplus) && (__cplusplus >= 201103L)
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) static_assert(expr)
#else
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
#endif

#if defined(JSON_HEDLEY_CONST_CAST)
    #undef JSON_HEDLEY_CONST_CAST
#endif
#if defined(__cplusplus)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
#elif \
  JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_REINTERPRET_CAST)
    #undef JSON_HEDLEY_REINTERPRET_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
#else
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (*((T*) &(expr)))
#endif

#if defined(JSON_HEDLEY_STATIC_CAST)
    #undef JSON_HEDLEY_STATIC_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
#else
    #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_CPP_CAST)
    #undef JSON_HEDLEY_CPP_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_CPP_CAST(T, expr) static_cast<T>(expr)
#else
    #define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
#endif

#if defined(JSON_HEDLEY_MESSAGE)
    #undef JSON_HEDLEY_MESSAGE
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_MESSAGE(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(message msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
#elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_WARNING)
    #undef JSON_HEDLEY_WARNING
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_WARNING(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(clang warning msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_REQUIRE_MSG)
    #undef JSON_HEDLEY_REQUIRE_MSG
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
#  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
#    define JSON_HEDLEY_REQUIRE_MSG(expr, msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((__diagnose_if__(!(expr), msg, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_REQUIRE_MSG(expr, msg) __attribute__((__diagnose_if__(!(expr), msg, "error")))
#  endif
#else
#  define JSON_HEDLEY_REQUIRE_MSG(expr, msg)
#endif

#if defined(JSON_HEDLEY_REQUIRE)
    #undef JSON_HEDLEY_REQUIRE
#endif
#define JSON_HEDLEY_REQUIRE(expr) JSON_HEDLEY_REQUIRE_MSG(expr, #expr)

#if defined(JSON_HEDLEY_FLAGS)
    #undef JSON_HEDLEY_FLAGS
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum)
    #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
#endif

#if defined(JSON_HEDLEY_FLAGS_CAST)
    #undef JSON_HEDLEY_FLAGS_CAST
#endif
#if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        _Pragma("warning(disable:188)") \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
#endif

/* Remaining macros are deprecated. */

#if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
#else
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
    #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#endif
#define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)

#if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
    #undef JSON_HEDLEY_CLANG_HAS_FEATURE
#endif
#define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)

#if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
    #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#endif
#define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)

#if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
    #undef JSON_HEDLEY_CLANG_HAS_WARNING
#endif
#define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)

#endif /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */


// This file contains all internal macro definitions
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
    #if defined(__clang__)
        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #endif
#endif

// C++ language standard detection
#if (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
    #define JSON_HAS_CPP_17
    #define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
    #define JSON_HAS_CPP_14
#endif

// disable float-equal warnings on GCC/clang
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wfloat-equal"
#endif

// disable documentation warnings on clang
#if defined(__clang__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wdocumentation"
#endif

// allow to disable exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
    #define JSON_THROW(exception) throw exception
    #define JSON_TRY try
    #define JSON_CATCH(exception) catch(exception)
    #define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
    #include <cstdlib>
    #define JSON_THROW(exception) std::abort()
    #define JSON_TRY if(true)
    #define JSON_CATCH(exception) if(false)
    #define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
    #undef JSON_THROW
    #define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
    #undef JSON_TRY
    #define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
    #undef JSON_CATCH
    #define JSON_CATCH JSON_CATCH_USER
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

/*!
@brief macro to briefly define a mapping between an enum and JSON
@def NLOHMANN_JSON_SERIALIZE_ENUM
@since version 3.4.0
*/
#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                           \
    template<typename BasicJsonType>                                                           \
    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                  \
    {                                                                                          \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");         \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                    \
        auto it = std::find_if(std::begin(m), std::end(m),                                     \
                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                      \
            return ej_pair.first == e;                                                         \
        });                                                                                    \
        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                \
    }                                                                                          \
    template<typename BasicJsonType>                                                           \
    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                \
    {                                                                                          \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");         \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                    \
        auto it = std::find_if(std::begin(m), std::end(m),                                     \
                               [j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                      \
            return ej_pair.second == j;                                                        \
        });                                                                                    \
        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                 \
    }

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer>


namespace nlohmann
{
namespace detail
{
////////////////
// exceptions //
////////////////

/*!
@brief general exception of the @ref basic_json class

This class is an extension of `std::exception` objects with a member @a id for
exception ids. It is used as the base class for all exceptions thrown by the
@ref basic_json class. This class can hence be used as "wildcard" to catch
exceptions.

Subclasses:
- @ref parse_error for exceptions indicating a parse error
- @ref invalid_iterator for exceptions indicating errors with iterators
- @ref type_error for exceptions indicating executing a member function with
                  a wrong type
- @ref out_of_range for exceptions indicating access out of the defined range
- @ref other_error for exceptions indicating other library errors

@internal
@note To have nothrow-copy-constructible exceptions, we internally use
      `std::runtime_error` which can cope with arbitrary-length error messages.
      Intermediate strings are built with static functions and then passed to
      the actual constructor.
@endinternal

@liveexample{The following code shows how arbitrary library exceptions can be
caught.,exception}

@since version 3.0.0
*/
class exception : public std::exception
{
  public:
    /// returns the explanatory string
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* what() const noexcept override
    {
        return m.what();
    }

    /// the id of the exception
    const int id;

  protected:
    JSON_HEDLEY_NON_NULL(3)
    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}

    static std::string name(const std::string& ename, int id_)
    {
        return "[json.exception." + ename + "." + std::to_string(id_) + "] ";
    }

  private:
    /// an exception object as storage for error messages
    std::runtime_error m;
};

/*!
@brief exception indicating a parse error

This exception is thrown by the library when a parse error occurs. Parse errors
can occur during the deserialization of JSON text, CBOR, MessagePack, as well
as when using JSON Patch.

Member @a byte holds the byte index of the last read character in the input
file.

Exceptions have ids 1xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.
json.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\uxxxx` entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.
json.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.
json.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.
json.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.
json.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.
json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
json.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.
json.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.
json.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.
json.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.
json.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.
json.exception.parse_error.114 | parse error: Unsupported BSON record type 0x0F | The parsing of the corresponding BSON record type is not implemented (yet).

@note For an input with n bytes, 1 is the index of the first character and n+1
      is the index of the terminating null byte or the end of file. This also
      holds true when reading a byte vector (CBOR or MessagePack).

@liveexample{The following code shows how a `parse_error` exception can be
caught.,parse_error}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class parse_error : public exception
{
  public:
    /*!
    @brief create a parse error exception
    @param[in] id_       the id of the exception
    @param[in] pos       the position where the error occurred (or with
                         chars_read_total=0 if the position cannot be
                         determined)
    @param[in] what_arg  the explanatory string
    @return parse_error object
    */
    static parse_error create(int id_, const position_t& pos, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        position_string(pos) + ": " + what_arg;
        return parse_error(id_, pos.chars_read_total, w.c_str());
    }

    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        (byte_ != 0 ? (" at byte " + std::to_string(byte_)) : "") +
                        ": " + what_arg;
        return parse_error(id_, byte_, w.c_str());
    }

    /*!
    @brief byte index of the parse error

    The byte index of the last read character in the input file.

    @note For an input with n bytes, 1 is the index of the first character and
          n+1 is the index of the terminating null byte or the end of file.
          This also holds true when reading a byte vector (CBOR or MessagePack).
    */
    const std::size_t byte;

  private:
    parse_error(int id_, std::size_t byte_, const char* what_arg)
        : exception(id_, what_arg), byte(byte_) {}

    static std::string position_string(const position_t& pos)
    {
        return " at line " + std::to_string(pos.lines_read + 1) +
               ", column " + std::to_string(pos.chars_read_current_line);
    }
};

/*!
@brief exception indicating errors with iterators

This exception is thrown if iterators passed to a library function do not match
the expected semantics.

Exceptions have ids 2xx.

name / id                           | example message | description
----------------------------------- | --------------- | -------------------------
json.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.
json.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.
json.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.
json.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.
json.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.
json.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.
json.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.
json.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.
json.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.
json.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().

@liveexample{The following code shows how an `invalid_iterator` exception can be
caught.,invalid_iterator}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class invalid_iterator : public exception
{
  public:
    static invalid_iterator create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("invalid_iterator", id_) + what_arg;
        return invalid_iterator(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    invalid_iterator(int id_, const char* what_arg)
        : exception(id_, what_arg) {}
};

/*!
@brief exception indicating executing a member function with a wrong type

This exception is thrown in case of a type error; that is, a library function is
executed on a JSON value whose type does not match the expected semantics.

Exceptions have ids 3xx.

name / id                     | example message | description
----------------------------- | --------------- | -------------------------
json.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.
json.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.
json.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref basic_json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t &.
json.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.
json.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.
json.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.
json.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.
json.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.
json.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.
json.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.
json.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.
json.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.
json.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.
json.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.
json.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.
json.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |
json.exception.type_error.317 | JSON value cannot be serialized to requested format | The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw `true` or `null` JSON object cannot be serialized to BSON) |

@liveexample{The following code shows how a `type_error` exception can be
caught.,type_error}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class type_error : public exception
{
  public:
    static type_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("type_error", id_) + what_arg;
        return type_error(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating access out of the defined range

This exception is thrown in case a library function is called on an input
parameter that exceeds the expected range, for instance in case of array
indices or nonexisting object keys.

Exceptions have ids 4xx.

name / id                       | example message | description
------------------------------- | --------------- | -------------------------
json.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.
json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
json.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.
json.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.
json.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.
json.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.
json.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON and BSON only support integer numbers up to 9223372036854775807. |
json.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |
json.exception.out_of_range.409 | BSON key cannot contain code point U+0000 (at byte 2) | Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string |

@liveexample{The following code shows how an `out_of_range` exception can be
caught.,out_of_range}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class out_of_range : public exception
{
  public:
    static out_of_range create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("out_of_range", id_) + what_arg;
        return out_of_range(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating other library errors

This exception is thrown in case of errors that cannot be classified with the
other exception types.

Exceptions have ids 5xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.other_error.501 | unsuccessful: {"op":"test","path":"/baz", "value":"bar"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range

@liveexample{The following code shows how an `other_error` exception can be
caught.,other_error}

@since version 3.0.0
*/
class other_error : public exception
{
  public:
    static other_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("other_error", id_) + what_arg;
        return other_error(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>


#include <ciso646> // not
#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type

namespace nlohmann
{
namespace detail
{
// alias templates to reduce boilerplate
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

template<typename T>
using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

// implementation of C++14 index_sequence and affiliates
// source: https://stackoverflow.com/a/32223343
template<std::size_t... Ints>
struct index_sequence
{
    using type = index_sequence;
    using value_type = std::size_t;
    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Ints);
    }
};

template<class Sequence1, class Sequence2>
struct merge_and_renumber;

template<std::size_t... I1, std::size_t... I2>
struct merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
        : index_sequence < I1..., (sizeof...(I1) + I2)... > {};

template<std::size_t N>
struct make_index_sequence
    : merge_and_renumber < typename make_index_sequence < N / 2 >::type,
      typename make_index_sequence < N - N / 2 >::type > {};

template<> struct make_index_sequence<0> : index_sequence<> {};
template<> struct make_index_sequence<1> : index_sequence<0> {};

template<typename... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

// dispatch utility (taken from ranges-v3)
template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
template<> struct priority_tag<0> {};

// taken from ranges-v3
template<typename T>
struct static_const
{
    static constexpr T value{};
};

template<typename T>
constexpr T static_const<T>::value;
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/meta/type_traits.hpp>


#include <ciso646> // not
#include <limits> // numeric_limits
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval

// #include <nlohmann/detail/iterators/iterator_traits.hpp>


#include <iterator> // random_access_iterator_tag

// #include <nlohmann/detail/meta/void_t.hpp>


namespace nlohmann
{
namespace detail
{
template <typename ...Ts> struct make_void
{
    using type = void;
};
template <typename ...Ts> using void_t = typename make_void<Ts...>::type;
} // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/meta/cpp_future.hpp>


namespace nlohmann
{
namespace detail
{
template <typename It, typename = void>
struct iterator_types {};

template <typename It>
struct iterator_types <
    It,
    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
    typename It::reference, typename It::iterator_category >>
{
    using difference_type = typename It::difference_type;
    using value_type = typename It::value_type;
    using pointer = typename It::pointer;
    using reference = typename It::reference;
    using iterator_category = typename It::iterator_category;
};

// This is required as some compilers implement std::iterator_traits in a way that
// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.
template <typename T, typename = void>
struct iterator_traits
{
};

template <typename T>
struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
            : iterator_types<T>
{
};

template <typename T>
struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
{
    using iterator_category = std::random_access_iterator_tag;
    using value_type = T;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using reference = T&;
};
} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>


#include <type_traits>

// #include <nlohmann/detail/meta/void_t.hpp>


// http://en.cppreference.com/w/cpp/experimental/is_detected
namespace nlohmann
{
namespace detail
{
struct nonesuch
{
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    nonesuch(nonesuch const&&) = delete;
    void operator=(nonesuch const&) = delete;
    void operator=(nonesuch&&) = delete;
};

template <class Default,
          class AlwaysVoid,
          template <class...> class Op,
          class... Args>
struct detector
{
    using value_t = std::false_type;
    using type = Default;
};

template <class Default, template <class...> class Op, class... Args>
struct detector<Default, void_t<Op<Args...>>, Op, Args...>
{
    using value_t = std::true_type;
    using type = Op<Args...>;
};

template <template <class...> class Op, class... Args>
using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

template <template <class...> class Op, class... Args>
using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

template <class Default, template <class...> class Op, class... Args>
using detected_or = detector<Default, void, Op, Args...>;

template <class Default, template <class...> class Op, class... Args>
using detected_or_t = typename detected_or<Default, Op, Args...>::type;

template <class Expected, template <class...> class Op, class... Args>
using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

template <class To, template <class...> class Op, class... Args>
using is_detected_convertible =
    std::is_convertible<detected_t<Op, Args...>, To>;
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/json_fwd.hpp>
#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
#define INCLUDE_NLOHMANN_JSON_FWD_HPP_

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{
/*!
@brief default JSONSerializer template argument

This serializer ignores the template arguments and uses ADL
([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
for serialization.
*/
template<typename T = void, typename SFINAE = void>
struct adl_serializer;

template<template<typename U, typename V, typename... Args> class ObjectType =
         std::map,
         template<typename U, typename... Args> class ArrayType = std::vector,
         class StringType = std::string, class BooleanType = bool,
         class NumberIntegerType = std::int64_t,
         class NumberUnsignedType = std::uint64_t,
         class NumberFloatType = double,
         template<typename U> class AllocatorType = std::allocator,
         template<typename T, typename SFINAE = void> class JSONSerializer =
         adl_serializer>
class basic_json;

/*!
@brief JSON Pointer

A JSON pointer defines a string syntax for identifying a specific value
within a JSON document. It can be used with functions `at` and
`operator[]`. Furthermore, JSON pointers are the base for JSON patches.

@sa [RFC 6901](https://tools.ietf.org/html/rfc6901)

@since version 2.0.0
*/
template<typename BasicJsonType>
class json_pointer;

/*!
@brief default JSON class

This type is the default specialization of the @ref basic_json class which
uses the standard template types.

@since version 1.0.0
*/
using json = basic_json<>;
}  // namespace nlohmann

#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_


namespace nlohmann
{
/*!
@brief detail namespace with internal helper functions

This namespace collects functions that should not be exposed,
implementations of some @ref basic_json methods, and meta-programming helpers.

@since version 2.1.0
*/
namespace detail
{
/////////////
// helpers //
/////////////

// Note to maintainers:
//
// Every trait in this file expects a non CV-qualified type.
// The only exceptions are in the 'aliases for detected' section
// (i.e. those of the form: decltype(T::member_function(std::declval<T>())))
//
// In this case, T has to be properly CV-qualified to constraint the function arguments
// (e.g. to_json(BasicJsonType&, const T&))

template<typename> struct is_basic_json : std::false_type {};

NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

//////////////////////////
// aliases for detected //
//////////////////////////

template <typename T>
using mapped_type_t = typename T::mapped_type;

template <typename T>
using key_type_t = typename T::key_type;

template <typename T>
using value_type_t = typename T::value_type;

template <typename T>
using difference_type_t = typename T::difference_type;

template <typename T>
using pointer_t = typename T::pointer;

template <typename T>
using reference_t = typename T::reference;

template <typename T>
using iterator_category_t = typename T::iterator_category;

template <typename T>
using iterator_t = typename T::iterator;

template <typename T, typename... Args>
using to_json_function = decltype(T::to_json(std::declval<Args>()...));

template <typename T, typename... Args>
using from_json_function = decltype(T::from_json(std::declval<Args>()...));

template <typename T, typename U>
using get_template_function = decltype(std::declval<T>().template get<U>());

// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
template <typename BasicJsonType, typename T, typename = void>
struct has_from_json : std::false_type {};

template <typename BasicJsonType, typename T>
struct has_from_json<BasicJsonType, T,
           enable_if_t<not is_basic_json<T>::value>>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, from_json_function, serializer,
        const BasicJsonType&, T&>::value;
};

// This trait checks if JSONSerializer<T>::from_json(json const&) exists
// this overload is used for non-default-constructible user-defined-types
template <typename BasicJsonType, typename T, typename = void>
struct has_non_default_from_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_non_default_from_json<BasicJsonType, T, enable_if_t<not is_basic_json<T>::value>>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<T, from_json_function, serializer,
        const BasicJsonType&>::value;
};

// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
template <typename BasicJsonType, typename T, typename = void>
struct has_to_json : std::false_type {};

template <typename BasicJsonType, typename T>
struct has_to_json<BasicJsonType, T, enable_if_t<not is_basic_json<T>::value>>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
        T>::value;
};


///////////////////
// is_ functions //
///////////////////

template <typename T, typename = void>
struct is_iterator_traits : std::false_type {};

template <typename T>
struct is_iterator_traits<iterator_traits<T>>
{
  private:
    using traits = iterator_traits<T>;

  public:
    static constexpr auto value =
        is_detected<value_type_t, traits>::value &&
        is_detected<difference_type_t, traits>::value &&
        is_detected<pointer_t, traits>::value &&
        is_detected<iterator_category_t, traits>::value &&
        is_detected<reference_t, traits>::value;
};

// source: https://stackoverflow.com/a/37193089/4116453

template <typename T, typename = void>
struct is_complete_type : std::false_type {};

template <typename T>
struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

template <typename BasicJsonType, typename CompatibleObjectType,
          typename = void>
struct is_compatible_object_type_impl : std::false_type {};

template <typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type_impl <
    BasicJsonType, CompatibleObjectType,
    enable_if_t<is_detected<mapped_type_t, CompatibleObjectType>::value and
    is_detected<key_type_t, CompatibleObjectType>::value >>
{

    using object_t = typename BasicJsonType::object_t;

    // macOS's is_constructible does not play well with nonesuch...
    static constexpr bool value =
        std::is_constructible<typename object_t::key_type,
        typename CompatibleObjectType::key_type>::value and
        std::is_constructible<typename object_t::mapped_type,
        typename CompatibleObjectType::mapped_type>::value;
};

template <typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type
    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

template <typename BasicJsonType, typename ConstructibleObjectType,
          typename = void>
struct is_constructible_object_type_impl : std::false_type {};

template <typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type_impl <
    BasicJsonType, ConstructibleObjectType,
    enable_if_t<is_detected<mapped_type_t, ConstructibleObjectType>::value and
    is_detected<key_type_t, ConstructibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    static constexpr bool value =
        (std::is_default_constructible<ConstructibleObjectType>::value and
         (std::is_move_assignable<ConstructibleObjectType>::value or
          std::is_copy_assignable<ConstructibleObjectType>::value) and
         (std::is_constructible<typename ConstructibleObjectType::key_type,
          typename object_t::key_type>::value and
          std::is_same <
          typename object_t::mapped_type,
          typename ConstructibleObjectType::mapped_type >::value)) or
        (has_from_json<BasicJsonType,
         typename ConstructibleObjectType::mapped_type>::value or
         has_non_default_from_json <
         BasicJsonType,
         typename ConstructibleObjectType::mapped_type >::value);
};

template <typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type
    : is_constructible_object_type_impl<BasicJsonType,
      ConstructibleObjectType> {};

template <typename BasicJsonType, typename CompatibleStringType,
          typename = void>
struct is_compatible_string_type_impl : std::false_type {};

template <typename BasicJsonType, typename CompatibleStringType>
struct is_compatible_string_type_impl <
    BasicJsonType, CompatibleStringType,
    enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
    value_type_t, CompatibleStringType>::value >>
{
    static constexpr auto value =
        std::is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
};

template <typename BasicJsonType, typename ConstructibleStringType>
struct is_compatible_string_type
    : is_compatible_string_type_impl<BasicJsonType, ConstructibleStringType> {};

template <typename BasicJsonType, typename ConstructibleStringType,
          typename = void>
struct is_constructible_string_type_impl : std::false_type {};

template <typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type_impl <
    BasicJsonType, ConstructibleStringType,
    enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
    value_type_t, ConstructibleStringType>::value >>
{
    static constexpr auto value =
        std::is_constructible<ConstructibleStringType,
        typename BasicJsonType::string_t>::value;
};

template <typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type
    : is_constructible_string_type_impl<BasicJsonType, ConstructibleStringType> {};

template <typename BasicJsonType, typename CompatibleArrayType, typename = void>
struct is_compatible_array_type_impl : std::false_type {};

template <typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type_impl <
    BasicJsonType, CompatibleArrayType,
    enable_if_t<is_detected<value_type_t, CompatibleArrayType>::value and
    is_detected<iterator_t, CompatibleArrayType>::value and
// This is needed because json_reverse_iterator has a ::iterator type...
// Therefore it is detected as a CompatibleArrayType.
// The real fix would be to have an Iterable concept.
    not is_iterator_traits<
    iterator_traits<CompatibleArrayType>>::value >>
{
    static constexpr bool value =
        std::is_constructible<BasicJsonType,
        typename CompatibleArrayType::value_type>::value;
};

template <typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type
    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

template <typename BasicJsonType, typename ConstructibleArrayType, typename = void>
struct is_constructible_array_type_impl : std::false_type {};

template <typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value >>
            : std::true_type {};

template <typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<not std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value and
    std::is_default_constructible<ConstructibleArrayType>::value and
(std::is_move_assignable<ConstructibleArrayType>::value or
 std::is_copy_assignable<ConstructibleArrayType>::value) and
is_detected<value_type_t, ConstructibleArrayType>::value and
is_detected<iterator_t, ConstructibleArrayType>::value and
is_complete_type<
detected_t<value_type_t, ConstructibleArrayType>>::value >>
{
    static constexpr bool value =
        // This is needed because json_reverse_iterator has a ::iterator type,
        // furthermore, std::back_insert_iterator (and other iterators) have a
        // base class `iterator`... Therefore it is detected as a
        // ConstructibleArrayType. The real fix would be to have an Iterable
        // concept.
        not is_iterator_traits<iterator_traits<ConstructibleArrayType>>::value and

        (std::is_same<typename ConstructibleArrayType::value_type,
         typename BasicJsonType::array_t::value_type>::value or
         has_from_json<BasicJsonType,
         typename ConstructibleArrayType::value_type>::value or
         has_non_default_from_json <
         BasicJsonType, typename ConstructibleArrayType::value_type >::value);
};

template <typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type
    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};

template <typename RealIntegerType, typename CompatibleNumberIntegerType,
          typename = void>
struct is_compatible_integer_type_impl : std::false_type {};

template <typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type_impl <
    RealIntegerType, CompatibleNumberIntegerType,
    enable_if_t<std::is_integral<RealIntegerType>::value and
    std::is_integral<CompatibleNumberIntegerType>::value and
    not std::is_same<bool, CompatibleNumberIntegerType>::value >>
{
    // is there an assert somewhere on overflows?
    using RealLimits = std::numeric_limits<RealIntegerType>;
    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

    static constexpr auto value =
        std::is_constructible<RealIntegerType,
        CompatibleNumberIntegerType>::value and
        CompatibleLimits::is_integer and
        RealLimits::is_signed == CompatibleLimits::is_signed;
};

template <typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type
    : is_compatible_integer_type_impl<RealIntegerType,
      CompatibleNumberIntegerType> {};

template <typename BasicJsonType, typename CompatibleType, typename = void>
struct is_compatible_type_impl: std::false_type {};

template <typename BasicJsonType, typename CompatibleType>
struct is_compatible_type_impl <
    BasicJsonType, CompatibleType,
    enable_if_t<is_complete_type<CompatibleType>::value >>
{
    static constexpr bool value =
        has_to_json<BasicJsonType, CompatibleType>::value;
};

template <typename BasicJsonType, typename CompatibleType>
struct is_compatible_type
    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>


#include <array> // array
#include <ciso646> // and
#include <cstddef> // size_t
#include <cstdint> // uint8_t
#include <string> // string

namespace nlohmann
{
namespace detail
{
///////////////////////////
// JSON type enumeration //
///////////////////////////

/*!
@brief the JSON type enumeration

This enumeration collects the different JSON types. It is internally used to
distinguish the stored values, and the functions @ref basic_json::is_null(),
@ref basic_json::is_object(), @ref basic_json::is_array(),
@ref basic_json::is_string(), @ref basic_json::is_boolean(),
@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
@ref basic_json::is_structured() rely on it.

@note There are three enumeration entries (number_integer, number_unsigned, and
number_float), because the library distinguishes these three types for numbers:
@ref basic_json::number_unsigned_t is used for unsigned integers,
@ref basic_json::number_integer_t is used for signed integers, and
@ref basic_json::number_float_t is used for floating-point numbers or to
approximate integers which do not fit in the limits of their respective type.

@sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
value with the default value for a given type

@since version 1.0.0
*/
enum class value_t : std::uint8_t
{
    null,             ///< null value
    object,           ///< object (unordered set of name/value pairs)
    array,            ///< array (ordered collection of values)
    string,           ///< string value
    boolean,          ///< boolean value
    number_integer,   ///< number value (signed integer)
    number_unsigned,  ///< number value (unsigned integer)
    number_float,     ///< number value (floating-point)
    discarded         ///< discarded by the the parser callback function
};

/*!
@brief comparison operator for JSON types

Returns an ordering that is similar to Python:
- order: null < boolean < number < object < array < string
- furthermore, each type is not smaller than itself
- discarded values are not comparable

@since version 1.0.0
*/
inline bool operator<(const value_t lhs, const value_t rhs) noexcept
{
    static constexpr std::array<std::uint8_t, 8> order = {{
            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */
        }
    };

    const auto l_index = static_cast<std::size_t>(lhs);
    const auto r_index = static_cast<std::size_t>(rhs);
    return l_index < order.size() and r_index < order.size() and order[l_index] < order[r_index];
}
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_null()))
    {
        JSON_THROW(type_error::create(302, "type must be null, but is " + std::string(j.type_name())));
    }
    n = nullptr;
}

// overloads for basic_json template parameters
template<typename BasicJsonType, typename ArithmeticType,
         enable_if_t<std::is_arithmetic<ArithmeticType>::value and
                     not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
                     int> = 0>
void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_boolean()))
    {
        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(j.type_name())));
    }
    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }
    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template <
    typename BasicJsonType, typename ConstructibleStringType,
    enable_if_t <
        is_constructible_string_type<BasicJsonType, ConstructibleStringType>::value and
        not std::is_same<typename BasicJsonType::string_t,
                         ConstructibleStringType>::value,
        int > = 0 >
void from_json(const BasicJsonType& j, ConstructibleStringType& s)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }

    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void from_json(const BasicJsonType& j, EnumType& e)
{
    typename std::underlying_type<EnumType>::type val;
    get_arithmetic_value(j, val);
    e = static_cast<EnumType>(val);
}

// forward_list doesn't have an insert method
template<typename BasicJsonType, typename T, typename Allocator,
         enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    l.clear();
    std::transform(j.rbegin(), j.rend(),
                   std::front_inserter(l), [](const BasicJsonType & i)
    {
        return i.template get<T>();
    });
}

// valarray doesn't have an insert method
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::valarray<T>& l)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    l.resize(j.size());
    std::copy(j.m_value.array->begin(), j.m_value.array->end(), std::begin(l));
}

template <typename BasicJsonType, typename T, std::size_t N>
auto from_json(const BasicJsonType& j, T (&arr)[N])
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType>
void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
{
    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
}

template <typename BasicJsonType, typename T, std::size_t N>
auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
                          priority_tag<2> /*unused*/)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename ConstructibleArrayType>
auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)
-> decltype(
    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
    j.template get<typename ConstructibleArrayType::value_type>(),
    void())
{
    using std::end;

    ConstructibleArrayType ret;
    ret.reserve(j.size());
    std::transform(j.begin(), j.end(),
                   std::inserter(ret, end(ret)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template <typename BasicJsonType, typename ConstructibleArrayType>
void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
                          priority_tag<0> /*unused*/)
{
    using std::end;

    ConstructibleArrayType ret;
    std::transform(
        j.begin(), j.end(), std::inserter(ret, end(ret)),
        [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template <typename BasicJsonType, typename ConstructibleArrayType,
          enable_if_t <
              is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value and
              not is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value and
              not is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value and
              not is_basic_json<ConstructibleArrayType>::value,
              int > = 0 >

auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
j.template get<typename ConstructibleArrayType::value_type>(),
void())
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " +
                                      std::string(j.type_name())));
    }

    from_json_array_impl(j, arr, priority_tag<3> {});
}

template<typename BasicJsonType, typename ConstructibleObjectType,
         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_object()))
    {
        JSON_THROW(type_error::create(302, "type must be object, but is " + std::string(j.type_name())));
    }

    ConstructibleObjectType ret;
    auto inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
    using value_type = typename ConstructibleObjectType::value_type;
    std::transform(
        inner_object->begin(), inner_object->end(),
        std::inserter(ret, ret.begin()),
        [](typename BasicJsonType::object_t::value_type const & p)
    {
        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
    });
    obj = std::move(ret);
}

// overload for arithmetic types, not chosen for basic_json template arguments
// (BooleanType, etc..); note: Is it really necessary to provide explicit
// overloads for boolean_t etc. in case of a custom BooleanType which is not
// an arithmetic type?
template<typename BasicJsonType, typename ArithmeticType,
         enable_if_t <
             std::is_arithmetic<ArithmeticType>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
             int> = 0>
void from_json(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }
        case value_t::boolean:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType, typename A1, typename A2>
void from_json(const BasicJsonType& j, std::pair<A1, A2>& p)
{
    p = {j.at(0).template get<A1>(), j.at(1).template get<A2>()};
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void from_json_tuple_impl(const BasicJsonType& j, Tuple& t, index_sequence<Idx...> /*unused*/)
{
    t = std::make_tuple(j.at(Idx).template get<typename std::tuple_element<Idx, Tuple>::type>()...);
}

template<typename BasicJsonType, typename... Args>
void from_json(const BasicJsonType& j, std::tuple<Args...>& t)
{
    from_json_tuple_impl(j, t, index_sequence_for<Args...> {});
}

template <typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
          typename = enable_if_t<not std::is_constructible<
                                     typename BasicJsonType::string_t, Key>::value>>
void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(not p.is_array()))
        {
            JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

template <typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
          typename = enable_if_t<not std::is_constructible<
                                     typename BasicJsonType::string_t, Key>::value>>
void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(not p.is_array()))
        {
            JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

struct from_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(const BasicJsonType& j, T& val) const
    noexcept(noexcept(from_json(j, val)))
    -> decltype(from_json(j, val), void())
    {
        return from_json(j, val);
    }
};
}  // namespace detail

/// namespace to hold default `from_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace
{
constexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value;
} // namespace
} // namespace nlohmann

// #include <nlohmann/detail/conversions/to_json.hpp>


#include <algorithm> // copy
#include <ciso646> // or, and, not
#include <iterator> // begin, end
#include <string> // string
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>


#include <cstddef> // size_t
#include <iterator> // input_iterator_tag
#include <string> // string, to_string
#include <tuple> // tuple_size, get, tuple_element

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
template <typename IteratorType> class iteration_proxy_value
{
  public:
    using difference_type = std::ptrdiff_t;
    using value_type = iteration_proxy_value;
    using pointer = value_type * ;
    using reference = value_type & ;
    using iterator_category = std::input_iterator_tag;

  private:
    /// the iterator
    IteratorType anchor;
    /// an index for arrays (used to create key names)
    std::size_t array_index = 0;
    /// last stringified array index
    mutable std::size_t array_index_last = 0;
    /// a string representation of the array index
    mutable std::string array_index_str = "0";
    /// an empty string (to return a reference for primitive values)
    const std::string empty_str = "";

  public:
    explicit iteration_proxy_value(IteratorType it) noexcept : anchor(it) {}

    /// dereference operator (needed for range-based for)
    iteration_proxy_value& operator*()
    {
        return *this;
    }

    /// increment operator (needed for range-based for)
    iteration_proxy_value& operator++()
    {
        ++anchor;
        ++array_index;

        return *this;
    }

    /// equality operator (needed for InputIterator)
    bool operator==(const iteration_proxy_value& o) const
    {
        return anchor == o.anchor;
    }

    /// inequality operator (needed for range-based for)
    bool operator!=(const iteration_proxy_value& o) const
    {
        return anchor != o.anchor;
    }

    /// return key of the iterator
    const std::string& key() const
    {
        assert(anchor.m_object != nullptr);

        switch (anchor.m_object->type())
        {
            // use integer array index as key
            case value_t::array:
            {
                if (array_index != array_index_last)
                {
                    array_index_str = std::to_string(array_index);
                    array_index_last = array_index;
                }
                return array_index_str;
            }

            // use key from the object
            case value_t::object:
                return anchor.key();

            // use an empty key for all primitive types
            default:
                return empty_str;
        }
    }

    /// return value of the iterator
    typename IteratorType::reference value() const
    {
        return anchor.value();
    }
};

/// proxy class for the items() function
template<typename IteratorType> class iteration_proxy
{
  private:
    /// the container to iterate
    typename IteratorType::reference container;

  public:
    /// construct iteration proxy from a container
    explicit iteration_proxy(typename IteratorType::reference cont) noexcept
        : container(cont) {}

    /// return iterator begin (needed for range-based for)
    iteration_proxy_value<IteratorType> begin() noexcept
    {
        return iteration_proxy_value<IteratorType>(container.begin());
    }

    /// return iterator end (needed for range-based for)
    iteration_proxy_value<IteratorType> end() noexcept
    {
        return iteration_proxy_value<IteratorType>(container.end());
    }
};
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template <std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
{
    return i.key();
}
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template <std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
{
    return i.value();
}
}  // namespace detail
}  // namespace nlohmann

// The Addition to the STD Namespace is required to add
// Structured Bindings Support to the iteration_proxy_value class
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
namespace std
{
#if defined(__clang__)
    // Fix: https://github.com/nlohmann/json/issues/1401
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wmismatched-tags"
#endif
template <typename IteratorType>
class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>>
            : public std::integral_constant<std::size_t, 2> {};

template <std::size_t N, typename IteratorType>
class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >>
{
  public:
    using type = decltype(
                     get<N>(std::declval <
                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
};
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif
} // namespace std

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
//////////////////
// constructors //
//////////////////

template<value_t> struct external_constructor;

template<>
struct external_constructor<value_t::boolean>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
    {
        j.m_type = value_t::boolean;
        j.m_value = b;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::string>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
    {
        j.m_type = value_t::string;
        j.m_value = s;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
    {
        j.m_type = value_t::string;
        j.m_value = std::move(s);
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename CompatibleStringType,
             enable_if_t<not std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
                         int> = 0>
    static void construct(BasicJsonType& j, const CompatibleStringType& str)
    {
        j.m_type = value_t::string;
        j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_float>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
    {
        j.m_type = value_t::number_float;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_unsigned>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
    {
        j.m_type = value_t::number_unsigned;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_integer>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
    {
        j.m_type = value_t::number_integer;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::array>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
    {
        j.m_type = value_t::array;
        j.m_value = arr;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
    {
        j.m_type = value_t::array;
        j.m_value = std::move(arr);
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename CompatibleArrayType,
             enable_if_t<not std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                         int> = 0>
    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
    {
        using std::begin;
        using std::end;
        j.m_type = value_t::array;
        j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->reserve(arr.size());
        for (const bool x : arr)
        {
            j.m_value.array->push_back(x);
        }
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename T,
             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->resize(arr.size());
        std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::object>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
    {
        j.m_type = value_t::object;
        j.m_value = obj;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
    {
        j.m_type = value_t::object;
        j.m_value = std::move(obj);
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename CompatibleObjectType,
             enable_if_t<not std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int> = 0>
    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
    {
        using std::begin;
        using std::end;

        j.m_type = value_t::object;
        j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
        j.assert_invariant();
    }
};

/////////////
// to_json //
/////////////

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
void to_json(BasicJsonType& j, T b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, b);
}

template<typename BasicJsonType, typename CompatibleString,
         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
void to_json(BasicJsonType& j, const CompatibleString& s)
{
    external_constructor<value_t::string>::construct(j, s);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
{
    external_constructor<value_t::string>::construct(j, std::move(s));
}

template<typename BasicJsonType, typename FloatType,
         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
void to_json(BasicJsonType& j, FloatType val) noexcept
{
    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
{
    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberIntegerType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
{
    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void to_json(BasicJsonType& j, EnumType e) noexcept
{
    using underlying_type = typename std::underlying_type<EnumType>::type;
    external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, const std::vector<bool>& e)
{
    external_constructor<value_t::array>::construct(j, e);
}

template <typename BasicJsonType, typename CompatibleArrayType,
          enable_if_t<is_compatible_array_type<BasicJsonType,
                      CompatibleArrayType>::value and
                      not is_compatible_object_type<
                          BasicJsonType, CompatibleArrayType>::value and
                      not is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value and
                      not is_basic_json<CompatibleArrayType>::value,
                      int> = 0>
void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
void to_json(BasicJsonType& j, const std::valarray<T>& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType, typename CompatibleObjectType,
         enable_if_t<is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value and not is_basic_json<CompatibleObjectType>::value, int> = 0>
void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
{
    external_constructor<value_t::object>::construct(j, obj);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
{
    external_constructor<value_t::object>::construct(j, std::move(obj));
}

template <
    typename BasicJsonType, typename T, std::size_t N,
    enable_if_t<not std::is_constructible<typename BasicJsonType::string_t,
                const T(&)[N]>::value,
                int> = 0 >
void to_json(BasicJsonType& j, const T(&arr)[N])
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType, typename... Args>
void to_json(BasicJsonType& j, const std::pair<Args...>& p)
{
    j = { p.first, p.second };
}

// for https://github.com/nlohmann/json/pull/1134
template < typename BasicJsonType, typename T,
           enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
void to_json(BasicJsonType& j, const T& b)
{
    j = { {b.key(), b.value()} };
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)
{
    j = { std::get<Idx>(t)... };
}

template<typename BasicJsonType, typename... Args>
void to_json(BasicJsonType& j, const std::tuple<Args...>& t)
{
    to_json_tuple_impl(j, t, index_sequence_for<Args...> {});
}

struct to_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
    -> decltype(to_json(j, std::forward<T>(val)), void())
    {
        return to_json(j, std::forward<T>(val));
    }
};
}  // namespace detail

/// namespace to hold default `to_json` function
namespace
{
constexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value;
} // namespace
} // namespace nlohmann


namespace nlohmann
{

template<typename, typename>
struct adl_serializer
{
    /*!
    @brief convert a JSON value to any value type

    This function is usually called by the `get()` function of the
    @ref basic_json class (either explicit or via conversion operators).

    @param[in] j        JSON value to read from
    @param[in,out] val  value to write to
    */
    template<typename BasicJsonType, typename ValueType>
    static auto from_json(BasicJsonType&& j, ValueType& val) noexcept(
        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
    {
        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
    }

    /*!
    @brief convert any value type to a JSON value

    This function is usually called by the constructors of the @ref basic_json
    class.

    @param[in,out] j  JSON value to write to
    @param[in] val    value to read from
    */
    template <typename BasicJsonType, typename ValueType>
    static auto to_json(BasicJsonType& j, ValueType&& val) noexcept(
        noexcept(::nlohmann::to_json(j, std::forward<ValueType>(val))))
    -> decltype(::nlohmann::to_json(j, std::forward<ValueType>(val)), void())
    {
        ::nlohmann::to_json(j, std::forward<ValueType>(val));
    }
};

}  // namespace nlohmann

// #include <nlohmann/detail/conversions/from_json.hpp>

// #include <nlohmann/detail/conversions/to_json.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/binary_reader.hpp>


#include <algorithm> // generate_n
#include <array> // array
#include <cassert> // assert
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>


#include <array> // array
#include <cassert> // assert
#include <cstddef> // size_t
#include <cstdio> //FILE *
#include <cstring> // strlen
#include <istream> // istream
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

// #include <nlohmann/detail/iterators/iterator_traits.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
/// the supported input formats
enum class input_format_t { json, cbor, msgpack, ubjson, bson };

////////////////////
// input adapters //
////////////////////

/*!
@brief abstract input adapter interface

Produces a stream of std::char_traits<char>::int_type characters from a
std::istream, a buffer, or some other input type. Accepts the return of
exactly one non-EOF character for future input. The int_type characters
returned consist of all valid char values as positive values (typically
unsigned char), plus an EOF value outside that range, specified by the value
of the function std::char_traits<char>::eof(). This value is typically -1, but
could be any arbitrary value which is not a valid char value.
*/
struct input_adapter_protocol
{
    /// get a character [0,255] or std::char_traits<char>::eof().
    virtual std::char_traits<char>::int_type get_character() = 0;
    virtual ~input_adapter_protocol() = default;
};

/// a type to simplify interfaces
using input_adapter_t = std::shared_ptr<input_adapter_protocol>;

/*!
Input adapter for stdio file access. This adapter read only 1 byte and do not use any
 buffer. This adapter is a very low level adapter.
*/
class file_input_adapter : public input_adapter_protocol
{
  public:
    JSON_HEDLEY_NON_NULL(2)
    explicit file_input_adapter(std::FILE* f)  noexcept
        : m_file(f)
    {}

    // make class move-only
    file_input_adapter(const file_input_adapter&) = delete;
    file_input_adapter(file_input_adapter&&) = default;
    file_input_adapter& operator=(const file_input_adapter&) = delete;
    file_input_adapter& operator=(file_input_adapter&&) = default;
    ~file_input_adapter() override = default;

    std::char_traits<char>::int_type get_character() noexcept override
    {
        return std::fgetc(m_file);
    }

  private:
    /// the file pointer to read from
    std::FILE* m_file;
};


/*!
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
beginning of input. Does not support changing the underlying std::streambuf
in mid-input. Maintains underlying std::istream and std::streambuf to support
subsequent use of standard std::istream operations to process any input
characters following those used in parsing the JSON input.  Clears the
std::istream flags; any input errors (e.g., EOF) will be detected by the first
subsequent call for input from the std::istream.
*/
class input_stream_adapter : public input_adapter_protocol
{
  public:
    ~input_stream_adapter() override
    {
        // clear stream flags; we use underlying streambuf I/O, do not
        // maintain ifstream flags, except eof
        is.clear(is.rdstate() & std::ios::eofbit);
    }

    explicit input_stream_adapter(std::istream& i)
        : is(i), sb(*i.rdbuf())
    {}

    // delete because of pointer members
    input_stream_adapter(const input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&) = delete;
    input_stream_adapter(input_stream_adapter&&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&&) = delete;

    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
    // end up as the same value, eg. 0xFFFFFFFF.
    std::char_traits<char>::int_type get_character() override
    {
        auto res = sb.sbumpc();
        // set eof manually, as we don't use the istream interface.
        if (res == EOF)
        {
            is.clear(is.rdstate() | std::ios::eofbit);
        }
        return res;
    }

  private:
    /// the associated input stream
    std::istream& is;
    std::streambuf& sb;
};

/// input adapter for buffer input
class input_buffer_adapter : public input_adapter_protocol
{
  public:
    JSON_HEDLEY_NON_NULL(2)
    input_buffer_adapter(const char* b, const std::size_t l) noexcept
        : cursor(b), limit(b + l)
    {}

    // delete because of pointer members
    input_buffer_adapter(const input_buffer_adapter&) = delete;
    input_buffer_adapter& operator=(input_buffer_adapter&) = delete;
    input_buffer_adapter(input_buffer_adapter&&) = delete;
    input_buffer_adapter& operator=(input_buffer_adapter&&) = delete;
    ~input_buffer_adapter() override = default;

    std::char_traits<char>::int_type get_character() noexcept override
    {
        if (JSON_HEDLEY_LIKELY(cursor < limit))
        {
            return std::char_traits<char>::to_int_type(*(cursor++));
        }

        return std::char_traits<char>::eof();
    }

  private:
    /// pointer to the current character
    const char* cursor;
    /// pointer past the last character
    const char* const limit;
};

template<typename WideStringType, size_t T>
struct wide_string_input_helper
{
    // UTF-32
    static void fill_buffer(const WideStringType& str,
                            size_t& current_wchar,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (current_wchar == str.size())
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = static_cast<unsigned int>(str[current_wchar++]);

            // UTF-32 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((wc >> 6u) & 0x1Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (wc <= 0xFFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((wc >> 12u) & 0x0Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((wc >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else if (wc <= 0x10FFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((wc >> 18u) & 0x07u));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((wc >> 12u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((wc >> 6u) & 0x3Fu));
                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 4;
            }
            else
            {
                // unknown character
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
        }
    }
};

template<typename WideStringType>
struct wide_string_input_helper<WideStringType, 2>
{
    // UTF-16
    static void fill_buffer(const WideStringType& str,
                            size_t& current_wchar,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (current_wchar == str.size())
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = static_cast<unsigned int>(str[current_wchar++]);

            // UTF-16 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((wc >> 6u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (0xD800 > wc or wc >= 0xE000)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((wc >> 12u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((wc >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else
            {
                if (current_wchar < str.size())
                {
                    const auto wc2 = static_cast<unsigned int>(str[current_wchar++]);
                    const auto charcode = 0x10000u + (((wc & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
                    utf8_bytes_filled = 4;
                }
                else
                {
                    // unknown character
                    ++current_wchar;
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                    utf8_bytes_filled = 1;
                }
            }
        }
    }
};

template<typename WideStringType>
class wide_string_input_adapter : public input_adapter_protocol
{
  public:
    explicit wide_string_input_adapter(const WideStringType& w) noexcept
        : str(w)
    {}

    std::char_traits<char>::int_type get_character() noexcept override
    {
        // check if buffer needs to be filled
        if (utf8_bytes_index == utf8_bytes_filled)
        {
            fill_buffer<sizeof(typename WideStringType::value_type)>();

            assert(utf8_bytes_filled > 0);
            assert(utf8_bytes_index == 0);
        }

        // use buffer
        assert(utf8_bytes_filled > 0);
        assert(utf8_bytes_index < utf8_bytes_filled);
        return utf8_bytes[utf8_bytes_index++];
    }

  private:
    template<size_t T>
    void fill_buffer()
    {
        wide_string_input_helper<WideStringType, T>::fill_buffer(str, current_wchar, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
    }

    /// the wstring to process
    const WideStringType& str;

    /// index of the current wchar in str
    std::size_t current_wchar = 0;

    /// a buffer for UTF-8 bytes
    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};

    /// index to the utf8_codes array for the next valid byte
    std::size_t utf8_bytes_index = 0;
    /// number of valid bytes in the utf8_codes array
    std::size_t utf8_bytes_filled = 0;
};

class input_adapter
{
  public:
    // native support
    JSON_HEDLEY_NON_NULL(2)
    input_adapter(std::FILE* file)
        : ia(std::make_shared<file_input_adapter>(file)) {}
    /// input adapter for input stream
    input_adapter(std::istream& i)
        : ia(std::make_shared<input_stream_adapter>(i)) {}

    /// input adapter for input stream
    input_adapter(std::istream&& i)
        : ia(std::make_shared<input_stream_adapter>(i)) {}

    input_adapter(const std::wstring& ws)
        : ia(std::make_shared<wide_string_input_adapter<std::wstring>>(ws)) {}

    input_adapter(const std::u16string& ws)
        : ia(std::make_shared<wide_string_input_adapter<std::u16string>>(ws)) {}

    input_adapter(const std::u32string& ws)
        : ia(std::make_shared<wide_string_input_adapter<std::u32string>>(ws)) {}

    /// input adapter for buffer
    template<typename CharT,
             typename std::enable_if<
                 std::is_pointer<CharT>::value and
                 std::is_integral<typename std::remove_pointer<CharT>::type>::value and
                 sizeof(typename std::remove_pointer<CharT>::type) == 1,
                 int>::type = 0>
    input_adapter(CharT b, std::size_t l)
        : ia(std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(b), l)) {}

    // derived support

    /// input adapter for string literal
    template<typename CharT,
             typename std::enable_if<
                 std::is_pointer<CharT>::value and
                 std::is_integral<typename std::remove_pointer<CharT>::type>::value and
                 sizeof(typename std::remove_pointer<CharT>::type) == 1,
                 int>::type = 0>
    input_adapter(CharT b)
        : input_adapter(reinterpret_cast<const char*>(b),
                        std::strlen(reinterpret_cast<const char*>(b))) {}

    /// input adapter for iterator range with contiguous storage
    template<class IteratorType,
             typename std::enable_if<
                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
                 int>::type = 0>
    input_adapter(IteratorType first, IteratorType last)
    {
#ifndef NDEBUG
        // assertion to check that the iterator range is indeed contiguous,
        // see http://stackoverflow.com/a/35008842/266378 for more discussion
        const auto is_contiguous = std::accumulate(
                                       first, last, std::pair<bool, int>(true, 0),
                                       [&first](std::pair<bool, int> res, decltype(*first) val)
        {
            res.first &= (val == *(std::next(std::addressof(*first), res.second++)));
            return res;
        }).first;
        assert(is_contiguous);
#endif

        // assertion to check that each element is 1 byte long
        static_assert(
            sizeof(typename iterator_traits<IteratorType>::value_type) == 1,
            "each element in the iterator range must have the size of 1 byte");

        const auto len = static_cast<size_t>(std::distance(first, last));
        if (JSON_HEDLEY_LIKELY(len > 0))
        {
            // there is at least one element: use the address of first
            ia = std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(&(*first)), len);
        }
        else
        {
            // the address of first cannot be used: use nullptr
            ia = std::make_shared<input_buffer_adapter>(nullptr, len);
        }
    }

    /// input adapter for array
    template<class T, std::size_t N>
    input_adapter(T (&array)[N])
        : input_adapter(std::begin(array), std::end(array)) {}

    /// input adapter for contiguous container
    template<class ContiguousContainer, typename
             std::enable_if<not std::is_pointer<ContiguousContainer>::value and
                            std::is_base_of<std::random_access_iterator_tag, typename iterator_traits<decltype(std::begin(std::declval<ContiguousContainer const>()))>::iterator_category>::value,
                            int>::type = 0>
    input_adapter(const ContiguousContainer& c)
        : input_adapter(std::begin(c), std::end(c)) {}

    operator input_adapter_t()
    {
        return ia;
    }

  private:
    /// the actual adapter
    input_adapter_t ia = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/json_sax.hpp>


#include <cassert> // assert
#include <cstddef>
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{

/*!
@brief SAX interface

This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
Each function is called in different situations while the input is parsed. The
boolean return value informs the parser whether to continue processing the
input.
*/
template<typename BasicJsonType>
struct json_sax
{
    /// type for (signed) integers
    using number_integer_t = typename BasicJsonType::number_integer_t;
    /// type for unsigned integers
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    /// type for floating-point numbers
    using number_float_t = typename BasicJsonType::number_float_t;
    /// type for strings
    using string_t = typename BasicJsonType::string_t;

    /*!
    @brief a null value was read
    @return whether parsing should proceed
    */
    virtual bool null() = 0;

    /*!
    @brief a boolean value was read
    @param[in] val  boolean value
    @return whether parsing should proceed
    */
    virtual bool boolean(bool val) = 0;

    /*!
    @brief an integer number was read
    @param[in] val  integer value
    @return whether parsing should proceed
    */
    virtual bool number_integer(number_integer_t val) = 0;

    /*!
    @brief an unsigned integer number was read
    @param[in] val  unsigned integer value
    @return whether parsing should proceed
    */
    virtual bool number_unsigned(number_unsigned_t val) = 0;

    /*!
    @brief an floating-point number was read
    @param[in] val  floating-point value
    @param[in] s    raw token value
    @return whether parsing should proceed
    */
    virtual bool number_float(number_float_t val, const string_t& s) = 0;

    /*!
    @brief a string was read
    @param[in] val  string value
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool string(string_t& val) = 0;

    /*!
    @brief the beginning of an object was read
    @param[in] elements  number of object elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_object(std::size_t elements) = 0;

    /*!
    @brief an object key was read
    @param[in] val  object key
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool key(string_t& val) = 0;

    /*!
    @brief the end of an object was read
    @return whether parsing should proceed
    */
    virtual bool end_object() = 0;

    /*!
    @brief the beginning of an array was read
    @param[in] elements  number of array elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_array(std::size_t elements) = 0;

    /*!
    @brief the end of an array was read
    @return whether parsing should proceed
    */
    virtual bool end_array() = 0;

    /*!
    @brief a parse error occurred
    @param[in] position    the position in the input where the error occurs
    @param[in] last_token  the last read token
    @param[in] ex          an exception object describing the error
    @return whether parsing should proceed (must return false)
    */
    virtual bool parse_error(std::size_t position,
                             const std::string& last_token,
                             const detail::exception& ex) = 0;

    virtual ~json_sax() = default;
};


namespace detail
{
/*!
@brief SAX implementation to create a JSON value from SAX events

This class implements the @ref json_sax interface and processes the SAX events
to create a JSON value which makes it basically a DOM parser. The structure or
hierarchy of the JSON value is managed by the stack `ref_stack` which contains
a pointer to the respective array or object for each recursion depth.

After successful parsing, the value that is passed by reference to the
constructor contains the parsed value.

@tparam BasicJsonType  the JSON type
*/
template<typename BasicJsonType>
class json_sax_dom_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;

    /*!
    @param[in, out] r  reference to a JSON value that is manipulated while
                       parsing
    @param[in] allow_exceptions_  whether parse errors yield exceptions
    */
    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
        : root(r), allow_exceptions(allow_exceptions_)
    {}

    // make class move-only
    json_sax_dom_parser(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser(json_sax_dom_parser&&) = default;
    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default;
    ~json_sax_dom_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool start_object(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

        if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408,
                                            "excessive object size: " + std::to_string(len)));
        }

        return true;
    }

    bool key(string_t& val)
    {
        // add null at given key and store the reference for later
        object_element = &(ref_stack.back()->m_value.object->operator[](val));
        return true;
    }

    bool end_object()
    {
        ref_stack.pop_back();
        return true;
    }

    bool start_array(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

        if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408,
                                            "excessive array size: " + std::to_string(len)));
        }

        return true;
    }

    bool end_array()
    {
        ref_stack.pop_back();
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const detail::exception& ex)
    {
        errored = true;
        if (allow_exceptions)
        {
            // determine the proper exception type from the id
            switch ((ex.id / 100) % 100)
            {
                case 1:
                    JSON_THROW(*static_cast<const detail::parse_error*>(&ex));
                case 4:
                    JSON_THROW(*static_cast<const detail::out_of_range*>(&ex));
                // LCOV_EXCL_START
                case 2:
                    JSON_THROW(*static_cast<const detail::invalid_iterator*>(&ex));
                case 3:
                    JSON_THROW(*static_cast<const detail::type_error*>(&ex));
                case 5:
                    JSON_THROW(*static_cast<const detail::other_error*>(&ex));
                default:
                    assert(false);
                    // LCOV_EXCL_STOP
            }
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements
    */
    template<typename Value>
    JSON_HEDLEY_RETURNS_NON_NULL
    BasicJsonType* handle_value(Value&& v)
    {
        if (ref_stack.empty())
        {
            root = BasicJsonType(std::forward<Value>(v));
            return &root;
        }

        assert(ref_stack.back()->is_array() or ref_stack.back()->is_object());

        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
            return &(ref_stack.back()->m_value.array->back());
        }

        assert(ref_stack.back()->is_object());
        assert(object_element);
        *object_element = BasicJsonType(std::forward<Value>(v));
        return object_element;
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};

template<typename BasicJsonType>
class json_sax_dom_callback_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using parser_callback_t = typename BasicJsonType::parser_callback_t;
    using parse_event_t = typename BasicJsonType::parse_event_t;

    json_sax_dom_callback_parser(BasicJsonType& r,
                                 const parser_callback_t cb,
                                 const bool allow_exceptions_ = true)
        : root(r), callback(cb), allow_exceptions(allow_exceptions_)
    {
        keep_stack.push_back(true);
    }

    // make class move-only
    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default;
    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default;
    ~json_sax_dom_callback_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool start_object(std::size_t len)
    {
        // check callback for object start
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::object, true);
        ref_stack.push_back(val.second);

        // check object limit
        if (ref_stack.back() and JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, "excessive object size: " + std::to_string(len)));
        }

        return true;
    }

    bool key(string_t& val)
    {
        BasicJsonType k = BasicJsonType(val);

        // check callback for key
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
        key_keep_stack.push_back(keep);

        // add discarded value at given key and store the reference for later
        if (keep and ref_stack.back())
        {
            object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
        }

        return true;
    }

    bool end_object()
    {
        if (ref_stack.back() and not callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
        {
            // discard object
            *ref_stack.back() = discarded;
        }

        assert(not ref_stack.empty());
        assert(not keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        if (not ref_stack.empty() and ref_stack.back() and ref_stack.back()->is_object())
        {
            // remove discarded value
            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
            {
                if (it->is_discarded())
                {
                    ref_stack.back()->erase(it);
                    break;
                }
            }
        }

        return true;
    }

    bool start_array(std::size_t len)
    {
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::array, true);
        ref_stack.push_back(val.second);

        // check array limit
        if (ref_stack.back() and JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, "excessive array size: " + std::to_string(len)));
        }

        return true;
    }

    bool end_array()
    {
        bool keep = true;

        if (ref_stack.back())
        {
            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
            if (not keep)
            {
                // discard array
                *ref_stack.back() = discarded;
            }
        }

        assert(not ref_stack.empty());
        assert(not keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        // remove discarded value
        if (not keep and not ref_stack.empty() and ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->pop_back();
        }

        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const detail::exception& ex)
    {
        errored = true;
        if (allow_exceptions)
        {
            // determine the proper exception type from the id
            switch ((ex.id / 100) % 100)
            {
                case 1:
                    JSON_THROW(*static_cast<const detail::parse_error*>(&ex));
                case 4:
                    JSON_THROW(*static_cast<const detail::out_of_range*>(&ex));
                // LCOV_EXCL_START
                case 2:
                    JSON_THROW(*static_cast<const detail::invalid_iterator*>(&ex));
                case 3:
                    JSON_THROW(*static_cast<const detail::type_error*>(&ex));
                case 5:
                    JSON_THROW(*static_cast<const detail::other_error*>(&ex));
                default:
                    assert(false);
                    // LCOV_EXCL_STOP
            }
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @param[in] v  value to add to the JSON value we build during parsing
    @param[in] skip_callback  whether we should skip calling the callback
               function; this is required after start_array() and
               start_object() SAX events, because otherwise we would call the
               callback function with an empty array or object, respectively.

    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements

    @return pair of boolean (whether value should be kept) and pointer (to the
            passed value in the ref_stack hierarchy; nullptr if not kept)
    */
    template<typename Value>
    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
    {
        assert(not keep_stack.empty());

        // do not handle this value if we know it would be added to a discarded
        // container
        if (not keep_stack.back())
        {
            return {false, nullptr};
        }

        // create value
        auto value = BasicJsonType(std::forward<Value>(v));

        // check callback
        const bool keep = skip_callback or callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

        // do not handle this value if we just learnt it shall be discarded
        if (not keep)
        {
            return {false, nullptr};
        }

        if (ref_stack.empty())
        {
            root = std::move(value);
            return {true, &root};
        }

        // skip this value if we already decided to skip the parent
        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
        if (not ref_stack.back())
        {
            return {false, nullptr};
        }

        // we now only expect arrays and objects
        assert(ref_stack.back()->is_array() or ref_stack.back()->is_object());

        // array
        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->push_back(std::move(value));
            return {true, &(ref_stack.back()->m_value.array->back())};
        }

        // object
        assert(ref_stack.back()->is_object());
        // check if we should store an element for the current key
        assert(not key_keep_stack.empty());
        const bool store_element = key_keep_stack.back();
        key_keep_stack.pop_back();

        if (not store_element)
        {
            return {false, nullptr};
        }

        assert(object_element);
        *object_element = std::move(value);
        return {true, object_element};
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// stack to manage which values to keep
    std::vector<bool> keep_stack {};
    /// stack to manage which object keys to keep
    std::vector<bool> key_keep_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// callback function
    const parser_callback_t callback = nullptr;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// a discarded value for the callback
    BasicJsonType discarded = BasicJsonType::value_t::discarded;
};

template<typename BasicJsonType>
class json_sax_acceptor
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;

    bool null()
    {
        return true;
    }

    bool boolean(bool /*unused*/)
    {
        return true;
    }

    bool number_integer(number_integer_t /*unused*/)
    {
        return true;
    }

    bool number_unsigned(number_unsigned_t /*unused*/)
    {
        return true;
    }

    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)
    {
        return true;
    }

    bool string(string_t& /*unused*/)
    {
        return true;
    }

    bool start_object(std::size_t  /*unused*/ = std::size_t(-1))
    {
        return true;
    }

    bool key(string_t& /*unused*/)
    {
        return true;
    }

    bool end_object()
    {
        return true;
    }

    bool start_array(std::size_t  /*unused*/ = std::size_t(-1))
    {
        return true;
    }

    bool end_array()
    {
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)
    {
        return false;
    }
};
}  // namespace detail

}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>


#include <cstdint> // size_t
#include <utility> // declval
#include <string> // string

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
namespace detail
{
template <typename T>
using null_function_t = decltype(std::declval<T&>().null());

template <typename T>
using boolean_function_t =
    decltype(std::declval<T&>().boolean(std::declval<bool>()));

template <typename T, typename Integer>
using number_integer_function_t =
    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

template <typename T, typename Unsigned>
using number_unsigned_function_t =
    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

template <typename T, typename Float, typename String>
using number_float_function_t = decltype(std::declval<T&>().number_float(
                                    std::declval<Float>(), std::declval<const String&>()));

template <typename T, typename String>
using string_function_t =
    decltype(std::declval<T&>().string(std::declval<String&>()));

template <typename T>
using start_object_function_t =
    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

template <typename T, typename String>
using key_function_t =
    decltype(std::declval<T&>().key(std::declval<String&>()));

template <typename T>
using end_object_function_t = decltype(std::declval<T&>().end_object());

template <typename T>
using start_array_function_t =
    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

template <typename T>
using end_array_function_t = decltype(std::declval<T&>().end_array());

template <typename T, typename Exception>
using parse_error_function_t = decltype(std::declval<T&>().parse_error(
        std::declval<std::size_t>(), std::declval<const std::string&>(),
        std::declval<const Exception&>()));

template <typename SAX, typename BasicJsonType>
struct is_sax
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static constexpr bool value =
        is_detected_exact<bool, null_function_t, SAX>::value &&
        is_detected_exact<bool, boolean_function_t, SAX>::value &&
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value &&
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value &&
        is_detected_exact<bool, number_float_function_t, SAX, number_float_t,
        string_t>::value &&
        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, start_object_function_t, SAX>::value &&
        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, end_object_function_t, SAX>::value &&
        is_detected_exact<bool, start_array_function_t, SAX>::value &&
        is_detected_exact<bool, end_array_function_t, SAX>::value &&
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
};

template <typename SAX, typename BasicJsonType>
struct is_sax_static_asserts
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
                  "Missing/invalid function: bool null()");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value,
        "Missing/invalid function: bool number_integer(number_integer_t)");
    static_assert(
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value,
        "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
    static_assert(is_detected_exact<bool, number_float_function_t, SAX,
                  number_float_t, string_t>::value,
                  "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
    static_assert(
        is_detected_exact<bool, string_function_t, SAX, string_t>::value,
        "Missing/invalid function: bool string(string_t&)");
    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
                  "Missing/invalid function: bool start_object(std::size_t)");
    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
                  "Missing/invalid function: bool key(string_t&)");
    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
                  "Missing/invalid function: bool end_object()");
    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
                  "Missing/invalid function: bool start_array(std::size_t)");
    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
                  "Missing/invalid function: bool end_array()");
    static_assert(
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
        "Missing/invalid function: bool parse_error(std::size_t, const "
        "std::string&, const exception&)");
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
///////////////////
// binary reader //
///////////////////

/*!
@brief deserialization of CBOR, MessagePack, and UBJSON values
*/
template<typename BasicJsonType, typename SAX = json_sax_dom_parser<BasicJsonType>>
class binary_reader
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using json_sax_t = SAX;

  public:
    /*!
    @brief create a binary reader

    @param[in] adapter  input adapter to read from
    */
    explicit binary_reader(input_adapter_t adapter) : ia(std::move(adapter))
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        assert(ia);
    }

    // make class move-only
    binary_reader(const binary_reader&) = delete;
    binary_reader(binary_reader&&) = default;
    binary_reader& operator=(const binary_reader&) = delete;
    binary_reader& operator=(binary_reader&&) = default;
    ~binary_reader() = default;

    /*!
    @param[in] format  the binary format to parse
    @param[in] sax_    a SAX event processor
    @param[in] strict  whether to expect the input to be consumed completed

    @return
    */
    JSON_HEDLEY_NON_NULL(3)
    bool sax_parse(const input_format_t format,
                   json_sax_t* sax_,
                   const bool strict = true)
    {
        sax = sax_;
        bool result = false;

        switch (format)
        {
            case input_format_t::bson:
                result = parse_bson_internal();
                break;

            case input_format_t::cbor:
                result = parse_cbor_internal();
                break;

            case input_format_t::msgpack:
                result = parse_msgpack_internal();
                break;

            case input_format_t::ubjson:
                result = parse_ubjson_internal();
                break;

            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }

        // strict mode: next byte must be EOF
        if (result and strict)
        {
            if (format == input_format_t::ubjson)
            {
                get_ignore_noop();
            }
            else
            {
                get();
            }

            if (JSON_HEDLEY_UNLIKELY(current != std::char_traits<char>::eof()))
            {
                return sax->parse_error(chars_read, get_token_string(),
                                        parse_error::create(110, chars_read, exception_message(format, "expected end of input; last byte: 0x" + get_token_string(), "value")));
            }
        }

        return result;
    }

    /*!
    @brief determine system byte order

    @return true if and only if system's byte order is little endian

    @note from http://stackoverflow.com/a/1001328/266378
    */
    static constexpr bool little_endianess(int num = 1) noexcept
    {
        return *reinterpret_cast<char*>(&num) == 1;
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @brief Reads in a BSON-object and passes it to the SAX-parser.
    @return whether a valid BSON-value was passed to the SAX parser
    */
    bool parse_bson_internal()
    {
        std::int32_t document_size;
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(not sax->start_object(std::size_t(-1))))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(not parse_bson_element_list(/*is_array*/false)))
        {
            return false;
        }

        return sax->end_object();
    }

    /*!
    @brief Parses a C-style string from the BSON input.
    @param[in, out] result  A reference to the string variable where the read
                            string is to be stored.
    @return `true` if the \x00-byte indicating the end of the string was
             encountered before the EOF; false` indicates an unexpected EOF.
    */
    bool get_bson_cstr(string_t& result)
    {
        auto out = std::back_inserter(result);
        while (true)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::bson, "cstring")))
            {
                return false;
            }
            if (current == 0x00)
            {
                return true;
            }
            *out++ = static_cast<char>(current);
        }

        return true;
    }

    /*!
    @brief Parses a zero-terminated string of length @a len from the BSON
           input.
    @param[in] len  The length (including the zero-byte at the end) of the
                    string to be read.
    @param[in, out] result  A reference to the string variable where the read
                            string is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 1
    @return `true` if the string was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_string(const NumberType len, string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 1))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, "string length must be at least 1, is " + std::to_string(len), "string")));
        }

        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) and get() != std::char_traits<char>::eof();
    }

    /*!
    @brief Read a BSON document element of the given @a element_type.
    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html
    @param[in] element_type_parse_position The position in the input stream,
               where the `element_type` was read.
    @warning Not all BSON element types are supported yet. An unsupported
             @a element_type will give rise to a parse_error.114:
             Unsupported BSON record type 0x...
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_internal(const int element_type,
                                     const std::size_t element_type_parse_position)
    {
        switch (element_type)
        {
            case 0x01: // double
            {
                double number;
                return get_number<double, true>(input_format_t::bson, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0x02: // string
            {
                std::int32_t len;
                string_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) and get_bson_string(len, value) and sax->string(value);
            }

            case 0x03: // object
            {
                return parse_bson_internal();
            }

            case 0x04: // array
            {
                return parse_bson_array();
            }

            case 0x08: // boolean
            {
                return sax->boolean(get() != 0);
            }

            case 0x0A: // null
            {
                return sax->null();
            }

            case 0x10: // int32
            {
                std::int32_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, value) and sax->number_integer(value);
            }

            case 0x12: // int64
            {
                std::int64_t value;
                return get_number<std::int64_t, true>(input_format_t::bson, value) and sax->number_integer(value);
            }

            default: // anything else not supported (yet)
            {
                std::array<char, 3> cr{{}};
                (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type));
                return sax->parse_error(element_type_parse_position, std::string(cr.data()), parse_error::create(114, element_type_parse_position, "Unsupported BSON record type 0x" + std::string(cr.data())));
            }
        }
    }

    /*!
    @brief Read a BSON element list (as specified in the BSON-spec)

    The same binary layout is used for objects and arrays, hence it must be
    indicated with the argument @a is_array which one is expected
    (true --> array, false --> object).

    @param[in] is_array Determines if the element list being read is to be
                        treated as an object (@a is_array == false), or as an
                        array (@a is_array == true).
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_list(const bool is_array)
    {
        string_t key;
        while (int element_type = get())
        {
            if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::bson, "element list")))
            {
                return false;
            }

            const std::size_t element_type_parse_position = chars_read;
            if (JSON_HEDLEY_UNLIKELY(not get_bson_cstr(key)))
            {
                return false;
            }

            if (not is_array and not sax->key(key))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(not parse_bson_element_internal(element_type, element_type_parse_position)))
            {
                return false;
            }

            // get_bson_cstr only appends
            key.clear();
        }

        return true;
    }

    /*!
    @brief Reads an array from the BSON input and passes it to the SAX-parser.
    @return whether a valid BSON-array was passed to the SAX parser
    */
    bool parse_bson_array()
    {
        std::int32_t document_size;
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(not sax->start_array(std::size_t(-1))))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(not parse_bson_element_list(/*is_array*/true)))
        {
            return false;
        }

        return sax->end_array();
    }

    //////////
    // CBOR //
    //////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid CBOR value was passed to the SAX parser
    */
    bool parse_cbor_internal(const bool get_char = true)
    {
        switch (get_char ? get() : current)
        {
            // EOF
            case std::char_traits<char>::eof():
                return unexpect_eof(input_format_t::cbor, "value");

            // Integer 0x00..0x17 (0..23)
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            case 0x18: // Unsigned integer (one-byte uint8_t follows)
            {
                std::uint8_t number;
                return get_number(input_format_t::cbor, number) and sax->number_unsigned(number);
            }

            case 0x19: // Unsigned integer (two-byte uint16_t follows)
            {
                std::uint16_t number;
                return get_number(input_format_t::cbor, number) and sax->number_unsigned(number);
            }

            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
            {
                std::uint32_t number;
                return get_number(input_format_t::cbor, number) and sax->number_unsigned(number);
            }

            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
            {
                std::uint64_t number;
                return get_number(input_format_t::cbor, number) and sax->number_unsigned(number);
            }

            // Negative integer -1-0x00..-1-0x17 (-1..-24)
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));

            case 0x38: // Negative integer (one-byte uint8_t follows)
            {
                std::uint8_t number;
                return get_number(input_format_t::cbor, number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
            {
                std::uint16_t number;
                return get_number(input_format_t::cbor, number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
            {
                std::uint32_t number;
                return get_number(input_format_t::cbor, number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
            {
                std::uint64_t number;
                return get_number(input_format_t::cbor, number) and sax->number_integer(static_cast<number_integer_t>(-1)
                        - static_cast<number_integer_t>(number));
            }

            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            case 0x7F: // UTF-8 string (indefinite length)
            {
                string_t s;
                return get_cbor_string(s) and sax->string(s);
            }

            // array (0x00..0x17 data items follow)
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
                return get_cbor_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu));

            case 0x98: // array (one-byte uint8_t for n follows)
            {
                std::uint8_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_array(static_cast<std::size_t>(len));
            }

            case 0x99: // array (two-byte uint16_t for n follow)
            {
                std::uint16_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_array(static_cast<std::size_t>(len));
            }

            case 0x9A: // array (four-byte uint32_t for n follow)
            {
                std::uint32_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_array(static_cast<std::size_t>(len));
            }

            case 0x9B: // array (eight-byte uint64_t for n follow)
            {
                std::uint64_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_array(static_cast<std::size_t>(len));
            }

            case 0x9F: // array (indefinite length)
                return get_cbor_array(std::size_t(-1));

            // map (0x00..0x17 pairs of data items follow)
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                return get_cbor_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu));

            case 0xB8: // map (one-byte uint8_t for n follows)
            {
                std::uint8_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_object(static_cast<std::size_t>(len));
            }

            case 0xB9: // map (two-byte uint16_t for n follow)
            {
                std::uint16_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_object(static_cast<std::size_t>(len));
            }

            case 0xBA: // map (four-byte uint32_t for n follow)
            {
                std::uint32_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_object(static_cast<std::size_t>(len));
            }

            case 0xBB: // map (eight-byte uint64_t for n follow)
            {
                std::uint64_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_object(static_cast<std::size_t>(len));
            }

            case 0xBF: // map (indefinite length)
                return get_cbor_object(std::size_t(-1));

            case 0xF4: // false
                return sax->boolean(false);

            case 0xF5: // true
                return sax->boolean(true);

            case 0xF6: // null
                return sax->null();

            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
            {
                const int byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }
                const int byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    assert(0 <= exp and exp <= 32);
                    assert(0 <= mant and mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
            {
                float number;
                return get_number(input_format_t::cbor, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
            {
                double number;
                return get_number(input_format_t::cbor, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            default: // anything else (0xFF is handled inside the other types)
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @brief reads a CBOR string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.
    Additionally, CBOR's strings with indefinite lengths are supported.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_cbor_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::cbor, "string")))
        {
            return false;
        }

        switch (current)
        {
            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            {
                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            {
                std::uint8_t len;
                return get_number(input_format_t::cbor, len) and get_string(input_format_t::cbor, len, result);
            }

            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            {
                std::uint16_t len;
                return get_number(input_format_t::cbor, len) and get_string(input_format_t::cbor, len, result);
            }

            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            {
                std::uint32_t len;
                return get_number(input_format_t::cbor, len) and get_string(input_format_t::cbor, len, result);
            }

            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            {
                std::uint64_t len;
                return get_number(input_format_t::cbor, len) and get_string(input_format_t::cbor, len, result);
            }

            case 0x7F: // UTF-8 string (indefinite length)
            {
                while (get() != 0xFF)
                {
                    string_t chunk;
                    if (not get_cbor_string(chunk))
                    {
                        return false;
                    }
                    result.append(chunk);
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, "expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x" + last_token, "string")));
            }
        }
    }

    /*!
    @param[in] len  the length of the array or std::size_t(-1) for an
                    array of indefinite size
    @return whether array creation completed
    */
    bool get_cbor_array(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(not sax->start_array(len)))
        {
            return false;
        }

        if (len != std::size_t(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(not parse_cbor_internal()))
                {
                    return false;
                }
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(not parse_cbor_internal(false)))
                {
                    return false;
                }
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object or std::size_t(-1) for an
                    object of indefinite size
    @return whether object creation completed
    */
    bool get_cbor_object(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(not sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        if (len != std::size_t(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(not get_cbor_string(key) or not sax->key(key)))
                {
                    return false;
                }

                if (JSON_HEDLEY_UNLIKELY(not parse_cbor_internal()))
                {
                    return false;
                }
                key.clear();
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(not get_cbor_string(key) or not sax->key(key)))
                {
                    return false;
                }

                if (JSON_HEDLEY_UNLIKELY(not parse_cbor_internal()))
                {
                    return false;
                }
                key.clear();
            }
        }

        return sax->end_object();
    }

    /////////////
    // MsgPack //
    /////////////

    /*!
    @return whether a valid MessagePack value was passed to the SAX parser
    */
    bool parse_msgpack_internal()
    {
        switch (get())
        {
            // EOF
            case std::char_traits<char>::eof():
                return unexpect_eof(input_format_t::msgpack, "value");

            // positive fixint
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            // fixmap
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
                return get_msgpack_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixarray
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
                return get_msgpack_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            case 0xD9: // str 8
            case 0xDA: // str 16
            case 0xDB: // str 32
            {
                string_t s;
                return get_msgpack_string(s) and sax->string(s);
            }

            case 0xC0: // nil
                return sax->null();

            case 0xC2: // false
                return sax->boolean(false);

            case 0xC3: // true
                return sax->boolean(true);

            case 0xCA: // float 32
            {
                float number;
                return get_number(input_format_t::msgpack, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCB: // float 64
            {
                double number;
                return get_number(input_format_t::msgpack, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCC: // uint 8
            {
                std::uint8_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_unsigned(number);
            }

            case 0xCD: // uint 16
            {
                std::uint16_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_unsigned(number);
            }

            case 0xCE: // uint 32
            {
                std::uint32_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_unsigned(number);
            }

            case 0xCF: // uint 64
            {
                std::uint64_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_unsigned(number);
            }

            case 0xD0: // int 8
            {
                std::int8_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_integer(number);
            }

            case 0xD1: // int 16
            {
                std::int16_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_integer(number);
            }

            case 0xD2: // int 32
            {
                std::int32_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_integer(number);
            }

            case 0xD3: // int 64
            {
                std::int64_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_integer(number);
            }

            case 0xDC: // array 16
            {
                std::uint16_t len;
                return get_number(input_format_t::msgpack, len) and get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDD: // array 32
            {
                std::uint32_t len;
                return get_number(input_format_t::msgpack, len) and get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDE: // map 16
            {
                std::uint16_t len;
                return get_number(input_format_t::msgpack, len) and get_msgpack_object(static_cast<std::size_t>(len));
            }

            case 0xDF: // map 32
            {
                std::uint32_t len;
                return get_number(input_format_t::msgpack, len) and get_msgpack_object(static_cast<std::size_t>(len));
            }

            // negative fixint
            case 0xE0:
            case 0xE1:
            case 0xE2:
            case 0xE3:
            case 0xE4:
            case 0xE5:
            case 0xE6:
            case 0xE7:
            case 0xE8:
            case 0xE9:
            case 0xEA:
            case 0xEB:
            case 0xEC:
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
                return sax->number_integer(static_cast<std::int8_t>(current));

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::msgpack, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @brief reads a MessagePack string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_msgpack_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::msgpack, "string")))
        {
            return false;
        }

        switch (current)
        {
            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0xD9: // str 8
            {
                std::uint8_t len;
                return get_number(input_format_t::msgpack, len) and get_string(input_format_t::msgpack, len, result);
            }

            case 0xDA: // str 16
            {
                std::uint16_t len;
                return get_number(input_format_t::msgpack, len) and get_string(input_format_t::msgpack, len, result);
            }

            case 0xDB: // str 32
            {
                std::uint32_t len;
                return get_number(input_format_t::msgpack, len) and get_string(input_format_t::msgpack, len, result);
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::msgpack, "expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x" + last_token, "string")));
            }
        }
    }

    /*!
    @param[in] len  the length of the array
    @return whether array creation completed
    */
    bool get_msgpack_array(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(not sax->start_array(len)))
        {
            return false;
        }

        for (std::size_t i = 0; i < len; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(not parse_msgpack_internal()))
            {
                return false;
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object
    @return whether object creation completed
    */
    bool get_msgpack_object(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(not sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        for (std::size_t i = 0; i < len; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(not get_msgpack_string(key) or not sax->key(key)))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(not parse_msgpack_internal()))
            {
                return false;
            }
            key.clear();
        }

        return sax->end_object();
    }

    ////////////
    // UBJSON //
    ////////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid UBJSON value was passed to the SAX parser
    */
    bool parse_ubjson_internal(const bool get_char = true)
    {
        return get_ubjson_value(get_char ? get_ignore_noop() : current);
    }

    /*!
    @brief reads a UBJSON string

    This function is either called after reading the 'S' byte explicitly
    indicating a string, or in case of an object key where the 'S' byte can be
    left out.

    @param[out] result   created string
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether string creation completed
    */
    bool get_ubjson_string(string_t& result, const bool get_char = true)
    {
        if (get_char)
        {
            get();  // TODO(niels): may we ignore N here?
        }

        if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::ubjson, "value")))
        {
            return false;
        }

        switch (current)
        {
            case 'U':
            {
                std::uint8_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            case 'i':
            {
                std::int8_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            case 'I':
            {
                std::int16_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            case 'l':
            {
                std::int32_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            case 'L':
            {
                std::int64_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            default:
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token, "string")));
        }
    }

    /*!
    @param[out] result  determined size
    @return whether size determination completed
    */
    bool get_ubjson_size_value(std::size_t& result)
    {
        switch (get_ignore_noop())
        {
            case 'U':
            {
                std::uint8_t number;
                if (JSON_HEDLEY_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'i':
            {
                std::int8_t number;
                if (JSON_HEDLEY_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'I':
            {
                std::int16_t number;
                if (JSON_HEDLEY_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'l':
            {
                std::int32_t number;
                if (JSON_HEDLEY_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'L':
            {
                std::int64_t number;
                if (JSON_HEDLEY_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token, "size")));
            }
        }
    }

    /*!
    @brief determine the type and size for a container

    In the optimized UBJSON format, a type and a size can be provided to allow
    for a more compact representation.

    @param[out] result  pair of the size and the type

    @return whether pair creation completed
    */
    bool get_ubjson_size_type(std::pair<std::size_t, int>& result)
    {
        result.first = string_t::npos; // size
        result.second = 0; // type

        get_ignore_noop();

        if (current == '$')
        {
            result.second = get();  // must not ignore 'N', because 'N' maybe the type
            if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::ubjson, "type")))
            {
                return false;
            }

            get_ignore_noop();
            if (JSON_HEDLEY_UNLIKELY(current != '#'))
            {
                if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::ubjson, "value")))
                {
                    return false;
                }
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "expected '#' after type information; last byte: 0x" + last_token, "size")));
            }

            return get_ubjson_size_value(result.first);
        }

        if (current == '#')
        {
            return get_ubjson_size_value(result.first);
        }

        return true;
    }

    /*!
    @param prefix  the previously read or set type prefix
    @return whether value creation completed
    */
    bool get_ubjson_value(const int prefix)
    {
        switch (prefix)
        {
            case std::char_traits<char>::eof():  // EOF
                return unexpect_eof(input_format_t::ubjson, "value");

            case 'T':  // true
                return sax->boolean(true);
            case 'F':  // false
                return sax->boolean(false);

            case 'Z':  // null
                return sax->null();

            case 'U':
            {
                std::uint8_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_unsigned(number);
            }

            case 'i':
            {
                std::int8_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_integer(number);
            }

            case 'I':
            {
                std::int16_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_integer(number);
            }

            case 'l':
            {
                std::int32_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_integer(number);
            }

            case 'L':
            {
                std::int64_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_integer(number);
            }

            case 'd':
            {
                float number;
                return get_number(input_format_t::ubjson, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'D':
            {
                double number;
                return get_number(input_format_t::ubjson, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'C':  // char
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(input_format_t::ubjson, "char")))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(current > 127))
                {
                    auto last_token = get_token_string();
                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "byte after 'C' must be in range 0x00..0x7F; last byte: 0x" + last_token, "char")));
                }
                string_t s(1, static_cast<char>(current));
                return sax->string(s);
            }

            case 'S':  // string
            {
                string_t s;
                return get_ubjson_string(s) and sax->string(s);
            }

            case '[':  // array
                return get_ubjson_array();

            case '{':  // object
                return get_ubjson_object();

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @return whether array creation completed
    */
    bool get_ubjson_array()
    {
        std::pair<std::size_t, int> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(not get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        if (size_and_type.first != string_t::npos)
        {
            if (JSON_HEDLEY_UNLIKELY(not sax->start_array(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(not get_ubjson_value(size_and_type.second)))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(not parse_ubjson_internal()))
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(not sax->start_array(std::size_t(-1))))
            {
                return false;
            }

            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(not parse_ubjson_internal(false)))
                {
                    return false;
                }
                get_ignore_noop();
            }
        }

        return sax->end_array();
    }

    /*!
    @return whether object creation completed
    */
    bool get_ubjson_object()
    {
        std::pair<std::size_t, int> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(not get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        string_t key;
        if (size_and_type.first != string_t::npos)
        {
            if (JSON_HEDLEY_UNLIKELY(not sax->start_object(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(not get_ubjson_string(key) or not sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(not get_ubjson_value(size_and_type.second)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(not get_ubjson_string(key) or not sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(not parse_ubjson_internal()))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(not sax->start_object(std::size_t(-1))))
            {
                return false;
            }

            while (current != '}')
            {
                if (JSON_HEDLEY_UNLIKELY(not get_ubjson_string(key, false) or not sax->key(key)))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(not parse_ubjson_internal()))
                {
                    return false;
                }
                get_ignore_noop();
                key.clear();
            }
        }

        return sax->end_object();
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*!
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a -'ve valued
    `std::char_traits<char>::eof()` in that case.

    @return character read from the input
    */
    int get()
    {
        ++chars_read;
        return current = ia->get_character();
    }

    /*!
    @return character read from the input after ignoring all 'N' entries
    */
    int get_ignore_noop()
    {
        do
        {
            get();
        }
        while (current == 'N');

        return current;
    }

    /*
    @brief read a number from the input

    @tparam NumberType the type of the number
    @param[in] format   the current format (for diagnostics)
    @param[out] result  number of type @a NumberType

    @return whether conversion completed

    @note This function needs to respect the system's endianess, because
          bytes in CBOR, MessagePack, and UBJSON are stored in network order
          (big endian) and therefore need reordering on little endian systems.
    */
    template<typename NumberType, bool InputIsLittleEndian = false>
    bool get_number(const input_format_t format, NumberType& result)
    {
        // step 1: read input into array with system's byte order
        std::array<std::uint8_t, sizeof(NumberType)> vec;
        for (std::size_t i = 0; i < sizeof(NumberType); ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(format, "number")))
            {
                return false;
            }

            // reverse byte order prior to conversion if necessary
            if (is_little_endian != InputIsLittleEndian)
            {
                vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
            }
            else
            {
                vec[i] = static_cast<std::uint8_t>(current); // LCOV_EXCL_LINE
            }
        }

        // step 2: convert array into number of type T and return
        std::memcpy(&result, vec.data(), sizeof(NumberType));
        return true;
    }

    /*!
    @brief create a string by reading characters from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of characters to read
    @param[out] result string created by reading @a len bytes

    @return whether string creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of string memory.
    */
    template<typename NumberType>
    bool get_string(const input_format_t format,
                    const NumberType len,
                    string_t& result)
    {
        bool success = true;
        std::generate_n(std::back_inserter(result), len, [this, &success, &format]()
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(not unexpect_eof(format, "string")))
            {
                success = false;
            }
            return static_cast<char>(current);
        });
        return success;
    }

    /*!
    @param[in] format   the current format (for diagnostics)
    @param[in] context  further context information (for diagnostics)
    @return whether the last read character is not EOF
    */
    JSON_HEDLEY_NON_NULL(3)
    bool unexpect_eof(const input_format_t format, const char* context) const
    {
        if (JSON_HEDLEY_UNLIKELY(current == std::char_traits<char>::eof()))
        {
            return sax->parse_error(chars_read, "<end of file>",
                                    parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context)));
        }
        return true;
    }

    /*!
    @return a string representation of the last read byte
    */
    std::string get_token_string() const
    {
        std::array<char, 3> cr{{}};
        (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current));
        return std::string{cr.data()};
    }

    /*!
    @param[in] format   the current format
    @param[in] detail   a detailed error message
    @param[in] context  further contect information
    @return a message string to use in the parse_error exceptions
    */
    std::string exception_message(const input_format_t format,
                                  const std::string& detail,
                                  const std::string& context) const
    {
        std::string error_msg = "syntax error while parsing ";

        switch (format)
        {
            case input_format_t::cbor:
                error_msg += "CBOR";
                break;

            case input_format_t::msgpack:
                error_msg += "MessagePack";
                break;

            case input_format_t::ubjson:
                error_msg += "UBJSON";
                break;

            case input_format_t::bson:
                error_msg += "BSON";
                break;

            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }

        return error_msg + " " + context + ": " + detail;
    }

  private:
    /// input adapter
    input_adapter_t ia = nullptr;

    /// the current character
    int current = std::char_traits<char>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// whether we can assume little endianess
    const bool is_little_endian = little_endianess();

    /// the SAX parser
    json_sax_t* sax = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/lexer.hpp>


#include <array> // array
#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdio> // snprintf
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/position_t.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
///////////
// lexer //
///////////

/*!
@brief lexical analysis

This class organizes the lexical analysis during JSON deserialization.
*/
template<typename BasicJsonType>
class lexer
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;

  public:
    /// token types for the parser
    enum class token_type
    {
        uninitialized,    ///< indicating the scanner is uninitialized
        literal_true,     ///< the `true` literal
        literal_false,    ///< the `false` literal
        literal_null,     ///< the `null` literal
        value_string,     ///< a string -- use get_string() for actual value
        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
        value_float,      ///< an floating point number -- use get_number_float() for actual value
        begin_array,      ///< the character for array begin `[`
        begin_object,     ///< the character for object begin `{`
        end_array,        ///< the character for array end `]`
        end_object,       ///< the character for object end `}`
        name_separator,   ///< the name separator `:`
        value_separator,  ///< the value separator `,`
        parse_error,      ///< indicating a parse error
        end_of_input,     ///< indicating the end of the input buffer
        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
    };

    /// return name of values of type token_type (only used for errors)
    JSON_HEDLEY_RETURNS_NON_NULL
    JSON_HEDLEY_CONST
    static const char* token_type_name(const token_type t) noexcept
    {
        switch (t)
        {
            case token_type::uninitialized:
                return "<uninitialized>";
            case token_type::literal_true:
                return "true literal";
            case token_type::literal_false:
                return "false literal";
            case token_type::literal_null:
                return "null literal";
            case token_type::value_string:
                return "string literal";
            case lexer::token_type::value_unsigned:
            case lexer::token_type::value_integer:
            case lexer::token_type::value_float:
                return "number literal";
            case token_type::begin_array:
                return "'['";
            case token_type::begin_object:
                return "'{'";
            case token_type::end_array:
                return "']'";
            case token_type::end_object:
                return "'}'";
            case token_type::name_separator:
                return "':'";
            case token_type::value_separator:
                return "','";
            case token_type::parse_error:
                return "<parse error>";
            case token_type::end_of_input:
                return "end of input";
            case token_type::literal_or_value:
                return "'[', '{', or a literal";
            // LCOV_EXCL_START
            default: // catch non-enum values
                return "unknown token";
                // LCOV_EXCL_STOP
        }
    }

    explicit lexer(detail::input_adapter_t&& adapter)
        : ia(std::move(adapter)), decimal_point_char(get_decimal_point()) {}

    // delete because of pointer members
    lexer(const lexer&) = delete;
    lexer(lexer&&) = delete;
    lexer& operator=(lexer&) = delete;
    lexer& operator=(lexer&&) = delete;
    ~lexer() = default;

  private:
    /////////////////////
    // locales
    /////////////////////

    /// return the locale-dependent decimal point
    JSON_HEDLEY_PURE
    static char get_decimal_point() noexcept
    {
        const auto loc = localeconv();
        assert(loc != nullptr);
        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
    }

    /////////////////////
    // scan functions
    /////////////////////

    /*!
    @brief get codepoint from 4 hex characters following `\u`

    For input "\u c1 c2 c3 c4" the codepoint is:
      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
    between the ASCII value of the character and the desired integer value.

    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
            non-hex character)
    */
    int get_codepoint()
    {
        // this function only makes sense after reading `\u`
        assert(current == 'u');
        int codepoint = 0;

        const auto factors = { 12u, 8u, 4u, 0u };
        for (const auto factor : factors)
        {
            get();

            if (current >= '0' and current <= '9')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
            }
            else if (current >= 'A' and current <= 'F')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
            }
            else if (current >= 'a' and current <= 'f')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
            }
            else
            {
                return -1;
            }
        }

        assert(0x0000 <= codepoint and codepoint <= 0xFFFF);
        return codepoint;
    }

    /*!
    @brief check if the next byte(s) are inside a given range

    Adds the current byte and, for each passed range, reads a new byte and
    checks if it is inside the range. If a violation was detected, set up an
    error message and return false. Otherwise, return true.

    @param[in] ranges  list of integers; interpreted as list of pairs of
                       inclusive lower and upper bound, respectively

    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
         1, 2, or 3 pairs. This precondition is enforced by an assertion.

    @return true if and only if no range violation was detected
    */
    bool next_byte_in_range(std::initializer_list<int> ranges)
    {
        assert(ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6);
        add(current);

        for (auto range = ranges.begin(); range != ranges.end(); ++range)
        {
            get();
            if (JSON_HEDLEY_LIKELY(*range <= current and current <= *(++range)))
            {
                add(current);
            }
            else
            {
                error_message = "invalid string: ill-formed UTF-8 byte";
                return false;
            }
        }

        return true;
    }

    /*!
    @brief scan a string literal

    This function scans a string according to Sect. 7 of RFC 7159. While
    scanning, bytes are escaped and copied into buffer token_buffer. Then the
    function returns successfully, token_buffer is *not* null-terminated (as it
    may contain \0 bytes), and token_buffer.size() is the number of bytes in the
    string.

    @return token_type::value_string if string could be successfully scanned,
            token_type::parse_error otherwise

    @note In case of errors, variable error_message contains a textual
          description.
    */
    token_type scan_string()
    {
        // reset token_buffer (ignore opening quote)
        reset();

        // we entered the function by reading an open quote
        assert(current == '\"');

        while (true)
        {
            // get next character
            switch (get())
            {
                // end of file while parsing string
                case std::char_traits<char>::eof():
                {
                    error_message = "invalid string: missing closing quote";
                    return token_type::parse_error;
                }

                // closing quote
                case '\"':
                {
                    return token_type::value_string;
                }

                // escapes
                case '\\':
                {
                    switch (get())
                    {
                        // quotation mark
                        case '\"':
                            add('\"');
                            break;
                        // reverse solidus
                        case '\\':
                            add('\\');
                            break;
                        // solidus
                        case '/':
                            add('/');
                            break;
                        // backspace
                        case 'b':
                            add('\b');
                            break;
                        // form feed
                        case 'f':
                            add('\f');
                            break;
                        // line feed
                        case 'n':
                            add('\n');
                            break;
                        // carriage return
                        case 'r':
                            add('\r');
                            break;
                        // tab
                        case 't':
                            add('\t');
                            break;

                        // unicode escapes
                        case 'u':
                        {
                            const int codepoint1 = get_codepoint();
                            int codepoint = codepoint1; // start with codepoint1

                            if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
                            {
                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                return token_type::parse_error;
                            }

                            // check if code point is a high surrogate
                            if (0xD800 <= codepoint1 and codepoint1 <= 0xDBFF)
                            {
                                // expect next \uxxxx entry
                                if (JSON_HEDLEY_LIKELY(get() == '\\' and get() == 'u'))
                                {
                                    const int codepoint2 = get_codepoint();

                                    if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
                                    {
                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                        return token_type::parse_error;
                                    }

                                    // check if codepoint2 is a low surrogate
                                    if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 and codepoint2 <= 0xDFFF))
                                    {
                                        // overwrite codepoint
                                        codepoint = static_cast<int>(
                                                        // high surrogate occupies the most significant 22 bits
                                                        (static_cast<unsigned int>(codepoint1) << 10u)
                                                        // low surrogate occupies the least significant 15 bits
                                                        + static_cast<unsigned int>(codepoint2)
                                                        // there is still the 0xD800, 0xDC00 and 0x10000 noise
                                                        // in the result so we have to subtract with:
                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
                                                        - 0x35FDC00u);
                                    }
                                    else
                                    {
                                        error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
                                        return token_type::parse_error;
                                    }
                                }
                                else
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
                                    return token_type::parse_error;
                                }
                            }
                            else
                            {
                                if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 and codepoint1 <= 0xDFFF))
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                                    return token_type::parse_error;
                                }
                            }

                            // result of the above calculation yields a proper codepoint
                            assert(0x00 <= codepoint and codepoint <= 0x10FFFF);

                            // translate codepoint into bytes
                            if (codepoint < 0x80)
                            {
                                // 1-byte characters: 0xxxxxxx (ASCII)
                                add(codepoint);
                            }
                            else if (codepoint <= 0x7FF)
                            {
                                // 2-byte characters: 110xxxxx 10xxxxxx
                                add(static_cast<int>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
                                add(static_cast<int>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else if (codepoint <= 0xFFFF)
                            {
                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
                                add(static_cast<int>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
                                add(static_cast<int>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<int>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else
                            {
                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                                add(static_cast<int>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
                                add(static_cast<int>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
                                add(static_cast<int>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<int>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }

                            break;
                        }

                        // other characters after escape
                        default:
                            error_message = "invalid string: forbidden character after backslash";
                            return token_type::parse_error;
                    }

                    break;
                }

                // invalid control characters
                case 0x00:
                {
                    error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                    return token_type::parse_error;
                }

                case 0x01:
                {
                    error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                    return token_type::parse_error;
                }

                case 0x02:
                {
                    error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                    return token_type::parse_error;
                }

                case 0x03:
                {
                    error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                    return token_type::parse_error;
                }

                case 0x04:
                {
                    error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                    return token_type::parse_error;
                }

                case 0x05:
                {
                    error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                    return token_type::parse_error;
                }

                case 0x06:
                {
                    error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                    return token_type::parse_error;
                }

                case 0x07:
                {
                    error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                    return token_type::parse_error;
                }

                case 0x08:
                {
                    error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                    return token_type::parse_error;
                }

                case 0x09:
                {
                    error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                    return token_type::parse_error;
                }

                case 0x0A:
                {
                    error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                    return token_type::parse_error;
                }

                case 0x0B:
                {
                    error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                    return token_type::parse_error;
                }

                case 0x0C:
                {
                    error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                    return token_type::parse_error;
                }

                case 0x0D:
                {
                    error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                    return token_type::parse_error;
                }

                case 0x0E:
                {
                    error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                    return token_type::parse_error;
                }

                case 0x0F:
                {
                    error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                    return token_type::parse_error;
                }

                case 0x10:
                {
                    error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                    return token_type::parse_error;
                }

                case 0x11:
                {
                    error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                    return token_type::parse_error;
                }

                case 0x12:
                {
                    error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                    return token_type::parse_error;
                }

                case 0x13:
                {
                    error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                    return token_type::parse_error;
                }

                case 0x14:
                {
                    error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                    return token_type::parse_error;
                }

                case 0x15:
                {
                    error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                    return token_type::parse_error;
                }

                case 0x16:
                {
                    error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                    return token_type::parse_error;
                }

                case 0x17:
                {
                    error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                    return token_type::parse_error;
                }

                case 0x18:
                {
                    error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                    return token_type::parse_error;
                }

                case 0x19:
                {
                    error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                    return token_type::parse_error;
                }

                case 0x1A:
                {
                    error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                    return token_type::parse_error;
                }

                case 0x1B:
                {
                    error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                    return token_type::parse_error;
                }

                case 0x1C:
                {
                    error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                    return token_type::parse_error;
                }

                case 0x1D:
                {
                    error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                    return token_type::parse_error;
                }

                case 0x1E:
                {
                    error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                    return token_type::parse_error;
                }

                case 0x1F:
                {
                    error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                    return token_type::parse_error;
                }

                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
                case 0x20:
                case 0x21:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                case 0x2F:
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                case 0x3A:
                case 0x3B:
                case 0x3C:
                case 0x3D:
                case 0x3E:
                case 0x3F:
                case 0x40:
                case 0x41:
                case 0x42:
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                case 0x4C:
                case 0x4D:
                case 0x4E:
                case 0x4F:
                case 0x50:
                case 0x51:
                case 0x52:
                case 0x53:
                case 0x54:
                case 0x55:
                case 0x56:
                case 0x57:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66:
                case 0x67:
                case 0x68:
                case 0x69:
                case 0x6A:
                case 0x6B:
                case 0x6C:
                case 0x6D:
                case 0x6E:
                case 0x6F:
                case 0x70:
                case 0x71:
                case 0x72:
                case 0x73:
                case 0x74:
                case 0x75:
                case 0x76:
                case 0x77:
                case 0x78:
                case 0x79:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                case 0x7D:
                case 0x7E:
                case 0x7F:
                {
                    add(current);
                    break;
                }

                // U+0080..U+07FF: bytes C2..DF 80..BF
                case 0xC2:
                case 0xC3:
                case 0xC4:
                case 0xC5:
                case 0xC6:
                case 0xC7:
                case 0xC8:
                case 0xC9:
                case 0xCA:
                case 0xCB:
                case 0xCC:
                case 0xCD:
                case 0xCE:
                case 0xCF:
                case 0xD0:
                case 0xD1:
                case 0xD2:
                case 0xD3:
                case 0xD4:
                case 0xD5:
                case 0xD6:
                case 0xD7:
                case 0xD8:
                case 0xD9:
                case 0xDA:
                case 0xDB:
                case 0xDC:
                case 0xDD:
                case 0xDE:
                case 0xDF:
                {
                    if (JSON_HEDLEY_UNLIKELY(not next_byte_in_range({0x80, 0xBF})))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
                case 0xE0:
                {
                    if (JSON_HEDLEY_UNLIKELY(not (next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
                case 0xE1:
                case 0xE2:
                case 0xE3:
                case 0xE4:
                case 0xE5:
                case 0xE6:
                case 0xE7:
                case 0xE8:
                case 0xE9:
                case 0xEA:
                case 0xEB:
                case 0xEC:
                case 0xEE:
                case 0xEF:
                {
                    if (JSON_HEDLEY_UNLIKELY(not (next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
                case 0xED:
                {
                    if (JSON_HEDLEY_UNLIKELY(not (next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
                case 0xF0:
                {
                    if (JSON_HEDLEY_UNLIKELY(not (next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
                case 0xF1:
                case 0xF2:
                case 0xF3:
                {
                    if (JSON_HEDLEY_UNLIKELY(not (next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
                case 0xF4:
                {
                    if (JSON_HEDLEY_UNLIKELY(not (next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // remaining bytes (80..C1 and F5..FF) are ill-formed
                default:
                {
                    error_message = "invalid string: ill-formed UTF-8 byte";
                    return token_type::parse_error;
                }
            }
        }
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(float& f, const char* str, char** endptr) noexcept
    {
        f = std::strtof(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtod(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(long double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtold(str, endptr);
    }

    /*!
    @brief scan a number literal

    This function scans a string according to Sect. 6 of RFC 7159.

    The function is realized with a deterministic finite state machine derived
    from the grammar described in RFC 7159. Starting in state "init", the
    input is read and used to determined the next state. Only state "done"
    accepts the number. State "error" is a trap state to model errors. In the
    table below, "anything" means any character but the ones listed before.

    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
    ---------|----------|----------|----------|---------|---------|----------|-----------
    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
    zero     | done     | done     | exponent | done    | done    | decimal1 | done
    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
    decimal1 | decimal2 | [error]  | [error]  | [error] | [error] | [error]  | [error]
    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
    any2     | any2     | any2     | done     | done    | done    | done     | done

    The state machine is realized with one label per state (prefixed with
    "scan_number_") and `goto` statements between them. The state machine
    contains cycles, but any cycle can be left when EOF is read. Therefore,
    the function is guaranteed to terminate.

    During scanning, the read bytes are stored in token_buffer. This string is
    then converted to a signed integer, an unsigned integer, or a
    floating-point number.

    @return token_type::value_unsigned, token_type::value_integer, or
            token_type::value_float if number could be successfully scanned,
            token_type::parse_error otherwise

    @note The scanner is independent of the current locale. Internally, the
          locale's decimal point is used instead of `.` to work with the
          locale-dependent converters.
    */
    token_type scan_number()  // lgtm [cpp/use-of-goto]
    {
        // reset token_buffer to store the number's bytes
        reset();

        // the type of the parsed number; initially set to unsigned; will be
        // changed if minus sign, decimal point or exponent is read
        token_type number_type = token_type::value_unsigned;

        // state (init): we just found out we need to scan a number
        switch (current)
        {
            case '-':
            {
                add(current);
                goto scan_number_minus;
            }

            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            // all other characters are rejected outside scan_number()
            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }

scan_number_minus:
        // state: we just parsed a leading minus sign
        number_type = token_type::value_integer;
        switch (get())
        {
            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                error_message = "invalid number; expected digit after '-'";
                return token_type::parse_error;
            }
        }

scan_number_zero:
        // state: we just parse a zero (maybe with a leading minus sign)
        switch (get())
        {
            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_any1:
        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_decimal1:
        // state: we just parsed a decimal point
        number_type = token_type::value_float;
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            default:
            {
                error_message = "invalid number; expected digit after '.'";
                return token_type::parse_error;
            }
        }

scan_number_decimal2:
        // we just parsed at least one number after a decimal point
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_exponent:
        // we just parsed an exponent
        number_type = token_type::value_float;
        switch (get())
        {
            case '+':
            case '-':
            {
                add(current);
                goto scan_number_sign;
            }

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message =
                    "invalid number; expected '+', '-', or digit after exponent";
                return token_type::parse_error;
            }
        }

scan_number_sign:
        // we just parsed an exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message = "invalid number; expected digit after exponent sign";
                return token_type::parse_error;
            }
        }

scan_number_any2:
        // we just parsed a number after the exponent or exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
                goto scan_number_done;
        }

scan_number_done:
        // unget the character after the number (we only read it to know that
        // we are done scanning a number)
        unget();

        char* endptr = nullptr;
        errno = 0;

        // try to parse integers first and fall back to floats
        if (number_type == token_type::value_unsigned)
        {
            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            assert(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_unsigned = static_cast<number_unsigned_t>(x);
                if (value_unsigned == x)
                {
                    return token_type::value_unsigned;
                }
            }
        }
        else if (number_type == token_type::value_integer)
        {
            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            assert(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_integer = static_cast<number_integer_t>(x);
                if (value_integer == x)
                {
                    return token_type::value_integer;
                }
            }
        }

        // this code is reached if we parse a floating-point number or if an
        // integer conversion above failed
        strtof(value_float, token_buffer.data(), &endptr);

        // we checked the number format before
        assert(endptr == token_buffer.data() + token_buffer.size());

        return token_type::value_float;
    }

    /*!
    @param[in] literal_text  the literal text to expect
    @param[in] length        the length of the passed literal text
    @param[in] return_type   the token type to return on success
    */
    JSON_HEDLEY_NON_NULL(2)
    token_type scan_literal(const char* literal_text, const std::size_t length,
                            token_type return_type)
    {
        assert(current == literal_text[0]);
        for (std::size_t i = 1; i < length; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(get() != literal_text[i]))
            {
                error_message = "invalid literal";
                return token_type::parse_error;
            }
        }
        return return_type;
    }

    /////////////////////
    // input management
    /////////////////////

    /// reset token_buffer; current character is beginning of token
    void reset() noexcept
    {
        token_buffer.clear();
        token_string.clear();
        token_string.push_back(std::char_traits<char>::to_char_type(current));
    }

    /*
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a
    `std::char_traits<char>::eof()` in that case.  Stores the scanned characters
    for use in error messages.

    @return character read from the input
    */
    std::char_traits<char>::int_type get()
    {
        ++position.chars_read_total;
        ++position.chars_read_current_line;

        if (next_unget)
        {
            // just reset the next_unget variable and work with current
            next_unget = false;
        }
        else
        {
            current = ia->get_character();
        }

        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char>::eof()))
        {
            token_string.push_back(std::char_traits<char>::to_char_type(current));
        }

        if (current == '\n')
        {
            ++position.lines_read;
            position.chars_read_current_line = 0;
        }

        return current;
    }

    /*!
    @brief unget current character (read it again on next get)

    We implement unget by setting variable next_unget to true. The input is not
    changed - we just simulate ungetting by modifying chars_read_total,
    chars_read_current_line, and token_string. The next call to get() will
    behave as if the unget character is read again.
    */
    void unget()
    {
        next_unget = true;

        --position.chars_read_total;

        // in case we "unget" a newline, we have to also decrement the lines_read
        if (position.chars_read_current_line == 0)
        {
            if (position.lines_read > 0)
            {
                --position.lines_read;
            }
        }
        else
        {
            --position.chars_read_current_line;
        }

        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char>::eof()))
        {
            assert(not token_string.empty());
            token_string.pop_back();
        }
    }

    /// add a character to token_buffer
    void add(int c)
    {
        token_buffer.push_back(std::char_traits<char>::to_char_type(c));
    }

  public:
    /////////////////////
    // value getters
    /////////////////////

    /// return integer value
    constexpr number_integer_t get_number_integer() const noexcept
    {
        return value_integer;
    }

    /// return unsigned integer value
    constexpr number_unsigned_t get_number_unsigned() const noexcept
    {
        return value_unsigned;
    }

    /// return floating-point value
    constexpr number_float_t get_number_float() const noexcept
    {
        return value_float;
    }

    /// return current string value (implicitly resets the token; useful only once)
    string_t& get_string()
    {
        return token_buffer;
    }

    /////////////////////
    // diagnostics
    /////////////////////

    /// return position of last read token
    constexpr position_t get_position() const noexcept
    {
        return position;
    }

    /// return the last read token (for errors only).  Will never contain EOF
    /// (an arbitrary value that is not a valid char value, often -1), because
    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
    std::string get_token_string() const
    {
        // escape control characters
        std::string result;
        for (const auto c : token_string)
        {
            if ('\x00' <= c and c <= '\x1F')
            {
                // escape control characters
                std::array<char, 9> cs{{}};
                (std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c));
                result += cs.data();
            }
            else
            {
                // add character as is
                result.push_back(c);
            }
        }

        return result;
    }

    /// return syntax error message
    JSON_HEDLEY_RETURNS_NON_NULL
    constexpr const char* get_error_message() const noexcept
    {
        return error_message;
    }

    /////////////////////
    // actual scanner
    /////////////////////

    /*!
    @brief skip the UTF-8 byte order mark
    @return true iff there is no BOM or the correct BOM has been skipped
    */
    bool skip_bom()
    {
        if (get() == 0xEF)
        {
            // check if we completely parse the BOM
            return get() == 0xBB and get() == 0xBF;
        }

        // the first character is not the beginning of the BOM; unget it to
        // process is later
        unget();
        return true;
    }

    token_type scan()
    {
        // initially, skip the BOM
        if (position.chars_read_total == 0 and not skip_bom())
        {
            error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
            return token_type::parse_error;
        }

        // read next character and ignore whitespace
        do
        {
            get();
        }
        while (current == ' ' or current == '\t' or current == '\n' or current == '\r');

        switch (current)
        {
            // structural characters
            case '[':
                return token_type::begin_array;
            case ']':
                return token_type::end_array;
            case '{':
                return token_type::begin_object;
            case '}':
                return token_type::end_object;
            case ':':
                return token_type::name_separator;
            case ',':
                return token_type::value_separator;

            // literals
            case 't':
                return scan_literal("true", 4, token_type::literal_true);
            case 'f':
                return scan_literal("false", 5, token_type::literal_false);
            case 'n':
                return scan_literal("null", 4, token_type::literal_null);

            // string
            case '\"':
                return scan_string();

            // number
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return scan_number();

            // end of input (the null byte is needed when parsing from
            // string literals)
            case '\0':
            case std::char_traits<char>::eof():
                return token_type::end_of_input;

            // error
            default:
                error_message = "invalid literal";
                return token_type::parse_error;
        }
    }

  private:
    /// input adapter
    detail::input_adapter_t ia = nullptr;

    /// the current character
    std::char_traits<char>::int_type current = std::char_traits<char>::eof();

    /// whether the next get() call should just return current
    bool next_unget = false;

    /// the start position of the current token
    position_t position {};

    /// raw input token string (for error messages)
    std::vector<char> token_string {};

    /// buffer for variable-length tokens (numbers, strings)
    string_t token_buffer {};

    /// a description of occurred lexer errors
    const char* error_message = "";

    // number values
    number_integer_t value_integer = 0;
    number_unsigned_t value_unsigned = 0;
    number_float_t value_float = 0;

    /// the decimal point
    const char decimal_point_char = '.';
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/parser.hpp>


#include <cassert> // assert
#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
////////////
// parser //
////////////

/*!
@brief syntax analysis

This class implements a recursive decent parser.
*/
template<typename BasicJsonType>
class parser
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using lexer_t = lexer<BasicJsonType>;
    using token_type = typename lexer_t::token_type;

  public:
    enum class parse_event_t : uint8_t
    {
        /// the parser read `{` and started to process a JSON object
        object_start,
        /// the parser read `}` and finished processing a JSON object
        object_end,
        /// the parser read `[` and started to process a JSON array
        array_start,
        /// the parser read `]` and finished processing a JSON array
        array_end,
        /// the parser read a key of a value in an object
        key,
        /// the parser finished reading a JSON value
        value
    };

    using parser_callback_t =
        std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;

    /// a parser reading from an input adapter
    explicit parser(detail::input_adapter_t&& adapter,
                    const parser_callback_t cb = nullptr,
                    const bool allow_exceptions_ = true)
        : callback(cb), m_lexer(std::move(adapter)), allow_exceptions(allow_exceptions_)
    {
        // read first token
        get_token();
    }

    /*!
    @brief public parser interface

    @param[in] strict      whether to expect the last token to be EOF
    @param[in,out] result  parsed JSON value

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse(const bool strict, BasicJsonType& result)
    {
        if (callback)
        {
            json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
            sax_parse_internal(&sdp);
            result.assert_invariant();

            // in strict mode, input must be completely read
            if (strict and (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value")));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }

            // set top-level value to null if it was discarded by the callback
            // function
            if (result.is_discarded())
            {
                result = nullptr;
            }
        }
        else
        {
            json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
            sax_parse_internal(&sdp);
            result.assert_invariant();

            // in strict mode, input must be completely read
            if (strict and (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value")));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }
        }
    }

    /*!
    @brief public accept interface

    @param[in] strict  whether to expect the last token to be EOF
    @return whether the input is a proper JSON text
    */
    bool accept(const bool strict = true)
    {
        json_sax_acceptor<BasicJsonType> sax_acceptor;
        return sax_parse(&sax_acceptor, strict);
    }

    template <typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse(SAX* sax, const bool strict = true)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        const bool result = sax_parse_internal(sax);

        // strict mode: next byte must be EOF
        if (result and strict and (get_token() != token_type::end_of_input))
        {
            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(),
                                            exception_message(token_type::end_of_input, "value")));
        }

        return result;
    }

  private:
    template <typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse_internal(SAX* sax)
    {
        // stack to remember the hierarchy of structured values we are parsing
        // true = array; false = object
        std::vector<bool> states;
        // value to avoid a goto (see comment where set to true)
        bool skip_to_state_evaluation = false;

        while (true)
        {
            if (not skip_to_state_evaluation)
            {
                // invariant: get_token() was called before each iteration
                switch (last_token)
                {
                    case token_type::begin_object:
                    {
                        if (JSON_HEDLEY_UNLIKELY(not sax->start_object(std::size_t(-1))))
                        {
                            return false;
                        }

                        // closing } -> we are done
                        if (get_token() == token_type::end_object)
                        {
                            if (JSON_HEDLEY_UNLIKELY(not sax->end_object()))
                            {
                                return false;
                            }
                            break;
                        }

                        // parse key
                        if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            exception_message(token_type::value_string, "object key")));
                        }
                        if (JSON_HEDLEY_UNLIKELY(not sax->key(m_lexer.get_string())))
                        {
                            return false;
                        }

                        // parse separator (:)
                        if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            exception_message(token_type::name_separator, "object separator")));
                        }

                        // remember we are now inside an object
                        states.push_back(false);

                        // parse values
                        get_token();
                        continue;
                    }

                    case token_type::begin_array:
                    {
                        if (JSON_HEDLEY_UNLIKELY(not sax->start_array(std::size_t(-1))))
                        {
                            return false;
                        }

                        // closing ] -> we are done
                        if (get_token() == token_type::end_array)
                        {
                            if (JSON_HEDLEY_UNLIKELY(not sax->end_array()))
                            {
                                return false;
                            }
                            break;
                        }

                        // remember we are now inside an array
                        states.push_back(true);

                        // parse values (no need to call get_token)
                        continue;
                    }

                    case token_type::value_float:
                    {
                        const auto res = m_lexer.get_number_float();

                        if (JSON_HEDLEY_UNLIKELY(not std::isfinite(res)))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    out_of_range::create(406, "number overflow parsing '" + m_lexer.get_token_string() + "'"));
                        }

                        if (JSON_HEDLEY_UNLIKELY(not sax->number_float(res, m_lexer.get_string())))
                        {
                            return false;
                        }

                        break;
                    }

                    case token_type::literal_false:
                    {
                        if (JSON_HEDLEY_UNLIKELY(not sax->boolean(false)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_null:
                    {
                        if (JSON_HEDLEY_UNLIKELY(not sax->null()))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_true:
                    {
                        if (JSON_HEDLEY_UNLIKELY(not sax->boolean(true)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_integer:
                    {
                        if (JSON_HEDLEY_UNLIKELY(not sax->number_integer(m_lexer.get_number_integer())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_string:
                    {
                        if (JSON_HEDLEY_UNLIKELY(not sax->string(m_lexer.get_string())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_unsigned:
                    {
                        if (JSON_HEDLEY_UNLIKELY(not sax->number_unsigned(m_lexer.get_number_unsigned())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::parse_error:
                    {
                        // using "uninitialized" to avoid "expected" message
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::uninitialized, "value")));
                    }

                    default: // the last token was unexpected
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::literal_or_value, "value")));
                    }
                }
            }
            else
            {
                skip_to_state_evaluation = false;
            }

            // we reached this line after we successfully parsed a value
            if (states.empty())
            {
                // empty stack: we reached the end of the hierarchy: done
                return true;
            }

            if (states.back())  // array
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse a new value
                    get_token();
                    continue;
                }

                // closing ]
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
                {
                    if (JSON_HEDLEY_UNLIKELY(not sax->end_array()))
                    {
                        return false;
                    }

                    // We are done with this array. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    assert(not states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(),
                                                exception_message(token_type::end_array, "array")));
            }
            else  // object
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse key
                    if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::value_string, "object key")));
                    }

                    if (JSON_HEDLEY_UNLIKELY(not sax->key(m_lexer.get_string())))
                    {
                        return false;
                    }

                    // parse separator (:)
                    if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::name_separator, "object separator")));
                    }

                    // parse values
                    get_token();
                    continue;
                }

                // closing }
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
                {
                    if (JSON_HEDLEY_UNLIKELY(not sax->end_object()))
                    {
                        return false;
                    }

                    // We are done with this object. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    assert(not states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(),
                                                exception_message(token_type::end_object, "object")));
            }
        }
    }

    /// get next token from lexer
    token_type get_token()
    {
        return last_token = m_lexer.scan();
    }

    std::string exception_message(const token_type expected, const std::string& context)
    {
        std::string error_msg = "syntax error ";

        if (not context.empty())
        {
            error_msg += "while parsing " + context + " ";
        }

        error_msg += "- ";

        if (last_token == token_type::parse_error)
        {
            error_msg += std::string(m_lexer.get_error_message()) + "; last read: '" +
                         m_lexer.get_token_string() + "'";
        }
        else
        {
            error_msg += "unexpected " + std::string(lexer_t::token_type_name(last_token));
        }

        if (expected != token_type::uninitialized)
        {
            error_msg += "; expected " + std::string(lexer_t::token_type_name(expected));
        }

        return error_msg;
    }

  private:
    /// callback function
    const parser_callback_t callback = nullptr;
    /// the type of the last read token
    token_type last_token = token_type::uninitialized;
    /// the lexer
    lexer_t m_lexer;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/internal_iterator.hpp>


// #include <nlohmann/detail/iterators/primitive_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

namespace nlohmann
{
namespace detail
{
/*
@brief an iterator for primitive JSON types

This class models an iterator for primitive JSON types (boolean, number,
string). It's only purpose is to allow the iterator/const_iterator classes
to "iterate" over primitive values. Internally, the iterator is modeled by
a `difference_type` variable. Value begin_value (`0`) models the begin,
end_value (`1`) models past the end.
*/
class primitive_iterator_t
{
  private:
    using difference_type = std::ptrdiff_t;
    static constexpr difference_type begin_value = 0;
    static constexpr difference_type end_value = begin_value + 1;

    /// iterator as signed integer type
    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

  public:
    constexpr difference_type get_value() const noexcept
    {
        return m_it;
    }

    /// set iterator to a defined beginning
    void set_begin() noexcept
    {
        m_it = begin_value;
    }

    /// set iterator to a defined past the end
    void set_end() noexcept
    {
        m_it = end_value;
    }

    /// return whether the iterator can be dereferenced
    constexpr bool is_begin() const noexcept
    {
        return m_it == begin_value;
    }

    /// return whether the iterator is at end
    constexpr bool is_end() const noexcept
    {
        return m_it == end_value;
    }

    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it == rhs.m_it;
    }

    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it < rhs.m_it;
    }

    primitive_iterator_t operator+(difference_type n) noexcept
    {
        auto result = *this;
        result += n;
        return result;
    }

    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it - rhs.m_it;
    }

    primitive_iterator_t& operator++() noexcept
    {
        ++m_it;
        return *this;
    }

    primitive_iterator_t const operator++(int) noexcept
    {
        auto result = *this;
        ++m_it;
        return result;
    }

    primitive_iterator_t& operator--() noexcept
    {
        --m_it;
        return *this;
    }

    primitive_iterator_t const operator--(int) noexcept
    {
        auto result = *this;
        --m_it;
        return result;
    }

    primitive_iterator_t& operator+=(difference_type n) noexcept
    {
        m_it += n;
        return *this;
    }

    primitive_iterator_t& operator-=(difference_type n) noexcept
    {
        m_it -= n;
        return *this;
    }
};
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
/*!
@brief an iterator value

@note This structure could easily be a union, but MSVC currently does not allow
unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
*/
template<typename BasicJsonType> struct internal_iterator
{
    /// iterator for JSON objects
    typename BasicJsonType::object_t::iterator object_iterator {};
    /// iterator for JSON arrays
    typename BasicJsonType::array_t::iterator array_iterator {};
    /// generic iterator for all other types
    primitive_iterator_t primitive_iterator {};
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/iter_impl.hpp>


#include <ciso646> // not
#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/internal_iterator.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
// forward declare, to be able to friend it later on
template<typename IteratorType> class iteration_proxy;
template<typename IteratorType> class iteration_proxy_value;

/*!
@brief a template for a bidirectional iterator for the @ref basic_json class
This class implements a both iterators (iterator and const_iterator) for the
@ref basic_json class.
@note An iterator is called *initialized* when a pointer to a JSON value has
      been set (e.g., by a constructor or a copy assignment). If the iterator is
      default-constructed, it is *uninitialized* and most methods are undefined.
      **The library uses assertions to detect calls on uninitialized iterators.**
@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
*/
template<typename BasicJsonType>
class iter_impl
{
    /// allow basic_json to access private members
    friend iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
    friend BasicJsonType;
    friend iteration_proxy<iter_impl>;
    friend iteration_proxy_value<iter_impl>;

    using object_t = typename BasicJsonType::object_t;
    using array_t = typename BasicJsonType::array_t;
    // make sure BasicJsonType is basic_json or const basic_json
    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
                  "iter_impl only accepts (const) basic_json");

  public:

    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
    /// A user-defined iterator should provide publicly accessible typedefs named
    /// iterator_category, value_type, difference_type, pointer, and reference.
    /// Note that value_type is required to be non-const, even for constant iterators.
    using iterator_category = std::bidirectional_iterator_tag;

    /// the type of the values when the iterator is dereferenced
    using value_type = typename BasicJsonType::value_type;
    /// a type to represent differences between iterators
    using difference_type = typename BasicJsonType::difference_type;
    /// defines a pointer to the type iterated over (value_type)
    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
          typename BasicJsonType::const_pointer,
          typename BasicJsonType::pointer>::type;
    /// defines a reference to the type iterated over (value_type)
    using reference =
        typename std::conditional<std::is_const<BasicJsonType>::value,
        typename BasicJsonType::const_reference,
        typename BasicJsonType::reference>::type;

    /// default constructor
    iter_impl() = default;

    /*!
    @brief constructor for a given JSON instance
    @param[in] object  pointer to a JSON object for this iterator
    @pre object != nullptr
    @post The iterator is initialized; i.e. `m_object != nullptr`.
    */
    explicit iter_impl(pointer object) noexcept : m_object(object)
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = typename object_t::iterator();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = typename array_t::iterator();
                break;
            }

            default:
            {
                m_it.primitive_iterator = primitive_iterator_t();
                break;
            }
        }
    }

    /*!
    @note The conventional copy constructor and copy assignment are implicitly
          defined. Combined with the following converting constructor and
          assignment, they support: (1) copy from iterator to iterator, (2)
          copy from const iterator to const iterator, and (3) conversion from
          iterator to const iterator. However conversion from const iterator
          to iterator is not defined.
    */

    /*!
    @brief const copy constructor
    @param[in] other const iterator to copy from
    @note This copy constuctor had to be defined explicitely to circumvent a bug
          occuring on msvc v19.0 compiler (VS 2015) debug build. For more
          information refer to: https://github.com/nlohmann/json/issues/1608
    */
    iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

    /*!
    @brief converting constructor
    @param[in] other  non-const iterator to copy from
    @note It is not checked whether @a other is initialized.
    */
    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other  non-const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

  private:
    /*!
    @brief set the iterator to the first value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_begin() noexcept
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->begin();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->begin();
                break;
            }

            case value_t::null:
            {
                // set to end so begin()==end() is true: null is empty
                m_it.primitive_iterator.set_end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_begin();
                break;
            }
        }
    }

    /*!
    @brief set the iterator past the last value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_end() noexcept
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->end();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_end();
                break;
            }
        }
    }

  public:
    /*!
    @brief return a reference to the value pointed to by the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator*() const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                assert(m_it.object_iterator != m_object->m_value.object->end());
                return m_it.object_iterator->second;
            }

            case value_t::array:
            {
                assert(m_it.array_iterator != m_object->m_value.array->end());
                return *m_it.array_iterator;
            }

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief dereference the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    pointer operator->() const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                assert(m_it.object_iterator != m_object->m_value.object->end());
                return &(m_it.object_iterator->second);
            }

            case value_t::array:
            {
                assert(m_it.array_iterator != m_object->m_value.array->end());
                return &*m_it.array_iterator;
            }

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief post-increment (it++)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl const operator++(int)
    {
        auto result = *this;
        ++(*this);
        return result;
    }

    /*!
    @brief pre-increment (++it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator++()
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, 1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, 1);
                break;
            }

            default:
            {
                ++m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief post-decrement (it--)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl const operator--(int)
    {
        auto result = *this;
        --(*this);
        return result;
    }

    /*!
    @brief pre-decrement (--it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator--()
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, -1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, -1);
                break;
            }

            default:
            {
                --m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  comparison: equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator==(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                return (m_it.object_iterator == other.m_it.object_iterator);

            case value_t::array:
                return (m_it.array_iterator == other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: not equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator!=(const iter_impl& other) const
    {
        return not operator==(other);
    }

    /*!
    @brief  comparison: smaller
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators"));

            case value_t::array:
                return (m_it.array_iterator < other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: less than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<=(const iter_impl& other) const
    {
        return not other.operator < (*this);
    }

    /*!
    @brief  comparison: greater than
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>(const iter_impl& other) const
    {
        return not operator<=(other);
    }

    /*!
    @brief  comparison: greater than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>=(const iter_impl& other) const
    {
        return not operator<(other);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator+=(difference_type i)
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
            {
                std::advance(m_it.array_iterator, i);
                break;
            }

            default:
            {
                m_it.primitive_iterator += i;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator-=(difference_type i)
    {
        return operator+=(-i);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator+(difference_type i) const
    {
        auto result = *this;
        result += i;
        return result;
    }

    /*!
    @brief  addition of distance and iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    friend iter_impl operator+(difference_type i, const iter_impl& it)
    {
        auto result = it;
        result += i;
        return result;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator-(difference_type i) const
    {
        auto result = *this;
        result -= i;
        return result;
    }

    /*!
    @brief  return difference
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    difference_type operator-(const iter_impl& other) const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
                return m_it.array_iterator - other.m_it.array_iterator;

            default:
                return m_it.primitive_iterator - other.m_it.primitive_iterator;
        }
    }

    /*!
    @brief  access to successor
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator[](difference_type n) const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators"));

            case value_t::array:
                return *std::next(m_it.array_iterator, n);

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief  return the key of an object iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    const typename object_t::key_type& key() const
    {
        assert(m_object != nullptr);

        if (JSON_HEDLEY_LIKELY(m_object->is_object()))
        {
            return m_it.object_iterator->first;
        }

        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators"));
    }

    /*!
    @brief  return the value of an iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference value() const
    {
        return operator*();
    }

  private:
    /// associated JSON instance
    pointer m_object = nullptr;
    /// the actual iterator of the associated instance
    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
};
} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>

// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

namespace nlohmann
{
namespace detail
{
//////////////////////
// reverse_iterator //
//////////////////////

/*!
@brief a template for a reverse iterator class

@tparam Base the base iterator type to reverse. Valid types are @ref
iterator (to create @ref reverse_iterator) and @ref const_iterator (to
create @ref const_reverse_iterator).

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
  It is possible to write to the pointed-to element (only if @a Base is
  @ref iterator).

@since version 1.0.0
*/
template<typename Base>
class json_reverse_iterator : public std::reverse_iterator<Base>
{
  public:
    using difference_type = std::ptrdiff_t;
    /// shortcut to the reverse iterator adapter
    using base_iterator = std::reverse_iterator<Base>;
    /// the reference type for the pointed-to element
    using reference = typename Base::reference;

    /// create reverse iterator from iterator
    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
        : base_iterator(it) {}

    /// create reverse iterator from base class
    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

    /// post-increment (it++)
    json_reverse_iterator const operator++(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
    }

    /// pre-increment (++it)
    json_reverse_iterator& operator++()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
    }

    /// post-decrement (it--)
    json_reverse_iterator const operator--(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
    }

    /// pre-decrement (--it)
    json_reverse_iterator& operator--()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
    }

    /// add to iterator
    json_reverse_iterator& operator+=(difference_type i)
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
    }

    /// add to iterator
    json_reverse_iterator operator+(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
    }

    /// subtract from iterator
    json_reverse_iterator operator-(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
    }

    /// return difference
    difference_type operator-(const json_reverse_iterator& other) const
    {
        return base_iterator(*this) - base_iterator(other);
    }

    /// access to successor
    reference operator[](difference_type n) const
    {
        return *(this->operator+(n));
    }

    /// return the key of an object iterator
    auto key() const -> decltype(std::declval<Base>().key())
    {
        auto it = --this->base();
        return it.key();
    }

    /// return the value of an iterator
    reference value() const
    {
        auto it = --this->base();
        return it.operator * ();
    }
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/json_pointer.hpp>


#include <algorithm> // all_of
#include <cassert> // assert
#include <cctype> // isdigit
#include <numeric> // accumulate
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
template<typename BasicJsonType>
class json_pointer
{
    // allow basic_json to access private members
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    friend class basic_json;

  public:
    /*!
    @brief create JSON pointer

    Create a JSON pointer according to the syntax described in
    [Section 3 of RFC6901](https://tools.ietf.org/html/rfc6901#section-3).

    @param[in] s  string representing the JSON pointer; if omitted, the empty
                  string is assumed which references the whole JSON value

    @throw parse_error.107 if the given JSON pointer @a s is nonempty and does
                           not begin with a slash (`/`); see example below

    @throw parse_error.108 if a tilde (`~`) in the given JSON pointer @a s is
    not followed by `0` (representing `~`) or `1` (representing `/`); see
    example below

    @liveexample{The example shows the construction several valid JSON pointers
    as well as the exceptional behavior.,json_pointer}

    @since version 2.0.0
    */
    explicit json_pointer(const std::string& s = "")
        : reference_tokens(split(s))
    {}

    /*!
    @brief return a string representation of the JSON pointer

    @invariant For each JSON pointer `ptr`, it holds:
    @code {.cpp}
    ptr == json_pointer(ptr.to_string());
    @endcode

    @return a string representation of the JSON pointer

    @liveexample{The example shows the result of `to_string`.,json_pointer__to_string}

    @since version 2.0.0
    */
    std::string to_string() const
    {
        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                               std::string{},
                               [](const std::string & a, const std::string & b)
        {
            return a + "/" + escape(b);
        });
    }

    /// @copydoc to_string()
    operator std::string() const
    {
        return to_string();
    }

    /*!
    @brief append another JSON pointer at the end of this JSON pointer

    @param[in] ptr  JSON pointer to append
    @return JSON pointer with @a ptr appended

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::string) to append a reference token
    @sa @ref operator/=(std::size_t) to append an array index
    @sa @ref operator/(const json_pointer&, const json_pointer&) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(const json_pointer& ptr)
    {
        reference_tokens.insert(reference_tokens.end(),
                                ptr.reference_tokens.begin(),
                                ptr.reference_tokens.end());
        return *this;
    }

    /*!
    @brief append an unescaped reference token at the end of this JSON pointer

    @param[in] token  reference token to append
    @return JSON pointer with @a token appended without escaping @a token

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Amortized constant.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer
    @sa @ref operator/=(std::size_t) to append an array index
    @sa @ref operator/(const json_pointer&, std::size_t) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(std::string token)
    {
        push_back(std::move(token));
        return *this;
    }

    /*!
    @brief append an array index at the end of this JSON pointer

    @param[in] array_index  array index ot append
    @return JSON pointer with @a array_index appended

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Amortized constant.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer
    @sa @ref operator/=(std::string) to append a reference token
    @sa @ref operator/(const json_pointer&, std::string) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(std::size_t array_index)
    {
        return *this /= std::to_string(array_index);
    }

    /*!
    @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer

    @param[in] lhs  JSON pointer
    @param[in] rhs  JSON pointer
    @return a new JSON pointer with @a rhs appended to @a lhs

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a lhs and @a rhs.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& lhs,
                                  const json_pointer& rhs)
    {
        return json_pointer(lhs) /= rhs;
    }

    /*!
    @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer

    @param[in] ptr  JSON pointer
    @param[in] token  reference token
    @return a new JSON pointer with unescaped @a token appended to @a ptr

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::string) to append a reference token

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& ptr, std::string token)
    {
        return json_pointer(ptr) /= std::move(token);
    }

    /*!
    @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer

    @param[in] ptr  JSON pointer
    @param[in] array_index  array index
    @return a new JSON pointer with @a array_index appended to @a ptr

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::size_t) to append an array index

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& ptr, std::size_t array_index)
    {
        return json_pointer(ptr) /= array_index;
    }

    /*!
    @brief returns the parent of this JSON pointer

    @return parent of this JSON pointer; in case this JSON pointer is the root,
            the root itself is returned

    @complexity Linear in the length of the JSON pointer.

    @liveexample{The example shows the result of `parent_pointer` for different
    JSON Pointers.,json_pointer__parent_pointer}

    @since version 3.6.0
    */
    json_pointer parent_pointer() const
    {
        if (empty())
        {
            return *this;
        }

        json_pointer res = *this;
        res.pop_back();
        return res;
    }

    /*!
    @brief remove last reference token

    @pre not `empty()`

    @liveexample{The example shows the usage of `pop_back`.,json_pointer__pop_back}

    @complexity Constant.

    @throw out_of_range.405 if JSON pointer has no parent

    @since version 3.6.0
    */
    void pop_back()
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        reference_tokens.pop_back();
    }

    /*!
    @brief return last reference token

    @pre not `empty()`
    @return last reference token

    @liveexample{The example shows the usage of `back`.,json_pointer__back}

    @complexity Constant.

    @throw out_of_range.405 if JSON pointer has no parent

    @since version 3.6.0
    */
    const std::string& back()
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        return reference_tokens.back();
    }

    /*!
    @brief append an unescaped token at the end of the reference pointer

    @param[in] token  token to add

    @complexity Amortized constant.

    @liveexample{The example shows the result of `push_back` for different
    JSON Pointers.,json_pointer__push_back}

    @since version 3.6.0
    */
    void push_back(const std::string& token)
    {
        reference_tokens.push_back(token);
    }

    /// @copydoc push_back(const std::string&)
    void push_back(std::string&& token)
    {
        reference_tokens.push_back(std::move(token));
    }

    /*!
    @brief return whether pointer points to the root document

    @return true iff the JSON pointer points to the root document

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example shows the result of `empty` for different JSON
    Pointers.,json_pointer__empty}

    @since version 3.6.0
    */
    bool empty() const noexcept
    {
        return reference_tokens.empty();
    }

  private:
    /*!
    @param[in] s  reference token to be converted into an array index

    @return integer representation of @a s

    @throw out_of_range.404 if string @a s could not be converted to an integer
    */
    static int array_index(const std::string& s)
    {
        std::size_t processed_chars = 0;
        const int res = std::stoi(s, &processed_chars);

        // check if the string was completely read
        if (JSON_HEDLEY_UNLIKELY(processed_chars != s.size()))
        {
            JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
        }

        return res;
    }

    json_pointer top() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        json_pointer result = *this;
        result.reference_tokens = {reference_tokens[0]};
        return result;
    }

    /*!
    @brief create and return a reference to the pointed to value

    @complexity Linear in the number of reference tokens.

    @throw parse_error.109 if array index is not a number
    @throw type_error.313 if value cannot be unflattened
    */
    BasicJsonType& get_and_create(BasicJsonType& j) const
    {
        using size_type = typename BasicJsonType::size_type;
        auto result = &j;

        // in case no reference tokens exist, return a reference to the JSON value
        // j which will be overwritten by a primitive value
        for (const auto& reference_token : reference_tokens)
        {
            switch (result->type())
            {
                case detail::value_t::null:
                {
                    if (reference_token == "0")
                    {
                        // start a new array if reference token is 0
                        result = &result->operator[](0);
                    }
                    else
                    {
                        // start a new object otherwise
                        result = &result->operator[](reference_token);
                    }
                    break;
                }

                case detail::value_t::object:
                {
                    // create an entry in the object
                    result = &result->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // create an entry in the array
                    JSON_TRY
                    {
                        result = &result->operator[](static_cast<size_type>(array_index(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                /*
                The following code is only reached if there exists a reference
                token _and_ the current value is primitive. In this case, we have
                an error situation, because primitive values may only occur as
                single value; that is, with an empty list of reference tokens.
                */
                default:
                    JSON_THROW(detail::type_error::create(313, "invalid value to unflatten"));
            }
        }

        return *result;
    }

    /*!
    @brief return a reference to the pointed to value

    @note This version does not throw if a value is not present, but tries to
          create nested values instead. For instance, calling this function
          with pointer `"/this/that"` on a null value is equivalent to calling
          `operator[]("this").operator[]("that")` on that value, effectively
          changing the null value to an object.

    @param[in] ptr  a JSON value

    @return reference to the JSON value pointed to by the JSON pointer

    @complexity Linear in the length of the JSON pointer.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    BasicJsonType& get_unchecked(BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            // convert null values to arrays or objects before continuing
            if (ptr->is_null())
            {
                // check if reference token is a number
                const bool nums =
                    std::all_of(reference_token.begin(), reference_token.end(),
                                [](const unsigned char x)
                {
                    return std::isdigit(x);
                });

                // change value to array for numbers or "-" or to object otherwise
                *ptr = (nums or reference_token == "-")
                       ? detail::value_t::array
                       : detail::value_t::object;
            }

            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    if (reference_token == "-")
                    {
                        // explicitly treat "-" as index beyond the end
                        ptr = &ptr->operator[](ptr->m_value.array->size());
                    }
                    else
                    {
                        // convert array index to number; unchecked access
                        JSON_TRY
                        {
                            ptr = &ptr->operator[](
                                static_cast<size_type>(array_index(reference_token)));
                        }
                        JSON_CATCH(std::invalid_argument&)
                        {
                            JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                        }
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    BasicJsonType& get_checked(BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    // note: at performs range check
                    JSON_TRY
                    {
                        ptr = &ptr->at(static_cast<size_type>(array_index(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @brief return a const reference to the pointed to value

    @param[in] ptr  a JSON value

    @return const reference to the JSON value pointed to by the JSON
    pointer

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" cannot be used for const access
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    // use unchecked array access
                    JSON_TRY
                    {
                        ptr = &ptr->operator[](
                            static_cast<size_type>(array_index(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    const BasicJsonType& get_checked(const BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    // note: at performs range check
                    JSON_TRY
                    {
                        ptr = &ptr->at(static_cast<size_type>(array_index(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    */
    bool contains(const BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    if (not ptr->contains(reference_token))
                    {
                        // we did not find the key in the object
                        return false;
                    }

                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        return false;
                    }

                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    JSON_TRY
                    {
                        const auto idx = static_cast<size_type>(array_index(reference_token));
                        if (idx >= ptr->size())
                        {
                            // index out of range
                            return false;
                        }

                        ptr = &ptr->operator[](idx);
                        break;
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                default:
                {
                    // we do not expect primitive values if there is still a
                    // reference token to process
                    return false;
                }
            }
        }

        // no reference token left means we found a primitive value
        return true;
    }

    /*!
    @brief split the string input to reference tokens

    @note This function is only called by the json_pointer constructor.
          All exceptions below are documented there.

    @throw parse_error.107  if the pointer is not empty or begins with '/'
    @throw parse_error.108  if character '~' is not followed by '0' or '1'
    */
    static std::vector<std::string> split(const std::string& reference_string)
    {
        std::vector<std::string> result;

        // special case: empty reference string -> no reference tokens
        if (reference_string.empty())
        {
            return result;
        }

        // check if nonempty reference string begins with slash
        if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
        {
            JSON_THROW(detail::parse_error::create(107, 1,
                                                   "JSON pointer must be empty or begin with '/' - was: '" +
                                                   reference_string + "'"));
        }

        // extract the reference tokens:
        // - slash: position of the last read slash (or end of string)
        // - start: position after the previous slash
        for (
            // search for the first slash after the first character
            std::size_t slash = reference_string.find_first_of('/', 1),
            // set the beginning of the first reference token
            start = 1;
            // we can stop if start == 0 (if slash == std::string::npos)
            start != 0;
            // set the beginning of the next reference token
            // (will eventually be 0 if slash == std::string::npos)
            start = (slash == std::string::npos) ? 0 : slash + 1,
            // find next slash
            slash = reference_string.find_first_of('/', start))
        {
            // use the text between the beginning of the reference token
            // (start) and the last slash (slash).
            auto reference_token = reference_string.substr(start, slash - start);

            // check reference tokens are properly escaped
            for (std::size_t pos = reference_token.find_first_of('~');
                    pos != std::string::npos;
                    pos = reference_token.find_first_of('~', pos + 1))
            {
                assert(reference_token[pos] == '~');

                // ~ must be followed by 0 or 1
                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 or
                                         (reference_token[pos + 1] != '0' and
                                          reference_token[pos + 1] != '1')))
                {
                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'"));
                }
            }

            // finally, store the reference token
            unescape(reference_token);
            result.push_back(reference_token);
        }

        return result;
    }

    /*!
    @brief replace all occurrences of a substring by another string

    @param[in,out] s  the string to manipulate; changed so that all
                   occurrences of @a f are replaced with @a t
    @param[in]     f  the substring to replace with @a t
    @param[in]     t  the string to replace @a f

    @pre The search string @a f must not be empty. **This precondition is
    enforced with an assertion.**

    @since version 2.0.0
    */
    static void replace_substring(std::string& s, const std::string& f,
                                  const std::string& t)
    {
        assert(not f.empty());
        for (auto pos = s.find(f);                // find first occurrence of f
                pos != std::string::npos;         // make sure f was found
                s.replace(pos, f.size(), t),      // replace with t, and
                pos = s.find(f, pos + t.size()))  // find next occurrence of f
        {}
    }

    /// escape "~" to "~0" and "/" to "~1"
    static std::string escape(std::string s)
    {
        replace_substring(s, "~", "~0");
        replace_substring(s, "/", "~1");
        return s;
    }

    /// unescape "~1" to tilde and "~0" to slash (order is important!)
    static void unescape(std::string& s)
    {
        replace_substring(s, "~1", "/");
        replace_substring(s, "~0", "~");
    }

    /*!
    @param[in] reference_string  the reference string to the current value
    @param[in] value             the value to consider
    @param[in,out] result        the result object to insert values to

    @note Empty objects or arrays are flattened to `null`.
    */
    static void flatten(const std::string& reference_string,
                        const BasicJsonType& value,
                        BasicJsonType& result)
    {
        switch (value.type())
        {
            case detail::value_t::array:
            {
                if (value.m_value.array->empty())
                {
                    // flatten empty array as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate array and use index as reference string
                    for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
                    {
                        flatten(reference_string + "/" + std::to_string(i),
                                value.m_value.array->operator[](i), result);
                    }
                }
                break;
            }

            case detail::value_t::object:
            {
                if (value.m_value.object->empty())
                {
                    // flatten empty object as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate object and use keys as reference string
                    for (const auto& element : *value.m_value.object)
                    {
                        flatten(reference_string + "/" + escape(element.first), element.second, result);
                    }
                }
                break;
            }

            default:
            {
                // add primitive value with its reference string
                result[reference_string] = value;
                break;
            }
        }
    }

    /*!
    @param[in] value  flattened JSON

    @return unflattened JSON

    @throw parse_error.109 if array index is not a number
    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive
    @throw type_error.313  if value cannot be unflattened
    */
    static BasicJsonType
    unflatten(const BasicJsonType& value)
    {
        if (JSON_HEDLEY_UNLIKELY(not value.is_object()))
        {
            JSON_THROW(detail::type_error::create(314, "only objects can be unflattened"));
        }

        BasicJsonType result;

        // iterate the JSON object values
        for (const auto& element : *value.m_value.object)
        {
            if (JSON_HEDLEY_UNLIKELY(not element.second.is_primitive()))
            {
                JSON_THROW(detail::type_error::create(315, "values in object must be primitive"));
            }

            // assign value to reference pointed to by JSON pointer; Note that if
            // the JSON pointer is "" (i.e., points to the whole value), function
            // get_and_create returns a reference to result itself. An assignment
            // will then create a primitive value.
            json_pointer(element.first).get_and_create(result) = element.second;
        }

        return result;
    }

    /*!
    @brief compares two JSON pointers for equality

    @param[in] lhs  JSON pointer to compare
    @param[in] rhs  JSON pointer to compare
    @return whether @a lhs is equal to @a rhs

    @complexity Linear in the length of the JSON pointer

    @exceptionsafety No-throw guarantee: this function never throws exceptions.
    */
    friend bool operator==(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept
    {
        return lhs.reference_tokens == rhs.reference_tokens;
    }

    /*!
    @brief compares two JSON pointers for inequality

    @param[in] lhs  JSON pointer to compare
    @param[in] rhs  JSON pointer to compare
    @return whether @a lhs is not equal @a rhs

    @complexity Linear in the length of the JSON pointer

    @exceptionsafety No-throw guarantee: this function never throws exceptions.
    */
    friend bool operator!=(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept
    {
        return not (lhs == rhs);
    }

    /// the reference tokens
    std::vector<std::string> reference_tokens;
};
}  // namespace nlohmann

// #include <nlohmann/detail/json_ref.hpp>


#include <initializer_list>
#include <utility>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
namespace detail
{
template<typename BasicJsonType>
class json_ref
{
  public:
    using value_type = BasicJsonType;

    json_ref(value_type&& value)
        : owned_value(std::move(value)), value_ref(&owned_value), is_rvalue(true)
    {}

    json_ref(const value_type& value)
        : value_ref(const_cast<value_type*>(&value)), is_rvalue(false)
    {}

    json_ref(std::initializer_list<json_ref> init)
        : owned_value(init), value_ref(&owned_value), is_rvalue(true)
    {}

    template <
        class... Args,
        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
    json_ref(Args && ... args)
        : owned_value(std::forward<Args>(args)...), value_ref(&owned_value),
          is_rvalue(true) {}

    // class should be movable only
    json_ref(json_ref&&) = default;
    json_ref(const json_ref&) = delete;
    json_ref& operator=(const json_ref&) = delete;
    json_ref& operator=(json_ref&&) = delete;
    ~json_ref() = default;

    value_type moved_or_copied() const
    {
        if (is_rvalue)
        {
            return std::move(*value_ref);
        }
        return *value_ref;
    }

    value_type const& operator*() const
    {
        return *static_cast<value_type const*>(value_ref);
    }

    value_type const* operator->() const
    {
        return static_cast<value_type const*>(value_ref);
    }

  private:
    mutable value_type owned_value = nullptr;
    value_type* value_ref = nullptr;
    const bool is_rvalue;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>


#include <algorithm> // reverse
#include <array> // array
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits
#include <string> // string

// #include <nlohmann/detail/input/binary_reader.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>


#include <algorithm> // copy
#include <cstddef> // size_t
#include <ios> // streamsize
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <ostream> // basic_ostream
#include <string> // basic_string
#include <vector> // vector
// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
/// abstract output adapter interface
template<typename CharType> struct output_adapter_protocol
{
    virtual void write_character(CharType c) = 0;
    virtual void write_characters(const CharType* s, std::size_t length) = 0;
    virtual ~output_adapter_protocol() = default;
};

/// a type to simplify interfaces
template<typename CharType>
using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

/// output adapter for byte vectors
template<typename CharType>
class output_vector_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_vector_adapter(std::vector<CharType>& vec) noexcept
        : v(vec)
    {}

    void write_character(CharType c) override
    {
        v.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        std::copy(s, s + length, std::back_inserter(v));
    }

  private:
    std::vector<CharType>& v;
};

/// output adapter for output streams
template<typename CharType>
class output_stream_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
        : stream(s)
    {}

    void write_character(CharType c) override
    {
        stream.put(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        stream.write(s, static_cast<std::streamsize>(length));
    }

  private:
    std::basic_ostream<CharType>& stream;
};

/// output adapter for basic_string
template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_string_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_string_adapter(StringType& s) noexcept
        : str(s)
    {}

    void write_character(CharType c) override
    {
        str.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        str.append(s, length);
    }

  private:
    StringType& str;
};

template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_adapter
{
  public:
    output_adapter(std::vector<CharType>& vec)
        : oa(std::make_shared<output_vector_adapter<CharType>>(vec)) {}

    output_adapter(std::basic_ostream<CharType>& s)
        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}

    output_adapter(StringType& s)
        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

    operator output_adapter_t<CharType>()
    {
        return oa;
    }

  private:
    output_adapter_t<CharType> oa = nullptr;
};
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
///////////////////
// binary writer //
///////////////////

/*!
@brief serialization to CBOR and MessagePack values
*/
template<typename BasicJsonType, typename CharType>
class binary_writer
{
    using string_t = typename BasicJsonType::string_t;

  public:
    /*!
    @brief create a binary writer

    @param[in] adapter  output adapter to write to
    */
    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(adapter)
    {
        assert(oa);
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
            {
                write_bson_object(*j.m_value.object);
                break;
            }

            default:
            {
                JSON_THROW(type_error::create(317, "to serialize to BSON, top-level type must be object, but is " + std::string(j.type_name())));
            }
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_cbor(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                oa->write_character(to_char_type(0xF6));
                break;
            }

            case value_t::boolean:
            {
                oa->write_character(j.m_value.boolean
                                    ? to_char_type(0xF5)
                                    : to_char_type(0xF4));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // CBOR does not differentiate between positive signed
                    // integers and unsigned integers. Therefore, we used the
                    // code from the value_t::number_unsigned case here.
                    if (j.m_value.number_integer <= 0x17)
                    {
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x18));
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x19));
                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x1A));
                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x1B));
                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    // The conversions below encode the sign in the first
                    // byte, and the value is converted to a positive number.
                    const auto positive_number = -1 - j.m_value.number_integer;
                    if (j.m_value.number_integer >= -24)
                    {
                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x38));
                        write_number(static_cast<std::uint8_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x39));
                        write_number(static_cast<std::uint16_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x3A));
                        write_number(static_cast<std::uint32_t>(positive_number));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x3B));
                        write_number(static_cast<std::uint64_t>(positive_number));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x18));
                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x19));
                    write_number(static_cast<std::uint16_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x1A));
                    write_number(static_cast<std::uint32_t>(j.m_value.number_unsigned));
                }
                else
                {
                    oa->write_character(to_char_type(0x1B));
                    write_number(static_cast<std::uint64_t>(j.m_value.number_unsigned));
                }
                break;
            }

            case value_t::number_float:
            {
                oa->write_character(get_cbor_float_prefix(j.m_value.number_float));
                write_number(j.m_value.number_float);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x60 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x78));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x79));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x7A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x7B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x80 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x98));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x99));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x9A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x9B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_cbor(el);
                }
                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0xA0 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0xB8));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0xB9));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0xBA));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0xBB));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_cbor(el.first);
                    write_cbor(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_msgpack(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null: // nil
            {
                oa->write_character(to_char_type(0xC0));
                break;
            }

            case value_t::boolean: // true and false
            {
                oa->write_character(j.m_value.boolean
                                    ? to_char_type(0xC3)
                                    : to_char_type(0xC2));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // MessagePack does not differentiate between positive
                    // signed integers and unsigned integers. Therefore, we used
                    // the code from the value_t::number_unsigned case here.
                    if (j.m_value.number_unsigned < 128)
                    {
                        // positive fixnum
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        // uint 8
                        oa->write_character(to_char_type(0xCC));
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        // uint 16
                        oa->write_character(to_char_type(0xCD));
                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        // uint 32
                        oa->write_character(to_char_type(0xCE));
                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        // uint 64
                        oa->write_character(to_char_type(0xCF));
                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    if (j.m_value.number_integer >= -32)
                    {
                        // negative fixnum
                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                    {
                        // int 8
                        oa->write_character(to_char_type(0xD0));
                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                    {
                        // int 16
                        oa->write_character(to_char_type(0xD1));
                        write_number(static_cast<std::int16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                    {
                        // int 32
                        oa->write_character(to_char_type(0xD2));
                        write_number(static_cast<std::int32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                    {
                        // int 64
                        oa->write_character(to_char_type(0xD3));
                        write_number(static_cast<std::int64_t>(j.m_value.number_integer));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned < 128)
                {
                    // positive fixnum
                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // uint 8
                    oa->write_character(to_char_type(0xCC));
                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // uint 16
                    oa->write_character(to_char_type(0xCD));
                    write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // uint 32
                    oa->write_character(to_char_type(0xCE));
                    write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    // uint 64
                    oa->write_character(to_char_type(0xCF));
                    write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                }
                break;
            }

            case value_t::number_float:
            {
                oa->write_character(get_msgpack_float_prefix(j.m_value.number_float));
                write_number(j.m_value.number_float);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 31)
                {
                    // fixstr
                    write_number(static_cast<std::uint8_t>(0xA0 | N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // str 8
                    oa->write_character(to_char_type(0xD9));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // str 16
                    oa->write_character(to_char_type(0xDA));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // str 32
                    oa->write_character(to_char_type(0xDB));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 15)
                {
                    // fixarray
                    write_number(static_cast<std::uint8_t>(0x90 | N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // array 16
                    oa->write_character(to_char_type(0xDC));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // array 32
                    oa->write_character(to_char_type(0xDD));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_msgpack(el);
                }
                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 15)
                {
                    // fixmap
                    write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // map 16
                    oa->write_character(to_char_type(0xDE));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // map 32
                    oa->write_character(to_char_type(0xDF));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_msgpack(el.first);
                    write_msgpack(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    @param[in] use_count   whether to use '#' prefixes (optimized format)
    @param[in] use_type    whether to use '$' prefixes (optimized format)
    @param[in] add_prefix  whether prefixes need to be used for this value
    */
    void write_ubjson(const BasicJsonType& j, const bool use_count,
                      const bool use_type, const bool add_prefix = true)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('Z'));
                }
                break;
            }

            case value_t::boolean:
            {
                if (add_prefix)
                {
                    oa->write_character(j.m_value.boolean
                                        ? to_char_type('T')
                                        : to_char_type('F'));
                }
                break;
            }

            case value_t::number_integer:
            {
                write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
                break;
            }

            case value_t::number_unsigned:
            {
                write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
                break;
            }

            case value_t::number_float:
            {
                write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
                break;
            }

            case value_t::string:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('S'));
                }
                write_number_with_ubjson_prefix(j.m_value.string->size(), true);
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                bool prefix_required = true;
                if (use_type and not j.m_value.array->empty())
                {
                    assert(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front());
                    const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
                                                         [this, first_prefix](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v) == first_prefix;
                    });

                    if (same_prefix)
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.array->size(), true);
                }

                for (const auto& el : *j.m_value.array)
                {
                    write_ubjson(el, use_count, use_type, prefix_required);
                }

                if (not use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::object:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('{'));
                }

                bool prefix_required = true;
                if (use_type and not j.m_value.object->empty())
                {
                    assert(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front());
                    const bool same_prefix = std::all_of(j.begin(), j.end(),
                                                         [this, first_prefix](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v) == first_prefix;
                    });

                    if (same_prefix)
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.object->size(), true);
                }

                for (const auto& el : *j.m_value.object)
                {
                    write_number_with_ubjson_prefix(el.first.size(), true);
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(el.first.c_str()),
                        el.first.size());
                    write_ubjson(el.second, use_count, use_type, prefix_required);
                }

                if (not use_count)
                {
                    oa->write_character(to_char_type('}'));
                }

                break;
            }

            default:
                break;
        }
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @return The size of a BSON document entry header, including the id marker
            and the entry name size (and its null-terminator).
    */
    static std::size_t calc_bson_entry_header_size(const string_t& name)
    {
        const auto it = name.find(static_cast<typename string_t::value_type>(0));
        if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
        {
            JSON_THROW(out_of_range::create(409,
                                            "BSON key cannot contain code point U+0000 (at byte " + std::to_string(it) + ")"));
        }

        return /*id*/ 1ul + name.size() + /*zero-terminator*/1u;
    }

    /*!
    @brief Writes the given @a element_type and @a name to the output adapter
    */
    void write_bson_entry_header(const string_t& name,
                                 const std::uint8_t element_type)
    {
        oa->write_character(to_char_type(element_type)); // boolean
        oa->write_characters(
            reinterpret_cast<const CharType*>(name.c_str()),
            name.size() + 1u);
    }

    /*!
    @brief Writes a BSON element with key @a name and boolean value @a value
    */
    void write_bson_boolean(const string_t& name,
                            const bool value)
    {
        write_bson_entry_header(name, 0x08);
        oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and double value @a value
    */
    void write_bson_double(const string_t& name,
                           const double value)
    {
        write_bson_entry_header(name, 0x01);
        write_number<double, true>(value);
    }

    /*!
    @return The size of the BSON-encoded string in @a value
    */
    static std::size_t calc_bson_string_size(const string_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and string value @a value
    */
    void write_bson_string(const string_t& name,
                           const string_t& value)
    {
        write_bson_entry_header(name, 0x02);

        write_number<std::int32_t, true>(static_cast<std::int32_t>(value.size() + 1ul));
        oa->write_characters(
            reinterpret_cast<const CharType*>(value.c_str()),
            value.size() + 1);
    }

    /*!
    @brief Writes a BSON element with key @a name and null value
    */
    void write_bson_null(const string_t& name)
    {
        write_bson_entry_header(name, 0x0A);
    }

    /*!
    @return The size of the BSON-encoded integer @a value
    */
    static std::size_t calc_bson_integer_size(const std::int64_t value)
    {
        return (std::numeric_limits<std::int32_t>::min)() <= value and value <= (std::numeric_limits<std::int32_t>::max)()
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and integer @a value
    */
    void write_bson_integer(const string_t& name,
                            const std::int64_t value)
    {
        if ((std::numeric_limits<std::int32_t>::min)() <= value and value <= (std::numeric_limits<std::int32_t>::max)())
        {
            write_bson_entry_header(name, 0x10); // int32
            write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
        }
        else
        {
            write_bson_entry_header(name, 0x12); // int64
            write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
        }
    }

    /*!
    @return The size of the BSON-encoded unsigned integer in @a j
    */
    static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
    {
        return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and unsigned @a value
    */
    void write_bson_unsigned(const string_t& name,
                             const std::uint64_t value)
    {
        if (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            write_bson_entry_header(name, 0x10 /* int32 */);
            write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
        }
        else if (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            write_bson_entry_header(name, 0x12 /* int64 */);
            write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
        }
        else
        {
            JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(value) + " cannot be represented by BSON as it does not fit int64"));
        }
    }

    /*!
    @brief Writes a BSON element with key @a name and object @a value
    */
    void write_bson_object_entry(const string_t& name,
                                 const typename BasicJsonType::object_t& value)
    {
        write_bson_entry_header(name, 0x03); // object
        write_bson_object(value);
    }

    /*!
    @return The size of the BSON-encoded array @a value
    */
    static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
    {
        std::size_t embedded_document_size = 0ul;
        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            embedded_document_size += calc_bson_element_size(std::to_string(array_index++), el);
        }

        return sizeof(std::int32_t) + embedded_document_size + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and array @a value
    */
    void write_bson_array(const string_t& name,
                          const typename BasicJsonType::array_t& value)
    {
        write_bson_entry_header(name, 0x04); // array
        write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_array_size(value)));

        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            write_bson_element(std::to_string(array_index++), el);
        }

        oa->write_character(to_char_type(0x00));
    }

    /*!
    @brief Calculates the size necessary to serialize the JSON value @a j with its @a name
    @return The calculated size for the BSON document entry for @a j with the given @a name.
    */
    static std::size_t calc_bson_element_size(const string_t& name,
            const BasicJsonType& j)
    {
        const auto header_size = calc_bson_entry_header_size(name);
        switch (j.type())
        {
            case value_t::object:
                return header_size + calc_bson_object_size(*j.m_value.object);

            case value_t::array:
                return header_size + calc_bson_array_size(*j.m_value.array);

            case value_t::boolean:
                return header_size + 1ul;

            case value_t::number_float:
                return header_size + 8ul;

            case value_t::number_integer:
                return header_size + calc_bson_integer_size(j.m_value.number_integer);

            case value_t::number_unsigned:
                return header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);

            case value_t::string:
                return header_size + calc_bson_string_size(*j.m_value.string);

            case value_t::null:
                return header_size + 0ul;

            // LCOV_EXCL_START
            default:
                assert(false);
                return 0ul;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Serializes the JSON value @a j to BSON and associates it with the
           key @a name.
    @param name The name to associate with the JSON entity @a j within the
                current BSON document
    @return The size of the BSON entry
    */
    void write_bson_element(const string_t& name,
                            const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
                return write_bson_object_entry(name, *j.m_value.object);

            case value_t::array:
                return write_bson_array(name, *j.m_value.array);

            case value_t::boolean:
                return write_bson_boolean(name, j.m_value.boolean);

            case value_t::number_float:
                return write_bson_double(name, j.m_value.number_float);

            case value_t::number_integer:
                return write_bson_integer(name, j.m_value.number_integer);

            case value_t::number_unsigned:
                return write_bson_unsigned(name, j.m_value.number_unsigned);

            case value_t::string:
                return write_bson_string(name, *j.m_value.string);

            case value_t::null:
                return write_bson_null(name);

            // LCOV_EXCL_START
            default:
                assert(false);
                return;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Calculates the size of the BSON serialization of the given
           JSON-object @a j.
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
    {
        std::size_t document_size = std::accumulate(value.begin(), value.end(), 0ul,
                                    [](size_t result, const typename BasicJsonType::object_t::value_type & el)
        {
            return result += calc_bson_element_size(el.first, el.second);
        });

        return sizeof(std::int32_t) + document_size + 1ul;
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson_object(const typename BasicJsonType::object_t& value)
    {
        write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_object_size(value)));

        for (const auto& el : value)
        {
            write_bson_element(el.first, el.second);
        }

        oa->write_character(to_char_type(0x00));
    }

    //////////
    // CBOR //
    //////////

    static constexpr CharType get_cbor_float_prefix(float /*unused*/)
    {
        return to_char_type(0xFA);  // Single-Precision Float
    }

    static constexpr CharType get_cbor_float_prefix(double /*unused*/)
    {
        return to_char_type(0xFB);  // Double-Precision Float
    }

    /////////////
    // MsgPack //
    /////////////

    static constexpr CharType get_msgpack_float_prefix(float /*unused*/)
    {
        return to_char_type(0xCA);  // float 32
    }

    static constexpr CharType get_msgpack_float_prefix(double /*unused*/)
    {
        return to_char_type(0xCB);  // float 64
    }

    ////////////
    // UBJSON //
    ////////////

    // UBJSON: write number (floating point)
    template<typename NumberType, typename std::enable_if<
                 std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if (add_prefix)
        {
            oa->write_character(get_ubjson_float_prefix(n));
        }
        write_number(n);
    }

    // UBJSON: write number (unsigned integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_unsigned<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if (n <= (std::numeric_limits<std::uint8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n));
        }
        else
        {
            JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(n) + " cannot be represented by UBJSON as it does not fit int64"));
        }
    }

    // UBJSON: write number (signed integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_signed<NumberType>::value and
                 not std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if ((std::numeric_limits<std::int8_t>::min)() <= n and n <= (std::numeric_limits<std::int8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::int8_t>(n));
        }
        else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n and n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if ((std::numeric_limits<std::int16_t>::min)() <= n and n <= (std::numeric_limits<std::int16_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n));
        }
        else if ((std::numeric_limits<std::int32_t>::min)() <= n and n <= (std::numeric_limits<std::int32_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n));
        }
        else if ((std::numeric_limits<std::int64_t>::min)() <= n and n <= (std::numeric_limits<std::int64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n));
        }
        // LCOV_EXCL_START
        else
        {
            JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(n) + " cannot be represented by UBJSON as it does not fit int64"));
        }
        // LCOV_EXCL_STOP
    }

    /*!
    @brief determine the type prefix of container values

    @note This function does not need to be 100% accurate when it comes to
          integer limits. In case a number exceeds the limits of int64_t,
          this will be detected by a later call to function
          write_number_with_ubjson_prefix. Therefore, we return 'L' for any
          value that does not fit the previous limits.
    */
    CharType ubjson_prefix(const BasicJsonType& j) const noexcept
    {
        switch (j.type())
        {
            case value_t::null:
                return 'Z';

            case value_t::boolean:
                return j.m_value.boolean ? 'T' : 'F';

            case value_t::number_integer:
            {
                if ((std::numeric_limits<std::int8_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                {
                    return 'i';
                }
                if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    return 'U';
                }
                if ((std::numeric_limits<std::int16_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                {
                    return 'I';
                }
                if ((std::numeric_limits<std::int32_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                {
                    return 'l';
                }
                // no check and assume int64_t (see note above)
                return 'L';
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
                {
                    return 'i';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
                {
                    return 'U';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
                {
                    return 'I';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
                {
                    return 'l';
                }
                // no check and assume int64_t (see note above)
                return 'L';
            }

            case value_t::number_float:
                return get_ubjson_float_prefix(j.m_value.number_float);

            case value_t::string:
                return 'S';

            case value_t::array:
                return '[';

            case value_t::object:
                return '{';

            default:  // discarded values
                return 'N';
        }
    }

    static constexpr CharType get_ubjson_float_prefix(float /*unused*/)
    {
        return 'd';  // float 32
    }

    static constexpr CharType get_ubjson_float_prefix(double /*unused*/)
    {
        return 'D';  // float 64
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*
    @brief write a number to output input
    @param[in] n number of type @a NumberType
    @tparam NumberType the type of the number
    @tparam OutputIsLittleEndian Set to true if output data is
                                 required to be little endian

    @note This function needs to respect the system's endianess, because bytes
          in CBOR, MessagePack, and UBJSON are stored in network order (big
          endian) and therefore need reordering on little endian systems.
    */
    template<typename NumberType, bool OutputIsLittleEndian = false>
    void write_number(const NumberType n)
    {
        // step 1: write number to array of length NumberType
        std::array<CharType, sizeof(NumberType)> vec;
        std::memcpy(vec.data(), &n, sizeof(NumberType));

        // step 2: write array to output (with possible reordering)
        if (is_little_endian != OutputIsLittleEndian)
        {
            // reverse byte order prior to conversion if necessary
            std::reverse(vec.begin(), vec.end());
        }

        oa->write_characters(vec.data(), sizeof(NumberType));
    }

  public:
    // The following to_char_type functions are implement the conversion
    // between uint8_t and CharType. In case CharType is not unsigned,
    // such a conversion is required to allow values greater than 128.
    // See <https://github.com/nlohmann/json/issues/1286> for a discussion.
    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value and std::is_signed<char>::value > * = nullptr >
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return *reinterpret_cast<char*>(&x);
    }

    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value and std::is_unsigned<char>::value > * = nullptr >
    static CharType to_char_type(std::uint8_t x) noexcept
    {
        static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
        static_assert(std::is_pod<CharType>::value, "CharType must be POD");
        CharType result;
        std::memcpy(&result, &x, sizeof(x));
        return result;
    }

    template<typename C = CharType,
             enable_if_t<std::is_unsigned<C>::value>* = nullptr>
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return x;
    }

    template < typename InputCharType, typename C = CharType,
               enable_if_t <
                   std::is_signed<C>::value and
                   std::is_signed<char>::value and
                   std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
                   > * = nullptr >
    static constexpr CharType to_char_type(InputCharType x) noexcept
    {
        return x;
    }

  private:
    /// whether we can assume little endianess
    const bool is_little_endian = binary_reader<BasicJsonType>::little_endianess();

    /// the output
    output_adapter_t<CharType> oa = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/output/serializer.hpp>


#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <cassert> // assert
#include <ciso646> // and, or
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string
#include <type_traits> // is_same
#include <utility> // move

// #include <nlohmann/detail/conversions/to_chars.hpp>


#include <array> // array
#include <cassert> // assert
#include <ciso646> // or, and, not
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove
#include <limits> // numeric_limits
#include <type_traits> // conditional
// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{

/*!
@brief implements the Grisu2 algorithm for binary to decimal floating-point
conversion.

This implementation is a slightly modified version of the reference
implementation which may be obtained from
http://florian.loitsch.com/publications (bench.tar.gz).

The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see:

[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
    Language Design and Implementation, PLDI 2010
[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
    Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
    Design and Implementation, PLDI 1996
*/
namespace dtoa_impl
{

template <typename Target, typename Source>
Target reinterpret_bits(const Source source)
{
    static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

    Target target;
    std::memcpy(&target, &source, sizeof(Source));
    return target;
}

struct diyfp // f * 2^e
{
    static constexpr int kPrecision = 64; // = q

    std::uint64_t f = 0;
    int e = 0;

    constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

    /*!
    @brief returns x - y
    @pre x.e == y.e and x.f >= y.f
    */
    static diyfp sub(const diyfp& x, const diyfp& y) noexcept
    {
        assert(x.e == y.e);
        assert(x.f >= y.f);

        return {x.f - y.f, x.e};
    }

    /*!
    @brief returns x * y
    @note The result is rounded. (Only the upper q bits are returned.)
    */
    static diyfp mul(const diyfp& x, const diyfp& y) noexcept
    {
        static_assert(kPrecision == 64, "internal error");

        // Computes:
        //  f = round((x.f * y.f) / 2^q)
        //  e = x.e + y.e + q

        // Emulate the 64-bit * 64-bit multiplication:
        //
        // p = u * v
        //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
        //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
        //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
        //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
        //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
        //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
        //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
        //
        // (Since Q might be larger than 2^32 - 1)
        //
        //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
        //
        // (Q_hi + H does not overflow a 64-bit int)
        //
        //   = p_lo + 2^64 p_hi

        const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
        const std::uint64_t u_hi = x.f >> 32u;
        const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
        const std::uint64_t v_hi = y.f >> 32u;

        const std::uint64_t p0 = u_lo * v_lo;
        const std::uint64_t p1 = u_lo * v_hi;
        const std::uint64_t p2 = u_hi * v_lo;
        const std::uint64_t p3 = u_hi * v_hi;

        const std::uint64_t p0_hi = p0 >> 32u;
        const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
        const std::uint64_t p1_hi = p1 >> 32u;
        const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
        const std::uint64_t p2_hi = p2 >> 32u;

        std::uint64_t Q = p0_hi + p1_lo + p2_lo;

        // The full product might now be computed as
        //
        // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
        // p_lo = p0_lo + (Q << 32)
        //
        // But in this particular case here, the full p_lo is not required.
        // Effectively we only need to add the highest bit in p_lo to p_hi (and
        // Q_hi + 1 does not overflow).

        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up

        const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);

        return {h, x.e + y.e + 64};
    }

    /*!
    @brief normalize x such that the significand is >= 2^(q-1)
    @pre x.f != 0
    */
    static diyfp normalize(diyfp x) noexcept
    {
        assert(x.f != 0);

        while ((x.f >> 63u) == 0)
        {
            x.f <<= 1u;
            x.e--;
        }

        return x;
    }

    /*!
    @brief normalize x such that the result has the exponent E
    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
    */
    static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
    {
        const int delta = x.e - target_exponent;

        assert(delta >= 0);
        assert(((x.f << delta) >> delta) == x.f);

        return {x.f << delta, target_exponent};
    }
};

struct boundaries
{
    diyfp w;
    diyfp minus;
    diyfp plus;
};

/*!
Compute the (normalized) diyfp representing the input number 'value' and its
boundaries.

@pre value must be finite and positive
*/
template <typename FloatType>
boundaries compute_boundaries(FloatType value)
{
    assert(std::isfinite(value));
    assert(value > 0);

    // Convert the IEEE representation into a diyfp.
    //
    // If v is denormal:
    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
    // If v is normalized:
    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

    static_assert(std::numeric_limits<FloatType>::is_iec559,
                  "internal error: dtoa_short requires an IEEE-754 floating-point implementation");

    constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
    constexpr int      kMinExp    = 1 - kBias;
    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)

    using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;

    const std::uint64_t bits = reinterpret_bits<bits_type>(value);
    const std::uint64_t E = bits >> (kPrecision - 1);
    const std::uint64_t F = bits & (kHiddenBit - 1);

    const bool is_denormal = E == 0;
    const diyfp v = is_denormal
                    ? diyfp(F, kMinExp)
                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

    // Compute the boundaries m- and m+ of the floating-point value
    // v = f * 2^e.
    //
    // Determine v- and v+, the floating-point predecessor and successor if v,
    // respectively.
    //
    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
    //
    //      v+ = v + 2^e
    //
    // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
    // between m- and m+ round to v, regardless of how the input rounding
    // algorithm breaks ties.
    //
    //      ---+-------------+-------------+-------------+-------------+---  (A)
    //         v-            m-            v             m+            v+
    //
    //      -----------------+------+------+-------------+-------------+---  (B)
    //                       v-     m-     v             m+            v+

    const bool lower_boundary_is_closer = F == 0 and E > 1;
    const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
    const diyfp m_minus = lower_boundary_is_closer
                          ? diyfp(4 * v.f - 1, v.e - 2)  // (B)
                          : diyfp(2 * v.f - 1, v.e - 1); // (A)

    // Determine the normalized w+ = m+.
    const diyfp w_plus = diyfp::normalize(m_plus);

    // Determine w- = m- such that e_(w-) = e_(w+).
    const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

    return {diyfp::normalize(v), w_minus, w_plus};
}

// Given normalized diyfp w, Grisu needs to find a (normalized) cached
// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
// within a certain range [alpha, gamma] (Definition 3.2 from [1])
//
//      alpha <= e = e_c + e_w + q <= gamma
//
// or
//
//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
//                          <= f_c * f_w * 2^gamma
//
// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
//
//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
//
// or
//
//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
//
// The choice of (alpha,gamma) determines the size of the table and the form of
// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
// in practice:
//
// The idea is to cut the number c * w = f * 2^e into two parts, which can be
// processed independently: An integral part p1, and a fractional part p2:
//
//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
//              = (f div 2^-e) + (f mod 2^-e) * 2^e
//              = p1 + p2 * 2^e
//
// The conversion of p1 into decimal form requires a series of divisions and
// modulos by (a power of) 10. These operations are faster for 32-bit than for
// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
// achieved by choosing
//
//      -e >= 32   or   e <= -32 := gamma
//
// In order to convert the fractional part
//
//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
//
// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
// d[-i] are extracted in order:
//
//      (10 * p2) div 2^-e = d[-1]
//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
//
// The multiplication by 10 must not overflow. It is sufficient to choose
//
//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
//
// Since p2 = f mod 2^-e < 2^-e,
//
//      -e <= 60   or   e >= -60 := alpha

constexpr int kAlpha = -60;
constexpr int kGamma = -32;

struct cached_power // c = f * 2^e ~= 10^k
{
    std::uint64_t f;
    int e;
    int k;
};

/*!
For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
satisfies (Definition 3.2 from [1])

     alpha <= e_c + e + q <= gamma.
*/
inline cached_power get_cached_power_for_binary_exponent(int e)
{
    // Now
    //
    //      alpha <= e_c + e + q <= gamma                                    (1)
    //      ==> f_c * 2^alpha <= c * 2^e * 2^q
    //
    // and since the c's are normalized, 2^(q-1) <= f_c,
    //
    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
    //      ==> 2^(alpha - e - 1) <= c
    //
    // If c were an exakt power of ten, i.e. c = 10^k, one may determine k as
    //
    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
    //        = ceil( (alpha - e - 1) * log_10(2) )
    //
    // From the paper:
    // "In theory the result of the procedure could be wrong since c is rounded,
    //  and the computation itself is approximated [...]. In practice, however,
    //  this simple function is sufficient."
    //
    // For IEEE double precision floating-point numbers converted into
    // normalized diyfp's w = f * 2^e, with q = 64,
    //
    //      e >= -1022      (min IEEE exponent)
    //           -52        (p - 1)
    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
    //           -11        (normalize the diyfp)
    //         = -1137
    //
    // and
    //
    //      e <= +1023      (max IEEE exponent)
    //           -52        (p - 1)
    //           -11        (normalize the diyfp)
    //         = 960
    //
    // This binary exponent range [-1137,960] results in a decimal exponent
    // range [-307,324]. One does not need to store a cached power for each
    // k in this range. For each such k it suffices to find a cached power
    // such that the exponent of the product lies in [alpha,gamma].
    // This implies that the difference of the decimal exponents of adjacent
    // table entries must be less than or equal to
    //
    //      floor( (gamma - alpha) * log_10(2) ) = 8.
    //
    // (A smaller distance gamma-alpha would require a larger table.)

    // NB:
    // Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.

    constexpr int kCachedPowersMinDecExp = -300;
    constexpr int kCachedPowersDecStep = 8;

    static constexpr std::array<cached_power, 79> kCachedPowers =
    {
        {
            { 0xAB70FE17C79AC6CA, -1060, -300 },
            { 0xFF77B1FCBEBCDC4F, -1034, -292 },
            { 0xBE5691EF416BD60C, -1007, -284 },
            { 0x8DD01FAD907FFC3C,  -980, -276 },
            { 0xD3515C2831559A83,  -954, -268 },
            { 0x9D71AC8FADA6C9B5,  -927, -260 },
            { 0xEA9C227723EE8BCB,  -901, -252 },
            { 0xAECC49914078536D,  -874, -244 },
            { 0x823C12795DB6CE57,  -847, -236 },
            { 0xC21094364DFB5637,  -821, -228 },
            { 0x9096EA6F3848984F,  -794, -220 },
            { 0xD77485CB25823AC7,  -768, -212 },
            { 0xA086CFCD97BF97F4,  -741, -204 },
            { 0xEF340A98172AACE5,  -715, -196 },
            { 0xB23867FB2A35B28E,  -688, -188 },
            { 0x84C8D4DFD2C63F3B,  -661, -180 },
            { 0xC5DD44271AD3CDBA,  -635, -172 },
            { 0x936B9FCEBB25C996,  -608, -164 },
            { 0xDBAC6C247D62A584,  -582, -156 },
            { 0xA3AB66580D5FDAF6,  -555, -148 },
            { 0xF3E2F893DEC3F126,  -529, -140 },
            { 0xB5B5ADA8AAFF80B8,  -502, -132 },
            { 0x87625F056C7C4A8B,  -475, -124 },
            { 0xC9BCFF6034C13053,  -449, -116 },
            { 0x964E858C91BA2655,  -422, -108 },
            { 0xDFF9772470297EBD,  -396, -100 },
            { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
            { 0xF8A95FCF88747D94,  -343,  -84 },
            { 0xB94470938FA89BCF,  -316,  -76 },
            { 0x8A08F0F8BF0F156B,  -289,  -68 },
            { 0xCDB02555653131B6,  -263,  -60 },
            { 0x993FE2C6D07B7FAC,  -236,  -52 },
            { 0xE45C10C42A2B3B06,  -210,  -44 },
            { 0xAA242499697392D3,  -183,  -36 },
            { 0xFD87B5F28300CA0E,  -157,  -28 },
            { 0xBCE5086492111AEB,  -130,  -20 },
            { 0x8CBCCC096F5088CC,  -103,  -12 },
            { 0xD1B71758E219652C,   -77,   -4 },
            { 0x9C40000000000000,   -50,    4 },
            { 0xE8D4A51000000000,   -24,   12 },
            { 0xAD78EBC5AC620000,     3,   20 },
            { 0x813F3978F8940984,    30,   28 },
            { 0xC097CE7BC90715B3,    56,   36 },
            { 0x8F7E32CE7BEA5C70,    83,   44 },
            { 0xD5D238A4ABE98068,   109,   52 },
            { 0x9F4F2726179A2245,   136,   60 },
            { 0xED63A231D4C4FB27,   162,   68 },
            { 0xB0DE65388CC8ADA8,   189,   76 },
            { 0x83C7088E1AAB65DB,   216,   84 },
            { 0xC45D1DF942711D9A,   242,   92 },
            { 0x924D692CA61BE758,   269,  100 },
            { 0xDA01EE641A708DEA,   295,  108 },
            { 0xA26DA3999AEF774A,   322,  116 },
            { 0xF209787BB47D6B85,   348,  124 },
            { 0xB454E4A179DD1877,   375,  132 },
            { 0x865B86925B9BC5C2,   402,  140 },
            { 0xC83553C5C8965D3D,   428,  148 },
            { 0x952AB45CFA97A0B3,   455,  156 },
            { 0xDE469FBD99A05FE3,   481,  164 },
            { 0xA59BC234DB398C25,   508,  172 },
            { 0xF6C69A72A3989F5C,   534,  180 },
            { 0xB7DCBF5354E9BECE,   561,  188 },
            { 0x88FCF317F22241E2,   588,  196 },
            { 0xCC20CE9BD35C78A5,   614,  204 },
            { 0x98165AF37B2153DF,   641,  212 },
            { 0xE2A0B5DC971F303A,   667,  220 },
            { 0xA8D9D1535CE3B396,   694,  228 },
            { 0xFB9B7CD9A4A7443C,   720,  236 },
            { 0xBB764C4CA7A44410,   747,  244 },
            { 0x8BAB8EEFB6409C1A,   774,  252 },
            { 0xD01FEF10A657842C,   800,  260 },
            { 0x9B10A4E5E9913129,   827,  268 },
            { 0xE7109BFBA19C0C9D,   853,  276 },
            { 0xAC2820D9623BF429,   880,  284 },
            { 0x80444B5E7AA7CF85,   907,  292 },
            { 0xBF21E44003ACDD2D,   933,  300 },
            { 0x8E679C2F5E44FF8F,   960,  308 },
            { 0xD433179D9C8CB841,   986,  316 },
            { 0x9E19DB92B4E31BA9,  1013,  324 },
        }
    };

    // This computation gives exactly the same results for k as
    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
    // for |e| <= 1500, but doesn't require floating-point operations.
    // NB: log_10(2) ~= 78913 / 2^18
    assert(e >= -1500);
    assert(e <=  1500);
    const int f = kAlpha - e - 1;
    const int k = (f * 78913) / (1 << 18) + static_cast<int>(f > 0);

    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
    assert(index >= 0);
    assert(static_cast<std::size_t>(index) < kCachedPowers.size());

    const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
    assert(kAlpha <= cached.e + e + 64);
    assert(kGamma >= cached.e + e + 64);

    return cached;
}

/*!
For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
For n == 0, returns 1 and sets pow10 := 1.
*/
inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
{
    // LCOV_EXCL_START
    if (n >= 1000000000)
    {
        pow10 = 1000000000;
        return 10;
    }
    // LCOV_EXCL_STOP
    else if (n >= 100000000)
    {
        pow10 = 100000000;
        return  9;
    }
    else if (n >= 10000000)
    {
        pow10 = 10000000;
        return  8;
    }
    else if (n >= 1000000)
    {
        pow10 = 1000000;
        return  7;
    }
    else if (n >= 100000)
    {
        pow10 = 100000;
        return  6;
    }
    else if (n >= 10000)
    {
        pow10 = 10000;
        return  5;
    }
    else if (n >= 1000)
    {
        pow10 = 1000;
        return  4;
    }
    else if (n >= 100)
    {
        pow10 = 100;
        return  3;
    }
    else if (n >= 10)
    {
        pow10 = 10;
        return  2;
    }
    else
    {
        pow10 = 1;
        return 1;
    }
}

inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
                         std::uint64_t rest, std::uint64_t ten_k)
{
    assert(len >= 1);
    assert(dist <= delta);
    assert(rest <= delta);
    assert(ten_k > 0);

    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    //                                  ten_k
    //                                <------>
    //                                       <---- rest ---->
    // --------------[------------------+----+--------------]--------------
    //                                  w    V
    //                                       = buf * 10^k
    //
    // ten_k represents a unit-in-the-last-place in the decimal representation
    // stored in buf.
    // Decrement buf by ten_k while this takes buf closer to w.

    // The tests are written in this order to avoid overflow in unsigned
    // integer arithmetic.

    while (rest < dist
            and delta - rest >= ten_k
            and (rest + ten_k < dist or dist - rest > rest + ten_k - dist))
    {
        assert(buf[len - 1] != '0');
        buf[len - 1]--;
        rest += ten_k;
    }
}

/*!
Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
*/
inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
                             diyfp M_minus, diyfp w, diyfp M_plus)
{
    static_assert(kAlpha >= -60, "internal error");
    static_assert(kGamma <= -32, "internal error");

    // Generates the digits (and the exponent) of a decimal floating-point
    // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
    // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
    //
    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    // Grisu2 generates the digits of M+ from left to right and stops as soon as
    // V is in [M-,M+].

    assert(M_plus.e >= kAlpha);
    assert(M_plus.e <= kGamma);

    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)

    // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
    //
    //      M+ = f * 2^e
    //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
    //         = ((p1        ) * 2^-e + (p2        )) * 2^e
    //         = p1 + p2 * 2^e

    const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);

    auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

    // 1)
    //
    // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

    assert(p1 > 0);

    std::uint32_t pow10;
    const int k = find_largest_pow10(p1, pow10);

    //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
    //
    //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
    //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
    //
    //      M+ = p1                                             + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
    //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
    //
    // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
    //
    //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
    //
    // but stop as soon as
    //
    //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

    int n = k;
    while (n > 0)
    {
        // Invariants:
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
        //      pow10 = 10^(n-1) <= p1 < 10^n
        //
        const std::uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
        const std::uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
        //
        //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
        //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
        //
        assert(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
        //
        p1 = r;
        n--;
        //
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
        //      pow10 = 10^n
        //

        // Now check if enough digits have been generated.
        // Compute
        //
        //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
        //
        // Note:
        // Since rest and delta share the same exponent e, it suffices to
        // compare the significands.
        const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
        if (rest <= delta)
        {
            // V = buffer * 10^n, with M- <= V <= M+.

            decimal_exponent += n;

            // We may now just stop. But instead look if the buffer could be
            // decremented to bring V closer to w.
            //
            // pow10 = 10^n is now 1 ulp in the decimal representation V.
            // The rounding procedure works with diyfp's with an implicit
            // exponent of e.
            //
            //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
            //
            const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
            grisu2_round(buffer, length, dist, delta, rest, ten_n);

            return;
        }

        pow10 /= 10;
        //
        //      pow10 = 10^(n-1) <= p1 < 10^n
        // Invariants restored.
    }

    // 2)
    //
    // The digits of the integral part have been generated:
    //
    //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
    //         = buffer            + p2 * 2^e
    //
    // Now generate the digits of the fractional part p2 * 2^e.
    //
    // Note:
    // No decimal point is generated: the exponent is adjusted instead.
    //
    // p2 actually represents the fraction
    //
    //      p2 * 2^e
    //          = p2 / 2^-e
    //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
    //
    // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
    //
    //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
    //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
    //
    // using
    //
    //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
    //                = (                   d) * 2^-e + (                   r)
    //
    // or
    //      10^m * p2 * 2^e = d + r * 2^e
    //
    // i.e.
    //
    //      M+ = buffer + p2 * 2^e
    //         = buffer + 10^-m * (d + r * 2^e)
    //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
    //
    // and stop as soon as 10^-m * r * 2^e <= delta * 2^e

    assert(p2 > delta);

    int m = 0;
    for (;;)
    {
        // Invariant:
        //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
        //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
        //
        assert(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
        p2 *= 10;
        const std::uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
        //
        //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
        //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        assert(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        p2 = r;
        m++;
        //
        //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
        // Invariant restored.

        // Check if enough digits have been generated.
        //
        //      10^-m * p2 * 2^e <= delta * 2^e
        //              p2 * 2^e <= 10^m * delta * 2^e
        //                    p2 <= 10^m * delta
        delta *= 10;
        dist  *= 10;
        if (p2 <= delta)
        {
            break;
        }
    }

    // V = buffer * 10^-m, with M- <= V <= M+.

    decimal_exponent -= m;

    // 1 ulp in the decimal representation is now 10^-m.
    // Since delta and dist are now scaled by 10^m, we need to do the
    // same with ulp in order to keep the units in sync.
    //
    //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
    //
    const std::uint64_t ten_m = one.f;
    grisu2_round(buffer, length, dist, delta, p2, ten_m);

    // By construction this algorithm generates the shortest possible decimal
    // number (Loitsch, Theorem 6.2) which rounds back to w.
    // For an input number of precision p, at least
    //
    //      N = 1 + ceil(p * log_10(2))
    //
    // decimal digits are sufficient to identify all binary floating-point
    // numbers (Matula, "In-and-Out conversions").
    // This implies that the algorithm does not produce more than N decimal
    // digits.
    //
    //      N = 17 for p = 53 (IEEE double precision)
    //      N = 9  for p = 24 (IEEE single precision)
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
JSON_HEDLEY_NON_NULL(1)
inline void grisu2(char* buf, int& len, int& decimal_exponent,
                   diyfp m_minus, diyfp v, diyfp m_plus)
{
    assert(m_plus.e == m_minus.e);
    assert(m_plus.e == v.e);

    //  --------(-----------------------+-----------------------)--------    (A)
    //          m-                      v                       m+
    //
    //  --------------------(-----------+-----------------------)--------    (B)
    //                      m-          v                       m+
    //
    // First scale v (and m- and m+) such that the exponent is in the range
    // [alpha, gamma].

    const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

    const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

    // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
    const diyfp w       = diyfp::mul(v,       c_minus_k);
    const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
    const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);

    //  ----(---+---)---------------(---+---)---------------(---+---)----
    //          w-                      w                       w+
    //          = c*m-                  = c*v                   = c*m+
    //
    // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
    // w+ are now off by a small amount.
    // In fact:
    //
    //      w - v * 10^k < 1 ulp
    //
    // To account for this inaccuracy, add resp. subtract 1 ulp.
    //
    //  --------+---[---------------(---+---)---------------]---+--------
    //          w-  M-                  w                   M+  w+
    //
    // Now any number in [M-, M+] (bounds included) will round to w when input,
    // regardless of how the input rounding algorithm breaks ties.
    //
    // And digit_gen generates the shortest possible such number in [M-, M+].
    // Note that this does not mean that Grisu2 always generates the shortest
    // possible number in the interval (m-, m+).
    const diyfp M_minus(w_minus.f + 1, w_minus.e);
    const diyfp M_plus (w_plus.f  - 1, w_plus.e );

    decimal_exponent = -cached.k; // = -(-k) = k

    grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
template <typename FloatType>
JSON_HEDLEY_NON_NULL(1)
void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
{
    static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
                  "internal error: not enough precision");

    assert(std::isfinite(value));
    assert(value > 0);

    // If the neighbors (and boundaries) of 'value' are always computed for double-precision
    // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
    // decimal representations are not exactly "short".
    //
    // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
    // says "value is converted to a string as if by std::sprintf in the default ("C") locale"
    // and since sprintf promotes float's to double's, I think this is exactly what 'std::to_chars'
    // does.
    // On the other hand, the documentation for 'std::to_chars' requires that "parsing the
    // representation using the corresponding std::from_chars function recovers value exactly". That
    // indicates that single precision floating-point numbers should be recovered using
    // 'std::strtof'.
    //
    // NB: If the neighbors are computed for single-precision numbers, there is a single float
    //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
    //     value is off by 1 ulp.
#if 0
    const boundaries w = compute_boundaries(static_cast<double>(value));
#else
    const boundaries w = compute_boundaries(value);
#endif

    grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
}

/*!
@brief appends a decimal representation of e to buf
@return a pointer to the element following the exponent.
@pre -1000 < e < 1000
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* append_exponent(char* buf, int e)
{
    assert(e > -1000);
    assert(e <  1000);

    if (e < 0)
    {
        e = -e;
        *buf++ = '-';
    }
    else
    {
        *buf++ = '+';
    }

    auto k = static_cast<std::uint32_t>(e);
    if (k < 10)
    {
        // Always print at least two digits in the exponent.
        // This is for compatibility with printf("%g").
        *buf++ = '0';
        *buf++ = static_cast<char>('0' + k);
    }
    else if (k < 100)
    {
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }
    else
    {
        *buf++ = static_cast<char>('0' + k / 100);
        k %= 100;
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }

    return buf;
}

/*!
@brief prettify v = buf * 10^decimal_exponent

If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
notation. Otherwise it will be printed in exponential notation.

@pre min_exp < 0
@pre max_exp > 0
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* format_buffer(char* buf, int len, int decimal_exponent,
                           int min_exp, int max_exp)
{
    assert(min_exp < 0);
    assert(max_exp > 0);

    const int k = len;
    const int n = len + decimal_exponent;

    // v = buf * 10^(n-k)
    // k is the length of the buffer (number of decimal digits)
    // n is the position of the decimal point relative to the start of the buffer.

    if (k <= n and n <= max_exp)
    {
        // digits[000]
        // len <= max_exp + 2

        std::memset(buf + k, '0', static_cast<size_t>(n - k));
        // Make it look like a floating-point number (#362, #378)
        buf[n + 0] = '.';
        buf[n + 1] = '0';
        return buf + (n + 2);
    }

    if (0 < n and n <= max_exp)
    {
        // dig.its
        // len <= max_digits10 + 1

        assert(k > n);

        std::memmove(buf + (n + 1), buf + n, static_cast<size_t>(k - n));
        buf[n] = '.';
        return buf + (k + 1);
    }

    if (min_exp < n and n <= 0)
    {
        // 0.[000]digits
        // len <= 2 + (-min_exp - 1) + max_digits10

        std::memmove(buf + (2 + -n), buf, static_cast<size_t>(k));
        buf[0] = '0';
        buf[1] = '.';
        std::memset(buf + 2, '0', static_cast<size_t>(-n));
        return buf + (2 + (-n) + k);
    }

    if (k == 1)
    {
        // dE+123
        // len <= 1 + 5

        buf += 1;
    }
    else
    {
        // d.igitsE+123
        // len <= max_digits10 + 1 + 5

        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k - 1));
        buf[1] = '.';
        buf += 1 + k;
    }

    *buf++ = 'e';
    return append_exponent(buf, n - 1);
}

} // namespace dtoa_impl

/*!
@brief generates a decimal representation of the floating-point number value in [first, last).

The format of the resulting decimal representation is similar to printf's %g
format. Returns an iterator pointing past-the-end of the decimal representation.

@note The input number must be finite, i.e. NaN's and Inf's are not supported.
@note The buffer must be large enough.
@note The result is NOT null-terminated.
*/
template <typename FloatType>
JSON_HEDLEY_NON_NULL(1, 2)
JSON_HEDLEY_RETURNS_NON_NULL
char* to_chars(char* first, const char* last, FloatType value)
{
    static_cast<void>(last); // maybe unused - fix warning
    assert(std::isfinite(value));

    // Use signbit(value) instead of (value < 0) since signbit works for -0.
    if (std::signbit(value))
    {
        value = -value;
        *first++ = '-';
    }

    if (value == 0) // +-0
    {
        *first++ = '0';
        // Make it look like a floating-point number (#362, #378)
        *first++ = '.';
        *first++ = '0';
        return first;
    }

    assert(last - first >= std::numeric_limits<FloatType>::max_digits10);

    // Compute v = buffer * 10^decimal_exponent.
    // The decimal digits are stored in the buffer, which needs to be interpreted
    // as an unsigned decimal integer.
    // len is the length of the buffer, i.e. the number of decimal digits.
    int len = 0;
    int decimal_exponent = 0;
    dtoa_impl::grisu2(first, len, decimal_exponent, value);

    assert(len <= std::numeric_limits<FloatType>::max_digits10);

    // Format the buffer like printf("%.*g", prec, value)
    constexpr int kMinExp = -4;
    // Use digits10 here to increase compatibility with version 2.
    constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

    assert(last - first >= kMaxExp + 2);
    assert(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
    assert(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

    return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
}

} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
///////////////////
// serialization //
///////////////////

/// how to treat decoding errors
enum class error_handler_t
{
    strict,  ///< throw a type_error exception in case of invalid UTF-8
    replace, ///< replace invalid UTF-8 sequences with U+FFFD
    ignore   ///< ignore invalid UTF-8 sequences
};

template<typename BasicJsonType>
class serializer
{
    using string_t = typename BasicJsonType::string_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    static constexpr std::uint8_t UTF8_ACCEPT = 0;
    static constexpr std::uint8_t UTF8_REJECT = 1;

  public:
    /*!
    @param[in] s  output stream to serialize to
    @param[in] ichar  indentation character to use
    @param[in] error_handler_  how to react on decoding errors
    */
    serializer(output_adapter_t<char> s, const char ichar,
               error_handler_t error_handler_ = error_handler_t::strict)
        : o(std::move(s))
        , loc(std::localeconv())
        , thousands_sep(loc->thousands_sep == nullptr ? '\0' : * (loc->thousands_sep))
        , decimal_point(loc->decimal_point == nullptr ? '\0' : * (loc->decimal_point))
        , indent_char(ichar)
        , indent_string(512, indent_char)
        , error_handler(error_handler_)
    {}

    // delete because of pointer members
    serializer(const serializer&) = delete;
    serializer& operator=(const serializer&) = delete;
    serializer(serializer&&) = delete;
    serializer& operator=(serializer&&) = delete;
    ~serializer() = default;

    /*!
    @brief internal implementation of the serialization function

    This function is called by the public member function dump and organizes
    the serialization internally. The indentation level is propagated as
    additional parameter. In case of arrays and objects, the function is
    called recursively.

    - strings and object keys are escaped using `escape_string()`
    - integer numbers are converted implicitly via `operator<<`
    - floating-point numbers are converted to a string using `"%g"` format

    @param[in] val             value to serialize
    @param[in] pretty_print    whether the output shall be pretty-printed
    @param[in] indent_step     the indent level
    @param[in] current_indent  the current indent level (only used internally)
    */
    void dump(const BasicJsonType& val, const bool pretty_print,
              const bool ensure_ascii,
              const unsigned int indent_step,
              const unsigned int current_indent = 0)
    {
        switch (val.m_type)
        {
            case value_t::object:
            {
                if (val.m_value.object->empty())
                {
                    o->write_characters("{}", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\": ", 3);
                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    assert(i != val.m_value.object->cend());
                    assert(std::next(i) == val.m_value.object->cend());
                    o->write_characters(indent_string.c_str(), new_indent);
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\": ", 3);
                    dump(i->second, true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_character('{');

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\":", 2);
                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    assert(i != val.m_value.object->cend());
                    assert(std::next(i) == val.m_value.object->cend());
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\":", 2);
                    dump(i->second, false, ensure_ascii, indent_step, current_indent);

                    o->write_character('}');
                }

                return;
            }

            case value_t::array:
            {
                if (val.m_value.array->empty())
                {
                    o->write_characters("[]", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("[\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        dump(*i, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    assert(not val.m_value.array->empty());
                    o->write_characters(indent_string.c_str(), new_indent);
                    dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character(']');
                }
                else
                {
                    o->write_character('[');

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        dump(*i, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    assert(not val.m_value.array->empty());
                    dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

                    o->write_character(']');
                }

                return;
            }

            case value_t::string:
            {
                o->write_character('\"');
                dump_escaped(*val.m_value.string, ensure_ascii);
                o->write_character('\"');
                return;
            }

            case value_t::boolean:
            {
                if (val.m_value.boolean)
                {
                    o->write_characters("true", 4);
                }
                else
                {
                    o->write_characters("false", 5);
                }
                return;
            }

            case value_t::number_integer:
            {
                dump_integer(val.m_value.number_integer);
                return;
            }

            case value_t::number_unsigned:
            {
                dump_integer(val.m_value.number_unsigned);
                return;
            }

            case value_t::number_float:
            {
                dump_float(val.m_value.number_float);
                return;
            }

            case value_t::discarded:
            {
                o->write_characters("<discarded>", 11);
                return;
            }

            case value_t::null:
            {
                o->write_characters("null", 4);
                return;
            }

            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }
    }

  private:
    /*!
    @brief dump escaped string

    Escape a string by replacing certain special characters by a sequence of an
    escape character (backslash) and another character and other control
    characters by a sequence of "\u" followed by a four-digit hex
    representation. The escaped string is written to output stream @a o.

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences

    @complexity Linear in the length of string @a s.
    */
    void dump_escaped(const string_t& s, const bool ensure_ascii)
    {
        std::uint32_t codepoint;
        std::uint8_t state = UTF8_ACCEPT;
        std::size_t bytes = 0;  // number of bytes written to string_buffer

        // number of bytes written at the point of the last valid byte
        std::size_t bytes_after_last_accept = 0;
        std::size_t undumped_chars = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            const auto byte = static_cast<uint8_t>(s[i]);

            switch (decode(state, codepoint, byte))
            {
                case UTF8_ACCEPT:  // decode found a new code point
                {
                    switch (codepoint)
                    {
                        case 0x08: // backspace
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'b';
                            break;
                        }

                        case 0x09: // horizontal tab
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 't';
                            break;
                        }

                        case 0x0A: // newline
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'n';
                            break;
                        }

                        case 0x0C: // formfeed
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'f';
                            break;
                        }

                        case 0x0D: // carriage return
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'r';
                            break;
                        }

                        case 0x22: // quotation mark
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\"';
                            break;
                        }

                        case 0x5C: // reverse solidus
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\\';
                            break;
                        }

                        default:
                        {
                            // escape control characters (0x00..0x1F) or, if
                            // ensure_ascii parameter is used, non-ASCII characters
                            if ((codepoint <= 0x1F) or (ensure_ascii and (codepoint >= 0x7F)))
                            {
                                if (codepoint <= 0xFFFF)
                                {
                                    (std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
                                                    static_cast<std::uint16_t>(codepoint));
                                    bytes += 6;
                                }
                                else
                                {
                                    (std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
                                                    static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
                                                    static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu)));
                                    bytes += 12;
                                }
                            }
                            else
                            {
                                // copy byte to buffer (all previous bytes
                                // been copied have in default case above)
                                string_buffer[bytes++] = s[i];
                            }
                            break;
                        }
                    }

                    // write buffer and reset index; there must be 13 bytes
                    // left, as this is the maximal number of bytes to be
                    // written ("\uxxxx\uxxxx\0") for one code point
                    if (string_buffer.size() - bytes < 13)
                    {
                        o->write_characters(string_buffer.data(), bytes);
                        bytes = 0;
                    }

                    // remember the byte position of this accept
                    bytes_after_last_accept = bytes;
                    undumped_chars = 0;
                    break;
                }

                case UTF8_REJECT:  // decode found invalid UTF-8 byte
                {
                    switch (error_handler)
                    {
                        case error_handler_t::strict:
                        {
                            std::string sn(3, '\0');
                            (std::snprintf)(&sn[0], sn.size(), "%.2X", byte);
                            JSON_THROW(type_error::create(316, "invalid UTF-8 byte at index " + std::to_string(i) + ": 0x" + sn));
                        }

                        case error_handler_t::ignore:
                        case error_handler_t::replace:
                        {
                            // in case we saw this character the first time, we
                            // would like to read it again, because the byte
                            // may be OK for itself, but just not OK for the
                            // previous sequence
                            if (undumped_chars > 0)
                            {
                                --i;
                            }

                            // reset length buffer to the last accepted index;
                            // thus removing/ignoring the invalid characters
                            bytes = bytes_after_last_accept;

                            if (error_handler == error_handler_t::replace)
                            {
                                // add a replacement character
                                if (ensure_ascii)
                                {
                                    string_buffer[bytes++] = '\\';
                                    string_buffer[bytes++] = 'u';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'd';
                                }
                                else
                                {
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
                                }

                                // write buffer and reset index; there must be 13 bytes
                                // left, as this is the maximal number of bytes to be
                                // written ("\uxxxx\uxxxx\0") for one code point
                                if (string_buffer.size() - bytes < 13)
                                {
                                    o->write_characters(string_buffer.data(), bytes);
                                    bytes = 0;
                                }

                                bytes_after_last_accept = bytes;
                            }

                            undumped_chars = 0;

                            // continue processing the string
                            state = UTF8_ACCEPT;
                            break;
                        }

                        default:            // LCOV_EXCL_LINE
                            assert(false);  // LCOV_EXCL_LINE
                    }
                    break;
                }

                default:  // decode found yet incomplete multi-byte code point
                {
                    if (not ensure_ascii)
                    {
                        // code point will not be escaped - copy byte to buffer
                        string_buffer[bytes++] = s[i];
                    }
                    ++undumped_chars;
                    break;
                }
            }
        }

        // we finished processing the string
        if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
        {
            // write buffer
            if (bytes > 0)
            {
                o->write_characters(string_buffer.data(), bytes);
            }
        }
        else
        {
            // we finish reading, but do not accept: string was incomplete
            switch (error_handler)
            {
                case error_handler_t::strict:
                {
                    std::string sn(3, '\0');
                    (std::snprintf)(&sn[0], sn.size(), "%.2X", static_cast<std::uint8_t>(s.back()));
                    JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + sn));
                }

                case error_handler_t::ignore:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    break;
                }

                case error_handler_t::replace:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    // add a replacement character
                    if (ensure_ascii)
                    {
                        o->write_characters("\\ufffd", 6);
                    }
                    else
                    {
                        o->write_characters("\xEF\xBF\xBD", 3);
                    }
                    break;
                }

                default:            // LCOV_EXCL_LINE
                    assert(false);  // LCOV_EXCL_LINE
            }
        }
    }

    /*!
    @brief count digits

    Count the number of decimal (base 10) digits for an input unsigned integer.

    @param[in] x  unsigned integer number to count its digits
    @return    number of decimal digits
    */
    inline unsigned int count_digits(number_unsigned_t x) noexcept
    {
        unsigned int n_digits = 1;
        for (;;)
        {
            if (x < 10)
            {
                return n_digits;
            }
            if (x < 100)
            {
                return n_digits + 1;
            }
            if (x < 1000)
            {
                return n_digits + 2;
            }
            if (x < 10000)
            {
                return n_digits + 3;
            }
            x = x / 10000u;
            n_digits += 4;
        }
    }

    /*!
    @brief dump an integer

    Dump a given integer to output stream @a o. Works internally with
    @a number_buffer.

    @param[in] x  integer number (signed or unsigned) to dump
    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
    */
    template<typename NumberType, detail::enable_if_t<
                 std::is_same<NumberType, number_unsigned_t>::value or
                 std::is_same<NumberType, number_integer_t>::value,
                 int> = 0>
    void dump_integer(NumberType x)
    {
        static constexpr std::array<std::array<char, 2>, 100> digits_to_99
        {
            {
                {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
                {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
                {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
                {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
                {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
                {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
                {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
                {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
                {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
                {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
            }
        };

        // special case for "0"
        if (x == 0)
        {
            o->write_character('0');
            return;
        }

        // use a pointer to fill the buffer
        auto buffer_ptr = number_buffer.begin();

        const bool is_negative = std::is_same<NumberType, number_integer_t>::value and not(x >= 0); // see issue #755
        number_unsigned_t abs_value;

        unsigned int n_chars;

        if (is_negative)
        {
            *buffer_ptr = '-';
            abs_value = static_cast<number_unsigned_t>(std::abs(static_cast<std::intmax_t>(x)));

            // account one more byte for the minus sign
            n_chars = 1 + count_digits(abs_value);
        }
        else
        {
            abs_value = static_cast<number_unsigned_t>(x);
            n_chars = count_digits(abs_value);
        }

        // spare 1 byte for '\0'
        assert(n_chars < number_buffer.size() - 1);

        // jump to the end to generate the string from backward
        // so we later avoid reversing the result
        buffer_ptr += n_chars;

        // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu
        // See: https://www.youtube.com/watch?v=o4-CwDo2zpg
        while (abs_value >= 100)
        {
            const auto digits_index = static_cast<unsigned>((abs_value % 100));
            abs_value /= 100;
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }

        if (abs_value >= 10)
        {
            const auto digits_index = static_cast<unsigned>(abs_value);
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }
        else
        {
            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
        }

        o->write_characters(number_buffer.data(), n_chars);
    }

    /*!
    @brief dump a floating-point number

    Dump a given floating-point number to output stream @a o. Works internally
    with @a number_buffer.

    @param[in] x  floating-point number to dump
    */
    void dump_float(number_float_t x)
    {
        // NaN / inf
        if (not std::isfinite(x))
        {
            o->write_characters("null", 4);
            return;
        }

        // If number_float_t is an IEEE-754 single or double precision number,
        // use the Grisu2 algorithm to produce short numbers which are
        // guaranteed to round-trip, using strtof and strtod, resp.
        //
        // NB: The test below works if <long double> == <double>.
        static constexpr bool is_ieee_single_or_double
            = (std::numeric_limits<number_float_t>::is_iec559 and std::numeric_limits<number_float_t>::digits == 24 and std::numeric_limits<number_float_t>::max_exponent == 128) or
              (std::numeric_limits<number_float_t>::is_iec559 and std::numeric_limits<number_float_t>::digits == 53 and std::numeric_limits<number_float_t>::max_exponent == 1024);

        dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
    }

    void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
    {
        char* begin = number_buffer.data();
        char* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

        o->write_characters(begin, static_cast<size_t>(end - begin));
    }

    void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
    {
        // get number of digits for a float -> text -> float round-trip
        static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

        // the actual conversion
        std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

        // negative value indicates an error
        assert(len > 0);
        // check if buffer was large enough
        assert(static_cast<std::size_t>(len) < number_buffer.size());

        // erase thousands separator
        if (thousands_sep != '\0')
        {
            const auto end = std::remove(number_buffer.begin(),
                                         number_buffer.begin() + len, thousands_sep);
            std::fill(end, number_buffer.end(), '\0');
            assert((end - number_buffer.begin()) <= len);
            len = (end - number_buffer.begin());
        }

        // convert decimal point to '.'
        if (decimal_point != '\0' and decimal_point != '.')
        {
            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
            if (dec_pos != number_buffer.end())
            {
                *dec_pos = '.';
            }
        }

        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

        // determine if need to append ".0"
        const bool value_is_int_like =
            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
                         [](char c)
        {
            return c == '.' or c == 'e';
        });

        if (value_is_int_like)
        {
            o->write_characters(".0", 2);
        }
    }

    /*!
    @brief check whether a string is UTF-8 encoded

    The function checks each byte of a string whether it is UTF-8 encoded. The
    result of the check is stored in the @a state parameter. The function must
    be called initially with state 0 (accept). State 1 means the string must
    be rejected, because the current byte is not allowed. If the string is
    completely processed, but the state is non-zero, the string ended
    prematurely; that is, the last byte indicated more bytes should have
    followed.

    @param[in,out] state  the state of the decoding
    @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
    @param[in] byte       next byte to decode
    @return               new state

    @note The function has been edited: a std::array is used.

    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
    */
    static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
    {
        static const std::array<std::uint8_t, 400> utf8d =
        {
            {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
            }
        };

        const std::uint8_t type = utf8d[byte];

        codep = (state != UTF8_ACCEPT)
                ? (byte & 0x3fu) | (codep << 6u)
                : (0xFFu >> type) & (byte);

        state = utf8d[256u + state * 16u + type];
        return state;
    }

  private:
    /// the output of the serializer
    output_adapter_t<char> o = nullptr;

    /// a (hopefully) large enough character buffer
    std::array<char, 64> number_buffer{{}};

    /// the locale
    const std::lconv* loc = nullptr;
    /// the locale's thousand separator character
    const char thousands_sep = '\0';
    /// the locale's decimal point character
    const char decimal_point = '\0';

    /// string buffer
    std::array<char, 512> string_buffer{{}};

    /// the indentation character
    const char indent_char;
    /// the indentation string
    string_t indent_string;

    /// error_handler how to react on decoding errors
    const error_handler_t error_handler;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>

// #include <nlohmann/json_fwd.hpp>


/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{

/*!
@brief a class to store JSON values

@tparam ObjectType type for JSON objects (`std::map` by default; will be used
in @ref object_t)
@tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
in @ref array_t)
@tparam StringType type for JSON strings and object keys (`std::string` by
default; will be used in @ref string_t)
@tparam BooleanType type for JSON booleans (`bool` by default; will be used
in @ref boolean_t)
@tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
default; will be used in @ref number_integer_t)
@tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
`uint64_t` by default; will be used in @ref number_unsigned_t)
@tparam NumberFloatType type for JSON floating-point numbers (`double` by
default; will be used in @ref number_float_t)
@tparam AllocatorType type of the allocator to use (`std::allocator` by
default)
@tparam JSONSerializer the serializer to resolve internal calls to `to_json()`
and `from_json()` (@ref adl_serializer by default)

@requirement The class satisfies the following concept requirements:
- Basic
 - [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible):
   JSON values can be default constructed. The result will be a JSON null
   value.
 - [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible):
   A JSON value can be constructed from an rvalue argument.
 - [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible):
   A JSON value can be copy-constructed from an lvalue expression.
 - [MoveAssignable](https://en.cppreference.com/w/cpp/named_req/MoveAssignable):
   A JSON value van be assigned from an rvalue argument.
 - [CopyAssignable](https://en.cppreference.com/w/cpp/named_req/CopyAssignable):
   A JSON value can be copy-assigned from an lvalue expression.
 - [Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible):
   JSON values can be destructed.
- Layout
 - [StandardLayoutType](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType):
   JSON values have
   [standard layout](https://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
   All non-static data members are private and standard layout types, the
   class has no virtual functions or (virtual) base classes.
- Library-wide
 - [EqualityComparable](https://en.cppreference.com/w/cpp/named_req/EqualityComparable):
   JSON values can be compared with `==`, see @ref
   operator==(const_reference,const_reference).
 - [LessThanComparable](https://en.cppreference.com/w/cpp/named_req/LessThanComparable):
   JSON values can be compared with `<`, see @ref
   operator<(const_reference,const_reference).
 - [Swappable](https://en.cppreference.com/w/cpp/named_req/Swappable):
   Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
   other compatible types, using unqualified function call @ref swap().
 - [NullablePointer](https://en.cppreference.com/w/cpp/named_req/NullablePointer):
   JSON values can be compared against `std::nullptr_t` objects which are used
   to model the `null` value.
- Container
 - [Container](https://en.cppreference.com/w/cpp/named_req/Container):
   JSON values can be used like STL containers and provide iterator access.
 - [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer);
   JSON values can be used like STL containers and provide reverse iterator
   access.

@invariant The member variables @a m_value and @a m_type have the following
relationship:
- If `m_type == value_t::object`, then `m_value.object != nullptr`.
- If `m_type == value_t::array`, then `m_value.array != nullptr`.
- If `m_type == value_t::string`, then `m_value.string != nullptr`.
The invariants are checked by member function assert_invariant().

@internal
@note ObjectType trick from http://stackoverflow.com/a/9860911
@endinternal

@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
Format](http://rfc7159.net/rfc7159)

@since version 1.0.0

@nosubgrouping
*/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
class basic_json
{
  private:
    template<detail::value_t> friend struct detail::external_constructor;
    friend ::nlohmann::json_pointer<basic_json>;
    friend ::nlohmann::detail::parser<basic_json>;
    friend ::nlohmann::detail::serializer<basic_json>;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::iter_impl;
    template<typename BasicJsonType, typename CharType>
    friend class ::nlohmann::detail::binary_writer;
    template<typename BasicJsonType, typename SAX>
    friend class ::nlohmann::detail::binary_reader;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_parser;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_callback_parser;

    /// workaround type for MSVC
    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;

    // convenience aliases for types residing in namespace detail;
    using lexer = ::nlohmann::detail::lexer<basic_json>;
    using parser = ::nlohmann::detail::parser<basic_json>;

    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
    template<typename BasicJsonType>
    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
    template<typename BasicJsonType>
    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
    template<typename Iterator>
    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

    template<typename CharType>
    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

    using binary_reader = ::nlohmann::detail::binary_reader<basic_json>;
    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

    using serializer = ::nlohmann::detail::serializer<basic_json>;

  public:
    using value_t = detail::value_t;
    /// JSON Pointer, see @ref nlohmann::json_pointer
    using json_pointer = ::nlohmann::json_pointer<basic_json>;
    template<typename T, typename SFINAE>
    using json_serializer = JSONSerializer<T, SFINAE>;
    /// how to treat decoding errors
    using error_handler_t = detail::error_handler_t;
    /// helper type for initializer lists of basic_json values
    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

    using input_format_t = detail::input_format_t;
    /// SAX interface type, see @ref nlohmann::json_sax
    using json_sax_t = json_sax<basic_json>;

    ////////////////
    // exceptions //
    ////////////////

    /// @name exceptions
    /// Classes to implement user-defined exceptions.
    /// @{

    /// @copydoc detail::exception
    using exception = detail::exception;
    /// @copydoc detail::parse_error
    using parse_error = detail::parse_error;
    /// @copydoc detail::invalid_iterator
    using invalid_iterator = detail::invalid_iterator;
    /// @copydoc detail::type_error
    using type_error = detail::type_error;
    /// @copydoc detail::out_of_range
    using out_of_range = detail::out_of_range;
    /// @copydoc detail::other_error
    using other_error = detail::other_error;

    /// @}


    /////////////////////
    // container types //
    /////////////////////

    /// @name container types
    /// The canonic container types to use @ref basic_json like any other STL
    /// container.
    /// @{

    /// the type of elements in a basic_json container
    using value_type = basic_json;

    /// the type of an element reference
    using reference = value_type&;
    /// the type of an element const reference
    using const_reference = const value_type&;

    /// a type to represent differences between iterators
    using difference_type = std::ptrdiff_t;
    /// a type to represent container sizes
    using size_type = std::size_t;

    /// the allocator type
    using allocator_type = AllocatorType<basic_json>;

    /// the type of an element pointer
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    /// the type of an element const pointer
    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

    /// an iterator for a basic_json container
    using iterator = iter_impl<basic_json>;
    /// a const iterator for a basic_json container
    using const_iterator = iter_impl<const basic_json>;
    /// a reverse iterator for a basic_json container
    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
    /// a const reverse iterator for a basic_json container
    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

    /// @}


    /*!
    @brief returns the allocator associated with the container
    */
    static allocator_type get_allocator()
    {
        return allocator_type();
    }

    /*!
    @brief returns version information on the library

    This function returns a JSON object with information about the library,
    including the version number and information on the platform and compiler.

    @return JSON object holding version information
    key         | description
    ----------- | ---------------
    `compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).
    `copyright` | The copyright line for the library as string.
    `name`      | The name of the library as string.
    `platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.
    `url`       | The URL of the project as string.
    `version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).

    @liveexample{The following code shows an example output of the `meta()`
    function.,meta}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @complexity Constant.

    @since 2.1.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json meta()
    {
        basic_json result;

        result["copyright"] = "(C) 2013-2017 Niels Lohmann";
        result["name"] = "JSON for Modern C++";
        result["url"] = "https://github.com/nlohmann/json";
        result["version"]["string"] =
            std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + "." +
            std::to_string(NLOHMANN_JSON_VERSION_MINOR) + "." +
            std::to_string(NLOHMANN_JSON_VERSION_PATCH);
        result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
        result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
        result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
        result["platform"] = "win32";
#elif defined __linux__
        result["platform"] = "linux";
#elif defined __APPLE__
        result["platform"] = "apple";
#elif defined __unix__
        result["platform"] = "unix";
#else
        result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
#elif defined(__clang__)
        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
#elif defined(__GNUC__) || defined(__GNUG__)
        result["compiler"] = {{"family", "gcc"}, {"version", std::to_string(__GNUC__) + "." + std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__)}};
#elif defined(__HP_cc) || defined(__HP_aCC)
        result["compiler"] = "hp"
#elif defined(__IBMCPP__)
        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
#elif defined(_MSC_VER)
        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
#elif defined(__PGI)
        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
#elif defined(__SUNPRO_CC)
        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
#else
        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
#endif

#ifdef __cplusplus
        result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
        result["compiler"]["c++"] = "unknown";
#endif
        return result;
    }


    ///////////////////////////
    // JSON value data types //
    ///////////////////////////

    /// @name JSON value data types
    /// The data types to store a JSON value. These types are derived from
    /// the template arguments passed to class @ref basic_json.
    /// @{

#if defined(JSON_HAS_CPP_14)
    // Use transparent comparator if possible, combined with perfect forwarding
    // on find() and count() calls prevents unnecessary string construction.
    using object_comparator_t = std::less<>;
#else
    using object_comparator_t = std::less<StringType>;
#endif

    /*!
    @brief a type for an object

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
    > An object is an unordered collection of zero or more name/value pairs,
    > where a name is a string and a value is a string, number, boolean, null,
    > object, or array.

    To store objects in C++, a type is defined by the template parameters
    described below.

    @tparam ObjectType  the container to store objects (e.g., `std::map` or
    `std::unordered_map`)
    @tparam StringType the type of the keys or names (e.g., `std::string`).
    The comparison function `std::less<StringType>` is used to order elements
    inside the container.
    @tparam AllocatorType the allocator to use for objects (e.g.,
    `std::allocator`)

    #### Default type

    With the default values for @a ObjectType (`std::map`), @a StringType
    (`std::string`), and @a AllocatorType (`std::allocator`), the default
    value for @a object_t is:

    @code {.cpp}
    std::map<
      std::string, // key_type
      basic_json, // value_type
      std::less<std::string>, // key_compare
      std::allocator<std::pair<const std::string, basic_json>> // allocator_type
    >
    @endcode

    #### Behavior

    The choice of @a object_t influences the behavior of the JSON class. With
    the default type, objects have the following behavior:

    - When all names are unique, objects will be interoperable in the sense
      that all software implementations receiving that object will agree on
      the name-value mappings.
    - When the names within an object are not unique, it is unspecified which
      one of the values for a given key will be chosen. For instance,
      `{"key": 2, "key": 1}` could be equal to either `{"key": 1}` or
      `{"key": 2}`.
    - Internally, name/value pairs are stored in lexicographical order of the
      names. Objects will also be serialized (see @ref dump) in this order.
      For instance, `{"b": 1, "a": 2}` and `{"a": 2, "b": 1}` will be stored
      and serialized as `{"a": 2, "b": 1}`.
    - When comparing objects, the order of the name/value pairs is irrelevant.
      This makes objects interoperable in the sense that they will not be
      affected by these differences. For instance, `{"b": 1, "a": 2}` and
      `{"a": 2, "b": 1}` will be treated as equal.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the object's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON object.

    #### Storage

    Objects are stored as pointers in a @ref basic_json type. That is, for any
    access to object values, a pointer of type `object_t*` must be
    dereferenced.

    @sa @ref array_t -- type for an array value

    @since version 1.0.0

    @note The order name/value pairs are added to the object is *not*
    preserved by the library. Therefore, iterating an object may return
    name/value pairs in a different order than they were originally stored. In
    fact, keys will be traversed in alphabetical order as `std::map` with
    `std::less` is used by default. Please note this behavior conforms to [RFC
    7159](http://rfc7159.net/rfc7159), because any order implements the
    specified "unordered" nature of JSON objects.
    */
    using object_t = ObjectType<StringType,
          basic_json,
          object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>;

    /*!
    @brief a type for an array

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
    > An array is an ordered sequence of zero or more values.

    To store objects in C++, a type is defined by the template parameters
    explained below.

    @tparam ArrayType  container type to store arrays (e.g., `std::vector` or
    `std::list`)
    @tparam AllocatorType allocator to use for arrays (e.g., `std::allocator`)

    #### Default type

    With the default values for @a ArrayType (`std::vector`) and @a
    AllocatorType (`std::allocator`), the default value for @a array_t is:

    @code {.cpp}
    std::vector<
      basic_json, // value_type
      std::allocator<basic_json> // allocator_type
    >
    @endcode

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the array's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON array.

    #### Storage

    Arrays are stored as pointers in a @ref basic_json type. That is, for any
    access to array values, a pointer of type `array_t*` must be dereferenced.

    @sa @ref object_t -- type for an object value

    @since version 1.0.0
    */
    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

    /*!
    @brief a type for a string

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
    > A string is a sequence of zero or more Unicode characters.

    To store objects in C++, a type is defined by the template parameter
    described below. Unicode values are split by the JSON class into
    byte-sized characters during deserialization.

    @tparam StringType  the container to store strings (e.g., `std::string`).
    Note this container is used for keys/names in objects, see @ref object_t.

    #### Default type

    With the default values for @a StringType (`std::string`), the default
    value for @a string_t is:

    @code {.cpp}
    std::string
    @endcode

    #### Encoding

    Strings are stored in UTF-8 encoding. Therefore, functions like
    `std::string::size()` or `std::string::length()` return the number of
    bytes in the string rather than the number of characters or glyphs.

    #### String comparison

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > Software implementations are typically required to test names of object
    > members for equality. Implementations that transform the textual
    > representation into sequences of Unicode code units and then perform the
    > comparison numerically, code unit by code unit, are interoperable in the
    > sense that implementations will agree in all cases on equality or
    > inequality of two strings. For example, implementations that compare
    > strings with escaped characters unconverted may incorrectly find that
    > `"a\\b"` and `"a\u005Cb"` are not equal.

    This implementation is interoperable as it does compare strings code unit
    by code unit.

    #### Storage

    String values are stored as pointers in a @ref basic_json type. That is,
    for any access to string values, a pointer of type `string_t*` must be
    dereferenced.

    @since version 1.0.0
    */
    using string_t = StringType;

    /*!
    @brief a type for a boolean

    [RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
    type which differentiates the two literals `true` and `false`.

    To store objects in C++, a type is defined by the template parameter @a
    BooleanType which chooses the type to use.

    #### Default type

    With the default values for @a BooleanType (`bool`), the default value for
    @a boolean_t is:

    @code {.cpp}
    bool
    @endcode

    #### Storage

    Boolean values are stored directly inside a @ref basic_json type.

    @since version 1.0.0
    */
    using boolean_t = BooleanType;

    /*!
    @brief a type for a number (integer)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store integer numbers in C++, a type is defined by the template
    parameter @a NumberIntegerType which chooses the type to use.

    #### Default type

    With the default values for @a NumberIntegerType (`int64_t`), the default
    value for @a number_integer_t is:

    @code {.cpp}
    int64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
    that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
    that are out of range will yield over/underflow when used in a
    constructor. During deserialization, too large or small integer numbers
    will be automatically be stored as @ref number_unsigned_t or @ref
    number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange of the exactly supported range [INT64_MIN,
    INT64_MAX], this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_integer_t = NumberIntegerType;

    /*!
    @brief a type for a number (unsigned)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store unsigned integer numbers in C++, a type is defined by the
    template parameter @a NumberUnsignedType which chooses the type to use.

    #### Default type

    With the default values for @a NumberUnsignedType (`uint64_t`), the
    default value for @a number_unsigned_t is:

    @code {.cpp}
    uint64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
    number that can be stored is `0`. Integer numbers that are out of range
    will yield over/underflow when used in a constructor. During
    deserialization, too large or small integer numbers will be automatically
    be stored as @ref number_integer_t or @ref number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange (when considered in conjunction with the
    number_integer_t type) of the exactly supported range [0, UINT64_MAX],
    this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)
    @sa @ref number_integer_t -- type for number values (integer)

    @since version 2.0.0
    */
    using number_unsigned_t = NumberUnsignedType;

    /*!
    @brief a type for a number (floating-point)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store floating-point numbers in C++, a type is defined by the template
    parameter @a NumberFloatType which chooses the type to use.

    #### Default type

    With the default values for @a NumberFloatType (`double`), the default
    value for @a number_float_t is:

    @code {.cpp}
    double
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in floating-point literals will be ignored. Internally,
      the value will be stored as decimal number. For instance, the C++
      floating-point literal `01.2` will be serialized to `1.2`. During
      deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > This specification allows implementations to set limits on the range and
    > precision of numbers accepted. Since software that implements IEEE
    > 754-2008 binary64 (double precision) numbers is generally available and
    > widely used, good interoperability can be achieved by implementations
    > that expect no more precision or range than these provide, in the sense
    > that implementations will approximate JSON numbers within the expected
    > precision.

    This implementation does exactly follow this approach, as it uses double
    precision floating-point numbers. Note values smaller than
    `-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
    will be stored as NaN internally and be serialized to `null`.

    #### Storage

    Floating-point number values are stored directly inside a @ref basic_json
    type.

    @sa @ref number_integer_t -- type for number values (integer)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_float_t = NumberFloatType;

    /// @}

  private:

    /// helper for exception-safe object creation
    template<typename T, typename... Args>
    JSON_HEDLEY_RETURNS_NON_NULL
    static T* create(Args&& ... args)
    {
        AllocatorType<T> alloc;
        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

        auto deleter = [&](T * object)
        {
            AllocatorTraits::deallocate(alloc, object, 1);
        };
        std::unique_ptr<T, decltype(deleter)> object(AllocatorTraits::allocate(alloc, 1), deleter);
        AllocatorTraits::construct(alloc, object.get(), std::forward<Args>(args)...);
        assert(object != nullptr);
        return object.release();
    }

    ////////////////////////
    // JSON value storage //
    ////////////////////////

    /*!
    @brief a JSON value

    The actual storage for a JSON value of the @ref basic_json class. This
    union combines the different storage types for the JSON value types
    defined in @ref value_t.

    JSON type | value_t type    | used type
    --------- | --------------- | ------------------------
    object    | object          | pointer to @ref object_t
    array     | array           | pointer to @ref array_t
    string    | string          | pointer to @ref string_t
    boolean   | boolean         | @ref boolean_t
    number    | number_integer  | @ref number_integer_t
    number    | number_unsigned | @ref number_unsigned_t
    number    | number_float    | @ref number_float_t
    null      | null            | *no value is stored*

    @note Variable-length types (objects, arrays, and strings) are stored as
    pointers. The size of the union should not exceed 64 bits if the default
    value types are used.

    @since version 1.0.0
    */
    union json_value
    {
        /// object (stored with pointer to save storage)
        object_t* object;
        /// array (stored with pointer to save storage)
        array_t* array;
        /// string (stored with pointer to save storage)
        string_t* string;
        /// boolean
        boolean_t boolean;
        /// number (integer)
        number_integer_t number_integer;
        /// number (unsigned integer)
        number_unsigned_t number_unsigned;
        /// number (floating-point)
        number_float_t number_float;

        /// default constructor (for null values)
        json_value() = default;
        /// constructor for booleans
        json_value(boolean_t v) noexcept : boolean(v) {}
        /// constructor for numbers (integer)
        json_value(number_integer_t v) noexcept : number_integer(v) {}
        /// constructor for numbers (unsigned)
        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
        /// constructor for numbers (floating-point)
        json_value(number_float_t v) noexcept : number_float(v) {}
        /// constructor for empty values of a given type
        json_value(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    object = create<object_t>();
                    break;
                }

                case value_t::array:
                {
                    array = create<array_t>();
                    break;
                }

                case value_t::string:
                {
                    string = create<string_t>("");
                    break;
                }

                case value_t::boolean:
                {
                    boolean = boolean_t(false);
                    break;
                }

                case value_t::number_integer:
                {
                    number_integer = number_integer_t(0);
                    break;
                }

                case value_t::number_unsigned:
                {
                    number_unsigned = number_unsigned_t(0);
                    break;
                }

                case value_t::number_float:
                {
                    number_float = number_float_t(0.0);
                    break;
                }

                case value_t::null:
                {
                    object = nullptr;  // silence warning, see #821
                    break;
                }

                default:
                {
                    object = nullptr;  // silence warning, see #821
                    if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
                    {
                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.7.0")); // LCOV_EXCL_LINE
                    }
                    break;
                }
            }
        }

        /// constructor for strings
        json_value(const string_t& value)
        {
            string = create<string_t>(value);
        }

        /// constructor for rvalue strings
        json_value(string_t&& value)
        {
            string = create<string_t>(std::move(value));
        }

        /// constructor for objects
        json_value(const object_t& value)
        {
            object = create<object_t>(value);
        }

        /// constructor for rvalue objects
        json_value(object_t&& value)
        {
            object = create<object_t>(std::move(value));
        }

        /// constructor for arrays
        json_value(const array_t& value)
        {
            array = create<array_t>(value);
        }

        /// constructor for rvalue arrays
        json_value(array_t&& value)
        {
            array = create<array_t>(std::move(value));
        }

        void destroy(value_t t) noexcept
        {
            switch (t)
            {
                case value_t::object:
                {
                    AllocatorType<object_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
                    break;
                }

                case value_t::array:
                {
                    AllocatorType<array_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
                    break;
                }

                case value_t::string:
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
    };

    /*!
    @brief checks the class invariants

    This function asserts the class invariants. It needs to be called at the
    end of every constructor to make sure that created objects respect the
    invariant. Furthermore, it has to be called each time the type of a JSON
    value is changed, because the invariant expresses a relationship between
    @a m_type and @a m_value.
    */
    void assert_invariant() const noexcept
    {
        assert(m_type != value_t::object or m_value.object != nullptr);
        assert(m_type != value_t::array or m_value.array != nullptr);
        assert(m_type != value_t::string or m_value.string != nullptr);
    }

  public:
    //////////////////////////
    // JSON parser callback //
    //////////////////////////

    /*!
    @brief parser event types

    The parser callback distinguishes the following events:
    - `object_start`: the parser read `{` and started to process a JSON object
    - `key`: the parser read a key of a value in an object
    - `object_end`: the parser read `}` and finished processing a JSON object
    - `array_start`: the parser read `[` and started to process a JSON array
    - `array_end`: the parser read `]` and finished processing a JSON array
    - `value`: the parser finished reading a JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    @sa @ref parser_callback_t for more information and examples
    */
    using parse_event_t = typename parser::parse_event_t;

    /*!
    @brief per-element parser callback type

    With a parser callback function, the result of parsing a JSON text can be
    influenced. When passed to @ref parse, it is called on certain events
    (passed as @ref parse_event_t via parameter @a event) with a set recursion
    depth @a depth and context JSON value @a parsed. The return value of the
    callback function is a boolean indicating whether the element that emitted
    the callback shall be kept or not.

    We distinguish six scenarios (determined by the event type) in which the
    callback function can be called. The following table describes the values
    of the parameters @a depth, @a event, and @a parsed.

    parameter @a event | description | parameter @a depth | parameter @a parsed
    ------------------ | ----------- | ------------------ | -------------------
    parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
    parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
    parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
    parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
    parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
    parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    Discarding a value (i.e., returning `false`) has different effects
    depending on the context in which function was called:

    - Discarded values in structured types are skipped. That is, the parser
      will behave as if the discarded value was never read.
    - In case a value outside a structured type is skipped, it is replaced
      with `null`. This case happens if the top-level element is skipped.

    @param[in] depth  the depth of the recursion during parsing

    @param[in] event  an event of type parse_event_t indicating the context in
    the callback function has been called

    @param[in,out] parsed  the current intermediate parse result; note that
    writing to this value has no effect for parse_event_t::key events

    @return Whether the JSON value which called the function during parsing
    should be kept (`true`) or not (`false`). In the latter case, it is either
    skipped completely or replaced by an empty discarded object.

    @sa @ref parse for examples

    @since version 1.0.0
    */
    using parser_callback_t = typename parser::parser_callback_t;

    //////////////////
    // constructors //
    //////////////////

    /// @name constructors and destructors
    /// Constructors of class @ref basic_json, copy/move constructor, copy
    /// assignment, static functions creating objects, and the destructor.
    /// @{

    /*!
    @brief create an empty value with a given type

    Create an empty JSON value with a given type. The value will be default
    initialized with an empty value which depends on the type:

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    object      | `{}`
    array       | `[]`

    @param[in] v  the type of the value to create

    @complexity Constant.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows the constructor for different @ref
    value_t values,basic_json__value_t}

    @sa @ref clear() -- restores the postcondition of this constructor

    @since version 1.0.0
    */
    basic_json(const value_t v)
        : m_type(v), m_value(v)
    {
        assert_invariant();
    }

    /*!
    @brief create a null object

    Create a `null` JSON value. It either takes a null pointer as parameter
    (explicitly creating `null`) or no parameter (implicitly creating `null`).
    The passed null pointer itself is not read -- it is only used to choose
    the right constructor.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @liveexample{The following code shows the constructor with and without a
    null pointer parameter.,basic_json__nullptr_t}

    @since version 1.0.0
    */
    basic_json(std::nullptr_t = nullptr) noexcept
        : basic_json(value_t::null)
    {
        assert_invariant();
    }

    /*!
    @brief create a JSON value

    This is a "catch all" constructor for all compatible JSON types; that is,
    types for which a `to_json()` method exists. The constructor forwards the
    parameter @a val to that method (to `json_serializer<U>::to_json` method
    with `U = uncvref_t<CompatibleType>`, to be exact).

    Template type @a CompatibleType includes, but is not limited to, the
    following types:
    - **arrays**: @ref array_t and all kinds of compatible containers such as
      `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
      `std::array`, `std::valarray`, `std::set`, `std::unordered_set`,
      `std::multiset`, and `std::unordered_multiset` with a `value_type` from
      which a @ref basic_json value can be constructed.
    - **objects**: @ref object_t and all kinds of compatible associative
      containers such as `std::map`, `std::unordered_map`, `std::multimap`,
      and `std::unordered_multimap` with a `key_type` compatible to
      @ref string_t and a `value_type` from which a @ref basic_json value can
      be constructed.
    - **strings**: @ref string_t, string literals, and all compatible string
      containers can be used.
    - **numbers**: @ref number_integer_t, @ref number_unsigned_t,
      @ref number_float_t, and all convertible number types such as `int`,
      `size_t`, `int64_t`, `float` or `double` can be used.
    - **boolean**: @ref boolean_t / `bool` can be used.

    See the examples below.

    @tparam CompatibleType a type such that:
    - @a CompatibleType is not derived from `std::istream`,
    - @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
         constructors),
    - @a CompatibleType is not a different @ref basic_json type (i.e. with different template arguments)
    - @a CompatibleType is not a @ref basic_json nested type (e.g.,
         @ref json_pointer, @ref iterator, etc ...)
    - @ref @ref json_serializer<U> has a
         `to_json(basic_json_t&, CompatibleType&&)` method

    @tparam U = `uncvref_t<CompatibleType>`

    @param[in] val the value to be forwarded to the respective constructor

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @liveexample{The following code shows the constructor with several
    compatible types.,basic_json__CompatibleType}

    @since version 2.1.0
    */
    template <typename CompatibleType,
              typename U = detail::uncvref_t<CompatibleType>,
              detail::enable_if_t<
                  not detail::is_basic_json<U>::value and detail::is_compatible_type<basic_json_t, U>::value, int> = 0>
    basic_json(CompatibleType && val) noexcept(noexcept(
                JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
                                           std::forward<CompatibleType>(val))))
    {
        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
        assert_invariant();
    }

    /*!
    @brief create a JSON value from an existing one

    This is a constructor for existing @ref basic_json types.
    It does not hijack copy/move constructors, since the parameter has different
    template arguments than the current ones.

    The constructor tries to convert the internal @ref m_value of the parameter.

    @tparam BasicJsonType a type such that:
    - @a BasicJsonType is a @ref basic_json type.
    - @a BasicJsonType has different template arguments than @ref basic_json_t.

    @param[in] val the @ref basic_json value to be converted.

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @since version 3.2.0
    */
    template <typename BasicJsonType,
              detail::enable_if_t<
                  detail::is_basic_json<BasicJsonType>::value and not std::is_same<basic_json, BasicJsonType>::value, int> = 0>
    basic_json(const BasicJsonType& val)
    {
        using other_boolean_t = typename BasicJsonType::boolean_t;
        using other_number_float_t = typename BasicJsonType::number_float_t;
        using other_number_integer_t = typename BasicJsonType::number_integer_t;
        using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
        using other_string_t = typename BasicJsonType::string_t;
        using other_object_t = typename BasicJsonType::object_t;
        using other_array_t = typename BasicJsonType::array_t;

        switch (val.type())
        {
            case value_t::boolean:
                JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
                break;
            case value_t::number_float:
                JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
                break;
            case value_t::number_integer:
                JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
                break;
            case value_t::number_unsigned:
                JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
                break;
            case value_t::string:
                JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
                break;
            case value_t::object:
                JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
                break;
            case value_t::array:
                JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
                break;
            case value_t::null:
                *this = nullptr;
                break;
            case value_t::discarded:
                m_type = value_t::discarded;
                break;
            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }
        assert_invariant();
    }

    /*!
    @brief create a container (array or object) from an initializer list

    Creates a JSON value of type array or object from the passed initializer
    list @a init. In case @a type_deduction is `true` (default), the type of
    the JSON value to be created is deducted from the initializer list @a init
    according to the following rules:

    1. If the list is empty, an empty JSON object value `{}` is created.
    2. If the list consists of pairs whose first element is a string, a JSON
       object value is created where the first elements of the pairs are
       treated as keys and the second elements are as values.
    3. In all other cases, an array is created.

    The rules aim to create the best fit between a C++ initializer list and
    JSON values. The rationale is as follows:

    1. The empty initializer list is written as `{}` which is exactly an empty
       JSON object.
    2. C++ has no way of describing mapped types other than to list a list of
       pairs. As JSON requires that keys must be of type string, rule 2 is the
       weakest constraint one can pose on initializer lists to interpret them
       as an object.
    3. In all other cases, the initializer list could not be interpreted as
       JSON object type, so interpreting it as JSON array type is safe.

    With the rules described above, the following JSON values cannot be
    expressed by an initializer list:

    - the empty array (`[]`): use @ref array(initializer_list_t)
      with an empty initializer list in this case
    - arrays whose elements satisfy rule 2: use @ref
      array(initializer_list_t) with the same initializer list
      in this case

    @note When used without parentheses around an empty initializer list, @ref
    basic_json() is called instead of this function, yielding the JSON null
    value.

    @param[in] init  initializer list with JSON values

    @param[in] type_deduction internal parameter; when set to `true`, the type
    of the JSON value is deducted from the initializer list @a init; when set
    to `false`, the type provided via @a manual_type is forced. This mode is
    used by the functions @ref array(initializer_list_t) and
    @ref object(initializer_list_t).

    @param[in] manual_type internal parameter; when @a type_deduction is set
    to `false`, the created JSON value will use the provided type (only @ref
    value_t::array and @ref value_t::object are valid); when @a type_deduction
    is set to `true`, this parameter has no effect

    @throw type_error.301 if @a type_deduction is `false`, @a manual_type is
    `value_t::object`, but @a init contains an element which is not a pair
    whose first element is a string. In this case, the constructor could not
    create an object. If @a type_deduction would have be `true`, an array
    would have been created. See @ref object(initializer_list_t)
    for an example.

    @complexity Linear in the size of the initializer list @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows how JSON values are created from
    initializer lists.,basic_json__list_init_t}

    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    basic_json(initializer_list_t init,
               bool type_deduction = true,
               value_t manual_type = value_t::array)
    {
        // check if each element is an array with two elements whose first
        // element is a string
        bool is_an_object = std::all_of(init.begin(), init.end(),
                                        [](const detail::json_ref<basic_json>& element_ref)
        {
            return element_ref->is_array() and element_ref->size() == 2 and (*element_ref)[0].is_string();
        });

        // adjust type if type deduction is not wanted
        if (not type_deduction)
        {
            // if array is wanted, do not create an object though possible
            if (manual_type == value_t::array)
            {
                is_an_object = false;
            }

            // if object is wanted but impossible, throw an exception
            if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object and not is_an_object))
            {
                JSON_THROW(type_error::create(301, "cannot create object from initializer list"));
            }
        }

        if (is_an_object)
        {
            // the initializer list is a list of pairs -> create object
            m_type = value_t::object;
            m_value = value_t::object;

            std::for_each(init.begin(), init.end(), [this](const detail::json_ref<basic_json>& element_ref)
            {
                auto element = element_ref.moved_or_copied();
                m_value.object->emplace(
                    std::move(*((*element.m_value.array)[0].m_value.string)),
                    std::move((*element.m_value.array)[1]));
            });
        }
        else
        {
            // the initializer list describes an array -> create array
            m_type = value_t::array;
            m_value.array = create<array_t>(init.begin(), init.end());
        }

        assert_invariant();
    }

    /*!
    @brief explicitly create an array from an initializer list

    Creates a JSON array value from a given initializer list. That is, given a
    list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
    initializer list is empty, the empty array `[]` is created.

    @note This function is only needed to express two edge cases that cannot
    be realized with the initializer list constructor (@ref
    basic_json(initializer_list_t, bool, value_t)). These cases
    are:
    1. creating an array whose elements are all pairs whose first element is a
    string -- in this case, the initializer list constructor would create an
    object, taking the first elements as keys
    2. creating an empty array -- passing the empty initializer list to the
    initializer list constructor yields an empty object

    @param[in] init  initializer list with JSON values to create an array from
    (optional)

    @return JSON array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `array`
    function.,array}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json array(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::array);
    }

    /*!
    @brief explicitly create an object from an initializer list

    Creates a JSON object value from a given initializer list. The initializer
    lists elements must be pairs, and their first elements must be strings. If
    the initializer list is empty, the empty object `{}` is created.

    @note This function is only added for symmetry reasons. In contrast to the
    related function @ref array(initializer_list_t), there are
    no cases which can only be expressed by this function. That is, any
    initializer list @a init can also be passed to the initializer list
    constructor @ref basic_json(initializer_list_t, bool, value_t).

    @param[in] init  initializer list to create an object from (optional)

    @return JSON object value

    @throw type_error.301 if @a init is not a list of pairs whose first
    elements are strings. In this case, no object can be created. When such a
    value is passed to @ref basic_json(initializer_list_t, bool, value_t),
    an array would have been created from the passed initializer list @a init.
    See example below.

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `object`
    function.,object}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list

    @since version 1.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json object(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::object);
    }

    /*!
    @brief construct an array with count copies of given value

    Constructs a JSON array value by creating @a cnt copies of a passed value.
    In case @a cnt is `0`, an empty array is created.

    @param[in] cnt  the number of JSON copies of @a val to create
    @param[in] val  the JSON value to copy

    @post `std::distance(begin(),end()) == cnt` holds.

    @complexity Linear in @a cnt.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows examples for the @ref
    basic_json(size_type\, const basic_json&)
    constructor.,basic_json__size_type_basic_json}

    @since version 1.0.0
    */
    basic_json(size_type cnt, const basic_json& val)
        : m_type(value_t::array)
    {
        m_value.array = create<array_t>(cnt, val);
        assert_invariant();
    }

    /*!
    @brief construct a JSON container given an iterator range

    Constructs the JSON value with the contents of the range `[first, last)`.
    The semantics depends on the different types a JSON value can have:
    - In case of a null type, invalid_iterator.206 is thrown.
    - In case of other primitive types (number, boolean, or string), @a first
      must be `begin()` and @a last must be `end()`. In this case, the value is
      copied. Otherwise, invalid_iterator.204 is thrown.
    - In case of structured types (array, object), the constructor behaves as
      similar versions for `std::vector` or `std::map`; that is, a JSON array
      or object is constructed from the values in the range.

    @tparam InputIT an input iterator type (@ref iterator or @ref
    const_iterator)

    @param[in] first begin of the range to copy from (included)
    @param[in] last end of the range to copy from (excluded)

    @pre Iterators @a first and @a last must be initialized. **This
         precondition is enforced with an assertion (see warning).** If
         assertions are switched off, a violation of this precondition yields
         undefined behavior.

    @pre Range `[first, last)` is valid. Usually, this precondition cannot be
         checked efficiently. Only certain edge cases are detected; see the
         description of the exceptions below. A violation of this precondition
         yields undefined behavior.

    @warning A precondition is enforced with a runtime assertion that will
             result in calling `std::abort` if this precondition is not met.
             Assertions can be disabled by defining `NDEBUG` at compile time.
             See https://en.cppreference.com/w/cpp/error/assert for more
             information.

    @throw invalid_iterator.201 if iterators @a first and @a last are not
    compatible (i.e., do not belong to the same JSON value). In this case,
    the range `[first, last)` is undefined.
    @throw invalid_iterator.204 if iterators @a first and @a last belong to a
    primitive type (number, boolean, or string), but @a first does not point
    to the first element any more. In this case, the range `[first, last)` is
    undefined. See example code below.
    @throw invalid_iterator.206 if iterators @a first and @a last belong to a
    null value. In this case, the range `[first, last)` is undefined.

    @complexity Linear in distance between @a first and @a last.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows several ways to create JSON values by
    specifying a subrange with iterators.,basic_json__InputIt_InputIt}

    @since version 1.0.0
    */
    template<class InputIT, typename std::enable_if<
                 std::is_same<InputIT, typename basic_json_t::iterator>::value or
                 std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int>::type = 0>
    basic_json(InputIT first, InputIT last)
    {
        assert(first.m_object != nullptr);
        assert(last.m_object != nullptr);

        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible"));
        }

        // copy type from first iterator
        m_type = first.m_object->m_type;

        // check if iterator range is complete for primitive values
        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_HEDLEY_UNLIKELY(not first.m_it.primitive_iterator.is_begin()
                                         or not last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }
                break;
            }

            default:
                break;
        }

        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = first.m_object->m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = first.m_object->m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = first.m_object->m_value.number_float;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = first.m_object->m_value.boolean;
                break;
            }

            case value_t::string:
            {
                m_value = *first.m_object->m_value.string;
                break;
            }

            case value_t::object:
            {
                m_value.object = create<object_t>(first.m_it.object_iterator,
                                                  last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                m_value.array = create<array_t>(first.m_it.array_iterator,
                                                last.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(invalid_iterator::create(206, "cannot construct with iterators from " +
                                                    std::string(first.m_object->type_name())));
        }

        assert_invariant();
    }


    ///////////////////////////////////////
    // other constructors and destructor //
    ///////////////////////////////////////

    /// @private
    basic_json(const detail::json_ref<basic_json>& ref)
        : basic_json(ref.moved_or_copied())
    {}

    /*!
    @brief copy constructor

    Creates a copy of a given JSON value.

    @param[in] other  the JSON value to copy

    @post `*this == other`

    @complexity Linear in the size of @a other.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.
    - As postcondition, it holds: `other == basic_json(other)`.

    @liveexample{The following code shows an example for the copy
    constructor.,basic_json__basic_json}

    @since version 1.0.0
    */
    basic_json(const basic_json& other)
        : m_type(other.m_type)
    {
        // check of passed value is valid
        other.assert_invariant();

        switch (m_type)
        {
            case value_t::object:
            {
                m_value = *other.m_value.object;
                break;
            }

            case value_t::array:
            {
                m_value = *other.m_value.array;
                break;
            }

            case value_t::string:
            {
                m_value = *other.m_value.string;
                break;
            }

            case value_t::boolean:
            {
                m_value = other.m_value.boolean;
                break;
            }

            case value_t::number_integer:
            {
                m_value = other.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value = other.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value = other.m_value.number_float;
                break;
            }

            default:
                break;
        }

        assert_invariant();
    }

    /*!
    @brief move constructor

    Move constructor. Constructs a JSON value with the contents of the given
    value @a other using move semantics. It "steals" the resources from @a
    other and leaves it as JSON null value.

    @param[in,out] other  value to move to this object

    @post `*this` has the same value as @a other before the call.
    @post @a other is a JSON null value.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @requirement This function helps `basic_json` satisfying the
    [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible)
    requirements.

    @liveexample{The code below shows the move constructor explicitly called
    via std::move.,basic_json__moveconstructor}

    @since version 1.0.0
    */
    basic_json(basic_json&& other) noexcept
        : m_type(std::move(other.m_type)),
          m_value(std::move(other.m_value))
    {
        // check that passed value is valid
        other.assert_invariant();

        // invalidate payload
        other.m_type = value_t::null;
        other.m_value = {};

        assert_invariant();
    }

    /*!
    @brief copy assignment

    Copy assignment operator. Copies a JSON value via the "copy and swap"
    strategy: It is expressed in terms of the copy constructor, destructor,
    and the `swap()` member function.

    @param[in] other  value to copy from

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.

    @liveexample{The code below shows and example for the copy assignment. It
    creates a copy of value `a` which is then swapped with `b`. Finally\, the
    copy of `a` (which is the null value after the swap) is
    destroyed.,basic_json__copyassignment}

    @since version 1.0.0
    */
    basic_json& operator=(basic_json other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value and
        std::is_nothrow_move_assignable<value_t>::value and
        std::is_nothrow_move_constructible<json_value>::value and
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        // check that passed value is valid
        other.assert_invariant();

        using std::swap;
        swap(m_type, other.m_type);
        swap(m_value, other.m_value);

        assert_invariant();
        return *this;
    }

    /*!
    @brief destructor

    Destroys the JSON value and frees all allocated memory.

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.
    - All stored elements are destroyed and all memory is freed.

    @since version 1.0.0
    */
    ~basic_json() noexcept
    {
        assert_invariant();
        m_value.destroy(m_type);
    }

    /// @}

  public:
    ///////////////////////
    // object inspection //
    ///////////////////////

    /// @name object inspection
    /// Functions to inspect the type of a JSON value.
    /// @{

    /*!
    @brief serialization

    Serialization function for JSON values. The function tries to mimic
    Python's `json.dumps()` function, and currently supports its @a indent
    and @a ensure_ascii parameters.

    @param[in] indent If indent is nonnegative, then array elements and object
    members will be pretty-printed with that indent level. An indent level of
    `0` will only insert newlines. `-1` (the default) selects the most compact
    representation.
    @param[in] indent_char The character to use for indentation if @a indent is
    greater than `0`. The default is ` ` (space).
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] error_handler  how to react on decoding errors; there are three
    possible values: `strict` (throws and exception in case a decoding error
    occurs; default), `replace` (replace invalid UTF-8 sequences with U+FFFD),
    and `ignore` (ignore invalid UTF-8 sequences during serialization).

    @return string containing the serialization of the JSON value

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded

    @complexity Linear.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @liveexample{The following example shows the effect of different @a indent\,
    @a indent_char\, and @a ensure_ascii parameters to the result of the
    serialization.,dump}

    @see https://docs.python.org/2/library/json.html#json.dump

    @since version 1.0.0; indentation character @a indent_char, option
           @a ensure_ascii and exceptions added in version 3.0.0; error
           handlers added in version 3.4.0.
    */
    string_t dump(const int indent = -1,
                  const char indent_char = ' ',
                  const bool ensure_ascii = false,
                  const error_handler_t error_handler = error_handler_t::strict) const
    {
        string_t result;
        serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);

        if (indent >= 0)
        {
            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
        }
        else
        {
            s.dump(*this, false, ensure_ascii, 0);
        }

        return result;
    }

    /*!
    @brief return the type of the JSON value (explicit)

    Return the type of the JSON value as a value from the @ref value_t
    enumeration.

    @return the type of the JSON value
            Value type                | return value
            ------------------------- | -------------------------
            null                      | value_t::null
            boolean                   | value_t::boolean
            string                    | value_t::string
            number (integer)          | value_t::number_integer
            number (unsigned integer) | value_t::number_unsigned
            number (floating-point)   | value_t::number_float
            object                    | value_t::object
            array                     | value_t::array
            discarded                 | value_t::discarded

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `type()` for all JSON
    types.,type}

    @sa @ref operator value_t() -- return the type of the JSON value (implicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr value_t type() const noexcept
    {
        return m_type;
    }

    /*!
    @brief return whether type is primitive

    This function returns true if and only if the JSON type is primitive
    (string, number, boolean, or null).

    @return `true` if type is primitive (string, number, boolean, or null),
    `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_primitive()` for all JSON
    types.,is_primitive}

    @sa @ref is_structured() -- returns whether JSON value is structured
    @sa @ref is_null() -- returns whether JSON value is `null`
    @sa @ref is_string() -- returns whether JSON value is a string
    @sa @ref is_boolean() -- returns whether JSON value is a boolean
    @sa @ref is_number() -- returns whether JSON value is a number

    @since version 1.0.0
    */
    constexpr bool is_primitive() const noexcept
    {
        return is_null() or is_string() or is_boolean() or is_number();
    }

    /*!
    @brief return whether type is structured

    This function returns true if and only if the JSON type is structured
    (array or object).

    @return `true` if type is structured (array or object), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_structured()` for all JSON
    types.,is_structured}

    @sa @ref is_primitive() -- returns whether value is primitive
    @sa @ref is_array() -- returns whether value is an array
    @sa @ref is_object() -- returns whether value is an object

    @since version 1.0.0
    */
    constexpr bool is_structured() const noexcept
    {
        return is_array() or is_object();
    }

    /*!
    @brief return whether value is null

    This function returns true if and only if the JSON value is null.

    @return `true` if type is null, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_null()` for all JSON
    types.,is_null}

    @since version 1.0.0
    */
    constexpr bool is_null() const noexcept
    {
        return m_type == value_t::null;
    }

    /*!
    @brief return whether value is a boolean

    This function returns true if and only if the JSON value is a boolean.

    @return `true` if type is boolean, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_boolean()` for all JSON
    types.,is_boolean}

    @since version 1.0.0
    */
    constexpr bool is_boolean() const noexcept
    {
        return m_type == value_t::boolean;
    }

    /*!
    @brief return whether value is a number

    This function returns true if and only if the JSON value is a number. This
    includes both integer (signed and unsigned) and floating-point values.

    @return `true` if type is number (regardless whether integer, unsigned
    integer or floating-type), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number()` for all JSON
    types.,is_number}

    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number() const noexcept
    {
        return is_number_integer() or is_number_float();
    }

    /*!
    @brief return whether value is an integer number

    This function returns true if and only if the JSON value is a signed or
    unsigned integer number. This excludes floating-point values.

    @return `true` if type is an integer or unsigned integer number, `false`
    otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_integer()` for all
    JSON types.,is_number_integer}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number_integer() const noexcept
    {
        return m_type == value_t::number_integer or m_type == value_t::number_unsigned;
    }

    /*!
    @brief return whether value is an unsigned integer number

    This function returns true if and only if the JSON value is an unsigned
    integer number. This excludes floating-point and signed integer values.

    @return `true` if type is an unsigned integer number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_unsigned()` for all
    JSON types.,is_number_unsigned}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 2.0.0
    */
    constexpr bool is_number_unsigned() const noexcept
    {
        return m_type == value_t::number_unsigned;
    }

    /*!
    @brief return whether value is a floating-point number

    This function returns true if and only if the JSON value is a
    floating-point number. This excludes signed and unsigned integer values.

    @return `true` if type is a floating-point number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_float()` for all
    JSON types.,is_number_float}

    @sa @ref is_number() -- check if value is number
    @sa @ref is_number_integer() -- check if value is an integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number

    @since version 1.0.0
    */
    constexpr bool is_number_float() const noexcept
    {
        return m_type == value_t::number_float;
    }

    /*!
    @brief return whether value is an object

    This function returns true if and only if the JSON value is an object.

    @return `true` if type is object, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_object()` for all JSON
    types.,is_object}

    @since version 1.0.0
    */
    constexpr bool is_object() const noexcept
    {
        return m_type == value_t::object;
    }

    /*!
    @brief return whether value is an array

    This function returns true if and only if the JSON value is an array.

    @return `true` if type is array, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_array()` for all JSON
    types.,is_array}

    @since version 1.0.0
    */
    constexpr bool is_array() const noexcept
    {
        return m_type == value_t::array;
    }

    /*!
    @brief return whether value is a string

    This function returns true if and only if the JSON value is a string.

    @return `true` if type is string, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_string()` for all JSON
    types.,is_string}

    @since version 1.0.0
    */
    constexpr bool is_string() const noexcept
    {
        return m_type == value_t::string;
    }

    /*!
    @brief return whether value is discarded

    This function returns true if and only if the JSON value was discarded
    during parsing with a callback function (see @ref parser_callback_t).

    @note This function will always be `false` for JSON values after parsing.
    That is, discarded values can only occur during parsing, but will be
    removed when inside a structured value or replaced by null in other cases.

    @return `true` if type is discarded, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_discarded()` for all JSON
    types.,is_discarded}

    @since version 1.0.0
    */
    constexpr bool is_discarded() const noexcept
    {
        return m_type == value_t::discarded;
    }

    /*!
    @brief return the type of the JSON value (implicit)

    Implicitly return the type of the JSON value as a value from the @ref
    value_t enumeration.

    @return the type of the JSON value

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies the @ref value_t operator for
    all JSON types.,operator__value_t}

    @sa @ref type() -- return the type of the JSON value (explicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr operator value_t() const noexcept
    {
        return m_type;
    }

    /// @}

  private:
    //////////////////
    // value access //
    //////////////////

    /// get a boolean (explicit)
    boolean_t get_impl(boolean_t* /*unused*/) const
    {
        if (JSON_HEDLEY_LIKELY(is_boolean()))
        {
            return m_value.boolean;
        }

        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name())));
    }

    /// get a pointer to the value (object)
    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (object)
    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (array)
    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (array)
    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (string)
    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (string)
    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (boolean)
    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (boolean)
    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (integer number)
    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (integer number)
    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /*!
    @brief helper function to implement get_ref()

    This function helps to implement get_ref() without code duplication for
    const and non-const overloads

    @tparam ThisType will be deduced as `basic_json` or `const basic_json`

    @throw type_error.303 if ReferenceType does not match underlying value
    type of the current JSON
    */
    template<typename ReferenceType, typename ThisType>
    static ReferenceType get_ref_impl(ThisType& obj)
    {
        // delegate the call to get_ptr<>()
        auto ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

        if (JSON_HEDLEY_LIKELY(ptr != nullptr))
        {
            return *ptr;
        }

        JSON_THROW(type_error::create(303, "incompatible ReferenceType for get_ref, actual type is " + std::string(obj.type_name())));
    }

  public:
    /// @name value access
    /// Direct access to the stored value of a JSON value.
    /// @{

    /*!
    @brief get special-case overload

    This overloads avoids a lot of template boilerplate, it can be seen as the
    identity method

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this

    @complexity Constant.

    @since version 2.1.0
    */
    template<typename BasicJsonType, detail::enable_if_t<
                 std::is_same<typename std::remove_const<BasicJsonType>::type, basic_json_t>::value,
                 int> = 0>
    basic_json get() const
    {
        return *this;
    }

    /*!
    @brief get special-case overload

    This overloads converts the current @ref basic_json in a different
    @ref basic_json type

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this, converted into @tparam BasicJsonType

    @complexity Depending on the implementation of the called `from_json()`
                method.

    @since version 3.2.0
    */
    template<typename BasicJsonType, detail::enable_if_t<
                 not std::is_same<BasicJsonType, basic_json>::value and
                 detail::is_basic_json<BasicJsonType>::value, int> = 0>
    BasicJsonType get() const
    {
        return *this;
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value
    which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType ret;
    JSONSerializer<ValueType>::from_json(*this, ret);
    return ret;
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and
    - @ref json_serializer<ValueType> does not have a `from_json()` method of
      the form `ValueType from_json(const basic_json&)`

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get__ValueType_const}

    @since version 2.1.0
    */
    template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
             detail::enable_if_t <
                 not detail::is_basic_json<ValueType>::value and
                 detail::has_from_json<basic_json_t, ValueType>::value and
                 not detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                 int> = 0>
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
    {
        // we cannot static_assert on ValueTypeCV being non-const, because
        // there is support for get<const basic_json_t>(), which is why we
        // still need the uncvref
        static_assert(not std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        static_assert(std::is_default_constructible<ValueType>::value,
                      "types must be DefaultConstructible when used with get()");

        ValueType ret;
        JSONSerializer<ValueType>::from_json(*this, ret);
        return ret;
    }

    /*!
    @brief get a value (explicit); special case

    Explicit type conversion between the JSON value and a compatible value
    which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    return JSONSerializer<ValueTypeCV>::from_json(*this);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json and
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `ValueType from_json(const basic_json&)`

    @note If @ref json_serializer<ValueType> has both overloads of
    `from_json()`, this one is chosen.

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @since version 2.1.0
    */
    template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
             detail::enable_if_t<not std::is_same<basic_json_t, ValueType>::value and
                                 detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                                 int> = 0>
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueTypeCV>::from_json(std::declval<const basic_json_t&>())))
    {
        static_assert(not std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        return JSONSerializer<ValueTypeCV>::from_json(*this);
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value.
    The value is filled into the input parameter by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType v;
    JSONSerializer<ValueType>::from_json(*this, v);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and

    @tparam ValueType the input parameter type.

    @return the input parameter, allowing chaining calls.

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get_to}

    @since version 3.3.0
    */
    template<typename ValueType,
             detail::enable_if_t <
                 not detail::is_basic_json<ValueType>::value and
                 detail::has_from_json<basic_json_t, ValueType>::value,
                 int> = 0>
    ValueType & get_to(ValueType& v) const noexcept(noexcept(
                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<ValueType>::from_json(*this, v);
        return v;
    }

    template <
        typename T, std::size_t N,
        typename Array = T (&)[N],
        detail::enable_if_t <
            detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
    Array get_to(T (&v)[N]) const
    noexcept(noexcept(JSONSerializer<Array>::from_json(
                          std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<Array>::from_json(*this, v);
        return v;
    }


    /*!
    @brief get a pointer value (implicit)

    Implicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning Writing data to the pointee of the result yields an undefined
    state.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t. Enforced by a static
    assertion.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get_ptr}

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>()
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (implicit)
    @copydoc get_ptr()
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value and
                 std::is_const<typename std::remove_pointer<PointerType>::type>::value, int>::type = 0>
    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>() const
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (explicit)

    Explicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning The pointer becomes invalid if the underlying JSON object
    changes.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get__PointerType}

    @sa @ref get_ptr() for explicit pointer-member access

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a pointer value (explicit)
    @copydoc get()
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    constexpr auto get() const noexcept -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a reference value (implicit)

    Implicit reference access to the internally stored JSON value. No copies
    are made.

    @warning Writing data to the referee of the result yields an undefined
    state.

    @tparam ReferenceType reference type; must be a reference to @ref array_t,
    @ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
    @ref number_float_t. Enforced by static assertion.

    @return reference to the internally stored JSON value if the requested
    reference type @a ReferenceType fits to the JSON value; throws
    type_error.303 otherwise

    @throw type_error.303 in case passed type @a ReferenceType is incompatible
    with the stored JSON value; see example below

    @complexity Constant.

    @liveexample{The example shows several calls to `get_ref()`.,get_ref}

    @since version 1.1.0
    */
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value, int>::type = 0>
    ReferenceType get_ref()
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a reference value (implicit)
    @copydoc get_ref()
    */
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value and
                 std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int>::type = 0>
    ReferenceType get_ref() const
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a value (implicit)

    Implicit type conversion between the JSON value and a compatible value.
    The call is realized by calling @ref get() const.

    @tparam ValueType non-pointer type compatible to the JSON value, for
    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
    `std::vector` types for JSON arrays. The character type of @ref string_t
    as well as an initializer list of this type is excluded to avoid
    ambiguities as these types implicitly convert to `std::string`.

    @return copy of the JSON value, converted to type @a ValueType

    @throw type_error.302 in case passed type @a ValueType is incompatible
    to the JSON value type (e.g., the JSON value is of type boolean, but a
    string is requested); see example below

    @complexity Linear in the size of the JSON value.

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,operator__ValueType}

    @since version 1.0.0
    */
    template < typename ValueType, typename std::enable_if <
                   not std::is_pointer<ValueType>::value and
                   not std::is_same<ValueType, detail::json_ref<basic_json>>::value and
                   not std::is_same<ValueType, typename string_t::value_type>::value and
                   not detail::is_basic_json<ValueType>::value

#ifndef _MSC_VER  // fix for issue #167 operator<< ambiguity under VS2015
                   and not std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>::value
#if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) and _MSC_VER <= 1914))
                   and not std::is_same<ValueType, typename std::string_view>::value
#endif
#endif
                   and detail::is_detected<detail::get_template_function, const basic_json_t&, ValueType>::value
                   , int >::type = 0 >
    operator ValueType() const
    {
        // delegate the call to get<>() const
        return get<ValueType>();
    }

    /// @}


    ////////////////////
    // element access //
    ////////////////////

    /// @name element access
    /// Access to the JSON value.
    /// @{

    /*!
    @brief access specified array element with bounds checking

    Returns a reference to the element at specified location @a idx, with
    bounds checking.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__size_type}
    */
    reference at(size_type idx)
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element with bounds checking

    Returns a const reference to the element at specified location @a idx,
    with bounds checking.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__size_type_const}
    */
    const_reference at(size_type idx) const
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a reference to the element at with specified key @a key, with
    bounds checking.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__object_t_key_type}
    */
    reference at(const typename object_t::key_type& key)
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a const reference to the element at with specified key @a key,
    with bounds checking.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__object_t_key_type_const}
    */
    const_reference at(const typename object_t::key_type& key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element

    Returns a reference to the element at specified location @a idx.

    @note If @a idx is beyond the range of the array (i.e., `idx >= size()`),
    then the array is silently filled up with `null` values to make `idx` a
    valid reference to the last stored element.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array or null; in that
    cases, using the [] operator with an index makes no sense.

    @complexity Constant if @a idx is in the range of the array. Otherwise
    linear in `idx - size()`.

    @liveexample{The example below shows how array elements can be read and
    written using `[]` operator. Note the addition of `null`
    values.,operatorarray__size_type}

    @since version 1.0.0
    */
    reference operator[](size_type idx)
    {
        // implicitly convert null value to an empty array
        if (is_null())
        {
            m_type = value_t::array;
            m_value.array = create<array_t>();
            assert_invariant();
        }

        // operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // fill up array with null values if given idx is outside range
            if (idx >= m_value.array->size())
            {
                m_value.array->insert(m_value.array->end(),
                                      idx - m_value.array->size() + 1,
                                      basic_json());
            }

            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified array element

    Returns a const reference to the element at specified location @a idx.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array; in that case,
    using the [] operator with an index makes no sense.

    @complexity Constant.

    @liveexample{The example below shows how array elements can be read using
    the `[]` operator.,operatorarray__size_type_const}

    @since version 1.0.0
    */
    const_reference operator[](size_type idx) const
    {
        // const operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    reference operator[](const typename object_t::key_type& key)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    const_reference operator[](const typename object_t::key_type& key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            assert(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    JSON_HEDLEY_NON_NULL(2)
    reference operator[](T* key)
    {
        // implicitly convert null to object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    JSON_HEDLEY_NON_NULL(2)
    const_reference operator[](T* key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            assert(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(key);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const typename object_t::key_type&), this function
    does not throw if the given key @a key was not found.

    @note Unlike @ref operator[](const typename object_t::key_type& key), this
    function does not implicitly add an element to the position defined by @a
    key. This function is furthermore also applicable to const objects.

    @param[in] key  key of the element to access
    @param[in] default_value  the value to return if @a key is not found

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.302 if @a default_value does not match the type of the
    value at @a key
    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference

    @since version 1.0.0
    */
    template<class ValueType, typename std::enable_if<
                 std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(key);
            if (it != end())
            {
                return *it;
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const typename object_t::key_type&, const ValueType&) const
    */
    string_t value(const typename object_t::key_type& key, const char* default_value) const
    {
        return value(key, string_t(default_value));
    }

    /*!
    @brief access specified object element via JSON Pointer with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(ptr);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const json_pointer&), this function does not throw
    if the given key @a key was not found.

    @param[in] ptr  a JSON pointer to the element to access
    @param[in] default_value  the value to return if @a ptr found no value

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.302 if @a default_value does not match the type of the
    value at @a ptr
    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value_ptr}

    @sa @ref operator[](const json_pointer&) for unchecked access by reference

    @since version 2.0.2
    */
    template<class ValueType, typename std::enable_if<
                 std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if pointer resolves a value, return it or use default value
            JSON_TRY
            {
                return ptr.get_checked(this);
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return default_value;
            }
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const json_pointer&, ValueType) const
    */
    JSON_HEDLEY_NON_NULL(3)
    string_t value(const json_pointer& ptr, const char* default_value) const
    {
        return value(ptr, string_t(default_value));
    }

    /*!
    @brief access the first element

    Returns a reference to the first element in the container. For a JSON
    container `c`, the expression `c.front()` is equivalent to `*c.begin()`.

    @return In case of a structured type (array or object), a reference to the
    first element is returned. In case of number, string, or boolean values, a
    reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on `null` value

    @liveexample{The following code shows an example for `front()`.,front}

    @sa @ref back() -- access the last element

    @since version 1.0.0
    */
    reference front()
    {
        return *begin();
    }

    /*!
    @copydoc basic_json::front()
    */
    const_reference front() const
    {
        return *cbegin();
    }

    /*!
    @brief access the last element

    Returns a reference to the last element in the container. For a JSON
    container `c`, the expression `c.back()` is equivalent to
    @code {.cpp}
    auto tmp = c.end();
    --tmp;
    return *tmp;
    @endcode

    @return In case of a structured type (array or object), a reference to the
    last element is returned. In case of number, string, or boolean values, a
    reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on a `null` value. See example
    below.

    @liveexample{The following code shows an example for `back()`.,back}

    @sa @ref front() -- access the first element

    @since version 1.0.0
    */
    reference back()
    {
        auto tmp = end();
        --tmp;
        return *tmp;
    }

    /*!
    @copydoc basic_json::back()
    */
    const_reference back() const
    {
        auto tmp = cend();
        --tmp;
        return *tmp;
    }

    /*!
    @brief remove element given an iterator

    Removes the element specified by iterator @a pos. The iterator @a pos must
    be valid and dereferenceable. Thus the `end()` iterator (which is valid,
    but is not dereferenceable) cannot be used as a value for @a pos.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] pos iterator to the element to remove
    @return Iterator following the last removed element. If the iterator @a
    pos refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.202 if called on an iterator which does not belong
    to the current JSON value; example: `"iterator does not fit current
    value"`
    @throw invalid_iterator.205 if called on a primitive type with invalid
    iterator (i.e., any iterator which is not `begin()`); example: `"iterator
    out of range"`

    @complexity The complexity depends on the type:
    - objects: amortized constant
    - arrays: linear in distance between @a pos and the end of the container
    - strings: linear in the length of the string
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType}

    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_same<IteratorType, typename basic_json_t::iterator>::value or
                 std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
             = 0>
    IteratorType erase(IteratorType pos)
    {
        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_HEDLEY_UNLIKELY(not pos.m_it.primitive_iterator.is_begin()))
                {
                    JSON_THROW(invalid_iterator::create(205, "iterator out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove elements given an iterator range

    Removes the element specified by the range `[first; last)`. The iterator
    @a first does not need to be dereferenceable if `first == last`: erasing
    an empty range is a no-op.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] first iterator to the beginning of the range to remove
    @param[in] last iterator past the end of the range to remove
    @return Iterator following the last removed element. If the iterator @a
    second refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.203 if called on iterators which does not belong
    to the current JSON value; example: `"iterators do not fit current value"`
    @throw invalid_iterator.204 if called on a primitive type with invalid
    iterators (i.e., if `first != begin()` and `last != end()`); example:
    `"iterators out of range"`

    @complexity The complexity depends on the type:
    - objects: `log(size()) + std::distance(first, last)`
    - arrays: linear in the distance between @a first and @a last, plus linear
      in the distance between @a last and end of the container
    - strings: linear in the length of the string
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType_IteratorType}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_same<IteratorType, typename basic_json_t::iterator>::value or
                 std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
             = 0>
    IteratorType erase(IteratorType first, IteratorType last)
    {
        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != first.m_object or this != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_HEDLEY_LIKELY(not first.m_it.primitive_iterator.is_begin()
                                       or not last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
                                              last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
                                             last.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove element from a JSON object given a key

    Removes elements from a JSON object with the key value @a key.

    @param[in] key value of the elements to remove

    @return Number of elements removed. If @a ObjectType is the default
    `std::map` type, the return value will always be `0` (@a key was not
    found) or `1` (@a key was found).

    @post References and iterators to the erased elements are invalidated.
    Other references and iterators are not affected.

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`

    @complexity `log(size()) + count(key)`

    @liveexample{The example shows the effect of `erase()`.,erase__key_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    size_type erase(const typename object_t::key_type& key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->erase(key);
        }

        JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
    }

    /*!
    @brief remove element from a JSON array given an index

    Removes element from a JSON array at the index @a idx.

    @param[in] idx index of the element to remove

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`
    @throw out_of_range.401 when `idx >= size()`; example: `"array index 17
    is out of range"`

    @complexity Linear in distance between @a idx and the end of the container.

    @liveexample{The example shows the effect of `erase()`.,erase__size_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key

    @since version 1.0.0
    */
    void erase(const size_type idx)
    {
        // this erase only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            if (JSON_HEDLEY_UNLIKELY(idx >= size()))
            {
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }

            m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
        }
        else
        {
            JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }
    }

    /// @}


    ////////////
    // lookup //
    ////////////

    /// @name lookup
    /// @{

    /*!
    @brief find an element in a JSON object

    Finds an element in a JSON object with key equivalent to @a key. If the
    element is not found or the JSON value is not an object, end() is
    returned.

    @note This method always returns @ref end() when executed on a JSON type
          that is not an object.

    @param[in] key key value of the element to search for.

    @return Iterator to an element with key equivalent to @a key. If no such
    element is found or the JSON value is not an object, past-the-end (see
    @ref end()) iterator is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `find()` is used.,find__key_type}

    @sa @ref contains(KeyT&&) const -- checks whether a key exists

    @since version 1.0.0
    */
    template<typename KeyT>
    iterator find(KeyT&& key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief find an element in a JSON object
    @copydoc find(KeyT&&)
    */
    template<typename KeyT>
    const_iterator find(KeyT&& key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief returns the number of occurrences of a key in a JSON object

    Returns the number of elements with key @a key. If ObjectType is the
    default `std::map` type, the return value will always be `0` (@a key was
    not found) or `1` (@a key was found).

    @note This method always returns `0` when executed on a JSON type that is
          not an object.

    @param[in] key key value of the element to count

    @return Number of elements with key @a key. If the JSON value is not an
    object, the return value will be `0`.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `count()` is used.,count}

    @since version 1.0.0
    */
    template<typename KeyT>
    size_type count(KeyT&& key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
    }

    /*!
    @brief check the existence of an element in a JSON object

    Check whether an element exists in a JSON object with key equivalent to
    @a key. If the element is not found or the JSON value is not an object,
    false is returned.

    @note This method always returns false when executed on a JSON type
          that is not an object.

    @param[in] key key value to check its existence.

    @return true if an element with specified @a key exists. If no such
    element with such key is found or the JSON value is not an object,
    false is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The following code shows an example for `contains()`.,contains}

    @sa @ref find(KeyT&&) -- returns an iterator to an object element
    @sa @ref contains(const json_pointer&) const -- checks the existence for a JSON pointer

    @since version 3.6.0
    */
    template<typename KeyT, typename std::enable_if<
                 not std::is_same<KeyT, json_pointer>::value, int>::type = 0>
    bool contains(KeyT && key) const
    {
        return is_object() and m_value.object->find(std::forward<KeyT>(key)) != m_value.object->end();
    }

    /*!
    @brief check the existence of an element in a JSON object given a JSON pointer

    Check wehther the given JSON pointer @a ptr can be resolved in the current
    JSON value.

    @note This method can be executed on any JSON value type.

    @param[in] ptr JSON pointer to check its existence.

    @return true if the JSON pointer can be resolved to a stored value, false
    otherwise.

    @post If `j.contains(ptr)` returns true, it is safe to call `j[ptr]`.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The following code shows an example for `contains()`.,contains_json_pointer}

    @sa @ref contains(KeyT &&) const -- checks the existence of a key

    @since version 3.7.0
    */
    bool contains(const json_pointer& ptr) const
    {
        return ptr.contains(this);
    }

    /// @}


    ///////////////
    // iterators //
    ///////////////

    /// @name iterators
    /// @{

    /*!
    @brief returns an iterator to the first element

    Returns an iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `begin()`.,begin}

    @sa @ref cbegin() -- returns a const iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    iterator begin() noexcept
    {
        iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @copydoc basic_json::cbegin()
    */
    const_iterator begin() const noexcept
    {
        return cbegin();
    }

    /*!
    @brief returns a const iterator to the first element

    Returns a const iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).begin()`.

    @liveexample{The following code shows an example for `cbegin()`.,cbegin}

    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    const_iterator cbegin() const noexcept
    {
        const_iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @brief returns an iterator to one past the last element

    Returns an iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `end()`.,end}

    @sa @ref cend() -- returns a const iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    iterator end() noexcept
    {
        iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @copydoc basic_json::cend()
    */
    const_iterator end() const noexcept
    {
        return cend();
    }

    /*!
    @brief returns a const iterator to one past the last element

    Returns a const iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).end()`.

    @liveexample{The following code shows an example for `cend()`.,cend}

    @sa @ref end() -- returns an iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    const_iterator cend() const noexcept
    {
        const_iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @brief returns an iterator to the reverse-beginning

    Returns an iterator to the reverse-beginning; that is, the last element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(end())`.

    @liveexample{The following code shows an example for `rbegin()`.,rbegin}

    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    /*!
    @copydoc basic_json::crbegin()
    */
    const_reverse_iterator rbegin() const noexcept
    {
        return crbegin();
    }

    /*!
    @brief returns an iterator to the reverse-end

    Returns an iterator to the reverse-end; that is, one before the first
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(begin())`.

    @liveexample{The following code shows an example for `rend()`.,rend}

    @sa @ref crend() -- returns a const reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    /*!
    @copydoc basic_json::crend()
    */
    const_reverse_iterator rend() const noexcept
    {
        return crend();
    }

    /*!
    @brief returns a const reverse iterator to the last element

    Returns a const iterator to the reverse-beginning; that is, the last
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.

    @liveexample{The following code shows an example for `crbegin()`.,crbegin}

    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(cend());
    }

    /*!
    @brief returns a const reverse iterator to one before the first

    Returns a const reverse iterator to the reverse-end; that is, one before
    the first element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rend()`.

    @liveexample{The following code shows an example for `crend()`.,crend}

    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(cbegin());
    }

  public:
    /*!
    @brief wrapper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without iterator_wrapper:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without iterator proxy:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with iterator proxy:

    @code{cpp}
    for (auto it : json::iterator_wrapper(j_object))
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example).

    @param[in] ref  reference to a JSON value
    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the wrapper is used,iterator_wrapper}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @note The name of this function is not yet final and may change in the
    future.

    @deprecated This stream operator is deprecated and will be removed in
                future 4.0.0 of the library. Please use @ref items() instead;
                that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    */
    JSON_HEDLEY_DEPRECATED(3.1.0)
    static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
    {
        return ref.items();
    }

    /*!
    @copydoc iterator_wrapper(reference)
    */
    JSON_HEDLEY_DEPRECATED(3.1.0)
    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
    {
        return ref.items();
    }

    /*!
    @brief helper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without `items()` function:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without `items()` function:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with `items()` function:

    @code{cpp}
    for (auto& el : j_object.items())
    {
        std::cout << "key: " << el.key() << ", value:" << el.value() << '\n';
    }
    @endcode

    The `items()` function also allows to use
    [structured bindings](https://en.cppreference.com/w/cpp/language/structured_binding)
    (C++17):

    @code{cpp}
    for (auto& [key, val] : j_object.items())
    {
        std::cout << "key: " << key << ", value:" << val << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example). For primitive types (e.g., numbers),
          `key()` returns an empty string.

    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the function is used.,items}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 3.1.0, structured bindings support since 3.5.0.
    */
    iteration_proxy<iterator> items() noexcept
    {
        return iteration_proxy<iterator>(*this);
    }

    /*!
    @copydoc items()
    */
    iteration_proxy<const_iterator> items() const noexcept
    {
        return iteration_proxy<const_iterator>(*this);
    }

    /// @}


    //////////////
    // capacity //
    //////////////

    /// @name capacity
    /// @{

    /*!
    @brief checks whether the container is empty.

    Checks if a JSON value has no elements (i.e. whether its @ref size is `0`).

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `true`
            boolean     | `false`
            string      | `false`
            number      | `false`
            object      | result of function `object_t::empty()`
            array       | result of function `array_t::empty()`

    @liveexample{The following code uses `empty()` to check if a JSON
    object contains any elements.,empty}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `empty()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return whether a string stored as JSON value
    is empty - it returns whether the JSON container itself is empty which is
    false in the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `begin() == end()`.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    bool empty() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return true;
            }

            case value_t::array:
            {
                // delegate call to array_t::empty()
                return m_value.array->empty();
            }

            case value_t::object:
            {
                // delegate call to object_t::empty()
                return m_value.object->empty();
            }

            default:
            {
                // all other types are nonempty
                return false;
            }
        }
    }

    /*!
    @brief returns the number of elements

    Returns the number of elements in a JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0`
            boolean     | `1`
            string      | `1`
            number      | `1`
            object      | result of function object_t::size()
            array       | result of function array_t::size()

    @liveexample{The following code calls `size()` on the different value
    types.,size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their size() functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return the length of a string stored as JSON
    value - it returns the number of elements in the JSON value which is 1 in
    the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `std::distance(begin(), end())`.

    @sa @ref empty() -- checks whether the container is empty
    @sa @ref max_size() -- returns the maximal number of elements

    @since version 1.0.0
    */
    size_type size() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return 0;
            }

            case value_t::array:
            {
                // delegate call to array_t::size()
                return m_value.array->size();
            }

            case value_t::object:
            {
                // delegate call to object_t::size()
                return m_value.object->size();
            }

            default:
            {
                // all other types have size 1
                return 1;
            }
        }
    }

    /*!
    @brief returns the maximum possible number of elements

    Returns the maximum number of elements a JSON value is able to hold due to
    system or library implementation limitations, i.e. `std::distance(begin(),
    end())` for the JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0` (same as `size()`)
            boolean     | `1` (same as `size()`)
            string      | `1` (same as `size()`)
            number      | `1` (same as `size()`)
            object      | result of function `object_t::max_size()`
            array       | result of function `array_t::max_size()`

    @liveexample{The following code calls `max_size()` on the different value
    types. Note the output is implementation specific.,max_size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `max_size()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of returning `b.size()` where `b` is the largest
      possible JSON value.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    size_type max_size() const noexcept
    {
        switch (m_type)
        {
            case value_t::array:
            {
                // delegate call to array_t::max_size()
                return m_value.array->max_size();
            }

            case value_t::object:
            {
                // delegate call to object_t::max_size()
                return m_value.object->max_size();
            }

            default:
            {
                // all other types have max_size() == size()
                return size();
            }
        }
    }

    /// @}


    ///////////////
    // modifiers //
    ///////////////

    /// @name modifiers
    /// @{

    /*!
    @brief clears the contents

    Clears the content of a JSON value and resets it to the default value as
    if @ref basic_json(value_t) would have been called with the current value
    type from @ref type():

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    object      | `{}`
    array       | `[]`

    @post Has the same effect as calling
    @code {.cpp}
    *this = basic_json(type());
    @endcode

    @liveexample{The example below shows the effect of `clear()` to different
    JSON types.,clear}

    @complexity Linear in the size of the JSON value.

    @iterators All iterators, pointers and references related to this container
               are invalidated.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @sa @ref basic_json(value_t) -- constructor that creates an object with the
        same value than calling `clear()`

    @since version 1.0.0
    */
    void clear() noexcept
    {
        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = 0;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = 0;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = 0.0;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = false;
                break;
            }

            case value_t::string:
            {
                m_value.string->clear();
                break;
            }

            case value_t::array:
            {
                m_value.array->clear();
                break;
            }

            case value_t::object:
            {
                m_value.object->clear();
                break;
            }

            default:
                break;
        }
    }

    /*!
    @brief add an object to an array

    Appends the given element @a val to the end of the JSON value. If the
    function is called on a JSON null value, an empty array is created before
    appending @a val.

    @param[in] val the value to add to the JSON array

    @throw type_error.308 when called on a type other than JSON array or
    null; example: `"cannot use push_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON array. Note how the `null` value was silently
    converted to a JSON array.,push_back}

    @since version 1.0.0
    */
    void push_back(basic_json&& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (move semantics)
        m_value.array->push_back(std::move(val));
        // invalidate object: mark it null so we do not call the destructor
        // cppcheck-suppress accessMoved
        val.m_type = value_t::null;
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(basic_json&& val)
    {
        push_back(std::move(val));
        return *this;
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    void push_back(const basic_json& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array
        m_value.array->push_back(val);
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(const basic_json& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    Inserts the given element @a val to the JSON object. If the function is
    called on a JSON null value, an empty object is created before inserting
    @a val.

    @param[in] val the value to add to the JSON object

    @throw type_error.308 when called on a type other than JSON object or
    null; example: `"cannot use push_back() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON object. Note how the `null` value was silently
    converted to a JSON object.,push_back__object_t__value}

    @since version 1.0.0
    */
    void push_back(const typename object_t::value_type& val)
    {
        // push_back only works for null objects or objects
        if (JSON_HEDLEY_UNLIKELY(not(is_null() or is_object())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array
        m_value.object->insert(val);
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(const typename object_t::value_type&)
    */
    reference operator+=(const typename object_t::value_type& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    This function allows to use `push_back` with an initializer list. In case

    1. the current value is an object,
    2. the initializer list @a init contains only two elements, and
    3. the first element of @a init is a string,

    @a init is converted into an object element and added using
    @ref push_back(const typename object_t::value_type&). Otherwise, @a init
    is converted to a JSON value and added using @ref push_back(basic_json&&).

    @param[in] init  an initializer list

    @complexity Linear in the size of the initializer list @a init.

    @note This function is required to resolve an ambiguous overload error,
          because pairs like `{"key", "value"}` can be both interpreted as
          `object_t::value_type` or `std::initializer_list<basic_json>`, see
          https://github.com/nlohmann/json/issues/235 for more information.

    @liveexample{The example shows how initializer lists are treated as
    objects when possible.,push_back__initializer_list}
    */
    void push_back(initializer_list_t init)
    {
        if (is_object() and init.size() == 2 and (*init.begin())->is_string())
        {
            basic_json&& key = init.begin()->moved_or_copied();
            push_back(typename object_t::value_type(
                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
        }
        else
        {
            push_back(basic_json(init));
        }
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(initializer_list_t)
    */
    reference operator+=(initializer_list_t init)
    {
        push_back(init);
        return *this;
    }

    /*!
    @brief add an object to an array

    Creates a JSON value from the passed parameters @a args to the end of the
    JSON value. If the function is called on a JSON null value, an empty array
    is created before appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @return reference to the inserted element

    @throw type_error.311 when called on a type other than JSON array or
    null; example: `"cannot use emplace_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` can be used to add
    elements to a JSON array. Note how the `null` value was silently converted
    to a JSON array.,emplace_back}

    @since version 2.0.8, returns reference since 3.7.0
    */
    template<class... Args>
    reference emplace_back(Args&& ... args)
    {
        // emplace_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
#ifdef JSON_HAS_CPP_17
        return m_value.array->emplace_back(std::forward<Args>(args)...);
#else
        m_value.array->emplace_back(std::forward<Args>(args)...);
        return m_value.array->back();
#endif
    }

    /*!
    @brief add an object to an object if key does not exist

    Inserts a new element into a JSON object constructed in-place with the
    given @a args if there is no element with the key in the container. If the
    function is called on a JSON null value, an empty object is created before
    appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @return a pair consisting of an iterator to the inserted element, or the
            already-existing element if no insertion happened, and a bool
            denoting whether the insertion took place.

    @throw type_error.311 when called on a type other than JSON object or
    null; example: `"cannot use emplace() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `emplace()` can be used to add elements
    to a JSON object. Note how the `null` value was silently converted to a
    JSON object. Further note how no value is added if there was already one
    value stored with the same key.,emplace}

    @since version 2.0.8
    */
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&& ... args)
    {
        // emplace only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(not(is_null() or is_object())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        auto res = m_value.object->emplace(std::forward<Args>(args)...);
        // create result iterator and set iterator to the result of emplace
        auto it = begin();
        it.m_it.object_iterator = res.first;

        // return pair of iterator and boolean
        return {it, res.second};
    }

    /// Helper for insertion of an iterator
    /// @note: This uses std::distance to support GCC 4.8,
    ///        see https://github.com/nlohmann/json/pull/1257
    template<typename... Args>
    iterator insert_iterator(const_iterator pos, Args&& ... args)
    {
        iterator result(this);
        assert(m_value.array != nullptr);

        auto insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);
        m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
        result.m_it.array_iterator = m_value.array->begin() + insert_pos;

        // This could have been written as:
        // result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);
        // but the return value of insert is missing in GCC 4.8, so it is written this way instead.

        return result;
    }

    /*!
    @brief inserts element

    Inserts element @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] val element to insert
    @return iterator pointing to the inserted @a val.

    @throw type_error.309 if called on JSON values other than arrays;
    example: `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Constant plus linear in the distance between @a pos and end of
    the container.

    @liveexample{The example shows how `insert()` is used.,insert}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            return insert_iterator(pos, val);
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts element
    @copydoc insert(const_iterator, const basic_json&)
    */
    iterator insert(const_iterator pos, basic_json&& val)
    {
        return insert(pos, val);
    }

    /*!
    @brief inserts elements

    Inserts @a cnt copies of @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] cnt number of copies of @a val to insert
    @param[in] val element to insert
    @return iterator pointing to the first element inserted, or @a pos if
    `cnt==0`

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Linear in @a cnt plus linear in the distance between @a pos
    and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__count}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            return insert_iterator(pos, cnt, val);
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)` before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`
    @throw invalid_iterator.211 if @a first or @a last are iterators into
    container for which insert is called; example: `"passed iterators may not
    belong to container"`

    @return iterator pointing to the first element inserted, or @a pos if
    `first==last`

    @complexity Linear in `std::distance(first, last)` plus linear in the
    distance between @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__range}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const_iterator first, const_iterator last)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(not is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
        {
            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container"));
        }

        // insert to array and return iterator
        return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
    }

    /*!
    @brief inserts elements

    Inserts elements from initializer list @a ilist before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] ilist initializer list to insert the values from

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @return iterator pointing to the first element inserted, or @a pos if
    `ilist` is empty

    @complexity Linear in `ilist.size()` plus linear in the distance between
    @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__ilist}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, initializer_list_t ilist)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(not is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // insert to array and return iterator
        return insert_iterator(pos, ilist.begin(), ilist.end());
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)`.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than objects; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number
    of elements to insert.

    @liveexample{The example shows how `insert()` is used.,insert__range_object}

    @since version 3.0.0
    */
    void insert(const_iterator first, const_iterator last)
    {
        // insert only works for objects
        if (JSON_HEDLEY_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(not first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from JSON object @a j and overwrites existing keys.

    @param[in] j  JSON object to read values from

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_reference j)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }
        if (JSON_HEDLEY_UNLIKELY(not j.is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(j.type_name())));
        }

        for (auto it = j.cbegin(); it != j.cend(); ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from from range `[first, last)` and overwrites existing
    keys.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used__range.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_iterator first, const_iterator last)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(not first.m_object->is_object()
                                 or not last.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        for (auto it = first; it != last; ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of the JSON value with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other JSON value to exchange the contents with

    @complexity Constant.

    @liveexample{The example below shows how JSON values can be swapped with
    `swap()`.,swap__reference}

    @since version 1.0.0
    */
    void swap(reference other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value and
        std::is_nothrow_move_assignable<value_t>::value and
        std::is_nothrow_move_constructible<json_value>::value and
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        std::swap(m_type, other.m_type);
        std::swap(m_value, other.m_value);
        assert_invariant();
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON array with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other array to exchange the contents with

    @throw type_error.310 when JSON value is not an array; example: `"cannot
    use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how arrays can be swapped with
    `swap()`.,swap__array_t}

    @since version 1.0.0
    */
    void swap(array_t& other)
    {
        // swap only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            std::swap(*(m_value.array), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON object with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other object to exchange the contents with

    @throw type_error.310 when JSON value is not an object; example:
    `"cannot use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how objects can be swapped with
    `swap()`.,swap__object_t}

    @since version 1.0.0
    */
    void swap(object_t& other)
    {
        // swap only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            std::swap(*(m_value.object), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON string with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other string to exchange the contents with

    @throw type_error.310 when JSON value is not a string; example: `"cannot
    use swap() with boolean"`

    @complexity Constant.

    @liveexample{The example below shows how strings can be swapped with
    `swap()`.,swap__string_t}

    @since version 1.0.0
    */
    void swap(string_t& other)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_string()))
        {
            std::swap(*(m_value.string), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /// @}

  public:
    //////////////////////////////////////////
    // lexicographical comparison operators //
    //////////////////////////////////////////

    /// @name lexicographical comparison operators
    /// @{

    /*!
    @brief comparison: equal

    Compares two JSON values for equality according to the following rules:
    - Two JSON values are equal if (1) they are from the same type and (2)
      their stored values are the same according to their respective
      `operator==`.
    - Integer and floating-point numbers are automatically converted before
      comparison. Note than two NaN values are always treated as unequal.
    - Two JSON null values are equal.

    @note Floating-point inside JSON values numbers are compared with
    `json::number_float_t::operator==` which is `double::operator==` by
    default. To compare floating-point while respecting an epsilon, an alternative
    [comparison function](https://github.com/mariokonrad/marnav/blob/master/src/marnav/math/floatingpoint.hpp#L34-#L39)
    could be used, for instance
    @code {.cpp}
    template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>
    inline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept
    {
        return std::abs(a - b) <= epsilon;
    }
    @endcode

    @note NaN values never compare equal to themselves or to other NaN values.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are equal

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Linear.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__equal}

    @since version 1.0.0
    */
    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    return *lhs.m_value.array == *rhs.m_value.array;

                case value_t::object:
                    return *lhs.m_value.object == *rhs.m_value.object;

                case value_t::null:
                    return true;

                case value_t::string:
                    return *lhs.m_value.string == *rhs.m_value.string;

                case value_t::boolean:
                    return lhs.m_value.boolean == rhs.m_value.boolean;

                case value_t::number_integer:
                    return lhs.m_value.number_integer == rhs.m_value.number_integer;

                case value_t::number_unsigned:
                    return lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;

                case value_t::number_float:
                    return lhs.m_value.number_float == rhs.m_value.number_float;

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }

        return false;
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs == basic_json(rhs);
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) == rhs;
    }

    /*!
    @brief comparison: not equal

    Compares two JSON values for inequality by calculating `not (lhs == rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are not equal

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__notequal}

    @since version 1.0.0
    */
    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs == rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs != basic_json(rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) != rhs;
    }

    /*!
    @brief comparison: less than

    Compares whether one JSON value @a lhs is less than another JSON value @a
    rhs according to the following rules:
    - If @a lhs and @a rhs have the same type, the values are compared using
      the default `<` operator.
    - Integer and floating-point numbers are automatically converted before
      comparison
    - In case @a lhs and @a rhs have different types, the values are ignored
      and the order of the types is considered, see
      @ref operator<(const value_t, const value_t).

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__less}

    @since version 1.0.0
    */
    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    // note parentheses are necessary, see
                    // https://github.com/nlohmann/json/issues/1530
                    return (*lhs.m_value.array) < (*rhs.m_value.array);

                case value_t::object:
                    return (*lhs.m_value.object) < (*rhs.m_value.object);

                case value_t::null:
                    return false;

                case value_t::string:
                    return (*lhs.m_value.string) < (*rhs.m_value.string);

                case value_t::boolean:
                    return (lhs.m_value.boolean) < (rhs.m_value.boolean);

                case value_t::number_integer:
                    return (lhs.m_value.number_integer) < (rhs.m_value.number_integer);

                case value_t::number_unsigned:
                    return (lhs.m_value.number_unsigned) < (rhs.m_value.number_unsigned);

                case value_t::number_float:
                    return (lhs.m_value.number_float) < (rhs.m_value.number_float);

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
        }

        // We only reach this line if we cannot compare values. In that case,
        // we compare types. Note we have to call the operator explicitly,
        // because MSVC has problems otherwise.
        return operator<(lhs_type, rhs_type);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs < basic_json(rhs);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) < rhs;
    }

    /*!
    @brief comparison: less than or equal

    Compares whether one JSON value @a lhs is less than or equal to another
    JSON value by calculating `not (rhs < lhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greater}

    @since version 1.0.0
    */
    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (rhs < lhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs <= basic_json(rhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) <= rhs;
    }

    /*!
    @brief comparison: greater than

    Compares whether one JSON value @a lhs is greater than another
    JSON value by calculating `not (lhs <= rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__lessequal}

    @since version 1.0.0
    */
    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs <= rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs > basic_json(rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) > rhs;
    }

    /*!
    @brief comparison: greater than or equal

    Compares whether one JSON value @a lhs is greater than or equal to another
    JSON value by calculating `not (lhs < rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greaterequal}

    @since version 1.0.0
    */
    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs < rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs >= basic_json(rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) >= rhs;
    }

    /// @}

    ///////////////////
    // serialization //
    ///////////////////

    /// @name serialization
    /// @{

    /*!
    @brief serialize to stream

    Serialize the given JSON value @a j to the output stream @a o. The JSON
    value will be serialized using the @ref dump member function.

    - The indentation of the output can be controlled with the member variable
      `width` of the output stream @a o. For instance, using the manipulator
      `std::setw(4)` on @a o sets the indentation level to `4` and the
      serialization result is the same as calling `dump(4)`.

    - The indentation character can be controlled with the member variable
      `fill` of the output stream @a o. For instance, the manipulator
      `std::setfill('\\t')` sets indentation to use a tab character rather than
      the default space character.

    @param[in,out] o  stream to serialize to
    @param[in] j  JSON value to serialize

    @return the stream @a o

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded

    @complexity Linear.

    @liveexample{The example below shows the serialization with different
    parameters to `width` to adjust the indentation level.,operator_serialize}

    @since version 1.0.0; indentation character added in version 3.0.0
    */
    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
    {
        // read width member and use it as indentation parameter if nonzero
        const bool pretty_print = o.width() > 0;
        const auto indentation = pretty_print ? o.width() : 0;

        // reset width to 0 for subsequent calls to this stream
        o.width(0);

        // do the actual serialization
        serializer s(detail::output_adapter<char>(o), o.fill());
        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
        return o;
    }

    /*!
    @brief serialize to stream
    @deprecated This stream operator is deprecated and will be removed in
                future 4.0.0 of the library. Please use
                @ref operator<<(std::ostream&, const basic_json&)
                instead; that is, replace calls like `j >> o;` with `o << j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_HEDLEY_DEPRECATED(3.0.0)
    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
    {
        return o << j;
    }

    /// @}


    /////////////////////
    // deserialization //
    /////////////////////

    /// @name deserialization
    /// @{

    /*!
    @brief deserialize from a compatible input

    This function reads from a compatible input. Examples are:
    - an array of 1-byte values
    - strings with character/literal type with size of 1 byte
    - input streams
    - container with contiguous storage of 1-byte values. Compatible container
      types include `std::vector`, `std::string`, `std::array`,
      `std::valarray`, and `std::initializer_list`. Furthermore, C-style
      arrays can be used with `std::begin()`/`std::end()`. User-defined
      containers can be used as long as they implement random-access iterators
      and a contiguous storage.

    @pre Each element of the container has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @pre The container storage is contiguous. Violating this precondition
    yields undefined behavior. **This precondition is enforced with an
    assertion.**

    @warning There is no way to enforce all preconditions at compile-time. If
             the function is called with a noncompliant container and with
             assertions switched off, the behavior is undefined and will most
             likely yield segmentation violation.

    @param[in] i  input to read from
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the parser callback function
    @a cb has a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `parse()` function reading
    from an array.,parse__array__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__string__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__istream__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function reading
    from a contiguous container.,parse__contiguouscontainer__parser_callback_t}

    @since version 2.0.3 (contiguous containers)
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(detail::input_adapter&& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true)
    {
        basic_json result;
        parser(i, cb, allow_exceptions).parse(true, result);
        return result;
    }

    static bool accept(detail::input_adapter&& i)
    {
        return parser(i).accept(true);
    }

    /*!
    @brief generate SAX events

    The SAX event lister must follow the interface of @ref json_sax.

    This function reads from a compatible input. Examples are:
    - an array of 1-byte values
    - strings with character/literal type with size of 1 byte
    - input streams
    - container with contiguous storage of 1-byte values. Compatible container
      types include `std::vector`, `std::string`, `std::array`,
      `std::valarray`, and `std::initializer_list`. Furthermore, C-style
      arrays can be used with `std::begin()`/`std::end()`. User-defined
      containers can be used as long as they implement random-access iterators
      and a contiguous storage.

    @pre Each element of the container has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @pre The container storage is contiguous. Violating this precondition
    yields undefined behavior. **This precondition is enforced with an
    assertion.**

    @warning There is no way to enforce all preconditions at compile-time. If
             the function is called with a noncompliant container and with
             assertions switched off, the behavior is undefined and will most
             likely yield segmentation violation.

    @param[in] i  input to read from
    @param[in,out] sax  SAX event listener
    @param[in] format  the format to parse (JSON, CBOR, MessagePack, or UBJSON)
    @param[in] strict  whether the input has to be consumed completely

    @return return value of the last processed SAX event

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the SAX consumer @a sax has
    a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `sax_parse()` function
    reading from string and processing the events with a user-defined SAX
    event consumer.,sax_parse}

    @since version 3.2.0
    */
    template <typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(detail::input_adapter&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true)
    {
        assert(sax);
        return format == input_format_t::json
               ? parser(std::move(i)).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, SAX>(std::move(i)).sax_parse(format, sax, strict);
    }

    /*!
    @brief deserialize from an iterator range with contiguous storage

    This function reads from an iterator range of a container with contiguous
    storage of 1-byte values. Compatible container types include
    `std::vector`, `std::string`, `std::array`, `std::valarray`, and
    `std::initializer_list`. Furthermore, C-style arrays can be used with
    `std::begin()`/`std::end()`. User-defined containers can be used as long
    as they implement random-access iterators and a contiguous storage.

    @pre The iterator range is contiguous. Violating this precondition yields
    undefined behavior. **This precondition is enforced with an assertion.**
    @pre Each element in the range has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @warning There is no way to enforce all preconditions at compile-time. If
             the function is called with noncompliant iterators and with
             assertions switched off, the behavior is undefined and will most
             likely yield segmentation violation.

    @tparam IteratorType iterator of container with contiguous storage
    @param[in] first  begin of the range to parse (included)
    @param[in] last  end of the range to parse (excluded)
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the parser callback function
    @a cb has a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `parse()` function reading
    from an iterator range.,parse__iteratortype__parser_callback_t}

    @since version 2.0.3
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_base_of<
                     std::random_access_iterator_tag,
                     typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
    static basic_json parse(IteratorType first, IteratorType last,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true)
    {
        basic_json result;
        parser(detail::input_adapter(first, last), cb, allow_exceptions).parse(true, result);
        return result;
    }

    template<class IteratorType, typename std::enable_if<
                 std::is_base_of<
                     std::random_access_iterator_tag,
                     typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
    static bool accept(IteratorType first, IteratorType last)
    {
        return parser(detail::input_adapter(first, last)).accept(true);
    }

    template<class IteratorType, class SAX, typename std::enable_if<
                 std::is_base_of<
                     std::random_access_iterator_tag,
                     typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
    JSON_HEDLEY_NON_NULL(3)
    static bool sax_parse(IteratorType first, IteratorType last, SAX* sax)
    {
        return parser(detail::input_adapter(first, last)).sax_parse(sax);
    }

    /*!
    @brief deserialize from stream
    @deprecated This stream operator is deprecated and will be removed in
                version 4.0.0 of the library. Please use
                @ref operator>>(std::istream&, basic_json&)
                instead; that is, replace calls like `j << i;` with `i >> j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_HEDLEY_DEPRECATED(3.0.0)
    friend std::istream& operator<<(basic_json& j, std::istream& i)
    {
        return operator>>(i, j);
    }

    /*!
    @brief deserialize from stream

    Deserializes an input stream to a JSON value.

    @param[in,out] i  input stream to read a serialized JSON value from
    @param[in,out] j  JSON value to write the deserialized input to

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below shows how a JSON value is constructed by
    reading a serialization from a stream.,operator_deserialize}

    @sa parse(std::istream&, const parser_callback_t) for a variant with a
    parser callback function to filter values while parsing

    @since version 1.0.0
    */
    friend std::istream& operator>>(std::istream& i, basic_json& j)
    {
        parser(detail::input_adapter(i)).parse(false, j);
        return i;
    }

    /// @}

    ///////////////////////////
    // convenience functions //
    ///////////////////////////

    /*!
    @brief return the type as string

    Returns the type name as string to be used in error messages - usually to
    indicate that a function was called on a wrong JSON type.

    @return a string representation of a the @a m_type member:
            Value type  | return value
            ----------- | -------------
            null        | `"null"`
            boolean     | `"boolean"`
            string      | `"string"`
            number      | `"number"` (for all number types)
            object      | `"object"`
            array       | `"array"`
            discarded   | `"discarded"`

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Constant.

    @liveexample{The following code exemplifies `type_name()` for all JSON
    types.,type_name}

    @sa @ref type() -- return the type of the JSON value
    @sa @ref operator value_t() -- return the type of the JSON value (implicit)

    @since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
    since 3.0.0
    */
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* type_name() const noexcept
    {
        {
            switch (m_type)
            {
                case value_t::null:
                    return "null";
                case value_t::object:
                    return "object";
                case value_t::array:
                    return "array";
                case value_t::string:
                    return "string";
                case value_t::boolean:
                    return "boolean";
                case value_t::discarded:
                    return "discarded";
                default:
                    return "number";
            }
        }
    }


  private:
    //////////////////////
    // member variables //
    //////////////////////

    /// the type of the current element
    value_t m_type = value_t::null;

    /// the value of the current element
    json_value m_value = {};

    //////////////////////////////////////////
    // binary serialization/deserialization //
    //////////////////////////////////////////

    /// @name binary serialization/deserialization support
    /// @{

  public:
    /*!
    @brief create a CBOR serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the CBOR (Concise
    Binary Object Representation) serialization format. CBOR is a binary
    serialization format which aims to be more compact than JSON itself, yet
    more efficient to parse.

    The library uses the following mapping from JSON values types to
    CBOR types according to the CBOR specification (RFC 7049):

    JSON value type | value/range                                | CBOR type                          | first byte
    --------------- | ------------------------------------------ | ---------------------------------- | ---------------
    null            | `null`                                     | Null                               | 0xF6
    boolean         | `true`                                     | True                               | 0xF5
    boolean         | `false`                                    | False                              | 0xF4
    number_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B
    number_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A
    number_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39
    number_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38
    number_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37
    number_integer  | 0..23                                      | Integer                            | 0x00..0x17
    number_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_unsigned | 0..23                                      | Integer                            | 0x00..0x17
    number_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_float    | *any value*                                | Double-Precision Float             | 0xFB
    string          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77
    string          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78
    string          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79
    string          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A
    string          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B
    array           | *size*: 0..23                              | array                              | 0x80..0x97
    array           | *size*: 23..255                            | array (1 byte follow)              | 0x98
    array           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99
    array           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A
    array           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B
    object          | *size*: 0..23                              | map                                | 0xA0..0xB7
    object          | *size*: 23..255                            | map (1 byte follow)                | 0xB8
    object          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9
    object          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA
    object          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a CBOR value.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The following CBOR types are not used in the conversion:
          - byte strings (0x40..0x5F)
          - UTF-8 strings terminated by "break" (0x7F)
          - arrays terminated by "break" (0x9F)
          - maps terminated by "break" (0xBF)
          - date/time (0xC0..0xC1)
          - bignum (0xC2..0xC3)
          - decimal fraction (0xC4)
          - bigfloat (0xC5)
          - tagged items (0xC6..0xD4, 0xD8..0xDB)
          - expected conversions (0xD5..0xD7)
          - simple values (0xE0..0xF3, 0xF8)
          - undefined (0xF7)
          - half and single-precision floats (0xF9-0xFA)
          - break (0xFF)

    @param[in] j  JSON value to serialize
    @return MessagePack serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in CBOR format.,to_cbor}

    @sa http://cbor.io
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool) for the
        analogous deserialization
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format

    @since version 2.0.9
    */
    static std::vector<uint8_t> to_cbor(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_cbor(j, result);
        return result;
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_cbor(j);
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_cbor(j);
    }

    /*!
    @brief create a MessagePack serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the MessagePack
    serialization format. MessagePack is a binary serialization format which
    aims to be more compact than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    MessagePack types according to the MessagePack specification:

    JSON value type | value/range                       | MessagePack type | first byte
    --------------- | --------------------------------- | ---------------- | ----------
    null            | `null`                            | nil              | 0xC0
    boolean         | `true`                            | true             | 0xC3
    boolean         | `false`                           | false            | 0xC2
    number_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3
    number_integer  | -2147483648..-32769               | int32            | 0xD2
    number_integer  | -32768..-129                      | int16            | 0xD1
    number_integer  | -128..-33                         | int8             | 0xD0
    number_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF
    number_integer  | 0..127                            | positive fixint  | 0x00..0x7F
    number_integer  | 128..255                          | uint 8           | 0xCC
    number_integer  | 256..65535                        | uint 16          | 0xCD
    number_integer  | 65536..4294967295                 | uint 32          | 0xCE
    number_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_unsigned | 0..127                            | positive fixint  | 0x00..0x7F
    number_unsigned | 128..255                          | uint 8           | 0xCC
    number_unsigned | 256..65535                        | uint 16          | 0xCD
    number_unsigned | 65536..4294967295                 | uint 32          | 0xCE
    number_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_float    | *any value*                       | float 64         | 0xCB
    string          | *length*: 0..31                   | fixstr           | 0xA0..0xBF
    string          | *length*: 32..255                 | str 8            | 0xD9
    string          | *length*: 256..65535              | str 16           | 0xDA
    string          | *length*: 65536..4294967295       | str 32           | 0xDB
    array           | *size*: 0..15                     | fixarray         | 0x90..0x9F
    array           | *size*: 16..65535                 | array 16         | 0xDC
    array           | *size*: 65536..4294967295         | array 32         | 0xDD
    object          | *size*: 0..15                     | fix map          | 0x80..0x8F
    object          | *size*: 16..65535                 | map 16           | 0xDE
    object          | *size*: 65536..4294967295         | map 32           | 0xDF

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a MessagePack value.

    @note The following values can **not** be converted to a MessagePack value:
          - strings with more than 4294967295 bytes
          - arrays with more than 4294967295 elements
          - objects with more than 4294967295 elements

    @note The following MessagePack types are not used in the conversion:
          - bin 8 - bin 32 (0xC4..0xC6)
          - ext 8 - ext 32 (0xC7..0xC9)
          - float 32 (0xCA)
          - fixext 1 - fixext 16 (0xD4..0xD8)

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @param[in] j  JSON value to serialize
    @return MessagePack serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in MessagePack format.,to_msgpack}

    @sa http://msgpack.org
    @sa @ref from_msgpack for the analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format

    @since version 2.0.9
    */
    static std::vector<uint8_t> to_msgpack(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_msgpack(j, result);
        return result;
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_msgpack(j);
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_msgpack(j);
    }

    /*!
    @brief create a UBJSON serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the UBJSON
    (Universal Binary JSON) serialization format. UBJSON aims to be more compact
    than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    UBJSON types according to the UBJSON specification:

    JSON value type | value/range                       | UBJSON type | marker
    --------------- | --------------------------------- | ----------- | ------
    null            | `null`                            | null        | `Z`
    boolean         | `true`                            | true        | `T`
    boolean         | `false`                           | false       | `F`
    number_integer  | -9223372036854775808..-2147483649 | int64       | `L`
    number_integer  | -2147483648..-32769               | int32       | `l`
    number_integer  | -32768..-129                      | int16       | `I`
    number_integer  | -128..127                         | int8        | `i`
    number_integer  | 128..255                          | uint8       | `U`
    number_integer  | 256..32767                        | int16       | `I`
    number_integer  | 32768..2147483647                 | int32       | `l`
    number_integer  | 2147483648..9223372036854775807   | int64       | `L`
    number_unsigned | 0..127                            | int8        | `i`
    number_unsigned | 128..255                          | uint8       | `U`
    number_unsigned | 256..32767                        | int16       | `I`
    number_unsigned | 32768..2147483647                 | int32       | `l`
    number_unsigned | 2147483648..9223372036854775807   | int64       | `L`
    number_float    | *any value*                       | float64     | `D`
    string          | *with shortest length indicator*  | string      | `S`
    array           | *see notes on optimized format*   | array       | `[`
    object          | *see notes on optimized format*   | map         | `{`

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a UBJSON value.

    @note The following values can **not** be converted to a UBJSON value:
          - strings with more than 9223372036854775807 bytes (theoretical)
          - unsigned integer numbers above 9223372036854775807

    @note The following markers are not used in the conversion:
          - `Z`: no-op values are not created.
          - `C`: single-byte strings are serialized with `S` markers.

    @note Any UBJSON output created @ref to_ubjson can be successfully parsed
          by @ref from_ubjson.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The optimized formats for containers are supported: Parameter
          @a use_size adds size information to the beginning of a container and
          removes the closing marker. Parameter @a use_type further checks
          whether all elements of a container have the same type and adds the
          type marker to the beginning of the container. The @a use_type
          parameter must only be used together with @a use_size = true. Note
          that @a use_size = true alone may result in larger representations -
          the benefit of this parameter is that the receiving side is
          immediately informed on the number of elements of the container.

    @param[in] j  JSON value to serialize
    @param[in] use_size  whether to add size annotations to container types
    @param[in] use_type  whether to add type annotations to container types
                         (must be combined with @a use_size = true)
    @return UBJSON serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in UBJSON format.,to_ubjson}

    @sa http://ubjson.org
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format

    @since version 3.1.0
    */
    static std::vector<uint8_t> to_ubjson(const basic_json& j,
                                          const bool use_size = false,
                                          const bool use_type = false)
    {
        std::vector<uint8_t> result;
        to_ubjson(j, result, use_size, use_type);
        return result;
    }

    static void to_ubjson(const basic_json& j, detail::output_adapter<uint8_t> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<uint8_t>(o).write_ubjson(j, use_size, use_type);
    }

    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
    }


    /*!
    @brief Serializes the given JSON object `j` to BSON and returns a vector
           containing the corresponding BSON-representation.

    BSON (Binary JSON) is a binary format in which zero or more ordered key/value pairs are
    stored as a single entity (a so-called document).

    The library uses the following mapping from JSON values types to BSON types:

    JSON value type | value/range                       | BSON type   | marker
    --------------- | --------------------------------- | ----------- | ------
    null            | `null`                            | null        | 0x0A
    boolean         | `true`, `false`                   | boolean     | 0x08
    number_integer  | -9223372036854775808..-2147483649 | int64       | 0x12
    number_integer  | -2147483648..2147483647           | int32       | 0x10
    number_integer  | 2147483648..9223372036854775807   | int64       | 0x12
    number_unsigned | 0..2147483647                     | int32       | 0x10
    number_unsigned | 2147483648..9223372036854775807   | int64       | 0x12
    number_unsigned | 9223372036854775808..18446744073709551615| --   | --
    number_float    | *any value*                       | double      | 0x01
    string          | *any value*                       | string      | 0x02
    array           | *any value*                       | document    | 0x04
    object          | *any value*                       | document    | 0x03

    @warning The mapping is **incomplete**, since only JSON-objects (and things
    contained therein) can be serialized to BSON.
    Also, integers larger than 9223372036854775807 cannot be serialized to BSON,
    and the keys may not contain U+0000, since they are serialized a
    zero-terminated c-strings.

    @throw out_of_range.407  if `j.is_number_unsigned() && j.get<std::uint64_t>() > 9223372036854775807`
    @throw out_of_range.409  if a key in `j` contains a NULL (U+0000)
    @throw type_error.317    if `!j.is_object()`

    @pre The input `j` is required to be an object: `j.is_object() == true`.

    @note Any BSON output created via @ref to_bson can be successfully parsed
          by @ref from_bson.

    @param[in] j  JSON value to serialize
    @return BSON serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in BSON format.,to_bson}

    @sa http://bsonspec.org/spec.html
    @sa @ref from_bson(detail::input_adapter&&, const bool strict) for the
        analogous deserialization
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format
    @sa @ref to_cbor(const basic_json&) for the related CBOR format
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
    */
    static std::vector<uint8_t> to_bson(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_bson(j, result);
        return result;
    }

    /*!
    @brief Serializes the given JSON object `j` to BSON and forwards the
           corresponding BSON-representation to the given output_adapter `o`.
    @param j The JSON object to convert to BSON.
    @param o The output adapter that receives the binary BSON representation.
    @pre The input `j` shall be an object: `j.is_object() == true`
    @sa @ref to_bson(const basic_json&)
    */
    static void to_bson(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_bson(j);
    }

    /*!
    @copydoc to_bson(const basic_json&, detail::output_adapter<uint8_t>)
    */
    static void to_bson(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_bson(j);
    }


    /*!
    @brief create a JSON value from an input in CBOR format

    Deserializes a given input @a i to a JSON value using the CBOR (Concise
    Binary Object Representation) serialization format.

    The library maps CBOR types to JSON value types as follows:

    CBOR type              | JSON value type | first byte
    ---------------------- | --------------- | ----------
    Integer                | number_unsigned | 0x00..0x17
    Unsigned integer       | number_unsigned | 0x18
    Unsigned integer       | number_unsigned | 0x19
    Unsigned integer       | number_unsigned | 0x1A
    Unsigned integer       | number_unsigned | 0x1B
    Negative integer       | number_integer  | 0x20..0x37
    Negative integer       | number_integer  | 0x38
    Negative integer       | number_integer  | 0x39
    Negative integer       | number_integer  | 0x3A
    Negative integer       | number_integer  | 0x3B
    Negative integer       | number_integer  | 0x40..0x57
    UTF-8 string           | string          | 0x60..0x77
    UTF-8 string           | string          | 0x78
    UTF-8 string           | string          | 0x79
    UTF-8 string           | string          | 0x7A
    UTF-8 string           | string          | 0x7B
    UTF-8 string           | string          | 0x7F
    array                  | array           | 0x80..0x97
    array                  | array           | 0x98
    array                  | array           | 0x99
    array                  | array           | 0x9A
    array                  | array           | 0x9B
    array                  | array           | 0x9F
    map                    | object          | 0xA0..0xB7
    map                    | object          | 0xB8
    map                    | object          | 0xB9
    map                    | object          | 0xBA
    map                    | object          | 0xBB
    map                    | object          | 0xBF
    False                  | `false`         | 0xF4
    True                   | `true`          | 0xF5
    Null                   | `null`          | 0xF6
    Half-Precision Float   | number_float    | 0xF9
    Single-Precision Float | number_float    | 0xFA
    Double-Precision Float | number_float    | 0xFB

    @warning The mapping is **incomplete** in the sense that not all CBOR
             types can be converted to a JSON value. The following CBOR types
             are not supported and will yield parse errors (parse_error.112):
             - byte strings (0x40..0x5F)
             - date/time (0xC0..0xC1)
             - bignum (0xC2..0xC3)
             - decimal fraction (0xC4)
             - bigfloat (0xC5)
             - tagged items (0xC6..0xD4, 0xD8..0xDB)
             - expected conversions (0xD5..0xD7)
             - simple values (0xE0..0xF3, 0xF8)
             - undefined (0xF7)

    @warning CBOR allows map keys of any type, whereas JSON only allows
             strings as keys in object values. Therefore, CBOR maps with keys
             other than UTF-8 strings are rejected (parse_error.113).

    @note Any CBOR output created @ref to_cbor can be successfully parsed by
          @ref from_cbor.

    @param[in] i  an input in CBOR format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from CBOR were
    used in the given input @a v or if the input is not valid CBOR
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in CBOR
    format to a JSON value.,from_cbor}

    @sa http://cbor.io
    @sa @ref to_cbor(const basic_json&) for the analogous serialization
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for the
        related MessagePack format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        related UBJSON format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0; added @a allow_exceptions parameter
           since 3.2.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(detail::input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::cbor, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_cbor(detail::input_adapter&&, const bool, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(A1 && a1, A2 && a2,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::cbor, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @brief create a JSON value from an input in MessagePack format

    Deserializes a given input @a i to a JSON value using the MessagePack
    serialization format.

    The library maps MessagePack types to JSON value types as follows:

    MessagePack type | JSON value type | first byte
    ---------------- | --------------- | ----------
    positive fixint  | number_unsigned | 0x00..0x7F
    fixmap           | object          | 0x80..0x8F
    fixarray         | array           | 0x90..0x9F
    fixstr           | string          | 0xA0..0xBF
    nil              | `null`          | 0xC0
    false            | `false`         | 0xC2
    true             | `true`          | 0xC3
    float 32         | number_float    | 0xCA
    float 64         | number_float    | 0xCB
    uint 8           | number_unsigned | 0xCC
    uint 16          | number_unsigned | 0xCD
    uint 32          | number_unsigned | 0xCE
    uint 64          | number_unsigned | 0xCF
    int 8            | number_integer  | 0xD0
    int 16           | number_integer  | 0xD1
    int 32           | number_integer  | 0xD2
    int 64           | number_integer  | 0xD3
    str 8            | string          | 0xD9
    str 16           | string          | 0xDA
    str 32           | string          | 0xDB
    array 16         | array           | 0xDC
    array 32         | array           | 0xDD
    map 16           | object          | 0xDE
    map 32           | object          | 0xDF
    negative fixint  | number_integer  | 0xE0-0xFF

    @warning The mapping is **incomplete** in the sense that not all
             MessagePack types can be converted to a JSON value. The following
             MessagePack types are not supported and will yield parse errors:
              - bin 8 - bin 32 (0xC4..0xC6)
              - ext 8 - ext 32 (0xC7..0xC9)
              - fixext 1 - fixext 16 (0xD4..0xD8)

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @param[in] i  an input in MessagePack format convertible to an input
                  adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from MessagePack were
    used in the given input @a i or if the input is not valid MessagePack
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    MessagePack format to a JSON value.,from_msgpack}

    @sa http://msgpack.org
    @sa @ref to_msgpack(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool) for the
        related CBOR format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for
        the related UBJSON format
    @sa @ref from_bson(detail::input_adapter&&, const bool, const bool) for
        the related BSON format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0; added @a allow_exceptions parameter
           since 3.2.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(detail::input_adapter&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_msgpack(detail::input_adapter&&, const bool, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(A1 && a1, A2 && a2,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @brief create a JSON value from an input in UBJSON format

    Deserializes a given input @a i to a JSON value using the UBJSON (Universal
    Binary JSON) serialization format.

    The library maps UBJSON types to JSON value types as follows:

    UBJSON type | JSON value type                         | marker
    ----------- | --------------------------------------- | ------
    no-op       | *no value, next value is read*          | `N`
    null        | `null`                                  | `Z`
    false       | `false`                                 | `F`
    true        | `true`                                  | `T`
    float32     | number_float                            | `d`
    float64     | number_float                            | `D`
    uint8       | number_unsigned                         | `U`
    int8        | number_integer                          | `i`
    int16       | number_integer                          | `I`
    int32       | number_integer                          | `l`
    int64       | number_integer                          | `L`
    string      | string                                  | `S`
    char        | string                                  | `C`
    array       | array (optimized values are supported)  | `[`
    object      | object (optimized values are supported) | `{`

    @note The mapping is **complete** in the sense that any UBJSON value can
          be converted to a JSON value.

    @param[in] i  an input in UBJSON format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if a parse error occurs
    @throw parse_error.113 if a string could not be parsed successfully

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    UBJSON format to a JSON value.,from_ubjson}

    @sa http://ubjson.org
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool) for the
        related CBOR format
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for
        the related MessagePack format
    @sa @ref from_bson(detail::input_adapter&&, const bool, const bool) for
        the related BSON format

    @since version 3.1.0; added @a allow_exceptions parameter since 3.2.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(detail::input_adapter&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_ubjson(detail::input_adapter&&, const bool, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(A1 && a1, A2 && a2,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @brief Create a JSON value from an input in BSON format

    Deserializes a given input @a i to a JSON value using the BSON (Binary JSON)
    serialization format.

    The library maps BSON record types to JSON value types as follows:

    BSON type       | BSON marker byte | JSON value type
    --------------- | ---------------- | ---------------------------
    double          | 0x01             | number_float
    string          | 0x02             | string
    document        | 0x03             | object
    array           | 0x04             | array
    binary          | 0x05             | still unsupported
    undefined       | 0x06             | still unsupported
    ObjectId        | 0x07             | still unsupported
    boolean         | 0x08             | boolean
    UTC Date-Time   | 0x09             | still unsupported
    null            | 0x0A             | null
    Regular Expr.   | 0x0B             | still unsupported
    DB Pointer      | 0x0C             | still unsupported
    JavaScript Code | 0x0D             | still unsupported
    Symbol          | 0x0E             | still unsupported
    JavaScript Code | 0x0F             | still unsupported
    int32           | 0x10             | number_integer
    Timestamp       | 0x11             | still unsupported
    128-bit decimal float | 0x13       | still unsupported
    Max Key         | 0x7F             | still unsupported
    Min Key         | 0xFF             | still unsupported

    @warning The mapping is **incomplete**. The unsupported mappings
             are indicated in the table above.

    @param[in] i  an input in BSON format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.114 if an unsupported BSON record type is encountered

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    BSON format to a JSON value.,from_bson}

    @sa http://bsonspec.org/spec.html
    @sa @ref to_bson(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool) for the
        related CBOR format
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for
        the related MessagePack format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        related UBJSON format
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(detail::input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_bson(detail::input_adapter&&, const bool, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(A1 && a1, A2 && a2,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }



    /// @}

    //////////////////////////
    // JSON Pointer support //
    //////////////////////////

    /// @name JSON Pointer functions
    /// @{

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. Similar to @ref operator[](const typename
    object_t::key_type&), `null` values are created in arrays and objects if
    necessary.

    In particular:
    - If the JSON pointer points to an object key that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned.
    - If the JSON pointer points to an array index that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned. All indices between the current maximum and the given
      index are also filled with `null`.
    - The special value `-` is treated as a synonym for the index past the
      end.

    @param[in] ptr  a JSON pointer

    @return reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer}

    @since version 2.0.0
    */
    reference operator[](const json_pointer& ptr)
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. The function does not change the JSON
    value; no `null` values are created. In particular, the the special value
    `-` yields an exception.

    @param[in] ptr  JSON pointer to the desired element

    @return const reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer_const}

    @since version 2.0.0
    */
    const_reference operator[](const json_pointer& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a reference to the element at with specified JSON pointer @a ptr,
    with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.403 if the JSON pointer describes a key of an object
    which cannot be found. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer}
    */
    reference at(const json_pointer& ptr)
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a const reference to the element at with specified JSON pointer @a
    ptr, with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.403 if the JSON pointer describes a key of an object
    which cannot be found. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer_const}
    */
    const_reference at(const json_pointer& ptr) const
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief return flattened JSON value

    The function creates a JSON object whose keys are JSON pointers (see [RFC
    6901](https://tools.ietf.org/html/rfc6901)) and whose values are all
    primitive. The original JSON value can be restored using the @ref
    unflatten() function.

    @return an object that maps JSON pointers to primitive values

    @note Empty objects and arrays are flattened to `null` and will not be
          reconstructed correctly by the @ref unflatten() function.

    @complexity Linear in the size the JSON value.

    @liveexample{The following code shows how a JSON object is flattened to an
    object whose keys consist of JSON pointers.,flatten}

    @sa @ref unflatten() for the reverse function

    @since version 2.0.0
    */
    basic_json flatten() const
    {
        basic_json result(value_t::object);
        json_pointer::flatten("", *this, result);
        return result;
    }

    /*!
    @brief unflatten a previously flattened JSON value

    The function restores the arbitrary nesting of a JSON value that has been
    flattened before using the @ref flatten() function. The JSON value must
    meet certain constraints:
    1. The value must be an object.
    2. The keys must be JSON pointers (see
       [RFC 6901](https://tools.ietf.org/html/rfc6901))
    3. The mapped values must be primitive JSON types.

    @return the original JSON from a flattened version

    @note Empty objects and arrays are flattened by @ref flatten() to `null`
          values and can not unflattened to their original type. Apart from
          this example, for a JSON value `j`, the following is always true:
          `j == j.flatten().unflatten()`.

    @complexity Linear in the size the JSON value.

    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive

    @liveexample{The following code shows how a flattened JSON object is
    unflattened into the original nested JSON object.,unflatten}

    @sa @ref flatten() for the reverse function

    @since version 2.0.0
    */
    basic_json unflatten() const
    {
        return json_pointer::unflatten(*this);
    }

    /// @}

    //////////////////////////
    // JSON Patch functions //
    //////////////////////////

    /// @name JSON Patch functions
    /// @{

    /*!
    @brief applies a JSON patch

    [JSON Patch](http://jsonpatch.com) defines a JSON document structure for
    expressing a sequence of operations to apply to a JSON) document. With
    this function, a JSON Patch is applied to the current JSON value by
    executing all operations from the patch.

    @param[in] json_patch  JSON patch document
    @return patched document

    @note The application of a patch is atomic: Either all operations succeed
          and the patched document is returned or an exception is thrown. In
          any case, the original value is not changed: the patch is applied
          to a copy of the value.

    @throw parse_error.104 if the JSON patch does not consist of an array of
    objects

    @throw parse_error.105 if the JSON patch is malformed (e.g., mandatory
    attributes are missing); example: `"operation add must have member path"`

    @throw out_of_range.401 if an array index is out of range.

    @throw out_of_range.403 if a JSON pointer inside the patch could not be
    resolved successfully in the current JSON value; example: `"key baz not
    found"`

    @throw out_of_range.405 if JSON pointer has no parent ("add", "remove",
    "move")

    @throw other_error.501 if "test" operation was unsuccessful

    @complexity Linear in the size of the JSON value and the length of the
    JSON patch. As usually only a fraction of the JSON value is affected by
    the patch, the complexity can usually be neglected.

    @liveexample{The following code shows how a JSON patch is applied to a
    value.,patch}

    @sa @ref diff -- create a JSON patch by comparing two JSON values

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
    @sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)

    @since version 2.0.0
    */
    basic_json patch(const basic_json& json_patch) const
    {
        // make a working copy to apply the patch to
        basic_json result = *this;

        // the valid JSON Patch operations
        enum class patch_operations {add, remove, replace, move, copy, test, invalid};

        const auto get_op = [](const std::string & op)
        {
            if (op == "add")
            {
                return patch_operations::add;
            }
            if (op == "remove")
            {
                return patch_operations::remove;
            }
            if (op == "replace")
            {
                return patch_operations::replace;
            }
            if (op == "move")
            {
                return patch_operations::move;
            }
            if (op == "copy")
            {
                return patch_operations::copy;
            }
            if (op == "test")
            {
                return patch_operations::test;
            }

            return patch_operations::invalid;
        };

        // wrapper for "add" operation; add value at ptr
        const auto operation_add = [&result](json_pointer & ptr, basic_json val)
        {
            // adding to the root of the target document means replacing it
            if (ptr.empty())
            {
                result = val;
                return;
            }

            // make sure the top element of the pointer exists
            json_pointer top_pointer = ptr.top();
            if (top_pointer != ptr)
            {
                result.at(top_pointer);
            }

            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result[ptr];

            switch (parent.m_type)
            {
                case value_t::null:
                case value_t::object:
                {
                    // use operator[] to add value
                    parent[last_path] = val;
                    break;
                }

                case value_t::array:
                {
                    if (last_path == "-")
                    {
                        // special case: append to back
                        parent.push_back(val);
                    }
                    else
                    {
                        const auto idx = json_pointer::array_index(last_path);
                        if (JSON_HEDLEY_UNLIKELY(static_cast<size_type>(idx) > parent.size()))
                        {
                            // avoid undefined behavior
                            JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
                        }

                        // default case: insert add offset
                        parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
                    }
                    break;
                }

                // if there exists a parent it cannot be primitive
                default:            // LCOV_EXCL_LINE
                    assert(false);  // LCOV_EXCL_LINE
            }
        };

        // wrapper for "remove" operation; remove value at ptr
        const auto operation_remove = [&result](json_pointer & ptr)
        {
            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result.at(ptr);

            // remove child
            if (parent.is_object())
            {
                // perform range check
                auto it = parent.find(last_path);
                if (JSON_HEDLEY_LIKELY(it != parent.end()))
                {
                    parent.erase(it);
                }
                else
                {
                    JSON_THROW(out_of_range::create(403, "key '" + last_path + "' not found"));
                }
            }
            else if (parent.is_array())
            {
                // note erase performs range check
                parent.erase(static_cast<size_type>(json_pointer::array_index(last_path)));
            }
        };

        // type check: top level value must be an array
        if (JSON_HEDLEY_UNLIKELY(not json_patch.is_array()))
        {
            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
        }

        // iterate and apply the operations
        for (const auto& val : json_patch)
        {
            // wrapper to get a value for an operation
            const auto get_value = [&val](const std::string & op,
                                          const std::string & member,
                                          bool string_type) -> basic_json &
            {
                // find value
                auto it = val.m_value.object->find(member);

                // context-sensitive error message
                const auto error_msg = (op == "op") ? "operation" : "operation '" + op + "'";

                // check if desired value is present
                if (JSON_HEDLEY_UNLIKELY(it == val.m_value.object->end()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have member '" + member + "'"));
                }

                // check if result is of type string
                if (JSON_HEDLEY_UNLIKELY(string_type and not it->second.is_string()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have string member '" + member + "'"));
                }

                // no error: return value
                return it->second;
            };

            // type check: every element of the array must be an object
            if (JSON_HEDLEY_UNLIKELY(not val.is_object()))
            {
                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
            }

            // collect mandatory members
            const std::string op = get_value("op", "op", true);
            const std::string path = get_value(op, "path", true);
            json_pointer ptr(path);

            switch (get_op(op))
            {
                case patch_operations::add:
                {
                    operation_add(ptr, get_value("add", "value", false));
                    break;
                }

                case patch_operations::remove:
                {
                    operation_remove(ptr);
                    break;
                }

                case patch_operations::replace:
                {
                    // the "path" location must exist - use at()
                    result.at(ptr) = get_value("replace", "value", false);
                    break;
                }

                case patch_operations::move:
                {
                    const std::string from_path = get_value("move", "from", true);
                    json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The move operation is functionally identical to a
                    // "remove" operation on the "from" location, followed
                    // immediately by an "add" operation at the target
                    // location with the value that was just removed.
                    operation_remove(from_ptr);
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::copy:
                {
                    const std::string from_path = get_value("copy", "from", true);
                    const json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The copy is functionally identical to an "add"
                    // operation at the target location using the value
                    // specified in the "from" member.
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::test:
                {
                    bool success = false;
                    JSON_TRY
                    {
                        // check if "value" matches the one at "path"
                        // the "path" location must exist - use at()
                        success = (result.at(ptr) == get_value("test", "value", false));
                    }
                    JSON_INTERNAL_CATCH (out_of_range&)
                    {
                        // ignore out of range errors: success remains false
                    }

                    // throw an exception if test fails
                    if (JSON_HEDLEY_UNLIKELY(not success))
                    {
                        JSON_THROW(other_error::create(501, "unsuccessful: " + val.dump()));
                    }

                    break;
                }

                default:
                {
                    // op must be "add", "remove", "replace", "move", "copy", or
                    // "test"
                    JSON_THROW(parse_error::create(105, 0, "operation value '" + op + "' is invalid"));
                }
            }
        }

        return result;
    }

    /*!
    @brief creates a diff as a JSON patch

    Creates a [JSON Patch](http://jsonpatch.com) so that value @a source can
    be changed into the value @a target by calling @ref patch function.

    @invariant For two JSON values @a source and @a target, the following code
    yields always `true`:
    @code {.cpp}
    source.patch(diff(source, target)) == target;
    @endcode

    @note Currently, only `remove`, `add`, and `replace` operations are
          generated.

    @param[in] source  JSON value to compare from
    @param[in] target  JSON value to compare against
    @param[in] path    helper value to create JSON pointers

    @return a JSON patch to convert the @a source to @a target

    @complexity Linear in the lengths of @a source and @a target.

    @liveexample{The following code shows how a JSON patch is created as a
    diff for two JSON values.,diff}

    @sa @ref patch -- apply a JSON patch
    @sa @ref merge_patch -- apply a JSON Merge Patch

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)

    @since version 2.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json diff(const basic_json& source, const basic_json& target,
                           const std::string& path = "")
    {
        // the patch
        basic_json result(value_t::array);

        // if the values are the same, return empty patch
        if (source == target)
        {
            return result;
        }

        if (source.type() != target.type())
        {
            // different types: replace value
            result.push_back(
            {
                {"op", "replace"}, {"path", path}, {"value", target}
            });
            return result;
        }

        switch (source.type())
        {
            case value_t::array:
            {
                // first pass: traverse common elements
                std::size_t i = 0;
                while (i < source.size() and i < target.size())
                {
                    // recursive call to compare array values at index i
                    auto temp_diff = diff(source[i], target[i], path + "/" + std::to_string(i));
                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    ++i;
                }

                // i now reached the end of at least one array
                // in a second pass, traverse the remaining elements

                // remove my remaining elements
                const auto end_index = static_cast<difference_type>(result.size());
                while (i < source.size())
                {
                    // add operations in reverse order to avoid invalid
                    // indices
                    result.insert(result.begin() + end_index, object(
                    {
                        {"op", "remove"},
                        {"path", path + "/" + std::to_string(i)}
                    }));
                    ++i;
                }

                // add other remaining elements
                while (i < target.size())
                {
                    result.push_back(
                    {
                        {"op", "add"},
                        {"path", path + "/" + std::to_string(i)},
                        {"value", target[i]}
                    });
                    ++i;
                }

                break;
            }

            case value_t::object:
            {
                // first pass: traverse this object's elements
                for (auto it = source.cbegin(); it != source.cend(); ++it)
                {
                    // escape the key name to be used in a JSON patch
                    const auto key = json_pointer::escape(it.key());

                    if (target.find(it.key()) != target.end())
                    {
                        // recursive call to compare object values at key it
                        auto temp_diff = diff(it.value(), target[it.key()], path + "/" + key);
                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    }
                    else
                    {
                        // found a key that is not in o -> remove it
                        result.push_back(object(
                        {
                            {"op", "remove"}, {"path", path + "/" + key}
                        }));
                    }
                }

                // second pass: traverse other object's elements
                for (auto it = target.cbegin(); it != target.cend(); ++it)
                {
                    if (source.find(it.key()) == source.end())
                    {
                        // found a key that is not in this -> add it
                        const auto key = json_pointer::escape(it.key());
                        result.push_back(
                        {
                            {"op", "add"}, {"path", path + "/" + key},
                            {"value", it.value()}
                        });
                    }
                }

                break;
            }

            default:
            {
                // both primitive type: replace value
                result.push_back(
                {
                    {"op", "replace"}, {"path", path}, {"value", target}
                });
                break;
            }
        }

        return result;
    }

    /// @}

    ////////////////////////////////
    // JSON Merge Patch functions //
    ////////////////////////////////

    /// @name JSON Merge Patch functions
    /// @{

    /*!
    @brief applies a JSON Merge Patch

    The merge patch format is primarily intended for use with the HTTP PATCH
    method as a means of describing a set of modifications to a target
    resource's content. This function applies a merge patch to the current
    JSON value.

    The function implements the following algorithm from Section 2 of
    [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396):

    ```
    define MergePatch(Target, Patch):
      if Patch is an Object:
        if Target is not an Object:
          Target = {} // Ignore the contents and set it to an empty Object
        for each Name/Value pair in Patch:
          if Value is null:
            if Name exists in Target:
              remove the Name/Value pair from Target
          else:
            Target[Name] = MergePatch(Target[Name], Value)
        return Target
      else:
        return Patch
    ```

    Thereby, `Target` is the current object; that is, the patch is applied to
    the current value.

    @param[in] apply_patch  the patch to apply

    @complexity Linear in the lengths of @a patch.

    @liveexample{The following code shows how a JSON Merge Patch is applied to
    a JSON document.,merge_patch}

    @sa @ref patch -- apply a JSON patch
    @sa [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396)

    @since version 3.0.0
    */
    void merge_patch(const basic_json& apply_patch)
    {
        if (apply_patch.is_object())
        {
            if (not is_object())
            {
                *this = object();
            }
            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
            {
                if (it.value().is_null())
                {
                    erase(it.key());
                }
                else
                {
                    operator[](it.key()).merge_patch(it.value());
                }
            }
        }
        else
        {
            *this = apply_patch;
        }
    }

    /// @}
};

/*!
@brief user-defined to_string function for JSON values

This function implements a user-defined to_string  for JSON objects.

@param[in] j  a JSON object
@return a std::string object
*/

NLOHMANN_BASIC_JSON_TPL_DECLARATION
std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
{
    return j.dump();
}
} // namespace nlohmann

///////////////////////
// nonmember support //
///////////////////////

// specialization of std::swap, and std::hash
namespace std
{

/// hash value for JSON objects
template<>
struct hash<nlohmann::json>
{
    /*!
    @brief return a hash value for a JSON object

    @since version 1.0.0
    */
    std::size_t operator()(const nlohmann::json& j) const
    {
        // a naive hashing via the string representation
        const auto& h = hash<nlohmann::json::string_t>();
        return h(j.dump());
    }
};

/// specialization for std::less<value_t>
/// @note: do not remove the space after '<',
///        see https://github.com/nlohmann/json/pull/679
template<>
struct less< ::nlohmann::detail::value_t>
{
    /*!
    @brief compare two value_t enum values
    @since version 3.0.0
    */
    bool operator()(nlohmann::detail::value_t lhs,
                    nlohmann::detail::value_t rhs) const noexcept
    {
        return nlohmann::detail::operator<(lhs, rhs);
    }
};

/*!
@brief exchanges the values of two JSON objects

@since version 1.0.0
*/
template<>
inline void swap<nlohmann::json>(nlohmann::json& j1, nlohmann::json& j2) noexcept(
    is_nothrow_move_constructible<nlohmann::json>::value and
    is_nothrow_move_assignable<nlohmann::json>::value
)
{
    j1.swap(j2);
}

} // namespace std

/*!
@brief user-defined string literal for JSON values

This operator implements a user-defined string literal for JSON objects. It
can be used by adding `"_json"` to a string literal and returns a JSON object
if no parse error occurred.

@param[in] s  a string representation of a JSON object
@param[in] n  the length of string @a s
@return a JSON object

@since version 1.0.0
*/
JSON_HEDLEY_NON_NULL(1)
inline nlohmann::json operator "" _json(const char* s, std::size_t n)
{
    return nlohmann::json::parse(s, s + n);
}

/*!
@brief user-defined string literal for JSON pointer

This operator implements a user-defined string literal for JSON Pointers. It
can be used by adding `"_json_pointer"` to a string literal and returns a JSON pointer
object if no parse error occurred.

@param[in] s  a string representation of a JSON Pointer
@param[in] n  the length of string @a s
@return a JSON pointer object

@since version 2.0.0
*/
JSON_HEDLEY_NON_NULL(1)
inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
{
    return nlohmann::json::json_pointer(std::string(s, n));
}

// #include <nlohmann/detail/macro_unscope.hpp>


// restore GCC/clang diagnostic settings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic pop
#endif
#if defined(__clang__)
    #pragma GCC diagnostic pop
#endif

// clean up
#undef JSON_INTERNAL_CATCH
#undef JSON_CATCH
#undef JSON_THROW
#undef JSON_TRY
#undef JSON_HAS_CPP_14
#undef JSON_HAS_CPP_17
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL

// #include <nlohmann/thirdparty/hedley/hedley_undef.hpp>
#undef JSON_HEDLEY_ALWAYS_INLINE
#undef JSON_HEDLEY_ARM_VERSION
#undef JSON_HEDLEY_ARM_VERSION_CHECK
#undef JSON_HEDLEY_ARRAY_PARAM
#undef JSON_HEDLEY_ASSUME
#undef JSON_HEDLEY_BEGIN_C_DECLS
#undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#undef JSON_HEDLEY_CLANG_HAS_FEATURE
#undef JSON_HEDLEY_CLANG_HAS_WARNING
#undef JSON_HEDLEY_COMPCERT_VERSION
#undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#undef JSON_HEDLEY_CONCAT
#undef JSON_HEDLEY_CONCAT_EX
#undef JSON_HEDLEY_CONST
#undef JSON_HEDLEY_CONSTEXPR
#undef JSON_HEDLEY_CONST_CAST
#undef JSON_HEDLEY_CPP_CAST
#undef JSON_HEDLEY_CRAY_VERSION
#undef JSON_HEDLEY_CRAY_VERSION_CHECK
#undef JSON_HEDLEY_C_DECL
#undef JSON_HEDLEY_DEPRECATED
#undef JSON_HEDLEY_DEPRECATED_FOR
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#undef JSON_HEDLEY_DIAGNOSTIC_POP
#undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#undef JSON_HEDLEY_DMC_VERSION
#undef JSON_HEDLEY_DMC_VERSION_CHECK
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#undef JSON_HEDLEY_END_C_DECLS
#undef JSON_HEDLEY_FALL_THROUGH
#undef JSON_HEDLEY_FLAGS
#undef JSON_HEDLEY_FLAGS_CAST
#undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_BUILTIN
#undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_EXTENSION
#undef JSON_HEDLEY_GCC_HAS_FEATURE
#undef JSON_HEDLEY_GCC_HAS_WARNING
#undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#undef JSON_HEDLEY_GCC_VERSION
#undef JSON_HEDLEY_GCC_VERSION_CHECK
#undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#undef JSON_HEDLEY_GNUC_HAS_FEATURE
#undef JSON_HEDLEY_GNUC_HAS_WARNING
#undef JSON_HEDLEY_GNUC_VERSION
#undef JSON_HEDLEY_GNUC_VERSION_CHECK
#undef JSON_HEDLEY_HAS_ATTRIBUTE
#undef JSON_HEDLEY_HAS_BUILTIN
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_HAS_EXTENSION
#undef JSON_HEDLEY_HAS_FEATURE
#undef JSON_HEDLEY_HAS_WARNING
#undef JSON_HEDLEY_IAR_VERSION
#undef JSON_HEDLEY_IAR_VERSION_CHECK
#undef JSON_HEDLEY_IBM_VERSION
#undef JSON_HEDLEY_IBM_VERSION_CHECK
#undef JSON_HEDLEY_IMPORT
#undef JSON_HEDLEY_INLINE
#undef JSON_HEDLEY_INTEL_VERSION
#undef JSON_HEDLEY_INTEL_VERSION_CHECK
#undef JSON_HEDLEY_IS_CONSTANT
#undef JSON_HEDLEY_LIKELY
#undef JSON_HEDLEY_MALLOC
#undef JSON_HEDLEY_MESSAGE
#undef JSON_HEDLEY_MSVC_VERSION
#undef JSON_HEDLEY_MSVC_VERSION_CHECK
#undef JSON_HEDLEY_NEVER_INLINE
#undef JSON_HEDLEY_NON_NULL
#undef JSON_HEDLEY_NO_RETURN
#undef JSON_HEDLEY_NO_THROW
#undef JSON_HEDLEY_PELLES_VERSION
#undef JSON_HEDLEY_PELLES_VERSION_CHECK
#undef JSON_HEDLEY_PGI_VERSION
#undef JSON_HEDLEY_PGI_VERSION_CHECK
#undef JSON_HEDLEY_PREDICT
#undef JSON_HEDLEY_PRINTF_FORMAT
#undef JSON_HEDLEY_PRIVATE
#undef JSON_HEDLEY_PUBLIC
#undef JSON_HEDLEY_PURE
#undef JSON_HEDLEY_REINTERPRET_CAST
#undef JSON_HEDLEY_REQUIRE
#undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#undef JSON_HEDLEY_REQUIRE_MSG
#undef JSON_HEDLEY_RESTRICT
#undef JSON_HEDLEY_RETURNS_NON_NULL
#undef JSON_HEDLEY_SENTINEL
#undef JSON_HEDLEY_STATIC_ASSERT
#undef JSON_HEDLEY_STATIC_CAST
#undef JSON_HEDLEY_STRINGIFY
#undef JSON_HEDLEY_STRINGIFY_EX
#undef JSON_HEDLEY_SUNPRO_VERSION
#undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#undef JSON_HEDLEY_TINYC_VERSION
#undef JSON_HEDLEY_TINYC_VERSION_CHECK
#undef JSON_HEDLEY_TI_VERSION
#undef JSON_HEDLEY_TI_VERSION_CHECK
#undef JSON_HEDLEY_UNAVAILABLE
#undef JSON_HEDLEY_UNLIKELY
#undef JSON_HEDLEY_UNPREDICTABLE
#undef JSON_HEDLEY_UNREACHABLE
#undef JSON_HEDLEY_UNREACHABLE_RETURN
#undef JSON_HEDLEY_VERSION
#undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#undef JSON_HEDLEY_VERSION_DECODE_MINOR
#undef JSON_HEDLEY_VERSION_DECODE_REVISION
#undef JSON_HEDLEY_VERSION_ENCODE
#undef JSON_HEDLEY_WARNING
#undef JSON_HEDLEY_WARN_UNUSED_RESULT



#endif  // INCLUDE_NLOHMANN_JSON_HPP_

```

`Broker/main.cc`:

```cc
/*++

Module Name:
   main.c

   
Abstract:

This is the main file for the broker.

The broker is a privileged process (must have at least SeDebug and SeLoadDriver) and is responsible 
for communicating with the IrpDumper driver by:
- create the service and load the driver
- instructing the driver to add/remove hooks to specific driver(s)
- fetching IRP data from the hooked drivers
- upon cleanup the resources, unload the driver and delete the service.


--*/


#include "main.h"


Session* Sess;

static HANDLE g_hTerminationEvent;

/*++

Routine Description:

Attempts to acquire a privilege by its name.


Arguments:

	lpszPrivilegeName - the name (as a wide string) of the privilege


Return Value:

	Returns TRUE if the privilege was successfully acquired

--*/
static BOOL AssignPrivilegeToSelf(_In_ const wchar_t* lpszPrivilegeName)
{
	HANDLE hToken = INVALID_HANDLE_VALUE;
	BOOL bRes = FALSE;
	

	bRes = ::OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);
	if (bRes)
	{
		LUID Luid = { 0, };

		bRes = ::LookupPrivilegeValue(NULL, lpszPrivilegeName, &Luid);
		if (bRes)
		{
			size_t nBufferSize = sizeof(TOKEN_PRIVILEGES) + 1*sizeof(LUID_AND_ATTRIBUTES);
			PTOKEN_PRIVILEGES NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, nBufferSize);
			if (NewState)
			{
				NewState->PrivilegeCount = 1;
				NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
				NewState->Privileges[0].Luid = Luid;

				bRes = ::AdjustTokenPrivileges(
					hToken,
					FALSE,
					NewState,
					0,
					(PTOKEN_PRIVILEGES)NULL,
					(PDWORD)NULL
				) != 0;

				if (bRes)
					bRes = GetLastError() != ERROR_NOT_ALL_ASSIGNED;

				LocalFree(NewState);
			}
		}

		CloseHandle(hToken);
	}

	return bRes;
}


/*++

Routine Description:

Simple helper function to check a privilege by name on the current process.


Arguments:

	lpszPrivilegeName - the name (as a wide string) of the privilege

	lpHasPriv - a pointer to a boolean indicating whether the current process own that 
	privilege


Return Value:

	Returns TRUE if the current has the privilege 

--*/
static BOOL HasPrivilege(_In_ const wchar_t* lpszPrivilegeName, _Out_ PBOOL lpHasPriv)
{
	LUID Luid = { 0, };
	BOOL bRes = FALSE, bHasPriv = FALSE;
	HANDLE hToken = INVALID_HANDLE_VALUE;

	do
	{
		xlog(LOG_DEBUG, L"Checking for '%s'...\n", lpszPrivilegeName);

		bRes = LookupPrivilegeValue(NULL, lpszPrivilegeName, &Luid);
		if (!bRes)
		{
			PrintErrorWithFunctionName(L"LookupPrivilegeValue");
			break;
		}

		LUID_AND_ATTRIBUTES PrivAttr = { 0 };
		PrivAttr.Luid = Luid;
		PrivAttr.Attributes = SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;

		PRIVILEGE_SET PrivSet = { 0, };
		PrivSet.PrivilegeCount = 1;
		PrivSet.Privilege[0] = PrivAttr;

		bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);
		if (!bRes)
		{
			PrintError(L"OpenProcessToken");
			break;
		}

		bRes = PrivilegeCheck(hToken, &PrivSet, &bHasPriv);
		if (!bRes)
		{
			PrintError(L"PrivilegeCheck");
			break;
		}

		*lpHasPriv = bHasPriv;
		bRes = TRUE;
	} 
	while (0);

	if (hToken != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hToken);
	}

	return bRes;
}



/*++

Routine Description:

Ctrl-C handler: when receiving either CTRL_C_EVENT or CTRL_CLOSE_EVENT, set the termination event.


Arguments:

	fdwCtrlType - the event type received by the window


Return Value:

	Returns TRUE if the event was handled. FALSE otherwise.

--*/
static BOOL CtrlHandler(DWORD fdwCtrlType)
{
	switch (fdwCtrlType)
	{
	case CTRL_CLOSE_EVENT:
	case CTRL_C_EVENT:
		xlog(LOG_INFO, L"Received Ctrl-C event, stopping...\n");
		Sess->Stop();
		return TRUE;

	default:
		return FALSE;
	}
}


/*++

Routine Description:

Run forever loop, can be run from either the standalone mode or own process service.


Arguments:

	lpParameter - unused parameter if running in standalone, holds a handle to the stop event if running as a service.


Return Value:

	Return 0 on success, or the last error code.

--*/
DWORD RunForever(_In_ LPVOID lpParameter)
{

	DWORD retcode = ERROR_SUCCESS;
	HANDLE ThreadHandles[4] = { INVALID_HANDLE_VALUE };
	DWORD dwNumberOfHandles = 3 + ((lpParameter != NULL) ? 1 : 0);
	DWORD dwWaitResult = 0;

	//
	// Initialize the broker <-> driver thread
	//

	if (!StartBackendManagerThread(Sess))
	{
		xlog(LOG_CRITICAL, L"StartBackendManagerThread() failed\n");
		return retcode;
	}


	//
	// Initialize the gui <-> broker thread
	//

	if (!FrontendThreadRoutine(Sess))
	{
		xlog(LOG_CRITICAL, L"FrontendThreadRoutine() failed\n");
		return retcode;
	}


	xlog(
		LOG_SUCCESS, 
		L"ThreadIds[]=[Frontend=%d,Backend=%d,IrpFetcher=%d]\n", 
		::GetThreadId(Sess->m_hFrontendThread), 
		::GetThreadId(Sess->m_hBackendThread), 
		::GetThreadId(Sess->m_hIrpFetcherThread)
	);


	//
	// Start everything
	//
	Sess->Start();
	ResumeThread(Sess->m_hFrontendThread);
	ResumeThread(Sess->m_hIrpFetcherThread);
	ResumeThread(Sess->m_hBackendThread);


	//
	// Wait for the threads to finish
	//
	ThreadHandles[0] = Sess->m_hFrontendThread;
	ThreadHandles[1] = Sess->m_hIrpFetcherThread;
	ThreadHandles[2] = Sess->m_hBackendThread;

	if (lpParameter)
	{
		ThreadHandles[3] = *((PHANDLE)lpParameter);
	}

	dwWaitResult = ::WaitForMultipleObjects(dwNumberOfHandles, ThreadHandles, TRUE, INFINITE);

	switch (dwWaitResult)
	{
	case WAIT_OBJECT_0:
		xlog(LOG_SUCCESS, L"All threads ended, cleaning up...\n");
		retcode = ERROR_SUCCESS;
		break;

	default:
		PrintErrorWithFunctionName(L"WaitForMultipleObjects");
		retcode = ::GetLastError();
		break;
	}

	return retcode;
}


/*++

Routine Description:

The entrypoint for the broker.


Arguments:

	argc - 

	argv - 


Return Value:

	Returns EXIT_SUCCESS on success, EXIT_FAILURE

--*/
int wmain(int argc, wchar_t** argv)
{
	int retcode = EXIT_SUCCESS;
	HANDLE hDriver = INVALID_HANDLE_VALUE;
	HANDLE hGui = INVALID_HANDLE_VALUE;
	
	
	BOOL bHasDebugPriv = FALSE;
	BOOL bHasLoadDriverPriv = FALSE;
	
	Sess = nullptr;


	HANDLE hStdErr = GetStdHandle(STD_ERROR_HANDLE);
	DWORD dwConsoleMode;

	::GetConsoleMode(hStdErr, &dwConsoleMode);
	dwConsoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
	::SetConsoleMode(hStdErr, dwConsoleMode);


	xlog(LOG_INFO, L"Starting %s (part of %s (v%.02f) - by <%s>)\n", argv[0], CFB_PROGRAM_NAME_SHORT, CFB_VERSION, CFB_AUTHOR);

#ifdef _DEBUG
	xlog(LOG_DEBUG, L"DEBUG mode on\n");
#endif


	//
	// Check the privileges first, if we don't have them there is no point going further
	//
	const wchar_t* lpszPrivilegeNames[2] = { L"SeDebugPrivilege", L"SeLoadDriverPrivilege" };

	for (int i = 0; i < _countof(lpszPrivilegeNames); i++)
	{
		BOOL fHasPriv = FALSE;
		if (!AssignPrivilegeToSelf(lpszPrivilegeNames[i]))
		{
			xlog(LOG_CRITICAL, L"%s requires '%s', cannot proceed...\n", argv[0], lpszPrivilegeNames[i]);
			return EXIT_FAILURE;
		}
	}

	dbg(L"Privilege check succeeded...\n");


	//
	// The session is ready to be initialized
	//

	dbg(L"Initializing the session...\n");
	
	try
	{
		Sess = new Session();
	}
	catch (std::runtime_error& e)
	{
		xlog(LOG_CRITICAL, L"Failed to initialize the session, reason: %S\n", e.what());
		return EXIT_FAILURE;
	}

	do
	{

		//
		// Should we run as a background service
		//
		if (argc > 1 && !wcscmp(argv[1], L"--service"))
		{
			Sess->ServiceManager.bRunInBackground = TRUE;
			if (!Sess->ServiceManager.RegisterService())
			{
				xlog(LOG_CRITICAL, L"Failed to register service...\n");
				retcode = EXIT_FAILURE;
				break;
			}
		}


		if (Sess->ServiceManager.bRunInBackground == FALSE)
		{
			if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlHandler, TRUE))
			{
				xlog(LOG_CRITICAL, L"Could not setup SetConsoleCtrlHandler()...\n");
				retcode = EXIT_FAILURE;
				break;
			}

			if (RunForever(NULL) != ERROR_SUCCESS)
			{
				xlog(LOG_ERROR, L"RunForever() returned with error\n");
				break;
			}

			dbg(L"RunForever() finished successfully\n");
		}
	} 
	while (0);


	//
	// Deleting the session will automatically destroy the FrontEnd/BackEnd server, along with 
	// the service manager.
	//
	try
	{
		if (Sess != nullptr)
		{
			delete Sess;
		}
	}
	catch (std::runtime_error & e)
	{
		xlog(LOG_CRITICAL, L"An error occured while deleting the session: %S\n", e.what());
		retcode = EXIT_FAILURE;
	}


#ifdef _DEBUG
	if(retcode != EXIT_SUCCESS)
		xlog(LOG_CRITICAL, L"%s exited with error(s)\n", argv[0]);
#endif // _DEBUG


	return retcode;
}
```

`Broker/main.h`:

```h
#pragma once

#include "common.h"
#include "Session.h"
#include "FrontEndServer.h"
#include "driver.h"

#pragma comment(lib, "advapi32.lib") // for privilege check and driver/service (un-)loading

#include <iostream>


DWORD RunForever(LPVOID lpParameter);


```

`Broker/nt.h`:

```h
#pragma once

/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2019, translated from Microsoft sources/debugger
*
*  TITLE:       NTOS.H
*
*  VERSION:     1.121
*
*  DATE:        18 Oct 2019
*
*  Common header file for the ntos API functions and definitions.
*
*  Only projects required API/definitions.
*
*  Depends on:    Windows.h
*                 NtStatus.h
*
*  Include:       Windows.h
*                 NtStatus.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#include <Windows.h>

//
// NTOS_RTL HEADER BEGIN
//

#if defined(__cplusplus)
extern "C" {
#endif

#pragma comment(lib, "ntdll.lib")

#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000ull
#endif

#ifndef ABSOLUTE_TIME
#define ABSOLUTE_TIME(wait) (wait)
#endif

#ifndef RELATIVE_TIME
#define RELATIVE_TIME(wait) (-(wait))
#endif

#ifndef NANOSECONDS
#define NANOSECONDS(nanos) (((signed __int64)(nanos)) / 100L)
#endif

#ifndef MICROSECONDS
#define MICROSECONDS(micros) (((signed __int64)(micros)) * NANOSECONDS(1000L))
#endif

#ifndef MILLISECONDS
#define MILLISECONDS(milli) (((signed __int64)(milli)) * MICROSECONDS(1000L))
#endif

#ifndef SECONDS
#define SECONDS(seconds) (((signed __int64)(seconds)) * MILLISECONDS(1000L))
#endif

#ifndef POI //poi-poi
#define POI(addr) *(ULONG *)(addr)
#endif

	typedef char CCHAR;
	typedef unsigned char UCHAR;
	typedef CCHAR KPROCESSOR_MODE;
	typedef UCHAR KIRQL;
	typedef KIRQL* PKIRQL;
	typedef ULONG CLONG;
	typedef LONG KPRIORITY;
	typedef short CSHORT;
	typedef ULONGLONG REGHANDLE, * PREGHANDLE;
	typedef PVOID* PDEVICE_MAP;
	typedef PVOID PHEAD;

#ifndef _WIN32_WINNT_WIN10
#define _WIN32_WINNT_WIN10 0x0A00
#endif
#if (_WIN32_WINNT < _WIN32_WINNT_WIN10)
	typedef PVOID PMEM_EXTENDED_PARAMETER;
#endif

#ifndef IN_REGION
#define IN_REGION(x, Base, Size) (((ULONG_PTR)(x) >= (ULONG_PTR)(Base)) && \
            ((ULONG_PTR)(x) <= (ULONG_PTR)(Base) + (ULONG_PTR)(Size)))
#endif

	//
	// Define alignment macros to align structure sizes and pointers up and down.
	//

#ifndef ALIGN_UP_TYPE
#define ALIGN_UP_TYPE(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(Address, Type) ALIGN_UP_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_DOWN_TYPE
#define ALIGN_DOWN_TYPE(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(Address, Type) ALIGN_DOWN_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_UP_BY
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_DOWN_BY
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_UP_POINTER_BY
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#endif

#ifndef ALIGN_DOWN_POINTER_BY
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#endif

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )
#endif

#ifndef LOGICAL
#define LOGICAL ULONG
#endif

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()

//Valid Only for Windows 8+
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) 
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5)
#define NtCurrentEffectiveToken() ((HANDLE)(LONG_PTR)-6)

//
// ntdef.h begin
//
#ifndef RTL_CONSTANT_STRING
	char _RTL_CONSTANT_STRING_type_check(const void* s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}
#endif

#ifndef RTL_CONSTANT_OBJECT_ATTRIBUTES
#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) \
    { sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL }
#endif

	// This synonym is more appropriate for initializing what isn't actually const.
#ifndef RTL_INIT_OBJECT_ATTRIBUTES
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)
#endif

//
// ntdef.h end
//
#ifndef RtlOffsetToPointer
#define RtlOffsetToPointer(Base, Offset)  ((PCHAR)( ((PCHAR)(Base)) + ((ULONG_PTR)(Offset))  ))
#endif

#ifndef RtlPointerToOffset
#define RtlPointerToOffset(Base, Pointer)  ((ULONG)( ((PCHAR)(Pointer)) - ((PCHAR)(Base))  ))
#endif

//
// Valid values for the OBJECT_ATTRIBUTES.Attributes field
//
#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

//
// Callback Object Rights
//
#define CALLBACK_MODIFY_STATE    0x0001
#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|CALLBACK_MODIFY_STATE )

//
// CompositionSurface Access Rights
//
#ifndef COMPOSITIONSURFACE_READ
#define COMPOSITIONSURFACE_READ         0x0001L
#endif

#ifndef COMPOSITIONSURFACE_WRITE
#define COMPOSITIONSURFACE_WRITE        0x0002L
#endif

#ifndef COMPOSITIONSURFACE_ALL_ACCESS
#define COMPOSITIONSURFACE_ALL_ACCESS   (COMPOSITIONSURFACE_READ | COMPOSITIONSURFACE_WRITE)
#endif

//
// Debug Object Access Rights
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
                              DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

//
// Directory Object Access Rights
//
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Event Object Access Rights
//
#define EVENT_QUERY_STATE       0x0001
#define EVENT_MODIFY_STATE      0x0002  
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// EventPair Object Access Rights
//
#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)

//
// I/O Completion Object Access Rights
//
#define IO_COMPLETION_QUERY_STATE   0x0001
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// KeyedEvent Object Access Rights
//
#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

//
// Mutant Object Access Rights
//
#define MUTANT_QUERY_STATE      0x0001
#ifndef MUTANT_ALL_ACCESS //SDK compatibility
#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|MUTANT_QUERY_STATE)
#endif

//
// Port Object Access Rights
//
#define PORT_CONNECT (0x0001)
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | PORT_CONNECT)

//
// Profile Object Access Rights
//
#define PROFILE_CONTROL (0x0001)
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

//
// Semaphore Object Access Rights
//
#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002 
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

//
// SymbolicLink Object Access Rights
//
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYMBOLIC_LINK_QUERY)

//
// Thread Object Access Rights
//
#define THREAD_ALERT   (0x0004)

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED        0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH      0x00000002 
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER      0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010 
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET  0x00000020 
#define THREAD_CREATE_FLAGS_INITIAL_THREAD          0x00000080

//
// Worker Factory Object Access Rights
//
#define WORKER_FACTORY_RELEASE_WORKER       0x0001
#define WORKER_FACTORY_WAIT                 0x0002
#define WORKER_FACTORY_SET_INFORMATION      0x0004
#define WORKER_FACTORY_QUERY_INFORMATION    0x0008
#define WORKER_FACTORY_READY_WORKER         0x0010
#define WORKER_FACTORY_SHUTDOWN             0x0020

#define WORKER_FACTORY_ALL_ACCESS ( \
    STANDARD_RIGHTS_REQUIRED | \
    WORKER_FACTORY_RELEASE_WORKER | \
    WORKER_FACTORY_WAIT | \
    WORKER_FACTORY_SET_INFORMATION | \
    WORKER_FACTORY_QUERY_INFORMATION | \
    WORKER_FACTORY_READY_WORKER | \
    WORKER_FACTORY_SHUTDOWN \
    )

//
// Type Object Access Rights
//
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | OBJECT_TYPE_CREATE)

//
// WMI Object Access Rights
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_CREATE_INPROC        0x0200
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800
#define TRACELOG_JOIN_GROUP           0x1000

//
// Memory Partition Object Access Rights
//
#define MEMORY_PARTITION_QUERY_ACCESS  0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002

#define MEMORY_PARTITION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |         \
                                     SYNCHRONIZE |                      \
                                     MEMORY_PARTITION_QUERY_ACCESS |    \
                                     MEMORY_PARTITION_MODIFY_ACCESS)

//
// NtCreateProcessEx specific flags.
//
#define PS_REQUEST_BREAKAWAY        1
#define PS_NO_DEBUG_INHERIT         2
#define PS_INHERIT_HANDLES          4
#define PS_LARGE_PAGES              8
#define PS_ALL_FLAGS                (PS_REQUEST_BREAKAWAY | \
                                     PS_NO_DEBUG_INHERIT  | \
                                     PS_INHERIT_HANDLES   | \
                                     PS_LARGE_PAGES)

//
// Define special ByteOffset parameters for read and write operations
//
#ifndef FILE_WRITE_TO_END_OF_FILE
#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#endif
#ifndef FILE_USE_FILE_POINTER_POSITION
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe
#endif

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#ifndef MAXUSHORT
#define MAXUSHORT   0xffff     
#endif
#ifndef MAX_USTRING
#define MAX_USTRING ( sizeof(WCHAR) * (MAXUSHORT/sizeof(WCHAR)) )
#endif

	typedef struct _EX_RUNDOWN_REF {
		union
		{
			ULONG Count;
			PVOID Ptr;
		};
	} EX_RUNDOWN_REF, * PEX_RUNDOWN_REF;

#ifdef _WIN64
#define MAX_FAST_REFS 15
#else
#define MAX_FAST_REFS 7
#endif

	typedef struct _EX_FAST_REF {
		union {
			PVOID Object;
#if defined (_WIN64)
			ULONG_PTR RefCnt : 4;
#else
			ULONG_PTR RefCnt : 3;
#endif
			ULONG_PTR Value;
		};
	} EX_FAST_REF, * PEX_FAST_REF;

	typedef struct _UNICODE_STRING {
		USHORT Length;
		USHORT MaximumLength;
		PWSTR  Buffer;
	} UNICODE_STRING, * PUNICODE_STRING;
	typedef const UNICODE_STRING* PCUNICODE_STRING;

#ifndef STATIC_UNICODE_STRING
#define STATIC_UNICODE_STRING(string, value) \
  static UNICODE_STRING string = { sizeof(value) - sizeof(WCHAR), sizeof(value), value };
#endif

	typedef struct _STRING {
		USHORT Length;
		USHORT MaximumLength;
		PCHAR Buffer;
	} STRING;
	typedef STRING* PSTRING;

	typedef STRING ANSI_STRING;
	typedef PSTRING PANSI_STRING;

	typedef STRING OEM_STRING;
	typedef PSTRING POEM_STRING;
	typedef CONST STRING* PCOEM_STRING;
	typedef CONST char* PCSZ;

	typedef struct _CSTRING {
		USHORT Length;
		USHORT MaximumLength;
		CONST char* Buffer;
	} CSTRING;
	typedef CSTRING* PCSTRING;
#define ANSI_NULL ((CHAR)0)

	typedef STRING CANSI_STRING;
	typedef PSTRING PCANSI_STRING;

	typedef struct _OBJECT_ATTRIBUTES {
		ULONG Length;
		HANDLE RootDirectory;
		PUNICODE_STRING ObjectName;
		ULONG Attributes;
		PVOID SecurityDescriptor;
		PVOID SecurityQualityOfService;
	} OBJECT_ATTRIBUTES;
	typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;

	typedef struct _IO_STATUS_BLOCK {
		union {
			NTSTATUS Status;
			PVOID Pointer;
		} DUMMYUNIONNAME;

		ULONG_PTR Information;
	} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

	/*
	** FileCache and MemoryList START
	*/

	typedef enum _SYSTEM_MEMORY_LIST_COMMAND {
		MemoryCaptureAccessedBits,
		MemoryCaptureAndResetAccessedBits,
		MemoryEmptyWorkingSets,
		MemoryFlushModifiedList,
		MemoryPurgeStandbyList,
		MemoryPurgeLowPriorityStandbyList,
		MemoryCommandMax
	} SYSTEM_MEMORY_LIST_COMMAND;

	typedef struct _SYSTEM_FILECACHE_INFORMATION {
		SIZE_T CurrentSize;
		SIZE_T PeakSize;
		ULONG PageFaultCount;
		SIZE_T MinimumWorkingSet;
		SIZE_T MaximumWorkingSet;
		SIZE_T CurrentSizeIncludingTransitionInPages;
		SIZE_T PeakSizeIncludingTransitionInPages;
		ULONG TransitionRePurposeCount;
		ULONG Flags;
	} SYSTEM_FILECACHE_INFORMATION, * PSYSTEM_FILECACHE_INFORMATION;

	/*
	** FileCache and MemoryList END
	*/

	/*
	** Processes START
	*/

	typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
		LARGE_INTEGER BootTime;
		LARGE_INTEGER CurrentTime;
		LARGE_INTEGER TimeZoneBias;
		ULONG TimeZoneId;
		ULONG Reserved;
		ULONGLONG BootTimeBias;
		ULONGLONG SleepTimeBias;
	} SYSTEM_TIMEOFDAY_INFORMATION, * PSYSTEM_TIMEOFDAY_INFORMATION;

	typedef enum _THREAD_STATE {
		StateInitialized,
		StateReady,
		StateRunning,
		StateStandby,
		StateTerminated,
		StateWait,
		StateTransition,
		StateUnknown
	} THREAD_STATE;

	typedef enum _KWAIT_REASON {
		Executive,
		FreePage,
		PageIn,
		PoolAllocation,
		DelayExecution,
		Suspended,
		UserRequest,
		WrExecutive,
		WrFreePage,
		WrPageIn,
		WrPoolAllocation,
		WrDelayExecution,
		WrSuspended,
		WrUserRequest,
		WrEventPair, //has no effect after 7
		WrQueue,
		WrLpcReceive,
		WrLpcReply,
		WrVirtualMemory,
		WrPageOut,
		WrRendezvous,
		WrKeyedEvent,
		WrTerminated,
		WrProcessInSwap,
		WrCpuRateControl,
		WrCalloutStack,
		WrKernel,
		WrResource,
		WrPushLock,
		WrMutex,
		WrQuantumEnd,
		WrDispatchInt,
		WrPreempted,
		WrYieldExecution,
		WrFastMutex,
		WrGuardedMutex,
		WrRundown,
		WrAlertByThreadId,
		WrDeferredPreempt,
		WrPhysicalFault,
		MaximumWaitReason
	} KWAIT_REASON;

	typedef VOID KSTART_ROUTINE(
		_In_ PVOID StartContext
	);
	typedef KSTART_ROUTINE* PKSTART_ROUTINE;

	typedef struct _CLIENT_ID {
		HANDLE UniqueProcess;
		HANDLE UniqueThread;
	} CLIENT_ID, * PCLIENT_ID;

	typedef struct _CLIENT_ID64 {
		ULONG64 UniqueProcess;
		ULONG64 UniqueThread;
	} CLIENT_ID64, * PCLIENT_ID64;

	typedef struct _CLIENT_ID32 {
		ULONG32 UniqueProcess;
		ULONG32 UniqueThread;
	} CLIENT_ID32, * PCLIENT_ID32;

	typedef struct _VM_COUNTERS {
		SIZE_T PeakVirtualSize;
		SIZE_T VirtualSize;
		ULONG PageFaultCount;
		SIZE_T PeakWorkingSetSize;
		SIZE_T WorkingSetSize;
		SIZE_T QuotaPeakPagedPoolUsage;
		SIZE_T QuotaPagedPoolUsage;
		SIZE_T QuotaPeakNonPagedPoolUsage;
		SIZE_T QuotaNonPagedPoolUsage;
		SIZE_T PagefileUsage;
		SIZE_T PeakPagefileUsage;
		SIZE_T PrivatePageCount;
	} VM_COUNTERS;

	typedef struct _SYSTEM_THREAD_INFORMATION {
		LARGE_INTEGER KernelTime;
		LARGE_INTEGER UserTime;
		LARGE_INTEGER CreateTime;
		ULONG WaitTime;
		PVOID StartAddress;
		CLIENT_ID ClientId;
		KPRIORITY Priority;
		KPRIORITY BasePriority;
		ULONG ContextSwitchCount;
		THREAD_STATE State;
		KWAIT_REASON WaitReason;
	} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

	typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
		SYSTEM_THREAD_INFORMATION ThreadInfo;
		PVOID StackBase;
		PVOID StackLimit;
		PVOID Win32StartAddress;
		PVOID TebBase;
		ULONG_PTR Reserved2;
		ULONG_PTR Reserved3;
		ULONG_PTR Reserved4;
	} SYSTEM_EXTENDED_THREAD_INFORMATION, * PSYSTEM_EXTENDED_THREAD_INFORMATION;

	typedef struct _SYSTEM_PROCESSES_INFORMATION {
		ULONG NextEntryDelta;
		ULONG ThreadCount;
		LARGE_INTEGER SpareLi1;
		LARGE_INTEGER SpareLi2;
		LARGE_INTEGER SpareLi3;
		LARGE_INTEGER CreateTime;
		LARGE_INTEGER UserTime;
		LARGE_INTEGER KernelTime;
		UNICODE_STRING ImageName;
		KPRIORITY BasePriority;
		HANDLE UniqueProcessId;
		HANDLE InheritedFromUniqueProcessId;
		ULONG HandleCount;
		ULONG SessionId;
		ULONG_PTR PageDirectoryBase;
		VM_COUNTERS VmCounters;
		IO_COUNTERS IoCounters;
		SYSTEM_THREAD_INFORMATION Threads[1];
	} SYSTEM_PROCESSES_INFORMATION, * PSYSTEM_PROCESSES_INFORMATION;

	typedef enum _SYSTEM_PROCESS_CLASSIFICATION {
		SystemProcessClassificationNormal,
		SystemProcessClassificationSystem,
		SystemProcessClassificationSecureSystem,
		SystemProcessClassificationMemCompression,
		SystemProcessClassificationRegistry,
		SystemProcessClassificationMaximum
	} SYSTEM_PROCESS_CLASSIFICATION;

	typedef struct _PROCESS_DISK_COUNTERS {
		ULONGLONG BytesRead;
		ULONGLONG BytesWritten;
		ULONGLONG ReadOperationCount;
		ULONGLONG WriteOperationCount;
		ULONGLONG FlushOperationCount;
	} PROCESS_DISK_COUNTERS, * PPROCESS_DISK_COUNTERS;

	typedef union _ENERGY_STATE_DURATION {
		union
		{
			ULONGLONG Value;
			ULONG LastChangeTime;
		};

		ULONG Duration : 31;
		ULONG IsInState : 1;
	} ENERGY_STATE_DURATION, * PENERGY_STATE_DURATION;

	typedef struct _PROCESS_ENERGY_VALUES {
		ULONGLONG Cycles[2][4];
		ULONGLONG DiskEnergy;
		ULONGLONG NetworkTailEnergy;
		ULONGLONG MBBTailEnergy;
		ULONGLONG NetworkTxRxBytes;
		ULONGLONG MBBTxRxBytes;
		union
		{
			ENERGY_STATE_DURATION Durations[3];
			struct
			{
				ENERGY_STATE_DURATION ForegroundDuration;
				ENERGY_STATE_DURATION DesktopVisibleDuration;
				ENERGY_STATE_DURATION PSMForegroundDuration;
			};
		};
		ULONG CompositionRendered;
		ULONG CompositionDirtyGenerated;
		ULONG CompositionDirtyPropagated;
		ULONG Reserved1;
		ULONGLONG AttributedCycles[4][2];
		ULONGLONG WorkOnBehalfCycles[4][2];
	} PROCESS_ENERGY_VALUES, * PPROCESS_ENERGY_VALUES;

	typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION {
		PROCESS_DISK_COUNTERS DiskCounters;
		ULONGLONG ContextSwitches;
		union
		{
			ULONG Flags;
			struct
			{
				ULONG HasStrongId : 1;
				ULONG Classification : 4; // SYSTEM_PROCESS_CLASSIFICATION
				ULONG BackgroundActivityModerated : 1;
				ULONG Spare : 26;
			};
		};
		ULONG UserSidOffset;
		ULONG PackageFullNameOffset;
		PROCESS_ENERGY_VALUES EnergyValues;
		ULONG AppIdOffset;
		SIZE_T SharedCommitCharge;
		ULONG JobObjectId;
		ULONG SpareUlong;
		ULONGLONG ProcessSequenceNumber;
	} SYSTEM_PROCESS_INFORMATION_EXTENSION, * PSYSTEM_PROCESS_INFORMATION_EXTENSION;

	typedef struct _SYSTEM_PROCESSES_FULL_INFORMATION {
		SYSTEM_PROCESSES_INFORMATION ProcessAndThreads;
		SYSTEM_PROCESS_INFORMATION_EXTENSION ExtendedInfo;
	} SYSTEM_PROCESSES_FULL_INFORMATION, * PSYSTEM_PROCESSES_FULL_INFORMATION;

	typedef struct _SYSTEM_PROCESS_ID_INFORMATION {
		HANDLE ProcessId;
		UNICODE_STRING ImageName;
	} SYSTEM_PROCESS_ID_INFORMATION, * PSYSTEM_PROCESS_ID_INFORMATION;

	typedef struct _SYSTEM_SECUREBOOT_INFORMATION {
		BOOLEAN SecureBootEnabled;
		BOOLEAN SecureBootCapable;
	} SYSTEM_SECUREBOOT_INFORMATION, * PSYSTEM_SECUREBOOT_INFORMATION;

	typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION {
		GUID PolicyPublisher;
		ULONG PolicyVersion;
		ULONG PolicyOptions;
	} SYSTEM_SECUREBOOT_POLICY_INFORMATION, * PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

	typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
		SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
		ULONG PolicySize;
		UCHAR Policy[1];
	} SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, * PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

	typedef struct _SYSTEM_BASIC_INFORMATION {
		ULONG Reserved;
		ULONG TimerResolution;
		ULONG PageSize;
		ULONG NumberOfPhysicalPages;
		ULONG LowestPhysicalPageNumber;
		ULONG HighestPhysicalPageNumber;
		ULONG AllocationGranularity;
		ULONG_PTR MinimumUserModeAddress;
		ULONG_PTR MaximumUserModeAddress;
		ULONG_PTR ActiveProcessorsAffinityMask;
		CCHAR NumberOfProcessors;
	} SYSTEM_BASIC_INFORMATION, * PSYSTEM_BASIC_INFORMATION;

	typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
		BOOLEAN SecureKernelRunning : 1;
		BOOLEAN HvciEnabled : 1;
		BOOLEAN HvciStrictMode : 1;
		BOOLEAN DebugEnabled : 1;
		BOOLEAN FirmwarePageProtection : 1;
		BOOLEAN EncryptionKeyAvailable : 1;
		BOOLEAN SpareFlags : 2;
		BOOLEAN TrustletRunning : 1;
		BOOLEAN HvciDisableAllowed : 1;
		BOOLEAN SpareFlags2 : 6;
		BOOLEAN Spare0[6];
		ULONGLONG Spare1;
	} SYSTEM_ISOLATED_USER_MODE_INFORMATION, * PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

	typedef enum _PROCESSINFOCLASS {
		ProcessBasicInformation = 0,
		ProcessQuotaLimits = 1,
		ProcessIoCounters = 2,
		ProcessVmCounters = 3,
		ProcessTimes = 4,
		ProcessBasePriority = 5,
		ProcessRaisePriority = 6,
		ProcessDebugPort = 7,
		ProcessExceptionPort = 8,
		ProcessAccessToken = 9,
		ProcessLdtInformation = 10,
		ProcessLdtSize = 11,
		ProcessDefaultHardErrorMode = 12,
		ProcessIoPortHandlers = 13,
		ProcessPooledUsageAndLimits = 14,
		ProcessWorkingSetWatch = 15,
		ProcessUserModeIOPL = 16,
		ProcessEnableAlignmentFaultFixup = 17,
		ProcessPriorityClass = 18,
		ProcessWx86Information = 19,
		ProcessHandleCount = 20,
		ProcessAffinityMask = 21,
		ProcessPriorityBoost = 22,
		ProcessDeviceMap = 23,
		ProcessSessionInformation = 24,
		ProcessForegroundInformation = 25,
		ProcessWow64Information = 26,
		ProcessImageFileName = 27,
		ProcessLUIDDeviceMapsEnabled = 28,
		ProcessBreakOnTermination = 29,
		ProcessDebugObjectHandle = 30,
		ProcessDebugFlags = 31,
		ProcessHandleTracing = 32,
		ProcessIoPriority = 33,
		ProcessExecuteFlags = 34,
		ProcessTlsInformation = 35,
		ProcessCookie = 36,
		ProcessImageInformation = 37,
		ProcessCycleTime = 38,
		ProcessPagePriority = 39,
		ProcessInstrumentationCallback = 40,
		ProcessThreadStackAllocation = 41,
		ProcessWorkingSetWatchEx = 42,
		ProcessImageFileNameWin32 = 43,
		ProcessImageFileMapping = 44,
		ProcessAffinityUpdateMode = 45,
		ProcessMemoryAllocationMode = 46,
		ProcessGroupInformation = 47,
		ProcessTokenVirtualizationEnabled = 48,
		ProcessOwnerInformation = 49,
		ProcessWindowInformation = 50,
		ProcessHandleInformation = 51,
		ProcessMitigationPolicy = 52,
		ProcessDynamicFunctionTableInformation = 53,
		ProcessHandleCheckingMode = 54,
		ProcessKeepAliveCount = 55,
		ProcessRevokeFileHandles = 56,
		ProcessWorkingSetControl = 57,
		ProcessHandleTable = 58,
		ProcessCheckStackExtentsMode = 59,
		ProcessCommandLineInformation = 60,
		ProcessProtectionInformation = 61,
		ProcessMemoryExhaustion = 62,
		ProcessFaultInformation = 63,
		ProcessTelemetryIdInformation = 64,
		ProcessCommitReleaseInformation = 65,
		ProcessDefaultCpuSetsInformation = 66,
		ProcessAllowedCpuSetsInformation = 67,
		ProcessSubsystemProcess = 68,
		ProcessJobMemoryInformation = 69,
		ProcessInPrivate = 70,
		ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
		ProcessIumChallengeResponse = 72,
		ProcessChildProcessInformation = 73,
		ProcessHighGraphicsPriorityInformation = 74,
		ProcessSubsystemInformation = 75,
		ProcessEnergyValues = 76,
		ProcessActivityThrottleState = 77,
		ProcessActivityThrottlePolicy = 78,
		ProcessWin32kSyscallFilterInformation = 79,
		ProcessDisableSystemAllowedCpuSets = 80,
		ProcessWakeInformation = 81,
		ProcessEnergyTrackingState = 82,
		ProcessManageWritesToExecutableMemory = 83,
		ProcessCaptureTrustletLiveDump = 84,
		ProcessTelemetryCoverage = 85,
		ProcessEnclaveInformation = 86,
		ProcessEnableReadWriteVmLogging = 87,
		ProcessUptimeInformation = 88,
		ProcessImageSection = 89,
		ProcessDebugAuthInformation = 90,
		ProcessSystemResourceManagement = 91,
		ProcessSequenceNumber = 92,
		ProcessLoaderDetour = 93,
		ProcessSecurityDomainInformation = 94,
		ProcessCombineSecurityDomainsInformation = 95,
		ProcessEnableLogging = 96,
		ProcessLeapSecondInformation = 97,
		ProcessFiberShadowStackAllocation = 98,
		ProcessFreeFiberShadowStackAllocation = 99,
		MaxProcessInfoClass
	} PROCESSINFOCLASS;

	typedef enum _THREADINFOCLASS {
		ThreadBasicInformation,
		ThreadTimes,
		ThreadPriority,
		ThreadBasePriority,
		ThreadAffinityMask,
		ThreadImpersonationToken,
		ThreadDescriptorTableEntry,
		ThreadEnableAlignmentFaultFixup,
		ThreadEventPair,
		ThreadQuerySetWin32StartAddress,
		ThreadZeroTlsCell,
		ThreadPerformanceCount,
		ThreadAmILastThread,
		ThreadIdealProcessor,
		ThreadPriorityBoost,
		ThreadSetTlsArrayAddress,
		ThreadIsIoPending,
		ThreadHideFromDebugger,
		ThreadBreakOnTermination,
		ThreadSwitchLegacyState,
		ThreadIsTerminated,
		ThreadLastSystemCall,
		ThreadIoPriority,
		ThreadCycleTime,
		ThreadPagePriority,
		ThreadActualBasePriority,
		ThreadTebInformation,
		ThreadCSwitchMon,
		ThreadCSwitchPmu,
		ThreadWow64Context,
		ThreadGroupInformation,
		ThreadUmsInformation,
		ThreadCounterProfiling,
		ThreadIdealProcessorEx,
		ThreadCpuAccountingInformation,
		ThreadSuspendCount,
		ThreadHeterogeneousCpuPolicy,
		ThreadContainerId,
		ThreadNameInformation,
		ThreadSelectedCpuSets,
		ThreadSystemThreadInformation,
		ThreadActualGroupAffinity,
		ThreadDynamicCodePolicyInfo,
		ThreadExplicitCaseSensitivity,
		ThreadWorkOnBehalfTicket,
		ThreadSubsystemInformation,
		ThreadDbgkWerReportActive,
		ThreadAttachContainer,
		ThreadManageWritesToExecutableMemory,
		ThreadPowerThrottlingState,
		ThreadWorkloadClass,
		MaxThreadInfoClass
	} THREADINFOCLASS;

	typedef struct _PROCESS_BASIC_INFORMATION {
		NTSTATUS ExitStatus;
		PVOID PebBaseAddress;
		ULONG_PTR AffinityMask;
		KPRIORITY BasePriority;
		ULONG_PTR UniqueProcessId;
		ULONG_PTR InheritedFromUniqueProcessId;
	} PROCESS_BASIC_INFORMATION, * PPROCESS_BASIC_INFORMATION;

	typedef struct _THREAD_BASIC_INFORMATION {
		NTSTATUS ExitStatus;
		PVOID TebBaseAddress;
		CLIENT_ID ClientId;
		ULONG_PTR AffinityMask;
		KPRIORITY Priority;
		LONG BasePriority;
	} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;

	typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION {
		SIZE_T Size;
		PROCESS_BASIC_INFORMATION BasicInfo;
		union
		{
			ULONG Flags;
			struct
			{
				ULONG IsProtectedProcess : 1;
				ULONG IsWow64Process : 1;
				ULONG IsProcessDeleting : 1;
				ULONG IsCrossSessionCreate : 1;
				ULONG IsFrozen : 1;
				ULONG IsBackground : 1;
				ULONG IsStronglyNamed : 1;
				ULONG IsSecureProcess : 1;
				ULONG IsSubsystemProcess : 1;
				ULONG SpareBits : 23;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_EXTENDED_BASIC_INFORMATION, * PPROCESS_EXTENDED_BASIC_INFORMATION;

	typedef struct _PROCESS_ACCESS_TOKEN {
		HANDLE Token;
		HANDLE Thread;
	} PROCESS_ACCESS_TOKEN, * PPROCESS_ACCESS_TOKEN;

	typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO {
		HANDLE HandleValue;
		ULONG_PTR HandleCount;
		ULONG_PTR PointerCount;
		ULONG GrantedAccess;
		ULONG ObjectTypeIndex;
		ULONG HandleAttributes;
		ULONG Reserved;
	} PROCESS_HANDLE_TABLE_ENTRY_INFO, * PPROCESS_HANDLE_TABLE_ENTRY_INFO;

	typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
		ULONG NumberOfHandles;
		ULONG Reserved;
		PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
	} PROCESS_HANDLE_SNAPSHOT_INFORMATION, * PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

	//
	// Process/Thread System and User Time
	//  NtQueryInformationProcess using ProcessTimes
	//  NtQueryInformationThread using ThreadTimes
	//
	typedef struct _KERNEL_USER_TIMES {
		LARGE_INTEGER CreateTime;
		LARGE_INTEGER ExitTime;
		LARGE_INTEGER KernelTime;
		LARGE_INTEGER UserTime;
	} KERNEL_USER_TIMES, * PKERNEL_USER_TIMES;

	typedef enum _PS_MITIGATION_OPTION {
		PS_MITIGATION_OPTION_NX,
		PS_MITIGATION_OPTION_SEHOP,
		PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
		PS_MITIGATION_OPTION_HEAP_TERMINATE,
		PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
		PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
		PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
		PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
		PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
		PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
		PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
		PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
		PS_MITIGATION_OPTION_FONT_DISABLE,
		PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
		PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
		PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
		PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
		PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
		PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
		PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
		PS_MITIGATION_OPTION_ROP_STACKPIVOT,
		PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
		PS_MITIGATION_OPTION_ROP_SIMEXEC,
		PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
		PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
		PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
		PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
		PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
		PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
		PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE,
		PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
		PS_MITIGATION_OPTION_CET_SHADOW_STACKS
	} PS_MITIGATION_OPTION;

	typedef enum _PS_CREATE_STATE {
		PsCreateInitialState,
		PsCreateFailOnFileOpen,
		PsCreateFailOnSectionCreate,
		PsCreateFailExeFormat,
		PsCreateFailMachineMismatch,
		PsCreateFailExeName,
		PsCreateSuccess,
		PsCreateMaximumStates
	} PS_CREATE_STATE;

	typedef struct _PS_CREATE_INFO {
		SIZE_T Size;
		PS_CREATE_STATE State;
		union
		{
			struct
			{
				union
				{
					ULONG InitFlags;
					struct
					{
						UCHAR WriteOutputOnExit : 1;
						UCHAR DetectManifest : 1;
						UCHAR IFEOSkipDebugger : 1;
						UCHAR IFEODoNotPropagateKeyState : 1;
						UCHAR SpareBits1 : 4;
						UCHAR SpareBits2 : 8;
						USHORT ProhibitedImageCharacteristics : 16;
					};
				};
				ACCESS_MASK AdditionalFileAccess;
			} InitState;

			struct
			{
				HANDLE FileHandle;
			} FailSection;

			struct
			{
				USHORT DllCharacteristics;
			} ExeFormat;

			struct
			{
				HANDLE IFEOKey;
			} ExeName;

			struct
			{
				union
				{
					ULONG OutputFlags;
					struct
					{
						UCHAR ProtectedProcess : 1;
						UCHAR AddressSpaceOverride : 1;
						UCHAR DevOverrideEnabled : 1;
						UCHAR ManifestDetected : 1;
						UCHAR ProtectedProcessLight : 1;
						UCHAR SpareBits1 : 3;
						UCHAR SpareBits2 : 8;
						USHORT SpareBits3 : 16;
					};
				};
				HANDLE FileHandle;
				HANDLE SectionHandle;
				ULONGLONG UserProcessParametersNative;
				ULONG UserProcessParametersWow64;
				ULONG CurrentParameterFlags;
				ULONGLONG PebAddressNative;
				ULONG PebAddressWow64;
				ULONGLONG ManifestAddress;
				ULONG ManifestSize;
			} SuccessState;
		};
	} PS_CREATE_INFO, * PPS_CREATE_INFO;

	typedef struct _PS_ATTRIBUTE {
		ULONG Attribute;
		SIZE_T Size;
		union
		{
			ULONG Value;
			PVOID ValuePtr;
		};
		PSIZE_T ReturnLength;
	} PS_ATTRIBUTE, * PPS_ATTRIBUTE;

	typedef struct _PS_ATTRIBUTE_LIST {
		SIZE_T TotalLength;
		PS_ATTRIBUTE Attributes[1];
	} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;

	typedef enum _PS_PROTECTED_TYPE {
		PsProtectedTypeNone,
		PsProtectedTypeProtectedLight,
		PsProtectedTypeProtected,
		PsProtectedTypeMax
	} PS_PROTECTED_TYPE;

	typedef enum _PS_PROTECTED_SIGNER {
		PsProtectedSignerNone,
		PsProtectedSignerAuthenticode,
		PsProtectedSignerCodeGen,
		PsProtectedSignerAntimalware,
		PsProtectedSignerLsa,
		PsProtectedSignerWindows,
		PsProtectedSignerWinTcb,
		PsProtectedSignerWinSystem,
		PsProtectedSignerApp,
		PsProtectedSignerMax
	} PS_PROTECTED_SIGNER;

	typedef struct _PS_PROTECTION {
		union
		{
			UCHAR Level;
			struct
			{
				UCHAR Type : 3;
				UCHAR Audit : 1;
				UCHAR Signer : 4;
			};
		};
	} PS_PROTECTION, * PPS_PROTECTION;

	// begin_rev
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 
#define PS_ATTRIBUTE_INPUT 0x00020000 
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 
// end_rev

	typedef enum _PS_ATTRIBUTE_NUM {
		PsAttributeParentProcess,
		PsAttributeDebugPort,
		PsAttributeToken,
		PsAttributeClientId,
		PsAttributeTebAddress,
		PsAttributeImageName,
		PsAttributeImageInfo,
		PsAttributeMemoryReserve,
		PsAttributePriorityClass,
		PsAttributeErrorMode,
		PsAttributeStdHandleInfo,
		PsAttributeHandleList,
		PsAttributeGroupAffinity,
		PsAttributePreferredNode,
		PsAttributeIdealProcessor,
		PsAttributeUmsThread,
		PsAttributeMitigationOptions,
		PsAttributeProtectionLevel,
		PsAttributeSecureProcess,
		PsAttributeJobList,
		PsAttributeChildProcessPolicy,
		PsAttributeAllApplicationPackagesPolicy,
		PsAttributeWin32kFilter,
		PsAttributeSafeOpenPromptOriginClaim,
		PsAttributeBnoIsolation,
		PsAttributeDesktopAppPolicy,
		PsAttributeChpe,
		PsAttributeMax
	} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Unknown) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Unknown) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_PORT \
    PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER \
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION \
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)

#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RTL_USER_PROC_PROFILE_USER          0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL        0x00000004
#define RTL_USER_PROC_PROFILE_SERVER        0x00000008
#define RTL_USER_PROC_RESERVE_1MB           0x00000020
#define RTL_USER_PROC_RESERVE_16MB          0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE        0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT  0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING     0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS         0x00020000

	/*
	** Processes END
	*/

	typedef enum _SYSTEM_INFORMATION_CLASS {
		SystemBasicInformation = 0,
		SystemProcessorInformation = 1,
		SystemPerformanceInformation = 2,
		SystemTimeOfDayInformation = 3,
		SystemPathInformation = 4,
		SystemProcessInformation = 5,
		SystemCallCountInformation = 6,
		SystemDeviceInformation = 7,
		SystemProcessorPerformanceInformation = 8,
		SystemFlagsInformation = 9,
		SystemCallTimeInformation = 10,
		SystemModuleInformation = 11,
		SystemLocksInformation = 12,
		SystemStackTraceInformation = 13,
		SystemPagedPoolInformation = 14,
		SystemNonPagedPoolInformation = 15,
		SystemHandleInformation = 16,
		SystemObjectInformation = 17,
		SystemPageFileInformation = 18,
		SystemVdmInstemulInformation = 19,
		SystemVdmBopInformation = 20,
		SystemFileCacheInformation = 21,
		SystemPoolTagInformation = 22,
		SystemInterruptInformation = 23,
		SystemDpcBehaviorInformation = 24,
		SystemFullMemoryInformation = 25,
		SystemLoadGdiDriverInformation = 26,
		SystemUnloadGdiDriverInformation = 27,
		SystemTimeAdjustmentInformation = 28,
		SystemSummaryMemoryInformation = 29,
		SystemMirrorMemoryInformation = 30,
		SystemPerformanceTraceInformation = 31,
		SystemObsolete0 = 32,
		SystemExceptionInformation = 33,
		SystemCrashDumpStateInformation = 34,
		SystemKernelDebuggerInformation = 35,
		SystemContextSwitchInformation = 36,
		SystemRegistryQuotaInformation = 37,
		SystemExtendServiceTableInformation = 38,
		SystemPrioritySeperation = 39,
		SystemVerifierAddDriverInformation = 40,
		SystemVerifierRemoveDriverInformation = 41,
		SystemProcessorIdleInformation = 42,
		SystemLegacyDriverInformation = 43,
		SystemCurrentTimeZoneInformation = 44,
		SystemLookasideInformation = 45,
		SystemTimeSlipNotification = 46,
		SystemSessionCreate = 47,
		SystemSessionDetach = 48,
		SystemSessionInformation = 49,
		SystemRangeStartInformation = 50,
		SystemVerifierInformation = 51,
		SystemVerifierThunkExtend = 52,
		SystemSessionProcessInformation = 53,
		SystemLoadGdiDriverInSystemSpace = 54,
		SystemNumaProcessorMap = 55,
		SystemPrefetcherInformation = 56,
		SystemExtendedProcessInformation = 57,
		SystemRecommendedSharedDataAlignment = 58,
		SystemComPlusPackage = 59,
		SystemNumaAvailableMemory = 60,
		SystemProcessorPowerInformation = 61,
		SystemEmulationBasicInformation = 62,
		SystemEmulationProcessorInformation = 63,
		SystemExtendedHandleInformation = 64,
		SystemLostDelayedWriteInformation = 65,
		SystemBigPoolInformation = 66,
		SystemSessionPoolTagInformation = 67,
		SystemSessionMappedViewInformation = 68,
		SystemHotpatchInformation = 69,
		SystemObjectSecurityMode = 70,
		SystemWatchdogTimerHandler = 71,
		SystemWatchdogTimerInformation = 72,
		SystemLogicalProcessorInformation = 73,
		SystemWow64SharedInformationObsolete = 74,
		SystemRegisterFirmwareTableInformationHandler = 75,
		SystemFirmwareTableInformation = 76,
		SystemModuleInformationEx = 77,
		SystemVerifierTriageInformation = 78,
		SystemSuperfetchInformation = 79,
		SystemMemoryListInformation = 80,
		SystemFileCacheInformationEx = 81,
		SystemThreadPriorityClientIdInformation = 82,
		SystemProcessorIdleCycleTimeInformation = 83,
		SystemVerifierCancellationInformation = 84,
		SystemProcessorPowerInformationEx = 85,
		SystemRefTraceInformation = 86,
		SystemSpecialPoolInformation = 87,
		SystemProcessIdInformation = 88,
		SystemErrorPortInformation = 89,
		SystemBootEnvironmentInformation = 90,
		SystemHypervisorInformation = 91,
		SystemVerifierInformationEx = 92,
		SystemTimeZoneInformation = 93,
		SystemImageFileExecutionOptionsInformation = 94,
		SystemCoverageInformation = 95,
		SystemPrefetchPatchInformation = 96,
		SystemVerifierFaultsInformation = 97,
		SystemSystemPartitionInformation = 98,
		SystemSystemDiskInformation = 99,
		SystemProcessorPerformanceDistribution = 100,
		SystemNumaProximityNodeInformation = 101,
		SystemDynamicTimeZoneInformation = 102,
		SystemCodeIntegrityInformation = 103,
		SystemProcessorMicrocodeUpdateInformation = 104,
		SystemProcessorBrandString = 105,
		SystemVirtualAddressInformation = 106,
		SystemLogicalProcessorAndGroupInformation = 107,
		SystemProcessorCycleTimeInformation = 108,
		SystemStoreInformation = 109,
		SystemRegistryAppendString = 110,
		SystemAitSamplingValue = 111,
		SystemVhdBootInformation = 112,
		SystemCpuQuotaInformation = 113,
		SystemNativeBasicInformation = 114,
		SystemErrorPortTimeouts = 115,
		SystemLowPriorityIoInformation = 116,
		SystemBootEntropyInformation = 117,
		SystemVerifierCountersInformation = 118,
		SystemPagedPoolInformationEx = 119,
		SystemSystemPtesInformationEx = 120,
		SystemNodeDistanceInformation = 121,
		SystemAcpiAuditInformation = 122,
		SystemBasicPerformanceInformation = 123,
		SystemQueryPerformanceCounterInformation = 124,
		SystemSessionBigPoolInformation = 125,
		SystemBootGraphicsInformation = 126,
		SystemScrubPhysicalMemoryInformation = 127,
		SystemBadPageInformation = 128,
		SystemProcessorProfileControlArea = 129,
		SystemCombinePhysicalMemoryInformation = 130,
		SystemEntropyInterruptTimingInformation = 131,
		SystemConsoleInformation = 132,
		SystemPlatformBinaryInformation = 133,
		SystemPolicyInformation = 134,
		SystemHypervisorProcessorCountInformation = 135,
		SystemDeviceDataInformation = 136,
		SystemDeviceDataEnumerationInformation = 137,
		SystemMemoryTopologyInformation = 138,
		SystemMemoryChannelInformation = 139,
		SystemBootLogoInformation = 140,
		SystemProcessorPerformanceInformationEx = 141,
		SystemSpare0 = 142,
		SystemSecureBootPolicyInformation = 143,
		SystemPageFileInformationEx = 144,
		SystemSecureBootInformation = 145,
		SystemEntropyInterruptTimingRawInformation = 146,
		SystemPortableWorkspaceEfiLauncherInformation = 147,
		SystemFullProcessInformation = 148,
		SystemKernelDebuggerInformationEx = 149,
		SystemBootMetadataInformation = 150,
		SystemSoftRebootInformation = 151,
		SystemElamCertificateInformation = 152,
		SystemOfflineDumpConfigInformation = 153,
		SystemProcessorFeaturesInformation = 154,
		SystemRegistryReconciliationInformation = 155,
		SystemEdidInformation = 156,
		SystemManufacturingInformation = 157,
		SystemEnergyEstimationConfigInformation = 158,
		SystemHypervisorDetailInformation = 159,
		SystemProcessorCycleStatsInformation = 160,
		SystemVmGenerationCountInformation = 161,
		SystemTrustedPlatformModuleInformation = 162,
		SystemKernelDebuggerFlags = 163,
		SystemCodeIntegrityPolicyInformation = 164,
		SystemIsolatedUserModeInformation = 165,
		SystemHardwareSecurityTestInterfaceResultsInformation = 166,
		SystemSingleModuleInformation = 167,
		SystemAllowedCpuSetsInformation = 168,
		SystemDmaProtectionInformation = 169,
		SystemInterruptCpuSetsInformation = 170,
		SystemSecureBootPolicyFullInformation = 171,
		SystemCodeIntegrityPolicyFullInformation = 172,
		SystemAffinitizedInterruptProcessorInformation = 173,
		SystemRootSiloInformation = 174,
		SystemCpuSetInformation = 175,
		SystemCpuSetTagInformation = 176,
		SystemWin32WerStartCallout = 177,
		SystemSecureKernelProfileInformation = 178,
		SystemCodeIntegrityPlatformManifestInformation = 179,
		SystemInterruptSteeringInformation = 180,
		SystemSupportedProcessorArchitectures = 181,
		SystemMemoryUsageInformation = 182,
		SystemCodeIntegrityCertificateInformation = 183,
		SystemPhysicalMemoryInformation = 184,
		SystemControlFlowTransition = 185,
		SystemKernelDebuggingAllowed = 186,
		SystemActivityModerationExeState = 187,
		SystemActivityModerationUserSettings = 188,
		SystemCodeIntegrityPoliciesFullInformation = 189,
		SystemCodeIntegrityUnlockInformation = 190,
		SystemIntegrityQuotaInformation = 191,
		SystemFlushInformation = 192,
		SystemProcessorIdleMaskInformation = 193,
		SystemSecureDumpEncryptionInformation = 194,
		SystemWriteConstraintInformation = 195,
		SystemKernelVaShadowInformation = 196,
		SystemHypervisorSharedPageInformation = 197,
		SystemFirmwareBootPerformanceInformation = 198,
		SystemCodeIntegrityVerificationInformation = 199,
		SystemFirmwarePartitionInformation = 200,
		SystemSpeculationControlInformation = 201,
		SystemDmaGuardPolicyInformation = 202,
		SystemEnclaveLaunchControlInformation = 203,
		SystemWorkloadAllowedCpuSetsInformation = 204,
		SystemCodeIntegrityUnlockModeInformation = 205,
		SystemLeapSecondInformation = 206,
		SystemFlags2Information = 207,
		SystemSecurityModelInformation = 208,
		SystemCodeIntegritySyntheticCacheInformation = 209,
		MaxSystemInfoClass
	} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

	//msdn.microsoft.com/en-us/library/windows/desktop/ms724509(v=vs.85).aspx
	typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION {
		struct {
			ULONG BpbEnabled : 1;
			ULONG BpbDisabledSystemPolicy : 1;
			ULONG BpbDisabledNoHardwareSupport : 1;
			ULONG SpecCtrlEnumerated : 1;
			ULONG SpecCmdEnumerated : 1;
			ULONG IbrsPresent : 1;
			ULONG StibpPresent : 1;
			ULONG SmepPresent : 1;
			ULONG SpeculativeStoreBypassDisableAvailable : 1;
			ULONG SpeculativeStoreBypassDisableSupported : 1;
			ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
			ULONG SpeculativeStoreBypassDisabledKernel : 1;
			ULONG SpeculativeStoreBypassDisableRequired : 1;
			ULONG BpbDisabledKernelToUser : 1;
			ULONG SpecCtrlRetpolineEnabled : 1;
			ULONG SpecCtrlImportOptimizationEnabled : 1;
			ULONG EnhancedIbrs : 1;
			ULONG HvL1tfStatusAvailable : 1;
			ULONG HvL1tfProcessorNotAffected : 1;
			ULONG HvL1tfMigitationEnabled : 1;
			ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
			ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
			ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
			ULONG EnhancedIbrsReported : 1;
			ULONG Reserved : 8;
		} SpeculationControlFlags;
	} SYSTEM_SPECULATION_CONTROL_INFORMATION, * PSYSTEM_SPECULATION_CONTROL_INFORMATION;

	typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
		struct {
			ULONG KvaShadowEnabled : 1;
			ULONG KvaShadowUserGlobal : 1;
			ULONG KvaShadowPcid : 1;
			ULONG KvaShadowInvpcid : 1;
			ULONG KvaShadowRequired : 1;
			ULONG KvaShadowRequiredAvailable : 1;
			ULONG InvalidPteBit : 6;
			ULONG L1DataCacheFlushSupported : 1;
			ULONG L1TerminalFaultMitigationPresent : 1;
			ULONG Reserved : 18;
		} KvaShadowFlags;
	} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, * PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

	typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
		ULONG  Length;
		ULONG  CodeIntegrityOptions;
	} SYSTEM_CODEINTEGRITY_INFORMATION, * PSYSTEM_CODEINTEGRITY_INFORMATION;

#define CODEINTEGRITY_OPTION_ENABLED                      0x01
#define CODEINTEGRITY_OPTION_TESTSIGN                     0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED                 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED       0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED  0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD                   0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD          0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED            0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD                 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED            0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED            0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED  0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED             0x2000

	typedef VOID(NTAPI* PIO_APC_ROUTINE)(
		_In_ PVOID ApcContext,
		_In_ PIO_STATUS_BLOCK IoStatusBlock,
		_In_ ULONG Reserved
		);

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

	typedef struct _SYSTEM_VHD_BOOT_INFORMATION {
		BOOLEAN OsDiskIsVhd;
		ULONG OsVhdFilePathOffset;
		WCHAR OsVhdParentVolume[ANYSIZE_ARRAY];
	} SYSTEM_VHD_BOOT_INFORMATION, * PSYSTEM_VHD_BOOT_INFORMATION;

	typedef struct _SYSTEM_OBJECTTYPE_INFORMATION {
		ULONG NextEntryOffset;
		ULONG NumberOfObjects;
		ULONG NumberOfHandles;
		ULONG TypeIndex;
		ULONG InvalidAttributes;
		GENERIC_MAPPING GenericMapping;
		ULONG ValidAccessMask;
		ULONG PoolType;
		BOOLEAN SecurityRequired;
		BOOLEAN WaitableObject;
		UNICODE_STRING TypeName;
	} SYSTEM_OBJECTTYPE_INFORMATION, * PSYSTEM_OBJECTTYPE_INFORMATION;

	typedef struct _SYSTEM_OBJECT_INFORMATION {
		ULONG NextEntryOffset;
		PVOID Object;
		HANDLE CreatorUniqueProcess;
		USHORT CreatorBackTraceIndex;
		USHORT Flags;
		LONG PointerCount;
		LONG HandleCount;
		ULONG PagedPoolCharge;
		ULONG NonPagedPoolCharge;
		HANDLE ExclusiveProcessId;
		PVOID SecurityDescriptor;
		UNICODE_STRING NameInfo;
	} SYSTEM_OBJECT_INFORMATION, * PSYSTEM_OBJECT_INFORMATION;

	/*
	** Boot Entry START
	*/

	typedef struct _FILE_PATH {
		ULONG Version;
		ULONG Length;
		ULONG Type;
		UCHAR FilePath[ANYSIZE_ARRAY];
	} FILE_PATH, * PFILE_PATH;

	typedef struct _BOOT_ENTRY {
		ULONG Version;
		ULONG Length;
		ULONG Id;
		ULONG Attributes;
		ULONG FriendlyNameOffset;
		ULONG BootFilePathOffset;
		ULONG OsOptionsLength;
		UCHAR OsOptions[ANYSIZE_ARRAY];
	} BOOT_ENTRY, * PBOOT_ENTRY;

	typedef struct _BOOT_ENTRY_LIST {
		ULONG NextEntryOffset;
		BOOT_ENTRY BootEntry;
	} BOOT_ENTRY_LIST, * PBOOT_ENTRY_LIST;

	/*
	** Boot Entry END
	*/

	/*
	** File start
	*/

#define FILE_SUPERSEDE                          0x00000000
#define FILE_OPEN                               0x00000001
#define FILE_CREATE                             0x00000002
#define FILE_OPEN_IF                            0x00000003
#define FILE_OVERWRITE                          0x00000004
#define FILE_OVERWRITE_IF                       0x00000005
#define FILE_MAXIMUM_DISPOSITION                0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

	typedef enum _FILE_INFORMATION_CLASS {
		FileDirectoryInformation = 1,
		FileFullDirectoryInformation,
		FileBothDirectoryInformation,
		FileBasicInformation,
		FileStandardInformation,
		FileInternalInformation,
		FileEaInformation,
		FileAccessInformation,
		FileNameInformation,
		FileRenameInformation,
		FileLinkInformation,
		FileNamesInformation,
		FileDispositionInformation,
		FilePositionInformation,
		FileFullEaInformation,
		FileModeInformation,
		FileAlignmentInformation,
		FileAllInformation,
		FileAllocationInformation,
		FileEndOfFileInformation,
		FileAlternateNameInformation,
		FileStreamInformation,
		FilePipeInformation,
		FilePipeLocalInformation,
		FilePipeRemoteInformation,
		FileMailslotQueryInformation,
		FileMailslotSetInformation,
		FileCompressionInformation,
		FileObjectIdInformation,
		FileCompletionInformation,
		FileMoveClusterInformation,
		FileQuotaInformation,
		FileReparsePointInformation,
		FileNetworkOpenInformation,
		FileAttributeTagInformation,
		FileTrackingInformation,
		FileIdBothDirectoryInformation,
		FileIdFullDirectoryInformation,
		FileValidDataLengthInformation,
		FileShortNameInformation,
		FileIoCompletionNotificationInformation,
		FileIoStatusBlockRangeInformation,
		FileIoPriorityHintInformation,
		FileSfioReserveInformation,
		FileSfioVolumeInformation,
		FileHardLinkInformation,
		FileProcessIdsUsingFileInformation,
		FileNormalizedNameInformation,
		FileNetworkPhysicalNameInformation,
		FileIdGlobalTxDirectoryInformation,
		FileIsRemoteDeviceInformation,
		FileUnusedInformation,
		FileNumaNodeInformation,
		FileStandardLinkInformation,
		FileRemoteProtocolInformation,
		FileRenameInformationBypassAccessCheck,
		FileLinkInformationBypassAccessCheck,
		FileVolumeNameInformation,
		FileIdInformation,
		FileIdExtdDirectoryInformation,
		FileReplaceCompletionInformation,
		FileHardLinkFullIdInformation,
		FileIdExtdBothDirectoryInformation,
		FileDispositionInformationEx,
		FileRenameInformationEx,
		FileRenameInformationExBypassAccessCheck,
		FileDesiredStorageClassInformation,
		FileStatInformation,
		FileMemoryPartitionInformation,
		FileStatLxInformation,
		FileCaseSensitiveInformation,
		FileLinkInformationEx,
		FileLinkInformationExBypassAccessCheck,
		FileStorageReserveIdInformation,
		FileCaseSensitiveInformationForceAccessCheck,
		FileMaximumInformation
	} FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;

	typedef enum _FSINFOCLASS {
		FileFsVolumeInformation = 1,
		FileFsLabelInformation,
		FileFsSizeInformation,
		FileFsDeviceInformation,
		FileFsAttributeInformation,
		FileFsControlInformation,
		FileFsFullSizeInformation,
		FileFsObjectIdInformation,
		FileFsDriverPathInformation,
		FileFsVolumeFlagsInformation,
		FileFsSectorSizeInformation,
		FileFsDataCopyInformation,
		FileFsMetadataSizeInformation,
		FileFsFullSizeInformationEx,
		FileFsMaximumInformation
	} FS_INFORMATION_CLASS, * PFS_INFORMATION_CLASS;

	typedef struct _FILE_BASIC_INFORMATION {
		LARGE_INTEGER CreationTime;
		LARGE_INTEGER LastAccessTime;
		LARGE_INTEGER LastWriteTime;
		LARGE_INTEGER ChangeTime;
		ULONG FileAttributes;
	} FILE_BASIC_INFORMATION, * PFILE_BASIC_INFORMATION;

	typedef struct _FILE_STANDARD_INFORMATION {
		LARGE_INTEGER AllocationSize;
		LARGE_INTEGER EndOfFile;
		ULONG NumberOfLinks;
		UCHAR DeletePending;
		UCHAR Directory;
	} FILE_STANDARD_INFORMATION;

	typedef struct _FILE_STANDARD_INFORMATION_EX {
		LARGE_INTEGER AllocationSize;
		LARGE_INTEGER EndOfFile;
		ULONG NumberOfLinks;
		BOOLEAN DeletePending;
		BOOLEAN Directory;
		BOOLEAN AlternateStream;
		BOOLEAN MetadataAttribute;
	} FILE_STANDARD_INFORMATION_EX, * PFILE_STANDARD_INFORMATION_EX;

	typedef struct _FILE_INTERNAL_INFORMATION {
		LARGE_INTEGER IndexNumber;
	} FILE_INTERNAL_INFORMATION, * PFILE_INTERNAL_INFORMATION;

	typedef struct _FILE_EA_INFORMATION {
		ULONG EaSize;
	} FILE_EA_INFORMATION, * PFILE_EA_INFORMATION;

	typedef struct _FILE_ACCESS_INFORMATION {
		ACCESS_MASK AccessFlags;
	} FILE_ACCESS_INFORMATION, * PFILE_ACCESS_INFORMATION;

	typedef struct _FILE_POSITION_INFORMATION {
		LARGE_INTEGER CurrentByteOffset;
	} FILE_POSITION_INFORMATION, * PFILE_POSITION_INFORMATION;

	typedef struct _FILE_MODE_INFORMATION {
		ULONG Mode;
	} FILE_MODE_INFORMATION, * PFILE_MODE_INFORMATION;

	typedef struct _FILE_ALIGNMENT_INFORMATION {
		ULONG AlignmentRequirement;
	} FILE_ALIGNMENT_INFORMATION, * PFILE_ALIGNMENT_INFORMATION;

	typedef struct _FILE_NAME_INFORMATION {
		ULONG FileNameLength;
		WCHAR FileName[1];
	} FILE_NAME_INFORMATION, * PFILE_NAME_INFORMATION;

	typedef struct _FILE_ALL_INFORMATION {
		FILE_BASIC_INFORMATION BasicInformation;
		FILE_STANDARD_INFORMATION StandardInformation;
		FILE_INTERNAL_INFORMATION InternalInformation;
		FILE_EA_INFORMATION EaInformation;
		FILE_ACCESS_INFORMATION AccessInformation;
		FILE_POSITION_INFORMATION PositionInformation;
		FILE_MODE_INFORMATION ModeInformation;
		FILE_ALIGNMENT_INFORMATION AlignmentInformation;
		FILE_NAME_INFORMATION NameInformation;
	} FILE_ALL_INFORMATION, * PFILE_ALL_INFORMATION;

	typedef struct _FILE_NETWORK_OPEN_INFORMATION {
		LARGE_INTEGER CreationTime;
		LARGE_INTEGER LastAccessTime;
		LARGE_INTEGER LastWriteTime;
		LARGE_INTEGER ChangeTime;
		LARGE_INTEGER AllocationSize;
		LARGE_INTEGER EndOfFile;
		ULONG FileAttributes;
	} FILE_NETWORK_OPEN_INFORMATION, * PFILE_NETWORK_OPEN_INFORMATION;

	typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
		ULONG FileAttributes;
		ULONG ReparseTag;
	} FILE_ATTRIBUTE_TAG_INFORMATION, * PFILE_ATTRIBUTE_TAG_INFORMATION;

	typedef struct _FILE_ALLOCATION_INFORMATION {
		LARGE_INTEGER AllocationSize;
	} FILE_ALLOCATION_INFORMATION, * PFILE_ALLOCATION_INFORMATION;

	typedef struct _FILE_COMPRESSION_INFORMATION {
		LARGE_INTEGER CompressedFileSize;
		USHORT CompressionFormat;
		UCHAR CompressionUnitShift;
		UCHAR ChunkShift;
		UCHAR ClusterShift;
		UCHAR Reserved[3];
	} FILE_COMPRESSION_INFORMATION, * PFILE_COMPRESSION_INFORMATION;

	typedef struct _FILE_DISPOSITION_INFORMATION {
		BOOLEAN DeleteFile;
	} FILE_DISPOSITION_INFORMATION, * PFILE_DISPOSITION_INFORMATION;

	typedef struct _FILE_END_OF_FILE_INFORMATION {
		LARGE_INTEGER EndOfFile;
	} FILE_END_OF_FILE_INFORMATION, * PFILE_END_OF_FILE_INFORMATION;

	typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
		LARGE_INTEGER ValidDataLength;
	} FILE_VALID_DATA_LENGTH_INFORMATION, * PFILE_VALID_DATA_LENGTH_INFORMATION;

	typedef struct _FILE_LINK_INFORMATION {
		BOOLEAN ReplaceIfExists;
		HANDLE RootDirectory;
		ULONG FileNameLength;
		WCHAR FileName[1];
	} FILE_LINK_INFORMATION, * PFILE_LINK_INFORMATION;

	typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
		ULONG ClusterCount;
		HANDLE RootDirectory;
		ULONG FileNameLength;
		WCHAR FileName[1];
	} FILE_MOVE_CLUSTER_INFORMATION, * PFILE_MOVE_CLUSTER_INFORMATION;

	typedef struct _FILE_RENAME_INFORMATION {
		BOOLEAN ReplaceIfExists;
		HANDLE RootDirectory;
		ULONG FileNameLength;
		WCHAR FileName[1];
	} FILE_RENAME_INFORMATION, * PFILE_RENAME_INFORMATION;

	typedef struct _FILE_STREAM_INFORMATION {
		ULONG NextEntryOffset;
		ULONG StreamNameLength;
		LARGE_INTEGER StreamSize;
		LARGE_INTEGER StreamAllocationSize;
		WCHAR StreamName[1];
	} FILE_STREAM_INFORMATION, * PFILE_STREAM_INFORMATION;

	typedef struct _FILE_TRACKING_INFORMATION {
		HANDLE DestinationFile;
		ULONG ObjectInformationLength;
		CHAR ObjectInformation[1];
	} FILE_TRACKING_INFORMATION, * PFILE_TRACKING_INFORMATION;

	typedef struct _FILE_COMPLETION_INFORMATION {
		HANDLE Port;
		PVOID Key;
	} FILE_COMPLETION_INFORMATION, * PFILE_COMPLETION_INFORMATION;

	//
	// Define the NamedPipeType flags for NtCreateNamedPipeFile
	//

#define FILE_PIPE_BYTE_STREAM_TYPE      0x00000000
#define FILE_PIPE_MESSAGE_TYPE          0x00000001

//
// Define the CompletionMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_QUEUE_OPERATION       0x00000000
#define FILE_PIPE_COMPLETE_OPERATION    0x00000001

//
// Define the ReadMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
#define FILE_PIPE_MESSAGE_MODE          0x00000001

//
// Define the NamedPipeConfiguration flags for NtQueryInformation
//

#define FILE_PIPE_INBOUND               0x00000000
#define FILE_PIPE_OUTBOUND              0x00000001
#define FILE_PIPE_FULL_DUPLEX           0x00000002

//
// Define the NamedPipeState flags for NtQueryInformation
//

#define FILE_PIPE_DISCONNECTED_STATE    0x00000001
#define FILE_PIPE_LISTENING_STATE       0x00000002
#define FILE_PIPE_CONNECTED_STATE       0x00000003
#define FILE_PIPE_CLOSING_STATE         0x00000004

//
// Define the NamedPipeEnd flags for NtQueryInformation
//

#define FILE_PIPE_CLIENT_END            0x00000000
#define FILE_PIPE_SERVER_END            0x00000001


	typedef struct _FILE_PIPE_INFORMATION {
		ULONG ReadMode;
		ULONG CompletionMode;
	} FILE_PIPE_INFORMATION, * PFILE_PIPE_INFORMATION;

	typedef struct _FILE_PIPE_LOCAL_INFORMATION {
		ULONG NamedPipeType;
		ULONG NamedPipeConfiguration;
		ULONG MaximumInstances;
		ULONG CurrentInstances;
		ULONG InboundQuota;
		ULONG ReadDataAvailable;
		ULONG OutboundQuota;
		ULONG WriteQuotaAvailable;
		ULONG NamedPipeState;
		ULONG NamedPipeEnd;
	} FILE_PIPE_LOCAL_INFORMATION, * PFILE_PIPE_LOCAL_INFORMATION;

	typedef struct _FILE_PIPE_REMOTE_INFORMATION {
		LARGE_INTEGER CollectDataTime;
		ULONG MaximumCollectionCount;
	} FILE_PIPE_REMOTE_INFORMATION, * PFILE_PIPE_REMOTE_INFORMATION;

	typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
		ULONG MaximumMessageSize;
		ULONG MailslotQuota;
		ULONG NextMessageSize;
		ULONG MessagesAvailable;
		LARGE_INTEGER ReadTimeout;
	} FILE_MAILSLOT_QUERY_INFORMATION, * PFILE_MAILSLOT_QUERY_INFORMATION;

	typedef struct _FILE_MAILSLOT_SET_INFORMATION {
		PLARGE_INTEGER ReadTimeout;
	} FILE_MAILSLOT_SET_INFORMATION, * PFILE_MAILSLOT_SET_INFORMATION;

	typedef struct _FILE_REPARSE_POINT_INFORMATION {
		LONGLONG FileReference;
		ULONG Tag;
	} FILE_REPARSE_POINT_INFORMATION, * PFILE_REPARSE_POINT_INFORMATION;

	typedef struct _FILE_LINK_ENTRY_INFORMATION {
		ULONG NextEntryOffset;
		LONGLONG ParentFileId;
		ULONG FileNameLength;
		WCHAR FileName[1];
	} FILE_LINK_ENTRY_INFORMATION, * PFILE_LINK_ENTRY_INFORMATION;

	typedef struct _FILE_LINKS_INFORMATION {
		ULONG BytesNeeded;
		ULONG EntriesReturned;
		FILE_LINK_ENTRY_INFORMATION Entry;
	} FILE_LINKS_INFORMATION, * PFILE_LINKS_INFORMATION;

	typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
		ULONG FileNameLength;
		WCHAR FileName[1];
	} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, * PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

	typedef struct _FILE_STANDARD_LINK_INFORMATION {
		ULONG NumberOfAccessibleLinks;
		ULONG TotalNumberOfLinks;
		BOOLEAN DeletePending;
		BOOLEAN Directory;
	} FILE_STANDARD_LINK_INFORMATION, * PFILE_STANDARD_LINK_INFORMATION;

	typedef struct _FILE_SFIO_RESERVE_INFORMATION {
		ULONG RequestsPerPeriod;
		ULONG Period;
		BOOLEAN RetryFailures;
		BOOLEAN Discardable;
		ULONG RequestSize;
		ULONG NumOutstandingRequests;
	} FILE_SFIO_RESERVE_INFORMATION, * PFILE_SFIO_RESERVE_INFORMATION;

	typedef struct _FILE_SFIO_VOLUME_INFORMATION {
		ULONG MaximumRequestsPerPeriod;
		ULONG MinimumPeriod;
		ULONG MinimumTransferSize;
	} FILE_SFIO_VOLUME_INFORMATION, * PFILE_SFIO_VOLUME_INFORMATION;

	//
	// Define the flags for NtSet(Query)EaFile service structure entries
	//

#define FILE_NEED_EA                    0x00000080

//
// Define EA type values
//

#define FILE_EA_TYPE_BINARY             0xfffe
#define FILE_EA_TYPE_ASCII              0xfffd
#define FILE_EA_TYPE_BITMAP             0xfffb
#define FILE_EA_TYPE_METAFILE           0xfffa
#define FILE_EA_TYPE_ICON               0xfff9
#define FILE_EA_TYPE_EA                 0xffee
#define FILE_EA_TYPE_MVMT               0xffdf
#define FILE_EA_TYPE_MVST               0xffde
#define FILE_EA_TYPE_ASN1               0xffdd
#define FILE_EA_TYPE_FAMILY_IDS         0xff01

	typedef struct _FILE_FULL_EA_INFORMATION {
		ULONG NextEntryOffset;
		UCHAR Flags;
		UCHAR EaNameLength;
		USHORT EaValueLength;
		CHAR EaName[1];
	} FILE_FULL_EA_INFORMATION, * PFILE_FULL_EA_INFORMATION;

	typedef struct _FILE_GET_EA_INFORMATION {
		ULONG NextEntryOffset;
		UCHAR EaNameLength;
		CHAR EaName[1];
	} FILE_GET_EA_INFORMATION, * PFILE_GET_EA_INFORMATION;

	typedef struct _FILE_GET_QUOTA_INFORMATION {
		ULONG NextEntryOffset;
		ULONG SidLength;
		SID Sid;
	} FILE_GET_QUOTA_INFORMATION, * PFILE_GET_QUOTA_INFORMATION;

	typedef struct _FILE_QUOTA_INFORMATION {
		ULONG NextEntryOffset;
		ULONG SidLength;
		LARGE_INTEGER ChangeTime;
		LARGE_INTEGER QuotaUsed;
		LARGE_INTEGER QuotaThreshold;
		LARGE_INTEGER QuotaLimit;
		SID Sid;
	} FILE_QUOTA_INFORMATION, * PFILE_QUOTA_INFORMATION;

	typedef struct _FILE_DIRECTORY_INFORMATION {
		ULONG NextEntryOffset;
		ULONG FileIndex;
		LARGE_INTEGER CreationTime;
		LARGE_INTEGER LastAccessTime;
		LARGE_INTEGER LastWriteTime;
		LARGE_INTEGER ChangeTime;
		LARGE_INTEGER EndOfFile;
		LARGE_INTEGER AllocationSize;
		ULONG FileAttributes;
		ULONG FileNameLength;
		WCHAR FileName[1];
	} FILE_DIRECTORY_INFORMATION, * PFILE_DIRECTORY_INFORMATION;

	typedef struct _FILE_FULL_DIR_INFORMATION {
		ULONG NextEntryOffset;
		ULONG FileIndex;
		LARGE_INTEGER CreationTime;
		LARGE_INTEGER LastAccessTime;
		LARGE_INTEGER LastWriteTime;
		LARGE_INTEGER ChangeTime;
		LARGE_INTEGER EndOfFile;
		LARGE_INTEGER AllocationSize;
		ULONG FileAttributes;
		ULONG FileNameLength;
		ULONG EaSize;
		WCHAR FileName[1];
	} FILE_FULL_DIR_INFORMATION, * PFILE_FULL_DIR_INFORMATION;

	typedef struct _FILE_ID_FULL_DIR_INFORMATION {
		ULONG NextEntryOffset;
		ULONG FileIndex;
		LARGE_INTEGER CreationTime;
		LARGE_INTEGER LastAccessTime;
		LARGE_INTEGER LastWriteTime;
		LARGE_INTEGER ChangeTime;
		LARGE_INTEGER EndOfFile;
		LARGE_INTEGER AllocationSize;
		ULONG FileAttributes;
		ULONG FileNameLength;
		ULONG EaSize;
		LARGE_INTEGER FileId;
		WCHAR FileName[1];
	} FILE_ID_FULL_DIR_INFORMATION, * PFILE_ID_FULL_DIR_INFORMATION;

	typedef struct _FILE_BOTH_DIR_INFORMATION {
		ULONG NextEntryOffset;
		ULONG FileIndex;
		LARGE_INTEGER CreationTime;
		LARGE_INTEGER LastAccessTime;
		LARGE_INTEGER LastWriteTime;
		LARGE_INTEGER ChangeTime;
		LARGE_INTEGER EndOfFile;
		LARGE_INTEGER AllocationSize;
		ULONG FileAttributes;
		ULONG FileNameLength;
		ULONG EaSize;
		CCHAR ShortNameLength;
		WCHAR ShortName[12];
		WCHAR FileName[1];
	} FILE_BOTH_DIR_INFORMATION, * PFILE_BOTH_DIR_INFORMATION;

	typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
		ULONG NextEntryOffset;
		ULONG FileIndex;
		LARGE_INTEGER CreationTime;
		LARGE_INTEGER LastAccessTime;
		LARGE_INTEGER LastWriteTime;
		LARGE_INTEGER ChangeTime;
		LARGE_INTEGER EndOfFile;
		LARGE_INTEGER AllocationSize;
		ULONG FileAttributes;
		ULONG FileNameLength;
		ULONG EaSize;
		CCHAR ShortNameLength;
		WCHAR ShortName[12];
		LARGE_INTEGER FileId;
		WCHAR FileName[1];
	} FILE_ID_BOTH_DIR_INFORMATION, * PFILE_ID_BOTH_DIR_INFORMATION;

	typedef struct _FILE_NAMES_INFORMATION {
		ULONG NextEntryOffset;
		ULONG FileIndex;
		ULONG FileNameLength;
		WCHAR FileName[1];
	} FILE_NAMES_INFORMATION, * PFILE_NAMES_INFORMATION;

	typedef struct _FILE_OBJECTID_INFORMATION {
		LONGLONG FileReference;
		UCHAR ObjectId[16];
		union {
			struct {
				UCHAR BirthVolumeId[16];
				UCHAR BirthObjectId[16];
				UCHAR DomainId[16];
			};
			UCHAR ExtendedInfo[48];
		};
	} FILE_OBJECTID_INFORMATION, * PFILE_OBJECTID_INFORMATION;

	typedef struct _FILE_FS_VOLUME_INFORMATION {
		LARGE_INTEGER VolumeCreationTime;
		ULONG         VolumeSerialNumber;
		ULONG         VolumeLabelLength;
		BOOLEAN       SupportsObjects;
		WCHAR         VolumeLabel[1];
	} FILE_FS_VOLUME_INFORMATION, * PFILE_FS_VOLUME_INFORMATION;

	typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
	{
		ULONG NextEntryOffset;
		ULONG FileIndex;
		LARGE_INTEGER CreationTime;
		LARGE_INTEGER LastAccessTime;
		LARGE_INTEGER LastWriteTime;
		LARGE_INTEGER ChangeTime;
		LARGE_INTEGER EndOfFile;
		LARGE_INTEGER AllocationSize;
		ULONG FileAttributes;
		ULONG FileNameLength;
		LARGE_INTEGER FileId;
		GUID LockingTransactionId;
		ULONG TxInfoFlags;
		WCHAR FileName[1];
	} FILE_ID_GLOBAL_TX_DIR_INFORMATION, * PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

	/*
	** File END
	*/

	/*
	** Section START
	*/

	typedef enum _SECTION_INFORMATION_CLASS {
		SectionBasicInformation,
		SectionImageInformation,
		SectionRelocationInformation,
		SectionOriginalBaseInformation,
		SectionInternalImageInformation,
		MaxSectionInfoClass
	} SECTION_INFORMATION_CLASS;

	typedef struct _SECTION_BASIC_INFO {
		PVOID BaseAddress;
		ULONG AllocationAttributes;
		LARGE_INTEGER MaximumSize;
	} SECTION_BASIC_INFORMATION, * PSECTION_BASIC_INFORMATION;

	typedef struct _SECTION_IMAGE_INFORMATION {
		PVOID TransferAddress;
		ULONG ZeroBits;
		SIZE_T MaximumStackSize;
		SIZE_T CommittedStackSize;
		ULONG SubSystemType;
		union {
			struct {
				USHORT SubSystemMinorVersion;
				USHORT SubSystemMajorVersion;
			};
			ULONG SubSystemVersion;
		};
		union
		{
			struct
			{
				USHORT MajorOperatingSystemVersion;
				USHORT MinorOperatingSystemVersion;
			};
			ULONG OperatingSystemVersion;
		};
		USHORT ImageCharacteristics;
		USHORT DllCharacteristics;
		USHORT Machine;
		BOOLEAN ImageContainsCode;
		union
		{
			UCHAR ImageFlags;
			struct
			{
				UCHAR ComPlusNativeReady : 1;
				UCHAR ComPlusILOnly : 1;
				UCHAR ImageDynamicallyRelocated : 1;
				UCHAR ImageMappedFlat : 1;
				UCHAR BaseBelow4gb : 1;
				UCHAR ComPlusPrefer32bit : 1;
				UCHAR Reserved : 2;
			};
		};
		ULONG LoaderFlags;
		ULONG ImageFileSize;
		ULONG CheckSum;
	} SECTION_IMAGE_INFORMATION, * PSECTION_IMAGE_INFORMATION;

	typedef struct _SECTION_IMAGE_INFORMATION64 {
		ULONGLONG TransferAddress;
		ULONG ZeroBits;
		ULONGLONG MaximumStackSize;
		ULONGLONG CommittedStackSize;
		ULONG SubSystemType;
		union {
			struct {
				USHORT SubSystemMinorVersion;
				USHORT SubSystemMajorVersion;
			};
			ULONG SubSystemVersion;
		};
		union
		{
			struct
			{
				USHORT MajorOperatingSystemVersion;
				USHORT MinorOperatingSystemVersion;
			};
			ULONG OperatingSystemVersion;
		};
		USHORT ImageCharacteristics;
		USHORT DllCharacteristics;
		USHORT Machine;
		BOOLEAN ImageContainsCode;
		union
		{
			UCHAR ImageFlags;
			struct
			{
				UCHAR ComPlusNativeReady : 1;
				UCHAR ComPlusILOnly : 1;
				UCHAR ImageDynamicallyRelocated : 1;
				UCHAR ImageMappedFlat : 1;
				UCHAR BaseBelow4gb : 1;
				UCHAR ComPlusPrefer32bit : 1;
				UCHAR Reserved : 2;
			};
		};
		ULONG LoaderFlags;
		ULONG ImageFileSize;
		ULONG CheckSum;
	} SECTION_IMAGE_INFORMATION64, * PSECTION_IMAGE_INFORMATION64;

	typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION {
		SECTION_IMAGE_INFORMATION SectionInformation;
		union
		{
			ULONG ExtendedFlags;
			struct
			{
				ULONG ImageExportSuppressionEnabled : 1;
				ULONG Reserved : 31;
			};
		};
	} SECTION_INTERNAL_IMAGE_INFORMATION, * PSECTION_INTERNAL_IMAGE_INFORMATION;

	typedef enum _SECTION_INHERIT {
		ViewShare = 1,
		ViewUnmap = 2
	} SECTION_INHERIT;

#ifndef SEC_BASED
#define SEC_BASED          0x200000
#endif

#ifndef SEC_NO_IMAGE
#define SEC_NO_CHANGE      0x400000
#endif

#ifndef SEC_FILE
#define SEC_FILE           0x800000     
#endif

#ifndef SEC_IMAGE
#define SEC_IMAGE         0x1000000     
#endif

#ifndef SEC_RESERVE
#define SEC_RESERVE       0x4000000     
#endif

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000     
#endif

#ifndef SEC_NOCACHE
#define SEC_NOCACHE      0x10000000     
#endif

#ifndef SEC_GLOBAL
#define SEC_GLOBAL       0x20000000
#endif

#ifndef SEC_LARGE_PAGES
#define SEC_LARGE_PAGES  0x80000000    
#endif

	/*
	** Section END
	*/

	/*
	** System Table START
	*/
#define NUMBER_SERVICE_TABLES 2
#define NTOS_SERVICE_INDEX   0
#define WIN32K_SERVICE_INDEX 1
#define SERVICE_NUMBER_MASK ((1 << 12) -  1)

#if defined(_WIN64)

#if defined(_AMD64_)

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#else

#define SERVICE_TABLE_SHIFT (12 - 5)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 5)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 5)

#endif

#else

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#endif

	typedef struct _KSERVICE_TABLE_DESCRIPTOR {
		ULONG_PTR Base; //e.g. KiServiceTable
		PULONG Count;
		ULONG Limit;//e.g. KiServiceLimit
		PUCHAR Number; //e.g. KiArgumentTable
	} KSERVICE_TABLE_DESCRIPTOR, * PKSERVICE_TABLE_DESCRIPTOR;
	/*
	** System Table END
	*/

	/*
	** System Boot Environment START
	*/

	// Size=20
	typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1 {
		struct _GUID BootIdentifier;
		enum _FIRMWARE_TYPE FirmwareType;
	} SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1, * PSYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1;

	// Size=32
	typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
		struct _GUID BootIdentifier;
		enum _FIRMWARE_TYPE FirmwareType;
		unsigned __int64 BootFlags;
	} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, * PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

	/*
	** System Boot Environment END
	*/

	/*
	** Key START
	*/

	typedef enum _KEY_INFORMATION_CLASS {
		KeyBasicInformation,
		KeyNodeInformation,
		KeyFullInformation,
		KeyNameInformation,
		KeyCachedInformation,
		KeyFlagsInformation,
		KeyVirtualizationInformation,
		KeyHandleTagsInformation,
		KeyTrustInformation,
		KeyLayerInformation,
		MaxKeyInfoClass
	} KEY_INFORMATION_CLASS;

	typedef enum _KEY_SET_INFORMATION_CLASS {
		KeyWriteTimeInformation,
		KeyWow64FlagsInformation,
		KeyControlFlagsInformation,
		KeySetVirtualizationInformation,
		KeySetDebugInformation,
		KeySetHandleTagsInformation,
		KeySetLayerInformation,
		MaxKeySetInfoClass
	} KEY_SET_INFORMATION_CLASS;

	typedef struct _KEY_FULL_INFORMATION {
		LARGE_INTEGER LastWriteTime;
		ULONG   TitleIndex;
		ULONG   ClassOffset;
		ULONG   ClassLength;
		ULONG   SubKeys;
		ULONG   MaxNameLen;
		ULONG   MaxClassLen;
		ULONG   Values;
		ULONG   MaxValueNameLen;
		ULONG   MaxValueDataLen;
		WCHAR   Class[1];
	} KEY_FULL_INFORMATION, * PKEY_FULL_INFORMATION;

	typedef struct _KEY_BASIC_INFORMATION {
		LARGE_INTEGER LastWriteTime;
		ULONG TitleIndex;
		ULONG NameLength;
		WCHAR Name[1];
	} KEY_BASIC_INFORMATION, * PKEY_BASIC_INFORMATION;

	typedef enum _KEY_VALUE_INFORMATION_CLASS {
		KeyValueBasicInformation,
		KeyValueFullInformation,
		KeyValuePartialInformation,
		KeyValueFullInformationAlign64,
		KeyValuePartialInformationAlign64,
		KeyValueLayerInformation,
		MaxKeyValueInfoClass
	} KEY_VALUE_INFORMATION_CLASS;

	typedef struct _KEY_VALUE_BASIC_INFORMATION {
		ULONG   TitleIndex;
		ULONG   Type;
		ULONG   NameLength;
		WCHAR   Name[1];            // Variable size
	} KEY_VALUE_BASIC_INFORMATION, * PKEY_VALUE_BASIC_INFORMATION;

	typedef struct _KEY_VALUE_FULL_INFORMATION {
		ULONG   TitleIndex;
		ULONG   Type;
		ULONG   DataOffset;
		ULONG   DataLength;
		ULONG   NameLength;
		WCHAR   Name[1];            // Variable size
		//          Data[1];            // Variable size data not declared
	} KEY_VALUE_FULL_INFORMATION, * PKEY_VALUE_FULL_INFORMATION;

	typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
		ULONG   TitleIndex;
		ULONG   Type;
		ULONG   DataLength;
		UCHAR   Data[1];            // Variable size
	} KEY_VALUE_PARTIAL_INFORMATION, * PKEY_VALUE_PARTIAL_INFORMATION;

	typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
		ULONG   Type;
		ULONG   DataLength;
		UCHAR   Data[1];            // Variable size
	} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, * PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

	typedef struct _KEY_VALUE_ENTRY {
		PUNICODE_STRING ValueName;
		ULONG           DataLength;
		ULONG           DataOffset;
		ULONG           Type;
	} KEY_VALUE_ENTRY, * PKEY_VALUE_ENTRY;

	/*
	** Key END
	*/


	/*
	** TIME_FIELDS START
	*/

	typedef struct _TIME_FIELDS {
		CSHORT Year;        // range [1601...]
		CSHORT Month;       // range [1..12]
		CSHORT Day;         // range [1..31]
		CSHORT Hour;        // range [0..23]
		CSHORT Minute;      // range [0..59]
		CSHORT Second;      // range [0..59]
		CSHORT Milliseconds;// range [0..999]
		CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
	} TIME_FIELDS;
	typedef TIME_FIELDS* PTIME_FIELDS;

	/*
	** TIME_FIELDS END
	*/

	/*
	** HANDLE START
	*/

	typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
		USHORT UniqueProcessId;
		USHORT CreatorBackTraceIndex;
		UCHAR ObjectTypeIndex;
		UCHAR HandleAttributes;
		USHORT HandleValue;
		PVOID Object;
		ULONG GrantedAccess;
	} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

	typedef struct _SYSTEM_HANDLE_INFORMATION {
		ULONG NumberOfHandles;
		SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
	} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

	typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
		PVOID Object;
		ULONG_PTR UniqueProcessId;
		ULONG_PTR HandleValue;
		ULONG GrantedAccess;
		USHORT CreatorBackTraceIndex;
		USHORT ObjectTypeIndex;
		ULONG HandleAttributes;
		ULONG Reserved;
	} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

	typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
		ULONG_PTR NumberOfHandles;
		ULONG_PTR Reserved;
		SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
	} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

	/*
	** HANDLE END
	*/

	// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE (36L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)


/*
** OBJECT MANAGER START
*/

//
// Header flags
//

#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40
#define OB_FLAG_DELETED_INLINE          0x80

//
// InfoMask values
//

#define OB_INFOMASK_PROCESS_INFO    0x10
#define OB_INFOMASK_QUOTA           0x08
#define OB_INFOMASK_HANDLE          0x04
#define OB_INFOMASK_NAME            0x02
#define OB_INFOMASK_CREATOR_INFO    0x01

#define OBJ_INVALID_SESSION_ID 0xFFFFFFFF
#define NUMBER_HASH_BUCKETS 37

	typedef struct _OBJECT_DIRECTORY_ENTRY {
		PVOID ChainLink;
		PVOID Object;
		ULONG HashValue;
	} OBJECT_DIRECTORY_ENTRY, * POBJECT_DIRECTORY_ENTRY;

	typedef struct _EX_PUSH_LOCK {
		union
		{
			ULONG Locked : 1;
			ULONG Waiting : 1;
			ULONG Waking : 1;
			ULONG MultipleShared : 1;
			ULONG Shared : 28;
			ULONG Value;
			PVOID Ptr;
		};
	} EX_PUSH_LOCK, * PEX_PUSH_LOCK;

	typedef struct _OBJECT_NAMESPACE_LOOKUPTABLE {
		LIST_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
		EX_PUSH_LOCK Lock;
		ULONG NumberOfPrivateSpaces;
	} OBJECT_NAMESPACE_LOOKUPTABLE, * POBJECT_NAMESPACE_LOOKUPTABLE;

	typedef struct _OBJECT_NAMESPACE_ENTRY {
		LIST_ENTRY ListEntry;
		PVOID NamespaceRootDirectory;
		ULONG SizeOfBoundaryInformation;
		ULONG Reserved;
		UCHAR HashValue;
		ULONG_PTR Alignment;
	} OBJECT_NAMESPACE_ENTRY, * POBJECT_NAMESPACE_ENTRY;

	typedef enum _BOUNDARY_ENTRY_TYPE {
		OBNS_Invalid = 0,
		OBNS_Name = 1,
		OBNS_SID = 2,
		OBNS_IntegrityLabel = 3
	} BOUNDARY_ENTRY_TYPE;

	typedef struct _OBJECT_BOUNDARY_ENTRY {
		BOUNDARY_ENTRY_TYPE EntryType;
		ULONG EntrySize;
	} OBJECT_BOUNDARY_ENTRY, * POBJECT_BOUNDARY_ENTRY;

	typedef struct _OBJECT_BOUNDARY_DESCRIPTOR {
		ULONG Version;
		ULONG Items;
		ULONG TotalSize;
		ULONG Reserved;
	} OBJECT_BOUNDARY_DESCRIPTOR, * POBJECT_BOUNDARY_DESCRIPTOR;

	typedef struct _OBJECT_DIRECTORY {
		POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
		EX_PUSH_LOCK Lock;
		PDEVICE_MAP DeviceMap;
		ULONG SessionId;
		PVOID NamespaceEntry;
		ULONG Flags;
	} OBJECT_DIRECTORY, * POBJECT_DIRECTORY;

	typedef struct _OBJECT_DIRECTORY_V2 {
		POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
		EX_PUSH_LOCK Lock;
		PDEVICE_MAP DeviceMap;
		POBJECT_DIRECTORY ShadowDirectory;
		ULONG SessionId;
		PVOID NamespaceEntry;
		ULONG Flags;
		LONG Padding[1];
	} OBJECT_DIRECTORY_V2, * POBJECT_DIRECTORY_V2;

	typedef struct _OBJECT_DIRECTORY_V3 {
		POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
		EX_PUSH_LOCK Lock;
		PDEVICE_MAP DeviceMap;
		POBJECT_DIRECTORY ShadowDirectory;
		PVOID NamespaceEntry;
		PVOID SessionObject;
		ULONG Flags;
		ULONG SessionId;
	} OBJECT_DIRECTORY_V3, * POBJECT_DIRECTORY_V3;

	typedef struct _OBJECT_HEADER_NAME_INFO {
		POBJECT_DIRECTORY Directory;
		UNICODE_STRING Name;
		ULONG QueryReferences;
	} OBJECT_HEADER_NAME_INFO, * POBJECT_HEADER_NAME_INFO;

	typedef struct _OBJECT_HEADER_CREATOR_INFO {// Size=32
		LIST_ENTRY TypeList; // Size=16 Offset=0
		PVOID CreatorUniqueProcess; // Size=8 Offset=16
		USHORT CreatorBackTraceIndex; // Size=2 Offset=24
		USHORT Reserved; // Size=2 Offset=26
	} OBJECT_HEADER_CREATOR_INFO, * POBJECT_HEADER_CREATOR_INFO;

	typedef struct _OBJECT_HANDLE_COUNT_ENTRY {// Size=16
		PVOID Process; // Size=8 Offset=0
		struct
		{
			unsigned long HandleCount : 24; // Size=4 Offset=8 BitOffset=0 BitCount=24
			unsigned long LockCount : 8; // Size=4 Offset=8 BitOffset=24 BitCount=8
		};
	} OBJECT_HANDLE_COUNT_ENTRY, * POBJECT_HANDLE_COUNT_ENTRY;

	typedef struct _OBJECT_HEADER_HANDLE_INFO { // Size=16
		union {
			PVOID HandleCountDataBase; // Size=8 Offset=0
			struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // Size=16 Offset=0
		};
	} OBJECT_HEADER_HANDLE_INFO, * POBJECT_HEADER_HANDLE_INFO;

	typedef struct _OBJECT_HEADER_PROCESS_INFO { // Size=16
		PVOID ExclusiveProcess; // Size=8 Offset=0
		PVOID Reserved; // Size=8 Offset=8
	} OBJECT_HEADER_PROCESS_INFO, * POBJECT_HEADER_PROCESS_INFO;

	typedef struct _OBJECT_HEADER_QUOTA_INFO {
		ULONG PagedPoolCharge; //4
		ULONG NonPagedPoolCharge; //4 
		ULONG SecurityDescriptorCharge; //4
		PVOID SecurityDescriptorQuotaBlock; //sizeof(pointer)
		unsigned __int64 Reserved; //sizeof(uint64)
	} OBJECT_HEADER_QUOTA_INFO, * POBJECT_HEADER_QUOTA_INFO;

	typedef struct _OBJECT_HEADER_PADDING_INFO {
		ULONG PaddingAmount;
	} OBJECT_HEADER_PADDING_INFO, * POBJECT_HEADER_PADDING_INFO;

	typedef struct _OBJECT_HEADER_AUDIT_INFO {
		PVOID SecurityDescriptor;
		PVOID Reserved;
	} OBJECT_HEADER_AUDIT_INFO, * POBJECT_HEADER_AUDIT_INFO;

	typedef struct _OBJECT_HEADER_EXTENDED_INFO {
		struct _OBJECT_FOOTER* Footer;
		PVOID Reserved;
	} OBJECT_HEADER_EXTENDED_INFO, POBJECT_HEADER_EXTENDED_INFO;

	typedef struct _OB_HANDLE_REVOCATION_BLOCK
	{
		LIST_ENTRY RevocationInfos;
		struct _EX_PUSH_LOCK Lock;
		struct _EX_RUNDOWN_REF Rundown;
	} OB_HANDLE_REVOCATION_BLOCK, * POB_HANDLE_REVOCATION_BLOCK;

	typedef struct _OBJECT_HEADER_HANDLE_REVOCATION_INFO {
		LIST_ENTRY ListEntry;
		OB_HANDLE_REVOCATION_BLOCK* RevocationBlock;
		unsigned char Padding1[4];
		unsigned char Padding2[4];
	} OBJECT_HEADER_HANDLE_REVOCATION_INFO, * POBJECT_HEADER_HANDLE_REVOCATION_INFO;

	typedef struct _QUAD {
		union {
			INT64 UseThisFieldToCopy;
			float DoNotUseThisField;
		};
	} QUAD, * PQUAD;

	typedef struct _OBJECT_CREATE_INFORMATION {
		ULONG Attributes;
		PVOID RootDirectory;
		CHAR ProbeMode;
		ULONG PagedPoolCharge;
		ULONG NonPagedPoolCharge;
		ULONG SecurityDescriptorCharge;
		PVOID SecurityDescriptor;
		PSECURITY_QUALITY_OF_SERVICE SecurityQos;
		SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
	} OBJECT_CREATE_INFORMATION, * POBJECT_CREATE_INFORMATION;

	typedef struct _SECURITY_CLIENT_CONTEXT {
		struct _SECURITY_QUALITY_OF_SERVICE SecurityQos;
		void* ClientToken;
		UCHAR DirectlyAccessClientToken;
		UCHAR DirectAccessEffectiveOnly;
		UCHAR ServerIsRemote;
		struct _TOKEN_CONTROL ClientTokenControl;
		LONG __PADDING__[1];
	} SECURITY_CLIENT_CONTEXT, * PSECURITY_CLIENT_CONTEXT;

	typedef enum _POOL_TYPE {
		NonPagedPool,
		NonPagedPoolExecute = NonPagedPool,
		PagedPool,
		NonPagedPoolMustSucceed = NonPagedPool + 2,
		DontUseThisType,
		NonPagedPoolCacheAligned = NonPagedPool + 4,
		PagedPoolCacheAligned,
		NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
		MaxPoolType,
		NonPagedPoolBase = 0,
		NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
		NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
		NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
		NonPagedPoolSession = 32,
		PagedPoolSession = NonPagedPoolSession + 1,
		NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
		DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
		NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
		PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
		NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
		NonPagedPoolNx = 512,
		NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
		NonPagedPoolSessionNx = NonPagedPoolNx + 32
	} POOL_TYPE;

	//
	// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
	//
	typedef struct _OBJECT_TYPE_INITIALIZER_COMPATIBLE {// Size=120
		USHORT Length; // Size=2 Offset=0
		UCHAR ObjectTypeFlags; // Size=1 Offset=2
		ULONG ObjectTypeCode; // Size=4 Offset=4
		ULONG InvalidAttributes; // Size=4 Offset=8
		GENERIC_MAPPING GenericMapping; // Size=16 Offset=12
		ULONG ValidAccessMask; // Size=4 Offset=28
		ULONG RetainAccess; // Size=4 Offset=32
		POOL_TYPE PoolType; // Size=4 Offset=36
		ULONG DefaultPagedPoolCharge; // Size=4 Offset=40
		ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
		PVOID DumpProcedure; // Size=8 Offset=48
		PVOID OpenProcedure; // Size=8 Offset=56
		PVOID CloseProcedure; // Size=8 Offset=64
		PVOID DeleteProcedure; // Size=8 Offset=72
		PVOID ParseProcedure; // Size=8 Offset=80
		PVOID SecurityProcedure; // Size=8 Offset=88
		PVOID QueryNameProcedure; // Size=8 Offset=96
		PVOID OkayToCloseProcedure; // Size=8 Offset=104
	} OBJECT_TYPE_INITIALIZER_COMPATIBLE, * POBJECT_TYPE_INITIALIZER_COMPATIBLE;

	//
	// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
	//
	typedef struct _OBJECT_TYPE_COMPATIBLE {
		LIST_ENTRY TypeList;
		UNICODE_STRING Name;
		PVOID DefaultObject;
		UCHAR Index;
		ULONG TotalNumberOfObjects;
		ULONG TotalNumberOfHandles;
		ULONG HighWaterNumberOfObjects;
		ULONG HighWaterNumberOfHandles;
		OBJECT_TYPE_INITIALIZER_COMPATIBLE TypeInfo;
	} OBJECT_TYPE_COMPATIBLE, * POBJECT_TYPE_COMPATIBLE;
	typedef POBJECT_TYPE_COMPATIBLE POBJECT_TYPE;

	//
	// Complete definitions of OBJECT_TYPE + OBJECT_TYPE_INITIALIZER per Windows version.
	//

	typedef struct _OBJECT_TYPE_INITIALIZER_7 {
		USHORT Length;
		union
		{
			UCHAR ObjectTypeFlags;
			struct
			{
				UCHAR CaseInsensitive : 1;
				UCHAR UnnamedObjectsOnly : 1;
				UCHAR UseDefaultObject : 1;
				UCHAR SecurityRequired : 1;
				UCHAR MaintainHandleCount : 1;
				UCHAR MaintainTypeList : 1;
				UCHAR SupportsObjectCallbacks : 1;
			};
		};
		ULONG ObjectTypeCode;
		ULONG InvalidAttributes;
		GENERIC_MAPPING GenericMapping;
		ULONG ValidAccessMask;
		ULONG RetainAccess;
		POOL_TYPE PoolType;
		ULONG DefaultPagedPoolCharge;
		ULONG DefaultNonPagedPoolCharge;
		PVOID DumpProcedure;
		PVOID OpenProcedure;
		PVOID CloseProcedure;
		PVOID DeleteProcedure;
		PVOID ParseProcedure;
		PVOID SecurityProcedure;
		PVOID QueryNameProcedure;
		PVOID OkayToCloseProcedure;
	} OBJECT_TYPE_INITIALIZER_7, * POBJECT_TYPE_INITIALIZER_7;

	//
	// Windows 8, new object type flag, WaitObject* members added
	//
	typedef struct _OBJECT_TYPE_INITIALIZER_8 {
		USHORT Length;
		union
		{
			UCHAR ObjectTypeFlags;
			struct
			{
				UCHAR CaseInsensitive : 1;
				UCHAR UnnamedObjectsOnly : 1;
				UCHAR UseDefaultObject : 1;
				UCHAR SecurityRequired : 1;
				UCHAR MaintainHandleCount : 1;
				UCHAR MaintainTypeList : 1;
				UCHAR SupportsObjectCallbacks : 1;
				UCHAR CacheAligned : 1;
			};
		};
		ULONG ObjectTypeCode;
		ULONG InvalidAttributes;
		GENERIC_MAPPING GenericMapping;
		ULONG ValidAccessMask;
		ULONG RetainAccess;
		POOL_TYPE PoolType;
		ULONG DefaultPagedPoolCharge;
		ULONG DefaultNonPagedPoolCharge;
		PVOID DumpProcedure;
		PVOID OpenProcedure;
		PVOID CloseProcedure;
		PVOID DeleteProcedure;
		PVOID ParseProcedure;
		PVOID SecurityProcedure;
		PVOID QueryNameProcedure;
		PVOID OkayToCloseProcedure;
		ULONG WaitObjectFlagMask;
		USHORT WaitObjectFlagOffset;
		USHORT WaitObjectPointerOffset;
	} OBJECT_TYPE_INITIALIZER_8, * POBJECT_TYPE_INITIALIZER_8;

	//
	// Windows 10 RS1, new ObjectTypeFlags2 flag added, 
	// ParseProcedure now has two variants with different parameters.
	//
	typedef struct _OBJECT_TYPE_INITIALIZER_RS1 {
		USHORT Length;
		union
		{
			UCHAR ObjectTypeFlags;
			struct
			{
				UCHAR CaseInsensitive : 1;
				UCHAR UnnamedObjectsOnly : 1;
				UCHAR UseDefaultObject : 1;
				UCHAR SecurityRequired : 1;
				UCHAR MaintainHandleCount : 1;
				UCHAR MaintainTypeList : 1;
				UCHAR SupportsObjectCallbacks : 1;
				UCHAR CacheAligned : 1;
			};
		};
		union
		{
			UCHAR ObjectTypeFlags2; //for ParseProcedureEx
			struct
			{
				UCHAR UseExtendedParameters : 1;
				UCHAR Reserved : 7;
			};
		};
		ULONG ObjectTypeCode;
		ULONG InvalidAttributes;
		GENERIC_MAPPING GenericMapping;
		ULONG ValidAccessMask;
		ULONG RetainAccess;
		POOL_TYPE PoolType;
		ULONG DefaultPagedPoolCharge;
		ULONG DefaultNonPagedPoolCharge;
		PVOID DumpProcedure;
		PVOID OpenProcedure;
		PVOID CloseProcedure;
		PVOID DeleteProcedure;
		union {
			PVOID ParseProcedure;
			PVOID ParseProcedureEx;
		};
		PVOID SecurityProcedure;
		PVOID QueryNameProcedure;
		PVOID OkayToCloseProcedure;
		ULONG WaitObjectFlagMask;
		USHORT WaitObjectFlagOffset;
		USHORT WaitObjectPointerOffset;
	} OBJECT_TYPE_INITIALIZER_RS1, * POBJECT_TYPE_INITIALIZER_RS1;

	//
	// ObjectTypeFlags2 moved to extended to USHORT ObjectTypeFlags field.
	// It was that hard to do this since beginning?
	//
	typedef struct _OBJECT_TYPE_INITIALIZER_RS2 {
		USHORT Length;
		union
		{
			USHORT ObjectTypeFlags;
			struct
			{
				UCHAR CaseInsensitive : 1;
				UCHAR UnnamedObjectsOnly : 1;
				UCHAR UseDefaultObject : 1;
				UCHAR SecurityRequired : 1;
				UCHAR MaintainHandleCount : 1;
				UCHAR MaintainTypeList : 1;
				UCHAR SupportsObjectCallbacks : 1;
				UCHAR CacheAligned : 1;
			};
			struct
			{
				UCHAR UseExtendedParameters : 1;//for ParseProcedureEx
				UCHAR Reserved : 7;
			};
		};
		ULONG ObjectTypeCode;
		ULONG InvalidAttributes;
		GENERIC_MAPPING GenericMapping;
		ULONG ValidAccessMask;
		ULONG RetainAccess;
		POOL_TYPE PoolType;
		ULONG DefaultPagedPoolCharge;
		ULONG DefaultNonPagedPoolCharge;
		PVOID DumpProcedure;
		PVOID OpenProcedure;
		PVOID CloseProcedure;
		PVOID DeleteProcedure;
		union {
			PVOID ParseProcedure;
			PVOID ParseProcedureEx;
		};
		PVOID SecurityProcedure;
		PVOID QueryNameProcedure;
		PVOID OkayToCloseProcedure;
		ULONG WaitObjectFlagMask;
		USHORT WaitObjectFlagOffset;
		USHORT WaitObjectPointerOffset;
	} OBJECT_TYPE_INITIALIZER_RS2, * POBJECT_TYPE_INITIALIZER_RS2;

	//
	// OBJECT_TYPE definition vary only because of OBJECT_TYPE_INITIALIZER changes.
	//
	typedef struct _OBJECT_TYPE_7 {
		LIST_ENTRY TypeList;
		UNICODE_STRING Name;
		PVOID DefaultObject;
		UCHAR Index;
		ULONG TotalNumberOfObjects;
		ULONG TotalNumberOfHandles;
		ULONG HighWaterNumberOfObjects;
		ULONG HighWaterNumberOfHandles;
		OBJECT_TYPE_INITIALIZER_7 TypeInfo;
		EX_PUSH_LOCK TypeLock;
		ULONG Key;
		LIST_ENTRY CallbackList;
	} OBJECT_TYPE_7, POBJECT_TYPE_7;

	typedef struct _OBJECT_TYPE_8 {
		LIST_ENTRY TypeList;
		UNICODE_STRING Name;
		PVOID DefaultObject;
		UCHAR Index;
		ULONG TotalNumberOfObjects;
		ULONG TotalNumberOfHandles;
		ULONG HighWaterNumberOfObjects;
		ULONG HighWaterNumberOfHandles;
		OBJECT_TYPE_INITIALIZER_8 TypeInfo;
		EX_PUSH_LOCK TypeLock;
		ULONG Key;
		LIST_ENTRY CallbackList;
	} OBJECT_TYPE_8, POBJECT_TYPE_8;

	typedef struct _OBJECT_TYPE_RS1 {
		LIST_ENTRY TypeList;
		UNICODE_STRING Name;
		PVOID DefaultObject;
		UCHAR Index;
		ULONG TotalNumberOfObjects;
		ULONG TotalNumberOfHandles;
		ULONG HighWaterNumberOfObjects;
		ULONG HighWaterNumberOfHandles;
		OBJECT_TYPE_INITIALIZER_RS1 TypeInfo;
		EX_PUSH_LOCK TypeLock;
		ULONG Key;
		LIST_ENTRY CallbackList;
	} OBJECT_TYPE_RS1, POBJECT_TYPE_RS1;

	typedef struct _OBJECT_TYPE_RS2 {
		LIST_ENTRY TypeList;
		UNICODE_STRING Name;
		PVOID DefaultObject;
		UCHAR Index;
		ULONG TotalNumberOfObjects;
		ULONG TotalNumberOfHandles;
		ULONG HighWaterNumberOfObjects;
		ULONG HighWaterNumberOfHandles;
		OBJECT_TYPE_INITIALIZER_RS2 TypeInfo;
		EX_PUSH_LOCK TypeLock;
		ULONG Key;
		LIST_ENTRY CallbackList;
	} OBJECT_TYPE_RS2, POBJECT_TYPE_RS2;

	/*
	** brand new header starting from 6.1
	*/

	typedef struct _OBJECT_HEADER {
		LONG_PTR PointerCount;
		union
		{
			LONG_PTR HandleCount;
			PVOID NextToFree;
		};
		EX_PUSH_LOCK Lock;
		UCHAR TypeIndex;
		UCHAR TraceFlags;
		UCHAR InfoMask;
		UCHAR Flags;
		union
		{
			POBJECT_CREATE_INFORMATION ObjectCreateInfo;
			PVOID QuotaBlockCharged;
		};
		PVOID SecurityDescriptor;
		QUAD Body;
	} OBJECT_HEADER, * POBJECT_HEADER;

#define OBJECT_TO_OBJECT_HEADER(obj) \
    CONTAINING_RECORD( (obj), OBJECT_HEADER, Body )

	/*
	** OBJECT MANAGER END
	*/

	/*
	* WDM START
	*/
#define TIMER_TOLERABLE_DELAY_BITS      6
#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5

	typedef struct _DISPATCHER_HEADER {
		union {
			union {
				volatile LONG Lock;
				LONG LockNV;
			} DUMMYUNIONNAME;

			struct {                            // Events, Semaphores, Gates, etc.
				UCHAR Type;                     // All (accessible via KOBJECT_TYPE)
				UCHAR Signalling;
				UCHAR Size;
				UCHAR Reserved1;
			} DUMMYSTRUCTNAME;

			struct {                            // Timer
				UCHAR TimerType;
				union {
					UCHAR TimerControlFlags;
					struct {
						UCHAR Absolute : 1;
						UCHAR Wake : 1;
						UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
					} DUMMYSTRUCTNAME;
				};

				UCHAR Hand;
				union {
					UCHAR TimerMiscFlags;
					struct {

#if !defined(KENCODED_TIMER_PROCESSOR)

						UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

						UCHAR Index : 1;
						UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

						UCHAR Inserted : 1;
						volatile UCHAR Expired : 1;
					} DUMMYSTRUCTNAME;
				} DUMMYUNIONNAME;
			} DUMMYSTRUCTNAME2;

			struct {                            // Timer2
				UCHAR Timer2Type;
				union {
					UCHAR Timer2Flags;
					struct {
						UCHAR Timer2Inserted : 1;
						UCHAR Timer2Expiring : 1;
						UCHAR Timer2CancelPending : 1;
						UCHAR Timer2SetPending : 1;
						UCHAR Timer2Running : 1;
						UCHAR Timer2Disabled : 1;
						UCHAR Timer2ReservedFlags : 2;
					} DUMMYSTRUCTNAME;
				} DUMMYUNIONNAME;

				UCHAR Timer2Reserved1;
				UCHAR Timer2Reserved2;
			} DUMMYSTRUCTNAME3;

			struct {                            // Queue
				UCHAR QueueType;
				union {
					UCHAR QueueControlFlags;
					struct {
						UCHAR Abandoned : 1;
						UCHAR DisableIncrement : 1;
						UCHAR QueueReservedControlFlags : 6;
					} DUMMYSTRUCTNAME;
				} DUMMYUNIONNAME;

				UCHAR QueueSize;
				UCHAR QueueReserved;
			} DUMMYSTRUCTNAME4;

			struct {                            // Thread
				UCHAR ThreadType;
				UCHAR ThreadReserved;
				union {
					UCHAR ThreadControlFlags;
					struct {
						UCHAR CycleProfiling : 1;
						UCHAR CounterProfiling : 1;
						UCHAR GroupScheduling : 1;
						UCHAR AffinitySet : 1;
						UCHAR ThreadReservedControlFlags : 4;
					} DUMMYSTRUCTNAME;
				} DUMMYUNIONNAME;

				union {
					UCHAR DebugActive;

#if !defined(_X86_)

					struct {
						BOOLEAN ActiveDR7 : 1;
						BOOLEAN Instrumented : 1;
						BOOLEAN Minimal : 1;
						BOOLEAN Reserved4 : 3;
						BOOLEAN UmsScheduled : 1;
						BOOLEAN UmsPrimary : 1;
					} DUMMYSTRUCTNAME;

#endif

				} DUMMYUNIONNAME2;
			} DUMMYSTRUCTNAME5;

			struct {                         // Mutant
				UCHAR MutantType;
				UCHAR MutantSize;
				BOOLEAN DpcActive;
				UCHAR MutantReserved;
			} DUMMYSTRUCTNAME6;
		} DUMMYUNIONNAME;

		LONG SignalState;                   // Object lock
		LIST_ENTRY WaitListHead;            // Object lock
	} DISPATCHER_HEADER, * PDISPATCHER_HEADER;

	typedef struct _KEVENT {
		DISPATCHER_HEADER Header;
	} KEVENT, * PKEVENT, * PRKEVENT;

	typedef struct _FAST_MUTEX {
		LONG_PTR Count;
		void* Owner;
		ULONG Contention;
		struct _KEVENT Event;
		ULONG OldIrql;
		LONG __PADDING__[1];
	} FAST_MUTEX, * PFAST_MUTEX;

	typedef struct _KMUTANT {
		DISPATCHER_HEADER Header;
		LIST_ENTRY MutantListEntry;
		struct _KTHREAD* OwnerThread;
		BOOLEAN Abandoned;
		UCHAR ApcDisable;
	} KMUTANT, * PKMUTANT, * PRKMUTANT, KMUTEX, * PKMUTEX, * PRKMUTEX;

	typedef struct _KSEMAPHORE {
		DISPATCHER_HEADER Header;
		LONG Limit;
	} KSEMAPHORE, * PKSEMAPHORE, * PRKSEMAPHORE;

	typedef struct _KTIMER {
		DISPATCHER_HEADER Header;
		ULARGE_INTEGER DueTime;
		LIST_ENTRY TimerListEntry;
		struct _KDPC* Dpc;
		ULONG Processor;
		LONG Period;
	} KTIMER, * PKTIMER, * PRKTIMER;

	typedef struct _KDEVICE_QUEUE_ENTRY {
		LIST_ENTRY DeviceListEntry;
		ULONG SortKey;
		BOOLEAN Inserted;
	} KDEVICE_QUEUE_ENTRY, * PKDEVICE_QUEUE_ENTRY, * PRKDEVICE_QUEUE_ENTRY;

	typedef enum _KDPC_IMPORTANCE {
		LowImportance,
		MediumImportance,
		HighImportance
	} KDPC_IMPORTANCE;

	typedef struct _KDPC {
		union {
			ULONG TargetInfoAsUlong;
			struct {
				UCHAR Type;
				UCHAR Importance;
				volatile USHORT Number;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;

		SINGLE_LIST_ENTRY DpcListEntry;
		KAFFINITY ProcessorHistory;
		PVOID DeferredRoutine;
		PVOID DeferredContext;
		PVOID SystemArgument1;
		PVOID SystemArgument2;
		__volatile PVOID DpcData;
	} KDPC, * PKDPC, * PRKDPC;

	typedef struct _WAIT_CONTEXT_BLOCK {
		union {
			KDEVICE_QUEUE_ENTRY WaitQueueEntry;
			struct {
				LIST_ENTRY DmaWaitEntry;
				ULONG NumberOfChannels;
				ULONG SyncCallback : 1;
				ULONG DmaContext : 1;
				ULONG Reserved : 30;
			};
		};
		PVOID DeviceRoutine;
		PVOID DeviceContext;
		ULONG NumberOfMapRegisters;
		PVOID DeviceObject;
		PVOID CurrentIrp;
		PKDPC BufferChainingDpc;
	} WAIT_CONTEXT_BLOCK, * PWAIT_CONTEXT_BLOCK;

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

	typedef struct _VPB {
		CSHORT Type;
		CSHORT Size;
		USHORT Flags;
		USHORT VolumeLabelLength; // in bytes
		struct _DEVICE_OBJECT* DeviceObject;
		struct _DEVICE_OBJECT* RealDevice;
		ULONG SerialNumber;
		ULONG ReferenceCount;
		WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
	} VPB, * PVPB;

	typedef struct _KQUEUE {
		DISPATCHER_HEADER Header;
		LIST_ENTRY EntryListHead;
		ULONG CurrentCount;
		ULONG MaximumCount;
		LIST_ENTRY ThreadListHead;
	} KQUEUE, * PKQUEUE;

	typedef struct _KDEVICE_QUEUE {
		CSHORT Type;
		CSHORT Size;
		LIST_ENTRY DeviceListHead;
		KSPIN_LOCK Lock;

#if defined(_AMD64_)

		union {
			BOOLEAN Busy;
			struct {
				LONG64 Reserved : 8;
				LONG64 Hint : 56;
			};
		};

#else

		BOOLEAN Busy;

#endif

	} KDEVICE_QUEUE, * PKDEVICE_QUEUE, * PRKDEVICE_QUEUE;

	enum _KOBJECTS {
		EventNotificationObject = 0x0,
		EventSynchronizationObject = 0x1,
		MutantObject = 0x2,
		ProcessObject = 0x3,
		QueueObject = 0x4,
		SemaphoreObject = 0x5,
		ThreadObject = 0x6,
		GateObject = 0x7,
		TimerNotificationObject = 0x8,
		TimerSynchronizationObject = 0x9,
		Spare2Object = 0xa,
		Spare3Object = 0xb,
		Spare4Object = 0xc,
		Spare5Object = 0xd,
		Spare6Object = 0xe,
		Spare7Object = 0xf,
		Spare8Object = 0x10,
		Spare9Object = 0x11,
		ApcObject = 0x12,
		DpcObject = 0x13,
		DeviceQueueObject = 0x14,
		EventPairObject = 0x15,
		InterruptObject = 0x16,
		ProfileObject = 0x17,
		ThreadedDpcObject = 0x18,
		MaximumKernelObject = 0x19,
	};

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs wdm
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000

#define FILE_REMOVABLE_MEDIA                        0x00000001
#define FILE_READ_ONLY_DEVICE                       0x00000002
#define FILE_FLOPPY_DISKETTE                        0x00000004
#define FILE_WRITE_ONCE_MEDIA                       0x00000008
#define FILE_REMOTE_DEVICE                          0x00000010
#define FILE_DEVICE_IS_MOUNTED                      0x00000020
#define FILE_VIRTUAL_VOLUME                         0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME              0x00000080
#define FILE_DEVICE_SECURE_OPEN                     0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE              0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE               0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE           0x00002000
#define FILE_CHARACTERISTIC_CSV                     0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL    0x00020000
#define FILE_PORTABLE_DEVICE                        0x00040000

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041
#define FILE_DEVICE_MT_COMPOSITE        0x00000042
#define FILE_DEVICE_MT_TRANSPORT        0x00000043
#define FILE_DEVICE_BIOMETRIC           0x00000044
#define FILE_DEVICE_PMI                 0x00000045
#define FILE_DEVICE_EHSTOR              0x00000046
#define FILE_DEVICE_DEVAPI              0x00000047
#define FILE_DEVICE_GPIO                0x00000048
#define FILE_DEVICE_USBEX               0x00000049
#define FILE_DEVICE_CONSOLE             0x00000050
#define FILE_DEVICE_NFP                 0x00000051
#define FILE_DEVICE_SYSENV              0x00000052
#define FILE_DEVICE_VIRTUAL_BLOCK       0x00000053
#define FILE_DEVICE_POINT_OF_SERVICE    0x00000054

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

#define DPC_NORMAL 0
#define DPC_THREADED 1

	typedef struct _DEVICE_OBJECT {
		CSHORT                      Type;
		USHORT                      Size;
		LONG                        ReferenceCount;
		struct _DRIVER_OBJECT* DriverObject;
		struct _DEVICE_OBJECT* NextDevice;
		struct _DEVICE_OBJECT* AttachedDevice;
		struct _IRP* CurrentIrp;
		PVOID		                Timer;
		ULONG                       Flags;
		ULONG                       Characteristics;
		__volatile PVPB             Vpb;
		PVOID                       DeviceExtension;
		DEVICE_TYPE                 DeviceType;
		CCHAR                       StackSize;
		union {
			LIST_ENTRY         ListEntry;
			WAIT_CONTEXT_BLOCK Wcb;
		} Queue;
		ULONG                       AlignmentRequirement;
		KDEVICE_QUEUE               DeviceQueue;
		KDPC                        Dpc;
		ULONG                       ActiveThreadCount;
		PSECURITY_DESCRIPTOR        SecurityDescriptor;
		KEVENT                      DeviceLock;
		USHORT                      SectorSize;
		USHORT                      Spare1;
		struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
		PVOID                       Reserved;
	} DEVICE_OBJECT, * PDEVICE_OBJECT;

	typedef struct _DEVOBJ_EXTENSION {

		CSHORT          Type;
		USHORT          Size;

		//
		// Public part of the DeviceObjectExtension structure
		//

		PDEVICE_OBJECT  DeviceObject;               // owning device object

		// end_ntddk end_nthal end_ntifs end_wdm end_ntosp

		//
		// Universal Power Data - all device objects must have this
		//

		ULONG           PowerFlags;             // see ntos\po\pop.h
		// WARNING: Access via PO macros
		// and with PO locking rules ONLY.

		//
		// Pointer to the non-universal power data
		//  Power data that only some device objects need is stored in the
		//  device object power extension -> DOPE
		//  see po.h
		//

		struct          _DEVICE_OBJECT_POWER_EXTENSION* Dope;

		//
		// power state information
		//

		//
		// Device object extension flags.  Protected by the IopDatabaseLock.
		//

		ULONG ExtensionFlags;

		//
		// PnP manager fields
		//

		PVOID           DeviceNode;

		//
		// AttachedTo is a pointer to the device object that this device
		// object is attached to.  The attachment chain is now doubly
		// linked: this pointer and DeviceObject->AttachedDevice provide the
		// linkage.
		//

		PDEVICE_OBJECT  AttachedTo;

		//
		// The next two fields are used to prevent recursion in IoStartNextPacket
		// interfaces.
		//

		LONG           StartIoCount;       // Used to keep track of number of pending start ios.
		LONG           StartIoKey;         // Next startio key
		ULONG          StartIoFlags;       // Start Io Flags. Need a separate flag so that it can be accessed without locks
		PVPB           Vpb;                // If not NULL contains the VPB of the mounted volume.
		// Set in the filesystem's volume device object.
		// This is a reverse VPB pointer.

		// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

	} DEVOBJ_EXTENSION, * PDEVOBJ_EXTENSION;

	typedef struct _FAST_IO_DISPATCH {
		ULONG SizeOfFastIoDispatch;
		PVOID FastIoCheckIfPossible;
		PVOID FastIoRead;
		PVOID FastIoWrite;
		PVOID FastIoQueryBasicInfo;
		PVOID FastIoQueryStandardInfo;
		PVOID FastIoLock;
		PVOID FastIoUnlockSingle;
		PVOID FastIoUnlockAll;
		PVOID FastIoUnlockAllByKey;
		PVOID FastIoDeviceControl;
		PVOID AcquireFileForNtCreateSection;
		PVOID ReleaseFileForNtCreateSection;
		PVOID FastIoDetachDevice;
		PVOID FastIoQueryNetworkOpenInfo;
		PVOID AcquireForModWrite;
		PVOID MdlRead;
		PVOID MdlReadComplete;
		PVOID PrepareMdlWrite;
		PVOID MdlWriteComplete;
		PVOID FastIoReadCompressed;
		PVOID FastIoWriteCompressed;
		PVOID MdlReadCompleteCompressed;
		PVOID MdlWriteCompleteCompressed;
		PVOID FastIoQueryOpen;
		PVOID ReleaseForModWrite;
		PVOID AcquireForCcFlush;
		PVOID ReleaseForCcFlush;
	} FAST_IO_DISPATCH, * PFAST_IO_DISPATCH;

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

	typedef struct _DRIVER_EXTENSION {

		//
		// Back pointer to Driver Object
		//

		struct _DRIVER_OBJECT* DriverObject;

		//
		// The AddDevice entry point is called by the Plug & Play manager
		// to inform the driver when a new device instance arrives that this
		// driver must control.
		//

		PVOID AddDevice;

		//
		// The count field is used to count the number of times the driver has
		// had its registered reinitialization routine invoked.
		//

		ULONG Count;

		//
		// The service name field is used by the pnp manager to determine
		// where the driver related info is stored in the registry.
		//

		UNICODE_STRING ServiceKeyName;

	} DRIVER_EXTENSION, * PDRIVER_EXTENSION;

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
	// end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER     0x00000080   // A driver that is at the bottom of the filesystem stack.
// begin_ntddk begin_nthal begin_ntifs begin_ntosp

	typedef struct _DRIVER_OBJECT {
		CSHORT Type;
		CSHORT Size;

		//
		// The following links all of the devices created by a single driver
		// together on a list, and the Flags word provides an extensible flag
		// location for driver objects.
		//

		PDEVICE_OBJECT DeviceObject;
		ULONG Flags;

		//
		// The following section describes where the driver is loaded.  The count
		// field is used to count the number of times the driver has had its
		// registered reinitialization routine invoked.
		//

		PVOID DriverStart;
		ULONG DriverSize;
		PVOID DriverSection; //PLDR_DATA_TABLE_ENTRY
		PDRIVER_EXTENSION DriverExtension;

		//
		// The driver name field is used by the error log thread
		// determine the name of the driver that an I/O request is/was bound.
		//

		UNICODE_STRING DriverName;

		//
		// The following section is for registry support.  Thise is a pointer
		// to the path to the hardware information in the registry
		//

		PUNICODE_STRING HardwareDatabase;

		//
		// The following section contains the optional pointer to an array of
		// alternate entry points to a driver for "fast I/O" support.  Fast I/O
		// is performed by invoking the driver routine directly with separate
		// parameters, rather than using the standard IRP call mechanism.  Note
		// that these functions may only be used for synchronous I/O, and when
		// the file is cached.
		//

		PFAST_IO_DISPATCH FastIoDispatch;

		//
		// The following section describes the entry points to this particular
		// driver.  Note that the major function dispatch table must be the last
		// field in the object so that it remains extensible.
		//

		PVOID DriverInit;
		PVOID DriverStartIo;
		PVOID DriverUnload;
		PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

	} DRIVER_OBJECT;
	typedef struct _DRIVER_OBJECT* PDRIVER_OBJECT;

#define RESOURCE_TYPE_LEVEL     0
#define RESOURCE_NAME_LEVEL     1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL     3

	typedef struct _LDR_RESOURCE_INFO {
		ULONG_PTR Type;
		ULONG_PTR Name;
		ULONG Lang;
	} LDR_RESOURCE_INFO, * PLDR_RESOURCE_INFO;

	typedef struct _LDR_DATA_TABLE_ENTRY_COMPATIBLE {
		LIST_ENTRY InLoadOrderLinks;
		LIST_ENTRY InMemoryOrderLinks;
		union
		{
			LIST_ENTRY InInitializationOrderLinks;
			LIST_ENTRY InProgressLinks;
		} DUMMYUNION0;
		PVOID DllBase;
		PVOID EntryPoint;
		ULONG SizeOfImage;
		UNICODE_STRING FullDllName;
		UNICODE_STRING BaseDllName;
		union
		{
			ULONG Flags;
			struct
			{
				ULONG PackagedBinary : 1; // Size=4 Offset=104 BitOffset=0 BitCount=1
				ULONG MarkedForRemoval : 1; // Size=4 Offset=104 BitOffset=1 BitCount=1
				ULONG ImageDll : 1; // Size=4 Offset=104 BitOffset=2 BitCount=1
				ULONG LoadNotificationsSent : 1; // Size=4 Offset=104 BitOffset=3 BitCount=1
				ULONG TelemetryEntryProcessed : 1; // Size=4 Offset=104 BitOffset=4 BitCount=1
				ULONG ProcessStaticImport : 1; // Size=4 Offset=104 BitOffset=5 BitCount=1
				ULONG InLegacyLists : 1; // Size=4 Offset=104 BitOffset=6 BitCount=1
				ULONG InIndexes : 1; // Size=4 Offset=104 BitOffset=7 BitCount=1
				ULONG ShimDll : 1; // Size=4 Offset=104 BitOffset=8 BitCount=1
				ULONG InExceptionTable : 1; // Size=4 Offset=104 BitOffset=9 BitCount=1
				ULONG ReservedFlags1 : 2; // Size=4 Offset=104 BitOffset=10 BitCount=2
				ULONG LoadInProgress : 1; // Size=4 Offset=104 BitOffset=12 BitCount=1
				ULONG LoadConfigProcessed : 1; // Size=4 Offset=104 BitOffset=13 BitCount=1
				ULONG EntryProcessed : 1; // Size=4 Offset=104 BitOffset=14 BitCount=1
				ULONG ProtectDelayLoad : 1; // Size=4 Offset=104 BitOffset=15 BitCount=1
				ULONG ReservedFlags3 : 2; // Size=4 Offset=104 BitOffset=16 BitCount=2
				ULONG DontCallForThreads : 1; // Size=4 Offset=104 BitOffset=18 BitCount=1
				ULONG ProcessAttachCalled : 1; // Size=4 Offset=104 BitOffset=19 BitCount=1
				ULONG ProcessAttachFailed : 1; // Size=4 Offset=104 BitOffset=20 BitCount=1
				ULONG CorDeferredValidate : 1; // Size=4 Offset=104 BitOffset=21 BitCount=1
				ULONG CorImage : 1; // Size=4 Offset=104 BitOffset=22 BitCount=1
				ULONG DontRelocate : 1; // Size=4 Offset=104 BitOffset=23 BitCount=1
				ULONG CorILOnly : 1; // Size=4 Offset=104 BitOffset=24 BitCount=1
				ULONG ChpeImage : 1; // Size=4 Offset=104 BitOffset=25 BitCount=1
				ULONG ReservedFlags5 : 2; // Size=4 Offset=104 BitOffset=26 BitCount=2
				ULONG Redirected : 1; // Size=4 Offset=104 BitOffset=28 BitCount=1
				ULONG ReservedFlags6 : 2; // Size=4 Offset=104 BitOffset=29 BitCount=2
				ULONG CompatDatabaseProcessed : 1; // Size=4 Offset=104 BitOffset=31 BitCount=1
			};
		} ENTRYFLAGSUNION;
		WORD ObsoleteLoadCount;
		WORD TlsIndex;
		union
		{
			LIST_ENTRY HashLinks;
			struct
			{
				PVOID SectionPointer;
				ULONG CheckSum;
			};
		} DUMMYUNION1;
		union
		{
			ULONG TimeDateStamp;
			PVOID LoadedImports;
		} DUMMYUNION2;
		//fields below removed for compatibility
	} LDR_DATA_TABLE_ENTRY_COMPATIBLE, * PLDR_DATA_TABLE_ENTRY_COMPATIBLE;
	typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE LDR_DATA_TABLE_ENTRY;
	typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE* PLDR_DATA_TABLE_ENTRY;
	typedef LDR_DATA_TABLE_ENTRY* PCLDR_DATA_TABLE_ENTRY;

	typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
		ULONG Flags;                    //Reserved.
		PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
		PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
		PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
		ULONG SizeOfImage;              //The size of the DLL image, in bytes.
	} LDR_DLL_LOADED_NOTIFICATION_DATA, * PLDR_DLL_LOADED_NOTIFICATION_DATA;

	typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
		ULONG Flags;                    //Reserved.
		PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
		PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
		PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
		ULONG SizeOfImage;              //The size of the DLL image, in bytes.
	} LDR_DLL_UNLOADED_NOTIFICATION_DATA, * PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

	typedef union _LDR_DLL_NOTIFICATION_DATA {
		LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
		LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
	} LDR_DLL_NOTIFICATION_DATA, * PLDR_DLL_NOTIFICATION_DATA;
	typedef const LDR_DLL_NOTIFICATION_DATA* PCLDR_DLL_NOTIFICATION_DATA;

#define LDR_DLL_NOTIFICATION_REASON_LOADED   1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

	typedef enum _LDR_DLL_LOAD_REASON {
		LoadReasonStaticDependency,
		LoadReasonStaticForwarderDependency,
		LoadReasonDynamicForwarderDependency,
		LoadReasonDelayloadDependency,
		LoadReasonDynamicLoad,
		LoadReasonAsImageLoad,
		LoadReasonAsDataLoad,
		LoadReasonEnclavePrimary,
		LoadReasonEnclaveDependency,
		LoadReasonUnknown = -1
	} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

	/*
	* WDM END
	*/


	/*
	** Callbacks START
	*/

	typedef struct _EX_CALLBACK {
		EX_FAST_REF RoutineBlock;
	} EX_CALLBACK, * PEX_CALLBACK;

	typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
		EX_RUNDOWN_REF RundownProtect;
		PVOID Function; //PEX_CALLBACK_FUNCTION
		PVOID Context;
	} EX_CALLBACK_ROUTINE_BLOCK, * PEX_CALLBACK_ROUTINE_BLOCK;

	typedef struct _KBUGCHECK_CALLBACK_RECORD {
		LIST_ENTRY Entry;
		PVOID CallbackRoutine;
		PVOID Buffer;
		ULONG Length;
		PUCHAR Component;
		ULONG_PTR Checksum;
		UCHAR State;
	} KBUGCHECK_CALLBACK_RECORD, * PKBUGCHECK_CALLBACK_RECORD;

	typedef enum _KBUGCHECK_CALLBACK_REASON {
		KbCallbackInvalid,
		KbCallbackReserved1,
		KbCallbackSecondaryDumpData,
		KbCallbackDumpIo,
		KbCallbackAddPages,
		KbCallbackSecondaryMultiPartDumpData,
		KbCallbackRemovePages,
		KbCallbackTriageDumpData
	} KBUGCHECK_CALLBACK_REASON;

	typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
		LIST_ENTRY Entry;
		PVOID CallbackRoutine;
		PUCHAR Component;
		ULONG_PTR Checksum;
		KBUGCHECK_CALLBACK_REASON Reason;
		UCHAR State;
	} KBUGCHECK_REASON_CALLBACK_RECORD, * PKBUGCHECK_REASON_CALLBACK_RECORD;

	typedef struct _CM_CALLBACK_CONTEXT_BLOCK {
		LIST_ENTRY CallbackListEntry;
		LIST_ENTRY PreCallListHead;
		PVOID Unknown1;
		PVOID Function; //PEX_CALLBACK_FUNCTION
		UNICODE_STRING Altitude;
		LIST_ENTRY ObjectContextListHead;
	} CM_CALLBACK_CONTEXT_BLOCK, * PCM_CALLBACK_CONTEXT_BLOCK;

	typedef struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION {
		struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION* Next;
		PVOID CallbackRoutine; //PSE_LOGON_SESSION_TERMINATED_ROUTINE
	} SEP_LOGON_SESSION_TERMINATED_NOTIFICATION, * PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION;

	typedef struct _NOTIFICATION_PACKET {
		LIST_ENTRY ListEntry;
		PVOID DriverObject; //PDRIVER_OBJECT
		PVOID NotificationRoutine; //PDRIVER_FS_NOTIFICATION
	} NOTIFICATION_PACKET, * PNOTIFICATION_PACKET;

	typedef struct _SHUTDOWN_PACKET {
		LIST_ENTRY ListEntry;
		PVOID DeviceObject; //PDEVICE_OBJECT
	} SHUTDOWN_PACKET, * PSHUTDOWN_PACKET;

#define EX_CALLBACK_SIGNATURE 'llaC'

	typedef struct _CALLBACK_OBJECT {
		ULONG Signature;
		KSPIN_LOCK Lock;
		LIST_ENTRY RegisteredCallbacks;
		BOOLEAN AllowMultipleCallbacks;
		UCHAR reserved[3];
	} CALLBACK_OBJECT, * PCALLBACK_OBJECT;

	typedef struct _CALLBACK_REGISTRATION {
		LIST_ENTRY Link;
		PCALLBACK_OBJECT CallbackObject;
		PVOID CallbackFunction; //PCALLBACK_FUNCTION
		PVOID CallbackContext;
		ULONG Busy;
		BOOLEAN UnregisterWaiting;
	} CALLBACK_REGISTRATION, * PCALLBACK_REGISTRATION;

	typedef ULONG OB_OPERATION;

	typedef struct _OB_CALLBACK_CONTEXT_BLOCK {
		LIST_ENTRY CallbackListEntry;
		OB_OPERATION Operations;
		ULONG Flags;
		PVOID Registration; //POB_CALLBACK_REGISTRATION
		POBJECT_TYPE ObjectType;
		PVOID PreCallback; //POB_PRE_OPERATION_CALLBACK
		PVOID PostCallback; //POB_POST_OPERATION_CALLBACK
		EX_RUNDOWN_REF RundownReference;
	} OB_CALLBACK_CONTEXT_BLOCK, * POB_CALLBACK_CONTEXT_BLOCK;

	typedef struct _OB_OPERATION_REGISTRATION {
		PVOID* ObjectType;
		OB_OPERATION Operations;
		PVOID  PreOperation;
		PVOID PostOperation;
	} OB_OPERATION_REGISTRATION, * POB_OPERATION_REGISTRATION;

	typedef struct _OB_CALLBACK_REGISTRATION {
		USHORT                    Version;
		USHORT                    OperationRegistrationCount;
		UNICODE_STRING            Altitude;
		PVOID                     RegistrationContext;
		OB_OPERATION_REGISTRATION* OperationRegistration;
	} OB_CALLBACK_REGISTRATION, * POB_CALLBACK_REGISTRATION;

#define PO_POWER_SETTINGS_REGISTRATION_TAG 'teSP'

	typedef struct _POP_POWER_SETTING_REGISTRATION_V1 {
		LIST_ENTRY Link;
		ULONG Tag;
		PVOID CallbackThread; //PKTHREAD
		UCHAR UnregisterOnReturn;
		UCHAR UnregisterPending;
		GUID Guid;
		PVOID LastValue; //PPOP_POWER_SETTING_VALUE
		PVOID Callback;
		PVOID Context;
		PDEVICE_OBJECT DeviceObject;
	} POP_POWER_SETTING_REGISTRATION_V1, * PPOP_POWER_SETTING_REGISTRATION_V1;

	//
	// WARNING: this structure definition is incomplete. 
	// Tail is incorrect/incomplete for newest Win10 versions.
	//
	typedef struct _POP_POWER_SETTING_REGISTRATION_V2 {
		LIST_ENTRY Link;
		ULONG Tag;
		PVOID CallbackThread; //PKTHREAD   
		UCHAR UnregisterOnReturn;
		UCHAR UnregisterPending;
		GUID Guid;
		GUID Guid2;
		PVOID LastValue; //PPOP_POWER_SETTING_VALUE
		PVOID Callback;
		PVOID Context;
		PDEVICE_OBJECT DeviceObject;
	} POP_POWER_SETTING_REGISTRATION_V2, * PPOP_POWER_SETTING_REGISTRATION_V2;

	typedef struct _RTL_CALLBACK_REGISTER {
		ULONG Flags;
		EX_RUNDOWN_REF RundownReference;
		PVOID DebugPrintCallback;
		LIST_ENTRY ListEntry;
	} RTL_CALLBACK_REGISTER, * PRTL_CALLBACK_REGISTER;

	/*
	** Callbacks END
	*/

	/*
	*  NTQSI Modules START
	*/

	typedef struct _RTL_PROCESS_MODULE_INFORMATION {
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];
	} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

	typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX {
		USHORT NextOffset;
		RTL_PROCESS_MODULE_INFORMATION BaseInfo;
		ULONG ImageChecksum;
		ULONG TimeDateStamp;
		PVOID DefaultBase;
	} RTL_PROCESS_MODULE_INFORMATION_EX, * PRTL_PROCESS_MODULE_INFORMATION_EX;

	typedef struct _RTL_PROCESS_MODULES {
		ULONG NumberOfModules;
		RTL_PROCESS_MODULE_INFORMATION Modules[1];
	} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

	/*
	*	NTQSI Modules END
	*/

	/*
	** Virtual Memory START
	*/

	typedef enum _MEMORY_INFORMATION_CLASS {
		MemoryBasicInformation,
		MemoryWorkingSetInformation,
		MemoryMappedFilenameInformation,
		MemoryRegionInformation,
		MemoryWorkingSetExInformation,
		MemorySharedCommitInformation,
		MemoryImageInformation,
		MemoryRegionInformationEx,
		MemoryPrivilegedBasicInformation,
		MemoryEnclaveImageInformation,
		MemoryBasicInformationCapped
	} MEMORY_INFORMATION_CLASS, * PMEMORY_INFORMATION_CLASS;

	typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS {
		VmPrefetchInformation,
		VmPagePriorityInformation,
		VmCfgCallTargetInformation,
		VmPageDirtyStateInformation
	} VIRTUAL_MEMORY_INFORMATION_CLASS;

	typedef struct _MEMORY_REGION_INFORMATION {
		PVOID AllocationBase;
		ULONG AllocationProtect;
		union
		{
			ULONG RegionType;
			struct
			{
				ULONG Private : 1;
				ULONG MappedDataFile : 1;
				ULONG MappedImage : 1;
				ULONG MappedPageFile : 1;
				ULONG MappedPhysical : 1;
				ULONG DirectMapped : 1;
				ULONG SoftwareEnclave : 1;
				ULONG PageSize64K : 1;
				ULONG Reserved : 24;
			};
		};
		SIZE_T RegionSize;
		//SIZE_T CommitSize;
	} MEMORY_REGION_INFORMATION, * PMEMORY_REGION_INFORMATION;

	typedef struct _MEMORY_RANGE_ENTRY {
		PVOID VirtualAddress;
		SIZE_T NumberOfBytes;
	} MEMORY_RANGE_ENTRY, * PMEMORY_RANGE_ENTRY;

	/*
	** Virtual Memory END
	*/

	/*
	** System Firmware START
	*/

	typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION {
		SystemFirmwareTable_Enumerate,
		SystemFirmwareTable_Get,
		SystemFirmwareTableMax
	} SYSTEM_FIRMWARE_TABLE_ACTION, * PSYSTEM_FIRMWARE_TABLE_ACTION;

	typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
		ULONG ProviderSignature;
		SYSTEM_FIRMWARE_TABLE_ACTION Action;
		ULONG TableID;
		ULONG TableBufferLength;
		UCHAR TableBuffer[ANYSIZE_ARRAY];
	} SYSTEM_FIRMWARE_TABLE_INFORMATION, * PSYSTEM_FIRMWARE_TABLE_INFORMATION;

	/*
	** System Firmware END
	*/

	//
	//  PEB/TEB
	//
#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

	typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
	typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
	typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

#define GDI_MAX_HANDLE_COUNT 0x4000

	// 32-bit definitions
	typedef struct _STRING32 {
		USHORT Length;
		USHORT MaximumLength;
		ULONG Buffer;
	} STRING32;
	typedef STRING32* PSTRING32;

	typedef STRING32 UNICODE_STRING32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
	typedef struct LIST_ENTRY32 {
		DWORD Flink;
		DWORD Blink;
	} LIST_ENTRY32;
	typedef LIST_ENTRY32* PLIST_ENTRY32;

	typedef struct LIST_ENTRY64 {
		ULONGLONG Flink;
		ULONGLONG Blink;
	} LIST_ENTRY64;
	typedef LIST_ENTRY64* PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

	typedef struct _PEB_LDR_DATA32 {
		ULONG Length;
		BOOLEAN Initialized;
		WOW64_POINTER(HANDLE) SsHandle;
		LIST_ENTRY32 InLoadOrderModuleList;
		LIST_ENTRY32 InMemoryOrderModuleList;
		LIST_ENTRY32 InInitializationOrderModuleList;
		WOW64_POINTER(PVOID) EntryInProgress;
		BOOLEAN ShutdownInProgress;
		WOW64_POINTER(HANDLE) ShutdownThreadId;
	} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET( LDR_DATA_TABLE_ENTRY32, ForwarderLinks )

	typedef struct _LDR_DATA_TABLE_ENTRY32 {
		LIST_ENTRY32 InLoadOrderLinks;
		LIST_ENTRY32 InMemoryOrderLinks;
		LIST_ENTRY32 InInitializationOrderLinks;
		WOW64_POINTER(PVOID) DllBase;
		WOW64_POINTER(PVOID) EntryPoint;
		ULONG SizeOfImage;
		UNICODE_STRING32 FullDllName;
		UNICODE_STRING32 BaseDllName;
		ULONG Flags;
		USHORT LoadCount;
		USHORT TlsIndex;
		union
		{
			LIST_ENTRY32 HashLinks;
			struct
			{
				WOW64_POINTER(PVOID) SectionPointer;
				ULONG CheckSum;
			};
		};
		union
		{
			ULONG TimeDateStamp;
			WOW64_POINTER(PVOID) LoadedImports;
		};
		WOW64_POINTER(PVOID) EntryPointActivationContext;
		WOW64_POINTER(PVOID) PatchInformation;
		LIST_ENTRY32 ForwarderLinks;
		LIST_ENTRY32 ServiceTagLinks;
		LIST_ENTRY32 StaticLinks;
		WOW64_POINTER(PVOID) ContextInformation;
		WOW64_POINTER(ULONG_PTR) OriginalBase;
		LARGE_INTEGER LoadTime;
	} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

	typedef struct _CURDIR32 {
		UNICODE_STRING32 DosPath;
		WOW64_POINTER(HANDLE) Handle;
	} CURDIR32, * PCURDIR32;

	typedef struct _RTL_DRIVE_LETTER_CURDIR32 {
		USHORT Flags;
		USHORT Length;
		ULONG TimeStamp;
		STRING32 DosPath;
	} RTL_DRIVE_LETTER_CURDIR32, * PRTL_DRIVE_LETTER_CURDIR32;

	typedef struct _RTL_USER_PROCESS_PARAMETERS32 {
		ULONG MaximumLength;
		ULONG Length;

		ULONG Flags;
		ULONG DebugFlags;

		WOW64_POINTER(HANDLE) ConsoleHandle;
		ULONG ConsoleFlags;
		WOW64_POINTER(HANDLE) StandardInput;
		WOW64_POINTER(HANDLE) StandardOutput;
		WOW64_POINTER(HANDLE) StandardError;

		CURDIR32 CurrentDirectory;
		UNICODE_STRING32 DllPath;
		UNICODE_STRING32 ImagePathName;
		UNICODE_STRING32 CommandLine;
		WOW64_POINTER(PVOID) Environment;

		ULONG StartingX;
		ULONG StartingY;
		ULONG CountX;
		ULONG CountY;
		ULONG CountCharsX;
		ULONG CountCharsY;
		ULONG FillAttribute;

		ULONG WindowFlags;
		ULONG ShowWindowFlags;
		UNICODE_STRING32 WindowTitle;
		UNICODE_STRING32 DesktopInfo;
		UNICODE_STRING32 ShellInfo;
		UNICODE_STRING32 RuntimeData;
		RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

		ULONG EnvironmentSize;
		ULONG EnvironmentVersion;
	} RTL_USER_PROCESS_PARAMETERS32, * PRTL_USER_PROCESS_PARAMETERS32;

	typedef struct _PEB32 {
		BOOLEAN InheritedAddressSpace;
		BOOLEAN ReadImageFileExecOptions;
		BOOLEAN BeingDebugged;
		union
		{
			BOOLEAN BitField;
			struct
			{
				BOOLEAN ImageUsesLargePages : 1;
				BOOLEAN IsProtectedProcess : 1;
				BOOLEAN IsLegacyProcess : 1;
				BOOLEAN IsImageDynamicallyRelocated : 1;
				BOOLEAN SkipPatchingUser32Forwarders : 1;
				BOOLEAN SpareBits : 3;
			};
		};
		WOW64_POINTER(HANDLE) Mutant;

		WOW64_POINTER(PVOID) ImageBaseAddress;
		WOW64_POINTER(PPEB_LDR_DATA) Ldr;
		WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
		WOW64_POINTER(PVOID) SubSystemData;
		WOW64_POINTER(PVOID) ProcessHeap;
		WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
		WOW64_POINTER(PVOID) AtlThunkSListPtr;
		WOW64_POINTER(PVOID) IFEOKey;
		union
		{
			ULONG CrossProcessFlags;
			struct
			{
				ULONG ProcessInJob : 1;
				ULONG ProcessInitializing : 1;
				ULONG ProcessUsingVEH : 1;
				ULONG ProcessUsingVCH : 1;
				ULONG ProcessUsingFTH : 1;
				ULONG ProcessPreviouslyThrottled : 1;
				ULONG ProcessCurrentlyThrottled : 1;
				ULONG ReservedBits0 : 25;
			};
			ULONG EnvironmentUpdateCount;
		};
		union
		{
			WOW64_POINTER(PVOID) KernelCallbackTable;
			WOW64_POINTER(PVOID) UserSharedInfoPtr;
		};
		ULONG SystemReserved[1];
		ULONG AtlThunkSListPtr32;
		WOW64_POINTER(PVOID) ApiSetMap;
		ULONG TlsExpansionCounter;
		WOW64_POINTER(PVOID) TlsBitmap;
		ULONG TlsBitmapBits[2];
		WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
		WOW64_POINTER(PVOID) HotpatchInformation;
		WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
		WOW64_POINTER(PVOID) AnsiCodePageData;
		WOW64_POINTER(PVOID) OemCodePageData;
		WOW64_POINTER(PVOID) UnicodeCaseTableData;

		ULONG NumberOfProcessors;
		ULONG NtGlobalFlag;

		LARGE_INTEGER CriticalSectionTimeout;
		WOW64_POINTER(SIZE_T) HeapSegmentReserve;
		WOW64_POINTER(SIZE_T) HeapSegmentCommit;
		WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
		WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

		ULONG NumberOfHeaps;
		ULONG MaximumNumberOfHeaps;
		WOW64_POINTER(PPVOID) ProcessHeaps;

		WOW64_POINTER(PVOID) GdiSharedHandleTable;
		WOW64_POINTER(PVOID) ProcessStarterHelper;
		ULONG GdiDCAttributeList;

		WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

		ULONG OSMajorVersion;
		ULONG OSMinorVersion;
		USHORT OSBuildNumber;
		USHORT OSCSDVersion;
		ULONG OSPlatformId;
		ULONG ImageSubsystem;
		ULONG ImageSubsystemMajorVersion;
		ULONG ImageSubsystemMinorVersion;
		WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
		GDI_HANDLE_BUFFER32 GdiHandleBuffer;
		WOW64_POINTER(PVOID) PostProcessInitRoutine;

		WOW64_POINTER(PVOID) TlsExpansionBitmap;
		ULONG TlsExpansionBitmapBits[32];

		ULONG SessionId;

		// Rest of structure not included.
	} PEB32, * PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

	typedef struct _GDI_TEB_BATCH32 {
		ULONG Offset;
		WOW64_POINTER(ULONG_PTR) HDC;
		ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
	} GDI_TEB_BATCH32, * PGDI_TEB_BATCH32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
	//
	// 32 and 64 bit specific version for wow64 and the debugger
	//
	typedef struct _NT_TIB32 {
		DWORD ExceptionList;
		DWORD StackBase;
		DWORD StackLimit;
		DWORD SubSystemTib;
		union {
			DWORD FiberData;
			DWORD Version;
		};
		DWORD ArbitraryUserPointer;
		DWORD Self;
	} NT_TIB32, * PNT_TIB32;

	typedef struct _NT_TIB64 {
		DWORD64 ExceptionList;
		DWORD64 StackBase;
		DWORD64 StackLimit;
		DWORD64 SubSystemTib;
		union {
			DWORD64 FiberData;
			DWORD Version;
		};
		DWORD64 ArbitraryUserPointer;
		DWORD64 Self;
	} NT_TIB64, * PNT_TIB64;
#endif

	typedef struct _TEB32 {
		NT_TIB32 NtTib;

		WOW64_POINTER(PVOID) EnvironmentPointer;
		CLIENT_ID32 ClientId;
		WOW64_POINTER(PVOID) ActiveRpcHandle;
		WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
		WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

		ULONG LastErrorValue;
		ULONG CountOfOwnedCriticalSections;
		WOW64_POINTER(PVOID) CsrClientThread;
		WOW64_POINTER(PVOID) Win32ThreadInfo;
		ULONG User32Reserved[26];
		ULONG UserReserved[5];
		WOW64_POINTER(PVOID) WOW32Reserved;
		LCID CurrentLocale;
		ULONG FpSoftwareStatusRegister;
		WOW64_POINTER(PVOID) SystemReserved1[54];
		NTSTATUS ExceptionCode;
		WOW64_POINTER(PVOID) ActivationContextStackPointer;
		BYTE SpareBytes[36];
		ULONG TxFsContext;

		GDI_TEB_BATCH32 GdiTebBatch;
		CLIENT_ID32 RealClientId;
		WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
		ULONG GdiClientPID;
		ULONG GdiClientTID;
		WOW64_POINTER(PVOID) GdiThreadLocalInfo;
		WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
		WOW64_POINTER(PVOID) glDispatchTable[233];
		WOW64_POINTER(ULONG_PTR) glReserved1[29];
		WOW64_POINTER(PVOID) glReserved2;
		WOW64_POINTER(PVOID) glSectionInfo;
		WOW64_POINTER(PVOID) glSection;
		WOW64_POINTER(PVOID) glTable;
		WOW64_POINTER(PVOID) glCurrentRC;
		WOW64_POINTER(PVOID) glContext;

		NTSTATUS LastStatusValue;
		UNICODE_STRING32 StaticUnicodeString;
		WCHAR StaticUnicodeBuffer[261];

		WOW64_POINTER(PVOID) DeallocationStack;
		WOW64_POINTER(PVOID) TlsSlots[64];
		LIST_ENTRY32 TlsLinks;
	} TEB32, * PTEB32;

	typedef struct _PEB_LDR_DATA {
		ULONG Length;
		BOOLEAN Initialized;
		HANDLE SsHandle;
		LIST_ENTRY InLoadOrderModuleList;
		LIST_ENTRY InMemoryOrderModuleList;
		LIST_ENTRY InInitializationOrderModuleList;
		PVOID EntryInProgress;
		BOOLEAN ShutdownInProgress;
		HANDLE ShutdownThreadId;
	} PEB_LDR_DATA, * PPEB_LDR_DATA;

	typedef struct _GDI_HANDLE_ENTRY {
		union
		{
			PVOID Object;
			PVOID NextFree;
		};
		union
		{
			struct
			{
				USHORT ProcessId;
				USHORT Lock : 1;
				USHORT Count : 15;
			};
			ULONG Value;
		} Owner;
		USHORT Unique;
		UCHAR Type;
		UCHAR Flags;
		PVOID UserPointer;
	} GDI_HANDLE_ENTRY, * PGDI_HANDLE_ENTRY;

	typedef struct _GDI_SHARED_MEMORY {
		GDI_HANDLE_ENTRY Handles[GDI_MAX_HANDLE_COUNT];
	} GDI_SHARED_MEMORY, * PGDI_SHARED_MEMORY;

#ifndef FLS_MAXIMUM_AVAILABLE
#define FLS_MAXIMUM_AVAILABLE 128
#endif
#ifndef TLS_MINIMUM_AVAILABLE
#define TLS_MINIMUM_AVAILABLE 64
#endif
#ifndef TLS_EXPANSION_SLOTS
#define TLS_EXPANSION_SLOTS 1024
#endif

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

	typedef struct _CURDIR {
		UNICODE_STRING DosPath;
		HANDLE Handle;
	} CURDIR, * PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

	typedef struct _RTL_DRIVE_LETTER_CURDIR {
		USHORT Flags;
		USHORT Length;
		ULONG TimeStamp;
		STRING DosPath;
	} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;

	typedef struct _RTL_USER_PROCESS_PARAMETERS {
		ULONG MaximumLength;
		ULONG Length;

		ULONG Flags;
		ULONG DebugFlags;

		HANDLE ConsoleHandle;
		ULONG ConsoleFlags;
		HANDLE StandardInput;
		HANDLE StandardOutput;
		HANDLE StandardError;

		CURDIR CurrentDirectory;
		UNICODE_STRING DllPath;
		UNICODE_STRING ImagePathName;
		UNICODE_STRING CommandLine;
		PVOID Environment;

		ULONG StartingX;
		ULONG StartingY;
		ULONG CountX;
		ULONG CountY;
		ULONG CountCharsX;
		ULONG CountCharsY;
		ULONG FillAttribute;

		ULONG WindowFlags;
		ULONG ShowWindowFlags;
		UNICODE_STRING WindowTitle;
		UNICODE_STRING DesktopInfo;
		UNICODE_STRING ShellInfo;
		UNICODE_STRING RuntimeData;
		RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

		ULONG EnvironmentSize;
		ULONG EnvironmentVersion;
		PVOID PackageDependencyData; //8+
		ULONG ProcessGroupId;
		// ULONG LoaderThreads;
	} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

	typedef struct _PEB {
		BOOLEAN InheritedAddressSpace;
		BOOLEAN ReadImageFileExecOptions;
		BOOLEAN BeingDebugged;
		union
		{
			BOOLEAN BitField;
			struct
			{
				BOOLEAN ImageUsesLargePages : 1;
				BOOLEAN IsProtectedProcess : 1;
				BOOLEAN IsImageDynamicallyRelocated : 1;
				BOOLEAN SkipPatchingUser32Forwarders : 1;
				BOOLEAN IsPackagedProcess : 1;
				BOOLEAN IsAppContainer : 1;
				BOOLEAN IsProtectedProcessLight : 1;
				BOOLEAN IsLongPathAwareProcess : 1;
			};
		};
		HANDLE Mutant;

		PVOID ImageBaseAddress;
		PPEB_LDR_DATA Ldr;
		PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
		PVOID SubSystemData;
		PVOID ProcessHeap;
		PRTL_CRITICAL_SECTION FastPebLock;
		PVOID AtlThunkSListPtr;
		PVOID IFEOKey;
		union
		{
			ULONG CrossProcessFlags;
			struct
			{
				ULONG ProcessInJob : 1;
				ULONG ProcessInitializing : 1;
				ULONG ProcessUsingVEH : 1;
				ULONG ProcessUsingVCH : 1;
				ULONG ProcessUsingFTH : 1;
				ULONG ProcessPreviouslyThrottled : 1;
				ULONG ProcessCurrentlyThrottled : 1;
				ULONG ProcessImagesHotPatched : 1;
				ULONG ReservedBits0 : 24;
			};
			ULONG EnvironmentUpdateCount;
		};
		union
		{
			PVOID KernelCallbackTable;
			PVOID UserSharedInfoPtr;
		};
		ULONG SystemReserved[1];
		ULONG AtlThunkSListPtr32;
		PVOID ApiSetMap;
		ULONG TlsExpansionCounter;
		PVOID TlsBitmap;
		ULONG TlsBitmapBits[2];
		PVOID ReadOnlySharedMemoryBase;
		PVOID HotpatchInformation;
		PVOID* ReadOnlyStaticServerData;
		PVOID AnsiCodePageData;
		PVOID OemCodePageData;
		PVOID UnicodeCaseTableData;

		ULONG NumberOfProcessors;
		ULONG NtGlobalFlag;

		LARGE_INTEGER CriticalSectionTimeout;
		SIZE_T HeapSegmentReserve;
		SIZE_T HeapSegmentCommit;
		SIZE_T HeapDeCommitTotalFreeThreshold;
		SIZE_T HeapDeCommitFreeBlockThreshold;

		ULONG NumberOfHeaps;
		ULONG MaximumNumberOfHeaps;
		PVOID* ProcessHeaps;

		PVOID GdiSharedHandleTable;
		PVOID ProcessStarterHelper;
		ULONG GdiDCAttributeList;

		PRTL_CRITICAL_SECTION LoaderLock;

		ULONG OSMajorVersion;
		ULONG OSMinorVersion;
		USHORT OSBuildNumber;
		USHORT OSCSDVersion;
		ULONG OSPlatformId;
		ULONG ImageSubsystem;
		ULONG ImageSubsystemMajorVersion;
		ULONG ImageSubsystemMinorVersion;
		ULONG_PTR ImageProcessAffinityMask;
		GDI_HANDLE_BUFFER GdiHandleBuffer;
		PVOID PostProcessInitRoutine;

		PVOID TlsExpansionBitmap;
		ULONG TlsExpansionBitmapBits[32];

		ULONG SessionId;

		ULARGE_INTEGER AppCompatFlags;
		ULARGE_INTEGER AppCompatFlagsUser;
		PVOID pShimData;
		PVOID AppCompatInfo;

		UNICODE_STRING CSDVersion;

		PVOID ActivationContextData;
		PVOID ProcessAssemblyStorageMap;
		PVOID SystemDefaultActivationContextData;
		PVOID SystemAssemblyStorageMap;

		SIZE_T MinimumStackCommit;

		PVOID* FlsCallback;
		LIST_ENTRY FlsListHead;
		PVOID FlsBitmap;
		ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
		ULONG FlsHighIndex;

		PVOID WerRegistrationData;
		PVOID WerShipAssertPtr;
		PVOID pContextData;
		PVOID pImageHeaderHash;
		union
		{
			ULONG TracingFlags;
			struct
			{
				ULONG HeapTracingEnabled : 1;
				ULONG CritSecTracingEnabled : 1;
				ULONG LibLoaderTracingEnabled : 1;
				ULONG SpareTracingBits : 29;
			};
		};
		ULONGLONG CsrServerReadOnlySharedMemoryBase;
	} PEB, * PPEB;

	typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
		ULONG Flags;
		PSTR FrameName;
	} TEB_ACTIVE_FRAME_CONTEXT, * PTEB_ACTIVE_FRAME_CONTEXT;

	typedef struct _TEB_ACTIVE_FRAME {
		ULONG Flags;
		struct _TEB_ACTIVE_FRAME* Previous;
		PTEB_ACTIVE_FRAME_CONTEXT Context;
	} TEB_ACTIVE_FRAME, * PTEB_ACTIVE_FRAME;

#define GDI_BATCH_BUFFER_SIZE 310

	typedef struct _GDI_TEB_BATCH {
		ULONG	Offset;
		UCHAR	Alignment[4];
		ULONG_PTR HDC;
		ULONG	Buffer[GDI_BATCH_BUFFER_SIZE];
	} GDI_TEB_BATCH, * PGDI_TEB_BATCH;

	typedef struct _TEB {
		NT_TIB NtTib;

		PVOID EnvironmentPointer;
		CLIENT_ID ClientId;
		PVOID ActiveRpcHandle;
		PVOID ThreadLocalStoragePointer;
		PPEB ProcessEnvironmentBlock;

		ULONG LastErrorValue;
		ULONG CountOfOwnedCriticalSections;
		PVOID CsrClientThread;
		PVOID Win32ThreadInfo;
		ULONG User32Reserved[26];
		ULONG UserReserved[5];
		PVOID WOW32Reserved;
		LCID CurrentLocale;
		ULONG FpSoftwareStatusRegister;
		PVOID SystemReserved1[54];
		NTSTATUS ExceptionCode;
		PVOID ActivationContextStackPointer;
#if defined(_M_X64)
		UCHAR SpareBytes[24];
#else
		UCHAR SpareBytes[36];
#endif
		ULONG TxFsContext;

		GDI_TEB_BATCH GdiTebBatch;
		CLIENT_ID RealClientId;
		HANDLE GdiCachedProcessHandle;
		ULONG GdiClientPID;
		ULONG GdiClientTID;
		PVOID GdiThreadLocalInfo;
		ULONG_PTR Win32ClientInfo[62];
		PVOID glDispatchTable[233];
		ULONG_PTR glReserved1[29];
		PVOID glReserved2;
		PVOID glSectionInfo;
		PVOID glSection;
		PVOID glTable;
		PVOID glCurrentRC;
		PVOID glContext;

		NTSTATUS LastStatusValue;
		UNICODE_STRING StaticUnicodeString;
		WCHAR StaticUnicodeBuffer[261];

		PVOID DeallocationStack;
		PVOID TlsSlots[64];
		LIST_ENTRY TlsLinks;

		PVOID Vdm;
		PVOID ReservedForNtRpc;
		PVOID DbgSsReserved[2];

		ULONG HardErrorMode;
#if defined(_M_X64)
		PVOID Instrumentation[11];
#else
		PVOID Instrumentation[9];
#endif
		GUID ActivityId;

		PVOID SubProcessTag;
		PVOID EtwLocalData;
		PVOID EtwTraceData;
		PVOID WinSockData;
		ULONG GdiBatchCount;

		union
		{
			PROCESSOR_NUMBER CurrentIdealProcessor;
			ULONG IdealProcessorValue;
			struct
			{
				UCHAR ReservedPad0;
				UCHAR ReservedPad1;
				UCHAR ReservedPad2;
				UCHAR IdealProcessor;
			};
		};

		ULONG GuaranteedStackBytes;
		PVOID ReservedForPerf;
		PVOID ReservedForOle;
		ULONG WaitingOnLoaderLock;
		PVOID SavedPriorityState;
		ULONG_PTR SoftPatchPtr1;
		PVOID ThreadPoolData;
		PVOID* TlsExpansionSlots;
#if defined(_M_X64)
		PVOID DeallocationBStore;
		PVOID BStoreLimit;
#endif
		ULONG MuiGeneration;
		ULONG IsImpersonating;
		PVOID NlsCache;
		PVOID pShimData;
		ULONG HeapVirtualAffinity;
		HANDLE CurrentTransactionHandle;
		PTEB_ACTIVE_FRAME ActiveFrame;
		PVOID FlsData;

		PVOID PreferredLanguages;
		PVOID UserPrefLanguages;
		PVOID MergedPrefLanguages;
		ULONG MuiImpersonation;

		union
		{
			USHORT CrossTebFlags;
			USHORT SpareCrossTebBits : 16;
		};
		union
		{
			USHORT SameTebFlags;
			struct
			{
				USHORT SafeThunkCall : 1;
				USHORT InDebugPrint : 1;
				USHORT HasFiberData : 1;
				USHORT SkipThreadAttach : 1;
				USHORT WerInShipAssertCode : 1;
				USHORT RanProcessInit : 1;
				USHORT ClonedThread : 1;
				USHORT SuppressDebugMsg : 1;
				USHORT DisableUserStackWalk : 1;
				USHORT RtlExceptionAttached : 1;
				USHORT InitialThread : 1;
				USHORT SpareSameTebBits : 1;
			};
		};

		PVOID TxnScopeEnterCallback;
		PVOID TxnScopeExitCallback;
		PVOID TxnScopeContext;
		ULONG LockCount;
		ULONG SpareUlong0;
		PVOID ResourceRetValue;
	} TEB, * PTEB;

	typedef struct _PROCESS_DEVICEMAP_INFORMATION {
		union {
			struct {
				HANDLE DirectoryHandle;
			} Set;
			struct {
				ULONG DriveMap;
				UCHAR DriveType[32];
			} Query;
		};
	} PROCESS_DEVICEMAP_INFORMATION, * PPROCESS_DEVICEMAP_INFORMATION;

	__inline struct _PEB* NtCurrentPeb() { return NtCurrentTeb()->ProcessEnvironmentBlock; }

	/*
	** PEB/TEB END
	*/

	/*
	**  MITIGATION POLICY START
	*/

	//redefine enum

#define ProcessDEPPolicy                    0
#define ProcessASLRPolicy                   1
#define ProcessDynamicCodePolicy            2
#define ProcessStrictHandleCheckPolicy      3
#define ProcessSystemCallDisablePolicy      4
#define ProcessMitigationOptionsMask        5
#define ProcessExtensionPointDisablePolicy  6
#define ProcessControlFlowGuardPolicy       7
#define ProcessSignaturePolicy              8
#define ProcessFontDisablePolicy            9
#define ProcessImageLoadPolicy              10
#define ProcessSystemCallFilterPolicy       11
#define ProcessPayloadRestrictionPolicy     12
#define ProcessChildProcessPolicy           13
#define ProcessSideChannelIsolationPolicy   14

	typedef struct tagPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 {
		union {
			DWORD Flags;
			struct {
				DWORD MicrosoftSignedOnly : 1;
				DWORD StoreSignedOnly : 1;
				DWORD MitigationOptIn : 1;
				DWORD AuditMicrosoftSignedOnly : 1;
				DWORD AuditStoreSignedOnly : 1;
				DWORD ReservedFlags : 27;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10, * PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10;

	typedef struct tagPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 {
		union {
			DWORD Flags;
			struct {
				DWORD ProhibitDynamicCode : 1;
				DWORD AllowThreadOptOut : 1;
				DWORD AllowRemoteDowngrade : 1;
				DWORD AuditProhibitDynamicCode : 1;
				DWORD ReservedFlags : 28;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10, * PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10;

	typedef struct tagPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 {
		union {
			DWORD Flags;
			struct {
				DWORD EnableControlFlowGuard : 1;
				DWORD EnableExportSuppression : 1;
				DWORD StrictMode : 1;
				DWORD ReservedFlags : 29;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10, * PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10;

	typedef struct tagPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 {
		union {
			DWORD Flags;
			struct {
				DWORD DisableNonSystemFonts : 1;
				DWORD AuditNonSystemFontLoading : 1;
				DWORD ReservedFlags : 30;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10, * PPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10;

	typedef struct tagPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 {
		union {
			DWORD Flags;
			struct {
				DWORD NoRemoteImages : 1;
				DWORD NoLowMandatoryLabelImages : 1;
				DWORD PreferSystem32Images : 1;
				DWORD AuditNoRemoteImages : 1;
				DWORD AuditNoLowMandatoryLabelImages : 1;
				DWORD ReservedFlags : 27;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10, * PPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10;

	typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 {
		union {
			ULONG Flags;
			struct {
				ULONG FilterId : 4;
				ULONG ReservedFlags : 28;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10, * PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10;

	typedef struct tagPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 {
		union {
			ULONG Flags;
			struct {
				ULONG EnableExportAddressFilter : 1;
				ULONG AuditExportAddressFilter : 1;
				ULONG EnableExportAddressFilterPlus : 1;
				ULONG AuditExportAddressFilterPlus : 1;
				ULONG EnableImportAddressFilter : 1;
				ULONG AuditImportAddressFilter : 1;
				ULONG EnableRopStackPivot : 1;
				ULONG AuditRopStackPivot : 1;
				ULONG EnableRopCallerCheck : 1;
				ULONG AuditRopCallerCheck : 1;
				ULONG EnableRopSimExec : 1;
				ULONG AuditRopSimExec : 1;
				ULONG ReservedFlags : 20;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10, * PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10;

	typedef struct tagPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 {
		union {
			ULONG Flags;
			struct {
				ULONG NoChildProcessCreation : 1;
				ULONG AuditNoChildProcessCreation : 1;
				ULONG AllowSecureProcessCreation : 1;
				ULONG ReservedFlags : 29;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10, * PPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10;

	typedef struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 {
		union {
			DWORD Flags;
			struct {
				DWORD SmtBranchTargetIsolation : 1;
				DWORD IsolateSecurityDomain : 1;
				DWORD DisablePageCombine : 1;
				DWORD SpeculativeStoreBypassDisable : 1;
				DWORD ReservedFlags : 28;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10, * PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10;

	typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 {
		union {
			DWORD Flags;
			struct {
				DWORD DisallowWin32kSystemCalls : 1;
				DWORD AuditDisallowWin32kSystemCalls : 1;
				DWORD ReservedFlags : 30;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;
	} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10, * PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10;

	typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION {
		PROCESS_MITIGATION_POLICY Policy;
		union
		{
			PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
			PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
			PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 SystemCallDisablePolicy;
			PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
			PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 DynamicCodePolicy;
			PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 ControlFlowGuardPolicy;
			PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 SignaturePolicy;
			PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 FontDisablePolicy;
			PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 ImageLoadPolicy;
			PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 SystemCallFilterPolicy;
			PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 PayloadRestrictionPolicy;
			PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 ChildProcessPolicy;
			PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 SideChannelIsolationPolicy;
		};
	} PROCESS_MITIGATION_POLICY_INFORMATION, * PPROCESS_MITIGATION_POLICY_INFORMATION;

	/*
	**  MITIGATION POLICY END
	*/

	/*
	** KUSER_SHARED_DATA START
	*/
#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON  1
#define NX_SUPPORT_POLICY_OPTIN     2
#define NX_SUPPORT_POLICY_OPTOUT    3

#include <pshpack4.h>
	typedef struct _KSYSTEM_TIME {
		ULONG LowPart;
		LONG High1Time;
		LONG High2Time;
	} KSYSTEM_TIME, * PKSYSTEM_TIME;
#include <poppack.h>

	typedef enum _NT_PRODUCT_TYPE {
		NtProductWinNt = 1,
		NtProductLanManNt,
		NtProductServer
	} NT_PRODUCT_TYPE, * PNT_PRODUCT_TYPE;

#define PROCESSOR_FEATURE_MAX 64

	typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
		StandardDesign,                 // None == 0 == standard design
		NEC98x86,                       // NEC PC98xx series on X86
		EndAlternatives                 // past end of known alternatives
	} ALTERNATIVE_ARCHITECTURE_TYPE;

	//
	// Define Address of User Shared Data
	//
#define MM_SHARED_USER_DATA_VA      0x000000007FFE0000

//
// WARNING: this definition is OS version dependent.
// Structure maybe incomplete.
//
#include <pshpack4.h>
	typedef struct _KUSER_SHARED_DATA {

		ULONG TickCountLowDeprecated;
		ULONG TickCountMultiplier;

		volatile KSYSTEM_TIME InterruptTime;
		volatile KSYSTEM_TIME SystemTime;
		volatile KSYSTEM_TIME TimeZoneBias;

		USHORT ImageNumberLow;
		USHORT ImageNumberHigh;

		WCHAR NtSystemRoot[260];

		ULONG MaxStackTraceDepth;
		ULONG CryptoExponent;
		ULONG TimeZoneId;
		ULONG LargePageMinimum;

		union {
			ULONG Reserved2[7];
			struct {
				ULONG AitSamplingValue;
				ULONG AppCompatFlag;
				struct {
					ULONG LowPart;
					ULONG HighPart;
				} RNGSeedVersion;
				ULONG GlobalValidationRunlevel;
				LONG TimeZoneBiasStamp;
				ULONG NtBuildNumber;
			};
		};

		NT_PRODUCT_TYPE NtProductType;
		BOOLEAN ProductTypeIsValid;
		UCHAR Reserved0[1];
		USHORT NativeProcessorArchitecture;

		ULONG NtMajorVersion;
		ULONG NtMinorVersion;

		BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];
		ULONG Reserved1;
		ULONG Reserved3;
		volatile ULONG TimeSlip;
		ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
		ULONG AltArchitecturePad;
		LARGE_INTEGER SystemExpirationDate;
		ULONG SuiteMask;
		BOOLEAN KdDebuggerEnabled;

		union {
			UCHAR MitigationPolicies;
			struct {
				UCHAR NXSupportPolicy : 2;
				UCHAR SEHValidationPolicy : 2;
				UCHAR CurDirDevicesSkippedForDlls : 2;
				UCHAR Reserved : 2;
			};
		};

		UCHAR Reserved6[2];

		volatile ULONG ActiveConsoleId;
		volatile ULONG DismountCount;
		ULONG ComPlusPackage;
		ULONG LastSystemRITEventTickCount;
		ULONG NumberOfPhysicalPages;
		BOOLEAN SafeBootMode;
		UCHAR VirtualizationFlags;
		UCHAR Reserved12[2];

		union {
			ULONG SharedDataFlags;
			struct {
				ULONG DbgErrorPortPresent : 1;
				ULONG DbgElevationEnabled : 1;
				ULONG DbgVirtEnabled : 1;
				ULONG DbgInstallerDetectEnabled : 1;
				ULONG DbgLkgEnabled : 1;
				ULONG DbgDynProcessorEnabled : 1;
				ULONG DbgConsoleBrokerEnabled : 1;
				ULONG DbgSecureBootEnabled : 1;
				ULONG DbgMultiSessionSku : 1;
				ULONG DbgMultiUsersInSessionSku : 1;
				ULONG DbgStateSeparationEnabled : 1;
				ULONG SpareBits : 21;
			};
		};
		ULONG DataFlagsPad[1];
		ULONGLONG TestRetInstruction;
		LONGLONG QpcFrequency;

		ULONG SystemCall;
		ULONG SystemCallPad0;

		ULONGLONG SystemCallPad[2];

		union {
			volatile KSYSTEM_TIME TickCount;
			volatile ULONG64 TickCountQuad;
			ULONG ReservedTickCountOverlay[3];
		};

		ULONG TickCountPad[1];

		ULONG Cookie;
		ULONG CookiedPad;

		ULONG ConsoleSessionForegroundProcessId;

		ULONGLONG TimeUpdateLock;
		ULONGLONG BaselineSystemTimeQpc;
		ULONGLONG BaselineInterruptTimeQpc;
		ULONGLONG QpcSystemTimeIncrement;
		ULONGLONG QpcInterruptTimeIncrement;
		UCHAR QpcSystemTimeIncrementShift;
		UCHAR QpcInterruptTimeIncrementShift;
		USHORT UnparkedProcessorCount;

		ULONG EnclaveFeatureMask[4];
		union {
			ULONG Reserved8;
			ULONG TelemetryCoverageRound;
		};

		USHORT UserModeGlobalLogger[16];

		ULONG ImageFileExecutionOptions;
		ULONG LangGenerationCount;
		ULONGLONG Reserved4;

		volatile ULONG64 InterruptTimeBias;
		volatile ULONG64 QpcBias;

		ULONG ActiveProcessorCount;
		volatile UCHAR ActiveGroupCount;
		UCHAR Reserved9;

		union {
			USHORT QpcData;
			struct {
				UCHAR QpcBypassEnabled : 1;
				UCHAR QpcShift : 1;
			};
		};

		LARGE_INTEGER TimeZoneBiasEffectiveStart;
		LARGE_INTEGER TimeZoneBiasEffectiveEnd;

		XSTATE_CONFIGURATION XState;

	} KUSER_SHARED_DATA, * PKUSER_SHARED_DATA;
#include <poppack.h>

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)MM_SHARED_USER_DATA_VA)

	/*
	** KUSER_SHARED_DATA END
	*/

	/*
	** FLT MANAGER START
	*/

#define FLTFL_MANDATORY_UNLOAD_IN_PROGRESS  0x1
#define FLTFL_FILTERING_INITIATED           0x2
#define FLTFL_NAME_PROVIDER                 0x4
#define FLTFL_SUPPORTS_PIPES_MAILSLOTS      0x8

#define FLT_OBFL_DRAINING                   0x1
#define FLT_OBFL_ZOMBIED                    0x2
#define FLT_OBFL_TYPE_INSTANCE              0x1000000
#define FLT_OBFL_TYPE_FILTER                0x2000000
#define FLT_OBFL_TYPE_VOLUME                0x4000000

	typedef struct _FLT_OBJECT {
		ULONG Flags;
		ULONG PointerCount;
		EX_RUNDOWN_REF RundownRef;
		LIST_ENTRY PrimaryLink;
	} FLT_OBJECT, * PFLT_OBJECT;

	typedef struct _FLT_SERVER_PORT_OBJECT {
		LIST_ENTRY FilterLink;
		PVOID ConnectNotify;
		PVOID DisconnectNotify;
		PVOID MessageNotify;
		PVOID Filter;
		PVOID Cookie;
		ULONG Flags;
		ULONG NumberOfConnections;
		ULONG MaxConnections;
	} FLT_SERVER_PORT_OBJECT, * PFLT_SERVER_PORT_OBJECT;

	/*
	** FLT MANAGER END
	*/

	/*
	** SILO START
	*/

	typedef struct _SYSTEM_ROOT_SILO_INFORMATION {
		ULONG NumberOfSilos;
		ULONG SiloIdList[1];
	} SYSTEM_ROOT_SILO_INFORMATION, * PSYSTEM_ROOT_SILO_INFORMATION;

	typedef struct _SILO_USER_SHARED_DATA {
		ULONG64 ServiceSessionId;
		ULONG ActiveConsoleId;
		LONGLONG ConsoleSessionForegroundProcessId;
		NT_PRODUCT_TYPE NtProductType;
		ULONG SuiteMask;
		ULONG SharedUserSessionId;
		BOOLEAN IsMultiSessionSku;
		WCHAR NtSystemRoot[260];
		USHORT UserModeGlobalLogger[16];
	} SILO_USER_SHARED_DATA, * PSILO_USER_SHARED_DATA;

	typedef struct _OBP_SYSTEM_DOS_DEVICE_STATE {
		ULONG GlobalDeviceMap;
		ULONG LocalDeviceCount[26];
	} OBP_SYSTEM_DOS_DEVICE_STATE, * POBP_SYSTEM_DOS_DEVICE_STATE;

	typedef struct _OBP_SILODRIVERSTATE {
		PDEVICE_MAP SystemDeviceMap;
		OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
		EX_PUSH_LOCK DeviceMapLock;
		OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
	} OBP_SILODRIVERSTATE, * POBP_SILODRIVERSTATE;

	//incomplete, values not important, change between versions.
	typedef struct _ESERVERSILO_GLOBALS {
		OBP_SILODRIVERSTATE ObSiloState;
		//incomplete
	} ESERVERSILO_GLOBALS, * PESERVERSILO_GLOBALS;

	/*
	** SILO END
	*/

	/*
	** SOFTWARE LICENSING START
	*/
#pragma pack(push, 1)
	typedef struct _SL_CACHE_VALUE_DESCRIPTOR {
		USHORT Size;
		USHORT NameLength;
		USHORT Type;
		USHORT DataLength;
		ULONG Attributes;
		ULONG Reserved;
		WCHAR Name[ANYSIZE_ARRAY];
	} SL_CACHE_VALUE_DESCRIPTOR, * PSL_CACHE_VALUE_DESCRIPTOR;
	typedef SL_CACHE_VALUE_DESCRIPTOR SL_KMEM_CACHE_VALUE_DESCRIPTOR;
#pragma pack(pop)

	typedef struct _SL_CACHE {
		ULONG TotalSize;
		ULONG SizeOfData;
		ULONG SignatureSize;
		ULONG Flags;
		ULONG Version;
		SL_KMEM_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
	} SL_CACHE, * PSL_CACHE;
	typedef SL_CACHE SL_KMEM_CACHE;

	typedef struct _SL_APPX_CACHE_VALUE_DESCRIPTOR {
		UCHAR HashedName[32];
		ULONGLONG Expiration;
		ULONG DataSize;
		WCHAR Name[ANYSIZE_ARRAY];
	} SL_APPX_CACHE_VALUE_DESCRIPTOR, * PSL_APPX_CACHE_VALUE_DESCRIPTOR;

	typedef struct _SL_APPX_CACHE {
		ULONG Version;
		ULONG Flags;
		ULONG DataSize;
		ULONGLONG DataCheckSum;
		SL_APPX_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
	} SL_APPX_CACHE, * PSL_APPX_CACHE;


	/*
	** SOFTWARE LICENSING END
	*/


	/*
	**  LDR START
	*/
	//
	// Dll Characteristics for LdrLoadDll
	//
#define LDR_IGNORE_CODE_AUTHZ_LEVEL                 0x00001000

//
// LdrAddRef Flags
//
#define LDR_ADDREF_DLL_PIN                          0x00000001

//
// LdrLockLoaderLock Flags
//
#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS   0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY          0x00000002

//
// LdrUnlockLoaderLock Flags
//
#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

//
// LdrGetDllHandleEx Flags
//
#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT    0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN                   0x00000002

	typedef VOID(NTAPI* PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)(
		_In_    PCLDR_DATA_TABLE_ENTRY DataTableEntry,
		_In_    PVOID Context,
		_Inout_ BOOLEAN* StopEnumeration
		);

	typedef VOID(CALLBACK* PLDR_DLL_NOTIFICATION_FUNCTION)(
		_In_ ULONG NotificationReason,
		_In_ PCLDR_DLL_NOTIFICATION_DATA NotificationData,
		_In_opt_ PVOID Context);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrAccessResource(
			_In_ PVOID DllHandle,
			_In_ CONST IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
			_Out_opt_ PVOID* Address,
			_Out_opt_ PULONG Size);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrAddRefDll(
			_In_ ULONG Flags,
			_In_ PVOID DllHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrEnumerateLoadedModules(
			_In_opt_ ULONG Flags,
			_In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
			_In_opt_ PVOID Context);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrFindResource_U(
			_In_ PVOID DllHandle,
			_In_ CONST ULONG_PTR* ResourceIdPath,
			_In_ ULONG ResourceIdPathLength,
			_Out_ PIMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrFindResourceDirectory_U(
			_In_ PVOID DllHandle,
			_In_ PLDR_RESOURCE_INFO ResourceInfo,
			_In_ ULONG Level,
			_Out_ PIMAGE_RESOURCE_DIRECTORY* ResourceDirectory);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrFindEntryForAddress(
			_In_ PVOID Address,
			_Out_ PLDR_DATA_TABLE_ENTRY* TableEntry);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetDllHandle(
			_In_opt_ PCWSTR DllPath,
			_In_opt_ PULONG DllCharacteristics,
			_In_ PCUNICODE_STRING DllName,
			_Out_ PVOID* DllHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetDllHandleEx(
			_In_ ULONG Flags,
			_In_opt_ PWSTR DllPath,
			_In_opt_ PULONG DllCharacteristics,
			_In_ PUNICODE_STRING DllName,
			_Out_opt_ PVOID* DllHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetDllHandleByMapping(
			_In_ PVOID BaseAddress,
			_Out_ PVOID* DllHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetDllHandleByName(
			_In_opt_ PUNICODE_STRING BaseDllName,
			_In_opt_ PUNICODE_STRING FullDllName,
			_Out_ PVOID* DllHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetDllFullName(
			_In_ PVOID DllHandle,
			_Out_ PUNICODE_STRING FullDllName);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetDllDirectory(
			_Out_ PUNICODE_STRING DllDirectory);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrSetDllDirectory(
			_In_ PUNICODE_STRING DllDirectory);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetProcedureAddress(
			_In_ PVOID DllHandle,
			_In_opt_ CONST ANSI_STRING* ProcedureName,
			_In_opt_ ULONG ProcedureNumber,
			_Out_ PVOID* ProcedureAddress);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetProcedureAddressForCaller(
			_In_ PVOID DllHandle,
			_In_opt_ PANSI_STRING ProcedureName,
			_In_opt_ ULONG ProcedureNumber,
			_Out_ PVOID* ProcedureAddress,
			_In_ ULONG Flags,
			_In_ PVOID* Callback);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrGetKnownDllSectionHandle(
			_In_ PCWSTR DllName,
			_In_ BOOLEAN KnownDlls32,
			_Out_ PHANDLE Section);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrLoadDll(
			_In_opt_ PCWSTR DllPath,
			_In_opt_ PULONG DllCharacteristics,
			_In_  PCUNICODE_STRING DllName,
			_Out_ PVOID* DllHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrUnloadDll(
			_In_ PVOID DllHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrQueryProcessModuleInformation(
			_Out_ PRTL_PROCESS_MODULES ModuleInformation,
			_In_ ULONG ModuleInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrRegisterDllNotification(
			_In_ ULONG Flags,
			_In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
			_In_opt_ PVOID Context,
			_Out_ PVOID* Cookie);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrUnregisterDllNotification(
			_In_ PVOID Cookie);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrResSearchResource(
			_In_ PVOID File,
			_In_ CONST ULONG_PTR* ResIds,
			_In_ ULONG ResIdCount,
			_In_ ULONG Flags,
			_Out_ LPVOID* Resource,
			_Out_ ULONG_PTR* Size,
			_In_opt_ USHORT* FoundLanguage,
			_In_opt_ ULONG* FoundLanguageLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrOpenImageFileOptionsKey(
			_In_ PCUNICODE_STRING ImagePathName,
			_In_ BOOLEAN Wow64Path,
			_Out_ PHANDLE KeyHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrQueryImageFileExecutionOptions(
			_In_ PCUNICODE_STRING ImagePathName,
			_In_ PCWSTR OptionName,
			_In_ ULONG Type,
			_Out_ PVOID Buffer,
			_In_ ULONG BufferSize,
			_Out_opt_ PULONG ResultSize);

	NTSYSAPI
		BOOLEAN
		NTAPI
		LdrIsModuleSxsRedirected( //LdrEntry->Flags->Redirected
			_In_ PVOID DllHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrQueryImageFileExecutionOptionsEx(
			_In_ PCUNICODE_STRING ImagePathName,
			_In_ PCWSTR OptionName,
			_In_ ULONG Type,
			_Out_ PVOID Buffer,
			_In_ ULONG BufferSize,
			_Out_opt_ PULONG ResultSize,
			_In_ BOOLEAN Wow64Path);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrQueryImageFileKeyOption(
			_In_ HANDLE KeyHandle,
			_In_ PCWSTR OptionName,
			_In_ ULONG Type,
			_Out_ PVOID Buffer,
			_In_ ULONG BufferSize,
			_Out_opt_ PULONG ResultSize);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrDisableThreadCalloutsForDll(
			_In_ PVOID DllImageBase);

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS           0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY                  0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID            0x00000000
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED      0x00000001
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED  0x00000002

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS         0x00000001

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrLockLoaderLock(
			_In_ ULONG Flags,
			_Out_opt_ ULONG* Disposition,
			_Out_ PVOID* Cookie);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrUnlockLoaderLock(
			_In_ ULONG Flags,
			_Inout_ PVOID Cookie);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrRelocateImage(
			_In_ PVOID NewBase,
			_In_ PSTR LoaderName,
			_In_ NTSTATUS Success,
			_In_ NTSTATUS Conflict,
			_In_ NTSTATUS Invalid);

	NTSYSAPI
		PIMAGE_BASE_RELOCATION
		NTAPI
		LdrProcessRelocationBlock(
			_In_ ULONG_PTR VA,
			_In_ ULONG SizeOfBlock,
			_In_ PUSHORT NextOffset,
			_In_ LONG_PTR Diff);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrShutdownProcess(
			VOID);

	NTSYSAPI
		NTSTATUS
		NTAPI
		LdrShutdownThread(
			VOID);

	NTSYSAPI
		BOOLEAN
		NTAPI
		LdrControlFlowGuardEnforced(
			VOID);

	/*
	**  LDR END
	*/

	typedef struct _HANDLEENTRY {
		PHEAD   phead;  // Pointer to the Object.
		PVOID   pOwner; // PTI or PPI
		BYTE    bType;  // Object handle type
		BYTE    bFlags; // Flags
		WORD    wUniq;  // Access count.
	} HANDLEENTRY, * PHANDLEENTRY;

	typedef struct _SERVERINFO {
		WORD            wRIPFlags;
		WORD            wSRVIFlags;
		WORD            wRIPPID;
		WORD            wRIPError;
		ULONG           cHandleEntries;
		// incomplete
	} SERVERINFO, * PSERVERINFO;

	typedef struct _SHAREDINFO {
		PSERVERINFO		psi;
		PHANDLEENTRY	aheList;
		ULONG			HeEntrySize;
		// incomplete
	} SHAREDINFO, * PSHAREDINFO;

	typedef struct _USERCONNECT {
		ULONG ulVersion;
		ULONG ulCurrentVersion;
		DWORD dwDispatchCount;
		SHAREDINFO siClient;
	} USERCONNECT, * PUSERCONNECT;

	/*
	** Runtime Library API START
	*/

	/************************************************************************************
	*
	* CSR API.
	*
	************************************************************************************/

	NTSYSAPI
		ULONG
		NTAPI
		CsrGetProcessId(
			VOID);

	NTSYSAPI
		NTSTATUS
		NTAPI
		CsrClientConnectToServer(
			_In_ PWSTR ObjectDirectory,
			_In_ ULONG ServerDllIndex,
			_Inout_ PVOID ConnectionInformation,
			_Inout_ ULONG* ConnectionInformationLength,
			_Out_ PBOOLEAN CalledFromServer);

	/************************************************************************************
	*
	* RTL Strings API.
	*
	************************************************************************************/

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

#ifndef RtlInitEmptyUnicodeString
#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))
#endif

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlCreateUnicodeString(
			_Out_ PUNICODE_STRING DestinationString,
			_In_ PCWSTR SourceString);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlCreateUnicodeStringFromAsciiz(
			_Out_ PUNICODE_STRING DestinationString,
			_In_ PSTR SourceString);

	NTSYSAPI
		VOID
		NTAPI
		RtlInitString(
			_Inout_ PSTRING DestinationString,
			_In_ PCSZ SourceString);

	NTSYSAPI
		VOID
		NTAPI
		RtlInitUnicodeString(
			_Out_ PUNICODE_STRING DestinationString,
			_In_opt_ PCWSTR SourceString);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlInitUnicodeStringEx(
			_Out_ PUNICODE_STRING DestinationString,
			_In_opt_ PWSTR SourceString);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlEqualUnicodeString(
			_In_ PCUNICODE_STRING String1,
			_In_ PCUNICODE_STRING String2,
			_In_ BOOLEAN CaseInSensitive);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDuplicateUnicodeString(
			_In_ ULONG Flags,
			_In_ PUNICODE_STRING StringIn,
			_Out_ PUNICODE_STRING StringOut);

	NTSYSAPI
		WCHAR
		NTAPI
		RtlUpcaseUnicodeChar(
			_In_ WCHAR SourceCharacter);

	NTSYSAPI
		WCHAR
		NTAPI
		RtlDowncaseUnicodeChar(
			_In_ WCHAR SourceCharacter);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlIsNameInExpression(
			_In_ PUNICODE_STRING Expression,
			_In_ PUNICODE_STRING Name,
			_In_ BOOLEAN IgnoreCase,
			_In_opt_ PWCH UpcaseTable);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlStringFromGUID(
			_In_ GUID* Guid,
			_Out_ PUNICODE_STRING GuidString);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGUIDFromString(
			_In_ PUNICODE_STRING GuidString,
			_Out_ GUID* Guid);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlPrefixUnicodeString(
			_In_ PCUNICODE_STRING String1,
			_In_ PCUNICODE_STRING String2,
			_In_ BOOLEAN CaseInSensitive);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlExpandEnvironmentStrings(
			_In_opt_ PVOID Environment,
			_In_reads_(SrcLength) PWSTR Src,
			_In_ SIZE_T SrcLength,
			_Out_writes_opt_(DstLength) PWSTR Dst,
			_In_ SIZE_T DstLength,
			_Out_opt_ PSIZE_T ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlExpandEnvironmentStrings_U(
			_In_opt_ PVOID Environment,
			_In_ PCUNICODE_STRING Source,
			_Out_ PUNICODE_STRING Destination,
			_Out_opt_ PULONG ReturnedLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlFormatCurrentUserKeyPath(
			_Out_ PUNICODE_STRING CurrentUserKeyPath);

	NTSYSAPI
		VOID
		NTAPI
		RtlFreeUnicodeString(
			_In_ PUNICODE_STRING UnicodeString);

	NTSYSAPI
		VOID
		NTAPI
		RtlEraseUnicodeString(
			_Inout_ PUNICODE_STRING String);

	NTSYSAPI
		VOID
		NTAPI
		RtlFreeAnsiString(
			_In_ PANSI_STRING AnsiString);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAnsiStringToUnicodeString(
			_Out_ PUNICODE_STRING DestinationString,
			_In_ PCANSI_STRING SourceString,
			_In_ BOOLEAN AllocateDestinationString);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlUnicodeStringToAnsiString(
			_Inout_ PANSI_STRING DestinationString,
			_In_ PUNICODE_STRING SourceString,
			_In_ BOOLEAN AllocateDestinationString);

	NTSYSAPI
		WCHAR
		NTAPI
		RtlAnsiCharToUnicodeChar(
			_Inout_ PUCHAR* SourceCharacter);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlUnicodeToMultiByteSize(
			_Out_ PULONG BytesInMultiByteString,
			_In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
			_In_ ULONG BytesInUnicodeString);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlDosPathNameToNtPathName_U(
			_In_ PCWSTR DosFileName,
			_Out_ PUNICODE_STRING NtFileName,
			_Out_opt_ PWSTR* FilePart,
			_Reserved_ PVOID Reserved);

	NTSYSAPI
		LONG
		NTAPI
		RtlCompareUnicodeStrings(
			_In_reads_(String1Length) PWCHAR String1,
			_In_ SIZE_T String1Length,
			_In_reads_(String2Length) PWCHAR String2,
			_In_ SIZE_T String2Length,
			_In_ BOOLEAN CaseInSensitive);

	NTSYSAPI
		VOID
		NTAPI
		RtlCopyString(
			_In_ PSTRING DestinationString,
			_In_opt_ PSTRING SourceString);

	NTSYSAPI
		CHAR
		NTAPI
		RtlUpperChar(
			_In_ CHAR Character);

	NTSYSAPI
		VOID
		NTAPI
		RtlUpperString(
			_In_ PSTRING DestinationString,
			_In_ PSTRING SourceString);

	//
	// preallocated heap-growable buffers
	//
	typedef struct _RTL_BUFFER {
		PUCHAR    Buffer;
		PUCHAR    StaticBuffer;
		SIZE_T    Size;
		SIZE_T    StaticSize;
		SIZE_T    ReservedForAllocatedSize; // for future doubling
		PVOID     ReservedForIMalloc; // for future pluggable growth
	} RTL_BUFFER, * PRTL_BUFFER;

	typedef struct _RTL_UNICODE_STRING_BUFFER {
		UNICODE_STRING String;
		RTL_BUFFER     ByteBuffer;
		UCHAR          MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
	} RTL_UNICODE_STRING_BUFFER, * PRTL_UNICODE_STRING_BUFFER;

	//
	// These are OUT Disposition values.
	//
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS   (0x00000001)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC         (0x00000002)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE       (0x00000003)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS (0x00000004)

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlNtPathNameToDosPathName(
			_In_ ULONG Flags,
			_Inout_ PRTL_UNICODE_STRING_BUFFER Path,
			_Out_opt_ PULONG Disposition,
			_Inout_opt_ PWSTR* FilePart);

	NTSYSAPI
		ULONG
		NTAPI
		RtlIsDosDeviceName_U(
			_In_ PCWSTR DosFileName);

	NTSYSAPI
		ULONG
		NTAPI
		RtlGetFullPathName_U(
			_In_ PCWSTR lpFileName,
			_In_ ULONG nBufferLength,
			_Out_writes_bytes_(nBufferLength) PWSTR lpBuffer,
			_Out_opt_ PWSTR* lpFilePart);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlGetSearchPath(
			_Out_ PWSTR* SearchPath);

	typedef enum _RTL_PATH_TYPE {
		RtlPathTypeUnknown,         // 0
		RtlPathTypeUncAbsolute,     // 1
		RtlPathTypeDriveAbsolute,   // 2
		RtlPathTypeDriveRelative,   // 3
		RtlPathTypeRooted,          // 4
		RtlPathTypeRelative,        // 5
		RtlPathTypeLocalDevice,     // 6
		RtlPathTypeRootLocalDevice  // 7
	} RTL_PATH_TYPE;

	NTSYSAPI
		RTL_PATH_TYPE
		NTAPI
		RtlDetermineDosPathNameType_U(
			_In_ PCWSTR DosFileName);

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlHashUnicodeString(
			_In_ const UNICODE_STRING* String,
			_In_ BOOLEAN CaseInSensitive,
			_In_ ULONG HashAlgorithm,
			_Out_ PULONG HashValue);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAppendUnicodeStringToString(
			_In_ PUNICODE_STRING Destination,
			_In_ PUNICODE_STRING Source);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAppendUnicodeToString(
			_In_ PUNICODE_STRING Destination,
			_In_opt_ PWSTR Source);

	NTSYSAPI
		VOID
		NTAPI
		RtlCopyUnicodeString(
			_In_ PUNICODE_STRING DestinationString,
			_In_ PUNICODE_STRING SourceString);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlUpcaseUnicodeString(
			_Inout_ PUNICODE_STRING DestinationString,
			_In_ PUNICODE_STRING SourceString,
			_In_ BOOLEAN AllocateDestinationString);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDowncaseUnicodeString(
			_Inout_ PUNICODE_STRING DestinationString,
			_In_ PUNICODE_STRING SourceString,
			_In_ BOOLEAN AllocateDestinationString);

	NTSYSAPI
		VOID
		NTAPI
		RtlEraseUnicodeString(
			_Inout_ PUNICODE_STRING String);

#define RTL_ENSURE_BUFFER_SIZE_NO_COPY (0x00000001)

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlpEnsureBufferSize(
			_In_ ULONG Flags,
			_Inout_ PRTL_BUFFER Buffer,
			_In_ SIZE_T NewSizeBytes);

#define RtlInitBuffer(Buff, StatBuff, StatSize) \
    do {                                        \
        (Buff)->Buffer       = (StatBuff);      \
        (Buff)->Size         = (StatSize);      \
        (Buff)->StaticBuffer = (StatBuff);      \
        (Buff)->StaticSize   = (StatSize);      \
    } while (0)

#define RtlEnsureBufferSize(Flags, Buff, NewSizeBytes) \
    (   ((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) \
        ? STATUS_SUCCESS \
        : RtlpEnsureBufferSize((Flags), (Buff), (NewSizeBytes)) \
    )

#define RtlFreeBuffer(Buff)                              \
    do {                                                 \
        if ((Buff) != NULL && (Buff)->Buffer != NULL) {  \
            if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buff)) {   \
                UNICODE_STRING UnicodeString;            \
                UnicodeString.Buffer = (PWSTR)(PVOID)(Buff)->Buffer; \
                RtlFreeUnicodeString(&UnicodeString);    \
            }                                            \
            (Buff)->Buffer = (Buff)->StaticBuffer;       \
            (Buff)->Size = (Buff)->StaticSize;           \
        }                                                \
    } while (0)


	/************************************************************************************
	*
	* RTL Integer conversion API.
	*
	************************************************************************************/

	NTSYSAPI
		PWSTR
		NTAPI
		RtlIpv4AddressToStringW(
			_In_ const struct in_addr* Addr,
			_Out_ PWSTR S);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlIpv4StringToAddressW(
			_In_ PCWSTR AddressString,
			_In_ BOOLEAN Strict,
			_Out_ LPCWSTR* Terminator,
			_Out_ struct in_addr* Address);

	//taken from ph2

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlIntegerToChar(
			_In_ ULONG Value,
			_In_opt_ ULONG Base,
			_In_ LONG OutputLength,
			_Out_ PSTR String);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCharToInteger(
			_In_ PSTR String,
			_In_opt_ ULONG Base,
			_Out_ PULONG Value);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlLargeIntegerToChar(
			_In_ PLARGE_INTEGER Value,
			_In_opt_ ULONG Base,
			_In_ LONG OutputLength,
			_Out_ PSTR String);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlIntegerToUnicodeString(
			_In_ ULONG Value,
			_In_opt_ ULONG Base,
			_Inout_ PUNICODE_STRING String);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlInt64ToUnicodeString(
			_In_ ULONGLONG Value,
			_In_opt_ ULONG Base,
			_Inout_ PUNICODE_STRING String);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlUnicodeStringToInteger(
			_In_ PUNICODE_STRING String,
			_In_opt_ ULONG Base,
			_Out_ PULONG Value);

	/************************************************************************************
	*
	* RTL Process/Thread API.
	*
	************************************************************************************/

	typedef NTSTATUS(*PUSER_PROCESS_START_ROUTINE)(
		PRTL_USER_PROCESS_PARAMETERS ProcessParameters
		);

	typedef NTSTATUS(*PUSER_THREAD_START_ROUTINE)(
		PVOID ThreadParameter
		);

	typedef struct _RTL_USER_PROCESS_INFORMATION {
		ULONG Length;
		HANDLE Process;
		HANDLE Thread;
		CLIENT_ID ClientId;
		SECTION_IMAGE_INFORMATION ImageInformation;
	} RTL_USER_PROCESS_INFORMATION, * PRTL_USER_PROCESS_INFORMATION;

	//
	// This structure is used only by Wow64 processes. The offsets
	// of structure elements should the same as viewed by a native Win64 application.
	//
	typedef struct _RTL_USER_PROCESS_INFORMATION64 {
		ULONG Length;
		LONGLONG Process;
		LONGLONG Thread;
		CLIENT_ID64 ClientId;
		SECTION_IMAGE_INFORMATION64 ImageInformation;
	} RTL_USER_PROCESS_INFORMATION64, * PRTL_USER_PROCESS_INFORMATION64;

	NTSYSAPI
		NTSTATUS
		STDAPIVCALLTYPE
		RtlSetProcessIsCritical(
			_In_ BOOLEAN NewValue,
			_Out_opt_ PBOOLEAN OldValue,
			_In_ BOOLEAN CheckFlag);

	NTSYSAPI
		NTSTATUS
		STDAPIVCALLTYPE
		RtlSetThreadIsCritical(
			_In_ BOOLEAN NewValue,
			_Out_opt_ PBOOLEAN OldValue,
			_In_ BOOLEAN CheckFlag);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateEnvironment(
			_In_ BOOLEAN CloneCurrentEnvironment,
			_Out_ PVOID* Environment);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateEnvironmentEx(
			_In_ PVOID SourceEnv,
			_Out_ PVOID* Environment,
			_In_ ULONG Flags);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlSetCurrentEnvironment(
			_In_ PVOID Environment,
			_Out_opt_ PVOID* PreviousEnvironment);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlQueryEnvironmentVariable_U(
			_In_opt_ PVOID Environment,
			_In_ PUNICODE_STRING Name,
			_Out_ PUNICODE_STRING Value);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDestroyEnvironment(
			_In_ PVOID Environment);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateProcessParameters(
			_Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
			_In_ PUNICODE_STRING ImagePathName,
			_In_opt_ PUNICODE_STRING DllPath,
			_In_opt_ PUNICODE_STRING CurrentDirectory,
			_In_opt_ PUNICODE_STRING CommandLine,
			_In_opt_ PVOID Environment,
			_In_opt_ PUNICODE_STRING WindowTitle,
			_In_opt_ PUNICODE_STRING DesktopInfo,
			_In_opt_ PUNICODE_STRING ShellInfo,
			_In_opt_ PUNICODE_STRING RuntimeData);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDestroyProcessParameters(
			_In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateProcessParametersEx(
			_Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
			_In_ PUNICODE_STRING ImagePathName,
			_In_opt_ PUNICODE_STRING DllPath,
			_In_opt_ PUNICODE_STRING CurrentDirectory,
			_In_opt_ PUNICODE_STRING CommandLine,
			_In_opt_ PVOID Environment,
			_In_opt_ PUNICODE_STRING WindowTitle,
			_In_opt_ PUNICODE_STRING DesktopInfo,
			_In_opt_ PUNICODE_STRING ShellInfo,
			_In_opt_ PUNICODE_STRING RuntimeData,
			_In_ ULONG Flags);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateUserProcess(
			_In_ PUNICODE_STRING NtImagePathName,
			_In_ ULONG Attributes,
			_In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
			_In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
			_In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
			_In_opt_ HANDLE ParentProcess,
			_In_ BOOLEAN InheritHandles,
			_In_opt_ HANDLE DebugPort,
			_In_opt_ HANDLE ExceptionPort,
			_Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformationn);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateUserThread(
			_In_ HANDLE Process,
			_In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
			_In_ BOOLEAN CreateSuspended,
			_In_ ULONG StackZeroBits,
			_In_opt_ SIZE_T MaximumStackSize,
			_In_opt_ SIZE_T InitialStackSize,
			_In_ PUSER_THREAD_START_ROUTINE StartAddress,
			_In_opt_ PVOID Parameter,
			_Out_opt_ PHANDLE Thread,
			_Out_opt_ PCLIENT_ID ClientId);

	NTSYSAPI
		VOID
		NTAPI
		RtlExitUserThread(
			_In_ NTSTATUS ExitStatus);

	NTSYSAPI
		VOID
		NTAPI
		RtlExitUserProcess(
			_In_ NTSTATUS ExitStatus);

	NTSYSAPI
		VOID
		NTAPI
		RtlFreeUserThreadStack(
			_In_ HANDLE hProcess,
			_In_ HANDLE hThread);

	NTSYSAPI
		VOID
		NTAPI
		RtlPushFrame(
			_In_ PTEB_ACTIVE_FRAME Frame);

	NTSYSAPI
		VOID
		NTAPI
		RtlPopFrame(
			_In_ PTEB_ACTIVE_FRAME Frame);

	NTSYSAPI
		PTEB_ACTIVE_FRAME
		NTAPI
		RtlGetFrame(
			VOID);

	NTSYSAPI
		PVOID
		NTAPI
		RtlEncodePointer(
			_In_ PVOID Ptr);

	NTSYSAPI
		PVOID
		NTAPI
		RtlDecodePointer(
			_In_ PVOID Ptr);

	/************************************************************************************
	*
	* RTL Memory Buffer API.
	*
	************************************************************************************/

	NTSYSAPI
		SIZE_T
		NTAPI
		RtlCompareMemoryUlong(
			_In_ PVOID Source,
			_In_ SIZE_T Length,
			_In_ ULONG Pattern);

	NTSYSAPI
		VOID
		NTAPI
		RtlFillMemoryUlong(
			_Out_ PVOID Destination,
			_In_ SIZE_T Length,
			_In_ ULONG Pattern);

	NTSYSAPI
		VOID
		NTAPI
		RtlFillMemoryUlonglong(
			_Out_ PVOID Destination,
			_In_ SIZE_T Length,
			_In_ ULONGLONG Pattern);

	/************************************************************************************
	*
	* RTL PEB API.
	*
	************************************************************************************/

	NTSYSAPI
		PPEB
		NTAPI
		RtlGetCurrentPeb(
			VOID);

	NTSYSAPI
		VOID
		NTAPI
		RtlAcquirePebLock(
			VOID);

	NTSYSAPI
		VOID
		NTAPI
		RtlReleasePebLock(
			VOID);

	/************************************************************************************
	*
	* RTL Exception Handling API.
	*
	************************************************************************************/

	NTSYSAPI
		PVOID
		NTAPI
		RtlAddVectoredExceptionHandler(
			_In_ ULONG First,
			_In_ PVECTORED_EXCEPTION_HANDLER Handler);

	NTSYSAPI
		ULONG
		NTAPI
		RtlRemoveVectoredExceptionHandler(
			_In_ PVOID Handle);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlDispatchException(
			_In_ PEXCEPTION_RECORD ExceptionRecord,
			_In_ PCONTEXT ContextRecord);

	NTSYSAPI
		PVOID
		NTAPI
		RtlAddVectoredContinueHandler(
			_In_ ULONG First,
			_In_ PVECTORED_EXCEPTION_HANDLER Handler);

	NTSYSAPI
		ULONG
		NTAPI
		RtlRemoveVectoredContinueHandler(
			_In_ PVOID Handle);

	NTSYSAPI
		VOID
		NTAPI
		RtlRaiseException(
			_In_ PEXCEPTION_RECORD ExceptionRecord);

	NTSYSAPI
		DECLSPEC_NORETURN
		VOID
		NTAPI
		RtlRaiseStatus(
			_In_ NTSTATUS Status);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtContinue(
			_In_ PCONTEXT ContextRecord,
			_In_ BOOLEAN TestAlert);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtRaiseException(
			_In_ PEXCEPTION_RECORD ExceptionRecord,
			_In_ PCONTEXT ContextRecord,
			_In_ BOOLEAN FirstChance);

	/************************************************************************************
	*
	* RTL Security API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGetOwnerSecurityDescriptor(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_Out_ PSID* Owner,
			_Out_ PBOOLEAN OwnerDefaulted);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGetGroupSecurityDescriptor(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_Out_ PSID* Group,
			_Out_ PBOOLEAN GroupDefaulted);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGetDaclSecurityDescriptor(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_Out_ PBOOLEAN DaclPresent,
			_Out_ PACL* Dacl,
			_Out_ PBOOLEAN DaclDefaulted);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGetSaclSecurityDescriptor(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_Out_ PBOOLEAN SaclPresent,
			_Out_ PACL* Sacl,
			_Out_ PBOOLEAN SaclDefaulted);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateAcl(
			_Out_writes_bytes_(AclLength) PACL Acl,
			_In_ ULONG AclLength,
			_In_ ULONG AclRevision);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlValidAcl(
			_In_ PACL Acl);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlQueryInformationAcl(
			_In_ PACL Acl,
			_Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
			_In_ ULONG AclInformationLength,
			_In_ ACL_INFORMATION_CLASS AclInformationClass);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlSetInformationAcl(
			_Inout_ PACL Acl,
			_In_reads_bytes_(AclInformationLength) PVOID AclInformation,
			_In_ ULONG AclInformationLength,
			_In_ ACL_INFORMATION_CLASS AclInformationClass);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ULONG StartingAceIndex,
			_In_reads_bytes_(AceListLength) PVOID AceList,
			_In_ ULONG AceListLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDeleteAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceIndex);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGetAce(
			_In_ PACL Acl,
			_In_ ULONG AceIndex,
			_Outptr_ PVOID* Ace);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlFirstFreeAce(
			_In_ PACL Acl,
			_Out_ PVOID* FirstFree);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlOwnerAcesPresent(
			_In_ PACL pAcl);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAccessAllowedAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ACCESS_MASK AccessMask,
			_In_ PSID Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAccessAllowedAceEx(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ULONG AceFlags,
			_In_ ACCESS_MASK AccessMask,
			_In_ PSID Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAccessDeniedAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ACCESS_MASK AccessMask,
			_In_ PSID Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAccessDeniedAceEx(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ULONG AceFlags,
			_In_ ACCESS_MASK AccessMask,
			_In_ PSID Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAuditAccessAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ACCESS_MASK AccessMask,
			_In_ PSID Sid,
			_In_ BOOLEAN AuditSuccess,
			_In_ BOOLEAN AuditFailure);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAuditAccessAceEx(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ULONG AceFlags,
			_In_ ACCESS_MASK AccessMask,
			_In_ PSID Sid,
			_In_ BOOLEAN AuditSuccess,
			_In_ BOOLEAN AuditFailure);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAccessAllowedObjectAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ULONG AceFlags,
			_In_ ACCESS_MASK AccessMask,
			_In_opt_ GUID* ObjectTypeGuid,
			_In_opt_ GUID* InheritedObjectTypeGuid,
			_In_ PSID Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAccessDeniedObjectAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ULONG AceFlags,
			_In_ ACCESS_MASK AccessMask,
			_In_opt_ GUID* ObjectTypeGuid,
			_In_opt_ GUID* InheritedObjectTypeGuid,
			_In_ PSID Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddAuditAccessObjectAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ULONG AceFlags,
			_In_ ACCESS_MASK AccessMask,
			_In_opt_ GUID* ObjectTypeGuid,
			_In_opt_ GUID* InheritedObjectTypeGuid,
			_In_ PSID Sid,
			_In_ BOOLEAN AuditSuccess,
			_In_ BOOLEAN AuditFailure);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddCompoundAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ UCHAR AceType,
			_In_ ACCESS_MASK AccessMask,
			_In_ PSID ServerSid,
			_In_ PSID ClientSid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddMandatoryAce(
			_Inout_ PACL Acl,
			_In_ ULONG AceRevision,
			_In_ ULONG AceFlags,
			_In_ PSID Sid,
			_In_ UCHAR AceType,
			_In_ ACCESS_MASK AccessMask);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDefaultNpAcl(
			_Out_ PACL* Acl);

	NTSYSAPI
		ULONG
		NTAPI
		RtlLengthSecurityDescriptor(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

	NTSYSAPI
		VOID
		NTAPI
		RtlMapGenericMask(
			_In_ PACCESS_MASK AccessMask,
			_In_ PGENERIC_MAPPING GenericMapping);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlValidSid(
			_In_ PSID Sid);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlEqualSid(
			_In_ PSID Sid1,
			_In_ PSID Sid2);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlEqualPrefixSid(
			_In_ PSID Sid1,
			_In_ PSID Sid2);

	NTSYSAPI
		ULONG
		NTAPI
		RtlLengthRequiredSid(
			_In_ ULONG SubAuthorityCount);

	NTSYSAPI
		PVOID
		NTAPI
		RtlFreeSid(
			_In_ PSID Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAllocateAndInitializeSid(
			_In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
			_In_ UCHAR SubAuthorityCount,
			_In_ ULONG SubAuthority0,
			_In_ ULONG SubAuthority1,
			_In_ ULONG SubAuthority2,
			_In_ ULONG SubAuthority3,
			_In_ ULONG SubAuthority4,
			_In_ ULONG SubAuthority5,
			_In_ ULONG SubAuthority6,
			_In_ ULONG SubAuthority7,
			_Out_ PSID* Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlInitializeSid(
			_Out_ PSID Sid,
			_In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
			_In_ UCHAR SubAuthorityCount);

	NTSYSAPI
		PSID_IDENTIFIER_AUTHORITY
		NTAPI
		RtlIdentifierAuthoritySid(
			_In_ PSID Sid);

	NTSYSAPI
		PULONG
		NTAPI
		RtlSubAuthoritySid(
			_In_ PSID Sid,
			_In_ ULONG SubAuthority);

	NTSYSAPI
		PUCHAR
		NTAPI
		RtlSubAuthorityCountSid(
			_In_ PSID Sid);

	NTSYSAPI
		ULONG
		NTAPI
		RtlLengthSid(
			_In_ PSID Sid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCopySid(
			_In_ ULONG DestinationSidLength,
			_In_ PSID DestinationSid,
			_In_ PSID SourceSid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCopySidAndAttributesArray(
			_In_ ULONG ArrayLength,
			_In_ PSID_AND_ATTRIBUTES Source,
			_In_ ULONG TargetSidBufferSize,
			_Out_ PSID_AND_ATTRIBUTES TargetArrayElement,
			_Out_ PSID TargetSid,
			_Out_ PSID* NextTargetSid,
			_Out_ PULONG RemainingTargetSidBufferSize);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlLengthSidAsUnicodeString(
			_In_ PSID Sid,
			_Out_ PULONG StringLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlConvertSidToUnicodeString(
			_In_ PUNICODE_STRING UnicodeString,
			_In_ PSID Sid,
			_In_ BOOLEAN AllocateDestinationString);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateServiceSid(
			_In_ PUNICODE_STRING ServiceName,
			_Out_writes_bytes_opt_(*ServiceSidLength) PSID ServiceSid,
			_Inout_ PULONG ServiceSidLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCreateSecurityDescriptor(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_In_ ULONG Revision);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlSetOwnerSecurityDescriptor(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_In_ PSID Owner,
			_In_ BOOLEAN OwnerDefaulted);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCopySecurityDescriptor(
			_In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
			_Out_ PSECURITY_DESCRIPTOR* OutputSecurityDescriptor);

	FORCEINLINE LUID NTAPI RtlConvertLongToLuid(
		_In_ LONG Long
	)
	{
		LUID TempLuid;
		LARGE_INTEGER TempLi;

		TempLi.QuadPart = Long;
		TempLuid.LowPart = TempLi.LowPart;
		TempLuid.HighPart = TempLi.HighPart;
		return(TempLuid);
	}

	NTSYSAPI
		ULONG
		NTAPI
		RtlUniform(
			_Inout_ PULONG Seed);

	NTSYSAPI
		ULONG
		NTAPI
		RtlRandomEx(
			_Inout_ PULONG Seed);

	NTSYSAPI
		ULONG32
		NTAPI
		RtlComputeCrc32(
			_In_ ULONG32 PartialCrc,
			_In_ PVOID Buffer,
			_In_ ULONG Length);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAdjustPrivilege(
			_In_ ULONG Privilege,
			_In_ BOOLEAN Enable,
			_In_ BOOLEAN Client,
			_Out_ PBOOLEAN WasEnabled);

	/************************************************************************************
	*
	* RTL Version API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGetVersion(
			_Inout_	PRTL_OSVERSIONINFOW lpVersionInformation);

	NTSYSAPI
		VOID
		NTAPI
		RtlGetNtVersionNumbers(
			_Out_opt_ PULONG MajorVersion,
			_Out_opt_ PULONG MinorVersion,
			_Out_opt_ PULONG BuildNumber);

	/************************************************************************************
	*
	* RTL Error Status API.
	*
	************************************************************************************/

	NTSYSAPI
		ULONG
		NTAPI
		RtlNtStatusToDosError(
			_In_ NTSTATUS Status);

	NTSYSAPI
		VOID
		NTAPI
		RtlSetLastWin32Error(
			_In_ LONG Win32Error);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGetLastNtStatus(
			VOID);

	NTSYSAPI
		LONG
		NTAPI
		RtlGetLastWin32Error(
			VOID);

	NTSYSAPI
		ULONG
		NTAPI
		RtlNtStatusToDosErrorNoTeb(
			_In_ NTSTATUS Status);

	NTSYSAPI
		VOID
		NTAPI
		RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
			_In_ NTSTATUS Status);

	/************************************************************************************
	*
	* RTL WOW64 Support API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlWow64EnableFsRedirection(
			_In_ BOOLEAN Wow64FsEnableRedirection);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlWow64EnableFsRedirectionEx(
			_In_ PVOID DisableFsRedirection,
			_Out_ PVOID* OldFsRedirectionLevel);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlWow64GetThreadContext(
			_In_ HANDLE ThreadHandle,
			_Inout_ PWOW64_CONTEXT ThreadContext);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlWow64SetThreadContext(
			_In_ HANDLE ThreadHandle,
			_In_ PWOW64_CONTEXT ThreadContext);

	/************************************************************************************
	*
	* RTL Heap Management API.
	*
	************************************************************************************/

	typedef NTSTATUS(NTAPI* PRTL_HEAP_COMMIT_ROUTINE)(
		_In_  PVOID Base,
		_Inout_ PVOID* CommitAddress,
		_Inout_ PSIZE_T CommitSize
		);

	typedef struct _RTL_HEAP_PARAMETERS {
		ULONG Length;
		SIZE_T SegmentReserve;
		SIZE_T SegmentCommit;
		SIZE_T DeCommitFreeBlockThreshold;
		SIZE_T DeCommitTotalFreeThreshold;
		SIZE_T MaximumAllocationSize;
		SIZE_T VirtualMemoryThreshold;
		SIZE_T InitialCommit;
		SIZE_T InitialReserve;
		PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
		SIZE_T Reserved[2];
	} RTL_HEAP_PARAMETERS, * PRTL_HEAP_PARAMETERS;

	NTSYSAPI
		PVOID
		NTAPI
		RtlCreateHeap(
			_In_ ULONG Flags,
			_In_opt_ PVOID HeapBase,
			_In_opt_ SIZE_T ReserveSize,
			_In_opt_ SIZE_T CommitSize,
			_In_opt_ PVOID Lock,
			_In_opt_ PRTL_HEAP_PARAMETERS Parameters);

	NTSYSAPI
		PVOID
		NTAPI
		RtlDestroyHeap(
			_In_ PVOID HeapHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlSetHeapInformation(
			_In_ PVOID HeapHandle,
			_In_ HEAP_INFORMATION_CLASS HeapInformationClass,
			_In_opt_ PVOID HeapInformation,
			_In_opt_ SIZE_T HeapInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlQueryHeapInformation(
			_In_ PVOID HeapHandle,
			_In_ HEAP_INFORMATION_CLASS HeapInformationClass,
			_Out_opt_ PVOID HeapInformation,
			_In_opt_ SIZE_T HeapInformationLength,
			_Out_opt_ PSIZE_T ReturnLength);

	NTSYSAPI
		PVOID
		NTAPI
		RtlAllocateHeap(
			_In_ PVOID HeapHandle,
			_In_ ULONG Flags,
			_In_ SIZE_T Size);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlFreeHeap(
			_In_ PVOID HeapHandle,
			_In_ ULONG Flags,
			_In_ PVOID BaseAddress);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlZeroHeap(
			_In_ PVOID HeapHandle,
			_In_ ULONG Flags);

	NTSYSAPI
		SIZE_T
		NTAPI
		RtlSizeHeap(
			_In_ PVOID HeapHandle,
			_In_ ULONG Flags,
			_In_ PVOID BaseAddress);

	NTSYSAPI
		VOID
		NTAPI
		RtlProtectHeap(
			_In_ PVOID HeapHandle,
			_In_ BOOLEAN MakeReadOnly);

	NTSYSAPI
		PVOID
		NTAPI
		RtlReAllocateHeap(
			_In_ PVOID HeapHandle,
			_In_ ULONG Flags,
			_Frees_ptr_opt_ PVOID BaseAddress,
			_In_ SIZE_T Size);

	NTSYSAPI
		ULONG
		NTAPI
		RtlGetProcessHeaps(
			_In_ ULONG NumberOfHeaps,
			_Out_ PVOID* ProcessHeaps);

	typedef NTSTATUS(NTAPI* PRTL_ENUM_HEAPS_ROUTINE)(
		_In_ PVOID HeapHandle,
		_In_ PVOID Parameter
		);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlEnumProcessHeaps(
			_In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
			_In_ PVOID Parameter);

	/************************************************************************************
	*
	* RTL Compression API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGetCompressionWorkSpaceSize(
			_In_ USHORT CompressionFormatAndEngine,
			_Out_ PULONG CompressBufferWorkSpaceSize,
			_Out_ PULONG CompressFragmentWorkSpaceSize);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlCompressBuffer(
			_In_ USHORT CompressionFormatAndEngine,
			_In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
			_In_ ULONG UncompressedBufferSize,
			_Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
			_In_ ULONG CompressedBufferSize,
			_In_ ULONG UncompressedChunkSize,
			_Out_ PULONG FinalCompressedSize,
			_In_ PVOID WorkSpace);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDecompressBuffer(
			_In_ USHORT CompressionFormat,
			_Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
			_In_ ULONG UncompressedBufferSize,
			_In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
			_In_ ULONG CompressedBufferSize,
			_Out_ PULONG FinalUncompressedSize);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDecompressBufferEx(
			_In_ USHORT CompressionFormat,
			_Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
			_In_ ULONG UncompressedBufferSize,
			_In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
			_In_ ULONG CompressedBufferSize,
			_Out_ PULONG FinalUncompressedSize,
			_In_ PVOID WorkSpace);

	/************************************************************************************
	*
	* RTL Image API.
	*
	************************************************************************************/

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK (0x00000001)

	NTSYSAPI
		PIMAGE_NT_HEADERS
		NTAPI
		RtlImageNtHeader(
			_In_ PVOID Base);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlImageNtHeaderEx(
			_In_ ULONG Flags,
			_In_ PVOID Base,
			_In_ ULONG64 Size,
			_Out_ PIMAGE_NT_HEADERS* OutHeaders);

	NTSYSAPI
		PVOID
		NTAPI
		RtlAddressInSectionTable(
			_In_ PIMAGE_NT_HEADERS NtHeaders,
			_In_ PVOID BaseOfImage,
			_In_ ULONG VirtualAddress);

	NTSYSAPI
		PIMAGE_SECTION_HEADER
		NTAPI
		RtlSectionTableFromVirtualAddress(
			_In_ PIMAGE_NT_HEADERS NtHeaders,
			_In_ PVOID BaseOfImage,
			_In_ ULONG VirtualAddress);

	NTSYSAPI
		PVOID
		NTAPI
		RtlImageDirectoryEntryToData(
			_In_ PVOID BaseOfImage,
			_In_ BOOLEAN MappedAsImage,
			_In_ USHORT DirectoryEntry,
			_Out_ PULONG Size);

	NTSYSAPI
		PIMAGE_SECTION_HEADER
		NTAPI
		RtlImageRvaToSection(
			_In_ PIMAGE_NT_HEADERS NtHeaders,
			_In_ PVOID Base,
			_In_ ULONG Rva);

	NTSYSAPI
		PVOID
		NTAPI
		RtlImageRvaToVa(
			_In_ PIMAGE_NT_HEADERS NtHeaders,
			_In_ PVOID Base,
			_In_ ULONG Rva,
			_Inout_opt_ PIMAGE_SECTION_HEADER* LastRvaSection);

	NTSYSAPI
		PVOID
		NTAPI
		RtlFindExportedRoutineByName(
			_In_ PVOID BaseOfImage,
			_In_ PSTR RoutineName);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlGuardCheckLongJumpTarget(
			_In_ PVOID PcValue,
			_In_ BOOL IsFastFail,
			_Out_ PBOOL IsLongJumpTarget);

	/************************************************************************************
	*
	* RTL Time API.
	*
	************************************************************************************/

	NTSYSAPI
		VOID
		NTAPI
		RtlSecondsSince1970ToTime(
			_In_ ULONG ElapsedSeconds,
			_Out_ PLARGE_INTEGER Time);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlTimeToSecondsSince1970(
			_In_ PLARGE_INTEGER Time,
			_Out_ PULONG ElapsedSeconds);


	NTSYSAPI
		VOID
		NTAPI
		RtlSecondsSince1980ToTime(
			_In_ ULONG ElapsedSeconds,
			_Out_ PLARGE_INTEGER Time);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlTimeToSecondsSince1980(
			_In_ PLARGE_INTEGER Time,
			_Out_ PULONG ElapsedSeconds);

	NTSYSAPI
		VOID
		NTAPI
		RtlTimeToTimeFields(
			_In_ PLARGE_INTEGER Time,
			_Out_ PTIME_FIELDS TimeFields);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlTimeFieldsToTime(
			_In_ PTIME_FIELDS TimeFields,
			_Out_ PLARGE_INTEGER Time);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlSystemTimeToLocalTime(
			_In_ PLARGE_INTEGER SystemTime,
			_Out_ PLARGE_INTEGER LocalTime);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlLocalTimeToSystemTime(
			_In_ PLARGE_INTEGER LocalTime,
			_Out_ PLARGE_INTEGER SystemTime);

	/************************************************************************************
	*
	* RTL Debug Support API.
	*
	************************************************************************************/

	NTSYSAPI
		ULONG
		STDAPIVCALLTYPE
		DbgPrint(
			_In_z_ _Printf_format_string_ PCH Format,
			...);

	NTSYSAPI
		ULONG
		STDAPIVCALLTYPE
		DbgPrintEx(
			_In_ ULONG ComponentId,
			_In_ ULONG Level,
			_In_z_ _Printf_format_string_ PSTR Format,
			...);

	NTSYSAPI
		NTSTATUS
		NTAPI
		DbgQueryDebugFilterState(
			_In_ ULONG ComponentId,
			_In_ ULONG Level);

	NTSYSAPI
		NTSTATUS
		NTAPI
		DbgSetDebugFilterState(
			_In_ ULONG ComponentId,
			_In_ ULONG Level,
			_In_ BOOLEAN State);

	NTSYSAPI
		VOID
		NTAPI
		DbgUserBreakPoint(
			VOID);

	NTSYSAPI
		VOID
		NTAPI
		DbgBreakPoint(
			VOID);

	NTSYSAPI
		NTSTATUS
		NTAPI
		DbgUiConnectToDbg(
			VOID);

	NTSYSAPI
		VOID
		NTAPI
		DbgUiSetThreadDebugObject(
			_In_ HANDLE DebugObject);

	NTSYSAPI
		NTSTATUS
		NTAPI
		DbgUiContinue(
			_In_ PCLIENT_ID AppClientId,
			_In_ NTSTATUS ContinueStatus);

	NTSYSAPI
		NTSTATUS
		NTAPI
		DbgUiStopDebugging(
			_In_ HANDLE Process);

	NTSYSAPI
		NTSTATUS
		NTAPI
		DbgUiDebugActiveProcess(
			_In_ HANDLE Process);

	/************************************************************************************
	*
	* RTL AVL Tree API.
	*
	************************************************************************************/

	typedef enum _TABLE_SEARCH_RESULT {
		TableEmptyTree,
		TableFoundNode,
		TableInsertAsLeft,
		TableInsertAsRight
	} TABLE_SEARCH_RESULT;

	typedef enum _RTL_GENERIC_COMPARE_RESULTS {
		GenericLessThan,
		GenericGreaterThan,
		GenericEqual
	} RTL_GENERIC_COMPARE_RESULTS;

	//
	// Add an empty typedef so that functions can reference the
	// a pointer to the generic table struct before it is declared.
	//

#if defined (__cplusplus)
	struct _RTL_AVL_TABLE;
#else
	typedef struct _RTL_AVL_TABLE RTL_AVL_TABLE;
	typedef struct PRTL_AVL_TABLE* _RTL_AVL_TABLE;
#endif

	typedef RTL_GENERIC_COMPARE_RESULTS(NTAPI* PRTL_AVL_COMPARE_ROUTINE)(
		_In_  struct _RTL_AVL_TABLE* Table,
		_In_ PVOID FirstStruct,
		_In_ PVOID SecondStruct
		);

	typedef PVOID(NTAPI* PRTL_AVL_ALLOCATE_ROUTINE)(
		_In_ struct _RTL_AVL_TABLE* Table,
		_In_ ULONG ByteSize
		);

	typedef VOID(NTAPI* PRTL_AVL_FREE_ROUTINE)(
		_In_  struct _RTL_AVL_TABLE* Table,
		_In_ _Post_invalid_ PVOID Buffer
		);

	typedef NTSTATUS(NTAPI* PRTL_AVL_MATCH_FUNCTION)(
		_In_ struct _RTL_AVL_TABLE* Table,
		_In_ PVOID UserData,
		_In_ PVOID MatchData
		);

	typedef struct _RTL_BALANCED_LINKS {
		struct _RTL_BALANCED_LINKS* Parent;
		struct _RTL_BALANCED_LINKS* LeftChild;
		struct _RTL_BALANCED_LINKS* RightChild;
		CHAR Balance;
		UCHAR Reserved[3];
	} RTL_BALANCED_LINKS, * PRTL_BALANCED_LINKS;

	typedef struct _RTL_AVL_TABLE {
		RTL_BALANCED_LINKS BalancedRoot;
		PVOID OrderedPointer;
		ULONG WhichOrderedElement;
		ULONG NumberGenericTableElements;
		ULONG DepthOfTree;
		PRTL_BALANCED_LINKS RestartKey;
		ULONG DeleteCount;
		PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
		PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
		PRTL_AVL_FREE_ROUTINE FreeRoutine;
		PVOID TableContext;
	} RTL_AVL_TABLE, * PRTL_AVL_TABLE;

	NTSYSAPI
		VOID
		NTAPI
		RtlInitializeGenericTableAvl(
			_Out_ PRTL_AVL_TABLE Table,
			_In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
			_In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
			_In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
			_In_opt_ PVOID TableContext);

	NTSYSAPI
		PVOID
		NTAPI
		RtlInsertElementGenericTableAvl(
			_In_ PRTL_AVL_TABLE Table,
			_In_reads_bytes_(BufferSize) PVOID Buffer,
			_In_ CLONG BufferSize,
			_Out_opt_ PBOOLEAN NewElement);

	NTSYSAPI
		PVOID
		NTAPI
		RtlInsertElementGenericTableFullAvl(
			_In_ PRTL_AVL_TABLE Table,
			_In_reads_bytes_(BufferSize) PVOID Buffer,
			_In_ CLONG BufferSize,
			_Out_opt_ PBOOLEAN NewElement,
			_In_ PVOID NodeOrParent,
			_In_ TABLE_SEARCH_RESULT SearchResult);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlDeleteElementGenericTableAvl(
			_In_ PRTL_AVL_TABLE Table,
			_In_ PVOID Buffer);

	NTSYSAPI
		PVOID
		NTAPI
		RtlLookupElementGenericTableAvl(
			_In_ PRTL_AVL_TABLE Table,
			_In_ PVOID Buffer);

	NTSYSAPI
		PVOID
		NTAPI
		RtlLookupElementGenericTableFullAvl(
			_In_ PRTL_AVL_TABLE Table,
			_In_ PVOID Buffer,
			_Out_ PVOID* NodeOrParent,
			_Out_ TABLE_SEARCH_RESULT* SearchResult);

	NTSYSAPI
		PVOID
		NTAPI
		RtlEnumerateGenericTableAvl(
			_In_ PRTL_AVL_TABLE Table,
			_In_ BOOLEAN Restart);

	NTSYSAPI
		PVOID
		NTAPI
		RtlEnumerateGenericTableWithoutSplayingAvl(
			_In_ PRTL_AVL_TABLE Table,
			_Inout_ PVOID* RestartKey);

	NTSYSAPI
		PVOID
		NTAPI
		RtlLookupFirstMatchingElementGenericTableAvl(
			_In_ PRTL_AVL_TABLE Table,
			_In_ PVOID Buffer,
			_Out_ PVOID* RestartKey);

	NTSYSAPI
		PVOID
		NTAPI
		RtlEnumerateGenericTableLikeADirectory(
			_In_ PRTL_AVL_TABLE Table,
			_In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
			_In_opt_ PVOID MatchData,
			_In_ ULONG NextFlag,
			_Inout_ PVOID* RestartKey,
			_Inout_ PULONG DeleteCount,
			_In_ PVOID Buffer);

	NTSYSAPI
		PVOID
		NTAPI
		RtlGetElementGenericTableAvl(
			_In_ PRTL_AVL_TABLE Table,
			_In_ ULONG I);

	NTSYSAPI
		ULONG
		NTAPI
		RtlNumberGenericTableElementsAvl(
			_In_ PRTL_AVL_TABLE Table);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlIsGenericTableEmptyAvl(
			_In_ PRTL_AVL_TABLE Table);

	/************************************************************************************
	*
	* RTL Critical Section Support API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlEnterCriticalSection(
			_In_ PRTL_CRITICAL_SECTION CriticalSection);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlLeaveCriticalSection(
			_In_ PRTL_CRITICAL_SECTION CriticalSection);

	NTSYSAPI
		LOGICAL
		NTAPI
		RtlIsCriticalSectionLocked(
			_In_ PRTL_CRITICAL_SECTION CriticalSection);

	NTSYSAPI
		LOGICAL
		NTAPI
		RtlIsCriticalSectionLockedByThread(
			_In_ PRTL_CRITICAL_SECTION CriticalSection);

	NTSYSAPI
		ULONG
		NTAPI
		RtlGetCriticalSectionRecursionCount(
			_In_ PRTL_CRITICAL_SECTION CriticalSection);

	NTSYSAPI
		LOGICAL
		NTAPI
		RtlTryEnterCriticalSection(
			_In_ PRTL_CRITICAL_SECTION CriticalSection);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlInitializeCriticalSection(
			_In_ PRTL_CRITICAL_SECTION CriticalSection);

	NTSYSAPI
		VOID
		NTAPI
		RtlEnableEarlyCriticalSectionEventCreation(
			VOID);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlInitializeCriticalSectionAndSpinCount(
			_In_ PRTL_CRITICAL_SECTION CriticalSection,
			_In_ ULONG SpinCount);

	NTSYSAPI
		ULONG
		NTAPI
		RtlSetCriticalSectionSpinCount(
			_In_ PRTL_CRITICAL_SECTION CriticalSection,
			_In_ ULONG SpinCount);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlDeleteCriticalSection(
			_In_ PRTL_CRITICAL_SECTION CriticalSection);

	/************************************************************************************
	*
	* RTL SRW Lock Support API.
	*
	************************************************************************************/

	NTSYSAPI
		VOID
		NTAPI
		RtlInitializeSRWLock(
			_Out_ PRTL_SRWLOCK SRWLock);

	NTSYSAPI
		VOID
		NTAPI
		RtlAcquireSRWLockExclusive(
			_Inout_ PRTL_SRWLOCK SRWLock);

	NTSYSAPI
		VOID
		NTAPI
		RtlAcquireSRWLockShared(
			_Inout_ PRTL_SRWLOCK SRWLock);

	NTSYSAPI
		VOID
		NTAPI
		RtlReleaseSRWLockExclusive(
			_Inout_ PRTL_SRWLOCK SRWLock);

	NTSYSAPI
		VOID
		NTAPI
		RtlReleaseSRWLockShared(
			_Inout_ PRTL_SRWLOCK SRWLock);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlTryAcquireSRWLockExclusive(
			_Inout_ PRTL_SRWLOCK SRWLock);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlTryAcquireSRWLockShared(
			_Inout_ PRTL_SRWLOCK SRWLock);

	NTSYSAPI
		VOID
		NTAPI
		RtlAcquireReleaseSRWLockExclusive(
			_Inout_ PRTL_SRWLOCK SRWLock);

	NTSYSAPI
		VOID
		NTAPI
		RtlUpdateClonedSRWLock(
			_Inout_ PRTL_SRWLOCK SRWLock,
			_In_ LOGICAL Shared);

	/************************************************************************************
	*
	* RTL UAC Support API.
	*
	************************************************************************************/

#define DBG_FLAG_ELEVATION_ENABLED        1
#define DBG_FLAG_VIRTUALIZATION_ENABLED   2
#define DBG_FLAG_INSTALLER_DETECT_ENABLED 3

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlQueryElevationFlags(
			_Inout_ ULONG* ElevationFlags);

	/************************************************************************************
	*
	* RTL Misc Support API.
	*
	************************************************************************************/

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlDoesFileExists_U(
			_In_ PCWSTR FileName);

	NTSYSAPI
		ULONG
		NTAPI
		RtlGetLongestNtPathLength(
			VOID);

	NTSYSAPI
		BOOLEAN
		NTAPI
		RtlAreLongPathsEnabled(
			VOID);

	/************************************************************************************
	*
	* RTL Boundary Descriptor API.
	*
	************************************************************************************/

	NTSYSAPI
		PVOID
		NTAPI
		RtlCreateBoundaryDescriptor(
			_In_ PUNICODE_STRING Name,
			_In_ ULONG Flags);

	NTSYSAPI
		VOID
		NTAPI
		RtlDeleteBoundaryDescriptor(
			_In_ PVOID BoundaryDescriptor);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddSIDToBoundaryDescriptor(
			_Inout_ PVOID* BoundaryDescriptor,
			_In_ PSID RequiredSid);

	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAddIntegrityLabelToBoundaryDescriptor(
			_Inout_ PVOID* BoundaryDescriptor,
			_In_ PSID IntegrityLabel);

	/************************************************************************************
	*
	* ETW API.
	*
	************************************************************************************/

	struct _EVENT_FILTER_DESCRIPTOR;

	typedef VOID(NTAPI* PENABLECALLBACK)(
		_In_ LPCGUID SourceId,
		_In_ ULONG IsEnabled,
		_In_ UCHAR Level,
		_In_ ULONGLONG MatchAnyKeyword,
		_In_ ULONGLONG MatchAllKeyword,
		_In_opt_ struct _EVENT_FILTER_DESCRIPTOR* FilterData,
		_Inout_opt_ PVOID CallbackContext
		);

	NTSYSAPI
		NTSTATUS
		NTAPI
		EtwEventRegister(
			_In_ LPCGUID ProviderId,
			_In_opt_ PENABLECALLBACK EnableCallback,
			_In_opt_ PVOID CallbackContext,
			_Out_ PREGHANDLE RegHandle);

	/*
	** Runtime Library API END
	*/

	/*
	** Native API START
	*/

	/************************************************************************************
	*
	* System Information API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		WINAPI
		NtQuerySystemInformation(
			_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
			_Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
			_In_ ULONG SystemInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQuerySystemInformationEx(
			_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
			_In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
			_In_ ULONG InputBufferLength,
			_Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
			_In_ ULONG SystemInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetSystemInformation(
			_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
			_In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
			_In_ ULONG SystemInformationLength);

	/************************************************************************************
	*
	* Event (EventPair) API.
	*
	************************************************************************************/

	typedef enum _EVENT_INFORMATION_CLASS {
		EventBasicInformation
	} EVENT_INFORMATION_CLASS;

	typedef enum _EVENT_TYPE {
		NotificationEvent,
		SynchronizationEvent
	} EVENT_TYPE;

	typedef struct _EVENT_BASIC_INFORMATION {
		EVENT_TYPE EventType;
		LONG EventState;
	} EVENT_BASIC_INFORMATION, * PEVENT_BASIC_INFORMATION;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateEvent(
			_Out_ PHANDLE EventHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ EVENT_TYPE EventType,
			_In_ BOOLEAN InitialState);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenEvent(
			_Out_ PHANDLE EventHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetEvent(
			_In_ HANDLE EventHandle,
			_Out_opt_ PLONG PreviousState);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtClearEvent(
			_In_ HANDLE EventHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtResetEvent(
			_In_ HANDLE EventHandle,
			_Out_opt_ PLONG PreviousState);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtPulseEvent(
			_In_ HANDLE EventHandle,
			_Out_opt_ PLONG PreviousState);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenKeyedEvent(
			_Out_ PHANDLE KeyedEventHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryEvent(
			_In_ HANDLE EventHandle,
			_In_ EVENT_INFORMATION_CLASS EventInformationClass,
			_Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
			_In_ ULONG EventInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateEventPair(
			_Out_ PHANDLE EventPairHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenEventPair(
			_Out_ PHANDLE EventPairHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetLowEventPair(
			_In_ HANDLE EventPairHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetHighEventPair(
			_In_ HANDLE EventPairHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtWaitLowEventPair(
			_In_ HANDLE EventPairHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtWaitHighEventPair(
			_In_ HANDLE EventPairHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetLowWaitHighEventPair(
			_In_ HANDLE EventPairHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetHighWaitLowEventPair(
			_In_ HANDLE EventPairHandle);

	/************************************************************************************
	*
	* Mutant API.
	*
	************************************************************************************/

	typedef enum _MUTANT_INFORMATION_CLASS {
		MutantBasicInformation,
		MutantOwnerInformation
	} MUTANT_INFORMATION_CLASS;

	typedef struct _MUTANT_BASIC_INFORMATION {
		LONG CurrentCount;
		BOOLEAN OwnedByCaller;
		BOOLEAN AbandonedState;
	} MUTANT_BASIC_INFORMATION, * PMUTANT_BASIC_INFORMATION;

	typedef struct _MUTANT_OWNER_INFORMATION {
		CLIENT_ID ClientId;
	} MUTANT_OWNER_INFORMATION, * PMUTANT_OWNER_INFORMATION;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateMutant(
			_Out_ PHANDLE MutantHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ BOOLEAN InitialOwner);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenMutant(
			_Out_ PHANDLE MutantHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryMutant(
			_In_ HANDLE MutantHandle,
			_In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
			_Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
			_In_ ULONG MutantInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReleaseMutant(
			_In_ HANDLE MutantHandle,
			_Out_opt_ PLONG PreviousCount);

	/************************************************************************************
	*
	* Timer API.
	*
	************************************************************************************/

	typedef VOID(*PTIMER_APC_ROUTINE) (
		_In_ PVOID TimerContext,
		_In_ ULONG TimerLowValue,
		_In_ LONG TimerHighValue
		);

	typedef enum _TIMER_TYPE {
		NotificationTimer,
		SynchronizationTimer
	} TIMER_TYPE;

	typedef enum _TIMER_INFORMATION_CLASS {
		TimerBasicInformation
	} TIMER_INFORMATION_CLASS;

	typedef struct _TIMER_BASIC_INFORMATION {
		LARGE_INTEGER RemainingTime;
		BOOLEAN TimerState;
	} TIMER_BASIC_INFORMATION, * PTIMER_BASIC_INFORMATION;

	typedef enum _TIMER_SET_INFORMATION_CLASS {
		TimerSetCoalescableTimer,
		MaxTimerInfoClass
	} TIMER_SET_INFORMATION_CLASS;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateTimer(
			_In_ PHANDLE TimerHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ TIMER_TYPE TimerType);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetTimer(
			_In_ HANDLE TimerHandle,
			_In_ PLARGE_INTEGER DueTime,
			_In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
			_In_opt_ PVOID TimerContext,
			_In_ BOOLEAN WakeTimer,
			_In_opt_ LONG Period,
			_Out_opt_ PBOOLEAN PreviousState);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetTimerEx(
			_In_ HANDLE TimerHandle,
			_In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
			_Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
			_In_ ULONG TimerSetInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenTimer(
			_In_ PHANDLE TimerHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryTimer(
			_In_ HANDLE TimerHandle,
			_In_ TIMER_INFORMATION_CLASS TimerInformationClass,
			_Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
			_In_ ULONG TimerInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCancelTimer(
			_In_ HANDLE TimerHandle,
			_Out_opt_ PBOOLEAN CurrentState);

	//ref from ph2

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateIRTimer(
			_Out_ PHANDLE TimerHandle,
			_In_ ACCESS_MASK DesiredAccess);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetIRTimer(
			_In_ HANDLE TimerHandle,
			_In_opt_ PLARGE_INTEGER DueTime);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateTimer2(
			_Out_ PHANDLE TimerHandle,
			_In_opt_ PVOID Reserved1,
			_In_opt_ PVOID Reserved2,
			_In_ ULONG Attributes,
			_In_ ACCESS_MASK DesiredAccess);

	/************************************************************************************
	*
	* Semaphore API.
	*
	************************************************************************************/

	typedef enum _SEMAPHORE_INFORMATION_CLASS {
		SemaphoreBasicInformation
	} SEMAPHORE_INFORMATION_CLASS;

	typedef struct _SEMAPHORE_BASIC_INFORMATION {
		LONG CurrentCount;
		LONG MaximumCount;
	} SEMAPHORE_BASIC_INFORMATION, * PSEMAPHORE_BASIC_INFORMATION;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateSemaphore(
			_Out_ PHANDLE SemaphoreHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ LONG InitialCount,
			_In_ LONG MaximumCount);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenSemaphore(
			_Out_ PHANDLE SemaphoreHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQuerySemaphore(
			_In_ HANDLE SemaphoreHandle,
			_In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
			_Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
			_In_ ULONG SemaphoreInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReleaseSemaphore(
			_In_ HANDLE SemaphoreHandle,
			_In_ LONG ReleaseCount,
			_Out_opt_ PLONG PreviousCount);

	/************************************************************************************
	*
	* Object and Handle API.
	*
	************************************************************************************/
	typedef enum _OBJECT_INFORMATION_CLASS {
		ObjectBasicInformation,
		ObjectNameInformation,
		ObjectTypeInformation,
		ObjectTypesInformation,
		ObjectHandleFlagInformation,
		ObjectSessionInformation,
		ObjectSessionObjectInformation,
		MaxObjectInfoClass
	} OBJECT_INFORMATION_CLASS;

	typedef struct _OBJECT_DIRECTORY_INFORMATION {
		UNICODE_STRING Name;
		UNICODE_STRING TypeName;
	} OBJECT_DIRECTORY_INFORMATION, * POBJECT_DIRECTORY_INFORMATION;

	typedef struct _OBJECT_BASIC_INFORMATION {
		ULONG Attributes;
		ACCESS_MASK GrantedAccess;
		ULONG HandleCount;
		ULONG PointerCount;
		ULONG PagedPoolCharge;
		ULONG NonPagedPoolCharge;
		ULONG Reserved[3];
		ULONG NameInfoSize;
		ULONG TypeInfoSize;
		ULONG SecurityDescriptorSize;
		LARGE_INTEGER CreationTime;
	} OBJECT_BASIC_INFORMATION, * POBJECT_BASIC_INFORMATION;

	typedef struct _OBJECT_NAME_INFORMATION {
		UNICODE_STRING Name;
	} OBJECT_NAME_INFORMATION, * POBJECT_NAME_INFORMATION;

	typedef struct _OBJECT_TYPE_INFORMATION {
		UNICODE_STRING TypeName;
		ULONG TotalNumberOfObjects;
		ULONG TotalNumberOfHandles;
		ULONG TotalPagedPoolUsage;
		ULONG TotalNonPagedPoolUsage;
		ULONG TotalNamePoolUsage;
		ULONG TotalHandleTableUsage;
		ULONG HighWaterNumberOfObjects;
		ULONG HighWaterNumberOfHandles;
		ULONG HighWaterPagedPoolUsage;
		ULONG HighWaterNonPagedPoolUsage;
		ULONG HighWaterNamePoolUsage;
		ULONG HighWaterHandleTableUsage;
		ULONG InvalidAttributes;
		GENERIC_MAPPING GenericMapping;
		ULONG ValidAccessMask;
		BOOLEAN SecurityRequired;
		BOOLEAN MaintainHandleCount;
		ULONG PoolType;
		ULONG DefaultPagedPoolCharge;
		ULONG DefaultNonPagedPoolCharge;
	} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

	typedef struct _OBJECT_TYPE_INFORMATION_V2 {
		UNICODE_STRING TypeName;
		ULONG TotalNumberOfObjects;
		ULONG TotalNumberOfHandles;
		ULONG TotalPagedPoolUsage;
		ULONG TotalNonPagedPoolUsage;
		ULONG TotalNamePoolUsage;
		ULONG TotalHandleTableUsage;
		ULONG HighWaterNumberOfObjects;
		ULONG HighWaterNumberOfHandles;
		ULONG HighWaterPagedPoolUsage;
		ULONG HighWaterNonPagedPoolUsage;
		ULONG HighWaterNamePoolUsage;
		ULONG HighWaterHandleTableUsage;
		ULONG InvalidAttributes;
		GENERIC_MAPPING GenericMapping;
		ULONG ValidAccessMask;
		BOOLEAN SecurityRequired;
		BOOLEAN MaintainHandleCount;
		UCHAR TypeIndex;
		CHAR ReservedByte;
		ULONG PoolType;
		ULONG DefaultPagedPoolCharge;
		ULONG DefaultNonPagedPoolCharge;
	} OBJECT_TYPE_INFORMATION_V2, * POBJECT_TYPE_INFORMATION_V2;

	typedef struct _OBJECT_TYPES_INFORMATION {
		ULONG NumberOfTypes;
	} OBJECT_TYPES_INFORMATION, * POBJECT_TYPES_INFORMATION;

#define OBJECT_TYPES_FIRST_ENTRY(ObjectTypes) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectTypes, ALIGN_UP(sizeof(OBJECT_TYPES_INFORMATION), ULONG_PTR))

#define OBJECT_TYPES_NEXT_ENTRY(ObjectType) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectType, sizeof(OBJECT_TYPE_INFORMATION) + \
    ALIGN_UP(ObjectType->TypeName.MaximumLength, ULONG_PTR))

	typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
		BOOLEAN Inherit;
		BOOLEAN ProtectFromClose;
	} OBJECT_HANDLE_FLAG_INFORMATION, * POBJECT_HANDLE_FLAG_INFORMATION;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtClose(
			_In_ HANDLE Handle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDuplicateObject(
			_In_ HANDLE SourceProcessHandle,
			_In_ HANDLE SourceHandle,
			_In_opt_ HANDLE TargetProcessHandle,
			_Out_ PHANDLE TargetHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ ULONG HandleAttributes,
			_In_ ULONG Options);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtMakePermanentObject(
			_In_ HANDLE Handle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtMakeTemporaryObject(
			_In_ HANDLE Handle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetSecurityObject(
			_In_ HANDLE Handle,
			_In_ SECURITY_INFORMATION SecurityInformation,
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQuerySecurityObject(
			_In_ HANDLE Handle,
			_In_ SECURITY_INFORMATION SecurityInformation,
			_Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
			_In_ ULONG Length,
			_Out_ PULONG LengthNeeded);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCompareObjects(
			_In_ HANDLE FirstObjectHandle,
			_In_ HANDLE SecondObjectHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryObject(
			_In_opt_ HANDLE Handle,
			_In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
			_Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
			_In_ ULONG ObjectInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetInformationObject(
			_In_ HANDLE Handle,
			_In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
			_In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
			_In_ ULONG ObjectInformationLength);

	typedef enum _WAIT_TYPE {
		WaitAll,
		WaitAny,
		WaitNotification
	} WAIT_TYPE;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtWaitForSingleObject(
			_In_ HANDLE Handle,
			_In_ BOOLEAN Alertable,
			_In_opt_ PLARGE_INTEGER Timeout);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtWaitForMultipleObjects(
			_In_ ULONG Count,
			_In_reads_(Count) HANDLE Handles[],
			_In_ WAIT_TYPE WaitType,
			_In_ BOOLEAN Alertable,
			_In_opt_ PLARGE_INTEGER Timeout);

	/************************************************************************************
	*
	* Directory Object API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateDirectoryObject(
			_Out_ PHANDLE DirectoryHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateDirectoryObjectEx(
			_Out_ PHANDLE DirectoryHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ HANDLE ShadowDirectoryHandle,
			_In_ ULONG Flags);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenDirectoryObject(
			_Out_ PHANDLE DirectoryHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryDirectoryObject(
			_In_ HANDLE DirectoryHandle,
			_Out_writes_bytes_opt_(Length) PVOID Buffer,
			_In_ ULONG Length,
			_In_ BOOLEAN ReturnSingleEntry,
			_In_ BOOLEAN RestartScan,
			_Inout_ PULONG Context,
			_Out_opt_ PULONG ReturnLength);

	/************************************************************************************
	*
	* Private Namespace API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreatePrivateNamespace(
			_Out_ PHANDLE NamespaceHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ PVOID BoundaryDescriptor);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenPrivateNamespace(
			_Out_ PHANDLE NamespaceHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ PVOID BoundaryDescriptor);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDeletePrivateNamespace(
			_In_ HANDLE NamespaceHandle);

	/************************************************************************************
	*
	* Symbolic Link API.
	*
	************************************************************************************/

	typedef struct _OBJECT_SYMBOLIC_LINK_V1 { //pre Win10 TH1
		LARGE_INTEGER CreationTime;
		UNICODE_STRING LinkTarget;
		ULONG DosDeviceDriveIndex;
	} OBJECT_SYMBOLIC_LINK_V1, * POBJECT_SYMBOLIC_LINK_V1;

	typedef struct _OBJECT_SYMBOLIC_LINK_V2 { //Win10 TH1/TH2
		LARGE_INTEGER CreationTime;
		UNICODE_STRING LinkTarget;
		ULONG DosDeviceDriveIndex;
		ULONG Flags;
	} OBJECT_SYMBOLIC_LINK_V2, * POBJECT_SYMBOLIC_LINK_V2;

	typedef struct _OBJECT_SYMBOLIC_LINK_V3 { //Win10 RS1
		LARGE_INTEGER CreationTime;
		UNICODE_STRING LinkTarget;
		ULONG DosDeviceDriveIndex;
		ULONG Flags;
		ULONG AccessMask;
	} OBJECT_SYMBOLIC_LINK_V3, * POBJECT_SYMBOLIC_LINK_V3;

	typedef struct _OBJECT_SYMBOLIC_LINK_V4 { //Win10 RS2+
		LARGE_INTEGER CreationTime;
		union {
			UNICODE_STRING LinkTarget;
			struct {
				PVOID Callback;
				PVOID CallbackContext;
			};
		} u1;
		ULONG DosDeviceDriveIndex;
		ULONG Flags;
		ULONG AccessMask;
	} OBJECT_SYMBOLIC_LINK_V4, * POBJECT_SYMBOLIC_LINK_V4;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateSymbolicLinkObject(
			_Out_ PHANDLE LinkHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ PUNICODE_STRING LinkTarget);

	NTSYSAPI
		NTSTATUS
		WINAPI
		NtOpenSymbolicLinkObject(
			_Out_ PHANDLE LinkHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQuerySymbolicLinkObject(
			_In_ HANDLE LinkHandle,
			_Inout_ PUNICODE_STRING LinkTarget,
			_Out_opt_ PULONG  ReturnedLength);

	/************************************************************************************
	*
	* File API (+Driver&HotPatch).
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateFile(
			_Out_ PHANDLE FileHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_opt_ PLARGE_INTEGER AllocationSize,
			_In_ ULONG FileAttributes,
			_In_ ULONG ShareAccess,
			_In_ ULONG CreateDisposition,
			_In_ ULONG CreateOptions,
			_In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
			_In_ ULONG EaLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateNamedPipeFile(
			_Out_ PHANDLE FileHandle,
			_In_ ULONG DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ ULONG ShareAccess,
			_In_ ULONG CreateDisposition,
			_In_ ULONG CreateOptions,
			_In_ ULONG NamedPipeType,
			_In_ ULONG ReadMode,
			_In_ ULONG CompletionMode,
			_In_ ULONG MaximumInstances,
			_In_ ULONG InboundQuota,
			_In_ ULONG OutboundQuota,
			_In_opt_ PLARGE_INTEGER DefaultTimeout);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateMailslotFile(
			_Out_ PHANDLE FileHandle,
			_In_ ULONG DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ ULONG CreateOptions,
			_In_ ULONG MailslotQuota,
			_In_ ULONG MaximumMessageSize,
			_In_ PLARGE_INTEGER ReadTimeout);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDeviceIoControlFile(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ ULONG IoControlCode,
			_In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
			_In_ ULONG InputBufferLength,
			_Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
			_In_ ULONG OutputBufferLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtFsControlFile(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ ULONG FsControlCode,
			_In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
			_In_ ULONG InputBufferLength,
			_Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
			_In_ ULONG OutputBufferLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenFile(
			_Out_ PHANDLE FileHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ ULONG ShareAccess,
			_In_ ULONG OpenOptions);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReadFile(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_Out_writes_bytes_(Length) PVOID Buffer,
			_In_ ULONG Length,
			_In_opt_ PLARGE_INTEGER ByteOffset,
			_In_opt_ PULONG Key);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtWriteFile(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_reads_bytes_(Length) PVOID Buffer,
			_In_ ULONG Length,
			_In_opt_ PLARGE_INTEGER ByteOffset,
			_In_opt_ PULONG Key);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLockFile(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ PLARGE_INTEGER ByteOffset,
			_In_ PLARGE_INTEGER Length,
			_In_ ULONG Key,
			_In_ BOOLEAN FailImmediately,
			_In_ BOOLEAN ExclusiveLock);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtUnlockFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ PLARGE_INTEGER ByteOffset,
			_In_ PLARGE_INTEGER Length,
			_In_ ULONG Key);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtFlushBuffersFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetInformationFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ PVOID FileInformation,
			_In_ ULONG Length,
			_In_ FILE_INFORMATION_CLASS FileInformationClass);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDeleteFile(
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryInformationFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_Out_writes_bytes_(Length) PVOID FileInformation,
			_In_ ULONG Length,
			_In_ FILE_INFORMATION_CLASS FileInformationClass);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryFullAttributesFile(
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryDirectoryFile(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_Out_writes_bytes_(Length) PVOID FileInformation,
			_In_ ULONG Length,
			_In_ FILE_INFORMATION_CLASS FileInformationClass,
			_In_ BOOLEAN ReturnSingleEntry,
			_In_opt_ PUNICODE_STRING FileName,
			_In_ BOOLEAN RestartScan);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryEaFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_Out_writes_bytes_(Length) PVOID Buffer,
			_In_ ULONG Length,
			_In_ BOOLEAN ReturnSingleEntry,
			_In_reads_bytes_opt_(EaListLength) PVOID EaList,
			_In_ ULONG EaListLength,
			_In_opt_ PULONG EaIndex,
			_In_ BOOLEAN RestartScan);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetEaFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_bytecount_(Length) PVOID Buffer,
			_In_ ULONG Length);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryVolumeInformationFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_Out_writes_bytes_(Length) PVOID FsInformation,
			_In_ ULONG Length,
			_In_ FS_INFORMATION_CLASS FsInformationClass);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryQuotaInformationFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_Out_writes_bytes_(Length) PVOID Buffer,
			_In_ ULONG Length,
			_In_ BOOLEAN ReturnSingleEntry,
			_In_reads_bytes_opt_(SidListLength) PVOID SidList,
			_In_ ULONG SidListLength,
			_In_opt_ PSID StartSid,
			_In_ BOOLEAN RestartScan);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetQuotaInformationFile(
			_In_ HANDLE FileHandle,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_reads_bytes_(Length) PVOID Buffer,
			_In_ ULONG Length);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReadFileScatter(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ PFILE_SEGMENT_ELEMENT SegmentArray,
			_In_ ULONG Length,
			_In_opt_ PLARGE_INTEGER ByteOffset,
			_In_opt_ PULONG Key);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtWriteFileGather(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ PFILE_SEGMENT_ELEMENT SegmentArray,
			_In_ ULONG Length,
			_In_opt_ PLARGE_INTEGER ByteOffset,
			_In_opt_ PULONG Key);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryDirectoryFile(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_Out_writes_bytes_(Length) PVOID FileInformation,
			_In_ ULONG Length,
			_In_ FILE_INFORMATION_CLASS FileInformationClass,
			_In_ BOOLEAN ReturnSingleEntry,
			_In_opt_ PUNICODE_STRING FileName,
			_In_ BOOLEAN RestartScan);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtNotifyChangeDirectoryFile(
			_In_ HANDLE FileHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_Out_writes_bytes_(Length) PVOID Buffer,
			_In_ ULONG Length,
			_In_ ULONG CompletionFilter,
			_In_ BOOLEAN WatchTree);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLoadDriver(
			_In_ PUNICODE_STRING DriverServiceName);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtUnloadDriver(
			_In_ PUNICODE_STRING DriverServiceName);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLoadHotPatch(
			_In_ PUNICODE_STRING HotPatchName,
			_Reserved_ ULONG LoadFlag);

	/************************************************************************************
	*
	* Section API (+MemoryPartitions).
	*
	************************************************************************************/

#define MEM_EXECUTE_OPTION_DISABLE 0x1
#define MEM_EXECUTE_OPTION_ENABLE 0x2
#define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x4
#define MEM_EXECUTE_OPTION_PERMANENT 0x8
#define MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE 0x10
#define MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE 0x20
#define MEM_EXECUTE_OPTION_VALID_FLAGS 0x3f

	typedef enum _MEMORY_PARTITION_INFORMATION_CLASS {
		SystemMemoryPartitionInformation,
		SystemMemoryPartitionMoveMemory,
		SystemMemoryPartitionAddPagefile,
		SystemMemoryPartitionCombineMemory,
		SystemMemoryPartitionInitialAddMemory,
		SystemMemoryPartitionGetMemoryEvents,
		SystemMemoryPartitionMax
	} MEMORY_PARTITION_INFORMATION_CLASS;

	typedef struct _MEMORY_PARTITION_PAGE_RANGE {
		ULONG_PTR StartPage;
		ULONG_PTR NumberOfPages;
	} MEMORY_PARTITION_PAGE_RANGE, * PMEMORY_PARTITION_PAGE_RANGE;

	typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION {
		ULONG Flags;
		ULONG NumberOfRanges;
		ULONG_PTR NumberOfPagesAdded;
		MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
	} MEMORY_PARTITION_INITIAL_ADD_INFORMATION, * PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

	typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
		PVOID StopHandle;
		ULONG Flags;
		ULONG_PTR TotalNumberOfPages;
	} MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, * PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

	typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION {
		UNICODE_STRING PageFileName;
		LARGE_INTEGER MinimumSize;
		LARGE_INTEGER MaximumSize;
		ULONG Flags;
	} MEMORY_PARTITION_PAGEFILE_INFORMATION, * PMEMORY_PARTITION_PAGEFILE_INFORMATION;

	typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION {
		ULONG_PTR NumberOfPages;
		ULONG NumaNode;
		ULONG Flags;
	} MEMORY_PARTITION_TRANSFER_INFORMATION, * PMEMORY_PARTITION_TRANSFER_INFORMATION;

	typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION {
		ULONG Flags;
		ULONG NumaNode;
		ULONG Channel;
		ULONG NumberOfNumaNodes;
		ULONG_PTR ResidentAvailablePages;
		ULONG_PTR CommittedPages;
		ULONG_PTR CommitLimit;
		ULONG_PTR PeakCommitment;
		ULONG_PTR TotalNumberOfPages;
		ULONG_PTR AvailablePages;
		ULONG_PTR ZeroPages;
		ULONG_PTR FreePages;
		ULONG_PTR StandbyPages;
	} MEMORY_PARTITION_CONFIGURATION_INFORMATION, * PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateSection(
			_Out_ PHANDLE SectionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ PLARGE_INTEGER MaximumSize,
			_In_ ULONG SectionPageProtection,
			_In_ ULONG AllocationAttributes,
			_In_opt_ HANDLE FileHandle);

	//taken from ph2
	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateSectionEx(
			_Out_ PHANDLE SectionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ PLARGE_INTEGER MaximumSize,
			_In_ ULONG SectionPageProtection,
			_In_ ULONG AllocationAttributes,
			_In_opt_ HANDLE FileHandle,
			_In_ PMEM_EXTENDED_PARAMETER ExtendedParameters,
			_In_ ULONG ExtendedParameterCount);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenSection(
			_Out_ PHANDLE SectionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtMapViewOfSection(
			_In_ HANDLE SectionHandle,
			_In_ HANDLE ProcessHandle,
			_Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID* BaseAddress,
			_In_ ULONG_PTR ZeroBits,
			_In_ SIZE_T CommitSize,
			_Inout_opt_ PLARGE_INTEGER SectionOffset,
			_Inout_ PSIZE_T ViewSize,
			_In_ SECTION_INHERIT InheritDisposition,
			_In_ ULONG AllocationType,
			_In_ ULONG Win32Protect);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtUnmapViewOfSection(
			_In_ HANDLE ProcessHandle,
			_In_opt_ PVOID BaseAddress);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtUnmapViewOfSectionEx(
			_In_ HANDLE ProcessHandle,
			_In_opt_ PVOID BaseAddress,
			_In_ ULONG Flags);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQuerySection(
			_In_ HANDLE SectionHandle,
			_In_ SECTION_INFORMATION_CLASS SectionInformationClass,
			_Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
			_In_ SIZE_T SectionInformationLength,
			_Out_opt_ PSIZE_T ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtExtendSection(
			_In_ HANDLE SectionHandle,
			_Inout_ PLARGE_INTEGER NewSectionSize);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtMapUserPhysicalPages(
			_In_ PVOID VirtualAddress,
			_In_ ULONG_PTR NumberOfPages,
			_In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtMapUserPhysicalPagesScatter(
			_In_reads_(NumberOfPages) PVOID* VirtualAddresses,
			_In_ ULONG_PTR NumberOfPages,
			_In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAllocateUserPhysicalPages(
			_In_ HANDLE ProcessHandle,
			_Inout_ PULONG_PTR NumberOfPages,
			_Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtFreeUserPhysicalPages(
			_In_ HANDLE ProcessHandle,
			_Inout_ PULONG_PTR NumberOfPages,
			_In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAreMappedFilesTheSame(
			_In_ PVOID File1MappedAsAnImage,
			_In_ PVOID File2MappedAsFile);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenPartition(
			_Out_ PHANDLE PartitionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtManagePartition(
			_In_ HANDLE TargetHandle,
			_In_opt_ HANDLE SourceHandle,
			_In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
			_In_ PVOID PartitionInformation,
			_In_ ULONG PartitionInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreatePartition(
			_Out_ PHANDLE PartitionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ ULONG PreferredNode);

	/************************************************************************************
	*
	* Token API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAccessCheck(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_In_ HANDLE ClientToken,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ PGENERIC_MAPPING GenericMapping,
			_Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
			_Inout_ PULONG PrivilegeSetLength,
			_Out_ PACCESS_MASK GrantedAccess,
			_Out_ PNTSTATUS AccessStatus);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAccessCheckByType(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_In_opt_ PSID PrincipalSelfSid,
			_In_ HANDLE ClientToken,
			_In_ ACCESS_MASK DesiredAccess,
			_In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
			_In_ ULONG ObjectTypeListLength,
			_In_ PGENERIC_MAPPING GenericMapping,
			_Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
			_Inout_ PULONG PrivilegeSetLength,
			_Out_ PACCESS_MASK GrantedAccess,
			_Out_ PNTSTATUS AccessStatus);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAccessCheckByTypeResultList(
			_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_In_opt_ PSID PrincipalSelfSid,
			_In_ HANDLE ClientToken,
			_In_ ACCESS_MASK DesiredAccess,
			_In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
			_In_ ULONG ObjectTypeListLength,
			_In_ PGENERIC_MAPPING GenericMapping,
			_Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
			_Inout_ PULONG PrivilegeSetLength,
			_Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
			_Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenObjectAuditAlarm(
			_In_ PUNICODE_STRING SubsystemName,
			_In_opt_ PVOID HandleId,
			_In_ PUNICODE_STRING ObjectTypeName,
			_In_ PUNICODE_STRING ObjectName,
			_In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
			_In_ HANDLE ClientToken,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ ACCESS_MASK GrantedAccess,
			_In_opt_ PPRIVILEGE_SET Privileges,
			_In_ BOOLEAN ObjectCreation,
			_In_ BOOLEAN AccessGranted,
			_Out_ PBOOLEAN GenerateOnClose);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCloseObjectAuditAlarm(
			_In_ PUNICODE_STRING SubsystemName,
			_In_opt_ PVOID HandleId,
			_In_ BOOLEAN GenerateOnClose);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDeleteObjectAuditAlarm(
			_In_ PUNICODE_STRING SubsystemName,
			_In_opt_ PVOID HandleId,
			_In_ BOOLEAN GenerateOnClose);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenProcessToken(
			_In_ HANDLE ProcessHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_Out_ PHANDLE TokenHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenProcessTokenEx(
			_In_ HANDLE ProcessHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ ULONG HandleAttributes,
			_Out_ PHANDLE TokenHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDuplicateToken(
			_In_ HANDLE ExistingTokenHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ BOOLEAN EffectiveOnly,
			_In_ TOKEN_TYPE TokenType,
			_Out_ PHANDLE NewTokenHandle);

#define DISABLE_MAX_PRIVILEGE   0x1 // winnt
#define SANDBOX_INERT           0x2 // winnt
#define LUA_TOKEN               0x4
#define WRITE_RESTRICT          0x8

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtFilterToken(
			_In_ HANDLE ExistingTokenHandle,
			_In_ ULONG Flags,
			_In_opt_ PTOKEN_GROUPS SidsToDisable,
			_In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
			_In_opt_ PTOKEN_GROUPS RestrictedSids,
			_Out_ PHANDLE NewTokenHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtImpersonateAnonymousToken(
			_In_ HANDLE ThreadHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryInformationToken(
			_In_ HANDLE TokenHandle,
			_In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
			_Out_writes_bytes_(TokenInformationLength) PVOID TokenInformation,
			_In_ ULONG TokenInformationLength,
			_Out_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetInformationToken(
			_In_ HANDLE TokenHandle,
			_In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
			_In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
			_In_ ULONG TokenInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenThreadToken(
			_In_ HANDLE ThreadHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ BOOLEAN OpenAsSelf,
			_Out_ PHANDLE TokenHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenThreadTokenEx(
			_In_ HANDLE ThreadHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ BOOLEAN OpenAsSelf,
			_In_ ULONG HandleAttributes,
			_Out_ PHANDLE TokenHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAdjustPrivilegesToken(
			_In_ HANDLE TokenHandle,
			_In_ BOOLEAN DisableAllPrivileges,
			_In_opt_ PTOKEN_PRIVILEGES NewState,
			_In_ ULONG BufferLength,
			_Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
			_Out_ _When_(PreviousState == NULL, _Out_opt_) PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAdjustGroupsToken(
			_In_ HANDLE TokenHandle,
			_In_ BOOLEAN ResetToDefault,
			_In_opt_ PTOKEN_GROUPS NewState,
			_In_opt_ ULONG BufferLength,
			_Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
			_Out_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCompareTokens(
			_In_ HANDLE FirstTokenHandle,
			_In_ HANDLE SecondTokenHandle,
			_Out_ PBOOLEAN Equal);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtPrivilegeCheck(
			_In_ HANDLE ClientToken,
			_Inout_ PPRIVILEGE_SET RequiredPrivileges,
			_Out_ PBOOLEAN Result);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateToken(
			_Out_ PHANDLE TokenHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ TOKEN_TYPE TokenType,
			_In_ PLUID AuthenticationId,
			_In_ PLARGE_INTEGER ExpirationTime,
			_In_ PTOKEN_USER User,
			_In_ PTOKEN_GROUPS Groups,
			_In_ PTOKEN_PRIVILEGES Privileges,
			_In_opt_ PTOKEN_OWNER Owner,
			_In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
			_In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
			_In_ PTOKEN_SOURCE TokenSource);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateTokenEx(
			_Out_ PHANDLE TokenHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ TOKEN_TYPE TokenType,
			_In_ PLUID AuthenticationId,
			_In_ PLARGE_INTEGER ExpirationTime,
			_In_ PTOKEN_USER User,
			_In_ PTOKEN_GROUPS Groups,
			_In_ PTOKEN_PRIVILEGES Privileges,
			_In_opt_ PVOID UserAttributes, // points to TOKEN_SECURITY_ATTRIBUTES_INFORMATION
			_In_opt_ PVOID DeviceAttributes, // points to PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
			_In_opt_ PTOKEN_GROUPS DeviceGroups,
			_In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
			_In_opt_ PTOKEN_OWNER Owner,
			_In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
			_In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
			_In_ PTOKEN_SOURCE TokenSource);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateLowBoxToken(
			_Out_ PHANDLE TokenHandle,
			_In_ HANDLE ExistingTokenHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ PSID PackageSid,
			_In_ ULONG CapabilityCount,
			_In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
			_In_ ULONG HandleCount,
			_In_reads_opt_(HandleCount) HANDLE* Handles);

	/************************************************************************************
	*
	* Registry API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateKey(
			_Out_ PHANDLE KeyHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_Reserved_ ULONG TitleIndex,
			_In_opt_ PUNICODE_STRING Class,
			_In_ ULONG CreateOptions,
			_Out_opt_ PULONG Disposition);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateKeyTransacted(
			_Out_ PHANDLE KeyHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_Reserved_ ULONG TitleIndex,
			_In_opt_ PUNICODE_STRING Class,
			_In_ ULONG CreateOptions,
			_In_ HANDLE TransactionHandle,
			_Out_opt_ PULONG Disposition);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenKey(
			_Out_ PHANDLE KeyHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenKeyEx(
			_Out_ PHANDLE KeyHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ ULONG OpenOptions);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenKeyTransacted(
			_Out_ PHANDLE KeyHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ HANDLE TransactionHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenKeyTransactedEx(
			_Out_ PHANDLE KeyHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ ULONG OpenOptions,
			_In_ HANDLE TransactionHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryKey(
			_In_ HANDLE KeyHandle,
			_In_ KEY_INFORMATION_CLASS KeyInformationClass,
			_Out_writes_bytes_opt_(Length) PVOID KeyInformation,
			_In_ ULONG Length,
			_Out_ PULONG ResultLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtEnumerateKey(
			_In_ HANDLE KeyHandle,
			_In_ ULONG Index,
			_In_ KEY_INFORMATION_CLASS KeyInformationClass,
			_Out_writes_bytes_opt_(Length) PVOID KeyInformation,
			_In_ ULONG Length,
			_Out_ PULONG ResultLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtEnumerateValueKey(
			_In_ HANDLE KeyHandle,
			_In_ ULONG Index,
			_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
			_Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
			_In_ ULONG Length,
			_Out_ PULONG ResultLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryValueKey(
			_In_ HANDLE KeyHandle,
			_In_ PUNICODE_STRING ValueName,
			_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
			_Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
			_In_ ULONG Length,
			_Out_ PULONG ResultLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryMultipleValueKey(
			_In_ HANDLE KeyHandle,
			_Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
			_In_ ULONG EntryCount,
			_Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
			_Inout_ PULONG BufferLength,
			_Out_opt_ PULONG RequiredBufferLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetValueKey(
			_In_ HANDLE KeyHandle,
			_In_ PUNICODE_STRING ValueName,
			_In_opt_ ULONG TitleIndex,
			_In_ ULONG Type,
			_In_reads_bytes_opt_(DataSize) PVOID Data,
			_In_ ULONG DataSize);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDeleteKey(
			_In_ HANDLE KeyHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDeleteValueKey(
			_In_ HANDLE KeyHandle,
			_In_ PUNICODE_STRING ValueName);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtRenameKey(
			_In_ HANDLE KeyHandle,
			_In_ PUNICODE_STRING NewName);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetInformationKey(
			_In_ HANDLE KeyHandle,
			_In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
			_In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
			_In_ ULONG KeySetInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtFlushKey(
			_In_ HANDLE KeyHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCompressKey(
			_In_ HANDLE Key);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLoadKey(
			_In_ POBJECT_ATTRIBUTES TargetKey,
			_In_ POBJECT_ATTRIBUTES SourceFile);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLoadKey2(
			_In_ POBJECT_ATTRIBUTES TargetKey,
			_In_ POBJECT_ATTRIBUTES SourceFile,
			_In_ ULONG Flags);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLoadKeyEx(
			_In_ POBJECT_ATTRIBUTES TargetKey,
			_In_ POBJECT_ATTRIBUTES SourceFile,
			_In_ ULONG Flags,
			_In_opt_ HANDLE TrustClassKey,
			_In_opt_ HANDLE Event,
			_In_opt_ ACCESS_MASK DesiredAccess,
			_Out_opt_ PHANDLE RootHandle,
			_Out_opt_ PIO_STATUS_BLOCK IoStatus);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSaveKey(
			_In_ HANDLE KeyHandle,
			_In_ HANDLE FileHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSaveKeyEx(
			_In_ HANDLE KeyHandle,
			_In_ HANDLE FileHandle,
			_In_ ULONG Format);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtUnloadKey(
			_In_ POBJECT_ATTRIBUTES TargetKey);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtUnloadKey2(
			_In_ POBJECT_ATTRIBUTES TargetKey,
			_In_ ULONG Flags);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtUnloadKeyEx(
			_In_ POBJECT_ATTRIBUTES TargetKey,
			_In_opt_ HANDLE Event);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtNotifyChangeKey(
			_In_ HANDLE KeyHandle,
			_In_opt_ HANDLE Event,
			_In_opt_ PIO_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_ ULONG CompletionFilter,
			_In_ BOOLEAN WatchTree,
			_Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
			_In_ ULONG BufferSize,
			_In_ BOOLEAN Asynchronous);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLockRegistryKey(
			_In_ HANDLE KeyHandle);

	/************************************************************************************
	*
	* Job API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAssignProcessToJobObject(
			_In_ HANDLE JobHandle,
			_In_ HANDLE ProcessHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateJobObject(
			_Out_ PHANDLE JobHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateJobSet(
			_In_ ULONG NumJob,
			_In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
			_In_ ULONG Flags);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtIsProcessInJob(
			_In_ HANDLE ProcessHandle,
			_In_opt_ HANDLE JobHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenJobObject(
			_Out_ PHANDLE JobHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryInformationJobObject(
			_In_opt_ HANDLE JobHandle,
			_In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
			_Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
			_In_ ULONG JobObjectInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetInformationJobObject(
			_In_ HANDLE JobHandle,
			_In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
			_In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
			_In_ ULONG JobObjectInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtTerminateJobObject(
			_In_ HANDLE JobHandle,
			_In_ NTSTATUS ExitStatus);

	/************************************************************************************
	*
	* Session API.
	*
	************************************************************************************/

	//taken from ph2

	typedef enum _IO_SESSION_EVENT {
		IoSessionEventIgnore,
		IoSessionEventCreated,
		IoSessionEventTerminated,
		IoSessionEventConnected,
		IoSessionEventDisconnected,
		IoSessionEventLogon,
		IoSessionEventLogoff,
		IoSessionEventMax
	} IO_SESSION_EVENT;

	typedef enum _IO_SESSION_STATE {
		IoSessionStateCreated,
		IoSessionStateInitialized,
		IoSessionStateConnected,
		IoSessionStateDisconnected,
		IoSessionStateDisconnectedLoggedOn,
		IoSessionStateLoggedOn,
		IoSessionStateLoggedOff,
		IoSessionStateTerminated,
		IoSessionStateMax
	} IO_SESSION_STATE;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenSession(
			_Out_ PHANDLE SessionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtNotifyChangeSession(
			_In_ HANDLE SessionHandle,
			_In_ ULONG ChangeSequenceNumber,
			_In_ PLARGE_INTEGER ChangeTimeStamp,
			_In_ IO_SESSION_EVENT Event,
			_In_ IO_SESSION_STATE NewState,
			_In_ IO_SESSION_STATE PreviousState,
			_In_reads_bytes_opt_(PayloadSize) PVOID Payload,
			_In_ ULONG PayloadSize);

	/************************************************************************************
	*
	* IO Completion API.
	*
	************************************************************************************/

	typedef enum _IO_COMPLETION_INFORMATION_CLASS {
		IoCompletionBasicInformation
	} IO_COMPLETION_INFORMATION_CLASS;

	typedef struct _IO_COMPLETION_BASIC_INFORMATION {
		LONG Depth;
	} IO_COMPLETION_BASIC_INFORMATION, * PIO_COMPLETION_BASIC_INFORMATION;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateIoCompletion(
			_Out_ PHANDLE IoCompletionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ ULONG Count);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenIoCompletion(
			_Out_ PHANDLE IoCompletionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryIoCompletion(
			_In_ HANDLE IoCompletionHandle,
			_In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
			_Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
			_In_ ULONG IoCompletionInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetIoCompletion(
			_In_ HANDLE IoCompletionHandle,
			_In_opt_ PVOID KeyContext,
			_In_opt_ PVOID ApcContext,
			_In_ NTSTATUS IoStatus,
			_In_ ULONG_PTR IoStatusInformation);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetIoCompletionEx(
			_In_ HANDLE IoCompletionHandle,
			_In_ HANDLE IoCompletionPacketHandle,
			_In_opt_ PVOID KeyContext,
			_In_opt_ PVOID ApcContext,
			_In_ NTSTATUS IoStatus,
			_In_ ULONG_PTR IoStatusInformation);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtRemoveIoCompletion(
			_In_ HANDLE IoCompletionHandle,
			_Out_ PVOID* KeyContext,
			_Out_ PVOID* ApcContext,
			_Out_ PIO_STATUS_BLOCK IoStatusBlock,
			_In_opt_ PLARGE_INTEGER Timeout);

	/************************************************************************************
	*
	* Transactions API.
	*
	************************************************************************************/

	//TmTx
	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateTransaction(
			_Out_ PHANDLE TransactionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ LPGUID Uow,
			_In_opt_ HANDLE TmHandle,
			_In_opt_ ULONG CreateOptions,
			_In_opt_ ULONG IsolationLevel,
			_In_opt_ ULONG IsolationFlags,
			_In_opt_ PLARGE_INTEGER Timeout,
			_In_opt_ PUNICODE_STRING Description);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenTransaction(
			_Out_ PHANDLE TransactionHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ LPGUID Uow,
			_In_opt_ HANDLE TmHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtRollbackTransaction(
			_In_ HANDLE TransactionHandle,
			_In_ BOOLEAN Wait);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCommitTransaction(
			_In_ HANDLE TransactionHandle,
			_In_ BOOLEAN Wait);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtFreezeTransactions(
			_In_ PLARGE_INTEGER FreezeTimeout,
			_In_ PLARGE_INTEGER ThawTimeout);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtThawTransactions(
			VOID);

	//TmRm
	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateResourceManager(
			_Out_ PHANDLE ResourceManagerHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ HANDLE TmHandle,
			_In_opt_ LPGUID ResourceManagerGuid,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ ULONG CreateOptions,
			_In_opt_ PUNICODE_STRING Description);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenResourceManager(
			_Out_ PHANDLE ResourceManagerHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ HANDLE TmHandle,
			_In_opt_ LPGUID ResourceManagerGuid,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

	//TmEn
	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateEnlistment(
			_Out_ PHANDLE EnlistmentHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ HANDLE ResourceManagerHandle,
			_In_ HANDLE TransactionHandle,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ ULONG CreateOptions,
			_In_ NOTIFICATION_MASK NotificationMask,
			_In_opt_ PVOID EnlistmentKey);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenEnlistment(
			_Out_ PHANDLE EnlistmentHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ HANDLE ResourceManagerHandle,
			_In_ LPGUID EnlistmentGuid,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

	//TmTm
	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateTransactionManager(
			_Out_ PHANDLE TmHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ PUNICODE_STRING LogFileName,
			_In_opt_ ULONG CreateOptions,
			_In_opt_ ULONG CommitStrength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenTransactionManager(
			_Out_ PHANDLE TmHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ PUNICODE_STRING LogFileName,
			_In_opt_ LPGUID TmIdentity,
			_In_opt_ ULONG OpenOptions);

	/************************************************************************************
	*
	* Process and Thread API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateUserProcess(
			_Out_ PHANDLE ProcessHandle,
			_Out_ PHANDLE ThreadHandle,
			_In_ ACCESS_MASK ProcessDesiredAccess,
			_In_ ACCESS_MASK ThreadDesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
			_In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
			_In_ ULONG ProcessFlags,
			_In_ ULONG ThreadFlags,
			_In_opt_ PVOID ProcessParameters,
			_Inout_ PPS_CREATE_INFO CreateInfo,
			_In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenProcess(
			_Out_ PHANDLE ProcessHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ PCLIENT_ID ClientId);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtTerminateProcess(
			_In_opt_ HANDLE ProcessHandle,
			_In_ NTSTATUS ExitStatus);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSuspendProcess(
			_In_ HANDLE ProcessHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtResumeProcess(
			_In_ HANDLE ProcessHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSuspendThread(
			_In_ HANDLE ThreadHandle,
			_Out_opt_ PULONG PreviousSuspendCount);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtResumeThread(
			_In_ HANDLE ThreadHandle,
			_Out_opt_ PULONG PreviousSuspendCount);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtOpenThread(
			_Out_ PHANDLE ThreadHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_opt_ PCLIENT_ID ClientId);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtTerminateThread(
			_In_opt_ HANDLE ThreadHandle,
			_In_ NTSTATUS ExitStatus);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtImpersonateThread(
			_In_ HANDLE ServerThreadHandle,
			_In_ HANDLE ClientThreadHandle,
			_In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetContextThread(
			_In_ HANDLE ThreadHandle,
			_In_ PCONTEXT ThreadContext);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtGetContextThread(
			_In_ HANDLE ThreadHandle,
			_Inout_ PCONTEXT ThreadContext);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryInformationThread(
			_In_ HANDLE ThreadHandle,
			_In_ THREADINFOCLASS ThreadInformationClass,
			_Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
			_In_ ULONG ThreadInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetInformationThread(
			_In_ HANDLE ThreadHandle,
			_In_ THREADINFOCLASS ThreadInformationClass,
			_In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
			_In_ ULONG ThreadInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryInformationProcess(
			_In_ HANDLE ProcessHandle,
			_In_ PROCESSINFOCLASS ProcessInformationClass,
			_Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
			_In_ ULONG ProcessInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetInformationProcess(
			_In_ HANDLE ProcessHandle,
			_In_ PROCESSINFOCLASS ProcessInformationClass,
			_In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
			_In_ ULONG ProcessInformationLength);

	typedef VOID(*PPS_APC_ROUTINE) (
		_In_opt_ PVOID ApcArgument1,
		_In_opt_ PVOID ApcArgument2,
		_In_opt_ PVOID ApcArgument3);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueueApcThread(
			_In_ HANDLE ThreadHandle,
			_In_ PPS_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcArgument1,
			_In_opt_ PVOID ApcArgument2,
			_In_opt_ PVOID ApcArgument3);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueueApcThreadEx(
			_In_ HANDLE ThreadHandle,
			_In_opt_ HANDLE UserApcReserveHandle,
			_In_ PPS_APC_ROUTINE ApcRoutine,
			_In_opt_ PVOID ApcArgument1,
			_In_opt_ PVOID ApcArgument2,
			_In_opt_ PVOID ApcArgument3);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtYieldExecution(
			VOID);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtTestAlert(
			VOID);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateProcessEx(
			_Out_ PHANDLE ProcessHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ HANDLE ParentProcess,
			_In_ ULONG Flags,
			_In_opt_ HANDLE SectionHandle,
			_In_opt_ HANDLE DebugPort,
			_In_opt_ HANDLE ExceptionPort,
			_In_ BOOLEAN InJob);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateThreadEx(
			_Out_ PHANDLE ThreadHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ HANDLE ProcessHandle,
			_In_ PVOID StartRoutine,
			_In_opt_ PVOID Argument,
			_In_ ULONG CreateFlags, //THREAD_CREATE_FLAGS_*
			_In_opt_ ULONG_PTR ZeroBits,
			_In_opt_ SIZE_T StackSize,
			_In_opt_ SIZE_T MaximumStackSize,
			_In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

	NTSYSAPI
		ULONG
		NTAPI
		NtGetCurrentProcessorNumber(
			VOID);

	/************************************************************************************
	*
	* License API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryLicenseValue(
			_In_ PUNICODE_STRING ValueName,
			_Out_opt_ PULONG Type,
			_Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
			_In_ ULONG DataSize,
			_Out_ PULONG ResultDataSize);

	/************************************************************************************
	*
	* Virtual Memory API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAllocateVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID* BaseAddress,
			_In_ ULONG_PTR ZeroBits,
			_Inout_ PSIZE_T RegionSize,
			_In_ ULONG AllocationType,
			_In_ ULONG Protect);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtFreeVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_Inout_ PVOID* BaseAddress,
			_Inout_ PSIZE_T RegionSize,
			_In_ ULONG FreeType);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_In_opt_ PVOID BaseAddress,
			_In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
			_Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
			_In_ SIZE_T MemoryInformationLength,
			_Out_opt_ PSIZE_T ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetInformationVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
			_In_ ULONG_PTR NumberOfEntries,
			_In_reads_(NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
			_In_reads_bytes_(VmInformationLength) PVOID VmInformation,
			_In_ ULONG VmInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReadVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_In_opt_ PVOID BaseAddress,
			_Out_writes_bytes_(BufferSize) PVOID Buffer,
			_In_ SIZE_T BufferSize,
			_Out_opt_ PSIZE_T NumberOfBytesRead);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtWriteVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_In_opt_ PVOID BaseAddress,
			_In_reads_bytes_(BufferSize) PVOID Buffer,
			_In_ SIZE_T BufferSize,
			_Out_opt_ PSIZE_T NumberOfBytesWritten);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtProtectVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_Inout_ PVOID* BaseAddress,
			_Inout_ PSIZE_T RegionSize,
			_In_ ULONG NewProtect,
			_Out_ PULONG OldProtect);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLockVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_Inout_ PVOID* BaseAddress,
			_Inout_ PSIZE_T RegionSize,
			_In_ ULONG MapType);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtUnlockVirtualMemory(
			_In_ HANDLE ProcessHandle,
			_Inout_ PVOID* BaseAddress,
			_Inout_ PSIZE_T RegionSize,
			_In_ ULONG MapType);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtFlushInstructionCache(
			_In_ HANDLE ProcessHandle,
			_In_opt_ PVOID BaseAddress,
			_In_ SIZE_T Length);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreatePagingFile(
			_In_ PUNICODE_STRING PageFileName,
			_In_ PLARGE_INTEGER MinimumSize,
			_In_ PLARGE_INTEGER MaximumSize,
			_In_ ULONG Priority);

	/************************************************************************************
	*
	* Port API.
	*
	************************************************************************************/

	typedef struct _PORT_VIEW {
		ULONG Length;
		HANDLE SectionHandle;
		ULONG SectionOffset;
		SIZE_T ViewSize;
		PVOID ViewBase;
		PVOID ViewRemoteBase;
	} PORT_VIEW, * PPORT_VIEW;

	typedef struct _REMOTE_PORT_VIEW {
		ULONG Length;
		SIZE_T ViewSize;
		PVOID ViewBase;
	} REMOTE_PORT_VIEW, * PREMOTE_PORT_VIEW;

	typedef struct _PORT_MESSAGE {
		union {
			struct {
				CSHORT DataLength;
				CSHORT TotalLength;
			} s1;
			ULONG Length;
		} u1;
		union {
			struct {
				CSHORT Type;
				CSHORT DataInfoOffset;
			} s2;
			ULONG ZeroInit;
		} u2;
		union {
			CLIENT_ID ClientId;
			double DoNotUseThisField;       // Force quadword alignment
		} u3;
		ULONG MessageId;
		union {
			ULONG ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
			ULONG CallbackId;                   // Only valid on LPC_REQUEST message
		} u4;
		UCHAR Reserved[8];
	} PORT_MESSAGE, * PPORT_MESSAGE;

	typedef struct _PORT_DATA_ENTRY {
		PVOID Base;
		ULONG Size;
	} PORT_DATA_ENTRY, * PPORT_DATA_ENTRY;

	typedef struct _PORT_DATA_INFORMATION {
		ULONG CountDataEntries;
		PORT_DATA_ENTRY DataEntries[1];
	} PORT_DATA_INFORMATION, * PPORT_DATA_INFORMATION;

#define LPC_REQUEST             1
#define LPC_REPLY               2
#define LPC_DATAGRAM            3
#define LPC_LOST_REPLY          4
#define LPC_PORT_CLOSED         5
#define LPC_CLIENT_DIED         6
#define LPC_EXCEPTION           7
#define LPC_DEBUG_EVENT         8
#define LPC_ERROR_EVENT         9
#define LPC_CONNECTION_REQUEST 10

#define PORT_VALID_OBJECT_ATTRIBUTES (OBJ_CASE_INSENSITIVE)
#define PORT_MAXIMUM_MESSAGE_LENGTH 256

	typedef struct _LPC_CLIENT_DIED_MSG {
		PORT_MESSAGE PortMsg;
		LARGE_INTEGER CreateTime;
	} LPC_CLIENT_DIED_MSG, * PLPC_CLIENT_DIED_MSG;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreatePort(
			_Out_ PHANDLE PortHandle,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ ULONG MaxConnectionInfoLength,
			_In_ ULONG MaxMessageLength,
			_In_ ULONG MaxPoolUsage);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCompleteConnectPort(
			_In_ HANDLE PortHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtListenPort(
			_In_ HANDLE PortHandle,
			_Out_ PPORT_MESSAGE ConnectionRequest);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReplyPort(
			_In_ HANDLE PortHandle,
			_In_ PPORT_MESSAGE ReplyMessage);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReplyWaitReplyPort(
			_In_ HANDLE PortHandle,
			_Inout_ PPORT_MESSAGE ReplyMessage);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtRequestPort(
			_In_ HANDLE PortHandle,
			_In_ PPORT_MESSAGE RequestMessage);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtRequestWaitReplyPort(
			_In_ HANDLE PortHandle,
			_In_ PPORT_MESSAGE RequestMessage,
			_Out_ PPORT_MESSAGE ReplyMessage);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtClosePort(
			_In_ HANDLE PortHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReplyWaitReceivePort(
			_In_ HANDLE PortHandle,
			_Out_opt_ PVOID* PortContext,
			_In_opt_ PPORT_MESSAGE ReplyMessage,
			_Out_ PPORT_MESSAGE ReceiveMessage);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtWriteRequestData(
			_In_ HANDLE PortHandle,
			_In_ PPORT_MESSAGE Message,
			_In_ ULONG DataEntryIndex,
			_In_ PVOID Buffer,
			_In_ ULONG BufferSize,
			_Out_opt_ PULONG NumberOfBytesWritten);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReadRequestData(
			_In_ HANDLE PortHandle,
			_In_ PPORT_MESSAGE Message,
			_In_ ULONG DataEntryIndex,
			_Out_ PVOID Buffer,
			_In_ ULONG BufferSize,
			_Out_opt_ PULONG NumberOfBytesRead);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtConnectPort(
			_Out_ PHANDLE PortHandle,
			_In_ PUNICODE_STRING PortName,
			_In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
			_Inout_opt_ PPORT_VIEW ClientView,
			_Out_opt_ PREMOTE_PORT_VIEW ServerView,
			_Out_opt_ PULONG MaxMessageLength,
			_Inout_opt_	PVOID ConnectionInformation,
			_Inout_opt_	PULONG ConnectionInformationLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAcceptConnectPort(
			_Out_ PHANDLE PortHandle,
			_In_opt_ PVOID PortContext,
			_In_ PPORT_MESSAGE ConnectionRequest,
			_In_ BOOLEAN AcceptConnection,
			_Inout_opt_ PPORT_VIEW ServerView,
			_Out_opt_ PREMOTE_PORT_VIEW ClientView);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSecureConnectPort(
			_Out_ PHANDLE PortHandle,
			_In_ PUNICODE_STRING PortName,
			_In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
			_Inout_opt_ PPORT_VIEW ClientView,
			_In_opt_ PSID RequiredServerSid,
			_Inout_opt_ PREMOTE_PORT_VIEW ServerView,
			_Out_opt_ PULONG MaxMessageLength,
			_Inout_opt_ PVOID ConnectionInformation,
			_Inout_opt_ PULONG ConnectionInformationLength);

	/************************************************************************************
	*
	* Boot Management API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtEnumerateBootEntries(
			_Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
			_Inout_ PULONG BufferLength);

	/************************************************************************************
	*
	* Reserve Objects API.
	*
	************************************************************************************/

	typedef enum _MEMORY_RESERVE_TYPE {
		MemoryReserveUserApc,
		MemoryReserveIoCompletion,
		MemoryReserveTypeMax
	} MEMORY_RESERVE_TYPE;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtAllocateReserveObject(
			_Out_ PHANDLE MemoryReserveHandle,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ MEMORY_RESERVE_TYPE Type);

	/************************************************************************************
	*
	* Debug API.
	*
	************************************************************************************/

	//
	// Define the debug object thats used to attatch to processes that are being debugged.
	//
#define DEBUG_OBJECT_DELETE_PENDING (0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE  (0x2) // Kill all debugged processes on close

	typedef struct _DEBUG_OBJECT {
		//
		// Event thats set when the EventList is populated.
		//
		KEVENT EventsPresent;
		//
		// Mutex to protect the structure
		//
		FAST_MUTEX Mutex;
		//
		// Queue of events waiting for debugger intervention
		//
		LIST_ENTRY EventList;
		//
		// Flags for the object
		//
		ULONG Flags;
	} DEBUG_OBJECT, * PDEBUG_OBJECT;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateDebugObject(
			_Out_ PHANDLE DebugObjectHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ ULONG Flags);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtDebugActiveProcess(
			_In_ HANDLE ProcessHandle,
			_In_ HANDLE DebugObjectHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtRemoveProcessDebug(
			_In_ HANDLE ProcessHandle,
			_In_ HANDLE DebugObjectHandle);

	/************************************************************************************
	*
	* Profile API.
	*
	************************************************************************************/

	typedef enum _KPROFILE_SOURCE {
		ProfileTime,
		ProfileAlignmentFixup,
		ProfileTotalIssues,
		ProfilePipelineDry,
		ProfileLoadInstructions,
		ProfilePipelineFrozen,
		ProfileBranchInstructions,
		ProfileTotalNonissues,
		ProfileDcacheMisses,
		ProfileIcacheMisses,
		ProfileCacheMisses,
		ProfileBranchMispredictions,
		ProfileStoreInstructions,
		ProfileFpInstructions,
		ProfileIntegerInstructions,
		Profile2Issue,
		Profile3Issue,
		Profile4Issue,
		ProfileSpecialInstructions,
		ProfileTotalCycles,
		ProfileIcacheIssues,
		ProfileDcacheAccesses,
		ProfileMemoryBarrierCycles,
		ProfileLoadLinkedIssues,
		ProfileMaximum
	} KPROFILE_SOURCE;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateProfile(
			_Out_ PHANDLE ProfileHandle,
			_In_opt_ HANDLE Process,
			_In_ PVOID ProfileBase,
			_In_ SIZE_T ProfileSize,
			_In_ ULONG BucketSize,
			_In_reads_bytes_(BufferSize) PULONG Buffer,
			_In_ ULONG BufferSize,
			_In_ KPROFILE_SOURCE ProfileSource,
			_In_ KAFFINITY Affinity);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtStartProfile(
			_In_ HANDLE ProfileHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtStopProfile(
			_In_ HANDLE ProfileHandle);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryIntervalProfile(
			_In_ KPROFILE_SOURCE ProfileSource,
			_Out_ PULONG Interval);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSetIntervalProfile(
			_In_ ULONG Interval,
			_In_ KPROFILE_SOURCE Source);

	/************************************************************************************
	*
	* Worker Factory API.
	*
	************************************************************************************/

	typedef enum _WORKERFACTORYINFOCLASS {
		WorkerFactoryTimeout,
		WorkerFactoryRetryTimeout,
		WorkerFactoryIdleTimeout,
		WorkerFactoryBindingCount,
		WorkerFactoryThreadMinimum,
		WorkerFactoryThreadMaximum,
		WorkerFactoryPaused,
		WorkerFactoryBasicInformation,
		WorkerFactoryAdjustThreadGoal,
		WorkerFactoryCallbackType,
		WorkerFactoryStackInformation,
		WorkerFactoryThreadBasePriority,
		WorkerFactoryTimeoutWaiters,
		WorkerFactoryFlags,
		WorkerFactoryThreadSoftMaximum,
		MaxWorkerFactoryInfoClass
	} WORKERFACTORYINFOCLASS, * PWORKERFACTORYINFOCLASS;

	typedef struct _WORKER_FACTORY_BASIC_INFORMATION {
		LARGE_INTEGER Timeout;
		LARGE_INTEGER RetryTimeout;
		LARGE_INTEGER IdleTimeout;
		BOOLEAN Paused;
		BOOLEAN TimerSet;
		BOOLEAN QueuedToExWorker;
		BOOLEAN MayCreate;
		BOOLEAN CreateInProgress;
		BOOLEAN InsertedIntoQueue;
		BOOLEAN Shutdown;
		ULONG BindingCount;
		ULONG ThreadMinimum;
		ULONG ThreadMaximum;
		ULONG PendingWorkerCount;
		ULONG WaitingWorkerCount;
		ULONG TotalWorkerCount;
		ULONG ReleaseCount;
		LONGLONG InfiniteWaitGoal;
		PVOID StartRoutine;
		PVOID StartParameter;
		HANDLE ProcessId;
		SIZE_T StackReserve;
		SIZE_T StackCommit;
		NTSTATUS LastThreadCreationStatus;
	} WORKER_FACTORY_BASIC_INFORMATION, * PWORKER_FACTORY_BASIC_INFORMATION;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtCreateWorkerFactory(
			_Out_ PHANDLE WorkerFactoryHandleReturn,
			_In_ ACCESS_MASK DesiredAccess,
			_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
			_In_ HANDLE CompletionPortHandle,
			_In_ HANDLE WorkerProcessHandle,
			_In_ PVOID StartRoutine,
			_In_opt_ PVOID StartParameter,
			_In_opt_ ULONG MaxThreadCount,
			_In_opt_ SIZE_T StackReserve,
			_In_opt_ SIZE_T StackCommit);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtQueryInformationWorkerFactory(
			_In_ HANDLE WorkerFactoryHandle,
			_In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
			_Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
			_In_ ULONG WorkerFactoryInformationLength,
			_Out_opt_ PULONG ReturnLength);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtShutdownWorkerFactory(
			_In_ HANDLE WorkerFactoryHandle,
			_Inout_ volatile LONG* PendingWorkerCount);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtReleaseWorkerFactoryWorker(
			_In_ HANDLE WorkerFactoryHandle);

	/************************************************************************************
	*
	* Event Tracing API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtTraceEvent(
			_In_ HANDLE TraceHandle,
			_In_ ULONG Flags,
			_In_ ULONG FieldSize,
			_In_ PVOID Fields);

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtTraceControl(
			_In_ ULONG FunctionCode,
			_In_reads_bytes_opt_(InBufferLen) PVOID InBuffer,
			_In_ ULONG InBufferLen,
			_Out_writes_bytes_opt_(OutBufferLen) PVOID OutBuffer,
			_In_ ULONG OutBufferLen,
			_Out_ PULONG ReturnLength);

	/************************************************************************************
	*
	* Enclave API.
	*
	************************************************************************************/

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtLoadEnclaveData(
			_In_ HANDLE ProcessHandle,
			_In_ PVOID BaseAddress,
			_In_reads_bytes_(BufferSize) PVOID Buffer,
			_In_ SIZE_T BufferSize,
			_In_ ULONG Protect,
			_In_reads_bytes_(PageInformationLength) PVOID PageInformation,
			_In_ ULONG PageInformationLength,
			_Out_opt_ PSIZE_T NumberOfBytesWritten,
			_Out_opt_ PULONG EnclaveError);

	/************************************************************************************
	*
	* Kernel Debugger API.
	*
	************************************************************************************/

	typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
		BOOLEAN KernelDebuggerEnabled;
		BOOLEAN KernelDebuggerNotPresent;
	} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

	typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
		BOOLEAN DebuggerAllowed;
		BOOLEAN DebuggerEnabled;
		BOOLEAN DebuggerPresent;
	} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

	typedef enum _SYSDBG_COMMAND {
		SysDbgQueryModuleInformation,
		SysDbgQueryTraceInformation,
		SysDbgSetTracepoint,
		SysDbgSetSpecialCall,
		SysDbgClearSpecialCalls,
		SysDbgQuerySpecialCalls,
		SysDbgBreakPoint,
		SysDbgQueryVersion,
		SysDbgReadVirtual,
		SysDbgWriteVirtual,
		SysDbgReadPhysical,
		SysDbgWritePhysical,
		SysDbgReadControlSpace,
		SysDbgWriteControlSpace,
		SysDbgReadIoSpace,
		SysDbgWriteIoSpace,
		SysDbgReadMsr,
		SysDbgWriteMsr,
		SysDbgReadBusData,
		SysDbgWriteBusData,
		SysDbgCheckLowMemory,
		SysDbgEnableKernelDebugger,
		SysDbgDisableKernelDebugger,
		SysDbgGetAutoKdEnable,
		SysDbgSetAutoKdEnable,
		SysDbgGetPrintBufferSize,
		SysDbgSetPrintBufferSize,
		SysDbgGetKdUmExceptionEnable,
		SysDbgSetKdUmExceptionEnable,
		SysDbgGetTriageDump,
		SysDbgGetKdBlockEnable,
		SysDbgSetKdBlockEnable,
		SysDbgRegisterForUmBreakInfo,
		SysDbgGetUmBreakPid,
		SysDbgClearUmBreakPid,
		SysDbgGetUmAttachPid,
		SysDbgClearUmAttachPid,
		SysDbgGetLiveKernelDump
	} SYSDBG_COMMAND, * PSYSDBG_COMMAND;

	typedef struct _SYSDBG_VIRTUAL {
		PVOID Address;
		PVOID Buffer;
		ULONG Request;
	} SYSDBG_VIRTUAL, * PSYSDBG_VIRTUAL;

	NTSYSAPI
		NTSTATUS
		NTAPI
		NtSystemDebugControl(
			_In_ SYSDBG_COMMAND Command,
			_Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
			_In_ ULONG InputBufferLength,
			_Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
			_In_ ULONG OutputBufferLength,
			_Out_opt_ PULONG ReturnLength);

	/************************************************************************************
	*
	* Application Verifier API and definitions.
	*
	************************************************************************************/

#ifndef DLL_PROCESS_VERIFIER
#define DLL_PROCESS_VERIFIER 4
#endif

	typedef VOID(NTAPI* RTL_VERIFIER_DLL_LOAD_CALLBACK)(
		PWSTR DllName,
		PVOID DllBase,
		SIZE_T DllSize,
		PVOID Reserved);

	typedef VOID(NTAPI* RTL_VERIFIER_DLL_UNLOAD_CALLBACK)(
		PWSTR DllName,
		PVOID DllBase,
		SIZE_T DllSize,
		PVOID Reserved);

	typedef VOID(NTAPI* RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK)(
		PVOID AllocationBase,
		SIZE_T AllocationSize);

	typedef struct _RTL_VERIFIER_THUNK_DESCRIPTOR {
		PCHAR ThunkName;
		PVOID ThunkOldAddress;
		PVOID ThunkNewAddress;
	} RTL_VERIFIER_THUNK_DESCRIPTOR, * PRTL_VERIFIER_THUNK_DESCRIPTOR;

	typedef struct _RTL_VERIFIER_DLL_DESCRIPTOR {
		PWCHAR DllName;
		DWORD DllFlags;
		PVOID DllAddress;
		PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks;
	} RTL_VERIFIER_DLL_DESCRIPTOR, * PRTL_VERIFIER_DLL_DESCRIPTOR;

	typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR {
		DWORD Length;
		PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
		RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
		RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
		PWSTR VerifierImage;
		DWORD VerifierFlags;
		DWORD VerifierDebug;
		PVOID RtlpGetStackTraceAddress;
		PVOID RtlpDebugPageHeapCreate;
		PVOID RtlpDebugPageHeapDestroy;
		RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK ProviderNtdllHeapFreeCallback;
	} RTL_VERIFIER_PROVIDER_DESCRIPTOR, * PRTL_VERIFIER_PROVIDER_DESCRIPTOR;

	//
	// Application verifier standard flags.
	//
#define RTL_VRF_FLG_FULL_PAGE_HEAP                   0x00000001
#define RTL_VRF_FLG_RESERVED_DONOTUSE                0x00000002
#define RTL_VRF_FLG_HANDLE_CHECKS                    0x00000004
#define RTL_VRF_FLG_STACK_CHECKS                     0x00000008
#define RTL_VRF_FLG_APPCOMPAT_CHECKS                 0x00000010
#define RTL_VRF_FLG_TLS_CHECKS                       0x00000020
#define RTL_VRF_FLG_DIRTY_STACKS                     0x00000040
#define RTL_VRF_FLG_RPC_CHECKS                       0x00000080
#define RTL_VRF_FLG_COM_CHECKS                       0x00000100
#define RTL_VRF_FLG_DANGEROUS_APIS                   0x00000200
#define RTL_VRF_FLG_RACE_CHECKS                      0x00000400
#define RTL_VRF_FLG_DEADLOCK_CHECKS                  0x00000800
#define RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS    0x00001000
#define RTL_VRF_FLG_VIRTUAL_MEM_CHECKS               0x00002000
#define RTL_VRF_FLG_ENABLE_LOGGING                   0x00004000
#define RTL_VRF_FLG_FAST_FILL_HEAP                   0x00008000
#define RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING           0x00010000
#define RTL_VRF_FLG_ENABLED_SYSTEM_WIDE              0x00020000
#define RTL_VRF_FLG_MISCELLANEOUS_CHECKS             0x00020000
#define RTL_VRF_FLG_LOCK_CHECKS                      0x00040000

	NTSYSAPI
		VOID
		NTAPI
		RtlApplicationVerifierStop(
			_In_ ULONG_PTR Code,
			_In_ PSTR Message,
			_In_ ULONG_PTR Param1,
			_In_ PSTR Description1,
			_In_ ULONG_PTR Param2,
			_In_ PSTR Description2,
			_In_ ULONG_PTR Param3,
			_In_ PSTR Description3,
			_In_ ULONG_PTR Param4,
			_In_ PSTR Description4);

#ifndef VERIFIER_STOP
#define VERIFIER_STOP(Code, Msg, P1, S1, P2, S2, P3, S3, P4, S4) {  \
        RtlApplicationVerifierStop ((Code),                         \
                                    (Msg),                          \
                                    (ULONG_PTR)(P1),(S1),           \
                                    (ULONG_PTR)(P2),(S2),           \
                                    (ULONG_PTR)(P3),(S3),           \
                                    (ULONG_PTR)(P4),(S4));          \
  }
#endif


	//
	// NTOS_RTL HEADER END
	//

#pragma warning(pop)


#ifdef __cplusplus
}
#endif



```

`Broker/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Broker.rc
//

#ifdef _DEBUG
#define CFB_PATH_DRIVER_PATH_RSC   "..\\x64\\Debug\\IrpDumper.sys"
#else
#define CFB_PATH_DRIVER_PATH_RSC   "..\\x64\\Release\\IrpDumper.sys"
#endif

#define IDR_CFB_DRIVER1                 101

#define IDI_ICON3                       108
#define SUBLANG_ENGLISH_US              0x01

#define SW_HIDE                         0
#define HIDE_WINDOW                     0
#define WM_NULL                         0x0000
#define WA_INACTIVE                     0
#define HTNOWHERE                       0
#define SMTO_NORMAL                     0x0000
#define ICON_SMALL                      0
#define SIZE_RESTORED                   0
#define BN_CLICKED                      0
#define BST_UNCHECKED                   0x0000
#define HDS_HORZ                        0x0000
#define TBSTYLE_BUTTON                  0x0000
#define TBS_HORZ                        0x0000
#define TBS_BOTTOM                      0x0000
#define TBS_RIGHT                       0x0000
#define LVS_ICON                        0x0000
#define LVS_ALIGNTOP                    0x0000
#define TCS_TABS                        0x0000
#define TCS_SINGLELINE                  0x0000
#define TCS_RIGHTJUSTIFY                0x0000
#define DTS_SHORTDATEFORMAT             0x0000
#define PGS_VERT                        0x00000000
#define LANG_NEUTRAL                    0x00
#define SUBLANG_NEUTRAL                 0x00
#define SORT_DEFAULT                    0x0
#define SORT_JAPANESE_XJIS              0x0
#define SORT_CHINESE_BIG5               0x0
#define SORT_CHINESE_PRCP               0x0
#define SORT_KOREAN_KSC                 0x0
#define SORT_HUNGARIAN_DEFAULT          0x0
#define SORT_GEORGIAN_TRADITIONAL       0x0
#define _USE_DECLSPECS_FOR_SAL          0
#define _USE_ATTRIBUTES_FOR_SAL         0
#define __drv_typeConst                 0


#define SW_SHOWNORMAL                   1
#define SW_NORMAL                       1
#define SHOW_OPENWINDOW                 1
#define SW_PARENTCLOSING                1
#define VK_LBUTTON                      0x01
#define WM_CREATE                       0x0001
#define WA_ACTIVE                       1
#define PWR_OK                          1
#define PWR_SUSPENDREQUEST              1
#define NFR_ANSI                        1
#define UIS_SET                         1
#define UISF_HIDEFOCUS                  0x1
#define XBUTTON1                        0x0001
#define WMSZ_LEFT                       1
#define HTCLIENT                        1
#define SMTO_BLOCK                      0x0001
#define MA_ACTIVATE                     1
#define ICON_BIG                        1
#define SIZE_MINIMIZED                  1
#define MK_LBUTTON                      0x0001
#define TME_HOVER                       0x00000001
#define CS_VREDRAW                      0x0001
#define CF_TEXT                         1
#define SCF_ISSECURE                    0x00000001
#define IDOK                            1
#define BN_PAINT                        1
#define BST_CHECKED                     0x0001
#define TBSTYLE_SEP                     0x0001
#define TTS_ALWAYSTIP                   0x01
#define TBS_AUTOTICKS                   0x0001
#define UDS_WRAP                        0x0001
#define PBS_SMOOTH                      0x01
#define LWS_TRANSPARENT                 0x0001
#define LVS_REPORT                      0x0001
#define TVS_HASBUTTONS                  0x0001
#define TVS_EX_NOSINGLECOLLAPSE         0x0001
#define TCS_SCROLLOPPOSITE              0x0001
#define ACS_CENTER                      0x0001
#define MCS_DAYSTATE                    0x0001
#define DTS_UPDOWN                      0x0001
#define PGS_HORZ                        0x00000001
#define NFS_EDIT                        0x0001
#define BCSIF_GLYPH                     0x0001
#define BCSS_NOSPLIT                    0x0001
#define LANG_ARABIC                     0x01
#define SUBLANG_DEFAULT                 0x01
#define SUBLANG_AFRIKAANS_SOUTH_AFRICA  0x01
#define SUBLANG_ALBANIAN_ALBANIA        0x01
#define SUBLANG_ALSATIAN_FRANCE         0x01
#define SUBLANG_AMHARIC_ETHIOPIA        0x01
#define SUBLANG_ARABIC_SAUDI_ARABIA     0x01
#define SUBLANG_ARMENIAN_ARMENIA        0x01
#define SUBLANG_ASSAMESE_INDIA          0x01
#define SUBLANG_AZERI_LATIN             0x01
#define SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN 0x01
#define SUBLANG_BANGLA_INDIA            0x01
#define SUBLANG_BASHKIR_RUSSIA          0x01
#define SUBLANG_BASQUE_BASQUE           0x01
#define SUBLANG_BELARUSIAN_BELARUS      0x01
#define SUBLANG_BENGALI_INDIA           0x01
#define SUBLANG_BRETON_FRANCE           0x01
#define SUBLANG_BULGARIAN_BULGARIA      0x01
#define SUBLANG_CATALAN_CATALAN         0x01
#define SUBLANG_CENTRAL_KURDISH_IRAQ    0x01
#define SUBLANG_CHEROKEE_CHEROKEE       0x01
#define SUBLANG_CHINESE_TRADITIONAL     0x01
#define SUBLANG_CORSICAN_FRANCE         0x01
#define SUBLANG_CZECH_CZECH_REPUBLIC    0x01
#define SUBLANG_CROATIAN_CROATIA        0x01
#define SUBLANG_DANISH_DENMARK          0x01
#define SUBLANG_DARI_AFGHANISTAN        0x01
#define SUBLANG_DIVEHI_MALDIVES         0x01
#define SUBLANG_DUTCH                   0x01

#define SUBLANG_ESTONIAN_ESTONIA        0x01
#define SUBLANG_FAEROESE_FAROE_ISLANDS  0x01
#define SUBLANG_FILIPINO_PHILIPPINES    0x01
#define SUBLANG_FINNISH_FINLAND         0x01
#define SUBLANG_FRENCH                  0x01
#define SUBLANG_FRISIAN_NETHERLANDS     0x01
#define SUBLANG_GALICIAN_GALICIAN       0x01
#define SUBLANG_GEORGIAN_GEORGIA        0x01
#define SUBLANG_GERMAN                  0x01
#define SUBLANG_GREEK_GREECE            0x01
#define SUBLANG_GREENLANDIC_GREENLAND   0x01
#define SUBLANG_GUJARATI_INDIA          0x01
#define SUBLANG_HAUSA_NIGERIA_LATIN     0x01
#define SUBLANG_HAWAIIAN_US             0x01
#define SUBLANG_HEBREW_ISRAEL           0x01
#define SUBLANG_HINDI_INDIA             0x01
#define SUBLANG_HUNGARIAN_HUNGARY       0x01
#define SUBLANG_ICELANDIC_ICELAND       0x01
#define SUBLANG_IGBO_NIGERIA            0x01
#define SUBLANG_INDONESIAN_INDONESIA    0x01
#define SUBLANG_INUKTITUT_CANADA        0x01
#define SUBLANG_ITALIAN                 0x01
#define SUBLANG_JAPANESE_JAPAN          0x01
#define SUBLANG_KANNADA_INDIA           0x01
#define SUBLANG_KAZAK_KAZAKHSTAN        0x01
#define SUBLANG_KHMER_CAMBODIA          0x01
#define SUBLANG_KICHE_GUATEMALA         0x01
#define SUBLANG_KINYARWANDA_RWANDA      0x01
#define SUBLANG_KONKANI_INDIA           0x01
#define SUBLANG_KOREAN                  0x01
#define SUBLANG_KYRGYZ_KYRGYZSTAN       0x01
#define SUBLANG_LAO_LAO                 0x01
#define SUBLANG_LATVIAN_LATVIA          0x01
#define SUBLANG_LITHUANIAN              0x01
#define SUBLANG_LUXEMBOURGISH_LUXEMBOURG 0x01
#define SUBLANG_MACEDONIAN_MACEDONIA    0x01
#define SUBLANG_MALAY_MALAYSIA          0x01
#define SUBLANG_MALAYALAM_INDIA         0x01
#define SUBLANG_MALTESE_MALTA           0x01
#define SUBLANG_MAORI_NEW_ZEALAND       0x01
#define SUBLANG_MAPUDUNGUN_CHILE        0x01
#define SUBLANG_MARATHI_INDIA           0x01
#define SUBLANG_MOHAWK_MOHAWK           0x01
#define SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA 0x01
#define SUBLANG_NEPALI_NEPAL            0x01
#define SUBLANG_NORWEGIAN_BOKMAL        0x01
#define SUBLANG_OCCITAN_FRANCE          0x01
#define SUBLANG_ODIA_INDIA              0x01
#define SUBLANG_ORIYA_INDIA             0x01
#define SUBLANG_PASHTO_AFGHANISTAN      0x01
#define SUBLANG_PERSIAN_IRAN            0x01
#define SUBLANG_POLISH_POLAND           0x01
#define SUBLANG_PORTUGUESE_BRAZILIAN    0x01
#define SUBLANG_PUNJABI_INDIA           0x01
#define SUBLANG_QUECHUA_BOLIVIA         0x01
#define SUBLANG_ROMANIAN_ROMANIA        0x01
#define SUBLANG_ROMANSH_SWITZERLAND     0x01
#define SUBLANG_RUSSIAN_RUSSIA          0x01
#define SUBLANG_SAKHA_RUSSIA            0x01
#define SUBLANG_SAMI_NORTHERN_NORWAY    0x01
#define SUBLANG_SANSKRIT_INDIA          0x01
#define SUBLANG_SCOTTISH_GAELIC         0x01
#define SUBLANG_SERBIAN_CROATIA         0x01
#define SUBLANG_SINDHI_INDIA            0x01
#define SUBLANG_SINHALESE_SRI_LANKA     0x01
#define SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA 0x01
#define SUBLANG_SLOVAK_SLOVAKIA         0x01
#define SUBLANG_SLOVENIAN_SLOVENIA      0x01
#define SUBLANG_SPANISH                 0x01
#define SUBLANG_SWAHILI_KENYA           0x01
#define SUBLANG_SWEDISH                 0x01
#define SUBLANG_SYRIAC_SYRIA            0x01
#define SUBLANG_TAJIK_TAJIKISTAN        0x01
#define SUBLANG_TAMIL_INDIA             0x01
#define SUBLANG_TATAR_RUSSIA            0x01
#define SUBLANG_TELUGU_INDIA            0x01
#define SUBLANG_THAI_THAILAND           0x01
#define SUBLANG_TIBETAN_PRC             0x01
#define SUBLANG_TIGRINYA_ETHIOPIA       0x01
#define SUBLANG_TSWANA_SOUTH_AFRICA     0x01
#define SUBLANG_TURKISH_TURKEY          0x01
#define SUBLANG_TURKMEN_TURKMENISTAN    0x01
#define SUBLANG_UIGHUR_PRC              0x01
#define SUBLANG_UKRAINIAN_UKRAINE       0x01
#define SUBLANG_UPPER_SORBIAN_GERMANY   0x01
#define SUBLANG_URDU_PAKISTAN           0x01
#define SUBLANG_UZBEK_LATIN             0x01
#define SUBLANG_VIETNAMESE_VIETNAM      0x01
#define SUBLANG_WELSH_UNITED_KINGDOM    0x01
#define SUBLANG_WOLOF_SENEGAL           0x01
#define SUBLANG_XHOSA_SOUTH_AFRICA      0x01
#define SUBLANG_YAKUT_RUSSIA            0x01
#define SUBLANG_YI_PRC                  0x01
#define SUBLANG_YORUBA_NIGERIA          0x01
#define SUBLANG_ZULU_SOUTH_AFRICA       0x01
#define SORT_INVARIANT_MATH             0x1
#define SORT_JAPANESE_UNICODE           0x1
#define SORT_CHINESE_UNICODE            0x1
#define SORT_KOREAN_UNICODE             0x1
#define SORT_GERMAN_PHONE_BOOK          0x1
#define SORT_HUNGARIAN_TECHNICAL        0x1
#define SORT_GEORGIAN_MODERN            0x1
#define __drv_typeCond                  1
#define VS_VERSION_INFO                 1
#define VFFF_ISSHAREDFILE               0x0001
#define VFF_CURNEDEST                   0x0001
#define VIFF_FORCEINSTALL               0x0001
#define WINAPI_FAMILY_PC_APP            2

#define SW_SHOWMINIMIZED                2
#define SHOW_ICONWINDOW                 2
#define SW_OTHERZOOM                    2
#define VK_RBUTTON                      0x02
#define WM_DESTROY                      0x0002
#define WA_CLICKACTIVE                  2
#define PWR_SUSPENDRESUME               2
#define NFR_UNICODE                     2
#define UIS_CLEAR                       2
#define UISF_HIDEACCEL                  0x2
#define XBUTTON2                        0x0002
#define WMSZ_RIGHT                      2
#define HTCAPTION                       2
#define SMTO_ABORTIFHUNG                0x0002
#define MA_ACTIVATEANDEAT               2
#define ICON_SMALL2                     2
#define SIZE_MAXIMIZED                  2
#define MK_RBUTTON                      0x0002
#define TME_LEAVE                       0x00000002
#define CS_HREDRAW                      0x0002
#define CF_BITMAP                       2
#define IDCANCEL                        2
#define BN_HILITE                       2
#define BST_INDETERMINATE               0x0002
#define HDS_BUTTONS                     0x0002
#define TBSTYLE_CHECK                   0x0002
#define TTS_NOPREFIX                    0x02
#define TBS_VERT                        0x0002
#define UDS_SETBUDDYINT                 0x0002
#define LWS_IGNORERETURN                0x0002
#define LVS_SMALLICON                   0x0002
#define TVS_HASLINES                    0x0002
#define TVS_EX_MULTISELECT              0x0002
#define TCS_BOTTOM                      0x0002
#define TCS_RIGHT                       0x0002
#define ACS_TRANSPARENT                 0x0002
#define MCS_MULTISELECT                 0x0002
#define DTS_SHOWNONE                    0x0002
#define PGS_AUTOSCROLL                  0x00000002
#define NFS_STATIC                      0x0002
#define BCSIF_IMAGE                     0x0002
#define BCSS_STRETCH                    0x0002
#define LANG_BULGARIAN                  0x02
#define SUBLANG_SYS_DEFAULT             0x02
#define SUBLANG_ARABIC_IRAQ             0x02
#define SUBLANG_AZERI_CYRILLIC          0x02
#define SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC 0x02
#define SUBLANG_BANGLA_BANGLADESH       0x02
#define SUBLANG_BENGALI_BANGLADESH      0x02
#define SUBLANG_CHINESE_SIMPLIFIED      0x02
#define SUBLANG_DUTCH_BELGIAN           0x02
#define SUBLANG_ENGLISH_UK              0x02
#define SUBLANG_FRENCH_BELGIAN          0x02
#define SUBLANG_FULAH_SENEGAL           0x02
#define SUBLANG_GERMAN_SWISS            0x02
#define SUBLANG_INUKTITUT_CANADA_LATIN  0x02
#define SUBLANG_IRISH_IRELAND           0x02
#define SUBLANG_ITALIAN_SWISS           0x02
#define SUBLANG_KASHMIRI_SASIA          0x02
#define SUBLANG_KASHMIRI_INDIA          0x02
#define SUBLANG_LOWER_SORBIAN_GERMANY   0x02
#define SUBLANG_MALAY_BRUNEI_DARUSSALAM 0x02
#define SUBLANG_MONGOLIAN_PRC           0x02
#define SUBLANG_NEPALI_INDIA            0x02
#define SUBLANG_NORWEGIAN_NYNORSK       0x02
#define SUBLANG_PORTUGUESE              0x02
#define SUBLANG_PULAR_SENEGAL           0x02
#define SUBLANG_PUNJABI_PAKISTAN        0x02
#define SUBLANG_QUECHUA_ECUADOR         0x02
#define SUBLANG_SAMI_NORTHERN_SWEDEN    0x02
#define SUBLANG_SERBIAN_LATIN           0x02
#define SUBLANG_SINDHI_PAKISTAN         0x02
#define SUBLANG_SINDHI_AFGHANISTAN      0x02
#define SUBLANG_SPANISH_MEXICAN         0x02
#define SUBLANG_SWEDISH_FINLAND         0x02
#define SUBLANG_TAMAZIGHT_ALGERIA_LATIN 0x02
#define SUBLANG_TAMIL_SRI_LANKA         0x02
#define SUBLANG_TIGRIGNA_ERITREA        0x02
#define SUBLANG_TIGRINYA_ERITREA        0x02
#define SUBLANG_TSWANA_BOTSWANA         0x02
#define SUBLANG_URDU_INDIA              0x02
#define SUBLANG_UZBEK_CYRILLIC          0x02
#define SUBLANG_VALENCIAN_VALENCIA      0x02
#define SORT_CHINESE_PRC                0x2
#define __drv_typeBitset                2
#define VFF_FILEINUSE                   0x0002
#define VIFF_DONTDELETEOLD              0x0002
#define WINAPI_FAMILY_PHONE_APP         3

#define SW_SHOWMAXIMIZED                3
#define SW_MAXIMIZE                     3
#define SHOW_FULLSCREEN                 3
#define SW_PARENTOPENING                3
#define VK_CANCEL                       0x03
#define WM_MOVE                         0x0003
#define PWR_CRITICALRESUME              3
#define NF_QUERY                        3
#define UIS_INITIALIZE                  3
#define WMSZ_TOP                        3
#define HTSYSMENU                       3
#define MA_NOACTIVATE                   3
#define SIZE_MAXSHOW                    3
#define CF_METAFILEPICT                 3
#define IDABORT                         3
#define BN_UNHILITE                     3
#define LVS_LIST                        0x0003
#define LVS_TYPEMASK                    0x0003
#define LANG_CATALAN                    0x03
#define LANG_VALENCIAN                  0x03
#define SUBLANG_CUSTOM_DEFAULT          0x03
#define SUBLANG_ARABIC_EGYPT            0x03
#define SUBLANG_CHINESE_HONGKONG        0x03
#define SUBLANG_ENGLISH_AUS             0x03
#define SUBLANG_FRENCH_CANADIAN         0x03
#define SUBLANG_GERMAN_AUSTRIAN         0x03
#define SUBLANG_QUECHUA_PERU            0x03
#define SUBLANG_SAMI_NORTHERN_FINLAND   0x03
#define SUBLANG_SERBIAN_CYRILLIC        0x03
#define SUBLANG_SPANISH_MODERN          0x03
#define SORT_CHINESE_BOPOMOFO           0x3
#define __drv_typeExpr                  3
#define WINAPI_FAMILY_SYSTEM            4

#define SW_SHOWNOACTIVATE               4
#define SHOW_OPENNOACTIVATE             4
#define SW_OTHERUNZOOM                  4
#define VK_MBUTTON                      0x04
#define NF_REQUERY                      4
#define UISF_ACTIVE                     0x4
#define WMSZ_TOPLEFT                    4
#define HTGROWBOX                       4
#define MA_NOACTIVATEANDEAT             4
#define SIZE_MAXHIDE                    4
#define MK_SHIFT                        0x0004
#define CF_SYLK                         4
#define IDRETRY                         4
#define BN_DISABLE                      4
#define BST_PUSHED                      0x0004
#define HDS_HOTTRACK                    0x0004
#define TBSTYLE_GROUP                   0x0004
#define TBS_TOP                         0x0004
#define TBS_LEFT                        0x0004
#define UDS_ALIGNRIGHT                  0x0004
#define PBS_VERTICAL                    0x04
#define LWS_NOPREFIX                    0x0004
#define LVS_SINGLESEL                   0x0004
#define TVS_LINESATROOT                 0x0004
#define TVS_EX_DOUBLEBUFFER             0x0004
#define TCS_MULTISELECT                 0x0004
#define ACS_AUTOPLAY                    0x0004
#define MCS_WEEKNUMBERS                 0x0004
#define DTS_LONGDATEFORMAT              0x0004
#define PGS_DRAGNDROP                   0x00000004
#define NFS_LISTCOMBO                   0x0004
#define BCSIF_STYLE                     0x0004
#define BCSS_ALIGNLEFT                  0x0004
#define LANG_CHINESE                    0x04
#define LANG_CHINESE_SIMPLIFIED         0x04
#define SUBLANG_CUSTOM_UNSPECIFIED      0x04
#define SUBLANG_ARABIC_LIBYA            0x04
#define SUBLANG_CHINESE_SINGAPORE       0x04
#define SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN 0x04
#define SUBLANG_ENGLISH_CAN             0x04
#define SUBLANG_FRENCH_SWISS            0x04
#define SUBLANG_GERMAN_LUXEMBOURG       0x04
#define SUBLANG_SAMI_LULE_NORWAY        0x04
#define SUBLANG_SPANISH_GUATEMALA       0x04
#define SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH 0x04
#define SORT_JAPANESE_RADICALSTROKE     0x4
#define SORT_CHINESE_RADICALSTROKE      0x4
#define VFF_BUFFTOOSMALL                0x0004
#define WINAPI_FAMILY_SERVER            5

#define SW_SHOW                         5
#define VK_XBUTTON1                     0x05
#define WM_SIZE                         0x0005
#define WMSZ_TOPRIGHT                   5
#define HTMENU                          5
#define CF_DIF                          5
#define IDIGNORE                        5
#define BN_DOUBLECLICKED                5
#define LANG_CZECH                      0x05
#define SUBLANG_UI_CUSTOM_DEFAULT       0x05
#define SUBLANG_ARABIC_ALGERIA          0x05
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN 0x05
#define SUBLANG_CHINESE_MACAU           0x05
#define SUBLANG_ENGLISH_NZ              0x05
#define SUBLANG_FRENCH_LUXEMBOURG       0x05
#define SUBLANG_GERMAN_LIECHTENSTEIN    0x05
#define SUBLANG_SAMI_LULE_SWEDEN        0x05
#define SUBLANG_SPANISH_COSTA_RICA      0x05
#define WINAPI_FAMILY_GAMES             6
#define SW_MINIMIZE                     6
#define VK_XBUTTON2                     0x06
#define WM_ACTIVATE                     0x0006
#define WMSZ_BOTTOM                     6
#define HTHSCROLL                       6
#define CF_TIFF                         6
#define IDYES                           6
#define BN_SETFOCUS                     6
#define LANG_DANISH                     0x06
#define SUBLANG_ARABIC_MOROCCO          0x06
#define SUBLANG_ENGLISH_EIRE            0x06
#define SUBLANG_FRENCH_MONACO           0x06
#define SUBLANG_SAMI_SOUTHERN_NORWAY    0x06
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN 0x06
#define SUBLANG_SPANISH_PANAMA          0x06
#define SW_SHOWMINNOACTIVE              7
#define WM_SETFOCUS                     0x0007
#define WMSZ_BOTTOMLEFT                 7
#define HTVSCROLL                       7
#define CF_OEMTEXT                      7
#define IDNO                            7
#define BN_KILLFOCUS                    7
#define LANG_GERMAN                     0x07
#define SUBLANG_ARABIC_TUNISIA          0x07
#define SUBLANG_ENGLISH_SOUTH_AFRICA    0x07
#define SUBLANG_SAMI_SOUTHERN_SWEDEN    0x07
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x07
#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07
#define SW_SHOWNA                       8
#define VK_BACK                         0x08
#define WM_KILLFOCUS                    0x0008
#define WMSZ_BOTTOMRIGHT                8
#define HTMINBUTTON                     8
#define SMTO_NOTIMEOUTIFNOTHUNG         0x0008
#define MK_CONTROL                      0x0008
#define CS_DBLCLKS                      0x0008
#define CF_DIB                          8
#define IDCLOSE                         8
#define BST_FOCUS                       0x0008
#define HDS_HIDDEN                      0x0008
#define TBSTYLE_DROPDOWN                0x0008
#define TBS_BOTH                        0x0008
#define UDS_ALIGNLEFT                   0x0008
#define PBS_MARQUEE                     0x08
#define LWS_USEVISUALSTYLE              0x0008
#define LVS_SHOWSELALWAYS               0x0008
#define TVS_EDITLABELS                  0x0008
#define TVS_EX_NOINDENTSTATE            0x0008
#define TCS_FLATBUTTONS                 0x0008
#define ACS_TIMER                       0x0008
#define MCS_NOTODAYCIRCLE               0x0008
#define NFS_BUTTON                      0x0008
#define BCSIF_SIZE                      0x0008
#define BCSS_IMAGE                      0x0008
#define LANG_GREEK                      0x08
#define SUBLANG_ARABIC_OMAN             0x08
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x08
#define SUBLANG_ENGLISH_JAMAICA         0x08
#define SUBLANG_SAMI_SKOLT_FINLAND      0x08
#define SUBLANG_SPANISH_VENEZUELA       0x08
#define SW_RESTORE                      9
#define VK_TAB                          0x09
#define HTMAXBUTTON                     9
#define CF_PALETTE                      9
#define IDHELP                          9
#define DTS_TIMEFORMAT                  0x0009
#define LANG_ENGLISH                    0x09
#define SUBLANG_ARABIC_YEMEN            0x09
#define SUBLANG_ENGLISH_CARIBBEAN       0x09
#define SUBLANG_SAMI_INARI_FINLAND      0x09
#define SUBLANG_SERBIAN_SERBIA_LATIN    0x09
#define SUBLANG_SPANISH_COLOMBIA        0x09
#define SW_SHOWDEFAULT                  10
#define WM_ENABLE                       0x000A
#define HTLEFT                          10
#define CF_PENDATA                      10
#define IDTRYAGAIN                      10
#define HELP_CONTEXTMENU                0x000a
#define LANG_SPANISH                    0x0a
#define SUBLANG_ARABIC_SYRIA            0x0a
#define SUBLANG_ENGLISH_BELIZE          0x0a
#define SUBLANG_SERBIAN_SERBIA_CYRILLIC 0x0a
#define SUBLANG_SPANISH_PERU            0x0a
#define SW_FORCEMINIMIZE                11
#define SW_MAX                          11
#define WM_SETREDRAW                    0x000B
#define HTRIGHT                         11
#define CF_RIFF                         11
#define IDCONTINUE                      11
#define HELP_FINDER                     0x000b
#define LANG_FINNISH                    0x0b
#define SUBLANG_ARABIC_JORDAN           0x0b
#define SUBLANG_ENGLISH_TRINIDAD        0x0b
#define SUBLANG_SERBIAN_MONTENEGRO_LATIN 0x0b
#define SUBLANG_SPANISH_ARGENTINA       0x0b
#define VK_CLEAR                        0x0C
#define WM_SETTEXT                      0x000C
#define HTTOP                           12
#define CF_WAVE                         12
#define HELP_WM_HELP                    0x000c
#define DTS_SHORTDATECENTURYFORMAT      0x000C
#define LANG_FRENCH                     0x0c
#define SUBLANG_ARABIC_LEBANON          0x0c
#define SUBLANG_ENGLISH_ZIMBABWE        0x0c
#define SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC 0x0c
#define SUBLANG_SPANISH_ECUADOR         0x0c
#define VK_RETURN                       0x0D
#define WM_GETTEXT                      0x000D
#define HTTOPLEFT                       13
#define CF_UNICODETEXT                  13
#define HELP_SETPOPUP_POS               0x000d
#define LANG_HEBREW                     0x0d
#define SUBLANG_ARABIC_KUWAIT           0x0d
#define SUBLANG_ENGLISH_PHILIPPINES     0x0d
#define SUBLANG_SPANISH_CHILE           0x0d
#define WM_GETTEXTLENGTH                0x000E
#define HTTOPRIGHT                      14
#define CF_ENHMETAFILE                  14
#define LANG_HUNGARIAN                  0x0e
#define SUBLANG_ARABIC_UAE              0x0e
#define SUBLANG_SPANISH_URUGUAY         0x0e
#define WM_PAINT                        0x000F
#define HTBOTTOM                        15
#define CF_HDROP                        15
#define LANG_ICELANDIC                  0x0f
#define SUBLANG_ARABIC_BAHRAIN          0x0f
#define SUBLANG_SPANISH_PARAGUAY        0x0f

#define VK_SHIFT                        0x10
#define WM_CLOSE                        0x0010
#define HTBOTTOMLEFT                    16
#define WVR_ALIGNTOP                    0x0010
#define MK_MBUTTON                      0x0010
#define TME_NONCLIENT                   0x00000010
#define CF_LOCALE                       16
#define HELP_TCARD_DATA                 0x0010
#define TBSTYLE_AUTOSIZE                0x0010
#define TTS_NOANIMATE                   0x10
#define TBS_NOTICKS                     0x0010
#define UDS_AUTOBUDDY                   0x0010
#define PBS_SMOOTHREVERSE               0x10
#define LWS_USECUSTOMTEXT               0x0010
#define LVS_SORTASCENDING               0x0010
#define TVS_DISABLEDRAGDROP             0x0010
#define TVS_EX_RICHTOOLTIP              0x0010
#define TCS_FORCEICONLEFT               0x0010
#define MCS_NOTODAY                     0x0010
#define DTS_APPCANPARSE                 0x0010
#define NFS_ALL                         0x0010
#define LANG_ITALIAN                    0x10
#define SUBLANG_ARABIC_QATAR            0x10
#define SUBLANG_ENGLISH_INDIA           0x10
#define SUBLANG_SPANISH_BOLIVIA         0x10
#define VK_CONTROL                      0x11
#define WM_QUERYENDSESSION              0x0011
#define HTBOTTOMRIGHT                   17
#define CF_DIBV5                        17
#define HELP_TCARD_OTHER_CALLER         0x0011
#define LANG_JAPANESE                   0x11
#define SUBLANG_ENGLISH_MALAYSIA        0x11
#define SUBLANG_SPANISH_EL_SALVADOR     0x11
#define VK_MENU                         0x12
#define WM_QUIT                         0x0012
#define HTBORDER                        18
#define CF_MAX                          18
#define LANG_KOREAN                     0x12
#define SUBLANG_ENGLISH_SINGAPORE       0x12
#define SUBLANG_SPANISH_HONDURAS        0x12
#define VK_PAUSE                        0x13
#define WM_QUERYOPEN                    0x0013
#define HTOBJECT                        19
#define LANG_DUTCH                      0x13
#define SUBLANG_SPANISH_NICARAGUA       0x13
#define VK_CAPITAL                      0x14
#define WM_ERASEBKGND                   0x0014
#define HTCLOSE                         20
#define LANG_NORWEGIAN                  0x14
#define SUBLANG_SPANISH_PUERTO_RICO     0x14
#define _SAL_VERSION                    20
#define VK_KANA                         0x15
#define VK_HANGEUL                      0x15
#define VK_HANGUL                       0x15
#define WM_SYSCOLORCHANGE               0x0015
#define HTHELP                          21
#define LANG_POLISH                     0x15
#define SUBLANG_SPANISH_US              0x15
#define WM_ENDSESSION                   0x0016
#define LANG_PORTUGUESE                 0x16
#define VK_JUNJA                        0x17
#define LANG_ROMANSH                    0x17

#define VK_FINAL                        0x18
#define WM_SHOWWINDOW                   0x0018
#define LANG_ROMANIAN                   0x18
#define VK_HANJA                        0x19
#define VK_KANJI                        0x19
#define LANG_RUSSIAN                    0x19
#define WM_WININICHANGE                 0x001A
#define LANG_BOSNIAN                    0x1a
#define LANG_CROATIAN                   0x1a
#define LANG_SERBIAN                    0x1a
#define VK_ESCAPE                       0x1B
#define WM_DEVMODECHANGE                0x001B
#define LANG_SLOVAK                     0x1b
#define VK_CONVERT                      0x1C
#define WM_ACTIVATEAPP                  0x001C
#define LANG_ALBANIAN                   0x1c
#define VK_NONCONVERT                   0x1D
#define WM_FONTCHANGE                   0x001D
#define LANG_SWEDISH                    0x1d
#define VK_ACCEPT                       0x1E
#define WM_TIMECHANGE                   0x001E
#define LANG_THAI                       0x1e
#define VK_MODECHANGE                   0x1F
#define WM_CANCELMODE                   0x001F
#define LANG_TURKISH                    0x1f
#define VK_SPACE                        0x20
#define WM_SETCURSOR                    0x0020
#define SMTO_ERRORONEXIT                0x0020
#define WVR_ALIGNLEFT                   0x0020
#define MK_XBUTTON1                     0x0020
#define CS_OWNDC                        0x0020
#define TBSTYLE_NOPREFIX                0x0020
#define TTS_NOFADE                      0x20
#define TBS_ENABLESELRANGE              0x0020
#define UDS_ARROWKEYS                   0x0020
#define LWS_RIGHT                       0x0020
#define LVS_SORTDESCENDING              0x0020
#define TVS_SHOWSELALWAYS               0x0020
#define TVS_EX_AUTOHSCROLL              0x0020
#define TCS_FORCELABELLEFT              0x0020
#define DTS_RIGHTALIGN                  0x0020
#define NFS_USEFONTASSOC                0x0020
#define LANG_URDU                       0x20
#define VK_PRIOR                        0x21
#define WM_MOUSEACTIVATE                0x0021
#define LANG_INDONESIAN                 0x21
#define VK_NEXT                         0x22
#define WM_CHILDACTIVATE                0x0022
#define LANG_UKRAINIAN                  0x22
#define VK_END                          0x23
#define WM_QUEUESYNC                    0x0023
#define LANG_BELARUSIAN                 0x23
#define VK_HOME                         0x24
#define WM_GETMINMAXINFO                0x0024
#define LANG_SLOVENIAN                  0x24
#define VK_LEFT                         0x25
#define LANG_ESTONIAN                   0x25
#define VK_UP                           0x26
#define WM_PAINTICON                    0x0026
#define LANG_LATVIAN                    0x26
#define VK_RIGHT                        0x27
#define WM_ICONERASEBKGND               0x0027
#define LANG_LITHUANIAN                 0x27
#define VK_DOWN                         0x28
#define WM_NEXTDLGCTL                   0x0028
#define LANG_TAJIK                      0x28
#define VK_SELECT                       0x29
#define LANG_FARSI                      0x29
#define LANG_PERSIAN                    0x29
#define VK_PRINT                        0x2A
#define WM_SPOOLERSTATUS                0x002A
#define LANG_VIETNAMESE                 0x2a
#define VK_EXECUTE                      0x2B
#define WM_DRAWITEM                     0x002B
#define LANG_ARMENIAN                   0x2b
#define VK_SNAPSHOT                     0x2C
#define WM_MEASUREITEM                  0x002C
#define LANG_AZERI                      0x2c
#define LANG_AZERBAIJANI                0x2c
#define VK_INSERT                       0x2D
#define WM_DELETEITEM                   0x002D
#define LANG_BASQUE                     0x2d
#define VK_DELETE                       0x2E
#define WM_VKEYTOITEM                   0x002E
#define LANG_LOWER_SORBIAN              0x2e
#define LANG_UPPER_SORBIAN              0x2e
#define VK_HELP                         0x2F
#define WM_CHARTOITEM                   0x002F
#define LANG_MACEDONIAN                 0x2f
#define WM_SETFONT                      0x0030
#define WM_GETFONT                      0x0031
#define WM_SETHOTKEY                    0x0032
#define LANG_TSWANA                     0x32
#define WM_GETHOTKEY                    0x0033
#define LANG_XHOSA                      0x34
#define LANG_ZULU                       0x35
#define LANG_AFRIKAANS                  0x36
#define WM_QUERYDRAGICON                0x0037
#define LANG_GEORGIAN                   0x37
#define LANG_FAEROESE                   0x38
#define WM_COMPAREITEM                  0x0039
#define LANG_HINDI                      0x39
#define LANG_MALTESE                    0x3a
#define LANG_SAMI                       0x3b
#define LANG_IRISH                      0x3c
#define WM_GETOBJECT                    0x003D
#define LANG_MALAY                      0x3e
#define LANG_KAZAK                      0x3f
#define WVR_ALIGNBOTTOM                 0x0040
#define MK_XBUTTON2                     0x0040
#define CS_CLASSDC                      0x0040
#define HDS_DRAGDROP                    0x0040
#define BTNS_SHOWTEXT                   0x0040
#define TTS_BALLOON                     0x40
#define TBS_FIXEDLENGTH                 0x0040
#define UDS_HORZ                        0x0040
#define LVS_SHAREIMAGELISTS             0x0040
#define TVS_RTLREADING                  0x0040
#define TVS_EX_FADEINOUTEXPANDOS        0x0040
#define TCS_HOTTRACK                    0x0040
#define MCS_NOTRAILINGDATES             0x0040
#define LANG_KYRGYZ                     0x40
#define WM_COMPACTING                   0x0041
#define LANG_SWAHILI                    0x41
#define LANG_TURKMEN                    0x42
#define LANG_UZBEK                      0x43
#define WM_COMMNOTIFY                   0x0044
#define LANG_TATAR                      0x44
#define LANG_BANGLA                     0x45
#define LANG_BENGALI                    0x45
#define WM_WINDOWPOSCHANGING            0x0046
#define LANG_PUNJABI                    0x46
#define WM_WINDOWPOSCHANGED             0x0047
#define LANG_GUJARATI                   0x47
#define WM_POWER                        0x0048
#define LANG_ODIA                       0x48
#define LANG_ORIYA                      0x48
#define LANG_TAMIL                      0x49
#define WM_COPYDATA                     0x004A
#define LANG_TELUGU                     0x4a
#define WM_CANCELJOURNAL                0x004B
#define LANG_KANNADA                    0x4b
#define LANG_MALAYALAM                  0x4c
#define LANG_ASSAMESE                   0x4d
#define WM_NOTIFY                       0x004E
#define LANG_MARATHI                    0x4e
#define LANG_SANSKRIT                   0x4f
#define WM_INPUTLANGCHANGEREQUEST       0x0050
#define LANG_MONGOLIAN                  0x50
#define WM_INPUTLANGCHANGE              0x0051
#define LANG_TIBETAN                    0x51
#define WM_TCARD                        0x0052
#define LANG_WELSH                      0x52
#define WM_HELP                         0x0053
#define LANG_KHMER                      0x53
#define WM_USERCHANGED                  0x0054
#define LANG_LAO                        0x54
#define WM_NOTIFYFORMAT                 0x0055
#define LANG_GALICIAN                   0x56
#define LANG_KONKANI                    0x57
#define LANG_MANIPURI                   0x58
#define LANG_SINDHI                     0x59
#define LANG_SYRIAC                     0x5a
#define VK_LWIN                         0x5B
#define LANG_SINHALESE                  0x5b
#define VK_RWIN                         0x5C
#define LANG_CHEROKEE                   0x5c
#define VK_APPS                         0x5D
#define LANG_INUKTITUT                  0x5d
#define LANG_AMHARIC                    0x5e
#define VK_SLEEP                        0x5F
#define LANG_TAMAZIGHT                  0x5f
#define VK_NUMPAD0                      0x60
#define LANG_KASHMIRI                   0x60
#define VK_NUMPAD1                      0x61
#define LANG_NEPALI                     0x61
#define VK_NUMPAD2                      0x62
#define LANG_FRISIAN                    0x62
#define VK_NUMPAD3                      0x63
#define LANG_PASHTO                     0x63
#define WINAPI_FAMILY_DESKTOP_APP       100
#define VK_NUMPAD4                      0x64
#define LANG_FILIPINO                   0x64
#define VS_USER_DEFINED                 100
#define VK_NUMPAD5                      0x65
#define LANG_DIVEHI                     0x65

#define VK_NUMPAD6                      0x66
#define VK_NUMPAD7                      0x67
#define LANG_FULAH                      0x67
#define LANG_PULAR                      0x67
#define VK_NUMPAD8                      0x68
#define LANG_HAUSA                      0x68
#define VK_NUMPAD9                      0x69
#define VK_MULTIPLY                     0x6A
#define LANG_YORUBA                     0x6a
#define VK_ADD                          0x6B
#define LANG_QUECHUA                    0x6b
#define VK_SEPARATOR                    0x6C
#define LANG_SOTHO                      0x6c

#define VK_SUBTRACT                     0x6D
#define LANG_BASHKIR                    0x6d
#define VK_DECIMAL                      0x6E
#define LANG_LUXEMBOURGISH              0x6e
#define VK_DIVIDE                       0x6F
#define LANG_GREENLANDIC                0x6f
#define VK_F1                           0x70
#define LANG_IGBO                       0x70
#define VK_F2                           0x71
#define VK_F3                           0x72
#define VK_F4                           0x73
#define LANG_TIGRIGNA                   0x73
#define LANG_TIGRINYA                   0x73
#define VK_F5                           0x74
#define VK_F6                           0x75
#define LANG_HAWAIIAN                   0x75
#define VK_F7                           0x76
#define VK_F8                           0x77
#define VK_F9                           0x78
#define WHEEL_DELTA                     120
#define LANG_YI                         0x78
#define VK_F10                          0x79
#define VK_F11                          0x7A
#define LANG_MAPUDUNGUN                 0x7a
#define VK_F12                          0x7B
#define WM_CONTEXTMENU                  0x007B
#define VK_F13                          0x7C
#define WM_STYLECHANGING                0x007C
#define LANG_MOHAWK                     0x7c
#define VK_F14                          0x7D
#define WM_STYLECHANGED                 0x007D
#define VK_F15                          0x7E
#define WM_DISPLAYCHANGE                0x007E
#define LANG_BRETON                     0x7e
#define VK_F16                          0x7F
#define WM_GETICON                      0x007F
#define LANG_INVARIANT                  0x7f
#define VK_F17                          0x80
#define WM_SETICON                      0x0080
#define WVR_ALIGNRIGHT                  0x0080
#define CS_PARENTDC                     0x0080
#define CF_OWNERDISPLAY                 0x0080
#define HDS_FULLDRAG                    0x0080
#define BTNS_WHOLEDROPDOWN              0x0080
#define TTS_CLOSE                       0x80
#define TBS_NOTHUMB                     0x0080
#define UDS_NOTHOUSANDS                 0x0080
#define LVS_NOLABELWRAP                 0x0080
#define TVS_NOTOOLTIPS                  0x0080
#define TVS_EX_PARTIALCHECKBOXES        0x0080
#define TCS_VERTICAL                    0x0080
#define MCS_SHORTDAYSOFWEEK             0x0080
#define LANG_UIGHUR                     0x80
#define VK_F18                          0x81
#define WM_NCCREATE                     0x0081
#define CF_DSPTEXT                      0x0081
#define LANG_MAORI                      0x81
#define VK_F19                          0x82
#define WM_NCDESTROY                    0x0082
#define CF_DSPBITMAP                    0x0082
#define LANG_OCCITAN                    0x82
#define VK_F20                          0x83
#define WM_NCCALCSIZE                   0x0083
#define CF_DSPMETAFILEPICT              0x0083
#define LANG_CORSICAN                   0x83
#define VK_F21                          0x84
#define WM_NCHITTEST                    0x0084
#define LANG_ALSATIAN                   0x84
#define VK_F22                          0x85
#define WM_NCPAINT                      0x0085
#define LANG_SAKHA                      0x85
#define LANG_YAKUT                      0x85
#define VK_F23                          0x86
#define WM_NCACTIVATE                   0x0086
#define LANG_KICHE                      0x86
#define VK_F24                          0x87
#define WM_GETDLGCODE                   0x0087
#define LANG_KINYARWANDA                0x87
#define VK_NAVIGATION_VIEW              0x88
#define WM_SYNCPAINT                    0x0088
#define LANG_WOLOF                      0x88
#define VK_NAVIGATION_MENU              0x89
#define VK_NAVIGATION_UP                0x8A
#define VK_NAVIGATION_DOWN              0x8B
#define VK_NAVIGATION_LEFT              0x8C
#define LANG_DARI                       0x8c
#define VK_NAVIGATION_RIGHT             0x8D
#define VK_NAVIGATION_ACCEPT            0x8E
#define CF_DSPENHMETAFILE               0x008E
#define VK_NAVIGATION_CANCEL            0x8F
#define VK_NUMLOCK                      0x90
#define VK_SCROLL                       0x91
#define LANG_SCOTTISH_GAELIC            0x91
#define VK_OEM_NEC_EQUAL                0x92
#define VK_OEM_FJ_JISHO                 0x92
#define LANG_CENTRAL_KURDISH            0x92
#define VK_OEM_FJ_MASSHOU               0x93
#define VK_OEM_FJ_TOUROKU               0x94
#define VK_OEM_FJ_LOYA                  0x95
#define VK_OEM_FJ_ROYA                  0x96
#define VK_LSHIFT                       0xA0
#define WM_NCMOUSEMOVE                  0x00A0
#define VK_RSHIFT                       0xA1
#define WM_NCLBUTTONDOWN                0x00A1
#define VK_LCONTROL                     0xA2
#define WM_NCLBUTTONUP                  0x00A2
#define VK_RCONTROL                     0xA3
#define WM_NCLBUTTONDBLCLK              0x00A3
#define VK_LMENU                        0xA4
#define WM_NCRBUTTONDOWN                0x00A4
#define VK_RMENU                        0xA5
#define WM_NCRBUTTONUP                  0x00A5
#define VK_BROWSER_BACK                 0xA6
#define WM_NCRBUTTONDBLCLK              0x00A6
#define VK_BROWSER_FORWARD              0xA7
#define WM_NCMBUTTONDOWN                0x00A7
#define VK_BROWSER_REFRESH              0xA8
#define WM_NCMBUTTONUP                  0x00A8
#define VK_BROWSER_STOP                 0xA9
#define WM_NCMBUTTONDBLCLK              0x00A9
#define VK_BROWSER_SEARCH               0xAA
#define VK_BROWSER_FAVORITES            0xAB
#define WM_NCXBUTTONDOWN                0x00AB
#define VK_BROWSER_HOME                 0xAC
#define WM_NCXBUTTONUP                  0x00AC
#define VK_VOLUME_MUTE                  0xAD
#define WM_NCXBUTTONDBLCLK              0x00AD
#define VK_VOLUME_DOWN                  0xAE
#define VK_VOLUME_UP                    0xAF
#define VK_MEDIA_NEXT_TRACK             0xB0
#define EM_GETSEL                       0x00B0
#define VK_MEDIA_PREV_TRACK             0xB1
#define EM_SETSEL                       0x00B1
#define VK_MEDIA_STOP                   0xB2
#define EM_GETRECT                      0x00B2
#define VK_MEDIA_PLAY_PAUSE             0xB3
#define EM_SETRECT                      0x00B3
#define VK_LAUNCH_MAIL                  0xB4
#define EM_SETRECTNP                    0x00B4
#define VK_LAUNCH_MEDIA_SELECT          0xB5
#define EM_SCROLL                       0x00B5
#define VK_LAUNCH_APP1                  0xB6
#define EM_LINESCROLL                   0x00B6
#define VK_LAUNCH_APP2                  0xB7
#define EM_SCROLLCARET                  0x00B7
#define EM_GETMODIFY                    0x00B8
#define EM_SETMODIFY                    0x00B9
#define VK_OEM_1                        0xBA
#define EM_GETLINECOUNT                 0x00BA
#define VK_OEM_PLUS                     0xBB
#define EM_LINEINDEX                    0x00BB
#define VK_OEM_COMMA                    0xBC
#define EM_SETHANDLE                    0x00BC
#define VK_OEM_MINUS                    0xBD
#define EM_GETHANDLE                    0x00BD
#define VK_OEM_PERIOD                   0xBE
#define EM_GETTHUMB                     0x00BE
#define VK_OEM_2                        0xBF
#define VK_OEM_3                        0xC0
#define EM_LINELENGTH                   0x00C1
#define EM_REPLACESEL                   0x00C2
#define VK_GAMEPAD_A                    0xC3
#define VK_GAMEPAD_B                    0xC4
#define EM_GETLINE                      0x00C4
#define VK_GAMEPAD_X                    0xC5
#define EM_LIMITTEXT                    0x00C5
#define VK_GAMEPAD_Y                    0xC6
#define EM_CANUNDO                      0x00C6
#define VK_GAMEPAD_RIGHT_SHOULDER       0xC7
#define EM_UNDO                         0x00C7
#define VK_GAMEPAD_LEFT_SHOULDER        0xC8
#define EM_FMTLINES                     0x00C8
#define VK_GAMEPAD_LEFT_TRIGGER         0xC9
#define EM_LINEFROMCHAR                 0x00C9
#define VK_GAMEPAD_RIGHT_TRIGGER        0xCA
#define VK_GAMEPAD_DPAD_UP              0xCB
#define EM_SETTABSTOPS                  0x00CB
#define VK_GAMEPAD_DPAD_DOWN            0xCC
#define EM_SETPASSWORDCHAR              0x00CC
#define VK_GAMEPAD_DPAD_LEFT            0xCD
#define EM_EMPTYUNDOBUFFER              0x00CD
#define VK_GAMEPAD_DPAD_RIGHT           0xCE
#define EM_GETFIRSTVISIBLELINE          0x00CE
#define VK_GAMEPAD_MENU                 0xCF
#define EM_SETREADONLY                  0x00CF
#define VK_GAMEPAD_VIEW                 0xD0
#define EM_SETWORDBREAKPROC             0x00D0
#define VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON 0xD1
#define EM_GETWORDBREAKPROC             0x00D1
#define VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON 0xD2
#define EM_GETPASSWORDCHAR              0x00D2
#define VK_GAMEPAD_LEFT_THUMBSTICK_UP   0xD3
#define EM_SETMARGINS                   0x00D3
#define VK_GAMEPAD_LEFT_THUMBSTICK_DOWN 0xD4
#define EM_GETMARGINS                   0x00D4
#define VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT 0xD5
#define EM_GETLIMITTEXT                 0x00D5
#define VK_GAMEPAD_LEFT_THUMBSTICK_LEFT 0xD6
#define EM_POSFROMCHAR                  0x00D6
#define VK_GAMEPAD_RIGHT_THUMBSTICK_UP  0xD7
#define EM_CHARFROMPOS                  0x00D7
#define VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN 0xD8
#define EM_SETIMESTATUS                 0x00D8
#define VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT 0xD9
#define EM_GETIMESTATUS                 0x00D9
#define VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT 0xDA
#define EM_ENABLEFEATURE                0x00DA
#define VK_OEM_4                        0xDB
#define VK_OEM_5                        0xDC
#define VK_OEM_6                        0xDD
#define VK_OEM_7                        0xDE
#define VK_OEM_8                        0xDF
#define VK_OEM_AX                       0xE1
#define VK_OEM_102                      0xE2
#define VK_ICO_HELP                     0xE3
#define VK_ICO_00                       0xE4
#define VK_PROCESSKEY                   0xE5
#define VK_ICO_CLEAR                    0xE6
#define VK_PACKET                       0xE7
#define VK_OEM_RESET                    0xE9
#define VK_OEM_JUMP                     0xEA
#define VK_OEM_PA1                      0xEB
#define VK_OEM_PA2                      0xEC
#define VK_OEM_PA3                      0xED
#define VK_OEM_WSCTRL                   0xEE
#define VK_OEM_CUSEL                    0xEF
#define VK_OEM_ATTN                     0xF0
#define BM_GETCHECK                     0x00F0
#define VK_OEM_FINISH                   0xF1
#define BM_SETCHECK                     0x00F1
#define VK_OEM_COPY                     0xF2
#define BM_GETSTATE                     0x00F2
#define VK_OEM_AUTO                     0xF3
#define BM_SETSTATE                     0x00F3
#define VK_OEM_ENLW                     0xF4
#define BM_SETSTYLE                     0x00F4
#define VK_OEM_BACKTAB                  0xF5
#define BM_CLICK                        0x00F5
#define VK_ATTN                         0xF6
#define BM_GETIMAGE                     0x00F6
#define VK_CRSEL                        0xF7
#define BM_SETIMAGE                     0x00F7
#define VK_EXSEL                        0xF8
#define BM_SETDONTCLICK                 0x00F8
#define VK_EREOF                        0xF9
#define VK_PLAY                         0xFA
#define VK_ZOOM                         0xFB
#define VK_NONAME                       0xFC
#define VK_PA1                          0xFD
#define VK_OEM_CLEAR                    0xFE
#define WM_INPUT_DEVICE_CHANGE          0x00FE
#define SUBVERSION_MASK                 0x000000FF
#define WM_INPUT                        0x00FF
#define WM_KEYFIRST                     0x0100
#define WM_KEYDOWN                      0x0100
#define WVR_HREDRAW                     0x0100
#define HDS_FILTERBAR                   0x0100
#define TBSTYLE_TOOLTIPS                0x0100
#define RBS_TOOLTIPS                    0x00000100
#define TTS_USEVISUALSTYLE              0x100
#define SBARS_SIZEGRIP                  0x0100
#define TBS_TOOLTIPS                    0x0100
#define UDS_HOTTRACK                    0x0100
#define LVS_AUTOARRANGE                 0x0100
#define TVS_CHECKBOXES                  0x0100
#define TVS_EX_EXCLUSIONCHECKBOXES      0x0100
#define TCS_BUTTONS                     0x0100
#define MCS_NOSELCHANGEONNAV            0x0100
#define WM_KEYUP                        0x0101
#define WM_CHAR                         0x0102
#define WM_DEADCHAR                     0x0103
#define WM_SYSKEYDOWN                   0x0104
#define WM_SYSKEYUP                     0x0105
#define WM_SYSCHAR                      0x0106
#define WM_SYSDEADCHAR                  0x0107
#define WM_UNICHAR                      0x0109
#define WM_KEYLAST                      0x0109
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F
#define WM_INITDIALOG                   0x0110
#define WM_COMMAND                      0x0111
#define WM_SYSCOMMAND                   0x0112
#define WM_TIMER                        0x0113
#define WM_HSCROLL                      0x0114
#define WM_VSCROLL                      0x0115
#define WM_INITMENU                     0x0116
#define WM_INITMENUPOPUP                0x0117
#define WM_GESTURE                      0x0119
#define WM_GESTURENOTIFY                0x011A
#define WM_MENUSELECT                   0x011F
#define WM_MENUCHAR                     0x0120
#define WM_ENTERIDLE                    0x0121
#define WM_MENURBUTTONUP                0x0122
#define WM_MENUDRAG                     0x0123
#define WM_MENUGETOBJECT                0x0124
#define WM_UNINITMENUPOPUP              0x0125
#define WM_MENUCOMMAND                  0x0126
#define WM_CHANGEUISTATE                0x0127
#define WM_UPDATEUISTATE                0x0128
#define WM_QUERYUISTATE                 0x0129
#define WM_CTLCOLORMSGBOX               0x0132
#define WM_CTLCOLOREDIT                 0x0133
#define WM_CTLCOLORLISTBOX              0x0134
#define WM_CTLCOLORBTN                  0x0135
#define WM_CTLCOLORDLG                  0x0136
#define WM_CTLCOLORSCROLLBAR            0x0137
#define WM_CTLCOLORSTATIC               0x0138
#define MN_GETHMENU                     0x01E1
#define _WIN32_IE_IE20                  0x0200
#define WM_MOUSEFIRST                   0x0200
#define WM_MOUSEMOVE                    0x0200
#define WVR_VREDRAW                     0x0200
#define CS_NOCLOSE                      0x0200
#define CF_PRIVATEFIRST                 0x0200
#define HDS_FLAT                        0x0200
#define TBSTYLE_WRAPABLE                0x0200
#define RBS_VARHEIGHT                   0x00000200
#define TBS_REVERSED                    0x0200
#define LVS_EDITLABELS                  0x0200
#define TVS_TRACKSELECT                 0x0200
#define TVS_EX_DIMMEDCHECKBOXES         0x0200
#define TCS_MULTILINE                   0x0200
#define WM_LBUTTONDOWN                  0x0201
#define WM_LBUTTONUP                    0x0202
#define WM_LBUTTONDBLCLK                0x0203
#define WM_RBUTTONDOWN                  0x0204
#define WM_RBUTTONUP                    0x0205
#define WM_RBUTTONDBLCLK                0x0206
#define WM_MBUTTONDOWN                  0x0207
#define WM_MBUTTONUP                    0x0208
#define WM_MBUTTONDBLCLK                0x0209
#define WM_MOUSEWHEEL                   0x020A
#define WM_XBUTTONDOWN                  0x020B
#define WM_XBUTTONUP                    0x020C
#define WM_XBUTTONDBLCLK                0x020D
#define WM_MOUSEHWHEEL                  0x020E
#define WM_MOUSELAST                    0x020E
#define WM_PARENTNOTIFY                 0x0210
#define WM_ENTERMENULOOP                0x0211
#define WM_EXITMENULOOP                 0x0212
#define WM_NEXTMENU                     0x0213
#define WM_SIZING                       0x0214
#define WM_CAPTURECHANGED               0x0215
#define WM_MOVING                       0x0216
#define WM_POWERBROADCAST               0x0218
#define WM_DEVICECHANGE                 0x0219
#define WM_MDICREATE                    0x0220
#define WM_MDIDESTROY                   0x0221
#define WM_MDIACTIVATE                  0x0222
#define WM_MDIRESTORE                   0x0223
#define WM_MDINEXT                      0x0224
#define WM_MDIMAXIMIZE                  0x0225
#define WM_MDITILE                      0x0226
#define WM_MDICASCADE                   0x0227
#define WM_MDIICONARRANGE               0x0228
#define WM_MDIGETACTIVE                 0x0229
#define WM_MDISETMENU                   0x0230
#define WM_ENTERSIZEMOVE                0x0231
#define WM_EXITSIZEMOVE                 0x0232
#define WM_DROPFILES                    0x0233
#define WM_MDIREFRESHMENU               0x0234
#define WM_POINTERDEVICECHANGE          0x238
#define WM_POINTERDEVICEINRANGE         0x239
#define WM_POINTERDEVICEOUTOFRANGE      0x23A
#define WM_TOUCH                        0x0240
#define WM_NCPOINTERUPDATE              0x0241
#define WM_NCPOINTERDOWN                0x0242
#define WM_NCPOINTERUP                  0x0243
#define WM_POINTERUPDATE                0x0245
#define WM_POINTERDOWN                  0x0246
#define WM_POINTERUP                    0x0247
#define WM_POINTERENTER                 0x0249
#define WM_POINTERLEAVE                 0x024A
#define WM_POINTERACTIVATE              0x024B
#define WM_POINTERCAPTURECHANGED        0x024C
#define WM_TOUCHHITTESTING              0x024D
#define WM_POINTERWHEEL                 0x024E
#define WM_POINTERHWHEEL                0x024F
#define DM_POINTERHITTEST               0x0250
#define WM_POINTERROUTEDTO              0x0251
#define WM_POINTERROUTEDAWAY            0x0252
#define WM_POINTERROUTEDRELEASED        0x0253
#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_REQUEST                  0x0288
#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291
#define WM_NCMOUSEHOVER                 0x02A0
#define WM_MOUSEHOVER                   0x02A1
#define WM_NCMOUSELEAVE                 0x02A2
#define WM_MOUSELEAVE                   0x02A3
#define WM_WTSSESSION_CHANGE            0x02B1
#define WM_TABLET_FIRST                 0x02c0
#define WM_TABLET_LAST                  0x02df
#define WM_DPICHANGED                   0x02E0
#define WM_DPICHANGED_BEFOREPARENT      0x02E2
#define WM_DPICHANGED_AFTERPARENT       0x02E3
#define WM_GETDPISCALEDSIZE             0x02E4
#define CF_PRIVATELAST                  0x02FF
#define _WIN32_IE_IE30                  0x0300
#define WM_CUT                          0x0300
#define CF_GDIOBJFIRST                  0x0300
#define WM_COPY                         0x0301
#define _WIN32_IE_IE302                 0x0302
#define WM_PASTE                        0x0302
#define WM_CLEAR                        0x0303
#define WM_UNDO                         0x0304
#define WM_RENDERFORMAT                 0x0305
#define WM_RENDERALLFORMATS             0x0306
#define WM_DESTROYCLIPBOARD             0x0307
#define WM_DRAWCLIPBOARD                0x0308
#define WM_PAINTCLIPBOARD               0x0309
#define WM_VSCROLLCLIPBOARD             0x030A
#define WM_SIZECLIPBOARD                0x030B
#define WM_ASKCBFORMATNAME              0x030C
#define WM_CHANGECBCHAIN                0x030D
#define WM_HSCROLLCLIPBOARD             0x030E
#define WM_QUERYNEWPALETTE              0x030F
#define WM_PALETTEISCHANGING            0x0310
#define WM_PALETTECHANGED               0x0311
#define WM_HOTKEY                       0x0312
#define WM_PRINT                        0x0317
#define WM_PRINTCLIENT                  0x0318
#define WM_APPCOMMAND                   0x0319
#define WM_THEMECHANGED                 0x031A
#define WM_CLIPBOARDUPDATE              0x031D
#define WM_DWMCOMPOSITIONCHANGED        0x031E
#define WM_DWMNCRENDERINGCHANGED        0x031F
#define WM_DWMCOLORIZATIONCOLORCHANGED  0x0320
#define WM_DWMWINDOWMAXIMIZEDCHANGE     0x0321
#define WM_DWMSENDICONICTHUMBNAIL       0x0323
#define WM_DWMSENDICONICLIVEPREVIEWBITMAP 0x0326
#define WM_GETTITLEBARINFOEX            0x033F
#define WM_HANDHELDFIRST                0x0358
#define WM_HANDHELDLAST                 0x035F
#define WM_AFXFIRST                     0x0360
#define WM_AFXLAST                      0x037F
#define WM_PENWINFIRST                  0x0380
#define WM_PENWINLAST                   0x038F
#define WM_DDE_FIRST                    0x03E0
#define CF_GDIOBJLAST                   0x03FF
#define _WIN32_WINNT_NT4                0x0400
#define _WIN32_IE_IE40                  0x0400
#define WM_USER                         0x0400
#define WVR_VALIDRECTS                  0x0400
#define HDS_CHECKBOXES                  0x0400
#define TBSTYLE_ALTDRAG                 0x0400
#define RBS_BANDBORDERS                 0x00000400
#define TBS_DOWNISLEFT                  0x0400
#define LVS_OWNERDRAWFIXED              0x0400
#define TVS_SINGLEEXPAND                0x0400
#define TVS_EX_DRAWIMAGEASYNC           0x0400
#define TCS_FIXEDWIDTH                  0x0400
#define ctlFirst                        0x0400
#define psh1                            0x0400
#define _WIN32_IE_IE401                 0x0401
#define psh2                            0x0401
#define psh3                            0x0402
#define psh4                            0x0403
#define psh5                            0x0404
#define psh6                            0x0405
#define psh7                            0x0406
#define psh8                            0x0407
#define psh9                            0x0408
#define psh10                           0x0409
#define psh11                           0x040a
#define psh12                           0x040b
#define psh13                           0x040c
#define psh14                           0x040d
#define psh15                           0x040e
#define psh16                           0x040f
#define _WIN32_WINDOWS                  0x0410
#define chx1                            0x0410
#define chx2                            0x0411
#define chx3                            0x0412
#define chx4                            0x0413
#define chx5                            0x0414
#define chx6                            0x0415
#define chx7                            0x0416
#define chx8                            0x0417
#define chx9                            0x0418
#define chx10                           0x0419
#define chx11                           0x041a
#define chx12                           0x041b
#define chx13                           0x041c
#define chx14                           0x041d
#define chx15                           0x041e
#define chx16                           0x041f
#define rad1                            0x0420
#define rad2                            0x0421
#define rad3                            0x0422
#define rad4                            0x0423
#define rad5                            0x0424
#define rad6                            0x0425
#define rad7                            0x0426
#define rad8                            0x0427
#define rad9                            0x0428
#define rad10                           0x0429
#define rad11                           0x042a
#define rad12                           0x042b
#define rad13                           0x042c
#define rad14                           0x042d
#define rad15                           0x042e
#define rad16                           0x042f
#define grp1                            0x0430
#define grp2                            0x0431
#define grp3                            0x0432
#define grp4                            0x0433
#define frm1                            0x0434
#define frm2                            0x0435
#define frm3                            0x0436
#define frm4                            0x0437
#define rct1                            0x0438
#define rct2                            0x0439
#define rct3                            0x043a
#define rct4                            0x043b
#define ico1                            0x043c
#define ico2                            0x043d
#define ico3                            0x043e
#define ico4                            0x043f
#define stc1                            0x0440
#define stc2                            0x0441
#define stc3                            0x0442
#define stc4                            0x0443
#define stc5                            0x0444
#define stc6                            0x0445
#define stc7                            0x0446
#define stc8                            0x0447
#define stc9                            0x0448
#define stc10                           0x0449
#define stc11                           0x044a
#define stc12                           0x044b
#define stc13                           0x044c
#define stc14                           0x044d
#define stc15                           0x044e
#define stc16                           0x044f
#define stc17                           0x0450
#define stc18                           0x0451
#define stc19                           0x0452
#define stc20                           0x0453
#define stc21                           0x0454
#define stc22                           0x0455
#define stc23                           0x0456
#define stc24                           0x0457
#define stc25                           0x0458
#define stc26                           0x0459
#define stc27                           0x045a
#define stc28                           0x045b
#define stc29                           0x045c
#define stc30                           0x045d
#define stc31                           0x045e
#define stc32                           0x045f
#define lst1                            0x0460
#define lst2                            0x0461
#define lst3                            0x0462
#define lst4                            0x0463
#define lst5                            0x0464
#define lst6                            0x0465
#define lst7                            0x0466
#define lst8                            0x0467
#define lst9                            0x0468
#define lst10                           0x0469
#define lst11                           0x046a
#define lst12                           0x046b
#define lst13                           0x046c
#define lst14                           0x046d
#define lst15                           0x046e
#define lst16                           0x046f
#define cmb1                            0x0470
#define cmb2                            0x0471
#define cmb3                            0x0472
#define cmb4                            0x0473
#define cmb5                            0x0474
#define cmb6                            0x0475
#define cmb7                            0x0476
#define cmb8                            0x0477
#define cmb9                            0x0478
#define cmb10                           0x0479
#define cmb11                           0x047a
#define cmb12                           0x047b
#define cmb13                           0x047c
#define cmb14                           0x047d
#define cmb15                           0x047e
#define cmb16                           0x047f
#define edt1                            0x0480
#define edt2                            0x0481
#define edt3                            0x0482
#define edt4                            0x0483
#define edt5                            0x0484
#define edt6                            0x0485
#define edt7                            0x0486
#define edt8                            0x0487
#define edt9                            0x0488
#define edt10                           0x0489
#define edt11                           0x048a
#define edt12                           0x048b
#define edt13                           0x048c
#define edt14                           0x048d
#define edt15                           0x048e
#define edt16                           0x048f
#define scr1                            0x0490
#define scr2                            0x0491
#define scr3                            0x0492
#define scr4                            0x0493
#define scr5                            0x0494
#define scr6                            0x0495
#define scr7                            0x0496
#define scr8                            0x0497
#define ctl1                            0x04A0
#define ctlLast                         0x04ff
#define _WIN32_WINNT_WIN2K              0x0500
#define _WIN32_IE_IE50                  0x0500
#define _WIN32_WINNT_WINXP              0x0501
#define _WIN32_IE_IE501                 0x0501
#define _WIN32_WINNT_WS03               0x0502
#define _WIN32_IE_IE55                  0x0550
#define _WIN32_WINNT_WIN6               0x0600
#define _WIN32_WINNT_VISTA              0x0600
#define _WIN32_WINNT_WS08               0x0600
#define _WIN32_WINNT_LONGHORN           0x0600
#define _WIN32_IE_IE60                  0x0600
#define FILEOPENORD                     1536
#define _WIN32_WINNT_WIN7               0x0601
#define _WIN32_IE_IE60SP1               0x0601
#define MULTIFILEOPENORD                1537
#define _WIN32_WINNT_WIN8               0x0602
#define _WIN32_IE_WS03                  0x0602
#define PRINTDLGORD                     1538
#define _WIN32_WINNT_WINBLUE            0x0603
#define _WIN32_IE_IE60SP2               0x0603
#define PRNSETUPDLGORD                  1539
#define FINDDLGORD                      1540
#define REPLACEDLGORD                   1541
#define FONTDLGORD                      1542
#define FORMATDLGORD31                  1543
#define FORMATDLGORD30                  1544
#define RUNDLGORD                       1545
#define PAGESETUPDLGORD                 1546
#define NEWFILEOPENORD                  1547
#define PRINTDLGEXORD                   1549
#define PAGESETUPDLGORDMOTIF            1550
#define COLORMGMTDLGORD                 1551
#define NEWFILEOPENV2ORD                1552
#define NEWFILEOPENV3ORD                1553
#define NEWFORMATDLGWITHLINK            1591
#define IDC_MANAGE_LINK                 1592
#define _WIN32_IE_IE70                  0x0700
#define _WIN32_IE_IE80                  0x0800
#define CS_SAVEBITS                     0x0800
#define HDS_NOSIZING                    0x0800
#define TBSTYLE_FLAT                    0x0800
#define RBS_FIXEDORDER                  0x00000800
#define SBARS_TOOLTIPS                  0x0800
#define SBT_TOOLTIPS                    0x0800
#define TBS_NOTIFYBEFOREMOVE            0x0800
#define LVS_ALIGNLEFT                   0x0800
#define TVS_INFOTIP                     0x0800
#define TCS_RAGGEDRIGHT                 0x0800
#define _WIN32_IE_IE90                  0x0900
#define _WIN32_WINNT_WINTHRESHOLD       0x0A00
#define _WIN32_WINNT_WIN10              0x0A00
#define _WIN32_IE_IE100                 0x0A00
#define _WIN32_IE_IE110                 0x0A00
#define _WIN32_WINNT                    0x0A00
#define _WIN32_IE                       0x0A00
#define LVS_ALIGNMASK                   0x0c00
#define CS_BYTEALIGNCLIENT              0x1000
#define HDS_OVERFLOW                    0x1000
#define TBSTYLE_LIST                    0x1000
#define RBS_REGISTERDROP                0x00001000
#define TBS_TRANSPARENTBKGND            0x1000
#define LVS_OWNERDATA                   0x1000
#define TVS_FULLROWSELECT               0x1000
#define TCS_FOCUSONBUTTONDOWN           0x1000
#define CS_BYTEALIGNWINDOW              0x2000
#define TBSTYLE_CUSTOMERASE             0x2000
#define RBS_AUTOSIZE                    0x00002000
#define LVS_NOSCROLL                    0x2000
#define TVS_NOSCROLL                    0x2000
#define TCS_OWNERDRAWFIXED              0x2000
#define CS_GLOBALCLASS                  0x4000
#define TBSTYLE_REGISTERDROP            0x4000
#define RBS_VERTICALGRIPPER             0x00004000
#define LVS_NOCOLUMNHEADER              0x4000
#define TVS_NONEVENHEIGHT               0x4000
#define TCS_TOOLTIPS                    0x4000
#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441
#define IDH_GENERIC_HELP_BUTTON         28442
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445
#define LANG_BOSNIAN_NEUTRAL            0x781a
#define LANG_CHINESE_TRADITIONAL        0x7c04
#define LANG_SERBIAN_NEUTRAL            0x7c1a
#define IDTIMEOUT                       32000
#define OCR_NORMAL                      32512
#define OIC_SAMPLE                      32512

#define OCR_IBEAM                       32513
#define OIC_HAND                        32513

#define OCR_WAIT                        32514
#define OIC_QUES                        32514

#define OCR_CROSS                       32515
#define OIC_BANG                        32515

#define OCR_UP                          32516
#define OIC_NOTE                        32516

#define OIC_WINLOGO                     32517

#define OIC_SHIELD                      32518
#define OCR_SIZE                        32640
#define OCR_ICON                        32641
#define OCR_SIZENWSE                    32642
#define OCR_SIZENESW                    32643
#define OCR_SIZEWE                      32644
#define OCR_SIZENS                      32645
#define OCR_SIZEALL                     32646
#define OCR_ICOCUR                      32647
#define OCR_NO                          32648
#define OCR_HAND                        32649
#define OCR_APPSTARTING                 32650
#define OBM_LFARROWI                    32734
#define OBM_RGARROWI                    32735
#define OBM_DNARROWI                    32736
#define OBM_UPARROWI                    32737
#define OBM_COMBO                       32738
#define OBM_MNARROW                     32739
#define OBM_LFARROWD                    32740
#define OBM_RGARROWD                    32741
#define OBM_DNARROWD                    32742
#define OBM_UPARROWD                    32743
#define OBM_RESTORED                    32744
#define OBM_ZOOMD                       32745
#define OBM_REDUCED                     32746
#define OBM_RESTORE                     32747
#define OBM_ZOOM                        32748
#define OBM_REDUCE                      32749
#define OBM_LFARROW                     32750
#define OBM_RGARROW                     32751
#define OBM_DNARROW                     32752
#define OBM_UPARROW                     32753
#define OBM_CLOSE                       32754
#define OBM_OLD_RESTORE                 32755
#define OBM_OLD_ZOOM                    32756
#define OBM_OLD_REDUCE                  32757
#define OBM_BTNCORNERS                  32758
#define OBM_CHECKBOXES                  32759
#define OBM_CHECK                       32760
#define OBM_BTSIZE                      32761
#define OBM_OLD_LFARROW                 32762
#define OBM_OLD_RGARROW                 32763
#define OBM_OLD_DNARROW                 32764
#define OBM_OLD_UPARROW                 32765
#define OBM_SIZE                        32766
#define OBM_OLD_CLOSE                   32767
#define WM_APP                          0x8000
#define HELP_TCARD                      0x8000
#define TBSTYLE_TRANSPARENT             0x8000
#define RBS_DBLCLKTOGGLE                0x00008000
#define LVS_NOSORTHEADER                0x8000
#define TVS_NOHSCROLL                   0x8000
#define TCS_FOCUSNEVER                  0x8000
#define SC_SIZE                         0xF000
#define SC_SEPARATOR                    0xF00F
#define SC_MOVE                         0xF010
#define SC_MINIMIZE                     0xF020
#define SC_MAXIMIZE                     0xF030
#define SC_NEXTWINDOW                   0xF040
#define SC_PREVWINDOW                   0xF050
#define SC_CLOSE                        0xF060
#define SC_VSCROLL                      0xF070
#define SC_HSCROLL                      0xF080
#define SC_MOUSEMENU                    0xF090
#define SC_KEYMENU                      0xF100
#define SC_ARRANGE                      0xF110
#define SC_RESTORE                      0xF120
#define SC_TASKLIST                     0xF130
#define SC_SCREENSAVE                   0xF140
#define SC_HOTKEY                       0xF150
#define SC_DEFAULT                      0xF160
#define SC_MONITORPOWER                 0xF170
#define SC_CONTEXTHELP                  0xF180
#define LVS_TYPESTYLEMASK               0xfc00
#define SPVERSION_MASK                  0x0000FF00
#define UNICODE_NOCHAR                  0xFFFF


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Broker/task.h`:

```h
#pragma once

#include "common.h"

#include <string>
#include <mutex>
#include <map>
#include <vector>
#include <array>
#include <cstddef>


enum class TaskState : uint16_t
{
	Initialized,
	Queued,
	Delivered,
	Completed
};


enum class TaskType : uint32_t
{
	TaskTypeMin = 0,
	GetOsInfo,
	HookDriver,
	UnhookDriver,
	GetDriverInfo,
	GetNumberOfDriver,
	NotifyEventHandle,
	EnableMonitoring,
	DisableMonitoring,
	GetInterceptedIrps,
	ReplayIrp,
	StoreTestCase,
	EnumerateDrivers,
	EnableDriver,
	DisableDriver,
	GetNamesOfHookedDrivers,
	TaskTypeMax = 16
};


static std::map<TaskType, DWORD> g_TaskIoctls = 
{
	{TaskType::HookDriver,                IOCTL_AddDriver},
	{TaskType::UnhookDriver,              IOCTL_RemoveDriver},
	{TaskType::GetNumberOfDriver,         IOCTL_GetNumberOfDrivers},
	{TaskType::GetNamesOfHookedDrivers,   IOCTL_GetNamesOfDrivers},
	{TaskType::GetDriverInfo,             IOCTL_GetDriverInfo},
	{TaskType::NotifyEventHandle,         IOCTL_SetEventPointer},
	{TaskType::EnableMonitoring,          IOCTL_EnableMonitoring},
	{TaskType::DisableMonitoring,         IOCTL_DisableMonitoring},
	{TaskType::StoreTestCase,             IOCTL_StoreTestCase},
	{TaskType::EnableDriver,              IOCTL_EnableDriver},
	{TaskType::DisableDriver,             IOCTL_DisableDriver},
};




class Task
{
public:
	Task(const Task& t);
	Task(TaskType type, const byte* data, uint32_t datalen, uint32_t errcode, bool IsRequest);
	~Task();

	const wchar_t* StateAsString();
	const wchar_t* TypeAsString();
	const TaskType Type();
	const DWORD IoctlCode();
	void SetState(TaskState s);
	const uint32_t Length();
	byte* Data();
	const DWORD Id();
	const DWORD ErrCode();


private:
	TaskType m_Type;
	TaskState m_State;
	byte* m_Data = nullptr;
	uint32_t m_dwDataLength;
	DWORD m_dwId;
	DWORD m_dwErrCode;
	bool m_bIsRequest;
};
```

`CFB.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28922.388
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Driver", "Driver\Driver.vcxproj", "{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}"
	ProjectSection(ProjectDependencies) = postProject
		{A1E1112D-966D-45EC-96DE-B84371E803EE} = {A1E1112D-966D-45EC-96DE-B84371E803EE}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Common", "Common\Common.vcxproj", "{A1E1112D-966D-45EC-96DE-B84371E803EE}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{0D5D410A-CA06-4EB5-B7B7-24A0A94357ED}"
	ProjectSection(SolutionItems) = preProject
		Docs\crash-analysis.md = Docs\crash-analysis.md
		Docs\FAQ.md = Docs\FAQ.md
		Docs\fuzzing-vm-setup.md = Docs\fuzzing-vm-setup.md
		README.md = README.md
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Broker", "Broker\Broker.vcxproj", "{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}"
	ProjectSection(ProjectDependencies) = postProject
		{A1E1112D-966D-45EC-96DE-B84371E803EE} = {A1E1112D-966D-45EC-96DE-B84371E803EE}
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16} = {148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GUI", "GUI\GUI.csproj", "{73B379CD-0298-415B-AC8E-FC6D4A6721AB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|Any CPU.ActiveCfg = Debug|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|Any CPU.Build.0 = Debug|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|Any CPU.Deploy.0 = Debug|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|ARM.ActiveCfg = Debug|ARM
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|ARM.Build.0 = Debug|ARM
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|ARM.Deploy.0 = Debug|ARM
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|ARM64.Build.0 = Debug|ARM64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|x64.ActiveCfg = Debug|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|x64.Build.0 = Debug|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|x86.ActiveCfg = Debug|Win32
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|x86.Build.0 = Debug|Win32
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Debug|x86.Deploy.0 = Debug|Win32
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|Any CPU.ActiveCfg = Release|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|Any CPU.Build.0 = Release|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|Any CPU.Deploy.0 = Release|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|ARM.ActiveCfg = Release|Win32
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|ARM.Build.0 = Release|ARM
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|ARM.Deploy.0 = Release|ARM
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|ARM64.ActiveCfg = Release|Win32
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|ARM64.Build.0 = Release|ARM64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|ARM64.Deploy.0 = Release|ARM64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|x64.ActiveCfg = Release|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|x64.Build.0 = Release|x64
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|x86.ActiveCfg = Release|Win32
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|x86.Build.0 = Release|Win32
		{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}.Release|x86.Deploy.0 = Release|Win32
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Debug|Any CPU.ActiveCfg = Debug|x64
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Debug|Any CPU.Build.0 = Debug|x64
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Debug|ARM.ActiveCfg = Debug|Win32
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Debug|ARM64.ActiveCfg = Debug|Win32
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Debug|x64.ActiveCfg = Debug|x64
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Debug|x64.Build.0 = Debug|x64
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Debug|x86.ActiveCfg = Debug|Win32
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Debug|x86.Build.0 = Debug|Win32
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Release|Any CPU.ActiveCfg = Release|x64
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Release|Any CPU.Build.0 = Release|x64
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Release|ARM.ActiveCfg = Release|Win32
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Release|ARM64.ActiveCfg = Release|Win32
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Release|x64.ActiveCfg = Release|x64
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Release|x64.Build.0 = Release|x64
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Release|x86.ActiveCfg = Release|Win32
		{A1E1112D-966D-45EC-96DE-B84371E803EE}.Release|x86.Build.0 = Release|Win32
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|Any CPU.ActiveCfg = Debug|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|Any CPU.Build.0 = Debug|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|ARM.ActiveCfg = Debug|Win32
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|ARM64.ActiveCfg = Debug|Win32
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|x64.ActiveCfg = Debug|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|x64.Build.0 = Debug|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|x64.Deploy.0 = Debug|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|x86.ActiveCfg = Debug|Win32
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Debug|x86.Build.0 = Debug|Win32
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Release|Any CPU.ActiveCfg = Release|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Release|Any CPU.Build.0 = Release|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Release|ARM.ActiveCfg = Release|Win32
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Release|ARM64.ActiveCfg = Release|Win32
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Release|x64.ActiveCfg = Release|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Release|x64.Build.0 = Release|x64
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Release|x86.ActiveCfg = Release|Win32
		{94DEB1FD-0D24-43CE-8E33-73F7F32E839C}.Release|x86.Build.0 = Release|Win32
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|Any CPU.ActiveCfg = Debug|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|Any CPU.Build.0 = Debug|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|Any CPU.Deploy.0 = Debug|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|ARM.ActiveCfg = Debug|ARM
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|ARM.Build.0 = Debug|ARM
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|ARM.Deploy.0 = Debug|ARM
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|ARM64.Build.0 = Debug|ARM64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|x64.ActiveCfg = Debug|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|x64.Build.0 = Debug|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|x64.Deploy.0 = Debug|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|x86.ActiveCfg = Debug|x86
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|x86.Build.0 = Debug|x86
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Debug|x86.Deploy.0 = Debug|x86
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|Any CPU.ActiveCfg = Release|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|Any CPU.Build.0 = Release|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|Any CPU.Deploy.0 = Release|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|ARM.ActiveCfg = Release|ARM
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|ARM.Build.0 = Release|ARM
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|ARM.Deploy.0 = Release|ARM
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|ARM64.ActiveCfg = Release|ARM64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|ARM64.Build.0 = Release|ARM64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|ARM64.Deploy.0 = Release|ARM64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|x64.ActiveCfg = Release|x64
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|x86.ActiveCfg = Release|x86
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|x86.Build.0 = Release|x86
		{73B379CD-0298-415B-AC8E-FC6D4A6721AB}.Release|x86.Deploy.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D7AF0CBB-E55E-48BE-93DB-68A4D38CADEB}
	EndGlobalSection
EndGlobal

```

`Common/Common.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{A1E1112D-966D-45EC-96DE-B84371E803EE}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Common</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_COLORIZE;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(WindowsSdkDir)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_COLORIZE;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>D:\Dev\VS\2019\VC\Auxiliary\VS\lib\onecore\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="common.c" />
    <ClCompile Include="stdafx.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Common/Common.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="common.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Common/common.c`:

```c
#include "stdafx.h"

#include "common.h"


static HANDLE g_hLogMutex = NULL;



/*++

--*/
void _xlog(log_level_t level, const wchar_t* format, ...)
{
#ifndef _DEBUG
	//
	// If we're not in Debug mode, we don't care about xlog(LOG_DEBUG) 
	//
	if (level == LOG_DEBUG)
		return;
#endif

	if (g_hLogMutex == NULL)
	{
		g_hLogMutex = CreateMutex(NULL, FALSE, NULL);
		if (g_hLogMutex == NULL)
			return;
	}

	const wchar_t* prio;

	switch (level)
	{
	case LOG_DEBUG:
		prio = L"[DEBUG] ";
		break;
	case LOG_INFO:
		prio =  L"[INFO] ";
		break;
	case LOG_SUCCESS:
		prio = COLOR_FG_GREEN L"[SUCCESS] " COLOR_RESET;
		break;
	case LOG_WARNING:
		prio = COLOR_FG_YELLOW L"[WARNING] " COLOR_RESET;
		break;
	case LOG_ERROR:
		prio = COLOR_BOLD COLOR_FG_RED L"[ERROR] " COLOR_RESET;
		break;
	case LOG_CRITICAL:
		prio = COLOR_BOLD COLOR_FG_MAGENTA L"[CRITICAL] " COLOR_RESET;
		break;
	default:
		return;
	}

	WaitForSingleObject(g_hLogMutex, INFINITE);

	va_list args;
	SYSTEMTIME lt;
	GetLocalTime(&lt);

#ifdef _DEBUG
	fwprintf(stderr, L"%02d-%02d-%02d %02d:%02d:%02d ",
		lt.wYear, lt.wMonth, lt.wDay,
		lt.wHour, lt.wMinute, lt.wSecond);
#endif

	fwprintf(stderr, L"%s ", prio);
	va_start(args, format);
	vfwprintf(stderr, format, args);
	va_end(args);
	fflush(stderr);
	
	ReleaseMutex(g_hLogMutex);

	return;
}



/*++

Print out an hexdump-like formatted representation of `data`.

--*/
void hexdump(PVOID data, SIZE_T size)
{
	WCHAR ascii[17] = { 0, };
	SIZE_T i, j;
	PBYTE ptr = (PBYTE)data;

	for (i = 0; i < size; ++i) 
	{
		BYTE c = ptr[i];

		if (!ascii[0])
			wprintf(L"%04Ix   ", i);

		wprintf(L"%02X ", c);

		ascii[i % 16] = (0x20 <= c && c < 0x7f) ? (WCHAR)c : L'.';

		if ((i + 1) % 8 == 0 || i + 1 == size)
		{
			wprintf(L" ");
			if ((i + 1) % 16 == 0)
			{
				wprintf(L"|  %s \n", ascii);
				ZeroMemory(ascii, sizeof(ascii));
			}
			else if (i + 1 == size)
			{
				ascii[(i + 1) % 16] = L'\0';
				if ((i + 1) % 16 <= 8)
				{
					wprintf(L" ");
				}
				for (j = (i + 1) % 16; j < 16; ++j)
				{
					wprintf(L"   ");
				}
				wprintf(L"|  %s \n", ascii);
			}
		}
	}

	return;
}


/*++

perror() style of function for Windows

--*/
void PrintError(const wchar_t* msg)
{
	WCHAR sysMsg[1024] = { 0, };

	DWORD eNum = GetLastError();
	FormatMessageW(
		FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, 
		eNum,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		sysMsg, 
		(sizeof(sysMsg) - 1)/sizeof(WCHAR), 
		NULL
	);

	xlog(LOG_ERROR, L"%s, errcode=0x%x : %s", msg, eNum, sysMsg);
	return;
}


/*++

Routine Description:

Fill the buffer given in parameter with a (C-like) string filled with a random 
alpha-numeric charset.


Arguments:

	- str is a pointer to the buffer to fill with random chars

	- len is the number of random char to populate `str` with 


Return value:
	
	None

--*/
void GenerateRandomString(char* str, const size_t len) 
{
	static const char charset[] =
		"0123456789"
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"abcdefghijklmnopqrstuvwxyz";

	for (int i = 0; i < len; ++i) {
		str[i] = charset[rand() % (sizeof(charset) - 1)];
	}

	str[len] = 0;
}


/*++

Routine Description:

Create a (C-like) string filled with a random alpha-numeric charset.
The buffer must be free-ed (via LocalFree()) by the caller.


Arguments:

	- len is the length of the wanted random string


Return value:

	A pointer to the random string if successful, NULL otherwise.

--*/
char* CreateRandomString(const size_t len)
{
	char* m = LocalAlloc(LHND, len+1);
	if (!m)
		return NULL;

	GenerateRandomString(m, len);

	return m;
}


/*++

Routine Description:

Create a (C-like) wide string filled with a random alpha-numeric charset.
The buffer must be free-ed (via LocalFree()) by the caller.


Arguments:

	- len is the length of the wanted random string


Return value:

	A pointer to the random string if successful, NULL otherwise.

--*/
wchar_t* CreateRandomWideString(const size_t len)
{
	char* m = LocalAlloc(LHND, 2*(len + 1));
	if (!m)
		return NULL;

	GenerateRandomString(m, len);

	for (int i = 0; i < 2 * len; i+=2)
		m[i] = 0;

	return (wchar_t*)m;
}



/*++
 
--*/
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{

	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		break;
	
	case DLL_THREAD_ATTACH:
		break;
	
	case DLL_THREAD_DETACH:
		break;
	
	case DLL_PROCESS_DETACH:
		break;
	}

	return TRUE;
}

```

`Common/common.h`:

```h
#pragma once

#ifndef _DRIVER
#include <Windows.h>
#include <stdio.h>
#endif

#define CFB_PROGRAM_NAME			L"Canadian Furious Beaver"
#define CFB_PROGRAM_NAME_SHORT		L"CFB"
#define CFB_AUTHOR					L"@_hugsy_"
#define CFB_VERSION					0.2

#define CFB_USER_DEVICE_NAME		L"\\\\.\\IrpDumper"
#define CFB_DEVICE_NAME				L"\\Device\\IrpDumper"
#define CFB_DEVICE_LINK				L"\\DosDevices\\IrpDumper"

#define CFB_DRIVER_NAME				L"IrpDumper.sys"
#define CFB_DRIVER_PATH				L"\\driver\\" CFB_DRIVER_NAME
#define CFB_SERVICE_NAME			L"IrpDumper"
#define CFB_SERVICE_DESCRIPTION		L"CFB IRP Dumper Driver"

#ifndef MAX_PATH
#define MAX_PATH                    0x104
#endif
#define HOOKED_DRIVER_MAX_NAME_LEN	MAX_PATH

#define CFB_PIPE_NAME               L"\\\\.\\pipe\\CFB"
#define CFB_PIPE_MAXCLIENTS			PIPE_UNLIMITED_INSTANCES
#define CFB_PIPE_INBUFLEN			4096
#define CFB_PIPE_OUTBUFLEN			4096


#define WIDE2(x) L##x
#define WIDECHAR(x) WIDE2(x)

#define FUNCTIONW WIDECHAR(__FUNCTION__) L"()"
#define FILENAMEW WIDECHAR(__FILE__)


#ifdef _DEBUG

/* Debug */
#define GEN_FMT L"in '%s'(%s:%d) [%d] "
#define __xlog(t, ...) _xlog(t, __VA_ARGS__)
#define xlog(t, _f, ...) __xlog(t, GEN_FMT _f, FUNCTIONW, FILENAMEW, __LINE__, GetThreadId(GetCurrentThread()), __VA_ARGS__)

#define dbg(...) _xlog(LOG_DEBUG, __VA_ARGS__)

#else

/* Release */
#define xlog(t, ...) _xlog(t, __VA_ARGS__)
#define dbg(...) 

#endif /* _DEBUG_ */


#ifdef _COLORIZE
#define COLOR_RESET L"\033[0m"
#define COLOR_BOLD L"\033[1m"
#define COLOR_UNDERLINE L"\033[4m"

#define COLOR_FG_BLACK L"\033[30m"
#define COLOR_FG_RED L"\033[31m"
#define COLOR_FG_GREEN L"\033[32m"
#define COLOR_FG_YELLOW L"\033[33m"
#define COLOR_FG_BLUE L"\033[34m"
#define COLOR_FG_MAGENTA L"\033[35m"
#define COLOR_FG_CYAN L"\033[36m"
#define COLOR_FG_WHITE L"\033[37m"
#else
#define COLOR_RESET
#define COLOR_BOLD
#define COLOR_UNDERLINE 

#define COLOR_FG_BLACK
#define COLOR_FG_RED
#define COLOR_FG_GREEN
#define COLOR_FG_YELLOW 
#define COLOR_FG_BLUE
#define COLOR_FG_MAGENTA
#define COLOR_FG_CYAN
#define COLOR_FG_WHITE
#endif

#define PrintErrorWithFunctionName(x) PrintError(FILENAMEW L":" FUNCTIONW L": " x)


typedef enum
{
	LOG_DEBUG,
	LOG_INFO,
	LOG_SUCCESS,
	LOG_WARNING,
	LOG_ERROR,
	LOG_CRITICAL
} log_level_t;

# pragma pack (1)
typedef struct 
{
	UINT32 Enabled;
	WCHAR Name[MAX_PATH];
	UINT32 NumberOfDevices;
	UINT64 NumberOfRequestIntercepted;
	ULONG_PTR DriverAddress;
}
HOOKED_DRIVER_INFO, *PHOOKED_DRIVER_INFO;
# pragma pack ()

# pragma pack (1)
typedef struct
{
	LARGE_INTEGER TimeStamp;
	UINT32 Irql;
	UINT32 Type;
	UINT32 IoctlCode;
	UINT32 Pid;
	UINT32 Tid;
	UINT32 InputBufferLength;
    UINT32 OutputBufferLength;
	WCHAR DriverName[MAX_PATH];
	WCHAR DeviceName[MAX_PATH];
	WCHAR ProcessName[MAX_PATH];
	NTSTATUS Status;
}
INTERCEPTED_IRP_HEADER, *PINTERCEPTED_IRP_HEADER;
# pragma pack ()

typedef PVOID PINTERCEPTED_IRP_BODY;

typedef struct 
{
	PINTERCEPTED_IRP_HEADER Header;
	PINTERCEPTED_IRP_BODY InputBuffer;
	PINTERCEPTED_IRP_BODY OutputBuffer;
	LIST_ENTRY ListEntry;
}
INTERCEPTED_IRP, *PINTERCEPTED_IRP;


__declspec(dllexport) void hexdump(PVOID data, SIZE_T size);
__declspec(dllexport) void PrintError(const wchar_t* msg);
__declspec(dllexport) void _xlog(log_level_t level, const wchar_t* format, ...);
__declspec(dllexport) char* CreateRandomString(const size_t len);
__declspec(dllexport) wchar_t* CreateRandomWideString(const size_t len);
__declspec(dllexport) void GenerateRandomString(char* str, const size_t len);

```

`Common/stdafx.c`:

```c
// stdafx.cpp : source file that includes just the standard includes
// Common.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"



```

`Common/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"



// TODO: reference additional headers your program requires here

```

`Common/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`Docs/FAQ.md`:

```md
# FAQ

## LoadDriver(0) error on start

Check that you're running in Debug mode, and have test signing enabled.



## Unable to load DLL 'Core.dll' (HRESULT: 0x8007007E)

Missing Visual C++ Redist. Runtime 14.0 (`vcruntime140.dll`)

Install x68 or x64 version from :

https://www.groovypost.com/howto/fix-visual-c-plus-plus-redistributable-windows-10/




## Where did you get those cool icons ?

Over there : http://freeiconshop.com/ 
```

`Docs/crash-analysis.md`:

```md
# Crash analysis

Found a crash?

* Validate the cause

```
kd> !analyze -v
kd> .load \path\to\msec.dll ; !exploitable
```

* IRPs are handled sequentially, therefore the crash has to be related to at least the last
 IRP sent. CFB will store the last IRP fuzzed in `IrpDumper!g_LastTestCase` in the following 
 format:
```
struct {
UINT32 SizeOfBuffer;
BYTE Buffer[SizeOfBuffer];
}
```

So you can easily dump the last IRP from WinDbg in 3 simple steps (which can easily automated in
a WinDbg JS script):

* First get the length, for example:

```
kd> dd poi(IrpDumper!g_LastTestCase) l1
ffffe088`f37ae000  00000218
```

The data length is 0x218 bytes.


* Then you can confirm by viewing those data
```
kd> db poi(IrpDumper!g_LastTestCase+4) l218
ffffe088`f37ae004  5c 00 44 00 6f 00 73 00-44 00 65 00 76 00 69 00  \.D.o.s.D.e.v.i.
ffffe088`f37ae014  63 00 65 00 73 00 5c 00-50 00 68 00 79 00 73 00  c.e.s.\.P.h.y.s.
[...]
```

* And finally store them on the debugger host.
```
kd> .writemem C:\Whatever.raw poi(IrpDumper!g_LastTestCase+4) l218
```

All the other info (like device name, ioctl number, etc.) can be retrieved from `analyze -v` above

```

`Docs/fuzzing-vm-setup.md`:

```md
*Note*: unless specified all commands should be run in an Admin Powershell prompt.

## Stop and disable useless services

```powershell
# disable some features
Set-MpPreference -DisableRealtimeMonitoring $true

# disable the services
$services = @("WinDefend", "WSearch", "WerSvc", "wuauserv", "TrustedInstaller", "TroubleShootingSvc")
$services+= @("DiagTrack", "DiagSvc", "diagnosticshub.standardcollector.service")

foreach($service in $services)
{
	Stop-Service -Name $service
	Set-Service -StartupType Disabled -Name $service
}
```

## Define the crash behavior

```powershell
$crash = Get-WmiObject Win32_OSRecoveryConfiguration -EnableAllPrivileges
$crash | Set-WmiInstance -Arguments @{ AutoReboot=$False }
# 0 = None
# 1 = Complete memory dump
# 2 = Kernel memory dump
# 3 = Small memory dump
$crash | Set-WmiInstance -Arguments @{ DebugInfoType=1  }
$crash | Set-WmiInstance -Arguments @{ OverwriteExistingDebugFile=$False }
New-Item -ItemType Directory c:\dumps
$crash | Set-WmiInstance -Arguments @{ DebugFilePath="c:\dumps" }
$crash | Set-WmiInstance -Arguments @{ WriteToSystemLog=$False }
```


## Make sure the target time is synchro

```powershell
Stop-Service -Name W32Time
Push-Location
Set-Location HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\DateTime\Servers
Set-ItemProperty . 0 "10.0.0.1"
Set-ItemProperty . "(Default)" "0"
Set-Location HKLM:\SYSTEM\CurrentControlSet\services\W32Time\Parameters
Set-ItemProperty . NtpServer "10.0.0.1"
Pop-Location
Start-Service -Name W32Time
```

## Blackhole some MS domains

```powershell
Invoke-WebRequest -Uri "https://raw.githubusercontent.com/hugsy/modern.ie-vagrant/master/scripts/DisableWin10Telemetry.ps1" -OutFile "c:\temp\DisableWin10Telemetry.ps1"
Set-ExecutionPolicy Bypass
&"c:\temp\DisableWin10Telemetry.ps1"
Remove-Item "c:\temp\DisableWin10Telemetry.ps1"
```

```

`Driver/Common.h`:

```h
#pragma once

#define CFB_MAX_HOOKED_DRIVERS		32
#define CFB_DEVICE_TAG				'CFB ' 

#include <ntifs.h>
#include <wdm.h>
#include <ntddk.h>

#include "..\Common\Common.h"

```

`Driver/Driver.c`:

```c
#include "Driver.h"


#ifdef ALLOC_PRAGMA

//
// Discard after initialization
//
#pragma alloc_text (INIT, DriverEntry)

#endif

UINT16 g_dwNumberOfHandle;

static PDEVICE_OBJECT g_DeviceObject;


//
// Not more than one process can interact with the device object
//
static PEPROCESS pCurrentOwnerProcess;
static KSPIN_LOCK SpinLockOwner;
static KLOCK_QUEUE_HANDLE SpinLockQueueOwner;

extern PLIST_ENTRY g_HookedDriverHead;



/*++

Routine Description:

This routine is called when trying to ReadFile() from a handle to the device IrpDumper. In a regular scenario,
Broker will call ReadFile() on the device only when it was notified some new data was available. However, if
the broker tries to read regardless of the event, the function returns successfully with any data back to userland.

The data sent back to the client is continuously following the sequence: header, inputbuffer, outputbuffer

Arguments:

    DeviceObject - a pointer to the Device Object being closed

    Irp - a pointer to the IRP context


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS _Function_class_(DRIVER_DISPATCH) DriverReadRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp )
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation( Irp );
    if ( !pStack )
    {
        CfbDbgPrintErr( L"IoGetCurrentIrpStackLocation() failed (IRP %p)\n", Irp );
        return CompleteRequest(Irp, STATUS_UNSUCCESSFUL, 0);
    }


    ULONG BufferSize = pStack->Parameters.Read.Length;

    PINTERCEPTED_IRP pInterceptedIrp;
    UINT32 dwExpectedSize;

    Status = PeekHeadEntryExpectedSize(&dwExpectedSize);
    if (!NT_SUCCESS(Status))
        return CompleteRequest(Irp, Status, 0);


    if ( BufferSize == 0 )
    {
        //
        // If BufferSize == 0, the client is probing for the size of the IRP raw data to allocate.
        //
        return CompleteRequest(Irp, STATUS_SUCCESS, dwExpectedSize);
    }

    if ( BufferSize != dwExpectedSize )
    {
        CfbDbgPrintErr( L"Buffer size is invalid, expected %dB, got %dB\n", dwExpectedSize, BufferSize );
        return CompleteRequest(Irp, STATUS_INFO_LENGTH_MISMATCH, dwExpectedSize); // STATUS_INVALID_BUFFER_SIZE
    }

    NT_ASSERT(Irp->MdlAddress);

    UINT32 BufferOffset = 0;
    PVOID Buffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority);
    if ( !Buffer )
        return CompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES, 0);
        

    Status = PopFromQueue(&pInterceptedIrp);

    if ( !NT_SUCCESS(Status) )
        return CompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES, 0);

    //
    // Copy the header (always)
    //
    PINTERCEPTED_IRP_HEADER pInterceptedIrpHeader = pInterceptedIrp->Header;
    RtlCopyMemory( Buffer, pInterceptedIrpHeader, sizeof(INTERCEPTED_IRP_HEADER) );
    BufferOffset += sizeof(INTERCEPTED_IRP_HEADER);


    //
    // Copy the IRP input buffer (if any)
    //
    if(pInterceptedIrpHeader->InputBufferLength && pInterceptedIrp->InputBuffer)
    {
        ULONG_PTR RawBuffer = ((ULONG_PTR)Buffer) + BufferOffset;
        RtlCopyMemory((PVOID)RawBuffer, pInterceptedIrp->InputBuffer, pInterceptedIrpHeader->InputBufferLength);
        BufferOffset += pInterceptedIrpHeader->InputBufferLength;
    }

    //
    // Copy the IRP output buffer (if any)
    //
    if (pInterceptedIrpHeader->OutputBufferLength && pInterceptedIrp->OutputBuffer)
    {		
        ULONG_PTR RawBuffer = ((ULONG_PTR)Buffer) + BufferOffset;
        //CfbDbgPrintInfo(L"RawBuffer+%d=%p <- OutputBufferLength=%x, OutputBuffer=%p\n", BufferOffset, RawBuffer, pInterceptedIrpHeader->OutputBufferLength, pInterceptedIrp->OutputBuffer);
        RtlCopyMemory((PVOID)RawBuffer, pInterceptedIrp->OutputBuffer, pInterceptedIrpHeader->OutputBufferLength);
        BufferOffset += pInterceptedIrpHeader->OutputBufferLength;
    }

    FreeInterceptedIrp(pInterceptedIrp);

    return CompleteRequest(Irp, STATUS_SUCCESS, dwExpectedSize);
}


/*++

Routine Description:

Generic routine for implemented major types.


Arguments:

    DeviceObject - a pointer to the Device Object being closed

    Irp - a pointer to the IRP context


Return Value:

    Returns STATUS_NOT_IMPLEMENTED.

--*/
NTSTATUS 
_Function_class_(DRIVER_DISPATCH) 
IrpNotImplementedHandler(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

#ifdef _DEBUG
    CfbDbgPrintInfo(L"MajorFunction = 0x%x\n", IoGetCurrentIrpStackLocation(Irp)->MajorFunction);
#endif

    return CompleteRequest(Irp, STATUS_NOT_IMPLEMENTED, 0); 
}


/*++

Routine Description:

The cleanup is invoked when the last handle to the device object is being closed for a specific process.
We must cleanup the context associated with that handle for said process.


Arguments:

    DeviceObject - a pointer to the Device Object being closed

    Irp - a pointer to the IRP context


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS 
_Function_class_(DRIVER_DISPATCH) 
DriverCleanup(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp )
{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER(Irp);

    PAGED_CODE();

    return CompleteRequest(Irp, STATUS_SUCCESS, 0);
}


/*++

Routine Description:

The driver entry point function for the IrpDumper driver: it will create the device object for CFB
stored in a global, and associate all the necessary routines to the driver object.

Last, it will initialize all the structures internal to the driver.


Arguments:

    DeviceObject - a pointer to the Device Object being closed

    Irp - a pointer to the IRP context


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS 
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    PAGED_CODE();

    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    CfbDbgLogInit();

    CfbDbgPrintInfo(L"Loading driver IrpDumper\n");
    pCurrentOwnerProcess = NULL;

    UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(CFB_DEVICE_NAME); 
    UNICODE_STRING DeviceSymlink = RTL_CONSTANT_STRING(CFB_DEVICE_LINK);


    //
    // Create the device object
    //

    Status = IoCreateDevice(
        DriverObject,
        0,
        &DeviceName,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &g_DeviceObject
    );

    if( !NT_SUCCESS(Status) )
    {
        CfbDbgPrintErr(L"Error creating device object (0x%08X)\n", Status);
        return Status;
    }

    CfbDbgPrintOk( L"Device object '%s' created\n", CFB_DEVICE_NAME );


    //
    // Populate the IRP handlers
    //

    for (DWORD i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DriverObject->MajorFunction[i] = IrpNotImplementedHandler;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = DriverCreateRoutine;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = DriverCloseRoutine;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDeviceControlRoutine;
    DriverObject->MajorFunction[IRP_MJ_READ] = DriverReadRoutine;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = DriverCleanup;
    DriverObject->DriverUnload = DriverUnloadRoutine;
    


    //
    // Create the symlink
    //
    Status = IoCreateSymbolicLink(&DeviceSymlink, &DeviceName);
    if (!NT_SUCCESS(Status))
    {
        CfbDbgPrintErr(L"Error creating symbolic link (0x%08X)\n", Status);
        IoDeleteDevice(g_DeviceObject);
        return Status;
    }

    CfbDbgPrintOk( L"Symlink '%s' to device object '%s' created\n", CFB_DEVICE_LINK, CFB_DEVICE_NAME );

    g_DeviceObject->Flags |= DO_DIRECT_IO; 
    g_DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    
    //
    // Initializing the locks and structures
    //
    g_dwNumberOfHandle = 0;
    //IoInitializeRemoveLock(&g_DriverRemoveLock, CFB_DEVICE_TAG, 0, 0);
    InitializeListHead(g_HookedDriverHead);
    KeInitializeSpinLock(&SpinLockOwner);
    InitializeMonitoringStructures();
    InitializeHookedDriverStructures();
    InitializeQueueStructures();
    InitializeTestCaseStructures();
    InitializeIoAddDriverStructure();
    
    return Status;
}





/*++

Routine Description:

This routine is the CFB interception routine that will be executed *before* the original
routine from the hooked driver.

Links:
 - https://msdn.microsoft.com/en-us/library/windows/hardware/ff550694(v=vs.85).aspx


Arguments:

    - DeviceObject

    - Irp


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
#ifndef PDRIVER_DISPATCH
typedef NTSTATUS(*PDRIVER_DISPATCH)(IN PDEVICE_OBJECT DeviceObject, OUT PIRP Irp);
#endif

NTSTATUS InterceptGenericRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{ 

    PHOOKED_DRIVER curDriver = GetHookedDriverFromDeviceObject(DeviceObject);
    if (!curDriver)
    {
        //
        // This is really bad: it means our interception routine got called by a non-hooked driver
        // Could be a bad pointer restoration. Anyway, we log and fail for now.
        //

        CfbDbgPrintErr(
            L"Failed to find a HOOKED_DRIVER object associated to the received IRP.\n"
            L"This could indicates a corruption of the hooked driver list, you should probably reboot...\n"
        );
        return CompleteRequest( Irp, STATUS_NO_SUCH_DEVICE, 0 );
    } 


    //
    // Capture the IRP data
    //
    PINTERCEPTED_IRP pIrpInfo = NULL;
    if (IsMonitoringEnabled() && curDriver->Enabled == TRUE && pCurrentOwnerProcess != PsGetCurrentProcess())
    {
        NTSTATUS Status = HandleInterceptedIrp(curDriver, DeviceObject, Irp, &pIrpInfo);

        if (!NT_SUCCESS(Status) && Status != STATUS_NOT_IMPLEMENTED)
        {
            CfbDbgPrintWarn(L"HandleInterceptedIrp() failed (status=0x%X)\n", Status);
        }
        else
        {
            curDriver->NumberOfRequestIntercepted++;
        }
    }


    //
    // And call the original routine
    //
    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);
    PVOID UserBuffer = NULL;

    switch (Stack->MajorFunction)
    {
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        UserBuffer = Irp->UserBuffer;
        break;

    case IRP_MJ_READ:
        if (Irp->MdlAddress)
            UserBuffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);
        else
            UserBuffer = Irp->UserBuffer;
        break;

    default:
        UserBuffer = NULL;
        break;
    }

    PDRIVER_DISPATCH OriginalIoctlDeviceControl = curDriver->OriginalRoutines[Stack->MajorFunction];
    NTSTATUS IoctlStatus = OriginalIoctlDeviceControl(DeviceObject, Irp);

    //
    // Collect the result from the result
    //
    if (pCurrentOwnerProcess != PsGetCurrentProcess() &&
        IsMonitoringEnabled() && 
        curDriver->Enabled == TRUE && 
        pIrpInfo != NULL
    )
    {
        NTSTATUS Status = CompleteHandleInterceptedIrp(UserBuffer, IoctlStatus, pIrpInfo);
        if (!NT_SUCCESS(Status))
            CfbDbgPrintWarn(L"CompleteHandleInterceptedIrp() failed, Status=0x%x\n", Status);
    }


    //
    // Push the new irp to the queue and notify the broker
    //
    if (pIrpInfo)
    {
        DWORD dwType = pIrpInfo->Header->Type;
        DWORD dwSize;
        NTSTATUS Status = PushToQueue(pIrpInfo);
        if (!NT_SUCCESS(Status))
        {
            CfbDbgPrintErr(L"PushToQueue(%p) failed, status=0x%x\n", pIrpInfo, Status);
            FreeInterceptedIrp(pIrpInfo);
        }
        else
        {
            dwSize = GetIrpListSize() ? GetIrpListSize() - 1 : 0;
            CfbDbgPrintOk(L"pushing IRPs[%d] = %p (type=%d)\n", dwSize, pIrpInfo, dwType);
            NotifyUserNewEvent();
        }
    }

    return IoctlStatus;
}




/*++

Routine Description:

Unload routine for CFB IrpDumper.


Arguments:

    - DriverObject


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
VOID _Function_class_(DRIVER_UNLOAD) DriverUnloadRoutine(_In_ PDRIVER_OBJECT DriverObject)
{  

    //
    // Unswap all hooked drivers left to avoid new IRPs to be handled by the driver
    //

    KeEnterCriticalRegion();
    DisableMonitoring();
    ReleaseTestCaseStructures();
    RemoveAllDrivers();
    KeLeaveCriticalRegion();


    //
    // Disable events and clear the queue
    //

    ClearNotificationPointer();

    FlushQueue();

    //
    // Delete the device object
    //

    UNICODE_STRING symLink = RTL_CONSTANT_STRING(CFB_DEVICE_LINK);

    IoDeleteSymbolicLink(&symLink);
    IoDeleteDevice(DriverObject->DeviceObject);

    CfbDbgPrintOk(L"Success unloading '%s'\n", CFB_PROGRAM_NAME_SHORT);

    CfbDbgLogFree();
    return;
}


/*++

Routine Description:

Generic function for IRP completion


Arguments:

    - Irp

    - Status

    - Information


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS CompleteRequest(_In_ PIRP Irp, _In_ NTSTATUS Status, _In_ ULONG_PTR Information)
{
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = Information;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


/*++

Routine Description:


Arguments:


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS _Function_class_(DRIVER_DISPATCH) DriverCloseRoutine(_In_ PDEVICE_OBJECT Device, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(Device);

    PAGED_CODE();

    KeAcquireInStackQueuedSpinLock(&SpinLockOwner, &SpinLockQueueOwner);
    
    g_dwNumberOfHandle--;

    if (g_dwNumberOfHandle == 0 && pCurrentOwnerProcess != NULL)
    {
        pCurrentOwnerProcess = NULL;
        CfbDbgPrintOk(L"Unlocked device...\n");
    }

    KeReleaseInStackQueuedSpinLock(&SpinLockQueueOwner);

    return CompleteRequest(Irp, STATUS_SUCCESS, 0);
}


/*++

Routine Description:


Arguments:


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS _Function_class_(DRIVER_DISPATCH) DriverCreateRoutine(_In_ PDEVICE_OBJECT pObject, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(pObject);

    PAGED_CODE();

    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION lpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_SECURITY_CONTEXT lpSecurityContext = lpStack->Parameters.Create.SecurityContext;


    //
    // Ensure the calling process has SeDebugPrivilege
    //
    PPRIVILEGE_SET lpRequiredPrivileges;
    UCHAR ucPrivilegesBuffer[FIELD_OFFSET(PRIVILEGE_SET, Privilege) + sizeof(LUID_AND_ATTRIBUTES)] = { 0 };

    lpRequiredPrivileges = (PPRIVILEGE_SET)ucPrivilegesBuffer;
    lpRequiredPrivileges->PrivilegeCount = 1;
    lpRequiredPrivileges->Control = PRIVILEGE_SET_ALL_NECESSARY;
    lpRequiredPrivileges->Privilege[0].Luid.LowPart = SE_DEBUG_PRIVILEGE;
    lpRequiredPrivileges->Privilege[0].Luid.HighPart = 0;
    lpRequiredPrivileges->Privilege[0].Attributes = 0;

    if (!SePrivilegeCheck(
        lpRequiredPrivileges,
        &lpSecurityContext->AccessState->SubjectSecurityContext,
        Irp->RequestorMode
        )
    )
    {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }
    else
    {
        PEPROCESS pCallingProcess = PsGetCurrentProcess();

        KeAcquireInStackQueuedSpinLock(&SpinLockOwner, &SpinLockQueueOwner);
    
        if (pCurrentOwnerProcess == NULL )
        {
            //
            // if there's no process owner, affect one and increment the handle counter
            //
            pCurrentOwnerProcess = pCallingProcess;
            CfbDbgPrintOk(L"Locked device to EPROCESS=%p...\n", pCurrentOwnerProcess);
            g_dwNumberOfHandle++;
            Status = STATUS_SUCCESS;
        }   
        else if (pCallingProcess == pCurrentOwnerProcess)
        {
            //
            // if the CreateFile() originates from the owner process, increment the handle counter
            //
            g_dwNumberOfHandle++;
            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // in any other case, simply reject
            //
            Status = STATUS_DEVICE_ALREADY_ATTACHED;
        }

        KeReleaseInStackQueuedSpinLock(&SpinLockQueueOwner);
    }

    return CompleteRequest(Irp, Status, 0);
}


/*++

Routine Description:

This routine handles the dispatch of DeviceIoControl() sent to a IrpDumper device object. It will 
parse the IRP and invoke the routine associated to the specific IOCTL code.


Arguments:

    - DeviceObject

    - Irp


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS _Function_class_(DRIVER_DISPATCH) DriverDeviceControlRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);
    PAGED_CODE();

    //
    // this should never happen as we checked the process when getting the handle, but still
    //
    if (pCurrentOwnerProcess != PsGetCurrentProcess())
        return CompleteRequest(Irp, STATUS_DEVICE_ALREADY_ATTACHED, 0);


    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION CurrentStack = IoGetCurrentIrpStackLocation(Irp);
    NT_ASSERT(CurrentStack);

    ULONG IoctlCode = CurrentStack->Parameters.DeviceIoControl.IoControlCode;
    ULONG dwDataWritten = 0;


    
    switch (IoctlCode)
    {

    case IOCTL_AddDriver:
        Status = HandleIoAddDriver(Irp, CurrentStack);
        break;

    case IOCTL_RemoveDriver:
        Status = HandleIoRemoveDriver(Irp, CurrentStack);
        break;

    case IOCTL_EnableMonitoring:
        Status = HandleIoEnableMonitoring(Irp, CurrentStack );
        break;

    case IOCTL_DisableMonitoring:
        Status = HandleIoDisableMonitoring(Irp, CurrentStack );
        break;

    case IOCTL_GetNumberOfDrivers:
        Status = HandleIoGetNumberOfHookedDrivers(Irp, CurrentStack, &dwDataWritten);
        break;

    case IOCTL_GetNamesOfDrivers:
        Status = HandleIoGetNamesOfHookedDrivers(Irp, CurrentStack, &dwDataWritten);
        break;

    case IOCTL_GetDriverInfo:
        Status = HandleIoGetDriverInfo( Irp, CurrentStack, &dwDataWritten);
        break;

    case IOCTL_SetEventPointer:
        Status = HandleIoSetEventPointer(Irp, CurrentStack);
        break;

    case IOCTL_StoreTestCase:
        Status = HandleIoStoreTestCase(Irp, CurrentStack);
        break;

    case IOCTL_EnableDriver:
        Status = HandleIoEnableDriverMonitoring(Irp, CurrentStack);
        break;

    case IOCTL_DisableDriver:
        Status = HandleIoDisableDriverMonitoring(Irp, CurrentStack);
        break;

    default:
        CfbDbgPrintErr(L"Received invalid ioctl code %#x\n", IoctlCode);
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    if (!NT_SUCCESS(Status))
        CfbDbgPrintErr(L"IOCTL %#x returned %#x\n", IoctlCode, Status);

    
    return CompleteRequest(Irp, Status, dwDataWritten);
}


/*++

Routine Description:

The DeviceIoControl() interception routine wrapper.


Arguments:

    - DeviceObject

    - Irp


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS InterceptedDeviceControlRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp )
{
    return InterceptGenericRoutine(DeviceObject, Irp);
}


/*++

Routine Description:

The ReadFile() interception routine wrapper.


Arguments:

    - DeviceObject

    - Irp


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS InterceptedReadRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp )
{
    return InterceptGenericRoutine(DeviceObject, Irp);
}
    

/*++

Routine Description:

The WriteFile() interception routine wrapper.


Arguments:

    - DeviceObject
    
    - Irp


Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS InterceptedWriteRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp )
{
    return InterceptGenericRoutine(DeviceObject, Irp);
}


/*++

Routine Description:

The InterceptGenericFastIoRoutinePre() routine wrapper intercepts FastIOs input data.


Arguments:

    - DeviceObject
    - InputBuffer
    - InputBufferLength
    - IoControlCode
    - pIrpOut


Return Value:

    Returns TRUE on success.

--*/
BOOLEAN 
InterceptGenericFastIoRoutine(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ UINT32 Type,
    _In_ PVOID Buffer,
    _In_ ULONG BufferLength,
    _In_ ULONG IoControlCode,
    _In_ UINT32 Flags,
    _Inout_ PINTERCEPTED_IRP *pIrpOut
)
{
    PHOOKED_DRIVER Driver = GetHookedDriverFromDeviceObject(DeviceObject);
    if (!Driver)
    {
        CfbDbgPrintErr(
            L"Failed to find driver for InterceptGenericFastIoRoutine(). "
            L"This could mean a corrupted state of " CFB_DRIVER_NAME L". "
            L"You should reboot to avoid further corruption...\n"
        );
        return FALSE;
    }

    NTSTATUS Status = STATUS_SUCCESS;

    if (IsMonitoringEnabled() && Driver->Enabled)
    {
        Status = HandleInterceptedFastIo(
            Driver,
            DeviceObject,
            Type,
            IoControlCode,
            Buffer,
            BufferLength,
            Flags,
            &*pIrpOut
        );
    }

    return Status == STATUS_SUCCESS;
}


/*++

Routine Description:

The InterceptGenericFastIoDeviceControl() interception routine wrapper.

```c
    typedef BOOLEAN (*PFAST_IO_DEVICE_CONTROL) (
        IN struct _FILE_OBJECT *FileObject,
        IN BOOLEAN Wait,
        IN PVOID InputBuffer OPTIONAL,
        IN ULONG InputBufferLength,
        OUT PVOID OutputBuffer OPTIONAL,
        IN ULONG OutputBufferLength,
        IN ULONG IoControlCode,
        OUT PIO_STATUS_BLOCK IoStatus,
        IN struct _DEVICE_OBJECT *DeviceObject
    );
```

Arguments:
    - FileObject
    - Wait
    - InputBuffer
    - InputBufferLength
    - OutputBuffer
    - OutputBufferLength
    - IoControlCode
    - IoStatus
    - DeviceObject

Return Value:

    Returns TRUE on success.

--*/
BOOLEAN InterceptGenericFastIoDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
{
    PINTERCEPTED_IRP pIrp = NULL;

    //
    // Capture the input
    //
    if (!InterceptGenericFastIoRoutine(
        DeviceObject, 
        CFB_INTERCEPTED_IRP_TYPE_FASTIO_IOCTL,
        InputBuffer, 
        InputBufferLength, 
        IoControlCode, 
        CFB_FASTIO_USE_INPUT_BUFFER | CFB_FASTIO_INIT_QUEUE_MESSAGE,
        &pIrp)
    )
        return FALSE;
    
    PHOOKED_DRIVER Driver = GetHookedDriverFromDeviceObject(DeviceObject);
    PFAST_IO_DEVICE_CONTROL OriginalFastIoDeviceControl = Driver->FastIoDeviceControl;
    BOOLEAN bRes = OriginalFastIoDeviceControl(
        FileObject, 
        Wait, 
        InputBuffer, 
        InputBufferLength, 
        OutputBuffer, 
        OutputBufferLength, 
        IoControlCode, 
        IoStatus, 
        DeviceObject
    );
    
    //
    // Capture the output - pIrp was already initialized
    //
    if (!InterceptGenericFastIoRoutine(
        DeviceObject, 
        CFB_INTERCEPTED_IRP_TYPE_FASTIO_IOCTL,
        OutputBuffer, 
        OutputBufferLength, 
        IoControlCode, 
        CFB_FASTIO_USE_OUTPUT_BUFFER,
        &pIrp
    ))
        return FALSE;

    return bRes;
}


/*++

Routine Description:

The InterceptGenericFastIoRead() interception routine wrapper.

```c
    typedef BOOLEAN (*PFAST_IO_READ) (
        IN PFILE_OBJECT FileObject,
        IN PLARGE_INTEGER FileOffset,
        IN ULONG Length,
        IN BOOLEAN Wait,
        IN ULONG LockKey,
        OUT PVOID Buffer,
        OUT PIO_STATUS_BLOCK IoStatus,
        IN PDEVICE_OBJECT DeviceObject
    );
```

Arguments:
    - FileObject
    - FileOffset
    - Length
    - Wait
    - LockKey
    - Buffer
    - IoStatus
    - DeviceObject

Return Value:

    Returns TRUE on success.

--*/
BOOLEAN InterceptGenericFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
{
    PINTERCEPTED_IRP pIrp = NULL;
    PHOOKED_DRIVER Driver = GetHookedDriverFromDeviceObject(DeviceObject);
    if (!Driver)
        return FALSE;

    PFAST_IO_READ OriginalFastIoRead = Driver->FastIoRead;
    BOOLEAN bRes = OriginalFastIoRead(
        FileObject,
        FileOffset,
        Length,
        Wait,
        LockKey,
        Buffer,
        IoStatus,
        DeviceObject
    );

    
    if (!InterceptGenericFastIoRoutine(
        DeviceObject, 
        CFB_INTERCEPTED_IRP_TYPE_FASTIO_READ,
        Buffer, 
        Length, 
        (ULONG)-1,
        CFB_FASTIO_USE_OUTPUT_BUFFER | CFB_FASTIO_INIT_QUEUE_MESSAGE,
        &pIrp
    ))
        return FALSE;
    
    return bRes;
}


/*++

Routine Description:

The InterceptGenericFastIoWrite() interception routine wrapper.

```c
    typedef BOOLEAN (*PFAST_IO_WRITE) (
        IN PFILE_OBJECT FileObject,
        IN PLARGE_INTEGER FileOffset,
        IN ULONG Length,
        IN BOOLEAN Wait,
        IN ULONG LockKey,
        OUT PVOID Buffer,
        OUT PIO_STATUS_BLOCK IoStatus,
        IN PDEVICE_OBJECT DeviceObject
    );
```

Arguments:
    - FileObject
    - FileOffset
    - Length
    - Wait
    - LockKey
    - Buffer
    - IoStatus
    - DeviceObject

Return Value:

    Returns TRUE on success.

--*/
BOOLEAN InterceptGenericFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
{
    PINTERCEPTED_IRP pIrp = NULL;
    if (!InterceptGenericFastIoRoutine(
        DeviceObject, 
        CFB_INTERCEPTED_IRP_TYPE_FASTIO_WRITE,
        Buffer, 
        Length, 
        (ULONG)-1,
        CFB_FASTIO_USE_INPUT_BUFFER | CFB_FASTIO_INIT_QUEUE_MESSAGE,
        &pIrp
    ))
        return FALSE;

    PHOOKED_DRIVER Driver = GetHookedDriverFromDeviceObject(DeviceObject);
    PFAST_IO_WRITE OriginalFastIoWrite = Driver->FastIoWrite;
    return OriginalFastIoWrite(
        FileObject,
        FileOffset,
        Length,
        Wait,
        LockKey,
        Buffer,
        IoStatus,
        DeviceObject
    );
}

```

`Driver/Driver.h`:

```h
#pragma once


#include "Common.h"

#include "IoctlCodes.h"
#include "Utils.h"
#include "HookedDrivers.h"
#include "InterceptedIrpHandler.h"
#include "Queue.h"

#include "IoAddDriver.h"
#include "IoRemoveDriver.h"
#include "IoGetDriverInfo.h"
#include "IoEnableDisableMonitoring.h"
#include "IoEnableDisableDriverMonitoring.h"
#include "IoStoreTestCase.h"


NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);
NTSTATUS _Function_class_(DRIVER_DISPATCH) DriverReadRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp );
VOID _Function_class_(DRIVER_UNLOAD) DriverUnloadRoutine(_In_ PDRIVER_OBJECT DriverObject);
NTSTATUS _Function_class_(DRIVER_DISPATCH) DriverCreateRoutine(_In_ PDEVICE_OBJECT pObject, _In_ PIRP Irp);
NTSTATUS _Function_class_(DRIVER_DISPATCH) DriverCloseRoutine(_In_ PDEVICE_OBJECT pObject, _In_ PIRP Irp);
NTSTATUS _Function_class_(DRIVER_DISPATCH) DriverDeviceControlRoutine(_In_ PDEVICE_OBJECT pObject, _In_ PIRP Irp);
NTSTATUS CompleteRequest(_In_ PIRP Irp, _In_ NTSTATUS status, _In_ ULONG_PTR Information);
NTSTATUS _Function_class_(DRIVER_DISPATCH) IrpNotImplementedHandler(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp );




//
// See https://lylone.wordpress.com/2007/05/08/obreferenceobjectbynameundocumented/
//
extern POBJECT_TYPE* IoDriverObjectType;
extern POBJECT_TYPE* IoDeviceObjectType;

extern NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(
	_In_ PUNICODE_STRING ObjectPath,
	_In_ ULONG Attributes,
	_In_opt_ PACCESS_STATE PassedAccessState,
	_In_opt_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_TYPE ObjectType,
	_In_ KPROCESSOR_MODE AccessMode,
	_Inout_opt_  PVOID ParseContext,
	_Out_ PVOID *ObjectPtr
);

//
// Generic interception routine
//
NTSTATUS InterceptGenericRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

BOOLEAN InterceptGenericFastIoRead(
	IN PFILE_OBJECT FileObject,
	IN PLARGE_INTEGER FileOffset,
	IN ULONG Length,
	IN BOOLEAN Wait,
	IN ULONG LockKey,
	OUT PVOID Buffer,
	OUT PIO_STATUS_BLOCK IoStatus,
	IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN InterceptGenericFastIoWrite(
	IN PFILE_OBJECT FileObject,
	IN PLARGE_INTEGER FileOffset,
	IN ULONG Length,
	IN BOOLEAN Wait,
	IN ULONG LockKey,
	OUT PVOID Buffer,
	OUT PIO_STATUS_BLOCK IoStatus,
	IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN InterceptGenericFastIoDeviceControl(
	IN PFILE_OBJECT FileObject,
	IN BOOLEAN Wait,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength,
	IN ULONG IoControlCode,
	OUT PIO_STATUS_BLOCK IoStatus,
	IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS EnableMonitoring();
NTSTATUS DisableMonitoring();
BOOLEAN IsMonitoringEnabled();

```

`Driver/Driver.inf`:

```inf
;
; IrpDumper.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=01/01/1970
CatalogFile=Driver.cat
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 10           ; %SystemRoot%


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
IrpDumper.sys = 1,,


[DefaultInstall]
OptionDesc = %ServiceDesc%
CopyFiles  = IrpDumper.DriverFiles

[IrpDumper.DriverFiles]
IrpDumper.sys,,,0x00000004        ; COPYFLG_NOVERSIONCHECK

[DefaultInstall.Services]
AddService = %ServiceName%,,IrpDumper.ServiceInstall

[IrpDumper.ServiceInstall]
DisplayName   = %ServiceName%
Description   = %ServiceDesc%
ServiceBinary = %10%\IrpDumper.sys
ServiceType   = 1              ; SERVICE_KERNEL_DRIVER
StartType     = 3              ; SERVICE_AUTO_START ; SERVICE_DEMAND_START = 3
ErrorControl  = 1              ; SERVICE_ERROR_NORMAL

[Strings]
ManufacturerName="BlahCat Corp"
DiskName="IrpDumper Installation Disk"
ServiceName = "IrpDumper"
ServiceDesc = "IrpDumper is the driver that hooks the IRPs, and can't be controlled via the Broker tool."
```

`Driver/Driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{148F59B4-A689-4C08-9D7D-0EFB5C6BDA16}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Driver</RootNamespace>
    <ProjectName>Driver</ProjectName>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(ConfigurationName)\</OutDir>
    <IntDir>$(Platform)\$(ConfigurationName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetName>IrpDumper</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetName>IrpDumper</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);_DRIVER</PreprocessorDefinitions>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <Link>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);_DRIVER</PreprocessorDefinitions>
      <SupportJustMyCode>false</SupportJustMyCode>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <UseFullPaths>false</UseFullPaths>
    </ClCompile>
    <Link>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
    </Link>
    <Inf>
      <SpecifyDriverVerDirectiveVersion>true</SpecifyDriverVerDirectiveVersion>
    </Inf>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_X86_=1;i386=1;STD_CALL;%(PreprocessorDefinitions);_DRIVER</PreprocessorDefinitions>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Driver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Common.h" />
    <ClInclude Include="Driver.h" />
    <ClInclude Include="HookedDrivers.h" />
    <ClInclude Include="IoAddDriver.h" />
    <ClInclude Include="IoctlCodes.h" />
    <ClInclude Include="IoEnableDisableDriverMonitoring.h" />
    <ClInclude Include="IoEnableDisableMonitoring.h" />
    <ClInclude Include="IoGetDriverInfo.h" />
    <ClInclude Include="IoRemoveDriver.h" />
    <ClInclude Include="IoSetEventPointer.h" />
    <ClInclude Include="InterceptedIrpHandler.h" />
    <ClInclude Include="IoStoreTestCase.h" />
    <ClInclude Include="Queue.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
    <ClCompile Include="HookedDrivers.c" />
    <ClCompile Include="IoAddDriver.c" />
    <ClCompile Include="IoEnableDisableDriverMonitoring.c" />
    <ClCompile Include="IoEnableDisableMonitoring.c" />
    <ClCompile Include="IoGetDriverInfo.c" />
    <ClCompile Include="IoRemoveDriver.c" />
    <ClCompile Include="IoSetEventPointer.c" />
    <ClCompile Include="InterceptedIrpHandler.c" />
    <ClCompile Include="IoStoreTestCase.c" />
    <ClCompile Include="Queue.c" />
    <ClCompile Include="Utils.c" />
  </ItemGroup>
  <ItemGroup>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Driver/Driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="IoAddDriver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IoctlCodes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HookedDrivers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IoRemoveDriver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IoGetDriverInfo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Queue.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IoSetEventPointer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IoEnableDisableMonitoring.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="InterceptedIrpHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IoStoreTestCase.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IoEnableDisableDriverMonitoring.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IoAddDriver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HookedDrivers.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IoRemoveDriver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IoGetDriverInfo.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Queue.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IoSetEventPointer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IoEnableDisableMonitoring.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="InterceptedIrpHandler.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IoStoreTestCase.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IoEnableDisableDriverMonitoring.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Driver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
</Project>
```

`Driver/HookedDrivers.c`:

```c
#include "HookedDrivers.h"
#include "IoAddDriver.h"

static LIST_ENTRY HookedDriversHead;
PLIST_ENTRY g_HookedDriverHead = &HookedDriversHead;

static KSPIN_LOCK HookedDriverSpinLock;
static KLOCK_QUEUE_HANDLE HookedDriverSpinLockQueue;

static FAST_MUTEX DriverListMutex;


/*++

Routine Description:

Initialize the structures used as part of the driver hooking.


Arguments:


Return Value:

	Returns STATUS_SUCCESS on success.

--*/
void InitializeHookedDriverStructures()
{
    KeInitializeSpinLock(&HookedDriverSpinLock);
	ExInitializeFastMutex(&DriverListMutex);
    return;
}


/*++

Routine Description:

Return the number of the hooked drivers


Arguments:

    None

Return Value:

	Returns STATUS_SUCCESS on success.

--*/
UINT32 
GetNumberOfHookedDrivers()
{
    UINT32 i = 0;
    
    KeAcquireInStackQueuedSpinLock(&g_AddRemoveDriverSpinLock, &g_AddRemoveSpinLockQueue);

    if (!IsListEmpty(g_HookedDriverHead))
    {
		PLIST_ENTRY Entry;
        for (i = 0, Entry = g_HookedDriverHead->Flink; 
            Entry != g_HookedDriverHead; 
            Entry = Entry->Flink, i++);
    }

    KeReleaseInStackQueuedSpinLock(&g_AddRemoveSpinLockQueue);

	return i;
}


/*++

Routine Description:

Return a null terminated wide-string formed with all names of hooked drivers, separated 
with a comma ','.


Arguments:
 
    None

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
NTSTATUS
GetNamesOfHookedDrivers(_In_ UCHAR Flags, _Out_ PUCHAR lpOutputBuffer, _In_ ULONG ulOutputBufferSize, _Out_ PULONG pdwDataWritten)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    ULONG cursz = 0;

    RtlSecureZeroMemory(lpOutputBuffer, ulOutputBufferSize);

    KeAcquireInStackQueuedSpinLock(&g_AddRemoveDriverSpinLock, &g_AddRemoveSpinLockQueue);

    Status = STATUS_SUCCESS;
    if (!IsListEmpty(g_HookedDriverHead))
    {

        for (PLIST_ENTRY Entry = g_HookedDriverHead->Flink;
            Entry != g_HookedDriverHead;
            Entry = Entry->Flink)
        {
            PHOOKED_DRIVER CurDrv = CONTAINING_RECORD(Entry, HOOKED_DRIVER, ListEntry);
            if (!CurDrv)
                break;

            if (Flags & ENABLED_DRIVERS_ONLY && !CurDrv->Enabled)
                continue;

            PWCHAR CurDrvName = CurDrv->Name;
            ULONG CurDrvNameLen = (ULONG) wcslen(CurDrvName)*2;

            if (cursz + CurDrvNameLen + 2 >= ulOutputBufferSize)
            {
                RtlSecureZeroMemory(lpOutputBuffer, ulOutputBufferSize);
                cursz = 0;
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            RtlCopyMemory(lpOutputBuffer + cursz, CurDrvName, CurDrvNameLen);
            cursz += CurDrvNameLen;

            RtlCopyMemory(lpOutputBuffer + cursz, L";", 2);
            cursz += 2;
        }
    }

    *pdwDataWritten = cursz;

    KeReleaseInStackQueuedSpinLock(&g_AddRemoveSpinLockQueue);

    return Status;
}


/*++

Routine Description:

Determines whether a specific Driver Object is already in the hooked driver list.


Arguments:


Return Value:

	Returns STATUS_SUCCESS on success.

--*/
BOOLEAN IsDriverHooked(_In_ PDRIVER_OBJECT pDriverObject)
{
    BOOLEAN bRes = FALSE;

    KeAcquireInStackQueuedSpinLock(&HookedDriverSpinLock, &HookedDriverSpinLockQueue);

    if (!IsListEmpty(g_HookedDriverHead))
    {
        for (PLIST_ENTRY Entry = g_HookedDriverHead->Flink;
            Entry != g_HookedDriverHead;
            Entry = Entry->Flink)
        {
            PHOOKED_DRIVER CurDrv = CONTAINING_RECORD(Entry, HOOKED_DRIVER, ListEntry);

            if (CurDrv->DriverObject == pDriverObject)
            {
                bRes = TRUE;
                break;
            }
        }
    }

    KeReleaseInStackQueuedSpinLock(&HookedDriverSpinLockQueue);

	return bRes;
}


/*++

Routine Description:

Returns a pointer to a HOOKED_DRIVER object if its name is found in the list of hooked
drivers.


Arguments:


Return Value:

	Returns STATUS_SUCCESS on success.

	--*/
NTSTATUS GetHookedDriverByName(_In_ LPWSTR lpDriverName, _Out_ PHOOKED_DRIVER *pHookedDrv)
{
	NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;

	//CfbDbgPrintInfo(L"GetHookedDriverByName(lpDriverName='%s')\n", lpDriverName);

    KeAcquireInStackQueuedSpinLock(&HookedDriverSpinLock, &HookedDriverSpinLockQueue);

    if (!IsListEmpty(g_HookedDriverHead))
    {
        PLIST_ENTRY Entry = g_HookedDriverHead->Flink;

        do
        {
            PHOOKED_DRIVER CurDrv = CONTAINING_RECORD(Entry, HOOKED_DRIVER, ListEntry);

            if (_wcsicmp(CurDrv->Name, lpDriverName) == 0)
            {
				*pHookedDrv = CurDrv;
				Status = STATUS_SUCCESS;
                break;
            }

            Entry = Entry->Flink;

        } 
		while (Entry != g_HookedDriverHead);

    }

    KeReleaseInStackQueuedSpinLock(&HookedDriverSpinLockQueue);

    return Status;
}



/*++

Routine Description:

 Find the original function for the driver


Arguments:

	- DeviceObject

Return Value:

	Returns a pointer to the hooked driver on success, NULL otherwise

--*/
PHOOKED_DRIVER GetHookedDriverFromDeviceObject(_In_ PDEVICE_OBJECT DeviceObject)
{
	if (IsListEmpty(g_HookedDriverHead))
		return NULL;

	PHOOKED_DRIVER Driver = NULL;
	PLIST_ENTRY Entry = g_HookedDriverHead->Flink;

	do
	{
		Driver = CONTAINING_RECORD(Entry, HOOKED_DRIVER, ListEntry);

		if (Driver->DriverObject == DeviceObject->DriverObject)
			return Driver;

		Entry = Entry->Flink;

	} 
	while (Entry != g_HookedDriverHead);

	return NULL;
}
```

`Driver/HookedDrivers.h`:

```h
#pragma once

#include "Common.h"
#include "../Common/common.h"
#include "Utils.h"


typedef struct _HOOKED_DRIVER
{
	BOOLEAN Enabled;
	WCHAR Name[HOOKED_DRIVER_MAX_NAME_LEN];
	UNICODE_STRING UnicodeName;
	PDRIVER_OBJECT DriverObject;
	LIST_ENTRY ListEntry;
	PDRIVER_DISPATCH OriginalRoutines[IRP_MJ_MAXIMUM_FUNCTION+1];
	PFAST_IO_READ FastIoRead;
	PFAST_IO_WRITE FastIoWrite;
	PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
	UINT64 NumberOfRequestIntercepted;
}
HOOKED_DRIVER, *PHOOKED_DRIVER;


#define ENABLED_DRIVERS_ONLY 1

void 
InitializeHookedDriverStructures();

UINT32 
GetNumberOfHookedDrivers();

NTSTATUS 
GetNamesOfHookedDrivers(_In_ UCHAR Flags, _Out_ PUCHAR lpOutputBuffer, _In_ ULONG ulOutputBufferSize, _Out_ PULONG pdwDataWritten);

BOOLEAN 
IsDriverHooked(_In_ PDRIVER_OBJECT pDriverName);

NTSTATUS 
GetHookedDriverByName(_In_ LPWSTR lpDriverName, _Out_ PHOOKED_DRIVER* pHookedDrv);

PHOOKED_DRIVER 
GetHookedDriverFromDeviceObject(_In_ PDEVICE_OBJECT DeviceObject);

```

`Driver/InterceptedIrpHandler.c`:

```c
#include "InterceptedIrpHandler.h"

typedef struct
{
    UINT32 Pid;
    UINT32 Tid;
    UINT32 IoctlCode;
    UINT32 Type;
    WCHAR DriverName[MAX_PATH];
    WCHAR DeviceName[MAX_PATH];
    PVOID InputBuffer;
    PVOID OutputBuffer;
    ULONG InputBufferLen;
    ULONG OutputBufferLen;
}
HOOKED_IRP_INFO, *PHOOKED_IRP_INFO;




/*++

Reference:
https://www.codeproject.com/Articles/9504/Driver-Development-Part-1-Introduction-to-Drivers
https://www.codeproject.com/Articles/8651/A-simple-demo-for-WDM-Driver-development

--*/
static NTSTATUS ExtractIrpData(IN PIRP Irp, IN ULONG Method, IN ULONG BufferLength, OUT PVOID *OutBuffer)
{
    PVOID Buffer = ExAllocatePoolWithTag(NonPagedPool, BufferLength, CFB_DEVICE_TAG);
    if (!Buffer)
        return STATUS_INSUFFICIENT_RESOURCES;

    RtlSecureZeroMemory(Buffer, BufferLength);

    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);

    __try
    {
        do
        {
            if ((Stack->MajorFunction == IRP_MJ_DEVICE_CONTROL || Stack->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) && \
                Method == METHOD_NEITHER)
            {
                if (Stack->Parameters.DeviceIoControl.Type3InputBuffer >= (PVOID)(1 << 16))
                    RtlCopyMemory(Buffer, Stack->Parameters.DeviceIoControl.Type3InputBuffer, BufferLength);
                else
                    Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if (Method == METHOD_BUFFERED)
            {
                if (Irp->AssociatedIrp.SystemBuffer)
                    RtlCopyMemory(Buffer, Irp->AssociatedIrp.SystemBuffer, BufferLength);
                else
                    Status = STATUS_INVALID_PARAMETER_1;
                break;
            }

            if(Method == METHOD_IN_DIRECT || Method == METHOD_OUT_DIRECT)
            {
                if (!Irp->MdlAddress)
                {
                    Status = STATUS_INVALID_PARAMETER_2;
                    break;
                }

                PVOID pDataAddr = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);
                if (!pDataAddr)
                {
                    Status = STATUS_INVALID_PARAMETER_3;
                    break;
                }

                RtlCopyMemory(Buffer, pDataAddr, BufferLength );
            }

        } while (0);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        CfbDbgPrintErr(L"Exception Code: 0x%X\n", Status);
    }


    if (!NT_SUCCESS(Status))
    {
        CfbDbgPrintErr(L"Failed to copy data (Status=0x%x), freeing %p\n", Status, Buffer);
        ExFreePoolWithTag(Buffer, CFB_DEVICE_TAG);
    }
    else
    {
        *OutBuffer = Buffer;
    }

    return Status;
}



NTSTATUS ExtractDeviceIoctlIrpData(IN PIRP Irp, OUT PVOID *Buffer, OUT PULONG BufferLength)
{
    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);

    *BufferLength = Stack->Parameters.DeviceIoControl.InputBufferLength;
    if( *BufferLength == 0 )
        return STATUS_SUCCESS;

    ULONG IoctlCode = Stack->Parameters.DeviceIoControl.IoControlCode;
    ULONG Method = METHOD_FROM_CTL_CODE(IoctlCode);

    return ExtractIrpData(Irp, Method, *BufferLength, Buffer);
}


/*++

Extract the IRP data from a READ or WRITE.

Ref: 
- https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-write
- https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-read

--*/
NTSTATUS ExtractReadWriteIrpData(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT PVOID *InputBuffer, OUT PULONG InputBufferLength)
{
    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);

    if (Stack->MajorFunction == IRP_MJ_READ)
    {
        *InputBufferLength = Stack->Parameters.Read.Length;
        return STATUS_SUCCESS;
    }

    *InputBufferLength = Stack->Parameters.Write.Length;

    if(*InputBufferLength == 0)
        return STATUS_SUCCESS;


    ULONG Method;

    if(DeviceObject->Flags & DO_BUFFERED_IO)
        Method = METHOD_BUFFERED;

    else if(DeviceObject->Flags & DO_DIRECT_IO)
        Method = METHOD_IN_DIRECT;

    else
        return STATUS_UNSUCCESSFUL;

    return ExtractIrpData(Irp, Method, *InputBufferLength, InputBuffer);
}



/*++

Move the message from the stack to kernel pool.

--*/
NTSTATUS PreparePipeMessage(IN PHOOKED_IRP_INFO pIn, OUT PINTERCEPTED_IRP *pIrp)
{
    *pIrp = (PINTERCEPTED_IRP)ExAllocatePoolWithTag( NonPagedPool, sizeof(INTERCEPTED_IRP), CFB_DEVICE_TAG );
    if ( !*pIrp)
        return STATUS_INSUFFICIENT_RESOURCES;

    RtlSecureZeroMemory(*pIrp, sizeof(INTERCEPTED_IRP));

    //
    // Allocate the intercepted IRP header...
    //
    PINTERCEPTED_IRP_HEADER pIrpHeader = (PINTERCEPTED_IRP_HEADER)ExAllocatePoolWithTag( 
        NonPagedPool,
        sizeof( INTERCEPTED_IRP_HEADER ), 
        CFB_DEVICE_TAG 
    );

    if (!pIrpHeader)
    {
        ExFreePoolWithTag( *pIrp, CFB_DEVICE_TAG );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlSecureZeroMemory(pIrpHeader, sizeof(INTERCEPTED_IRP_HEADER) );

    size_t szDriverNameLength = wcslen( pIn->DriverName );
    szDriverNameLength = szDriverNameLength > MAX_PATH ? MAX_PATH : szDriverNameLength + 1;
    
    size_t szDeviceNameLength = wcslen( pIn->DeviceName );
    szDeviceNameLength = szDeviceNameLength > MAX_PATH ? MAX_PATH : szDeviceNameLength + 1;

    PWCHAR lpswProcessName = L"unknown\0";
    size_t szProcessNameLength = 8;
    UNICODE_STRING u = { 0 };
    PUNICODE_STRING us = &u;

    if (NT_SUCCESS(GetProcessNameFromPid(pIn->Pid, &us)) && us->Length)
    {
        lpswProcessName = us->Buffer;
        szProcessNameLength = us->Length < MAX_PATH ? us->Length : MAX_PATH;
    }


    //
    // ... and fill it up
    //

    KeQuerySystemTime( &pIrpHeader->TimeStamp );
    pIrpHeader->Pid = pIn->Pid;
    pIrpHeader->Tid = pIn->Tid;
    pIrpHeader->Type = pIn->Type;
    pIrpHeader->Irql = KeGetCurrentIrql();
    pIrpHeader->InputBufferLength = pIn->InputBufferLen;
    pIrpHeader->OutputBufferLength = pIn->OutputBufferLen;
    pIrpHeader->IoctlCode = pIn->IoctlCode;

    wcscpy_s(pIrpHeader->DriverName, szDriverNameLength, pIn->DriverName );
    wcscpy_s(pIrpHeader->DeviceName, szDeviceNameLength, pIn->DeviceName );
    wcscpy_s(pIrpHeader->ProcessName, szProcessNameLength, lpswProcessName);

    if (us)
        RtlFreeUnicodeString(us);

    //
    // fill up the message structure
    //

    (*pIrp)->Header = pIrpHeader;
    (*pIrp)->InputBuffer = pIn->InputBuffer;

    return STATUS_SUCCESS;
}


/*++

Totally wipe all traces of the IRP.

--*/
VOID FreeInterceptedIrp(IN PINTERCEPTED_IRP pIrp)
{
    UINT32 dwBodyLen = pIrp->Header->InputBufferLength;
    if (pIrp->InputBuffer && dwBodyLen)
    {
        RtlSecureZeroMemory(pIrp->InputBuffer, dwBodyLen);
        ExFreePoolWithTag(pIrp->InputBuffer, CFB_DEVICE_TAG);
        pIrp->InputBuffer = NULL;
    }

    dwBodyLen = pIrp->Header->OutputBufferLength;
    if (pIrp->OutputBuffer && dwBodyLen)
    {
        RtlSecureZeroMemory(pIrp->OutputBuffer, dwBodyLen);
        ExFreePoolWithTag(pIrp->OutputBuffer, CFB_DEVICE_TAG);
        pIrp->OutputBuffer = NULL;
    }

    RtlSecureZeroMemory(pIrp->Header, sizeof(INTERCEPTED_IRP_HEADER));
    ExFreePoolWithTag(pIrp->Header, CFB_DEVICE_TAG);

    RtlSecureZeroMemory(pIrp, sizeof(INTERCEPTED_IRP));
    ExFreePoolWithTag(pIrp, CFB_DEVICE_TAG);
    pIrp = NULL;
    return;
}


/*++

HandleInterceptedIrp is called every time we intercept an IRP. It will extract the data
from the IRP packet (depending on its method), and build a INTERCEPTED_IRP object that will
written back to the userland client.

--*/
NTSTATUS HandleInterceptedIrp(IN PHOOKED_DRIVER Driver, IN PDEVICE_OBJECT pDeviceObject, IN PIRP Irp, OUT PINTERCEPTED_IRP *pIrpOut)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PINTERCEPTED_IRP pIrp = NULL;
    HOOKED_IRP_INFO temp = { 0, };
    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation( Irp );
    
    temp.Pid = HandleToULong(PsGetProcessId(PsGetCurrentProcess()));
    temp.Tid = HandleToULong(PsGetCurrentThreadId());
    temp.Type = (CFB_INTERCEPTED_IRP_TYPE_IRP |(UINT32)Stack->MajorFunction);

    wcsncpy_s( temp.DriverName, MAX_PATH*sizeof(WCHAR), Driver->Name, _TRUNCATE);

    Status = GetDeviceNameFromDeviceObject( pDeviceObject, temp.DeviceName, MAX_PATH );
    if ( !NT_SUCCESS( Status ) )
        CfbDbgPrintWarn( L"Cannot get device name, using empty string (Status=0x%#x)\n", Status );


    switch (temp.Type)
    {
        case IRP_MJ_DEVICE_CONTROL:
        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            temp.InputBufferLen = Stack->Parameters.DeviceIoControl.InputBufferLength;
            temp.OutputBufferLen = Stack->Parameters.DeviceIoControl.OutputBufferLength;
            temp.IoctlCode = Stack->Parameters.DeviceIoControl.IoControlCode;
            Status = ExtractDeviceIoctlIrpData(Irp, &temp.InputBuffer, &temp.InputBufferLen);
            if (!NT_SUCCESS(Status))
            {
                CfbDbgPrintErr(L"ExtractDeviceIoctlIrpData() returned 0x%x\n", Status);
                return Status;
            }
            break;

        case IRP_MJ_WRITE:
            temp.InputBufferLen = Stack->Parameters.Write.Length;
            temp.OutputBufferLen = 0;
            Status = ExtractReadWriteIrpData(pDeviceObject, Irp, &temp.InputBuffer, &temp.InputBufferLen);
            if (!NT_SUCCESS(Status))
            {
                CfbDbgPrintErr(L"ExtractReadWriteIrpData returned 0x%x\n", Status);
                return Status;
            }
            break;

        case IRP_MJ_READ:
            temp.InputBufferLen = 0;
            temp.OutputBufferLen = Stack->Parameters.Read.Length;
            break;

        default:
            break;
    }

    Status = PreparePipeMessage(&temp, &pIrp);

    if (!NT_SUCCESS(Status) || pIrp == NULL)
    {
        CfbDbgPrintErr(L"PreparePipeMessage() failed, Status=%#X\n", Status);
        if (temp.InputBuffer)
        {
            ExFreePoolWithTag(temp.InputBuffer, CFB_DEVICE_TAG);
            temp.InputBuffer = NULL;
        }

        return Status;
    }

    *pIrpOut = pIrp;

    return STATUS_SUCCESS;
}


/*++

This function is called when a synchronous IRP is done being processed, so we can
collect additional info about the result.

--*/
NTSTATUS
CompleteHandleInterceptedIrp(
    _In_opt_ PVOID UserBuffer,
    _In_ NTSTATUS IrpStatus,
    _Inout_ PINTERCEPTED_IRP pIrpInfo
)
{
    //
    // Complete the info
    //
    pIrpInfo->Header->Status = IrpStatus;


    //
    // Only filter the types we're interested in (read and ioctls for now)
    //
    switch (pIrpInfo->Header->Type)
    {
    case IRP_MJ_READ:
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        break;

    default:
        //
        // for any other type we don't care about the output, just return
        //
        return STATUS_SUCCESS;
    }

    
    UINT32 OutputBufferLength = pIrpInfo->Header->OutputBufferLength;

    //
    // check the INTERCEPTED_IRP consistency 
    //
    if (OutputBufferLength == 0)
        return STATUS_SUCCESS;

    if (UserBuffer == NULL)
    {
        pIrpInfo->OutputBuffer = NULL;

        if (OutputBufferLength > 0)
            return STATUS_INVALID_PARAMETER_3;

        return STATUS_SUCCESS;
    }


    //
    // if here, we know UserBuffer!=0, and OutputBufferLength!=0 meaning that there's data to 
    // copy and the space was correctly allocated: perform the copy
    //
    PVOID OutputBuffer = ExAllocatePoolWithTag(NonPagedPool, OutputBufferLength, CFB_DEVICE_TAG);
    if (!OutputBuffer)
        return STATUS_INSUFFICIENT_RESOURCES;

    // TODO: add protection since UserBuffer can point to UM

    RtlSecureZeroMemory(OutputBuffer, OutputBufferLength);
    RtlCopyMemory(OutputBuffer, UserBuffer, OutputBufferLength);

#ifdef _DEBUG
    //CfbDbgPrintOk(L"after copied output_buffer=%p, len=%u, type=%d, irql=%d\n", OutputBuffer, OutputBufferLength, pIrpInfo->Header->Type, pIrpInfo->Header->Irql);
    //CfbHexDump(OutputBuffer, OutputBufferLength);
#endif

    pIrpInfo->OutputBuffer = OutputBuffer;

    return STATUS_SUCCESS;
}



NTSTATUS 
HandleInterceptedFastIo(
    _In_ PHOOKED_DRIVER Driver, 
    _In_ PDEVICE_OBJECT pDeviceObject, 
    _In_ UINT32 Type,
    _In_ UINT32 IoctlCode,
    _In_ PVOID Buffer,
    _In_ ULONG BufferLength,
    _In_ UINT32 Flags,
    _Inout_ PINTERCEPTED_IRP* pIrpOut
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PINTERCEPTED_IRP pIrp = NULL;
    HOOKED_IRP_INFO temp = { 0, };

    BOOLEAN IsInput = Flags & CFB_FASTIO_USE_INPUT_BUFFER;


    //
    // prepare the metadata
    //
    temp.Pid = HandleToULong(PsGetProcessId(PsGetCurrentProcess()));
    temp.Tid = HandleToULong(PsGetCurrentThreadId());
    temp.Type = Type;
    temp.IoctlCode = IoctlCode;

    wcsncpy_s(temp.DriverName, MAX_PATH*sizeof(WCHAR), Driver->Name, _TRUNCATE);

    Status = GetDeviceNameFromDeviceObject(pDeviceObject, temp.DeviceName, MAX_PATH);
    if (!NT_SUCCESS(Status))
        CfbDbgPrintWarn(L"Cannot get device name, using empty string (Status=0x%#x)\n", Status);


    //
    // Copy the input buffer
    //
    if (IsInput)
    {
        if (BufferLength && Buffer)
        {
            temp.InputBuffer = ExAllocatePoolWithTag(
                NonPagedPool,
                BufferLength,
                CFB_DEVICE_TAG
            );
            if (!temp.InputBuffer)
                return STATUS_INSUFFICIENT_RESOURCES;

            RtlSecureZeroMemory(temp.InputBuffer, BufferLength);

            RtlCopyMemory(temp.InputBuffer, Buffer, BufferLength);

            temp.InputBufferLen = BufferLength;
        }
        else
        {
            temp.InputBufferLen = 0;
            temp.InputBuffer = NULL;
        }
    }
    else
    {
        if (BufferLength && Buffer)
        {
            temp.OutputBuffer = ExAllocatePoolWithTag(
                NonPagedPool,
                BufferLength,
                CFB_DEVICE_TAG
            );
            if (!temp.OutputBuffer)
                return STATUS_INSUFFICIENT_RESOURCES;

            RtlSecureZeroMemory(temp.OutputBuffer, BufferLength);

            RtlCopyMemory(temp.OutputBuffer, Buffer, BufferLength);

            temp.OutputBufferLen = BufferLength;
        }
        else
        {
            temp.OutputBufferLen = 0;
            temp.OutputBuffer = NULL;
        }
    }



    if (Flags & CFB_FASTIO_INIT_QUEUE_MESSAGE)
    {
        //
        // Prepare the message to be queued
        //
        Status = PreparePipeMessage(&temp, &pIrp);

        if (!NT_SUCCESS(Status) || pIrp == NULL)
        {
            CfbDbgPrintErr(L"PreparePipeMessage() failed, Status=%#X\n", Status);
            if (IsInput==TRUE && temp.InputBuffer)
            {
                ExFreePoolWithTag(temp.InputBuffer, CFB_DEVICE_TAG);
                temp.InputBuffer = NULL;
            }
            else if (IsInput==FALSE && temp.OutputBuffer)
            {
                ExFreePoolWithTag(temp.OutputBuffer, CFB_DEVICE_TAG);
                temp.OutputBuffer = NULL;
            }

            return Status;
        }
    }

    *pIrpOut = pIrp;
    return Status;
}
```

`Driver/InterceptedIrpHandler.h`:

```h
#pragma once

#include "Common.h"
#include "../Common/common.h"
#include "Utils.h"
#include "Queue.h"
#include "HookedDrivers.h"
#include "IoSetEventPointer.h"


/**
 * Value inserted in INTERCEPTED_IRP_HEADER.Type:
 *  - for regular IRPs, the type from INTERCEPTED_IRP_HEADER.Type is CFB_INTERCEPTED_IRP_TYPE_IRP | Irp->Stack->MajorFunction
 *  - for FastIos, the bit 24 is set, the lowest WORD is the function itself
 */
#define CFB_INTERCEPTED_IRP_TYPE_IRP           0x00000000
#define CFB_INTERCEPTED_IRP_TYPE_FASTIO_IOCTL  0x80000000
#define CFB_INTERCEPTED_IRP_TYPE_FASTIO_READ   0x80000002
#define CFB_INTERCEPTED_IRP_TYPE_FASTIO_WRITE  0x80000001


#define CFB_FASTIO_USE_OUTPUT_BUFFER           0
#define CFB_FASTIO_USE_INPUT_BUFFER            1
#define CFB_FASTIO_INIT_QUEUE_MESSAGE          2


//extern NTKERNELAPI HANDLE PsGetCurrentThreadId();
//extern NTKERNELAPI HANDLE PsGetProcessId(PEPROCESS Process);


/**
 *
 * IOCTL hooked IRP handling
 *
 */
NTSTATUS HandleInterceptedIrp(IN PHOOKED_DRIVER Driver, IN PDEVICE_OBJECT pDeviceObject, IN PIRP Irp, OUT PINTERCEPTED_IRP* pIrpOut);

NTSTATUS 
CompleteHandleInterceptedIrp(
    _In_opt_ PVOID UserBuffer, 
    _In_ NTSTATUS IrpStatus, 
    _Inout_ PINTERCEPTED_IRP pIrpInfo
);


/**
 *
 * IOCTL hooked IRP handling
 *
 */
NTSTATUS
HandleInterceptedFastIo(
	_In_ PHOOKED_DRIVER Driver,
	_In_ PDEVICE_OBJECT pDeviceObject,
	_In_ UINT32 Type,
	_In_ UINT32 IoctlCode,
	_In_ PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_In_ UINT32 Flags,
	_Inout_ PINTERCEPTED_IRP* pIrpOut
);


/**
 *
 * Intercepted IRP cleanup 
 *
 */
VOID FreeInterceptedIrp( IN PINTERCEPTED_IRP pMessage );
```

`Driver/IoAddDriver.c`:

```c
#include "IoAddDriver.h"

typedef enum
{
    Driver,
    FileSystem,
    Device
} HOOKABLE_OBJECT_T;

extern PLIST_ENTRY g_HookedDriverHead;




VOID InitializeIoAddDriverStructure()
{
    KeInitializeSpinLock(&g_AddRemoveDriverSpinLock);
}



/*++

--*/
NTSTATUS AddObjectByName(LPWSTR lpObjectName, HOOKABLE_OBJECT_T Type)
{
    NTSTATUS Status = STATUS_SUCCESS;

    /* make sure the list is not full */
    if (GetNumberOfHookedDrivers() == CFB_MAX_HOOKED_DRIVERS)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    /* lookup the driver by name, and swap it if found */
    UNICODE_STRING UnicodeName;
    PDRIVER_OBJECT pDriver;
    PDEVICE_OBJECT pDevice;
    


    RtlInitUnicodeString(&UnicodeName, lpObjectName);

    switch (Type)
    {
    case Driver:
    case FileSystem:

        Status = ObReferenceObjectByName(
            /* IN PUNICODE_STRING */ &UnicodeName,
            /* IN ULONG */ OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            /* IN PACCESS_STATE */ NULL,
            /* IN ACCESS_MASK */ 0,
            /* IN POBJECT_TYPE */ *IoDriverObjectType,
            /* IN KPROCESSOR_MODE */KernelMode,
            /* IN OUT PVOID */ NULL,
            /* OUT PVOID* */ (PVOID*)&pDriver
        );

        if (!NT_SUCCESS(Status))
            return Status;


        break;

    case Device:
        
        Status = ObReferenceObjectByName(
            &UnicodeName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            0,
            *IoDeviceObjectType,
            KernelMode,
            NULL,
            (PVOID*)&pDevice
        );

        // always returns 0xc0000024 
        

        if (!NT_SUCCESS(Status))
            return Status;


        pDriver = pDevice->DriverObject;
        
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }


    //
    // check if driver is already hooked
    //

    if ( IsDriverHooked(pDriver) )
    {
        return STATUS_ALREADY_REGISTERED;
    }


    //
    // create the new hooked driver pool object, and chain it to the rest
    //

    PHOOKED_DRIVER NewDriver = ExAllocatePoolWithTag(NonPagedPool, sizeof(HOOKED_DRIVER), CFB_DEVICE_TAG);
    if (!NewDriver)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlSecureZeroMemory(NewDriver, sizeof(HOOKED_DRIVER));


    wcscpy_s(NewDriver->Name, sizeof(NewDriver->Name) / sizeof(wchar_t), lpObjectName);
    RtlUnicodeStringCopy(&NewDriver->UnicodeName, &UnicodeName);
    NewDriver->DriverObject = pDriver;

    

    KeAcquireInStackQueuedSpinLock(&g_AddRemoveDriverSpinLock, &g_AddRemoveSpinLockQueue);

    //
    // Exchange pointers for all the major functions
    //
    for (DWORD i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        PDRIVER_DISPATCH OldRoutine = (PDRIVER_DISPATCH)InterlockedExchangePointer(
            (PVOID*)&pDriver->MajorFunction[i],
            (PVOID)InterceptGenericRoutine
        );

        NewDriver->OriginalRoutines[i] = OldRoutine;
    }


    //
    // Exchange pointer for Fast IO dispatcher
    //
    
    if (pDriver->FastIoDispatch)
    {
        PFAST_IO_DEVICE_CONTROL OldFastIoDeviceControl = (PFAST_IO_DEVICE_CONTROL)InterlockedExchangePointer(
            (PVOID*)&pDriver->FastIoDispatch->FastIoDeviceControl,
            (PVOID)InterceptGenericFastIoDeviceControl
        );

        NewDriver->FastIoDeviceControl = OldFastIoDeviceControl;

        PFAST_IO_READ OldFastIoRead = (PFAST_IO_READ)InterlockedExchangePointer(
            (PVOID*)&pDriver->FastIoDispatch->FastIoRead,
            (PVOID)InterceptGenericFastIoRead
        );

        NewDriver->FastIoRead = OldFastIoRead;

        PFAST_IO_WRITE OldFastIoWrite = (PFAST_IO_WRITE)InterlockedExchangePointer(
            (PVOID*)&pDriver->FastIoDispatch->FastIoWrite,
            (PVOID)InterceptGenericFastIoWrite
        );

        NewDriver->FastIoWrite = OldFastIoWrite;
    }

    //
    // add it to the list
    //
    InsertTailList(g_HookedDriverHead, &(NewDriver->ListEntry));

    //
    // Set the driver as ready
    //
    NewDriver->Enabled = TRUE;

    KeReleaseInStackQueuedSpinLock(&g_AddRemoveSpinLockQueue);

    return Status;
}


/*++

--*/
NTSTATUS HandleIoAddDriver(PIRP Irp, PIO_STACK_LOCATION Stack)
{

    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR lpObjectName;
    ULONG InputBufferLen;

    do
    {

        //
        // Check IRP arguments
        //

        lpObjectName = (LPWSTR)Irp->AssociatedIrp.SystemBuffer;

        if (!lpObjectName)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        InputBufferLen = Stack->Parameters.DeviceIoControl.InputBufferLength;

        if (InputBufferLen >= HOOKED_DRIVER_MAX_NAME_LEN)
        {
            CfbDbgPrintErr(L"Input buffer too large\n");
            Status = STATUS_BUFFER_OVERFLOW;
            break;
        }


        CfbDbgPrintInfo(L"Adding AddObjectByName('%s') \n", lpObjectName);


        //
        // Add the driver
        //

        //
        // Cannot hook itself
        //
        if (wcsncmp(lpObjectName, CFB_DRIVER_PATH, wcslen(CFB_DRIVER_PATH)) == 0)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (wcsncmp(lpObjectName, L"\\driver", 7) == 0)
        {
            Status = AddObjectByName(lpObjectName, Driver);
        }
        else if (wcsncmp(lpObjectName, L"\\filesystem", 11) == 0)
        {
            Status = AddObjectByName(lpObjectName, FileSystem);
        }
        else if (wcsncmp(lpObjectName, L"\\device", 7) == 0)
        {
            Status = AddObjectByName(lpObjectName, Device);
        }
        else
        {
            Status = STATUS_INVALID_PARAMETER;
        }
        
        CfbDbgPrintOk(L"AddObjectByName('%s') returned %#x\n", lpObjectName, Status);
    }
    while(0);

    return Status;
}

```

`Driver/IoAddDriver.h`:

```h
#pragma once

#include "Common.h"
#include "Utils.h"
#include "Driver.h"
#include "HookedDrivers.h"

#include <Ntstrsafe.h>

KSPIN_LOCK g_AddRemoveDriverSpinLock;
KLOCK_QUEUE_HANDLE g_AddRemoveSpinLockQueue;

NTSTATUS HandleIoAddDriver(PIRP Irp, PIO_STACK_LOCATION Stack);
VOID InitializeIoAddDriverStructure();

```

`Driver/IoEnableDisableDriverMonitoring.c`:

```c
#include "IoEnableDisableDriverMonitoring.h"


/*++

Update the hooked driver `Enabled` flag, indicating whether this driver specifically should be 
monitored.

--*/
static NTSTATUS SetDriverMonitoringStatus(_In_ PIRP Irp, BOOLEAN NewStatus)
{
	NTSTATUS Status = STATUS_SUCCESS;

	LPWSTR lpDriverName = (LPWSTR)Irp->AssociatedIrp.SystemBuffer;
	if (!lpDriverName)
		return STATUS_INVALID_PARAMETER;


	PHOOKED_DRIVER pHookedDriver;
	Status = GetHookedDriverByName(lpDriverName, &pHookedDriver);
	if (!NT_SUCCESS(Status))
		return Status;

	pHookedDriver->Enabled = !!NewStatus;

	return Status;
}



/*++

Enable driver monitoring IO request.

--*/
NTSTATUS HandleIoEnableDriverMonitoring(_In_ PIRP Irp, _In_ PIO_STACK_LOCATION Stack)
{
	UNREFERENCED_PARAMETER(Stack);
	PAGED_CODE();

	NTSTATUS Status = SetDriverMonitoringStatus(Irp, TRUE);
	if (NT_SUCCESS(Status))
		CfbDbgPrintOk(L"Driver monitoring is ENABLED\n");

	return STATUS_SUCCESS;
}


/*++

Disable driver monitoring IO request.

--*/
NTSTATUS HandleIoDisableDriverMonitoring(_In_ PIRP Irp, _In_ PIO_STACK_LOCATION Stack)
{
	UNREFERENCED_PARAMETER(Stack);
	PAGED_CODE();

	NTSTATUS Status = SetDriverMonitoringStatus(Irp, FALSE);
	if(NT_SUCCESS(Status))
		CfbDbgPrintOk(L"Driver monitoring is DISABLED\n");

	return Status;
}
```

`Driver/IoEnableDisableDriverMonitoring.h`:

```h
#pragma once

#include "Common.h"
#include "Driver.h"


NTSTATUS HandleIoEnableDriverMonitoring(_In_ PIRP Irp, _In_ PIO_STACK_LOCATION Stack);
NTSTATUS HandleIoDisableDriverMonitoring(_In_ PIRP Irp, _In_ PIO_STACK_LOCATION Stack);
```

`Driver/IoEnableDisableMonitoring.c`:

```c
#include "IoEnableDisableMonitoring.h"


BOOLEAN g_IsMonitoringEnabled;
static FAST_MUTEX g_InterceptFastMutex;


/*++

--*/
void InitializeMonitoringStructures()
{
    ExInitializeFastMutex(&g_InterceptFastMutex);

    return;
}


/*++

--*/
static inline NTSTATUS ChangeMonitoringStatus(BOOLEAN NewStatus)
{
    ExAcquireFastMutex(&g_InterceptFastMutex);
    g_IsMonitoringEnabled = NewStatus;
    ExReleaseFastMutex(&g_InterceptFastMutex);

    return STATUS_SUCCESS;
}


/*++

--*/
NTSTATUS EnableMonitoring()
{
    return ChangeMonitoringStatus(TRUE);
}


/*++

--*/
NTSTATUS DisableMonitoring()
{
    return ChangeMonitoringStatus(FALSE);
}


/*++

--*/
BOOLEAN IsMonitoringEnabled()
{
    return g_IsMonitoringEnabled != 0;
}


/*++

--*/
NTSTATUS HandleIoEnableMonitoring( PIRP Irp, PIO_STACK_LOCATION Stack )
{
	UNREFERENCED_PARAMETER( Irp );
	UNREFERENCED_PARAMETER( Stack );
	PAGED_CODE();

	EnableMonitoring();
	CfbDbgPrintOk( L"Monitoring is ENABLED\n" );

	return STATUS_SUCCESS;
}


/*++

--*/
NTSTATUS HandleIoDisableMonitoring( PIRP Irp, PIO_STACK_LOCATION Stack )
{
	UNREFERENCED_PARAMETER( Irp );
	UNREFERENCED_PARAMETER( Stack );
	PAGED_CODE();

	DisableMonitoring();
	CfbDbgPrintOk( L"Monitoring is DISABLED\n" );

	return STATUS_SUCCESS;
}
```

`Driver/IoEnableDisableMonitoring.h`:

```h
#pragma once

#include "Common.h"
#include "Driver.h"

void InitializeMonitoringStructures();

NTSTATUS HandleIoEnableMonitoring( PIRP Irp, PIO_STACK_LOCATION Stack );
NTSTATUS HandleIoDisableMonitoring( PIRP Irp, PIO_STACK_LOCATION Stack );

```

`Driver/IoGetDriverInfo.c`:

```c
#include "IoGetDriverInfo.h"



/*++


--*/
static NTSTATUS GetDriverInfo(_In_ PHOOKED_DRIVER pHookedDriver, _Out_ PHOOKED_DRIVER_INFO pDrvInfo, _Out_ PULONG pdwNbWrittenBytes)
{

	NTSTATUS Status = STATUS_SUCCESS;

	__try
	{
		RtlSecureZeroMemory(pDrvInfo, sizeof(HOOKED_DRIVER_INFO));
		pDrvInfo->Enabled = pHookedDriver->Enabled;
		pDrvInfo->DriverAddress = (ULONG_PTR)pHookedDriver->DriverObject;
		pDrvInfo->NumberOfRequestIntercepted = pHookedDriver->NumberOfRequestIntercepted;
		wcscpy_s(pDrvInfo->Name, pHookedDriver->DriverObject->DriverName.Length, pHookedDriver->Name);
		*pdwNbWrittenBytes = sizeof(HOOKED_DRIVER_INFO);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		Status = GetExceptionCode();
		CfbDbgPrintErr(L"[-] Exception Code: 0x%X\n", Status);
	}

	return Status;
}



/*++

--*/
NTSTATUS HandleIoGetDriverInfo(_In_ PIRP Irp, _Inout_ PIO_STACK_LOCATION Stack, _Out_ PULONG pdwDataWritten)
{
	UNREFERENCED_PARAMETER(Irp);
	PAGED_CODE();

	NTSTATUS Status = STATUS_SUCCESS;

	do
	{
        PHOOKED_DRIVER_INFO lpDriverInfo = (PHOOKED_DRIVER_INFO)Irp->AssociatedIrp.SystemBuffer;
		if (!lpDriverInfo)
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

        LPWSTR lpDriverName = (LPWSTR)Irp->AssociatedIrp.SystemBuffer;
        if (!lpDriverName)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

		PHOOKED_DRIVER pHookedDriver;
		Status = GetHookedDriverByName(lpDriverName, &pHookedDriver);
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		ULONG OutputBufferLen = Stack->Parameters.DeviceIoControl.OutputBufferLength;
		if (OutputBufferLen < sizeof(HOOKED_DRIVER_INFO))
		{
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = GetDriverInfo(pHookedDriver, lpDriverInfo, pdwDataWritten);
	}
	while (0);

	return Status;
}



/*++

--*/
NTSTATUS HandleIoGetNumberOfHookedDrivers(_In_ PIRP Irp, _Inout_ PIO_STACK_LOCATION Stack, _Out_ PULONG pdwDataWritten)
{
	UNREFERENCED_PARAMETER(Irp);
	PAGED_CODE();

	ULONG OutputBufferLen = Stack->Parameters.DeviceIoControl.OutputBufferLength;

	if (OutputBufferLen < sizeof(UINT32))
		return STATUS_BUFFER_TOO_SMALL;

	UINT32* u32Res = (UINT32*)Irp->AssociatedIrp.SystemBuffer;
	*u32Res = GetNumberOfHookedDrivers();
	*pdwDataWritten = sizeof(UINT32);
	return STATUS_SUCCESS;
}


/*++

--*/
NTSTATUS HandleIoGetNamesOfHookedDrivers(_In_ PIRP Irp, _Inout_ PIO_STACK_LOCATION Stack, _Out_ PULONG pdwDataWritten)
{
	UNREFERENCED_PARAMETER(Irp);
	PAGED_CODE();

	*pdwDataWritten = 0;

	ULONG OutputBufferLen = Stack->Parameters.DeviceIoControl.OutputBufferLength;
	PVOID OutputBuffer = (UINT32*)Irp->AssociatedIrp.SystemBuffer;

	if(!OutputBuffer || OutputBufferLen==0)
		return STATUS_BUFFER_TOO_SMALL;

	NTSTATUS Status = GetNamesOfHookedDrivers(ENABLED_DRIVERS_ONLY, OutputBuffer, OutputBufferLen, pdwDataWritten);
	if (!NT_SUCCESS(Status))
		return Status;

	return STATUS_SUCCESS;
}
```

`Driver/IoGetDriverInfo.h`:

```h
#pragma once

#include "Common.h"
#include "Driver.h"
#include "HookedDrivers.h"



NTSTATUS HandleIoGetDriverInfo(_In_ PIRP Irp, _Inout_ PIO_STACK_LOCATION Stack, _Out_ PULONG pdwDataWritten);
NTSTATUS HandleIoGetNumberOfHookedDrivers(_In_ PIRP Irp, _Inout_ PIO_STACK_LOCATION Stack, _Out_ PULONG pdwDataWritten);
NTSTATUS HandleIoGetNamesOfHookedDrivers(_In_ PIRP Irp, _Inout_ PIO_STACK_LOCATION Stack, _Out_ PULONG pdwDataWritten);
```

`Driver/IoRemoveDriver.c`:

```c
#include "IoRemoveDriver.h"


extern PLIST_ENTRY g_HookedDriverHead;


/*++

--*/
NTSTATUS RemoveDriverByName(LPWSTR lpDriverName)
{
	CfbDbgPrintInfo(L"Removing driver '%s'\n", lpDriverName);

	PHOOKED_DRIVER pHookedDriverToRemove;
	NTSTATUS Status = GetHookedDriverByName(lpDriverName, &pHookedDriverToRemove);

	if (!NT_SUCCESS(Status))
	{
		CfbDbgPrintErr(L"No hooked driver found as '%s': Status=0x%x\n", lpDriverName, Status);
		return Status;
	}


	pHookedDriverToRemove->Enabled = FALSE;


	//
	// restore the former device control function pointer
	//
	PDRIVER_OBJECT pDriver = pHookedDriverToRemove->DriverObject;

	KeAcquireInStackQueuedSpinLock(&g_AddRemoveDriverSpinLock, &g_AddRemoveSpinLockQueue);

    for (DWORD i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        InterlockedExchangePointer(
            (PVOID)&pDriver->MajorFunction[i],
            (PVOID)pHookedDriverToRemove->OriginalRoutines[i]
        );
    }

	//
	// Restore Fast IO Dispatch pointers
	//
	
	if (pDriver->FastIoDispatch)
	{
		InterlockedExchangePointer(
			(PVOID)&pDriver->FastIoDispatch->FastIoDeviceControl,
			(PVOID)pHookedDriverToRemove->FastIoDeviceControl
		);

		InterlockedExchangePointer(
			(PVOID)&pDriver->FastIoDispatch->FastIoRead,
			(PVOID)pHookedDriverToRemove->FastIoRead
		);

		InterlockedExchangePointer(
			(PVOID)&pDriver->FastIoDispatch->FastIoWrite,
			(PVOID)pHookedDriverToRemove->FastIoWrite
		);
	}


	//
	// fix the chain
	//

    RemoveEntryList(&(pHookedDriverToRemove->ListEntry));
        
	KeReleaseInStackQueuedSpinLock(&g_AddRemoveSpinLockQueue);


	//
	// free the driver pool and its reference
	//
	ObDereferenceObject(pHookedDriverToRemove->DriverObject);

	ExFreePoolWithTag(pHookedDriverToRemove, CFB_DEVICE_TAG);

	return Status;
}


/*++

--*/
NTSTATUS RemoveAllDrivers()
{
	NTSTATUS Status = STATUS_SUCCESS;

    if (IsListEmpty(g_HookedDriverHead))
    {
		CfbDbgPrintInfo(L"Hooked driver list is empty, nothing to do\n");
        return Status;
    }
    
    UINT32 dwNbRemoved = 0;
    BOOLEAN bIsLast;
    PLIST_ENTRY Entry = g_HookedDriverHead->Flink;
    PLIST_ENTRY Next;

    do
	{
        Next = Entry->Flink;
        bIsLast = Next == g_HookedDriverHead;

        PHOOKED_DRIVER Driver = CONTAINING_RECORD(Entry, HOOKED_DRIVER, ListEntry);

		WCHAR OldDriverName[HOOKED_DRIVER_MAX_NAME_LEN]={ 0, };
		wcscpy_s( OldDriverName, HOOKED_DRIVER_MAX_NAME_LEN-sizeof(WCHAR), Driver->Name );
        
		Status = RemoveDriverByName( Driver->Name );
		if (!NT_SUCCESS(Status))
		{
			CfbDbgPrintErr(L"Failed to remove driver %s\n", OldDriverName );
		}
		else
		{
			CfbDbgPrintOk(L"Driver %s removed\n", OldDriverName );
			dwNbRemoved++;
		}

        if (bIsLast)
        {
            break;
        }

        Entry = Next;
    } 
	while ( !IsListEmpty(g_HookedDriverHead) );

	CfbDbgPrintOk(L"Removed %lu drivers\n", dwNbRemoved);

	return Status;
}


/*++

--*/
NTSTATUS HandleIoRemoveDriver(PIRP Irp, PIO_STACK_LOCATION Stack)
{
	UNREFERENCED_PARAMETER(Irp);
	PAGED_CODE();

	NTSTATUS Status = STATUS_SUCCESS;
	LPWSTR lpDriverName;
	ULONG InputBufferLen;

	do
	{

		//
		// Check IRP arguments
		//

		lpDriverName = (LPWSTR)Irp->AssociatedIrp.SystemBuffer;

		if (!lpDriverName)
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		InputBufferLen = Stack->Parameters.DeviceIoControl.InputBufferLength;

		if (InputBufferLen >= HOOKED_DRIVER_MAX_NAME_LEN)
		{
			CfbDbgPrintErr(L"Input buffer too large\n");
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}


		//
		// Remove the driver
		//
		Status = RemoveDriverByName(lpDriverName);

		CfbDbgPrintOk(L"RemoveDriverByName('%s') returned %#x\n", lpDriverName, Status);

	} while (0);

	return Status;
}


```

`Driver/IoRemoveDriver.h`:

```h
#pragma once

#include "Common.h"
#include "Driver.h"
#include "HookedDrivers.h"

#include "IoAddDriver.h"

NTSTATUS HandleIoRemoveDriver(PIRP Irp, PIO_STACK_LOCATION Stack);
NTSTATUS RemoveAllDrivers();


```

`Driver/IoSetEventPointer.c`:

```c
#include "IoSetEventPointer.h"




/*++

--*/
VOID NotifyUserNewEvent()
{
	KeSetEvent( g_EventNotificationPointer, 2, FALSE );
}


/*++

--*/
VOID UnsetNewIrpInQueueAlert()
{
    KeClearEvent(g_EventNotificationPointer);
}


/*++

--*/
VOID ClearNotificationPointer()
{
	if ( !g_EventNotificationPointer )
	{
        CfbDbgPrintErr(L"Trying to free NULL pointer g_EventNotificationPointer\n");
		return;
	}

	KeResetEvent( g_EventNotificationPointer );
	ObDereferenceObject( g_EventNotificationPointer );
	g_EventNotificationPointer = NULL;
	
	return;
}


/*++

This function sets the event pointer that is used to notify of new activity (i.e new message pushed 
to the queue). It reads from the IRP the handle from usermode, and performs the adequate checks.

--*/
NTSTATUS HandleIoSetEventPointer( IN PIRP Irp, IN PIO_STACK_LOCATION Stack ) 
{
	NTSTATUS status = STATUS_SUCCESS;

	UINT32 dwInputLength = Stack->Parameters.DeviceIoControl.InputBufferLength;
	if (dwInputLength != sizeof(HANDLE) )
	{
		return STATUS_INVALID_PARAMETER;
	}

	PHANDLE pHandle = (PHANDLE)Irp->AssociatedIrp.SystemBuffer;
	HANDLE hEvent = *pHandle;
	PKEVENT pKernelNotifEvent;

	CfbDbgPrintInfo(L"Lookup for handle 0x%x\n", hEvent);
	
	status = ObReferenceObjectByHandle(
		hEvent,
		EVENT_ALL_ACCESS,
		*ExEventObjectType,
		UserMode,
		&pKernelNotifEvent,
		NULL
	);

	if ( !NT_SUCCESS( status ) )
	{
		return status;
	}

	CfbDbgPrintOk(L"Event handle set to 0x%x\n", hEvent);

	PKEVENT pOldEvent = InterlockedExchangePointer((PVOID*)&g_EventNotificationPointer, pKernelNotifEvent );

	if ( pOldEvent )
	{
		ObDereferenceObject( pOldEvent );
	}
	
	return status;
}


```

`Driver/IoSetEventPointer.h`:

```h
#pragma once

#include "Common.h"
#include "Utils.h"

PKEVENT g_EventNotificationPointer;

NTSTATUS HandleIoSetEventPointer( IN PIRP Irp, IN PIO_STACK_LOCATION Stack );
VOID ClearNotificationPointer();
VOID NotifyUserNewEvent();
VOID UnsetNewIrpInQueueAlert();
```

`Driver/IoStoreTestCase.c`:

```c
#include "IoStoreTestCase.h"

PVOID g_LastTestCase = NULL;

static FAST_MUTEX FastMutex;


/*++

--*/
NTSTATUS InitializeTestCaseStructures()
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

    ExInitializeFastMutex(&FastMutex);

    ExAcquireFastMutex(&FastMutex);
	{
		g_LastTestCase = ExAllocatePoolWithTag(NonPagedPool, CFB_MAX_TESTCASE_SIZE, CFB_TESTCASE_TAG);
		if (!g_LastTestCase)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
		}
		else
		{
			RtlSecureZeroMemory(g_LastTestCase, CFB_MAX_TESTCASE_SIZE);
			Status = STATUS_SUCCESS;
		}
	}
    ExReleaseFastMutex(&FastMutex);

	return Status;
}


/*++

--*/
NTSTATUS HandleIoStoreTestCase(PIRP Irp, PIO_STACK_LOCATION Stack) 
{

    NTSTATUS Status = STATUS_UNSUCCESSFUL;


    if (!g_LastTestCase)
    {
        return Status;
    }


    ExAcquireFastMutex(&FastMutex);

    RtlSecureZeroMemory(g_LastTestCase, CFB_MAX_TESTCASE_SIZE);

    __try {
        do
        {

            PVOID lpUserBuffer = Irp->AssociatedIrp.SystemBuffer;
            UINT32 uBufferLen = (UINT32) Stack->Parameters.DeviceIoControl.InputBufferLength;

            if (uBufferLen-sizeof(PUINT32) >= CFB_MAX_TESTCASE_SIZE)
            {
                CfbDbgPrintErr(L"Cannot store testcase (size=0x%x, max=0x%x)\n", uBufferLen, CFB_MAX_TESTCASE_SIZE);
                Status = STATUS_BUFFER_OVERFLOW;
                break;
            }

            PUINT32 ptr = (PUINT32)g_LastTestCase;
            *ptr = uBufferLen;
			ptr++;
            RtlCopyMemory(ptr, lpUserBuffer, uBufferLen - sizeof(PUINT32));

			CfbDbgPrintOk(L"%d copied to %p...\n", uBufferLen - sizeof(PUINT32), g_LastTestCase);

            Status = STATUS_SUCCESS;
        } 
        while (0);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        Status = GetExceptionCode();
        CfbDbgPrintErr(L"Exception Code: 0x%x\n", Status);
    }

    ExReleaseFastMutex(&FastMutex);

    return Status;

}


/*++

--*/
NTSTATUS ReleaseTestCaseStructures()
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    ExAcquireFastMutex(&FastMutex);
    
    if (g_LastTestCase)
    {
        ExFreePoolWithTag(g_LastTestCase, CFB_TESTCASE_TAG);
        g_LastTestCase = NULL;
        Status = STATUS_SUCCESS;
    }

    ExReleaseFastMutex(&FastMutex);

    return Status;
}
```

`Driver/IoStoreTestCase.h`:

```h
#pragma once

#include "Common.h"
#include "Driver.h"

#define CFB_TESTCASE_TAG 'CFBT'
#define CFB_MAX_TESTCASE_SIZE 4096

NTSTATUS InitializeTestCaseStructures();
NTSTATUS HandleIoStoreTestCase(PIRP Irp, PIO_STACK_LOCATION Stack);
NTSTATUS ReleaseTestCaseStructures();

```

`Driver/IoctlCodes.h`:

```h
#pragma once

#define IOCTL_AddDriver				CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_RemoveDriver			CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GetNumberOfDrivers	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GetNamesOfDrivers		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GetDriverInfo			CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SetEventPointer       CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EnableMonitoring		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DisableMonitoring		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_StoreTestCase 		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EnableDriver	 		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DisableDriver	 		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80b, METHOD_BUFFERED, FILE_ANY_ACCESS)


```

`Driver/Queue.c`:

```c
#include "Queue.h"


//static KSPIN_LOCK IrpQueueSpinLock;
//static KLOCK_QUEUE_HANDLE IrpQueueSpinLockQueue;
//static FAST_MUTEX FlushQueueMutex;
static FAST_MUTEX QueueMutex;
static LIST_ENTRY InterceptedIrpHead;
LIST_ENTRY* g_InterceptedIrpHead = &InterceptedIrpHead;
UINT32 InterceptedIrpListSize;



/*++

Initialize the structure of the queue.

--*/
void InitializeQueueStructures()
{
	//KeInitializeSpinLock(&IrpQueueSpinLock);
	//ExInitializeFastMutex(&FlushQueueMutex);
	ExInitializeFastMutex(&QueueMutex);
	InitializeListHead(g_InterceptedIrpHead); 
	InterceptedIrpListSize = 0;
	return;
}


/*++

Return the current number of IRP data stored in memory.

--*/
UINT32 GetIrpListSize()
{
	return InterceptedIrpListSize;
}


/*++

Push a new item at the end of the queue.

--*/
NTSTATUS PushToQueue(_In_ PINTERCEPTED_IRP pData)
{
	NTSTATUS Status;

	ExAcquireFastMutex(&QueueMutex);

	if (InterceptedIrpListSize < CFB_QUEUE_SIZE)
	{
		InsertTailList(g_InterceptedIrpHead, &(pData->ListEntry));
		InterceptedIrpListSize++;
		Status = STATUS_SUCCESS;
	}
	else
	{
		Status = STATUS_INSUFFICIENT_RESOURCES;
	}

	ExReleaseFastMutex(&QueueMutex);

	return Status;
}


/*++

Peek into the first item of the hooked driver linked list (if any), to determine the 
total size of the intercepted IRP (header + body).

--*/
NTSTATUS PeekHeadEntryExpectedSize(OUT PUINT32 pdwExpectedSize)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
    
	ExAcquireFastMutex(&QueueMutex);

	if (IsListEmpty(g_InterceptedIrpHead))
	{
		*pdwExpectedSize = 0;
		Status = STATUS_NO_MORE_ENTRIES;
	}
	else
	{
		PINTERCEPTED_IRP pFirstIrp = CONTAINING_RECORD(g_InterceptedIrpHead->Flink, INTERCEPTED_IRP, ListEntry);
		*pdwExpectedSize = sizeof(INTERCEPTED_IRP_HEADER) + \
			pFirstIrp->Header->InputBufferLength + \
			pFirstIrp->Header->OutputBufferLength;
		Status = STATUS_SUCCESS;
	}

	ExReleaseFastMutex(&QueueMutex);
    
	return Status;
}


/*++

Pops the heading item out of the queue.

--*/
NTSTATUS PopFromQueue(OUT PINTERCEPTED_IRP *pData)
{
	NTSTATUS Status;

	ExAcquireFastMutex(&QueueMutex);

	if (!IsListEmpty(g_InterceptedIrpHead))
	{
		PLIST_ENTRY pListHead = RemoveHeadList(g_InterceptedIrpHead);
		*pData = CONTAINING_RECORD(pListHead, INTERCEPTED_IRP, ListEntry);
		InterceptedIrpListSize--;
		Status = STATUS_SUCCESS;
	}
	else
	{
		*pData = NULL;
		Status = STATUS_NO_MORE_ENTRIES;
	}

	ExReleaseFastMutex(&QueueMutex);

	return Status;
}


/*++

Empty the entire queue.

--*/
NTSTATUS FlushQueue()
{
	NTSTATUS Status = STATUS_SUCCESS; 

	ExAcquireFastMutex(&QueueMutex);

	while (!IsListEmpty(g_InterceptedIrpHead))
	{
		PINTERCEPTED_IRP pIrp;

		Status = PopFromQueue(&pIrp);
		if (!NT_SUCCESS(Status))
		{
			if (Status == STATUS_NO_MORE_ENTRIES)
			{
				Status = STATUS_SUCCESS;
				break;
			}

			CfbDbgPrintErr(L"An error occured : status=0x%x\n", Status);
		}
        else
        {
            FreeInterceptedIrp(pIrp);
        }
	}

	ExReleaseFastMutex(&QueueMutex);
	
	CfbDbgPrintOk( L"Message queue flushed...\n" );

	return STATUS_SUCCESS;
}

```

`Driver/Queue.h`:

```h
#pragma once

#include "Common.h"
#include "../Common/common.h"
#include "Utils.h"
#include "InterceptedIrpHandler.h"


#define CFB_QUEUE_SIZE 8192


void InitializeQueueStructures();

NTSTATUS PushToQueue(_In_ PINTERCEPTED_IRP pData);
NTSTATUS PopFromQueue(OUT PINTERCEPTED_IRP *pData);
NTSTATUS FlushQueue();
NTSTATUS PeekHeadEntryExpectedSize(OUT PUINT32 pdwExpectedSize);
UINT32 GetIrpListSize();
```

`Driver/Utils.c`:

```c
#include "Utils.h"

#define CFB_DRIVER_LOG_BUFSIZE 4096

static PWCHAR g_LogBuffer = NULL;
static FAST_MUTEX g_LogMutex;


VOID CfbDbgLogInit()
{
	if (!g_LogBuffer)
	{
		g_LogBuffer = (PWCHAR)ExAllocatePoolWithTag(NonPagedPool, CFB_DRIVER_LOG_BUFSIZE, CFB_DEVICE_TAG);
		if (!g_LogBuffer)
			return;
		ExInitializeFastMutex(&g_LogMutex);
	}
}


VOID CfbDbgLogFree()
{
	if (g_LogBuffer)
	{
		ExFreePoolWithTag(g_LogBuffer, CFB_DEVICE_TAG);
	}
}


/*++
Routine Description:

The logging function for the driver. This function displays the message only if in DEBUG mode.


Arguments:

	- lpFormatString is a format string of the message to print

	- ...args are the arguments to the format string


Return Value:

	Does not return any value.

--*/
VOID CfbDbgPrint(IN const WCHAR* lpFormatString, ...)
{

#ifdef _DEBUG
	va_list args;

	ExAcquireFastMutex(&g_LogMutex);
	RtlZeroMemory(g_LogBuffer, CFB_DRIVER_LOG_BUFSIZE);

	va_start(args, lpFormatString);
	vswprintf_s(g_LogBuffer, CFB_DRIVER_LOG_BUFSIZE / sizeof(WCHAR), lpFormatString, args);
	va_end(args);

	KdPrint(("[%S] %S", CFB_PROGRAM_NAME_SHORT, g_LogBuffer));
	ExReleaseFastMutex(&g_LogMutex);

#else
	UNREFERENCED_PARAMETER( lpFormatString );
#endif
}


/*++

Routine Description:

A simple hexdumping function.


Arguments:

	- Buffer is a pointer to the address to hexdump

	- Length is the size (in bytes) of Buffer


Return Value:

	Does not return any value.

--*/
VOID CfbHexDump(IN PUCHAR Buffer, IN ULONG Length)
{
#ifdef _DEBUG
	for (ULONG i = 0; i < Length; i++)
	{
		if(i%16==0 && i)	KdPrint(("\n"));
		KdPrint(("%02x ", (UCHAR)Buffer[i]));
	}
	KdPrint(("\n"));
#else
	UNREFERENCED_PARAMETER( Buffer );
	UNREFERENCED_PARAMETER( Length );
#endif
}


/*++

Routine Description:

A convenience function to quickly retrieve the name of a device directly from the device object.


Arguments:

	- pDeviceObject is a pointer to the device object
	 
	- DeviceNameBuffer is a pointer to wide buffer to store the device object name

	- DeviceNameBufferSize is the size (in bytes) of DeviceNameBuffer


Return Value:

	Returns STATUS_SUCCESS on success.

--*/
NTSTATUS GetDeviceNameFromDeviceObject( _In_ PVOID pDeviceObject, _Out_ WCHAR* DeviceNameBuffer, _In_ ULONG DeviceNameBufferSize )
{
	NTSTATUS Status;
	UCHAR Buffer[0x400] = { 0, };
	ULONG ReturnLength;
	POBJECT_NAME_INFORMATION pDeviceNameInfo = (POBJECT_NAME_INFORMATION)Buffer;

	Status = ObQueryNameString(
        pDeviceObject,
        pDeviceNameInfo,
        sizeof( Buffer ),
        &ReturnLength
	);

	if ( !NT_SUCCESS( Status ) )
		return Status;

	if ( DeviceNameBufferSize < (ULONG)(2*(pDeviceNameInfo->Name.Length+1)) )
		return STATUS_BUFFER_TOO_SMALL;

	RtlSecureZeroMemory( DeviceNameBuffer, DeviceNameBufferSize );
	RtlCopyMemory( DeviceNameBuffer, pDeviceNameInfo->Name.Buffer, pDeviceNameInfo->Name.Length );
	return STATUS_SUCCESS;
}



/*++

Routine Description:

A convenience function to the name as a UNICODE_STRING from its PID.


Arguments:

	- Pid is the process ID

	- StrDst is a pointer to the UNICODE_STRING receiving the result if successful

Return Value:

	Returns STATUS_SUCCESS on success.

--*/
NTSTATUS GetProcessNameFromPid(IN UINT32 Pid, OUT PUNICODE_STRING *StrDst)
{
	PEPROCESS Process;
	
	if (NT_SUCCESS(PsLookupProcessByProcessId(UlongToHandle(Pid), &Process)))
	{
		PSTR lpProcessName = PsGetProcessImageFileName(Process);
		if (lpProcessName)
		{
			CANSI_STRING as = { 0, };
			if (NT_SUCCESS(RtlInitAnsiStringEx(&as, lpProcessName)))
				return RtlAnsiStringToUnicodeString(*StrDst, &as, TRUE);
		}
	}

	return STATUS_UNSUCCESSFUL;
}
```

`Driver/Utils.h`:

```h
#include "Common.h"

#include <stdio.h>
#include <wchar.h>
#include <stdarg.h>

#include "../common/Common.h"

#pragma once

#define WIDEN2(x) L ## x
#define WIDEN(x) WIDEN2(x)
#define __WFILE__ WIDEN(__FILE__)
#define __WFUNCTION__ WIDEN(__FUNCTION__)

VOID CfbDbgLogInit();
VOID CfbDbgLogFree();
VOID CfbDbgPrint( IN const WCHAR* lpFormatString, ... );
VOID CfbHexDump( IN PUCHAR Buffer, IN ULONG Length );

#define CfbDbgPrintOk(fmt, ...)			CfbDbgPrint(L"[+] " __WFILE__ L":" __WFUNCTION__ L"() " fmt,  __VA_ARGS__)
#define CfbDbgPrintInfo(fmt, ...)		CfbDbgPrint(L"[*] " __WFILE__ L":" __WFUNCTION__ L"() " fmt,  __VA_ARGS__)
#define CfbDbgPrintErr(fmt, ...)		CfbDbgPrint(L"[-] " __WFILE__ L":" __WFUNCTION__ L"() " fmt,  __VA_ARGS__)
#define CfbDbgPrintWarn(fmt, ...)		CfbDbgPrint(L"[!] " __WFILE__ L":" __WFUNCTION__ L"() " fmt,  __VA_ARGS__)
#define CfbAssertIrqlMinLevel(Irql)		NT_ASSERT( KeGetCurrentIrql() > Irql )

extern NTKERNELAPI PSTR PsGetProcessImageFileName(IN PEPROCESS Process);

NTSTATUS GetDeviceNameFromDeviceObject( _In_ PVOID pDeviceObject, _Out_ WCHAR* DeviceNameBuffer, _In_ ULONG DeviceNameBufferSize );
NTSTATUS GetProcessNameFromPid(IN UINT32 Pid, OUT PUNICODE_STRING *StrDst);
```

`GUI/App.xaml`:

```xaml
<Application
    x:Class="GUI.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI">

</Application>

```

`GUI/App.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.ApplicationModel;
using Windows.ApplicationModel.Activation;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;
using System.Collections.ObjectModel;
using Windows.ApplicationModel.Background;

using GUI.ViewModels;
using GUI.Models;
using GUI.Repositories;
using GUI.Views;
using Windows.Storage;
using Windows.UI.Core;
using System.Diagnostics;

namespace GUI
{
    /// <summary>
    /// Provides application-specific behavior to supplement the default Application class.
    /// </summary>
    sealed partial class App : Application
    {
        /// <summary>
        /// Initializes the singleton application object.  This is the first line of authored code
        /// executed, and as such is the logical equivalent of main() or WinMain().
        /// </summary>
        public App()
        {
            this.InitializeComponent();
            this.Suspending += OnSuspending;
        }

        /// <summary>
        /// Invoked when the application is launched normally by the end user.  Other entry points
        /// will be used such as when the application is launched to open a specific file.
        /// </summary>
        /// <param name="e">Details about the launch request and process.</param>
        protected override void OnLaunched(LaunchActivatedEventArgs e)
        {
            
            AppShell shell = Window.Current.Content as AppShell ?? new AppShell();
            Window.Current.Content = shell;

            if (shell.AppFrame.Content == null)
            {
                Type defaultPage;

                try
                {
                    var localSettings = ApplicationData.Current.LocalSettings;
                    var homePageIndex = localSettings.Values["HomePage"] != null ? (int)localSettings.Values["HomePage"] : 0;
                    var defaultPageName = App.HomePageList[homePageIndex];
                    defaultPage = Type.GetType($"GUI.Views.{defaultPageName}");
                }
                catch (Exception)
                {
                    defaultPage = Type.GetType($"GUI.Views.{nameof(MonitoredIrpsPage)}");
                }

                // On launch the app frame content will be empty,
                // so redirect to the default page (monitored irps)
                shell.AppFrame.Navigate(
                    defaultPage,
                    null,
                    new Windows.UI.Xaml.Media.Animation.SuppressNavigationTransitionInfo()
                );
            }

            Window.Current.Activate();

            Window.Current.CoreWindow.PointerPressed += CoreWindow_PointerPressed;
        }

        /// <summary>
        /// Invoked when Navigation to a certain page fails
        /// </summary>
        /// <param name="sender">The Frame which failed navigation</param>
        /// <param name="e">Details about the navigation failure</param>
        void OnNavigationFailed(object sender, NavigationFailedEventArgs e)
        {
            throw new Exception("Failed to load Page " + e.SourcePageType.FullName);
        }

        /// <summary>
        /// Invoked when application execution is being suspended.  Application state is saved
        /// without knowing whether the application will be terminated or resumed with the contents
        /// of memory still intact.
        /// </summary>
        /// <param name="sender">The source of the suspend request.</param>
        /// <param name="e">Details about the suspend request.</param>
        private void OnSuspending(object sender, SuspendingEventArgs e)
        {
            var deferral = e.SuspendingOperation.GetDeferral();
            //TODO: Save application state and stop any background activity
            deferral.Complete();
        }




        /// <summary>
        /// Static reference to the IRP list view model (main model)
        /// </summary>
        public static MonitoredIrpsViewModel ViewModel { get; } = new MonitoredIrpsViewModel();

        public static IAsyncDriverRepository Drivers { get; private set; } = new DriverRepository();

        public static IAsyncIrpRepository Irps { get; private set; } = new IrpRepository();

        public static ConnectionManager BrokerSession { get; private set; } = new ConnectionManager();

        public static IrpDumper DumperTask = new IrpDumper();


        public static readonly ObservableCollection<string> HomePageList = new ObservableCollection<string>()
        {
            nameof(MonitoredIrpsPage),
            nameof(SessionInfoPage),
            nameof(DriverListPage),
            nameof(SettingsPage),
            nameof(AboutPage)
        };


        /// <summary>
        /// Used for the In-Process background task
        /// https://docs.microsoft.com/en-us/windows/uwp/launch-resume/create-and-register-an-inproc-background-task
        /// </summary>
        /// <param name="args"></param>
        protected override void OnBackgroundActivated(BackgroundActivatedEventArgs args)
        {
            base.OnBackgroundActivated(args);
            IBackgroundTaskInstance taskInstance = args.TaskInstance;
            DumperTask.SetInstance(taskInstance);
        }


        /// <summary>
        /// Assign Back-Navigation mouse key to go back
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void CoreWindow_PointerPressed(CoreWindow sender, PointerEventArgs args)
        {
            if (args.CurrentPoint.Properties.IsXButton1Pressed)
            {
                var AppShell = Window.Current.Content as AppShell;
                if (AppShell == null)
                {
                    Debug.WriteLine("AppShell is null - should never be here");
                    return;
                }

                var AppFrame = AppShell.AppFrame; 
                if (AppFrame == null)
                {
                    Debug.WriteLine("AppFrame is null");
                    return;
                }
                
                if (AppFrame.CanGoBack)
                    AppFrame.GoBack();
            }
        }
    }
}

```

`GUI/AppShell.xaml`:

```xaml
<Page
    x:Class="GUI.AppShell"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:controls="using:Microsoft.Toolkit.Uwp.UI.Controls"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">


    <Page.BottomAppBar>
        <CommandBar>
            <CommandBar.Content>
                <TextBlock x:Name="CurrentStateInfoLbl"  Text="Disconnected" Margin="12,14"/>
            </CommandBar.Content>

            <AppBarSeparator/>

            <AppBarButton  
                x:Name="IsConnectedAppBarButton"
                Label="{x:Bind DisconnectedStatusLabel}" 
                ToolTipService.ToolTip="{x:Bind DisconnectedStatusLabel}"
                Click="ToggleConnectButton_Click">
                <AppBarButton.Icon>
                    <FontIcon x:Name="IsConnectedAppBarButtonFont" FontFamily="Segoe MDL2 Assets" Glyph="&#xE91F;" Foreground="Red" />
                </AppBarButton.Icon>
            </AppBarButton>

            <AppBarSeparator/>
            
            <AppBarButton Icon="Play" 
                          x:Name="StartMonitoringLabelBtn"
                          Label="{x:Bind StartMonitoringLabel}" 
                          ToolTipService.ToolTip="{x:Bind StartMonitoringLabel}"
                          Click="StartMonitoring_Click"
                          IsEnabled="True"
                          />
            
            <AppBarButton Icon="Stop" 
                          x:Name="StopMonitoringLabelBtn"
                          Label="{x:Bind StopMonitoringLabel}" 
                          ToolTipService.ToolTip="{x:Bind StopMonitoringLabel}"
                          Click="StopMonitoring_Click"
                          IsEnabled="False"
                          />
            
            <AppBarSeparator/>
            
            <AppBarButton Icon="Clear" 
                          x:Name="ClearGridLabelBtn"
                          Click="ClearGridLabelBtn_Click"
                          Label="{x:Bind ClearGridLabel}"
                          ToolTipService.ToolTip="{x:Bind ClearGridLabel}" />
        </CommandBar>
    </Page.BottomAppBar>


    <Grid x:Name="LayoutRoot" Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

        <NavigationView
            x:Name="NavView"
            OpenPaneLength="200"
            AlwaysShowHeader="False"
            IsSettingsVisible="True"
            IsPaneOpen = "False"
            ItemInvoked="NavView_OnItemTapped"
            BackRequested="NavView_BackRequested">

            <NavigationView.MenuItems>

                <NavigationViewItem
                    x:Name="SessionInfoMenuItem"
                    Content="{x:Bind SessionInfoLabel}"
                    ToolTipService.ToolTip="{x:Bind SessionInfoLabel}">
                    <NavigationViewItem.Icon>
                        <SymbolIcon Symbol="Home"/>
                    </NavigationViewItem.Icon>
                </NavigationViewItem>
                
                <NavigationViewItem
                    x:Name="MonitoredIrpsMenuItem"
                    Content="{x:Bind MonitoredIrpsListLabel}"
                    ToolTipService.ToolTip="{x:Bind MonitoredIrpsListLabel}">
                    <NavigationViewItem.Icon>
                        <FontIcon FontFamily="Segoe MDL2 Assets" Glyph="&#xE943;"/>
                    </NavigationViewItem.Icon>
                </NavigationViewItem>

                <NavigationViewItem
                    x:Name="OpenIrpDbMenuItem"
                    Content="{x:Bind OpenIrpDbLabel}"
                    ToolTipService.ToolTip="Open and load a previously saved database">
                    <NavigationViewItem.Icon>
                        <SymbolIcon Symbol="OpenFile"/>
                    </NavigationViewItem.Icon>
                </NavigationViewItem>

                <NavigationViewItem
                    x:Name="SaveIrpDbMenuItem"
                    Content="{x:Bind SaveIrpDbLabel}"
                    ToolTipService.ToolTip="Save all the IRPs to a local file that can be loaded later.">
                    <NavigationViewItem.Icon>
                        <SymbolIcon Symbol="SaveLocal"/>
                    </NavigationViewItem.Icon>
                </NavigationViewItem>

                <NavigationViewItem
                    x:Name="AddRemoveDriversMenuItem"
                    Content="{x:Bind ManageDriversLabel}"
                    ToolTipService.ToolTip="{x:Bind ManageDriversLabel}">
                    <NavigationViewItem.Icon>
                        <SymbolIcon Symbol="NewFolder"/>
                    </NavigationViewItem.Icon>
                </NavigationViewItem>

                <NavigationViewItem
                    x:Name="ReplayIrpMenuItem"
                    Content="{x:Bind ReplayIrpLabel}"
                    ToolTipService.ToolTip="{x:Bind ReplayIrpLabel}">
                    <NavigationViewItem.Icon>
                        <SymbolIcon Symbol="Next"/>
                    </NavigationViewItem.Icon>
                </NavigationViewItem>


                <NavigationViewItem
                        x:Name="AboutMenuItem"
                        Content="{x:Bind AboutLabel}" 
                        ToolTipService.ToolTip="{x:Bind AboutLabel}"
                        Icon="Account" />
                
            </NavigationView.MenuItems>

            <NavigationView.PaneFooter>
                <StackPanel>
                    <NavigationViewItem
                        Content="Report Bug"
                        ToolTipService.ToolTip="Go to CFB issues page to report a bug"
                        Tapped="ReportBug_Tapped">
                        <NavigationViewItem.Icon>
                            <FontIcon FontFamily="Segoe MDL2 Assets" Glyph="&#xE91c;"/>
                        </NavigationViewItem.Icon>
                    </NavigationViewItem>

                </StackPanel>
                </NavigationView.PaneFooter>

            <Frame
                x:Name="frame"
                Margin="20,0,0,0"
                Navigating="OnNavigatingToPage">
                    <Frame.ContentTransitions>
                        <TransitionCollection>
                            <NavigationThemeTransition>
                                <NavigationThemeTransition.DefaultNavigationTransitionInfo>
                                    <EntranceNavigationTransitionInfo />
                                </NavigationThemeTransition.DefaultNavigationTransitionInfo>
                            </NavigationThemeTransition>
                        </TransitionCollection>
                    </Frame.ContentTransitions>
                </Frame>

            </NavigationView>
        </Grid>
</Page>

```

`GUI/AppShell.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;
using Windows.System;
using System.Threading.Tasks;

using GUI.Models;
using Windows.Storage;
using Windows.UI.Popups;
using GUI.Helpers;
using GUI.Views;

namespace GUI
{

    public sealed partial class AppShell : Page
    {
        public readonly string MonitoredIrpsListLabel      = "Monitored IRPs";
        public readonly string OpenIrpDbLabel              = "Load IRPs from file";
        public readonly string SaveIrpDbLabel              = "Save IRPs to file";
        public readonly string ManageDriversLabel          = "Add/remove drivers";
        public readonly string SessionInfoLabel            = "Show session info";
        public readonly string ReplayIrpLabel              = "Forge IRP";
        public readonly string AboutLabel                  = "About CFB";

        public readonly string StartMonitoringLabel        = "Start Monitoring IRPs";
        public readonly string StopMonitoringLabel         = "Stop Monitoring IRPs";
        public readonly string ClearGridLabel              = "Clear all intercepted IRPs";

        public readonly string ConnectedStatusLabel        = "Connected, click to disconnect...";
        public readonly string DisconnectedStatusLabel     = "Disconnected, click to connect...";

        public readonly string GlobalState_Connected       = "Connected";
        public readonly string GlobalState_Disconnected    = "Disconnected";
        public readonly string GlobalState_Capturing       = "Capturing...";


        public Frame AppFrame => frame;

        public AppShell()
        {
            this.InitializeComponent();
        }


        /// <summary>
        /// The AppShell NavigationView "on tap" dispatcher
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void NavView_OnItemTapped(NavigationView sender, NavigationViewItemInvokedEventArgs args)
        {
            var label = args.InvokedItem as string;

            var localSettings = ApplicationData.Current.LocalSettings;
            var homePageIndex = localSettings.Values["HomePage"] != null ? (int)localSettings.Values["HomePage"] : 0;
            var defaultPageName = App.HomePageList[homePageIndex];
            var defaultPage = Type.GetType(defaultPageName);
            var targetPage = defaultPage;

            if (args.IsSettingsInvoked)
            {
                targetPage = typeof(Views.SettingsPage);
            }
            else
            {

                if (label == MonitoredIrpsListLabel)
                    targetPage = typeof(Views.MonitoredIrpsPage);

                else if (label == AboutLabel)
                    targetPage = typeof(Views.AboutPage);

                else if (label == OpenIrpDbLabel)
                    targetPage = typeof(Views.LoadIrpsFromFilePage);

                else if (label == SaveIrpDbLabel)
                    targetPage = typeof(Views.SaveIrpsToFilePage);

                else if (label == ManageDriversLabel)
                    targetPage = typeof(Views.DriverListPage);

                else if (label == SessionInfoLabel)
                    targetPage = typeof(Views.SessionInfoPage);

                else if (label == ReplayIrpLabel)
                    targetPage = typeof(Views.ReplayIrpPage);

                //
                // TODO: Add other pages
                //
            }

            NavView.IsPaneOpen = false;
            NavView.IsBackEnabled = AppFrame.CanGoBack;
            AppFrame.Navigate(targetPage);
        }


        /// <summary>
        /// When navigating to a new page in the root frame, keep track of the previous page
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnNavigatingToPage(object sender, NavigatingCancelEventArgs e)
        {
            if (e.NavigationMode == NavigationMode.Back)
            {
                if (e.SourcePageType == typeof(Views.SettingsPage))
                    NavView.SelectedItem = NavView.SettingsItem;

                else if (e.SourcePageType == typeof(Views.MonitoredIrpsPage))
                    NavView.SelectedItem = MonitoredIrpsMenuItem;

                else if (e.SourcePageType == typeof(Views.AboutPage))
                    NavView.SelectedItem = AboutMenuItem;

                else if (e.SourcePageType == typeof(Views.LoadIrpsFromFilePage))
                    NavView.SelectedItem = OpenIrpDbMenuItem;

                else if (e.SourcePageType == typeof(Views.SaveIrpsToFilePage))
                    NavView.SelectedItem = SaveIrpDbMenuItem;

                else if (e.SourcePageType == typeof(Views.DriverListPage))
                    NavView.SelectedItem = AddRemoveDriversMenuItem;

                else if (e.SourcePageType == typeof(Views.SessionInfoPage))
                    NavView.SelectedItem = SessionInfoMenuItem;

                else if (e.SourcePageType == typeof(Views.ReplayIrpPage))
                    NavView.SelectedItem = ReplayIrpMenuItem;

                //
                // TODO add other pages
                //
            }

            NavView.IsBackEnabled = AppFrame.CanGoBack;
        }
        

        /// <summary>
        /// Open the browser page to report a bug
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private async void ReportBug_Tapped(object sender, TappedRoutedEventArgs e) =>
            await Launcher.LaunchUriAsync(new Uri(Constants.ProjectIssueUrl));


        /// <summary>
        /// Returns to the previous page if possible
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void NavView_BackRequested(NavigationView sender, NavigationViewBackRequestedEventArgs args)
        {
            if (AppFrame.CanGoBack)
            {
                AppFrame.GoBack();
            }
        }

        public void UpdateGlobalState(string message)
        {
            CurrentStateInfoLbl.Text = message;
        }


        private async void ToggleConnectButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (!App.BrokerSession.IsConnected)
                    TryConnect();
                else
                    TryDisconnect();
            }
            catch (Exception ex)
            {
                var brokerPathSetting = ApplicationData.Current.LocalSettings.Values["IrpBrokerLocation"].ToString();
                var dialog = new MessageDialog($"An error occured while trying to open/close connection with '{brokerPathSetting}'. " +
                    $"Reason:\n{ex.Message}", 
                    "Connection error"
                );
                await dialog.ShowAsync();
            }
        }      

        private async void TryConnect()
        {
            UpdateGlobalState("Connecting...");
            try
            {
                var t = await App.BrokerSession.Reconnect();
                if (t && App.BrokerSession.IsConnected)
                {
                    App.DumperTask.Trigger();
                    App.DumperTask.Enabled = true;

                    IsConnectedAppBarButtonFont.Foreground = new SolidColorBrush(Windows.UI.Colors.Green);
                    IsConnectedAppBarButton.Label = ConnectedStatusLabel;
                    UpdateGlobalState(GlobalState_Connected);
                }
            }
            catch(Exception e)
            {
                UpdateGlobalState($"Failed to connect: {e.Message}");
            }
        }


        private async void TryDisconnect()
        {
            UpdateGlobalState("Disconnecting...");
            try
            {
                App.DumperTask.Enabled = false;

                await App.BrokerSession.Close();
                if (! App.BrokerSession.IsConnected)
                {
                    IsConnectedAppBarButtonFont.Foreground = new SolidColorBrush(Windows.UI.Colors.Red);
                    IsConnectedAppBarButton.Label = DisconnectedStatusLabel;
                    UpdateGlobalState(GlobalState_Disconnected);
                }
            }
            catch (Exception e)
            {
                UpdateGlobalState($"Failed to disconnect: {e.Message}");
            }
        }


        private async void StartMonitoring_Click(object sender, RoutedEventArgs e)
        {
            bool success = false;
            try
            {
                success = await Task.Run(App.BrokerSession.StartMonitoring);
                if (success)
                {
                    StartMonitoringLabelBtn.IsEnabled = false;
                    StopMonitoringLabelBtn.IsEnabled = true;
                    App.ViewModel.IsLoading = true;

                    UpdateGlobalState(GlobalState_Capturing);
                }
            }
            catch (Exception ex)
            {
                await Utils.ShowPopUp(
                    $"Unable to start monitoring, reason:\n {ex.Message}",
                    "StartMonitoring() Error!"
                );

                if(success)
                    await Task.Run(App.BrokerSession.StopMonitoring);
            }
        }


        private async void StopMonitoring_Click(object sender, RoutedEventArgs e)
        {
            bool success = false;
            try
            {
                success = await Task.Run(App.BrokerSession.StopMonitoring);
                if ( success )
                {
                    StartMonitoringLabelBtn.IsEnabled = true;
                    StopMonitoringLabelBtn.IsEnabled = false;
                    App.ViewModel.IsLoading = false;

                    UpdateGlobalState(GlobalState_Connected);
                }
            }
            catch (Exception ex)
            {
                await Utils.ShowPopUp(
                    $"Unable to stop monitoring, reason:\n {ex.Message}",
                    "StopMonitoring() Error!"
                );
            }
        }


        private void ClearGridLabelBtn_Click(object sender, RoutedEventArgs e)
        {
            App.Irps.Clear();
            App.ViewModel.Irps.Clear();
        }
    }
}

```

`GUI/GUI.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProjectGuid>{73B379CD-0298-415B-AC8E-FC6D4A6721AB}</ProjectGuid>
    <OutputType>AppContainerExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>GUI</RootNamespace>
    <AssemblyName>GUI</AssemblyName>
    <DefaultLanguage>en-US</DefaultLanguage>
    <TargetPlatformIdentifier>UAP</TargetPlatformIdentifier>
    <TargetPlatformVersion Condition=" '$(TargetPlatformVersion)' == '' ">10.0.18362.0</TargetPlatformVersion>
    <TargetPlatformMinVersion>10.0.18362.0</TargetPlatformMinVersion>
    <MinimumVisualStudioVersion>14</MinimumVisualStudioVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{A5A43C5B-DE2A-4C0C-9213-0A381AF9435A};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WindowsXamlEnableOverview>true</WindowsXamlEnableOverview>
    <AppxPackageSigningEnabled>True</AppxPackageSigningEnabled>
    <GenerateAppInstallerFile>False</GenerateAppInstallerFile>
    <AppxPackageSigningTimestampDigestAlgorithm>SHA256</AppxPackageSigningTimestampDigestAlgorithm>
    <AppxAutoIncrementPackageRevision>False</AppxAutoIncrementPackageRevision>
    <GenerateTestArtifacts>True</GenerateTestArtifacts>
    <AppxBundle>Always</AppxBundle>
    <AppxBundlePlatforms>x64</AppxBundlePlatforms>
    <HoursBetweenUpdateChecks>0</HoursBetweenUpdateChecks>
    <PackageCertificateKeyFile>D:\Code\CFB\GUI\GUI_TemporaryKey.pfx</PackageCertificateKeyFile>
    <PackageCertificateThumbprint>5E0EEC9CE69267064D02197F6E77A195658DEFD7</PackageCertificateThumbprint>
    <AppxSymbolPackageEnabled>False</AppxSymbolPackageEnabled>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE;NETFX_CORE;WINDOWS_UWP</DefineConstants>
    <NoWarn>;2008</NoWarn>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE;NETFX_CORE;WINDOWS_UWP</DefineConstants>
    <Optimize>true</Optimize>
    <NoWarn>;2008</NoWarn>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
    <UseDotNetNativeToolchain>true</UseDotNetNativeToolchain>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|ARM'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\ARM\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE;NETFX_CORE;WINDOWS_UWP</DefineConstants>
    <NoWarn>;2008</NoWarn>
    <DebugType>full</DebugType>
    <PlatformTarget>ARM</PlatformTarget>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|ARM'">
    <OutputPath>bin\ARM\Release\</OutputPath>
    <DefineConstants>TRACE;NETFX_CORE;WINDOWS_UWP</DefineConstants>
    <Optimize>true</Optimize>
    <NoWarn>;2008</NoWarn>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>ARM</PlatformTarget>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
    <UseDotNetNativeToolchain>true</UseDotNetNativeToolchain>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|ARM64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\ARM64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE;NETFX_CORE;WINDOWS_UWP</DefineConstants>
    <NoWarn>;2008</NoWarn>
    <DebugType>full</DebugType>
    <PlatformTarget>ARM64</PlatformTarget>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
    <UseDotNetNativeToolchain>true</UseDotNetNativeToolchain>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|ARM64'">
    <OutputPath>bin\ARM64\Release\</OutputPath>
    <DefineConstants>TRACE;NETFX_CORE;WINDOWS_UWP</DefineConstants>
    <Optimize>true</Optimize>
    <NoWarn>;2008</NoWarn>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>ARM64</PlatformTarget>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
    <UseDotNetNativeToolchain>true</UseDotNetNativeToolchain>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE;NETFX_CORE;WINDOWS_UWP</DefineConstants>
    <NoWarn>;2008</NoWarn>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE;NETFX_CORE;WINDOWS_UWP</DefineConstants>
    <Optimize>true</Optimize>
    <NoWarn>;2008</NoWarn>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
    <UseDotNetNativeToolchain>true</UseDotNetNativeToolchain>
  </PropertyGroup>
  <PropertyGroup>
    <RestoreProjectStyle>PackageReference</RestoreProjectStyle>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
    </Compile>
    <Compile Include="AppShell.xaml.cs">
      <DependentUpon>AppShell.xaml</DependentUpon>
    </Compile>
    <Compile Include="Helpers\Constants.cs" />
    <Compile Include="Helpers\Utils.cs" />
    <Compile Include="Models\BrokerMessage.cs" />
    <Compile Include="Models\ConnectionManager.cs" />
    <Compile Include="Models\Constants.cs" />
    <Compile Include="Models\Device.cs" />
    <Compile Include="Models\Driver.cs" />
    <Compile Include="Models\IrpDumper.cs" />
    <Compile Include="Repositories\DriverRepository.cs" />
    <Compile Include="Repositories\IAsyncDriverRepository.cs" />
    <Compile Include="Repositories\IAsyncIrpRepository.cs" />
    <Compile Include="Models\Irp.cs" />
    <Compile Include="Helpers\ErrorCodes.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Repositories\IrpRepository.cs" />
    <Compile Include="UserControls\CollapsibleSearchBox.xaml.cs">
      <DependentUpon>CollapsibleSearchBox.xaml</DependentUpon>
    </Compile>
    <Compile Include="ViewModels\BindableBase.cs" />
    <Compile Include="ViewModels\BrokerConnectionViewModel.cs" />
    <Compile Include="ViewModels\Converters.cs" />
    <Compile Include="Helpers\Exceptions.cs" />
    <Compile Include="ViewModels\DriverViewModel.cs" />
    <Compile Include="ViewModels\IrpReplayViewModel.cs" />
    <Compile Include="ViewModels\IrpViewModel.cs" />
    <Compile Include="ViewModels\MonitoredIrpsViewModel.cs" />
    <Compile Include="ViewModels\SaveLoadIrpsViewModel.cs" />
    <Compile Include="ViewModels\SessionInfoViewModel.cs" />
    <Compile Include="Views\AboutPage.xaml.cs">
      <DependentUpon>AboutPage.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\DataGridHelper.cs" />
    <Compile Include="Views\DriverListPage.xaml.cs">
      <DependentUpon>DriverListPage.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\IrpInfoPage.xaml.cs">
      <DependentUpon>IrpInfoPage.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\LoadIrpsFromFilePage.xaml.cs">
      <DependentUpon>LoadIrpsFromFilePage.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\MonitoredIrpsPage.xaml.cs">
      <DependentUpon>MonitoredIrpsPage.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\ReplayIrpPage.xaml.cs">
      <DependentUpon>ReplayIrpPage.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\SaveIrpsToFilePage.xaml.cs">
      <DependentUpon>SaveIrpsToFilePage.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\SessionInfoPage.xaml.cs">
      <DependentUpon>SessionInfoPage.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\SettingsPage.xaml.cs">
      <DependentUpon>SettingsPage.xaml</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <AppxManifest Include="Package.appxmanifest">
      <SubType>Designer</SubType>
    </AppxManifest>
  </ItemGroup>
  <ItemGroup>
    <Content Include="Assets\BadgeLogo.scale-100.png" />
    <Content Include="Assets\BadgeLogo.scale-125.png" />
    <Content Include="Assets\BadgeLogo.scale-150.png" />
    <Content Include="Assets\BadgeLogo.scale-200.png" />
    <Content Include="Assets\BadgeLogo.scale-400.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-lightunplated_targetsize-16.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-lightunplated_targetsize-24.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-lightunplated_targetsize-256.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-lightunplated_targetsize-32.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-lightunplated_targetsize-48.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-unplated_targetsize-16.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-unplated_targetsize-24.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-unplated_targetsize-256.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-unplated_targetsize-32.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.altform-unplated_targetsize-48.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.scale-100.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.scale-125.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.scale-150.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.scale-200.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.scale-400.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.targetsize-16.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.targetsize-24.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.targetsize-256.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.targetsize-32.png" />
    <Content Include="Assets\FuriousBeaver_AppIcon.targetsize-48.png" />
    <Content Include="Assets\FuriousBeaver_SplashScreen.scale-100.png" />
    <Content Include="Assets\FuriousBeaver_SplashScreen.scale-125.png" />
    <Content Include="Assets\FuriousBeaver_SplashScreen.scale-150.png" />
    <Content Include="Assets\FuriousBeaver_SplashScreen.scale-200.png" />
    <Content Include="Assets\FuriousBeaver_SplashScreen.scale-400.png" />
    <Content Include="Assets\Square150x150Logo.scale-100.png" />
    <Content Include="Assets\Square150x150Logo.scale-125.png" />
    <Content Include="Assets\Square150x150Logo.scale-150.png" />
    <Content Include="Assets\Square150x150Logo.scale-200.png" />
    <Content Include="Assets\Square150x150Logo.scale-400.png" />
    <Content Include="Assets\StoreLogo.scale-100.png" />
    <Content Include="Assets\StoreLogo.scale-125.png" />
    <Content Include="Assets\StoreLogo.scale-150.png" />
    <Content Include="Assets\StoreLogo.scale-200.png" />
    <Content Include="Assets\StoreLogo.scale-400.png" />
    <Content Include="Properties\Default.rd.xml" />
    <Content Include="Assets\Wide310x150Logo.scale-200.png" />
    <Content Include="ScriptTemplates\CTemplate.txt" />
    <Content Include="ScriptTemplates\PowershellTemplate.txt" />
    <Content Include="ScriptTemplates\PythonTemplate.txt" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Page Include="AppShell.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="UserControls\CollapsibleSearchBox.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Compile Include="ViewModels\DriverListPageViewModel.cs">
      <Generator>MSBuild:Compile</Generator>
    </Compile>
    <Page Include="Views\AboutPage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\DriverListPage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\IrpInfoPage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\LoadIrpsFromFilePage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\MonitoredIrpsPage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\ReplayIrpPage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\SaveIrpsToFilePage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\SessionInfoPage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\SettingsPage.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Data.SQLite">
      <Version>3.1.5</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.Data.Sqlite.Core">
      <Version>3.1.5</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.NETCore.UniversalWindowsPlatform">
      <Version>6.2.10</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.Toolkit.Uwp">
      <Version>6.1.0</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.Toolkit.Uwp.UI.Controls">
      <Version>6.1.0</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.Toolkit.Uwp.UI.Controls.DataGrid">
      <Version>6.1.0</Version>
    </PackageReference>
    <PackageReference Include="Newtonsoft.Json">
      <Version>13.0.1</Version>
    </PackageReference>
    <PackageReference Include="System.Interactive.Async">
      <Version>4.1.1</Version>
    </PackageReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="GUI_TemporaryKey.pfx" />
  </ItemGroup>
  <PropertyGroup Condition=" '$(VisualStudioVersion)' == '' or '$(VisualStudioVersion)' &lt; '14.0' ">
    <VisualStudioVersion>14.0</VisualStudioVersion>
  </PropertyGroup>
  <Import Project="$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v$(VisualStudioVersion)\Microsoft.Windows.UI.Xaml.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`GUI/Helpers/Constants.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.Helpers
{
    #region ConstantsIoctl
    namespace Constants.Ioctl
    {
        /**
         *  from ntifs.h 
         *  #define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
         *      ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
         *  )
         */
        public enum FileDeviceType : uint
        {
            FILE_DEVICE_BEEP = 0x00000001,
            FILE_DEVICE_CD_ROM = 0x00000002,
            FILE_DEVICE_CD_ROM_FILE_SYSTEM = 0x00000003,
            FILE_DEVICE_CONTROLLER = 0x00000004,
            FILE_DEVICE_DATALINK = 0x00000005,
            FILE_DEVICE_DFS = 0x00000006,
            FILE_DEVICE_DISK = 0x00000007,
            FILE_DEVICE_DISK_FILE_SYSTEM = 0x00000008,
            FILE_DEVICE_FILE_SYSTEM = 0x00000009,
            FILE_DEVICE_INPORT_PORT = 0x0000000a,
            FILE_DEVICE_KEYBOARD = 0x0000000b,
            FILE_DEVICE_MAILSLOT = 0x0000000c,
            FILE_DEVICE_MIDI_IN = 0x0000000d,
            FILE_DEVICE_MIDI_OUT = 0x0000000e,
            FILE_DEVICE_MOUSE = 0x0000000f,
            FILE_DEVICE_MULTI_UNC_PROVIDER = 0x00000010,
            FILE_DEVICE_NAMED_PIPE = 0x00000011,
            FILE_DEVICE_NETWORK = 0x00000012,
            FILE_DEVICE_NETWORK_BROWSER = 0x00000013,
            FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x00000014,
            FILE_DEVICE_NULL = 0x00000015,
            FILE_DEVICE_PARALLEL_PORT = 0x00000016,
            FILE_DEVICE_PHYSICAL_NETCARD = 0x00000017,
            FILE_DEVICE_PRINTER = 0x00000018,
            FILE_DEVICE_SCANNER = 0x00000019,
            FILE_DEVICE_SERIAL_MOUSE_PORT = 0x0000001a,
            FILE_DEVICE_SERIAL_PORT = 0x0000001b,
            FILE_DEVICE_SCREEN = 0x0000001c,
            FILE_DEVICE_SOUND = 0x0000001d,
            FILE_DEVICE_STREAMS = 0x0000001e,
            FILE_DEVICE_TAPE = 0x0000001f,
            FILE_DEVICE_TAPE_FILE_SYSTEM = 0x00000020,
            FILE_DEVICE_TRANSPORT = 0x00000021,
            FILE_DEVICE_UNKNOWN = 0x00000022,
            FILE_DEVICE_VIDEO = 0x00000023,
            FILE_DEVICE_VIRTUAL_DISK = 0x00000024,
            FILE_DEVICE_WAVE_IN = 0x00000025,
            FILE_DEVICE_WAVE_OUT = 0x00000026,
            FILE_DEVICE_8042_PORT = 0x00000027,
            FILE_DEVICE_NETWORK_REDIRECTOR = 0x00000028,
            FILE_DEVICE_BATTERY = 0x00000029,
            FILE_DEVICE_BUS_EXTENDER = 0x0000002a,
            FILE_DEVICE_MODEM = 0x0000002b,
            FILE_DEVICE_VDM = 0x0000002c,
            FILE_DEVICE_MASS_STORAGE = 0x0000002d,
            FILE_DEVICE_SMB = 0x0000002e,
            FILE_DEVICE_KS = 0x0000002f,
            FILE_DEVICE_CHANGER = 0x00000030,
            FILE_DEVICE_SMARTCARD = 0x00000031,
            FILE_DEVICE_ACPI = 0x00000032,
            FILE_DEVICE_DVD = 0x00000033,
            FILE_DEVICE_FULLSCREEN_VIDEO = 0x00000034,
            FILE_DEVICE_DFS_FILE_SYSTEM = 0x00000035,
            FILE_DEVICE_DFS_VOLUME = 0x00000036,
            FILE_DEVICE_SERENUM = 0x00000037,
            FILE_DEVICE_TERMSRV = 0x00000038,
            FILE_DEVICE_KSEC = 0x00000039,
            FILE_DEVICE_FIPS = 0x0000003A,
            FILE_DEVICE_INFINIBAND = 0x0000003B,
            FILE_DEVICE_VMBUS = 0x0000003E,
            FILE_DEVICE_CRYPT_PROVIDER = 0x0000003F,
            FILE_DEVICE_WPD = 0x00000040,
            FILE_DEVICE_BLUETOOTH = 0x00000041,
            FILE_DEVICE_MT_COMPOSITE = 0x00000042,
            FILE_DEVICE_MT_TRANSPORT = 0x00000043,
            FILE_DEVICE_BIOMETRIC = 0x00000044,
            FILE_DEVICE_PMI = 0x00000045,
            FILE_DEVICE_EHSTOR = 0x00000046,
            FILE_DEVICE_DEVAPI = 0x00000047,
            FILE_DEVICE_GPIO = 0x00000048,
            FILE_DEVICE_USBEX = 0x00000049,
            FILE_DEVICE_CONSOLE = 0x00000050,
            FILE_DEVICE_NFP = 0x00000051,
            FILE_DEVICE_SYSENV = 0x00000052,
            FILE_DEVICE_VIRTUAL_BLOCK = 0x00000053,
            FILE_DEVICE_POINT_OF_SERVICE = 0x00000054,
            FILE_DEVICE_STORAGE_REPLICATION = 0x00000055,
            FILE_DEVICE_TRUST_ENV = 0x00000056,
            FILE_DEVICE_UCM = 0x00000057,
            FILE_DEVICE_UCMTCPCI = 0x00000058,
            FILE_DEVICE_PERSISTENT_MEMORY = 0x00000059,
            FILE_DEVICE_NVDIMM = 0x0000005a,
            FILE_DEVICE_HOLOGRAPHIC = 0x0000005b,
            FILE_DEVICE_SDFXHCI = 0x0000005c,
        }

        public enum AccessType : uint 
        {
            FILE_ANY_ACCESS = 0x0000,
            FILE_READ_ACCESS = 0x0001,
            FILE_WRITE_ACCESS = 0x0002,
        }

        public enum MethodType : uint
        {
            METHOD_BUFFERED = 0x0,
            METHOD_IN_DIRECT = 0x1,
            METHOD_OUT_DIRECT = 0x2,
            METHOD_NEITHER = 0x3,
        }

    }
    #endregion


}

```

`GUI/Helpers/ErrorCodes.cs`:

```cs
/**
 * 
 * Copy/paste of error header files (winerror.h & ntstatus.h)
 * SDK=win10 16.4.1
 * 
 */

namespace GUI.Helpers
{
    public enum Win32Error : uint
    {

        #region ntstatus.h codes
        STATUS_SUCCESS = 0x00000000,
        STATUS_ABANDONED = 0x00000080,
        STATUS_ABANDONED_WAIT_0 = 0x00000080,
        STATUS_ABANDONED_WAIT_63 = 0x000000BF,
        STATUS_USER_APC = 0x000000C0,
        STATUS_ALREADY_COMPLETE = 0x000000FF,
        STATUS_KERNEL_APC = 0x00000100,
        STATUS_ALERTED = 0x00000101,
        STATUS_TIMEOUT = 0x00000102,
        STATUS_PENDING = 0x00000103,
        STATUS_REPARSE = 0x00000104,
        STATUS_MORE_ENTRIES = 0x00000105,
        STATUS_NOT_ALL_ASSIGNED = 0x00000106,
        STATUS_SOME_NOT_MAPPED = 0x00000107,
        STATUS_OPLOCK_BREAK_IN_PROGRESS = 0x00000108,
        STATUS_VOLUME_MOUNTED = 0x00000109,
        STATUS_RXACT_COMMITTED = 0x0000010A,
        STATUS_NOTIFY_CLEANUP = 0x0000010B,
        STATUS_NOTIFY_ENUM_DIR = 0x0000010C,
        STATUS_NO_QUOTAS_FOR_ACCOUNT = 0x0000010D,
        STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED = 0x0000010E,
        STATUS_PAGE_FAULT_TRANSITION = 0x00000110,
        STATUS_PAGE_FAULT_DEMAND_ZERO = 0x00000111,
        STATUS_PAGE_FAULT_COPY_ON_WRITE = 0x00000112,
        STATUS_PAGE_FAULT_GUARD_PAGE = 0x00000113,
        STATUS_PAGE_FAULT_PAGING_FILE = 0x00000114,
        STATUS_CACHE_PAGE_LOCKED = 0x00000115,
        STATUS_CRASH_DUMP = 0x00000116,
        STATUS_BUFFER_ALL_ZEROS = 0x00000117,
        STATUS_REPARSE_OBJECT = 0x00000118,
        STATUS_RESOURCE_REQUIREMENTS_CHANGED = 0x00000119,
        STATUS_TRANSLATION_COMPLETE = 0x00000120,
        STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY = 0x00000121,
        STATUS_NOTHING_TO_TERMINATE = 0x00000122,
        STATUS_PROCESS_NOT_IN_JOB = 0x00000123,
        STATUS_PROCESS_IN_JOB = 0x00000124,
        STATUS_VOLSNAP_HIBERNATE_READY = 0x00000125,
        STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 0x00000126,
        STATUS_INTERRUPT_VECTOR_ALREADY_CONNECTED = 0x00000127,
        STATUS_INTERRUPT_STILL_CONNECTED = 0x00000128,
        STATUS_PROCESS_CLONED = 0x00000129,
        STATUS_FILE_LOCKED_WITH_ONLY_READERS = 0x0000012A,
        STATUS_FILE_LOCKED_WITH_WRITERS = 0x0000012B,
        STATUS_VALID_IMAGE_HASH = 0x0000012C,
        STATUS_VALID_CATALOG_HASH = 0x0000012D,
        STATUS_VALID_STRONG_CODE_HASH = 0x0000012E,
        STATUS_GHOSTED = 0x0000012F,
        STATUS_RESOURCEMANAGER_READ_ONLY = 0x00000202,
        STATUS_RING_PREVIOUSLY_EMPTY = 0x00000210,
        STATUS_RING_PREVIOUSLY_FULL = 0x00000211,
        STATUS_RING_PREVIOUSLY_ABOVE_QUOTA = 0x00000212,
        STATUS_RING_NEWLY_EMPTY = 0x00000213,
        STATUS_RING_SIGNAL_OPPOSITE_ENDPOINT = 0x00000214,
        STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE = 0x00000215,
        STATUS_OPLOCK_HANDLE_CLOSED = 0x00000216,
        STATUS_WAIT_FOR_OPLOCK = 0x00000367,
        STATUS_REPARSE_GLOBAL = 0x00000368,
        STATUS_FLT_IO_COMPLETE = 0x001C0001,
        STATUS_OBJECT_NAME_EXISTS = 0x40000000,
        STATUS_THREAD_WAS_SUSPENDED = 0x40000001,
        STATUS_WORKING_SET_LIMIT_RANGE = 0x40000002,
        STATUS_IMAGE_NOT_AT_BASE = 0x40000003,
        STATUS_RXACT_STATE_CREATED = 0x40000004,
        STATUS_SEGMENT_NOTIFICATION = 0x40000005,
        STATUS_LOCAL_USER_SESSION_KEY = 0x40000006,
        STATUS_BAD_CURRENT_DIRECTORY = 0x40000007,
        STATUS_SERIAL_MORE_WRITES = 0x40000008,
        STATUS_REGISTRY_RECOVERED = 0x40000009,
        STATUS_FT_READ_RECOVERY_FROM_BACKUP = 0x4000000A,
        STATUS_FT_WRITE_RECOVERY = 0x4000000B,
        STATUS_SERIAL_COUNTER_TIMEOUT = 0x4000000C,
        STATUS_NULL_LM_PASSWORD = 0x4000000D,
        STATUS_IMAGE_MACHINE_TYPE_MISMATCH = 0x4000000E,
        STATUS_RECEIVE_PARTIAL = 0x4000000F,
        STATUS_RECEIVE_EXPEDITED = 0x40000010,
        STATUS_RECEIVE_PARTIAL_EXPEDITED = 0x40000011,
        STATUS_EVENT_DONE = 0x40000012,
        STATUS_EVENT_PENDING = 0x40000013,
        STATUS_CHECKING_FILE_SYSTEM = 0x40000014,
        STATUS_FATAL_APP_EXIT = 0x40000015,
        STATUS_PREDEFINED_HANDLE = 0x40000016,
        STATUS_WAS_UNLOCKED = 0x40000017,
        STATUS_SERVICE_NOTIFICATION = 0x40000018,
        STATUS_WAS_LOCKED = 0x40000019,
        STATUS_LOG_HARD_ERROR = 0x4000001A,
        STATUS_ALREADY_WIN32 = 0x4000001B,
        STATUS_WX86_UNSIMULATE = 0x4000001C,
        STATUS_WX86_CONTINUE = 0x4000001D,
        STATUS_WX86_SINGLE_STEP = 0x4000001E,
        STATUS_WX86_BREAKPOINT = 0x4000001F,
        STATUS_WX86_EXCEPTION_CONTINUE = 0x40000020,
        STATUS_WX86_EXCEPTION_LASTCHANCE = 0x40000021,
        STATUS_WX86_EXCEPTION_CHAIN = 0x40000022,
        STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE = 0x40000023,
        STATUS_NO_YIELD_PERFORMED = 0x40000024,
        STATUS_TIMER_RESUME_IGNORED = 0x40000025,
        STATUS_ARBITRATION_UNHANDLED = 0x40000026,
        STATUS_CARDBUS_NOT_SUPPORTED = 0x40000027,
        STATUS_WX86_CREATEWX86TIB = 0x40000028,
        STATUS_MP_PROCESSOR_MISMATCH = 0x40000029,
        STATUS_HIBERNATED = 0x4000002A,
        STATUS_RESUME_HIBERNATION = 0x4000002B,
        STATUS_FIRMWARE_UPDATED = 0x4000002C,
        STATUS_DRIVERS_LEAKING_LOCKED_PAGES = 0x4000002D,
        STATUS_MESSAGE_RETRIEVED = 0x4000002E,
        STATUS_SYSTEM_POWERSTATE_TRANSITION = 0x4000002F,
        STATUS_ALPC_CHECK_COMPLETION_LIST = 0x40000030,
        STATUS_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = 0x40000031,
        STATUS_ACCESS_AUDIT_BY_POLICY = 0x40000032,
        STATUS_ABANDON_HIBERFILE = 0x40000033,
        STATUS_BIZRULES_NOT_ENABLED = 0x40000034,
        STATUS_FT_READ_FROM_COPY = 0x40000035,
        STATUS_IMAGE_AT_DIFFERENT_BASE = 0x40000036,
        STATUS_HEURISTIC_DAMAGE_POSSIBLE = 0x40190001,
        STATUS_GUARD_PAGE_VIOLATION = 0x80000001,
        STATUS_DATATYPE_MISALIGNMENT = 0x80000002,
        STATUS_BREAKPOINT = 0x80000003,
        STATUS_SINGLE_STEP = 0x80000004,
        STATUS_BUFFER_OVERFLOW = 0x80000005,
        STATUS_NO_MORE_FILES = 0x80000006,
        STATUS_WAKE_SYSTEM_DEBUGGER = 0x80000007,
        STATUS_HANDLES_CLOSED = 0x8000000A,
        STATUS_NO_INHERITANCE = 0x8000000B,
        STATUS_GUID_SUBSTITUTION_MADE = 0x8000000C,
        STATUS_PARTIAL_COPY = 0x8000000D,
        STATUS_DEVICE_PAPER_EMPTY = 0x8000000E,
        STATUS_DEVICE_POWERED_OFF = 0x8000000F,
        STATUS_DEVICE_OFF_LINE = 0x80000010,
        STATUS_DEVICE_BUSY = 0x80000011,
        STATUS_NO_MORE_EAS = 0x80000012,
        STATUS_INVALID_EA_NAME = 0x80000013,
        STATUS_EA_LIST_INCONSISTENT = 0x80000014,
        STATUS_INVALID_EA_FLAG = 0x80000015,
        STATUS_VERIFY_REQUIRED = 0x80000016,
        STATUS_EXTRANEOUS_INFORMATION = 0x80000017,
        STATUS_RXACT_COMMIT_NECESSARY = 0x80000018,
        STATUS_NO_MORE_ENTRIES = 0x8000001A,
        STATUS_FILEMARK_DETECTED = 0x8000001B,
        STATUS_MEDIA_CHANGED = 0x8000001C,
        STATUS_BUS_RESET = 0x8000001D,
        STATUS_END_OF_MEDIA = 0x8000001E,
        STATUS_BEGINNING_OF_MEDIA = 0x8000001F,
        STATUS_MEDIA_CHECK = 0x80000020,
        STATUS_SETMARK_DETECTED = 0x80000021,
        STATUS_NO_DATA_DETECTED = 0x80000022,
        STATUS_REDIRECTOR_HAS_OPEN_HANDLES = 0x80000023,
        STATUS_SERVER_HAS_OPEN_HANDLES = 0x80000024,
        STATUS_ALREADY_DISCONNECTED = 0x80000025,
        STATUS_LONGJUMP = 0x80000026,
        STATUS_CLEANER_CARTRIDGE_INSTALLED = 0x80000027,
        STATUS_PLUGPLAY_QUERY_VETOED = 0x80000028,
        STATUS_UNWIND_CONSOLIDATE = 0x80000029,
        STATUS_REGISTRY_HIVE_RECOVERED = 0x8000002A,
        STATUS_DLL_MIGHT_BE_INSECURE = 0x8000002B,
        STATUS_DLL_MIGHT_BE_INCOMPATIBLE = 0x8000002C,
        STATUS_STOPPED_ON_SYMLINK = 0x8000002D,
        STATUS_CANNOT_GRANT_REQUESTED_OPLOCK = 0x8000002E,
        STATUS_NO_ACE_CONDITION = 0x8000002F,
        STATUS_DEVICE_SUPPORT_IN_PROGRESS = 0x80000030,
        STATUS_DEVICE_POWER_CYCLE_REQUIRED = 0x80000031,
        STATUS_NO_WORK_DONE = 0x80000032,
        STATUS_CLUSTER_NODE_ALREADY_UP = 0x80130001,
        STATUS_CLUSTER_NODE_ALREADY_DOWN = 0x80130002,
        STATUS_CLUSTER_NETWORK_ALREADY_ONLINE = 0x80130003,
        STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE = 0x80130004,
        STATUS_CLUSTER_NODE_ALREADY_MEMBER = 0x80130005,
        STATUS_FLT_BUFFER_TOO_SMALL = 0x801C0001,
        STATUS_FVE_PARTIAL_METADATA = 0x80210001,
        STATUS_FVE_TRANSIENT_STATE = 0x80210002,
        STATUS_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH = 0x8000CF00,
        STATUS_UNSUCCESSFUL = 0xC0000001,
        STATUS_NOT_IMPLEMENTED = 0xC0000002,
        STATUS_INVALID_INFO_CLASS = 0xC0000003,
        STATUS_INFO_LENGTH_MISMATCH = 0xC0000004,
        STATUS_ACCESS_VIOLATION = 0xC0000005,
        STATUS_IN_PAGE_ERROR = 0xC0000006,
        STATUS_PAGEFILE_QUOTA = 0xC0000007,
        STATUS_INVALID_HANDLE = 0xC0000008,
        STATUS_BAD_INITIAL_STACK = 0xC0000009,
        STATUS_BAD_INITIAL_PC = 0xC000000A,
        STATUS_INVALID_CID = 0xC000000B,
        STATUS_TIMER_NOT_CANCELED = 0xC000000C,
        STATUS_INVALID_PARAMETER = 0xC000000D,
        STATUS_NO_SUCH_DEVICE = 0xC000000E,
        STATUS_NO_SUCH_FILE = 0xC000000F,
        STATUS_INVALID_DEVICE_REQUEST = 0xC0000010,
        STATUS_END_OF_FILE = 0xC0000011,
        STATUS_WRONG_VOLUME = 0xC0000012,
        STATUS_NO_MEDIA_IN_DEVICE = 0xC0000013,
        STATUS_UNRECOGNIZED_MEDIA = 0xC0000014,
        STATUS_NONEXISTENT_SECTOR = 0xC0000015,
        STATUS_MORE_PROCESSING_REQUIRED = 0xC0000016,
        STATUS_NO_MEMORY = 0xC0000017,
        STATUS_CONFLICTING_ADDRESSES = 0xC0000018,
        STATUS_NOT_MAPPED_VIEW = 0xC0000019,
        STATUS_UNABLE_TO_FREE_VM = 0xC000001A,
        STATUS_UNABLE_TO_DELETE_SECTION = 0xC000001B,
        STATUS_INVALID_SYSTEM_SERVICE = 0xC000001C,
        STATUS_ILLEGAL_INSTRUCTION = 0xC000001D,
        STATUS_INVALID_LOCK_SEQUENCE = 0xC000001E,
        STATUS_INVALID_VIEW_SIZE = 0xC000001F,
        STATUS_INVALID_FILE_FOR_SECTION = 0xC0000020,
        STATUS_ALREADY_COMMITTED = 0xC0000021,
        STATUS_ACCESS_DENIED = 0xC0000022,
        STATUS_BUFFER_TOO_SMALL = 0xC0000023,
        STATUS_OBJECT_TYPE_MISMATCH = 0xC0000024,
        STATUS_NONCONTINUABLE_EXCEPTION = 0xC0000025,
        STATUS_INVALID_DISPOSITION = 0xC0000026,
        STATUS_UNWIND = 0xC0000027,
        STATUS_BAD_STACK = 0xC0000028,
        STATUS_INVALID_UNWIND_TARGET = 0xC0000029,
        STATUS_NOT_LOCKED = 0xC000002A,
        STATUS_PARITY_ERROR = 0xC000002B,
        STATUS_UNABLE_TO_DECOMMIT_VM = 0xC000002C,
        STATUS_NOT_COMMITTED = 0xC000002D,
        STATUS_INVALID_PORT_ATTRIBUTES = 0xC000002E,
        STATUS_PORT_MESSAGE_TOO_LONG = 0xC000002F,
        STATUS_INVALID_PARAMETER_MIX = 0xC0000030,
        STATUS_INVALID_QUOTA_LOWER = 0xC0000031,
        STATUS_DISK_CORRUPT_ERROR = 0xC0000032,
        STATUS_OBJECT_NAME_INVALID = 0xC0000033,
        STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034,
        STATUS_OBJECT_NAME_COLLISION = 0xC0000035,
        STATUS_PORT_DO_NOT_DISTURB = 0xC0000036,
        STATUS_PORT_DISCONNECTED = 0xC0000037,
        STATUS_DEVICE_ALREADY_ATTACHED = 0xC0000038,
        STATUS_OBJECT_PATH_INVALID = 0xC0000039,
        STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A,
        STATUS_OBJECT_PATH_SYNTAX_BAD = 0xC000003B,
        STATUS_DATA_OVERRUN = 0xC000003C,
        STATUS_DATA_LATE_ERROR = 0xC000003D,
        STATUS_DATA_ERROR = 0xC000003E,
        STATUS_CRC_ERROR = 0xC000003F,
        STATUS_SECTION_TOO_BIG = 0xC0000040,
        STATUS_PORT_CONNECTION_REFUSED = 0xC0000041,
        STATUS_INVALID_PORT_HANDLE = 0xC0000042,
        STATUS_SHARING_VIOLATION = 0xC0000043,
        STATUS_QUOTA_EXCEEDED = 0xC0000044,
        STATUS_INVALID_PAGE_PROTECTION = 0xC0000045,
        STATUS_MUTANT_NOT_OWNED = 0xC0000046,
        STATUS_SEMAPHORE_LIMIT_EXCEEDED = 0xC0000047,
        STATUS_PORT_ALREADY_SET = 0xC0000048,
        STATUS_SECTION_NOT_IMAGE = 0xC0000049,
        STATUS_SUSPEND_COUNT_EXCEEDED = 0xC000004A,
        STATUS_THREAD_IS_TERMINATING = 0xC000004B,
        STATUS_BAD_WORKING_SET_LIMIT = 0xC000004C,
        STATUS_INCOMPATIBLE_FILE_MAP = 0xC000004D,
        STATUS_SECTION_PROTECTION = 0xC000004E,
        STATUS_EAS_NOT_SUPPORTED = 0xC000004F,
        STATUS_EA_TOO_LARGE = 0xC0000050,
        STATUS_NONEXISTENT_EA_ENTRY = 0xC0000051,
        STATUS_NO_EAS_ON_FILE = 0xC0000052,
        STATUS_EA_CORRUPT_ERROR = 0xC0000053,
        STATUS_FILE_LOCK_CONFLICT = 0xC0000054,
        STATUS_LOCK_NOT_GRANTED = 0xC0000055,
        STATUS_DELETE_PENDING = 0xC0000056,
        STATUS_CTL_FILE_NOT_SUPPORTED = 0xC0000057,
        STATUS_UNKNOWN_REVISION = 0xC0000058,
        STATUS_REVISION_MISMATCH = 0xC0000059,
        STATUS_INVALID_OWNER = 0xC000005A,
        STATUS_INVALID_PRIMARY_GROUP = 0xC000005B,
        STATUS_NO_IMPERSONATION_TOKEN = 0xC000005C,
        STATUS_CANT_DISABLE_MANDATORY = 0xC000005D,
        STATUS_NO_LOGON_SERVERS = 0xC000005E,
        STATUS_NO_SUCH_LOGON_SESSION = 0xC000005F,
        STATUS_NO_SUCH_PRIVILEGE = 0xC0000060,
        STATUS_PRIVILEGE_NOT_HELD = 0xC0000061,
        STATUS_INVALID_ACCOUNT_NAME = 0xC0000062,
        STATUS_USER_EXISTS = 0xC0000063,
        STATUS_NO_SUCH_USER = 0xC0000064,
        STATUS_GROUP_EXISTS = 0xC0000065,
        STATUS_NO_SUCH_GROUP = 0xC0000066,
        STATUS_MEMBER_IN_GROUP = 0xC0000067,
        STATUS_MEMBER_NOT_IN_GROUP = 0xC0000068,
        STATUS_LAST_ADMIN = 0xC0000069,
        STATUS_WRONG_PASSWORD = 0xC000006A,
        STATUS_ILL_FORMED_PASSWORD = 0xC000006B,
        STATUS_PASSWORD_RESTRICTION = 0xC000006C,
        STATUS_LOGON_FAILURE = 0xC000006D,
        STATUS_ACCOUNT_RESTRICTION = 0xC000006E,
        STATUS_INVALID_LOGON_HOURS = 0xC000006F,
        STATUS_INVALID_WORKSTATION = 0xC0000070,
        STATUS_PASSWORD_EXPIRED = 0xC0000071,
        STATUS_ACCOUNT_DISABLED = 0xC0000072,
        STATUS_NONE_MAPPED = 0xC0000073,
        STATUS_TOO_MANY_LUIDS_REQUESTED = 0xC0000074,
        STATUS_LUIDS_EXHAUSTED = 0xC0000075,
        STATUS_INVALID_SUB_AUTHORITY = 0xC0000076,
        STATUS_INVALID_ACL = 0xC0000077,
        STATUS_INVALID_SID = 0xC0000078,
        STATUS_INVALID_SECURITY_DESCR = 0xC0000079,
        STATUS_PROCEDURE_NOT_FOUND = 0xC000007A,
        STATUS_INVALID_IMAGE_FORMAT = 0xC000007B,
        STATUS_NO_TOKEN = 0xC000007C,
        STATUS_BAD_INHERITANCE_ACL = 0xC000007D,
        STATUS_RANGE_NOT_LOCKED = 0xC000007E,
        STATUS_DISK_FULL = 0xC000007F,
        STATUS_SERVER_DISABLED = 0xC0000080,
        STATUS_SERVER_NOT_DISABLED = 0xC0000081,
        STATUS_TOO_MANY_GUIDS_REQUESTED = 0xC0000082,
        STATUS_GUIDS_EXHAUSTED = 0xC0000083,
        STATUS_INVALID_ID_AUTHORITY = 0xC0000084,
        STATUS_AGENTS_EXHAUSTED = 0xC0000085,
        STATUS_INVALID_VOLUME_LABEL = 0xC0000086,
        STATUS_SECTION_NOT_EXTENDED = 0xC0000087,
        STATUS_NOT_MAPPED_DATA = 0xC0000088,
        STATUS_RESOURCE_DATA_NOT_FOUND = 0xC0000089,
        STATUS_RESOURCE_TYPE_NOT_FOUND = 0xC000008A,
        STATUS_RESOURCE_NAME_NOT_FOUND = 0xC000008B,
        STATUS_ARRAY_BOUNDS_EXCEEDED = 0xC000008C,
        STATUS_FLOAT_DENORMAL_OPERAND = 0xC000008D,
        STATUS_FLOAT_DIVIDE_BY_ZERO = 0xC000008E,
        STATUS_FLOAT_INEXACT_RESULT = 0xC000008F,
        STATUS_FLOAT_INVALID_OPERATION = 0xC0000090,
        STATUS_FLOAT_OVERFLOW = 0xC0000091,
        STATUS_FLOAT_STACK_CHECK = 0xC0000092,
        STATUS_FLOAT_UNDERFLOW = 0xC0000093,
        STATUS_INTEGER_DIVIDE_BY_ZERO = 0xC0000094,
        STATUS_INTEGER_OVERFLOW = 0xC0000095,
        STATUS_PRIVILEGED_INSTRUCTION = 0xC0000096,
        STATUS_TOO_MANY_PAGING_FILES = 0xC0000097,
        STATUS_FILE_INVALID = 0xC0000098,
        STATUS_ALLOTTED_SPACE_EXCEEDED = 0xC0000099,
        STATUS_INSUFFICIENT_RESOURCES = 0xC000009A,
        STATUS_DFS_EXIT_PATH_FOUND = 0xC000009B,
        STATUS_DEVICE_DATA_ERROR = 0xC000009C,
        STATUS_DEVICE_NOT_CONNECTED = 0xC000009D,
        STATUS_DEVICE_POWER_FAILURE = 0xC000009E,
        STATUS_FREE_VM_NOT_AT_BASE = 0xC000009F,
        STATUS_MEMORY_NOT_ALLOCATED = 0xC00000A0,
        STATUS_WORKING_SET_QUOTA = 0xC00000A1,
        STATUS_MEDIA_WRITE_PROTECTED = 0xC00000A2,
        STATUS_DEVICE_NOT_READY = 0xC00000A3,
        STATUS_INVALID_GROUP_ATTRIBUTES = 0xC00000A4,
        STATUS_BAD_IMPERSONATION_LEVEL = 0xC00000A5,
        STATUS_CANT_OPEN_ANONYMOUS = 0xC00000A6,
        STATUS_BAD_VALIDATION_CLASS = 0xC00000A7,
        STATUS_BAD_TOKEN_TYPE = 0xC00000A8,
        STATUS_BAD_MASTER_BOOT_RECORD = 0xC00000A9,
        STATUS_INSTRUCTION_MISALIGNMENT = 0xC00000AA,
        STATUS_INSTANCE_NOT_AVAILABLE = 0xC00000AB,
        STATUS_PIPE_NOT_AVAILABLE = 0xC00000AC,
        STATUS_INVALID_PIPE_STATE = 0xC00000AD,
        STATUS_PIPE_BUSY = 0xC00000AE,
        STATUS_ILLEGAL_FUNCTION = 0xC00000AF,
        STATUS_PIPE_DISCONNECTED = 0xC00000B0,
        STATUS_PIPE_CLOSING = 0xC00000B1,
        STATUS_PIPE_CONNECTED = 0xC00000B2,
        STATUS_PIPE_LISTENING = 0xC00000B3,
        STATUS_INVALID_READ_MODE = 0xC00000B4,
        STATUS_IO_TIMEOUT = 0xC00000B5,
        STATUS_FILE_FORCED_CLOSED = 0xC00000B6,
        STATUS_PROFILING_NOT_STARTED = 0xC00000B7,
        STATUS_PROFILING_NOT_STOPPED = 0xC00000B8,
        STATUS_COULD_NOT_INTERPRET = 0xC00000B9,
        STATUS_FILE_IS_A_DIRECTORY = 0xC00000BA,
        STATUS_NOT_SUPPORTED = 0xC00000BB,
        STATUS_REMOTE_NOT_LISTENING = 0xC00000BC,
        STATUS_DUPLICATE_NAME = 0xC00000BD,
        STATUS_BAD_NETWORK_PATH = 0xC00000BE,
        STATUS_NETWORK_BUSY = 0xC00000BF,
        STATUS_DEVICE_DOES_NOT_EXIST = 0xC00000C0,
        STATUS_TOO_MANY_COMMANDS = 0xC00000C1,
        STATUS_ADAPTER_HARDWARE_ERROR = 0xC00000C2,
        STATUS_INVALID_NETWORK_RESPONSE = 0xC00000C3,
        STATUS_UNEXPECTED_NETWORK_ERROR = 0xC00000C4,
        STATUS_BAD_REMOTE_ADAPTER = 0xC00000C5,
        STATUS_PRINT_QUEUE_FULL = 0xC00000C6,
        STATUS_NO_SPOOL_SPACE = 0xC00000C7,
        STATUS_PRINT_CANCELLED = 0xC00000C8,
        STATUS_NETWORK_NAME_DELETED = 0xC00000C9,
        STATUS_NETWORK_ACCESS_DENIED = 0xC00000CA,
        STATUS_BAD_DEVICE_TYPE = 0xC00000CB,
        STATUS_BAD_NETWORK_NAME = 0xC00000CC,
        STATUS_TOO_MANY_NAMES = 0xC00000CD,
        STATUS_TOO_MANY_SESSIONS = 0xC00000CE,
        STATUS_SHARING_PAUSED = 0xC00000CF,
        STATUS_REQUEST_NOT_ACCEPTED = 0xC00000D0,
        STATUS_REDIRECTOR_PAUSED = 0xC00000D1,
        STATUS_NET_WRITE_FAULT = 0xC00000D2,
        STATUS_PROFILING_AT_LIMIT = 0xC00000D3,
        STATUS_NOT_SAME_DEVICE = 0xC00000D4,
        STATUS_FILE_RENAMED = 0xC00000D5,
        STATUS_VIRTUAL_CIRCUIT_CLOSED = 0xC00000D6,
        STATUS_NO_SECURITY_ON_OBJECT = 0xC00000D7,
        STATUS_CANT_WAIT = 0xC00000D8,
        STATUS_PIPE_EMPTY = 0xC00000D9,
        STATUS_CANT_ACCESS_DOMAIN_INFO = 0xC00000DA,
        STATUS_CANT_TERMINATE_SELF = 0xC00000DB,
        STATUS_INVALID_SERVER_STATE = 0xC00000DC,
        STATUS_INVALID_DOMAIN_STATE = 0xC00000DD,
        STATUS_INVALID_DOMAIN_ROLE = 0xC00000DE,
        STATUS_NO_SUCH_DOMAIN = 0xC00000DF,
        STATUS_DOMAIN_EXISTS = 0xC00000E0,
        STATUS_DOMAIN_LIMIT_EXCEEDED = 0xC00000E1,
        STATUS_OPLOCK_NOT_GRANTED = 0xC00000E2,
        STATUS_INVALID_OPLOCK_PROTOCOL = 0xC00000E3,
        STATUS_INTERNAL_DB_CORRUPTION = 0xC00000E4,
        STATUS_INTERNAL_ERROR = 0xC00000E5,
        STATUS_GENERIC_NOT_MAPPED = 0xC00000E6,
        STATUS_BAD_DESCRIPTOR_FORMAT = 0xC00000E7,
        STATUS_INVALID_USER_BUFFER = 0xC00000E8,
        STATUS_UNEXPECTED_IO_ERROR = 0xC00000E9,
        STATUS_UNEXPECTED_MM_CREATE_ERR = 0xC00000EA,
        STATUS_UNEXPECTED_MM_MAP_ERROR = 0xC00000EB,
        STATUS_UNEXPECTED_MM_EXTEND_ERR = 0xC00000EC,
        STATUS_NOT_LOGON_PROCESS = 0xC00000ED,
        STATUS_LOGON_SESSION_EXISTS = 0xC00000EE,
        STATUS_INVALID_PARAMETER_1 = 0xC00000EF,
        STATUS_INVALID_PARAMETER_2 = 0xC00000F0,
        STATUS_INVALID_PARAMETER_3 = 0xC00000F1,
        STATUS_INVALID_PARAMETER_4 = 0xC00000F2,
        STATUS_INVALID_PARAMETER_5 = 0xC00000F3,
        STATUS_INVALID_PARAMETER_6 = 0xC00000F4,
        STATUS_INVALID_PARAMETER_7 = 0xC00000F5,
        STATUS_INVALID_PARAMETER_8 = 0xC00000F6,
        STATUS_INVALID_PARAMETER_9 = 0xC00000F7,
        STATUS_INVALID_PARAMETER_10 = 0xC00000F8,
        STATUS_INVALID_PARAMETER_11 = 0xC00000F9,
        STATUS_INVALID_PARAMETER_12 = 0xC00000FA,
        STATUS_REDIRECTOR_NOT_STARTED = 0xC00000FB,
        STATUS_REDIRECTOR_STARTED = 0xC00000FC,
        STATUS_STACK_OVERFLOW = 0xC00000FD,
        STATUS_NO_SUCH_PACKAGE = 0xC00000FE,
        STATUS_BAD_FUNCTION_TABLE = 0xC00000FF,
        STATUS_VARIABLE_NOT_FOUND = 0xC0000100,
        STATUS_DIRECTORY_NOT_EMPTY = 0xC0000101,
        STATUS_FILE_CORRUPT_ERROR = 0xC0000102,
        STATUS_NOT_A_DIRECTORY = 0xC0000103,
        STATUS_BAD_LOGON_SESSION_STATE = 0xC0000104,
        STATUS_LOGON_SESSION_COLLISION = 0xC0000105,
        STATUS_NAME_TOO_LONG = 0xC0000106,
        STATUS_FILES_OPEN = 0xC0000107,
        STATUS_CONNECTION_IN_USE = 0xC0000108,
        STATUS_MESSAGE_NOT_FOUND = 0xC0000109,
        STATUS_PROCESS_IS_TERMINATING = 0xC000010A,
        STATUS_INVALID_LOGON_TYPE = 0xC000010B,
        STATUS_NO_GUID_TRANSLATION = 0xC000010C,
        STATUS_CANNOT_IMPERSONATE = 0xC000010D,
        STATUS_IMAGE_ALREADY_LOADED = 0xC000010E,
        STATUS_ABIOS_NOT_PRESENT = 0xC000010F,
        STATUS_ABIOS_LID_NOT_EXIST = 0xC0000110,
        STATUS_ABIOS_LID_ALREADY_OWNED = 0xC0000111,
        STATUS_ABIOS_NOT_LID_OWNER = 0xC0000112,
        STATUS_ABIOS_INVALID_COMMAND = 0xC0000113,
        STATUS_ABIOS_INVALID_LID = 0xC0000114,
        STATUS_ABIOS_SELECTOR_NOT_AVAILABLE = 0xC0000115,
        STATUS_ABIOS_INVALID_SELECTOR = 0xC0000116,
        STATUS_NO_LDT = 0xC0000117,
        STATUS_INVALID_LDT_SIZE = 0xC0000118,
        STATUS_INVALID_LDT_OFFSET = 0xC0000119,
        STATUS_INVALID_LDT_DESCRIPTOR = 0xC000011A,
        STATUS_INVALID_IMAGE_NE_FORMAT = 0xC000011B,
        STATUS_RXACT_INVALID_STATE = 0xC000011C,
        STATUS_RXACT_COMMIT_FAILURE = 0xC000011D,
        STATUS_MAPPED_FILE_SIZE_ZERO = 0xC000011E,
        STATUS_TOO_MANY_OPENED_FILES = 0xC000011F,
        STATUS_CANCELLED = 0xC0000120,
        STATUS_CANNOT_DELETE = 0xC0000121,
        STATUS_INVALID_COMPUTER_NAME = 0xC0000122,
        STATUS_FILE_DELETED = 0xC0000123,
        STATUS_SPECIAL_ACCOUNT = 0xC0000124,
        STATUS_SPECIAL_GROUP = 0xC0000125,
        STATUS_SPECIAL_USER = 0xC0000126,
        STATUS_MEMBERS_PRIMARY_GROUP = 0xC0000127,
        STATUS_FILE_CLOSED = 0xC0000128,
        STATUS_TOO_MANY_THREADS = 0xC0000129,
        STATUS_THREAD_NOT_IN_PROCESS = 0xC000012A,
        STATUS_TOKEN_ALREADY_IN_USE = 0xC000012B,
        STATUS_PAGEFILE_QUOTA_EXCEEDED = 0xC000012C,
        STATUS_COMMITMENT_LIMIT = 0xC000012D,
        STATUS_INVALID_IMAGE_LE_FORMAT = 0xC000012E,
        STATUS_INVALID_IMAGE_NOT_MZ = 0xC000012F,
        STATUS_INVALID_IMAGE_PROTECT = 0xC0000130,
        STATUS_INVALID_IMAGE_WIN_16 = 0xC0000131,
        STATUS_LOGON_SERVER_CONFLICT = 0xC0000132,
        STATUS_TIME_DIFFERENCE_AT_DC = 0xC0000133,
        STATUS_SYNCHRONIZATION_REQUIRED = 0xC0000134,
        STATUS_DLL_NOT_FOUND = 0xC0000135,
        STATUS_OPEN_FAILED = 0xC0000136,
        STATUS_IO_PRIVILEGE_FAILED = 0xC0000137,
        STATUS_ORDINAL_NOT_FOUND = 0xC0000138,
        STATUS_ENTRYPOINT_NOT_FOUND = 0xC0000139,
        STATUS_CONTROL_C_EXIT = 0xC000013A,
        STATUS_LOCAL_DISCONNECT = 0xC000013B,
        STATUS_REMOTE_DISCONNECT = 0xC000013C,
        STATUS_REMOTE_RESOURCES = 0xC000013D,
        STATUS_LINK_FAILED = 0xC000013E,
        STATUS_LINK_TIMEOUT = 0xC000013F,
        STATUS_INVALID_CONNECTION = 0xC0000140,
        STATUS_INVALID_ADDRESS = 0xC0000141,
        STATUS_DLL_INIT_FAILED = 0xC0000142,
        STATUS_MISSING_SYSTEMFILE = 0xC0000143,
        STATUS_UNHANDLED_EXCEPTION = 0xC0000144,
        STATUS_APP_INIT_FAILURE = 0xC0000145,
        STATUS_PAGEFILE_CREATE_FAILED = 0xC0000146,
        STATUS_NO_PAGEFILE = 0xC0000147,
        STATUS_INVALID_LEVEL = 0xC0000148,
        STATUS_WRONG_PASSWORD_CORE = 0xC0000149,
        STATUS_ILLEGAL_FLOAT_CONTEXT = 0xC000014A,
        STATUS_PIPE_BROKEN = 0xC000014B,
        STATUS_REGISTRY_CORRUPT = 0xC000014C,
        STATUS_REGISTRY_IO_FAILED = 0xC000014D,
        STATUS_NO_EVENT_PAIR = 0xC000014E,
        STATUS_UNRECOGNIZED_VOLUME = 0xC000014F,
        STATUS_SERIAL_NO_DEVICE_INITED = 0xC0000150,
        STATUS_NO_SUCH_ALIAS = 0xC0000151,
        STATUS_MEMBER_NOT_IN_ALIAS = 0xC0000152,
        STATUS_MEMBER_IN_ALIAS = 0xC0000153,
        STATUS_ALIAS_EXISTS = 0xC0000154,
        STATUS_LOGON_NOT_GRANTED = 0xC0000155,
        STATUS_TOO_MANY_SECRETS = 0xC0000156,
        STATUS_SECRET_TOO_LONG = 0xC0000157,
        STATUS_INTERNAL_DB_ERROR = 0xC0000158,
        STATUS_FULLSCREEN_MODE = 0xC0000159,
        STATUS_TOO_MANY_CONTEXT_IDS = 0xC000015A,
        STATUS_LOGON_TYPE_NOT_GRANTED = 0xC000015B,
        STATUS_NOT_REGISTRY_FILE = 0xC000015C,
        STATUS_NT_CROSS_ENCRYPTION_REQUIRED = 0xC000015D,
        STATUS_DOMAIN_CTRLR_CONFIG_ERROR = 0xC000015E,
        STATUS_FT_MISSING_MEMBER = 0xC000015F,
        STATUS_ILL_FORMED_SERVICE_ENTRY = 0xC0000160,
        STATUS_ILLEGAL_CHARACTER = 0xC0000161,
        STATUS_UNMAPPABLE_CHARACTER = 0xC0000162,
        STATUS_UNDEFINED_CHARACTER = 0xC0000163,
        STATUS_FLOPPY_VOLUME = 0xC0000164,
        STATUS_FLOPPY_ID_MARK_NOT_FOUND = 0xC0000165,
        STATUS_FLOPPY_WRONG_CYLINDER = 0xC0000166,
        STATUS_FLOPPY_UNKNOWN_ERROR = 0xC0000167,
        STATUS_FLOPPY_BAD_REGISTERS = 0xC0000168,
        STATUS_DISK_RECALIBRATE_FAILED = 0xC0000169,
        STATUS_DISK_OPERATION_FAILED = 0xC000016A,
        STATUS_DISK_RESET_FAILED = 0xC000016B,
        STATUS_SHARED_IRQ_BUSY = 0xC000016C,
        STATUS_FT_ORPHANING = 0xC000016D,
        STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT = 0xC000016E,
        STATUS_PARTITION_FAILURE = 0xC0000172,
        STATUS_INVALID_BLOCK_LENGTH = 0xC0000173,
        STATUS_DEVICE_NOT_PARTITIONED = 0xC0000174,
        STATUS_UNABLE_TO_LOCK_MEDIA = 0xC0000175,
        STATUS_UNABLE_TO_UNLOAD_MEDIA = 0xC0000176,
        STATUS_EOM_OVERFLOW = 0xC0000177,
        STATUS_NO_MEDIA = 0xC0000178,
        STATUS_NO_SUCH_MEMBER = 0xC000017A,
        STATUS_INVALID_MEMBER = 0xC000017B,
        STATUS_KEY_DELETED = 0xC000017C,
        STATUS_NO_LOG_SPACE = 0xC000017D,
        STATUS_TOO_MANY_SIDS = 0xC000017E,
        STATUS_LM_CROSS_ENCRYPTION_REQUIRED = 0xC000017F,
        STATUS_KEY_HAS_CHILDREN = 0xC0000180,
        STATUS_CHILD_MUST_BE_VOLATILE = 0xC0000181,
        STATUS_DEVICE_CONFIGURATION_ERROR = 0xC0000182,
        STATUS_DRIVER_INTERNAL_ERROR = 0xC0000183,
        STATUS_INVALID_DEVICE_STATE = 0xC0000184,
        STATUS_IO_DEVICE_ERROR = 0xC0000185,
        STATUS_DEVICE_PROTOCOL_ERROR = 0xC0000186,
        STATUS_BACKUP_CONTROLLER = 0xC0000187,
        STATUS_LOG_FILE_FULL = 0xC0000188,
        STATUS_TOO_LATE = 0xC0000189,
        STATUS_NO_TRUST_LSA_SECRET = 0xC000018A,
        STATUS_NO_TRUST_SAM_ACCOUNT = 0xC000018B,
        STATUS_TRUSTED_DOMAIN_FAILURE = 0xC000018C,
        STATUS_TRUSTED_RELATIONSHIP_FAILURE = 0xC000018D,
        STATUS_EVENTLOG_FILE_CORRUPT = 0xC000018E,
        STATUS_EVENTLOG_CANT_START = 0xC000018F,
        STATUS_TRUST_FAILURE = 0xC0000190,
        STATUS_MUTANT_LIMIT_EXCEEDED = 0xC0000191,
        STATUS_NETLOGON_NOT_STARTED = 0xC0000192,
        STATUS_ACCOUNT_EXPIRED = 0xC0000193,
        STATUS_POSSIBLE_DEADLOCK = 0xC0000194,
        STATUS_NETWORK_CREDENTIAL_CONFLICT = 0xC0000195,
        STATUS_REMOTE_SESSION_LIMIT = 0xC0000196,
        STATUS_EVENTLOG_FILE_CHANGED = 0xC0000197,
        STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 0xC0000198,
        STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 0xC0000199,
        STATUS_NOLOGON_SERVER_TRUST_ACCOUNT = 0xC000019A,
        STATUS_DOMAIN_TRUST_INCONSISTENT = 0xC000019B,
        STATUS_FS_DRIVER_REQUIRED = 0xC000019C,
        STATUS_IMAGE_ALREADY_LOADED_AS_DLL = 0xC000019D,
        STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 0xC000019E,
        STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 0xC000019F,
        STATUS_SECURITY_STREAM_IS_INCONSISTENT = 0xC00001A0,
        STATUS_INVALID_LOCK_RANGE = 0xC00001A1,
        STATUS_INVALID_ACE_CONDITION = 0xC00001A2,
        STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT = 0xC00001A3,
        STATUS_NOTIFICATION_GUID_ALREADY_DEFINED = 0xC00001A4,
        STATUS_INVALID_EXCEPTION_HANDLER = 0xC00001A5,
        STATUS_DUPLICATE_PRIVILEGES = 0xC00001A6,
        STATUS_NOT_ALLOWED_ON_SYSTEM_FILE = 0xC00001A7,
        STATUS_REPAIR_NEEDED = 0xC00001A8,
        STATUS_QUOTA_NOT_ENABLED = 0xC00001A9,
        STATUS_NO_APPLICATION_PACKAGE = 0xC00001AA,
        STATUS_FILE_METADATA_OPTIMIZATION_IN_PROGRESS = 0xC00001AB,
        STATUS_NOT_SAME_OBJECT = 0xC00001AC,
        STATUS_FATAL_MEMORY_EXHAUSTION = 0xC00001AD,
        STATUS_ERROR_PROCESS_NOT_IN_JOB = 0xC00001AE,
        STATUS_CPU_SET_INVALID = 0xC00001AF,
        STATUS_NETWORK_OPEN_RESTRICTION = 0xC0000201,
        STATUS_NO_USER_SESSION_KEY = 0xC0000202,
        STATUS_USER_SESSION_DELETED = 0xC0000203,
        STATUS_RESOURCE_LANG_NOT_FOUND = 0xC0000204,
        STATUS_INSUFF_SERVER_RESOURCES = 0xC0000205,
        STATUS_INVALID_BUFFER_SIZE = 0xC0000206,
        STATUS_INVALID_ADDRESS_COMPONENT = 0xC0000207,
        STATUS_INVALID_ADDRESS_WILDCARD = 0xC0000208,
        STATUS_TOO_MANY_ADDRESSES = 0xC0000209,
        STATUS_ADDRESS_ALREADY_EXISTS = 0xC000020A,
        STATUS_ADDRESS_CLOSED = 0xC000020B,
        STATUS_CONNECTION_DISCONNECTED = 0xC000020C,
        STATUS_CONNECTION_RESET = 0xC000020D,
        STATUS_TOO_MANY_NODES = 0xC000020E,
        STATUS_TRANSACTION_ABORTED = 0xC000020F,
        STATUS_TRANSACTION_TIMED_OUT = 0xC0000210,
        STATUS_TRANSACTION_NO_RELEASE = 0xC0000211,
        STATUS_TRANSACTION_NO_MATCH = 0xC0000212,
        STATUS_TRANSACTION_RESPONDED = 0xC0000213,
        STATUS_TRANSACTION_INVALID_ID = 0xC0000214,
        STATUS_TRANSACTION_INVALID_TYPE = 0xC0000215,
        STATUS_NOT_SERVER_SESSION = 0xC0000216,
        STATUS_NOT_CLIENT_SESSION = 0xC0000217,
        STATUS_CANNOT_LOAD_REGISTRY_FILE = 0xC0000218,
        STATUS_DEBUG_ATTACH_FAILED = 0xC0000219,
        STATUS_SYSTEM_PROCESS_TERMINATED = 0xC000021A,
        STATUS_DATA_NOT_ACCEPTED = 0xC000021B,
        STATUS_NO_BROWSER_SERVERS_FOUND = 0xC000021C,
        STATUS_VDM_HARD_ERROR = 0xC000021D,
        STATUS_DRIVER_CANCEL_TIMEOUT = 0xC000021E,
        STATUS_REPLY_MESSAGE_MISMATCH = 0xC000021F,
        STATUS_MAPPED_ALIGNMENT = 0xC0000220,
        STATUS_IMAGE_CHECKSUM_MISMATCH = 0xC0000221,
        STATUS_LOST_WRITEBEHIND_DATA = 0xC0000222,
        STATUS_CLIENT_SERVER_PARAMETERS_INVALID = 0xC0000223,
        STATUS_PASSWORD_MUST_CHANGE = 0xC0000224,
        STATUS_NOT_FOUND = 0xC0000225,
        STATUS_NOT_TINY_STREAM = 0xC0000226,
        STATUS_RECOVERY_FAILURE = 0xC0000227,
        STATUS_STACK_OVERFLOW_READ = 0xC0000228,
        STATUS_FAIL_CHECK = 0xC0000229,
        STATUS_DUPLICATE_OBJECTID = 0xC000022A,
        STATUS_OBJECTID_EXISTS = 0xC000022B,
        STATUS_CONVERT_TO_LARGE = 0xC000022C,
        STATUS_RETRY = 0xC000022D,
        STATUS_FOUND_OUT_OF_SCOPE = 0xC000022E,
        STATUS_ALLOCATE_BUCKET = 0xC000022F,
        STATUS_PROPSET_NOT_FOUND = 0xC0000230,
        STATUS_MARSHALL_OVERFLOW = 0xC0000231,
        STATUS_INVALID_VARIANT = 0xC0000232,
        STATUS_DOMAIN_CONTROLLER_NOT_FOUND = 0xC0000233,
        STATUS_ACCOUNT_LOCKED_OUT = 0xC0000234,
        STATUS_HANDLE_NOT_CLOSABLE = 0xC0000235,
        STATUS_CONNECTION_REFUSED = 0xC0000236,
        STATUS_GRACEFUL_DISCONNECT = 0xC0000237,
        STATUS_ADDRESS_ALREADY_ASSOCIATED = 0xC0000238,
        STATUS_ADDRESS_NOT_ASSOCIATED = 0xC0000239,
        STATUS_CONNECTION_INVALID = 0xC000023A,
        STATUS_CONNECTION_ACTIVE = 0xC000023B,
        STATUS_NETWORK_UNREACHABLE = 0xC000023C,
        STATUS_HOST_UNREACHABLE = 0xC000023D,
        STATUS_PROTOCOL_UNREACHABLE = 0xC000023E,
        STATUS_PORT_UNREACHABLE = 0xC000023F,
        STATUS_REQUEST_ABORTED = 0xC0000240,
        STATUS_CONNECTION_ABORTED = 0xC0000241,
        STATUS_BAD_COMPRESSION_BUFFER = 0xC0000242,
        STATUS_USER_MAPPED_FILE = 0xC0000243,
        STATUS_AUDIT_FAILED = 0xC0000244,
        STATUS_TIMER_RESOLUTION_NOT_SET = 0xC0000245,
        STATUS_CONNECTION_COUNT_LIMIT = 0xC0000246,
        STATUS_LOGIN_TIME_RESTRICTION = 0xC0000247,
        STATUS_LOGIN_WKSTA_RESTRICTION = 0xC0000248,
        STATUS_IMAGE_MP_UP_MISMATCH = 0xC0000249,
        STATUS_INSUFFICIENT_LOGON_INFO = 0xC0000250,
        STATUS_BAD_DLL_ENTRYPOINT = 0xC0000251,
        STATUS_BAD_SERVICE_ENTRYPOINT = 0xC0000252,
        STATUS_LPC_REPLY_LOST = 0xC0000253,
        STATUS_IP_ADDRESS_CONFLICT1 = 0xC0000254,
        STATUS_IP_ADDRESS_CONFLICT2 = 0xC0000255,
        STATUS_REGISTRY_QUOTA_LIMIT = 0xC0000256,
        STATUS_PATH_NOT_COVERED = 0xC0000257,
        STATUS_NO_CALLBACK_ACTIVE = 0xC0000258,
        STATUS_LICENSE_QUOTA_EXCEEDED = 0xC0000259,
        STATUS_PWD_TOO_SHORT = 0xC000025A,
        STATUS_PWD_TOO_RECENT = 0xC000025B,
        STATUS_PWD_HISTORY_CONFLICT = 0xC000025C,
        STATUS_PLUGPLAY_NO_DEVICE = 0xC000025E,
        STATUS_UNSUPPORTED_COMPRESSION = 0xC000025F,
        STATUS_INVALID_HW_PROFILE = 0xC0000260,
        STATUS_INVALID_PLUGPLAY_DEVICE_PATH = 0xC0000261,
        STATUS_DRIVER_ORDINAL_NOT_FOUND = 0xC0000262,
        STATUS_DRIVER_ENTRYPOINT_NOT_FOUND = 0xC0000263,
        STATUS_RESOURCE_NOT_OWNED = 0xC0000264,
        STATUS_TOO_MANY_LINKS = 0xC0000265,
        STATUS_QUOTA_LIST_INCONSISTENT = 0xC0000266,
        STATUS_FILE_IS_OFFLINE = 0xC0000267,
        STATUS_EVALUATION_EXPIRATION = 0xC0000268,
        STATUS_ILLEGAL_DLL_RELOCATION = 0xC0000269,
        STATUS_LICENSE_VIOLATION = 0xC000026A,
        STATUS_DLL_INIT_FAILED_LOGOFF = 0xC000026B,
        STATUS_DRIVER_UNABLE_TO_LOAD = 0xC000026C,
        STATUS_DFS_UNAVAILABLE = 0xC000026D,
        STATUS_VOLUME_DISMOUNTED = 0xC000026E,
        STATUS_WX86_INTERNAL_ERROR = 0xC000026F,
        STATUS_WX86_FLOAT_STACK_CHECK = 0xC0000270,
        STATUS_VALIDATE_CONTINUE = 0xC0000271,
        STATUS_NO_MATCH = 0xC0000272,
        STATUS_NO_MORE_MATCHES = 0xC0000273,
        STATUS_NOT_A_REPARSE_POINT = 0xC0000275,
        STATUS_IO_REPARSE_TAG_INVALID = 0xC0000276,
        STATUS_IO_REPARSE_TAG_MISMATCH = 0xC0000277,
        STATUS_IO_REPARSE_DATA_INVALID = 0xC0000278,
        STATUS_IO_REPARSE_TAG_NOT_HANDLED = 0xC0000279,
        STATUS_PWD_TOO_LONG = 0xC000027A,
        STATUS_STOWED_EXCEPTION = 0xC000027B,
        STATUS_REPARSE_POINT_NOT_RESOLVED = 0xC0000280,
        STATUS_DIRECTORY_IS_A_REPARSE_POINT = 0xC0000281,
        STATUS_RANGE_LIST_CONFLICT = 0xC0000282,
        STATUS_SOURCE_ELEMENT_EMPTY = 0xC0000283,
        STATUS_DESTINATION_ELEMENT_FULL = 0xC0000284,
        STATUS_ILLEGAL_ELEMENT_ADDRESS = 0xC0000285,
        STATUS_MAGAZINE_NOT_PRESENT = 0xC0000286,
        STATUS_REINITIALIZATION_NEEDED = 0xC0000287,
        STATUS_DEVICE_REQUIRES_CLEANING = 0x80000288,
        STATUS_DEVICE_DOOR_OPEN = 0x80000289,
        STATUS_ENCRYPTION_FAILED = 0xC000028A,
        STATUS_DECRYPTION_FAILED = 0xC000028B,
        STATUS_RANGE_NOT_FOUND = 0xC000028C,
        STATUS_NO_RECOVERY_POLICY = 0xC000028D,
        STATUS_NO_EFS = 0xC000028E,
        STATUS_WRONG_EFS = 0xC000028F,
        STATUS_NO_USER_KEYS = 0xC0000290,
        STATUS_FILE_NOT_ENCRYPTED = 0xC0000291,
        STATUS_NOT_EXPORT_FORMAT = 0xC0000292,
        STATUS_FILE_ENCRYPTED = 0xC0000293,
        STATUS_WAKE_SYSTEM = 0x40000294,
        STATUS_WMI_GUID_NOT_FOUND = 0xC0000295,
        STATUS_WMI_INSTANCE_NOT_FOUND = 0xC0000296,
        STATUS_WMI_ITEMID_NOT_FOUND = 0xC0000297,
        STATUS_WMI_TRY_AGAIN = 0xC0000298,
        STATUS_SHARED_POLICY = 0xC0000299,
        STATUS_POLICY_OBJECT_NOT_FOUND = 0xC000029A,
        STATUS_POLICY_ONLY_IN_DS = 0xC000029B,
        STATUS_VOLUME_NOT_UPGRADED = 0xC000029C,
        STATUS_REMOTE_STORAGE_NOT_ACTIVE = 0xC000029D,
        STATUS_REMOTE_STORAGE_MEDIA_ERROR = 0xC000029E,
        STATUS_NO_TRACKING_SERVICE = 0xC000029F,
        STATUS_SERVER_SID_MISMATCH = 0xC00002A0,
        STATUS_DS_NO_ATTRIBUTE_OR_VALUE = 0xC00002A1,
        STATUS_DS_INVALID_ATTRIBUTE_SYNTAX = 0xC00002A2,
        STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED = 0xC00002A3,
        STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS = 0xC00002A4,
        STATUS_DS_BUSY = 0xC00002A5,
        STATUS_DS_UNAVAILABLE = 0xC00002A6,
        STATUS_DS_NO_RIDS_ALLOCATED = 0xC00002A7,
        STATUS_DS_NO_MORE_RIDS = 0xC00002A8,
        STATUS_DS_INCORRECT_ROLE_OWNER = 0xC00002A9,
        STATUS_DS_RIDMGR_INIT_ERROR = 0xC00002AA,
        STATUS_DS_OBJ_CLASS_VIOLATION = 0xC00002AB,
        STATUS_DS_CANT_ON_NON_LEAF = 0xC00002AC,
        STATUS_DS_CANT_ON_RDN = 0xC00002AD,
        STATUS_DS_CANT_MOD_OBJ_CLASS = 0xC00002AE,
        STATUS_DS_CROSS_DOM_MOVE_FAILED = 0xC00002AF,
        STATUS_DS_GC_NOT_AVAILABLE = 0xC00002B0,
        STATUS_DIRECTORY_SERVICE_REQUIRED = 0xC00002B1,
        STATUS_REPARSE_ATTRIBUTE_CONFLICT = 0xC00002B2,
        STATUS_CANT_ENABLE_DENY_ONLY = 0xC00002B3,
        STATUS_FLOAT_MULTIPLE_FAULTS = 0xC00002B4,
        STATUS_FLOAT_MULTIPLE_TRAPS = 0xC00002B5,
        STATUS_DEVICE_REMOVED = 0xC00002B6,
        STATUS_JOURNAL_DELETE_IN_PROGRESS = 0xC00002B7,
        STATUS_JOURNAL_NOT_ACTIVE = 0xC00002B8,
        STATUS_NOINTERFACE = 0xC00002B9,
        STATUS_DS_RIDMGR_DISABLED = 0xC00002BA,
        STATUS_DS_ADMIN_LIMIT_EXCEEDED = 0xC00002C1,
        STATUS_DRIVER_FAILED_SLEEP = 0xC00002C2,
        STATUS_MUTUAL_AUTHENTICATION_FAILED = 0xC00002C3,
        STATUS_CORRUPT_SYSTEM_FILE = 0xC00002C4,
        STATUS_DATATYPE_MISALIGNMENT_ERROR = 0xC00002C5,
        STATUS_WMI_READ_ONLY = 0xC00002C6,
        STATUS_WMI_SET_FAILURE = 0xC00002C7,
        STATUS_COMMITMENT_MINIMUM = 0xC00002C8,
        STATUS_REG_NAT_CONSUMPTION = 0xC00002C9,
        STATUS_TRANSPORT_FULL = 0xC00002CA,
        STATUS_DS_SAM_INIT_FAILURE = 0xC00002CB,
        STATUS_ONLY_IF_CONNECTED = 0xC00002CC,
        STATUS_DS_SENSITIVE_GROUP_VIOLATION = 0xC00002CD,
        STATUS_PNP_RESTART_ENUMERATION = 0xC00002CE,
        STATUS_JOURNAL_ENTRY_DELETED = 0xC00002CF,
        STATUS_DS_CANT_MOD_PRIMARYGROUPID = 0xC00002D0,
        STATUS_SYSTEM_IMAGE_BAD_SIGNATURE = 0xC00002D1,
        STATUS_PNP_REBOOT_REQUIRED = 0xC00002D2,
        STATUS_POWER_STATE_INVALID = 0xC00002D3,
        STATUS_DS_INVALID_GROUP_TYPE = 0xC00002D4,
        STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 0xC00002D5,
        STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 0xC00002D6,
        STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 0xC00002D7,
        STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 0xC00002D8,
        STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 0xC00002D9,
        STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 0xC00002DA,
        STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 0xC00002DB,
        STATUS_DS_HAVE_PRIMARY_MEMBERS = 0xC00002DC,
        STATUS_WMI_NOT_SUPPORTED = 0xC00002DD,
        STATUS_INSUFFICIENT_POWER = 0xC00002DE,
        STATUS_SAM_NEED_BOOTKEY_PASSWORD = 0xC00002DF,
        STATUS_SAM_NEED_BOOTKEY_FLOPPY = 0xC00002E0,
        STATUS_DS_CANT_START = 0xC00002E1,
        STATUS_DS_INIT_FAILURE = 0xC00002E2,
        STATUS_SAM_INIT_FAILURE = 0xC00002E3,
        STATUS_DS_GC_REQUIRED = 0xC00002E4,
        STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 0xC00002E5,
        STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 0xC00002E6,
        STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 0xC00002E7,
        STATUS_MULTIPLE_FAULT_VIOLATION = 0xC00002E8,
        STATUS_CURRENT_DOMAIN_NOT_ALLOWED = 0xC00002E9,
        STATUS_CANNOT_MAKE = 0xC00002EA,
        STATUS_SYSTEM_SHUTDOWN = 0xC00002EB,
        STATUS_DS_INIT_FAILURE_CONSOLE = 0xC00002EC,
        STATUS_DS_SAM_INIT_FAILURE_CONSOLE = 0xC00002ED,
        STATUS_UNFINISHED_CONTEXT_DELETED = 0xC00002EE,
        STATUS_NO_TGT_REPLY = 0xC00002EF,
        STATUS_OBJECTID_NOT_FOUND = 0xC00002F0,
        STATUS_NO_IP_ADDRESSES = 0xC00002F1,
        STATUS_WRONG_CREDENTIAL_HANDLE = 0xC00002F2,
        STATUS_CRYPTO_SYSTEM_INVALID = 0xC00002F3,
        STATUS_MAX_REFERRALS_EXCEEDED = 0xC00002F4,
        STATUS_MUST_BE_KDC = 0xC00002F5,
        STATUS_STRONG_CRYPTO_NOT_SUPPORTED = 0xC00002F6,
        STATUS_TOO_MANY_PRINCIPALS = 0xC00002F7,
        STATUS_NO_PA_DATA = 0xC00002F8,
        STATUS_PKINIT_NAME_MISMATCH = 0xC00002F9,
        STATUS_SMARTCARD_LOGON_REQUIRED = 0xC00002FA,
        STATUS_KDC_INVALID_REQUEST = 0xC00002FB,
        STATUS_KDC_UNABLE_TO_REFER = 0xC00002FC,
        STATUS_KDC_UNKNOWN_ETYPE = 0xC00002FD,
        STATUS_SHUTDOWN_IN_PROGRESS = 0xC00002FE,
        STATUS_SERVER_SHUTDOWN_IN_PROGRESS = 0xC00002FF,
        STATUS_NOT_SUPPORTED_ON_SBS = 0xC0000300,
        STATUS_WMI_GUID_DISCONNECTED = 0xC0000301,
        STATUS_WMI_ALREADY_DISABLED = 0xC0000302,
        STATUS_WMI_ALREADY_ENABLED = 0xC0000303,
        STATUS_MFT_TOO_FRAGMENTED = 0xC0000304,
        STATUS_COPY_PROTECTION_FAILURE = 0xC0000305,
        STATUS_CSS_AUTHENTICATION_FAILURE = 0xC0000306,
        STATUS_CSS_KEY_NOT_PRESENT = 0xC0000307,
        STATUS_CSS_KEY_NOT_ESTABLISHED = 0xC0000308,
        STATUS_CSS_SCRAMBLED_SECTOR = 0xC0000309,
        STATUS_CSS_REGION_MISMATCH = 0xC000030A,
        STATUS_CSS_RESETS_EXHAUSTED = 0xC000030B,
        STATUS_PASSWORD_CHANGE_REQUIRED = 0xC000030C,
        STATUS_PKINIT_FAILURE = 0xC0000320,
        STATUS_SMARTCARD_SUBSYSTEM_FAILURE = 0xC0000321,
        STATUS_NO_KERB_KEY = 0xC0000322,
        STATUS_HOST_DOWN = 0xC0000350,
        STATUS_UNSUPPORTED_PREAUTH = 0xC0000351,
        STATUS_EFS_ALG_BLOB_TOO_BIG = 0xC0000352,
        STATUS_PORT_NOT_SET = 0xC0000353,
        STATUS_DEBUGGER_INACTIVE = 0xC0000354,
        STATUS_DS_VERSION_CHECK_FAILURE = 0xC0000355,
        STATUS_AUDITING_DISABLED = 0xC0000356,
        STATUS_PRENT4_MACHINE_ACCOUNT = 0xC0000357,
        STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 0xC0000358,
        STATUS_INVALID_IMAGE_WIN_32 = 0xC0000359,
        STATUS_INVALID_IMAGE_WIN_64 = 0xC000035A,
        STATUS_BAD_BINDINGS = 0xC000035B,
        STATUS_NETWORK_SESSION_EXPIRED = 0xC000035C,
        STATUS_APPHELP_BLOCK = 0xC000035D,
        STATUS_ALL_SIDS_FILTERED = 0xC000035E,
        STATUS_NOT_SAFE_MODE_DRIVER = 0xC000035F,
        STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT = 0xC0000361,
        STATUS_ACCESS_DISABLED_BY_POLICY_PATH = 0xC0000362,
        STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER = 0xC0000363,
        STATUS_ACCESS_DISABLED_BY_POLICY_OTHER = 0xC0000364,
        STATUS_FAILED_DRIVER_ENTRY = 0xC0000365,
        STATUS_DEVICE_ENUMERATION_ERROR = 0xC0000366,
        STATUS_MOUNT_POINT_NOT_RESOLVED = 0xC0000368,
        STATUS_INVALID_DEVICE_OBJECT_PARAMETER = 0xC0000369,
        STATUS_MCA_OCCURED = 0xC000036A,
        STATUS_DRIVER_BLOCKED_CRITICAL = 0xC000036B,
        STATUS_DRIVER_BLOCKED = 0xC000036C,
        STATUS_DRIVER_DATABASE_ERROR = 0xC000036D,
        STATUS_SYSTEM_HIVE_TOO_LARGE = 0xC000036E,
        STATUS_INVALID_IMPORT_OF_NON_DLL = 0xC000036F,
        STATUS_DS_SHUTTING_DOWN = 0x40000370,
        STATUS_NO_SECRETS = 0xC0000371,
        STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 0xC0000372,
        STATUS_FAILED_STACK_SWITCH = 0xC0000373,
        STATUS_HEAP_CORRUPTION = 0xC0000374,
        STATUS_SMARTCARD_WRONG_PIN = 0xC0000380,
        STATUS_SMARTCARD_CARD_BLOCKED = 0xC0000381,
        STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED = 0xC0000382,
        STATUS_SMARTCARD_NO_CARD = 0xC0000383,
        STATUS_SMARTCARD_NO_KEY_CONTAINER = 0xC0000384,
        STATUS_SMARTCARD_NO_CERTIFICATE = 0xC0000385,
        STATUS_SMARTCARD_NO_KEYSET = 0xC0000386,
        STATUS_SMARTCARD_IO_ERROR = 0xC0000387,
        STATUS_DOWNGRADE_DETECTED = 0xC0000388,
        STATUS_SMARTCARD_CERT_REVOKED = 0xC0000389,
        STATUS_ISSUING_CA_UNTRUSTED = 0xC000038A,
        STATUS_REVOCATION_OFFLINE_C = 0xC000038B,
        STATUS_PKINIT_CLIENT_FAILURE = 0xC000038C,
        STATUS_SMARTCARD_CERT_EXPIRED = 0xC000038D,
        STATUS_DRIVER_FAILED_PRIOR_UNLOAD = 0xC000038E,
        STATUS_SMARTCARD_SILENT_CONTEXT = 0xC000038F,
        STATUS_PER_USER_TRUST_QUOTA_EXCEEDED = 0xC0000401,
        STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED = 0xC0000402,
        STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED = 0xC0000403,
        STATUS_DS_NAME_NOT_UNIQUE = 0xC0000404,
        STATUS_DS_DUPLICATE_ID_FOUND = 0xC0000405,
        STATUS_DS_GROUP_CONVERSION_ERROR = 0xC0000406,
        STATUS_VOLSNAP_PREPARE_HIBERNATE = 0xC0000407,
        STATUS_USER2USER_REQUIRED = 0xC0000408,
        STATUS_STACK_BUFFER_OVERRUN = 0xC0000409,
        STATUS_NO_S4U_PROT_SUPPORT = 0xC000040A,
        STATUS_CROSSREALM_DELEGATION_FAILURE = 0xC000040B,
        STATUS_REVOCATION_OFFLINE_KDC = 0xC000040C,
        STATUS_ISSUING_CA_UNTRUSTED_KDC = 0xC000040D,
        STATUS_KDC_CERT_EXPIRED = 0xC000040E,
        STATUS_KDC_CERT_REVOKED = 0xC000040F,
        STATUS_PARAMETER_QUOTA_EXCEEDED = 0xC0000410,
        STATUS_HIBERNATION_FAILURE = 0xC0000411,
        STATUS_DELAY_LOAD_FAILED = 0xC0000412,
        STATUS_AUTHENTICATION_FIREWALL_FAILED = 0xC0000413,
        STATUS_VDM_DISALLOWED = 0xC0000414,
        STATUS_HUNG_DISPLAY_DRIVER_THREAD = 0xC0000415,
        STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 0xC0000416,
        STATUS_INVALID_CRUNTIME_PARAMETER = 0xC0000417,
        STATUS_NTLM_BLOCKED = 0xC0000418,
        STATUS_DS_SRC_SID_EXISTS_IN_FOREST = 0xC0000419,
        STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 0xC000041A,
        STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST = 0xC000041B,
        STATUS_INVALID_USER_PRINCIPAL_NAME = 0xC000041C,
        STATUS_FATAL_USER_CALLBACK_EXCEPTION = 0xC000041D,
        STATUS_ASSERTION_FAILURE = 0xC0000420,
        STATUS_VERIFIER_STOP = 0xC0000421,
        STATUS_CALLBACK_POP_STACK = 0xC0000423,
        STATUS_INCOMPATIBLE_DRIVER_BLOCKED = 0xC0000424,
        STATUS_HIVE_UNLOADED = 0xC0000425,
        STATUS_COMPRESSION_DISABLED = 0xC0000426,
        STATUS_FILE_SYSTEM_LIMITATION = 0xC0000427,
        STATUS_INVALID_IMAGE_HASH = 0xC0000428,
        STATUS_NOT_CAPABLE = 0xC0000429,
        STATUS_REQUEST_OUT_OF_SEQUENCE = 0xC000042A,
        STATUS_IMPLEMENTATION_LIMIT = 0xC000042B,
        STATUS_ELEVATION_REQUIRED = 0xC000042C,
        STATUS_NO_SECURITY_CONTEXT = 0xC000042D,
        STATUS_PKU2U_CERT_FAILURE = 0xC000042F,
        STATUS_BEYOND_VDL = 0xC0000432,
        STATUS_ENCOUNTERED_WRITE_IN_PROGRESS = 0xC0000433,
        STATUS_PTE_CHANGED = 0xC0000434,
        STATUS_PURGE_FAILED = 0xC0000435,
        STATUS_CRED_REQUIRES_CONFIRMATION = 0xC0000440,
        STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 0xC0000441,
        STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER = 0xC0000442,
        STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 0xC0000443,
        STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 0xC0000444,
        STATUS_CS_ENCRYPTION_FILE_NOT_CSE = 0xC0000445,
        STATUS_INVALID_LABEL = 0xC0000446,
        STATUS_DRIVER_PROCESS_TERMINATED = 0xC0000450,
        STATUS_AMBIGUOUS_SYSTEM_DEVICE = 0xC0000451,
        STATUS_SYSTEM_DEVICE_NOT_FOUND = 0xC0000452,
        STATUS_RESTART_BOOT_APPLICATION = 0xC0000453,
        STATUS_INSUFFICIENT_NVRAM_RESOURCES = 0xC0000454,
        STATUS_INVALID_SESSION = 0xC0000455,
        STATUS_THREAD_ALREADY_IN_SESSION = 0xC0000456,
        STATUS_THREAD_NOT_IN_SESSION = 0xC0000457,
        STATUS_INVALID_WEIGHT = 0xC0000458,
        STATUS_REQUEST_PAUSED = 0xC0000459,
        STATUS_NO_RANGES_PROCESSED = 0xC0000460,
        STATUS_DISK_RESOURCES_EXHAUSTED = 0xC0000461,
        STATUS_NEEDS_REMEDIATION = 0xC0000462,
        STATUS_DEVICE_FEATURE_NOT_SUPPORTED = 0xC0000463,
        STATUS_DEVICE_UNREACHABLE = 0xC0000464,
        STATUS_INVALID_TOKEN = 0xC0000465,
        STATUS_SERVER_UNAVAILABLE = 0xC0000466,
        STATUS_FILE_NOT_AVAILABLE = 0xC0000467,
        STATUS_DEVICE_INSUFFICIENT_RESOURCES = 0xC0000468,
        STATUS_PACKAGE_UPDATING = 0xC0000469,
        STATUS_NOT_READ_FROM_COPY = 0xC000046A,
        STATUS_FT_WRITE_FAILURE = 0xC000046B,
        STATUS_FT_DI_SCAN_REQUIRED = 0xC000046C,
        STATUS_OBJECT_NOT_EXTERNALLY_BACKED = 0xC000046D,
        STATUS_EXTERNAL_BACKING_PROVIDER_UNKNOWN = 0xC000046E,
        STATUS_COMPRESSION_NOT_BENEFICIAL = 0xC000046F,
        STATUS_DATA_CHECKSUM_ERROR = 0xC0000470,
        STATUS_INTERMIXED_KERNEL_EA_OPERATION = 0xC0000471,
        STATUS_TRIM_READ_ZERO_NOT_SUPPORTED = 0xC0000472,
        STATUS_TOO_MANY_SEGMENT_DESCRIPTORS = 0xC0000473,
        STATUS_INVALID_OFFSET_ALIGNMENT = 0xC0000474,
        STATUS_INVALID_FIELD_IN_PARAMETER_LIST = 0xC0000475,
        STATUS_OPERATION_IN_PROGRESS = 0xC0000476,
        STATUS_INVALID_INITIATOR_TARGET_PATH = 0xC0000477,
        STATUS_SCRUB_DATA_DISABLED = 0xC0000478,
        STATUS_NOT_REDUNDANT_STORAGE = 0xC0000479,
        STATUS_RESIDENT_FILE_NOT_SUPPORTED = 0xC000047A,
        STATUS_COMPRESSED_FILE_NOT_SUPPORTED = 0xC000047B,
        STATUS_DIRECTORY_NOT_SUPPORTED = 0xC000047C,
        STATUS_IO_OPERATION_TIMEOUT = 0xC000047D,
        STATUS_SYSTEM_NEEDS_REMEDIATION = 0xC000047E,
        STATUS_APPX_INTEGRITY_FAILURE_CLR_NGEN = 0xC000047F,
        STATUS_SHARE_UNAVAILABLE = 0xC0000480,
        STATUS_APISET_NOT_HOSTED = 0xC0000481,
        STATUS_APISET_NOT_PRESENT = 0xC0000482,
        STATUS_DEVICE_HARDWARE_ERROR = 0xC0000483,
        STATUS_FIRMWARE_SLOT_INVALID = 0xC0000484,
        STATUS_FIRMWARE_IMAGE_INVALID = 0xC0000485,
        STATUS_STORAGE_TOPOLOGY_ID_MISMATCH = 0xC0000486,
        STATUS_WIM_NOT_BOOTABLE = 0xC0000487,
        STATUS_BLOCKED_BY_PARENTAL_CONTROLS = 0xC0000488,
        STATUS_NEEDS_REGISTRATION = 0xC0000489,
        STATUS_QUOTA_ACTIVITY = 0xC000048A,
        STATUS_CALLBACK_INVOKE_INLINE = 0xC000048B,
        STATUS_BLOCK_TOO_MANY_REFERENCES = 0xC000048C,
        STATUS_MARKED_TO_DISALLOW_WRITES = 0xC000048D,
        STATUS_NETWORK_ACCESS_DENIED_EDP = 0xC000048E,
        STATUS_ENCLAVE_FAILURE = 0xC000048F,
        STATUS_PNP_NO_COMPAT_DRIVERS = 0xC0000490,
        STATUS_PNP_DRIVER_PACKAGE_NOT_FOUND = 0xC0000491,
        STATUS_PNP_DRIVER_CONFIGURATION_NOT_FOUND = 0xC0000492,
        STATUS_PNP_DRIVER_CONFIGURATION_INCOMPLETE = 0xC0000493,
        STATUS_PNP_FUNCTION_DRIVER_REQUIRED = 0xC0000494,
        STATUS_PNP_DEVICE_CONFIGURATION_PENDING = 0xC0000495,
        STATUS_DEVICE_HINT_NAME_BUFFER_TOO_SMALL = 0xC0000496,
        STATUS_PACKAGE_NOT_AVAILABLE = 0xC0000497,
        STATUS_DEVICE_IN_MAINTENANCE = 0xC0000499,
        STATUS_NOT_SUPPORTED_ON_DAX = 0xC000049A,
        STATUS_FREE_SPACE_TOO_FRAGMENTED = 0xC000049B,
        STATUS_DAX_MAPPING_EXISTS = 0xC000049C,
        STATUS_CHILD_PROCESS_BLOCKED = 0xC000049D,
        STATUS_STORAGE_LOST_DATA_PERSISTENCE = 0xC000049E,
        STATUS_INVALID_TASK_NAME = 0xC0000500,
        STATUS_INVALID_TASK_INDEX = 0xC0000501,
        STATUS_THREAD_ALREADY_IN_TASK = 0xC0000502,
        STATUS_CALLBACK_BYPASS = 0xC0000503,
        STATUS_UNDEFINED_SCOPE = 0xC0000504,
        STATUS_INVALID_CAP = 0xC0000505,
        STATUS_NOT_GUI_PROCESS = 0xC0000506,
        STATUS_DEVICE_HUNG = 0xC0000507,
        STATUS_CONTAINER_ASSIGNED = 0xC0000508,
        STATUS_JOB_NO_CONTAINER = 0xC0000509,
        STATUS_DEVICE_UNRESPONSIVE = 0xC000050A,
        STATUS_REPARSE_POINT_ENCOUNTERED = 0xC000050B,
        STATUS_FAIL_FAST_EXCEPTION = 0xC0000602,
        STATUS_IMAGE_CERT_REVOKED = 0xC0000603,
        STATUS_DYNAMIC_CODE_BLOCKED = 0xC0000604,
        STATUS_IMAGE_CERT_EXPIRED = 0xC0000605,
        STATUS_PORT_CLOSED = 0xC0000700,
        STATUS_MESSAGE_LOST = 0xC0000701,
        STATUS_INVALID_MESSAGE = 0xC0000702,
        STATUS_REQUEST_CANCELED = 0xC0000703,
        STATUS_RECURSIVE_DISPATCH = 0xC0000704,
        STATUS_LPC_RECEIVE_BUFFER_EXPECTED = 0xC0000705,
        STATUS_LPC_INVALID_CONNECTION_USAGE = 0xC0000706,
        STATUS_LPC_REQUESTS_NOT_ALLOWED = 0xC0000707,
        STATUS_RESOURCE_IN_USE = 0xC0000708,
        STATUS_HARDWARE_MEMORY_ERROR = 0xC0000709,
        STATUS_THREADPOOL_HANDLE_EXCEPTION = 0xC000070A,
        STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED = 0xC000070B,
        STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED = 0xC000070C,
        STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED = 0xC000070D,
        STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED = 0xC000070E,
        STATUS_THREADPOOL_RELEASED_DURING_OPERATION = 0xC000070F,
        STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING = 0xC0000710,
        STATUS_APC_RETURNED_WHILE_IMPERSONATING = 0xC0000711,
        STATUS_PROCESS_IS_PROTECTED = 0xC0000712,
        STATUS_MCA_EXCEPTION = 0xC0000713,
        STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE = 0xC0000714,
        STATUS_SYMLINK_CLASS_DISABLED = 0xC0000715,
        STATUS_INVALID_IDN_NORMALIZATION = 0xC0000716,
        STATUS_NO_UNICODE_TRANSLATION = 0xC0000717,
        STATUS_ALREADY_REGISTERED = 0xC0000718,
        STATUS_CONTEXT_MISMATCH = 0xC0000719,
        STATUS_PORT_ALREADY_HAS_COMPLETION_LIST = 0xC000071A,
        STATUS_CALLBACK_RETURNED_THREAD_PRIORITY = 0xC000071B,
        STATUS_INVALID_THREAD = 0xC000071C,
        STATUS_CALLBACK_RETURNED_TRANSACTION = 0xC000071D,
        STATUS_CALLBACK_RETURNED_LDR_LOCK = 0xC000071E,
        STATUS_CALLBACK_RETURNED_LANG = 0xC000071F,
        STATUS_CALLBACK_RETURNED_PRI_BACK = 0xC0000720,
        STATUS_CALLBACK_RETURNED_THREAD_AFFINITY = 0xC0000721,
        STATUS_LPC_HANDLE_COUNT_EXCEEDED = 0xC0000722,
        STATUS_DISK_REPAIR_DISABLED = 0xC0000800,
        STATUS_DS_DOMAIN_RENAME_IN_PROGRESS = 0xC0000801,
        STATUS_DISK_QUOTA_EXCEEDED = 0xC0000802,
        STATUS_DATA_LOST_REPAIR = 0x80000803,
        STATUS_CONTENT_BLOCKED = 0xC0000804,
        STATUS_BAD_CLUSTERS = 0xC0000805,
        STATUS_VOLUME_DIRTY = 0xC0000806,
        STATUS_DISK_REPAIR_REDIRECTED = 0x40000807,
        STATUS_DISK_REPAIR_UNSUCCESSFUL = 0xC0000808,
        STATUS_CORRUPT_LOG_OVERFULL = 0xC0000809,
        STATUS_CORRUPT_LOG_CORRUPTED = 0xC000080A,
        STATUS_CORRUPT_LOG_UNAVAILABLE = 0xC000080B,
        STATUS_CORRUPT_LOG_DELETED_FULL = 0xC000080C,
        STATUS_CORRUPT_LOG_CLEARED = 0xC000080D,
        STATUS_ORPHAN_NAME_EXHAUSTED = 0xC000080E,
        STATUS_PROACTIVE_SCAN_IN_PROGRESS = 0xC000080F,
        STATUS_ENCRYPTED_IO_NOT_POSSIBLE = 0xC0000810,
        STATUS_CORRUPT_LOG_UPLEVEL_RECORDS = 0xC0000811,
        STATUS_FILE_CHECKED_OUT = 0xC0000901,
        STATUS_CHECKOUT_REQUIRED = 0xC0000902,
        STATUS_BAD_FILE_TYPE = 0xC0000903,
        STATUS_FILE_TOO_LARGE = 0xC0000904,
        STATUS_FORMS_AUTH_REQUIRED = 0xC0000905,
        STATUS_VIRUS_INFECTED = 0xC0000906,
        STATUS_VIRUS_DELETED = 0xC0000907,
        STATUS_BAD_MCFG_TABLE = 0xC0000908,
        STATUS_CANNOT_BREAK_OPLOCK = 0xC0000909,
        STATUS_BAD_KEY = 0xC000090A,
        STATUS_BAD_DATA = 0xC000090B,
        STATUS_NO_KEY = 0xC000090C,
        STATUS_FILE_HANDLE_REVOKED = 0xC0000910,
        STATUS_WOW_ASSERTION = 0xC0009898,
        STATUS_INVALID_SIGNATURE = 0xC000A000,
        STATUS_HMAC_NOT_SUPPORTED = 0xC000A001,
        STATUS_AUTH_TAG_MISMATCH = 0xC000A002,
        STATUS_INVALID_STATE_TRANSITION = 0xC000A003,
        STATUS_INVALID_KERNEL_INFO_VERSION = 0xC000A004,
        STATUS_INVALID_PEP_INFO_VERSION = 0xC000A005,
        STATUS_HANDLE_REVOKED = 0xC000A006,
        STATUS_EOF_ON_GHOSTED_RANGE = 0xC000A007,
        STATUS_IPSEC_QUEUE_OVERFLOW = 0xC000A010,
        STATUS_ND_QUEUE_OVERFLOW = 0xC000A011,
        STATUS_HOPLIMIT_EXCEEDED = 0xC000A012,
        STATUS_PROTOCOL_NOT_SUPPORTED = 0xC000A013,
        STATUS_FASTPATH_REJECTED = 0xC000A014,
        STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 0xC000A080,
        STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 0xC000A081,
        STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = 0xC000A082,
        STATUS_XML_PARSE_ERROR = 0xC000A083,
        STATUS_XMLDSIG_ERROR = 0xC000A084,
        STATUS_WRONG_COMPARTMENT = 0xC000A085,
        STATUS_AUTHIP_FAILURE = 0xC000A086,
        STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = 0xC000A087,
        STATUS_DS_OID_NOT_FOUND = 0xC000A088,
        STATUS_INCORRECT_ACCOUNT_TYPE = 0xC000A089,
        STATUS_HASH_NOT_SUPPORTED = 0xC000A100,
        STATUS_HASH_NOT_PRESENT = 0xC000A101,
        STATUS_SECONDARY_IC_PROVIDER_NOT_REGISTERED = 0xC000A121,
        STATUS_GPIO_CLIENT_INFORMATION_INVALID = 0xC000A122,
        STATUS_GPIO_VERSION_NOT_SUPPORTED = 0xC000A123,
        STATUS_GPIO_INVALID_REGISTRATION_PACKET = 0xC000A124,
        STATUS_GPIO_OPERATION_DENIED = 0xC000A125,
        STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE = 0xC000A126,
        STATUS_GPIO_INTERRUPT_ALREADY_UNMASKED = 0x8000A127,
        STATUS_CANNOT_SWITCH_RUNLEVEL = 0xC000A141,
        STATUS_INVALID_RUNLEVEL_SETTING = 0xC000A142,
        STATUS_RUNLEVEL_SWITCH_TIMEOUT = 0xC000A143,
        STATUS_SERVICES_FAILED_AUTOSTART = 0x4000A144,
        STATUS_RUNLEVEL_SWITCH_AGENT_TIMEOUT = 0xC000A145,
        STATUS_RUNLEVEL_SWITCH_IN_PROGRESS = 0xC000A146,
        STATUS_NOT_APPCONTAINER = 0xC000A200,
        STATUS_NOT_SUPPORTED_IN_APPCONTAINER = 0xC000A201,
        STATUS_INVALID_PACKAGE_SID_LENGTH = 0xC000A202,
        STATUS_APP_DATA_NOT_FOUND = 0xC000A281,
        STATUS_APP_DATA_EXPIRED = 0xC000A282,
        STATUS_APP_DATA_CORRUPT = 0xC000A283,
        STATUS_APP_DATA_LIMIT_EXCEEDED = 0xC000A284,
        STATUS_APP_DATA_REBOOT_REQUIRED = 0xC000A285,
        STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED = 0xC000A2A1,
        STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = 0xC000A2A2,
        STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED = 0xC000A2A3,
        STATUS_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = 0xC000A2A4,
        STATUS_CLOUD_FILE_PROVIDER_UNKNOWN = 0xC000CF00,
        STATUS_CLOUD_FILE_PROVIDER_NOT_RUNNING = 0xC000CF01,
        STATUS_CLOUD_FILE_METADATA_CORRUPT = 0xC000CF02,
        STATUS_CLOUD_FILE_METADATA_TOO_LARGE = 0xC000CF03,
        STATUS_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE = 0x8000CF04,
        STATUS_ACPI_INVALID_OPCODE = 0xC0140001,
        STATUS_ACPI_STACK_OVERFLOW = 0xC0140002,
        STATUS_ACPI_ASSERT_FAILED = 0xC0140003,
        STATUS_ACPI_INVALID_INDEX = 0xC0140004,
        STATUS_ACPI_INVALID_ARGUMENT = 0xC0140005,
        STATUS_ACPI_FATAL = 0xC0140006,
        STATUS_ACPI_INVALID_SUPERNAME = 0xC0140007,
        STATUS_ACPI_INVALID_ARGTYPE = 0xC0140008,
        STATUS_ACPI_INVALID_OBJTYPE = 0xC0140009,
        STATUS_ACPI_INVALID_TARGETTYPE = 0xC014000A,
        STATUS_ACPI_INCORRECT_ARGUMENT_COUNT = 0xC014000B,
        STATUS_ACPI_ADDRESS_NOT_MAPPED = 0xC014000C,
        STATUS_ACPI_INVALID_EVENTTYPE = 0xC014000D,
        STATUS_ACPI_HANDLER_COLLISION = 0xC014000E,
        STATUS_ACPI_INVALID_DATA = 0xC014000F,
        STATUS_ACPI_INVALID_REGION = 0xC0140010,
        STATUS_ACPI_INVALID_ACCESS_SIZE = 0xC0140011,
        STATUS_ACPI_ACQUIRE_GLOBAL_LOCK = 0xC0140012,
        STATUS_ACPI_ALREADY_INITIALIZED = 0xC0140013,
        STATUS_ACPI_NOT_INITIALIZED = 0xC0140014,
        STATUS_ACPI_INVALID_MUTEX_LEVEL = 0xC0140015,
        STATUS_ACPI_MUTEX_NOT_OWNED = 0xC0140016,
        STATUS_ACPI_MUTEX_NOT_OWNER = 0xC0140017,
        STATUS_ACPI_RS_ACCESS = 0xC0140018,
        STATUS_ACPI_INVALID_TABLE = 0xC0140019,
        STATUS_ACPI_REG_HANDLER_FAILED = 0xC0140020,
        STATUS_ACPI_POWER_REQUEST_FAILED = 0xC0140021,
        STATUS_CTX_WINSTATION_NAME_INVALID = 0xC00A0001,
        STATUS_CTX_INVALID_PD = 0xC00A0002,
        STATUS_CTX_PD_NOT_FOUND = 0xC00A0003,
        STATUS_CTX_CDM_CONNECT = 0x400A0004,
        STATUS_CTX_CDM_DISCONNECT = 0x400A0005,
        STATUS_CTX_CLOSE_PENDING = 0xC00A0006,
        STATUS_CTX_NO_OUTBUF = 0xC00A0007,
        STATUS_CTX_MODEM_INF_NOT_FOUND = 0xC00A0008,
        STATUS_CTX_INVALID_MODEMNAME = 0xC00A0009,
        STATUS_CTX_RESPONSE_ERROR = 0xC00A000A,
        STATUS_CTX_MODEM_RESPONSE_TIMEOUT = 0xC00A000B,
        STATUS_CTX_MODEM_RESPONSE_NO_CARRIER = 0xC00A000C,
        STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE = 0xC00A000D,
        STATUS_CTX_MODEM_RESPONSE_BUSY = 0xC00A000E,
        STATUS_CTX_MODEM_RESPONSE_VOICE = 0xC00A000F,
        STATUS_CTX_TD_ERROR = 0xC00A0010,
        STATUS_CTX_LICENSE_CLIENT_INVALID = 0xC00A0012,
        STATUS_CTX_LICENSE_NOT_AVAILABLE = 0xC00A0013,
        STATUS_CTX_LICENSE_EXPIRED = 0xC00A0014,
        STATUS_CTX_WINSTATION_NOT_FOUND = 0xC00A0015,
        STATUS_CTX_WINSTATION_NAME_COLLISION = 0xC00A0016,
        STATUS_CTX_WINSTATION_BUSY = 0xC00A0017,
        STATUS_CTX_BAD_VIDEO_MODE = 0xC00A0018,
        STATUS_CTX_GRAPHICS_INVALID = 0xC00A0022,
        STATUS_CTX_NOT_CONSOLE = 0xC00A0024,
        STATUS_CTX_CLIENT_QUERY_TIMEOUT = 0xC00A0026,
        STATUS_CTX_CONSOLE_DISCONNECT = 0xC00A0027,
        STATUS_CTX_CONSOLE_CONNECT = 0xC00A0028,
        STATUS_CTX_SHADOW_DENIED = 0xC00A002A,
        STATUS_CTX_WINSTATION_ACCESS_DENIED = 0xC00A002B,
        STATUS_CTX_INVALID_WD = 0xC00A002E,
        STATUS_CTX_WD_NOT_FOUND = 0xC00A002F,
        STATUS_CTX_SHADOW_INVALID = 0xC00A0030,
        STATUS_CTX_SHADOW_DISABLED = 0xC00A0031,
        STATUS_RDP_PROTOCOL_ERROR = 0xC00A0032,
        STATUS_CTX_CLIENT_LICENSE_NOT_SET = 0xC00A0033,
        STATUS_CTX_CLIENT_LICENSE_IN_USE = 0xC00A0034,
        STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 0xC00A0035,
        STATUS_CTX_SHADOW_NOT_RUNNING = 0xC00A0036,
        STATUS_CTX_LOGON_DISABLED = 0xC00A0037,
        STATUS_CTX_SECURITY_LAYER_ERROR = 0xC00A0038,
        STATUS_TS_INCOMPATIBLE_SESSIONS = 0xC00A0039,
        STATUS_TS_VIDEO_SUBSYSTEM_ERROR = 0xC00A003A,
        STATUS_PNP_BAD_MPS_TABLE = 0xC0040035,
        STATUS_PNP_TRANSLATION_FAILED = 0xC0040036,
        STATUS_PNP_IRQ_TRANSLATION_FAILED = 0xC0040037,
        STATUS_PNP_INVALID_ID = 0xC0040038,
        STATUS_IO_REISSUE_AS_CACHED = 0xC0040039,
        STATUS_MUI_FILE_NOT_FOUND = 0xC00B0001,
        STATUS_MUI_INVALID_FILE = 0xC00B0002,
        STATUS_MUI_INVALID_RC_CONFIG = 0xC00B0003,
        STATUS_MUI_INVALID_LOCALE_NAME = 0xC00B0004,
        STATUS_MUI_INVALID_ULTIMATEFALLBACK_NAME = 0xC00B0005,
        STATUS_MUI_FILE_NOT_LOADED = 0xC00B0006,
        STATUS_RESOURCE_ENUM_USER_STOP = 0xC00B0007,
        STATUS_FLT_NO_HANDLER_DEFINED = 0xC01C0001,
        STATUS_FLT_CONTEXT_ALREADY_DEFINED = 0xC01C0002,
        STATUS_FLT_INVALID_ASYNCHRONOUS_REQUEST = 0xC01C0003,
        STATUS_FLT_DISALLOW_FAST_IO = 0xC01C0004,
        STATUS_FLT_INVALID_NAME_REQUEST = 0xC01C0005,
        STATUS_FLT_NOT_SAFE_TO_POST_OPERATION = 0xC01C0006,
        STATUS_FLT_NOT_INITIALIZED = 0xC01C0007,
        STATUS_FLT_FILTER_NOT_READY = 0xC01C0008,
        STATUS_FLT_POST_OPERATION_CLEANUP = 0xC01C0009,
        STATUS_FLT_INTERNAL_ERROR = 0xC01C000A,
        STATUS_FLT_DELETING_OBJECT = 0xC01C000B,
        STATUS_FLT_MUST_BE_NONPAGED_POOL = 0xC01C000C,
        STATUS_FLT_DUPLICATE_ENTRY = 0xC01C000D,
        STATUS_FLT_CBDQ_DISABLED = 0xC01C000E,
        STATUS_FLT_DO_NOT_ATTACH = 0xC01C000F,
        STATUS_FLT_DO_NOT_DETACH = 0xC01C0010,
        STATUS_FLT_INSTANCE_ALTITUDE_COLLISION = 0xC01C0011,
        STATUS_FLT_INSTANCE_NAME_COLLISION = 0xC01C0012,
        STATUS_FLT_FILTER_NOT_FOUND = 0xC01C0013,
        STATUS_FLT_VOLUME_NOT_FOUND = 0xC01C0014,
        STATUS_FLT_INSTANCE_NOT_FOUND = 0xC01C0015,
        STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND = 0xC01C0016,
        STATUS_FLT_INVALID_CONTEXT_REGISTRATION = 0xC01C0017,
        STATUS_FLT_NAME_CACHE_MISS = 0xC01C0018,
        STATUS_FLT_NO_DEVICE_OBJECT = 0xC01C0019,
        STATUS_FLT_VOLUME_ALREADY_MOUNTED = 0xC01C001A,
        STATUS_FLT_ALREADY_ENLISTED = 0xC01C001B,
        STATUS_FLT_CONTEXT_ALREADY_LINKED = 0xC01C001C,
        STATUS_FLT_NO_WAITER_FOR_REPLY = 0xC01C0020,
        STATUS_FLT_REGISTRATION_BUSY = 0xC01C0023,
        STATUS_SXS_SECTION_NOT_FOUND = 0xC0150001,
        STATUS_SXS_CANT_GEN_ACTCTX = 0xC0150002,
        STATUS_SXS_INVALID_ACTCTXDATA_FORMAT = 0xC0150003,
        STATUS_SXS_ASSEMBLY_NOT_FOUND = 0xC0150004,
        STATUS_SXS_MANIFEST_FORMAT_ERROR = 0xC0150005,
        STATUS_SXS_MANIFEST_PARSE_ERROR = 0xC0150006,
        STATUS_SXS_ACTIVATION_CONTEXT_DISABLED = 0xC0150007,
        STATUS_SXS_KEY_NOT_FOUND = 0xC0150008,
        STATUS_SXS_VERSION_CONFLICT = 0xC0150009,
        STATUS_SXS_WRONG_SECTION_TYPE = 0xC015000A,
        STATUS_SXS_THREAD_QUERIES_DISABLED = 0xC015000B,
        STATUS_SXS_ASSEMBLY_MISSING = 0xC015000C,
        STATUS_SXS_RELEASE_ACTIVATION_CONTEXT = 0x4015000D,
        STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET = 0xC015000E,
        STATUS_SXS_EARLY_DEACTIVATION = 0xC015000F,
        STATUS_SXS_INVALID_DEACTIVATION = 0xC0150010,
        STATUS_SXS_MULTIPLE_DEACTIVATION = 0xC0150011,
        STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 0xC0150012,
        STATUS_SXS_PROCESS_TERMINATION_REQUESTED = 0xC0150013,
        STATUS_SXS_CORRUPT_ACTIVATION_STACK = 0xC0150014,
        STATUS_SXS_CORRUPTION = 0xC0150015,
        STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 0xC0150016,
        STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 0xC0150017,
        STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 0xC0150018,
        STATUS_SXS_IDENTITY_PARSE_ERROR = 0xC0150019,
        STATUS_SXS_COMPONENT_STORE_CORRUPT = 0xC015001A,
        STATUS_SXS_FILE_HASH_MISMATCH = 0xC015001B,
        STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 0xC015001C,
        STATUS_SXS_IDENTITIES_DIFFERENT = 0xC015001D,
        STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 0xC015001E,
        STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY = 0xC015001F,
        STATUS_ADVANCED_INSTALLER_FAILED = 0xC0150020,
        STATUS_XML_ENCODING_MISMATCH = 0xC0150021,
        STATUS_SXS_MANIFEST_TOO_BIG = 0xC0150022,
        STATUS_SXS_SETTING_NOT_REGISTERED = 0xC0150023,
        STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 0xC0150024,
        STATUS_SMI_PRIMITIVE_INSTALLER_FAILED = 0xC0150025,
        STATUS_GENERIC_COMMAND_FAILED = 0xC0150026,
        STATUS_SXS_FILE_HASH_MISSING = 0xC0150027,
        STATUS_CLUSTER_INVALID_NODE = 0xC0130001,
        STATUS_CLUSTER_NODE_EXISTS = 0xC0130002,
        STATUS_CLUSTER_JOIN_IN_PROGRESS = 0xC0130003,
        STATUS_CLUSTER_NODE_NOT_FOUND = 0xC0130004,
        STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND = 0xC0130005,
        STATUS_CLUSTER_NETWORK_EXISTS = 0xC0130006,
        STATUS_CLUSTER_NETWORK_NOT_FOUND = 0xC0130007,
        STATUS_CLUSTER_NETINTERFACE_EXISTS = 0xC0130008,
        STATUS_CLUSTER_NETINTERFACE_NOT_FOUND = 0xC0130009,
        STATUS_CLUSTER_INVALID_REQUEST = 0xC013000A,
        STATUS_CLUSTER_INVALID_NETWORK_PROVIDER = 0xC013000B,
        STATUS_CLUSTER_NODE_DOWN = 0xC013000C,
        STATUS_CLUSTER_NODE_UNREACHABLE = 0xC013000D,
        STATUS_CLUSTER_NODE_NOT_MEMBER = 0xC013000E,
        STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS = 0xC013000F,
        STATUS_CLUSTER_INVALID_NETWORK = 0xC0130010,
        STATUS_CLUSTER_NO_NET_ADAPTERS = 0xC0130011,
        STATUS_CLUSTER_NODE_UP = 0xC0130012,
        STATUS_CLUSTER_NODE_PAUSED = 0xC0130013,
        STATUS_CLUSTER_NODE_NOT_PAUSED = 0xC0130014,
        STATUS_CLUSTER_NO_SECURITY_CONTEXT = 0xC0130015,
        STATUS_CLUSTER_NETWORK_NOT_INTERNAL = 0xC0130016,
        STATUS_CLUSTER_POISONED = 0xC0130017,
        STATUS_CLUSTER_NON_CSV_PATH = 0xC0130018,
        STATUS_CLUSTER_CSV_VOLUME_NOT_LOCAL = 0xC0130019,
        STATUS_CLUSTER_CSV_READ_OPLOCK_BREAK_IN_PROGRESS = 0xC0130020,
        STATUS_CLUSTER_CSV_AUTO_PAUSE_ERROR = 0xC0130021,
        STATUS_CLUSTER_CSV_REDIRECTED = 0xC0130022,
        STATUS_CLUSTER_CSV_NOT_REDIRECTED = 0xC0130023,
        STATUS_CLUSTER_CSV_VOLUME_DRAINING = 0xC0130024,
        STATUS_CLUSTER_CSV_SNAPSHOT_CREATION_IN_PROGRESS = 0xC0130025,
        STATUS_CLUSTER_CSV_VOLUME_DRAINING_SUCCEEDED_DOWNLEVEL = 0xC0130026,
        STATUS_CLUSTER_CSV_NO_SNAPSHOTS = 0xC0130027,
        STATUS_CSV_IO_PAUSE_TIMEOUT = 0xC0130028,
        STATUS_CLUSTER_CSV_INVALID_HANDLE = 0xC0130029,
        STATUS_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR = 0xC0130030,
        STATUS_TRANSACTIONAL_CONFLICT = 0xC0190001,
        STATUS_INVALID_TRANSACTION = 0xC0190002,
        STATUS_TRANSACTION_NOT_ACTIVE = 0xC0190003,
        STATUS_TM_INITIALIZATION_FAILED = 0xC0190004,
        STATUS_RM_NOT_ACTIVE = 0xC0190005,
        STATUS_RM_METADATA_CORRUPT = 0xC0190006,
        STATUS_TRANSACTION_NOT_JOINED = 0xC0190007,
        STATUS_DIRECTORY_NOT_RM = 0xC0190008,
        STATUS_COULD_NOT_RESIZE_LOG = 0x80190009,
        STATUS_TRANSACTIONS_UNSUPPORTED_REMOTE = 0xC019000A,
        STATUS_LOG_RESIZE_INVALID_SIZE = 0xC019000B,
        STATUS_REMOTE_FILE_VERSION_MISMATCH = 0xC019000C,
        STATUS_CRM_PROTOCOL_ALREADY_EXISTS = 0xC019000F,
        STATUS_TRANSACTION_PROPAGATION_FAILED = 0xC0190010,
        STATUS_CRM_PROTOCOL_NOT_FOUND = 0xC0190011,
        STATUS_TRANSACTION_SUPERIOR_EXISTS = 0xC0190012,
        STATUS_TRANSACTION_REQUEST_NOT_VALID = 0xC0190013,
        STATUS_TRANSACTION_NOT_REQUESTED = 0xC0190014,
        STATUS_TRANSACTION_ALREADY_ABORTED = 0xC0190015,
        STATUS_TRANSACTION_ALREADY_COMMITTED = 0xC0190016,
        STATUS_TRANSACTION_INVALID_MARSHALL_BUFFER = 0xC0190017,
        STATUS_CURRENT_TRANSACTION_NOT_VALID = 0xC0190018,
        STATUS_LOG_GROWTH_FAILED = 0xC0190019,
        STATUS_OBJECT_NO_LONGER_EXISTS = 0xC0190021,
        STATUS_STREAM_MINIVERSION_NOT_FOUND = 0xC0190022,
        STATUS_STREAM_MINIVERSION_NOT_VALID = 0xC0190023,
        STATUS_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = 0xC0190024,
        STATUS_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 0xC0190025,
        STATUS_CANT_CREATE_MORE_STREAM_MINIVERSIONS = 0xC0190026,
        STATUS_HANDLE_NO_LONGER_VALID = 0xC0190028,
        STATUS_NO_TXF_METADATA = 0x80190029,
        STATUS_LOG_CORRUPTION_DETECTED = 0xC0190030,
        STATUS_CANT_RECOVER_WITH_HANDLE_OPEN = 0x80190031,
        STATUS_RM_DISCONNECTED = 0xC0190032,
        STATUS_ENLISTMENT_NOT_SUPERIOR = 0xC0190033,
        STATUS_RECOVERY_NOT_NEEDED = 0x40190034,
        STATUS_RM_ALREADY_STARTED = 0x40190035,
        STATUS_FILE_IDENTITY_NOT_PERSISTENT = 0xC0190036,
        STATUS_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 0xC0190037,
        STATUS_CANT_CROSS_RM_BOUNDARY = 0xC0190038,
        STATUS_TXF_DIR_NOT_EMPTY = 0xC0190039,
        STATUS_INDOUBT_TRANSACTIONS_EXIST = 0xC019003A,
        STATUS_TM_VOLATILE = 0xC019003B,
        STATUS_ROLLBACK_TIMER_EXPIRED = 0xC019003C,
        STATUS_TXF_ATTRIBUTE_CORRUPT = 0xC019003D,
        STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION = 0xC019003E,
        STATUS_TRANSACTIONAL_OPEN_NOT_ALLOWED = 0xC019003F,
        STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 0xC0190040,
        STATUS_TXF_METADATA_ALREADY_PRESENT = 0x80190041,
        STATUS_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = 0x80190042,
        STATUS_TRANSACTION_REQUIRED_PROMOTION = 0xC0190043,
        STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION = 0xC0190044,
        STATUS_TRANSACTIONS_NOT_FROZEN = 0xC0190045,
        STATUS_TRANSACTION_FREEZE_IN_PROGRESS = 0xC0190046,
        STATUS_NOT_SNAPSHOT_VOLUME = 0xC0190047,
        STATUS_NO_SAVEPOINT_WITH_OPEN_FILES = 0xC0190048,
        STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 0xC0190049,
        STATUS_TM_IDENTITY_MISMATCH = 0xC019004A,
        STATUS_FLOATED_SECTION = 0xC019004B,
        STATUS_CANNOT_ACCEPT_TRANSACTED_WORK = 0xC019004C,
        STATUS_CANNOT_ABORT_TRANSACTIONS = 0xC019004D,
        STATUS_TRANSACTION_NOT_FOUND = 0xC019004E,
        STATUS_RESOURCEMANAGER_NOT_FOUND = 0xC019004F,
        STATUS_ENLISTMENT_NOT_FOUND = 0xC0190050,
        STATUS_TRANSACTIONMANAGER_NOT_FOUND = 0xC0190051,
        STATUS_TRANSACTIONMANAGER_NOT_ONLINE = 0xC0190052,
        STATUS_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 0xC0190053,
        STATUS_TRANSACTION_NOT_ROOT = 0xC0190054,
        STATUS_TRANSACTION_OBJECT_EXPIRED = 0xC0190055,
        STATUS_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 0xC0190056,
        STATUS_TRANSACTION_RESPONSE_NOT_ENLISTED = 0xC0190057,
        STATUS_TRANSACTION_RECORD_TOO_LONG = 0xC0190058,
        STATUS_NO_LINK_TRACKING_IN_TRANSACTION = 0xC0190059,
        STATUS_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = 0xC019005A,
        STATUS_TRANSACTION_INTEGRITY_VIOLATED = 0xC019005B,
        STATUS_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 0xC019005C,
        STATUS_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = 0xC019005D,
        STATUS_TRANSACTION_MUST_WRITETHROUGH = 0xC019005E,
        STATUS_TRANSACTION_NO_SUPERIOR = 0xC019005F,
        STATUS_EXPIRED_HANDLE = 0xC0190060,
        STATUS_TRANSACTION_NOT_ENLISTED = 0xC0190061,
        STATUS_LOG_SECTOR_INVALID = 0xC01A0001,
        STATUS_LOG_SECTOR_PARITY_INVALID = 0xC01A0002,
        STATUS_LOG_SECTOR_REMAPPED = 0xC01A0003,
        STATUS_LOG_BLOCK_INCOMPLETE = 0xC01A0004,
        STATUS_LOG_INVALID_RANGE = 0xC01A0005,
        STATUS_LOG_BLOCKS_EXHAUSTED = 0xC01A0006,
        STATUS_LOG_READ_CONTEXT_INVALID = 0xC01A0007,
        STATUS_LOG_RESTART_INVALID = 0xC01A0008,
        STATUS_LOG_BLOCK_VERSION = 0xC01A0009,
        STATUS_LOG_BLOCK_INVALID = 0xC01A000A,
        STATUS_LOG_READ_MODE_INVALID = 0xC01A000B,
        STATUS_LOG_NO_RESTART = 0x401A000C,
        STATUS_LOG_METADATA_CORRUPT = 0xC01A000D,
        STATUS_LOG_METADATA_INVALID = 0xC01A000E,
        STATUS_LOG_METADATA_INCONSISTENT = 0xC01A000F,
        STATUS_LOG_RESERVATION_INVALID = 0xC01A0010,
        STATUS_LOG_CANT_DELETE = 0xC01A0011,
        STATUS_LOG_CONTAINER_LIMIT_EXCEEDED = 0xC01A0012,
        STATUS_LOG_START_OF_LOG = 0xC01A0013,
        STATUS_LOG_POLICY_ALREADY_INSTALLED = 0xC01A0014,
        STATUS_LOG_POLICY_NOT_INSTALLED = 0xC01A0015,
        STATUS_LOG_POLICY_INVALID = 0xC01A0016,
        STATUS_LOG_POLICY_CONFLICT = 0xC01A0017,
        STATUS_LOG_PINNED_ARCHIVE_TAIL = 0xC01A0018,
        STATUS_LOG_RECORD_NONEXISTENT = 0xC01A0019,
        STATUS_LOG_RECORDS_RESERVED_INVALID = 0xC01A001A,
        STATUS_LOG_SPACE_RESERVED_INVALID = 0xC01A001B,
        STATUS_LOG_TAIL_INVALID = 0xC01A001C,
        STATUS_LOG_FULL = 0xC01A001D,
        STATUS_LOG_MULTIPLEXED = 0xC01A001E,
        STATUS_LOG_DEDICATED = 0xC01A001F,
        STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS = 0xC01A0020,
        STATUS_LOG_ARCHIVE_IN_PROGRESS = 0xC01A0021,
        STATUS_LOG_EPHEMERAL = 0xC01A0022,
        STATUS_LOG_NOT_ENOUGH_CONTAINERS = 0xC01A0023,
        STATUS_LOG_CLIENT_ALREADY_REGISTERED = 0xC01A0024,
        STATUS_LOG_CLIENT_NOT_REGISTERED = 0xC01A0025,
        STATUS_LOG_FULL_HANDLER_IN_PROGRESS = 0xC01A0026,
        STATUS_LOG_CONTAINER_READ_FAILED = 0xC01A0027,
        STATUS_LOG_CONTAINER_WRITE_FAILED = 0xC01A0028,
        STATUS_LOG_CONTAINER_OPEN_FAILED = 0xC01A0029,
        STATUS_LOG_CONTAINER_STATE_INVALID = 0xC01A002A,
        STATUS_LOG_STATE_INVALID = 0xC01A002B,
        STATUS_LOG_PINNED = 0xC01A002C,
        STATUS_LOG_METADATA_FLUSH_FAILED = 0xC01A002D,
        STATUS_LOG_INCONSISTENT_SECURITY = 0xC01A002E,
        STATUS_LOG_APPENDED_FLUSH_FAILED = 0xC01A002F,
        STATUS_LOG_PINNED_RESERVATION = 0xC01A0030,
        STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD = 0xC01B00EA,
        STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD_RECOVERED = 0x801B00EB,
        STATUS_VIDEO_DRIVER_DEBUG_REPORT_REQUEST = 0x401B00EC,
        STATUS_MONITOR_NO_DESCRIPTOR = 0xC01D0001,
        STATUS_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = 0xC01D0002,
        STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM = 0xC01D0003,
        STATUS_MONITOR_INVALID_STANDARD_TIMING_BLOCK = 0xC01D0004,
        STATUS_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED = 0xC01D0005,
        STATUS_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = 0xC01D0006,
        STATUS_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = 0xC01D0007,
        STATUS_MONITOR_NO_MORE_DESCRIPTOR_DATA = 0xC01D0008,
        STATUS_MONITOR_INVALID_DETAILED_TIMING_BLOCK = 0xC01D0009,
        STATUS_MONITOR_INVALID_MANUFACTURE_DATE = 0xC01D000A,
        STATUS_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER = 0xC01E0000,
        STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER = 0xC01E0001,
        STATUS_GRAPHICS_INVALID_DISPLAY_ADAPTER = 0xC01E0002,
        STATUS_GRAPHICS_ADAPTER_WAS_RESET = 0xC01E0003,
        STATUS_GRAPHICS_INVALID_DRIVER_MODEL = 0xC01E0004,
        STATUS_GRAPHICS_PRESENT_MODE_CHANGED = 0xC01E0005,
        STATUS_GRAPHICS_PRESENT_OCCLUDED = 0xC01E0006,
        STATUS_GRAPHICS_PRESENT_DENIED = 0xC01E0007,
        STATUS_GRAPHICS_CANNOTCOLORCONVERT = 0xC01E0008,
        STATUS_GRAPHICS_DRIVER_MISMATCH = 0xC01E0009,
        STATUS_GRAPHICS_PARTIAL_DATA_POPULATED = 0x401E000A,
        STATUS_GRAPHICS_PRESENT_REDIRECTION_DISABLED = 0xC01E000B,
        STATUS_GRAPHICS_PRESENT_UNOCCLUDED = 0xC01E000C,
        STATUS_GRAPHICS_WINDOWDC_NOT_AVAILABLE = 0xC01E000D,
        STATUS_GRAPHICS_WINDOWLESS_PRESENT_DISABLED = 0xC01E000E,
        STATUS_GRAPHICS_NO_VIDEO_MEMORY = 0xC01E0100,
        STATUS_GRAPHICS_CANT_LOCK_MEMORY = 0xC01E0101,
        STATUS_GRAPHICS_ALLOCATION_BUSY = 0xC01E0102,
        STATUS_GRAPHICS_TOO_MANY_REFERENCES = 0xC01E0103,
        STATUS_GRAPHICS_TRY_AGAIN_LATER = 0xC01E0104,
        STATUS_GRAPHICS_TRY_AGAIN_NOW = 0xC01E0105,
        STATUS_GRAPHICS_ALLOCATION_INVALID = 0xC01E0106,
        STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = 0xC01E0107,
        STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = 0xC01E0108,
        STATUS_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION = 0xC01E0109,
        STATUS_GRAPHICS_INVALID_ALLOCATION_USAGE = 0xC01E0110,
        STATUS_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION = 0xC01E0111,
        STATUS_GRAPHICS_ALLOCATION_CLOSED = 0xC01E0112,
        STATUS_GRAPHICS_INVALID_ALLOCATION_INSTANCE = 0xC01E0113,
        STATUS_GRAPHICS_INVALID_ALLOCATION_HANDLE = 0xC01E0114,
        STATUS_GRAPHICS_WRONG_ALLOCATION_DEVICE = 0xC01E0115,
        STATUS_GRAPHICS_ALLOCATION_CONTENT_LOST = 0xC01E0116,
        STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE = 0xC01E0200,
        STATUS_GRAPHICS_SKIP_ALLOCATION_PREPARATION = 0x401E0201,
        STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY = 0xC01E0300,
        STATUS_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED = 0xC01E0301,
        STATUS_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = 0xC01E0302,
        STATUS_GRAPHICS_INVALID_VIDPN = 0xC01E0303,
        STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = 0xC01E0304,
        STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = 0xC01E0305,
        STATUS_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED = 0xC01E0306,
        STATUS_GRAPHICS_MODE_NOT_PINNED = 0x401E0307,
        STATUS_GRAPHICS_INVALID_VIDPN_SOURCEMODESET = 0xC01E0308,
        STATUS_GRAPHICS_INVALID_VIDPN_TARGETMODESET = 0xC01E0309,
        STATUS_GRAPHICS_INVALID_FREQUENCY = 0xC01E030A,
        STATUS_GRAPHICS_INVALID_ACTIVE_REGION = 0xC01E030B,
        STATUS_GRAPHICS_INVALID_TOTAL_REGION = 0xC01E030C,
        STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = 0xC01E0310,
        STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = 0xC01E0311,
        STATUS_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET = 0xC01E0312,
        STATUS_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = 0xC01E0313,
        STATUS_GRAPHICS_MODE_ALREADY_IN_MODESET = 0xC01E0314,
        STATUS_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = 0xC01E0315,
        STATUS_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = 0xC01E0316,
        STATUS_GRAPHICS_SOURCE_ALREADY_IN_SET = 0xC01E0317,
        STATUS_GRAPHICS_TARGET_ALREADY_IN_SET = 0xC01E0318,
        STATUS_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = 0xC01E0319,
        STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY = 0xC01E031A,
        STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = 0xC01E031B,
        STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE = 0xC01E031C,
        STATUS_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET = 0xC01E031D,
        STATUS_GRAPHICS_NO_PREFERRED_MODE = 0x401E031E,
        STATUS_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = 0xC01E031F,
        STATUS_GRAPHICS_STALE_MODESET = 0xC01E0320,
        STATUS_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = 0xC01E0321,
        STATUS_GRAPHICS_INVALID_MONITOR_SOURCE_MODE = 0xC01E0322,
        STATUS_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN = 0xC01E0323,
        STATUS_GRAPHICS_MODE_ID_MUST_BE_UNIQUE = 0xC01E0324,
        STATUS_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = 0xC01E0325,
        STATUS_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES = 0xC01E0326,
        STATUS_GRAPHICS_PATH_NOT_IN_TOPOLOGY = 0xC01E0327,
        STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = 0xC01E0328,
        STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = 0xC01E0329,
        STATUS_GRAPHICS_INVALID_MONITORDESCRIPTORSET = 0xC01E032A,
        STATUS_GRAPHICS_INVALID_MONITORDESCRIPTOR = 0xC01E032B,
        STATUS_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET = 0xC01E032C,
        STATUS_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET = 0xC01E032D,
        STATUS_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = 0xC01E032E,
        STATUS_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE = 0xC01E032F,
        STATUS_GRAPHICS_RESOURCES_NOT_RELATED = 0xC01E0330,
        STATUS_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = 0xC01E0331,
        STATUS_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE = 0xC01E0332,
        STATUS_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = 0xC01E0333,
        STATUS_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER = 0xC01E0334,
        STATUS_GRAPHICS_NO_VIDPNMGR = 0xC01E0335,
        STATUS_GRAPHICS_NO_ACTIVE_VIDPN = 0xC01E0336,
        STATUS_GRAPHICS_STALE_VIDPN_TOPOLOGY = 0xC01E0337,
        STATUS_GRAPHICS_MONITOR_NOT_CONNECTED = 0xC01E0338,
        STATUS_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY = 0xC01E0339,
        STATUS_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE = 0xC01E033A,
        STATUS_GRAPHICS_INVALID_VISIBLEREGION_SIZE = 0xC01E033B,
        STATUS_GRAPHICS_INVALID_STRIDE = 0xC01E033C,
        STATUS_GRAPHICS_INVALID_PIXELFORMAT = 0xC01E033D,
        STATUS_GRAPHICS_INVALID_COLORBASIS = 0xC01E033E,
        STATUS_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = 0xC01E033F,
        STATUS_GRAPHICS_TARGET_NOT_IN_TOPOLOGY = 0xC01E0340,
        STATUS_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = 0xC01E0341,
        STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE = 0xC01E0342,
        STATUS_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = 0xC01E0343,
        STATUS_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL = 0xC01E0344,
        STATUS_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = 0xC01E0345,
        STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED = 0xC01E0346,
        STATUS_GRAPHICS_INVALID_GAMMA_RAMP = 0xC01E0347,
        STATUS_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = 0xC01E0348,
        STATUS_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED = 0xC01E0349,
        STATUS_GRAPHICS_MODE_NOT_IN_MODESET = 0xC01E034A,
        STATUS_GRAPHICS_DATASET_IS_EMPTY = 0x401E034B,
        STATUS_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET = 0x401E034C,
        STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON = 0xC01E034D,
        STATUS_GRAPHICS_INVALID_PATH_CONTENT_TYPE = 0xC01E034E,
        STATUS_GRAPHICS_INVALID_COPYPROTECTION_TYPE = 0xC01E034F,
        STATUS_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS = 0xC01E0350,
        STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED = 0x401E0351,
        STATUS_GRAPHICS_INVALID_SCANLINE_ORDERING = 0xC01E0352,
        STATUS_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = 0xC01E0353,
        STATUS_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS = 0xC01E0354,
        STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT = 0xC01E0355,
        STATUS_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM = 0xC01E0356,
        STATUS_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN = 0xC01E0357,
        STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = 0xC01E0358,
        STATUS_GRAPHICS_MAX_NUM_PATHS_REACHED = 0xC01E0359,
        STATUS_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = 0xC01E035A,
        STATUS_GRAPHICS_INVALID_CLIENT_TYPE = 0xC01E035B,
        STATUS_GRAPHICS_CLIENTVIDPN_NOT_SET = 0xC01E035C,
        STATUS_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = 0xC01E0400,
        STATUS_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED = 0xC01E0401,
        STATUS_GRAPHICS_UNKNOWN_CHILD_STATUS = 0x401E042F,
        STATUS_GRAPHICS_NOT_A_LINKED_ADAPTER = 0xC01E0430,
        STATUS_GRAPHICS_LEADLINK_NOT_ENUMERATED = 0xC01E0431,
        STATUS_GRAPHICS_CHAINLINKS_NOT_ENUMERATED = 0xC01E0432,
        STATUS_GRAPHICS_ADAPTER_CHAIN_NOT_READY = 0xC01E0433,
        STATUS_GRAPHICS_CHAINLINKS_NOT_STARTED = 0xC01E0434,
        STATUS_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = 0xC01E0435,
        STATUS_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE = 0xC01E0436,
        STATUS_GRAPHICS_LEADLINK_START_DEFERRED = 0x401E0437,
        STATUS_GRAPHICS_NOT_POST_DEVICE_DRIVER = 0xC01E0438,
        STATUS_GRAPHICS_POLLING_TOO_FREQUENTLY = 0x401E0439,
        STATUS_GRAPHICS_START_DEFERRED = 0x401E043A,
        STATUS_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = 0xC01E043B,
        STATUS_GRAPHICS_DEPENDABLE_CHILD_STATUS = 0x401E043C,
        STATUS_GRAPHICS_OPM_NOT_SUPPORTED = 0xC01E0500,
        STATUS_GRAPHICS_COPP_NOT_SUPPORTED = 0xC01E0501,
        STATUS_GRAPHICS_UAB_NOT_SUPPORTED = 0xC01E0502,
        STATUS_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = 0xC01E0503,
        STATUS_GRAPHICS_OPM_NO_PROTECTED_OUTPUTS_EXIST = 0xC01E0505,
        STATUS_GRAPHICS_OPM_INTERNAL_ERROR = 0xC01E050B,
        STATUS_GRAPHICS_OPM_INVALID_HANDLE = 0xC01E050C,
        STATUS_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH = 0xC01E050E,
        STATUS_GRAPHICS_OPM_SPANNING_MODE_ENABLED = 0xC01E050F,
        STATUS_GRAPHICS_OPM_THEATER_MODE_ENABLED = 0xC01E0510,
        STATUS_GRAPHICS_PVP_HFS_FAILED = 0xC01E0511,
        STATUS_GRAPHICS_OPM_INVALID_SRM = 0xC01E0512,
        STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP = 0xC01E0513,
        STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP = 0xC01E0514,
        STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = 0xC01E0515,
        STATUS_GRAPHICS_OPM_HDCP_SRM_NEVER_SET = 0xC01E0516,
        STATUS_GRAPHICS_OPM_RESOLUTION_TOO_HIGH = 0xC01E0517,
        STATUS_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = 0xC01E0518,
        STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_NO_LONGER_EXISTS = 0xC01E051A,
        STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS = 0xC01E051C,
        STATUS_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST = 0xC01E051D,
        STATUS_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR = 0xC01E051E,
        STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = 0xC01E051F,
        STATUS_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED = 0xC01E0520,
        STATUS_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = 0xC01E0521,
        STATUS_GRAPHICS_I2C_NOT_SUPPORTED = 0xC01E0580,
        STATUS_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST = 0xC01E0581,
        STATUS_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = 0xC01E0582,
        STATUS_GRAPHICS_I2C_ERROR_RECEIVING_DATA = 0xC01E0583,
        STATUS_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED = 0xC01E0584,
        STATUS_GRAPHICS_DDCCI_INVALID_DATA = 0xC01E0585,
        STATUS_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = 0xC01E0586,
        STATUS_GRAPHICS_DDCCI_INVALID_CAPABILITIES_STRING = 0xC01E0587,
        STATUS_GRAPHICS_MCA_INTERNAL_ERROR = 0xC01E0588,
        STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND = 0xC01E0589,
        STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH = 0xC01E058A,
        STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = 0xC01E058B,
        STATUS_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE = 0xC01E058C,
        STATUS_GRAPHICS_MONITOR_NO_LONGER_EXISTS = 0xC01E058D,
        STATUS_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = 0xC01E05E0,
        STATUS_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = 0xC01E05E1,
        STATUS_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = 0xC01E05E2,
        STATUS_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED = 0xC01E05E3,
        STATUS_GRAPHICS_INVALID_POINTER = 0xC01E05E4,
        STATUS_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = 0xC01E05E5,
        STATUS_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL = 0xC01E05E6,
        STATUS_GRAPHICS_INTERNAL_ERROR = 0xC01E05E7,
        STATUS_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = 0xC01E05E8,
        STATUS_FVE_LOCKED_VOLUME = 0xC0210000,
        STATUS_FVE_NOT_ENCRYPTED = 0xC0210001,
        STATUS_FVE_BAD_INFORMATION = 0xC0210002,
        STATUS_FVE_TOO_SMALL = 0xC0210003,
        STATUS_FVE_FAILED_WRONG_FS = 0xC0210004,
        STATUS_FVE_BAD_PARTITION_SIZE = 0xC0210005,
        STATUS_FVE_FS_NOT_EXTENDED = 0xC0210006,
        STATUS_FVE_FS_MOUNTED = 0xC0210007,
        STATUS_FVE_NO_LICENSE = 0xC0210008,
        STATUS_FVE_ACTION_NOT_ALLOWED = 0xC0210009,
        STATUS_FVE_BAD_DATA = 0xC021000A,
        STATUS_FVE_VOLUME_NOT_BOUND = 0xC021000B,
        STATUS_FVE_NOT_DATA_VOLUME = 0xC021000C,
        STATUS_FVE_CONV_READ_ERROR = 0xC021000D,
        STATUS_FVE_CONV_WRITE_ERROR = 0xC021000E,
        STATUS_FVE_OVERLAPPED_UPDATE = 0xC021000F,
        STATUS_FVE_FAILED_SECTOR_SIZE = 0xC0210010,
        STATUS_FVE_FAILED_AUTHENTICATION = 0xC0210011,
        STATUS_FVE_NOT_OS_VOLUME = 0xC0210012,
        STATUS_FVE_KEYFILE_NOT_FOUND = 0xC0210013,
        STATUS_FVE_KEYFILE_INVALID = 0xC0210014,
        STATUS_FVE_KEYFILE_NO_VMK = 0xC0210015,
        STATUS_FVE_TPM_DISABLED = 0xC0210016,
        STATUS_FVE_TPM_SRK_AUTH_NOT_ZERO = 0xC0210017,
        STATUS_FVE_TPM_INVALID_PCR = 0xC0210018,
        STATUS_FVE_TPM_NO_VMK = 0xC0210019,
        STATUS_FVE_PIN_INVALID = 0xC021001A,
        STATUS_FVE_AUTH_INVALID_APPLICATION = 0xC021001B,
        STATUS_FVE_AUTH_INVALID_CONFIG = 0xC021001C,
        STATUS_FVE_DEBUGGER_ENABLED = 0xC021001D,
        STATUS_FVE_DRY_RUN_FAILED = 0xC021001E,
        STATUS_FVE_BAD_METADATA_POINTER = 0xC021001F,
        STATUS_FVE_OLD_METADATA_COPY = 0xC0210020,
        STATUS_FVE_REBOOT_REQUIRED = 0xC0210021,
        STATUS_FVE_RAW_ACCESS = 0xC0210022,
        STATUS_FVE_RAW_BLOCKED = 0xC0210023,
        STATUS_FVE_NO_AUTOUNLOCK_MASTER_KEY = 0xC0210024,
        STATUS_FVE_MOR_FAILED = 0xC0210025,
        STATUS_FVE_NO_FEATURE_LICENSE = 0xC0210026,
        STATUS_FVE_POLICY_USER_DISABLE_RDV_NOT_ALLOWED = 0xC0210027,
        STATUS_FVE_CONV_RECOVERY_FAILED = 0xC0210028,
        STATUS_FVE_VIRTUALIZED_SPACE_TOO_BIG = 0xC0210029,
        STATUS_FVE_INVALID_DATUM_TYPE = 0xC021002A,
        STATUS_FVE_VOLUME_TOO_SMALL = 0xC0210030,
        STATUS_FVE_ENH_PIN_INVALID = 0xC0210031,
        STATUS_FVE_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE = 0xC0210032,
        STATUS_FVE_WIPE_NOT_ALLOWED_ON_TP_STORAGE = 0xC0210033,
        STATUS_FVE_NOT_ALLOWED_ON_CSV_STACK = 0xC0210034,
        STATUS_FVE_NOT_ALLOWED_ON_CLUSTER = 0xC0210035,
        STATUS_FVE_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING = 0xC0210036,
        STATUS_FVE_WIPE_CANCEL_NOT_APPLICABLE = 0xC0210037,
        STATUS_FVE_EDRIVE_DRY_RUN_FAILED = 0xC0210038,
        STATUS_FVE_SECUREBOOT_DISABLED = 0xC0210039,
        STATUS_FVE_SECUREBOOT_CONFIG_CHANGE = 0xC021003A,
        STATUS_FVE_DEVICE_LOCKEDOUT = 0xC021003B,
        STATUS_FVE_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT = 0xC021003C,
        STATUS_FVE_NOT_DE_VOLUME = 0xC021003D,
        STATUS_FVE_PROTECTION_DISABLED = 0xC021003E,
        STATUS_FVE_PROTECTION_CANNOT_BE_DISABLED = 0xC021003F,
        STATUS_FVE_OSV_KSR_NOT_ALLOWED = 0xC0210040,
        STATUS_FWP_CALLOUT_NOT_FOUND = 0xC0220001,
        STATUS_FWP_CONDITION_NOT_FOUND = 0xC0220002,
        STATUS_FWP_FILTER_NOT_FOUND = 0xC0220003,
        STATUS_FWP_LAYER_NOT_FOUND = 0xC0220004,
        STATUS_FWP_PROVIDER_NOT_FOUND = 0xC0220005,
        STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND = 0xC0220006,
        STATUS_FWP_SUBLAYER_NOT_FOUND = 0xC0220007,
        STATUS_FWP_NOT_FOUND = 0xC0220008,
        STATUS_FWP_ALREADY_EXISTS = 0xC0220009,
        STATUS_FWP_IN_USE = 0xC022000A,
        STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS = 0xC022000B,
        STATUS_FWP_WRONG_SESSION = 0xC022000C,
        STATUS_FWP_NO_TXN_IN_PROGRESS = 0xC022000D,
        STATUS_FWP_TXN_IN_PROGRESS = 0xC022000E,
        STATUS_FWP_TXN_ABORTED = 0xC022000F,
        STATUS_FWP_SESSION_ABORTED = 0xC0220010,
        STATUS_FWP_INCOMPATIBLE_TXN = 0xC0220011,
        STATUS_FWP_TIMEOUT = 0xC0220012,
        STATUS_FWP_NET_EVENTS_DISABLED = 0xC0220013,
        STATUS_FWP_INCOMPATIBLE_LAYER = 0xC0220014,
        STATUS_FWP_KM_CLIENTS_ONLY = 0xC0220015,
        STATUS_FWP_LIFETIME_MISMATCH = 0xC0220016,
        STATUS_FWP_BUILTIN_OBJECT = 0xC0220017,
        STATUS_FWP_TOO_MANY_CALLOUTS = 0xC0220018,
        STATUS_FWP_NOTIFICATION_DROPPED = 0xC0220019,
        STATUS_FWP_TRAFFIC_MISMATCH = 0xC022001A,
        STATUS_FWP_INCOMPATIBLE_SA_STATE = 0xC022001B,
        STATUS_FWP_NULL_POINTER = 0xC022001C,
        STATUS_FWP_INVALID_ENUMERATOR = 0xC022001D,
        STATUS_FWP_INVALID_FLAGS = 0xC022001E,
        STATUS_FWP_INVALID_NET_MASK = 0xC022001F,
        STATUS_FWP_INVALID_RANGE = 0xC0220020,
        STATUS_FWP_INVALID_INTERVAL = 0xC0220021,
        STATUS_FWP_ZERO_LENGTH_ARRAY = 0xC0220022,
        STATUS_FWP_NULL_DISPLAY_NAME = 0xC0220023,
        STATUS_FWP_INVALID_ACTION_TYPE = 0xC0220024,
        STATUS_FWP_INVALID_WEIGHT = 0xC0220025,
        STATUS_FWP_MATCH_TYPE_MISMATCH = 0xC0220026,
        STATUS_FWP_TYPE_MISMATCH = 0xC0220027,
        STATUS_FWP_OUT_OF_BOUNDS = 0xC0220028,
        STATUS_FWP_RESERVED = 0xC0220029,
        STATUS_FWP_DUPLICATE_CONDITION = 0xC022002A,
        STATUS_FWP_DUPLICATE_KEYMOD = 0xC022002B,
        STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER = 0xC022002C,
        STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER = 0xC022002D,
        STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER = 0xC022002E,
        STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = 0xC022002F,
        STATUS_FWP_INCOMPATIBLE_AUTH_METHOD = 0xC0220030,
        STATUS_FWP_INCOMPATIBLE_DH_GROUP = 0xC0220031,
        STATUS_FWP_EM_NOT_SUPPORTED = 0xC0220032,
        STATUS_FWP_NEVER_MATCH = 0xC0220033,
        STATUS_FWP_PROVIDER_CONTEXT_MISMATCH = 0xC0220034,
        STATUS_FWP_INVALID_PARAMETER = 0xC0220035,
        STATUS_FWP_TOO_MANY_SUBLAYERS = 0xC0220036,
        STATUS_FWP_CALLOUT_NOTIFICATION_FAILED = 0xC0220037,
        STATUS_FWP_INVALID_AUTH_TRANSFORM = 0xC0220038,
        STATUS_FWP_INVALID_CIPHER_TRANSFORM = 0xC0220039,
        STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM = 0xC022003A,
        STATUS_FWP_INVALID_TRANSFORM_COMBINATION = 0xC022003B,
        STATUS_FWP_DUPLICATE_AUTH_METHOD = 0xC022003C,
        STATUS_FWP_INVALID_TUNNEL_ENDPOINT = 0xC022003D,
        STATUS_FWP_L2_DRIVER_NOT_READY = 0xC022003E,
        STATUS_FWP_KEY_DICTATOR_ALREADY_REGISTERED = 0xC022003F,
        STATUS_FWP_KEY_DICTATION_INVALID_KEYING_MATERIAL = 0xC0220040,
        STATUS_FWP_CONNECTIONS_DISABLED = 0xC0220041,
        STATUS_FWP_INVALID_DNS_NAME = 0xC0220042,
        STATUS_FWP_STILL_ON = 0xC0220043,
        STATUS_FWP_IKEEXT_NOT_RUNNING = 0xC0220044,
        STATUS_FWP_TCPIP_NOT_READY = 0xC0220100,
        STATUS_FWP_INJECT_HANDLE_CLOSING = 0xC0220101,
        STATUS_FWP_INJECT_HANDLE_STALE = 0xC0220102,
        STATUS_FWP_CANNOT_PEND = 0xC0220103,
        STATUS_FWP_DROP_NOICMP = 0xC0220104,
        STATUS_NDIS_CLOSING = 0xC0230002,
        STATUS_NDIS_BAD_VERSION = 0xC0230004,
        STATUS_NDIS_BAD_CHARACTERISTICS = 0xC0230005,
        STATUS_NDIS_ADAPTER_NOT_FOUND = 0xC0230006,
        STATUS_NDIS_OPEN_FAILED = 0xC0230007,
        STATUS_NDIS_DEVICE_FAILED = 0xC0230008,
        STATUS_NDIS_MULTICAST_FULL = 0xC0230009,
        STATUS_NDIS_MULTICAST_EXISTS = 0xC023000A,
        STATUS_NDIS_MULTICAST_NOT_FOUND = 0xC023000B,
        STATUS_NDIS_REQUEST_ABORTED = 0xC023000C,
        STATUS_NDIS_RESET_IN_PROGRESS = 0xC023000D,
        STATUS_NDIS_NOT_SUPPORTED = 0xC02300BB,
        STATUS_NDIS_INVALID_PACKET = 0xC023000F,
        STATUS_NDIS_ADAPTER_NOT_READY = 0xC0230011,
        STATUS_NDIS_INVALID_LENGTH = 0xC0230014,
        STATUS_NDIS_INVALID_DATA = 0xC0230015,
        STATUS_NDIS_BUFFER_TOO_SHORT = 0xC0230016,
        STATUS_NDIS_INVALID_OID = 0xC0230017,
        STATUS_NDIS_ADAPTER_REMOVED = 0xC0230018,
        STATUS_NDIS_UNSUPPORTED_MEDIA = 0xC0230019,
        STATUS_NDIS_GROUP_ADDRESS_IN_USE = 0xC023001A,
        STATUS_NDIS_FILE_NOT_FOUND = 0xC023001B,
        STATUS_NDIS_ERROR_READING_FILE = 0xC023001C,
        STATUS_NDIS_ALREADY_MAPPED = 0xC023001D,
        STATUS_NDIS_RESOURCE_CONFLICT = 0xC023001E,
        STATUS_NDIS_MEDIA_DISCONNECTED = 0xC023001F,
        STATUS_NDIS_INVALID_ADDRESS = 0xC0230022,
        STATUS_NDIS_INVALID_DEVICE_REQUEST = 0xC0230010,
        STATUS_NDIS_PAUSED = 0xC023002A,
        STATUS_NDIS_INTERFACE_NOT_FOUND = 0xC023002B,
        STATUS_NDIS_UNSUPPORTED_REVISION = 0xC023002C,
        STATUS_NDIS_INVALID_PORT = 0xC023002D,
        STATUS_NDIS_INVALID_PORT_STATE = 0xC023002E,
        STATUS_NDIS_LOW_POWER_STATE = 0xC023002F,
        STATUS_NDIS_REINIT_REQUIRED = 0xC0230030,
        STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED = 0xC0232000,
        STATUS_NDIS_DOT11_MEDIA_IN_USE = 0xC0232001,
        STATUS_NDIS_DOT11_POWER_STATE_INVALID = 0xC0232002,
        STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL = 0xC0232003,
        STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = 0xC0232004,
        STATUS_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE = 0xC0232005,
        STATUS_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE = 0xC0232006,
        STATUS_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED = 0xC0232007,
        STATUS_NDIS_DOT11_AP_BAND_NOT_ALLOWED = 0xC0232008,
        STATUS_NDIS_INDICATION_REQUIRED = 0x40230001,
        STATUS_NDIS_OFFLOAD_POLICY = 0xC023100F,
        STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED = 0xC0231012,
        STATUS_NDIS_OFFLOAD_PATH_REJECTED = 0xC0231013,
        STATUS_TPM_ERROR_MASK = 0xC0290000,
        STATUS_TPM_AUTHFAIL = 0xC0290001,
        STATUS_TPM_BADINDEX = 0xC0290002,
        STATUS_TPM_BAD_PARAMETER = 0xC0290003,
        STATUS_TPM_AUDITFAILURE = 0xC0290004,
        STATUS_TPM_CLEAR_DISABLED = 0xC0290005,
        STATUS_TPM_DEACTIVATED = 0xC0290006,
        STATUS_TPM_DISABLED = 0xC0290007,
        STATUS_TPM_DISABLED_CMD = 0xC0290008,
        STATUS_TPM_FAIL = 0xC0290009,
        STATUS_TPM_BAD_ORDINAL = 0xC029000A,
        STATUS_TPM_INSTALL_DISABLED = 0xC029000B,
        STATUS_TPM_INVALID_KEYHANDLE = 0xC029000C,
        STATUS_TPM_KEYNOTFOUND = 0xC029000D,
        STATUS_TPM_INAPPROPRIATE_ENC = 0xC029000E,
        STATUS_TPM_MIGRATEFAIL = 0xC029000F,
        STATUS_TPM_INVALID_PCR_INFO = 0xC0290010,
        STATUS_TPM_NOSPACE = 0xC0290011,
        STATUS_TPM_NOSRK = 0xC0290012,
        STATUS_TPM_NOTSEALED_BLOB = 0xC0290013,
        STATUS_TPM_OWNER_SET = 0xC0290014,
        STATUS_TPM_RESOURCES = 0xC0290015,
        STATUS_TPM_SHORTRANDOM = 0xC0290016,
        STATUS_TPM_SIZE = 0xC0290017,
        STATUS_TPM_WRONGPCRVAL = 0xC0290018,
        STATUS_TPM_BAD_PARAM_SIZE = 0xC0290019,
        STATUS_TPM_SHA_THREAD = 0xC029001A,
        STATUS_TPM_SHA_ERROR = 0xC029001B,
        STATUS_TPM_FAILEDSELFTEST = 0xC029001C,
        STATUS_TPM_AUTH2FAIL = 0xC029001D,
        STATUS_TPM_BADTAG = 0xC029001E,
        STATUS_TPM_IOERROR = 0xC029001F,
        STATUS_TPM_ENCRYPT_ERROR = 0xC0290020,
        STATUS_TPM_DECRYPT_ERROR = 0xC0290021,
        STATUS_TPM_INVALID_AUTHHANDLE = 0xC0290022,
        STATUS_TPM_NO_ENDORSEMENT = 0xC0290023,
        STATUS_TPM_INVALID_KEYUSAGE = 0xC0290024,
        STATUS_TPM_WRONG_ENTITYTYPE = 0xC0290025,
        STATUS_TPM_INVALID_POSTINIT = 0xC0290026,
        STATUS_TPM_INAPPROPRIATE_SIG = 0xC0290027,
        STATUS_TPM_BAD_KEY_PROPERTY = 0xC0290028,
        STATUS_TPM_BAD_MIGRATION = 0xC0290029,
        STATUS_TPM_BAD_SCHEME = 0xC029002A,
        STATUS_TPM_BAD_DATASIZE = 0xC029002B,
        STATUS_TPM_BAD_MODE = 0xC029002C,
        STATUS_TPM_BAD_PRESENCE = 0xC029002D,
        STATUS_TPM_BAD_VERSION = 0xC029002E,
        STATUS_TPM_NO_WRAP_TRANSPORT = 0xC029002F,
        STATUS_TPM_AUDITFAIL_UNSUCCESSFUL = 0xC0290030,
        STATUS_TPM_AUDITFAIL_SUCCESSFUL = 0xC0290031,
        STATUS_TPM_NOTRESETABLE = 0xC0290032,
        STATUS_TPM_NOTLOCAL = 0xC0290033,
        STATUS_TPM_BAD_TYPE = 0xC0290034,
        STATUS_TPM_INVALID_RESOURCE = 0xC0290035,
        STATUS_TPM_NOTFIPS = 0xC0290036,
        STATUS_TPM_INVALID_FAMILY = 0xC0290037,
        STATUS_TPM_NO_NV_PERMISSION = 0xC0290038,
        STATUS_TPM_REQUIRES_SIGN = 0xC0290039,
        STATUS_TPM_KEY_NOTSUPPORTED = 0xC029003A,
        STATUS_TPM_AUTH_CONFLICT = 0xC029003B,
        STATUS_TPM_AREA_LOCKED = 0xC029003C,
        STATUS_TPM_BAD_LOCALITY = 0xC029003D,
        STATUS_TPM_READ_ONLY = 0xC029003E,
        STATUS_TPM_PER_NOWRITE = 0xC029003F,
        STATUS_TPM_FAMILYCOUNT = 0xC0290040,
        STATUS_TPM_WRITE_LOCKED = 0xC0290041,
        STATUS_TPM_BAD_ATTRIBUTES = 0xC0290042,
        STATUS_TPM_INVALID_STRUCTURE = 0xC0290043,
        STATUS_TPM_KEY_OWNER_CONTROL = 0xC0290044,
        STATUS_TPM_BAD_COUNTER = 0xC0290045,
        STATUS_TPM_NOT_FULLWRITE = 0xC0290046,
        STATUS_TPM_CONTEXT_GAP = 0xC0290047,
        STATUS_TPM_MAXNVWRITES = 0xC0290048,
        STATUS_TPM_NOOPERATOR = 0xC0290049,
        STATUS_TPM_RESOURCEMISSING = 0xC029004A,
        STATUS_TPM_DELEGATE_LOCK = 0xC029004B,
        STATUS_TPM_DELEGATE_FAMILY = 0xC029004C,
        STATUS_TPM_DELEGATE_ADMIN = 0xC029004D,
        STATUS_TPM_TRANSPORT_NOTEXCLUSIVE = 0xC029004E,
        STATUS_TPM_OWNER_CONTROL = 0xC029004F,
        STATUS_TPM_DAA_RESOURCES = 0xC0290050,
        STATUS_TPM_DAA_INPUT_DATA0 = 0xC0290051,
        STATUS_TPM_DAA_INPUT_DATA1 = 0xC0290052,
        STATUS_TPM_DAA_ISSUER_SETTINGS = 0xC0290053,
        STATUS_TPM_DAA_TPM_SETTINGS = 0xC0290054,
        STATUS_TPM_DAA_STAGE = 0xC0290055,
        STATUS_TPM_DAA_ISSUER_VALIDITY = 0xC0290056,
        STATUS_TPM_DAA_WRONG_W = 0xC0290057,
        STATUS_TPM_BAD_HANDLE = 0xC0290058,
        STATUS_TPM_BAD_DELEGATE = 0xC0290059,
        STATUS_TPM_BADCONTEXT = 0xC029005A,
        STATUS_TPM_TOOMANYCONTEXTS = 0xC029005B,
        STATUS_TPM_MA_TICKET_SIGNATURE = 0xC029005C,
        STATUS_TPM_MA_DESTINATION = 0xC029005D,
        STATUS_TPM_MA_SOURCE = 0xC029005E,
        STATUS_TPM_MA_AUTHORITY = 0xC029005F,
        STATUS_TPM_PERMANENTEK = 0xC0290061,
        STATUS_TPM_BAD_SIGNATURE = 0xC0290062,
        STATUS_TPM_NOCONTEXTSPACE = 0xC0290063,
        STATUS_TPM_COMMAND_BLOCKED = 0xC0290400,
        STATUS_TPM_INVALID_HANDLE = 0xC0290401,
        STATUS_TPM_DUPLICATE_VHANDLE = 0xC0290402,
        STATUS_TPM_EMBEDDED_COMMAND_BLOCKED = 0xC0290403,
        STATUS_TPM_EMBEDDED_COMMAND_UNSUPPORTED = 0xC0290404,
        STATUS_TPM_RETRY = 0xC0290800,
        STATUS_TPM_NEEDS_SELFTEST = 0xC0290801,
        STATUS_TPM_DOING_SELFTEST = 0xC0290802,
        STATUS_TPM_DEFEND_LOCK_RUNNING = 0xC0290803,
        STATUS_TPM_COMMAND_CANCELED = 0xC0291001,
        STATUS_TPM_TOO_MANY_CONTEXTS = 0xC0291002,
        STATUS_TPM_NOT_FOUND = 0xC0291003,
        STATUS_TPM_ACCESS_DENIED = 0xC0291004,
        STATUS_TPM_INSUFFICIENT_BUFFER = 0xC0291005,
        STATUS_TPM_PPI_FUNCTION_UNSUPPORTED = 0xC0291006,
        STATUS_PCP_ERROR_MASK = 0xC0292000,
        STATUS_PCP_DEVICE_NOT_READY = 0xC0292001,
        STATUS_PCP_INVALID_HANDLE = 0xC0292002,
        STATUS_PCP_INVALID_PARAMETER = 0xC0292003,
        STATUS_PCP_FLAG_NOT_SUPPORTED = 0xC0292004,
        STATUS_PCP_NOT_SUPPORTED = 0xC0292005,
        STATUS_PCP_BUFFER_TOO_SMALL = 0xC0292006,
        STATUS_PCP_INTERNAL_ERROR = 0xC0292007,
        STATUS_PCP_AUTHENTICATION_FAILED = 0xC0292008,
        STATUS_PCP_AUTHENTICATION_IGNORED = 0xC0292009,
        STATUS_PCP_POLICY_NOT_FOUND = 0xC029200A,
        STATUS_PCP_PROFILE_NOT_FOUND = 0xC029200B,
        STATUS_PCP_VALIDATION_FAILED = 0xC029200C,
        STATUS_PCP_DEVICE_NOT_FOUND = 0xC029200D,
        STATUS_RTPM_CONTEXT_CONTINUE = 0x00293000,
        STATUS_RTPM_CONTEXT_COMPLETE = 0x00293001,
        STATUS_RTPM_NO_RESULT = 0xC0293002,
        STATUS_RTPM_PCR_READ_INCOMPLETE = 0xC0293003,
        STATUS_RTPM_INVALID_CONTEXT = 0xC0293004,
        STATUS_RTPM_UNSUPPORTED_CMD = 0xC0293005,
        STATUS_HV_INVALID_HYPERCALL_CODE = 0xC0350002,
        STATUS_HV_INVALID_HYPERCALL_INPUT = 0xC0350003,
        STATUS_HV_INVALID_ALIGNMENT = 0xC0350004,
        STATUS_HV_INVALID_PARAMETER = 0xC0350005,
        STATUS_HV_ACCESS_DENIED = 0xC0350006,
        STATUS_HV_INVALID_PARTITION_STATE = 0xC0350007,
        STATUS_HV_OPERATION_DENIED = 0xC0350008,
        STATUS_HV_UNKNOWN_PROPERTY = 0xC0350009,
        STATUS_HV_PROPERTY_VALUE_OUT_OF_RANGE = 0xC035000A,
        STATUS_HV_INSUFFICIENT_MEMORY = 0xC035000B,
        STATUS_HV_PARTITION_TOO_DEEP = 0xC035000C,
        STATUS_HV_INVALID_PARTITION_ID = 0xC035000D,
        STATUS_HV_INVALID_VP_INDEX = 0xC035000E,
        STATUS_HV_INVALID_PORT_ID = 0xC0350011,
        STATUS_HV_INVALID_CONNECTION_ID = 0xC0350012,
        STATUS_HV_INSUFFICIENT_BUFFERS = 0xC0350013,
        STATUS_HV_NOT_ACKNOWLEDGED = 0xC0350014,
        STATUS_HV_INVALID_VP_STATE = 0xC0350015,
        STATUS_HV_ACKNOWLEDGED = 0xC0350016,
        STATUS_HV_INVALID_SAVE_RESTORE_STATE = 0xC0350017,
        STATUS_HV_INVALID_SYNIC_STATE = 0xC0350018,
        STATUS_HV_OBJECT_IN_USE = 0xC0350019,
        STATUS_HV_INVALID_PROXIMITY_DOMAIN_INFO = 0xC035001A,
        STATUS_HV_NO_DATA = 0xC035001B,
        STATUS_HV_INACTIVE = 0xC035001C,
        STATUS_HV_NO_RESOURCES = 0xC035001D,
        STATUS_HV_FEATURE_UNAVAILABLE = 0xC035001E,
        STATUS_HV_INSUFFICIENT_BUFFER = 0xC0350033,
        STATUS_HV_INSUFFICIENT_DEVICE_DOMAINS = 0xC0350038,
        STATUS_HV_CPUID_FEATURE_VALIDATION_ERROR = 0xC035003C,
        STATUS_HV_CPUID_XSAVE_FEATURE_VALIDATION_ERROR = 0xC035003D,
        STATUS_HV_PROCESSOR_STARTUP_TIMEOUT = 0xC035003E,
        STATUS_HV_SMX_ENABLED = 0xC035003F,
        STATUS_HV_INVALID_LP_INDEX = 0xC0350041,
        STATUS_HV_INVALID_REGISTER_VALUE = 0xC0350050,
        STATUS_HV_INVALID_VTL_STATE = 0xC0350051,
        STATUS_HV_NX_NOT_DETECTED = 0xC0350055,
        STATUS_HV_INVALID_DEVICE_ID = 0xC0350057,
        STATUS_HV_INVALID_DEVICE_STATE = 0xC0350058,
        STATUS_HV_PENDING_PAGE_REQUESTS = 0x00350059,
        STATUS_HV_PAGE_REQUEST_INVALID = 0xC0350060,
        STATUS_HV_INVALID_CPU_GROUP_ID = 0xC035006F,
        STATUS_HV_INVALID_CPU_GROUP_STATE = 0xC0350070,
        STATUS_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE = 0xC0350071,
        STATUS_HV_NOT_PRESENT = 0xC0351000,
        STATUS_VID_DUPLICATE_HANDLER = 0xC0370001,
        STATUS_VID_TOO_MANY_HANDLERS = 0xC0370002,
        STATUS_VID_QUEUE_FULL = 0xC0370003,
        STATUS_VID_HANDLER_NOT_PRESENT = 0xC0370004,
        STATUS_VID_INVALID_OBJECT_NAME = 0xC0370005,
        STATUS_VID_PARTITION_NAME_TOO_LONG = 0xC0370006,
        STATUS_VID_MESSAGE_QUEUE_NAME_TOO_LONG = 0xC0370007,
        STATUS_VID_PARTITION_ALREADY_EXISTS = 0xC0370008,
        STATUS_VID_PARTITION_DOES_NOT_EXIST = 0xC0370009,
        STATUS_VID_PARTITION_NAME_NOT_FOUND = 0xC037000A,
        STATUS_VID_MESSAGE_QUEUE_ALREADY_EXISTS = 0xC037000B,
        STATUS_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = 0xC037000C,
        STATUS_VID_MB_STILL_REFERENCED = 0xC037000D,
        STATUS_VID_CHILD_GPA_PAGE_SET_CORRUPTED = 0xC037000E,
        STATUS_VID_INVALID_NUMA_SETTINGS = 0xC037000F,
        STATUS_VID_INVALID_NUMA_NODE_INDEX = 0xC0370010,
        STATUS_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED = 0xC0370011,
        STATUS_VID_INVALID_MEMORY_BLOCK_HANDLE = 0xC0370012,
        STATUS_VID_PAGE_RANGE_OVERFLOW = 0xC0370013,
        STATUS_VID_INVALID_MESSAGE_QUEUE_HANDLE = 0xC0370014,
        STATUS_VID_INVALID_GPA_RANGE_HANDLE = 0xC0370015,
        STATUS_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE = 0xC0370016,
        STATUS_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = 0xC0370017,
        STATUS_VID_INVALID_PPM_HANDLE = 0xC0370018,
        STATUS_VID_MBPS_ARE_LOCKED = 0xC0370019,
        STATUS_VID_MESSAGE_QUEUE_CLOSED = 0xC037001A,
        STATUS_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED = 0xC037001B,
        STATUS_VID_STOP_PENDING = 0xC037001C,
        STATUS_VID_INVALID_PROCESSOR_STATE = 0xC037001D,
        STATUS_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT = 0xC037001E,
        STATUS_VID_KM_INTERFACE_ALREADY_INITIALIZED = 0xC037001F,
        STATUS_VID_MB_PROPERTY_ALREADY_SET_RESET = 0xC0370020,
        STATUS_VID_MMIO_RANGE_DESTROYED = 0xC0370021,
        STATUS_VID_INVALID_CHILD_GPA_PAGE_SET = 0xC0370022,
        STATUS_VID_RESERVE_PAGE_SET_IS_BEING_USED = 0xC0370023,
        STATUS_VID_RESERVE_PAGE_SET_TOO_SMALL = 0xC0370024,
        STATUS_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE = 0xC0370025,
        STATUS_VID_MBP_COUNT_EXCEEDED_LIMIT = 0xC0370026,
        STATUS_VID_SAVED_STATE_CORRUPT = 0xC0370027,
        STATUS_VID_SAVED_STATE_UNRECOGNIZED_ITEM = 0xC0370028,
        STATUS_VID_SAVED_STATE_INCOMPATIBLE = 0xC0370029,
        STATUS_VID_VTL_ACCESS_DENIED = 0xC037002A,
        STATUS_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED = 0x80370001,
        STATUS_IPSEC_BAD_SPI = 0xC0360001,
        STATUS_IPSEC_SA_LIFETIME_EXPIRED = 0xC0360002,
        STATUS_IPSEC_WRONG_SA = 0xC0360003,
        STATUS_IPSEC_REPLAY_CHECK_FAILED = 0xC0360004,
        STATUS_IPSEC_INVALID_PACKET = 0xC0360005,
        STATUS_IPSEC_INTEGRITY_CHECK_FAILED = 0xC0360006,
        STATUS_IPSEC_CLEAR_TEXT_DROP = 0xC0360007,
        STATUS_IPSEC_AUTH_FIREWALL_DROP = 0xC0360008,
        STATUS_IPSEC_THROTTLE_DROP = 0xC0360009,
        STATUS_IPSEC_DOSP_BLOCK = 0xC0368000,
        STATUS_IPSEC_DOSP_RECEIVED_MULTICAST = 0xC0368001,
        STATUS_IPSEC_DOSP_INVALID_PACKET = 0xC0368002,
        STATUS_IPSEC_DOSP_STATE_LOOKUP_FAILED = 0xC0368003,
        STATUS_IPSEC_DOSP_MAX_ENTRIES = 0xC0368004,
        STATUS_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = 0xC0368005,
        STATUS_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 0xC0368006,
        STATUS_VOLMGR_INCOMPLETE_REGENERATION = 0x80380001,
        STATUS_VOLMGR_INCOMPLETE_DISK_MIGRATION = 0x80380002,
        STATUS_VOLMGR_DATABASE_FULL = 0xC0380001,
        STATUS_VOLMGR_DISK_CONFIGURATION_CORRUPTED = 0xC0380002,
        STATUS_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = 0xC0380003,
        STATUS_VOLMGR_PACK_CONFIG_UPDATE_FAILED = 0xC0380004,
        STATUS_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME = 0xC0380005,
        STATUS_VOLMGR_DISK_DUPLICATE = 0xC0380006,
        STATUS_VOLMGR_DISK_DYNAMIC = 0xC0380007,
        STATUS_VOLMGR_DISK_ID_INVALID = 0xC0380008,
        STATUS_VOLMGR_DISK_INVALID = 0xC0380009,
        STATUS_VOLMGR_DISK_LAST_VOTER = 0xC038000A,
        STATUS_VOLMGR_DISK_LAYOUT_INVALID = 0xC038000B,
        STATUS_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = 0xC038000C,
        STATUS_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED = 0xC038000D,
        STATUS_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL = 0xC038000E,
        STATUS_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = 0xC038000F,
        STATUS_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS = 0xC0380010,
        STATUS_VOLMGR_DISK_MISSING = 0xC0380011,
        STATUS_VOLMGR_DISK_NOT_EMPTY = 0xC0380012,
        STATUS_VOLMGR_DISK_NOT_ENOUGH_SPACE = 0xC0380013,
        STATUS_VOLMGR_DISK_REVECTORING_FAILED = 0xC0380014,
        STATUS_VOLMGR_DISK_SECTOR_SIZE_INVALID = 0xC0380015,
        STATUS_VOLMGR_DISK_SET_NOT_CONTAINED = 0xC0380016,
        STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS = 0xC0380017,
        STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES = 0xC0380018,
        STATUS_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED = 0xC0380019,
        STATUS_VOLMGR_EXTENT_ALREADY_USED = 0xC038001A,
        STATUS_VOLMGR_EXTENT_NOT_CONTIGUOUS = 0xC038001B,
        STATUS_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION = 0xC038001C,
        STATUS_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED = 0xC038001D,
        STATUS_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION = 0xC038001E,
        STATUS_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = 0xC038001F,
        STATUS_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED = 0xC0380020,
        STATUS_VOLMGR_INTERLEAVE_LENGTH_INVALID = 0xC0380021,
        STATUS_VOLMGR_MAXIMUM_REGISTERED_USERS = 0xC0380022,
        STATUS_VOLMGR_MEMBER_IN_SYNC = 0xC0380023,
        STATUS_VOLMGR_MEMBER_INDEX_DUPLICATE = 0xC0380024,
        STATUS_VOLMGR_MEMBER_INDEX_INVALID = 0xC0380025,
        STATUS_VOLMGR_MEMBER_MISSING = 0xC0380026,
        STATUS_VOLMGR_MEMBER_NOT_DETACHED = 0xC0380027,
        STATUS_VOLMGR_MEMBER_REGENERATING = 0xC0380028,
        STATUS_VOLMGR_ALL_DISKS_FAILED = 0xC0380029,
        STATUS_VOLMGR_NO_REGISTERED_USERS = 0xC038002A,
        STATUS_VOLMGR_NO_SUCH_USER = 0xC038002B,
        STATUS_VOLMGR_NOTIFICATION_RESET = 0xC038002C,
        STATUS_VOLMGR_NUMBER_OF_MEMBERS_INVALID = 0xC038002D,
        STATUS_VOLMGR_NUMBER_OF_PLEXES_INVALID = 0xC038002E,
        STATUS_VOLMGR_PACK_DUPLICATE = 0xC038002F,
        STATUS_VOLMGR_PACK_ID_INVALID = 0xC0380030,
        STATUS_VOLMGR_PACK_INVALID = 0xC0380031,
        STATUS_VOLMGR_PACK_NAME_INVALID = 0xC0380032,
        STATUS_VOLMGR_PACK_OFFLINE = 0xC0380033,
        STATUS_VOLMGR_PACK_HAS_QUORUM = 0xC0380034,
        STATUS_VOLMGR_PACK_WITHOUT_QUORUM = 0xC0380035,
        STATUS_VOLMGR_PARTITION_STYLE_INVALID = 0xC0380036,
        STATUS_VOLMGR_PARTITION_UPDATE_FAILED = 0xC0380037,
        STATUS_VOLMGR_PLEX_IN_SYNC = 0xC0380038,
        STATUS_VOLMGR_PLEX_INDEX_DUPLICATE = 0xC0380039,
        STATUS_VOLMGR_PLEX_INDEX_INVALID = 0xC038003A,
        STATUS_VOLMGR_PLEX_LAST_ACTIVE = 0xC038003B,
        STATUS_VOLMGR_PLEX_MISSING = 0xC038003C,
        STATUS_VOLMGR_PLEX_REGENERATING = 0xC038003D,
        STATUS_VOLMGR_PLEX_TYPE_INVALID = 0xC038003E,
        STATUS_VOLMGR_PLEX_NOT_RAID5 = 0xC038003F,
        STATUS_VOLMGR_PLEX_NOT_SIMPLE = 0xC0380040,
        STATUS_VOLMGR_STRUCTURE_SIZE_INVALID = 0xC0380041,
        STATUS_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS = 0xC0380042,
        STATUS_VOLMGR_TRANSACTION_IN_PROGRESS = 0xC0380043,
        STATUS_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE = 0xC0380044,
        STATUS_VOLMGR_VOLUME_CONTAINS_MISSING_DISK = 0xC0380045,
        STATUS_VOLMGR_VOLUME_ID_INVALID = 0xC0380046,
        STATUS_VOLMGR_VOLUME_LENGTH_INVALID = 0xC0380047,
        STATUS_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = 0xC0380048,
        STATUS_VOLMGR_VOLUME_NOT_MIRRORED = 0xC0380049,
        STATUS_VOLMGR_VOLUME_NOT_RETAINED = 0xC038004A,
        STATUS_VOLMGR_VOLUME_OFFLINE = 0xC038004B,
        STATUS_VOLMGR_VOLUME_RETAINED = 0xC038004C,
        STATUS_VOLMGR_NUMBER_OF_EXTENTS_INVALID = 0xC038004D,
        STATUS_VOLMGR_DIFFERENT_SECTOR_SIZE = 0xC038004E,
        STATUS_VOLMGR_BAD_BOOT_DISK = 0xC038004F,
        STATUS_VOLMGR_PACK_CONFIG_OFFLINE = 0xC0380050,
        STATUS_VOLMGR_PACK_CONFIG_ONLINE = 0xC0380051,
        STATUS_VOLMGR_NOT_PRIMARY_PACK = 0xC0380052,
        STATUS_VOLMGR_PACK_LOG_UPDATE_FAILED = 0xC0380053,
        STATUS_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID = 0xC0380054,
        STATUS_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = 0xC0380055,
        STATUS_VOLMGR_VOLUME_MIRRORED = 0xC0380056,
        STATUS_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = 0xC0380057,
        STATUS_VOLMGR_NO_VALID_LOG_COPIES = 0xC0380058,
        STATUS_VOLMGR_PRIMARY_PACK_PRESENT = 0xC0380059,
        STATUS_VOLMGR_NUMBER_OF_DISKS_INVALID = 0xC038005A,
        STATUS_VOLMGR_MIRROR_NOT_SUPPORTED = 0xC038005B,
        STATUS_VOLMGR_RAID5_NOT_SUPPORTED = 0xC038005C,
        STATUS_BCD_NOT_ALL_ENTRIES_IMPORTED = 0x80390001,
        STATUS_BCD_TOO_MANY_ELEMENTS = 0xC0390002,
        STATUS_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED = 0x80390003,
        STATUS_VHD_DRIVE_FOOTER_MISSING = 0xC03A0001,
        STATUS_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = 0xC03A0002,
        STATUS_VHD_DRIVE_FOOTER_CORRUPT = 0xC03A0003,
        STATUS_VHD_FORMAT_UNKNOWN = 0xC03A0004,
        STATUS_VHD_FORMAT_UNSUPPORTED_VERSION = 0xC03A0005,
        STATUS_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH = 0xC03A0006,
        STATUS_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = 0xC03A0007,
        STATUS_VHD_SPARSE_HEADER_CORRUPT = 0xC03A0008,
        STATUS_VHD_BLOCK_ALLOCATION_FAILURE = 0xC03A0009,
        STATUS_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = 0xC03A000A,
        STATUS_VHD_INVALID_BLOCK_SIZE = 0xC03A000B,
        STATUS_VHD_BITMAP_MISMATCH = 0xC03A000C,
        STATUS_VHD_PARENT_VHD_NOT_FOUND = 0xC03A000D,
        STATUS_VHD_CHILD_PARENT_ID_MISMATCH = 0xC03A000E,
        STATUS_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = 0xC03A000F,
        STATUS_VHD_METADATA_READ_FAILURE = 0xC03A0010,
        STATUS_VHD_METADATA_WRITE_FAILURE = 0xC03A0011,
        STATUS_VHD_INVALID_SIZE = 0xC03A0012,
        STATUS_VHD_INVALID_FILE_SIZE = 0xC03A0013,
        STATUS_VIRTDISK_PROVIDER_NOT_FOUND = 0xC03A0014,
        STATUS_VIRTDISK_NOT_VIRTUAL_DISK = 0xC03A0015,
        STATUS_VHD_PARENT_VHD_ACCESS_DENIED = 0xC03A0016,
        STATUS_VHD_CHILD_PARENT_SIZE_MISMATCH = 0xC03A0017,
        STATUS_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = 0xC03A0018,
        STATUS_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = 0xC03A0019,
        STATUS_VIRTUAL_DISK_LIMITATION = 0xC03A001A,
        STATUS_VHD_INVALID_TYPE = 0xC03A001B,
        STATUS_VHD_INVALID_STATE = 0xC03A001C,
        STATUS_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE = 0xC03A001D,
        STATUS_VIRTDISK_DISK_ALREADY_OWNED = 0xC03A001E,
        STATUS_VIRTDISK_DISK_ONLINE_AND_WRITABLE = 0xC03A001F,
        STATUS_CTLOG_TRACKING_NOT_INITIALIZED = 0xC03A0020,
        STATUS_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE = 0xC03A0021,
        STATUS_CTLOG_VHD_CHANGED_OFFLINE = 0xC03A0022,
        STATUS_CTLOG_INVALID_TRACKING_STATE = 0xC03A0023,
        STATUS_CTLOG_INCONSISTENT_TRACKING_FILE = 0xC03A0024,
        STATUS_VHD_METADATA_FULL = 0xC03A0028,
        STATUS_VHD_INVALID_CHANGE_TRACKING_ID = 0xC03A0029,
        STATUS_VHD_CHANGE_TRACKING_DISABLED = 0xC03A002A,
        STATUS_VHD_MISSING_CHANGE_TRACKING_INFORMATION = 0xC03A0030,
        STATUS_VHD_RESIZE_WOULD_TRUNCATE_DATA = 0xC03A0031,
        STATUS_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE = 0xC03A0032,
        STATUS_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE = 0xC03A0033,
        STATUS_QUERY_STORAGE_ERROR = 0x803A0001,
        STATUS_RKF_KEY_NOT_FOUND = 0xC0400001,
        STATUS_RKF_DUPLICATE_KEY = 0xC0400002,
        STATUS_RKF_BLOB_FULL = 0xC0400003,
        STATUS_RKF_STORE_FULL = 0xC0400004,
        STATUS_RKF_FILE_BLOCKED = 0xC0400005,
        STATUS_RKF_ACTIVE_KEY = 0xC0400006,
        STATUS_RDBSS_RESTART_OPERATION = 0xC0410001,
        STATUS_RDBSS_CONTINUE_OPERATION = 0xC0410002,
        STATUS_RDBSS_POST_OPERATION = 0xC0410003,
        STATUS_BTH_ATT_INVALID_HANDLE = 0xC0420001,
        STATUS_BTH_ATT_READ_NOT_PERMITTED = 0xC0420002,
        STATUS_BTH_ATT_WRITE_NOT_PERMITTED = 0xC0420003,
        STATUS_BTH_ATT_INVALID_PDU = 0xC0420004,
        STATUS_BTH_ATT_INSUFFICIENT_AUTHENTICATION = 0xC0420005,
        STATUS_BTH_ATT_REQUEST_NOT_SUPPORTED = 0xC0420006,
        STATUS_BTH_ATT_INVALID_OFFSET = 0xC0420007,
        STATUS_BTH_ATT_INSUFFICIENT_AUTHORIZATION = 0xC0420008,
        STATUS_BTH_ATT_PREPARE_QUEUE_FULL = 0xC0420009,
        STATUS_BTH_ATT_ATTRIBUTE_NOT_FOUND = 0xC042000A,
        STATUS_BTH_ATT_ATTRIBUTE_NOT_LONG = 0xC042000B,
        STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE = 0xC042000C,
        STATUS_BTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH = 0xC042000D,
        STATUS_BTH_ATT_UNLIKELY = 0xC042000E,
        STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION = 0xC042000F,
        STATUS_BTH_ATT_UNSUPPORTED_GROUP_TYPE = 0xC0420010,
        STATUS_BTH_ATT_INSUFFICIENT_RESOURCES = 0xC0420011,
        STATUS_BTH_ATT_UNKNOWN_ERROR = 0xC0421000,
        STATUS_SECUREBOOT_ROLLBACK_DETECTED = 0xC0430001,
        STATUS_SECUREBOOT_POLICY_VIOLATION = 0xC0430002,
        STATUS_SECUREBOOT_INVALID_POLICY = 0xC0430003,
        STATUS_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = 0xC0430004,
        STATUS_SECUREBOOT_POLICY_NOT_SIGNED = 0xC0430005,
        STATUS_SECUREBOOT_NOT_ENABLED = 0x80430006,
        STATUS_SECUREBOOT_FILE_REPLACED = 0xC0430007,
        STATUS_SECUREBOOT_POLICY_NOT_AUTHORIZED = 0xC0430008,
        STATUS_SECUREBOOT_POLICY_UNKNOWN = 0xC0430009,
        STATUS_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION = 0xC043000A,
        STATUS_SECUREBOOT_PLATFORM_ID_MISMATCH = 0xC043000B,
        STATUS_SECUREBOOT_POLICY_ROLLBACK_DETECTED = 0xC043000C,
        STATUS_SECUREBOOT_POLICY_UPGRADE_MISMATCH = 0xC043000D,
        STATUS_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING = 0xC043000E,
        STATUS_SECUREBOOT_NOT_BASE_POLICY = 0xC043000F,
        STATUS_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY = 0xC0430010,
        STATUS_PLATFORM_MANIFEST_NOT_AUTHORIZED = 0xC0EB0001,
        STATUS_PLATFORM_MANIFEST_INVALID = 0xC0EB0002,
        STATUS_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED = 0xC0EB0003,
        STATUS_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED = 0xC0EB0004,
        STATUS_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND = 0xC0EB0005,
        STATUS_PLATFORM_MANIFEST_NOT_ACTIVE = 0xC0EB0006,
        STATUS_PLATFORM_MANIFEST_NOT_SIGNED = 0xC0EB0007,
        STATUS_SYSTEM_INTEGRITY_ROLLBACK_DETECTED = 0xC0E90001,
        STATUS_SYSTEM_INTEGRITY_POLICY_VIOLATION = 0xC0E90002,
        STATUS_SYSTEM_INTEGRITY_INVALID_POLICY = 0xC0E90003,
        STATUS_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED = 0xC0E90004,
        STATUS_NO_APPLICABLE_APP_LICENSES_FOUND = 0xC0EA0001,
        STATUS_CLIP_LICENSE_NOT_FOUND = 0xC0EA0002,
        STATUS_CLIP_DEVICE_LICENSE_MISSING = 0xC0EA0003,
        STATUS_CLIP_LICENSE_INVALID_SIGNATURE = 0xC0EA0004,
        STATUS_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID = 0xC0EA0005,
        STATUS_CLIP_LICENSE_EXPIRED = 0xC0EA0006,
        STATUS_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE = 0xC0EA0007,
        STATUS_CLIP_LICENSE_NOT_SIGNED = 0xC0EA0008,
        STATUS_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE = 0xC0EA0009,
        STATUS_CLIP_LICENSE_DEVICE_ID_MISMATCH = 0xC0EA000A,
        STATUS_AUDIO_ENGINE_NODE_NOT_FOUND = 0xC0440001,
        STATUS_HDAUDIO_EMPTY_CONNECTION_LIST = 0xC0440002,
        STATUS_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED = 0xC0440003,
        STATUS_HDAUDIO_NO_LOGICAL_DEVICES_CREATED = 0xC0440004,
        STATUS_HDAUDIO_NULL_LINKED_LIST_ENTRY = 0xC0440005,
        STATUS_SPACES_REPAIRED = 0x00E70000,
        STATUS_SPACES_PAUSE = 0x00E70001,
        STATUS_SPACES_COMPLETE = 0x00E70002,
        STATUS_SPACES_REDIRECT = 0x00E70003,
        STATUS_SPACES_FAULT_DOMAIN_TYPE_INVALID = 0xC0E70001,
        STATUS_SPACES_RESILIENCY_TYPE_INVALID = 0xC0E70003,
        STATUS_SPACES_DRIVE_SECTOR_SIZE_INVALID = 0xC0E70004,
        STATUS_SPACES_DRIVE_REDUNDANCY_INVALID = 0xC0E70006,
        STATUS_SPACES_NUMBER_OF_DATA_COPIES_INVALID = 0xC0E70007,
        STATUS_SPACES_INTERLEAVE_LENGTH_INVALID = 0xC0E70009,
        STATUS_SPACES_NUMBER_OF_COLUMNS_INVALID = 0xC0E7000A,
        STATUS_SPACES_NOT_ENOUGH_DRIVES = 0xC0E7000B,
        STATUS_SPACES_EXTENDED_ERROR = 0xC0E7000C,
        STATUS_SPACES_PROVISIONING_TYPE_INVALID = 0xC0E7000D,
        STATUS_SPACES_ALLOCATION_SIZE_INVALID = 0xC0E7000E,
        STATUS_SPACES_ENCLOSURE_AWARE_INVALID = 0xC0E7000F,
        STATUS_SPACES_WRITE_CACHE_SIZE_INVALID = 0xC0E70010,
        STATUS_SPACES_NUMBER_OF_GROUPS_INVALID = 0xC0E70011,
        STATUS_SPACES_DRIVE_OPERATIONAL_STATE_INVALID = 0xC0E70012,
        STATUS_SPACES_UPDATE_COLUMN_STATE = 0xC0E70013,
        STATUS_SPACES_MAP_REQUIRED = 0xC0E70014,
        STATUS_SPACES_UNSUPPORTED_VERSION = 0xC0E70015,
        STATUS_SPACES_CORRUPT_METADATA = 0xC0E70016,
        STATUS_SPACES_DRT_FULL = 0xC0E70017,
        STATUS_SPACES_INCONSISTENCY = 0xC0E70018,
        STATUS_SPACES_LOG_NOT_READY = 0xC0E70019,
        STATUS_SPACES_NO_REDUNDANCY = 0xC0E7001A,
        STATUS_SPACES_DRIVE_NOT_READY = 0xC0E7001B,
        STATUS_SPACES_DRIVE_SPLIT = 0xC0E7001C,
        STATUS_SPACES_DRIVE_LOST_DATA = 0xC0E7001D,
        STATUS_VOLSNAP_BOOTFILE_NOT_VALID = 0xC0500003,
        STATUS_VOLSNAP_ACTIVATION_TIMEOUT = 0xC0500004,
        STATUS_IO_PREEMPTED = 0xC0510001,
        STATUS_SVHDX_ERROR_STORED = 0xC05C0000,
        STATUS_SVHDX_ERROR_NOT_AVAILABLE = 0xC05CFF00,
        STATUS_SVHDX_UNIT_ATTENTION_AVAILABLE = 0xC05CFF01,
        STATUS_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED = 0xC05CFF02,
        STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED = 0xC05CFF03,
        STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED = 0xC05CFF04,
        STATUS_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED = 0xC05CFF05,
        STATUS_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED = 0xC05CFF06,
        STATUS_SVHDX_RESERVATION_CONFLICT = 0xC05CFF07,
        STATUS_SVHDX_WRONG_FILE_TYPE = 0xC05CFF08,
        STATUS_SVHDX_VERSION_MISMATCH = 0xC05CFF09,
        STATUS_VHD_SHARED = 0xC05CFF0A,
        STATUS_SVHDX_NO_INITIATOR = 0xC05CFF0B,
        STATUS_VHDSET_BACKING_STORAGE_NOT_FOUND = 0xC05CFF0C,
        STATUS_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP = 0xC05D0000,
        STATUS_SMB_BAD_CLUSTER_DIALECT = 0xC05D0001,
        STATUS_SMB_GUEST_LOGON_BLOCKED = 0xC05D0002,
        STATUS_SECCORE_INVALID_COMMAND = 0xC0E80000,
        STATUS_VSM_NOT_INITIALIZED = 0xC0450000,
        STATUS_VSM_DMA_PROTECTION_NOT_IN_USE = 0xC0450001,
        #endregion

        #region winerror.h codes
        ERROR_SUCCESS = 0,
        ERROR_INVALID_FUNCTION = 1,
        ERROR_FILE_NOT_FOUND = 2,
        ERROR_PATH_NOT_FOUND = 3,
        ERROR_TOO_MANY_OPEN_FILES = 4,
        ERROR_ACCESS_DENIED = 5,
        ERROR_INVALID_HANDLE = 6,
        ERROR_ARENA_TRASHED = 7,
        ERROR_NOT_ENOUGH_MEMORY = 8,
        ERROR_INVALID_BLOCK = 9,
        ERROR_BAD_ENVIRONMENT = 10,
        ERROR_BAD_FORMAT = 11,
        ERROR_INVALID_ACCESS = 12,
        ERROR_INVALID_DATA = 13,
        ERROR_OUTOFMEMORY = 14,
        ERROR_INVALID_DRIVE = 15,
        ERROR_CURRENT_DIRECTORY = 16,
        ERROR_NOT_SAME_DEVICE = 17,
        ERROR_NO_MORE_FILES = 18,
        ERROR_WRITE_PROTECT = 19,
        ERROR_BAD_UNIT = 20,
        ERROR_NOT_READY = 21,
        ERROR_BAD_COMMAND = 22,
        ERROR_CRC = 23,
        ERROR_BAD_LENGTH = 24,
        ERROR_SEEK = 25,
        ERROR_NOT_DOS_DISK = 26,
        ERROR_SECTOR_NOT_FOUND = 27,
        ERROR_OUT_OF_PAPER = 28,
        ERROR_WRITE_FAULT = 29,
        ERROR_READ_FAULT = 30,
        ERROR_GEN_FAILURE = 31,
        ERROR_SHARING_VIOLATION = 32,
        ERROR_LOCK_VIOLATION = 33,
        ERROR_WRONG_DISK = 34,
        ERROR_SHARING_BUFFER_EXCEEDED = 36,
        ERROR_HANDLE_EOF = 38,
        ERROR_HANDLE_DISK_FULL = 39,
        ERROR_NOT_SUPPORTED = 50,
        ERROR_REM_NOT_LIST = 51,
        ERROR_DUP_NAME = 52,
        ERROR_BAD_NETPATH = 53,
        ERROR_NETWORK_BUSY = 54,
        ERROR_DEV_NOT_EXIST = 55,
        ERROR_TOO_MANY_CMDS = 56,
        ERROR_ADAP_HDW_ERR = 57,
        ERROR_BAD_NET_RESP = 58,
        ERROR_UNEXP_NET_ERR = 59,
        ERROR_BAD_REM_ADAP = 60,
        ERROR_PRINTQ_FULL = 61,
        ERROR_NO_SPOOL_SPACE = 62,
        ERROR_PRINT_CANCELLED = 63,
        ERROR_NETNAME_DELETED = 64,
        ERROR_NETWORK_ACCESS_DENIED = 65,
        ERROR_BAD_DEV_TYPE = 66,
        ERROR_BAD_NET_NAME = 67,
        ERROR_TOO_MANY_NAMES = 68,
        ERROR_TOO_MANY_SESS = 69,
        ERROR_SHARING_PAUSED = 70,
        ERROR_REQ_NOT_ACCEP = 71,
        ERROR_REDIR_PAUSED = 72,
        ERROR_FILE_EXISTS = 80,
        ERROR_CANNOT_MAKE = 82,
        ERROR_FAIL_I24 = 83,
        ERROR_OUT_OF_STRUCTURES = 84,
        ERROR_ALREADY_ASSIGNED = 85,
        ERROR_INVALID_PASSWORD = 86,
        ERROR_INVALID_PARAMETER = 87,
        ERROR_NET_WRITE_FAULT = 88,
        ERROR_NO_PROC_SLOTS = 89,
        ERROR_TOO_MANY_SEMAPHORES = 100,
        ERROR_EXCL_SEM_ALREADY_OWNED = 101,
        ERROR_SEM_IS_SET = 102,
        ERROR_TOO_MANY_SEM_REQUESTS = 103,
        ERROR_INVALID_AT_INTERRUPT_TIME = 104,
        ERROR_SEM_OWNER_DIED = 105,
        ERROR_SEM_USER_LIMIT = 106,
        ERROR_DISK_CHANGE = 107,
        ERROR_DRIVE_LOCKED = 108,
        ERROR_BROKEN_PIPE = 109,
        ERROR_OPEN_FAILED = 110,
        ERROR_BUFFER_OVERFLOW = 111,
        ERROR_DISK_FULL = 112,
        ERROR_NO_MORE_SEARCH_HANDLES = 113,
        ERROR_INVALID_TARGET_HANDLE = 114,
        ERROR_INVALID_CATEGORY = 117,
        ERROR_INVALID_VERIFY_SWITCH = 118,
        ERROR_BAD_DRIVER_LEVEL = 119,
        ERROR_CALL_NOT_IMPLEMENTED = 120,
        ERROR_SEM_TIMEOUT = 121,
        ERROR_INSUFFICIENT_BUFFER = 122,
        ERROR_INVALID_NAME = 123,
        ERROR_INVALID_LEVEL = 124,
        ERROR_NO_VOLUME_LABEL = 125,
        ERROR_MOD_NOT_FOUND = 126,
        ERROR_PROC_NOT_FOUND = 127,
        ERROR_WAIT_NO_CHILDREN = 128,
        ERROR_CHILD_NOT_COMPLETE = 129,
        ERROR_DIRECT_ACCESS_HANDLE = 130,
        ERROR_NEGATIVE_SEEK = 131,
        ERROR_SEEK_ON_DEVICE = 132,
        ERROR_IS_JOIN_TARGET = 133,
        ERROR_IS_JOINED = 134,
        ERROR_IS_SUBSTED = 135,
        ERROR_NOT_JOINED = 136,
        ERROR_NOT_SUBSTED = 137,
        ERROR_JOIN_TO_JOIN = 138,
        ERROR_SUBST_TO_SUBST = 139,
        ERROR_JOIN_TO_SUBST = 140,
        ERROR_SUBST_TO_JOIN = 141,
        ERROR_BUSY_DRIVE = 142,
        ERROR_SAME_DRIVE = 143,
        ERROR_DIR_NOT_ROOT = 144,
        ERROR_DIR_NOT_EMPTY = 145,
        ERROR_IS_SUBST_PATH = 146,
        ERROR_IS_JOIN_PATH = 147,
        ERROR_PATH_BUSY = 148,
        ERROR_IS_SUBST_TARGET = 149,
        ERROR_SYSTEM_TRACE = 150,
        ERROR_INVALID_EVENT_COUNT = 151,
        ERROR_TOO_MANY_MUXWAITERS = 152,
        ERROR_INVALID_LIST_FORMAT = 153,
        ERROR_LABEL_TOO_LONG = 154,
        ERROR_TOO_MANY_TCBS = 155,
        ERROR_SIGNAL_REFUSED = 156,
        ERROR_DISCARDED = 157,
        ERROR_NOT_LOCKED = 158,
        ERROR_BAD_THREADID_ADDR = 159,
        ERROR_BAD_ARGUMENTS = 160,
        ERROR_BAD_PATHNAME = 161,
        ERROR_SIGNAL_PENDING = 162,
        ERROR_MAX_THRDS_REACHED = 164,
        ERROR_LOCK_FAILED = 167,
        ERROR_BUSY = 170,
        ERROR_DEVICE_SUPPORT_IN_PROGRESS = 171,
        ERROR_CANCEL_VIOLATION = 173,
        ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 174,
        ERROR_INVALID_SEGMENT_NUMBER = 180,
        ERROR_INVALID_ORDINAL = 182,
        ERROR_ALREADY_EXISTS = 183,
        ERROR_INVALID_FLAG_NUMBER = 186,
        ERROR_SEM_NOT_FOUND = 187,
        ERROR_INVALID_STARTING_CODESEG = 188,
        ERROR_INVALID_STACKSEG = 189,
        ERROR_INVALID_MODULETYPE = 190,
        ERROR_INVALID_EXE_SIGNATURE = 191,
        ERROR_EXE_MARKED_INVALID = 192,
        ERROR_BAD_EXE_FORMAT = 193,
        ERROR_ITERATED_DATA_EXCEEDS_64k = 194,
        ERROR_INVALID_MINALLOCSIZE = 195,
        ERROR_DYNLINK_FROM_INVALID_RING = 196,
        ERROR_IOPL_NOT_ENABLED = 197,
        ERROR_INVALID_SEGDPL = 198,
        ERROR_AUTODATASEG_EXCEEDS_64k = 199,
        ERROR_RING2SEG_MUST_BE_MOVABLE = 200,
        ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 201,
        ERROR_INFLOOP_IN_RELOC_CHAIN = 202,
        ERROR_ENVVAR_NOT_FOUND = 203,
        ERROR_NO_SIGNAL_SENT = 205,
        ERROR_FILENAME_EXCED_RANGE = 206,
        ERROR_RING2_STACK_IN_USE = 207,
        ERROR_META_EXPANSION_TOO_LONG = 208,
        ERROR_INVALID_SIGNAL_NUMBER = 209,
        ERROR_THREAD_1_INACTIVE = 210,
        ERROR_LOCKED = 212,
        ERROR_TOO_MANY_MODULES = 214,
        ERROR_NESTING_NOT_ALLOWED = 215,
        ERROR_EXE_MACHINE_TYPE_MISMATCH = 216,
        ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = 217,
        ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = 218,
        ERROR_FILE_CHECKED_OUT = 220,
        ERROR_CHECKOUT_REQUIRED = 221,
        ERROR_BAD_FILE_TYPE = 222,
        ERROR_FILE_TOO_LARGE = 223,
        ERROR_FORMS_AUTH_REQUIRED = 224,
        ERROR_VIRUS_INFECTED = 225,
        ERROR_VIRUS_DELETED = 226,
        ERROR_PIPE_LOCAL = 229,
        ERROR_BAD_PIPE = 230,
        ERROR_PIPE_BUSY = 231,
        ERROR_NO_DATA = 232,
        ERROR_PIPE_NOT_CONNECTED = 233,
        ERROR_MORE_DATA = 234,
        ERROR_NO_WORK_DONE = 235,
        ERROR_VC_DISCONNECTED = 240,
        ERROR_INVALID_EA_NAME = 254,
        ERROR_EA_LIST_INCONSISTENT = 255,
        WAIT_TIMEOUT = 258,
        ERROR_NO_MORE_ITEMS = 259,
        ERROR_CANNOT_COPY = 266,
        ERROR_DIRECTORY = 267,
        ERROR_EAS_DIDNT_FIT = 275,
        ERROR_EA_FILE_CORRUPT = 276,
        ERROR_EA_TABLE_FULL = 277,
        ERROR_INVALID_EA_HANDLE = 278,
        ERROR_EAS_NOT_SUPPORTED = 282,
        ERROR_NOT_OWNER = 288,
        ERROR_TOO_MANY_POSTS = 298,
        ERROR_PARTIAL_COPY = 299,
        ERROR_OPLOCK_NOT_GRANTED = 300,
        ERROR_INVALID_OPLOCK_PROTOCOL = 301,
        ERROR_DISK_TOO_FRAGMENTED = 302,
        ERROR_DELETE_PENDING = 303,
        ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 304,
        ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 305,
        ERROR_SECURITY_STREAM_IS_INCONSISTENT = 306,
        ERROR_INVALID_LOCK_RANGE = 307,
        ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = 308,
        ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = 309,
        ERROR_INVALID_EXCEPTION_HANDLER = 310,
        ERROR_DUPLICATE_PRIVILEGES = 311,
        ERROR_NO_RANGES_PROCESSED = 312,
        ERROR_NOT_ALLOWED_ON_SYSTEM_FILE = 313,
        ERROR_DISK_RESOURCES_EXHAUSTED = 314,
        ERROR_INVALID_TOKEN = 315,
        ERROR_DEVICE_FEATURE_NOT_SUPPORTED = 316,
        ERROR_MR_MID_NOT_FOUND = 317,
        ERROR_SCOPE_NOT_FOUND = 318,
        ERROR_UNDEFINED_SCOPE = 319,
        ERROR_INVALID_CAP = 320,
        ERROR_DEVICE_UNREACHABLE = 321,
        ERROR_DEVICE_NO_RESOURCES = 322,
        ERROR_DATA_CHECKSUM_ERROR = 323,
        ERROR_INTERMIXED_KERNEL_EA_OPERATION = 324,
        ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED = 326,
        ERROR_OFFSET_ALIGNMENT_VIOLATION = 327,
        ERROR_INVALID_FIELD_IN_PARAMETER_LIST = 328,
        ERROR_OPERATION_IN_PROGRESS = 329,
        ERROR_BAD_DEVICE_PATH = 330,
        ERROR_TOO_MANY_DESCRIPTORS = 331,
        ERROR_SCRUB_DATA_DISABLED = 332,
        ERROR_NOT_REDUNDANT_STORAGE = 333,
        ERROR_RESIDENT_FILE_NOT_SUPPORTED = 334,
        ERROR_COMPRESSED_FILE_NOT_SUPPORTED = 335,
        ERROR_DIRECTORY_NOT_SUPPORTED = 336,
        ERROR_NOT_READ_FROM_COPY = 337,
        ERROR_FT_WRITE_FAILURE = 338,
        ERROR_FT_DI_SCAN_REQUIRED = 339,
        ERROR_INVALID_KERNEL_INFO_VERSION = 340,
        ERROR_INVALID_PEP_INFO_VERSION = 341,
        ERROR_OBJECT_NOT_EXTERNALLY_BACKED = 342,
        ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN = 343,
        ERROR_COMPRESSION_NOT_BENEFICIAL = 344,
        ERROR_STORAGE_TOPOLOGY_ID_MISMATCH = 345,
        ERROR_BLOCKED_BY_PARENTAL_CONTROLS = 346,
        ERROR_BLOCK_TOO_MANY_REFERENCES = 347,
        ERROR_MARKED_TO_DISALLOW_WRITES = 348,
        ERROR_ENCLAVE_FAILURE = 349,
        ERROR_FAIL_NOACTION_REBOOT = 350,
        ERROR_FAIL_SHUTDOWN = 351,
        ERROR_FAIL_RESTART = 352,
        ERROR_MAX_SESSIONS_REACHED = 353,
        ERROR_NETWORK_ACCESS_DENIED_EDP = 354,
        ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL = 355,
        ERROR_EDP_POLICY_DENIES_OPERATION = 356,
        ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED = 357,
        ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT = 358,
        ERROR_DEVICE_IN_MAINTENANCE = 359,
        ERROR_NOT_SUPPORTED_ON_DAX = 360,
        ERROR_DAX_MAPPING_EXISTS = 361,
        ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING = 362,
        ERROR_CLOUD_FILE_METADATA_CORRUPT = 363,
        ERROR_CLOUD_FILE_METADATA_TOO_LARGE = 364,
        ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE = 365,
        ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH = 366,
        ERROR_CHILD_PROCESS_BLOCKED = 367,
        ERROR_STORAGE_LOST_DATA_PERSISTENCE = 368,
        ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE = 369,
        ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT = 370,
        ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY = 371,
        ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN = 372,
        ERROR_GDI_HANDLE_LEAK = 373,
        ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS = 374,
        ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED = 375,
        ERROR_NOT_A_CLOUD_FILE = 376,
        ERROR_CLOUD_FILE_NOT_IN_SYNC = 377,
        ERROR_CLOUD_FILE_ALREADY_CONNECTED = 378,
        ERROR_CLOUD_FILE_NOT_SUPPORTED = 379,
        ERROR_CLOUD_FILE_INVALID_REQUEST = 380,
        ERROR_CLOUD_FILE_READ_ONLY_VOLUME = 381,
        ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY = 382,
        ERROR_CLOUD_FILE_VALIDATION_FAILED = 383,
        ERROR_SMB1_NOT_AVAILABLE = 384,
        ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION = 385,
        ERROR_CLOUD_FILE_AUTHENTICATION_FAILED = 386,
        ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES = 387,
        ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE = 388,
        ERROR_CLOUD_FILE_UNSUCCESSFUL = 389,
        ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT = 390,
        ERROR_CLOUD_FILE_IN_USE = 391,
        ERROR_CLOUD_FILE_PINNED = 392,
        ERROR_CLOUD_FILE_REQUEST_ABORTED = 393,
        ERROR_CLOUD_FILE_PROPERTY_CORRUPT = 394,
        ERROR_CLOUD_FILE_ACCESS_DENIED = 395,
        ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS = 396,
        ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT = 397,
        ERROR_CLOUD_FILE_REQUEST_CANCELED = 398,
        ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED = 399,
        ERROR_THREAD_MODE_ALREADY_BACKGROUND = 400,
        ERROR_THREAD_MODE_NOT_BACKGROUND = 401,
        ERROR_PROCESS_MODE_ALREADY_BACKGROUND = 402,
        ERROR_PROCESS_MODE_NOT_BACKGROUND = 403,
        ERROR_CLOUD_FILE_PROVIDER_TERMINATED = 404,
        ERROR_NOT_A_CLOUD_SYNC_ROOT = 405,
        ERROR_FILE_PROTECTED_UNDER_DPL = 406,
        ERROR_VOLUME_NOT_CLUSTER_ALIGNED = 407,
        ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND = 408,
        ERROR_APPX_FILE_NOT_ENCRYPTED = 409,
        ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED = 410,
        ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET = 411,
        ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE = 412,
        ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER = 413,
        ERROR_LINUX_SUBSYSTEM_NOT_PRESENT = 414,
        ERROR_FT_READ_FAILURE = 415,
        ERROR_STORAGE_RESERVE_ID_INVALID = 416,
        ERROR_STORAGE_RESERVE_DOES_NOT_EXIST = 417,
        ERROR_STORAGE_RESERVE_ALREADY_EXISTS = 418,
        ERROR_STORAGE_RESERVE_NOT_EMPTY = 419,
        ERROR_NOT_A_DAX_VOLUME = 420,
        ERROR_NOT_DAX_MAPPABLE = 421,
        ERROR_TIME_SENSITIVE_THREAD = 422,
        ERROR_DPL_NOT_SUPPORTED_FOR_USER = 423,
        ERROR_CASE_DIFFERING_NAMES_IN_DIR = 424,
        ERROR_FILE_NOT_SUPPORTED = 425,
        ERROR_CLOUD_FILE_REQUEST_TIMEOUT = 426,
        ERROR_NO_TASK_QUEUE = 427,
        ERROR_SRC_SRV_DLL_LOAD_FAILED = 428,
        ERROR_NOT_SUPPORTED_WITH_BTT = 429,
        ERROR_ENCRYPTION_DISABLED = 430,
        ERROR_ENCRYPTING_METADATA_DISALLOWED = 431,
        ERROR_CANT_CLEAR_ENCRYPTION_FLAG = 432,
        ERROR_NO_SUCH_DEVICE = 433,
        ERROR_CAPAUTHZ_NOT_DEVUNLOCKED = 450,
        ERROR_CAPAUTHZ_CHANGE_TYPE = 451,
        ERROR_CAPAUTHZ_NOT_PROVISIONED = 452,
        ERROR_CAPAUTHZ_NOT_AUTHORIZED = 453,
        ERROR_CAPAUTHZ_NO_POLICY = 454,
        ERROR_CAPAUTHZ_DB_CORRUPTED = 455,
        ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG = 456,
        ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY = 457,
        ERROR_CAPAUTHZ_SCCD_PARSE_ERROR = 458,
        ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED = 459,
        ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH = 460,
        ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT = 480,
        ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT = 481,
        ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT = 482,
        ERROR_DEVICE_HARDWARE_ERROR = 483,
        ERROR_INVALID_ADDRESS = 487,
        ERROR_VRF_CFG_ENABLED = 1183,
        ERROR_PARTITION_TERMINATING = 1184,
        ERROR_USER_PROFILE_LOAD = 500,
        ERROR_ARITHMETIC_OVERFLOW = 534,
        ERROR_PIPE_CONNECTED = 535,
        ERROR_PIPE_LISTENING = 536,
        ERROR_VERIFIER_STOP = 537,
        ERROR_ABIOS_ERROR = 538,
        ERROR_WX86_WARNING = 539,
        ERROR_WX86_ERROR = 540,
        ERROR_TIMER_NOT_CANCELED = 541,
        ERROR_UNWIND = 542,
        ERROR_BAD_STACK = 543,
        ERROR_INVALID_UNWIND_TARGET = 544,
        ERROR_INVALID_PORT_ATTRIBUTES = 545,
        ERROR_PORT_MESSAGE_TOO_LONG = 546,
        ERROR_INVALID_QUOTA_LOWER = 547,
        ERROR_DEVICE_ALREADY_ATTACHED = 548,
        ERROR_INSTRUCTION_MISALIGNMENT = 549,
        ERROR_PROFILING_NOT_STARTED = 550,
        ERROR_PROFILING_NOT_STOPPED = 551,
        ERROR_COULD_NOT_INTERPRET = 552,
        ERROR_PROFILING_AT_LIMIT = 553,
        ERROR_CANT_WAIT = 554,
        ERROR_CANT_TERMINATE_SELF = 555,
        ERROR_UNEXPECTED_MM_CREATE_ERR = 556,
        ERROR_UNEXPECTED_MM_MAP_ERROR = 557,
        ERROR_UNEXPECTED_MM_EXTEND_ERR = 558,
        ERROR_BAD_FUNCTION_TABLE = 559,
        ERROR_NO_GUID_TRANSLATION = 560,
        ERROR_INVALID_LDT_SIZE = 561,
        ERROR_INVALID_LDT_OFFSET = 563,
        ERROR_INVALID_LDT_DESCRIPTOR = 564,
        ERROR_TOO_MANY_THREADS = 565,
        ERROR_THREAD_NOT_IN_PROCESS = 566,
        ERROR_PAGEFILE_QUOTA_EXCEEDED = 567,
        ERROR_LOGON_SERVER_CONFLICT = 568,
        ERROR_SYNCHRONIZATION_REQUIRED = 569,
        ERROR_NET_OPEN_FAILED = 570,
        ERROR_IO_PRIVILEGE_FAILED = 571,
        ERROR_CONTROL_C_EXIT = 572,
        ERROR_MISSING_SYSTEMFILE = 573,
        ERROR_UNHANDLED_EXCEPTION = 574,
        ERROR_APP_INIT_FAILURE = 575,
        ERROR_PAGEFILE_CREATE_FAILED = 576,
        ERROR_INVALID_IMAGE_HASH = 577,
        ERROR_NO_PAGEFILE = 578,
        ERROR_ILLEGAL_FLOAT_CONTEXT = 579,
        ERROR_NO_EVENT_PAIR = 580,
        ERROR_DOMAIN_CTRLR_CONFIG_ERROR = 581,
        ERROR_ILLEGAL_CHARACTER = 582,
        ERROR_UNDEFINED_CHARACTER = 583,
        ERROR_FLOPPY_VOLUME = 584,
        ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT = 585,
        ERROR_BACKUP_CONTROLLER = 586,
        ERROR_MUTANT_LIMIT_EXCEEDED = 587,
        ERROR_FS_DRIVER_REQUIRED = 588,
        ERROR_CANNOT_LOAD_REGISTRY_FILE = 589,
        ERROR_DEBUG_ATTACH_FAILED = 590,
        ERROR_SYSTEM_PROCESS_TERMINATED = 591,
        ERROR_DATA_NOT_ACCEPTED = 592,
        ERROR_VDM_HARD_ERROR = 593,
        ERROR_DRIVER_CANCEL_TIMEOUT = 594,
        ERROR_REPLY_MESSAGE_MISMATCH = 595,
        ERROR_LOST_WRITEBEHIND_DATA = 596,
        ERROR_CLIENT_SERVER_PARAMETERS_INVALID = 597,
        ERROR_NOT_TINY_STREAM = 598,
        ERROR_STACK_OVERFLOW_READ = 599,
        ERROR_CONVERT_TO_LARGE = 600,
        ERROR_FOUND_OUT_OF_SCOPE = 601,
        ERROR_ALLOCATE_BUCKET = 602,
        ERROR_MARSHALL_OVERFLOW = 603,
        ERROR_INVALID_VARIANT = 604,
        ERROR_BAD_COMPRESSION_BUFFER = 605,
        ERROR_AUDIT_FAILED = 606,
        ERROR_TIMER_RESOLUTION_NOT_SET = 607,
        ERROR_INSUFFICIENT_LOGON_INFO = 608,
        ERROR_BAD_DLL_ENTRYPOINT = 609,
        ERROR_BAD_SERVICE_ENTRYPOINT = 610,
        ERROR_IP_ADDRESS_CONFLICT1 = 611,
        ERROR_IP_ADDRESS_CONFLICT2 = 612,
        ERROR_REGISTRY_QUOTA_LIMIT = 613,
        ERROR_NO_CALLBACK_ACTIVE = 614,
        ERROR_PWD_TOO_SHORT = 615,
        ERROR_PWD_TOO_RECENT = 616,
        ERROR_PWD_HISTORY_CONFLICT = 617,
        ERROR_UNSUPPORTED_COMPRESSION = 618,
        ERROR_INVALID_HW_PROFILE = 619,
        ERROR_INVALID_PLUGPLAY_DEVICE_PATH = 620,
        ERROR_QUOTA_LIST_INCONSISTENT = 621,
        ERROR_EVALUATION_EXPIRATION = 622,
        ERROR_ILLEGAL_DLL_RELOCATION = 623,
        ERROR_DLL_INIT_FAILED_LOGOFF = 624,
        ERROR_VALIDATE_CONTINUE = 625,
        ERROR_NO_MORE_MATCHES = 626,
        ERROR_RANGE_LIST_CONFLICT = 627,
        ERROR_SERVER_SID_MISMATCH = 628,
        ERROR_CANT_ENABLE_DENY_ONLY = 629,
        ERROR_FLOAT_MULTIPLE_FAULTS = 630,
        ERROR_FLOAT_MULTIPLE_TRAPS = 631,
        ERROR_NOINTERFACE = 632,
        ERROR_DRIVER_FAILED_SLEEP = 633,
        ERROR_CORRUPT_SYSTEM_FILE = 634,
        ERROR_COMMITMENT_MINIMUM = 635,
        ERROR_PNP_RESTART_ENUMERATION = 636,
        ERROR_SYSTEM_IMAGE_BAD_SIGNATURE = 637,
        ERROR_PNP_REBOOT_REQUIRED = 638,
        ERROR_INSUFFICIENT_POWER = 639,
        ERROR_MULTIPLE_FAULT_VIOLATION = 640,
        ERROR_SYSTEM_SHUTDOWN = 641,
        ERROR_PORT_NOT_SET = 642,
        ERROR_DS_VERSION_CHECK_FAILURE = 643,
        ERROR_RANGE_NOT_FOUND = 644,
        ERROR_NOT_SAFE_MODE_DRIVER = 646,
        ERROR_FAILED_DRIVER_ENTRY = 647,
        ERROR_DEVICE_ENUMERATION_ERROR = 648,
        ERROR_MOUNT_POINT_NOT_RESOLVED = 649,
        ERROR_INVALID_DEVICE_OBJECT_PARAMETER = 650,
        ERROR_MCA_OCCURED = 651,
        ERROR_DRIVER_DATABASE_ERROR = 652,
        ERROR_SYSTEM_HIVE_TOO_LARGE = 653,
        ERROR_DRIVER_FAILED_PRIOR_UNLOAD = 654,
        ERROR_VOLSNAP_PREPARE_HIBERNATE = 655,
        ERROR_HIBERNATION_FAILURE = 656,
        ERROR_PWD_TOO_LONG = 657,
        ERROR_FILE_SYSTEM_LIMITATION = 665,
        ERROR_ASSERTION_FAILURE = 668,
        ERROR_ACPI_ERROR = 669,
        ERROR_WOW_ASSERTION = 670,
        ERROR_PNP_BAD_MPS_TABLE = 671,
        ERROR_PNP_TRANSLATION_FAILED = 672,
        ERROR_PNP_IRQ_TRANSLATION_FAILED = 673,
        ERROR_PNP_INVALID_ID = 674,
        ERROR_WAKE_SYSTEM_DEBUGGER = 675,
        ERROR_HANDLES_CLOSED = 676,
        ERROR_EXTRANEOUS_INFORMATION = 677,
        ERROR_RXACT_COMMIT_NECESSARY = 678,
        ERROR_MEDIA_CHECK = 679,
        ERROR_GUID_SUBSTITUTION_MADE = 680,
        ERROR_STOPPED_ON_SYMLINK = 681,
        ERROR_LONGJUMP = 682,
        ERROR_PLUGPLAY_QUERY_VETOED = 683,
        ERROR_UNWIND_CONSOLIDATE = 684,
        ERROR_REGISTRY_HIVE_RECOVERED = 685,
        ERROR_DLL_MIGHT_BE_INSECURE = 686,
        ERROR_DLL_MIGHT_BE_INCOMPATIBLE = 687,
        ERROR_DBG_EXCEPTION_NOT_HANDLED = 688,
        ERROR_DBG_REPLY_LATER = 689,
        ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE = 690,
        ERROR_DBG_TERMINATE_THREAD = 691,
        ERROR_DBG_TERMINATE_PROCESS = 692,
        ERROR_DBG_CONTROL_C = 693,
        ERROR_DBG_PRINTEXCEPTION_C = 694,
        ERROR_DBG_RIPEXCEPTION = 695,
        ERROR_DBG_CONTROL_BREAK = 696,
        ERROR_DBG_COMMAND_EXCEPTION = 697,
        ERROR_OBJECT_NAME_EXISTS = 698,
        ERROR_THREAD_WAS_SUSPENDED = 699,
        ERROR_IMAGE_NOT_AT_BASE = 700,
        ERROR_RXACT_STATE_CREATED = 701,
        ERROR_SEGMENT_NOTIFICATION = 702,
        ERROR_BAD_CURRENT_DIRECTORY = 703,
        ERROR_FT_READ_RECOVERY_FROM_BACKUP = 704,
        ERROR_FT_WRITE_RECOVERY = 705,
        ERROR_IMAGE_MACHINE_TYPE_MISMATCH = 706,
        ERROR_RECEIVE_PARTIAL = 707,
        ERROR_RECEIVE_EXPEDITED = 708,
        ERROR_RECEIVE_PARTIAL_EXPEDITED = 709,
        ERROR_EVENT_DONE = 710,
        ERROR_EVENT_PENDING = 711,
        ERROR_CHECKING_FILE_SYSTEM = 712,
        ERROR_FATAL_APP_EXIT = 713,
        ERROR_PREDEFINED_HANDLE = 714,
        ERROR_WAS_UNLOCKED = 715,
        ERROR_SERVICE_NOTIFICATION = 716,
        ERROR_WAS_LOCKED = 717,
        ERROR_LOG_HARD_ERROR = 718,
        ERROR_ALREADY_WIN32 = 719,
        ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE = 720,
        ERROR_NO_YIELD_PERFORMED = 721,
        ERROR_TIMER_RESUME_IGNORED = 722,
        ERROR_ARBITRATION_UNHANDLED = 723,
        ERROR_CARDBUS_NOT_SUPPORTED = 724,
        ERROR_MP_PROCESSOR_MISMATCH = 725,
        ERROR_HIBERNATED = 726,
        ERROR_RESUME_HIBERNATION = 727,
        ERROR_FIRMWARE_UPDATED = 728,
        ERROR_DRIVERS_LEAKING_LOCKED_PAGES = 729,
        ERROR_WAKE_SYSTEM = 730,
        ERROR_WAIT_1 = 731,
        ERROR_WAIT_2 = 732,
        ERROR_WAIT_3 = 733,
        ERROR_WAIT_63 = 734,
        ERROR_ABANDONED_WAIT_0 = 735,
        ERROR_ABANDONED_WAIT_63 = 736,
        ERROR_USER_APC = 737,
        ERROR_KERNEL_APC = 738,
        ERROR_ALERTED = 739,
        ERROR_ELEVATION_REQUIRED = 740,
        ERROR_REPARSE = 741,
        ERROR_OPLOCK_BREAK_IN_PROGRESS = 742,
        ERROR_VOLUME_MOUNTED = 743,
        ERROR_RXACT_COMMITTED = 744,
        ERROR_NOTIFY_CLEANUP = 745,
        ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED = 746,
        ERROR_PAGE_FAULT_TRANSITION = 747,
        ERROR_PAGE_FAULT_DEMAND_ZERO = 748,
        ERROR_PAGE_FAULT_COPY_ON_WRITE = 749,
        ERROR_PAGE_FAULT_GUARD_PAGE = 750,
        ERROR_PAGE_FAULT_PAGING_FILE = 751,
        ERROR_CACHE_PAGE_LOCKED = 752,
        ERROR_CRASH_DUMP = 753,
        ERROR_BUFFER_ALL_ZEROS = 754,
        ERROR_REPARSE_OBJECT = 755,
        ERROR_RESOURCE_REQUIREMENTS_CHANGED = 756,
        ERROR_TRANSLATION_COMPLETE = 757,
        ERROR_NOTHING_TO_TERMINATE = 758,
        ERROR_PROCESS_NOT_IN_JOB = 759,
        ERROR_PROCESS_IN_JOB = 760,
        ERROR_VOLSNAP_HIBERNATE_READY = 761,
        ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 762,
        ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED = 763,
        ERROR_INTERRUPT_STILL_CONNECTED = 764,
        ERROR_WAIT_FOR_OPLOCK = 765,
        ERROR_DBG_EXCEPTION_HANDLED = 766,
        ERROR_DBG_CONTINUE = 767,
        ERROR_CALLBACK_POP_STACK = 768,
        ERROR_COMPRESSION_DISABLED = 769,
        ERROR_CANTFETCHBACKWARDS = 770,
        ERROR_CANTSCROLLBACKWARDS = 771,
        ERROR_ROWSNOTRELEASED = 772,
        ERROR_BAD_ACCESSOR_FLAGS = 773,
        ERROR_ERRORS_ENCOUNTERED = 774,
        ERROR_NOT_CAPABLE = 775,
        ERROR_REQUEST_OUT_OF_SEQUENCE = 776,
        ERROR_VERSION_PARSE_ERROR = 777,
        ERROR_BADSTARTPOSITION = 778,
        ERROR_MEMORY_HARDWARE = 779,
        ERROR_DISK_REPAIR_DISABLED = 780,
        ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 781,
        ERROR_SYSTEM_POWERSTATE_TRANSITION = 782,
        ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = 783,
        ERROR_MCA_EXCEPTION = 784,
        ERROR_ACCESS_AUDIT_BY_POLICY = 785,
        ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 786,
        ERROR_ABANDON_HIBERFILE = 787,
        ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 788,
        ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 789,
        ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = 790,
        ERROR_BAD_MCFG_TABLE = 791,
        ERROR_DISK_REPAIR_REDIRECTED = 792,
        ERROR_DISK_REPAIR_UNSUCCESSFUL = 793,
        ERROR_CORRUPT_LOG_OVERFULL = 794,
        ERROR_CORRUPT_LOG_CORRUPTED = 795,
        ERROR_CORRUPT_LOG_UNAVAILABLE = 796,
        ERROR_CORRUPT_LOG_DELETED_FULL = 797,
        ERROR_CORRUPT_LOG_CLEARED = 798,
        ERROR_ORPHAN_NAME_EXHAUSTED = 799,
        ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE = 800,
        ERROR_CANNOT_GRANT_REQUESTED_OPLOCK = 801,
        ERROR_CANNOT_BREAK_OPLOCK = 802,
        ERROR_OPLOCK_HANDLE_CLOSED = 803,
        ERROR_NO_ACE_CONDITION = 804,
        ERROR_INVALID_ACE_CONDITION = 805,
        ERROR_FILE_HANDLE_REVOKED = 806,
        ERROR_IMAGE_AT_DIFFERENT_BASE = 807,
        ERROR_ENCRYPTED_IO_NOT_POSSIBLE = 808,
        ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS = 809,
        ERROR_QUOTA_ACTIVITY = 810,
        ERROR_HANDLE_REVOKED = 811,
        ERROR_CALLBACK_INVOKE_INLINE = 812,
        ERROR_CPU_SET_INVALID = 813,
        ERROR_ENCLAVE_NOT_TERMINATED = 814,
        ERROR_ENCLAVE_VIOLATION = 815,
        ERROR_EA_ACCESS_DENIED = 994,
        ERROR_OPERATION_ABORTED = 995,
        ERROR_IO_INCOMPLETE = 996,
        ERROR_IO_PENDING = 997,
        ERROR_NOACCESS = 998,
        ERROR_SWAPERROR = 999,
        ERROR_STACK_OVERFLOW = 1001,
        ERROR_INVALID_MESSAGE = 1002,
        ERROR_CAN_NOT_COMPLETE = 1003,
        ERROR_INVALID_FLAGS = 1004,
        ERROR_UNRECOGNIZED_VOLUME = 1005,
        ERROR_FILE_INVALID = 1006,
        ERROR_FULLSCREEN_MODE = 1007,
        ERROR_NO_TOKEN = 1008,
        ERROR_BADDB = 1009,
        ERROR_BADKEY = 1010,
        ERROR_CANTOPEN = 1011,
        ERROR_CANTREAD = 1012,
        ERROR_CANTWRITE = 1013,
        ERROR_REGISTRY_RECOVERED = 1014,
        ERROR_REGISTRY_CORRUPT = 1015,
        ERROR_REGISTRY_IO_FAILED = 1016,
        ERROR_NOT_REGISTRY_FILE = 1017,
        ERROR_KEY_DELETED = 1018,
        ERROR_NO_LOG_SPACE = 1019,
        ERROR_KEY_HAS_CHILDREN = 1020,
        ERROR_CHILD_MUST_BE_VOLATILE = 1021,
        ERROR_NOTIFY_ENUM_DIR = 1022,
        ERROR_DEPENDENT_SERVICES_RUNNING = 1051,
        ERROR_INVALID_SERVICE_CONTROL = 1052,
        ERROR_SERVICE_REQUEST_TIMEOUT = 1053,
        ERROR_SERVICE_NO_THREAD = 1054,
        ERROR_SERVICE_DATABASE_LOCKED = 1055,
        ERROR_SERVICE_ALREADY_RUNNING = 1056,
        ERROR_INVALID_SERVICE_ACCOUNT = 1057,
        ERROR_SERVICE_DISABLED = 1058,
        ERROR_CIRCULAR_DEPENDENCY = 1059,
        ERROR_SERVICE_DOES_NOT_EXIST = 1060,
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 1061,
        ERROR_SERVICE_NOT_ACTIVE = 1062,
        ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063,
        ERROR_EXCEPTION_IN_SERVICE = 1064,
        ERROR_DATABASE_DOES_NOT_EXIST = 1065,
        ERROR_SERVICE_SPECIFIC_ERROR = 1066,
        ERROR_PROCESS_ABORTED = 1067,
        ERROR_SERVICE_DEPENDENCY_FAIL = 1068,
        ERROR_SERVICE_LOGON_FAILED = 1069,
        ERROR_SERVICE_START_HANG = 1070,
        ERROR_INVALID_SERVICE_LOCK = 1071,
        ERROR_SERVICE_MARKED_FOR_DELETE = 1072,
        ERROR_SERVICE_EXISTS = 1073,
        ERROR_ALREADY_RUNNING_LKG = 1074,
        ERROR_SERVICE_DEPENDENCY_DELETED = 1075,
        ERROR_BOOT_ALREADY_ACCEPTED = 1076,
        ERROR_SERVICE_NEVER_STARTED = 1077,
        ERROR_DUPLICATE_SERVICE_NAME = 1078,
        ERROR_DIFFERENT_SERVICE_ACCOUNT = 1079,
        ERROR_CANNOT_DETECT_DRIVER_FAILURE = 1080,
        ERROR_CANNOT_DETECT_PROCESS_ABORT = 1081,
        ERROR_NO_RECOVERY_PROGRAM = 1082,
        ERROR_SERVICE_NOT_IN_EXE = 1083,
        ERROR_NOT_SAFEBOOT_SERVICE = 1084,
        ERROR_END_OF_MEDIA = 1100,
        ERROR_FILEMARK_DETECTED = 1101,
        ERROR_BEGINNING_OF_MEDIA = 1102,
        ERROR_SETMARK_DETECTED = 1103,
        ERROR_NO_DATA_DETECTED = 1104,
        ERROR_PARTITION_FAILURE = 1105,
        ERROR_INVALID_BLOCK_LENGTH = 1106,
        ERROR_DEVICE_NOT_PARTITIONED = 1107,
        ERROR_UNABLE_TO_LOCK_MEDIA = 1108,
        ERROR_UNABLE_TO_UNLOAD_MEDIA = 1109,
        ERROR_MEDIA_CHANGED = 1110,
        ERROR_BUS_RESET = 1111,
        ERROR_NO_MEDIA_IN_DRIVE = 1112,
        ERROR_NO_UNICODE_TRANSLATION = 1113,
        ERROR_DLL_INIT_FAILED = 1114,
        ERROR_SHUTDOWN_IN_PROGRESS = 1115,
        ERROR_NO_SHUTDOWN_IN_PROGRESS = 1116,
        ERROR_IO_DEVICE = 1117,
        ERROR_SERIAL_NO_DEVICE = 1118,
        ERROR_IRQ_BUSY = 1119,
        ERROR_MORE_WRITES = 1120,
        ERROR_COUNTER_TIMEOUT = 1121,
        ERROR_FLOPPY_ID_MARK_NOT_FOUND = 1122,
        ERROR_FLOPPY_WRONG_CYLINDER = 1123,
        ERROR_FLOPPY_UNKNOWN_ERROR = 1124,
        ERROR_FLOPPY_BAD_REGISTERS = 1125,
        ERROR_DISK_RECALIBRATE_FAILED = 1126,
        ERROR_DISK_OPERATION_FAILED = 1127,
        ERROR_DISK_RESET_FAILED = 1128,
        ERROR_EOM_OVERFLOW = 1129,
        ERROR_NOT_ENOUGH_SERVER_MEMORY = 1130,
        ERROR_POSSIBLE_DEADLOCK = 1131,
        ERROR_MAPPED_ALIGNMENT = 1132,
        ERROR_SET_POWER_STATE_VETOED = 1140,
        ERROR_SET_POWER_STATE_FAILED = 1141,
        ERROR_TOO_MANY_LINKS = 1142,
        ERROR_OLD_WIN_VERSION = 1150,
        ERROR_APP_WRONG_OS = 1151,
        ERROR_SINGLE_INSTANCE_APP = 1152,
        ERROR_RMODE_APP = 1153,
        ERROR_INVALID_DLL = 1154,
        ERROR_NO_ASSOCIATION = 1155,
        ERROR_DDE_FAIL = 1156,
        ERROR_DLL_NOT_FOUND = 1157,
        ERROR_NO_MORE_USER_HANDLES = 1158,
        ERROR_MESSAGE_SYNC_ONLY = 1159,
        ERROR_SOURCE_ELEMENT_EMPTY = 1160,
        ERROR_DESTINATION_ELEMENT_FULL = 1161,
        ERROR_ILLEGAL_ELEMENT_ADDRESS = 1162,
        ERROR_MAGAZINE_NOT_PRESENT = 1163,
        ERROR_DEVICE_REINITIALIZATION_NEEDED = 1164,
        ERROR_DEVICE_REQUIRES_CLEANING = 1165,
        ERROR_DEVICE_DOOR_OPEN = 1166,
        ERROR_DEVICE_NOT_CONNECTED = 1167,
        ERROR_NOT_FOUND = 1168,
        ERROR_NO_MATCH = 1169,
        ERROR_SET_NOT_FOUND = 1170,
        ERROR_POINT_NOT_FOUND = 1171,
        ERROR_NO_TRACKING_SERVICE = 1172,
        ERROR_NO_VOLUME_ID = 1173,
        ERROR_UNABLE_TO_REMOVE_REPLACED = 1175,
        ERROR_UNABLE_TO_MOVE_REPLACEMENT = 1176,
        ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 = 1177,
        ERROR_JOURNAL_DELETE_IN_PROGRESS = 1178,
        ERROR_JOURNAL_NOT_ACTIVE = 1179,
        ERROR_POTENTIAL_FILE_FOUND = 1180,
        ERROR_JOURNAL_ENTRY_DELETED = 1181,
        ERROR_SHUTDOWN_IS_SCHEDULED = 1190,
        ERROR_SHUTDOWN_USERS_LOGGED_ON = 1191,
        ERROR_BAD_DEVICE = 1200,
        ERROR_CONNECTION_UNAVAIL = 1201,
        ERROR_DEVICE_ALREADY_REMEMBERED = 1202,
        ERROR_NO_NET_OR_BAD_PATH = 1203,
        ERROR_BAD_PROVIDER = 1204,
        ERROR_CANNOT_OPEN_PROFILE = 1205,
        ERROR_BAD_PROFILE = 1206,
        ERROR_NOT_CONTAINER = 1207,
        ERROR_EXTENDED_ERROR = 1208,
        ERROR_INVALID_GROUPNAME = 1209,
        ERROR_INVALID_COMPUTERNAME = 1210,
        ERROR_INVALID_EVENTNAME = 1211,
        ERROR_INVALID_DOMAINNAME = 1212,
        ERROR_INVALID_SERVICENAME = 1213,
        ERROR_INVALID_NETNAME = 1214,
        ERROR_INVALID_SHARENAME = 1215,
        ERROR_INVALID_PASSWORDNAME = 1216,
        ERROR_INVALID_MESSAGENAME = 1217,
        ERROR_INVALID_MESSAGEDEST = 1218,
        ERROR_SESSION_CREDENTIAL_CONFLICT = 1219,
        ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 1220,
        ERROR_DUP_DOMAINNAME = 1221,
        ERROR_NO_NETWORK = 1222,
        ERROR_CANCELLED = 1223,
        ERROR_USER_MAPPED_FILE = 1224,
        ERROR_CONNECTION_REFUSED = 1225,
        ERROR_GRACEFUL_DISCONNECT = 1226,
        ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227,
        ERROR_ADDRESS_NOT_ASSOCIATED = 1228,
        ERROR_CONNECTION_INVALID = 1229,
        ERROR_CONNECTION_ACTIVE = 1230,
        ERROR_NETWORK_UNREACHABLE = 1231,
        ERROR_HOST_UNREACHABLE = 1232,
        ERROR_PROTOCOL_UNREACHABLE = 1233,
        ERROR_PORT_UNREACHABLE = 1234,
        ERROR_REQUEST_ABORTED = 1235,
        ERROR_CONNECTION_ABORTED = 1236,
        ERROR_RETRY = 1237,
        ERROR_CONNECTION_COUNT_LIMIT = 1238,
        ERROR_LOGIN_TIME_RESTRICTION = 1239,
        ERROR_LOGIN_WKSTA_RESTRICTION = 1240,
        ERROR_INCORRECT_ADDRESS = 1241,
        ERROR_ALREADY_REGISTERED = 1242,
        ERROR_SERVICE_NOT_FOUND = 1243,
        ERROR_NOT_AUTHENTICATED = 1244,
        ERROR_NOT_LOGGED_ON = 1245,
        ERROR_CONTINUE = 1246,
        ERROR_ALREADY_INITIALIZED = 1247,
        ERROR_NO_MORE_DEVICES = 1248,
        ERROR_NO_SUCH_SITE = 1249,
        ERROR_DOMAIN_CONTROLLER_EXISTS = 1250,
        ERROR_ONLY_IF_CONNECTED = 1251,
        ERROR_OVERRIDE_NOCHANGES = 1252,
        ERROR_BAD_USER_PROFILE = 1253,
        ERROR_NOT_SUPPORTED_ON_SBS = 1254,
        ERROR_SERVER_SHUTDOWN_IN_PROGRESS = 1255,
        ERROR_HOST_DOWN = 1256,
        ERROR_NON_ACCOUNT_SID = 1257,
        ERROR_NON_DOMAIN_SID = 1258,
        ERROR_APPHELP_BLOCK = 1259,
        ERROR_ACCESS_DISABLED_BY_POLICY = 1260,
        ERROR_REG_NAT_CONSUMPTION = 1261,
        ERROR_CSCSHARE_OFFLINE = 1262,
        ERROR_PKINIT_FAILURE = 1263,
        ERROR_SMARTCARD_SUBSYSTEM_FAILURE = 1264,
        ERROR_DOWNGRADE_DETECTED = 1265,
        ERROR_MACHINE_LOCKED = 1271,
        ERROR_SMB_GUEST_LOGON_BLOCKED = 1272,
        ERROR_CALLBACK_SUPPLIED_INVALID_DATA = 1273,
        ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED = 1274,
        ERROR_DRIVER_BLOCKED = 1275,
        ERROR_INVALID_IMPORT_OF_NON_DLL = 1276,
        ERROR_ACCESS_DISABLED_WEBBLADE = 1277,
        ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER = 1278,
        ERROR_RECOVERY_FAILURE = 1279,
        ERROR_ALREADY_FIBER = 1280,
        ERROR_ALREADY_THREAD = 1281,
        ERROR_STACK_BUFFER_OVERRUN = 1282,
        ERROR_PARAMETER_QUOTA_EXCEEDED = 1283,
        ERROR_DEBUGGER_INACTIVE = 1284,
        ERROR_DELAY_LOAD_FAILED = 1285,
        ERROR_VDM_DISALLOWED = 1286,
        ERROR_UNIDENTIFIED_ERROR = 1287,
        ERROR_INVALID_CRUNTIME_PARAMETER = 1288,
        ERROR_BEYOND_VDL = 1289,
        ERROR_INCOMPATIBLE_SERVICE_SID_TYPE = 1290,
        ERROR_DRIVER_PROCESS_TERMINATED = 1291,
        ERROR_IMPLEMENTATION_LIMIT = 1292,
        ERROR_PROCESS_IS_PROTECTED = 1293,
        ERROR_SERVICE_NOTIFY_CLIENT_LAGGING = 1294,
        ERROR_DISK_QUOTA_EXCEEDED = 1295,
        ERROR_CONTENT_BLOCKED = 1296,
        ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE = 1297,
        ERROR_APP_HANG = 1298,
        ERROR_INVALID_LABEL = 1299,
        ERROR_NOT_ALL_ASSIGNED = 1300,
        ERROR_SOME_NOT_MAPPED = 1301,
        ERROR_NO_QUOTAS_FOR_ACCOUNT = 1302,
        ERROR_LOCAL_USER_SESSION_KEY = 1303,
        ERROR_NULL_LM_PASSWORD = 1304,
        ERROR_UNKNOWN_REVISION = 1305,
        ERROR_REVISION_MISMATCH = 1306,
        ERROR_INVALID_OWNER = 1307,
        ERROR_INVALID_PRIMARY_GROUP = 1308,
        ERROR_NO_IMPERSONATION_TOKEN = 1309,
        ERROR_CANT_DISABLE_MANDATORY = 1310,
        ERROR_NO_LOGON_SERVERS = 1311,
        ERROR_NO_SUCH_LOGON_SESSION = 1312,
        ERROR_NO_SUCH_PRIVILEGE = 1313,
        ERROR_PRIVILEGE_NOT_HELD = 1314,
        ERROR_INVALID_ACCOUNT_NAME = 1315,
        ERROR_USER_EXISTS = 1316,
        ERROR_NO_SUCH_USER = 1317,
        ERROR_GROUP_EXISTS = 1318,
        ERROR_NO_SUCH_GROUP = 1319,
        ERROR_MEMBER_IN_GROUP = 1320,
        ERROR_MEMBER_NOT_IN_GROUP = 1321,
        ERROR_LAST_ADMIN = 1322,
        ERROR_WRONG_PASSWORD = 1323,
        ERROR_ILL_FORMED_PASSWORD = 1324,
        ERROR_PASSWORD_RESTRICTION = 1325,
        ERROR_LOGON_FAILURE = 1326,
        ERROR_ACCOUNT_RESTRICTION = 1327,
        ERROR_INVALID_LOGON_HOURS = 1328,
        ERROR_INVALID_WORKSTATION = 1329,
        ERROR_PASSWORD_EXPIRED = 1330,
        ERROR_ACCOUNT_DISABLED = 1331,
        ERROR_NONE_MAPPED = 1332,
        ERROR_TOO_MANY_LUIDS_REQUESTED = 1333,
        ERROR_LUIDS_EXHAUSTED = 1334,
        ERROR_INVALID_SUB_AUTHORITY = 1335,
        ERROR_INVALID_ACL = 1336,
        ERROR_INVALID_SID = 1337,
        ERROR_INVALID_SECURITY_DESCR = 1338,
        ERROR_BAD_INHERITANCE_ACL = 1340,
        ERROR_SERVER_DISABLED = 1341,
        ERROR_SERVER_NOT_DISABLED = 1342,
        ERROR_INVALID_ID_AUTHORITY = 1343,
        ERROR_ALLOTTED_SPACE_EXCEEDED = 1344,
        ERROR_INVALID_GROUP_ATTRIBUTES = 1345,
        ERROR_BAD_IMPERSONATION_LEVEL = 1346,
        ERROR_CANT_OPEN_ANONYMOUS = 1347,
        ERROR_BAD_VALIDATION_CLASS = 1348,
        ERROR_BAD_TOKEN_TYPE = 1349,
        ERROR_NO_SECURITY_ON_OBJECT = 1350,
        ERROR_CANT_ACCESS_DOMAIN_INFO = 1351,
        ERROR_INVALID_SERVER_STATE = 1352,
        ERROR_INVALID_DOMAIN_STATE = 1353,
        ERROR_INVALID_DOMAIN_ROLE = 1354,
        ERROR_NO_SUCH_DOMAIN = 1355,
        ERROR_DOMAIN_EXISTS = 1356,
        ERROR_DOMAIN_LIMIT_EXCEEDED = 1357,
        ERROR_INTERNAL_DB_CORRUPTION = 1358,
        ERROR_INTERNAL_ERROR = 1359,
        ERROR_GENERIC_NOT_MAPPED = 1360,
        ERROR_BAD_DESCRIPTOR_FORMAT = 1361,
        ERROR_NOT_LOGON_PROCESS = 1362,
        ERROR_LOGON_SESSION_EXISTS = 1363,
        ERROR_NO_SUCH_PACKAGE = 1364,
        ERROR_BAD_LOGON_SESSION_STATE = 1365,
        ERROR_LOGON_SESSION_COLLISION = 1366,
        ERROR_INVALID_LOGON_TYPE = 1367,
        ERROR_CANNOT_IMPERSONATE = 1368,
        ERROR_RXACT_INVALID_STATE = 1369,
        ERROR_RXACT_COMMIT_FAILURE = 1370,
        ERROR_SPECIAL_ACCOUNT = 1371,
        ERROR_SPECIAL_GROUP = 1372,
        ERROR_SPECIAL_USER = 1373,
        ERROR_MEMBERS_PRIMARY_GROUP = 1374,
        ERROR_TOKEN_ALREADY_IN_USE = 1375,
        ERROR_NO_SUCH_ALIAS = 1376,
        ERROR_MEMBER_NOT_IN_ALIAS = 1377,
        ERROR_MEMBER_IN_ALIAS = 1378,
        ERROR_ALIAS_EXISTS = 1379,
        ERROR_LOGON_NOT_GRANTED = 1380,
        ERROR_TOO_MANY_SECRETS = 1381,
        ERROR_SECRET_TOO_LONG = 1382,
        ERROR_INTERNAL_DB_ERROR = 1383,
        ERROR_TOO_MANY_CONTEXT_IDS = 1384,
        ERROR_LOGON_TYPE_NOT_GRANTED = 1385,
        ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 1386,
        ERROR_NO_SUCH_MEMBER = 1387,
        ERROR_INVALID_MEMBER = 1388,
        ERROR_TOO_MANY_SIDS = 1389,
        ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 1390,
        ERROR_NO_INHERITANCE = 1391,
        ERROR_FILE_CORRUPT = 1392,
        ERROR_DISK_CORRUPT = 1393,
        ERROR_NO_USER_SESSION_KEY = 1394,
        ERROR_LICENSE_QUOTA_EXCEEDED = 1395,
        ERROR_WRONG_TARGET_NAME = 1396,
        ERROR_MUTUAL_AUTH_FAILED = 1397,
        ERROR_TIME_SKEW = 1398,
        ERROR_CURRENT_DOMAIN_NOT_ALLOWED = 1399,
        ERROR_INVALID_WINDOW_HANDLE = 1400,
        ERROR_INVALID_MENU_HANDLE = 1401,
        ERROR_INVALID_CURSOR_HANDLE = 1402,
        ERROR_INVALID_ACCEL_HANDLE = 1403,
        ERROR_INVALID_HOOK_HANDLE = 1404,
        ERROR_INVALID_DWP_HANDLE = 1405,
        ERROR_TLW_WITH_WSCHILD = 1406,
        ERROR_CANNOT_FIND_WND_CLASS = 1407,
        ERROR_WINDOW_OF_OTHER_THREAD = 1408,
        ERROR_HOTKEY_ALREADY_REGISTERED = 1409,
        ERROR_CLASS_ALREADY_EXISTS = 1410,
        ERROR_CLASS_DOES_NOT_EXIST = 1411,
        ERROR_CLASS_HAS_WINDOWS = 1412,
        ERROR_INVALID_INDEX = 1413,
        ERROR_INVALID_ICON_HANDLE = 1414,
        ERROR_PRIVATE_DIALOG_INDEX = 1415,
        ERROR_LISTBOX_ID_NOT_FOUND = 1416,
        ERROR_NO_WILDCARD_CHARACTERS = 1417,
        ERROR_CLIPBOARD_NOT_OPEN = 1418,
        ERROR_HOTKEY_NOT_REGISTERED = 1419,
        ERROR_WINDOW_NOT_DIALOG = 1420,
        ERROR_CONTROL_ID_NOT_FOUND = 1421,
        ERROR_INVALID_COMBOBOX_MESSAGE = 1422,
        ERROR_WINDOW_NOT_COMBOBOX = 1423,
        ERROR_INVALID_EDIT_HEIGHT = 1424,
        ERROR_DC_NOT_FOUND = 1425,
        ERROR_INVALID_HOOK_FILTER = 1426,
        ERROR_INVALID_FILTER_PROC = 1427,
        ERROR_HOOK_NEEDS_HMOD = 1428,
        ERROR_GLOBAL_ONLY_HOOK = 1429,
        ERROR_JOURNAL_HOOK_SET = 1430,
        ERROR_HOOK_NOT_INSTALLED = 1431,
        ERROR_INVALID_LB_MESSAGE = 1432,
        ERROR_SETCOUNT_ON_BAD_LB = 1433,
        ERROR_LB_WITHOUT_TABSTOPS = 1434,
        ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 1435,
        ERROR_CHILD_WINDOW_MENU = 1436,
        ERROR_NO_SYSTEM_MENU = 1437,
        ERROR_INVALID_MSGBOX_STYLE = 1438,
        ERROR_INVALID_SPI_VALUE = 1439,
        ERROR_SCREEN_ALREADY_LOCKED = 1440,
        ERROR_HWNDS_HAVE_DIFF_PARENT = 1441,
        ERROR_NOT_CHILD_WINDOW = 1442,
        ERROR_INVALID_GW_COMMAND = 1443,
        ERROR_INVALID_THREAD_ID = 1444,
        ERROR_NON_MDICHILD_WINDOW = 1445,
        ERROR_POPUP_ALREADY_ACTIVE = 1446,
        ERROR_NO_SCROLLBARS = 1447,
        ERROR_INVALID_SCROLLBAR_RANGE = 1448,
        ERROR_INVALID_SHOWWIN_COMMAND = 1449,
        ERROR_NO_SYSTEM_RESOURCES = 1450,
        ERROR_NONPAGED_SYSTEM_RESOURCES = 1451,
        ERROR_PAGED_SYSTEM_RESOURCES = 1452,
        ERROR_WORKING_SET_QUOTA = 1453,
        ERROR_PAGEFILE_QUOTA = 1454,
        ERROR_COMMITMENT_LIMIT = 1455,
        ERROR_MENU_ITEM_NOT_FOUND = 1456,
        ERROR_INVALID_KEYBOARD_HANDLE = 1457,
        ERROR_HOOK_TYPE_NOT_ALLOWED = 1458,
        ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = 1459,
        ERROR_TIMEOUT = 1460,
        ERROR_INVALID_MONITOR_HANDLE = 1461,
        ERROR_INCORRECT_SIZE = 1462,
        ERROR_SYMLINK_CLASS_DISABLED = 1463,
        ERROR_SYMLINK_NOT_SUPPORTED = 1464,
        ERROR_XML_PARSE_ERROR = 1465,
        ERROR_XMLDSIG_ERROR = 1466,
        ERROR_RESTART_APPLICATION = 1467,
        ERROR_WRONG_COMPARTMENT = 1468,
        ERROR_AUTHIP_FAILURE = 1469,
        ERROR_NO_NVRAM_RESOURCES = 1470,
        ERROR_NOT_GUI_PROCESS = 1471,
        ERROR_EVENTLOG_FILE_CORRUPT = 1500,
        ERROR_EVENTLOG_CANT_START = 1501,
        ERROR_LOG_FILE_FULL = 1502,
        ERROR_EVENTLOG_FILE_CHANGED = 1503,
        ERROR_CONTAINER_ASSIGNED = 1504,
        ERROR_JOB_NO_CONTAINER = 1505,
        ERROR_INVALID_TASK_NAME = 1550,
        ERROR_INVALID_TASK_INDEX = 1551,
        ERROR_THREAD_ALREADY_IN_TASK = 1552,
        ERROR_INSTALL_SERVICE_FAILURE = 1601,
        ERROR_INSTALL_USEREXIT = 1602,
        ERROR_INSTALL_FAILURE = 1603,
        ERROR_INSTALL_SUSPEND = 1604,
        ERROR_UNKNOWN_PRODUCT = 1605,
        ERROR_UNKNOWN_FEATURE = 1606,
        ERROR_UNKNOWN_COMPONENT = 1607,
        ERROR_UNKNOWN_PROPERTY = 1608,
        ERROR_INVALID_HANDLE_STATE = 1609,
        ERROR_BAD_CONFIGURATION = 1610,
        ERROR_INDEX_ABSENT = 1611,
        ERROR_INSTALL_SOURCE_ABSENT = 1612,
        ERROR_INSTALL_PACKAGE_VERSION = 1613,
        ERROR_PRODUCT_UNINSTALLED = 1614,
        ERROR_BAD_QUERY_SYNTAX = 1615,
        ERROR_INVALID_FIELD = 1616,
        ERROR_DEVICE_REMOVED = 1617,
        ERROR_INSTALL_ALREADY_RUNNING = 1618,
        ERROR_INSTALL_PACKAGE_OPEN_FAILED = 1619,
        ERROR_INSTALL_PACKAGE_INVALID = 1620,
        ERROR_INSTALL_UI_FAILURE = 1621,
        ERROR_INSTALL_LOG_FAILURE = 1622,
        ERROR_INSTALL_LANGUAGE_UNSUPPORTED = 1623,
        ERROR_INSTALL_TRANSFORM_FAILURE = 1624,
        ERROR_INSTALL_PACKAGE_REJECTED = 1625,
        ERROR_FUNCTION_NOT_CALLED = 1626,
        ERROR_FUNCTION_FAILED = 1627,
        ERROR_INVALID_TABLE = 1628,
        ERROR_DATATYPE_MISMATCH = 1629,
        ERROR_UNSUPPORTED_TYPE = 1630,
        ERROR_CREATE_FAILED = 1631,
        ERROR_INSTALL_TEMP_UNWRITABLE = 1632,
        ERROR_INSTALL_PLATFORM_UNSUPPORTED = 1633,
        ERROR_INSTALL_NOTUSED = 1634,
        ERROR_PATCH_PACKAGE_OPEN_FAILED = 1635,
        ERROR_PATCH_PACKAGE_INVALID = 1636,
        ERROR_PATCH_PACKAGE_UNSUPPORTED = 1637,
        ERROR_PRODUCT_VERSION = 1638,
        ERROR_INVALID_COMMAND_LINE = 1639,
        ERROR_INSTALL_REMOTE_DISALLOWED = 1640,
        ERROR_SUCCESS_REBOOT_INITIATED = 1641,
        ERROR_PATCH_TARGET_NOT_FOUND = 1642,
        ERROR_PATCH_PACKAGE_REJECTED = 1643,
        ERROR_INSTALL_TRANSFORM_REJECTED = 1644,
        ERROR_INSTALL_REMOTE_PROHIBITED = 1645,
        ERROR_PATCH_REMOVAL_UNSUPPORTED = 1646,
        ERROR_UNKNOWN_PATCH = 1647,
        ERROR_PATCH_NO_SEQUENCE = 1648,
        ERROR_PATCH_REMOVAL_DISALLOWED = 1649,
        ERROR_INVALID_PATCH_XML = 1650,
        ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT = 1651,
        ERROR_INSTALL_SERVICE_SAFEBOOT = 1652,
        ERROR_FAIL_FAST_EXCEPTION = 1653,
        ERROR_INSTALL_REJECTED = 1654,
        ERROR_DYNAMIC_CODE_BLOCKED = 1655,
        ERROR_NOT_SAME_OBJECT = 1656,
        ERROR_STRICT_CFG_VIOLATION = 1657,
        ERROR_SET_CONTEXT_DENIED = 1660,
        ERROR_CROSS_PARTITION_VIOLATION = 1661,
        RPC_S_INVALID_STRING_BINDING = 1700,
        RPC_S_WRONG_KIND_OF_BINDING = 1701,
        RPC_S_INVALID_BINDING = 1702,
        RPC_S_PROTSEQ_NOT_SUPPORTED = 1703,
        RPC_S_INVALID_RPC_PROTSEQ = 1704,
        RPC_S_INVALID_STRING_UUID = 1705,
        RPC_S_INVALID_ENDPOINT_FORMAT = 1706,
        RPC_S_INVALID_NET_ADDR = 1707,
        RPC_S_NO_ENDPOINT_FOUND = 1708,
        RPC_S_INVALID_TIMEOUT = 1709,
        RPC_S_OBJECT_NOT_FOUND = 1710,
        RPC_S_ALREADY_REGISTERED = 1711,
        RPC_S_TYPE_ALREADY_REGISTERED = 1712,
        RPC_S_ALREADY_LISTENING = 1713,
        RPC_S_NO_PROTSEQS_REGISTERED = 1714,
        RPC_S_NOT_LISTENING = 1715,
        RPC_S_UNKNOWN_MGR_TYPE = 1716,
        RPC_S_UNKNOWN_IF = 1717,
        RPC_S_NO_BINDINGS = 1718,
        RPC_S_NO_PROTSEQS = 1719,
        RPC_S_CANT_CREATE_ENDPOINT = 1720,
        RPC_S_OUT_OF_RESOURCES = 1721,
        RPC_S_SERVER_UNAVAILABLE = 1722,
        RPC_S_SERVER_TOO_BUSY = 1723,
        RPC_S_INVALID_NETWORK_OPTIONS = 1724,
        RPC_S_NO_CALL_ACTIVE = 1725,
        RPC_S_CALL_FAILED = 1726,
        RPC_S_CALL_FAILED_DNE = 1727,
        RPC_S_PROTOCOL_ERROR = 1728,
        RPC_S_PROXY_ACCESS_DENIED = 1729,
        RPC_S_UNSUPPORTED_TRANS_SYN = 1730,
        RPC_S_UNSUPPORTED_TYPE = 1732,
        RPC_S_INVALID_TAG = 1733,
        RPC_S_INVALID_BOUND = 1734,
        RPC_S_NO_ENTRY_NAME = 1735,
        RPC_S_INVALID_NAME_SYNTAX = 1736,
        RPC_S_UNSUPPORTED_NAME_SYNTAX = 1737,
        RPC_S_UUID_NO_ADDRESS = 1739,
        RPC_S_DUPLICATE_ENDPOINT = 1740,
        RPC_S_UNKNOWN_AUTHN_TYPE = 1741,
        RPC_S_MAX_CALLS_TOO_SMALL = 1742,
        RPC_S_STRING_TOO_LONG = 1743,
        RPC_S_PROTSEQ_NOT_FOUND = 1744,
        RPC_S_PROCNUM_OUT_OF_RANGE = 1745,
        RPC_S_BINDING_HAS_NO_AUTH = 1746,
        RPC_S_UNKNOWN_AUTHN_SERVICE = 1747,
        RPC_S_UNKNOWN_AUTHN_LEVEL = 1748,
        RPC_S_INVALID_AUTH_IDENTITY = 1749,
        RPC_S_UNKNOWN_AUTHZ_SERVICE = 1750,
        EPT_S_INVALID_ENTRY = 1751,
        EPT_S_CANT_PERFORM_OP = 1752,
        EPT_S_NOT_REGISTERED = 1753,
        RPC_S_NOTHING_TO_EXPORT = 1754,
        RPC_S_INCOMPLETE_NAME = 1755,
        RPC_S_INVALID_VERS_OPTION = 1756,
        RPC_S_NO_MORE_MEMBERS = 1757,
        RPC_S_NOT_ALL_OBJS_UNEXPORTED = 1758,
        RPC_S_INTERFACE_NOT_FOUND = 1759,
        RPC_S_ENTRY_ALREADY_EXISTS = 1760,
        RPC_S_ENTRY_NOT_FOUND = 1761,
        RPC_S_NAME_SERVICE_UNAVAILABLE = 1762,
        RPC_S_INVALID_NAF_ID = 1763,
        RPC_S_CANNOT_SUPPORT = 1764,
        RPC_S_NO_CONTEXT_AVAILABLE = 1765,
        RPC_S_INTERNAL_ERROR = 1766,
        RPC_S_ZERO_DIVIDE = 1767,
        RPC_S_ADDRESS_ERROR = 1768,
        RPC_S_FP_DIV_ZERO = 1769,
        RPC_S_FP_UNDERFLOW = 1770,
        RPC_S_FP_OVERFLOW = 1771,
        RPC_X_NO_MORE_ENTRIES = 1772,
        RPC_X_SS_CHAR_TRANS_OPEN_FAIL = 1773,
        RPC_X_SS_CHAR_TRANS_SHORT_FILE = 1774,
        RPC_X_SS_IN_NULL_CONTEXT = 1775,
        RPC_X_SS_CONTEXT_DAMAGED = 1777,
        RPC_X_SS_HANDLES_MISMATCH = 1778,
        RPC_X_SS_CANNOT_GET_CALL_HANDLE = 1779,
        RPC_X_NULL_REF_POINTER = 1780,
        RPC_X_ENUM_VALUE_OUT_OF_RANGE = 1781,
        RPC_X_BYTE_COUNT_TOO_SMALL = 1782,
        RPC_X_BAD_STUB_DATA = 1783,
        ERROR_INVALID_USER_BUFFER = 1784,
        ERROR_UNRECOGNIZED_MEDIA = 1785,
        ERROR_NO_TRUST_LSA_SECRET = 1786,
        ERROR_NO_TRUST_SAM_ACCOUNT = 1787,
        ERROR_TRUSTED_DOMAIN_FAILURE = 1788,
        ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789,
        ERROR_TRUST_FAILURE = 1790,
        RPC_S_CALL_IN_PROGRESS = 1791,
        ERROR_NETLOGON_NOT_STARTED = 1792,
        ERROR_ACCOUNT_EXPIRED = 1793,
        ERROR_REDIRECTOR_HAS_OPEN_HANDLES = 1794,
        ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 1795,
        ERROR_UNKNOWN_PORT = 1796,
        ERROR_UNKNOWN_PRINTER_DRIVER = 1797,
        ERROR_UNKNOWN_PRINTPROCESSOR = 1798,
        ERROR_INVALID_SEPARATOR_FILE = 1799,
        ERROR_INVALID_PRIORITY = 1800,
        ERROR_INVALID_PRINTER_NAME = 1801,
        ERROR_PRINTER_ALREADY_EXISTS = 1802,
        ERROR_INVALID_PRINTER_COMMAND = 1803,
        ERROR_INVALID_DATATYPE = 1804,
        ERROR_INVALID_ENVIRONMENT = 1805,
        RPC_S_NO_MORE_BINDINGS = 1806,
        ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 1807,
        ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 1808,
        ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 1809,
        ERROR_DOMAIN_TRUST_INCONSISTENT = 1810,
        ERROR_SERVER_HAS_OPEN_HANDLES = 1811,
        ERROR_RESOURCE_DATA_NOT_FOUND = 1812,
        ERROR_RESOURCE_TYPE_NOT_FOUND = 1813,
        ERROR_RESOURCE_NAME_NOT_FOUND = 1814,
        ERROR_RESOURCE_LANG_NOT_FOUND = 1815,
        ERROR_NOT_ENOUGH_QUOTA = 1816,
        RPC_S_NO_INTERFACES = 1817,
        RPC_S_CALL_CANCELLED = 1818,
        RPC_S_BINDING_INCOMPLETE = 1819,
        RPC_S_COMM_FAILURE = 1820,
        RPC_S_UNSUPPORTED_AUTHN_LEVEL = 1821,
        RPC_S_NO_PRINC_NAME = 1822,
        RPC_S_NOT_RPC_ERROR = 1823,
        RPC_S_UUID_LOCAL_ONLY = 1824,
        RPC_S_SEC_PKG_ERROR = 1825,
        RPC_S_NOT_CANCELLED = 1826,
        RPC_X_INVALID_ES_ACTION = 1827,
        RPC_X_WRONG_ES_VERSION = 1828,
        RPC_X_WRONG_STUB_VERSION = 1829,
        RPC_X_INVALID_PIPE_OBJECT = 1830,
        RPC_X_WRONG_PIPE_ORDER = 1831,
        RPC_X_WRONG_PIPE_VERSION = 1832,
        RPC_S_COOKIE_AUTH_FAILED = 1833,
        RPC_S_DO_NOT_DISTURB = 1834,
        RPC_S_SYSTEM_HANDLE_COUNT_EXCEEDED = 1835,
        RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH = 1836,
        RPC_S_GROUP_MEMBER_NOT_FOUND = 1898,
        EPT_S_CANT_CREATE = 1899,
        RPC_S_INVALID_OBJECT = 1900,
        ERROR_INVALID_TIME = 1901,
        ERROR_INVALID_FORM_NAME = 1902,
        ERROR_INVALID_FORM_SIZE = 1903,
        ERROR_ALREADY_WAITING = 1904,
        ERROR_PRINTER_DELETED = 1905,
        ERROR_INVALID_PRINTER_STATE = 1906,
        ERROR_PASSWORD_MUST_CHANGE = 1907,
        ERROR_DOMAIN_CONTROLLER_NOT_FOUND = 1908,
        ERROR_ACCOUNT_LOCKED_OUT = 1909,
        OR_INVALID_OXID = 1910,
        OR_INVALID_OID = 1911,
        OR_INVALID_SET = 1912,
        RPC_S_SEND_INCOMPLETE = 1913,
        RPC_S_INVALID_ASYNC_HANDLE = 1914,
        RPC_S_INVALID_ASYNC_CALL = 1915,
        RPC_X_PIPE_CLOSED = 1916,
        RPC_X_PIPE_DISCIPLINE_ERROR = 1917,
        RPC_X_PIPE_EMPTY = 1918,
        ERROR_NO_SITENAME = 1919,
        ERROR_CANT_ACCESS_FILE = 1920,
        ERROR_CANT_RESOLVE_FILENAME = 1921,
        RPC_S_ENTRY_TYPE_MISMATCH = 1922,
        RPC_S_NOT_ALL_OBJS_EXPORTED = 1923,
        RPC_S_INTERFACE_NOT_EXPORTED = 1924,
        RPC_S_PROFILE_NOT_ADDED = 1925,
        RPC_S_PRF_ELT_NOT_ADDED = 1926,
        RPC_S_PRF_ELT_NOT_REMOVED = 1927,
        RPC_S_GRP_ELT_NOT_ADDED = 1928,
        RPC_S_GRP_ELT_NOT_REMOVED = 1929,
        ERROR_KM_DRIVER_BLOCKED = 1930,
        ERROR_CONTEXT_EXPIRED = 1931,
        ERROR_PER_USER_TRUST_QUOTA_EXCEEDED = 1932,
        ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED = 1933,
        ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED = 1934,
        ERROR_AUTHENTICATION_FIREWALL_FAILED = 1935,
        ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED = 1936,
        ERROR_NTLM_BLOCKED = 1937,
        ERROR_PASSWORD_CHANGE_REQUIRED = 1938,
        ERROR_LOST_MODE_LOGON_RESTRICTION = 1939,
        ERROR_INVALID_PIXEL_FORMAT = 2000,
        ERROR_BAD_DRIVER = 2001,
        ERROR_INVALID_WINDOW_STYLE = 2002,
        ERROR_METAFILE_NOT_SUPPORTED = 2003,
        ERROR_TRANSFORM_NOT_SUPPORTED = 2004,
        ERROR_CLIPPING_NOT_SUPPORTED = 2005,
        ERROR_INVALID_CMM = 2010,
        ERROR_INVALID_PROFILE = 2011,
        ERROR_TAG_NOT_FOUND = 2012,
        ERROR_TAG_NOT_PRESENT = 2013,
        ERROR_DUPLICATE_TAG = 2014,
        ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = 2015,
        ERROR_PROFILE_NOT_FOUND = 2016,
        ERROR_INVALID_COLORSPACE = 2017,
        ERROR_ICM_NOT_ENABLED = 2018,
        ERROR_DELETING_ICM_XFORM = 2019,
        ERROR_INVALID_TRANSFORM = 2020,
        ERROR_COLORSPACE_MISMATCH = 2021,
        ERROR_INVALID_COLORINDEX = 2022,
        ERROR_PROFILE_DOES_NOT_MATCH_DEVICE = 2023,
        ERROR_CONNECTED_OTHER_PASSWORD = 2108,
        ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT = 2109,
        ERROR_BAD_USERNAME = 2202,
        ERROR_NOT_CONNECTED = 2250,
        ERROR_OPEN_FILES = 2401,
        ERROR_ACTIVE_CONNECTIONS = 2402,
        ERROR_DEVICE_IN_USE = 2404,
        ERROR_UNKNOWN_PRINT_MONITOR = 3000,
        ERROR_PRINTER_DRIVER_IN_USE = 3001,
        ERROR_SPOOL_FILE_NOT_FOUND = 3002,
        ERROR_SPL_NO_STARTDOC = 3003,
        ERROR_SPL_NO_ADDJOB = 3004,
        ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = 3005,
        ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 3006,
        ERROR_INVALID_PRINT_MONITOR = 3007,
        ERROR_PRINT_MONITOR_IN_USE = 3008,
        ERROR_PRINTER_HAS_JOBS_QUEUED = 3009,
        ERROR_SUCCESS_REBOOT_REQUIRED = 3010,
        ERROR_SUCCESS_RESTART_REQUIRED = 3011,
        ERROR_PRINTER_NOT_FOUND = 3012,
        ERROR_PRINTER_DRIVER_WARNED = 3013,
        ERROR_PRINTER_DRIVER_BLOCKED = 3014,
        ERROR_PRINTER_DRIVER_PACKAGE_IN_USE = 3015,
        ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND = 3016,
        ERROR_FAIL_REBOOT_REQUIRED = 3017,
        ERROR_FAIL_REBOOT_INITIATED = 3018,
        ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED = 3019,
        ERROR_PRINT_JOB_RESTART_REQUIRED = 3020,
        ERROR_INVALID_PRINTER_DRIVER_MANIFEST = 3021,
        ERROR_PRINTER_NOT_SHAREABLE = 3022,
        ERROR_REQUEST_PAUSED = 3050,
        ERROR_APPEXEC_CONDITION_NOT_SATISFIED = 3060,
        ERROR_APPEXEC_HANDLE_INVALIDATED = 3061,
        ERROR_APPEXEC_INVALID_HOST_GENERATION = 3062,
        ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION = 3063,
        ERROR_APPEXEC_INVALID_HOST_STATE = 3064,
        ERROR_APPEXEC_NO_DONOR = 3065,
        ERROR_APPEXEC_HOST_ID_MISMATCH = 3066,
        ERROR_APPEXEC_UNKNOWN_USER = 3067,
        ERROR_IO_REISSUE_AS_CACHED = 3950,
        ERROR_WINS_INTERNAL = 4000,
        ERROR_CAN_NOT_DEL_LOCAL_WINS = 4001,
        ERROR_STATIC_INIT = 4002,
        ERROR_INC_BACKUP = 4003,
        ERROR_FULL_BACKUP = 4004,
        ERROR_REC_NON_EXISTENT = 4005,
        ERROR_RPL_NOT_ALLOWED = 4006,
        PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED = 4050,
        PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO = 4051,
        PEERDIST_ERROR_MISSING_DATA = 4052,
        PEERDIST_ERROR_NO_MORE = 4053,
        PEERDIST_ERROR_NOT_INITIALIZED = 4054,
        PEERDIST_ERROR_ALREADY_INITIALIZED = 4055,
        PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS = 4056,
        PEERDIST_ERROR_INVALIDATED = 4057,
        PEERDIST_ERROR_ALREADY_EXISTS = 4058,
        PEERDIST_ERROR_OPERATION_NOTFOUND = 4059,
        PEERDIST_ERROR_ALREADY_COMPLETED = 4060,
        PEERDIST_ERROR_OUT_OF_BOUNDS = 4061,
        PEERDIST_ERROR_VERSION_UNSUPPORTED = 4062,
        PEERDIST_ERROR_INVALID_CONFIGURATION = 4063,
        PEERDIST_ERROR_NOT_LICENSED = 4064,
        PEERDIST_ERROR_SERVICE_UNAVAILABLE = 4065,
        PEERDIST_ERROR_TRUST_FAILURE = 4066,
        ERROR_DHCP_ADDRESS_CONFLICT = 4100,
        ERROR_WMI_GUID_NOT_FOUND = 4200,
        ERROR_WMI_INSTANCE_NOT_FOUND = 4201,
        ERROR_WMI_ITEMID_NOT_FOUND = 4202,
        ERROR_WMI_TRY_AGAIN = 4203,
        ERROR_WMI_DP_NOT_FOUND = 4204,
        ERROR_WMI_UNRESOLVED_INSTANCE_REF = 4205,
        ERROR_WMI_ALREADY_ENABLED = 4206,
        ERROR_WMI_GUID_DISCONNECTED = 4207,
        ERROR_WMI_SERVER_UNAVAILABLE = 4208,
        ERROR_WMI_DP_FAILED = 4209,
        ERROR_WMI_INVALID_MOF = 4210,
        ERROR_WMI_INVALID_REGINFO = 4211,
        ERROR_WMI_ALREADY_DISABLED = 4212,
        ERROR_WMI_READ_ONLY = 4213,
        ERROR_WMI_SET_FAILURE = 4214,
        ERROR_NOT_APPCONTAINER = 4250,
        ERROR_APPCONTAINER_REQUIRED = 4251,
        ERROR_NOT_SUPPORTED_IN_APPCONTAINER = 4252,
        ERROR_INVALID_PACKAGE_SID_LENGTH = 4253,
        ERROR_INVALID_MEDIA = 4300,
        ERROR_INVALID_LIBRARY = 4301,
        ERROR_INVALID_MEDIA_POOL = 4302,
        ERROR_DRIVE_MEDIA_MISMATCH = 4303,
        ERROR_MEDIA_OFFLINE = 4304,
        ERROR_LIBRARY_OFFLINE = 4305,
        ERROR_EMPTY = 4306,
        ERROR_NOT_EMPTY = 4307,
        ERROR_MEDIA_UNAVAILABLE = 4308,
        ERROR_RESOURCE_DISABLED = 4309,
        ERROR_INVALID_CLEANER = 4310,
        ERROR_UNABLE_TO_CLEAN = 4311,
        ERROR_OBJECT_NOT_FOUND = 4312,
        ERROR_DATABASE_FAILURE = 4313,
        ERROR_DATABASE_FULL = 4314,
        ERROR_MEDIA_INCOMPATIBLE = 4315,
        ERROR_RESOURCE_NOT_PRESENT = 4316,
        ERROR_INVALID_OPERATION = 4317,
        ERROR_MEDIA_NOT_AVAILABLE = 4318,
        ERROR_DEVICE_NOT_AVAILABLE = 4319,
        ERROR_REQUEST_REFUSED = 4320,
        ERROR_INVALID_DRIVE_OBJECT = 4321,
        ERROR_LIBRARY_FULL = 4322,
        ERROR_MEDIUM_NOT_ACCESSIBLE = 4323,
        ERROR_UNABLE_TO_LOAD_MEDIUM = 4324,
        ERROR_UNABLE_TO_INVENTORY_DRIVE = 4325,
        ERROR_UNABLE_TO_INVENTORY_SLOT = 4326,
        ERROR_UNABLE_TO_INVENTORY_TRANSPORT = 4327,
        ERROR_TRANSPORT_FULL = 4328,
        ERROR_CONTROLLING_IEPORT = 4329,
        ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA = 4330,
        ERROR_CLEANER_SLOT_SET = 4331,
        ERROR_CLEANER_SLOT_NOT_SET = 4332,
        ERROR_CLEANER_CARTRIDGE_SPENT = 4333,
        ERROR_UNEXPECTED_OMID = 4334,
        ERROR_CANT_DELETE_LAST_ITEM = 4335,
        ERROR_MESSAGE_EXCEEDS_MAX_SIZE = 4336,
        ERROR_VOLUME_CONTAINS_SYS_FILES = 4337,
        ERROR_INDIGENOUS_TYPE = 4338,
        ERROR_NO_SUPPORTING_DRIVES = 4339,
        ERROR_CLEANER_CARTRIDGE_INSTALLED = 4340,
        ERROR_IEPORT_FULL = 4341,
        ERROR_FILE_OFFLINE = 4350,
        ERROR_REMOTE_STORAGE_NOT_ACTIVE = 4351,
        ERROR_REMOTE_STORAGE_MEDIA_ERROR = 4352,
        ERROR_NOT_A_REPARSE_POINT = 4390,
        ERROR_REPARSE_ATTRIBUTE_CONFLICT = 4391,
        ERROR_INVALID_REPARSE_DATA = 4392,
        ERROR_REPARSE_TAG_INVALID = 4393,
        ERROR_REPARSE_TAG_MISMATCH = 4394,
        ERROR_REPARSE_POINT_ENCOUNTERED = 4395,
        ERROR_APP_DATA_NOT_FOUND = 4400,
        ERROR_APP_DATA_EXPIRED = 4401,
        ERROR_APP_DATA_CORRUPT = 4402,
        ERROR_APP_DATA_LIMIT_EXCEEDED = 4403,
        ERROR_APP_DATA_REBOOT_REQUIRED = 4404,
        ERROR_SECUREBOOT_ROLLBACK_DETECTED = 4420,
        ERROR_SECUREBOOT_POLICY_VIOLATION = 4421,
        ERROR_SECUREBOOT_INVALID_POLICY = 4422,
        ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = 4423,
        ERROR_SECUREBOOT_POLICY_NOT_SIGNED = 4424,
        ERROR_SECUREBOOT_NOT_ENABLED = 4425,
        ERROR_SECUREBOOT_FILE_REPLACED = 4426,
        ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED = 4427,
        ERROR_SECUREBOOT_POLICY_UNKNOWN = 4428,
        ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION = 4429,
        ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH = 4430,
        ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED = 4431,
        ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH = 4432,
        ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING = 4433,
        ERROR_SECUREBOOT_NOT_BASE_POLICY = 4434,
        ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY = 4435,
        ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED = 4440,
        ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = 4441,
        ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED = 4442,
        ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = 4443,
        ERROR_ALREADY_HAS_STREAM_ID = 4444,
        ERROR_SMR_GARBAGE_COLLECTION_REQUIRED = 4445,
        ERROR_WOF_WIM_HEADER_CORRUPT = 4446,
        ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT = 4447,
        ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT = 4448,
        ERROR_VOLUME_NOT_SIS_ENABLED = 4500,
        ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED = 4550,
        ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION = 4551,
        ERROR_SYSTEM_INTEGRITY_INVALID_POLICY = 4552,
        ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED = 4553,
        ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES = 4554,
        ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED = 4555,
        ERROR_VSM_NOT_INITIALIZED = 4560,
        ERROR_VSM_DMA_PROTECTION_NOT_IN_USE = 4561,
        ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED = 4570,
        ERROR_PLATFORM_MANIFEST_INVALID = 4571,
        ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED = 4572,
        ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED = 4573,
        ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND = 4574,
        ERROR_PLATFORM_MANIFEST_NOT_ACTIVE = 4575,
        ERROR_PLATFORM_MANIFEST_NOT_SIGNED = 4576,
        ERROR_DEPENDENT_RESOURCE_EXISTS = 5001,
        ERROR_DEPENDENCY_NOT_FOUND = 5002,
        ERROR_DEPENDENCY_ALREADY_EXISTS = 5003,
        ERROR_RESOURCE_NOT_ONLINE = 5004,
        ERROR_HOST_NODE_NOT_AVAILABLE = 5005,
        ERROR_RESOURCE_NOT_AVAILABLE = 5006,
        ERROR_RESOURCE_NOT_FOUND = 5007,
        ERROR_SHUTDOWN_CLUSTER = 5008,
        ERROR_CANT_EVICT_ACTIVE_NODE = 5009,
        ERROR_OBJECT_ALREADY_EXISTS = 5010,
        ERROR_OBJECT_IN_LIST = 5011,
        ERROR_GROUP_NOT_AVAILABLE = 5012,
        ERROR_GROUP_NOT_FOUND = 5013,
        ERROR_GROUP_NOT_ONLINE = 5014,
        ERROR_HOST_NODE_NOT_RESOURCE_OWNER = 5015,
        ERROR_HOST_NODE_NOT_GROUP_OWNER = 5016,
        ERROR_RESMON_CREATE_FAILED = 5017,
        ERROR_RESMON_ONLINE_FAILED = 5018,
        ERROR_RESOURCE_ONLINE = 5019,
        ERROR_QUORUM_RESOURCE = 5020,
        ERROR_NOT_QUORUM_CAPABLE = 5021,
        ERROR_CLUSTER_SHUTTING_DOWN = 5022,
        ERROR_INVALID_STATE = 5023,
        ERROR_RESOURCE_PROPERTIES_STORED = 5024,
        ERROR_NOT_QUORUM_CLASS = 5025,
        ERROR_CORE_RESOURCE = 5026,
        ERROR_QUORUM_RESOURCE_ONLINE_FAILED = 5027,
        ERROR_QUORUMLOG_OPEN_FAILED = 5028,
        ERROR_CLUSTERLOG_CORRUPT = 5029,
        ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = 5030,
        ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE = 5031,
        ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND = 5032,
        ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE = 5033,
        ERROR_QUORUM_OWNER_ALIVE = 5034,
        ERROR_NETWORK_NOT_AVAILABLE = 5035,
        ERROR_NODE_NOT_AVAILABLE = 5036,
        ERROR_ALL_NODES_NOT_AVAILABLE = 5037,
        ERROR_RESOURCE_FAILED = 5038,
        ERROR_CLUSTER_INVALID_NODE = 5039,
        ERROR_CLUSTER_NODE_EXISTS = 5040,
        ERROR_CLUSTER_JOIN_IN_PROGRESS = 5041,
        ERROR_CLUSTER_NODE_NOT_FOUND = 5042,
        ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND = 5043,
        ERROR_CLUSTER_NETWORK_EXISTS = 5044,
        ERROR_CLUSTER_NETWORK_NOT_FOUND = 5045,
        ERROR_CLUSTER_NETINTERFACE_EXISTS = 5046,
        ERROR_CLUSTER_NETINTERFACE_NOT_FOUND = 5047,
        ERROR_CLUSTER_INVALID_REQUEST = 5048,
        ERROR_CLUSTER_INVALID_NETWORK_PROVIDER = 5049,
        ERROR_CLUSTER_NODE_DOWN = 5050,
        ERROR_CLUSTER_NODE_UNREACHABLE = 5051,
        ERROR_CLUSTER_NODE_NOT_MEMBER = 5052,
        ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS = 5053,
        ERROR_CLUSTER_INVALID_NETWORK = 5054,
        ERROR_CLUSTER_NODE_UP = 5056,
        ERROR_CLUSTER_IPADDR_IN_USE = 5057,
        ERROR_CLUSTER_NODE_NOT_PAUSED = 5058,
        ERROR_CLUSTER_NO_SECURITY_CONTEXT = 5059,
        ERROR_CLUSTER_NETWORK_NOT_INTERNAL = 5060,
        ERROR_CLUSTER_NODE_ALREADY_UP = 5061,
        ERROR_CLUSTER_NODE_ALREADY_DOWN = 5062,
        ERROR_CLUSTER_NETWORK_ALREADY_ONLINE = 5063,
        ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE = 5064,
        ERROR_CLUSTER_NODE_ALREADY_MEMBER = 5065,
        ERROR_CLUSTER_LAST_INTERNAL_NETWORK = 5066,
        ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS = 5067,
        ERROR_INVALID_OPERATION_ON_QUORUM = 5068,
        ERROR_DEPENDENCY_NOT_ALLOWED = 5069,
        ERROR_CLUSTER_NODE_PAUSED = 5070,
        ERROR_NODE_CANT_HOST_RESOURCE = 5071,
        ERROR_CLUSTER_NODE_NOT_READY = 5072,
        ERROR_CLUSTER_NODE_SHUTTING_DOWN = 5073,
        ERROR_CLUSTER_JOIN_ABORTED = 5074,
        ERROR_CLUSTER_INCOMPATIBLE_VERSIONS = 5075,
        ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED = 5076,
        ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED = 5077,
        ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND = 5078,
        ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED = 5079,
        ERROR_CLUSTER_RESNAME_NOT_FOUND = 5080,
        ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED = 5081,
        ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST = 5082,
        ERROR_CLUSTER_DATABASE_SEQMISMATCH = 5083,
        ERROR_RESMON_INVALID_STATE = 5084,
        ERROR_CLUSTER_GUM_NOT_LOCKER = 5085,
        ERROR_QUORUM_DISK_NOT_FOUND = 5086,
        ERROR_DATABASE_BACKUP_CORRUPT = 5087,
        ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT = 5088,
        ERROR_RESOURCE_PROPERTY_UNCHANGEABLE = 5089,
        ERROR_NO_ADMIN_ACCESS_POINT = 5090,
        ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE = 5890,
        ERROR_CLUSTER_QUORUMLOG_NOT_FOUND = 5891,
        ERROR_CLUSTER_MEMBERSHIP_HALT = 5892,
        ERROR_CLUSTER_INSTANCE_ID_MISMATCH = 5893,
        ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP = 5894,
        ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH = 5895,
        ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP = 5896,
        ERROR_CLUSTER_PARAMETER_MISMATCH = 5897,
        ERROR_NODE_CANNOT_BE_CLUSTERED = 5898,
        ERROR_CLUSTER_WRONG_OS_VERSION = 5899,
        ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME = 5900,
        ERROR_CLUSCFG_ALREADY_COMMITTED = 5901,
        ERROR_CLUSCFG_ROLLBACK_FAILED = 5902,
        ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT = 5903,
        ERROR_CLUSTER_OLD_VERSION = 5904,
        ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME = 5905,
        ERROR_CLUSTER_NO_NET_ADAPTERS = 5906,
        ERROR_CLUSTER_POISONED = 5907,
        ERROR_CLUSTER_GROUP_MOVING = 5908,
        ERROR_CLUSTER_RESOURCE_TYPE_BUSY = 5909,
        ERROR_RESOURCE_CALL_TIMED_OUT = 5910,
        ERROR_INVALID_CLUSTER_IPV6_ADDRESS = 5911,
        ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION = 5912,
        ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS = 5913,
        ERROR_CLUSTER_PARTIAL_SEND = 5914,
        ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION = 5915,
        ERROR_CLUSTER_INVALID_STRING_TERMINATION = 5916,
        ERROR_CLUSTER_INVALID_STRING_FORMAT = 5917,
        ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS = 5918,
        ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS = 5919,
        ERROR_CLUSTER_NULL_DATA = 5920,
        ERROR_CLUSTER_PARTIAL_READ = 5921,
        ERROR_CLUSTER_PARTIAL_WRITE = 5922,
        ERROR_CLUSTER_CANT_DESERIALIZE_DATA = 5923,
        ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT = 5924,
        ERROR_CLUSTER_NO_QUORUM = 5925,
        ERROR_CLUSTER_INVALID_IPV6_NETWORK = 5926,
        ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK = 5927,
        ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP = 5928,
        ERROR_DEPENDENCY_TREE_TOO_COMPLEX = 5929,
        ERROR_EXCEPTION_IN_RESOURCE_CALL = 5930,
        ERROR_CLUSTER_RHS_FAILED_INITIALIZATION = 5931,
        ERROR_CLUSTER_NOT_INSTALLED = 5932,
        ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE = 5933,
        ERROR_CLUSTER_MAX_NODES_IN_CLUSTER = 5934,
        ERROR_CLUSTER_TOO_MANY_NODES = 5935,
        ERROR_CLUSTER_OBJECT_ALREADY_USED = 5936,
        ERROR_NONCORE_GROUPS_FOUND = 5937,
        ERROR_FILE_SHARE_RESOURCE_CONFLICT = 5938,
        ERROR_CLUSTER_EVICT_INVALID_REQUEST = 5939,
        ERROR_CLUSTER_SINGLETON_RESOURCE = 5940,
        ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE = 5941,
        ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED = 5942,
        ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR = 5943,
        ERROR_CLUSTER_GROUP_BUSY = 5944,
        ERROR_CLUSTER_NOT_SHARED_VOLUME = 5945,
        ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR = 5946,
        ERROR_CLUSTER_SHARED_VOLUMES_IN_USE = 5947,
        ERROR_CLUSTER_USE_SHARED_VOLUMES_API = 5948,
        ERROR_CLUSTER_BACKUP_IN_PROGRESS = 5949,
        ERROR_NON_CSV_PATH = 5950,
        ERROR_CSV_VOLUME_NOT_LOCAL = 5951,
        ERROR_CLUSTER_WATCHDOG_TERMINATING = 5952,
        ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES = 5953,
        ERROR_CLUSTER_INVALID_NODE_WEIGHT = 5954,
        ERROR_CLUSTER_RESOURCE_VETOED_CALL = 5955,
        ERROR_RESMON_SYSTEM_RESOURCES_LACKING = 5956,
        ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION = 5957,
        ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE = 5958,
        ERROR_CLUSTER_GROUP_QUEUED = 5959,
        ERROR_CLUSTER_RESOURCE_LOCKED_STATUS = 5960,
        ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED = 5961,
        ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS = 5962,
        ERROR_CLUSTER_DISK_NOT_CONNECTED = 5963,
        ERROR_DISK_NOT_CSV_CAPABLE = 5964,
        ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE = 5965,
        ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED = 5966,
        ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED = 5967,
        ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES = 5968,
        ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES = 5969,
        ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE = 5970,
        ERROR_CLUSTER_AFFINITY_CONFLICT = 5971,
        ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE = 5972,
        ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS = 5973,
        ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED = 5974,
        ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED = 5975,
        ERROR_CLUSTER_UPGRADE_IN_PROGRESS = 5976,
        ERROR_CLUSTER_UPGRADE_INCOMPLETE = 5977,
        ERROR_CLUSTER_NODE_IN_GRACE_PERIOD = 5978,
        ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT = 5979,
        ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER = 5980,
        ERROR_CLUSTER_RESOURCE_NOT_MONITORED = 5981,
        ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED = 5982,
        ERROR_CLUSTER_RESOURCE_IS_REPLICATED = 5983,
        ERROR_CLUSTER_NODE_ISOLATED = 5984,
        ERROR_CLUSTER_NODE_QUARANTINED = 5985,
        ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED = 5986,
        ERROR_CLUSTER_SPACE_DEGRADED = 5987,
        ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED = 5988,
        ERROR_CLUSTER_CSV_INVALID_HANDLE = 5989,
        ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR = 5990,
        ERROR_GROUPSET_NOT_AVAILABLE = 5991,
        ERROR_GROUPSET_NOT_FOUND = 5992,
        ERROR_GROUPSET_CANT_PROVIDE = 5993,
        ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND = 5994,
        ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY = 5995,
        ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION = 5996,
        ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS = 5997,
        ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME = 5998,
        ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE = 5999,
        ERROR_ENCRYPTION_FAILED = 6000,
        ERROR_DECRYPTION_FAILED = 6001,
        ERROR_FILE_ENCRYPTED = 6002,
        ERROR_NO_RECOVERY_POLICY = 6003,
        ERROR_NO_EFS = 6004,
        ERROR_WRONG_EFS = 6005,
        ERROR_NO_USER_KEYS = 6006,
        ERROR_FILE_NOT_ENCRYPTED = 6007,
        ERROR_NOT_EXPORT_FORMAT = 6008,
        ERROR_FILE_READ_ONLY = 6009,
        ERROR_DIR_EFS_DISALLOWED = 6010,
        ERROR_EFS_SERVER_NOT_TRUSTED = 6011,
        ERROR_BAD_RECOVERY_POLICY = 6012,
        ERROR_EFS_ALG_BLOB_TOO_BIG = 6013,
        ERROR_VOLUME_NOT_SUPPORT_EFS = 6014,
        ERROR_EFS_DISABLED = 6015,
        ERROR_EFS_VERSION_NOT_SUPPORT = 6016,
        ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 6017,
        ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER = 6018,
        ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 6019,
        ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 6020,
        ERROR_CS_ENCRYPTION_FILE_NOT_CSE = 6021,
        ERROR_ENCRYPTION_POLICY_DENIES_OPERATION = 6022,
        ERROR_WIP_ENCRYPTION_FAILED = 6023,
        ERROR_NO_BROWSER_SERVERS_FOUND = 6118,
        SCHED_E_SERVICE_NOT_LOCALSYSTEM = 6200,
        ERROR_LOG_SECTOR_INVALID = 6600,
        ERROR_LOG_SECTOR_PARITY_INVALID = 6601,
        ERROR_LOG_SECTOR_REMAPPED = 6602,
        ERROR_LOG_BLOCK_INCOMPLETE = 6603,
        ERROR_LOG_INVALID_RANGE = 6604,
        ERROR_LOG_BLOCKS_EXHAUSTED = 6605,
        ERROR_LOG_READ_CONTEXT_INVALID = 6606,
        ERROR_LOG_RESTART_INVALID = 6607,
        ERROR_LOG_BLOCK_VERSION = 6608,
        ERROR_LOG_BLOCK_INVALID = 6609,
        ERROR_LOG_READ_MODE_INVALID = 6610,
        ERROR_LOG_NO_RESTART = 6611,
        ERROR_LOG_METADATA_CORRUPT = 6612,
        ERROR_LOG_METADATA_INVALID = 6613,
        ERROR_LOG_METADATA_INCONSISTENT = 6614,
        ERROR_LOG_RESERVATION_INVALID = 6615,
        ERROR_LOG_CANT_DELETE = 6616,
        ERROR_LOG_CONTAINER_LIMIT_EXCEEDED = 6617,
        ERROR_LOG_START_OF_LOG = 6618,
        ERROR_LOG_POLICY_ALREADY_INSTALLED = 6619,
        ERROR_LOG_POLICY_NOT_INSTALLED = 6620,
        ERROR_LOG_POLICY_INVALID = 6621,
        ERROR_LOG_POLICY_CONFLICT = 6622,
        ERROR_LOG_PINNED_ARCHIVE_TAIL = 6623,
        ERROR_LOG_RECORD_NONEXISTENT = 6624,
        ERROR_LOG_RECORDS_RESERVED_INVALID = 6625,
        ERROR_LOG_SPACE_RESERVED_INVALID = 6626,
        ERROR_LOG_TAIL_INVALID = 6627,
        ERROR_LOG_FULL = 6628,
        ERROR_COULD_NOT_RESIZE_LOG = 6629,
        ERROR_LOG_MULTIPLEXED = 6630,
        ERROR_LOG_DEDICATED = 6631,
        ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS = 6632,
        ERROR_LOG_ARCHIVE_IN_PROGRESS = 6633,
        ERROR_LOG_EPHEMERAL = 6634,
        ERROR_LOG_NOT_ENOUGH_CONTAINERS = 6635,
        ERROR_LOG_CLIENT_ALREADY_REGISTERED = 6636,
        ERROR_LOG_CLIENT_NOT_REGISTERED = 6637,
        ERROR_LOG_FULL_HANDLER_IN_PROGRESS = 6638,
        ERROR_LOG_CONTAINER_READ_FAILED = 6639,
        ERROR_LOG_CONTAINER_WRITE_FAILED = 6640,
        ERROR_LOG_CONTAINER_OPEN_FAILED = 6641,
        ERROR_LOG_CONTAINER_STATE_INVALID = 6642,
        ERROR_LOG_STATE_INVALID = 6643,
        ERROR_LOG_PINNED = 6644,
        ERROR_LOG_METADATA_FLUSH_FAILED = 6645,
        ERROR_LOG_INCONSISTENT_SECURITY = 6646,
        ERROR_LOG_APPENDED_FLUSH_FAILED = 6647,
        ERROR_LOG_PINNED_RESERVATION = 6648,
        ERROR_INVALID_TRANSACTION = 6700,
        ERROR_TRANSACTION_NOT_ACTIVE = 6701,
        ERROR_TRANSACTION_REQUEST_NOT_VALID = 6702,
        ERROR_TRANSACTION_NOT_REQUESTED = 6703,
        ERROR_TRANSACTION_ALREADY_ABORTED = 6704,
        ERROR_TRANSACTION_ALREADY_COMMITTED = 6705,
        ERROR_TM_INITIALIZATION_FAILED = 6706,
        ERROR_RESOURCEMANAGER_READ_ONLY = 6707,
        ERROR_TRANSACTION_NOT_JOINED = 6708,
        ERROR_TRANSACTION_SUPERIOR_EXISTS = 6709,
        ERROR_CRM_PROTOCOL_ALREADY_EXISTS = 6710,
        ERROR_TRANSACTION_PROPAGATION_FAILED = 6711,
        ERROR_CRM_PROTOCOL_NOT_FOUND = 6712,
        ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER = 6713,
        ERROR_CURRENT_TRANSACTION_NOT_VALID = 6714,
        ERROR_TRANSACTION_NOT_FOUND = 6715,
        ERROR_RESOURCEMANAGER_NOT_FOUND = 6716,
        ERROR_ENLISTMENT_NOT_FOUND = 6717,
        ERROR_TRANSACTIONMANAGER_NOT_FOUND = 6718,
        ERROR_TRANSACTIONMANAGER_NOT_ONLINE = 6719,
        ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 6720,
        ERROR_TRANSACTION_NOT_ROOT = 6721,
        ERROR_TRANSACTION_OBJECT_EXPIRED = 6722,
        ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED = 6723,
        ERROR_TRANSACTION_RECORD_TOO_LONG = 6724,
        ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED = 6725,
        ERROR_TRANSACTION_INTEGRITY_VIOLATED = 6726,
        ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 6727,
        ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = 6728,
        ERROR_TRANSACTION_MUST_WRITETHROUGH = 6729,
        ERROR_TRANSACTION_NO_SUPERIOR = 6730,
        ERROR_HEURISTIC_DAMAGE_POSSIBLE = 6731,
        ERROR_TRANSACTIONAL_CONFLICT = 6800,
        ERROR_RM_NOT_ACTIVE = 6801,
        ERROR_RM_METADATA_CORRUPT = 6802,
        ERROR_DIRECTORY_NOT_RM = 6803,
        ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE = 6805,
        ERROR_LOG_RESIZE_INVALID_SIZE = 6806,
        ERROR_OBJECT_NO_LONGER_EXISTS = 6807,
        ERROR_STREAM_MINIVERSION_NOT_FOUND = 6808,
        ERROR_STREAM_MINIVERSION_NOT_VALID = 6809,
        ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = 6810,
        ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 6811,
        ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS = 6812,
        ERROR_REMOTE_FILE_VERSION_MISMATCH = 6814,
        ERROR_HANDLE_NO_LONGER_VALID = 6815,
        ERROR_NO_TXF_METADATA = 6816,
        ERROR_LOG_CORRUPTION_DETECTED = 6817,
        ERROR_CANT_RECOVER_WITH_HANDLE_OPEN = 6818,
        ERROR_RM_DISCONNECTED = 6819,
        ERROR_ENLISTMENT_NOT_SUPERIOR = 6820,
        ERROR_RECOVERY_NOT_NEEDED = 6821,
        ERROR_RM_ALREADY_STARTED = 6822,
        ERROR_FILE_IDENTITY_NOT_PERSISTENT = 6823,
        ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 6824,
        ERROR_CANT_CROSS_RM_BOUNDARY = 6825,
        ERROR_TXF_DIR_NOT_EMPTY = 6826,
        ERROR_INDOUBT_TRANSACTIONS_EXIST = 6827,
        ERROR_TM_VOLATILE = 6828,
        ERROR_ROLLBACK_TIMER_EXPIRED = 6829,
        ERROR_TXF_ATTRIBUTE_CORRUPT = 6830,
        ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION = 6831,
        ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED = 6832,
        ERROR_LOG_GROWTH_FAILED = 6833,
        ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 6834,
        ERROR_TXF_METADATA_ALREADY_PRESENT = 6835,
        ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = 6836,
        ERROR_TRANSACTION_REQUIRED_PROMOTION = 6837,
        ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION = 6838,
        ERROR_TRANSACTIONS_NOT_FROZEN = 6839,
        ERROR_TRANSACTION_FREEZE_IN_PROGRESS = 6840,
        ERROR_NOT_SNAPSHOT_VOLUME = 6841,
        ERROR_NO_SAVEPOINT_WITH_OPEN_FILES = 6842,
        ERROR_DATA_LOST_REPAIR = 6843,
        ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 6844,
        ERROR_TM_IDENTITY_MISMATCH = 6845,
        ERROR_FLOATED_SECTION = 6846,
        ERROR_CANNOT_ACCEPT_TRANSACTED_WORK = 6847,
        ERROR_CANNOT_ABORT_TRANSACTIONS = 6848,
        ERROR_BAD_CLUSTERS = 6849,
        ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 6850,
        ERROR_VOLUME_DIRTY = 6851,
        ERROR_NO_LINK_TRACKING_IN_TRANSACTION = 6852,
        ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = 6853,
        ERROR_EXPIRED_HANDLE = 6854,
        ERROR_TRANSACTION_NOT_ENLISTED = 6855,
        ERROR_CTX_WINSTATION_NAME_INVALID = 7001,
        ERROR_CTX_INVALID_PD = 7002,
        ERROR_CTX_PD_NOT_FOUND = 7003,
        ERROR_CTX_WD_NOT_FOUND = 7004,
        ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY = 7005,
        ERROR_CTX_SERVICE_NAME_COLLISION = 7006,
        ERROR_CTX_CLOSE_PENDING = 7007,
        ERROR_CTX_NO_OUTBUF = 7008,
        ERROR_CTX_MODEM_INF_NOT_FOUND = 7009,
        ERROR_CTX_INVALID_MODEMNAME = 7010,
        ERROR_CTX_MODEM_RESPONSE_ERROR = 7011,
        ERROR_CTX_MODEM_RESPONSE_TIMEOUT = 7012,
        ERROR_CTX_MODEM_RESPONSE_NO_CARRIER = 7013,
        ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE = 7014,
        ERROR_CTX_MODEM_RESPONSE_BUSY = 7015,
        ERROR_CTX_MODEM_RESPONSE_VOICE = 7016,
        ERROR_CTX_TD_ERROR = 7017,
        ERROR_CTX_WINSTATION_NOT_FOUND = 7022,
        ERROR_CTX_WINSTATION_ALREADY_EXISTS = 7023,
        ERROR_CTX_WINSTATION_BUSY = 7024,
        ERROR_CTX_BAD_VIDEO_MODE = 7025,
        ERROR_CTX_GRAPHICS_INVALID = 7035,
        ERROR_CTX_LOGON_DISABLED = 7037,
        ERROR_CTX_NOT_CONSOLE = 7038,
        ERROR_CTX_CLIENT_QUERY_TIMEOUT = 7040,
        ERROR_CTX_CONSOLE_DISCONNECT = 7041,
        ERROR_CTX_CONSOLE_CONNECT = 7042,
        ERROR_CTX_SHADOW_DENIED = 7044,
        ERROR_CTX_WINSTATION_ACCESS_DENIED = 7045,
        ERROR_CTX_INVALID_WD = 7049,
        ERROR_CTX_SHADOW_INVALID = 7050,
        ERROR_CTX_SHADOW_DISABLED = 7051,
        ERROR_CTX_CLIENT_LICENSE_IN_USE = 7052,
        ERROR_CTX_CLIENT_LICENSE_NOT_SET = 7053,
        ERROR_CTX_LICENSE_NOT_AVAILABLE = 7054,
        ERROR_CTX_LICENSE_CLIENT_INVALID = 7055,
        ERROR_CTX_LICENSE_EXPIRED = 7056,
        ERROR_CTX_SHADOW_NOT_RUNNING = 7057,
        ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 7058,
        ERROR_ACTIVATION_COUNT_EXCEEDED = 7059,
        ERROR_CTX_WINSTATIONS_DISABLED = 7060,
        ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED = 7061,
        ERROR_CTX_SESSION_IN_USE = 7062,
        ERROR_CTX_NO_FORCE_LOGOFF = 7063,
        ERROR_CTX_ACCOUNT_RESTRICTION = 7064,
        ERROR_RDP_PROTOCOL_ERROR = 7065,
        ERROR_CTX_CDM_CONNECT = 7066,
        ERROR_CTX_CDM_DISCONNECT = 7067,
        ERROR_CTX_SECURITY_LAYER_ERROR = 7068,
        ERROR_TS_INCOMPATIBLE_SESSIONS = 7069,
        ERROR_TS_VIDEO_SUBSYSTEM_ERROR = 7070,
        FRS_ERR_INVALID_API_SEQUENCE = 8001,
        FRS_ERR_STARTING_SERVICE = 8002,
        FRS_ERR_STOPPING_SERVICE = 8003,
        FRS_ERR_INTERNAL_API = 8004,
        FRS_ERR_INTERNAL = 8005,
        FRS_ERR_SERVICE_COMM = 8006,
        FRS_ERR_INSUFFICIENT_PRIV = 8007,
        FRS_ERR_AUTHENTICATION = 8008,
        FRS_ERR_PARENT_INSUFFICIENT_PRIV = 8009,
        FRS_ERR_PARENT_AUTHENTICATION = 8010,
        FRS_ERR_CHILD_TO_PARENT_COMM = 8011,
        FRS_ERR_PARENT_TO_CHILD_COMM = 8012,
        FRS_ERR_SYSVOL_POPULATE = 8013,
        FRS_ERR_SYSVOL_POPULATE_TIMEOUT = 8014,
        FRS_ERR_SYSVOL_IS_BUSY = 8015,
        FRS_ERR_SYSVOL_DEMOTE = 8016,
        FRS_ERR_INVALID_SERVICE_PARAMETER = 8017,
        ERROR_DS_NOT_INSTALLED = 8200,
        ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = 8201,
        ERROR_DS_NO_ATTRIBUTE_OR_VALUE = 8202,
        ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = 8203,
        ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED = 8204,
        ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = 8205,
        ERROR_DS_BUSY = 8206,
        ERROR_DS_UNAVAILABLE = 8207,
        ERROR_DS_NO_RIDS_ALLOCATED = 8208,
        ERROR_DS_NO_MORE_RIDS = 8209,
        ERROR_DS_INCORRECT_ROLE_OWNER = 8210,
        ERROR_DS_RIDMGR_INIT_ERROR = 8211,
        ERROR_DS_OBJ_CLASS_VIOLATION = 8212,
        ERROR_DS_CANT_ON_NON_LEAF = 8213,
        ERROR_DS_CANT_ON_RDN = 8214,
        ERROR_DS_CANT_MOD_OBJ_CLASS = 8215,
        ERROR_DS_CROSS_DOM_MOVE_ERROR = 8216,
        ERROR_DS_GC_NOT_AVAILABLE = 8217,
        ERROR_SHARED_POLICY = 8218,
        ERROR_POLICY_OBJECT_NOT_FOUND = 8219,
        ERROR_POLICY_ONLY_IN_DS = 8220,
        ERROR_PROMOTION_ACTIVE = 8221,
        ERROR_NO_PROMOTION_ACTIVE = 8222,
        ERROR_DS_OPERATIONS_ERROR = 8224,
        ERROR_DS_PROTOCOL_ERROR = 8225,
        ERROR_DS_TIMELIMIT_EXCEEDED = 8226,
        ERROR_DS_SIZELIMIT_EXCEEDED = 8227,
        ERROR_DS_ADMIN_LIMIT_EXCEEDED = 8228,
        ERROR_DS_COMPARE_FALSE = 8229,
        ERROR_DS_COMPARE_TRUE = 8230,
        ERROR_DS_AUTH_METHOD_NOT_SUPPORTED = 8231,
        ERROR_DS_STRONG_AUTH_REQUIRED = 8232,
        ERROR_DS_INAPPROPRIATE_AUTH = 8233,
        ERROR_DS_AUTH_UNKNOWN = 8234,
        ERROR_DS_REFERRAL = 8235,
        ERROR_DS_UNAVAILABLE_CRIT_EXTENSION = 8236,
        ERROR_DS_CONFIDENTIALITY_REQUIRED = 8237,
        ERROR_DS_INAPPROPRIATE_MATCHING = 8238,
        ERROR_DS_CONSTRAINT_VIOLATION = 8239,
        ERROR_DS_NO_SUCH_OBJECT = 8240,
        ERROR_DS_ALIAS_PROBLEM = 8241,
        ERROR_DS_INVALID_DN_SYNTAX = 8242,
        ERROR_DS_IS_LEAF = 8243,
        ERROR_DS_ALIAS_DEREF_PROBLEM = 8244,
        ERROR_DS_UNWILLING_TO_PERFORM = 8245,
        ERROR_DS_LOOP_DETECT = 8246,
        ERROR_DS_NAMING_VIOLATION = 8247,
        ERROR_DS_OBJECT_RESULTS_TOO_LARGE = 8248,
        ERROR_DS_AFFECTS_MULTIPLE_DSAS = 8249,
        ERROR_DS_SERVER_DOWN = 8250,
        ERROR_DS_LOCAL_ERROR = 8251,
        ERROR_DS_ENCODING_ERROR = 8252,
        ERROR_DS_DECODING_ERROR = 8253,
        ERROR_DS_FILTER_UNKNOWN = 8254,
        ERROR_DS_PARAM_ERROR = 8255,
        ERROR_DS_NOT_SUPPORTED = 8256,
        ERROR_DS_NO_RESULTS_RETURNED = 8257,
        ERROR_DS_CONTROL_NOT_FOUND = 8258,
        ERROR_DS_CLIENT_LOOP = 8259,
        ERROR_DS_REFERRAL_LIMIT_EXCEEDED = 8260,
        ERROR_DS_SORT_CONTROL_MISSING = 8261,
        ERROR_DS_OFFSET_RANGE_ERROR = 8262,
        ERROR_DS_RIDMGR_DISABLED = 8263,
        ERROR_DS_ROOT_MUST_BE_NC = 8301,
        ERROR_DS_ADD_REPLICA_INHIBITED = 8302,
        ERROR_DS_ATT_NOT_DEF_IN_SCHEMA = 8303,
        ERROR_DS_MAX_OBJ_SIZE_EXCEEDED = 8304,
        ERROR_DS_OBJ_STRING_NAME_EXISTS = 8305,
        ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA = 8306,
        ERROR_DS_RDN_DOESNT_MATCH_SCHEMA = 8307,
        ERROR_DS_NO_REQUESTED_ATTS_FOUND = 8308,
        ERROR_DS_USER_BUFFER_TO_SMALL = 8309,
        ERROR_DS_ATT_IS_NOT_ON_OBJ = 8310,
        ERROR_DS_ILLEGAL_MOD_OPERATION = 8311,
        ERROR_DS_OBJ_TOO_LARGE = 8312,
        ERROR_DS_BAD_INSTANCE_TYPE = 8313,
        ERROR_DS_MASTERDSA_REQUIRED = 8314,
        ERROR_DS_OBJECT_CLASS_REQUIRED = 8315,
        ERROR_DS_MISSING_REQUIRED_ATT = 8316,
        ERROR_DS_ATT_NOT_DEF_FOR_CLASS = 8317,
        ERROR_DS_ATT_ALREADY_EXISTS = 8318,
        ERROR_DS_CANT_ADD_ATT_VALUES = 8320,
        ERROR_DS_SINGLE_VALUE_CONSTRAINT = 8321,
        ERROR_DS_RANGE_CONSTRAINT = 8322,
        ERROR_DS_ATT_VAL_ALREADY_EXISTS = 8323,
        ERROR_DS_CANT_REM_MISSING_ATT = 8324,
        ERROR_DS_CANT_REM_MISSING_ATT_VAL = 8325,
        ERROR_DS_ROOT_CANT_BE_SUBREF = 8326,
        ERROR_DS_NO_CHAINING = 8327,
        ERROR_DS_NO_CHAINED_EVAL = 8328,
        ERROR_DS_NO_PARENT_OBJECT = 8329,
        ERROR_DS_PARENT_IS_AN_ALIAS = 8330,
        ERROR_DS_CANT_MIX_MASTER_AND_REPS = 8331,
        ERROR_DS_CHILDREN_EXIST = 8332,
        ERROR_DS_OBJ_NOT_FOUND = 8333,
        ERROR_DS_ALIASED_OBJ_MISSING = 8334,
        ERROR_DS_BAD_NAME_SYNTAX = 8335,
        ERROR_DS_ALIAS_POINTS_TO_ALIAS = 8336,
        ERROR_DS_CANT_DEREF_ALIAS = 8337,
        ERROR_DS_OUT_OF_SCOPE = 8338,
        ERROR_DS_OBJECT_BEING_REMOVED = 8339,
        ERROR_DS_CANT_DELETE_DSA_OBJ = 8340,
        ERROR_DS_GENERIC_ERROR = 8341,
        ERROR_DS_DSA_MUST_BE_INT_MASTER = 8342,
        ERROR_DS_CLASS_NOT_DSA = 8343,
        ERROR_DS_INSUFF_ACCESS_RIGHTS = 8344,
        ERROR_DS_ILLEGAL_SUPERIOR = 8345,
        ERROR_DS_ATTRIBUTE_OWNED_BY_SAM = 8346,
        ERROR_DS_NAME_TOO_MANY_PARTS = 8347,
        ERROR_DS_NAME_TOO_LONG = 8348,
        ERROR_DS_NAME_VALUE_TOO_LONG = 8349,
        ERROR_DS_NAME_UNPARSEABLE = 8350,
        ERROR_DS_NAME_TYPE_UNKNOWN = 8351,
        ERROR_DS_NOT_AN_OBJECT = 8352,
        ERROR_DS_SEC_DESC_TOO_SHORT = 8353,
        ERROR_DS_SEC_DESC_INVALID = 8354,
        ERROR_DS_NO_DELETED_NAME = 8355,
        ERROR_DS_SUBREF_MUST_HAVE_PARENT = 8356,
        ERROR_DS_NCNAME_MUST_BE_NC = 8357,
        ERROR_DS_CANT_ADD_SYSTEM_ONLY = 8358,
        ERROR_DS_CLASS_MUST_BE_CONCRETE = 8359,
        ERROR_DS_INVALID_DMD = 8360,
        ERROR_DS_OBJ_GUID_EXISTS = 8361,
        ERROR_DS_NOT_ON_BACKLINK = 8362,
        ERROR_DS_NO_CROSSREF_FOR_NC = 8363,
        ERROR_DS_SHUTTING_DOWN = 8364,
        ERROR_DS_UNKNOWN_OPERATION = 8365,
        ERROR_DS_INVALID_ROLE_OWNER = 8366,
        ERROR_DS_COULDNT_CONTACT_FSMO = 8367,
        ERROR_DS_CROSS_NC_DN_RENAME = 8368,
        ERROR_DS_CANT_MOD_SYSTEM_ONLY = 8369,
        ERROR_DS_REPLICATOR_ONLY = 8370,
        ERROR_DS_OBJ_CLASS_NOT_DEFINED = 8371,
        ERROR_DS_OBJ_CLASS_NOT_SUBCLASS = 8372,
        ERROR_DS_NAME_REFERENCE_INVALID = 8373,
        ERROR_DS_CROSS_REF_EXISTS = 8374,
        ERROR_DS_CANT_DEL_MASTER_CROSSREF = 8375,
        ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD = 8376,
        ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX = 8377,
        ERROR_DS_DUP_RDN = 8378,
        ERROR_DS_DUP_OID = 8379,
        ERROR_DS_DUP_MAPI_ID = 8380,
        ERROR_DS_DUP_SCHEMA_ID_GUID = 8381,
        ERROR_DS_DUP_LDAP_DISPLAY_NAME = 8382,
        ERROR_DS_SEMANTIC_ATT_TEST = 8383,
        ERROR_DS_SYNTAX_MISMATCH = 8384,
        ERROR_DS_EXISTS_IN_MUST_HAVE = 8385,
        ERROR_DS_EXISTS_IN_MAY_HAVE = 8386,
        ERROR_DS_NONEXISTENT_MAY_HAVE = 8387,
        ERROR_DS_NONEXISTENT_MUST_HAVE = 8388,
        ERROR_DS_AUX_CLS_TEST_FAIL = 8389,
        ERROR_DS_NONEXISTENT_POSS_SUP = 8390,
        ERROR_DS_SUB_CLS_TEST_FAIL = 8391,
        ERROR_DS_BAD_RDN_ATT_ID_SYNTAX = 8392,
        ERROR_DS_EXISTS_IN_AUX_CLS = 8393,
        ERROR_DS_EXISTS_IN_SUB_CLS = 8394,
        ERROR_DS_EXISTS_IN_POSS_SUP = 8395,
        ERROR_DS_RECALCSCHEMA_FAILED = 8396,
        ERROR_DS_TREE_DELETE_NOT_FINISHED = 8397,
        ERROR_DS_CANT_DELETE = 8398,
        ERROR_DS_ATT_SCHEMA_REQ_ID = 8399,
        ERROR_DS_BAD_ATT_SCHEMA_SYNTAX = 8400,
        ERROR_DS_CANT_CACHE_ATT = 8401,
        ERROR_DS_CANT_CACHE_CLASS = 8402,
        ERROR_DS_CANT_REMOVE_ATT_CACHE = 8403,
        ERROR_DS_CANT_REMOVE_CLASS_CACHE = 8404,
        ERROR_DS_CANT_RETRIEVE_DN = 8405,
        ERROR_DS_MISSING_SUPREF = 8406,
        ERROR_DS_CANT_RETRIEVE_INSTANCE = 8407,
        ERROR_DS_CODE_INCONSISTENCY = 8408,
        ERROR_DS_DATABASE_ERROR = 8409,
        ERROR_DS_GOVERNSID_MISSING = 8410,
        ERROR_DS_MISSING_EXPECTED_ATT = 8411,
        ERROR_DS_NCNAME_MISSING_CR_REF = 8412,
        ERROR_DS_SECURITY_CHECKING_ERROR = 8413,
        ERROR_DS_SCHEMA_NOT_LOADED = 8414,
        ERROR_DS_SCHEMA_ALLOC_FAILED = 8415,
        ERROR_DS_ATT_SCHEMA_REQ_SYNTAX = 8416,
        ERROR_DS_GCVERIFY_ERROR = 8417,
        ERROR_DS_DRA_SCHEMA_MISMATCH = 8418,
        ERROR_DS_CANT_FIND_DSA_OBJ = 8419,
        ERROR_DS_CANT_FIND_EXPECTED_NC = 8420,
        ERROR_DS_CANT_FIND_NC_IN_CACHE = 8421,
        ERROR_DS_CANT_RETRIEVE_CHILD = 8422,
        ERROR_DS_SECURITY_ILLEGAL_MODIFY = 8423,
        ERROR_DS_CANT_REPLACE_HIDDEN_REC = 8424,
        ERROR_DS_BAD_HIERARCHY_FILE = 8425,
        ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED = 8426,
        ERROR_DS_CONFIG_PARAM_MISSING = 8427,
        ERROR_DS_COUNTING_AB_INDICES_FAILED = 8428,
        ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED = 8429,
        ERROR_DS_INTERNAL_FAILURE = 8430,
        ERROR_DS_UNKNOWN_ERROR = 8431,
        ERROR_DS_ROOT_REQUIRES_CLASS_TOP = 8432,
        ERROR_DS_REFUSING_FSMO_ROLES = 8433,
        ERROR_DS_MISSING_FSMO_SETTINGS = 8434,
        ERROR_DS_UNABLE_TO_SURRENDER_ROLES = 8435,
        ERROR_DS_DRA_GENERIC = 8436,
        ERROR_DS_DRA_INVALID_PARAMETER = 8437,
        ERROR_DS_DRA_BUSY = 8438,
        ERROR_DS_DRA_BAD_DN = 8439,
        ERROR_DS_DRA_BAD_NC = 8440,
        ERROR_DS_DRA_DN_EXISTS = 8441,
        ERROR_DS_DRA_INTERNAL_ERROR = 8442,
        ERROR_DS_DRA_INCONSISTENT_DIT = 8443,
        ERROR_DS_DRA_CONNECTION_FAILED = 8444,
        ERROR_DS_DRA_BAD_INSTANCE_TYPE = 8445,
        ERROR_DS_DRA_OUT_OF_MEM = 8446,
        ERROR_DS_DRA_MAIL_PROBLEM = 8447,
        ERROR_DS_DRA_REF_ALREADY_EXISTS = 8448,
        ERROR_DS_DRA_REF_NOT_FOUND = 8449,
        ERROR_DS_DRA_OBJ_IS_REP_SOURCE = 8450,
        ERROR_DS_DRA_DB_ERROR = 8451,
        ERROR_DS_DRA_NO_REPLICA = 8452,
        ERROR_DS_DRA_ACCESS_DENIED = 8453,
        ERROR_DS_DRA_NOT_SUPPORTED = 8454,
        ERROR_DS_DRA_RPC_CANCELLED = 8455,
        ERROR_DS_DRA_SOURCE_DISABLED = 8456,
        ERROR_DS_DRA_SINK_DISABLED = 8457,
        ERROR_DS_DRA_NAME_COLLISION = 8458,
        ERROR_DS_DRA_SOURCE_REINSTALLED = 8459,
        ERROR_DS_DRA_MISSING_PARENT = 8460,
        ERROR_DS_DRA_PREEMPTED = 8461,
        ERROR_DS_DRA_ABANDON_SYNC = 8462,
        ERROR_DS_DRA_SHUTDOWN = 8463,
        ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET = 8464,
        ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA = 8465,
        ERROR_DS_DRA_EXTN_CONNECTION_FAILED = 8466,
        ERROR_DS_INSTALL_SCHEMA_MISMATCH = 8467,
        ERROR_DS_DUP_LINK_ID = 8468,
        ERROR_DS_NAME_ERROR_RESOLVING = 8469,
        ERROR_DS_NAME_ERROR_NOT_FOUND = 8470,
        ERROR_DS_NAME_ERROR_NOT_UNIQUE = 8471,
        ERROR_DS_NAME_ERROR_NO_MAPPING = 8472,
        ERROR_DS_NAME_ERROR_DOMAIN_ONLY = 8473,
        ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 8474,
        ERROR_DS_CONSTRUCTED_ATT_MOD = 8475,
        ERROR_DS_WRONG_OM_OBJ_CLASS = 8476,
        ERROR_DS_DRA_REPL_PENDING = 8477,
        ERROR_DS_DS_REQUIRED = 8478,
        ERROR_DS_INVALID_LDAP_DISPLAY_NAME = 8479,
        ERROR_DS_NON_BASE_SEARCH = 8480,
        ERROR_DS_CANT_RETRIEVE_ATTS = 8481,
        ERROR_DS_BACKLINK_WITHOUT_LINK = 8482,
        ERROR_DS_EPOCH_MISMATCH = 8483,
        ERROR_DS_SRC_NAME_MISMATCH = 8484,
        ERROR_DS_SRC_AND_DST_NC_IDENTICAL = 8485,
        ERROR_DS_DST_NC_MISMATCH = 8486,
        ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC = 8487,
        ERROR_DS_SRC_GUID_MISMATCH = 8488,
        ERROR_DS_CANT_MOVE_DELETED_OBJECT = 8489,
        ERROR_DS_PDC_OPERATION_IN_PROGRESS = 8490,
        ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD = 8491,
        ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION = 8492,
        ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS = 8493,
        ERROR_DS_NC_MUST_HAVE_NC_PARENT = 8494,
        ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE = 8495,
        ERROR_DS_DST_DOMAIN_NOT_NATIVE = 8496,
        ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER = 8497,
        ERROR_DS_CANT_MOVE_ACCOUNT_GROUP = 8498,
        ERROR_DS_CANT_MOVE_RESOURCE_GROUP = 8499,
        ERROR_DS_INVALID_SEARCH_FLAG = 8500,
        ERROR_DS_NO_TREE_DELETE_ABOVE_NC = 8501,
        ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE = 8502,
        ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE = 8503,
        ERROR_DS_SAM_INIT_FAILURE = 8504,
        ERROR_DS_SENSITIVE_GROUP_VIOLATION = 8505,
        ERROR_DS_CANT_MOD_PRIMARYGROUPID = 8506,
        ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD = 8507,
        ERROR_DS_NONSAFE_SCHEMA_CHANGE = 8508,
        ERROR_DS_SCHEMA_UPDATE_DISALLOWED = 8509,
        ERROR_DS_CANT_CREATE_UNDER_SCHEMA = 8510,
        ERROR_DS_INSTALL_NO_SRC_SCH_VERSION = 8511,
        ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE = 8512,
        ERROR_DS_INVALID_GROUP_TYPE = 8513,
        ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 8514,
        ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 8515,
        ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 8516,
        ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 8517,
        ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 8518,
        ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 8519,
        ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 8520,
        ERROR_DS_HAVE_PRIMARY_MEMBERS = 8521,
        ERROR_DS_STRING_SD_CONVERSION_FAILED = 8522,
        ERROR_DS_NAMING_MASTER_GC = 8523,
        ERROR_DS_DNS_LOOKUP_FAILURE = 8524,
        ERROR_DS_COULDNT_UPDATE_SPNS = 8525,
        ERROR_DS_CANT_RETRIEVE_SD = 8526,
        ERROR_DS_KEY_NOT_UNIQUE = 8527,
        ERROR_DS_WRONG_LINKED_ATT_SYNTAX = 8528,
        ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD = 8529,
        ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY = 8530,
        ERROR_DS_CANT_START = 8531,
        ERROR_DS_INIT_FAILURE = 8532,
        ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION = 8533,
        ERROR_DS_SOURCE_DOMAIN_IN_FOREST = 8534,
        ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST = 8535,
        ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED = 8536,
        ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN = 8537,
        ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER = 8538,
        ERROR_DS_SRC_SID_EXISTS_IN_FOREST = 8539,
        ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH = 8540,
        ERROR_SAM_INIT_FAILURE = 8541,
        ERROR_DS_DRA_SCHEMA_INFO_SHIP = 8542,
        ERROR_DS_DRA_SCHEMA_CONFLICT = 8543,
        ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT = 8544,
        ERROR_DS_DRA_OBJ_NC_MISMATCH = 8545,
        ERROR_DS_NC_STILL_HAS_DSAS = 8546,
        ERROR_DS_GC_REQUIRED = 8547,
        ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 8548,
        ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 8549,
        ERROR_DS_CANT_ADD_TO_GC = 8550,
        ERROR_DS_NO_CHECKPOINT_WITH_PDC = 8551,
        ERROR_DS_SOURCE_AUDITING_NOT_ENABLED = 8552,
        ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC = 8553,
        ERROR_DS_INVALID_NAME_FOR_SPN = 8554,
        ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS = 8555,
        ERROR_DS_UNICODEPWD_NOT_IN_QUOTES = 8556,
        ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 8557,
        ERROR_DS_MUST_BE_RUN_ON_DST_DC = 8558,
        ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER = 8559,
        ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ = 8560,
        ERROR_DS_INIT_FAILURE_CONSOLE = 8561,
        ERROR_DS_SAM_INIT_FAILURE_CONSOLE = 8562,
        ERROR_DS_FOREST_VERSION_TOO_HIGH = 8563,
        ERROR_DS_DOMAIN_VERSION_TOO_HIGH = 8564,
        ERROR_DS_FOREST_VERSION_TOO_LOW = 8565,
        ERROR_DS_DOMAIN_VERSION_TOO_LOW = 8566,
        ERROR_DS_INCOMPATIBLE_VERSION = 8567,
        ERROR_DS_LOW_DSA_VERSION = 8568,
        ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN = 8569,
        ERROR_DS_NOT_SUPPORTED_SORT_ORDER = 8570,
        ERROR_DS_NAME_NOT_UNIQUE = 8571,
        ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 = 8572,
        ERROR_DS_OUT_OF_VERSION_STORE = 8573,
        ERROR_DS_INCOMPATIBLE_CONTROLS_USED = 8574,
        ERROR_DS_NO_REF_DOMAIN = 8575,
        ERROR_DS_RESERVED_LINK_ID = 8576,
        ERROR_DS_LINK_ID_NOT_AVAILABLE = 8577,
        ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 8578,
        ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE = 8579,
        ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC = 8580,
        ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG = 8581,
        ERROR_DS_MODIFYDN_WRONG_GRANDPARENT = 8582,
        ERROR_DS_NAME_ERROR_TRUST_REFERRAL = 8583,
        ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER = 8584,
        ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD = 8585,
        ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 = 8586,
        ERROR_DS_THREAD_LIMIT_EXCEEDED = 8587,
        ERROR_DS_NOT_CLOSEST = 8588,
        ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF = 8589,
        ERROR_DS_SINGLE_USER_MODE_FAILED = 8590,
        ERROR_DS_NTDSCRIPT_SYNTAX_ERROR = 8591,
        ERROR_DS_NTDSCRIPT_PROCESS_ERROR = 8592,
        ERROR_DS_DIFFERENT_REPL_EPOCHS = 8593,
        ERROR_DS_DRS_EXTENSIONS_CHANGED = 8594,
        ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR = 8595,
        ERROR_DS_NO_MSDS_INTID = 8596,
        ERROR_DS_DUP_MSDS_INTID = 8597,
        ERROR_DS_EXISTS_IN_RDNATTID = 8598,
        ERROR_DS_AUTHORIZATION_FAILED = 8599,
        ERROR_DS_INVALID_SCRIPT = 8600,
        ERROR_DS_REMOTE_CROSSREF_OP_FAILED = 8601,
        ERROR_DS_CROSS_REF_BUSY = 8602,
        ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN = 8603,
        ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC = 8604,
        ERROR_DS_DUPLICATE_ID_FOUND = 8605,
        ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT = 8606,
        ERROR_DS_GROUP_CONVERSION_ERROR = 8607,
        ERROR_DS_CANT_MOVE_APP_BASIC_GROUP = 8608,
        ERROR_DS_CANT_MOVE_APP_QUERY_GROUP = 8609,
        ERROR_DS_ROLE_NOT_VERIFIED = 8610,
        ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL = 8611,
        ERROR_DS_DOMAIN_RENAME_IN_PROGRESS = 8612,
        ERROR_DS_EXISTING_AD_CHILD_NC = 8613,
        ERROR_DS_REPL_LIFETIME_EXCEEDED = 8614,
        ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER = 8615,
        ERROR_DS_LDAP_SEND_QUEUE_FULL = 8616,
        ERROR_DS_DRA_OUT_SCHEDULE_WINDOW = 8617,
        ERROR_DS_POLICY_NOT_KNOWN = 8618,
        ERROR_NO_SITE_SETTINGS_OBJECT = 8619,
        ERROR_NO_SECRETS = 8620,
        ERROR_NO_WRITABLE_DC_FOUND = 8621,
        ERROR_DS_NO_SERVER_OBJECT = 8622,
        ERROR_DS_NO_NTDSA_OBJECT = 8623,
        ERROR_DS_NON_ASQ_SEARCH = 8624,
        ERROR_DS_AUDIT_FAILURE = 8625,
        ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE = 8626,
        ERROR_DS_INVALID_SEARCH_FLAG_TUPLE = 8627,
        ERROR_DS_HIERARCHY_TABLE_TOO_DEEP = 8628,
        ERROR_DS_DRA_CORRUPT_UTD_VECTOR = 8629,
        ERROR_DS_DRA_SECRETS_DENIED = 8630,
        ERROR_DS_RESERVED_MAPI_ID = 8631,
        ERROR_DS_MAPI_ID_NOT_AVAILABLE = 8632,
        ERROR_DS_DRA_MISSING_KRBTGT_SECRET = 8633,
        ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 8634,
        ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST = 8635,
        ERROR_INVALID_USER_PRINCIPAL_NAME = 8636,
        ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = 8637,
        ERROR_DS_OID_NOT_FOUND = 8638,
        ERROR_DS_DRA_RECYCLED_TARGET = 8639,
        ERROR_DS_DISALLOWED_NC_REDIRECT = 8640,
        ERROR_DS_HIGH_ADLDS_FFL = 8641,
        ERROR_DS_HIGH_DSA_VERSION = 8642,
        ERROR_DS_LOW_ADLDS_FFL = 8643,
        ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION = 8644,
        ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED = 8645,
        ERROR_INCORRECT_ACCOUNT_TYPE = 8646,
        ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST = 8647,
        ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST = 8648,
        ERROR_DS_MISSING_FOREST_TRUST = 8649,
        ERROR_DS_VALUE_KEY_NOT_UNIQUE = 8650,
        DNS_ERROR_RESPONSE_CODES_BASE = 900,
        DNS_ERROR_MASK = 0x0000232,
        DNS_ERROR_RCODE_FORMAT_ERROR = 9001,
        DNS_ERROR_RCODE_SERVER_FAILURE = 9002,
        DNS_ERROR_RCODE_NAME_ERROR = 9003,
        DNS_ERROR_RCODE_NOT_IMPLEMENTED = 9004,
        DNS_ERROR_RCODE_REFUSED = 9005,
        DNS_ERROR_RCODE_YXDOMAIN = 9006,
        DNS_ERROR_RCODE_YXRRSET = 9007,
        DNS_ERROR_RCODE_NXRRSET = 9008,
        DNS_ERROR_RCODE_NOTAUTH = 9009,
        DNS_ERROR_RCODE_NOTZONE = 9010,
        DNS_ERROR_RCODE_BADSIG = 9016,
        DNS_ERROR_RCODE_BADKEY = 9017,
        DNS_ERROR_RCODE_BADTIME = 9018,
        DNS_ERROR_DNSSEC_BASE = 9109,
        DNS_ERROR_KEYMASTER_REQUIRED = 9101,
        DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE = 9102,
        DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1 = 9103,
        DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS = 9104,
        DNS_ERROR_UNSUPPORTED_ALGORITHM = 9105,
        DNS_ERROR_INVALID_KEY_SIZE = 9106,
        DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE = 9107,
        DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION = 9108,
        DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR = 9109,
        DNS_ERROR_UNEXPECTED_CNG_ERROR = 9110,
        DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION = 9111,
        DNS_ERROR_KSP_NOT_ACCESSIBLE = 9112,
        DNS_ERROR_TOO_MANY_SKDS = 9113,
        DNS_ERROR_INVALID_ROLLOVER_PERIOD = 9114,
        DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET = 9115,
        DNS_ERROR_ROLLOVER_IN_PROGRESS = 9116,
        DNS_ERROR_STANDBY_KEY_NOT_PRESENT = 9117,
        DNS_ERROR_NOT_ALLOWED_ON_ZSK = 9118,
        DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD = 9119,
        DNS_ERROR_ROLLOVER_ALREADY_QUEUED = 9120,
        DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE = 9121,
        DNS_ERROR_BAD_KEYMASTER = 9122,
        DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD = 9123,
        DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT = 9124,
        DNS_ERROR_DNSSEC_IS_DISABLED = 9125,
        DNS_ERROR_INVALID_XML = 9126,
        DNS_ERROR_NO_VALID_TRUST_ANCHORS = 9127,
        DNS_ERROR_ROLLOVER_NOT_POKEABLE = 9128,
        DNS_ERROR_NSEC3_NAME_COLLISION = 9129,
        DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1 = 9130,
        DNS_ERROR_PACKET_FMT_BASE = 950,
        DNS_INFO_NO_RECORDS = 9501,
        DNS_ERROR_BAD_PACKET = 9502,
        DNS_ERROR_NO_PACKET = 9503,
        DNS_ERROR_RCODE = 9504,
        DNS_ERROR_UNSECURE_PACKET = 9505,
        DNS_REQUEST_PENDING = 9506,
        DNS_ERROR_GENERAL_API_BASE = 9550,
        DNS_ERROR_INVALID_TYPE = 9551,
        DNS_ERROR_INVALID_IP_ADDRESS = 9552,
        DNS_ERROR_INVALID_PROPERTY = 9553,
        DNS_ERROR_TRY_AGAIN_LATER = 9554,
        DNS_ERROR_NOT_UNIQUE = 9555,
        DNS_ERROR_NON_RFC_NAME = 9556,
        DNS_STATUS_FQDN = 9557,
        DNS_STATUS_DOTTED_NAME = 9558,
        DNS_STATUS_SINGLE_PART_NAME = 9559,
        DNS_ERROR_INVALID_NAME_CHAR = 9560,
        DNS_ERROR_NUMERIC_NAME = 9561,
        DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER = 9562,
        DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION = 9563,
        DNS_ERROR_CANNOT_FIND_ROOT_HINTS = 9564,
        DNS_ERROR_INCONSISTENT_ROOT_HINTS = 9565,
        DNS_ERROR_DWORD_VALUE_TOO_SMALL = 9566,
        DNS_ERROR_DWORD_VALUE_TOO_LARGE = 9567,
        DNS_ERROR_BACKGROUND_LOADING = 9568,
        DNS_ERROR_NOT_ALLOWED_ON_RODC = 9569,
        DNS_ERROR_NOT_ALLOWED_UNDER_DNAME = 9570,
        DNS_ERROR_DELEGATION_REQUIRED = 9571,
        DNS_ERROR_INVALID_POLICY_TABLE = 9572,
        DNS_ERROR_ADDRESS_REQUIRED = 9573,
        DNS_ERROR_ZONE_BASE = 960,
        DNS_ERROR_ZONE_DOES_NOT_EXIST = 9601,
        DNS_ERROR_NO_ZONE_INFO = 9602,
        DNS_ERROR_INVALID_ZONE_OPERATION = 9603,
        DNS_ERROR_ZONE_CONFIGURATION_ERROR = 9604,
        DNS_ERROR_ZONE_HAS_NO_SOA_RECORD = 9605,
        DNS_ERROR_ZONE_HAS_NO_NS_RECORDS = 9606,
        DNS_ERROR_ZONE_LOCKED = 9607,
        DNS_ERROR_ZONE_CREATION_FAILED = 9608,
        DNS_ERROR_ZONE_ALREADY_EXISTS = 9609,
        DNS_ERROR_AUTOZONE_ALREADY_EXISTS = 9610,
        DNS_ERROR_INVALID_ZONE_TYPE = 9611,
        DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP = 9612,
        DNS_ERROR_ZONE_NOT_SECONDARY = 9613,
        DNS_ERROR_NEED_SECONDARY_ADDRESSES = 9614,
        DNS_ERROR_WINS_INIT_FAILED = 9615,
        DNS_ERROR_NEED_WINS_SERVERS = 9616,
        DNS_ERROR_NBSTAT_INIT_FAILED = 9617,
        DNS_ERROR_SOA_DELETE_INVALID = 9618,
        DNS_ERROR_FORWARDER_ALREADY_EXISTS = 9619,
        DNS_ERROR_ZONE_REQUIRES_MASTER_IP = 9620,
        DNS_ERROR_ZONE_IS_SHUTDOWN = 9621,
        DNS_ERROR_ZONE_LOCKED_FOR_SIGNING = 9622,
        DNS_ERROR_DATAFILE_BASE = 965,
        DNS_ERROR_PRIMARY_REQUIRES_DATAFILE = 9651,
        DNS_ERROR_INVALID_DATAFILE_NAME = 9652,
        DNS_ERROR_DATAFILE_OPEN_FAILURE = 9653,
        DNS_ERROR_FILE_WRITEBACK_FAILED = 9654,
        DNS_ERROR_DATAFILE_PARSING = 9655,
        DNS_ERROR_DATABASE_BASE = 970,
        DNS_ERROR_RECORD_DOES_NOT_EXIST = 9701,
        DNS_ERROR_RECORD_FORMAT = 9702,
        DNS_ERROR_NODE_CREATION_FAILED = 9703,
        DNS_ERROR_UNKNOWN_RECORD_TYPE = 9704,
        DNS_ERROR_RECORD_TIMED_OUT = 9705,
        DNS_ERROR_NAME_NOT_IN_ZONE = 9706,
        DNS_ERROR_CNAME_LOOP = 9707,
        DNS_ERROR_NODE_IS_CNAME = 9708,
        DNS_ERROR_CNAME_COLLISION = 9709,
        DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT = 9710,
        DNS_ERROR_RECORD_ALREADY_EXISTS = 9711,
        DNS_ERROR_SECONDARY_DATA = 9712,
        DNS_ERROR_NO_CREATE_CACHE_DATA = 9713,
        DNS_ERROR_NAME_DOES_NOT_EXIST = 9714,
        DNS_WARNING_PTR_CREATE_FAILED = 9715,
        DNS_WARNING_DOMAIN_UNDELETED = 9716,
        DNS_ERROR_DS_UNAVAILABLE = 9717,
        DNS_ERROR_DS_ZONE_ALREADY_EXISTS = 9718,
        DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE = 9719,
        DNS_ERROR_NODE_IS_DNAME = 9720,
        DNS_ERROR_DNAME_COLLISION = 9721,
        DNS_ERROR_ALIAS_LOOP = 9722,
        DNS_ERROR_OPERATION_BASE = 975,
        DNS_INFO_AXFR_COMPLETE = 9751,
        DNS_ERROR_AXFR = 9752,
        DNS_INFO_ADDED_LOCAL_WINS = 9753,
        DNS_ERROR_SECURE_BASE = 980,
        DNS_STATUS_CONTINUE_NEEDED = 9801,
        DNS_ERROR_SETUP_BASE = 985,
        DNS_ERROR_NO_TCPIP = 9851,
        DNS_ERROR_NO_DNS_SERVERS = 9852,
        DNS_ERROR_DP_BASE = 990,
        DNS_ERROR_DP_DOES_NOT_EXIST = 9901,
        DNS_ERROR_DP_ALREADY_EXISTS = 9902,
        DNS_ERROR_DP_NOT_ENLISTED = 9903,
        DNS_ERROR_DP_ALREADY_ENLISTED = 9904,
        DNS_ERROR_DP_NOT_AVAILABLE = 9905,
        DNS_ERROR_DP_FSMO_ERROR = 9906,
        DNS_ERROR_RRL_NOT_ENABLED = 9911,
        DNS_ERROR_RRL_INVALID_WINDOW_SIZE = 9912,
        DNS_ERROR_RRL_INVALID_IPV4_PREFIX = 9913,
        DNS_ERROR_RRL_INVALID_IPV6_PREFIX = 9914,
        DNS_ERROR_RRL_INVALID_TC_RATE = 9915,
        DNS_ERROR_RRL_INVALID_LEAK_RATE = 9916,
        DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE = 9917,
        DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS = 9921,
        DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST = 9922,
        DNS_ERROR_VIRTUALIZATION_TREE_LOCKED = 9923,
        DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME = 9924,
        DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE = 9925,
        DNS_ERROR_ZONESCOPE_ALREADY_EXISTS = 9951,
        DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST = 9952,
        DNS_ERROR_DEFAULT_ZONESCOPE = 9953,
        DNS_ERROR_INVALID_ZONESCOPE_NAME = 9954,
        DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES = 9955,
        DNS_ERROR_LOAD_ZONESCOPE_FAILED = 9956,
        DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED = 9957,
        DNS_ERROR_INVALID_SCOPE_NAME = 9958,
        DNS_ERROR_SCOPE_DOES_NOT_EXIST = 9959,
        DNS_ERROR_DEFAULT_SCOPE = 9960,
        DNS_ERROR_INVALID_SCOPE_OPERATION = 9961,
        DNS_ERROR_SCOPE_LOCKED = 9962,
        DNS_ERROR_SCOPE_ALREADY_EXISTS = 9963,
        DNS_ERROR_POLICY_ALREADY_EXISTS = 9971,
        DNS_ERROR_POLICY_DOES_NOT_EXIST = 9972,
        DNS_ERROR_POLICY_INVALID_CRITERIA = 9973,
        DNS_ERROR_POLICY_INVALID_SETTINGS = 9974,
        DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED = 9975,
        DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST = 9976,
        DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS = 9977,
        DNS_ERROR_SUBNET_DOES_NOT_EXIST = 9978,
        DNS_ERROR_SUBNET_ALREADY_EXISTS = 9979,
        DNS_ERROR_POLICY_LOCKED = 9980,
        DNS_ERROR_POLICY_INVALID_WEIGHT = 9981,
        DNS_ERROR_POLICY_INVALID_NAME = 9982,
        DNS_ERROR_POLICY_MISSING_CRITERIA = 9983,
        DNS_ERROR_INVALID_CLIENT_SUBNET_NAME = 9984,
        DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID = 9985,
        DNS_ERROR_POLICY_SCOPE_MISSING = 9986,
        DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED = 9987,
        DNS_ERROR_SERVERSCOPE_IS_REFERENCED = 9988,
        DNS_ERROR_ZONESCOPE_IS_REFERENCED = 9989,
        DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET = 9990,
        DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL = 9991,
        DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL = 9992,
        DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE = 9993,
        DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN = 9994,
        DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE = 9995,
        DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY = 9996,
        WSABASEERR = 1000,
        WSAEINTR = 10004,
        WSAEBADF = 10009,
        WSAEACCES = 10013,
        WSAEFAULT = 10014,
        WSAEINVAL = 10022,
        WSAEMFILE = 10024,
        WSAEWOULDBLOCK = 10035,
        WSAEINPROGRESS = 10036,
        WSAEALREADY = 10037,
        WSAENOTSOCK = 10038,
        WSAEDESTADDRREQ = 10039,
        WSAEMSGSIZE = 10040,
        WSAEPROTOTYPE = 10041,
        WSAENOPROTOOPT = 10042,
        WSAEPROTONOSUPPORT = 10043,
        WSAESOCKTNOSUPPORT = 10044,
        WSAEOPNOTSUPP = 10045,
        WSAEPFNOSUPPORT = 10046,
        WSAEAFNOSUPPORT = 10047,
        WSAEADDRINUSE = 10048,
        WSAEADDRNOTAVAIL = 10049,
        WSAENETDOWN = 10050,
        WSAENETUNREACH = 10051,
        WSAENETRESET = 10052,
        WSAECONNABORTED = 10053,
        WSAECONNRESET = 10054,
        WSAENOBUFS = 10055,
        WSAEISCONN = 10056,
        WSAENOTCONN = 10057,
        WSAESHUTDOWN = 10058,
        WSAETOOMANYREFS = 10059,
        WSAETIMEDOUT = 10060,
        WSAECONNREFUSED = 10061,
        WSAELOOP = 10062,
        WSAENAMETOOLONG = 10063,
        WSAEHOSTDOWN = 10064,
        WSAEHOSTUNREACH = 10065,
        WSAENOTEMPTY = 10066,
        WSAEPROCLIM = 10067,
        WSAEUSERS = 10068,
        WSAEDQUOT = 10069,
        WSAESTALE = 10070,
        WSAEREMOTE = 10071,
        WSASYSNOTREADY = 10091,
        WSAVERNOTSUPPORTED = 10092,
        WSANOTINITIALISED = 10093,
        WSAEDISCON = 10101,
        WSAENOMORE = 10102,
        WSAECANCELLED = 10103,
        WSAEINVALIDPROCTABLE = 10104,
        WSAEINVALIDPROVIDER = 10105,
        WSAEPROVIDERFAILEDINIT = 10106,
        WSASYSCALLFAILURE = 10107,
        WSASERVICE_NOT_FOUND = 10108,
        WSATYPE_NOT_FOUND = 10109,
        WSA_E_NO_MORE = 10110,
        WSA_E_CANCELLED = 10111,
        WSAEREFUSED = 10112,
        WSAHOST_NOT_FOUND = 11001,
        WSATRY_AGAIN = 11002,
        WSANO_RECOVERY = 11003,
        WSANO_DATA = 11004,
        WSA_QOS_RECEIVERS = 11005,
        WSA_QOS_SENDERS = 11006,
        WSA_QOS_NO_SENDERS = 11007,
        WSA_QOS_NO_RECEIVERS = 11008,
        WSA_QOS_REQUEST_CONFIRMED = 11009,
        WSA_QOS_ADMISSION_FAILURE = 11010,
        WSA_QOS_POLICY_FAILURE = 11011,
        WSA_QOS_BAD_STYLE = 11012,
        WSA_QOS_BAD_OBJECT = 11013,
        WSA_QOS_TRAFFIC_CTRL_ERROR = 11014,
        WSA_QOS_GENERIC_ERROR = 11015,
        WSA_QOS_ESERVICETYPE = 11016,
        WSA_QOS_EFLOWSPEC = 11017,
        WSA_QOS_EPROVSPECBUF = 11018,
        WSA_QOS_EFILTERSTYLE = 11019,
        WSA_QOS_EFILTERTYPE = 11020,
        WSA_QOS_EFILTERCOUNT = 11021,
        WSA_QOS_EOBJLENGTH = 11022,
        WSA_QOS_EFLOWCOUNT = 11023,
        WSA_QOS_EUNKOWNPSOBJ = 11024,
        WSA_QOS_EPOLICYOBJ = 11025,
        WSA_QOS_EFLOWDESC = 11026,
        WSA_QOS_EPSFLOWSPEC = 11027,
        WSA_QOS_EPSFILTERSPEC = 11028,
        WSA_QOS_ESDMODEOBJ = 11029,
        WSA_QOS_ESHAPERATEOBJ = 11030,
        WSA_QOS_RESERVED_PETYPE = 11031,
        WSA_SECURE_HOST_NOT_FOUND = 11032,
        WSA_IPSEC_NAME_POLICY_ERROR = 11033,
        ERROR_IPSEC_QM_POLICY_EXISTS = 13000,
        ERROR_IPSEC_QM_POLICY_NOT_FOUND = 13001,
        ERROR_IPSEC_QM_POLICY_IN_USE = 13002,
        ERROR_IPSEC_MM_POLICY_EXISTS = 13003,
        ERROR_IPSEC_MM_POLICY_NOT_FOUND = 13004,
        ERROR_IPSEC_MM_POLICY_IN_USE = 13005,
        ERROR_IPSEC_MM_FILTER_EXISTS = 13006,
        ERROR_IPSEC_MM_FILTER_NOT_FOUND = 13007,
        ERROR_IPSEC_TRANSPORT_FILTER_EXISTS = 13008,
        ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND = 13009,
        ERROR_IPSEC_MM_AUTH_EXISTS = 13010,
        ERROR_IPSEC_MM_AUTH_NOT_FOUND = 13011,
        ERROR_IPSEC_MM_AUTH_IN_USE = 13012,
        ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND = 13013,
        ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND = 13014,
        ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND = 13015,
        ERROR_IPSEC_TUNNEL_FILTER_EXISTS = 13016,
        ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND = 13017,
        ERROR_IPSEC_MM_FILTER_PENDING_DELETION = 13018,
        ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION = 13019,
        ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION = 13020,
        ERROR_IPSEC_MM_POLICY_PENDING_DELETION = 13021,
        ERROR_IPSEC_MM_AUTH_PENDING_DELETION = 13022,
        ERROR_IPSEC_QM_POLICY_PENDING_DELETION = 13023,
        WARNING_IPSEC_MM_POLICY_PRUNED = 13024,
        WARNING_IPSEC_QM_POLICY_PRUNED = 13025,
        ERROR_IPSEC_IKE_NEG_STATUS_BEGIN = 13800,
        ERROR_IPSEC_IKE_AUTH_FAIL = 13801,
        ERROR_IPSEC_IKE_ATTRIB_FAIL = 13802,
        ERROR_IPSEC_IKE_NEGOTIATION_PENDING = 13803,
        ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR = 13804,
        ERROR_IPSEC_IKE_TIMED_OUT = 13805,
        ERROR_IPSEC_IKE_NO_CERT = 13806,
        ERROR_IPSEC_IKE_SA_DELETED = 13807,
        ERROR_IPSEC_IKE_SA_REAPED = 13808,
        ERROR_IPSEC_IKE_MM_ACQUIRE_DROP = 13809,
        ERROR_IPSEC_IKE_QM_ACQUIRE_DROP = 13810,
        ERROR_IPSEC_IKE_QUEUE_DROP_MM = 13811,
        ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM = 13812,
        ERROR_IPSEC_IKE_DROP_NO_RESPONSE = 13813,
        ERROR_IPSEC_IKE_MM_DELAY_DROP = 13814,
        ERROR_IPSEC_IKE_QM_DELAY_DROP = 13815,
        ERROR_IPSEC_IKE_ERROR = 13816,
        ERROR_IPSEC_IKE_CRL_FAILED = 13817,
        ERROR_IPSEC_IKE_INVALID_KEY_USAGE = 13818,
        ERROR_IPSEC_IKE_INVALID_CERT_TYPE = 13819,
        ERROR_IPSEC_IKE_NO_PRIVATE_KEY = 13820,
        ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY = 13821,
        ERROR_IPSEC_IKE_DH_FAIL = 13822,
        ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED = 13823,
        ERROR_IPSEC_IKE_INVALID_HEADER = 13824,
        ERROR_IPSEC_IKE_NO_POLICY = 13825,
        ERROR_IPSEC_IKE_INVALID_SIGNATURE = 13826,
        ERROR_IPSEC_IKE_KERBEROS_ERROR = 13827,
        ERROR_IPSEC_IKE_NO_PUBLIC_KEY = 13828,
        ERROR_IPSEC_IKE_PROCESS_ERR = 13829,
        ERROR_IPSEC_IKE_PROCESS_ERR_SA = 13830,
        ERROR_IPSEC_IKE_PROCESS_ERR_PROP = 13831,
        ERROR_IPSEC_IKE_PROCESS_ERR_TRANS = 13832,
        ERROR_IPSEC_IKE_PROCESS_ERR_KE = 13833,
        ERROR_IPSEC_IKE_PROCESS_ERR_ID = 13834,
        ERROR_IPSEC_IKE_PROCESS_ERR_CERT = 13835,
        ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ = 13836,
        ERROR_IPSEC_IKE_PROCESS_ERR_HASH = 13837,
        ERROR_IPSEC_IKE_PROCESS_ERR_SIG = 13838,
        ERROR_IPSEC_IKE_PROCESS_ERR_NONCE = 13839,
        ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY = 13840,
        ERROR_IPSEC_IKE_PROCESS_ERR_DELETE = 13841,
        ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR = 13842,
        ERROR_IPSEC_IKE_INVALID_PAYLOAD = 13843,
        ERROR_IPSEC_IKE_LOAD_SOFT_SA = 13844,
        ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN = 13845,
        ERROR_IPSEC_IKE_INVALID_COOKIE = 13846,
        ERROR_IPSEC_IKE_NO_PEER_CERT = 13847,
        ERROR_IPSEC_IKE_PEER_CRL_FAILED = 13848,
        ERROR_IPSEC_IKE_POLICY_CHANGE = 13849,
        ERROR_IPSEC_IKE_NO_MM_POLICY = 13850,
        ERROR_IPSEC_IKE_NOTCBPRIV = 13851,
        ERROR_IPSEC_IKE_SECLOADFAIL = 13852,
        ERROR_IPSEC_IKE_FAILSSPINIT = 13853,
        ERROR_IPSEC_IKE_FAILQUERYSSP = 13854,
        ERROR_IPSEC_IKE_SRVACQFAIL = 13855,
        ERROR_IPSEC_IKE_SRVQUERYCRED = 13856,
        ERROR_IPSEC_IKE_GETSPIFAIL = 13857,
        ERROR_IPSEC_IKE_INVALID_FILTER = 13858,
        ERROR_IPSEC_IKE_OUT_OF_MEMORY = 13859,
        ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED = 13860,
        ERROR_IPSEC_IKE_INVALID_POLICY = 13861,
        ERROR_IPSEC_IKE_UNKNOWN_DOI = 13862,
        ERROR_IPSEC_IKE_INVALID_SITUATION = 13863,
        ERROR_IPSEC_IKE_DH_FAILURE = 13864,
        ERROR_IPSEC_IKE_INVALID_GROUP = 13865,
        ERROR_IPSEC_IKE_ENCRYPT = 13866,
        ERROR_IPSEC_IKE_DECRYPT = 13867,
        ERROR_IPSEC_IKE_POLICY_MATCH = 13868,
        ERROR_IPSEC_IKE_UNSUPPORTED_ID = 13869,
        ERROR_IPSEC_IKE_INVALID_HASH = 13870,
        ERROR_IPSEC_IKE_INVALID_HASH_ALG = 13871,
        ERROR_IPSEC_IKE_INVALID_HASH_SIZE = 13872,
        ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG = 13873,
        ERROR_IPSEC_IKE_INVALID_AUTH_ALG = 13874,
        ERROR_IPSEC_IKE_INVALID_SIG = 13875,
        ERROR_IPSEC_IKE_LOAD_FAILED = 13876,
        ERROR_IPSEC_IKE_RPC_DELETE = 13877,
        ERROR_IPSEC_IKE_BENIGN_REINIT = 13878,
        ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY = 13879,
        ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION = 13880,
        ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN = 13881,
        ERROR_IPSEC_IKE_MM_LIMIT = 13882,
        ERROR_IPSEC_IKE_NEGOTIATION_DISABLED = 13883,
        ERROR_IPSEC_IKE_QM_LIMIT = 13884,
        ERROR_IPSEC_IKE_MM_EXPIRED = 13885,
        ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID = 13886,
        ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH = 13887,
        ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID = 13888,
        ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD = 13889,
        ERROR_IPSEC_IKE_DOS_COOKIE_SENT = 13890,
        ERROR_IPSEC_IKE_SHUTTING_DOWN = 13891,
        ERROR_IPSEC_IKE_CGA_AUTH_FAILED = 13892,
        ERROR_IPSEC_IKE_PROCESS_ERR_NATOA = 13893,
        ERROR_IPSEC_IKE_INVALID_MM_FOR_QM = 13894,
        ERROR_IPSEC_IKE_QM_EXPIRED = 13895,
        ERROR_IPSEC_IKE_TOO_MANY_FILTERS = 13896,
        ERROR_IPSEC_IKE_NEG_STATUS_END = 13897,
        ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL = 13898,
        ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE = 13899,
        ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING = 13900,
        ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING = 13901,
        ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS = 13902,
        ERROR_IPSEC_IKE_RATELIMIT_DROP = 13903,
        ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE = 13904,
        ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE = 13905,
        ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE = 13906,
        ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY = 13907,
        ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE = 13908,
        ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END = 13909,
        ERROR_IPSEC_BAD_SPI = 13910,
        ERROR_IPSEC_SA_LIFETIME_EXPIRED = 13911,
        ERROR_IPSEC_WRONG_SA = 13912,
        ERROR_IPSEC_REPLAY_CHECK_FAILED = 13913,
        ERROR_IPSEC_INVALID_PACKET = 13914,
        ERROR_IPSEC_INTEGRITY_CHECK_FAILED = 13915,
        ERROR_IPSEC_CLEAR_TEXT_DROP = 13916,
        ERROR_IPSEC_AUTH_FIREWALL_DROP = 13917,
        ERROR_IPSEC_THROTTLE_DROP = 13918,
        ERROR_IPSEC_DOSP_BLOCK = 13925,
        ERROR_IPSEC_DOSP_RECEIVED_MULTICAST = 13926,
        ERROR_IPSEC_DOSP_INVALID_PACKET = 13927,
        ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED = 13928,
        ERROR_IPSEC_DOSP_MAX_ENTRIES = 13929,
        ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = 13930,
        ERROR_IPSEC_DOSP_NOT_INSTALLED = 13931,
        ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 13932,
        ERROR_SXS_SECTION_NOT_FOUND = 14000,
        ERROR_SXS_CANT_GEN_ACTCTX = 14001,
        ERROR_SXS_INVALID_ACTCTXDATA_FORMAT = 14002,
        ERROR_SXS_ASSEMBLY_NOT_FOUND = 14003,
        ERROR_SXS_MANIFEST_FORMAT_ERROR = 14004,
        ERROR_SXS_MANIFEST_PARSE_ERROR = 14005,
        ERROR_SXS_ACTIVATION_CONTEXT_DISABLED = 14006,
        ERROR_SXS_KEY_NOT_FOUND = 14007,
        ERROR_SXS_VERSION_CONFLICT = 14008,
        ERROR_SXS_WRONG_SECTION_TYPE = 14009,
        ERROR_SXS_THREAD_QUERIES_DISABLED = 14010,
        ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET = 14011,
        ERROR_SXS_UNKNOWN_ENCODING_GROUP = 14012,
        ERROR_SXS_UNKNOWN_ENCODING = 14013,
        ERROR_SXS_INVALID_XML_NAMESPACE_URI = 14014,
        ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED = 14015,
        ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED = 14016,
        ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE = 14017,
        ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE = 14018,
        ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE = 14019,
        ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT = 14020,
        ERROR_SXS_DUPLICATE_DLL_NAME = 14021,
        ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME = 14022,
        ERROR_SXS_DUPLICATE_CLSID = 14023,
        ERROR_SXS_DUPLICATE_IID = 14024,
        ERROR_SXS_DUPLICATE_TLBID = 14025,
        ERROR_SXS_DUPLICATE_PROGID = 14026,
        ERROR_SXS_DUPLICATE_ASSEMBLY_NAME = 14027,
        ERROR_SXS_FILE_HASH_MISMATCH = 14028,
        ERROR_SXS_POLICY_PARSE_ERROR = 14029,
        ERROR_SXS_XML_E_MISSINGQUOTE = 14030,
        ERROR_SXS_XML_E_COMMENTSYNTAX = 14031,
        ERROR_SXS_XML_E_BADSTARTNAMECHAR = 14032,
        ERROR_SXS_XML_E_BADNAMECHAR = 14033,
        ERROR_SXS_XML_E_BADCHARINSTRING = 14034,
        ERROR_SXS_XML_E_XMLDECLSYNTAX = 14035,
        ERROR_SXS_XML_E_BADCHARDATA = 14036,
        ERROR_SXS_XML_E_MISSINGWHITESPACE = 14037,
        ERROR_SXS_XML_E_EXPECTINGTAGEND = 14038,
        ERROR_SXS_XML_E_MISSINGSEMICOLON = 14039,
        ERROR_SXS_XML_E_UNBALANCEDPAREN = 14040,
        ERROR_SXS_XML_E_INTERNALERROR = 14041,
        ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE = 14042,
        ERROR_SXS_XML_E_INCOMPLETE_ENCODING = 14043,
        ERROR_SXS_XML_E_MISSING_PAREN = 14044,
        ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE = 14045,
        ERROR_SXS_XML_E_MULTIPLE_COLONS = 14046,
        ERROR_SXS_XML_E_INVALID_DECIMAL = 14047,
        ERROR_SXS_XML_E_INVALID_HEXIDECIMAL = 14048,
        ERROR_SXS_XML_E_INVALID_UNICODE = 14049,
        ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK = 14050,
        ERROR_SXS_XML_E_UNEXPECTEDENDTAG = 14051,
        ERROR_SXS_XML_E_UNCLOSEDTAG = 14052,
        ERROR_SXS_XML_E_DUPLICATEATTRIBUTE = 14053,
        ERROR_SXS_XML_E_MULTIPLEROOTS = 14054,
        ERROR_SXS_XML_E_INVALIDATROOTLEVEL = 14055,
        ERROR_SXS_XML_E_BADXMLDECL = 14056,
        ERROR_SXS_XML_E_MISSINGROOT = 14057,
        ERROR_SXS_XML_E_UNEXPECTEDEOF = 14058,
        ERROR_SXS_XML_E_BADPEREFINSUBSET = 14059,
        ERROR_SXS_XML_E_UNCLOSEDSTARTTAG = 14060,
        ERROR_SXS_XML_E_UNCLOSEDENDTAG = 14061,
        ERROR_SXS_XML_E_UNCLOSEDSTRING = 14062,
        ERROR_SXS_XML_E_UNCLOSEDCOMMENT = 14063,
        ERROR_SXS_XML_E_UNCLOSEDDECL = 14064,
        ERROR_SXS_XML_E_UNCLOSEDCDATA = 14065,
        ERROR_SXS_XML_E_RESERVEDNAMESPACE = 14066,
        ERROR_SXS_XML_E_INVALIDENCODING = 14067,
        ERROR_SXS_XML_E_INVALIDSWITCH = 14068,
        ERROR_SXS_XML_E_BADXMLCASE = 14069,
        ERROR_SXS_XML_E_INVALID_STANDALONE = 14070,
        ERROR_SXS_XML_E_UNEXPECTED_STANDALONE = 14071,
        ERROR_SXS_XML_E_INVALID_VERSION = 14072,
        ERROR_SXS_XML_E_MISSINGEQUALS = 14073,
        ERROR_SXS_PROTECTION_RECOVERY_FAILED = 14074,
        ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT = 14075,
        ERROR_SXS_PROTECTION_CATALOG_NOT_VALID = 14076,
        ERROR_SXS_UNTRANSLATABLE_HRESULT = 14077,
        ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING = 14078,
        ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE = 14079,
        ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME = 14080,
        ERROR_SXS_ASSEMBLY_MISSING = 14081,
        ERROR_SXS_CORRUPT_ACTIVATION_STACK = 14082,
        ERROR_SXS_CORRUPTION = 14083,
        ERROR_SXS_EARLY_DEACTIVATION = 14084,
        ERROR_SXS_INVALID_DEACTIVATION = 14085,
        ERROR_SXS_MULTIPLE_DEACTIVATION = 14086,
        ERROR_SXS_PROCESS_TERMINATION_REQUESTED = 14087,
        ERROR_SXS_RELEASE_ACTIVATION_CONTEXT = 14088,
        ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 14089,
        ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 14090,
        ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 14091,
        ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 14092,
        ERROR_SXS_IDENTITY_PARSE_ERROR = 14093,
        ERROR_MALFORMED_SUBSTITUTION_STRING = 14094,
        ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN = 14095,
        ERROR_UNMAPPED_SUBSTITUTION_STRING = 14096,
        ERROR_SXS_ASSEMBLY_NOT_LOCKED = 14097,
        ERROR_SXS_COMPONENT_STORE_CORRUPT = 14098,
        ERROR_ADVANCED_INSTALLER_FAILED = 14099,
        ERROR_XML_ENCODING_MISMATCH = 14100,
        ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 14101,
        ERROR_SXS_IDENTITIES_DIFFERENT = 14102,
        ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 14103,
        ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY = 14104,
        ERROR_SXS_MANIFEST_TOO_BIG = 14105,
        ERROR_SXS_SETTING_NOT_REGISTERED = 14106,
        ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 14107,
        ERROR_SMI_PRIMITIVE_INSTALLER_FAILED = 14108,
        ERROR_GENERIC_COMMAND_FAILED = 14109,
        ERROR_SXS_FILE_HASH_MISSING = 14110,
        ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS = 14111,
        ERROR_EVT_INVALID_CHANNEL_PATH = 15000,
        ERROR_EVT_INVALID_QUERY = 15001,
        ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND = 15002,
        ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND = 15003,
        ERROR_EVT_INVALID_PUBLISHER_NAME = 15004,
        ERROR_EVT_INVALID_EVENT_DATA = 15005,
        ERROR_EVT_CHANNEL_NOT_FOUND = 15007,
        ERROR_EVT_MALFORMED_XML_TEXT = 15008,
        ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL = 15009,
        ERROR_EVT_CONFIGURATION_ERROR = 15010,
        ERROR_EVT_QUERY_RESULT_STALE = 15011,
        ERROR_EVT_QUERY_RESULT_INVALID_POSITION = 15012,
        ERROR_EVT_NON_VALIDATING_MSXML = 15013,
        ERROR_EVT_FILTER_ALREADYSCOPED = 15014,
        ERROR_EVT_FILTER_NOTELTSET = 15015,
        ERROR_EVT_FILTER_INVARG = 15016,
        ERROR_EVT_FILTER_INVTEST = 15017,
        ERROR_EVT_FILTER_INVTYPE = 15018,
        ERROR_EVT_FILTER_PARSEERR = 15019,
        ERROR_EVT_FILTER_UNSUPPORTEDOP = 15020,
        ERROR_EVT_FILTER_UNEXPECTEDTOKEN = 15021,
        ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL = 15022,
        ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE = 15023,
        ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE = 15024,
        ERROR_EVT_CHANNEL_CANNOT_ACTIVATE = 15025,
        ERROR_EVT_FILTER_TOO_COMPLEX = 15026,
        ERROR_EVT_MESSAGE_NOT_FOUND = 15027,
        ERROR_EVT_MESSAGE_ID_NOT_FOUND = 15028,
        ERROR_EVT_UNRESOLVED_VALUE_INSERT = 15029,
        ERROR_EVT_UNRESOLVED_PARAMETER_INSERT = 15030,
        ERROR_EVT_MAX_INSERTS_REACHED = 15031,
        ERROR_EVT_EVENT_DEFINITION_NOT_FOUND = 15032,
        ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND = 15033,
        ERROR_EVT_VERSION_TOO_OLD = 15034,
        ERROR_EVT_VERSION_TOO_NEW = 15035,
        ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY = 15036,
        ERROR_EVT_PUBLISHER_DISABLED = 15037,
        ERROR_EVT_FILTER_OUT_OF_RANGE = 15038,
        ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE = 15080,
        ERROR_EC_LOG_DISABLED = 15081,
        ERROR_EC_CIRCULAR_FORWARDING = 15082,
        ERROR_EC_CREDSTORE_FULL = 15083,
        ERROR_EC_CRED_NOT_FOUND = 15084,
        ERROR_EC_NO_ACTIVE_CHANNEL = 15085,
        ERROR_MUI_FILE_NOT_FOUND = 15100,
        ERROR_MUI_INVALID_FILE = 15101,
        ERROR_MUI_INVALID_RC_CONFIG = 15102,
        ERROR_MUI_INVALID_LOCALE_NAME = 15103,
        ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME = 15104,
        ERROR_MUI_FILE_NOT_LOADED = 15105,
        ERROR_RESOURCE_ENUM_USER_STOP = 15106,
        ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED = 15107,
        ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME = 15108,
        ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE = 15110,
        ERROR_MRM_INVALID_PRICONFIG = 15111,
        ERROR_MRM_INVALID_FILE_TYPE = 15112,
        ERROR_MRM_UNKNOWN_QUALIFIER = 15113,
        ERROR_MRM_INVALID_QUALIFIER_VALUE = 15114,
        ERROR_MRM_NO_CANDIDATE = 15115,
        ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE = 15116,
        ERROR_MRM_RESOURCE_TYPE_MISMATCH = 15117,
        ERROR_MRM_DUPLICATE_MAP_NAME = 15118,
        ERROR_MRM_DUPLICATE_ENTRY = 15119,
        ERROR_MRM_INVALID_RESOURCE_IDENTIFIER = 15120,
        ERROR_MRM_FILEPATH_TOO_LONG = 15121,
        ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE = 15122,
        ERROR_MRM_INVALID_PRI_FILE = 15126,
        ERROR_MRM_NAMED_RESOURCE_NOT_FOUND = 15127,
        ERROR_MRM_MAP_NOT_FOUND = 15135,
        ERROR_MRM_UNSUPPORTED_PROFILE_TYPE = 15136,
        ERROR_MRM_INVALID_QUALIFIER_OPERATOR = 15137,
        ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE = 15138,
        ERROR_MRM_AUTOMERGE_ENABLED = 15139,
        ERROR_MRM_TOO_MANY_RESOURCES = 15140,
        ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE = 15141,
        ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE = 15142,
        ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD = 15143,
        ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST = 15144,
        ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT = 15145,
        ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE = 15146,
        ERROR_MRM_GENERATION_COUNT_MISMATCH = 15147,
        ERROR_PRI_MERGE_VERSION_MISMATCH = 15148,
        ERROR_PRI_MERGE_MISSING_SCHEMA = 15149,
        ERROR_PRI_MERGE_LOAD_FILE_FAILED = 15150,
        ERROR_PRI_MERGE_ADD_FILE_FAILED = 15151,
        ERROR_PRI_MERGE_WRITE_FILE_FAILED = 15152,
        ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED = 15153,
        ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED = 15154,
        ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED = 15155,
        ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED = 15156,
        ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED = 15157,
        ERROR_PRI_MERGE_INVALID_FILE_NAME = 15158,
        ERROR_MRM_PACKAGE_NOT_FOUND = 15159,
        ERROR_MRM_MISSING_DEFAULT_LANGUAGE = 15160,
        ERROR_MCA_INVALID_CAPABILITIES_STRING = 15200,
        ERROR_MCA_INVALID_VCP_VERSION = 15201,
        ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = 15202,
        ERROR_MCA_MCCS_VERSION_MISMATCH = 15203,
        ERROR_MCA_UNSUPPORTED_MCCS_VERSION = 15204,
        ERROR_MCA_INTERNAL_ERROR = 15205,
        ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = 15206,
        ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE = 15207,
        ERROR_AMBIGUOUS_SYSTEM_DEVICE = 15250,
        ERROR_SYSTEM_DEVICE_NOT_FOUND = 15299,
        ERROR_HASH_NOT_SUPPORTED = 15300,
        ERROR_HASH_NOT_PRESENT = 15301,
        ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED = 15321,
        ERROR_GPIO_CLIENT_INFORMATION_INVALID = 15322,
        ERROR_GPIO_VERSION_NOT_SUPPORTED = 15323,
        ERROR_GPIO_INVALID_REGISTRATION_PACKET = 15324,
        ERROR_GPIO_OPERATION_DENIED = 15325,
        ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE = 15326,
        ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED = 15327,
        ERROR_CANNOT_SWITCH_RUNLEVEL = 15400,
        ERROR_INVALID_RUNLEVEL_SETTING = 15401,
        ERROR_RUNLEVEL_SWITCH_TIMEOUT = 15402,
        ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT = 15403,
        ERROR_RUNLEVEL_SWITCH_IN_PROGRESS = 15404,
        ERROR_SERVICES_FAILED_AUTOSTART = 15405,
        ERROR_COM_TASK_STOP_PENDING = 15501,
        ERROR_INSTALL_OPEN_PACKAGE_FAILED = 15600,
        ERROR_INSTALL_PACKAGE_NOT_FOUND = 15601,
        ERROR_INSTALL_INVALID_PACKAGE = 15602,
        ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED = 15603,
        ERROR_INSTALL_OUT_OF_DISK_SPACE = 15604,
        ERROR_INSTALL_NETWORK_FAILURE = 15605,
        ERROR_INSTALL_REGISTRATION_FAILURE = 15606,
        ERROR_INSTALL_DEREGISTRATION_FAILURE = 15607,
        ERROR_INSTALL_CANCEL = 15608,
        ERROR_INSTALL_FAILED = 15609,
        ERROR_REMOVE_FAILED = 15610,
        ERROR_PACKAGE_ALREADY_EXISTS = 15611,
        ERROR_NEEDS_REMEDIATION = 15612,
        ERROR_INSTALL_PREREQUISITE_FAILED = 15613,
        ERROR_PACKAGE_REPOSITORY_CORRUPTED = 15614,
        ERROR_INSTALL_POLICY_FAILURE = 15615,
        ERROR_PACKAGE_UPDATING = 15616,
        ERROR_DEPLOYMENT_BLOCKED_BY_POLICY = 15617,
        ERROR_PACKAGES_IN_USE = 15618,
        ERROR_RECOVERY_FILE_CORRUPT = 15619,
        ERROR_INVALID_STAGED_SIGNATURE = 15620,
        ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED = 15621,
        ERROR_INSTALL_PACKAGE_DOWNGRADE = 15622,
        ERROR_SYSTEM_NEEDS_REMEDIATION = 15623,
        ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN = 15624,
        ERROR_RESILIENCY_FILE_CORRUPT = 15625,
        ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING = 15626,
        ERROR_PACKAGE_MOVE_FAILED = 15627,
        ERROR_INSTALL_VOLUME_NOT_EMPTY = 15628,
        ERROR_INSTALL_VOLUME_OFFLINE = 15629,
        ERROR_INSTALL_VOLUME_CORRUPT = 15630,
        ERROR_NEEDS_REGISTRATION = 15631,
        ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE = 15632,
        ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED = 15633,
        ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE = 15634,
        ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM = 15635,
        ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING = 15636,
        ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE = 15637,
        ERROR_PACKAGE_STAGING_ONHOLD = 15638,
        ERROR_INSTALL_INVALID_RELATED_SET_UPDATE = 15639,
        ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY = 15640,
        ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF = 15641,
        ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED = 15642,
        ERROR_PACKAGES_REPUTATION_CHECK_FAILED = 15643,
        ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT = 15644,
        ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED = 15645,
        ERROR_APPINSTALLER_ACTIVATION_BLOCKED = 15646,
        ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED = 15647,
        ERROR_APPX_RAW_DATA_WRITE_FAILED = 15648,
        ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE = 15649,
        ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE = 15650,
        ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY = 15651,
        ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY = 15652,
        ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER = 15653,
        ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED = 15654,
        ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE = 15655,
        ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES = 15656,
        APPMODEL_ERROR_NO_PACKAGE = 15700,
        APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT = 15701,
        APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT = 15702,
        APPMODEL_ERROR_NO_APPLICATION = 15703,
        APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED = 15704,
        APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID = 15705,
        APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE = 15706,
        APPMODEL_ERROR_NO_MUTABLE_DIRECTORY = 15707,
        ERROR_STATE_LOAD_STORE_FAILED = 15800,
        ERROR_STATE_GET_VERSION_FAILED = 15801,
        ERROR_STATE_SET_VERSION_FAILED = 15802,
        ERROR_STATE_STRUCTURED_RESET_FAILED = 15803,
        ERROR_STATE_OPEN_CONTAINER_FAILED = 15804,
        ERROR_STATE_CREATE_CONTAINER_FAILED = 15805,
        ERROR_STATE_DELETE_CONTAINER_FAILED = 15806,
        ERROR_STATE_READ_SETTING_FAILED = 15807,
        ERROR_STATE_WRITE_SETTING_FAILED = 15808,
        ERROR_STATE_DELETE_SETTING_FAILED = 15809,
        ERROR_STATE_QUERY_SETTING_FAILED = 15810,
        ERROR_STATE_READ_COMPOSITE_SETTING_FAILED = 15811,
        ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED = 15812,
        ERROR_STATE_ENUMERATE_CONTAINER_FAILED = 15813,
        ERROR_STATE_ENUMERATE_SETTINGS_FAILED = 15814,
        ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = 15815,
        ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = 15816,
        ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED = 15817,
        ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED = 15818,
        ERROR_API_UNAVAILABLE = 15841,
        STORE_ERROR_UNLICENSED = 15861,
        STORE_ERROR_UNLICENSED_USER = 15862,
        STORE_ERROR_PENDING_COM_TRANSACTION = 15863,
        STORE_ERROR_LICENSE_REVOKED = 15864,
        #endregion

    };

}
```

`GUI/Helpers/Exceptions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.Helpers
{

    public class HookedDriverNotFoundException : Exception
    {
        public HookedDriverNotFoundException() : base("Cannot find hooked driver.") { }

        public HookedDriverNotFoundException(string message) : base(message) { }

        public HookedDriverNotFoundException(string message, Exception innerException) : base(message, innerException) { }
    }
}

```

`GUI/Helpers/Utils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Windows.UI.Popups;

using GUI.Helpers.Constants.Ioctl;

namespace GUI.Helpers
{
    public static class Utils
    {
        public static string Base64Encode(string plainText)
        {
            var plainTextBytes = System.Text.Encoding.UTF8.GetBytes(plainText);
            return Base64Encode(plainTextBytes);
        }

        public static string Base64Encode(byte[] plainText)
        {
            return System.Convert.ToBase64String(plainText);
        }

        public static byte[] Base64Decode(string base64EncodedData)
        {
            return System.Convert.FromBase64String(base64EncodedData);
        }

        public static async Task ShowPopUp(string msg, string title = "")
        {
            var dialog = new MessageDialog(msg, title);
            await dialog.ShowAsync();
        }


        private static string HexdumpI(byte[] bytes, int bytesPerLine = 16, bool showOffset = true, bool showAscii = true, int addressOffset = 0)
        {
            if (bytes == null) 
                return "<null>";

            char[] hexCharset = "0123456789ABCDEF".ToCharArray();
            char[] asciiCharset = "................................ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~.".ToCharArray();

            var lines = new List<string>();
            var fieldSeparator = "   ";

            for (var off = 0; off < bytes.Length; off += bytesPerLine)
            {
                var hexAddress = (addressOffset + off).ToString("x8");
                var hexaLine  = new char[3 * (bytesPerLine + 1)];
                var asciiLine = new char[bytesPerLine + 1];
                var line = new StringBuilder();

                for (int i=0, j=0, k=0; i<bytesPerLine; i++, j+=3, k++)
                {

                    if(i == bytesPerLine / 2)
                    {
                        hexaLine[j]   = ' ';
                        hexaLine[j+1] = ' ';
                        hexaLine[j+2] = ' ';
                        j += 3;

                        asciiLine[k] = ' ';
                        k++;
                    }

                    if (off + i >= bytes.Length)
                    {
                        hexaLine[j] = ' ';
                        hexaLine[j + 1] = ' ';
                        hexaLine[j + 2] = ' ';

                        asciiLine[k] = ' ';
                        continue;
                    }

                    var b = bytes[off + i];
                    hexaLine[j] = hexCharset[(b & 0xF0) >> 4];
                    hexaLine[j+1] = hexCharset[(b & 0x0F)];
                    hexaLine[j+2] = ' ';

                    if ((b & 0x80) == 0x80)
                        asciiLine[k] = '.';
                    else
                        asciiLine[k] = asciiCharset[b];
                }

                
                if(showOffset)
                {
                    line.Append(hexAddress);
                    line.Append(fieldSeparator);
                }

                line.Append(hexaLine);

                if (showAscii)
                {
                    line.Append(fieldSeparator);
                    line.Append(asciiLine);
                }

                lines.Add(line.ToString());
            }

            return String.Join(Environment.NewLine, lines.ToArray()); 
        }


        public static string Hexdump(byte[] bytes)
            => HexdumpI(bytes, 16, true, true, 0);


        public static string SimpleHexdump(byte[] bytes)
            => HexdumpI(bytes, 16, false, false, 0);


        public static byte[] StringToByteArray(string hex)
        {
            if (hex.Length % 2 == 1)
                throw new Exception("The binary key cannot have an odd number of digits");

            byte[] arr = new byte[hex.Length >> 1];

            for (int i = 0; i < hex.Length >> 1; ++i)
            {
                arr[i] = (byte)((GetHexVal(hex[i << 1]) << 4) + (GetHexVal(hex[(i << 1) + 1])));
            }

            return arr;
        }


        private static int GetHexVal(char hex)
        {
            int val = (int)hex;
            return val - (val < 58 ? 48 : 55);
        }

        public static string FormatMessage(uint Status)
            => $"{Enum.GetName(typeof(Win32Error), Status)} - 0x{Status:x8}";

        public static string PrintParsedIoctlCode(uint IoctlCode)
            => new IoctlHelperStub(IoctlCode).ToString();
    }

    public class IoctlHelperStub
    {
        public FileDeviceType DeviceType;
        public AccessType AccessType;
        public MethodType MethodType;
        public UInt16 FunctionNumber;

        public IoctlHelperStub(uint IoctlCode)
        {
            this.DeviceType = (FileDeviceType)((IoctlCode >> 16) & 0x0000ffff);
            this.AccessType = (AccessType)((IoctlCode >> 14) & 0x00000003);
            this.MethodType = (MethodType)(IoctlCode & 0x0000003);
            this.FunctionNumber = (UInt16)((IoctlCode >> 2) & 0x0000fff);
        }

        public override string ToString()
            => $"CTL_CODE(DeviceType={this.DeviceType}, Function=0x{this.FunctionNumber:x3}, Method={this.MethodType}, Access={this.AccessType})";
    }
}

```

`GUI/Models/BrokerMessage.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using GUI.Helpers;
using Newtonsoft.Json.Linq;

namespace GUI.Models
{
    /// <summary>
    /// The different message types to the Broker
    /// The values must reflect *exactly* the values defined in Broker\Task.h
    /// </summary>
    public enum MessageType : uint
    {
        GetOsInfo                    = 1,
        HookDriver                   = 2,
        UnhookDriver                 = 3,
        GetDriverInfo                = 4,
        NumberOfDriver               = 5,
        NotifyEventHandle            = 6, // don't use, todo remove
        EnableMonitoring             = 7,
        DisableMonitoring            = 8,
        GetInterceptedIrps           = 9,
        ReplayIrp                    = 10,
        StoreTestCase                = 11,
        EnumerateDrivers             = 12,
        EnableDriver                 = 13,
        DisableDriver                = 14,
        GetNamesOfHookedDrivers      = 15,
    };


    public class BrokerMessageHeader
    {
        public BrokerMessageHeader() { }

        public Win32Error gle;
        public bool is_success;
        public MessageType type;
    }
    
    public  class ReplayIrpMessage
    {
        public byte[] output_buffer;
        public int output_buffer_length;
    }

    public class GetInterceptedIrps
    {
        public uint nb_irps;
        public List<Irp> irps;
    }

    public class GetDriverListMessage
    {
        public List<String> drivers;
    }

    public class GetDriverInfo
    {
        public Driver driver;
    }

    public class GetOsInfoMessage
    {
        public uint version_major;
        public uint version_minor;
        public String version_build;
        
        public uint cpu_arch;
        public uint cpu_num;

        public String username;
        public String integrity;
        public uint pid;
        public uint version;
    }

    public class BrokerMessageBody
    {
        public BrokerMessageBody() { }

        // used by requests (generic message)
        public uint param_length;
        public string param;

        public GetDriverListMessage hooked_driver_list;
        public GetDriverListMessage driver_list;
        public GetDriverInfo driver_info;
        public GetInterceptedIrps intercepted_irps;
        public ReplayIrpMessage replay_irp;
        public GetOsInfoMessage os_info;
    }


    public class BrokerMessage
    {
        public BrokerMessageHeader header;
        public BrokerMessageBody body;

        public BrokerMessage() { }
       

        public BrokerMessage(MessageType type, byte[] args=null)
        {
            header = new BrokerMessageHeader();
            header.type = type;

            body = new BrokerMessageBody();
            if(args == null)
            {
                body.param_length = 0;
                body.param = "";
            }
            else
            {
                body.param_length = (uint)args.Length;
                body.param = Utils.Base64Encode(args);
            }
        }
    }
}

```

`GUI/Models/ConnectionManager.cs`:

```cs
using System;
using System.Collections.Generic;
using Windows.Networking;
using Windows.Networking.Sockets;
using Windows.Storage;
using System.IO;
using System.IO.Pipes;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using System.Threading.Tasks;
using Windows.UI.Popups;
using System.Threading;
using Windows.Storage.Streams;
using System.Text;
using System.Runtime.InteropServices.WindowsRuntime;

using GUI.Helpers;
using System.Diagnostics;

namespace GUI.Models
{
    public enum BrokerConnectionStatus
    {
        Disconnected,
        Connecting,
        Connected,
        WaitingForResponse,
        Disconnecting,
    }


    /// <summary>
    /// 
    /// This class manages the connection and message to the remote broker
    /// 
    /// </summary>
    public class ConnectionManager
    {
        private StreamSocket ClientSocket;
        private BrokerConnectionStatus _Status;
        private Uri uri;
        private static readonly SemaphoreSlim sem = new SemaphoreSlim(1, 1);



        public ConnectionManager()
        {
            ReinitializeSocket();
        }


        private void ReinitializeSocket()
        {
            var IrpLocation = ApplicationData.Current.LocalSettings.Values.ContainsKey("IrpBrokerLocation") ? 
                ApplicationData.Current.LocalSettings.Values["IrpBrokerLocation"].ToString() : 
                Models.DefaultSettings.IrpBrokerUri;
            uri = new Uri(IrpLocation);
            ClientSocket = new StreamSocket();
            ClientSocket.Control.KeepAlive = true;
            ClientSocket.Control.NoDelay = false;
            _Status = BrokerConnectionStatus.Disconnected;
        }

        public async Task<bool> Close()
        {
            await Task.Run( () => ClientSocket.Dispose() );
            _Status = BrokerConnectionStatus.Disconnected;
            return true;
        }


        public async Task<bool> Reconnect()
        {
            if (_Status == BrokerConnectionStatus.Connected || _Status == BrokerConnectionStatus.Connecting)
                return true;

            _ = await Close();
            ReinitializeSocket();

            _Status = BrokerConnectionStatus.Connecting;
            try
            {
                await ClientSocket.ConnectAsync(
                    new HostName(uri.Host), 
                    uri.Port.ToString(),
                    SocketProtectionLevel.PlainSocket
                );
                _Status = BrokerConnectionStatus.Connected;
            }
            catch(Exception)
            {
                _Status = BrokerConnectionStatus.Disconnected;
                throw new Exception($"failed to connect to {uri.Host}:{uri.Port}");
            }
            return true;
        }


        public bool IsConnected
        {
            get => _Status != BrokerConnectionStatus.Disconnected && _Status != BrokerConnectionStatus.Disconnecting;
        }

        public string TargetHost
        {
            get => uri.Host;
        }

        public int TargetPort
        {
            get => uri.Port;
        }

        public BrokerConnectionStatus Status
        {
            get => _Status;
        }


        private async Task SendBytes(byte[] message)
        {
            using (DataWriter writer = new DataWriter(ClientSocket.OutputStream))
            {
                writer.UnicodeEncoding = Windows.Storage.Streams.UnicodeEncoding.Utf8;
                writer.ByteOrder = Windows.Storage.Streams.ByteOrder.LittleEndian;

                try
                {
                    writer.WriteBytes(message);
                    await writer.StoreAsync();
                }
                catch (Exception exception)
                {
                    throw new Exception($"An error occured while sending message to {TargetHost}:{TargetPort}: {exception.Message}");
                }

                await writer.FlushAsync();
                writer.DetachStream();
            }
        }


        private async Task<byte[]> ReceiveBytes()
        {
            List<byte> DataReceived;

            using (DataReader reader = new DataReader(ClientSocket.InputStream))
            {
                DataReceived = new List<byte>();

                reader.InputStreamOptions = Windows.Storage.Streams.InputStreamOptions.Partial;
                reader.UnicodeEncoding = Windows.Storage.Streams.UnicodeEncoding.Utf8;
                reader.ByteOrder = Windows.Storage.Streams.ByteOrder.LittleEndian;

                uint NomimalReadSize = 256;
                uint LeftToRead = NomimalReadSize;

                do
                {
                    // prefetch data from stream
                    await reader.LoadAsync(LeftToRead);
                    LeftToRead = reader.UnconsumedBufferLength;

                    // copy all the data received locally
                    for (uint i = 0; i < LeftToRead; i++)
                        DataReceived.Add(reader.ReadByte());

                    // did we prefetch everything? if so, break out
                    if (LeftToRead < NomimalReadSize)
                        break;
                }
                while (LeftToRead > 0);

                reader.DetachStream();
                return DataReceived.ToArray();
            }
        }


        private async Task<BrokerMessage> SendAndReceive(MessageType type, byte[] args = null)
        {
            BrokerMessage req, res = null;
            req = new BrokerMessage(type, args);
            string StrResponse = "";

            await sem.WaitAsync();
            try
            {
                var req_str = JsonConvert.SerializeObject(
                            req,
                            Newtonsoft.Json.Formatting.None,
                            new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }
                );
                Debug.WriteLine($"send -> {req_str}");

                var req_raw = Encoding.UTF8.GetBytes(req_str);

                await this.SendBytes(req_raw);


                _Status = BrokerConnectionStatus.WaitingForResponse;

                while (_Status == BrokerConnectionStatus.WaitingForResponse)
                {
                    var RawResponse = await this.ReceiveBytes();
                    var res_str = Encoding.Default.GetString(RawResponse);
                    StrResponse += res_str;
                    try
                    {
                        res = JsonConvert.DeserializeObject<BrokerMessage>(StrResponse);
                    }
                    catch(Exception ex)
                    {
                        Debug.WriteLine($"SendAndReceive(): {ex.Message}");
                        continue;
                    }
                    _Status = BrokerConnectionStatus.Connected;
                }
            }
            finally
            {
                sem.Release();
            }

            Debug.WriteLine($"recv <- {StrResponse}");
            return res;
        }

        

        public async Task<List<Driver>> EnumerateDrivers()
        {
            var msg = await SendAndReceive(MessageType.EnumerateDrivers);
            if (!msg.header.is_success)
                // should never happen, EnumerateDrivers success always return true even if there is no driver
                throw new Exception($"SendAndReceive({nameof(MessageType.EnumerateDrivers)}) operation returned FALSE: 0x{msg.header.gle:x}");
                
            List<Driver> drivers = new List<Driver>();
            List<string> hooked_driver_names = await GetNamesOfHookedDrivers();

            foreach (string driver_name in msg.body.driver_list.drivers)
            {
                var d = new Driver(driver_name);
                if (hooked_driver_names.Contains(d.Name.ToLower()))
                {
                    d.IsHooked = true;
                    d.IsEnabled = true;
                }
                drivers.Add(d);
            }

            return drivers;
        }


        /// <summary>
        /// Hook the driver from its given name
        /// </summary>
        /// <param name="DriverName"></param>
        /// <returns></returns>
        public async Task<bool> HookDriver(String DriverName)
        {
            byte[] RawName = Encoding.Unicode.GetBytes($"{DriverName.ToLower()}\x00");
            var msg = await SendAndReceive(MessageType.HookDriver, RawName);
            return msg.header.is_success;
        }


        /// <summary>
        /// Unhook the driver from its given name
        /// </summary>
        /// <param name="DriverName"></param>
        /// <returns></returns>
        public async Task<bool> UnhookDriver(String DriverName)
        {
            byte[] RawName = Encoding.Unicode.GetBytes($"{DriverName.ToLower()}\x00");
            var msg = await SendAndReceive(MessageType.UnhookDriver, RawName);
            return msg.header.is_success;
        }


        /// <summary>
        /// Sends a "Start Monitoring" task to the broker
        /// </summary>
        /// <returns>True on success</returns>
        public async Task<bool> StartMonitoring()
        {
            var msg = await SendAndReceive(MessageType.EnableMonitoring);
            return msg.header.is_success;
        }


        /// <summary>
        /// Sends a "Stop Monitoring" task to the broker
        /// </summary>
        /// <returns>True on success</returns>
        public async Task<bool> StopMonitoring()
        {
            var msg = await SendAndReceive(MessageType.DisableMonitoring);
            return msg.header.is_success;
        }


        /// <summary>
        /// Get the  hooked driver info, returns a BrokerMessage with the hooked driver properties (driver object 
        /// address, whether is hooked/enabled or not, etc.) If the driver is not hooked, it returns an error with 
        /// GLE=FILE_NOT_FOUND.
        /// </summary>
        /// <param name="DriverName"></param>
        /// <returns></returns>
        public async Task<BrokerMessage> GetDriverInfo(string DriverName)
        {
            byte[] RawDriverName = Encoding.Unicode.GetBytes($"{DriverName.ToLower()}\x00");
            var msg = await SendAndReceive(MessageType.GetDriverInfo, RawDriverName);
            return msg;
        }


        /// <summary>
        /// Fetches the IRP collected by the broker (from the driver).
        /// </summary>
        /// <returns>
        /// If the operation is successful, the new IRPs can be found in a list from `BrokerMessage.body.irps`.
        /// </returns>
        public async Task<BrokerMessage> GetInterceptedIrps()
        {
            var msg = await SendAndReceive(MessageType.GetInterceptedIrps);
            return msg;
        }


        /// <summary>
        /// Gets the names of all the drivers that are hooked by IrpDumper
        /// </summary>
        /// <returns></returns>
        public async Task<List<string>> GetNamesOfHookedDrivers()
        {
            var msg = await SendAndReceive(MessageType.GetNamesOfHookedDrivers);
            if (!msg.header.is_success)
                throw new Exception($"SendAndReceive({nameof(MessageType.GetNamesOfHookedDrivers)}) operation returned FALSE: 0x{msg.header.gle:x}");

            List<string> drivers = new List<string>();

            foreach (string driver_name in msg.body.hooked_driver_list.drivers)
                drivers.Add(driver_name);

            return drivers;
        }


        public async Task<Tuple<uint, byte[]>> ReplayIrp(string DeviceName, int ioctlCode, byte[] inputBuffer, int inputBufferLength, int outputBufferLength)
        {
            string args = $@"{{ ""replay_irp"": {{
""device_name"": ""{DeviceName.Replace("\\","\\\\")}"",
""ioctl_code"": {ioctlCode},
""input_buffer"": ""{Utils.Base64Encode(inputBuffer)}"",
""input_buffer_length"": {inputBufferLength},
""output_buffer_length"": {outputBufferLength}
}} }}";

            args = args.Replace("\r", "").Replace("\n", "");
            var msg = await SendAndReceive(MessageType.ReplayIrp, Encoding.ASCII.GetBytes(args));
            byte[] outputBuffer = msg.body.replay_irp.output_buffer;

            return new Tuple<uint, byte[]>((uint)msg.header.gle,outputBuffer);
        }


        public async Task<GetOsInfoMessage> GetOsInfo()
        {
            return (await SendAndReceive(MessageType.GetOsInfo)).body.os_info;
        }
    }
}

```

`GUI/Models/Constants.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.Models
{
    public static class Constants
    {
        /// <summary>
        /// 
        /// </summary>
        public const string ProjectName = "CFB - Monitor View";

        /// <summary>
        /// 
        /// </summary>
        public const string ProjectAuthor = "@hugsy";

        /// <summary>
        /// 
        /// </summary>
        public const double ProjectVersion = 0.1;

        /// <summary>
        /// 
        /// </summary>
        public const string ProjectUrl = @"https://github.com/hugsy/cfb";

        /// <summary>
        /// 
        /// </summary>
        public const string ProjectIssueUrl = @"https://github.com/hugsy/cfb/issues";

    }


    public static class DefaultSettings
    {
        public const string IrpBrokerUri = "tcp://127.0.0.1:1337";

    }
}

```

`GUI/Models/Device.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.Models
{
    public class Device
    {
    }
}

```

`GUI/Models/Driver.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.Models
{
    public class Driver : IEquatable<Driver>
    {
        public string Name { get; set; } = "";
        public ulong Address { get; set; } = 0;
        public ulong NumberOfRequestIntercepted { get; set; } = 0;
        public bool IsEnabled { get; set; } = false;
        public bool IsHooked { get; set; } = false;


        public Driver(String name) => Name = name;
        public Driver() : this("") { }


        public bool Equals(Driver other) =>
            Address == other.Address &&
            NumberOfRequestIntercepted == other.NumberOfRequestIntercepted &&
            Name == other.Name &&
            IsEnabled == other.IsEnabled &&
            IsHooked == other.IsHooked;
    }
}

```

`GUI/Models/Irp.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using Newtonsoft.Json.Linq;

namespace GUI.Models
{

    public class IrpHeader
    {
        public ulong TimeStamp=0;
        public uint IrqLevel=0;
        public uint Type=0;
        public uint IoctlCode=0;
        public uint ProcessId=0;
        public uint ThreadId=0;
        public uint InputBufferLength=0;
        public uint OutputBufferLength=0;
        public uint Status=0;
        public string DriverName="";
        public string DeviceName="";
        public string ProcessName="";
    }


    public class IrpBody
    {
        public byte[] InputBuffer;
        public byte[] OutputBuffer;
    }

    public enum IrqLevel : uint
    {
        // Software
        PASSIVE_LEVEL                       = 0,
        LOW_LEVEL                           = 0,
        APC_LEVEL                           = 1,
        DPC_LEVEL                           = 2,

        // Hardware
        // TODO: add the rest
        // DIRQL_[3-26]
        PROFILE_LEVEL                       = 27, // 0x1B = timer used for profiling.
        CLOCK1_LEVEL                        = 28, // 0x1C = Interval clock 1 level - Not used on x86
        CLOCK2_LEVEL                        = 28, // 0x1C = Interval clock 2 level
        SYNCH_LEVEL                         = 28, // 0x1C = synchronization level
        IPI_LEVEL                           = 29, // 0x1D = Interprocessor interrupt level
        POWER_LEVEL                         = 30, // 0x1E = Power failure level
        HIGH_LEVEL                          = 31, // 0x1F = Highest interrupt level
    }


    public enum IrpMajorType : uint
    {
        IRP_MJ_CREATE                       = 0x00,
        IRP_MJ_CREATE_NAMED_PIPE            = 0x01,
        IRP_MJ_CLOSE                        = 0x02,
        IRP_MJ_READ                         = 0x03,
        IRP_MJ_WRITE                        = 0x04,
        IRP_MJ_QUERY_INFORMATION            = 0x05,
        IRP_MJ_SET_INFORMATION              = 0x06,
        IRP_MJ_QUERY_EA                     = 0x07,
        IRP_MJ_SET_EA                       = 0x08,
        IRP_MJ_FLUSH_BUFFERS                = 0x09,
        IRP_MJ_QUERY_VOLUME_INFORMATION     = 0x0a,
        IRP_MJ_SET_VOLUME_INFORMATION       = 0x0b,
        IRP_MJ_DIRECTORY_CONTROL            = 0x0c,
        IRP_MJ_FILE_SYSTEM_CONTROL          = 0x0d,
        IRP_MJ_DEVICE_CONTROL               = 0x0e,
        IRP_MJ_INTERNAL_DEVICE_CONTROL      = 0x0f,
        IRP_MJ_SHUTDOWN                     = 0x10,
        IRP_MJ_LOCK_CONTROL                 = 0x11,
        IRP_MJ_CLEANUP                      = 0x12,
        IRP_MJ_CREATE_MAILSLOT              = 0x13,
        IRP_MJ_QUERY_SECURITY               = 0x14,
        IRP_MJ_SET_SECURITY                 = 0x15,
        IRP_MJ_POWER                        = 0x16,
        IRP_MJ_SYSTEM_CONTROL               = 0x17,
        IRP_MJ_DEVICE_CHANGE                = 0x18,
        IRP_MJ_QUERY_QUOTA                  = 0x19,
        IRP_MJ_SET_QUOTA                    = 0x1a,
        IRP_MJ_PNP                          = 0x1b,
        IRP_MJ_PNP_POWER                    = IRP_MJ_PNP,
        IRP_MJ_MAX                          = IRP_MJ_PNP_POWER
    };


    /// <summary>
    /// Represents IRP
    /// </summary>
    public class Irp : IEquatable<Irp>
    {
        public IrpHeader header;
        public IrpBody body;

        public Irp() 
        {
            header = new IrpHeader();
            body = new IrpBody();
        }


        public bool Equals(Irp other) =>
            header.TimeStamp    == other.header.TimeStamp &&
            header.IrqLevel     == other.header.IrqLevel &&
            header.Type         == other.header.Type &&
            header.IoctlCode    == other.header.IoctlCode &&
            header.ProcessId    == other.header.ProcessId && 
            header.ThreadId     == other.header.ThreadId &&
            header.Status       == other.header.Status &&
            header.DriverName   == other.header.DriverName && 
            header.DeviceName   == other.header.DeviceName &&
            body.InputBuffer    == other.body.InputBuffer &&
            body.OutputBuffer   == other.body.OutputBuffer;


        public override string ToString() => 
            $"IRP{{'{header.DeviceName}', IRQL: {IrqlAsString()}, Type:{TypeAsString()}, PID:#{header.ProcessId} }}";


        public static string TypeAsString(UInt32 type)
        {
            var IrpType = (IrpMajorType)type;
            return $"{Enum.GetName(typeof(IrpMajorType), IrpType)}";
        }


        public string TypeAsString()
            => $"{TypeAsString(header.Type)} (0x{header.Type:x})";


        public static string IrqlAsString(UInt32 irql)
        {
            var irqLevel = (IrqLevel)irql;
            return $"{Enum.GetName(typeof(IrqLevel), irqLevel)}";
        }


        public string IrqlAsString()
           => $"{IrqlAsString(header.IrqLevel)} - 0x{header.IrqLevel:x}";

    }
}

```

`GUI/Models/IrpDumper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.ApplicationModel.Background;
using Windows.ApplicationModel.Core;
using Windows.Storage;
using Windows.System.Threading;
using Windows.UI.Core;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Navigation;


namespace GUI.Models
{
    /// <summary>
    /// This class operates in background and manages the IRP fetching operations.
    /// Upon receiving new IRPs it'll push them to the IrpRepository.
    /// </summary>
    public class IrpDumper
    {
        public const double IrpDumperDefaultProbeValue = 1.0; // seconds
        public const string IrpDumperTaskName = "IrpDumperBackgroundTask";
        public const string IrpDumperPollDelayKey = "BackgroundTaskPollDelay";

        private ApplicationTrigger _trigger = null;
        private BackgroundTaskRegistration _task;
        IBackgroundTaskInstance _taskInstance = null;
        BackgroundTaskDeferral _deferral = null;
        ThreadPoolTimer _periodicTimer = null;

        BackgroundTaskCancellationReason _cancelReason = BackgroundTaskCancellationReason.Abort;
        volatile bool _cancelRequested = false;
        string _cancelReasonExtra = "";


        public IrpDumper()
        {
            ResetBackgroundTask();
        }

        private void ResetBackgroundTask()
        { 
            // unregister in case the app wasn't shut down properly
            UnregisterBackgroundTask();

            _trigger = new ApplicationTrigger();
            var requestTask = BackgroundExecutionManager.RequestAccessAsync();
            var builder = new BackgroundTaskBuilder();
            builder.Name = IrpDumperTaskName;
            builder.SetTrigger(_trigger);
            _task = builder.Register();
            ApplicationData.Current.LocalSettings.Values.Remove(IrpDumperTaskName);
            ApplicationData.Current.LocalSettings.Values.Remove(IrpDumperPollDelayKey);
        }


        public async void Trigger()
            => await _trigger.RequestAsync();


        public void SetInstance(IBackgroundTaskInstance taskInstance)
        {
            _taskInstance = taskInstance;
            _deferral = taskInstance.GetDeferral();
            _taskInstance.Canceled += OnCanceled;
        }


        private bool _enabled = false;
        public bool Enabled
        {
            get => _enabled;
            set
            {
                bool success = false;
                if (value)
                    success = StartFetcher();
                else
                    success = StopFetcher();

                if (success)
                    _enabled = value;
            }
        }


        private bool StartFetcher()
        {
            Debug.WriteLine($"Starting in-process background instance '{_task.Name}'...");

            var delay = (double) (ApplicationData.Current.LocalSettings.Values[IrpDumperPollDelayKey] ?? IrpDumperDefaultProbeValue);
            _cancelRequested = false;
            _cancelReasonExtra = "";
            _periodicTimer = ThreadPoolTimer.CreatePeriodicTimer(
                new TimerElapsedHandler(PeriodicTimerCallback),
                TimeSpan.FromSeconds(delay)
            );

            return true;
        }


        private bool StopFetcher()
        {
            Debug.WriteLine($"Stopping in-process background instance '{_task.Name}'...");
            _periodicTimer.Cancel();
            _cancelRequested = true;
            _cancelReasonExtra = "UserRequest";
            return true;
        }


        private void OnCanceled(IBackgroundTaskInstance sender, BackgroundTaskCancellationReason reason)
        {
            _cancelRequested = true;
            _cancelReason = reason;
            Debug.WriteLine($"Canceled background instance '{sender.Task.Name}'");
            _deferral.Complete();
        }


        private void OnProgress(IBackgroundTaskRegistration task, BackgroundTaskProgressEventArgs args)
        {
            Debug.WriteLine($"OnProgress('{task.Name}')");
        }


        private void OnCompleted(IBackgroundTaskRegistration task, BackgroundTaskCompletedEventArgs args)
        {
            Debug.WriteLine($"OnCompleted('{task.Name}')");
        }


        //
        // Periodic callback for the task: this is where we actually do the job of fetching new IRPs
        //
        private async void PeriodicTimerCallback(ThreadPoolTimer timer)
        {
            // is there a pending cancellation request
            if (_cancelRequested)
            {
                _periodicTimer.Cancel();
                var msg = $"Cancelling background task {_task.Name }, reason: {_cancelReason.ToString()}";
                if (_cancelReasonExtra.Length > 0)
                    msg += _cancelReasonExtra;
                Debug.WriteLine(msg);
                _deferral.Complete();
                return;
            }

            try
            {
                //
                // collect the irps from the broker
                //
                List<Irp> NewIrps = new List<Irp>(); 
                var NbIrps = await FetchAllIrps(NewIrps);
                _taskInstance.Progress += (uint)NewIrps.Count;

                if(NewIrps.Count > 0)
                {
                    Debug.WriteLine($"Received {NewIrps.Count:d} new irps");

                    //
                    // push them to the db
                    //
                    foreach (var irp in NewIrps)
                    {
                        await App.Irps.Insert(irp);
                    }

                    App.ViewModel.UpdateUi();
                }

            }
            catch (Exception e)
            {
                _cancelRequested = true;
                _cancelReason = BackgroundTaskCancellationReason.ConditionLoss;
                _cancelReasonExtra = e.Message;
                StopFetcher();
            }
        }


        //
        // Fetch new IRPs
        //
        private async Task<List<Irp>> FetchIrps()
        {
            var msg = await App.BrokerSession.GetInterceptedIrps();

            if (msg.header.is_success)
                return msg.body.intercepted_irps.irps;

            throw new Exception($"GetInterceptedIrps() request returned FALSE, GLE=0x{msg.header.gle}");
        }


        //
        // Fetch all IRPs from Broker queue until it's empty
        //
        private async Task<uint> FetchAllIrps(List<Irp> Irps)
        {
            // don't allow more that number of items per request
            uint ForceFlushLimit = 512;
            uint Count = 0; 

            while(Count < ForceFlushLimit)
            {
                var irps = await FetchIrps();
                if (irps.Count == 0)
                    break;
                foreach (var irp in irps)
                    Irps.Add(irp);
                Count += (uint)irps.Count;
            }

            return Count;
        }


        //
        // Unregister the background task
        //
        private static bool UnregisterBackgroundTask()
        {
            foreach (var cur in BackgroundTaskRegistration.AllTasks)
            {
                if (cur.Value.Name == IrpDumperTaskName)
                {
                    cur.Value.Unregister(true);
                    return true;
                }
            }
            return false;
        }
    }
}

```

`GUI/Package.appxmanifest`:

```appxmanifest
<?xml version="1.0" encoding="utf-8"?>

<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  IgnorableNamespaces="uap mp">

  <Identity
    Name="7a364a05-b8d4-4a53-bba8-8a5c1a4bb25f"
    Publisher="CN=hugsy"
    Version="0.1.0.0" />

  <mp:PhoneIdentity PhoneProductId="7a364a05-b8d4-4a53-bba8-8a5c1a4bb25f" PhonePublisherId="00000000-0000-0000-0000-000000000000"/>

  <Properties>
    <DisplayName>CFB</DisplayName>
    <PublisherDisplayName>hugsy</PublisherDisplayName>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>

  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.0.0" MaxVersionTested="10.0.0.0" />
  </Dependencies>

  <Resources>
    <Resource Language="x-generate"/>
  </Resources>

  <Applications>
    <Application Id="App"
      Executable="$targetnametoken$.exe"
      EntryPoint="GUI.App">
      <uap:VisualElements
        DisplayName="CFB Monitor View"
        Square150x150Logo="Assets\Square150x150Logo.png"
        Square44x44Logo="Assets\FuriousBeaver_AppIcon.png"
        Description="UWP based GUI for Furious Beaver"
        BackgroundColor="transparent">
        <uap:DefaultTile Wide310x150Logo="Assets\Wide310x150Logo.png" ShortName="Furious Beaver">
          <uap:ShowNameOnTiles>
            <uap:ShowOn Tile="wide310x150Logo"/>
            <uap:ShowOn Tile="square150x150Logo"/>
          </uap:ShowNameOnTiles>
        </uap:DefaultTile >
        <uap:SplashScreen Image="Assets\FuriousBeaver_SplashScreen.png" />
        <uap:LockScreen Notification="badge" BadgeLogo="Assets\BadgeLogo.png"/>
      </uap:VisualElements>
    </Application>
  </Applications>

  <Capabilities>
    <Capability Name="internetClient" />
    <Capability Name="privateNetworkClientServer"/>
  </Capabilities>
</Package>
```

`GUI/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CFB App")]
[assembly: AssemblyDescription("UWP GUI for CFB")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("World Domination Corp.")]
[assembly: AssemblyProduct("CFB")]
[assembly: AssemblyCopyright("Copyright ©  2019")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: ComVisible(false)]
```

`GUI/Properties/Default.rd.xml`:

```xml
<!--
    This file contains Runtime Directives used by .NET Native. The defaults here are suitable for most
    developers. However, you can modify these parameters to modify the behavior of the .NET Native
    optimizer.

    Runtime Directives are documented at https://go.microsoft.com/fwlink/?LinkID=391919

    To fully enable reflection for App1.MyClass and all of its public/private members
    <Type Name="App1.MyClass" Dynamic="Required All"/>

    To enable dynamic creation of the specific instantiation of AppClass<T> over System.Int32
    <TypeInstantiation Name="App1.AppClass" Arguments="System.Int32" Activate="Required Public" />

    Using the Namespace directive to apply reflection policy to all the types in a particular namespace
    <Namespace Name="DataClasses.ViewModels" Serialize="All" />
-->

<Directives xmlns="http://schemas.microsoft.com/netfx/2013/01/metadata">
  <Application>
    <!--
      An Assembly element with Name="*Application*" applies to all assemblies in
      the application package. The asterisks are not wildcards.
    -->
    <Assembly Name="*Application*" Dynamic="Required All" />
    
    <!-- Add your application specific runtime directives here. -->


  </Application>
</Directives>
```

`GUI/Repositories/DriverRepository.cs`:

```cs
using GUI.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.Repositories
{
    //
    // this class contains all the object drivers fetched from the broker
    //
    public class DriverRepository : IAsyncDriverRepository
    {
        private List<Driver> _drivers = null;

        public IEnumerable<Driver> Get()
        {
            return _drivers ?? new List<Driver>();
        }


        /// <summary>
        /// Get all drivers
        /// </summary>
        /// <param name="forceRefresh"></param>
        /// <returns></returns>
        public async Task<IEnumerable<Driver>> GetAsync(bool forceRefresh=false)
        {
            if (_drivers == null || forceRefresh)
                _drivers = await App.BrokerSession.EnumerateDrivers();

            return _drivers;
        }


        /// <summary>
        /// Get all the drivers whose name matches the given patterns
        /// </summary>
        /// <param name="pattern"></param>
        /// <returns></returns>
        public async Task<IEnumerable<Driver>> GetAsync(string pattern)
        {
            string[] parameters = pattern.Split(' ');
            return await Task.Run(() =>
            {
                return _drivers
                  .Where(driver =>
                      parameters.Any(
                          parameter =>
                              driver.Name.Contains(parameter)
                      )
                  ).OrderByDescending(
                      driver =>
                          parameters.Count(parameter =>
                              driver.Name.Contains(parameter)
                          )
                  );
            });
        }

        public async Task<IEnumerable<Driver>> GetAsync(bool onlyHooked, bool onlyEnabled)
        {
            return await Task.Run(() =>
            {
                return _drivers
                     .Where(
                        x => (onlyHooked && x.IsHooked == true) ||
                            (onlyEnabled && x.IsEnabled == true)
                     );
            });
        }

        public int Count(bool onlyHooked, bool onlyEnabled)
        {
            if (_drivers == null) 
                return 0;

            if (onlyHooked || onlyEnabled)
                return _drivers
                    .Where(
                        x => (onlyHooked && x.IsHooked == true) || 
                            (onlyEnabled && x.IsEnabled == true)
                    ).Count();
            else
                return _drivers.Count();
        }

    }
}

```

`GUI/Repositories/IAsyncDriverRepository.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using GUI.Models;


namespace GUI.Repositories
{
    public interface IAsyncDriverRepository
    {
        IEnumerable<Driver> Get();

        /// <summary>
        /// Returns all drivers. 
        /// </summary>
        Task<IEnumerable<Driver>> GetAsync(bool forceRefresh=false);

        /// <summary>
        /// Returns all drivers whose names match the given pattern. 
        /// </summary>
        Task<IEnumerable<Driver>> GetAsync(string pattern);

        /// <summary>
        /// Returns all hooked drivers 
        /// </summary>
        Task<IEnumerable<Driver>> GetAsync(bool onlyHooked, bool onlyEnabled);


        int Count(bool onlyHooked, bool onlyEnabled);
    }
}


```

`GUI/Repositories/IAsyncIrpRepository.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using GUI.Models;


namespace GUI.Repositories
{
    public interface IAsyncIrpRepository
    {
        /// <summary>
        /// Returns all IRPs. 
        /// </summary>
        Task<IEnumerable<Irp>> GetAsync();


        /// <summary>
        /// Returns all IRPs matching a field matching the given pattern. 
        /// </summary>
        Task<IEnumerable<Irp>> GetAsync(string pattern);


        Task<bool> Insert(Irp irp);


        Task<bool> Clear();


        Task<bool> Delete(int id);


        int Count();
    }
}

```

`GUI/Repositories/IrpRepository.cs`:

```cs
using GUI.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.Repositories
{
    public class IrpRepository : IAsyncIrpRepository
    {
        private List<Irp> _irps = new List<Irp>();

        public async Task<bool> Clear()
        {
            return await Task.Run(() =>
            {
                _irps.Clear();
                return true;
            });
        }



        public async Task<bool> Delete(int id)
        {
            return await Task.Run(() =>
            {
                try
                {
                    _irps.RemoveAt(id);
                    return true;
                }
                catch
                {
                    return false;
                }

            });
        }



        public async Task<IEnumerable<Irp>> GetAsync()
        {
            return await Task.Run(() =>
            {
                return _irps;
            });
        }



        public async Task<IEnumerable<Irp>> GetAsync(string pattern)
        {
            string[] parameters = pattern.Split(' ');

            return await Task.Run(() =>
            {
            return _irps
              .Where(
                irp => parameters.Any(
                    parameter =>
                        irp.header.DriverName.StartsWith(parameter) ||
                        irp.header.DeviceName.StartsWith(parameter) ||
                        irp.header.ProcessName.StartsWith(parameter)
                    )
                ).OrderByDescending(
                    irp => parameters.Count(
                        parameter =>
                            irp.header.DriverName.StartsWith(parameter) ||
                            irp.header.DeviceName.StartsWith(parameter) ||
                            irp.header.ProcessName.StartsWith(parameter)
                     )
                );
            });
        }


        public async Task<bool> Insert(Irp irp)
        {
            try
            {
                await Task.Run(() =>
                {
                    _irps.Add(irp);
                });

                return true;
            }
            catch
            {
                return false;
            }
        }


        public int Count()
        {
            if (_irps == null) return 0;
            return _irps.Count();
        }
    }
}

```

`GUI/ScriptTemplates/CTemplate.txt`:

```txt
/**
 *
 * Replay IOCTL 0x{0:x} script to {1:s} (in {2:s})
 * Auto-generated by CFB
 *
 */

 // Change to 1 to build as a DLL
 #define BUILD_AS_DLL 0

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdint.h>
#include <assert.h>

#include <string>
#include <iostream>
#include <vector>

#define DEVICE_NAME   L"{1:s}"
#define DRIVER_NAME   L"{2:s}"
#define IOCTL_CODE    0x{0:x}

using namespace std;


HMODULE g_hLoadLibrary = NULL;

typedef HANDLE (WINAPI *CreateFileSig)(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
typedef BOOL (WINAPI *CloseHandleSig)(HANDLE);
typedef BOOL (WINAPI* DeviceIoControlSig)(HANDLE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
typedef DWORD (WINAPI* GetLastErrorSig)();


static inline bool unhexlify(const std::string& in, std::vector<uint8_t>& out)
{{
    for(size_t i=0; i<in.size(); i+=2)
    {{
        uint8_t hi = ((in[i] % 32 + 9) % 25) & 0x0f;
        uint8_t lo = ((in[i+1] % 32 + 9) % 25) & 0x0f;
        uint8_t b = hi<<4 | lo;
        out.push_back(b);
    }}
    return true;
}}




#if BUILD_AS_DLL == 1
extern "C" __declspec(dllexport) DWORD InjectPayload()
#else
int main(int argc, char** argv)
#endif
{{
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    BOOL bResult = FALSE;
    DWORD lpBytesReturned = 0;

    if(!g_hLoadLibrary)
        g_hLoadLibrary = GetModuleHandle(TEXT("kernel32.dll"));

    assert(g_hLoadLibrary);

    CreateFileSig pfnCreateFile = (CreateFileSig)GetProcAddress(g_hLoadLibrary, TEXT("CreateFileW"));
    CloseHandleSig pfnCloseHandle = (CloseHandleSig)GetProcAddress( g_hLoadLibrary, TEXT("CloseHandle"));
    DeviceIoControlSig pfnDeviceIoControl = (DeviceIoControlSig)GetProcAddress( g_hLoadLibrary, TEXT("DeviceIoControl"));
    GetLastErrorSig pfnGetLastError = (GetLastErrorSig)GetProcAddress( g_hLoadLibrary, TEXT("GetLastError"));

    assert( pfnCreateFile && pfnCloseHandle && pfnDeviceIoControl && pfnGetLastError);

    std::vector<uint8_t> IrpDataIn;
    unhexlify( std::string({3:s}), IrpDataIn );
    std::vector<uint8_t> IrpDataOut;
    IrpDataOut.resize({4:d});


    do
    {{
        hDevice = pfnCreateFile(
            DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );

        if (hDevice == INVALID_HANDLE_VALUE)
        {{
            break;
        }}


        bResult = pfnDeviceIoControl(
            hDevice,
            IOCTL_CODE,
            IrpDataIn.data(),
            IrpDataIn.size(),
            IrpDataOut.data(),
            IrpDataOut.size(),
            &lpBytesReturned,
            (LPOVERLAPPED) NULL
        );

        if (bResult==FALSE)
        {{
            break;
        }}
    }}
    while(0);

    if(hDevice != INVALID_HANDLE_VALUE)
    {{
        pfnCloseHandle(hDevice);
    }}

    return pfnGetLastError();
}}


#if BUILD_AS_DLL == 1
extern "C" BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{{
    switch (ul_reason_for_call)
    {{
    case DLL_PROCESS_ATTACH:
        InjectPayload();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    }}

    return TRUE;
}}

extern "C" __declspec(dllexport) DWORD TestInjection()
{{
    return ERROR_SUCCESS;
}}
#endif
```

`GUI/ScriptTemplates/PowershellTemplate.txt`:

```txt
#
#
# PowerShell replay script for IOCTL 0x{0:x} to {1:s} (in {2:s})
#
# Auto-generated by CFB
#
#


Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;	
using System.Runtime.InteropServices;	
using System.Security.Principal;

public static class CFB
{{
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr CreateFile(
        String lpFileName,
        UInt32 dwDesiredAccess,
        UInt32 dwShareMode,
        IntPtr lpSecurityAttributes,
        UInt32 dwCreationDisposition,
        UInt32 dwFlagsAndAttributes,
        IntPtr hTemplateFile
    );
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool DeviceIoControl(
        IntPtr hDevice,
        int IoControlCode,
        byte[] InBuffer,
        int nInBufferSize,
        byte[] OutBuffer,
        int nOutBufferSize,
        ref int pBytesReturned,
        IntPtr Overlapped
    );
    [DllImport("kernel32.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto)]
    public static extern bool CloseHandle(IntPtr hObject);
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern void OutputDebugString(string lpOutputString);
    [DllImport("kernel32.dll")]
    public static extern uint GetLastError();
}}
"@;

function Convert-HexToByteArray
{{
    param([parameter(Mandatory=$true)][String]$HexString)
    $Bytes = [byte[]]::new($HexString.Length / 2)
    for($i=0; $i -lt $HexString.Length; $i+=2)
    {{
        $Bytes[$i/2] = [convert]::ToByte($HexString.Substring($i, 2), 16)
    }}
    $Bytes
}}

function Debug-Info
{{
    param([string]$Message )
    [CFB]::OutputDebugString("[*] " + $Message + "`n")
    Write-Host("[*] " + $Message)
}}

function Debug-Success
{{
    param([string]$Message )
    [CFB]::OutputDebugString("[+] " + $Message + "`n")
    Write-Host("[+] " + $Message)
}}

function Debug-Error
{{
    param([string]$Message )
    [CFB]::OutputDebugString("[-] " + $Message + "`n")
    Write-Error("[-] " + $Message)
}}


$IoctlCode    = 0x{0:x}
$DeviceName   = "{1:s}"
$DriverName   = "{2:s}"
$IrpDataIn    = Convert-HexToByteArray({3:s})
$IrpDataOut   = [byte[]]::new({4:d})

Debug-Info("Getting handle to device {{0:s}}..." -f $DeviceName)

Set-Variable OPEN_EXISTING -Option Constant -Value 3
Set-Variable FILE_ATTRIBUTE_NORMAL -Option Constant -Value 0x80

$hDevice = [CFB]::CreateFile(
    $DeviceName,
    [System.IO.FileAccess]::ReadWrite,
    [System.IO.FileShare]::ReadWrite,
    [System.IntPtr]::Zero,
    $OPEN_EXISTING,
    $FILE_ATTRIBUTE_NORMAL,
    [System.IntPtr]::Zero
)

if ($hDevice -eq -1)
{{
    Debug-Error("Unable to get a handle to device {{0:s}}..." -f $DeviceName)
    Return
}}

$dwReturnLength = 0

Debug-Info("Sending request (IoctlCode=#{{0:x}}) via handle {{1:d}}..." -f $IoctlCode,$hDevice)
$res = [CFB]::DeviceIoControl(
    $hDevice,
    $IoctlCode,
    $IrpDataIn,
    $IrpDataIn.Length,
    $IrpDataOut,
    $IrpDataOut.Length,
    [ref]$dwReturnLength,
    [System.IntPtr]::Zero
)

if ( $res -eq $true )
{{
    Debug-Success("Success")
    if($dwReturnLength -gt 0)
    {{
        $IrpDataOut | Format-Hex
    }}
}}
else
{{
    Debug-Error("Failed, GetLastError=#{{0:x}}" -f [CFB]::GetLastError())
}}

Debug-Info("Closing handle {{0:d}}..." -f $hDevice)
[CFB]::CloseHandle($hDevice)

```

`GUI/ScriptTemplates/PythonTemplate.txt`:

```txt
"""

Python3 replay script for IOCTL 0x{0:x} to {1:s} (in {2:s})

Auto-generated by CFB

"""

import sys, os
from ctypes import *
from contextlib import contextmanager

try:
    import win32con
except ImportError:
    print('win32 package is required: pip install pywin32')
    sys.exit(1)

ntdll       = windll.ntdll
kernel32    = windll.kernel32
KdPrint     = lambda x:  kernel32.OutputDebugStringW(x + os.linesep)

GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 3


def hexdump(source, length=0x10):
    result = []
    for i in range(0, len(source), length):
        chunk = bytearray(source[i:i + length])
        hexa = " ".join([c for c in chunk])
        text = "".join([chr(b) if 0x20 <= b < 0x7F else "." for b in chunk])
        result.append("{{addr:#018x}}    {{data:<{{dw}}}}    {{text}}".format(addr=base+i,dw=3*length,data=hexa,text=text))
    return os.linesep.join(result)


@contextmanager
def GetDeviceHandle(DeviceName, *args, **kwargs):
    Access = kwargs.get('dwDesiredAccess', GENERIC_READ | GENERIC_WRITE)
    handle = kernel32.CreateFileW(DeviceName, Access, 0, None, OPEN_EXISTING, 0, None)
    if handle == -1: raise IOError('Cannot get handle to "%s"' % DeviceName)
    try: yield handle
    finally: kernel32.CloseHandle(handle)


def DeviceIoctlControl(DeviceName, IoctlCode, _in=b'', _out=b'', *args, **kwargs):
    dwBytesReturned = c_uint32()
    InputBufferSize = kwargs.get('_inlen', len(_in))
    OutputBufferSize = kwargs.get('_outlen', len(_out))
    InputBuffer = create_string_buffer(InputBufferSize)
    OutputBuffer = create_string_buffer(OutputBufferSize)
    InputBuffer.value = _in
    OutputBuffer.value = _out
    res = -1
    with GetDeviceHandle(DeviceName) as hDriver:
        KdPrint('Sending inbuflen=%dB to %s with ioctl=%#x (outbuflen=%dB)' % (InputBufferSize, DeviceName, IoctlCode, OutputBufferSize))
        res = kernel32.DeviceIoControl(hDriver, IoctlCode, InputBuffer, InputBufferSize, OutputBuffer, OutputBufferSize, byref(dwBytesReturned), None)
        KdPrint('Sent %dB to %s with IoctlCode %#x' % (InputBufferSize, DeviceName, IoctlCode ))
        if res:
            if dwBytesReturned: 
                print(hexdump(OutputBuffer))
        else:
            print( GetLastError(), FormatError(GetLastError()) )
    return res


def Trigger():
    DeviceName = r'''{1:s}'''
    IoctlCode = 0x{0:x}
    lpIrpDataIn = bytearray.fromhex({3:s})
    lpIrpDataOut = bytearray([0x00]*{4:d})
    # lpIrpDataIn & lpIrpDataOut can be modified freely from here
    return DeviceIoctlControl(DeviceName, IoctlCode, bytes(lpIrpDataIn), bytes(lpIrpDataOut))


if __name__ == '__main__':
    Trigger()
```

`GUI/UserControls/CollapsibleSearchBox.xaml`:

```xaml
<UserControl
    x:Class="GUI.UserControls.CollapsibleSearchBox"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI.UserControls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    d:DesignHeight="300"
    d:DesignWidth="400">

    <Grid>
        <ToggleButton
            x:Name="searchButton"
            Width="32"
            Height="32"
            HorizontalAlignment="Right"
            VerticalAlignment="Top"
            Checked="SearchButton_Checked"
            Visibility="Collapsed">
            <FontIcon
                FontFamily="Segoe MDL2 Assets"
                FontSize="12"
                Glyph="&#xE11A;" />
        </ToggleButton>

        <AutoSuggestBox
            x:Name="searchBox"
            LostFocus="SearchBox_LostFocus"
            PlaceholderText="Search..."
            QueryIcon="Find"
            Visibility="Visible" />
        
        <VisualStateManager.VisualStateGroups>
            <VisualStateGroup>
                <VisualState x:Name="OpenState" />
                <VisualState x:Name="CollapsedState">
                    <VisualState.Setters>
                        <Setter Target="searchBox.Visibility" Value="Collapsed" />
                        <Setter Target="searchButton.Visibility" Value="Visible" />
                    </VisualState.Setters>
                </VisualState>
            </VisualStateGroup>
        </VisualStateManager.VisualStateGroups>
    </Grid>
    
    
</UserControl>

```

`GUI/UserControls/CollapsibleSearchBox.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;

// The User Control item template is documented at https://go.microsoft.com/fwlink/?LinkId=234236

namespace GUI.UserControls
{
    public sealed partial class CollapsibleSearchBox : UserControl
    {
        private double RequestedWidth = 32;


        public CollapsibleSearchBox()
        {
            this.InitializeComponent();
            Loaded += CollapsableSearchBox_Loaded;
            Window.Current.SizeChanged += Current_SizeChanged;
            myAutoSuggestBox = searchBox;
        }



        public static readonly DependencyProperty CollapseWidthProperty = DependencyProperty.Register(
            "CollapseWidth", 
            typeof(double), 
            typeof(CollapsibleSearchBox), 
            new PropertyMetadata(0.0)
        );


        public double CollapseWidth
        {
            get { return (double)GetValue(CollapseWidthProperty); }
            set { SetValue(CollapseWidthProperty, value); }
        }


        private AutoSuggestBox myAutoSuggestBox;
        public AutoSuggestBox AutoSuggestBox
        {
            get { return myAutoSuggestBox; }
            private set { myAutoSuggestBox = value; }
        }


        private void CollapsableSearchBox_Loaded(object sender, RoutedEventArgs e)
        {
            RequestedWidth = Width;
            SetState(Window.Current.Bounds.Width);
        }

        private void Current_SizeChanged(object sender, Windows.UI.Core.WindowSizeChangedEventArgs e)
        {
            SetState(e.Size.Width);
        }

        private void SearchBox_LostFocus(object sender, RoutedEventArgs e)
        {
            SetState(Window.Current.Bounds.Width);
            searchButton.IsChecked = false;
        }

        private void SetState(double width)
        {
            if (width <= CollapseWidth)
            {
                VisualStateManager.GoToState(this, "CollapsedState", false);
                Width = 32;
            }
            else
            {
                VisualStateManager.GoToState(this, "OpenState", false);
                Width = RequestedWidth;
            }
        }

        private void SearchButton_Checked(object sender, RoutedEventArgs e)
        {
            VisualStateManager.GoToState(this, "OpenState", false);
            Width = RequestedWidth;
            if (searchBox != null)
            {
                searchBox.Focus(FocusState.Programmatic);
            }
        }
    }
}

```

`GUI/ViewModels/BindableBase.cs`:

```cs
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;


namespace GUI.ViewModels
{
    public abstract class BindableBase : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged([CallerMemberName] string propertyName = null) =>
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        
        protected bool Set<T>(ref T storage, T value, [CallerMemberName] String propertyName = null)
        {
            if (Equals(storage, value))
            {
                return false;
            }

            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}

```

`GUI/ViewModels/BrokerConnectionViewModel.cs`:

```cs
using GUI.Models;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.ViewModels
{
    class BrokerConnectionViewModel : INotifyPropertyChanged
    {
        private ConnectionManager Connection;

        public BrokerConnectionViewModel()
        {
            this.PropertyChanged += new PropertyChangedEventHandler(OnConnectionPropertyChanged);
            Connection = new ConnectionManager();

        }

        public BrokerConnectionStatus Status
        {
            get => Connection.Status;
        }


        private void OnConnectionPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "Status")
            {
                
            }
        }


        #region INotifyPropertyChanged
        private void OnPropertyChanged(string propName)
        {
            if (this.PropertyChanged != null)
            {
                this.PropertyChanged(this, new PropertyChangedEventArgs(propName));
            }
        }
        public event PropertyChangedEventHandler PropertyChanged;
        #endregion
    }

}

```

`GUI/ViewModels/Converters.cs`:

```cs
using GUI.Models;
using Windows.UI.Xaml;

namespace GUI.ViewModels
{
    /// <summary>
    /// Bunch of View converter helpers to improve the views
    /// </summary>
    public static class Converters
    {
        /// <summary>
        /// Returns the reverse of the provided value.
        /// </summary>
        public static bool Not(bool value) => !value;

        /// <summary>
        /// Returns true if the specified value is not null; otherwise, returns false.
        /// </summary>
        public static bool IsNotNull(object value) => value != null;

        /// <summary>
        /// Returns a default integer value of 0 if the object is null.
        /// </summary>
        public static int DefaultIntegerIfNull(object value) => value == null ? 0 : (int)value;

        /// <summary>
        /// Returns Visibility.Collapsed if the specified value is true; otherwise, returns Visibility.Visible.
        /// </summary>
        public static Visibility BooleanToVisibility(bool value) =>
            value ? Visibility.Visible : Visibility.Collapsed;

        public static bool OnlyForDeviceIoControlIrp(IrpViewModel irp) =>
            irp != null && irp.Model.header.Type == (uint)IrpMajorType.IRP_MJ_DEVICE_CONTROL;

        public static Visibility VisibleOnlyForDeviceIoControlIrp(IrpViewModel irp) =>
            irp != null && irp.Model.header.Type == (uint)IrpMajorType.IRP_MJ_DEVICE_CONTROL ? Visibility.Visible : Visibility.Collapsed;

        /// <summary>
        /// Returns Visibility.Collapsed if the specified value is true; otherwise, returns Visibility.Visible.
        /// </summary>
        public static Visibility CollapsedIf(bool value) =>
            value ? Visibility.Collapsed : Visibility.Visible;

        /// <summary>
        /// Returns Visibility.Collapsed if the specified value is true; otherwise, returns Visibility.Visible.
        /// </summary>
        public static Visibility VisibleIfGreaterThanZero(uint value) =>
            value > 0 ? Visibility.Visible : Visibility.Collapsed ;

        /// <summary>
        /// Returns Visibility.Collapsed if the specified value is null; otherwise, returns Visibility.Visible.
        /// </summary>
        public static Visibility CollapsedIfNull(object value) =>
            value == null ? Visibility.Collapsed : Visibility.Visible;

        /// <summary>
        /// Returns Visibility.Collapsed if the specified string is null or empty; otherwise, returns Visibility.Visible.
        /// </summary>
        public static Visibility CollapsedIfNullOrEmpty(string value) =>
            string.IsNullOrEmpty(value) ? Visibility.Collapsed : Visibility.Visible;

        /// <summary>
        /// Display an address as hexa string
        /// </summary>
        /// <param name="Address"></param>
        /// <returns></returns>
        public static string FormatAddressAsHex(ulong Address) =>
            $"0x{Address.ToString("X")}";

    }
}

```

`GUI/ViewModels/DriverListPageViewModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Toolkit.Uwp.Helpers;
using Windows.UI.Popups;
using System.ComponentModel;

using GUI.Models;
using GUI.Helpers;
using Windows.UI.Xaml;

namespace GUI.ViewModels
{
    public class DriverListPageViewModel : BindableBase
    {
        public DriverListPageViewModel() 
            => Task.Run(() => GetDriversAsync());


        public string EnableDisableSelectedDriverText
        {
            get
            {
                if (_selectedDriver == null)
                    return "Hook/Unhook";

                return SelectedDriver.IsHooked ? $"Unhook {SelectedDriver.Name}" : $"Hook {SelectedDriver.Name}";
            }
        }


        private bool _isLoading = false;

        public bool IsLoading
        {
            get => _isLoading;
            set => Set(ref _isLoading, value);
        }

        //
        // Collection of drivers visible from the view (set or subset of App.Drivers)
        //
        public ObservableCollection<DriverViewModel> Drivers { get; private set; } = new ObservableCollection<DriverViewModel>();

        //
        // Collection of drivers showing up in the suggestion part of the search box
        //
        public ObservableCollection<DriverViewModel> DriverSuggestions { get; } = new ObservableCollection<DriverViewModel>();


        public async Task UpdateDriverCollection(bool forceRefresh)
        {
            var drivers = await App.Drivers.GetAsync(forceRefresh);

            await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
            {
                Drivers.Clear();

                foreach (var d in drivers)
                    Drivers.Add(new DriverViewModel(d));
            });
        }


        public async Task GetDriversAsync(bool forceRefresh=false)
        {
            await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
            {
                IsLoading = true;
                Drivers.Clear();
            });

            await UpdateDriverCollection(forceRefresh);

            await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
            {
                IsLoading = false;
            });
        }


        public void ForceGetDriversAsync()
            => Task.Run(() => GetDriversAsync(true));
        

        private DriverViewModel _lastselectedDriver;
        private DriverViewModel _selectedDriver;

        public DriverViewModel SelectedDriver
        {
            get
            {
                if (_selectedDriver != null && _lastselectedDriver != _selectedDriver)
                    _selectedDriver.RefreshDriverAsync();
                _lastselectedDriver = _selectedDriver;
                return _selectedDriver;
            }
            set => Set(ref _selectedDriver, value);
        }
    }
}

```

`GUI/ViewModels/DriverViewModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using GUI.Helpers;
using GUI.Models;


namespace GUI.ViewModels
{

    public class DriverViewModel : BindableBase
    {
        public DriverViewModel(Driver model)
        {
            Model = model;
        }


        private Driver _model;


        public Driver Model
        {
            get => _model;
            set
            {
                if (_model != value)
                {
                    _model = value;
                    //Task.Run(RefreshDriverAsync);
                    OnPropertyChanged();
                }
            }
        }

        public override string ToString()
            => Name;

        public string Name
        {
            get => Model.Name;
        }

        public bool IsEnabled
        {
            get => Model.IsHooked && Model.IsEnabled;
        }

        public ulong NumberOfRequestIntercepted
        {
            get => Model.NumberOfRequestIntercepted;
        }


        public ulong Address
        {
            get => Model.Address;
        }


        public bool IsHooked
        {
            get => Model.IsHooked;
        }

        
        private void PropagateChangesToView()
        {
            Task.Run(RefreshDriverAsync);
            OnPropertyChanged();
        }


        public async Task<bool> TryToggleHookStatus()
        {
            bool data_changed = IsHooked ?
                await App.BrokerSession.UnhookDriver(Name):
                await App.BrokerSession.HookDriver(Name);

            if (data_changed)
                PropagateChangesToView();

            return data_changed;
        }


        public async void RefreshDriverAsync()
        {
            var msg = await App.BrokerSession.GetDriverInfo(Name);

            if (!msg.header.is_success)
            {
                if (msg.header.gle == Win32Error.ERROR_FILE_NOT_FOUND)
                {
                    Model.IsEnabled = false;
                    Model.IsHooked = false;
                    Model.Address = 0;
                    Model.NumberOfRequestIntercepted = 0;
                }
                else
                {
                    Model.IsEnabled = false;
                    Model.IsHooked = false;
                    Model.Address = 0;
                    Model.NumberOfRequestIntercepted = 0;
                    Model.Name = $"Error {Utils.FormatMessage((uint)msg.header.gle)}";
                }
            }
            else
            {
                var driver = msg.body.driver_info.driver;
                if(!String.Equals(driver.Name, Model.Name, StringComparison.OrdinalIgnoreCase))
                    throw new Exception("unexpected driver info");
                Model.IsHooked = true;
                Model.IsEnabled = driver.IsEnabled;
                Model.Address = driver.Address;
                Model.NumberOfRequestIntercepted = driver.NumberOfRequestIntercepted;
            }
        }
    }
}

```

`GUI/ViewModels/IrpReplayViewModel.cs`:

```cs
using GUI.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GUI.ViewModels
{
    public class IrpReplayViewModel
    {

        /// <summary>
        /// send the irp to the broker with the given inputbuffer, returns an array of byte of the result
        /// </summary>
        /// <returns></returns>
        public async Task<Tuple<uint, byte[]>> SendIrp(
            string deviceName, 
            int ioctlCode, 
            byte[] inputBuffer, 
            int inputBufferLength,
            int outputBufferLength
        )
        {
            var outputBuffer = await App.BrokerSession.ReplayIrp(
                deviceName,
                ioctlCode,
                inputBuffer,
                inputBufferLength,
                outputBufferLength
            );

            return outputBuffer;
        }

    }
}

```

`GUI/ViewModels/IrpViewModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

using Windows.ApplicationModel;
using Windows.Security.Cryptography;
using Windows.Storage;
using Windows.Storage.Provider;
using Windows.Storage.Streams;

using GUI.Helpers;
using GUI.Models;


namespace GUI.ViewModels
{
    public class IrpViewModel : BindableBase
    {

        public IrpViewModel(Irp irp = null)
            => _model = irp ?? new Irp();


        private Irp _model;
        
        public Irp Model
        {
            get => _model;
        }


        private bool _isLoading = false;

        public bool IsLoading
        {
            get => _isLoading;
            set => Set(ref _isLoading, value);
        }



        public DateTime TimeStamp       { get => DateTime.FromFileTime((long)Model.header.TimeStamp); }
        public string TimeStampString   { get => TimeStamp.ToString("yyyy/MM/dd HH:mm:ss.fffffff"); }
        public uint ProcessId           { get => Model.header.ProcessId; }
        public uint ThreadId            { get => Model.header.ThreadId; }
        public string IrqLevel          { get => Model.IrqlAsString(); }
        public string Type              { get => Model.TypeAsString(); }
        public uint IoctlCode           { get => Model.header.IoctlCode; }
        public uint Status              { get => Model.header.Status; }
        public uint InputBufferLength   { get => Model.header.InputBufferLength; }
        public uint OutputBufferLength  { get => Model.header.OutputBufferLength; }
        public string DriverName        { get => Model.header.DriverName; }
        public string DeviceName        { get => Model.header.DeviceName; }
        public string ProcessName       { get => Model.header.ProcessName; }
        public byte[] InputBuffer       { get => Model.body.InputBuffer; }
        public byte[] OutputBuffer      { get => Model.body.OutputBuffer; }

        public string IoctlCodeString    { get => 
                Model.header.Type == (uint)IrpMajorType.IRP_MJ_DEVICE_CONTROL || Model.header.Type == (uint)IrpMajorType.IRP_MJ_INTERNAL_DEVICE_CONTROL 
                ? $"0x{IoctlCode.ToString("x8")}"
                : "N/A"; }

        public string IoctlCodeDetailString { get => Utils.PrintParsedIoctlCode(this.IoctlCode); }

        public string StatusString       { get => $"0x{Status.ToString("x8")}"; }

        public string StatusFullString   { get => Utils.FormatMessage(Status); }


        private string ShowStringMax(string s, int nb)
        {
            if (s == null || s.Length == 0)
                return "";

            int len = Math.Min(s.Length, nb);

            var t = s.Substring(0, len);
            if (len == nb)
                t += "[...]";
            return t;
        }


        public string InputBufferString  { get => InputBuffer != null ? ShowStringMax(BitConverter.ToString(InputBuffer), 10 * 3): ""; }
        public string OutputBufferString { get => OutputBuffer != null ? ShowStringMax(BitConverter.ToString(OutputBuffer), 10 * 3): ""; }


        /// <summary>
        /// Export the IRP as a standalone script whose type is given as parameter.
        /// </summary>
        /// <param name="_type">File type of the script</param>
        /// <returns>True on success, Exception() upon failure</returns>
        public async Task<bool> ExportAs(string _type)
        {
            if (Model.header.Type != (uint)IrpMajorType.IRP_MJ_DEVICE_CONTROL)
                throw new Exception("Only IRP_MJ_DEVICE_CONTROL IRP can be replayed...");


            List<string> ValidTypes = new List<string>() {
                "Raw",
                "Powershell",
                "Python",
                "C"
            };

            if (!ValidTypes.Contains(_type))
            {
                throw new Exception("Invalid export type provided");
            }

            string template_filepath = null;

            if (_type != "Raw")
            {
                template_filepath = Package.Current.InstalledLocation.Path + $"\\ScriptTemplates\\{_type:s}Template.txt";
                if (!File.Exists(template_filepath))
                {
                    throw new Exception($"SaveAs{_type}Script(): missing template");
                }
            }

            return await GenerateBodyScript(_type, template_filepath);
        }

        /// <summary>
        /// Generate the script body 
        /// </summary>
        /// <param name="TypeStr"></param>
        /// <param name="template_file"></param>
        /// <returns></returns>
        private async Task<bool> GenerateBodyScript(string TypeStr, string template_file)
        {

            IBuffer output;

            if (TypeStr == "Raw")
            {
                output = CryptographicBuffer.CreateFromByteArray(this.InputBuffer);
            }
            else
            {
                var DriverName = this.DriverName;
                var DeviceName = this.DeviceName.Replace(@"\Device", @"\\.");
                if (TypeStr == "C")
                {
                    DeviceName = DeviceName.Replace(@"\", @"\\");
                    DriverName = DriverName.Replace(@"\", @"\\");
                }
                var IrpDataInStr = "";

                foreach (byte c in this.Model.body.InputBuffer)
                    IrpDataInStr += $"{c:X2}";

                var fmt = File.ReadAllText(template_file);
                output = CryptographicBuffer.ConvertStringToBinary(
                    String.Format(
                        fmt,
                        this.IoctlCode,
                        DeviceName,
                        DriverName,
                        $"\"{IrpDataInStr}\"",
                        this.OutputBufferLength
                    ),
                    BinaryStringEncoding.Utf8
                );
            }


            //
            // write it to disk
            //
            var savePicker = new Windows.Storage.Pickers.FileSavePicker();
            savePicker.SuggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.DocumentsLibrary;
            savePicker.SuggestedFileName = $"Irp-{this.IoctlCodeString}-Session-{DateTime.Now.ToString("yyyyMMddTHH:mm:ssZ")}";

            switch (TypeStr)
            {
                case "Powershell":
                    savePicker.FileTypeChoices.Add("PowerShell", new List<string>() { ".ps1" });
                    break;

                case "Python":
                    savePicker.FileTypeChoices.Add("Python", new List<string>() { ".py" });
                    break;

                case "C":
                    savePicker.FileTypeChoices.Add("C++", new List<string>() { ".cpp" });
                    break;

                case "Raw":
                    savePicker.FileTypeChoices.Add("Raw", new List<string>() { ".bin" });
                    break;
            }

            StorageFile file = await savePicker.PickSaveFileAsync();
            if (file != null)
            {
                CachedFileManager.DeferUpdates(file);
                await FileIO.WriteBufferAsync(file, output);
                FileUpdateStatus status = await CachedFileManager.CompleteUpdatesAsync(file);
                if (status == FileUpdateStatus.Complete)
                    return true;
            }

            throw new Exception($"Couldn't save IRP as a {TypeStr} script...");
        }
    }
}

```

`GUI/ViewModels/MonitoredIrpsViewModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections.ObjectModel;
using System.ComponentModel;

using GUI.ViewModels;
using GUI.Models;
using Microsoft.Toolkit.Uwp.Helpers;

namespace GUI.ViewModels
{
    public class MonitoredIrpsViewModel : BindableBase
    {
        public ObservableCollection<IrpViewModel> Irps { get; } = new ObservableCollection<IrpViewModel>();

        public bool IsModified { get; set; }

        public MonitoredIrpsViewModel()
            => UpdateUi();

        public void UpdateUi()
           => Task.Run(GetIrpListAsync);

            
        private IrpViewModel _model;


        public IrpViewModel Model
        {
            get => _model;
            set
            {
                if (_model != value)
                {
                    _model = value;
                }
            }
        }

        private IrpViewModel _lastSelectedIrp;
        private IrpViewModel _selectedIrp;


        public IrpViewModel SelectedIrp
        {
            get
            {
                _lastSelectedIrp = _selectedIrp;
                return _selectedIrp;
            }
            set => Set(ref _selectedIrp, value);
        }


        private bool _isLoading = false;


        public bool IsLoading
        {
            get => _isLoading;
            set => Set(ref _isLoading, value);
        }


        public async Task GetIrpListAsync()
        {
            await DispatcherHelper.ExecuteOnUIThreadAsync(() => {
                IsLoading = true;
            });

            var irps = await App.Irps.GetAsync();
            if (irps == null)
            {
                IsLoading = false;
                return;
            }

            await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
            {
                Irps.Clear();
                foreach (var irp in irps)
                {
                    Irps.Add(new IrpViewModel(irp));
                }
                IsLoading = false;
            });
        }

    }
}

```

`GUI/ViewModels/SaveLoadIrpsViewModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using GUI.Models;
using Microsoft.Data.Sqlite;
using Windows.Storage;


namespace GUI.ViewModels
{
    public class SaveLoadIrpsViewModel : BindableBase
    {
        private readonly string _filename = "temporary_db.cfb";

        public SaveLoadIrpsViewModel()
        {
            //
            // make sure the file exists
            //
            Task.Run(() =>
            {
                Windows.Foundation.IAsyncOperation<StorageFile> asyncOperation = ApplicationData.Current.LocalFolder.CreateFileAsync(_filename, CreationCollisionOption.ReplaceExisting);
            });
        }

        

        private bool _isLoading = false;

        public bool IsLoading
        {
            get => _isLoading;
            set => Set(ref _isLoading, value);
        }


        private string _status;
        public string Status
        {
            get => _status;
            set => Set(ref _status, value);
        }


        private string DbPath
        {
            get => Path.Combine(ApplicationData.Current.LocalFolder.Path, _filename);
        }


        public int CountIrpEntries(string dbpath = null)
        {
            int nb_entries = 0;
            dbpath = dbpath ?? DbPath;

            using (var db = new SqliteConnection($"Filename={dbpath}"))
            {
                db.Open();

                var cmd = new SqliteCommand("SELECT COUNT(*) from Irps", db);
                var query = cmd.ExecuteReader();

                nb_entries = query.GetInt32(0);
                db.Close();
            }

            return nb_entries;
        }


        public async Task<StorageFile> DumpIrpsToFile()
        {
            var file = await ApplicationData.Current.LocalFolder.CreateFileAsync(_filename, CreationCollisionOption.OpenIfExists);

            using (var db = new SqliteConnection($"Filename={DbPath}"))
            {
                db.Open();

                //
                // Create the table
                //
                {
                    var req = @"
CREATE TABLE IF NOT EXISTS Irps (
    TimeStamp integer,
    IrqLevel integer,
    Type integer,
    IoctlCode integer,
    Status integer,
    ProcessId integer NOT NULL,
    ThreadId integer NOT NULL,
    InputBufferLength integer,
    OutputBufferLength integer,
    DriverName text NOT NULL,
    DeviceName text NOT NULL,
    ProcessName text NOT NULL,
    InputBuffer blob,
    OutputBuffer blob
)
";
                    var cmd = new SqliteCommand(req, db);
                    cmd.ExecuteReader();
                }


                //
                // Populate it
                //
                var tx = db.BeginTransaction();
                try
                {
                    foreach (var irp in await App.Irps.GetAsync())
                    {
                        var query = @"
                            INSERT INTO Irps VALUES(
                            @TimeStamp, 
                            @IrqLevel, 
                            @Type, 
                            @IoctlCode, 
                            @Status, 
                            @ProcessId, 
                            @ThreadId, 
                            @InputBufferLength, 
                            @OutputBufferLength, 
                            @DriverName, 
                            @DeviceName, 
                            @ProcessName,
                            @InputBuffer,
                            @OutputBuffer
                            )
                            ";
                        SqliteCommand cmd = new SqliteCommand(query, db, tx);
                        cmd.Parameters.AddWithValue("@TimeStamp", irp.header.TimeStamp);
                        cmd.Parameters.AddWithValue("@IrqLevel", irp.header.IrqLevel);
                        cmd.Parameters.AddWithValue("@Type", irp.header.Type);
                        cmd.Parameters.AddWithValue("@IoctlCode", irp.header.IoctlCode);
                        cmd.Parameters.AddWithValue("@Status", irp.header.Status);
                        cmd.Parameters.AddWithValue("@ProcessId", irp.header.ProcessId);
                        cmd.Parameters.AddWithValue("@ThreadId", irp.header.ThreadId);
                        cmd.Parameters.AddWithValue("@InputBufferLength", irp.header.InputBufferLength);
                        cmd.Parameters.AddWithValue("@OutputBufferLength", irp.header.OutputBufferLength);
                        cmd.Parameters.AddWithValue("@DriverName", irp.header.DriverName);
                        cmd.Parameters.AddWithValue("@DeviceName", irp.header.DeviceName);
                        cmd.Parameters.AddWithValue("@ProcessName", irp.header.ProcessName);
                        cmd.Parameters.AddWithValue("@InputBuffer", irp.body.InputBuffer);
                        cmd.Parameters.AddWithValue("@OutputBuffer", irp.body.OutputBuffer);
                        cmd.ExecuteReader();
                    }
                    tx.Commit();
                }
                catch (Exception)
                {
                    tx.Rollback();
                }
                db.Close();
            }

            return file;
        }


        public async Task<bool> LoadIrpsFromFile(StorageFile file)
        {
            var f = await file.CopyAsync(ApplicationData.Current.TemporaryFolder, file.Name, NameCollisionOption.ReplaceExisting);

            using (var db = new SqliteConnection($"Filename={f.Path}"))
            {
                db.Open();

                var cmd = new SqliteCommand(@"
                    SELECT 
                    TimeStamp, 
                    IrqLevel,
                    Type,
                    IoctlCode,
                    Status,
                    ProcessId,
                    ThreadId,
                    InputBufferLength,
                    OutputBufferLength,
                    DriverName,
                    DeviceName,
                    ProcessName,
                    InputBuffer,
                    OutputBuffer  
                    FROM Irps", db);
                var query = cmd.ExecuteReader();

                while (query.Read())
                {

                    Irp irp = new Irp();
                    irp.header.TimeStamp = (ulong)query.GetInt64(0);
                    irp.header.IrqLevel = (uint)query.GetInt32(1);
                    irp.header.Type = (uint)query.GetInt32(2);
                    irp.header.IoctlCode = (uint)query.GetInt32(3);
                    irp.header.Status = (uint)query.GetInt64(4);
                    irp.header.ProcessId = (uint)query.GetInt32(5);
                    irp.header.ThreadId = (uint)query.GetInt32(6);
                    irp.header.InputBufferLength = (uint)query.GetInt32(7);
                    irp.header.OutputBufferLength = (uint)query.GetInt32(8);
                    irp.header.DriverName = query.GetString(9);
                    irp.header.DeviceName = query.GetString(10);
                    irp.header.ProcessName = query.GetString(11);
                    
                    irp.body.InputBuffer = ((MemoryStream)query.GetStream(12)).ToArray();
                    irp.body.OutputBuffer = ((MemoryStream)query.GetStream(13)).ToArray();

                    await App.Irps.Insert(irp);
                }

                await App.ViewModel.GetIrpListAsync();

                db.Close();
            }

            await f.DeleteAsync();

            return true;
        }
    }
}

```

`GUI/ViewModels/SessionInfoViewModel.cs`:

```cs
using GUI.Models;
using Microsoft.Toolkit.Uwp.Helpers;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.System.Threading;

namespace GUI.ViewModels
{
    public class SessionInfoViewModel : BindableBase
    {
        private uint _versionMajor = 0;
        private uint _versionMinor = 0;
        private string _versionBuild = "0";
        private uint _cpuArchitecture = 0;
        private uint _cpuNumber = 0;
        private string _userName = "";
        private string _integrityLevel = "";
        private uint _processId = 0;
        private float _version = 0;

        private ThreadPoolTimer PeriodicTimer;


        public SessionInfoViewModel(){}


        public void StartPeriodicTimer()
        {
            TimeSpan period = TimeSpan.FromSeconds(2);
            PeriodicTimer = ThreadPoolTimer.CreatePeriodicTimer(
                async (src) => {
                    var success = await RefreshValues();
                    if (!success) 
                        src.Cancel(); 
                }, 
                period
            );
        }


        public async Task<bool> RefreshValues()
        {
            if (!App.BrokerSession.IsConnected)
                return false;

            var msg = await App.BrokerSession.GetOsInfo();

            await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
            {
                RemoteMajorVersion = msg.version_major;
                RemoteMinorVersion = msg.version_minor;
                RemoteBuildVersion = msg.version_build;

                RemoteCpuArchitecture = msg.cpu_arch;
                RemoteNumberOfProcessor = msg.cpu_num;

                UserName = msg.username;
                IntegrityLevel = msg.integrity;
                ProcessId = msg.pid;
                Version = msg.version;
            });

            return true;
        }



        public void StopPeriodicTimer()
        {
            PeriodicTimer.Cancel();
        }

        private bool _isLoading = false;

        public bool IsLoading
        {
            get => _isLoading;
            set => Set(ref _isLoading, value);
        }

        public int NumberOfIrpsCaptured
        {
            get => App.Irps.Count();
        }

        public int NumberOfDrivers
        {
            get => App.Drivers.Count(false, false);
        }

        public string NumberOfDriversString
        {
            get => $"{NumberOfDrivers} driver(s) found";
        }

        public int NumberOfDriversHooked
        {
            get => App.Drivers.Count(true, false);
        }

        public string NumberOfDriversHookedString
        {
            get => $"{NumberOfDriversHooked:d} driver(s) hooked";
        }


        public bool IsConnected
        {
            get => App.BrokerSession.IsConnected;
        }


        public string ConnectionStatus
        {
            get => IsConnected ? "Connected" : "Disconnected";
        }


        public string HookedDriverList
        {
            get
            {
                if (!IsConnected) 
                    return "";

                var DriverNames = new List<string>();
                foreach (var driver in App.Drivers.Get())
                {
                    if (driver.IsHooked)
                        DriverNames.Add($" → {driver.Name}");
                }
                return String.Join(System.Environment.NewLine, DriverNames);
            }
        }


        public uint RemoteMajorVersion
        {
            get => _versionMajor;
            set
            {
                Set(ref _versionMajor, value);
                OnPropertyChanged("RemoteOsVersion");
            }
        }

        public uint RemoteMinorVersion
        {
            get => _versionMinor;
            set {
                Set(ref _versionMinor, value);
                OnPropertyChanged("RemoteOsVersion");
            }
        }

        public string RemoteBuildVersion
        {
            get => _versionBuild;
            set
            {
                Set(ref _versionBuild, value);
                OnPropertyChanged("RemoteOsVersion");
            }
        }

        public string RemoteOsVersion
        {
            get => $"WinVer={RemoteMajorVersion}.{RemoteMinorVersion}.{RemoteBuildVersion}";
        }

        public uint RemoteNumberOfProcessor
        {
            get => _cpuNumber;
            set { 
                Set(ref _cpuNumber, value);
                OnPropertyChanged("RemoteNumberOfProcessorString");
            }
        }

        public string RemoteNumberOfProcessorString
        {
            get => $"{RemoteNumberOfProcessor:d} logical processor(s)";
        }

        public uint RemoteCpuArchitecture
        {
            get => _cpuArchitecture;
            set { 
                Set(ref _cpuArchitecture, value);
                OnPropertyChanged("RemoteCpuArchitectureString");
            }
        }


        public string RemoteCpuArchitectureString
        {
            get
            {
                switch(RemoteCpuArchitecture)
                {
                    case 0: return "PROCESSOR_ARCHITECTURE_INTEL";
                    case 5: return "PROCESSOR_ARCHITECTURE_ARM";
                    case 6: return "PROCESSOR_ARCHITECTURE_IA64";
                    case 9: return "PROCESSOR_ARCHITECTURE_AMD64";
                    case 12: return "PROCESSOR_ARCHITECTURE_ARM64";
                }
                return "PROCESSOR_ARCHITECTURE_UNKNOWN";
            }
        }

        public string UserName
        {
            get => _userName;
            set => Set(ref _userName, value);
        }

        public string IntegrityLevel
        {
            get => _integrityLevel;
            set => Set(ref _integrityLevel, value);
        }

        public uint ProcessId
        {
            get => _processId;
            set {
                Set(ref _processId, value);
                OnPropertyChanged("ProcessInfo");
            }
        }

        public float Version
        {
            get => _version;
            set {
                Set(ref _version, value);
                OnPropertyChanged("ProcessInfo");
            }
        }

        public string ProcessInfo
        {
            get => $"Broker.exe v.{Version.ToString("n2")} running as PID={ProcessId}";
        }
    }
}

```

`GUI/Views/AboutPage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.AboutPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI.Views"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
        <StackPanel>
            <TextBlock Style="{ThemeResource HeaderTextBlockStyle}"
                       Text="About CFB" />

            <Image 
                Margin="100,55,150,30"
                x:Name="FuriousBeaverLogo" Source="/Assets/FuriousBeaver_SplashScreen.scale-125.png" 
                Height="186" 
                Width="1100" 
                />

            <TextBlock Margin="100,25,150,30"
                       Style="{ThemeResource TitleTextBlockStyle}"
                       Text="Furious Beaver is a tool for assisting in the process of monitoring, capturing and fuzzing IRPs on Windows hosts. It works by hooking the major function functions in the targeted drivers." />

            <HyperlinkButton
                Margin="20,0,0,0"
                Click="OnLink_Clicked"
                Content="{x:Bind GithubRepositoryLabel}" />
            
            <HyperlinkButton
                Margin="20,0,0,0"
                Click="OnLink_Clicked"
                Content="{x:Bind GithubIssueLabel}" />

        </StackPanel>

    </Grid>
</Page>

```

`GUI/Views/AboutPage.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;

using GUI.Models;
using Windows.System;

namespace GUI.Views
{
    /// <summary>
    /// An empty page that can be used on its own or navigated to within a Frame.
    /// </summary>
    public sealed partial class AboutPage : Page
    {
        public readonly string GithubRepositoryLabel = "Visit Github Repository";
        public readonly string GithubIssueLabel = "Submit an issue";
        public readonly string GithubPullRequestLabel = "Submit a pull request";

        public AboutPage()
        {
            this.InitializeComponent();
        }


        private async void OnLink_Clicked(object sender, RoutedEventArgs e)
        {
            HyperlinkButton clickedBtn = (HyperlinkButton)e.OriginalSource;
            string buttonLabel = clickedBtn.Content.ToString();

            await Launcher.LaunchUriAsync(new Uri("http://localhost/?"+buttonLabel));

            if (buttonLabel == GithubRepositoryLabel)
                await Launcher.LaunchUriAsync(new Uri(Constants.ProjectUrl));
            else if (buttonLabel == GithubIssueLabel)
                await Launcher.LaunchUriAsync(new Uri(Constants.ProjectIssueUrl));
        }
    }
}

```

`GUI/Views/DataGridHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Microsoft.Toolkit.Uwp.UI.Controls;

namespace GUI.Views
{
    /// <summary>
    /// Extension methods used with the DataGrid control to support sorting.
    /// </summary>
    public static class DataGridHelper
    {
        public static void Sort(this DataGrid dataGrid, DataGridColumn columnToSort, Action<string, bool> sort)
        {
            var lastSortedColumn = dataGrid.Columns.Where(column =>
                column.SortDirection.HasValue).FirstOrDefault();
            bool isSortColumnDifferentThanLast = columnToSort != lastSortedColumn;
            bool isAscending = isSortColumnDifferentThanLast ||
                columnToSort.SortDirection == DataGridSortDirection.Descending;

            columnToSort.SortDirection = isAscending ?
                DataGridSortDirection.Ascending : DataGridSortDirection.Descending;
            if (isSortColumnDifferentThanLast && lastSortedColumn != null)
            {
                lastSortedColumn.SortDirection = null;
            }

            var propertyName = columnToSort.Tag as string ?? columnToSort.Header.ToString();
            sort(propertyName, isAscending);
        }


        public static void Sort<T>(this ObservableCollection<T> collection, string propertyName, bool isAscending)
        {
            object sortFunc(T obj) => obj.GetType().GetProperty(propertyName).GetValue(obj);
            List<T> sortedCollection = isAscending ?
                collection.OrderBy(sortFunc).ToList() :
                collection.OrderByDescending(sortFunc).ToList();
            collection.Clear();
            foreach (var obj in sortedCollection)
            {
                collection.Add(obj);
            }
        }
    }
}

```

`GUI/Views/DriverListPage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.DriverListPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:models="using:GUI.Models"
    xmlns:local="using:GUI.Views"
    xmlns:vm="using:GUI.ViewModels"
    xmlns:uc="using:GUI.UserControls"
    xmlns:sys="using:System"
    xmlns:toolkit="using:Microsoft.Toolkit.Uwp.UI.Controls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Page.Resources>
        <MenuFlyout x:Key="DataGridContextMenu">
            <MenuFlyoutItem
                Click="MenuFlyoutViewDetails_Click"
                Tag="&#xE1A5;"
                Text="View details" />
        </MenuFlyout>

        <Style
            x:Key="SearchSuggestionItemStyle"
            TargetType="ListViewItem">
            <Setter Property="HorizontalContentAlignment" Value="Stretch" />
        </Style>

        <DataTemplate
            x:Key="SearchSuggestionItemTemplate"
            x:DataType="vm:DriverViewModel">
            <Grid HorizontalAlignment="Stretch">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="2*" />
                </Grid.ColumnDefinitions>
                <Grid.Resources>
                    <Style TargetType="TextBlock">
                        <Setter Property="Margin" Value="8,0,0,0" />
                    </Style>
                </Grid.Resources>
                <TextBlock
                    Grid.Column="1"
                    Margin="0,0,20,0"
                    HorizontalAlignment="Stretch"
                    Text="{x:Bind Name, Mode=OneWay}" />
            </Grid>
        </DataTemplate>
    </Page.Resources>

    <Grid>
        <RelativePanel>

            <TextBlock
                x:Name="PageTitle"
                Style="{StaticResource HeaderTextBlockStyle}"
                Text="Drivers" />

            <CommandBar
                x:Name="mainCommandBar"
                HorizontalAlignment="Stretch"
                Background="Transparent"
                RelativePanel.LeftOf="DriverSearchBox"
                RelativePanel.RightOf="PageTitle">
                <AppBarButton
                    Click="{x:Bind ViewModel.ForceGetDriversAsync}"
                    Icon="Refresh"
                    Label="Refresh" />
            </CommandBar>

            <uc:CollapsibleSearchBox
                x:Name="DriverSearchBox"
                Width="240"
                Margin="12,8,12,0"
                Loaded="DriverSearchBox_Loaded"
                RelativePanel.AlignRightWithPanel="True" />

            <SplitView
                x:Name="listSplitView"
                DisplayMode="Inline"
                IsPaneOpen="{x:Bind vm:Converters.IsNotNull(ViewModel.SelectedDriver), Mode=OneWay}"
                OpenPaneLength="260"
                PanePlacement="Right"
                RelativePanel.AlignBottomWithPanel="True"
                RelativePanel.AlignLeftWithPanel="True"
                RelativePanel.AlignRightWithPanel="True"
                RelativePanel.Below="PageTitle">

                <!--  Displays details about the currently selected driver.  -->
                <SplitView.Pane>
                    <StackPanel
                        x:Name="DriverInfoPanel"
                        Margin="24,28,24,0"
                        Visibility="{x:Bind vm:Converters.CollapsedIfNull(ViewModel.SelectedDriver), Mode=OneWay}">
                        <StackPanel.Resources>
                            <Style TargetType="TextBox">
                                <Setter Property="HorizontalAlignment" Value="Stretch" />
                                <Setter Property="TextWrapping" Value="Wrap" />
                            </Style>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Stretch" />
                                <Setter Property="TextWrapping" Value="Wrap" />
                            </Style>
                        </StackPanel.Resources>

                        <StackPanel Margin="0,20,0,20">
                            <TextBlock FontWeight="SemiBold" Text="Driver Name" />
                            <TextBlock Text="{x:Bind ViewModel.SelectedDriver.Name, Mode=OneWay}" />
                        </StackPanel>

                        <StackPanel Margin="0,20,0,20">
                            <TextBlock FontWeight="SemiBold" Text="Is hooked?" />
                            <TextBlock Text="{x:Bind ViewModel.SelectedDriver.IsHooked, Mode=OneWay}" />
                        </StackPanel>

                        <StackPanel Margin="0,20,0,20">
                            <TextBlock FontWeight="SemiBold" Text="Is enabled?" />
                            <TextBlock Text="{x:Bind ViewModel.SelectedDriver.IsEnabled, Mode=OneWay}" />
                        </StackPanel>

                        <StackPanel Margin="0,20,0,20">
                            <TextBlock FontWeight="SemiBold" Text="Driver Object address" />
                            <TextBlock Text="{x:Bind vm:Converters.FormatAddressAsHex(ViewModel.SelectedDriver.Address), Mode=OneWay}" />
                        </StackPanel>

                        <StackPanel Margin="0,20,0,20">
                            <TextBlock FontWeight="SemiBold" Text="Number of IRP intercepted" />
                            <TextBlock Text="{x:Bind ViewModel.SelectedDriver.NumberOfRequestIntercepted, Mode=OneWay}" />
                        </StackPanel>

                        <StackPanel Margin="0,20,0,20">
                            <Button x:Name="SelectedDriverEnableDisableBtn" Click="SelectedDriverEnableDisableBtn_Click" Margin="10" Width="150">
                                <TextBlock x:Name="SelectedDriverEnableDisableBtnLbl" FontWeight="SemiBold" Text="{x:Bind ViewModel.EnableDisableSelectedDriverText}" />
                            </Button>
                        </StackPanel>
                    </StackPanel>
                </SplitView.Pane>

                <SplitView.Content>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="343*"/>
                            <ColumnDefinition Width="32*"/>
                            <ColumnDefinition Width="32*"/>
                        </Grid.ColumnDefinitions>
                        
                        <toolkit:DataGrid
                            x:Name="DriverDatagrid"
                            BorderThickness="0"
                            CanUserReorderColumns="True"
                            CanUserResizeColumns="True"
                            GridLinesVisibility="None"
                            IsReadOnly="True"
                            DoubleTapped="DataGrid_DoubleTapped"
                            Sorting="DataGrid_Sorting"
                            AutoGenerateColumns="False"
                            Margin="0,10,0,0"
                            ItemsSource="{x:Bind ViewModel.Drivers, Mode=OneWay}"
                            SelectedItem="{x:Bind ViewModel.SelectedDriver, Mode=TwoWay}"
                            KeyDown="DataGrid_KeyDown"
                            ContextFlyout="{StaticResource DataGridContextMenu}" 
                            Grid.ColumnSpan="2">

                            <toolkit:DataGrid.Columns>
                                <toolkit:DataGridTextColumn
                                    Header="Driver"
                                    Tag="Name"
                                    CanUserSort="True"
                                    IsReadOnly="True"
                                    Binding="{Binding Name, Mode=TwoWay}"
                                    />

                                <toolkit:DataGridTextColumn 
                                    Header="Is driver hooked?"
                                    Tag="IsHooked"
                                    CanUserSort="True"
                                    IsReadOnly="True"
                                    Binding="{Binding IsHooked, Mode=TwoWay}"
                                    />
                                
                                <toolkit:DataGridTextColumn 
                                    Header="Is interception enabled?"
                                    Tag="IsEnabled"
                                    CanUserSort="True"
                                    IsReadOnly="True"
                                    Binding="{Binding IsEnabled, Mode=TwoWay}"
                                    />
                                
                            </toolkit:DataGrid.Columns>
                        </toolkit:DataGrid>

                        <ProgressBar
                            Margin="0,50,0,0"
                            VerticalAlignment="Top"
                            IsIndeterminate="True"
                            Visibility="{x:Bind ViewModel.IsLoading, Mode=OneWay}" Grid.ColumnSpan="2" />
                    </Grid>
                </SplitView.Content>
            </SplitView>
        </RelativePanel>

    </Grid>
</Page>

```

`GUI/Views/DriverListPage.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;


using GUI.ViewModels;
using GUI.Models;
using Microsoft.Toolkit.Uwp.UI.Controls;
using Microsoft.Toolkit.Uwp.Helpers;
using System.Threading.Tasks;
using Windows.UI.Popups;

namespace GUI.Views
{

    public sealed partial class DriverListPage : Page
    {
        public DriverListPage()
        {
            this.InitializeComponent();
        }


        public DriverListPageViewModel ViewModel = new DriverListPageViewModel();


        protected override void OnNavigatedTo(NavigationEventArgs e)
        {
        }

        private void CommandBarDriverInfoButton_Click(object sender, RoutedEventArgs e)
        {
        }

        private void DataGrid_DoubleTapped(object sender, DoubleTappedRoutedEventArgs e)
        {
        }    
    

        private void DataGrid_KeyDown(object sender, KeyRoutedEventArgs e)
        {
        }


        private void DataGrid_Sorting(object sender, DataGridColumnEventArgs e)
            => (sender as DataGrid).Sort(e.Column, ViewModel.Drivers.Sort);
    

        private void DriverSearchBox_Loaded(object sender, RoutedEventArgs e)
        {
            if(DriverSearchBox != null)
            {
                DriverSearchBox.AutoSuggestBox.TextChanged += DriverSearchBox_TextChanged;
                DriverSearchBox.AutoSuggestBox.QuerySubmitted += DriverSearchBox_QuerySubmitted;
                DriverSearchBox.AutoSuggestBox.PlaceholderText = "Filter driver by name...";
                DriverSearchBox.AutoSuggestBox.ItemTemplate = (DataTemplate)Resources["SearchSuggestionItemTemplate"];
                DriverSearchBox.AutoSuggestBox.ItemContainerStyle = (Style)Resources["SearchSuggestionItemStyle"];
            }
        }

        private async void DriverSearchBox_QuerySubmitted(AutoSuggestBox sender, AutoSuggestBoxQuerySubmittedEventArgs args)
        {
            if (String.IsNullOrEmpty(args.QueryText))
            {
                await ViewModel.GetDriversAsync(false);
            }
            else
            {
                var text = sender.Text;
                string[] parameters = text.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                var matches = ViewModel.Drivers
                        .Where(
                            driver => parameters.Any(
                                parameter =>
                                    driver.Name.Contains(parameter, StringComparison.OrdinalIgnoreCase)
                            )
                        ).OrderByDescending(
                            driver => parameters.Count(
                                parameter =>
                                    driver.Name.Contains(parameter, StringComparison.OrdinalIgnoreCase)
                            )
                        ).ToList();

                
                await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
                {
                    if (matches.Count() > 0)
                    {
                        ViewModel.Drivers.Clear();

                        foreach (var match in matches)
                            ViewModel.Drivers.Add(match);
                    }
                    else
                    {
                        var dialog = new MessageDialog($"No driver found matching the pattern '{text}'...", "Driver search");
                        Task.Run(dialog.ShowAsync);
                    }
                });
            }
        }


        private void DriverSearchBox_TextChanged(AutoSuggestBox sender, AutoSuggestBoxTextChangedEventArgs args)
        {
            if (args.Reason == AutoSuggestionBoxTextChangeReason.UserInput)
            {
                if (String.IsNullOrEmpty(sender.Text))
                {
                    sender.ItemsSource = null;
                }
                else
                {
                    string[] parameters = sender.Text.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    sender.ItemsSource = ViewModel.Drivers
                        .Where(
                            driver => parameters.Any(
                                parameter =>
                                    driver.Name.Contains(parameter, StringComparison.OrdinalIgnoreCase)
                            )
                        );
                }
            }
        }


        private void MenuFlyoutViewDetails_Click(object sender, RoutedEventArgs e) 
        {
            //todo:
            //Frame.Navigate(typeof(DriverDetailPage), ViewModel.SelectedDriver.DriverName, new DrillInNavigationTransitionInfo());
        }


        private async void SelectedDriverEnableDisableBtn_Click(object sender, RoutedEventArgs e)
        {
            var Driver = ViewModel.SelectedDriver;
            if (Driver != null)
            {
                try
                {
                    await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
                    {
                        SelectedDriverEnableDisableBtn.IsEnabled = false;
                        ViewModel.IsLoading = true;
                    });

                    if (await Driver.TryToggleHookStatus())
                        RefreshDataGrid();
                }
                finally
                {
                    await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
                    {
                        ViewModel.IsLoading = false;
                        SelectedDriverEnableDisableBtn.IsEnabled = true;
                    });
                }
            }
        }


        private void RefreshDataGrid()
        {
            DriverDatagrid.ItemsSource = null;
            DriverDatagrid.ItemsSource = ViewModel.Drivers;
        }
    }
}

```

`GUI/Views/IrpInfoPage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.IrpInfoPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI.Views"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:controls="using:Microsoft.Toolkit.Uwp.UI.Controls"
    xmlns:vm="using:GUI.ViewModels"
    xmlns:h="using:GUI.Helpers"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Grid>
        <RelativePanel>

            <TextBlock
                x:Name="PageTitle"
                Style="{ThemeResource TitleTextBlockStyle}"
                Text="{x:Bind IrpDetailPageTitle}" />

            <CommandBar
                x:Name="mainCommandBar"
                Background="Transparent"
                RelativePanel.RightOf="PageTitle" 
                DefaultLabelPosition="Right"
                IsDynamicOverflowEnabled="False"
                HorizontalAlignment="Stretch" 
                HorizontalContentAlignment="Stretch" 
                RelativePanel.AlignRightWithPanel="True"
                >

                <AppBarButton
                    Icon="Save"
                    Label="Save as Powershell script"
                    Visibility="{x:Bind vm:Converters.VisibleOnlyForDeviceIoControlIrp(ViewModel)}" 
                    Click="SaveAsPowerShell_Click"
                    />

                <AppBarButton
                    Icon="Forward"
                    Label="Send to Repeater"
                    Visibility="{x:Bind vm:Converters.VisibleOnlyForDeviceIoControlIrp(ViewModel)}" 
                    Click="ReplayIrp_Click"
                    />

            </CommandBar>

        </RelativePanel>
        
            <controls:TabView 
                Margin="0,50,0,0"
                x:Name="Tabs">
                
                <controls:TabViewItem Header="IRP Metadata">
                <Grid HorizontalAlignment="Stretch">
                    <RelativePanel Margin="8,0,0,12">
                        <TextBox
                            x:Name="TimeStampTextBox"
                            Grid.Row="0"
                            Margin="0,0,0,0"
                            Width="300"
                            MinWidth="120"
                            Header="Time Stamp"
                            IsReadOnly="True"
                            Text="{x:Bind ViewModel.TimeStampString, Mode=OneWay}"
                            />

                        <TextBox
                             x:Name="DeviceNameTextBox"
                             RelativePanel.Below="TimeStampTextBox"
                             MinWidth="120"
                             Width="300"
                             Margin="0,20,0,0"
                             Header="Device Name"
                             IsReadOnly="True"
                             RelativePanel.AlignLeftWithPanel="True"
                             Text="{x:Bind ViewModel.DeviceName, Mode=OneWay}"
                         />

                        <TextBox
                            x:Name="DriverNameTextBox"
                            RelativePanel.Below="TimeStampTextBox"
                            RelativePanel.RightOf="DeviceNameTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="400,20,0,0"
                            Header="Driver Name"
                            IsReadOnly="True"
                            RelativePanel.AlignLeftWithPanel="True"
                            Text="{x:Bind ViewModel.DriverName, Mode=OneWay}"
                            />

                        <TextBox
                            x:Name="ProcessNameTextBox"
                            RelativePanel.Below="DriverNameTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="0,20,0,0"
                            Header="Process Name"
                            IsReadOnly="True"
                            RelativePanel.AlignLeftWithPanel="True"
                            Text="{x:Bind ViewModel.ProcessName, Mode=OneWay}"
                            />
                            
                            
                        <TextBox
                            x:Name="ThreadIdTextBox"
                            RelativePanel.Below="DriverNameTextBox"
                            RelativePanel.RightOf="ProcessNameTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="400,20,0,0"
                            Header="Thread Id"
                            IsReadOnly="True"
                            RelativePanel.AlignLeftWithPanel="True"
                            Text="{x:Bind ViewModel.ThreadId, Mode=OneWay}"
                            />
                        
                        <TextBox
                            x:Name="ProcessIdTextBox"
                            RelativePanel.Below="DriverNameTextBox"
                            RelativePanel.RightOf="ThreadIdTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="100,20,0,0"
                            Header="Process Id"
                            IsReadOnly="True"
                            Text="{x:Bind ViewModel.ProcessId, Mode=OneWay}"
                            />

                        <TextBox
                            x:Name="IrqlTextBox"
                            RelativePanel.Below="ProcessNameTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="0,20,0,0"
                            Header="IRQ Level"
                            IsReadOnly="True"
                            Text="{x:Bind ViewModel.IrqLevel, Mode=OneWay}"
                            />

                        <TextBox
                            x:Name="IoctlCodeTextBox"
                            RelativePanel.RightOf="IrqlTextBox"
                            RelativePanel.Below="ThreadIdTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="100,20,0,0"
                            Header="IOCTL Code"
                            IsReadOnly="True"
                            Text="{x:Bind ViewModel.IoctlCodeString, Mode=OneWay}"
                            >
                            <ToolTipService.ToolTip>
                                <ToolTip 
                                    Content="{x:Bind ViewModel.IoctlCodeDetailString, Mode=OneWay}"
                                    Placement="Right"
                                    HorizontalOffset="20"
                                    MinWidth="100"
                                    />
                            </ToolTipService.ToolTip>
                        </TextBox>

                        <TextBox
                            x:Name="TypeTextBox"
                            RelativePanel.Below="ProcessIdTextBox"
                            RelativePanel.RightOf="IoctlCodeTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="100,20,0,0"
                            Header="IRP Major Function"
                            IsReadOnly="True"
                            Text="{x:Bind ViewModel.Type, Mode=OneWay}"
                            />

                        <TextBox
                            x:Name="InputBufferLengthTextBox"
                            RelativePanel.Below="IrqlTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="0,20,0,0"
                            Header="Input Buffer Length"
                            IsReadOnly="True"
                            Text="{x:Bind ViewModel.InputBufferLength, Mode=OneWay}"
                            />

                        <TextBox
                            x:Name="OutputBufferLengthTextBox"
                            RelativePanel.RightOf="IrqlTextBox"
                            RelativePanel.Below="IoctlCodeTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="100,20,0,0"
                            Header="Output Buffer Length"
                            IsReadOnly="True"
                            Text="{x:Bind ViewModel.OutputBufferLength, Mode=OneWay}"
                            />

                        <TextBox
                            x:Name="StatusCodeTextBox"
                            RelativePanel.Below="TypeTextBox"
                            RelativePanel.RightOf="OutputBufferLengthTextBox"
                            MinWidth="120"
                            Width="300"
                            Margin="100,20,0,0"
                            Header="Status Code"
                            IsReadOnly="True"
                            Text="{x:Bind ViewModel.StatusFullString, Mode=OneWay}"
                            />
                    </RelativePanel>
                </Grid>
                </controls:TabViewItem>
                
                <controls:TabViewItem 
                    Header="InputBuffer"
                    Visibility="{x:Bind vm:Converters.VisibleIfGreaterThanZero(ViewModel.InputBufferLength), Mode=OneWay}"
                    >

                <TextBox 
                    x:Name="InputBufferTabViewBlock" 
                    Text="{x:Bind h:Utils.Hexdump(ViewModel.InputBuffer)}"
                    TextWrapping="Wrap" 
                    IsReadOnly="True"
                    FontSize="16" 
                    FontFamily="Consolas"
                    VerticalAlignment="Stretch" 
                    HorizontalAlignment="Stretch" 
                    />
            </controls:TabViewItem>

                <controls:TabViewItem 
                    Header="OutputBuffer"
                    Visibility="{x:Bind vm:Converters.VisibleIfGreaterThanZero(ViewModel.OutputBufferLength), Mode=OneWay}"
                    >
                <TextBox 
                    x:Name="OutputBufferTabViewBlock" 
                    Text="{x:Bind h:Utils.Hexdump(ViewModel.OutputBuffer)}"
                    TextWrapping="Wrap" 
                    IsReadOnly="True"
                    VerticalAlignment="Stretch" 
                    HorizontalAlignment="Stretch" 
                    FontSize="16" 
                    FontFamily="Consolas"
                    />
                </controls:TabViewItem>

        </controls:TabView>

    </Grid>
</Page>

```

`GUI/Views/IrpInfoPage.xaml.cs`:

```cs
using GUI.Helpers;
using GUI.Models;
using GUI.ViewModels;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;



namespace GUI.Views
{

    public sealed partial class IrpInfoPage : Page
    {
        public IrpInfoPage()
        {
            this.InitializeComponent();
        }

        public IrpViewModel ViewModel = null;


        public string IrpDetailPageTitle
        {
            get
            {
                var msg = $"IRP {ViewModel.Type} sent to {ViewModel.DeviceName}";
                if (ViewModel.Model.header.Type != (uint)IrpMajorType.IRP_MJ_DEVICE_CONTROL)
                    msg += $" (IOCTL {ViewModel.IoctlCodeString})";
                return msg;
            }
        }


        protected async override void OnNavigatedTo(NavigationEventArgs e)
        {
            base.OnNavigatedTo(e);

            var irp = (IrpViewModel)e.Parameter;
            if (irp == null)
            {
                await Utils.ShowPopUp("No IRP passed to the page");
                Frame.GoBack();
            }
            else
            {
                ViewModel = irp;
            }
        }


        private async void SaveAsPowerShell_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                await ViewModel.ExportAs("Powershell");
            }
            catch(Exception ex)
            {
                await Utils.ShowPopUp(ex.Message);
            }
        }

        private void ReplayIrp_Click(object sender, RoutedEventArgs e)
        {
            Frame.Navigate(typeof(ReplayIrpPage), ViewModel);
        }
    }
}

```

`GUI/Views/LoadIrpsFromFilePage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.LoadIrpsFromFilePage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"   
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <ScrollViewer Background="{ThemeResource ApplicationPageBackgroundThemeBrush}" Padding="12,10,12,12">
        <StackPanel>
            <TextBlock Text="Load saved IRPs from a previous session" Style="{StaticResource HeaderTextBlockStyle}"/>

            <ProgressBar
                Margin="0,25,0,25"
                VerticalAlignment="Top"
                IsIndeterminate="True"
                Visibility="{x:Bind ViewModel.IsLoading, Mode=OneWay}" 
                Grid.ColumnSpan="2" 
                />

            <TextBlock Style="{StaticResource BodyTextBlockStyle}" TextWrapping="Wrap" Margin="0,15,0,0">
                Select a file on the file system saved in the *.cfb format, and load its content into the current sessions.
            </TextBlock>
            
            <Button 
                x:Name="LoadIrpsBtn"
                Content="Select IRP file" 
                Click="LoadIrpDatabaseButton_Click" 
                Margin="50,35,0,0"
                />
            
            <TextBlock 
                Name="UpdateStatusLabel" 
                Margin="0,50,0,0"
                Text="{x:Bind ViewModel.Status, Mode=OneWay}"
                />
        </StackPanel>
    </ScrollViewer>
</Page>

```

`GUI/Views/LoadIrpsFromFilePage.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;

using GUI.Helpers;
using GUI.Models;
using GUI.ViewModels;


namespace GUI.Views
{
    /// <summary>
    /// Page associated to loading previously saved IRPs into the current session
    /// </summary>
    public sealed partial class LoadIrpsFromFilePage : Page
    {

        public LoadIrpsFromFilePage()
        {
            this.InitializeComponent();
        }


        public SaveLoadIrpsViewModel ViewModel = new SaveLoadIrpsViewModel();


        private async void LoadIrpDatabaseButton_Click(object sender, RoutedEventArgs e)
        {
            LoadIrpsBtn.IsEnabled = false;
            ViewModel.IsLoading = true;

            try
            {
                var openPicker = new Windows.Storage.Pickers.FileOpenPicker();
                openPicker.ViewMode = Windows.Storage.Pickers.PickerViewMode.Thumbnail;
                openPicker.SuggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.DocumentsLibrary;
                openPicker.FileTypeFilter.Add(".cfb");
                Windows.Storage.StorageFile file = await openPicker.PickSingleFileAsync();
                if (file != null)
                {
                    ViewModel.Status = $"🡆 Parsing content of file '{file.Path}'...";

                    bool res = await ViewModel.LoadIrpsFromFile(file);
                    if (res)
                    {
                        ViewModel.Status = $"✔ IRPs from '{file.Path}' loaded!";
                        return;
                    }
                }

                ViewModel.Status = "✘ Couldn't load IRPs from file.";
            }
            catch (Exception ex)
            {
                await Utils.ShowPopUp(
                    $"An error occured while trying to load IRPs to file.\n\nReason:\n{ex.Message}",
                    "Save IRPs Failed"
                );
            }
            finally
            {
                LoadIrpsBtn.IsEnabled = true;
                ViewModel.IsLoading = false;
            }

            return;
        }

    }
}

```

`GUI/Views/MonitoredIrpsPage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.MonitoredIrpsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:vm="using:GUI.ViewModels"
    xmlns:uc="using:GUI.UserControls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:toolkit="using:Microsoft.Toolkit.Uwp.UI.Controls"
    mc:Ignorable="d"
    NavigationCacheMode="Required"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Page.Resources>
        <MenuFlyout 
            x:Key="DataGridContextMenu" 
            x:Name="IrpDatagridMenuFlyout"
            >

            <MenuFlyoutItem
                Style="{ThemeResource MenuFlyoutItemRevealStyle}"
                Tag="&#xE1A5;"
                Text="Show IRP Details" 
                Click="ShowDetails_Click"
                />
            
            <MenuFlyoutItem
                Style="{ThemeResource MenuFlyoutItemRevealStyle}"
                Tag="&#xE14D;"
                Text="Send to Repeater" 
                Click="SendToRepeater_Click"
                />
            
            <MenuFlyoutItem               
                Style="{ThemeResource MenuFlyoutItemRevealStyle}"
                Tag="&#xE14D;"
                Text="Export the IRP input buffer as Raw" 
                Click="SaveAsRawFile_Click" 
                />
            
            <MenuFlyoutItem
                Style="{ThemeResource MenuFlyoutItemRevealStyle}"
                Tag="&#xE14D;"
                Text="Export the IRP as a PowerShell snippet" 
                Click="SaveAsPowershellScript_Click" 
                />

            <MenuFlyoutItem
                Style="{ThemeResource MenuFlyoutItemRevealStyle}"
                Tag="&#xE14D;"
                Text="Export the IRP as a Python snippet" 
                Click="SaveAsPythonScript_Click"
                />
            
            <MenuFlyoutItem
                Style="{ThemeResource MenuFlyoutItemRevealStyle}"
                Tag="&#xE14D;"
                Text="Export the IRP as a C++ (.exe/.dll) snippet" 
                Click="SaveAsCScript_Click"
                />

        </MenuFlyout>
    </Page.Resources>

    <Grid
        x:Name="LayoutRoot"
        Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

        <RelativePanel>
            <TextBlock
                Margin="10,0,0,0"
                x:Name="PageTitle"
                Style="{ThemeResource TitleTextBlockStyle}"
                Text="Intercepted IRPs" />

            <uc:CollapsibleSearchBox
                x:Name="IrpSearchBox"
                Width="240"
                HorizontalAlignment="Right"
                Margin="12,8,12,0"
                Loaded="IrpSearchBox_Loaded"
                RelativePanel.AlignRightWithPanel="True" />
            
            <Grid
                    Margin="0,20,0,0"
                    RelativePanel.AlignLeftWithPanel="True"
                    RelativePanel.AlignRightWithPanel="True"
                    RelativePanel.Below="PageTitle">

                <toolkit:DataGrid
                        CanUserReorderColumns="True"
                        CanUserResizeColumns="True"
                        AutoGenerateColumns="False"
                        Sorting="DataGrid_Sorting"
                        DoubleTapped="DataGrid_DoubleTapped"
                        BorderThickness="0"
                        x:Name="IrpDataGrid"
                        GridLinesVisibility="None"
                        ItemsSource="{x:Bind ViewModel.Irps}"
                        SelectedItem="{x:Bind ViewModel.SelectedIrp, Mode=TwoWay}"
                        ContextFlyout="{StaticResource DataGridContextMenu}">
                    
                    <toolkit:DataGrid.Columns>
                        <toolkit:DataGridTextColumn Header="TimeStamp" Tag="TimeStamp" Binding="{Binding TimeStamp}" />
                        <toolkit:DataGridTextColumn Header="Driver Name" Tag="DriverName" Binding="{Binding DriverName}" />
                        <toolkit:DataGridTextColumn Header="Device Name" Tag="DeviceName" Binding="{Binding DeviceName}" />
                        <toolkit:DataGridTextColumn Header="Process Name" Tag="ProcessName" Binding="{Binding ProcessName}" />
                        <toolkit:DataGridTextColumn Header="Process ID" Tag="ProcessId" Binding="{Binding ProcessId}" />
                        <toolkit:DataGridTextColumn Header="Thread ID" Tag="ThreadId" Binding="{Binding ThreadId}" />
                        <toolkit:DataGridTextColumn Header="Type" Tag="Type" Binding="{Binding Type}" />
                        <toolkit:DataGridTextColumn Header="IOCTL Code" Tag="IoctlCode" Binding="{Binding IoctlCodeString}" />
                        <toolkit:DataGridTextColumn Header="Status" Tag="Status" Binding="{Binding StatusString}" />
                        <toolkit:DataGridTextColumn Header="Input Buffer Length" Tag="InputBufferLength" Binding="{Binding InputBufferLength}" />
                        <toolkit:DataGridTextColumn Header="Output Buffer Length" Tag="OutputBufferLength" Binding="{Binding OutputBufferLength}" />
                        <!--
                        <toolkit:DataGridTextColumn Header="Input Buffer" Tag="InputBuffer" Binding="{Binding InputBufferString}" />
                        <toolkit:DataGridTextColumn Header="Output Buffer" Tag="OutputBuffer" Binding="{Binding OutputBufferString}" />
                        -->
                    </toolkit:DataGrid.Columns>
                </toolkit:DataGrid>

                <ProgressBar
                            Margin="0,50,0,0"
                            VerticalAlignment="Top"
                            IsIndeterminate="True"
                            Visibility="{x:Bind ViewModel.IsLoading, Mode=OneWay}" Grid.ColumnSpan="2" />
            </Grid>
        </RelativePanel>
    </Grid>

</Page>

```

`GUI/Views/MonitoredIrpsPage.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Core;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Microsoft.Toolkit.Uwp.UI.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;

using GUI.ViewModels;
using System.Collections.ObjectModel;
using Microsoft.Toolkit.Uwp.Helpers;
using Windows.ApplicationModel;
using GUI.Helpers;
using Windows.Storage;
using Windows.Storage.Streams;
using Windows.Security.Cryptography;
using Windows.Storage.Provider;
using System.Threading.Tasks;
using GUI.Models;

namespace GUI.Views
{

    public sealed partial class MonitoredIrpsPage : Page
    {
        public MonitoredIrpsViewModel ViewModel 
            => App.ViewModel;


        public MonitoredIrpsPage()
        {
            this.InitializeComponent();
            Window.Current.SizeChanged += CurrentWindow_SizeChanged;
        }

        private void CurrentWindow_SizeChanged(object sender, WindowSizeChangedEventArgs e)
        {
        }

        private void DataGrid_DoubleTapped(object sender, DoubleTappedRoutedEventArgs e)
        {
            if (ViewModel.SelectedIrp != null)
                this.Frame.Navigate(typeof(Views.IrpInfoPage), ViewModel.SelectedIrp);
        }


        private async void SaveAsPythonScript_Click(object sender, RoutedEventArgs e)
        {
            if (ViewModel.SelectedIrp == null)
            {
                await Utils.ShowPopUp("No IRP selected", "Missing IRP");
                return;
            }

            try
            {
                await ViewModel.SelectedIrp.ExportAs("Python");
            }
            catch (Exception ex)
            {
                await Utils.ShowPopUp(ex.Message);
            }
        }


        private async void SaveAsPowershellScript_Click(object sender, RoutedEventArgs e)
        {
            if (ViewModel.SelectedIrp == null)
            {
                await Utils.ShowPopUp("No IRP selected", "Missing IRP");
                return;
            }

            try
            {
                await ViewModel.SelectedIrp.ExportAs("Powershell");
            }
            catch (Exception ex)
            {
                await Utils.ShowPopUp(ex.Message);
            }
        }


        private async void SaveAsCScript_Click(object sender, RoutedEventArgs e)
        {
            if (ViewModel.SelectedIrp == null)
            {
                await Utils.ShowPopUp("No IRP selected", "Missing IRP");
                return;
            }

            try
            {
                await ViewModel.SelectedIrp.ExportAs("C");
            }
            catch(Exception ex)
            {
                await Utils.ShowPopUp(ex.Message);
            }
        }


        private async void SaveAsRawFile_Click(object sender, RoutedEventArgs e)
        {
            if (ViewModel.SelectedIrp == null)
            {
                await Utils.ShowPopUp("No IRP selected", "Missing IRP");
                return;
            }

            try
            {
                await ViewModel.SelectedIrp.ExportAs("Raw");
            }
            catch(Exception ex)
            {
                await Utils.ShowPopUp(ex.Message);
            }
            
        }


        private void IrpSearchBox_Loaded(object sender, RoutedEventArgs e)
        {
            if (IrpSearchBox != null)
            {
                IrpSearchBox.AutoSuggestBox.TextChanged += IrpSearchBox_TextChanged;
                IrpSearchBox.AutoSuggestBox.PlaceholderText = "Enter your IRP Smart Filter...";
            }
        }


        private async void IrpSearchBox_TextChanged(AutoSuggestBox sender, AutoSuggestBoxTextChangedEventArgs args)
        {
            var text = sender.Text;

            if (String.IsNullOrEmpty(text))
            {
                await ViewModel.GetIrpListAsync();
                return;
            }

            ViewModel.IsLoading = true;

             string[] parameters = text.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
             
             var matches = ViewModel.Irps
                     .Where(
                         irp => parameters.Any(
                             parameter =>
                                 irp.DeviceName.Contains(parameter, StringComparison.OrdinalIgnoreCase) ||
                                 irp.DriverName.Contains(parameter, StringComparison.OrdinalIgnoreCase) ||
                                 irp.ProcessName.Contains(parameter, StringComparison.OrdinalIgnoreCase)
                         )
                     ).ToList();
             
             
             await DispatcherHelper.ExecuteOnUIThreadAsync(() =>
             {
                 if (matches.Count() > 0)
                 {
                     ViewModel.Irps.Clear();
             
                     foreach (var match in matches)
                         ViewModel.Irps.Add(match);
                 }
             });

            ViewModel.IsLoading = false;
        }

        private void RefreshDataGrid()
        {
            IrpDataGrid.ItemsSource = null;
            IrpDataGrid.ItemsSource = ViewModel.Irps;
        }

        private void DataGrid_Sorting(object sender, DataGridColumnEventArgs e) =>
            (sender as DataGrid).Sort(e.Column, ViewModel.Irps.Sort);

        private void ShowDetails_Click(object sender, RoutedEventArgs e)
        {
            this.Frame.Navigate(typeof(Views.IrpInfoPage), ViewModel.SelectedIrp);
        }

        private async void SendToRepeater_Click(object sender, RoutedEventArgs e)
        {
            if (ViewModel.SelectedIrp.Model.header.Type != (uint)IrpMajorType.IRP_MJ_DEVICE_CONTROL)
            {
                await Utils.ShowPopUp("Only IRP_MJ_DEVICE_CONTROL IRP can be replayed");
            }
            else
            {
                this.Frame.Navigate(typeof(Views.ReplayIrpPage), ViewModel.SelectedIrp);
            }
        }


    }
}

```

`GUI/Views/ReplayIrpPage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.ReplayIrpPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:h="using:GUI.Helpers"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Grid>
        <RelativePanel>

            <TextBlock
                x:Name="PageTitle"
                Style="{ThemeResource TitleTextBlockStyle}"
                Text="{x:Bind ReplayIrpPageTitle}" 
                />

            <CommandBar
                x:Name="mainCommandBar"
                Background="Transparent"
                RelativePanel.RightOf="PageTitle" 
                DefaultLabelPosition="Right"
                IsDynamicOverflowEnabled="False"
                HorizontalAlignment="Stretch" 
                HorizontalContentAlignment="Stretch" 
                RelativePanel.AlignRightWithPanel="True"
                >

                <AppBarSeparator />

                <AppBarButton
                    Icon="Send"
                    Label="Send IRP"
                    Visibility="Visible" 
                    Click="SendIrp_Click"
                    />

                <AppBarButton
                    Icon="Cancel"
                    Label="Cancel Replay"
                    Visibility="Visible"
                    Click="CancelReplay_Click"
                    />

                <AppBarSeparator />
            </CommandBar>

            <RelativePanel Margin="10,60,0,0" x:Name="ThisPanel">
                <ProgressBar
                    RelativePanel.AlignTopWithPanel ="True"
                    RelativePanel.AlignHorizontalCenterWithPanel="True"
                    IsIndeterminate="True"
                    Width="1000"
                    FontFamily="Consolas"
                    Visibility="{x:Bind ViewModel.IsLoading, Mode=OneWay}" />
                
                <TextBox
                    x:Name="DeviceNameTextBox"
                    MinWidth="120"
                    Width="300"
                    Margin="0,50,0,0"
                    Header="Device Name"
                    FontFamily="Consolas"
                    FontSize="16" 
                    RelativePanel.AlignLeftWithPanel="True"
                    Text="{x:Bind ViewModel.DeviceName, Mode=OneWay}"
                    TextChanged="DeviceName_TextChanged"
                    />

                <TextBox
                    x:Name="IoctlCodeTextBox"
                    RelativePanel.Below="DeviceNameTextBox"
                    MinWidth="120"
                    Width="300"
                    Margin="0,20,0,0"
                    Header="IOCTL Code"
                    FontFamily="Consolas"
                    FontSize="16" 
                    Text="{x:Bind ViewModel.IoctlCodeString, Mode=OneWay}"
                    TextChanged="IoctlCode_TextChanged"
                    />

                <TextBox
                    x:Name="InputBufferLengthTextBox"
                    RelativePanel.Below="IoctlCodeTextBox"
                    MinWidth="120"
                    Width="300"
                    Margin="0,20,0,0"
                    FontFamily="Consolas"
                    FontSize="16" 
                    Header="Input Buffer Length"
                    Text="{x:Bind ViewModel.InputBufferLength, Mode=OneWay}"
                    TextChanged="InputBufferLength_TextChanged"
                    />

                <TextBox
                    x:Name="OutputBufferLengthTextBox"
                    RelativePanel.RightOf="InputBufferLengthTextBox"
                    RelativePanel.Below="IoctlCodeTextBox"
                    MinWidth="120"
                    Width="300"
                    Margin="50,20,0,0"
                    FontFamily="Consolas"
                    FontSize="16" 
                    Header="Output Buffer Length"
                    Text="{x:Bind ViewModel.OutputBufferLength, Mode=OneWay}"
                    TextChanged="OutputBufferLength_TextChanged"
                    />

                <TextBox
                    x:Name="StatusCodeTextBox"
                    RelativePanel.RightOf="OutputBufferLengthTextBox"
                    RelativePanel.Below="IoctlCodeTextBox"
                    MinWidth="120"
                    Width="300"
                    Margin="50,20,0,0"
                    FontFamily="Consolas"
                    FontSize="16" 
                    Header="Status Code"
                    IsReadOnly="True"
                    Text=""
                    />

                <!--
                TODO: use a real hex-editor (like https://github.com/abbaye/WpfHexEditorControl but for UAP)
                -->

                <TextBox 
                    x:Name="InputBufferTextBlock" 
                    Text="{x:Bind h:Utils.SimpleHexdump(ViewModel.InputBuffer)}"
                    RelativePanel.Below="InputBufferLengthTextBox"
                    TextWrapping="Wrap" 
                    Margin="0,20,0,0"
                    Width="600"
                    FontSize="16" 
                    FontFamily="Consolas"
                    Header="Input Buffer"
                    HorizontalAlignment="Stretch" 
                    />

                <TextBox 
                    x:Name="OutputBufferTextBlock" 
                    Text=""
                    RelativePanel.Below="OutputBufferLengthTextBox"
                    RelativePanel.RightOf="InputBufferTextBlock"
                    TextWrapping="Wrap" 
                    Margin="100,20,0,0"
                    Width="600"
                    FontSize="16" 
                    FontFamily="Consolas"
                    IsReadOnly="True"
                    Header="Output Buffer"
                    HorizontalAlignment="Stretch" 
                    />


                
            </RelativePanel>
            
        </RelativePanel>
    </Grid>
</Page>

```

`GUI/Views/ReplayIrpPage.xaml.cs`:

```cs
using GUI.Helpers;
using GUI.Models;
using GUI.ViewModels;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;



namespace GUI.Views
{

    public sealed partial class ReplayIrpPage : Page
    {
        public ReplayIrpPage()
        {
            this.InitializeComponent();
            this.Loading += OnLoading;
        }


        private void OnLoading(FrameworkElement sender, object args)
        {
            ViewModel = new IrpViewModel();
            ViewModel.Model.header.Type = (uint)IrpMajorType.IRP_MJ_DEVICE_CONTROL;
        }


        public IrpViewModel ViewModel = null;


        protected async override void OnNavigatedTo(NavigationEventArgs e)
        {
            base.OnNavigatedTo(e);

            var irp = (IrpViewModel)e.Parameter;
            if (irp != null)
            {
                if (irp.Model.header.Type != (uint)IrpMajorType.IRP_MJ_DEVICE_CONTROL)
                {
                    await Utils.ShowPopUp("Only IRP_MJ_DEVICE_CONTROL IRP can be replayed");
                    if (Frame.CanGoBack)
                        Frame.GoBack();
                    else
                        Frame.Navigate(typeof(Views.MonitoredIrpsPage));
                    return;
                }

                ViewModel = irp;
            }
        }


        public string ReplayIrpPageTitle
        {
            get
            {
                if (ViewModel == null)
                    return "Forge IRP";
                return $"Replay IRP to {ViewModel.DeviceName} with IOCTL {ViewModel.IoctlCodeString}";
            }
        }


        private async void SendIrp_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                ViewModel.IsLoading = true;

                // 0. empty former result
                StatusCodeTextBox.Text = "";
                OutputBufferTextBlock.Text = "";

                // 1. check fields + sanitize
                var DeviceName = DeviceNameTextBox.Text;
                if (!IsValidDeviceName(DeviceName))
                    throw new InvalidDataException("Expected a valid device path");

                int IoctlCode = Convert.ToInt32(IoctlCodeTextBox.Text, 16);
                int InputBufferLength = int.Parse(InputBufferLengthTextBox.Text);
                int OutputBufferLength = int.Parse(OutputBufferLengthTextBox.Text);

                byte[] InputBuffer = Utils.StringToByteArray(
                    InputBufferTextBlock.Text.Replace(" ", "")
                    .Replace("\r", "")
                    .Replace("\n", "")
                    .Replace("\t", "")
                );


                // 2. build & send forged irp
                var irp = new IrpReplayViewModel();

                Tuple<uint, byte[]> ioctl = await irp.SendIrp(DeviceName, IoctlCode, InputBuffer, InputBuffer.Length, OutputBufferLength);
                StatusCodeTextBox.Text = Utils.FormatMessage(ioctl.Item1);
                OutputBufferTextBlock.Text = Utils.SimpleHexdump(ioctl.Item2);
            }
            catch(Exception ex)
            {
                await Utils.ShowPopUp($"Error: the following exception was triggered: {ex.Message}");
            }
            finally
            {
                ViewModel.IsLoading = false;
            }
        }


        private void CancelReplay_Click(object sender, RoutedEventArgs e)
            => Frame.GoBack();


        private bool IsValidDeviceName(string DeviceName)
            => DeviceName.StartsWith("\\\\.\\");


        private bool IsHex(string text)
        {
            try
            {
                Convert.ToInt32(text, 16);
                return true;
            }
            catch
            {
                return false;
            }
        }


        private bool IsInt(string text)
        {
            try
            {
                int.Parse(text);
                return true;
            }
            catch
            {
                return false;
            }
        }


        private bool IsIntOrHex(string text)
            => IsHex(text) || IsInt(text);

        private void DeviceName_TextChanged(object sender, TextChangedEventArgs e)
        {
            DeviceNameTextBox.BorderBrush = IsValidDeviceName(DeviceNameTextBox.Text) ?
                new SolidColorBrush(Windows.UI.Colors.Green):
                new SolidColorBrush(Windows.UI.Colors.Red);
        }

        private void IoctlCode_TextChanged(object sender, TextChangedEventArgs e)
        {
            IoctlCodeTextBox.BorderBrush = IsIntOrHex(IoctlCodeTextBox.Text) ?
                new SolidColorBrush(Windows.UI.Colors.Green) :
                new SolidColorBrush(Windows.UI.Colors.Red);
        }

        private void InputBufferLength_TextChanged(object sender, TextChangedEventArgs e)
        {
            InputBufferLengthTextBox.BorderBrush = IsIntOrHex(InputBufferLengthTextBox.Text) ?
                new SolidColorBrush(Windows.UI.Colors.Green) :
                new SolidColorBrush(Windows.UI.Colors.Red);
        }

        private void OutputBufferLength_TextChanged(object sender, TextChangedEventArgs e)
        {
            OutputBufferLengthTextBox.BorderBrush = IsIntOrHex(OutputBufferLengthTextBox.Text) ?
                new SolidColorBrush(Windows.UI.Colors.Green) :
                new SolidColorBrush(Windows.UI.Colors.Red);
        }
    }
}

```

`GUI/Views/SaveIrpsToFilePage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.SaveIrpsToFilePage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI.Views"
    xmlns:vm="using:GUI.ViewModels"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
    
    <ScrollViewer Background="{ThemeResource ApplicationPageBackgroundThemeBrush}" Padding="12,10,12,12">
        <StackPanel>
            <TextBlock Text="Save IRPs to disk" Style="{StaticResource HeaderTextBlockStyle}"/>

            <ProgressBar
                 Margin="0,25,0,25"
                 VerticalAlignment="Top"
                 IsIndeterminate="True"
                 Visibility="{x:Bind ViewModel.IsLoading, Mode=OneWay}" 
                Grid.ColumnSpan="2" 
                />
            
            <TextBlock Style="{StaticResource BodyTextBlockStyle}" TextWrapping="Wrap" Margin="0,15,0,0">
                Dump all the IRPs captured in this session to a CFB file on disk, which can be used in further session to restore the current state.
            </TextBlock>
            
            <Button Content="Save IRPs" Click="DumpIrpsToFileButton_Click" Margin="50,35,0,0" x:Name="SaveIrpBtn"/>

            <TextBlock 
                Margin="0,50,0,0"
                Name="UpdateStatusLabel" 
                Text="{x:Bind ViewModel.Status, Mode=OneWay}"
                />
            
        </StackPanel>
    </ScrollViewer>
</Page>

```

`GUI/Views/SaveIrpsToFilePage.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;
using Windows.Storage.Streams;
using Windows.Storage;
using Windows.Storage.Provider;
using Windows.Security.Cryptography;
using System.Threading.Tasks;
using System.Diagnostics;


using GUI.Helpers;
using GUI.ViewModels;


namespace GUI.Views
{
    /// <summary>
    /// Save all the IRP objects to a serialized format to disk
    /// </summary>
    public sealed partial class SaveIrpsToFilePage : Page
    {
        public SaveIrpsToFilePage()
        {
            this.InitializeComponent();
        }


        public SaveLoadIrpsViewModel ViewModel = new SaveLoadIrpsViewModel();


        private async void DumpIrpsToFileButton_Click(object sender, RoutedEventArgs e)
        {
            SaveIrpBtn.IsEnabled = false;
            ViewModel.IsLoading = true;

            try
            {
                var savePicker = new Windows.Storage.Pickers.FileSavePicker();
                savePicker.SuggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.DocumentsLibrary;
                savePicker.SuggestedFileName = $"Session-{DateTime.Now.ToString("yyyyMMddTHH:mm:ssZ")}";
                savePicker.FileTypeChoices.Add("SQLite", new List<string>() { ".cfb" });

                StorageFile file = await savePicker.PickSaveFileAsync();
                if (file != null)
                {
                    CachedFileManager.DeferUpdates(file);
                    FileUpdateStatus status = await CachedFileManager.CompleteUpdatesAsync(file);
                    if (status == FileUpdateStatus.Complete)
                    {
                        var db = await ViewModel.DumpIrpsToFile();
                        await db.MoveAndReplaceAsync(file);
                        ViewModel.Status = $"✔ IRPs saved as '{db.Path}'!";
                        return;
                    }
                }

                ViewModel.Status = "✘ The IRPs were not saved.";
            } 
            catch(Exception ex)
            {
                await Utils.ShowPopUp(
                    $"An error occured while trying to save IRPs to file.\nReason:\n{ex.Message}",
                    "Save IRPs Failed"
                );
            }
            finally
            {
                SaveIrpBtn.IsEnabled = true;
                ViewModel.IsLoading = false;
            }
        }


        static internal IBuffer GetBufferFromString(string str)
        {
            if (String.IsNullOrEmpty(str))
            {
                return new Windows.Storage.Streams.Buffer(0);
            }
            else
            {
                return CryptographicBuffer.ConvertStringToBinary(str, BinaryStringEncoding.Utf8);
            }
        }

    }
    
}

```

`GUI/Views/SessionInfoPage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.SessionInfoPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI.Views"
    xmlns:vm="using:GUI.ViewModels"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
        
        <ProgressBar
            Margin="0,50,0,0"
            VerticalAlignment="Top"
            IsIndeterminate="True"
            Visibility="{x:Bind ViewModel.IsLoading, Mode=OneWay}" Grid.ColumnSpan="2" />
        
        <StackPanel>
            <TextBlock 
                Style="{ThemeResource HeaderTextBlockStyle}"
                Text="Session Information" 
            />

            <TextBlock 
                Margin="5,25,0,5"
                Style="{ThemeResource TitleTextBlockStyle}"     
                Text="Status" />

            <TextBlock
                Margin="10,0,0,0"
                Text="{x:Bind ViewModel.ConnectionStatus}" />

            <TextBlock 
                Margin="5,25,0,5"
                Style="{ThemeResource TitleTextBlockStyle}"     
                Text="IRP captured" />

            <TextBlock
                Margin="10,0,0,0"
                Text="{x:Bind ViewModel.NumberOfIrpsCaptured}" />

            <TextBlock 
                Margin="5,25,0,5"
                Style="{ThemeResource TitleTextBlockStyle}"     
                Text="Number of Drivers" />

            <TextBlock
                Margin="10,0,0,0"
                Text="{x:Bind ViewModel.NumberOfDrivers}" />

            <TextBlock 
                Margin="5,25,0,5"
                Style="{ThemeResource TitleTextBlockStyle}"     
                Text="Hooked Drivers" />

            <TextBlock
                Margin="10,0,0,0"
                Text="{x:Bind ViewModel.NumberOfDriversHooked}" />

            <TextBlock
                x:Name="HookedDrivers"
                Margin="10,0,0,0"
                Text="{x:Bind ViewModel.HookedDriverList}" />

            <StackPanel
                Visibility="{x:Bind vm:Converters.BooleanToVisibility(ViewModel.IsConnected)}"
                >

                <TextBlock 
                    Margin="5,10,0,5"
                    Style="{ThemeResource TitleTextBlockStyle}"     
                    Text="Remote target information" />

                <TextBlock Margin="0,10,0,0" Text="OS Version" />
                <TextBlock Margin="10,0,0,0" Text="{x:Bind ViewModel.RemoteOsVersion, Mode=OneWay}" />

                <TextBlock Margin="0,10,0,0" Text="CPU Info" />
                <TextBlock Margin="10,0,0,0" Text="{x:Bind ViewModel.RemoteNumberOfProcessorString, Mode=OneWay}" />
                <TextBlock Margin="10,0,0,0" Text="{x:Bind ViewModel.RemoteCpuArchitectureString, Mode=OneWay}" />

                <TextBlock Margin="0,10,0,0" Text="User" />
                <TextBlock Margin="10,0,0,0" Text="{x:Bind ViewModel.UserName, Mode=OneWay}" />

                <TextBlock Margin="0,10,0,0" Text="Integrity" />
                <TextBlock Margin="10,0,0,0" Text="{x:Bind ViewModel.IntegrityLevel, Mode=OneWay}" />

                <TextBlock Margin="0,10,0,0" Text="Process Info" />
                <TextBlock Margin="10,0,0,0" Text="{x:Bind ViewModel.ProcessInfo, Mode=OneWay}" />
            </StackPanel>

        </StackPanel>
    </Grid>
</Page>

```

`GUI/Views/SessionInfoPage.xaml.cs`:

```cs
using GUI.ViewModels;
using GUI.Helpers;

using Microsoft.Toolkit.Uwp.Helpers;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;
using System.Threading.Tasks;

namespace GUI.Views
{

    public sealed partial class SessionInfoPage : Page
    {

        public SessionInfoViewModel ViewModel = new SessionInfoViewModel();

        public SessionInfoPage()
        {
            this.InitializeComponent();
        }


        protected override void OnNavigatedTo(NavigationEventArgs e)
        {
            base.OnNavigatedTo(e);

            ViewModel.IsLoading = true;
            ViewModel.StartPeriodicTimer();
            ViewModel.IsLoading = false;
        }


        protected override void OnNavigatingFrom(NavigatingCancelEventArgs e)
        {
            ViewModel.StopPeriodicTimer();
        }
    }
}

```

`GUI/Views/SettingsPage.xaml`:

```xaml
<Page
    x:Class="GUI.Views.SettingsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:GUI.Views"
    xmlns:vm="using:GUI.ViewModels"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

   
    <Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
        <StackPanel>

            <TextBlock Style="{ThemeResource HeaderTextBlockStyle}"
                       Text="Settings" />

            <TextBlock Margin="5,25,0,5"
                       Style="{ThemeResource TitleTextBlockStyle}"
                       Text="IRP Broker location" />

            <TextBlock Text="Specify here the path to the named pipe of the CFB Broker. Default locations can be local (e.g. pipe:\\.\pipe\cfb) or remote (e.g. \\IP.ADDRESS\pipe\cfb or file://IP.ADDRESS/pipe/cfb)"/>

            <TextBox Margin="0,5,1000,0" 
                     BorderBrush="Green"
                     BorderThickness="5"
                     x:Name="settingIrpBrokerLocationTextBox" 
                     SelectionChanged="settingIrpBrokerLocationTextBox_Changed"
                     Text="{x:Bind localSettings.Values['IrpBrokerLocation'] }"/>

            <TextBlock Margin="5,25,0,5"
                       Style="{ThemeResource TitleTextBlockStyle}"
                       Text="Poll delay to the Broker" />
            
            <TextBlock Text="The delay in seconds (double) for polling the broker for new data when monitoring mode is enabled"/>

            <TextBox Margin="0,5,1000,0" 
                     BorderThickness="5"
                     x:Name="settingBrokerPollDelay" 
                     SelectionChanged="settingBrokerPollDelay_Changed"
                     Text="{x:Bind localSettings.Values['BackgroundTaskPollDelay'].ToString() }"/>

            <TextBlock Margin="5,25,0,5"
                       Style="{ThemeResource TitleTextBlockStyle}"
                       Text="Change the home page" />
            
            <TextBlock Text="Set the landing page once CFB-App is loaded"/>

            <ComboBox
                Margin="0,5,1000,0" 
                BorderThickness="5"
                x:Name="settingHomePage" 
                ItemsSource="{x:Bind HomePageList}" 
                SelectedIndex = "{x:Bind vm:Converters.DefaultIntegerIfNull(localSettings.Values['HomePage'])}"
                SelectionChanged="settingHomePage_Changed"
                />
            
        </StackPanel>
    </Grid>
</Page>

```

`GUI/Views/SettingsPage.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;
using Windows.Storage;
using GUI.Models;
using System.Collections.ObjectModel;

namespace GUI.Views
{

    public sealed partial class SettingsPage : Page
    {
        private ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;


        public ObservableCollection<string> HomePageList => App.HomePageList;


        public SettingsPage()
        {
            this.InitializeComponent();
        }


        private void settingIrpBrokerLocationTextBox_Changed(object sender, RoutedEventArgs e)
        {
            var location = settingIrpBrokerLocationTextBox.Text.ToLower();
            if (IsValidLocationFormat(location))
            {
                localSettings.Values["IrpBrokerLocation"] = location;
                settingIrpBrokerLocationTextBox.BorderBrush = new SolidColorBrush(Windows.UI.Colors.Green);
            }
            else
            {
                settingIrpBrokerLocationTextBox.BorderBrush = new SolidColorBrush(Windows.UI.Colors.Red);
            }
        }


        private bool IsValidLocationFormat(string location)
        {
            try
            {
                var uri = new Uri(location);

                if (uri.Scheme != "tcp")
                    return false;

                if (uri.Port < 0)
                    return false;
            }
            catch(Exception)
            {
                return false;
            }

            return true;
        }



        private void settingBrokerPollDelay_Changed(object sender, RoutedEventArgs e)
        {
            try
            {
                var val = Convert.ToDouble(settingBrokerPollDelay.Text.ToString());
                localSettings.Values[IrpDumper.IrpDumperPollDelayKey] = val;
            }
            catch
            {
                // fallback to default
                localSettings.Values[IrpDumper.IrpDumperPollDelayKey] = IrpDumper.IrpDumperDefaultProbeValue;
            }
        }


        private void settingHomePage_Changed(object sender, RoutedEventArgs e)
        {
            localSettings.Values["HomePage"] = settingHomePage.SelectedIndex;
        }
    }
}

```

`README.md`:

```md

<p align="center">
  <img src="/Assets/img/logo/Logo_v1.svg" width="50%" alt="logo" />
</p>

| CI  | Discord |
|:---:|:---:|
| [![Broker - Build MSVC](https://github.com/hugsy/CFB/workflows/CI%20Build%20Broker%20for%20MSVC/badge.svg)](https://github.com/hugsy/CFB/actions/) |[![Discord](https://img.shields.io/badge/Discord-CFB-purple)](https://discord.gg/5HmwPxy3HP) |


## Idea

Furious Beaver is a distributed tool for capturing IRPs sent to any Windows driver. It operates in 2 parts:

1. the "Broker" combines both a user-land agent and a self-extractable driver (`IrpDumper.sys`) that will install itself on the targeted system.
  Once running it will expose (depending on the compilation options) a remote named pipe (reachable from
  `\\target.ip.address\pipe\cfb`), or a TCP port listening on TCP/1337. The communication protocol was made to be simple by design
  (i.e. not secure) allowing any [3rd party tool](https://github.com/hugsy/cfb-cli) to dump the driver IRPs from the same Broker
  easily (via simple JSON messages).

2. the GUI is a Windows 10 UWP app made in a `ProcMon`-style: it will connect to wherever the broker is, and provide a convienent
 GUI for manipulating the broker (driver enumeration, hooking and IRP capturing). It also offers facililties for forging/replaying
 IRPs, auto-fuzzing (i.e. apply specific fuzzing policies on *each* IRP captured), or extract IRP in various formats (raw, as a
 Python script, as a PowerShell script) for further analysis. The captured data can be saved on disk in an easily parsable format
 (`*.cfb` = SQLite) for further analysis, and/or reload afterwards in the GUI.

Although the GUI obviously requires a Windows 10 environment (UWP App), the Broker itself can be deployed on any Windows 7+ host (x86 or x64).
The target host must have `testsigning` BCD policy enabled, as the self-extracting driver is not WHQL friendly.


## Screenshots

### Intercepted IRP view

![Intercepted IRP view](https://i.imgur.com/xMOIIhC.png)

### IRP details

![IRP Metadata](https://i.imgur.com/zmh2QAw.png)
![IRP InputBuffer](https://i.imgur.com/j0W9ljL.png)


### IRP replay

![IRP Replay](https://i.imgur.com/9Ybq27G.png)


## Concept

`IrpDumper.sys` is the driver part of the CFB Broker that will auto-extract and install when launched. The driver will be responsible for hooking the IRP Major Function table of
the driver that is requested to be hooked, via an IOCTL passed from the Broker.
Upon success, the IRP table of the driver will then be pointing to `IrpDumper.sys` interception routine, as we can easily see with a debugger or tools like [`WinObjEx64`](https://github.com/hfiref0x/WinObjEx64).

![img](https://i.imgur.com/dYqHE6q.png)

`IrpDumper.sys` in itself then acts a rootkit, proxy-ing all calls to the targeted driver(s). When a `DeviceIoControl` is sent to a hooked driver, `IrpDumper` will simply capture the data if any, and push a message to the user-land agent (`Broker`), and yield the execution back to the legitimate drivers, allowing the intended code to continue as expected.
The `Broker` stores all this data in user-land waiting for a event to ask for them.


## Build

### GUI

Clone the repository, and build the `Broker` in the solution `CFB.sln` at the project root with Visual Studio (Debug - very verbose - or Release). Additionally, you can build the App GUI by building the `GUI (Universal Windows)` project.



### Command line

Clone the repository and in a VS prompt run

```
C:\cfb\> msbuild CFB.sln /p:Configuration=$Conf
```

Where `$Conf` can be set to `Release` to `Debug`.


## Setup

A Windows 7+ machine ([Windows 10 SDK VM](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines) is recommended)

On this target machine, simply enable BCD test signing flag (in `cmd.exe` as Admin):

```
C:\> bcdedit.exe /set {whatever-profile} testsigning on
```

If using in Debug mode, `IrpDumper.sys` will provide a lot more valuable information as to what's being hooked (the price of performance).
All those info can be visible via tools like `DebugView.exe` or a kernel debugger like WinDbg. In either case, you must enable kernel debug
BCD flag (in `cmd.exe` as Admin):

```
C:\> bcdedit.exe /set {whatever-profile} debug on
```

It is also recommended to edit the KD verbosity level, via:
  - the registry for a permanent effect (`reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter" /v DEFAULT /t REG_DWORD /d 0xf`)
  - directly from WinDbg for only the current session (`ed nt!Kd_Default_Mask 0xf`)


If you plan on (re-)compiling any of the tools, you must install VS (2019 preferred). If using the Release binaries, you only need VS C++ Redist installed
(x86 or x64 depending on your VM architecture).

Follow the indications in the `Docs/` folder to improve your setup.


## Command-line client

Several command line tools (such as dumping all data to SQLite database, fuzzing IRP, etc.) can be found in the external repository
[CFB-cli](https://github.com/hugsy/CFB-cli).


## Why the name?

Because I had no idea for the name of this tool, so it was graciously generated by [a script of mine](https://github.com/hugsy/stuff/tree/master/random-word).

```