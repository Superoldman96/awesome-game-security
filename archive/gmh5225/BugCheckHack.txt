Project Path: arc_gmh5225_BugCheckHack_h81zj_ax

Source Tree:

```txt
arc_gmh5225_BugCheckHack_h81zj_ax
├── BugCheckHack
│   ├── BugCheckHack.inf
│   ├── BugCheckHack.vcxproj
│   ├── BugCheckHack.vcxproj.filters
│   └── entry.c
├── BugCheckHack.sln
├── BugCheckHackUser
│   ├── BugCheckHackUser.vcxproj
│   ├── BugCheckHackUser.vcxproj.filters
│   ├── get.h
│   ├── main.c
│   ├── pdb.h
│   ├── registry.c
│   ├── registry.h
│   ├── service.c
│   └── service.h
└── README.md

```

`BugCheckHack.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BugCheckHack", "BugCheckHack\BugCheckHack.vcxproj", "{7531E089-C527-411B-A36B-17FD0841CE45}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BugCheckHackUser", "BugCheckHackUser\BugCheckHackUser.vcxproj", "{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|ARM.ActiveCfg = Debug|ARM
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|ARM.Build.0 = Debug|ARM
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|ARM.Deploy.0 = Debug|ARM
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|ARM64.Build.0 = Debug|ARM64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|x64.ActiveCfg = Debug|x64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|x64.Build.0 = Debug|x64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|x64.Deploy.0 = Debug|x64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|x86.ActiveCfg = Debug|Win32
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|x86.Build.0 = Debug|Win32
		{7531E089-C527-411B-A36B-17FD0841CE45}.Debug|x86.Deploy.0 = Debug|Win32
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|ARM.ActiveCfg = Release|ARM
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|ARM.Build.0 = Release|ARM
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|ARM.Deploy.0 = Release|ARM
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|ARM64.ActiveCfg = Release|ARM64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|ARM64.Build.0 = Release|ARM64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|ARM64.Deploy.0 = Release|ARM64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|x64.ActiveCfg = Release|x64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|x64.Build.0 = Release|x64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|x64.Deploy.0 = Release|x64
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|x86.ActiveCfg = Release|Win32
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|x86.Build.0 = Release|Win32
		{7531E089-C527-411B-A36B-17FD0841CE45}.Release|x86.Deploy.0 = Release|Win32
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Debug|ARM.ActiveCfg = Debug|Win32
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Debug|ARM64.ActiveCfg = Debug|Win32
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Debug|x64.ActiveCfg = Debug|x64
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Debug|x64.Build.0 = Debug|x64
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Debug|x86.ActiveCfg = Debug|Win32
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Debug|x86.Build.0 = Debug|Win32
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Release|ARM.ActiveCfg = Release|Win32
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Release|ARM64.ActiveCfg = Release|Win32
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Release|x64.ActiveCfg = Release|x64
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Release|x64.Build.0 = Release|x64
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Release|x86.ActiveCfg = Release|Win32
		{158D39C3-3C3D-44E7-B0E1-34334FAFF9D4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BDC49B23-0362-4542-A824-4EF88043B3A3}
	EndGlobalSection
EndGlobal

```

`BugCheckHack/BugCheckHack.inf`:

```inf
;
; BugCheckHack.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=BugCheckHack.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
BugCheckHack_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
BugCheckHack.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%BugCheckHack.DeviceDesc%=BugCheckHack_Device, Root\BugCheckHack ; TODO: edit hw-id

[BugCheckHack_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
BugCheckHack.sys

;-------------- Service installation
[BugCheckHack_Device.NT.Services]
AddService = BugCheckHack,%SPSVCINST_ASSOCSERVICE%, BugCheckHack_Service_Inst

; -------------- BugCheckHack driver install sections
[BugCheckHack_Service_Inst]
DisplayName    = %BugCheckHack.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\BugCheckHack.sys

;
;--- BugCheckHack_Device Coinstaller installation ------
;

[BugCheckHack_Device.NT.CoInstallers]
AddReg=BugCheckHack_Device_CoInstaller_AddReg
CopyFiles=BugCheckHack_Device_CoInstaller_CopyFiles

[BugCheckHack_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[BugCheckHack_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[BugCheckHack_Device.NT.Wdf]
KmdfService =  BugCheckHack, BugCheckHack_wdfsect
[BugCheckHack_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "BugCheckHack Installation Disk"
BugCheckHack.DeviceDesc = "BugCheckHack Device"
BugCheckHack.SVCDESC = "BugCheckHack Service"

```

`BugCheckHack/BugCheckHack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7531E089-C527-411B-A36B-17FD0841CE45}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>BugCheckHack</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="BugCheckHack.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BugCheckHack/BugCheckHack.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="BugCheckHack.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`BugCheckHack/entry.c`:

```c
#include <ntddk.h>

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

PVOID KernelBase = NULL;

PCWSTR Entries[6] = {
	L"Emoticon",
	L"StringOne",
	L"StringTwo",
	L"WebsiteUrl",
	L"CalledSupport",
	L"PossibleFixes"
};

NTSTATUS RegistryGetValue(PCWSTR EntryName, PVOID Address) {
	RTL_QUERY_REGISTRY_TABLE Query[2] = { 0 };
	Query[0].Name = EntryName;
	Query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
	Query[0].EntryContext = Address;
	return RtlQueryRegistryValues(
		RTL_REGISTRY_ABSOLUTE,
		L"\\Registry\\Machine\\Software\\BugCheckHack",
		Query,
		NULL,
		NULL
	);
}

NTSTATUS Overwrite(PVOID Address, PVOID Data, ULONG Size) {
	PHYSICAL_ADDRESS PhysAddress = MmGetPhysicalAddress(Address);
	PVOID MappedAddress = MmMapIoSpace(PhysAddress, Size, MmNonCached);

	if (MappedAddress == NULL)
		return STATUS_INSUFFICIENT_RESOURCES;

	RtlCopyMemory(MappedAddress, Data, Size);
	MmUnmapIoSpace(MappedAddress, Size);
	return STATUS_SUCCESS;
}


// https://www.unknowncheats.me/forum/general-programming-and-reversing/427419-getkernelbase.html

__forceinline wchar_t locase_w(wchar_t c) {
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

int _strcmpi_w(const wchar_t* s1, const wchar_t* s2) {
	wchar_t c1, c2;

	if (s1 == s2)
		return 0;

	if (s1 == 0)
		return -1;

	if (s2 == 0)
		return 1;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
	} while ((c1 != 0) && (c1 == c2));

	return (int)(c1 - c2);
}

PVOID GetKernelBase(PDRIVER_OBJECT DriverObject) {
	if (KernelBase)
		return KernelBase;
	PLDR_DATA_TABLE_ENTRY entry = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;
	PLDR_DATA_TABLE_ENTRY first = entry;
	while ((PLDR_DATA_TABLE_ENTRY)entry->InLoadOrderLinks.Flink != first) {
		if (_strcmpi_w(entry->BaseDllName.Buffer, L"ntoskrnl.exe") == 0) {
			return entry->DllBase;
		}
		entry = (PLDR_DATA_TABLE_ENTRY)entry->InLoadOrderLinks.Flink;
	}
	KernelBase = NULL;
	return NULL;
}

BOOLEAN IsInsider(VOID) {
	DWORD32 Exist;
	RTL_QUERY_REGISTRY_TABLE Query[2] = { 0 };
	Query[0].Name = L"IsBuildFlightingEnabled";
	Query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
	Query[0].EntryContext = &Exist;
	if (RtlQueryRegistryValues(
		RTL_REGISTRY_ABSOLUTE,
		L"\\Registry\\Machine\\Software\\Microsoft\\WindowsSelfHost\\Applicability",
		Query,
		NULL,
		NULL
	)) {
		return FALSE;
	}
	return Exist;
}

VOID ParseEtwpLastBranchLookAsideListStrings(ULONG_PTR EtwpLastBranchLookAsideList, ULONG_PTR* Addresses) {
	Addresses[0] = EtwpLastBranchLookAsideList + 0x60;
	PUNICODE_STRING temp = (PUNICODE_STRING)(EtwpLastBranchLookAsideList + 0x60);
	for (UCHAR i = 0; i < sizeof(UNICODE_STRING); i++, temp++) {
		if (wcsstr(temp->Buffer, L"Insider Build ran into a problem and needs to restart.") && IsInsider())
			Addresses[0] = (UINT64)temp;
		if (wcsstr(temp->Buffer, L"and then we'll restart for you"))
			Addresses[1] = (UINT64)temp;
		if (wcsstr(temp->Buffer, L"www.windows.com/stopcode"))
			Addresses[2] = (UINT64)temp;
		if (wcsstr(temp->Buffer, L"this issue and possible fixes, visit"))
			Addresses[3] = (UINT64)temp;
		if (wcsstr(temp->Buffer, L"give them this info:"))
			Addresses[4] = (UINT64)temp;
	}
}

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
	DWORD32 FrownyOffset = 0;
	DWORD32 StringsOffset = 0;
	DWORD32 BgpClearScreen = 0;
	KernelBase = GetKernelBase(DriverObject);
	if (RegistryGetValue(L"FrownyOffset", &FrownyOffset)) {
		return STATUS_DRIVER_INTERNAL_ERROR;
	}
	if (RegistryGetValue(L"StringsOffset", &StringsOffset)) {
		return STATUS_DRIVER_INTERNAL_ERROR;
	}
	if (RegistryGetValue(L"BgpClearScreenOffset", &BgpClearScreen)) {
		return STATUS_DRIVER_INTERNAL_ERROR;
	}
	
	DbgPrint("%llx\n%llx\n%llx\n%llx\n", FrownyOffset, StringsOffset, BgpClearScreen, KernelBase);

	if (!FrownyOffset || !StringsOffset)
		return STATUS_DRIVER_INTERNAL_ERROR;

	ULONG_PTR Strings[5] = { 0 };
	ParseEtwpLastBranchLookAsideListStrings((ULONG_PTR)KernelBase + StringsOffset, Strings);
	
	// faster than memset lmfao
	CHAR Patch[8] = { 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3 };

	if (BgpClearScreen != 0) {
		Overwrite((PVOID)((ULONG_PTR)KernelBase + BgpClearScreen), Patch, 1);
	}

	UNICODE_STRING String[6] = { 0 };

	String[0].MaximumLength = 10;
	for (UCHAR i = 1; i < 6; i++)
		String[i].MaximumLength = 100;

	for (UCHAR i = 0; i < 6; i++) {
		if (RegistryGetValue(Entries[i], &String[i])) {
			return STATUS_DRIVER_INTERNAL_ERROR;
		}
		if (i == 0) {
			if (Overwrite(((ULONG_PTR)KernelBase + FrownyOffset), &String[i], sizeof(UNICODE_STRING)))
				return STATUS_DRIVER_INTERNAL_ERROR;
		}
		else {
			if (Overwrite(Strings[i - 1], &String[i], sizeof(UNICODE_STRING)))
				return STATUS_DRIVER_INTERNAL_ERROR;
		}
	}

	return STATUS_FAILED_DRIVER_ENTRY;
}
```

`BugCheckHackUser/BugCheckHackUser.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{158d39c3-3c3d-44e7-b0e1-34334faff9d4}</ProjectGuid>
    <RootNamespace>BugCheckHackUser</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Version.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Version.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Version.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Version.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="registry.c" />
    <ClCompile Include="service.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="get.h" />
    <ClInclude Include="pdb.h" />
    <ClInclude Include="registry.h" />
    <ClInclude Include="service.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BugCheckHackUser/BugCheckHackUser.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="registry.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="service.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="registry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="get.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pdb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="service.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`BugCheckHackUser/get.h`:

```h
#ifndef LIBVALINET_INTERNET_GET_H_
#define LIBVALINET_INTERNET_GET_H_
#include <stdio.h>
#include <Windows.h>
#include <Wininet.h>
#pragma comment(lib, "Wininet.lib")

DWORD VnDownloadFile(
    char* filename,
    char* hostname,
    char* path,
    char* userAgent,
    INTERNET_PORT nServerPort,
    DWORD dwService,
    char* referrer,
    char* headers,
    DWORD bufsiz
)
{
    DWORD dwRet = 0;
    HINTERNET hInternet;
    if (hInternet = InternetOpenA(
        userAgent,
        INTERNET_OPEN_TYPE_DIRECT,
        NULL,
        NULL,
        NULL
    ))
    {
        HINTERNET hConnect;
        if (hConnect = InternetConnectA(
            hInternet,
            hostname,
            nServerPort,
            NULL,
            NULL,
            dwService,
            NULL,
            NULL
        ))
        {
            HINTERNET hRequest;
            if (hRequest = HttpOpenRequestA(
                hConnect,
                "GET",
                path,
                NULL,
                referrer,
                NULL,
                NULL,
                NULL
            ))
            {
                char data[1] = "";
                if (HttpSendRequestA(
                    hRequest,
                    headers,
                    strlen(headers),
                    (LPVOID)(data),
                    strlen(data) * sizeof(char)
                ))
                {
                    FILE* f = NULL;
                    if (fopen_s(
                        &f,
                        filename,
                        "wb"
                    ))
                    {
                        dwRet = 7;
                    }
                    else
                    {
                        BYTE* buffer = (BYTE*)malloc(bufsiz);
                        if (buffer == NULL)
                        {
                            dwRet = 6;
                        }
                        else
                        {
                            DWORD dwRead;
                            BOOL bRet = TRUE;
                            while (bRet = InternetReadFile(
                                hRequest,
                                buffer,
                                bufsiz,
                                &dwRead
                            ))
                            {
                                if (dwRead == 0)
                                {
                                    break;
                                }
                                fwrite(
                                    buffer,
                                    sizeof(BYTE),
                                    dwRead,
                                    f
                                );
                                dwRead = 0;
                            }
                            if (bRet == FALSE)
                            {
                                dwRet = 5;
                            }
                            free(buffer);
                        }
                        fclose(f);
                    }
                }
                else
                {
                    dwRet = 4;
                }
                InternetCloseHandle(hRequest);
            }
            else
            {
                dwRet = 3;
            }
            InternetCloseHandle(hConnect);
        }
        else
        {
            dwRet = 2;
        }
        InternetCloseHandle(hInternet);
    }
    else
    {
        dwRet = 1;
    }
    return dwRet;
}

#endif
```

`BugCheckHackUser/main.c`:

```c
#include <windows.h>
#include "registry.h"
#include "pdb.h"
#include "service.h"

// shit to make it look nicer

#pragma comment(linker,"\"/manifestdependency:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

// https://stackoverflow.com/a/41808496

BOOL CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam) {
    HFONT hfDefault = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    SendMessage(hWnd, WM_SETFONT, (WPARAM)hfDefault, MAKELPARAM(TRUE, 0));
    return TRUE;
}

PCWSTR* ValueNames[6] = {
    L"Frowny",
    L"String One",
    L"String Two",
    L"Website URL",
    L"Called Support",
    L"Possible Fixes"
};

PCWSTR* ButtonNames[4] = {
    L"Save Values",
    L"Create Service",
    L"Delete Service",
    L"Run Service"
};

PCWSTR* RegValueNames[9] = {
    L"FrownyOffset",
    L"StringsOffset",
    L"BgpClearScreenOffset",
    L"Emoticon",
    L"StringOne",
    L"StringTwo",
    L"WebsiteUrl",
    L"CalledSupport",
    L"PossibleFixes"
};

#define KEY L"SOFTWARE\\BugCheckHack"

CHAR FilePathA[MAX_PATH] = { 0 };
WCHAR FilePathW[MAX_PATH] = { 0 };
UCHAR count = 2;

VOID GetWindowsVersion(DWORD* Version) {
    DWORD Dummy;
    DWORD FileInfoSize = GetFileVersionInfoSizeExW(FILE_VER_GET_NEUTRAL, L"KernelBase.dll", &Dummy);
    BYTE* Buffer = (BYTE*)malloc(FileInfoSize);
    GetFileVersionInfoExW(FILE_VER_GET_NEUTRAL, L"KernelBase.dll", Dummy,
        FileInfoSize, Buffer);
    VOID* p = NULL;
    UINT Size = 0;
    VerQueryValueW(Buffer, L"\\", &p, &Size);
    const VS_FIXEDFILEINFO* FileInfo = (const VS_FIXEDFILEINFO*)p;
    Version[0] = HIWORD(FileInfo->dwFileVersionMS);
    Version[1] = LOWORD(FileInfo->dwFileVersionMS);
    Version[2] = HIWORD(FileInfo->dwFileVersionLS);
    Version[3] = LOWORD(FileInfo->dwFileVersionLS);
    free(Buffer);
}

BOOL IsProcessElevated(VOID) {
    BOOL IsElevated = FALSE;
    HANDLE hToken = NULL;
    TOKEN_ELEVATION elevation;
    DWORD dwSize;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        if (hToken) {
            CloseHandle(hToken);
            hToken = NULL;
            return FALSE;
        }
    }


    if (!GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize)) {
        if (hToken) {
            CloseHandle(hToken);
            hToken = NULL;
            return FALSE;
        }
    }

    return elevation.TokenIsElevated;
}

// Kill me

BOOLEAN ParseNtoskrnl(VOID) {
    if (VnDownloadSymbols(NULL, FilePathA,
        FilePathA, MAX_PATH)) {
        MessageBox(NULL, L"Failed to download symbols", NULL, MB_ICONSTOP);
        return FALSE;
    }
    DWORD Address[3] = { 0 };
    DWORD WindowsVersion[4] = { 0 };
    GetWindowsVersion(WindowsVersion);
    if (WindowsVersion[2] >= 19041 && WindowsVersion[2] < 22000) {
        CHAR* SymbolName[3] = { "HalpPCIConfigReadHandlers", "EtwpLastBranchLookAsideList", "BgpClearScreen" };
        if (VnGetSymbols(FilePathA,
            Address, SymbolName, count)) {
            MessageBox(NULL, L"Failed to find the required functions", NULL, MB_ICONSTOP);
            return FALSE;
        }
    }
    else if (WindowsVersion[2] >= 22000) {
        if (WindowsVersion[3] >= 434) {
            CHAR* SymbolName[3] = { "HalpPCIConfigReadHandlers", "EtwpStackLookAsideList", "BgpClearScreen" };
            if (VnGetSymbols(FilePathA,
                Address, SymbolName, count)) {
                MessageBox(NULL, L"Failed to find the required functions", NULL, MB_ICONSTOP);
                return FALSE;
            }
        }
        else {
            CHAR* SymbolName[3] = { "HalpPCIConfigReadHandlers", "EtwpLastBranchLookAsideList", "BgpClearScreen" };
            if (VnGetSymbols(FilePathA,
                Address, SymbolName, count)) {
                MessageBox(NULL, L"Failed to find the required functions", NULL, MB_ICONSTOP);
                return FALSE;
            }
        }
    }
    else {
        MessageBox(NULL, L"This version of Windows is not supported", NULL, MB_ICONSTOP);
        return FALSE;
    }
    for (int i = 0; i < 3; i++) {
        if (!i)
            Address[i] += 0x18;
        RegistryWriteDword32(KEY, RegValueNames[i], Address[i]);
    }
    if (!ServiceStart(L"BugCheckHack")) {
        MessageBox(NULL, L"Failed to start service", NULL, MB_ICONSTOP);
        return FALSE;
    }
    return TRUE;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {

    BOOLEAN checked = TRUE;
    INT first = 5;
    static HWND TextBoxes[6];
    HINSTANCE inst = { 0 };
    switch (msg) {

    case WM_CREATE:

        for (UCHAR i = 0; i < 6; i++) {
            CreateWindow(L"Static", ValueNames[i],
                WS_CHILD | WS_VISIBLE | SS_LEFT,
                5, 10 + (i * 30), 300, 230,
                hwnd, (HMENU)1, NULL, NULL);
            TextBoxes[i] = CreateWindow(L"Edit", NULL,
                WS_CHILD | WS_VISIBLE | WS_BORDER,
                90, 10 + (i * 30), 325, 20, hwnd, (HMENU)i,
                NULL, NULL);
        }

        CreateWindowW(L"Button", L"Aero BSOD",
            WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON,
            5, 10 + (6 * 30), (10 * 9), 15, hwnd, (HMENU)42, inst, NULL);

        for (int i = 0; i < 4; i++) {
            CreateWindow(L"Button", ButtonNames[i],
                WS_VISIBLE | WS_CHILD,
                first, (7 * 30) + 10, (wcslen(ButtonNames[i]) * 8), 25, hwnd, (HMENU)10 + i, NULL, NULL);
                first += (wcslen(ButtonNames[i]) * 8) + 10;
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
            case 0xa:
                for (INT i = 0; i < 6; i++) {
                    PCWSTR Text = malloc((GetWindowTextLength(TextBoxes[i]) + 1) * sizeof(WCHAR));
                    GetWindowText(TextBoxes[i], Text, GetWindowTextLength(TextBoxes[i]) + 1);
                    RegistryWriteString(KEY, RegValueNames[i + 3], Text);
                    free(Text);
                }
                break;
            case 0xe:
                if (!ServiceCreate(L"BugCheckHack", FilePathW)) {
                    MessageBox(hwnd, L"Failed to create service", NULL, MB_ICONSTOP);
                    break;
                }
                MessageBox(hwnd, L"Successfully created the service", NULL, 0);
                break;
            case 0x12:
                if (!ServiceDelete(L"BugCheckHack")) {
                    MessageBox(hwnd, L"Failed to delete service", NULL, MB_ICONSTOP);
                    break;
                }
                MessageBox(hwnd, L"Successfully deleted the service", NULL, 0);
                break;
            case 0x16:
                if (!ParseNtoskrnl()) {
                    MessageBox(hwnd, L"Failed to modify the bsod", NULL, 0);
                    break;
                }
                MessageBox(hwnd, L"Successfully modified the bsod", NULL, 0);
                break;
            case 0x2a:
                count = 3;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {

    if (!IsProcessElevated()) {
        MessageBox(NULL, L"Please run the program as administrator!", NULL, MB_ICONSTOP);
        return -1;
    }

    if (!RegistryDoesKeyExist(KEY))
        RegistryCreateKey(KEY);

    GetSystemDirectoryA(FilePathA, MAX_PATH);
    strcat_s(FilePathA, MAX_PATH, "\\ntoskrnl.exe");

    GetWindowsDirectoryW(FilePathW, MAX_PATH * sizeof(WCHAR));
    lstrcatW(FilePathW, L"\\BugCheckHack.sys");

    DWORD dwAttrib = GetFileAttributes(FilePathW);

    if (!(dwAttrib != INVALID_FILE_ATTRIBUTES &&
        !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY))) {
        MessageBox(NULL, L"Make sure to copy over BugCheckHack.sys to your Windows directory before running", NULL, MB_ICONSTOP);
        return -1;
    }

    MSG  msg;
    WNDCLASSW wc = { 0 };
    wc.lpszClassName = L"BugCheckHack";
    wc.hInstance = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc = WndProc;
    wc.hCursor = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    HWND window = CreateWindow(wc.lpszClassName, L"BugCheckHack",
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
        150, 150, 455, (10 * 30), 0, 0, hInstance, 0);

    EnumChildWindows(window, EnumChildProc, 0);

    ShowWindow(window, SW_SHOW);

    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}
```

`BugCheckHackUser/pdb.h`:

```h
#ifndef LIBVALINET_PDB_PDB_H_
#define LIBVALINET_PDB_PDB_H_
//
// pdb includes:
// * pdbdump - Small tool to list and query symbols in PDB files.
//   original source code: https://gist.github.com/mridgers/2968595
// * PDBDownloader
//   original source code: https://github.com/rajkumar-rangaraj/PDB-Downloader

#include "get.h"
#include <stdio.h>
#include <Windows.h>
#include <stdint.h>
#include <DbgHelp.h>
#pragma comment(lib, "dbghelp.lib")
#include <Shlwapi.h>
#pragma comment(lib, "Shlwapi.lib")

#define ASSERT(x, m, ...)                   if (!(x)) { fprintf(stderr, m, __VA_ARGS__);    \
                                                exit(-1); }
#define VN_PDB_ONE_MB                       (10240 * 10240)
#define VN_PDB_ADDRESS_OFFSET               0x400000
#define VN_PDB_SYMBOL_HOSTNAME              "msdl.microsoft.com"
#define VN_PDB_SYMBOL_WEB                   "/download/symbols/"
#define VN_PDB_USER_AGENT                   "Microsoft-Symbol-Server/10.0.10036.206"
#define VN_PDB_FORM_HEADERS                 "Content-Type: application/octet-stream;\r\n"
#define VN_PDB_DOWNLOAD_FILE_BUFFER_SIZE    4096

// https://deplinenoise.wordpress.com/2013/06/14/getting-your-pdb-name-from-a-running-executable-windows/
typedef struct _PdbInfo
{
    DWORD     Signature;
    GUID      Guid;
    DWORD     Age;
    char      PdbFileName[1];
};
typedef struct _PdbInfo PdbInfo;

//------------------------------------------------------------------------------
// https://stackoverflow.com/questions/3828835/how-can-we-check-if-a-file-exists-or-not-using-win32-program
int fileExists(char* file)
{
    WIN32_FIND_DATAA FindFileData;
    HANDLE handle = FindFirstFileA(file, &FindFileData);
    int found = handle != INVALID_HANDLE_VALUE;
    if (found)
    {
        FindClose(handle);
    }
    return found;
}

enum e_mode
{
    e_mode_resolve_stdin,
    e_mode_enum_symbols,
};

enum e_enum_type
{
    e_enum_type_symbols,
    e_enum_type_types
};

struct _sym_info
{
    DWORD64     addr;
    int         size;
    char* name;
    char* file;
    int         tag : 8;
    int         line : 24;
};
typedef struct _sym_info sym_info_t;

struct _pool
{
    char* base;
    int     committed;
    int     size;
    int     used;
};
typedef struct _pool pool_t;

typedef int (sort_func_t)(const sym_info_t*, const sym_info_t*);

int                 g_page_size = 0;
HANDLE              g_handle = (HANDLE)0x493;
int                 g_csv_output = 0;
int                 g_sym_count = 0;
enum e_mode         g_mode = e_mode_enum_symbols;
enum e_enum_type    g_enum_type = e_enum_type_symbols;
pool_t              g_symbol_pool;
pool_t              g_string_pool;
extern const char* g_sym_tag_names[];      /* ...at end of file */

void pool_create(pool_t* pool, int size)
{
    pool->base = (char*)VirtualAlloc(NULL, size, MEM_RESERVE, PAGE_READWRITE);
    pool->size = size;
    pool->committed = 0;
    pool->used = 0;
}

void pool_destroy(pool_t* pool)
{
    VirtualFree(pool->base, 0, MEM_RELEASE);
}

void pool_clear(pool_t* pool)
{
    pool->used = 0;
}

void* pool_alloc(pool_t* pool, int size)
{
    int i;
    char* addr;

    ASSERT(size < g_page_size, "Allocation too large!");

    i = pool->used + size;
    if (i >= pool->committed)
    {
        ASSERT(i < pool->size, "Memory pool exhausted.");
        VirtualAlloc((void*)(pool->base + pool->committed), g_page_size,
            MEM_COMMIT, PAGE_READWRITE
        );
        pool->committed += g_page_size;
    }

    addr = pool->base + pool->used;
    pool->used += size;
    return addr;
}

void dbghelp_to_sym_info(SYMBOL_INFO* info, sym_info_t* sym_info)
{
    BOOL ok;
    DWORD disp;
    IMAGEHLP_LINE64 line;

    // General properties
    sym_info->addr = info->Address;
    sym_info->size = info->Size;
    sym_info->tag = info->Tag;

    // Symbol name
    sym_info->name = (char*)pool_alloc(&g_string_pool, info->NameLen + 1);
    memcpy(sym_info->name, info->Name, info->NameLen);

    // Get file and line number info.
    line.SizeOfStruct = sizeof(line);
    ok = SymGetLineFromAddr64(g_handle, info->Address, &disp, &line);
    if ((ok != FALSE) && line.FileName)
    {
        sym_info->line = line.LineNumber;
        sym_info->file = (char*)pool_alloc(&g_string_pool, strlen(line.FileName) + 1);
        memcpy(sym_info->file, line.FileName, strlen(line.FileName));
    }
    else
    {
        sym_info->line = 0;
        sym_info->file = (char*)"?";
    }
}

BOOL CALLBACK enum_proc(SYMBOL_INFO* info, ULONG size, void* param)
{
    sym_info_t* sym_info;

    sym_info = (sym_info_t*)pool_alloc(&g_symbol_pool, sizeof(sym_info_t));
    dbghelp_to_sym_info(info, sym_info);

    ++g_sym_count;

    return TRUE;
}

int create_pools(uintptr_t base_addr)
{
    BOOL ok;
    FILE* in;
    int size, i;
    const char* guide;

    // Fetch PDB file for the module.
    IMAGEHLP_MODULE64 module = { sizeof(module) };
    ok = SymGetModuleInfo64(g_handle, base_addr, &module);
    if (!ok)
    {
        return 0;
    }

    guide = module.LoadedPdbName;

    // An .exe with no symbols available?
    if (!guide || guide[0] == '\0')
    {
        return 0;
    }

    // Get file size.
    fopen_s(&in, guide, "rb");
    ASSERT(in != NULL, "Failed to open pool-size guide file.");

    fseek(in, 0, SEEK_END);
    size = ftell(in);
    fclose(in);

    // Use anecdotal evidence to guess at suitable pool sizes :).
    i = size / 4;
    pool_create(&g_string_pool, (i < VN_PDB_ONE_MB) ? VN_PDB_ONE_MB : i);

    i = size / 25;
    pool_create(&g_symbol_pool, (i < VN_PDB_ONE_MB) ? VN_PDB_ONE_MB : i);

    return 1;
}

uintptr_t load_module(const char* pdb_file)
{
    uintptr_t base_addr = VN_PDB_ADDRESS_OFFSET;

    base_addr = (size_t)SymLoadModuleEx(g_handle, NULL, pdb_file, NULL,
        base_addr, 0x7fffffff, NULL, 0
    );

    return base_addr;
}

INT VnGetSymbols(
    const char* pdb_file,
    DWORD* addresses,
    char** symbols,
    DWORD numOfSymbols
)
{
    DWORD options;
    SYSTEM_INFO sys_info;
    int i;
    uintptr_t base_addr;
    DWORD ok;

    // Get page size.
    GetSystemInfo(&sys_info);
    g_page_size = sys_info.dwPageSize;

    // Initialise DbgHelp
    options = SymGetOptions();
    options &= ~SYMOPT_DEFERRED_LOADS;
    options |= SYMOPT_LOAD_LINES;
    options |= SYMOPT_IGNORE_NT_SYMPATH;
#if ENABLE_DEBUG_OUTPUT
    options |= SYMOPT_DEBUG;
#endif
    options |= SYMOPT_UNDNAME;
    SymSetOptions(options);

    ok = SymInitialize(g_handle, NULL, FALSE);
    if (!ok)
    {
        return -1;
    }

    // Load module.
    base_addr = load_module(pdb_file);
    if (!base_addr)
    {
        SymCleanup(g_handle);
        return -2;
    }

    if (!create_pools(base_addr))
    {
        SymCleanup(g_handle);
        return -3;
    }

    g_sym_count = 0;
    for (i = 0; i < numOfSymbols; ++i)
    {
        SymEnumSymbols(g_handle, base_addr, symbols[i], enum_proc, NULL);
        if (g_sym_count != i + 1)
        {
            SymCleanup(g_handle);
            return -4;
        }
    }

    for (i = 0; i < g_sym_count; ++i)
    {
        sym_info_t* sym_info = ((sym_info_t*)g_symbol_pool.base) + i;
        addresses[i] = sym_info->addr - VN_PDB_ADDRESS_OFFSET;
    }

    // Done.
    ok = SymUnloadModule64(g_handle, (DWORD64)base_addr);
    if (!ok)
    {
        SymCleanup(g_handle);
        return -5;
    }

    pool_destroy(&g_string_pool);
    pool_destroy(&g_symbol_pool);

    SymCleanup(g_handle);

    return 0;
}

// adapted from: https://github.com/rajkumar-rangaraj/PDB-Downloader
INT VnDownloadSymbols(
    HMODULE hModule,
    char* dllName,
    char* szLibPath,
    UINT sizeLibPath
)
{
    HANDLE hFile;
    HANDLE hFileMapping;
    LPVOID lpFileBase;
    PBYTE baseImage;
    PIMAGE_DOS_HEADER dosHeader;
#ifdef _WIN64
    PIMAGE_NT_HEADERS64 ntHeader;
#else
    PIMAGE_NT_HEADERS32 ntHeader;
#endif
    PIMAGE_SECTION_HEADER sectionHeader;
    DWORD ptr;
    UINT nSectionCount;
    UINT i;
    uintptr_t offset;
    UINT cbDebug = 0;
    PIMAGE_DEBUG_DIRECTORY imageDebugDirectory;
    PdbInfo* pdb_info = NULL;
    char url[_MAX_PATH];
    ZeroMemory(url, _MAX_PATH * sizeof(char));
    strcat_s(url, _MAX_PATH, VN_PDB_SYMBOL_WEB);

    hFile = CreateFileA(
        dllName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        0
    );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return 1;
    }

    hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hFileMapping == 0)
    {
        CloseHandle(hFile);
        return 2;
    }

    lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if (lpFileBase == 0)
    {
        CloseHandle(hFileMapping);
        CloseHandle(hFile);
        return 3;
    }

    baseImage = (PBYTE)lpFileBase;
    dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
    {
        UnmapViewOfFile(lpFileBase);
        CloseHandle(hFileMapping);
        CloseHandle(hFile);
        return 4;
    }

#ifdef _WIN64
    ntHeader = (PIMAGE_NT_HEADERS64)((u_char*)dosHeader + dosHeader->e_lfanew);
#else
    ntHeader = (PIMAGE_NT_HEADERS32)((u_char*)dosHeader + dosHeader->e_lfanew);
#endif
    if (ntHeader->Signature != IMAGE_NT_SIGNATURE)
    {
        UnmapViewOfFile(lpFileBase);
        CloseHandle(hFileMapping);
        CloseHandle(hFile);
        return 5;
    }
    if (ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress == 0)
    {
        UnmapViewOfFile(lpFileBase);
        CloseHandle(hFileMapping);
        CloseHandle(hFile);
        return 6;
    }
    cbDebug = ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
    ptr = ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
    sectionHeader = IMAGE_FIRST_SECTION(ntHeader);
    nSectionCount = ntHeader->FileHeader.NumberOfSections;
    for (i = 0; i <= nSectionCount; ++i, ++sectionHeader)
    {
        if ((sectionHeader->VirtualAddress) > ptr)
        {
            sectionHeader--;
            break;
        }
    }
    if (i > nSectionCount)
    {
        sectionHeader = IMAGE_FIRST_SECTION(ntHeader);
        UINT nSectionCount = ntHeader->FileHeader.NumberOfSections;
        for (i = 0; i < nSectionCount - 1; ++i, ++sectionHeader);
    }
    offset = (uintptr_t)baseImage + ptr + (uintptr_t)sectionHeader->PointerToRawData - (uintptr_t)sectionHeader->VirtualAddress;
    while (cbDebug >= sizeof(IMAGE_DEBUG_DIRECTORY))
    {
        imageDebugDirectory = (PIMAGE_DEBUG_DIRECTORY)(offset);
        offset += sizeof(IMAGE_DEBUG_DIRECTORY);
        if (imageDebugDirectory->Type == IMAGE_DEBUG_TYPE_CODEVIEW)
        {
            pdb_info = (PdbInfo*)((uintptr_t)baseImage + imageDebugDirectory->PointerToRawData);
            if (0 == memcmp(&pdb_info->Signature, "RSDS", 4))
            {
                strcat_s(url, _MAX_PATH, pdb_info->PdbFileName);
                strcat_s(url, _MAX_PATH, "/");
                // https://stackoverflow.com/questions/1672677/print-a-guid-variable
                sprintf_s(
                    url + strlen(url),
                    33,
                    "%08lX%04hX%04hX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX",
                    pdb_info->Guid.Data1,
                    pdb_info->Guid.Data2,
                    pdb_info->Guid.Data3,
                    pdb_info->Guid.Data4[0],
                    pdb_info->Guid.Data4[1],
                    pdb_info->Guid.Data4[2],
                    pdb_info->Guid.Data4[3],
                    pdb_info->Guid.Data4[4],
                    pdb_info->Guid.Data4[5],
                    pdb_info->Guid.Data4[6],
                    pdb_info->Guid.Data4[7]
                );
                sprintf_s(
                    url + strlen(url),
                    4,
                    "%x/",
                    pdb_info->Age
                );
                strcat_s(url, _MAX_PATH, pdb_info->PdbFileName);
                break;
            }
        }
        cbDebug -= (UINT)sizeof(IMAGE_DEBUG_DIRECTORY);
    }
    if (pdb_info == NULL)
    {
        UnmapViewOfFile(lpFileBase);
        CloseHandle(hFileMapping);
        CloseHandle(hFile);
        return 7;
    }
    PathRemoveFileSpecA(szLibPath);
    strcat_s(
        szLibPath,
        sizeLibPath,
        "\\"
    );
    strcat_s(
        szLibPath,
        sizeLibPath,
        pdb_info->PdbFileName
    );
    UnmapViewOfFile(lpFileBase);
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
    if (fileExists(szLibPath))
    {
        DeleteFileA(szLibPath);
    }
    return VnDownloadFile(
        szLibPath,
        (char*)VN_PDB_SYMBOL_HOSTNAME,
        url,
        (char*)VN_PDB_USER_AGENT,
        INTERNET_DEFAULT_HTTP_PORT,
        INTERNET_SERVICE_HTTP,
        NULL,
        (char*)VN_PDB_FORM_HEADERS,
        VN_PDB_DOWNLOAD_FILE_BUFFER_SIZE
    );
}
#endif

```

`BugCheckHackUser/registry.c`:

```c
#include "registry.h"

BOOLEAN RegistryDoesKeyExist(PCWSTR Key) {
	HKEY temp;
	return !(RegOpenKeyEx(HKEY_LOCAL_MACHINE, Key, 0, KEY_READ, &temp));
}

BOOLEAN RegistryCreateKey(PCWSTR Key) {
	DWORD dwDisposition;
	HKEY  hKey;
	DWORD Ret = RegCreateKeyEx(HKEY_LOCAL_MACHINE, Key, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition);
	if (Ret != ERROR_SUCCESS) {
		return FALSE;
	}
	RegCloseKey(hKey);
	return TRUE;
}

BOOLEAN RegistryWriteDword32(PCWSTR Key, PCWSTR ValueName, DWORD32 Value) {
	HKEY hKey;
	DWORD Ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, Key, 0, KEY_WRITE, &hKey);
	if (Ret == ERROR_SUCCESS) {
		if (RegSetValueEx(hKey, ValueName, 0, REG_DWORD, (BYTE*)(&Value), sizeof(Value))) {
			RegCloseKey(hKey);
			return FALSE;
		}
		RegCloseKey(hKey);
		return TRUE;
	}
	return FALSE;
}

BOOLEAN RegistryWriteString(PCWSTR Key, PCWSTR ValueName, PCWSTR Value) {
	DWORD Ret;
	HKEY hKey;
	Ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, Key, 0, KEY_WRITE, &hKey);
	if (Ret == ERROR_SUCCESS) {
		if (RegSetValueEx(hKey, ValueName, 0, REG_SZ, (LPBYTE)(Value), ((((DWORD)lstrlen(Value) + 1)) * 2))) {
			RegCloseKey(hKey);
			return FALSE;
		}
		RegCloseKey(hKey);
		return TRUE;
	}
	return FALSE;
}
```

`BugCheckHackUser/registry.h`:

```h
#pragma once

#include <Windows.h>

BOOLEAN RegistryDoesKeyExist(PCWSTR Key);
BOOLEAN RegistryCreateKey(PCWSTR Key);
BOOLEAN RegistryWriteDword32(PCWSTR Key, PCWSTR ValueName, DWORD32 Value);
BOOLEAN RegistryWriteString(PCWSTR Key, PCWSTR ValueName, PCWSTR Value);
```

`BugCheckHackUser/service.c`:

```c
#include "service.h"

BOOLEAN ServiceCreate(PCWSTR Name, PCWSTR Path) {
	SC_HANDLE pSCM = OpenSCManagerW(NULL, NULL,
		SC_MANAGER_CREATE_SERVICE);
	if (!pSCM)
		return FALSE;
	SC_HANDLE pService = CreateService(
		pSCM,
		Name,
		Name,
		SERVICE_ALL_ACCESS,
		SERVICE_KERNEL_DRIVER,
		SERVICE_AUTO_START,
		SERVICE_ERROR_IGNORE,
		Path,
		NULL, NULL, NULL, NULL, NULL
	);
	if (!pService) {
		CloseServiceHandle(pSCM);
		return FALSE;
	}
	CloseServiceHandle(pService);
	CloseServiceHandle(pSCM);
	return TRUE;
}

BOOLEAN ServiceDelete(PCWSTR Name) {
	SC_HANDLE pSCM = OpenSCManagerW(NULL, NULL,
		SC_MANAGER_CREATE_SERVICE);
	if (!pSCM)
		return FALSE;
	SC_HANDLE pService = OpenService(pSCM, Name, SERVICE_ALL_ACCESS);
	if (!pService) {
		CloseServiceHandle(pSCM);
		return FALSE;
	}
	BOOLEAN ret = DeleteService(pService);
	CloseServiceHandle(pService);
	CloseServiceHandle(pSCM);
	return ret;
}

BOOLEAN ServiceStart(PCWSTR Name) {
	SC_HANDLE pSCM = OpenSCManagerW(NULL, NULL,
		SC_MANAGER_CREATE_SERVICE);
	if (!pSCM)
		return FALSE;

	SC_HANDLE pService = OpenService(pSCM, Name, SERVICE_ALL_ACCESS);
	if (!pService) {
		CloseServiceHandle(pSCM);
		return FALSE;
	}
	BOOLEAN ret = (StartService(pService, 0, NULL) || GetLastError() == 0x287);
	CloseServiceHandle(pService);
	CloseServiceHandle(pSCM);
	return ret;
}
```

`BugCheckHackUser/service.h`:

```h
#pragma once

#include <Windows.h>

BOOLEAN ServiceCreate(PCWSTR Name, PCWSTR Path);
BOOLEAN ServiceDelete(PCWSTR Name);
BOOLEAN ServiceStart(PCWSTR Name);
```

`README.md`:

```md
# BugCheckHack
Modify your BSOD!

# Note

This works on real hardware but I would recommend you to use this under a virtual machine

Make sure you have internet access as this tool downloads pdb files for getting offsets of required functions.

Windows builds from 19041.* to current 22000.556 should work

The service created by the program is Automatic and the driver will load at startup

You can change the service setting by using the `sc` tool

# How to use

1) Enable test signing by running
```
bcdedit /set testsigning on
````
2) Copy over `BugCheckHack.sys` to your Windows folder

3) Launch the program as an administrator

![Program](https://cdn.discordapp.com/attachments/855872050132811796/978613277586243605/unknown.png)

4) Fill in your values and click `Save values`

5) Then create the service and then run service

6) If everything went correctly you should get a message saying "Successfully modified the BSOD"

# Aero BSOD

This option `0xc3s` [ret] out `BgpClearScreen` so whatever was present on the screen will be displayed during the BSOD

# Images

![WeDontKnowwhereyourPCis](https://cdn.discordapp.com/attachments/855872050132811796/978650524045963264/unknown.png)
![OmameBSOD](https://cdn.discordapp.com/attachments/413430340388913171/978623156875055134/unknown.png)
[Cat's owner](https://omame.xyz/)

# Resources used

[Libvalinet](https://github.com/valinet/libvalinet/) for downloading and finding offsets in `ntoskrnl.exe` using the pdb.

[Unknowncheats](https://www.unknowncheats.me/forum/general-programming-and-reversing/427419-getkernelbase.html) for getting the kernel base address in the driver.

[Stackoverflow](https://stackoverflow.com/a/41808496) for figuring out how to make the program look nicer and not something from Windows 3.1.
```