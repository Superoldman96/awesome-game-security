Project Path: arc_gmh5225_PsImageNotifyRoutineSpamFilter_78g70p2b

Source Tree:

```txt
arc_gmh5225_PsImageNotifyRoutineSpamFilter_78g70p2b
├── PsImageNotifyRoutineSpamFilter
│   ├── Main.c
│   ├── Main.h
│   ├── PsImageNotifyRoutineSpamFilter.vcxproj
│   ├── Resources.rc
│   └── resource.h
├── PsImageNotifyRoutineSpamFilter.sln
├── README.md
└── SampleOutput.png

```

`PsImageNotifyRoutineSpamFilter.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.31101.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PsImageNotifyRoutineSpamFilter", "PsImageNotifyRoutineSpamFilter\PsImageNotifyRoutineSpamFilter.vcxproj", "{4A883475-F7A9-47DA-94B8-EC1F992130C4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Win7 Debug|x64 = Win7 Debug|x64
		Win7 Release|x64 = Win7 Release|x64
		Description = PsImageNotifyRoutine Spam Filter
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4A883475-F7A9-47DA-94B8-EC1F992130C4}.Win7 Debug|x64.ActiveCfg = Win7 Debug|x64
		{4A883475-F7A9-47DA-94B8-EC1F992130C4}.Win7 Debug|x64.Build.0 = Win7 Debug|x64
		{4A883475-F7A9-47DA-94B8-EC1F992130C4}.Win7 Debug|x64.Deploy.0 = Win7 Debug|x64
		{4A883475-F7A9-47DA-94B8-EC1F992130C4}.Win7 Release|x64.ActiveCfg = Win7 Release|x64
		{4A883475-F7A9-47DA-94B8-EC1F992130C4}.Win7 Release|x64.Build.0 = Win7 Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`PsImageNotifyRoutineSpamFilter/Main.c`:

```c
/*
	PsImageNotifyRoutine Spam Filter v1.0

	Copyright (c) 2016 Maarten Boone
	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation
	files (the "Software"), to deal in the Software without
	restriction, including without limitation the rights to use,
	copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following
	conditions:
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
*/

#include "Main.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnload)
#pragma alloc_text(PAGE, LoadImageNotify)
#pragma alloc_text(PAGE, IsSourceNtLoader)
#pragma alloc_text(PAGE, IsNtDll32)
#pragma alloc_text(PAGE, IsNtDll64)
#pragma alloc_text(PAGE, GetProcAddress)
#pragma alloc_text(PAGE, PrintRealDllLoad)
#endif

#pragma data_seg("PAGEDATA")
#pragma bss_seg("PAGEBSS")
static BOOLEAN	LoadImageNotifyActive = FALSE;
static ULONG	LdrLoadDllOffset32 =	0;
static ULONG	LdrLoadDllOffset64 =	0;

static UCHAR	LdrLoadDll[] =			{ "LdrLoadDll" };
static UCHAR	DbgPrintText[] =		{ "[%08X] %s LdrLoadDll: %wZ" };
#pragma data_seg()
#pragma bss_seg()

VOID PrintRealDllLoad(HANDLE ProcessId, PUNICODE_STRING module)
{
	DbgPrint((PCHAR)&DbgPrintText, ProcessId, PsGetProcessImageFileName(PsGetCurrentProcess()), module);
}

BOOLEAN IsSourceNtLoader()
{
	__try
	{
		PVOID Trace[2 * MAX_STACK_DEPTH];
		ULONG FramesFound = RtlWalkFrameChain(Trace, FramesToCapture + FramesToSkip, USER_MODE_STACK);

		if (FramesFound <= FramesToSkip)
		{
			if (FramesFound == FramesToSkip)	// Process is initializing, log the first 2 or 3(WoW64) entries.
			{									// 1) Main binary								
				return TRUE;					// 2) Ntdll64
			}									// And optionally in case of WoW64 emulation
			return FALSE;						// 3) Ntdll32
		}										// During initialization RtlWalkFrameChain always returns only 1 frame so no need to verify if it's the Windows PE Loader
												// Because of this the list entry checks in both IsNtDll32 and IsNtDll64 could be removed
		
		for (ULONG i = FramesToSkip; i < FramesToCapture + FramesToSkip; i++)
		{
			if (i >= FramesFound)
				break;
			else if (!Trace[i])
				break;

			ULONG		NtDllBase32;
			ULONG_PTR	NtDllBase64;
			ULONG_PTR	Entry = ((ULONG_PTR)Trace[i]);

			if (IsWoW64Process())
			{
				if (IsNtDll32((ULONG)Entry, &NtDllBase32))
				{
					if (Entry >= (ULONG_PTR) (NtDllBase32 + LdrLoadDllOffset32) &&
						Entry <= (ULONG_PTR)((NtDllBase32 + LdrLoadDllOffset32) + LdrLoadDllSize))
					{
						return TRUE;
					}
				}
				// Could be the WoW64 subsystem loading or malicious DLL's getting injected/loaded
				else if (IsNtDll64(Entry, &NtDllBase64))
				{
					if (Entry >= (ULONG_PTR) (NtDllBase64 + LdrLoadDllOffset64) &&
						Entry <= (ULONG_PTR)((NtDllBase64 + LdrLoadDllOffset64) + LdrLoadDllSize))
					{
						return TRUE;
					}
				}
			}
			else if (IsNtDll64(Entry, &NtDllBase64))
			{
				if (Entry >= (ULONG_PTR) (NtDllBase64 + LdrLoadDllOffset64) &&
					Entry <= (ULONG_PTR)((NtDllBase64 + LdrLoadDllOffset64) + LdrLoadDllSize))
				{
					return TRUE;
				}
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) { }
	return FALSE;
}

VOID LoadImageNotify(PUNICODE_STRING FullImageName,	HANDLE ProcessId, PIMAGE_INFO ImageInfo)
{
	if (!(ImageInfo->SystemModeImage))
		if (IsSourceNtLoader())
			PrintRealDllLoad(ProcessId, FullImageName);
}

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);

	NTSTATUS status;

	DriverObject->DriverUnload = DriverUnload;

	status = PsSetLoadImageNotifyRoutine(LoadImageNotify);
	if (NT_SUCCESS(status))
		LoadImageNotifyActive = TRUE;

	return status;
}

NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);

	NTSTATUS status = STATUS_SUCCESS;

	if (LoadImageNotifyActive)
		PsRemoveLoadImageNotifyRoutine(LoadImageNotify);

	return status;
}

// This function checks if the current stackframe is located inside the Ntdll WoW64 binary
// if that's the case check if the caller was LdrLoadDll
BOOLEAN IsNtDll32(ULONG address, PULONG base)
{
	PPEB_LDR_DATA32			Ldr;
	PLDR_DATA_TABLE_ENTRY32 Entry;
	
	Ldr = ((PPEB_LDR_DATA32)PsGetCurrentProcessWow64Process()->Ldr);

	if (!Ldr)		// This can happen while the WoW64 subsystem is still initializing
		return FALSE;

	Entry = (PLDR_DATA_TABLE_ENTRY32)Ldr->InLoadOrderModuleList.Flink;	// Main exe
	Entry = (PLDR_DATA_TABLE_ENTRY32)Entry->InLoadOrderLinks.Flink;		// Ntdll

	if (((ULONG_PTR)address >= (ULONG_PTR)Entry->DllBase) &&
		((ULONG_PTR)address < ((ULONG_PTR)Entry->DllBase + Entry->SizeOfImage)))
	{
		if (!LdrLoadDllOffset32)
			 LdrLoadDllOffset32 = (ULONG)(GetProcAddress((PVOID)Entry->DllBase, (PCHAR)&LdrLoadDll) - Entry->DllBase);	// Only called once

		*base = Entry->DllBase;
		return TRUE;
	}
	return FALSE;
}

// This function checks if the current stackframe is located inside the Ntdll 64 bits binary
// if that's the case check if the caller was LdrLoadDll
BOOLEAN IsNtDll64(ULONG_PTR address, PULONG_PTR base)
{
	PPEB_LDR_DATA64			Ldr;
	PLDR_DATA_TABLE_ENTRY64 Entry;
	
	Ldr = ((PPEB_LDR_DATA64)PsGetProcessPeb(PsGetCurrentProcess())->Ldr);

	Entry = (PLDR_DATA_TABLE_ENTRY64)Ldr->InLoadOrderModuleList.Flink;	// Main exe
	Entry = (PLDR_DATA_TABLE_ENTRY64)Entry->InLoadOrderLinks.Flink;		// Ntdll

	if (((ULONG_PTR)address >= (ULONG_PTR)Entry->DllBase) &&
		((ULONG_PTR)address < ((ULONG_PTR)Entry->DllBase + Entry->SizeOfImage)))
	{
		if (!LdrLoadDllOffset64)
			 LdrLoadDllOffset64 = (ULONG)(GetProcAddress((PVOID)Entry->DllBase, (PCHAR)&LdrLoadDll) - (ULONG_PTR)Entry->DllBase);	// Only called once

		*base = (ULONG_PTR)Entry->DllBase;
		return TRUE;
	}
	return FALSE;
}

// Just in case you happen to notice the complete lack of ProbeForRead checks, every stack frame address item returned by 
// RtlWalkFrameChain is fully validated and checked if it's safe to access before it will even return the value to the caller.
// 
// So it's pretty safe to asusume no additional checks are needed here.
ULONG_PTR GetProcAddress(PVOID base, PCHAR name)
{
	PIMAGE_DOS_HEADER		dosHeader			= (PIMAGE_DOS_HEADER)base;
	PIMAGE_NT_HEADERS32		ntHeaders32			= NULL;
	PIMAGE_NT_HEADERS64		ntHeaders64			= NULL;
	PIMAGE_EXPORT_DIRECTORY exportDirectory		= NULL;
	ULONG					exportDirectorySize = 0;
	ULONG_PTR				functionAddress		= 0;

	ASSERT(base != NULL);
	if (base == NULL)
		return 0;
		
	__try
	{
		if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
			return 0;

		ntHeaders32 = (PIMAGE_NT_HEADERS32)((PUCHAR)base + dosHeader->e_lfanew);
		ntHeaders64 = (PIMAGE_NT_HEADERS64)((PUCHAR)base + dosHeader->e_lfanew);

		if (ntHeaders32->Signature != IMAGE_NT_SIGNATURE)
			return 0;

		if (ntHeaders64->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		{
			exportDirectory =		(PIMAGE_EXPORT_DIRECTORY)(ntHeaders64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)base);
			exportDirectorySize =	ntHeaders64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
		}
		else
		{
			exportDirectory =		(PIMAGE_EXPORT_DIRECTORY)(ntHeaders32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)base);
			exportDirectorySize =	ntHeaders32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
		}

		PUSHORT AddressOfNameOrdinals = (PUSHORT)(exportDirectory->AddressOfNameOrdinals +	(ULONG_PTR)base);
		PULONG  AddressOfNames =		(PULONG) (exportDirectory->AddressOfNames +			(ULONG_PTR)base);
		PULONG  AddressOfFunctions =	(PULONG) (exportDirectory->AddressOfFunctions +		(ULONG_PTR)base);

		for (ULONG i = 0; i < exportDirectory->NumberOfFunctions; ++i)
		{
			USHORT functionOrdinal =	AddressOfNameOrdinals[i];
			PCHAR  functionName	=		functionName = (PCHAR)(AddressOfNames[i] + (ULONG_PTR)base);
						
			if (strcmp(functionName, name) == 0)
			{
				functionAddress = AddressOfFunctions[functionOrdinal] + (ULONG_PTR)base;
				break;
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) { }
	return functionAddress;
}


```

`PsImageNotifyRoutineSpamFilter/Main.h`:

```h
/*
	PsImageNotifyRoutine Spam Filter v1.0

	Copyright (c) 2016 Maarten Boone
	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation
	files (the "Software"), to deal in the Software without
	restriction, including without limitation the rights to use,
	copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following
	conditions:
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
*/

#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>

#define FramesToSkip		1
#define FramesToCapture		16
#define MAX_STACK_DEPTH		32

#define KERNEL_MODE_STACK	0
#define USER_MODE_STACK		1

#define LdrLoadDllSize		0x400

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32		InLoadOrderLinks;
	LIST_ENTRY32		InMemoryOrderLinks;
	LIST_ENTRY32		InInitializationOrderLinks;
	ULONG				DllBase;
	ULONG				EntryPoint;
	ULONG				SizeOfImage;
	UNICODE_STRING32	FullDllName;
	UNICODE_STRING32	BaseDllName;
	ULONG				Flags;
	USHORT				LoadCount;
	USHORT				TlsIndex;
	LIST_ENTRY32		HashLinks;
	ULONG				TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _LDR_DATA_TABLE_ENTRY64
{
	LIST_ENTRY64		InLoadOrderLinks;
	LIST_ENTRY64		InMemoryOrderLinks;
	LIST_ENTRY64		InInitializationOrderLinks;
	VOID*				DllBase;
	VOID*				EntryPoint;
	ULONG				SizeOfImage;
	UCHAR				_PADDING0_[0x4];
	UNICODE_STRING64	FullDllName;
	UNICODE_STRING64	BaseDllName;
	ULONG				Flags;
	USHORT				LoadCount;
	USHORT				TlsIndex;
	LIST_ENTRY64		HashLinks;
	ULONG32				TimeDateStamp;
}LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64;

typedef struct _PEB_LDR_DATA32
{
	ULONG				Length;
	UCHAR				Initialized;
	UCHAR				_PADDING0_[0x3];
	ULONG				SsHandle;
	LIST_ENTRY32		InLoadOrderModuleList;
	LIST_ENTRY32		InMemoryOrderModuleList;
	LIST_ENTRY32		InInitializationOrderModuleList;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _PEB_LDR_DATA64
{
	ULONG				Length;
	UCHAR				Initialized;
	UCHAR				_PADDING0_[0x3];
	VOID*				SsHandle;
	LIST_ENTRY64		InLoadOrderModuleList;
	LIST_ENTRY64		InMemoryOrderModuleList;
	LIST_ENTRY64		InInitializationOrderModuleList;
}PEB_LDR_DATA64, *PPEB_LDR_DATA64;

typedef struct _PEB32
{
	UCHAR				InheritedAddressSpace;
	UCHAR				ReadImageFileExecOptions;
	UCHAR				BeingDebugged;
	UCHAR				BitField;
	ULONG				Mutant;
	ULONG				ImageBaseAddress;
	ULONG				Ldr;
} PEB32, *PPEB32;

typedef struct _PEB64
{
	UCHAR				InheritedAddressSpace;
	UCHAR				ReadImageFileExecOptions;
	UCHAR				BeingDebugged;
	UCHAR				BitField;
	UCHAR				_PADDING0_[0x4];
	VOID*				Mutant;
	VOID*				ImageBaseAddress;
	PPEB_LDR_DATA64		Ldr;
} PEB64, *PPEB64;

BOOLEAN CFORCEINLINE IsListEmpty32(PLIST_ENTRY32 head) { return (BOOLEAN)((PLIST_ENTRY32)head->Flink == head); }
BOOLEAN CFORCEINLINE IsListEmpty64(PLIST_ENTRY64 head) { return (BOOLEAN)((PLIST_ENTRY64)head->Flink == head); }

ULONG CFORCEINLINE ListItemCount32(PLIST_ENTRY32 head)
{
	PLIST_ENTRY32	next;
	ULONG			i = 0;

	for (next = ((PLIST_ENTRY32)head->Flink); next != head; next = ((PLIST_ENTRY32)next->Flink))
		i++;
	return i;
}

ULONG CFORCEINLINE ListItemCount64(PLIST_ENTRY64 head)
{
	PLIST_ENTRY64	next;
	ULONG			i = 0;

	for (next = ((PLIST_ENTRY64)head->Flink); next != head; next = ((PLIST_ENTRY64)next->Flink))
		i++;
	return i;
}

VOID PrintRealDllLoad(HANDLE ProcessId, PUNICODE_STRING module);

NTKERNELAPI PCHAR  NTAPI PsGetProcessImageFileName	(PEPROCESS process);
NTKERNELAPI PPEB64 NTAPI PsGetProcessPeb			(PEPROCESS process);
NTKERNELAPI PPEB32 NTAPI PsGetProcessWow64Process	(PEPROCESS process);
NTKERNELAPI PPEB32 NTAPI PsGetCurrentProcessWow64Process();

NTSTATUS DriverEntry (PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject);

VOID LoadImageNotify(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo);

BOOLEAN CFORCEINLINE IsWoW64Process() { return PsGetCurrentProcessWow64Process() != NULL; }

BOOLEAN		IsSourceNtLoader();

ULONG_PTR	GetProcAddress(PVOID base,		PCHAR		name);

BOOLEAN		IsNtDll32(ULONG		 address,	PULONG		base);
BOOLEAN		IsNtDll64(ULONG_PTR  address,	PULONG_PTR	base);
```

`PsImageNotifyRoutineSpamFilter/PsImageNotifyRoutineSpamFilter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Win7 Debug|x64">
      <Configuration>Win7 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|x64">
      <Configuration>Win7 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4A883475-F7A9-47DA-94B8-EC1F992130C4}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>
    <Configuration>Win8.1 Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>PsImageNotifyRoutineSpamFilter</RootNamespace>
    <ProjectName>PsImageNotifyRoutineSpamFilter</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer>http://timestamp.globalsign.com/scripts/timstamp.dll</TimeStampServer>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer>http://timestamp.globalsign.com/scripts/timstamp.dll</TimeStampServer>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <ClCompile>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
    <FilesToPackage Include="@(Inf->'%(CopyOutput)')" Condition="'@(Inf)'!=''" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Main.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resources.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PsImageNotifyRoutineSpamFilter/Resources.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Dutch (Netherlands) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NLD)
LANGUAGE LANG_DUTCH, SUBLANG_DUTCH

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x3L
 FILESUBTYPE 0x7L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Maarten Boone"
            VALUE "FileDescription", "PsImageNotifyRoutine Spam Filter"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "PsImageNotifyRoutineSpamFilter.sys"
            VALUE "LegalCopyright", "Copyright (C) 2016 Maarten Boone"
            VALUE "OriginalFilename", "PsImageNotifyRoutineSpamFilter.sys"
            VALUE "ProductName", "PsImageNotifyRoutineSpamFilter"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // Dutch (Netherlands) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`PsImageNotifyRoutineSpamFilter/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resources.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`README.md`:

```md
# PsImageNotifyRoutine Spam Filter v1.0
PsImageNotifyRoutine Spam Filter is a small project that will enable you to filter out garbage or otherwise not interesting events that are send to the PLOAD_IMAGE_NOTIFY_ROUTINE handler.

If you ever used this kernel callback I'm pretty sure you noticed that it generates a lot of useless events caused mainly by the fact that Shell32.dll has the annoying habit to load executable images in memory using the SEC_IMAGE and PAGE_EXECUTE flags even for trivial tasks like extracting icon's or other file information causing a flood of pretty much useless events being send to the LoadImageNotifyRoutine.

By using RtlWalkFrameChain to trace the call stack back into usermode my spam filter will verify if the event was actually triggerd by the Windows PE loader instead of Shell32 or some random other software component effectively leaving you with only the real DLL, Driver or EXE image load events.

The current Visual Studio project only supports 64 bits Windows versions but it's fully compatible with 32 bits applications running on the WoW64 emulation layer.

*Tested only on Windows 7 x64*

*Screenshot showing the nice and clean output after filtering*
![alt tag](https://raw.githubusercontent.com/Staatsgeheim/PsImageNotifyRoutineSpamFilter/master/SampleOutput.png)

```