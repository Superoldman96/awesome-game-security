Project Path: arc_gmh5225_blanket_cd6rrtu5

Source Tree:

```txt
arc_gmh5225_blanket_cd6rrtu5
├── README.md
├── blanket
│   ├── blanket.h
│   ├── blanket.inf
│   ├── blanket.vcxproj
│   ├── blanket.vcxproj.filters
│   ├── includes.h
│   ├── internals.h
│   ├── log.h
│   ├── main.cpp
│   ├── mem.h
│   ├── scan.h
│   └── struct.h
└── blanket.sln

```

`README.md`:

```md
# blanket
Hiding a system thread against conventional means of detection. Designed to work on win 1909

```

`blanket.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30204.135
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "blanket", "blanket\blanket.vcxproj", "{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|ARM.ActiveCfg = Debug|ARM
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|ARM.Build.0 = Debug|ARM
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|ARM.Deploy.0 = Debug|ARM
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|ARM64.Build.0 = Debug|ARM64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|x64.ActiveCfg = Debug|x64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|x64.Build.0 = Debug|x64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|x64.Deploy.0 = Debug|x64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|x86.ActiveCfg = Debug|Win32
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|x86.Build.0 = Debug|Win32
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Debug|x86.Deploy.0 = Debug|Win32
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|ARM.ActiveCfg = Release|ARM
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|ARM.Build.0 = Release|ARM
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|ARM.Deploy.0 = Release|ARM
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|ARM64.ActiveCfg = Release|ARM64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|ARM64.Build.0 = Release|ARM64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|ARM64.Deploy.0 = Release|ARM64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|x64.ActiveCfg = Release|x64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|x64.Build.0 = Release|x64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|x64.Deploy.0 = Release|x64
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|x86.ActiveCfg = Release|Win32
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|x86.Build.0 = Release|Win32
		{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {AE58BE20-88DB-47C4-A555-8FABFF840C5B}
	EndGlobalSection
EndGlobal

```

`blanket/blanket.h`:

```h
#pragma once
#include "log.h"
#include "scan.h"
#include "struct.h"
#include "mem.h"
#include "includes.h"

UCHAR codeCave[] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
UCHAR sExMapHandleToPointer[] = "\x40\x53\x48\x83\xEC\x20\x4C\x8B\xC9\xF7\xC2\xFC\x03\x00\x00\x74";
UCHAR sExDestroyHandle[] = "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x20\x48\x83\x79\x60\x00\x49\x8B\xE8\x48\x8B\xF2\x48";

typedef struct _HANDLE_TABLE* PHANDLE_TABLE;

typedef struct HANDLE_TABLE_ENTRY* PHANDLE_TABLE_ENTRY;

typedef NTKERNELAPI PHANDLE_TABLE_ENTRY(*PEX_MAP_HANDLE_TO_POINTER)(
	__in  PHANDLE_TABLE HandleTable,
	__in  HANDLE Handle
	);

typedef NTKERNELAPI BOOLEAN(*PEX_DESTROY_HANDLE)(
	__inout		PHANDLE_TABLE HandleTable,
	__in		HANDLE Handle,
	__inout_opt PHANDLE_TABLE_ENTRY HandleTableEntry
);

namespace blanket
{
	PEX_MAP_HANDLE_TO_POINTER pExMapHandleToPointer;
	PEX_DESTROY_HANDLE pExDestroyHandle;
	PHANDLE_TABLE PspCidTable;

	NTSTATUS unlinkThread(PMYTHREAD thread)
	{
		PMYPROCESS thisProcess = (PMYPROCESS)PsGetCurrentProcess();
		auto threadId = PsGetThreadId((PETHREAD)thread);

		LIST_ENTRY threadListHead = thisProcess->ThreadListHead;
		for (PLIST_ENTRY list(threadListHead.Flink); list != &threadListHead; list = list->Flink) {
			PMYTHREAD pEntry = CONTAINING_RECORD(list, MYTHREAD, ThreadListEntry);
			QWORD currentThreadId = (QWORD)PsGetThreadId((PETHREAD)pEntry);
			if (currentThreadId == (QWORD)threadId)
			{
				PMYTHREAD pPreviousEntry = CONTAINING_RECORD(list->Blink, MYTHREAD, ThreadListEntry);
				PMYTHREAD pNextEntry = CONTAINING_RECORD(list->Flink, MYTHREAD, ThreadListEntry);
				pPreviousEntry->ThreadListEntry.Flink = list->Flink;
				pNextEntry->ThreadListEntry.Blink = list->Blink;
				return STATUS_SUCCESS;
			}
		}
		return STATUS_UNSUCCESSFUL;
	}

	NTSTATUS changeFlags(PMYTHREAD thread)
	{
		// Not a system thread anymore
		thread->MiscFlags &= ~(1UL << 10);
		// Dont queue APC on me
		thread->MiscFlags &= ~(1UL << 4);

		// Testing
		if (PsIsSystemThread((PETHREAD)thread))
			return STATUS_UNSUCCESSFUL;

		return STATUS_SUCCESS;
	}

	NTSTATUS removePspCidTableHandle(HANDLE handle)
	{
		if (pExMapHandleToPointer == NULL)
			pExMapHandleToPointer = (PEX_MAP_HANDLE_TO_POINTER)scan::signatureScanBySection(
				memory::getKernelBase(), "PAGE", sExMapHandleToPointer, 0, sizeof(sExMapHandleToPointer) - 1
			);

		if (pExMapHandleToPointer == NULL)
		{
			log("Unable to find ExMapHandleToPointer function, exiting...");
			return STATUS_UNSUCCESSFUL;
		}

		if (pExDestroyHandle == NULL)
			pExDestroyHandle = (PEX_DESTROY_HANDLE)scan::signatureScanBySection(
				memory::getKernelBase(), "PAGE", sExDestroyHandle, 0, sizeof(sExDestroyHandle) - 1
			);

		if (pExDestroyHandle == NULL)
		{
			log("Unable to find ExDestroyHandle function, exiting...");
			return STATUS_UNSUCCESSFUL;
		}

		if (PspCidTable == NULL)
			RtlCopyMemory(&PspCidTable, (PVOID)((UINT64)memory::getKernelBase() + 0x572538), 8);  // TODO sigscan this

		// Find handle in PspCidTable
		PHANDLE_TABLE_ENTRY ptr = pExMapHandleToPointer(PspCidTable, handle);
		if (ptr == NULL)
		{
			log("ExMapHandleToPointer returned NULL, exiting...");
			return STATUS_UNSUCCESSFUL;
		}

		// Remove it
		pExDestroyHandle(PspCidTable, handle, ptr);
		return STATUS_SUCCESS;
	}

	NTSTATUS clearPspCidTable(PMYTHREAD thread)
	{
		PETHREAD tempThread = NULL;
		auto threadId = PsGetThreadId((PETHREAD)thread);

		if (!NT_SUCCESS(PsLookupThreadByThreadId(threadId, &tempThread)))
		{
			log("Thread id %u was not found using PsLookupThreadByThreadId", threadId);
			return STATUS_SUCCESS;
		}

		blanket::removePspCidTableHandle(thread->Cid.UniqueThread);

		if (NT_SUCCESS(PsLookupThreadByThreadId(threadId, &tempThread)))
		{
			log("Thread id %u was found using PsLookupThreadByThreadId, exiting...", threadId);
			return STATUS_UNSUCCESSFUL;
		}

		return STATUS_SUCCESS;
	}

	NTSTATUS clearPspCidTable(PMYPROCESS process)
	{
		PEPROCESS tempProcess = NULL;
		auto processId = PsGetProcessId((PEPROCESS)process);

		if (!NT_SUCCESS(PsLookupProcessByProcessId(processId, &tempProcess)))
		{
			log("Process id %u was not found using PsLookupProcessByProcessId", processId);
			return STATUS_SUCCESS;
		}

		blanket::removePspCidTableHandle(processId);

		if (NT_SUCCESS(PsLookupProcessByProcessId(processId, &tempProcess)))
		{
			log("Process id %u was found using PsLookupProcessByProcessId, exiting...", processId);
			return STATUS_UNSUCCESSFUL;
		}

		return STATUS_SUCCESS;
	}

	NTSTATUS setupStartAddress(PVOID routine, PVOID& outCodeCave)
	{
		// movabs rax jmp rax
		BYTE trampoline[] = { 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0, 0xCC};
		memcpy((PVOID)((ULONG_PTR)trampoline + 2), &routine, sizeof(PVOID));

		// Find code cave in ntoskrnl
		PVOID codeCaveStart = scan::signatureScanBySection(
			memory::getKernelBase(), ".text", codeCave, 0, sizeof(codeCave) - 1
		);

		if (codeCaveStart == NULL)
		{
			log("Unable to find code cave in ntoskrnl, exiting...");
			return STATUS_UNSUCCESSFUL;
		}

		// Write a jmp
		if (!NT_SUCCESS(memory::writeToReadOnly(codeCaveStart, &trampoline, sizeof(trampoline))))
		{
			log("Unable to setup a jmp, exiting...");
			return STATUS_UNSUCCESSFUL;
		}

		outCodeCave = codeCaveStart;
		return STATUS_SUCCESS;
	}

	NTSTATUS restoreStartAddress(PVOID codeCaveStart)
	{
		BYTE zeros[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
		if (!NT_SUCCESS(memory::writeToReadOnly(codeCaveStart, &zeros, sizeof(zeros), true)))
		{
			log("Could not restore start address, exiting...");
			return STATUS_UNSUCCESSFUL;
		}
		return STATUS_SUCCESS;
	}

	NTSTATUS hideThread(PMYTHREAD thread)
	{
		// Unlink thread
		if (!NT_SUCCESS(blanket::unlinkThread(thread)))
		{
			log("Could not properly unlink thread, exiting...");
			return STATUS_UNSUCCESSFUL;
		}
		log("Succesfully unlinked thread");	

		// Change flags
		if (!NT_SUCCESS(blanket::changeFlags(thread)))
		{
			log("Could not properly change thread flags, exiting...");
			return STATUS_UNSUCCESSFUL;
		}
		log("Succesfully changed flags");

		// Clear PspCidTable
		if (!NT_SUCCESS(blanket::clearPspCidTable(thread)))
		{
			log("Could not properly clear PspCidTable, exiting...");
			return STATUS_UNSUCCESSFUL;
		}
		log("Succesfully cleared PspCidTable");

		return STATUS_SUCCESS;
	}
}
```

`blanket/blanket.inf`:

```inf
;
; blanket.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=blanket.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
blanket_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
blanket.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%blanket.DeviceDesc%=blanket_Device, Root\blanket ; TODO: edit hw-id

[blanket_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
blanket.sys

;-------------- Service installation
[blanket_Device.NT.Services]
AddService = blanket,%SPSVCINST_ASSOCSERVICE%, blanket_Service_Inst

; -------------- blanket driver install sections
[blanket_Service_Inst]
DisplayName    = %blanket.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\blanket.sys

;
;--- blanket_Device Coinstaller installation ------
;

[blanket_Device.NT.CoInstallers]
AddReg=blanket_Device_CoInstaller_AddReg
CopyFiles=blanket_Device_CoInstaller_CopyFiles

[blanket_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[blanket_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[blanket_Device.NT.Wdf]
KmdfService =  blanket, blanket_wdfsect
[blanket_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "blanket Installation Disk"
blanket.DeviceDesc = "blanket Device"
blanket.SVCDESC = "blanket Service"

```

`blanket/blanket.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E260DB30-9D5B-466A-8BA9-DD400F5CDDA8}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ThreadHider</RootNamespace>
    <ProjectName>blanket</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="blanket.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h" />
    <ClInclude Include="internals.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="mem.h" />
    <ClInclude Include="scan.h" />
    <ClInclude Include="struct.h" />
    <ClInclude Include="blanket.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`blanket/blanket.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="blanket.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="struct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="scan.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="internals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mem.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="blanket.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`blanket/includes.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <ntstrsafe.h>
#include <ntimage.h>

```

`blanket/internals.h`:

```h
#pragma once
#include "struct.h"

EXTERN_C NTSYSAPI
NTSTATUS NTAPI ZwQuerySystemInformation(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
);

EXTERN_C NTSYSAPI
PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(
	PVOID   ModuleAddress
);
```

`blanket/log.h`:

```h
#pragma once
#include "includes.h"

template <typename... Args>
void log(PCCHAR format, Args... args)
{
	DbgPrint(format, args...);
}
```

`blanket/main.cpp`:

```cpp
#include "includes.h"
#include "log.h"
#include "blanket.h"

PVOID gStartAddress = NULL;


void NTAPI main_loop()
{
	auto currentThreadId = PsGetCurrentThreadId();
	auto thisThread = (PMYTHREAD)PsGetCurrentThread();
	LARGE_INTEGER Timeout;
	Timeout.QuadPart = RELATIVE(SECONDS(1));

	// Restore the original address
	blanket::restoreStartAddress(gStartAddress);
	
	// Hide the thread from common API calls
	if (!NT_SUCCESS(blanket::hideThread(thisThread)))
	{
		log("Could not hide properly thread, exiting...");
		return;
	}

	// Main loop. Exiting the loop will result in a BSOD
	while (1)
	{
		log("Thread id %u running", currentThreadId);
		KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
	}
}

EXTERN_C NTSTATUS DriverEntry(
	PDRIVER_OBJECT  driverObject,
	PUNICODE_STRING registryPath
)
{
	UNREFERENCED_PARAMETER(driverObject);
	UNREFERENCED_PARAMETER(registryPath);

	// Find a decent start address for the thread, and write a jmp there
	if (!NT_SUCCESS(blanket::setupStartAddress(main_loop, gStartAddress)))
	{
		log("Failed to find a start address for the thread, exiting...");
		return STATUS_UNSUCCESSFUL;
	}

	// Create the thread at this address, which should be cleared at the beginning of the thread
	HANDLE threadHandle = NULL;
	const auto status = PsCreateSystemThread(&threadHandle, THREAD_ALL_ACCESS, 0, 0, 0, (PKSTART_ROUTINE)gStartAddress, 0);

	if (!NT_SUCCESS(status))
	{
		log("Failed to create thread. Code: %X", status);
		ZwClose(threadHandle);
		return STATUS_UNSUCCESSFUL;
	}

	ZwClose(threadHandle);
	return STATUS_SUCCESS;
}
```

`blanket/mem.h`:

```h
#include "includes.h"

namespace memory
{
	PVOID kernelBase = NULL;

	NTSTATUS writeToReadOnly(PVOID address, PVOID buffer, SIZE_T size, BOOLEAN reset = false)
	{
		auto mdl = IoAllocateMdl(address, (ULONG)size, FALSE, FALSE, NULL);
		if (!mdl)
		{
			log("IoAllocateMdl failed");
			return STATUS_UNSUCCESSFUL;
		}

		MmProbeAndLockPages(mdl, KernelMode, IoReadAccess);
		MmProtectMdlSystemAddress(mdl, PAGE_EXECUTE_READWRITE);

		auto mmMap = MmMapLockedPagesSpecifyCache(mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
		RtlCopyMemory(mmMap, buffer, size);

		if (reset)
		{
			log("Restoring page to READONLY");
			MmProtectMdlSystemAddress(mdl, PAGE_READONLY);
		}

		MmUnmapLockedPages(mmMap, mdl);
		MmUnlockPages(mdl);
		IoFreeMdl(mdl);

		return STATUS_SUCCESS;
	}

	PVOID getSystemModuleBase(PCCHAR module_name)
	{
		ULONG bytes = 0;
		PVOID moduleBase = NULL;
		PRTL_PROCESS_MODULES modules = NULL;

		// First fetch to retrieve the size
		ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
		if (bytes == 0)
			return moduleBase;

		// Allocate the size
		modules = (PRTL_PROCESS_MODULES)ExAllocatePoolZero(NonPagedPool, bytes, 'KEKE');
		if (modules == NULL)
			return moduleBase;

		// Fetch real data
		if (NT_SUCCESS(ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes)))
		{
			// Walk loaded modules
			PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
			for (ULONG i(0); i < modules->NumberOfModules; i++)
			{
				if (strstr((PCHAR)module[i].FullPathName, module_name) != NULL)
				{
					moduleBase = module[i].ImageBase;
					break;
				}
			}
		}

		if (modules)
			ExFreePoolWithTag(modules, 'KEKE');

		return moduleBase;
	}

	PVOID getKernelBase()
	{
		if (kernelBase == NULL)
			return (kernelBase = getSystemModuleBase("ntoskrnl"));
		return kernelBase;
	}
}
```

`blanket/scan.h`:

```h
#pragma once
#include "struct.h"
#include "log.h"
#include "internals.h"
#include "includes.h"

namespace scan
{
	UINT64 scanPattern(PUINT8 base, SIZE_T size, PCUCHAR pattern, PCUCHAR mask, SIZE_T patternSize) {
		for (SIZE_T i(0); i < size - patternSize; i++)
		{
			for (SIZE_T j(0); j < patternSize; j++)
			{
				if ((mask == NULL || mask[j] != '?') && *(PUINT8)(base + i + j) != (UINT8)(pattern[j]))
					break;

				if (j == patternSize - 1)
					return (UINT64)(base)+i;
			}
		}

		return NULL;
	}

	PVOID signatureScanBySection(PVOID baseAddress, PCCHAR sectionName, PCUCHAR pattern, PCUCHAR mask, SIZE_T len)
	{
		ANSI_STRING ansiSectionName, ansiCurrentSectionName;
		RtlInitAnsiString(&ansiSectionName, sectionName);

		if (baseAddress == NULL)
			return NULL;

		PIMAGE_NT_HEADERS64 header = RtlImageNtHeader(baseAddress);
		if (!header)
			return NULL;

		PIMAGE_SECTION_HEADER firstSection = (PIMAGE_SECTION_HEADER)((uintptr_t)&header->FileHeader + header->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER));

		// There can be multiple sections with the same name
		for (PIMAGE_SECTION_HEADER section(firstSection); section < firstSection + header->FileHeader.NumberOfSections; section++)
		{
			RtlInitAnsiString(&ansiCurrentSectionName, (PCCHAR)section->Name);
			if (!RtlCompareString(&ansiSectionName, &ansiCurrentSectionName, TRUE))
			{
				UINT64 result = scanPattern((PUCHAR)baseAddress + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask, len);
				if (result != NULL)
					return (PVOID)result;
			}
		}

		return NULL;
	}
}

```

`blanket/struct.h`:

```h
#pragma once
#include "includes.h"

#define ABSOLUTE(wait) (wait)

#define RELATIVE(wait) (-(wait))

#define NANOSECONDS(nanos) \
(((signed __int64)(nanos)) / 100L)

#define MICROSECONDS(micros) \
(((signed __int64)(micros)) * NANOSECONDS(1000L))

#define MILLISECONDS(milli) \
(((signed __int64)(milli)) * MICROSECONDS(1000L))

#define SECONDS(seconds) \
(((signed __int64)(seconds)) * MILLISECONDS(1000L))

typedef __int32 * PDWORD, * LPDWORD; //32bit
typedef __int64 QWORD; //64 bit
typedef unsigned char BYTE;

struct MYPROCESS
{
	char padding[0x488];
	LIST_ENTRY ThreadListHead;
};

typedef MYPROCESS* PMYPROCESS;

struct MYTHREAD
{
	BYTE p0[0x28];
	PVOID InitialStack;                                                     //0x28
	PVOID volatile StackLimit;                                              //0x30
	PVOID StackBase;                                                        //0x38
	ULONGLONG ThreadLock;                                                   //0x40
	volatile ULONGLONG CycleTime;                                           //0x48
	ULONG CurrentRunTime;                                                   //0x50
	ULONG ExpectedRunTime;                                                  //0x54
	PVOID KernelStack;                                                      //0x58
	BYTE p1[0x14];
    union
    {
        struct Flags
        {
            ULONG AutoBoostActive : 1;                                        //0x74
            ULONG ReadyTransition : 1;                                        //0x74
            ULONG WaitNext : 1;                                               //0x74
            ULONG SystemAffinityActive : 1;                                   //0x74
            ULONG Alertable : 1;                                              //0x74
            ULONG UserStackWalkActive : 1;                                    //0x74
            ULONG ApcInterruptRequest : 1;                                    //0x74
            ULONG QuantumEndMigrate : 1;                                      //0x74
            ULONG UmsDirectedSwitchEnable : 1;                                //0x74
            ULONG TimerActive : 1;                                            //0x74
            ULONG SystemThread : 1;                                           //0x74
            ULONG ProcessDetachActive : 1;                                    //0x74
            ULONG CalloutActive : 1;                                          //0x74
            ULONG ScbReadyQueue : 1;                                          //0x74
            ULONG ApcQueueable : 1;                                           //0x74
            ULONG ReservedStackInUse : 1;                                     //0x74
            ULONG UmsPerformingSyscall : 1;                                   //0x74
            ULONG TimerSuspended : 1;                                         //0x74
            ULONG SuspendedWaitMode : 1;                                      //0x74
            ULONG SuspendSchedulerApcWait : 1;                                //0x74
            ULONG CetUserShadowStack : 1;                                     //0x74
            ULONG BypassProcessFreeze : 1;                                    //0x74
            ULONG Reserved : 10;                                              //0x74
        };
        LONG MiscFlags;                                                     //0x74
    };
	BYTE p2[0x5D0];
	_CLIENT_ID Cid;															//0x648
	BYTE p3[0x48];
	PVOID Win32StartAddress;                                                //0x6a0
	BYTE p4[0x10];
	LIST_ENTRY ThreadListEntry;
};

typedef MYTHREAD* PMYTHREAD;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;
```