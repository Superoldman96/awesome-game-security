Project Path: arc_gmh5225_KnownDllUnhook_qlpylbfe

Source Tree:

```txt
arc_gmh5225_KnownDllUnhook_qlpylbfe
├── KnownDllUnhook
│   ├── Helper.c
│   ├── Helper.h
│   ├── KnownDllUnhook.vcxproj
│   ├── KnownDllUnhook.vcxproj.filters
│   ├── KnownDllUnhook.vcxproj.user
│   ├── Structs.h
│   ├── Syscalls.h
│   ├── Syscalls.lib
│   └── main.c
├── KnownDllUnhook.sln
├── LICENSE
├── README.md
└── image.png

```

`KnownDllUnhook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32421.90
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KnownDllUnhook", "KnownDllUnhook\KnownDllUnhook.vcxproj", "{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}.Debug|x64.ActiveCfg = Debug|x64
		{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}.Debug|x64.Build.0 = Debug|x64
		{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}.Debug|x86.ActiveCfg = Debug|Win32
		{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}.Debug|x86.Build.0 = Debug|Win32
		{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}.Release|x64.ActiveCfg = Release|x64
		{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}.Release|x64.Build.0 = Release|x64
		{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}.Release|x86.ActiveCfg = Release|Win32
		{BE14DA39-3E40-444F-AE7D-D56F9CD76DFD}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {582C3C5B-9817-41E3-8183-72A5FBF1A108}
	EndGlobalSection
EndGlobal

```

`KnownDllUnhook/Helper.c`:

```c
#include <Windows.h>

#include "Structs.h"





//-----------------------------------------------------------------------------------------------------------------------------------------------------------------//

PVOID _memcpy(PVOID Destination, CONST PVOID Source, SIZE_T Length)
{
	PBYTE D = (PBYTE)Destination;
	PBYTE S = (PBYTE)Source;

	while (Length--)
		*D++ = *S++;

	return Destination;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------//

void _RtlInitUnicodeString(PUNICODE_STRING target, PCWSTR source)
{
	if ((target->Buffer = (PWSTR)source))
	{
		unsigned int length = wcslen(source) * sizeof(WCHAR);
		if (length > 0xfffc)
			length = 0xfffc;

		target->Length = length;
		target->MaximumLength = target->Length + sizeof(WCHAR);
	}
	else target->Length = target->MaximumLength = 0;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------//

wchar_t* _strcpy(wchar_t* dest, const wchar_t* src)
{
	wchar_t* p;

	if ((dest == NULL) || (src == NULL))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while (*src != 0) {
		*p = *src;
		p++;
		src++;
	}

	*p = 0;
	return dest;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------//

wchar_t* _strcat(wchar_t* dest, const wchar_t* src)
{
	if ((dest == NULL) || (src == NULL))
		return dest;

	while (*dest != 0)
		dest++;

	while (*src != 0) {
		*dest = *src;
		dest++;
		src++;
	}

	*dest = 0;
	return dest;
}
```

`KnownDllUnhook/Helper.h`:

```h
#pragma once

#include <Windows.h>


#define PRINT( STR, ... )                                                                   \
    if (1) {                                                                                \
        LPWSTR buf = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );         \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfW( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  



#define NtAllocateVirtualMemory_StrHashed       0x014044AE
#define NtProtectVirtualMemory_StrHashed        0xE67C7320
#define NtCreateSection_StrHashed               0xAC2EDA02
#define NtOpenSection_StrHashed                 0xD443EC8C
#define NtMapViewOfSection_StrHashed            0x92DD00B3
#define NtUnmapViewOfSection_StrHashed          0x12D71086
#define NtClose_StrHashed                       0x7B3F64A4




PVOID _memcpy(PVOID Destination, CONST PVOID Source, SIZE_T Length);

void _RtlInitUnicodeString(PUNICODE_STRING target, PCWSTR source);

wchar_t* _strcpy(wchar_t* dest, const wchar_t* src);

wchar_t* _strcat(wchar_t* dest, const wchar_t* src);




```

`KnownDllUnhook/KnownDllUnhook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{be14da39-3e40-444f-ae7d-d56f9cd76dfd}</ProjectGuid>
    <RootNamespace>KnownDllUnhook</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>
      </RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <ControlFlowGuard>
      </ControlFlowGuard>
      <ProgramDataBaseFileName />
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>Syscalls.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>
      </RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <Optimization>Disabled</Optimization>
      <ControlFlowGuard>
      </ControlFlowGuard>
      <ProgramDataBaseFileName />
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>Syscalls.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Helper.c" />
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Helper.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="Syscalls.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`KnownDllUnhook/KnownDllUnhook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Helper.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Syscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Helper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KnownDllUnhook/KnownDllUnhook.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`KnownDllUnhook/Structs.h`:

```h
#pragma once



#ifndef _STRUCTS_
#define _STRUCTS_


#include <Windows.h>




#define NtCurrentThread()  ((HANDLE)(LONG_PTR)-2)
#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)


#define InitializeObjectAttributes( p, n, a, r, s ) {   \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }


typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;

} UNICODE_STRING, * PUNICODE_STRING;



typedef PVOID PACTIVATION_CONTEXT;



typedef struct _OBJECT_ATTRIBUTES {
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;



#define OBJ_INHERIT                         0x00000002L
#define OBJ_PERMANENT                       0x00000010L
#define OBJ_EXCLUSIVE                       0x00000020L
#define OBJ_CASE_INSENSITIVE                0x00000040L
#define OBJ_OPENIF                          0x00000080L
#define OBJ_OPENLINK                        0x00000100L
#define OBJ_KERNEL_HANDLE                   0x00000200L
#define OBJ_FORCE_ACCESS_CHECK              0x00000400L
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP   0x00000800L
#define OBJ_DONT_REPARSE                    0x00001000L
#define OBJ_VALID_ATTRIBUTES                0x00001FF2L



typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;



typedef struct _PEB_LDR_DATA {
    ULONG                   Length;
    ULONG                   Initialized;
    PVOID                   SsHandle;
    LIST_ENTRY              InLoadOrderModuleList;
    LIST_ENTRY              InMemoryOrderModuleList;
    LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;


typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    WORD LoadCount;
    WORD TlsIndex;
    union {
        LIST_ENTRY HashLinks;
        struct {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    union {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    };
    PACTIVATION_CONTEXT EntryPointActivationContext;
    PVOID PatchInformation;
    LIST_ENTRY ForwarderLinks;
    LIST_ENTRY ServiceTagLinks;
    LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB
{
    UCHAR InheritedAddressSpace;                                            
    UCHAR ReadImageFileExecOptions;                                         
    UCHAR BeingDebugged;                                                   
    union
    {
        UCHAR BitField;                                                    
        struct
        {
            UCHAR ImageUsesLargePages : 1;                                    
            UCHAR IsProtectedProcess : 1;                                     
            UCHAR IsImageDynamicallyRelocated : 1;                            
            UCHAR SkipPatchingUser32Forwarders : 1;                           
            UCHAR IsPackagedProcess : 1;                                      
            UCHAR IsAppContainer : 1;                                         
            UCHAR IsProtectedProcessLight : 1;                                
            UCHAR IsLongPathAwareProcess : 1;                                
        };
    };
    UCHAR Padding0[4];                                                     
    VOID* Mutant;                                                           
    VOID* ImageBaseAddress;                                                
    struct _PEB_LDR_DATA* Ldr;                                             
    struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                 
    VOID* SubSystemData;                                                    
    VOID* ProcessHeap;                                                      
    struct _RTL_CRITICAL_SECTION* FastPebLock;                              
    union _SLIST_HEADER* volatile AtlThunkSListPtr;                         
    VOID* IFEOKey;                                                          
    union
    {
        ULONG CrossProcessFlags;                                            
        struct
        {
            ULONG ProcessInJob : 1;                                           
            ULONG ProcessInitializing : 1;                                    
            ULONG ProcessUsingVEH : 1;                                        
            ULONG ProcessUsingVCH : 1;                                        
            ULONG ProcessUsingFTH : 1;                                        
            ULONG ProcessPreviouslyThrottled : 1;                             
            ULONG ProcessCurrentlyThrottled : 1;                              
            ULONG ProcessImagesHotPatched : 1;                               
            ULONG ReservedBits0 : 24;                                         
        };
    };
    UCHAR Padding1[4];                                                      
    union
    {
        VOID* KernelCallbackTable;                                         
        VOID* UserSharedInfoPtr;                                            
    };
    ULONG SystemReserved;                                                  
    ULONG AtlThunkSListPtr32;                                              
    VOID* ApiSetMap;                                                        
    ULONG TlsExpansionCounter;                                             
    UCHAR Padding2[4];                                                      
    VOID* TlsBitmap;                                                       
    ULONG TlsBitmapBits[2];                                                 
    VOID* ReadOnlySharedMemoryBase;                                         
    VOID* SharedData;                                                       
    VOID** ReadOnlyStaticServerData;                                        
    VOID* AnsiCodePageData;                                                
    VOID* OemCodePageData;                                                 
    VOID* UnicodeCaseTableData;                                             
    ULONG NumberOfProcessors;                                               
    ULONG NtGlobalFlag;                                                     
    union _LARGE_INTEGER CriticalSectionTimeout;                            
    ULONGLONG HeapSegmentReserve;                                           
    ULONGLONG HeapSegmentCommit;                                          
    ULONGLONG HeapDeCommitTotalFreeThreshold;                              
    ULONGLONG HeapDeCommitFreeBlockThreshold;                               
    ULONG NumberOfHeaps;                                                   
    ULONG MaximumNumberOfHeaps;                                             
    VOID** ProcessHeaps;                                                    
    VOID* GdiSharedHandleTable;                                             
    VOID* ProcessStarterHelper;                                             
    ULONG GdiDCAttributeList;                                               
    UCHAR Padding3[4];                                                      
    struct _RTL_CRITICAL_SECTION* LoaderLock;                               
    ULONG OSMajorVersion;                                                  
    ULONG OSMinorVersion;                                                   
    USHORT OSBuildNumber;                                                   
    USHORT OSCSDVersion;                                                   
    ULONG OSPlatformId;                                                    
    ULONG ImageSubsystem;                                                  
    ULONG ImageSubsystemMajorVersion;                                      
    ULONG ImageSubsystemMinorVersion;                                       
    UCHAR Padding4[4];                                                      
    ULONGLONG ActiveProcessAffinityMask;                                   
    ULONG GdiHandleBuffer[60];                                              
    VOID(*PostProcessInitRoutine)();                                      
    VOID* TlsExpansionBitmap;                                              
    ULONG TlsExpansionBitmapBits[32];                                       
    ULONG SessionId;                                                        
    UCHAR Padding5[4];                                                     
    union _ULARGE_INTEGER AppCompatFlags;                                   
    union _ULARGE_INTEGER AppCompatFlagsUser;                              
    VOID* pShimData;                                                       
    VOID* AppCompatInfo;                                                   
    struct _UNICODE_STRING CSDVersion;                                      
    struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;                 
    struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;                
    struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;   
    struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;                
    ULONGLONG MinimumStackCommit;                                           
    struct _FLS_CALLBACK_INFO* FlsCallback;                               
    struct _LIST_ENTRY FlsListHead;                                         
    VOID* FlsBitmap;                                                        
    ULONG FlsBitmapBits[4];                                                 
    ULONG FlsHighIndex;                                                     
    VOID* WerRegistrationData;                                             
    VOID* WerShipAssertPtr;                                                 
    VOID* pUnused;                                                         
    VOID* pImageHeaderHash;                                                 
    union
    {
        ULONG TracingFlags;                                                 
        struct
        {
            ULONG HeapTracingEnabled : 1;                                     
            ULONG CritSecTracingEnabled : 1;                                  
            ULONG LibLoaderTracingEnabled : 1;                                
            ULONG SpareTracingBits : 29;                                      
        };
    };
    UCHAR Padding6[4];                                                     
    ULONGLONG CsrServerReadOnlySharedMemoryBase;                           
    ULONGLONG TppWorkerpListLock;                                          
    struct _LIST_ENTRY TppWorkerpList;                                      
    VOID* WaitOnAddressHashTable[128];                                      
    VOID* TelemetryCoverageHeader;                                          
    ULONG CloudFileFlags;                                                   
    ULONG CloudFileDiagFlags;                                              
    CHAR PlaceholderCompatibilityMode;                                      
    CHAR PlaceholderCompatibilityModeReserved[7];                           
    struct _LEAP_SECOND_DATA* LeapSecondData;                              
    union
    {
        ULONG LeapSecondFlags;                                             
        struct
        {
            ULONG SixtySecondEnabled : 1;                                     
            ULONG Reserved : 31;                                             
        };
    };
    ULONG NtGlobalFlag2;                                                    
} PEB, * PPEB;



#endif // !_STRUCTS_

```

`KnownDllUnhook/Syscalls.h`:

```h
#pragma once


#define EXTERN extern

#ifndef _SYSCALLS_H
#define _SYSCALLS_H

#include <Windows.h>



typedef struct _HashStruct {
	DWORD NtAllocateVirtualMemory_Hash;
	DWORD NtProtectVirtualMemory_Hash;

	DWORD NtCreateSection_Hash;
	DWORD NtOpenSection_Hash;
	DWORD NtMapViewOfSection_Hash;
	DWORD NtUnmapViewOfSection_Hash;

	DWORD NtClose_Hash;

}HashStruct, * PHashStruct;



EXTERN BOOL
InitializeStruct(
	IN			INT			Seed,									// INPUT : Seed Of The Rotr32 Hashing algo
	IN			PHashStruct PStruct									// INPUT : pointer to a struct of type 'HashStruct' that will initialize the data 
);

EXTERN PVOID
NtAllocateVirtualMemory(
	IN  OPTIONAL  HANDLE	ProcessHandle,							// INPUT  : in case of null, the function will run localy
	IN  OPTIONAL  PVOID		BaseAddress,							// INPUT  : NULL by default  
	IN			  SIZE_T	RegionSize,								// INPUT  : can't be NULL
	IN  OPTIONAL  ULONG		AllocationType,							// INPUT  : MEM_COMMIT | MEM_RESERVE by default
	IN  OPTIONAL  ULONG		Protect,								// INPUT  : PAGE_READWRITE by default
	OUT OPTIONAL  PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

// calling the default NtAllocateVirtualMemory | u can do such thing to the others ...
EXTERN PVOID
NtAllocateVirtualMemory2(
	IN			  SIZE_T	RegionSize,								// INPUT  : can't be NULL
	OUT OPTIONAL  PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

EXTERN ULONG
NtProtectVirtualMemory(
	IN  OPTIONAL HANDLE		ProcessHandle,							// INPUT  : in case of null, the function will run localy
	IN			 PVOID		BaseAddress,							// INPUT  : can't be NULL
	IN			 SIZE_T		NumberOfBytesToProtect,					// INPUT  : can't be NULL
	IN			 ULONG		NewAccessProtection,					// INPUT  : can't be NULL
	OUT OPTIONAL PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

EXTERN HANDLE
NtCreateSection(
	IN	OPTIONAL	ACCESS_MASK			DesiredAccess,				// INPUT  : SECTION_ALL_ACCESS by default
	IN	OPTIONAL	POBJECT_ATTRIBUTES	ObjectAttributes,			// INPUT  : NULL by default
	IN				SIZE_T				NumberOfBytes,				// INPUT  : can't be NULL
	IN	OPTIONAL	ULONG               SectionPageProtection,		// INPUT  : PAGE_READWRITE be default
	IN	OPTIONAL	ULONG               AllocationAttributes,		// INPUT  : SEC_COMMIT by default
	IN	OPTIONAL	HANDLE              FileHandle,					// INPUT  : NULL by default
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall

);



EXTERN HANDLE
NtOpenSection(
	IN	OPTIONAL	ACCESS_MASK			DesiredAccess,				// INPUT  : SECTION_ALL_ACCESS by default
	IN				POBJECT_ATTRIBUTES  ObjectAttributes,			// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);

EXTERN PVOID
NtMapViewOfSection(
	IN				HANDLE              SectionHandle,				// INPUT  : can't be NULL
	IN  OPTIONAL	HANDLE              ProcessHandle,				// INPUT  : in case of null, the function will run localy
	IN  OPTIONAL	PVOID				BaseAddress,				// INPUT  : NULL by default
	IN  OPTIONAL	ULONG               AllocationType,				// INPUT  : NULL by default
	IN  OPTIONAL	ULONG               Protect,					// INPUT  : PAGE_READWRITE by default
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall

);


EXTERN VOID
NtUnmapViewOfSection(
	IN  OPTIONAL	HANDLE              ProcessHandle,				// INPUT  : in case of null, the function will run localy
	IN  			PVOID				BaseAddress,				// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);



EXTERN VOID
NtClose(															
	IN				HANDLE              SectionHandle,				// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);




















#endif // !_SYSCALLS_H

```

`KnownDllUnhook/main.c`:

```c
/*
	ORCA   9/24/2022
	- Program That Irretate Through All The Loaded Dlls
	- Check If Found In \KnownDlls\ Dir
	- Replace it's .txt Section 
*/

#include <Windows.h>

#include "Structs.h"
#include "Helper.h"
#include "Syscalls.h"
#pragma comment (lib, "Syscalls.lib")

#pragma comment(linker,"/ENTRY:main")



//-----------------------------------------------------------------------------------------------------------------------------------------------------------------//

LPVOID GetDllFromKnownDll(PWSTR DllName){
	
	PVOID pModule = NULL;
	HANDLE hSection = INVALID_HANDLE_VALUE;
	UNICODE_STRING UniStr;
	OBJECT_ATTRIBUTES ObjAtr;
	NTSTATUS STATUS;

	WCHAR FullName[MAX_PATH];
	WCHAR Buf[MAX_PATH] = { L'\\', L'K', L'n', L'o', L'w', L'n', L'D', L'l', L'l', L's', L'\\' };

	_strcpy(FullName, Buf);
	_strcat(FullName, DllName);
	_RtlInitUnicodeString(&UniStr, FullName);

	InitializeObjectAttributes(
		&ObjAtr,
		&UniStr,
		0x40L,
		NULL,
		NULL
	);


	hSection = NtOpenSection(SECTION_MAP_READ | SECTION_MAP_EXECUTE, &ObjAtr, &STATUS);
	if (!NT_SUCCESS(STATUS) || hSection == INVALID_HANDLE_VALUE) {
		PRINT(L"\t[!] %s : NtOpenSection Failed : 0x%0.8X [THAT'S PROB OK]\n", FullName, STATUS);
		return NULL;
	}


	pModule = NtMapViewOfSection(hSection, NULL, NULL, NULL, PAGE_READONLY, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
		PRINT(L"\t[!] %s : NtMapViewOfSection Failed : 0x%0.8X (main.c:52)\n", FullName, STATUS);
		return NULL;
	}


	return pModule;
}



BOOL RefreshAllDlls() {

#if _WIN64								
	PPEB pPeb = (PPEB)__readgsqword(0x60);
#elif _WIN32							
	PPEB pPeb = (PPEB)(__readfsdword(0x30));
#else									
	PPEB pPeb = NULL;
#endif

	if (pPeb == NULL || (pPeb != NULL && pPeb->OSMajorVersion != 0xA)) {
		return FALSE;
	}
	
	PLIST_ENTRY Head = NULL, Next = NULL;

	NTSTATUS	STATUS				= NULL;
	LPVOID		KnownDllDllModule	= NULL, CurrentDllModule = NULL;
	PVOID		pLocalTxtAddress	= NULL, pRemoteTxtAddress = NULL;
	SIZE_T		sLocalTxtSize		= NULL;
	DWORD		dwOldPermission		= NULL;
	

	Head = &pPeb->Ldr->InMemoryOrderModuleList;
	Next = Head->Flink;

	// loop through all dlls:
	while (Next != Head) {

		// getting the dll name:
		PLDR_DATA_TABLE_ENTRY	pLdrData	= (PLDR_DATA_TABLE_ENTRY)((PBYTE)Next - offsetof(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks));
		PUNICODE_STRING			DllName		= (PUNICODE_STRING)((PBYTE)&pLdrData->FullDllName + sizeof(UNICODE_STRING));

		// getting it's pointer from \KnownDlls\ in case it returned null, that's ok, cz the dll may not be in KnownDlls after all ...
		KnownDllDllModule = GetDllFromKnownDll(DllName->Buffer);
		CurrentDllModule =  (LPVOID)(pLdrData->DllBase);

		// if we had the dll mapped with a valid address from KnownDlls:
		if (KnownDllDllModule != NULL && CurrentDllModule != NULL) {
			// get the dos & nt headers of our local dll 
			PIMAGE_DOS_HEADER CurrentDllImgDosHdr = (PIMAGE_DOS_HEADER)CurrentDllModule;
			if (CurrentDllImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
				return FALSE;
			}
			PIMAGE_NT_HEADERS CurrentDllImgNtHdr = (PIMAGE_NT_HEADERS)((PBYTE)CurrentDllModule + CurrentDllImgDosHdr->e_lfanew);
			if (CurrentDllImgNtHdr->Signature != IMAGE_NT_SIGNATURE) {
				return FALSE;
			}
			// get the address of the module's txt section & its size & calculate the knowndll txt section address 
			for (int i = 0; i < CurrentDllImgNtHdr->FileHeader.NumberOfSections; i++) {
				PIMAGE_SECTION_HEADER pImgSec = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(CurrentDllImgNtHdr) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
				if ((*(ULONG*)pImgSec->Name | 0x20202020) == 'xet.') {
					sLocalTxtSize		= pImgSec->Misc.VirtualSize;
					pLocalTxtAddress	= (PVOID)((ULONG_PTR)CurrentDllModule + pImgSec->VirtualAddress);
					pRemoteTxtAddress	= (PVOID)((ULONG_PTR)KnownDllDllModule + pImgSec->VirtualAddress);
				}
			}
			// small check here ...
			if (sLocalTxtSize == NULL || pLocalTxtAddress == NULL || pRemoteTxtAddress == NULL){
				return FALSE;
			}

			// change mmeory permissions to start patching
			dwOldPermission = NtProtectVirtualMemory(NtCurrentProcess(), pLocalTxtAddress, sLocalTxtSize, PAGE_EXECUTE_WRITECOPY, &STATUS);
			if (!NT_SUCCESS(STATUS)) {
				PRINT(L"\t[!] NtProtectVirtualMemory [1] Failed : 0x%0.8X (main.c:127)\n", STATUS);
				return FALSE;
			}


			PRINT(L"\t[i] Replacing .txt of %s ... ", DllName->Buffer);
			// do the replacement of the .text section
			_memcpy(pLocalTxtAddress, pRemoteTxtAddress, sLocalTxtSize);
			PRINT(L"[+] DONE \n");

			
			// re-fix the memory permissions to what it was
			NtProtectVirtualMemory(NtCurrentProcess(), pLocalTxtAddress, sLocalTxtSize, dwOldPermission, &STATUS);
			if (!NT_SUCCESS(STATUS)) {
				PRINT(L"\t[!] NtProtectVirtualMemory [2] Failed : 0x%0.8X (main.c:141)\n", STATUS);
				return FALSE;
			}

			// unmap the KnownDlls dll 
			NtUnmapViewOfSection(NtCurrentProcess(), KnownDllDllModule, &STATUS);
			if (!NT_SUCCESS(STATUS)) {
				PRINT(L"\t[!] NtUnmapViewOfSection  Failed : 0x%0.8X (main.c:148)\n", STATUS);
				return FALSE;
			}

		}

		// continue to the next dll ...
		Next = Next->Flink;

	}


	return TRUE;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------//


BOOL CheckIfSyscallIsHooked(ULONG_PTR SyscallAddress) {
	if (*(ULONG*)SyscallAddress != 0xb8d18b4c) {
		return TRUE;
	}
	return FALSE;
}


VOID PrintState(const wchar_t* Syscall, PVOID pSyscall) {
	PRINT(L"[#] %s [ 0x%p ] ---> %s \n", Syscall, pSyscall, CheckIfSyscallIsHooked(pSyscall) == TRUE ? L"[ HOOKED ]" : L"[ UNHOOKED ]");
}



#ifdef WAIT
BOOL Exit = FALSE;

VOID WINAPI ExitFunc(DWORD id){
	Exit = TRUE;
	return;
}
#endif

int main() {

	// getting the syscalls needed to do the job | ( Syscallslib repo )
	HashStruct SyscallHashStruct = {

	.NtAllocateVirtualMemory_Hash = NtAllocateVirtualMemory_StrHashed,
	.NtProtectVirtualMemory_Hash = NtProtectVirtualMemory_StrHashed,
	.NtCreateSection_Hash = NtCreateSection_StrHashed,
	.NtOpenSection_Hash = NtOpenSection_StrHashed,
	.NtMapViewOfSection_Hash = NtMapViewOfSection_StrHashed,
	.NtUnmapViewOfSection_Hash = NtUnmapViewOfSection_StrHashed,
	.NtClose_Hash = NtClose_StrHashed,

	};


	if (!InitializeStruct(0x07, &SyscallHashStruct)) {
		PRINT(L"[!] Failed To Fill Up The Direct Syscalls Hash Struct (main:207) \n");
		return -1;
	}




	PVOID pNtAllocateVirtualMemory = GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), "NtAllocateVirtualMemory");

	PVOID pNtCreateThreadEx = GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), "NtCreateThreadEx");

	PVOID pNtProtectVirtualMemory = GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), "NtProtectVirtualMemory");

	PVOID pNtMapViewOfSection = GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), "NtMapViewOfSection");



	PrintState(L"NtAllocateVirtualMemory", pNtAllocateVirtualMemory);
	
	PrintState(L"NtCreateThreadEx", pNtCreateThreadEx);

	PrintState(L"NtProtectVirtualMemory", pNtProtectVirtualMemory);

	PrintState(L"NtMapViewOfSection", pNtMapViewOfSection);
	


	if (!RefreshAllDlls()) {
		PRINT(L"[!] Failed To Refresh Loaded Dlls (main.c:235) \n");
		return -1;
	}



	PrintState(L"NtAllocateVirtualMemory", pNtAllocateVirtualMemory);

	PrintState(L"NtCreateThreadEx", pNtCreateThreadEx);

	PrintState(L"NtProtectVirtualMemory", pNtProtectVirtualMemory);

	PrintState(L"NtMapViewOfSection", pNtMapViewOfSection);

	

#ifdef WAIT
	// i mean in case u wanted to do some debugging ? :)
	PRINT(L"[i] Hit <Ctrl-C> To Quit ... \n");
	SetConsoleCtrlHandler(ExitFunc, TRUE);
	while (!Exit) {
		Sleep(500);
	}
#endif // WAIT

	

	return 0;
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2022 ORCA

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
### KnownDllUnhook: Replace the .txt section of the current loaded modules from \KnownDlls\ to do api unhooking


### How Does it Work:
  - first, it loops through the loaded dlls
  - check if the name of the loaded dll is found in \KnownDlls\ dir
  - if found, the dll will be mapped to the current process
  - then, some calculations happen ( to get the address of the .txt section of the current dll & it's size )
  - change the memory permissions on current dll's .txt to 'PAGE_EXECUTE_WRITECOPY'
  - replace the .txt section from our \KnownDlls\ dll
  - fix the memory protection back to what it was
  - unmap the \KnownDlls\ dll since it is no longer needed
  - continue the loop until all the current dlls are checked 
  - all the intial syscalls ( the ones that do the unhooking ) are from [Syscallslib](https://github.com/ORCx41/Syscallslib) 



### Demo:
![image](https://user-images.githubusercontent.com/111295429/192431761-df759634-28be-4cf2-85ab-f8633ba45ff4.png)




<br>

### Note that this idea isnt mine, its my implementation only ...
### Based On:
  - https://github.com/rad9800/WTSRM
  
  
 
  

```