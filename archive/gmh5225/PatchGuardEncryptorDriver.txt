Project Path: arc_gmh5225_PatchGuardEncryptorDriver_fmbzq2a0

Source Tree:

```txt
arc_gmh5225_PatchGuardEncryptorDriver_fmbzq2a0
├── PatchGuardEncryptorDriver
│   ├── Helper.h
│   ├── IntegrityChecker.cpp
│   ├── IntegrityChecker.h
│   ├── MSRs.h
│   ├── PatchGuardEncryptorDriver.cpp
│   ├── PatchGuardEncryptorDriver.inf
│   ├── PatchGuardEncryptorDriver.vcxproj
│   └── PatchGuardEncryptorDriver.vcxproj.filters
├── PatchGuardEncryptorDriver.sln
└── README.md

```

`PatchGuardEncryptorDriver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35728.132 d17.12
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PatchGuardEncryptorDriver", "PatchGuardEncryptorDriver\PatchGuardEncryptorDriver.vcxproj", "{DBA3F6EF-9864-423F-A432-96B254CAEB06}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Debug|ARM64.Build.0 = Debug|ARM64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Debug|x64.ActiveCfg = Debug|x64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Debug|x64.Build.0 = Debug|x64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Debug|x64.Deploy.0 = Debug|x64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Release|ARM64.ActiveCfg = Release|ARM64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Release|ARM64.Build.0 = Release|ARM64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Release|ARM64.Deploy.0 = Release|ARM64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Release|x64.ActiveCfg = Release|x64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Release|x64.Build.0 = Release|x64
		{DBA3F6EF-9864-423F-A432-96B254CAEB06}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`PatchGuardEncryptorDriver/Helper.h`:

```h
#pragma once
#include <ntddk.h>

#define SystemProcessInformationSize 1024 * 1024 * 2
#define BYTE CHAR 
#define DWORD ULONG

//0x10 bytes (sizeof)
union _KIDTENTRY64
{
	struct
	{
		USHORT OffsetLow;                                                   //0x0
		USHORT Selector;                                                    //0x2
	};
	USHORT IstIndex : 3;                                                    //0x4
	USHORT Reserved0 : 5;                                                   //0x4
	USHORT Type : 5;                                                        //0x4
	USHORT Dpl : 2;                                                         //0x4
	struct
	{
		USHORT Present : 1;                                                 //0x4
		USHORT OffsetMiddle;                                                //0x6
	};
	struct
	{
		ULONG OffsetHigh;                                                   //0x8
		ULONG Reserved1;                                                    //0xc
	};
	ULONGLONG Alignment;                                                    //0x0
};

typedef struct _IDT_ENTRY
{
	DWORD32 Vector;			// The vector number of the relative interrupt in the IDT
	PVOID ServiceRoutine;	// The kernel address of the service routine
} IDT_ENTRY, * PIDT_ENTRY;

typedef struct _MSR_ENTRY
{
	DWORD32 MSRIndex;		// The MSR Index (i.e 0xC0000082)
	ULONG_PTR MSRValue;		// The inital value within the relative MSR register
} MSR_ENTRY, * PMSR_ENTRY;

typedef struct _SSDT_ENTRY
{
	DWORD32 SyscallNumber;	// Will serve as the index in the SSDT
	DWORD32 SSDTValue;		// The SSDT value in the relative SCN
} SSDT_ENTRY, * PSSDT_ENTRY;

typedef struct _KERNEL_INFO
{
	PVOID KernelBaseAddress;
	SIZE_T Size;
} KERNEL_INFO, * PKERNEL_INFO;

// The _TIMER_INFO structure will hold the address of the _KTIMER object and it's relative pointer to _KDPC
// This will be declared as a global variable, and will be initialized in the DriverEntry()
// This structure will be mainly used in the IntegrityChecker 
typedef struct _TIMER_INFO
{
	PKTIMER Timer;				// Holds the pointer to the _KTIMER object
	PKDPC Dpc;					// Holds the relevant pointer to the _KDPC object associated with the timer
	PVOID DeferredRoutine;		// Holds the relevant function pointer of the Deferred Routine initialized with the DPC
} TIMER_INFO, * PTIMER_INFO;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0,
	SystemProcessorInformation = 1,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemPathInformation = 4,
	SystemProcessInformation = 5,
	SystemCallCountInformation = 6,
	SystemDeviceInformation = 7,
	SystemProcessorPerformanceInformation = 8,
	SystemFlagsInformation = 9,
	SystemCallTimeInformation = 10,
	SystemModuleInformation = 11,
	SystemLocksInformation = 12,
	SystemStackTraceInformation = 13,
	SystemPagedPoolInformation = 14,
	SystemNonPagedPoolInformation = 15,
	SystemHandleInformation = 16,
	SystemObjectInformation = 17,
	SystemPageFileInformation = 18,
	SystemVdmInstemulInformation = 19,
	SystemVdmBopInformation = 20,
	SystemFileCacheInformation = 21,
	SystemPoolTagInformation = 22,
	SystemInterruptInformation = 23,
	SystemDpcBehaviorInformation = 24,
	SystemFullMemoryInformation = 25,
	SystemLoadGdiDriverInformation = 26,
	SystemUnloadGdiDriverInformation = 27,
	SystemTimeAdjustmentInformation = 28,
	SystemSummaryMemoryInformation = 29,
	SystemMirrorMemoryInformation = 30,
	SystemPerformanceTraceInformation = 31,
	SystemObsolete0 = 32,
	SystemExceptionInformation = 33,
	SystemCrashDumpStateInformation = 34,
	SystemKernelDebuggerInformation = 35,
	SystemContextSwitchInformation = 36,
	SystemRegistryQuotaInformation = 37,
	SystemExtendServiceTableInformation = 38,
	SystemPrioritySeperation = 39,
	SystemVerifierAddDriverInformation = 40,
	SystemVerifierRemoveDriverInformation = 41,
	SystemProcessorIdleInformation = 42,
	SystemLegacyDriverInformation = 43,
	SystemCurrentTimeZoneInformation = 44,
	SystemLookasideInformation = 45,
	SystemTimeSlipNotification = 46,
	SystemSessionCreate = 47,
	SystemSessionDetach = 48,
	SystemSessionInformation = 49,
	SystemRangeStartInformation = 50,
	SystemVerifierInformation = 51,
	SystemVerifierThunkExtend = 52,
	SystemSessionProcessInformation = 53,
	SystemLoadGdiDriverInSystemSpace = 54,
	SystemNumaProcessorMap = 55,
	SystemPrefetcherInformation = 56,
	SystemExtendedProcessInformation = 57,
	SystemRecommendedSharedDataAlignment = 58,
	SystemComPlusPackage = 59,
	SystemNumaAvailableMemory = 60,
	SystemProcessorPowerInformation = 61,
	SystemEmulationBasicInformation = 62,
	SystemEmulationProcessorInformation = 63,
	SystemExtendedHandleInformation = 64,
	SystemLostDelayedWriteInformation = 65,
	SystemBigPoolInformation = 66,
	SystemSessionPoolTagInformation = 67,
	SystemSessionMappedViewInformation = 68,
	SystemHotpatchInformation = 69,
	SystemObjectSecurityMode = 70,
	SystemWatchdogTimerHandler = 71,
	SystemWatchdogTimerInformation = 72,
	SystemLogicalProcessorInformation = 73,
	SystemWow64SharedInformation = 74,
	SystemRegisterFirmwareTableInformationHandler = 75,
	SystemFirmwareTableInformation = 76,
	SystemModuleInformationEx = 77,
	SystemVerifierTriageInformation = 78,
	SystemSuperfetchInformation = 79,
	SystemMemoryListInformation = 80,
	SystemFileCacheInformationEx = 81,
	MaxSystemInfoClass = 82  // MaxSystemInfoClass should always be the last enum

} SYSTEM_INFORMATION_CLASS;


typedef struct _SYSTEM_MODULE {
	PVOID  Reserved1;
	PVOID  Reserved2;
	PVOID  ImageBase;		// Base address of the module
	ULONG  ImageSize;		// Size of the image
	ULONG  Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	CHAR   ImageName[256]; // Full path of the module
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG ModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;
```

`PatchGuardEncryptorDriver/IntegrityChecker.cpp`:

```cpp
#include "IntegrityChecker.h"
#include <ntddk.h>
#include "Helper.h"

#pragma warning(push)
#pragma warning(disable: 4244)  // Disable specific warning
#pragma warning(disable: 4293)	// Disable specific warning
#pragma warning(disable: 4201)	// Disable specific warning
#pragma warning(disable: 4996)	// Disable specific warning
#pragma warning(disable: 6066)	// Disable specific warning
#pragma warning(disable: 4018)	// Disable specific warning
#pragma warning(disable: 4838)	// Disable specific warning
#pragma warning(disable: 4309)	// Disable specific warning

extern "C" PKERNEL_INFO g_KernelInfo = nullptr;


IntegrityCheck::IntegrityCheck(PTIMER_INFO TimerInfoArr) : TimerInfoArray(TimerInfoArr)
{
	KdPrint(("[*] PatchGuardEncryptorDriver::IntegrityCheck constructor invoked!\n"));

	KeInitializeTimerEx(&TimerVerifierIDT, NotificationTimer);
	KdPrint(("IntegrityCheck::IntegrityCheck() IDT Verifier _KTIMER object initialized successfully at address: 0x%p\n", &(TimerVerifierIDT)));

	KeInitializeTimerEx(&TimerVerifierSSDT, NotificationTimer);
	KdPrint(("IntegrityCheck::IntegrityCheck() SSDT Verifier _KTIMER object initialized successfully at address: 0x%p\n", &(TimerVerifierSSDT)));

	KeInitializeTimerEx(&TimerVerifierMSR, NotificationTimer);
	KdPrint(("IntegrityCheck::IntegrityCheck() MSR Verifier _KTIMER object initialized successfully at address: 0x%p\n", &(TimerVerifierMSR)));

	// 3 is the Number of times to allocate the DeferredContextDPC structure in non-paged pool,
	// since we have 3 "IntegrityCheck" timers for each mechanism (IDT, SSDT, MSRs), we'll allocate 3 structures.
	g_DefferedContext = (PDeferredContextDPC)ExAllocatePool(NonPagedPool, sizeof(DeferredContextDPC) * 3);
	if (!g_DefferedContext)
	{
		KdPrint(("[*] IntegrityCheck::IntegrityCheck(): failed to allocate g_DefferedContext memory!\n"));
		return;
	}

	//TimerInfo of TimerIDT
	g_DefferedContext[0].TimerInfo = &TimerInfoArray[0];
	g_DefferedContext[0].TimerObjectPointer = TimerInfoArray[0].Timer;

	//TimerInfo of TimerSSDT
	g_DefferedContext[1].TimerInfo = &TimerInfoArray[1];
	g_DefferedContext[1].TimerObjectPointer = TimerInfoArray[1].Timer;

	//TimerInfo of TimerMSRs
	g_DefferedContext[2].TimerInfo = &TimerInfoArray[2];	//(PTIMER_INFO)((ULONG_PTR)TimerInfoArray + (sizeof(TIMER_INFO)*2))
	g_DefferedContext[2].TimerObjectPointer = TimerInfoArray[2].Timer;


	KdPrint(("[*] g_DefferedContext allocated at address: 0x%p\n", g_DefferedContext));

	// Initializing DPC for the IDT Timer Integrity Check Verifier
	InitializeDPC(&TimerVerifierIDT,
		&DPCVerifierIDT,
		&DPCIntegrityCheckIDT,
		(PVOID)&g_DefferedContext[0]);

	// Initializing DPC for the SSDT Timer Integrity Check Verifier
	InitializeDPC(&TimerVerifierSSDT,
		&DPCVerifierSSDT,
		&DPCIntegrityCheckSSDT,
		(PVOID)&g_DefferedContext[1]);

	// Initializing DPC for the MSR Timer Integrity Check Verifier
	InitializeDPC(&TimerVerifierMSR,
		&DPCVerifierMSR,
		&DPCIntegrityCheckMSRs,
		(PVOID)&g_DefferedContext[2]);
}


BOOLEAN IntegrityCheck::CancelVerifierTimer(PKTIMER Timer)
{
	return KeCancelTimer(Timer);
}


// Right rotate function for 64-bit values
static inline ULONG_PTR ROR8(ULONG_PTR value, BYTE shift)
{
	return (value >> shift) | (value << (64 - shift));
}

/*
	I implemented the IntegrityCheck::CalculateTimerDPCValue() method through reversing the nt!KeSetTimerEx()
	which performs the following operations when attaching a DPC to the target _KTIMER object and stores
	the calculated result in _KTIMER->Dpc field.
*/

ULONG_PTR IntegrityCheck::CalculateTimerDPCValue(PKDPC Dpc, PKTIMER KTimer)
{
	ULONG_PTR KernelBaseAddress = (ULONG_PTR)g_KernelInfo->KernelBaseAddress;

	// Offsets for nt!KiWaitAlways and nt!KiWaitNever (These offsets change between builds!!!)
	ULONG_PTR KiWaitAlwaysAddress = KernelBaseAddress + 0x00fc5260;
	ULONG_PTR KiWaitNeverAddress = KernelBaseAddress + 0x00fc4f80;

	// Read values from memory
	ULONG_PTR KiWaitAlwaysValue = *(ULONG_PTR*)KiWaitAlwaysAddress;
	ULONG_PTR KiWaitNeverValue = *(ULONG_PTR*)KiWaitNeverAddress;

	// Read the shift count from KiWaitNever (ensuring it's a valid rotation amount)
	BYTE shift = *(BYTE*)(KiWaitNeverAddress) & 0x3F; // Masking to avoid invalid shifts (0x3F = 63)

	ULONG_PTR intermediate = _byteswap_uint64((ULONG_PTR)Dpc ^ KiWaitAlwaysValue);
	ULONG_PTR rotated = ROR8(intermediate ^ (ULONG_PTR)KTimer, shift);

	return rotated ^ KiWaitNeverValue;
}

BOOLEAN IntegrityCheck::TimerChecker(PKTIMER TimerObjectPointer, PTIMER_INFO TimerInfo)
{
	// Verifying that the KTIMER's DPC wasn't manipulated 

	KdPrint(("[*] IntegrityCheck::TimerChecker: _KTIMER object being checked: 0x%p\n", TimerObjectPointer));

	ULONG_PTR CalculatedDPCValue = CalculateTimerDPCValue(TimerInfo->Dpc, TimerInfo->Timer);
	KdPrint(("[*] IntegrityCheck::TimerChecker: CalculatedDPCValue received is: 0x%p\n", CalculatedDPCValue));

	if (CalculatedDPCValue != (ULONG_PTR)TimerObjectPointer->Dpc)
	{
		KdPrint(("IntegrityCheck::TimerChecker: KTIMER->Dpc structure pointer was manipulated: TimerInfo->Dpc: 0x%p and TimerObjectPointer->Dpc: 0x%p\n", TimerInfo->Dpc, TimerObjectPointer->Dpc));
		return FALSE;
	}

	// Verifying that the DPC's routine wasn't manipulated 
	if ((ULONG_PTR)TimerInfo->DeferredRoutine != (ULONG_PTR)TimerInfo->Dpc->DeferredRoutine)
	{
		KdPrint(("IntegrityCheck::TimerChecker: DPC's Deferred Routine was manipulated: Original DeferredRoutine: 0x%p and Malicious Deferred Routine: 0x%p\n", TimerInfo->DeferredRoutine, TimerObjectPointer->Dpc->DeferredRoutine));
		return FALSE;
	}
	return TRUE;
}

VOID IntegrityCheck::InitializeDPC(PKTIMER Timer, PKDPC Dpc, PVOID DeferredRoutine, PVOID DeferredContext)
{

	KdPrint(("IntegrityCheck::InitializeDPC: Timer pointer: 0x%p\n", Timer));
	KdPrint(("IntegrityCheck::InitializeDPC: Dpc pointer: 0x%p\n", Dpc));
	KdPrint(("IntegrityCheck::InitializeDPC: DeferredRoutine pointer: 0x%p\n", DeferredRoutine));
	KdPrint(("IntegrityCheck::InitializeDPC: DeferredContext pointer: 0x%p\n", DeferredContext));

	LARGE_INTEGER DueTime;
	DueTime.QuadPart = -5 * 10 * 1000 * 1000;	// 5 seconds
	LONG Period = 2 * 1000;						// 2 seconds interval

	KeInitializeDpc(Dpc, (PKDEFERRED_ROUTINE)DeferredRoutine, DeferredContext);
	if (!Dpc->DeferredRoutine)
	{
		KdPrint(("IntegrityCheck::InitializeDPC: Failed to initialize DPC\n"));
		return;
	}

	if (!KeSetTimerEx(Timer, DueTime, Period, Dpc))
	{
		KdPrint(("[*] IntegrityCheck::InitializeDPCs: _KTIMER object at address: 0x%p was setted successfully with its associated DPC\n", Timer));
		return;
	}

	KdPrint(("[*] IntegrityCheck::InitializeDPCs: Failed to set _KTIMER object at address: 0x%p\n", Timer));
	KeCancelTimer(Timer);
}

VOID IntegrityCheck::DPCIntegrityCheckIDT(
	PKDPC Dpc,
	PVOID DeferredContext,		// PKTIMER TimerObjectPointer + PTIMER_INFO TimerInfo 
	PVOID SystemArgument1,
	PVOID SystemArgument2)
{
	KdPrint(("[*] IntegrityCheck::DPCIntegrityCheckIDT Invoked!!\n"));
	PDeferredContextDPC DeferredStruct = (PDeferredContextDPC)DeferredContext;

	KIRQL OldIrql;
	KeRaiseIrql(HIGH_LEVEL, &OldIrql); // Raising IRQL to HIGH_LEVEL

	if (!TimerChecker(DeferredStruct->TimerObjectPointer, DeferredStruct->TimerInfo))
	{
		KdPrint(("IntegrityCheck::DPCIntegrityCheckIDT: PatchGuard's IDT Timer's DPC was manipulated!\n"));
		KeLowerIrql(OldIrql);

		//0xC7: TIMER_OR_DPC_INVALID 
		/*KeBugCheckEx(TIMER_OR_DPC_INVALID,(ULONG_PTR)DeferredStruct->TimerInfo->Dpc,(ULONG_PTR)DeferredStruct->TimerObjectPointer,(ULONG_PTR)((ULONG_PTR)DeferredStruct->TimerObjectPointer+sizeof(_KTIMER)),0x1);*/
		return;
	}
	KdPrint(("IntegrityCheck::DPCIntegrityCheckIDT: PatchGuard's IDT Timer's DPC is valid!\n"));

	KeLowerIrql(OldIrql);
}

VOID IntegrityCheck::DPCIntegrityCheckSSDT(
	PKDPC Dpc,
	PVOID DeferredContext,		// PKTIMER TimerObjectPointer + PTIMER_INFO TimerInfo 
	PVOID SystemArgument1,
	PVOID SystemArgument2)
{
	KdPrint(("[*] IntegrityCheck::DPCIntegrityCheckSSDT Invoked!!\n"));
	PDeferredContextDPC DeferredStruct = (PDeferredContextDPC)DeferredContext;

	KIRQL OldIrql;
	KeRaiseIrql(HIGH_LEVEL, &OldIrql); // Raising IRQL to HIGH_LEVEL

	if (!TimerChecker(DeferredStruct->TimerObjectPointer, DeferredStruct->TimerInfo))
	{
		KdPrint(("IntegrityCheck::DPCIntegrityCheckSSDT: PatchGuard's SSDT Timer's DPC was manipulated!\n"));
		KeLowerIrql(OldIrql);

		//0xC7: TIMER_OR_DPC_INVALID <- Will be used in production environment
		/*KeBugCheckEx(
			TIMER_OR_DPC_INVALID,
			(ULONG_PTR)DeferredStruct->TimerInfo->Dpc,
			(ULONG_PTR)DeferredStruct->TimerObjectPointer,
			(ULONG_PTR)((ULONG_PTR)DeferredStruct->TimerObjectPointer+sizeof(_KTIMER)),
			0x1);*/
		return;
	}
	KdPrint(("IntegrityCheck::DPCIntegrityCheckSSDT: PatchGuard's SSDT Timer's DPC is valid!\n"));

	KeLowerIrql(OldIrql);
}

VOID IntegrityCheck::DPCIntegrityCheckMSRs(
	PKDPC Dpc,
	PVOID DeferredContext,		// PKTIMER TimerObjectPointer + PTIMER_INFO TimerInfo 
	PVOID SystemArgument1,
	PVOID SystemArgument2)
{
	KdPrint(("[*] IntegrityCheck::DPCIntegrityCheckMSRs Invoked!!\n"));
	PDeferredContextDPC DeferredStruct = (PDeferredContextDPC)DeferredContext;

	KIRQL OldIrql;
	KeRaiseIrql(HIGH_LEVEL, &OldIrql); // Raising IRQL to HIGH_LEVEL

	if (!TimerChecker(DeferredStruct->TimerObjectPointer, DeferredStruct->TimerInfo))
	{
		KdPrint(("IntegrityCheck::DPCIntegrityCheckMSRs: PatchGuard's MSR Timer's DPC was manipulated!\n"));
		KeLowerIrql(OldIrql);

		//0xC7: TIMER_OR_DPC_INVALID 
		/*KeBugCheckEx(
			TIMER_OR_DPC_INVALID,
			(ULONG_PTR)DeferredStruct->TimerInfo->Dpc,
			(ULONG_PTR)DeferredStruct->TimerObjectPointer,
			(ULONG_PTR)((ULONG_PTR)DeferredStruct->TimerObjectPointer+sizeof(_KTIMER)),
			0x1);*/
		return;
	}
	KdPrint(("IntegrityCheck::DPCIntegrityCheckMSRs: PatchGuard's MSR Timer's DPC is valid!\n"));

	KeLowerIrql(OldIrql);
}

IntegrityCheck::~IntegrityCheck()
{
	KdPrint(("[*] PatchGuardEncryptorDriver::~IntegrityCheck Destructor invoked!\n"));
	if (CancelVerifierTimer(&TimerVerifierIDT)) {
		KdPrint(("[*] PatchGuardEncryptorDriver::~IntegrityCheck: TimerVerifierIDT at address: 0x%p was cancelled successfully!\n", &TimerVerifierIDT));
	}

	else {
		KdPrint(("[*] PatchGuardEncryptorDriver::~IntegrityCheck: TimerVerifierIDT wasn't initialized!\n"));
	}

	if (CancelVerifierTimer(&TimerVerifierSSDT)) {
		KdPrint(("[*] PatchGuardEncryptorDriver::~IntegrityCheck: TimerVerifierSSDT at address: 0x%p was cancelled successfully!\n", &TimerVerifierSSDT));
	}

	else {
		KdPrint(("[*] PatchGuardEncryptorDriver::~IntegrityCheck: TimerVerifierSSDT wasn't initialized!\n"));
	}

	if (CancelVerifierTimer(&TimerVerifierMSR)) {
		KdPrint(("[*] PatchGuardEncryptorDriver::~IntegrityCheck: TimerVerifierMSR at address: 0x%p was cancelled successfully!\n", &TimerVerifierMSR));
	}
	else {
		KdPrint(("[*] PatchGuardEncryptorDriver::~IntegrityCheck: TimerVerifierMSR wasn't initialized!\n"));
	}

	if (g_DefferedContext) {
		KdPrint(("[*] PatchGuardEncryptorDriver::~IntegrityCheck: successfully freed g_DefferedContext in address: 0x%p\n", g_DefferedContext));
		ExFreePool(g_DefferedContext);
	}

}
```

`PatchGuardEncryptorDriver/IntegrityChecker.h`:

```h
#pragma once
#include <ntddk.h>
#include "Helper.h"

/*
	This code will be responsible to verify that the timers haven't been modified in the following ways:
		- The DPCs haven't been patched (Verify that _KDPC->Dpc haven't been changed, DPC+0x18 is the function pointer to the
		  deferred routine.
		- Verify the _KTIMERs haven't been patched (especially the _KTIMER+0x30, which is the pointer to the DPC associated to the _KTIMER object
*/

typedef struct DeferredContextDPC
{
	PKTIMER TimerObjectPointer;
	PTIMER_INFO TimerInfo;
} DeferredContextDPC, * PDeferredContextDPC;

struct IntegrityCheck
{
	IntegrityCheck(PTIMER_INFO TimerInfoArr);
	~IntegrityCheck();

	BOOLEAN CancelVerifierTimer(PKTIMER Timer);
	VOID InitializeDPC(PKTIMER Timer, PKDPC Dpc, PVOID DeferredRoutine, PVOID DeferredContext);

	static VOID DPCIntegrityCheckIDT(_KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
	static VOID DPCIntegrityCheckSSDT(_KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
	static VOID DPCIntegrityCheckMSRs(_KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);

	static ULONG_PTR CalculateTimerDPCValue(PKDPC Dpc, PKTIMER KTimer);
	static BOOLEAN TimerChecker(PKTIMER TimerObjectPointer, PTIMER_INFO TimerInfo);

	KTIMER TimerVerifierSSDT;
	KTIMER TimerVerifierIDT;
	KTIMER TimerVerifierMSR;

	KDPC DPCVerifierSSDT;
	KDPC DPCVerifierIDT;
	KDPC DPCVerifierMSR;

	PTIMER_INFO TimerInfoArray;

	PDeferredContextDPC g_DefferedContext;
};
```

`PatchGuardEncryptorDriver/MSRs.h`:

```h
#pragma once

/* Intel VT MSRs */
#define MSR_IA32_VMX_BASIC              0x00000480
#define MSR_IA32_VMX_PINBASED_CTLS      0x00000481
#define MSR_IA32_VMX_PROCBASED_CTLS     0x00000482
#define MSR_IA32_VMX_EXIT_CTLS          0x00000483
#define MSR_IA32_VMX_ENTRY_CTLS         0x00000484
#define MSR_IA32_VMX_MISC               0x00000485
#define MSR_IA32_VMX_CR0_FIXED0         0x00000486
#define MSR_IA32_VMX_CR0_FIXED1         0x00000487
#define MSR_IA32_VMX_CR4_FIXED0         0x00000488
#define MSR_IA32_VMX_CR4_FIXED1         0x00000489
#define MSR_IA32_VMX_VMCS_ENUM          0x0000048a
#define MSR_IA32_VMX_PROCBASED_CTLS2    0x0000048b
#define MSR_IA32_VMX_EPT_VPID_CAP       0x0000048c

/* x86-64 specific MSRs */
#define MSR_EFER					    0xc0000080			// extended feature register 
#define MSR_STAR						0xc0000081			// legacy mode SYSCALL target
#define MSR_LSTAR						0xc0000082			// long mode SYSCALL target 
#define MSR_CSTAR						0xc0000083			// compat mode SYSCALL target
#define MSR_SYSCALL_MASK				0xc0000084			// EFLAGS mask for syscall 
#define MSR_FS_BASE						0xc0000100			// 64bit FS base 
#define MSR_GS_BASE						0xc0000101			// 64bit GS base 
#define MSR_KERNEL_GS_BASE				0xc0000102			// SwapGS GS shadow 

#define MSR_IA32_APICBASE               0x0000001b
#define MSR_IA32_APICBASE_BSP           (1<<8)
#define MSR_IA32_APICBASE_ENABLE		(1<<11)
#define MSR_IA32_APICBASE_BASE          (0xfffff<<12)



```

`PatchGuardEncryptorDriver/PatchGuardEncryptorDriver.cpp`:

```cpp
#include <ntddk.h>
#include <intrin.h>
#include "Helper.h"
#include "intrin.h"
#include "MSRs.h"
#include "IntegrityChecker.h"

#pragma warning(push)
#pragma warning(disable: 4244)  // Disable specific warning
#pragma warning(disable: 4293)	// Disable specific warning
#pragma warning(disable: 4201)	// Disable specific warning
#pragma warning(disable: 4996)	// Disable specific warning
#pragma warning(disable: 6066)	// Disable specific warning
#pragma warning(disable: 4018)	// Disable specific warning
#pragma warning(disable: 4838)	// Disable specific warning
#pragma warning(disable: 4309)	// Disable specific warning

// Booleans that are used in each Enumerate (IDT,SSDT, MSRs) functions to determine first run and VMX state
BOOLEAN g_IsInitial_IDT = TRUE;
BOOLEAN g_IsInitial_MSRs = TRUE;
BOOLEAN g_IsInitialSSDT = TRUE;

BOOLEAN g_CR4_VMXE_Enabled = FALSE;

PIDT_ENTRY	g_InitialIDTEntries;
PMSR_ENTRY	g_InitialMSRs;
PSSDT_ENTRY g_InitialSSDTEntries;

extern "C" PKERNEL_INFO g_KernelInfo;
//extern "C" ULONG_PTR g_KernelBaseAddress;

PTIMER_INFO g_TimerInfoArray;
ULONG_PTR	g_SystemInformation;
DWORD32		g_MaxVectorNumber = 0;
DWORD32		g_Number_Of_SSDT_Entries = 0;
PVOID		g_KiServiceTableAddress;

IntegrityCheck* g_Verifier;

//BYTE KiServiceTableOpCodes[] = {0xF0, 0x87, 0x26, 0x00, 0x00, 0x50, 0x27, 0x00};
BYTE KiServiceTableOpCodes[] = { 0x60, 0x41,0x32, 0x00, 0xF0, 0xA4, 0x43, 0x00 };

// Global Timer objects for each Patch Guard check
KTIMER TimerIDT;
KTIMER TimerSSDT;
KTIMER TimerMSRs;

// Global DPC objects for each Patch Guard Check
KDPC DPC_IDT;
KDPC DPC_SSDT;
KDPC DPC_MSRs;

NTSTATUS CompleteRequest(PIRP Irp, NTSTATUS status, ULONG information)
{
	Irp->IoStatus.Information = information;
	Irp->IoStatus.Status = status;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return status;
}

NTSTATUS CreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	return CompleteRequest(Irp, STATUS_SUCCESS, 0);
}

VOID UnloadRoutine(PDRIVER_OBJECT DriverObject)
{
	PDEVICE_OBJECT Device = DriverObject->DeviceObject;
	UNICODE_STRING DeviceSymlink = RTL_CONSTANT_STRING(L"\\??\\PatchGuardEncryptor");

	IoDeleteDevice(Device);
	IoDeleteSymbolicLink(&DeviceSymlink);

	if (g_InitialIDTEntries)
	{
		ExFreePool(g_InitialIDTEntries);
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: successfully freed the allocated IDT_ENTRY entries copy allocated from non paged pool!\n"));
	}

	if (g_InitialMSRs)
	{
		ExFreePool(g_InitialMSRs);
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: successfully freed the allocated MSR_ENTRY Entries allocated from non paged pool!\n"));
	}

	if (g_KernelInfo)
	{
		ExFreePool(g_KernelInfo);
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: successfully freed the allocated KERNEL_INFO structure allocated from non-paged pool!\n"));
	}

	if (g_InitialSSDTEntries)
	{
		ExFreePool(g_InitialSSDTEntries);
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: successfully freed the allocated SSDT_ENTRY entries allocated from non-paged pool!\n"));
	}

	if (g_TimerInfoArray)
	{
		ExFreePool(g_TimerInfoArray);
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: successfully freed the allocated TIMER_INFO entries allocated from non-paged pool!\n"));
	}

	// Cancelling the PatchGuardEncryptorDriver timers - if it's already cancelled/unset, then nothing will happen
	if (KeCancelTimer(&TimerIDT))
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: IDT Timer was cancelled successfully!\n"));
	else
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: IDT Timer was not active.\n"));

	if (KeCancelTimer(&TimerMSRs))
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: MSRs Timer was cancelled successfully!\n"));
	else
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: MSRs Timer was not active.\n"));

	if (KeCancelTimer(&TimerSSDT))
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: SSDT Timer was cancelled successfully!\n"));
	else
		KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: SSDT Timer was not active.\n"));

	//if (g_Verifier) {
	delete g_Verifier;
	//}

	KdPrint(("[*] PatchGuardEncryptor::UnloadRoutine: Driver unloaded successfully!\n"));
}

VOID NTAPI EnumerateIDT()
{
	PKPCR CurrentKPCR = (PKPCR)__readgsqword(0x18);
	PVOID CurrentPrcb = CurrentKPCR->CurrentPrcb;
	PVOID IdtBaseAddress = (PVOID)CurrentKPCR->IdtBase;

	KdPrint(("[*] PatchGuardEncryptor::EnumerateIDT: _KPCR Base Address: 0x%p\n", CurrentKPCR));
	KdPrint(("[*] PatchGuardEncryptor::EnumerateIDT: _KPRCB Base Address: 0x%p\n", CurrentPrcb));
	KdPrint(("[*] PatchGuardEncryptor::EnumerateIDT: _KPCR.IdtBase Base Address: 0x%p\n", IdtBaseAddress));

	// Bonus: Another way of dynamically getting the IDT base address:
	// I found it through reversing the nt!KiGetGdtIdt() function
	PVOID IDT_BaseAddress2;
	__sidt(&IDT_BaseAddress2); // stores the value in the IDTR register <- shown only for demonstration 
	KdPrint(("[*] PatchGuardEncryptor::EnumerateIDT: IdtBase Base Address from __sidt instruction: 0x%p\n", IdtBaseAddress));

	_KIDTENTRY64* IDTEntry = (_KIDTENTRY64*)(IdtBaseAddress);

	if (g_IsInitial_IDT)
	{
		for (int i = 0; i < 256; i++)
		{
			_KIDTENTRY64* IDTEntry = (_KIDTENTRY64*)((ULONG_PTR)IdtBaseAddress + (0x10 * i));
			KdPrint(("IDTEntry: 0x%p\n", IDTEntry));
			if (*(ULONG_PTR*)IDTEntry == 0x0 && *(ULONG_PTR*)((CHAR*)IDTEntry + 0x8) == 0)
			{
				KdPrint(("[*] PatchGuardEncryptor::EnumerateIDT: Finished running on the Interrupt Dispatch Table\n"));
				break;
			}

			ULONG_PTR High = *(DWORD32*)((CHAR*)IDTEntry + 8);		// Using IDTEntry->OffsetHigh returned a false value
			ULONG_PTR Middle = *(USHORT*)((CHAR*)IDTEntry + 6);		// Using IDTEntry->OffsetMiddle returned a false value
			ULONG_PTR Low = IDTEntry->OffsetLow;

			ULONG_PTR ServiceRoutine = High << 32;
			ServiceRoutine = ServiceRoutine ^ (Middle << 16);
			ServiceRoutine = ServiceRoutine ^ Low;

			g_InitialIDTEntries[i].ServiceRoutine = (PVOID)ServiceRoutine;
			g_InitialIDTEntries[i].Vector = i;
			g_MaxVectorNumber++;

			KdPrint(("g_InitialIDTEntries[%d].Vector: 0%x | IDT_ENTRY[%x].ServiceRoutine: 0x%p\n", i, g_InitialIDTEntries[i].Vector, i, g_InitialIDTEntries[i].ServiceRoutine));
		}

		g_IsInitial_IDT = FALSE;
		return;
	}

	if (*(PVOID*)g_InitialIDTEntries || *(PVOID*)(g_InitialIDTEntries + 0x8))	// Verifying that at least the first entry or the second entry the value isn't 0
	{
		for (int i = 0; i < g_MaxVectorNumber; i++)
		{
			_KIDTENTRY64* IDTEntry = (_KIDTENTRY64*)((ULONG_PTR)IdtBaseAddress + (0x10 * i));

			ULONG_PTR High = *(DWORD32*)((CHAR*)IDTEntry + 8);
			ULONG_PTR Middle = *(USHORT*)((CHAR*)IDTEntry + 6);
			ULONG_PTR Low = IDTEntry->OffsetLow;

			ULONG_PTR ServiceRoutine = High << 32;
			ServiceRoutine = ServiceRoutine ^ (Middle << 16);
			ServiceRoutine = ServiceRoutine ^ Low;

			KdPrint(("[*] PatchGuardEncryptor::EnumerateIDT: Comparing Service Routine[%x]: 0x%p with g_InitialIDTEntries[%x].ServiceRoutine: 0x%p\n", i, ServiceRoutine, i, g_InitialIDTEntries[i].ServiceRoutine));
			if ((PVOID)ServiceRoutine != g_InitialIDTEntries[i].ServiceRoutine)
			{
				/*
				 Which BugCheck to use: https://www.geoffchappell.com/studies/windows/km/bugchecks/index.htm
										https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-0x109---critical-structure-corruption
				*/

				//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); // 0x2 = A processor interrupt dispatch table (IDT)

				//For testing purposes, instead of bugcheck, we'll use KdPrint() to print that a modification was detected
				KdPrint(("[*] PatchGuardEncryptor::EnumerateIDT: detected a change in Vector: 0x%x\n", i));
				break;
			}
			KdPrint(("[*] PatchGuardEncryptor: Vector 0x%x is verified\n", i));
		}
	}
}

extern "C" VOID GetNtosBaseAddress()
{
	NTSTATUS status = STATUS_SUCCESS;
	UNICODE_STRING NtQuerySystemInformationName = RTL_CONSTANT_STRING(L"NtQuerySystemInformation");
	typedef NTSTATUS(NTAPI* fNtQuerySytsemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass,
		PVOID SystemInformation,
		ULONG SystemInformationLength,
		PULONG ReturnLength
		);

	fNtQuerySytsemInformation NtQuerySystemInformation = (fNtQuerySytsemInformation)MmGetSystemRoutineAddress(&NtQuerySystemInformationName);
	PVOID DummyMemory = ExAllocatePool(NonPagedPool, 1);
	if (!DummyMemory)
	{
		KdPrint(("[*] PatchGuardEncryptor::GetNtosBaseAddress: Unable to allocate DummyMemory!\n"));
		return;
	}
	ULONG ReturnLength;
	status = NtQuerySystemInformation(SystemModuleInformation, DummyMemory, 1, &ReturnLength);
	if (status == STATUS_INFO_LENGTH_MISMATCH)
	{

		PSYSTEM_MODULE_INFORMATION ModuleInformationMemory = (PSYSTEM_MODULE_INFORMATION)ExAllocatePool(NonPagedPool, ReturnLength);
		if (!ModuleInformationMemory) {
			KdPrint(("[*] PatchGuardEncryptor::GetNtosBaseAddress: Unable to allocate ModuleInformationMemory\n"));
			return;
		}
		status = NtQuerySystemInformation(SystemModuleInformation, ModuleInformationMemory, ReturnLength, nullptr);
		if (!NT_SUCCESS(status))
		{
			KdPrint(("[*] PatchGuardEncryptor::GetNtosBaseAddress: NtQuerySystemInformation failed with: 0x%x\n", status));
			return;
		}
		
		g_KernelInfo->KernelBaseAddress = ModuleInformationMemory->Modules[0].ImageBase;
		g_KernelInfo->Size = ModuleInformationMemory->Modules[0].ImageSize;

		KdPrint(("GetNtosBaseAddress(): Kernel Base Address: 0x%p\n", g_KernelInfo->KernelBaseAddress));

	}
}

VOID FillNumberOfSSDTEntries()
{
	/*
		The function will fill g_Number_Of_SSDT_Entries global variable with the number of SSDT enrties available on the system
		by dynamically resolving it through iterating over the SSDT.
	*/

	if (!g_KernelInfo->KernelBaseAddress)
	{
		GetNtosBaseAddress();
	}

	if (!g_KiServiceTableAddress)
	{
		//The nt!KiServiceTable offset is hardcoded - offset can be changed between different builds!!
		g_KiServiceTableAddress = (PVOID)(((ULONG_PTR)g_KernelInfo->KernelBaseAddress) + 0xd4270);
		KdPrint(("nt!KiServiceTable address: 0x%p\n", g_KiServiceTableAddress));
	}

	ULONG_PTR CurrentSSDTEntry = (ULONG_PTR)g_KiServiceTableAddress;
	if((CurrentSSDTEntry & 0xfffff00000000000) != 0xfffff00000000000) // checking if the given address is a valid kernel address - without it I encountered a rabdom BSOD
	{
		KdPrint(("CurrentSSDTEntry is invalid! (0x%p) returning...\n", CurrentSSDTEntry));
		return;
	}

	int limiter = 300;	// Used to avoid a case of infinite iteration over the kernel space
	while (*(DWORD*)CurrentSSDTEntry || limiter--)
	{
		// I made some bitwise operations that determines if the currently iterated DWORD
		// is a valid SSDT entry. I created it through researching how a SSDT entry is constructed  
		// and found a common base that each valid SSDT entry won't have
		if (((*(DWORD*)CurrentSSDTEntry) == 00000000)					// Checking if the currently iterated SSDT entry is 0
			|| (((*(DWORD*)CurrentSSDTEntry) & 0xff000000) == 00000000) // Checking if the first byte in the currently iterated SSDT is 00
			|| (((*(DWORD*)CurrentSSDTEntry) & 0xfffff000) == 00000000) // Checking if only the last 12 bits in the currently iterated SSDT are set
			|| (((*(DWORD*)CurrentSSDTEntry) ^ 0xff000000) == 0))		// checking if first byte in the currently iterated SSDT entry is bigger than 0x0f
		{
			break;
		}

		CurrentSSDTEntry += sizeof(DWORD);
		g_Number_Of_SSDT_Entries++;
	}
	KdPrint(("[*] PatchGuardEncryptorDriver::FillNumberOfSSDTEntries: Number of SSDT entries found: %d\n", g_Number_Of_SSDT_Entries));

}

VOID EnumerateSSDT()
{
	/*
		The EnumerateSSDT function will first check if it's the first run using a global boolean variable that
		will be initially set to TRUE.

		If the boolean variable is TRUE:
		The function will set the boolean variable to false,
		and will contiue by dynamically resolving the address of nt!KiServiceTable and stroring it in a global variable.
		Next, initialize a while loop from nt!KiServiceTable base address and in each iteration will read 4 bytes
		from the address, while the DWORD value read isn't 00000000, increment the SSDT Entries counter by one.
		This will be used to know how many SSDT_ENTRY structures to allocated in the non-paged pool using ExAllocatePool().

		The allocated pool base address will be stored in a global variable and will be freed in the UnloadRoutine().

		Next, A for loop will iterate over each SSDT entry and will allocate SSDT_ENTRY structure within the SSDT_ENTRY array
		allocated using ExAllocatePool().

		If the boolean is false, meaning it's isn't the first time the function runs.
		A for loop will iterate over each current value in the SSDT, and will dynamically compare the relative value with
		the current SSDT entry value, if it fails, a BSOD will be invoked in a production! in our case, we'll KdPrint(()) a message
	*/

	if (g_IsInitialSSDT)
	{
		g_IsInitialSSDT = FALSE;
		if (!g_InitialSSDTEntries)
		{
			KdPrint(("[*] PatchGuardEncryptor::EnumerateSSDT: g_InitialSSDTEntries is not allocated, returning...\n"));
			return;
		}

		//g_KiServiceTableAddress = GetKiServiceTableBaseAddress(); // This will fill the g_KiServiceTableAddress with nt!KiServiceTable base address
		g_KiServiceTableAddress = (PVOID)(((ULONG_PTR)g_KernelInfo->KernelBaseAddress) + 0xd4270); // hardcoded offset for testing purposes

		KdPrint(("[*] PatchGuardEncryptor::EnumerateSSDT: Number of SSDT entries found: %d!\n", g_Number_Of_SSDT_Entries));

		ULONG_PTR LocalKiServiceTableAddress = (ULONG_PTR)g_KiServiceTableAddress;
		DWORD CurrentSSDTEntry;
		for (int i = 0; i < g_Number_Of_SSDT_Entries; i++)
		{
			CurrentSSDTEntry = *(DWORD*)((BYTE*)LocalKiServiceTableAddress + (i * sizeof(DWORD)));
			g_InitialSSDTEntries[i].SyscallNumber = i; // since a syscall number is an index in the SSDT table, i is the SCN
			g_InitialSSDTEntries[i].SSDTValue = *(DWORD*)((BYTE*)LocalKiServiceTableAddress + (i * sizeof(DWORD)));
		}
		return;
	}

	ULONG_PTR LocalKiServiceTableAddress = (ULONG_PTR)g_KiServiceTableAddress;
	for (int i = 0; i < g_Number_Of_SSDT_Entries; i++)
	{
		ULONG_PTR CurrentSSDTEntryPointer = (ULONG_PTR)(((BYTE*)LocalKiServiceTableAddress) + (i * sizeof(DWORD)));
		if (g_InitialSSDTEntries[i].SSDTValue != *(DWORD*)CurrentSSDTEntryPointer)
		{
			KdPrint(("[*] PatchGuardEncryptor::EnumerateSSDT: Original SSDT entry value: 0x%x at 0x%p was changed to: 0x%x!!\n", g_InitialSSDTEntries[i].SSDTValue, CurrentSSDTEntryPointer, *(DWORD*)CurrentSSDTEntryPointer));
			continue;
		}
		//KdPrint(("[*] PatchGuardEncryptor::EnumerateSSDT: SSDT Entry[%d]: Original SSDT Entry Value = 0x%x | Current SSDT Entry value: 0x%x are verified!\n", i, g_InitialSSDTEntries[i].SSDTValue, *(DWORD*)CurrentSSDTEntryPointer));
		KdPrint(("[*] PatchGuardEncryptor::EnumerateSSDT: SSDT Entry at %d is valid and has the original value of 0x%x\n", i, g_InitialSSDTEntries[i].SSDTValue));
	}

}

VOID EnumerateMSRs()
{
	/*
		Captures MSR values that are supposed to be static
		and through a timer, this function will be executed as DPC routine with IRQL = DISPATCH_LEVEL
		after each clock time of the timer is passed
	*/

	if (g_IsInitial_MSRs) // Checking if it's being executed from DriverEntry() when the driver is first being loaded in kernel space.
	{
		g_IsInitial_MSRs = FALSE;

		ULONG reg_cr4 = __readcr4();
		KdPrint(("CR4 value: 0x%x\n", reg_cr4));

		// CR4.VMXE (Virtual Machine Extension Enabled) is at index 13 
		// If CR4.VMXE = 1 -> VMX MSR registers will also be captured at initial run.
		if ((reg_cr4 & (1 << 13)) != 0x0)
		{
			KdPrint(("[*] PatchGuardEncryptorDriver::EnumerateMSRs: CR4.VMXE = 0x1\n"));
			g_CR4_VMXE_Enabled = TRUE;

			g_InitialMSRs[0].MSRIndex = MSR_IA32_VMX_BASIC;
			g_InitialMSRs[0].MSRValue = __readmsr(MSR_IA32_VMX_BASIC);

			g_InitialMSRs[1].MSRIndex = MSR_IA32_VMX_PINBASED_CTLS;
			g_InitialMSRs[1].MSRValue = __readmsr(MSR_IA32_VMX_PINBASED_CTLS);

			g_InitialMSRs[2].MSRIndex = MSR_IA32_VMX_PROCBASED_CTLS;
			g_InitialMSRs[2].MSRValue = __readmsr(MSR_IA32_VMX_PROCBASED_CTLS);

			g_InitialMSRs[3].MSRIndex = MSR_IA32_VMX_EXIT_CTLS;
			g_InitialMSRs[3].MSRValue = __readmsr(MSR_IA32_VMX_EXIT_CTLS);

			g_InitialMSRs[4].MSRIndex = MSR_IA32_VMX_ENTRY_CTLS;
			g_InitialMSRs[4].MSRValue = __readmsr(MSR_IA32_VMX_ENTRY_CTLS);

			g_InitialMSRs[5].MSRIndex = MSR_IA32_VMX_MISC;
			g_InitialMSRs[5].MSRValue = __readmsr(MSR_IA32_VMX_MISC);

			g_InitialMSRs[6].MSRIndex = MSR_IA32_VMX_CR0_FIXED0;
			g_InitialMSRs[6].MSRValue = __readmsr(MSR_IA32_VMX_CR0_FIXED0);

			g_InitialMSRs[7].MSRIndex = MSR_IA32_VMX_CR0_FIXED1;
			g_InitialMSRs[7].MSRValue = __readmsr(MSR_IA32_VMX_CR0_FIXED1);

			g_InitialMSRs[8].MSRIndex = MSR_IA32_VMX_CR4_FIXED0;
			g_InitialMSRs[8].MSRValue = __readmsr(MSR_IA32_VMX_CR4_FIXED0);

			g_InitialMSRs[9].MSRIndex = MSR_IA32_VMX_CR4_FIXED1;
			g_InitialMSRs[9].MSRValue = __readmsr(MSR_IA32_VMX_CR4_FIXED1);

			g_InitialMSRs[10].MSRIndex = MSR_IA32_VMX_VMCS_ENUM;
			g_InitialMSRs[10].MSRValue = __readmsr(MSR_IA32_VMX_VMCS_ENUM);

			g_InitialMSRs[11].MSRIndex = MSR_IA32_VMX_PROCBASED_CTLS2;
			g_InitialMSRs[11].MSRValue = __readmsr(MSR_IA32_VMX_PROCBASED_CTLS2);

			g_InitialMSRs[12].MSRIndex = MSR_IA32_VMX_EPT_VPID_CAP;
			g_InitialMSRs[12].MSRValue = __readmsr(MSR_IA32_VMX_EPT_VPID_CAP);

			g_InitialMSRs[13].MSRIndex = MSR_EFER;
			g_InitialMSRs[13].MSRValue = __readmsr(MSR_EFER);

			g_InitialMSRs[14].MSRIndex = MSR_STAR;
			g_InitialMSRs[14].MSRValue = __readmsr(MSR_STAR);

			g_InitialMSRs[15].MSRIndex = MSR_LSTAR;
			g_InitialMSRs[15].MSRValue = __readmsr(MSR_LSTAR);

			g_InitialMSRs[16].MSRIndex = MSR_CSTAR;
			g_InitialMSRs[16].MSRValue = __readmsr(MSR_CSTAR);

			g_InitialMSRs[17].MSRIndex = MSR_FS_BASE;
			g_InitialMSRs[17].MSRValue = __readmsr(MSR_FS_BASE);

			g_InitialMSRs[18].MSRIndex = MSR_GS_BASE;
			g_InitialMSRs[18].MSRValue = __readmsr(MSR_GS_BASE);

			g_InitialMSRs[19].MSRIndex = MSR_KERNEL_GS_BASE;
			g_InitialMSRs[19].MSRValue = __readmsr(MSR_KERNEL_GS_BASE);

			g_InitialMSRs[20].MSRIndex = MSR_IA32_APICBASE;
			g_InitialMSRs[20].MSRValue = __readmsr(MSR_IA32_APICBASE);

			g_InitialMSRs[21].MSRIndex = MSR_SYSCALL_MASK;
			g_InitialMSRs[21].MSRValue = __readmsr(MSR_SYSCALL_MASK);

			KdPrint(("[*] PatchGuardEncryptor::EnumerateMSR: CR4.VMXE=1\n"));
			KdPrint(("[*] PatchGuardEncryptor::EnumerateMSR: successfully filled g_InitialMSRs at base address : 0x%p\n", g_InitialMSRs));
			return;
		}

		g_InitialMSRs[0].MSRIndex = MSR_EFER;
		g_InitialMSRs[0].MSRValue = __readmsr(MSR_EFER);

		g_InitialMSRs[1].MSRIndex = MSR_STAR;
		g_InitialMSRs[1].MSRValue = __readmsr(MSR_STAR);

		g_InitialMSRs[2].MSRIndex = MSR_LSTAR;
		g_InitialMSRs[2].MSRValue = __readmsr(MSR_LSTAR);

		g_InitialMSRs[3].MSRIndex = MSR_CSTAR;
		g_InitialMSRs[3].MSRValue = __readmsr(MSR_CSTAR);

		g_InitialMSRs[4].MSRIndex = MSR_FS_BASE;
		g_InitialMSRs[4].MSRValue = __readmsr(MSR_FS_BASE);

		g_InitialMSRs[5].MSRIndex = MSR_GS_BASE;
		g_InitialMSRs[5].MSRValue = __readmsr(MSR_GS_BASE);

		g_InitialMSRs[6].MSRIndex = MSR_KERNEL_GS_BASE;
		g_InitialMSRs[6].MSRValue = __readmsr(MSR_KERNEL_GS_BASE);

		g_InitialMSRs[7].MSRIndex = MSR_IA32_APICBASE;
		g_InitialMSRs[7].MSRValue = __readmsr(MSR_IA32_APICBASE);

		g_InitialMSRs[8].MSRIndex = MSR_SYSCALL_MASK;
		g_InitialMSRs[8].MSRValue = __readmsr(MSR_SYSCALL_MASK);

		KdPrint(("[*] PatchGuardEncryptor::EnumerateMSR: CR4.VMXE=0\n"));
		KdPrint(("[*] PatchGuardEncryptor::EnumerateMSR: successfully filled g_InitialMSRs at base address : 0x%p\n", g_InitialMSRs));

		return;
	}

	// An MSR integrity check if the CR4.VXME bit is set to 1 (which means that the CPU supports VMX operations)
	// This check will include both the regular MSRs and also the VMX related MSRs
	if (g_CR4_VMXE_Enabled)
	{
		KdPrint(("[*] PatchGuardEncryptor::EnumerateMSRs: CR4.VMXE=1 -> Comparing current MSRs with initial MSRs\n"));

		// Verify if each "if" statement compares with the correct index!!
		if (g_InitialMSRs[0].MSRValue != __readmsr(MSR_IA32_VMX_BASIC))
		{
			KdPrint(("[*] MSR_IA32_VMX_BASIC (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_BASIC, g_InitialMSRs[0].MSRValue, __readmsr(MSR_IA32_VMX_BASIC)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[1].MSRValue != __readmsr(MSR_IA32_VMX_PINBASED_CTLS))
		{
			KdPrint(("[*] MSR_IA32_VMX_PINBASED_CTLS (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_PINBASED_CTLS, g_InitialMSRs[1].MSRValue, __readmsr(MSR_IA32_VMX_PINBASED_CTLS)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[2].MSRValue != __readmsr(MSR_IA32_VMX_PROCBASED_CTLS))
		{
			KdPrint(("[*] MSR_IA32_VMX_PROCBASED_CTLS (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_PROCBASED_CTLS, g_InitialMSRs[2].MSRValue, __readmsr(MSR_IA32_VMX_PROCBASED_CTLS)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[3].MSRValue != __readmsr(MSR_IA32_VMX_EXIT_CTLS))
		{
			KdPrint(("[*] MSR_IA32_VMX_EXIT_CTLS (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_EXIT_CTLS, g_InitialMSRs[3].MSRValue, __readmsr(MSR_IA32_VMX_EXIT_CTLS)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[4].MSRValue != __readmsr(MSR_IA32_VMX_ENTRY_CTLS))
		{
			KdPrint(("[*] MSR_IA32_VMX_ENTRY_CTLS (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_ENTRY_CTLS, g_InitialMSRs[4].MSRValue, __readmsr(MSR_IA32_VMX_ENTRY_CTLS)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[5].MSRValue != __readmsr(MSR_IA32_VMX_MISC))
		{
			KdPrint(("[*] MSR_IA32_VMX_MISC (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_MISC, g_InitialMSRs[5].MSRValue, __readmsr(MSR_IA32_VMX_MISC)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[6].MSRValue != __readmsr(MSR_IA32_VMX_CR0_FIXED0))
		{
			KdPrint(("[*] MSR_IA32_VMX_CR0_FIXED0 (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_CR0_FIXED0, g_InitialMSRs[6].MSRValue, __readmsr(MSR_IA32_VMX_CR0_FIXED0)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[7].MSRValue != __readmsr(MSR_IA32_VMX_CR0_FIXED1))
		{
			KdPrint(("[*] MSR_IA32_VMX_CR0_FIXED1 (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_CR0_FIXED1, g_InitialMSRs[7].MSRValue, __readmsr(MSR_IA32_VMX_CR0_FIXED1)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[8].MSRValue != __readmsr(MSR_IA32_VMX_CR4_FIXED0))
		{
			KdPrint(("[*] MSR_IA32_VMX_CR4_FIXED0 (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_CR4_FIXED0, g_InitialMSRs[8].MSRValue, __readmsr(MSR_IA32_VMX_CR4_FIXED0)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[9].MSRValue != __readmsr(MSR_IA32_VMX_CR4_FIXED1))
		{
			KdPrint(("[*] MSR_IA32_VMX_CR4_FIXED1 (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_CR4_FIXED1, g_InitialMSRs[9].MSRValue, __readmsr(MSR_IA32_VMX_CR4_FIXED1)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[10].MSRValue != __readmsr(MSR_IA32_VMX_VMCS_ENUM))
		{
			KdPrint(("[*] MSR_IA32_VMX_VMCS_ENUM (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_VMCS_ENUM, g_InitialMSRs[10].MSRValue, __readmsr(MSR_IA32_VMX_VMCS_ENUM)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[11].MSRValue != __readmsr(MSR_IA32_VMX_PROCBASED_CTLS2))
		{
			KdPrint(("[*] MSR_IA32_VMX_PROCBASED_CTLS2 (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_PROCBASED_CTLS2, g_InitialMSRs[11].MSRValue, __readmsr(MSR_IA32_VMX_PROCBASED_CTLS2)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[12].MSRValue != __readmsr(MSR_IA32_VMX_EPT_VPID_CAP))
		{
			KdPrint(("[*] MSR_IA32_VMX_EPT_VPID_CAP (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_VMX_EPT_VPID_CAP, g_InitialMSRs[12].MSRValue, __readmsr(MSR_IA32_VMX_EPT_VPID_CAP)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[13].MSRValue != __readmsr(MSR_EFER))
		{
			KdPrint(("[*] MSR_EFER (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_EFER, g_InitialMSRs[13].MSRValue, __readmsr(MSR_EFER)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[14].MSRValue != __readmsr(MSR_STAR))
		{
			KdPrint(("[*] MSR_STAR (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_STAR, g_InitialMSRs[14].MSRValue, __readmsr(MSR_STAR)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[15].MSRValue != __readmsr(MSR_LSTAR))
		{
			KdPrint(("[*] MSR_LSTAR (0x%x) was changed from: 0x%p to: 0x%p!\n", MSR_LSTAR, g_InitialMSRs[15].MSRValue, __readmsr(MSR_LSTAR)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[16].MSRValue != __readmsr(MSR_CSTAR))
		{
			KdPrint(("[*] MSR_CSTAR (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_CSTAR, g_InitialMSRs[16].MSRValue, __readmsr(MSR_CSTAR)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[17].MSRValue != __readmsr(MSR_FS_BASE))
		{
			KdPrint(("[*] MSR_FS_BASE (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_FS_BASE, g_InitialMSRs[17].MSRValue, __readmsr(MSR_FS_BASE)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[18].MSRValue != __readmsr(MSR_GS_BASE))
		{
			KdPrint(("[*] MSR_GS_BASE (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_GS_BASE, g_InitialMSRs[18].MSRValue, __readmsr(MSR_GS_BASE)));
		}

		if (g_InitialMSRs[19].MSRValue != __readmsr(MSR_KERNEL_GS_BASE))
		{
			KdPrint(("[*] MSR_KERNEL_GS_BASE (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_KERNEL_GS_BASE, g_InitialMSRs[19].MSRValue, __readmsr(MSR_KERNEL_GS_BASE)));
		}

		if (g_InitialMSRs[20].MSRValue != __readmsr(MSR_IA32_APICBASE))
		{
			KdPrint(("[*] MSR_IA32_APICBASE (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_APICBASE, g_InitialMSRs[20].MSRValue, __readmsr(MSR_IA32_APICBASE)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		if (g_InitialMSRs[21].MSRValue != __readmsr(MSR_SYSCALL_MASK))
		{
			KdPrint(("[*] MSR_SYSCALL_MASK (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_SYSCALL_MASK, g_InitialMSRs[21].MSRValue, __readmsr(MSR_SYSCALL_MASK)));
			//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
		}

		return;
	}


	if (g_InitialMSRs[0].MSRValue != __readmsr(MSR_EFER))
	{
		KdPrint(("[*] MSR_EFER (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_EFER, g_InitialMSRs[0].MSRValue, __readmsr(MSR_EFER)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}

	if (g_InitialMSRs[1].MSRValue != __readmsr(MSR_STAR))
	{
		KdPrint(("[*] MSR_STAR (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_STAR, g_InitialMSRs[1].MSRValue, __readmsr(MSR_STAR)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}

	if (g_InitialMSRs[2].MSRValue != __readmsr(MSR_LSTAR))
	{
		KdPrint(("[*] MSR_LSTAR (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_LSTAR, g_InitialMSRs[2].MSRValue, __readmsr(MSR_LSTAR)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}

	if (g_InitialMSRs[3].MSRValue != __readmsr(MSR_CSTAR))
	{
		KdPrint(("[*] MSR_CSTAR (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_CSTAR, g_InitialMSRs[3].MSRValue, __readmsr(MSR_CSTAR)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}

	if (g_InitialMSRs[4].MSRValue != __readmsr(MSR_FS_BASE))
	{
		KdPrint(("[*] MSR_FS_BASE (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_FS_BASE, g_InitialMSRs[4].MSRValue, __readmsr(MSR_FS_BASE)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}

	if (g_InitialMSRs[5].MSRValue != __readmsr(MSR_GS_BASE))
	{
		KdPrint(("[*] MSR_GS_BASE (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_GS_BASE, g_InitialMSRs[5].MSRValue, __readmsr(MSR_GS_BASE)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}

	if (g_InitialMSRs[6].MSRValue != __readmsr(MSR_KERNEL_GS_BASE))
	{
		KdPrint(("[*] MSR_KERNEL_GS_BASE (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_KERNEL_GS_BASE, g_InitialMSRs[6].MSRValue, __readmsr(MSR_KERNEL_GS_BASE)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}

	if (g_InitialMSRs[7].MSRValue != __readmsr(MSR_IA32_APICBASE))
	{
		KdPrint(("[*] MSR_IA32_APICBASE (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_IA32_APICBASE, g_InitialMSRs[7].MSRValue, __readmsr(MSR_IA32_APICBASE)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}

	if (g_InitialMSRs[8].MSRValue != __readmsr(MSR_SYSCALL_MASK))
	{
		KdPrint(("[*] MSR_SYSCALL_MASK (0x%x) was changed from: 0x%p to: 0x%p\n", MSR_SYSCALL_MASK, g_InitialMSRs[8].MSRValue, __readmsr(MSR_SYSCALL_MASK)));
		//KeBugCheckEx(CRITICAL_STRUCTURE_CORRUPTION, 0, 0, 0, 0x2); //0x7 = A critical MSR modification
	}
}


VOID DPCInterruptDispatchTable(PKDPC Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
	NT_ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	/*
	 Increases IRQL to HIGH_LEVEL (0xF) to avoid potential evasion from an attacker when overriding a function pointer
	 with a malicious function pointer that automatically increases the IRQL to HIGH_LEVEL and prevent the timer DPC from being invoked.
	 Since working in a HIGH_LEVEL IRQL is an expensive operation, it must to be minimal and effective.
	*/

	KIRQL CurrentIRQL;
	KeRaiseIrql(HIGH_LEVEL, &CurrentIRQL);

	KdPrint(("[*] DPCInterruptDispatchTable was invoked!\n"));

	EnumerateIDT();

	KeLowerIrql(CurrentIRQL); // Lowers IRQL to DISPATCH_LEVEL (0x2)
}


VOID DPCMSRs(PKDPC Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
	NT_ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	/*
	 Increases IRQL to HIGH_LEVEL (0xF) to avoid potential evasion from an attacker when overriding a function pointer
	 with a malicious function pointer that automatically increases the IRQL to HIGH_LEVEL and prevent the timer DPC from being invoked.
	 Since working in a HIGH_LEVEL IRQL is an expensive operation, it must to be minimal and effective.
	*/

	KIRQL CurrentIrql;
	KeRaiseIrql(HIGH_LEVEL, &CurrentIrql);

	KdPrint(("[*] PatchGuardEncryptorDriver::DPCMSRs: MSR DPC is invoked, Current IRQL: %d\n", KeGetCurrentIrql()));
	EnumerateMSRs();

	KeLowerIrql(CurrentIrql);

}

VOID DPCSSDT(PKDPC Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
	NT_ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	/*
	 Increases IRQL to HIGH_LEVEL (0xF) to avoid potential evasion from an attacker when overriding a function pointer
	 with a malicious function pointer that automatically increases the IRQL to HIGH_LEVEL and prevent the timer DPC from being invoked.
	 Since working in a HIGH_LEVEL IRQL is an expensive operation, it must to be minimal and effective.
	*/

	KIRQL CurrentIrql;
	KeRaiseIrql(HIGH_LEVEL, &CurrentIrql);

	KdPrint(("[*] PatchGuardEncryptorDriver::DPC_SSDT: SSDT DPC is invoked, Current IRQL: %d\n", KeGetCurrentIrql()));
	EnumerateSSDT();

	KeLowerIrql(CurrentIrql);
}

// new operator overloading
void* __cdecl operator new(size_t size, DWORD32 NumberOfAllocations, POOL_TYPE PoolType)
{
	return ExAllocatePool(PoolType, NumberOfAllocations * size);
}

// delete operator overloading
void __cdecl operator delete(void* p, size_t)
{
	ExFreePool(p);
}

extern "C"
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);

	UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L"\\Device\\PatchGuardEncryptor");
	UNICODE_STRING DeviceSymlink = RTL_CONSTANT_STRING(L"\\??\\PatchGuardEncryptor");

	PDEVICE_OBJECT DeviceObject;
	NTSTATUS status = STATUS_SUCCESS;

	status = IoCreateDevice(DriverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &DeviceObject);
	if (!NT_SUCCESS(status))
	{
		KdPrint(("[-] PatchGuardEncryptor::DriverEntry - Failed to created Device Object [0x%x]\n", status));
		return status;
	}

	status = IoCreateSymbolicLink(&DeviceSymlink, &DeviceName);
	if (!NT_SUCCESS(status))
	{
		KdPrint(("[-] PatchGuardEncryptor::DriverEntry - Failed to created Device symlink [0x%x]\n", status));
		IoDeleteDevice(DeviceObject);
	}

	DriverObject->MajorFunction[IRP_MJ_CREATE] = CreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = CreateClose;
	DriverObject->DriverUnload = UnloadRoutine;


	g_TimerInfoArray = (PTIMER_INFO)ExAllocatePool(NonPagedPool, sizeof(TIMER_INFO) * 3);
	if (!g_TimerInfoArray)
	{
		KdPrint(("[-] PatchGuardEncryptor::DriverEntry: Failed allocating g_TimerInfoArray with ExAllocatePool()!\n"));
		status = STATUS_INSUFFICIENT_RESOURCES;
		UnloadRoutine(DriverObject);
		return status;
	}

	g_InitialIDTEntries = (PIDT_ENTRY)ExAllocatePool(NonPagedPool, sizeof(IDT_ENTRY) * 256);
	if (!g_InitialIDTEntries)
	{
		KdPrint(("[-] PatchGuardEncryptor::DriverEntry: Failed allocating g_InitialIDTEntries with ExAllocatePool()!\n"));
		status = STATUS_INSUFFICIENT_RESOURCES;
		UnloadRoutine(DriverObject);

		return status;
	}

	KdPrint(("Allocated an array in non-paged pool of 256 IDT_ENTRY structures at address: 0x%p\n", g_InitialIDTEntries));

	g_InitialMSRs = (PMSR_ENTRY)ExAllocatePool(NonPagedPool, 27 * sizeof(MSR_ENTRY)); // There are actually 26 MSRs at max being check, but rounding the allocation to 27 for safety.
	if (!g_InitialMSRs)
	{
		KdPrint(("[-] PatchGuardEncryptor::DriverEntry: Failed allocating g_InitialMSRs with ExAllocatePool()!\n"));
		status = STATUS_INSUFFICIENT_RESOURCES;
		UnloadRoutine(DriverObject);
		return status;
	}

	KdPrint(("Allocated an array in non-paged pool of 256 MSR_ENTRY structures at address: 0x%p\n", g_InitialMSRs));

	g_KernelInfo = (PKERNEL_INFO)ExAllocatePool(NonPagedPool, sizeof(KERNEL_INFO));
	if (!g_KernelInfo)
	{
		KdPrint(("[-] PatchGuardEncryptor::DriverEntry: Failed allocating g_KernelInfo with ExAllocatePool()!\n"));
		status = STATUS_INSUFFICIENT_RESOURCES;
		UnloadRoutine(DriverObject);
		return status;
	}

	FillNumberOfSSDTEntries();
	if (!g_Number_Of_SSDT_Entries)	// if the number of SSDT entries returned from FillNumberOfSSDTEntries() is 0...
	{
		KdPrint(("[*] PatchGuardEncryptor::EnumerateSSDT: g_Number_Of_SSDT_Entries is not allocated, returning...\n"));
		UnloadRoutine(DriverObject);
		return STATUS_BAD_DATA;
	}

	g_InitialSSDTEntries = (PSSDT_ENTRY)ExAllocatePool(NonPagedPool, g_Number_Of_SSDT_Entries * sizeof(SSDT_ENTRY));
	if (!g_InitialSSDTEntries)
	{
		KdPrint(("[-] PatchGuardEncryptor::DriverEntry: Failed allocating g_InitialSSDTEntries with ExAllocatePool()!\n"));
		status = STATUS_INSUFFICIENT_RESOURCES;
		UnloadRoutine(DriverObject);
		return status;
	}

	KdPrint(("Allocated an array in non-paged pool %d SSDT_ENTRY structures at address: 0x%p\n", g_Number_Of_SSDT_Entries, g_InitialSSDTEntries));

	EnumerateIDT();		// Captures the initial state of the Interrupt Dispatch Table when the driver is being loaded into kernel space.
	EnumerateMSRs();	// Captures the initial state of MSR registers when the driver is being loaded into kernel space.
	EnumerateSSDT();	// Captures the initial state of the SSDT when the driver is being loaded into kernel space.

	LARGE_INTEGER DueTime;
	DueTime.QuadPart = -3 * 10 * 1000 * 1000;	// 3 seconds
	LONG Period = 2 * 1000;						// 2 seconds interval

	// Allocating IDT, MSRs and SSDT timers using KeInitializeTimerEx()
	KeInitializeTimerEx(&TimerIDT, NotificationTimer);			// NotificationTimer makes the timer periodic
	KeInitializeTimerEx(&TimerMSRs, NotificationTimer);			// NotificationTimer makes the timer periodic
	KeInitializeTimerEx(&TimerSSDT, NotificationTimer);			// NotificationTimer makes the timer periodic

	g_TimerInfoArray[0].Timer = &TimerIDT;
	g_TimerInfoArray[1].Timer = &TimerSSDT;
	g_TimerInfoArray[2].Timer = &TimerMSRs;

	g_TimerInfoArray[0].DeferredRoutine = (PVOID)&DPCInterruptDispatchTable;
	g_TimerInfoArray[1].DeferredRoutine = (PVOID)&DPCSSDT;
	g_TimerInfoArray[2].DeferredRoutine = (PVOID)&DPCMSRs;

	// Initializing the IDT, MSR and SSDT DPCs with their relevant DPC routines
	KeInitializeDpc(&DPC_IDT, (PKDEFERRED_ROUTINE)DPCInterruptDispatchTable, nullptr);
	KeInitializeDpc(&DPC_MSRs, (PKDEFERRED_ROUTINE)DPCMSRs, nullptr);
	KeInitializeDpc(&DPC_SSDT, (PKDEFERRED_ROUTINE)DPCSSDT, nullptr);

	g_TimerInfoArray[0].Dpc = &DPC_IDT;
	g_TimerInfoArray[1].Dpc = &DPC_SSDT;
	g_TimerInfoArray[2].Dpc = &DPC_MSRs;

	KdPrint(("DPC_IDT address: 0x%p\n", &DPC_IDT));
	KdPrint(("TimerIDT address: 0x%p\n", &TimerIDT));

	// Setting the timer with a certain Period, DueTime, and their DPCs
	KeSetTimerEx(&TimerIDT, DueTime, Period, &DPC_IDT);
	KeSetTimerEx(&TimerMSRs, DueTime, Period, &DPC_MSRs);
	KeSetTimerEx(&TimerSSDT, DueTime, Period, &DPC_SSDT);

	// When it's currently being invoked, successfully loads and unloads for the first time
	// When attempting to load the driver for the second time, we get a BSOD

	g_Verifier = new(1, NonPagedPool)IntegrityCheck(g_TimerInfoArray);

	/*
		it's possible to dynamically get the address of exported kernel variables (yes, variables not only functions)
		using the MmGetSystemRoutineAddress() kernel function.

		The KdDebuggerEnabled variable, is global exported kernel variable, which means that it's possible to
		dynamically resolve the address of it using the MmGetSystemRoutineAddress() as done below:

		UNICODE_STRING KdDebuggerEnabledName = RTL_CONSTANT_STRING(L"KdDebuggerEnabled");
		PVOID KdDebuggerEnabledAddress = MmGetSystemRoutineAddress(&KdDebuggerEnabledName);
		KdPrint(("[*] PatchGuardEncryptorDriver: nt!KdDebuggerEnabled global kernel variable at address: 0x%p\n", KdDebuggerEnabledAddress));	
	*/


	return status;
}
```

`PatchGuardEncryptorDriver/PatchGuardEncryptorDriver.inf`:

```inf
;
; PatchGuardEncryptorDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=PatchGuardEncryptorDriver.cat
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 13

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$.10.0...16299 ; %13% support introduced in build 16299

[Standard.NT$ARCH$.10.0...16299]

[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName="PatchGuardEncryptorDriver Source Disk"

```

`PatchGuardEncryptorDriver/PatchGuardEncryptorDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DBA3F6EF-9864-423F-A432-96B254CAEB06}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>PatchGuardEncryptorDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
    </ClCompile>
    <Link>
      <AdditionalOptions>/IGNORE:4210 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IntegrityChecker.cpp" />
    <ClCompile Include="PatchGuardEncryptorDriver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Helper.h" />
    <ClInclude Include="IntegrityChecker.h" />
    <ClInclude Include="MSRs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PatchGuardEncryptorDriver/PatchGuardEncryptorDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="PatchGuardEncryptorDriver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IntegrityChecker.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Helper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MSRs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IntegrityChecker.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# PatchGuardEncryptorDriver

I created My own **Patch Guard** driver that dynamically monitors the following mechanisms in kernel space:
- **System Service Descriptor Table** (**SSDT**)
- **Interrupt Dispatch Table** (**IDT**)
- **Model Specific Registers** (**MSRs**)

At `DriverEntry()` the driver starts by initially capturing each mechanism's state (**initial MSR state**, **initial IDT state** and **initial SSDT state**) at **driver load time** and saves it into **kernel memory**.

The monitoring is performed through allocating **3 timers** (`_KTIMER` objects) in **kernel space** (for each monitored mechanism) and each timer has an associated **DPC** attached to it.
- The **SSDT monitoring timer** has an **associated DPC routine** that gets the **base address** of the **SSDT** and compares each **SSDT entry** with the inital state's relative **SSDT** entry. The number of **SSDT** entries available on the system is resolved at `DriverEntry()` using the function `FillNumberOfSSDTEntries()` function in the driver and is saved into a global driver variable.
   
- The **IDT monitoring timer** has an **associated DPC routine** that runs over each entry in the **IDT** and compares each entry with the initial **IDT** entry value captured at driver load.

- The **MSRs monitoring timer** has an **associated DPC routine** that read the values of certain MSRs and dynamically compares it to their relevant MSR state.
  The number of **MSRs** that are being checked is different based on if **VMX** is available on the system (I performed the check by reading the `CR4.VMXE` bit value which is the **13th bit** in the **CR4 register**).

At the **start of the Each DPC routine**, the **IRQL** of the processor immediately increases to **HIGH_LEVEL** (**0xf**), this is because an attacker can potentially overwrite an entry in one of the monitored mechanisms and also immediately increase the **IRQL** to **HIGH_LEVEL** to avoid the timer's DPCs from invoking.
At the **end of the DPC routine**, the **IRQL** is lowered back to **DISPATCH_LEVEL** (**0x2**) using the `KeLowerIrql()` function.

The second thing I implemented is an `IntegrityCheck` structure that allocates another 3 timer (`_KTIMER`) objects.
Each `IntegrityCheck` timer object is responsible to perform an integrity check on its relative **patch guard** timer.

Each integrity check timer has an associated **DPC** that is responsible to check that the following didn't occur:
- The `_KTIMER->Dpc` field of the patch guard timer object isn't being overwritten with a malicious `_KDPC` routine potentially overwritten by an attacker.
- The `DeferredRoutine` value of the patch guard's DPC isn't being overwritten with a malicious function pointer by an attacker.

The first check with `_KTIMER->Dpc` was a bit tricky since the value of the **DPC** shown in the `_KTIMER` field is bitwise manipulated:
```c++
dt nt!_KTIMER 0xFFFFF8073BA68080
```
![image](https://github.com/user-attachments/assets/c55d1597-541f-45f6-999c-3f0c49d6569c)

To discover how it's constructed, I needed to reverse the `KeSetTimerEx()` kernel function:
![image](https://github.com/user-attachments/assets/2651340f-f358-45e0-83b5-e80df180d2f7)

After reversing the bitwise operations shown above, I created a function called `CalculateTimerDPCValue()` and a helper function called `ROR8()` function.
The `CalculateTimerDPCValue()` takes 2 arguments:
- The `_KDPC` base address of the associated timer. 
- The `_KTIMER` kernel object base address.

```c++
// Right rotate function for 64-bit values
static inline ULONG_PTR ROR8(ULONG_PTR value, BYTE shift)
{
	return (value >> shift) | (value << (64 - shift));
}

ULONG_PTR IntegrityCheck::CalculateTimerDPCValue(PKDPC Dpc, PKTIMER KTimer)
{
	ULONG_PTR KernelBaseAddress = (ULONG_PTR)g_KernelInfo->KernelBaseAddress;

	// Offsets for nt!KiWaitAlways and nt!KiWaitNever (These offsets change between builds!!!)
	ULONG_PTR KiWaitAlwaysAddress = KernelBaseAddress + 0x00fc5260;
	ULONG_PTR KiWaitNeverAddress = KernelBaseAddress + 0x00fc4f80;

	// Read values from memory
	ULONG_PTR KiWaitAlwaysValue = *(ULONG_PTR*)KiWaitAlwaysAddress;
	ULONG_PTR KiWaitNeverValue = *(ULONG_PTR*)KiWaitNeverAddress;

	// Read the shift count from KiWaitNever (ensuring it's a valid rotation amount)
	BYTE shift = *(BYTE*)(KiWaitNeverAddress) & 0x3F; // Masking to avoid invalid shifts (0x3F = 63)

	ULONG_PTR intermediate = _byteswap_uint64((ULONG_PTR)Dpc ^ KiWaitAlwaysValue);
	ULONG_PTR rotated = ROR8(intermediate ^ (ULONG_PTR)KTimer, shift);

	return rotated ^ KiWaitNeverValue;
}
```

After calculating the bitwised **DPC** value of the relative patch guard timer's **DPC**, I compared this value, with the currently setted value within the patch guard's timer.

The second check performed takes the original `DeferredRoutine` function pointer associated with the patch guard timer's DPC and dynamically compares it with the current `DeferredRoutine` function pointer setted in the `_KDPC` object.

These checks are performed in each IntegrityCheck timer responsible for the integrity of each patch guard's timer initially created by the driver.

--PLEASE NOTE THAT THE OFFSETS USED IN THIS DRIVER ARE DIFFERENT BETWEEN OS BUILDS!!--

```