Project Path: arc_gmh5225_BEDaisy_f5j_vf33

Source Tree:

```txt
arc_gmh5225_BEDaisy_f5j_vf33
├── README.md
└── bedaisy-master
    └── BEDaisy
        ├── BEDaisy.filters
        ├── BEDaisy.vcxproj
        ├── BEDaisy.vcxproj.filters
        ├── DriverEntry.cpp
        ├── DriverUtil.cpp
        ├── DriverUtil.h
        ├── Hooks.cpp
        ├── Hooks.h
        ├── Memory.cpp
        ├── Memory.h
        └── Types.h

```

`README.md`:

```md
# BEDaisy

reverse engineering of bedaisy.sys (battleyes kernel driver). By registering on image load callbacks and IAT hooking BEDaisy's `MmGetSystemRoutineAddress` we can simply hook any imports
we want and have control flow over subsequent functions.

<img src="https://imgur.com/NFGyGrY.png"/>

# APCS

The below function will be executed in each thread that bedaisy registers an APC on.

```cpp
__int64 __usercall apc_callback@<rax>(char _CL@<cl>, char _BH@<bh>, __int64 *a3@<r9>)
{
  __int64 v4; // rbx

  __asm { rcl     bh, cl }
  v4 = *a3;
  *(_DWORD *)(v4 + 2160) = RtlWalkFrameChain(*a3 + 0x70, 256i64, 0i64);
  return KeSetEvent(v4 + 88, 0i64, 0i64);
}
```

Registeration of APCS:

```cpp
    status = PsLookupThreadByThreadId(thread_id, &some_pethread);
    v17 = 0;
    if ( (int)status >= 0 )
    {
      allocated_pool = ExAllocatePool(0x200i64, 0x878i64);
      allocated_pool_1 = allocated_pool;
      allocated_pool_2 = allocated_pool;
      if ( allocated_pool )
      {
        allocated_pool_plus_58 = allocated_pool + 0x58;
        KeInitializeEvent((PRKEVENT)(allocated_pool + 0x58), NotificationEvent, 0);
        __asm { rcl     cx, 0C6h }
        LOBYTE(v77) = 0;
        KeInitializeApc(allocated_pool_2, some_pethread, 0i64, j_apc_callback, 0i64, 0i64, v77, 0i64);
        if ( (unsigned __int8)KeInsertQueueApc(allocated_pool_2, allocated_pool_2, 0i64, 2i64) )
```

# HWID

BEDaisy opens a handle to DR0 (disk.sys).

```
02646022	190.98799133	[GoodEye]ZwOpenFile called from: 0xFFFFF804DEFDB904	
02646023	190.98799133	[GoodEye]     - ZwOpenFile(\Device\Harddisk0\DR0)	
02646024	190.98869324	[GoodEye]     - ZwOpenFile handle result: 0xFFFFFFFF80003E28
```

BEDaisy then sends a few IOCTL's to disk.sys using `ZwDeviceIoControlFile`
```
02646049	190.99142456	[GoodEye]ZwDeviceIoControlFile Called From 0xFFFFF804DEFDB94A	
02646050	190.99143982	[GoodEye]     - FileHandle: 0xFFFFFFFF80003E28	
02646051	190.99143982	[GoodEye]     - IoControlCode: 0x00000000002D1400	
02646052	190.99143982	[GoodEye]     - OutputBufferLength: 0x0000000000000008	
02646053	190.99143982	[GoodEye]     - InoutBufferLength: 0x000000000000000C

02646059	190.99192810	[GoodEye]ZwDeviceIoControlFile Called From 0xFFFFF804DEFDB960	
02646060	190.99192810	[GoodEye]     - FileHandle: 0xFFFFFFFF80003E28	
02646061	190.99192810	[GoodEye]     - IoControlCode: 0x00000000002D1400	
02646062	190.99192810	[GoodEye]     - OutputBufferLength: 0x0000000000000000	
02646063	190.99194336	[GoodEye]     - InoutBufferLength: 0x000000000000000C

02646072	190.99209595	[GoodEye]ZwDeviceIoControlFile Called From 0xFFFFF804DEFDB9B1	
02646073	190.99211121	[GoodEye]     - FileHandle: 0xFFFFFFFF80003E28	
02646074	190.99211121	[GoodEye]     - IoControlCode: 0x000000000007C088	
02646075	190.99211121	[GoodEye]     - OutputBufferLength: 0x0000000000000211	
02646076	190.99211121	[GoodEye]     - InoutBufferLength: 0x0000000000000021	
```

# IRP

BEDaisy checks the IRP's of every single loaded driver. Below is the checks done on dxgkrnl.sys on windows 10-2004. Base address of dxgkrnl.sys is `0xfffff80498f10000`.

```
00042942	92.55983734	[GoodEye]gh_wcsnicmp called from: 0xFFFFF804DEFDD874	
00042943	92.55983734	[GoodEye]     - string1: C:\Windows\System32\drivers\dxgkrnl.sys	
00042944	92.55983734	[GoodEye]     - string2: C:\Windows\System32\drivers\dxgkrnl.sys	
00042945	92.55983734	[GoodEye]     - count: 0x27	
00042946	92.55996704	[GoodEye]MmIsAddressValid Called From: 0xFFFFF804DEFDD8B6	
00042947	92.55996704	[GoodEye]     - NonPaged VirtualAddress: 0xFFFFF80498F10000	// base address of dxgkrnl.sys
00042951	92.56208801	[GoodEye]MmIsAddressValid Called From: 0xFFFFF804DEFE1116	
00042952	92.56209564	[GoodEye]     - NonPaged VirtualAddress: 0xFFFFF8049905E400	// address of DxgkCreateClose
00042953	92.56209564	[GoodEye]MmIsAddressValid Called From: 0xFFFFF804DEFE1116	
00042956	92.56209564	[GoodEye]     - NonPaged VirtualAddress: 0xFFFFF8049905E400	// address of DxgkCreateClose
00042957	92.56209564	[GoodEye]MmIsAddressValid Called From: 0xFFFFF804DEFE1116	
00042980	92.56213379	[GoodEye]     - NonPaged VirtualAddress: 0xFFFFF80498F516A0	// address of DxgkDeviceIoctl
00042981	92.56213379	[GoodEye]MmIsAddressValid Called From: 0xFFFFF804DEFE1116	
00042982	92.56213379	[GoodEye]     - NonPaged VirtualAddress: 0xFFFFF80499059670	// address of DxgkInternalDeviceIoctl
```

# Imports

All import addresses are stored in the `.data` section of the driver and can easily be changed to hook imported functions.

<img src="https://imgur.com/hafZdDd.png"/>

```

`bedaisy-master/BEDaisy/BEDaisy.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`bedaisy-master/BEDaisy/BEDaisy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1F1679F7-60D4-4170-8FE1-FA6B49D7D229}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ioctl_meme</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
    <ProjectName>BEDaisy</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <NoEntryPoint>false</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <NoEntryPoint>false</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <NoEntryPoint>false</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <NoEntryPoint>false</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <NoEntryPoint>false</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <NoEntryPoint>false</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <NoEntryPoint>false</NoEntryPoint>
      <AdditionalDependencies>FltMgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Inf>
      <SpecifyArchitecture>false</SpecifyArchitecture>
      <SpecifyDriverVerDirectiveVersion>false</SpecifyDriverVerDirectiveVersion>
      <SpecifyDriverVerDirectiveDate>false</SpecifyDriverVerDirectiveDate>
    </Inf>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <NoEntryPoint>false</NoEntryPoint>
      <AdditionalDependencies>FltMgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp" />
    <ClCompile Include="DriverUtil.cpp" />
    <ClCompile Include="Hooks.cpp" />
    <ClCompile Include="Memory.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverUtil.h" />
    <ClInclude Include="Hooks.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Types.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`bedaisy-master/BEDaisy/BEDaisy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="DriverUtil.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Hooks.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Memory.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverUtil.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Hooks.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Types.h">
      <Filter>Headers</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Headers">
      <UniqueIdentifier>{b2f67e29-768d-4980-9e9e-c112e9c7635e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{937d350f-e918-446d-9ee9-1a9d69013f1b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`bedaisy-master/BEDaisy/DriverEntry.cpp`:

```cpp
#include "Types.h"
#include "DriverUtil.h"
#include "Hooks.h"

using namespace DriverUtil;
using namespace Hooks;

void TdDeviceUnload(
    DRIVER_OBJECT* DriverObject
)
{
    PsRemoveLoadImageNotifyRoutine(&LoadImageNotifyRoutine);
}

NTSTATUS TdDeviceClose(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP  Irp
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(
    _In_ PDRIVER_OBJECT  DriverObject,
    _In_ PUNICODE_STRING RegistryPath
)
{
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = &TdDeviceClose;
    DriverObject->DriverUnload = &TdDeviceUnload;

    PsSetLoadImageNotifyRoutine(&LoadImageNotifyRoutine);
	DBG_PRINT("Installed ImageNotifyRoutine... 0x%p", &LoadImageNotifyRoutine);
    return STATUS_SUCCESS;
}
```

`bedaisy-master/BEDaisy/DriverUtil.cpp`:

```cpp
#include "DriverUtil.h"

namespace DriverUtil
{
    // This function was created with help from wlan
    //
    // Links to his work: 
    // https://github.com/not-wlan/driver-hijack
    // https://www.unknowncheats.me/forum/c-and-c-/274073-iterating-driver_objects.html
    // https://www.unknowncheats.me/forum/anti-cheat-bypass/274881-memedriver-driver-object-hijack-poc.html

    PDRIVER_OBJECT GetDriverObject(PUNICODE_STRING lpDriverName)
    {
        HANDLE handle{};
        OBJECT_ATTRIBUTES attributes{};
        UNICODE_STRING directory_name{};
        PVOID directory{};
        BOOLEAN success = FALSE;
        FAST_IO_DISPATCH fastIoDispatch;
        bool installedHook = false;
        RtlZeroMemory(&fastIoDispatch, sizeof(FAST_IO_DISPATCH));
        RtlInitUnicodeString(&directory_name, L"\\Driver");
        InitializeObjectAttributes(
            &attributes,
            &directory_name,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
        );

        // open OBJECT_DIRECTORY for \\Driver
        auto status = ZwOpenDirectoryObject(
            &handle,
            DIRECTORY_ALL_ACCESS,
            &attributes
        );

        if (!NT_SUCCESS(status))
        {
            DBG_PRINT("ZwOpenDirectoryObject Failed");
            return NULL;
        }

        // Get OBJECT_DIRECTORY pointer from HANDLE
        status = ObReferenceObjectByHandle(
            handle,
            DIRECTORY_ALL_ACCESS,
            nullptr,
            KernelMode,
            &directory,
            nullptr
        );

        if (!NT_SUCCESS(status))
        {
            DBG_PRINT("ObReferenceObjectByHandle Failed");
            ZwClose(handle);
            return NULL;
        }

        const auto directory_object = POBJECT_DIRECTORY(directory);
        if (!directory_object)
            return NULL;

        ExAcquirePushLockExclusiveEx(&directory_object->Lock, 0);

        // traverse hash table with 37 entries
        // when a new object is created, the object manager computes a hash value in the range zero to 36 from the object name and creates an OBJECT_DIRECTORY_ENTRY.    
        // http://www.informit.com/articles/article.aspx?p=22443&seqNum=7
        for (auto entry : directory_object->HashBuckets)
        {
            if (!entry)
                continue;

            while (entry && entry->Object)
            {
                auto driver = PDRIVER_OBJECT(entry->Object);
                if (!driver)
                    continue;

                if (wcscmp(driver->DriverExtension->ServiceKeyName.Buffer, lpDriverName->Buffer) == 0)
                    return driver;
            }
        }

        ExReleasePushLockExclusiveEx(&directory_object->Lock, 0);
        // Release the acquired resources back to the OS
        ObDereferenceObject(directory);
        ZwClose(handle);
        //TODO remove
        return NULL;
    }

    PVOID GetDriverBase(LPCSTR module_name)
    {
        ULONG bytes{};
        NTSTATUS status = ZwQuerySystemInformation(
            SystemModuleInformation,
            NULL,
            bytes,
            &bytes
        );
        if (!bytes)
            return NULL;
        PRTL_PROCESS_MODULES modules =
            (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, POOLTAG);

        if (modules)
        {
            status = ZwQuerySystemInformation(
                SystemModuleInformation,
                modules,
                bytes,
                &bytes
            );

            if (!NT_SUCCESS(status))
            {
                ExFreePoolWithTag(modules, POOLTAG);
                return NULL;
            }
            
            PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
            PVOID module_base{}, module_size{};
            for (ULONG i = 0; i < modules->NumberOfModules; i++)
            {
                if (strcmp(reinterpret_cast<char*>(module[i].FullPathName + module[i].OffsetToFileName), module_name) == 0)
                {
                    module_base = module[i].ImageBase;
                    module_size = (PVOID)module[i].ImageSize;
                    break;
                }
            }
            ExFreePoolWithTag(modules, POOLTAG);
            return module_base;
        }
        return NULL;
    }

    PVOID GetSystemModuleExport(LPCSTR ModName, LPCSTR RoutineName)
    {
        PVOID result = GetDriverBase(ModName);
        if (!result)
            return NULL;
        return RtlFindExportedRoutineByName(result, RoutineName);
    }

    PVOID IATHook(PVOID lpBaseAddress, CHAR* lpcStrImport, PVOID lpFuncAddress)
    {
        if (!lpBaseAddress || !lpcStrImport || !lpFuncAddress)
            return NULL;

        PIMAGE_DOS_HEADER dosHeaders = 
            reinterpret_cast<PIMAGE_DOS_HEADER>(lpBaseAddress);

        PIMAGE_NT_HEADERS ntHeaders = 
            reinterpret_cast<PIMAGE_NT_HEADERS>(
                reinterpret_cast<DWORD_PTR>(lpBaseAddress) + dosHeaders->e_lfanew);

        IMAGE_DATA_DIRECTORY importsDirectory = 
            ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

        PIMAGE_IMPORT_DESCRIPTOR importDescriptor = 
            reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(importsDirectory.VirtualAddress + (DWORD_PTR)lpBaseAddress);

        LPCSTR libraryName = NULL;
        PVOID result = NULL;
        PIMAGE_IMPORT_BY_NAME functionName = NULL;

        if (!importDescriptor) 
            return NULL;

        while (importDescriptor->Name != NULL)
        {
            libraryName = (LPCSTR)importDescriptor->Name + (DWORD_PTR)lpBaseAddress;
            if (GetDriverBase(libraryName))
            {
                PIMAGE_THUNK_DATA originalFirstThunk = NULL, firstThunk = NULL;
                originalFirstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)lpBaseAddress + importDescriptor->OriginalFirstThunk);
                firstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)lpBaseAddress + importDescriptor->FirstThunk);
                while (originalFirstThunk->u1.AddressOfData != NULL)
                {
                    functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)lpBaseAddress + originalFirstThunk->u1.AddressOfData);
                    if (strcmp(functionName->Name, lpcStrImport) == 0)
                    {
                        // save old function pointer
                        result = reinterpret_cast<PVOID>(firstThunk->u1.Function);
                        Memory::WriteProtectOff();
                        // swap address
                        firstThunk->u1.Function = reinterpret_cast<ULONG64>(lpFuncAddress);
                        Memory::WriteProtectOn();
                        return result;
                    }
                    ++originalFirstThunk;
                    ++firstThunk;
                }
            }
            importDescriptor++;
        }
        return NULL;
    }

    PVOID DriverIATHook(PDRIVER_OBJECT pDriverObject, CHAR* lpcStrImport, PVOID lpFuncAddress)
    {
        if (!pDriverObject || !lpcStrImport)
            return NULL;
        return IATHook(pDriverObject->DriverStart, lpcStrImport, lpFuncAddress);
    }

    VOID DumpDriver(PDRIVER_OBJECT lpDriverObject)
    {
        DumpDriver(lpDriverObject->DriverStart);
    }

    VOID DumpDriver(PVOID lpBaseAddress)
    {
        if (!lpBaseAddress || *(short*) lpBaseAddress != 0x5A4D)
            return;

        PIMAGE_DOS_HEADER dosHeaders =
            reinterpret_cast<PIMAGE_DOS_HEADER>(lpBaseAddress);

        PIMAGE_NT_HEADERS ntHeaders =
            reinterpret_cast<PIMAGE_NT_HEADERS>(
                reinterpret_cast<DWORD_PTR>(lpBaseAddress) + dosHeaders->e_lfanew);

        HANDLE             hFile;
        UNICODE_STRING     uniName;
        OBJECT_ATTRIBUTES  objAttr;
        IO_STATUS_BLOCK    ioStatusBlock;
        LARGE_INTEGER      offset{};

        RtlInitUnicodeString(&uniName, L"\\DosDevices\\C:\\DriverDump.sys");
        InitializeObjectAttributes(&objAttr, &uniName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL, NULL
        );

        ZwCreateFile(&hFile,
            GENERIC_WRITE,
            &objAttr,
            &ioStatusBlock, 
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            NULL,
            FILE_OVERWRITE_IF,
            FILE_SYNCHRONOUS_IO_NONALERT,
            NULL, 
            NULL
        );

        ZwWriteFile(
            hFile,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            lpBaseAddress,
            ntHeaders->OptionalHeader.SizeOfImage,
            &offset,
            NULL
        );

        ZwClose(hFile);
    }

    void MemDump(void* BaseAddress, unsigned Size)
    {
        if (!BaseAddress || !Size)
            return;

        HANDLE             h_file;
        UNICODE_STRING     name;
        OBJECT_ATTRIBUTES  attr;
        IO_STATUS_BLOCK    status_block;
        LARGE_INTEGER      offset{ NULL };

        RtlInitUnicodeString(&name, L"\\DosDevices\\C:\\dump.bin");
        InitializeObjectAttributes(&attr, &name,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL, NULL
        );

        auto status = ZwCreateFile(
            &h_file,
            GENERIC_WRITE,
            &attr,
            &status_block,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            NULL,
            FILE_OVERWRITE_IF,
            FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            NULL
        );

        status = ZwWriteFile(
            h_file,
            NULL,
            NULL,
            NULL,
            &status_block,
            BaseAddress,
            Size,
            &offset,
            NULL
        );
        ZwClose(h_file);
    }
}
```

`bedaisy-master/BEDaisy/DriverUtil.h`:

```h
#pragma once
#include <intrin.h>
#include "Types.h"
#include "Memory.h"

namespace DriverUtil
{
	PDRIVER_OBJECT GetDriverObject(PUNICODE_STRING lpDriverName);
	PVOID GetDriverBase(LPCSTR module_name);
	PVOID IATHook(PVOID lpBaseAddress, CHAR* lpcStrImport, PVOID lpFuncAddress);
	PVOID DriverIATHook(PDRIVER_OBJECT pDriverObject, CHAR* lpcStrImport, PVOID lpFuncAddress);

	PVOID GetSystemModuleExport(LPCSTR ModName, LPCSTR RoutineName);
	VOID DumpDriver(PVOID lpBaseAddress);
	VOID DumpDriver(PDRIVER_OBJECT lpDriverObject);
	void MemDump(void* BaseAddress, unsigned Size);
}
```

`bedaisy-master/BEDaisy/Hooks.cpp`:

```cpp
#include "Hooks.h"
#include <fltKernel.h>

namespace Hooks
{
    BOOLEAN gh_ExEnumHandleTable(
        PVOID HandleTable,
        PVOID EnumHandleProcedure,
        PVOID EnumParameter,
        PHANDLE Handle OPTIONAL
    )
    {
        DBG_PRINT("EnumHandleProcedure Called From: 0x%p, EnumHandleProcedure: 0x%p", _ReturnAddress(), EnumHandleProcedure);
        return TRUE;
    }

    NTSTATUS gh_ZwAllocateVirtualMemory(
        _In_    HANDLE    ProcessHandle,
        _Inout_ PVOID*    BaseAddress,
        _In_    ULONG_PTR ZeroBits,
        _Inout_ PSIZE_T   RegionSize,
        _In_    ULONG     AllocationType,
        _In_    ULONG     Protect
    )
    {
        DBG_PRINT("ZwAllocateVirtualMemory called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - ProcessHandle: 0x%p", ProcessHandle);
        if(BaseAddress)
            DBG_PRINT("     - BaseAddress (of allocation): 0x%p", *(ULONGLONG*)BaseAddress);
        if(RegionSize)
            DBG_PRINT("     - RegionSize: 0x%p", *(SIZE_T*)RegionSize);
        DBG_PRINT("     - Protect: 0x%p", Protect);

        return ZwAllocateVirtualMemory(
            ProcessHandle,
            BaseAddress,
            ZeroBits, 
            RegionSize,
            AllocationType, 
            Protect
        );
    }

    NTSTATUS gh_PsSetLoadImageNotifyRoutine(
        PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    )
    {
        DBG_PRINT("PsSetLoadImageNotifyRoutine called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - NotifyRoutine: 0x%p", NotifyRoutine);
        return PsSetLoadImageNotifyRoutine(NotifyRoutine);
    }

    NTSTATUS gh_ObRegisterCallbacks(
        POB_CALLBACK_REGISTRATION CallbackRegistration,
        PVOID* RegistrationHandle
    )
    {
        DBG_PRINT("ObRegisterCallbacks called from: 0x%p", _ReturnAddress());
        return ObRegisterCallbacks(
            CallbackRegistration,
            RegistrationHandle
        );
    }

    NTSTATUS gh_ZwQuerySystemInformation(
        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
        _Inout_   PVOID                    SystemInformation,
        _In_      ULONG                    SystemInformationLength,
        _Out_opt_ PULONG                   ReturnLength
    )
    {
        DBG_PRINT("ZwQuerySystemInformation called");
        DBG_PRINT("     - SystemInformationClass: 0x%p", SystemInformationClass);
        DBG_PRINT("     - SystemInformation: 0x%p", SystemInformation);
        DBG_PRINT("     - SystemInformationLength: 0x%p", SystemInformationLength);

        auto result = ZwQuerySystemInformation(
            SystemInformationClass,
            SystemInformation,
            SystemInformationLength,
            ReturnLength
        );

        if (SystemInformationLength && SystemInformation && ReturnLength && *ReturnLength)
        {
            switch (SystemInformationClass)
            {
            case SystemProcessInformation:
            {
                auto process_info = reinterpret_cast<PSYSTEM_PROCESS_INFORMATION>(SystemInformation);
                process_info->NextEntryOffset = NULL;
                DBG_PRINT("Spoofed SystemProcessInformation.....");
                break;
            }
            case SystemModuleInformation:
            {
                auto module_info = reinterpret_cast<PRTL_PROCESS_MODULES>(SystemInformation);
                module_info->NumberOfModules = 1;
                DBG_PRINT("Spoofed SystemModuleInformation.....");
                break;
            }
            default:
                break;
            }
        }
        return result;
    }

    NTSTATUS gh_PsSetCreateProcessNotifyRoutineEx(
        PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,
        BOOLEAN                           Remove
    )
    {
        DBG_PRINT("PsSetCreateProcessNotifyRoutineEx Called From 0x%p", _ReturnAddress());
        DBG_PRINT("     - NotifyRoutine: 0x%p", NotifyRoutine);
        DBG_PRINT("     - Remove: 0x%x", Remove);
        return PsSetCreateProcessNotifyRoutineEx(NotifyRoutine, Remove);
    }

    NTSTATUS gh_IoCreateDevice(
        PDRIVER_OBJECT  DriverObject,
        ULONG           DeviceExtensionSize,
        PUNICODE_STRING DeviceName,
        DEVICE_TYPE     DeviceType,
        ULONG           DeviceCharacteristics,
        BOOLEAN         Exclusive,
        PDEVICE_OBJECT* DeviceObject
    )
    {
        DBG_PRINT("================= BattlEye =================");
        DBG_PRINT("     - BattlEye IRP_MJ_DEVICE_CONTROL: 0x%p", DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]);
        DBG_PRINT("     - BattlEye IRP_MJ_READ: 0x%p", DriverObject->MajorFunction[IRP_MJ_READ]);
        DBG_PRINT("     - BattlEye IRP_MJ_WRITE: 0x%p", DriverObject->MajorFunction[IRP_MJ_WRITE]);

        return IoCreateDevice(
            DriverObject,
            DeviceExtensionSize,
            DeviceName,
            DeviceType,
            DeviceCharacteristics,
            Exclusive,
            DeviceObject
        );
    }

    NTSTATUS gh_PsSetCreateThreadNotifyRoutine(
        PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    )
    {
        DBG_PRINT("PsSetCreateThreadNotifyRoutine Called From 0x%p", _ReturnAddress());
        DBG_PRINT("     - NotifyRoutine: 0x%p", NotifyRoutine);
        return PsSetCreateThreadNotifyRoutine(NotifyRoutine);
    }

    PHYSICAL_ADDRESS gh_MmGetPhysicalAddress(
        PVOID BaseAddress
    )
    {
        DBG_PRINT("MmGetPhysicalAddress called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - BaseAddress (Virtual Address): 0x%p", BaseAddress);
        return MmGetPhysicalAddress(BaseAddress);
    }

    BOOLEAN gh_MmIsAddressValid(
        PVOID VirtualAddress
    )
    {
        DBG_PRINT("MmIsAddressValid Called From: 0x%p", _ReturnAddress());
        DBG_PRINT("     - NonPaged VirtualAddress: 0x%p", VirtualAddress);
        return MmIsAddressValid(VirtualAddress);
    }

    NTSTATUS gh_ZwDeviceIoControlFile(
        HANDLE           FileHandle,
        HANDLE           Event,
        PIO_APC_ROUTINE  ApcRoutine,
        PVOID            ApcContext,
        PIO_STATUS_BLOCK IoStatusBlock,
        ULONG            IoControlCode,
        PVOID            InputBuffer,
        ULONG            InputBufferLength,
        PVOID            OutputBuffer,
        ULONG            OutputBufferLength
    )
    {
        DBG_PRINT("ZwDeviceIoControlFile Called From 0x%p", _ReturnAddress());
        DBG_PRINT("     - FileHandle: 0x%p", FileHandle);
        DBG_PRINT("     - IoControlCode: 0x%p", IoControlCode);
        DBG_PRINT("     - OutputBufferLength: 0x%p", OutputBufferLength);
        DBG_PRINT("     - InoutBufferLength: 0x%p", InputBufferLength);
        const auto result = ZwDeviceIoControlFile(
            FileHandle,
            Event, 
            ApcRoutine, 
            ApcContext,
            IoStatusBlock,
            IoControlCode, 
            InputBuffer, 
            InputBufferLength, 
            OutputBuffer,
            OutputBufferLength
        );
        ULONG seed = 0x1000;
        for (auto idx = 0u; idx < OutputBufferLength; ++idx)
            *(unsigned char*)((unsigned char*)OutputBuffer + idx) = (unsigned char)RtlRandomEx(&seed);
        return result;
    }

    VOID gh_RtlInitAnsiString(
        PANSI_STRING          DestinationString,
        PCSZ SourceString
    )
    {
        DBG_PRINT("RtlInitAnsiString Called From: 0x%p", _ReturnAddress());
        DBG_PRINT("     - SourceString: 0x%s", SourceString);
        return RtlInitAnsiString(DestinationString, SourceString);
    }

    VOID gh_RtlInitUnicodeString(
        PUNICODE_STRING         DestinationString,
        PCWSTR SourceString
    )
    {
        DBG_PRINT("RtlInitUnicodeString Called From: 0x%p", _ReturnAddress());
        DBG_PRINT("     - SourceString: %ws", SourceString);
        return RtlInitUnicodeString(DestinationString, SourceString);
    }

    PVOID gh_MmMapIoSpace(
        PHYSICAL_ADDRESS    PhysicalAddress,
        SIZE_T              NumberOfBytes,
        MEMORY_CACHING_TYPE CacheType
    )
    {
        DBG_PRINT("MmMapIoSpace called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - PhysicalAddress: 0x%p", PhysicalAddress);
        DBG_PRINT("     - NumberOfBytes: 0x%p", NumberOfBytes);

        return MmMapIoSpace(
            PhysicalAddress,
            NumberOfBytes, 
            CacheType
        );
    }

    NTSTATUS gh_ZwOpenFile(
        PHANDLE            FileHandle,
        ACCESS_MASK        DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        PIO_STATUS_BLOCK   IoStatusBlock,
        ULONG              ShareAccess,
        ULONG              OpenOptions
    )
    {
        DBG_PRINT("ZwOpenFile called from: 0x%p", _ReturnAddress());
        if (ObjectAttributes)
            DBG_PRINT("     - ZwOpenFile(%ws)", ObjectAttributes->ObjectName->Buffer);

        const auto result = ZwOpenFile(
            FileHandle,
            DesiredAccess,
            ObjectAttributes,
            IoStatusBlock,
            ShareAccess,
            OpenOptions
        );
        DBG_PRINT("     - ZwOpenFile handle result: 0x%p", *(HANDLE*)FileHandle);
        return result;
    }

    void gh_KeStackAttachProcess(
        PRKPROCESS   PROCESS,
        PRKAPC_STATE ApcState
    )
    {
        DBG_PRINT("KeStackAttachProcess called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - Attaching to %s....", PsGetProcessImageFileName(PROCESS));
        KeStackAttachProcess(PROCESS, ApcState);
    }

    NTSTATUS gh_ZwCreateSection(
        PHANDLE            SectionHandle,
        ACCESS_MASK        DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        PLARGE_INTEGER     MaximumSize,
        ULONG              SectionPageProtection,
        ULONG              AllocationAttributes,
        HANDLE             FileHandle
    )
    {
        DBG_PRINT("ZwCreateSection called from: 0x%p", _ReturnAddress());
        const auto result = ZwCreateSection(
            SectionHandle, 
            DesiredAccess,
            ObjectAttributes,
            MaximumSize,
            SectionPageProtection,
            AllocationAttributes,
            FileHandle
        );
        DBG_PRINT("     - DesiredAccess: 0x%p", DesiredAccess);
        DBG_PRINT("     - SectionPageProtection: 0x%p", SectionPageProtection);
        DBG_PRINT("     - SectionHandle: 0x%p", *SectionHandle);
        DBG_PRINT("     - FileHandle: 0x%p", FileHandle);
        return result;
    }

    NTSTATUS gh_ObOpenObjectByName(
        __in POBJECT_ATTRIBUTES ObjectAttributes,
        __in_opt POBJECT_TYPE ObjectType,
        __in KPROCESSOR_MODE AccessMode,
        __inout_opt PACCESS_STATE AccessState,
        __in_opt ACCESS_MASK DesiredAccess,
        __inout_opt PVOID ParseContext,
        __out PHANDLE Handle
    )
    {
        DBG_PRINT("ObOpenObjectByName called from: 0x%p", _ReturnAddress());
        const auto result = ObOpenObjectByName(
            ObjectAttributes,
            ObjectType, 
            AccessMode,
            AccessState,
            DesiredAccess, 
            ParseContext,
            Handle
        );
        DBG_PRINT("     - ObjectName: %s", ObjectAttributes->ObjectName->Buffer);
        return result;
    }

    NTSTATUS gh_ZwMapViewOfSection(
        HANDLE          SectionHandle,
        HANDLE          ProcessHandle,
        PVOID*          BaseAddress,
        ULONG_PTR       ZeroBits,
        SIZE_T          CommitSize,
        PLARGE_INTEGER  SectionOffset,
        PSIZE_T         ViewSize,
        SECTION_INHERIT InheritDisposition,
        ULONG           AllocationType,
        ULONG           Win32Protect
    )
    {
        const auto result = ZwMapViewOfSection(
            SectionHandle, 
            ProcessHandle,
            BaseAddress,
            ZeroBits, 
            CommitSize,
            SectionOffset,
            ViewSize, 
            InheritDisposition, 
            AllocationType, 
            Win32Protect
        );

        DBG_PRINT("ZwMapViewOfSection called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - SectionHandle: 0x%p", SectionHandle);
        DBG_PRINT("     - ProcessHandle: 0x%p", ProcessHandle);
        DBG_PRINT("     - ViewSize: 0x%p", *ViewSize);
        DBG_PRINT("     - Win32Protect: 0x%p", Win32Protect);
        return result;
    }

    NTSTATUS gh_MmCopyVirtualMemory
    (
        PEPROCESS SourceProcess,
        PVOID SourceAddress,
        PEPROCESS TargetProcess,
        PVOID TargetAddress,
        SIZE_T BufferSize,
        KPROCESSOR_MODE PreviousMode,
        PSIZE_T ReturnSize
    )
    {
        DBG_PRINT("MmCopyVirtualMemory called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - SourceProcess: %s", PsGetProcessImageFileName(SourceProcess));
        DBG_PRINT("     - SourceAddress: 0x%p", SourceAddress);
        DBG_PRINT("     - TargetProcess: %s", PsGetProcessImageFileName(TargetProcess));
        DBG_PRINT("     - TargetAddress: 0x%p", TargetAddress);
        DBG_PRINT("     - BufferSize: 0x%p", BufferSize);

        const auto result = MmCopyVirtualMemory(
            SourceProcess, 
            SourceAddress,
            TargetProcess, 
            TargetAddress, 
            BufferSize,
            PreviousMode,
            ReturnSize
        );
        return result;
    }

    void gh_IofCompleteRequest(
        PIRP  Irp,
        CCHAR PriorityBoost
    )
    {
        auto StackLocation = IoGetCurrentIrpStackLocation(Irp);
        DBG_PRINT("IofCompleteRequest called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - Request Called From: %s", PsGetProcessImageFileName(IoGetCurrentProcess()));
        switch (StackLocation->MajorFunction)
        {
        case IRP_MJ_DEVICE_CONTROL:
            DBG_PRINT("     - IRP_MJ_DEVICE_CONTROL!");
            DBG_PRINT("     - IoControlCode:  0x%p", StackLocation->Parameters.DeviceIoControl.IoControlCode);
            DBG_PRINT("     - InputBufferLength: 0x%p", StackLocation->Parameters.DeviceIoControl.InputBufferLength);
            DBG_PRINT("     - OutputBufferLength: 0x%p", StackLocation->Parameters.DeviceIoControl.OutputBufferLength);
            DBG_PRINT("     - UserBuffer: 0x%p", Irp->UserBuffer);
            DBG_PRINT("     - MdlAddress: 0x%p", Irp->MdlAddress);
            DBG_PRINT("     - SystemBuffer: 0x%p", Irp->AssociatedIrp.SystemBuffer);
            break;
        case IRP_MJ_READ:
            DBG_PRINT("     - IRP_MJ_READ!");
            DBG_PRINT("     - ReadSize: 0x%p", StackLocation->Parameters.Read.Length);
            DBG_PRINT("     - UserBuffer: 0x%p", Irp->UserBuffer);
            DBG_PRINT("     - MdlAddress: 0x%p", Irp->MdlAddress);
            DBG_PRINT("     - SystemBuffer: 0x%p", Irp->AssociatedIrp.SystemBuffer);
            break;
        case IRP_MJ_WRITE:
            DBG_PRINT("     - IRP_MJ_WRITE!");
            DBG_PRINT("     - WriteSize: 0x%p", StackLocation->Parameters.Write.Length);
            DBG_PRINT("     - UserBuffer: 0x%p", Irp->UserBuffer);
            DBG_PRINT("     - MdlAddress: 0x%p", Irp->MdlAddress);
            DBG_PRINT("     - SystemBuffer: 0x%p", Irp->AssociatedIrp.SystemBuffer);
            break;
        default:
            DBG_PRINT("Unkown Major Function Type: 0x%p", StackLocation->MajorFunction);
            break;
        }
        IofCompleteRequest(Irp, PriorityBoost);
    }

    int gh_stricmp(
        const char* string1,
        const char* string2
    )
    {
        DBG_PRINT("_stricmp called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - string1: %s", string1);
        DBG_PRINT("     - string2: %s", string2);
        return reinterpret_cast<decltype(&stricmp)>(DriverUtil::GetSystemModuleExport("ntoskrnl.exe", "stricmp"))(string1, string2);
    }

    int gh_strnicmp(
        const char* string1,
        const char* string2,
        size_t count
    )
    {
        DBG_PRINT("_strnicmp called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - string1: %s", string1);
        DBG_PRINT("     - string2: %s", string2);
        DBG_PRINT("     - count: 0x%x", count);
        return reinterpret_cast<decltype(&strnicmp)>(DriverUtil::GetSystemModuleExport("ntoskrnl.exe", "strnicmp"))(string1, string2, count);
    }

    int gh_wcsncmp(const wchar_t* wcs1, const wchar_t* wcs2, size_t num)
    {
        DBG_PRINT("gh_wcsncmp called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - string1: %ws", wcs1);
        DBG_PRINT("     - string2: %ws", wcs2);
        DBG_PRINT("     - count: 0x%x", num);
        return wcsncmp(wcs1, wcs2, num);
    }

    int gh_wcsnicmp(
        const wchar_t* string1,
        const wchar_t* string2,
        size_t count
    )
    {
        DBG_PRINT("gh_wcsnicmp called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - string1: %ws", string1);
        DBG_PRINT("     - string2: %ws", string2);
        DBG_PRINT("     - count: 0x%x", count);
        return wcsncmp(string1, string2, count);
    }

    wchar_t* gh_wcsncat(wchar_t* dest, const wchar_t* src, size_t count)
    {
        DBG_PRINT("wcsncat called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - dest: %ws", dest);
        DBG_PRINT("     - src: %ws", src);
        DBG_PRINT("     - count: 0x%x", count);
        auto result = wcsncat(dest, src, count);
        DBG_PRINT("     - result: %ws", result);
        return result;
    }

    void gh_KeInitializeEvent(
        PRKEVENT   Event,
        EVENT_TYPE Type,
        BOOLEAN    State
    )
    {
        DBG_PRINT("KeInitializeEvent called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - Event: 0x%p", Event);
        DBG_PRINT("     - Type: 0x%x", Type);
        DBG_PRINT("     - State: 0x%x", State);
        KeInitializeEvent(Event, Type, State);
    }

    PVOID gh_ExAllocatePoolWithTag(
        POOL_TYPE   PoolType,
        SIZE_T      NumberOfBytes,
        ULONG       Tag
    )
    {
        auto result = ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
        DBG_PRINT("ExAllocatePoolWithTag called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - PoolType: 0x%x", PoolType);
        DBG_PRINT("     - NumberOfBytes: 0x%x", NumberOfBytes);
        DBG_PRINT("     - Tag: 0x%x", Tag);
        DBG_PRINT("     - Allocate Pool at: 0x%p", result);
        return result;
    }

    PVOID gh_ExAllocatePool(
        POOL_TYPE PoolType,
        SIZE_T    NumberOfBytes
    )
    {
        auto result = ExAllocatePool(PoolType, NumberOfBytes);
        DBG_PRINT("ExAllocatePool called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - PoolType: 0x%x", PoolType);
        DBG_PRINT("     - NumberOfBytes: 0x%x", NumberOfBytes);
        DBG_PRINT("     - Allocate Pool at: 0x%p", result);
        return result;
    }

    void gh_ExFreePoolWithTag(
        PVOID P,
        ULONG Tag
    )
    {
        DBG_PRINT("ExFreePoolWithTag called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - Freeing pool at: 0x%p", P);
        DBG_PRINT("     - Pool Tag: 0x%x", Tag);
        return ExFreePoolWithTag(P, Tag);
    }

    void gh_ProbeForRead(
        volatile VOID* Address,
        SIZE_T              Length,
        ULONG               Alignment
    )
    {
        DBG_PRINT("ProbeForRead called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - Address: 0x%p", Address);
        DBG_PRINT("     - Length: 0x%x", Length);
        DBG_PRINT("     - Alignment: 0x%x", Alignment);

        __try
        {
            ProbeForRead(Address, Length, Alignment);
        }
        __except (STATUS_ACCESS_VIOLATION | STATUS_DATATYPE_MISALIGNMENT) {}
    }

    void gh_ProbeForWrite(
        volatile VOID* Address,
        SIZE_T        Length,
        ULONG         Alignment
    )
    {
        DBG_PRINT("ProbeForWrite called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - Address: 0x%p", Address);
        DBG_PRINT("     - Length: 0x%x", Length);
        DBG_PRINT("     - Alignment: 0x%x", Alignment);

        __try
        {
            ProbeForWrite(Address, Length, Alignment);
        }
        __except (STATUS_ACCESS_VIOLATION | STATUS_DATATYPE_MISALIGNMENT) {}
    }

    NTSTATUS gh_PsCreateSystemThread(
        PHANDLE            ThreadHandle,
        ULONG              DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        HANDLE             ProcessHandle,
        PCLIENT_ID         ClientId,
        PKSTART_ROUTINE    StartRoutine,
        PVOID              StartContext
    )
    {
        DBG_PRINT("PsCreateSystemThread called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - StartRoutine: 0x%p", StartRoutine);
        DBG_PRINT("     - StartContext: 0x%p", StartContext);
        DBG_PRINT("     - ProcessHandle: 0x%p", ProcessHandle);
        DBG_PRINT("     - ClientId Pointer: 0x%p", ClientId);
        if (ClientId)
        {
            DBG_PRINT("     - ClientId->ProcessId: 0x%x", ClientId->UniqueProcess);
            DBG_PRINT("     - ClientId->ThreadId: 0x%x", ClientId->UniqueThread);
        }
        auto result = PsCreateSystemThread(
            ThreadHandle,
            DesiredAccess,
            ObjectAttributes,
            ProcessHandle, 
            ClientId, 
            StartRoutine,
            StartContext
        );
        DBG_PRINT("     - Thread Handle: 0x%x", *ThreadHandle);
        return result;
    }

    PMDL gh_IoAllocateMdl(
        __drv_aliasesMem PVOID VirtualAddress,
        ULONG                  Length,
        BOOLEAN                SecondaryBuffer,
        BOOLEAN                ChargeQuota,
        PIRP                   Irp
    )
    {
        DBG_PRINT("IoAllocateMdl called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - VirtualAddress: 0x%p", VirtualAddress);
        DBG_PRINT("     - Length: 0x%x", Length);
        DBG_PRINT("     - Irp: 0x%p", Irp);
        return IoAllocateMdl(
            VirtualAddress,
            Length, 
            SecondaryBuffer,
            ChargeQuota,
            Irp
        );
    }

    NTSTATUS gh_ObReferenceObjectByName(
            __in PUNICODE_STRING ObjectName,
            __in ULONG Attributes,
            __in_opt PACCESS_STATE AccessState,
            __in_opt ACCESS_MASK DesiredAccess,
            __in POBJECT_TYPE ObjectType,
            __in KPROCESSOR_MODE AccessMode,
            __inout_opt PVOID ParseContext,
            __out PVOID* Object
        )
    {
        DBG_PRINT("ObReferenceObjectByName called from: 0x%p", _ReturnAddress());
        if(ObjectName)
            DBG_PRINT("     - ObjectName: %ws", ObjectName->Buffer);

        return ObReferenceObjectByName(
            ObjectName, 
            Attributes,
            AccessState,
            DesiredAccess,
            ObjectType, 
            AccessMode,
            ParseContext, 
            Object
        );
    }

    NTSTATUS gh_MmCopyMemory(
        PVOID           TargetAddress,
        MM_COPY_ADDRESS SourceAddress,
        SIZE_T          NumberOfBytes,
        ULONG           Flags,
        PSIZE_T         NumberOfBytesTransferred
    )
    {
        DBG_PRINT("MmCopyMemory called from: 0x%p", _ReturnAddress());
        DBG_PRINT("     - TargetAddress: 0x%p", TargetAddress);
        DBG_PRINT("     - SourceAddress: 0x%p", SourceAddress);
        DBG_PRINT("     - Size: 0x%x", NumberOfBytes);
        DBG_PRINT("     - Flags: 0x%x", Flags);

        return MmCopyMemory(
            TargetAddress, 
            SourceAddress,
            NumberOfBytes,
            Flags, 
            NumberOfBytesTransferred
        );
    }

    ULONG gh_RtlWalkFrameChain(
        __out PVOID* Callers,
        __in ULONG 	Count,
        __in ULONG 	Flags
    )
    {
        return NULL;
    }

    PVOID gh_MmGetSystemRoutineAddress(
        PUNICODE_STRING SystemRoutineName
    )
    {
        DBG_PRINT("MmGetSystemRoutineAddress: %ws", SystemRoutineName->Buffer);
        if (wcsstr(SystemRoutineName->Buffer, L"ZwAllocateVirtualMemory"))
        {
            DBG_PRINT("Hooking ZwAllocateVirtualMemory");
            return &gh_ZwAllocateVirtualMemory;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"RtlInitUnicodeString"))
        {
            DBG_PRINT("Hooking RtlInitUnicodeString...");
            return &gh_RtlInitUnicodeString;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"RtlInitAnsiString"))
        {
            DBG_PRINT("Hooking RtlInitAnsiString...");
            return &gh_RtlInitAnsiString;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"MmIsAddressValid"))
        {
            DBG_PRINT("Hooking MmIsAddressValid...");
            return &gh_MmIsAddressValid;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"IoCreateDevice"))
        {
            DBG_PRINT("Hooking IoCreateDevice...");
            return &gh_IoCreateDevice;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"PsSetCreateProcessNotifyRoutineEx"))
        {
            DBG_PRINT("Hooking PsSetCreateProcessNotifyRoutineEx...");
            return &gh_PsSetCreateProcessNotifyRoutineEx;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ObRegisterCallbacks"))
        {
            DBG_PRINT("Hooking ObRegisterCallbacks...");
            return &gh_ObRegisterCallbacks;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"PsSetLoadImageNotifyRoutine"))
        {
            DBG_PRINT("Hooking PsSetLoadImageNotifyRoutine...");
            return &gh_PsSetLoadImageNotifyRoutine;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ExEnumHandleTable"))
        {
            //DBG_PRINT("Hooking ExEnumHandleTable...");
            //return &gh_ExEnumHandleTable;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"MmGetPhysicalAddress"))
        {
            DBG_PRINT("Hooking MmGetPhysicalAddress...");
            return &gh_MmGetPhysicalAddress;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"MmMapIoSpace"))
        {
            DBG_PRINT("Hooking MmMapIoSpace...");
            return &gh_MmMapIoSpace;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ZwOpenFile"))
        {
            DBG_PRINT("Hooking ZwOpenFile...");
            return &gh_ZwOpenFile;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"DeviceIoControlFile")) // Nt or Zw
        {
            DBG_PRINT("Hooking %ws....", SystemRoutineName->Buffer);
            return &gh_ZwDeviceIoControlFile;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"KeStackAttachProcess"))
        {
            DBG_PRINT("Hooking KeStackAttachProcess....");
            return &gh_KeStackAttachProcess;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ZwMapViewOfSection"))
        {
            DBG_PRINT("Hooking ZwMapViewOfSection....");
            return &gh_ZwMapViewOfSection;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ObOpenObjectByName"))
        {
            DBG_PRINT("Hooking ObOpenObjectByName....");
            return &gh_ObOpenObjectByName;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ZwCreateSection"))
        {
            DBG_PRINT("Hooking ZwCreateSection....");
            return &gh_ZwCreateSection;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"MmCopyVirtualMemory"))
        {
            DBG_PRINT("Hooking MmCopyVirtualMemory....");
            return &gh_MmCopyVirtualMemory;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"IofCompleteRequest"))
        {
            DBG_PRINT("Hooking IofCompleteRequest...");
            return &gh_IofCompleteRequest;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"QuerySystemInformation"))
        {
            DBG_PRINT("Hooking QuerySystemInformation...");
            return &gh_ZwQuerySystemInformation;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"stricmp"))
        {
            //DBG_PRINT("Hooking stricmp...");
            //return &gh_stricmp;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"strnicmp"))
        {
            //DBG_PRINT("Hooking strnicmp...");
            //return &gh_strnicmp;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"wcsncmp"))
        {
            DBG_PRINT("Hooking wcsncmp...");
            return &gh_wcsncmp;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"wcsnicmp"))
        {
            DBG_PRINT("Hooking wcsnicmp...");
            return &gh_wcsnicmp;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"wcsncat"))
        {
            DBG_PRINT("Hooking wcsncat...");
            return &gh_wcsncat;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"KeInitializeEvent"))
        {
            DBG_PRINT("Hooking KeInitializeEvent...");
            return &gh_KeInitializeEvent;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ExAllocatePoolWithTag"))
        {
            DBG_PRINT("Hooking ExAllocatePoolWithTag...");
            return &gh_ExAllocatePoolWithTag;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ExAllocatePool"))
        {
            DBG_PRINT("Hooking ExAllocatePool...");
            return &gh_ExAllocatePool;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ExFreePoolWithTag"))
        {
            DBG_PRINT("Hooking ExFreePoolWithTag...");
            return &gh_ExFreePoolWithTag;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ProbeForWrite"))
        {
            DBG_PRINT("Hooking ProbeForWrite...");
            return &gh_ProbeForWrite;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ProbeForRead"))
        {
            DBG_PRINT("Hooking ProbeForRead...");
            return &gh_ProbeForRead;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"PsCreateSystemThread"))
        {
            DBG_PRINT("Hooking PsCreateSystemThread...");
            return &gh_PsCreateSystemThread;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"ObReferenceObjectByName"))
        {
            DBG_PRINT("Hooking ObReferenceObjectByName...");
            return &gh_ObReferenceObjectByName;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"MmCopyMemory"))
        {
            DBG_PRINT("Hooking MmCopyMemory...");
            return &gh_MmCopyMemory;
        }
        else if (wcsstr(SystemRoutineName->Buffer, L"RtlWalkFrameChain"))
        {
            DBG_PRINT("Hooking RtlWalkFrameChain...");
            return &gh_RtlWalkFrameChain;
        }
        return MmGetSystemRoutineAddress(SystemRoutineName);
    }

    PVOID gh_FltGetRoutineAddress(
        PCSTR FltMgrRoutineName
    )
    {
        DBG_PRINT("FltGetRoutineAddress: %s", FltMgrRoutineName);
        return FltGetRoutineAddress(FltMgrRoutineName);
    }

    VOID gh_KeBugCheckEx(
        ULONG     BugCheckCode,
        ULONG_PTR BugCheckParameter1,
        ULONG_PTR BugCheckParameter2,
        ULONG_PTR BugCheckParameter3,
        ULONG_PTR BugCheckParameter4
    )
    { DBG_PRINT("KeBugCheckEx Called!"); }

    VOID LoadImageNotifyRoutine(
        PUNICODE_STRING FullImageName,
        HANDLE ProcessId,
        PIMAGE_INFO ImageInfo
    )
    {
        if (!ProcessId && FullImageName && wcsstr(FullImageName->Buffer, L"BEDaisy.sys"))
        {
            DBG_PRINT("> ============= Driver %ws ================", FullImageName->Buffer);
            DriverUtil::IATHook(
                ImageInfo->ImageBase,
                "KeBugCheckEx",
                &gh_KeBugCheckEx
            );

            DriverUtil::IATHook(
                ImageInfo->ImageBase,
                "MmGetSystemRoutineAddress",
                &gh_MmGetSystemRoutineAddress
            );

            DriverUtil::IATHook(
                ImageInfo->ImageBase,
                "FltGetRoutineAddress",
                &gh_FltGetRoutineAddress
            );
        }
    }
}
```

`bedaisy-master/BEDaisy/Hooks.h`:

```h
#pragma once
#include "Types.h"
#include "DriverUtil.h"

namespace Hooks
{
    BOOLEAN gh_ExEnumHandleTable(
        PVOID HandleTable,
        PVOID EnumHandleProcedure,
        PVOID EnumParameter,
        PHANDLE Handle OPTIONAL
    );

    NTSTATUS gh_ZwAllocateVirtualMemory(
        _In_    HANDLE    ProcessHandle,
        _Inout_ PVOID* BaseAddress,
        _In_    ULONG_PTR ZeroBits,
        _Inout_ PSIZE_T   RegionSize,
        _In_    ULONG     AllocationType,
        _In_    ULONG     Protect
    );

    NTSTATUS gh_PsSetLoadImageNotifyRoutine(
        PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    );

    NTSTATUS gh_ObRegisterCallbacks(
        POB_CALLBACK_REGISTRATION CallbackRegistration,
        PVOID* RegistrationHandle
    );

    NTSTATUS gh_ZwQuerySystemInformation(
        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
        _Inout_   PVOID                    SystemInformation,
        _In_      ULONG                    SystemInformationLength,
        _Out_opt_ PULONG                   ReturnLength
    );

    NTSTATUS gh_PsSetCreateProcessNotifyRoutineEx(
        PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,
        BOOLEAN                           Remove
    );

    NTSTATUS gh_IoCreateDevice(
        PDRIVER_OBJECT  DriverObject,
        ULONG           DeviceExtensionSize,
        PUNICODE_STRING DeviceName,
        DEVICE_TYPE     DeviceType,
        ULONG           DeviceCharacteristics,
        BOOLEAN         Exclusive,
        PDEVICE_OBJECT* DeviceObject
    );

    NTSTATUS gh_PsSetCreateThreadNotifyRoutine(
        PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );

    PHYSICAL_ADDRESS gh_MmGetPhysicalAddress(
        PVOID BaseAddress
    );

    BOOLEAN gh_MmIsAddressValid(
        PVOID VirtualAddress
    );

    NTSTATUS gh_ZwDeviceIoControlFile(
        HANDLE           FileHandle,
        HANDLE           Event,
        PIO_APC_ROUTINE  ApcRoutine,
        PVOID            ApcContext,
        PIO_STATUS_BLOCK IoStatusBlock,
        ULONG            IoControlCode,
        PVOID            InputBuffer,
        ULONG            InputBufferLength,
        PVOID            OutputBuffer,
        ULONG            OutputBufferLength
    );

    VOID gh_RtlInitAnsiString(
        PANSI_STRING          DestinationString,
        PCSZ SourceString
    );

    VOID gh_RtlInitUnicodeString(
        PUNICODE_STRING         DestinationString,
        PCWSTR SourceString
    );

    PVOID gh_MmMapIoSpace(
        PHYSICAL_ADDRESS    PhysicalAddress,
        SIZE_T              NumberOfBytes,
        MEMORY_CACHING_TYPE CacheType
    );

    NTSTATUS gh_ZwOpenFile(
        PHANDLE            FileHandle,
        ACCESS_MASK        DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        PIO_STATUS_BLOCK   IoStatusBlock,
        ULONG              ShareAccess,
        ULONG              OpenOptions
    );

    void gh_KeStackAttachProcess(
        PRKPROCESS   PROCESS,
        PRKAPC_STATE ApcState
    );

    NTSTATUS gh_ZwCreateSection(
        PHANDLE            SectionHandle,
        ACCESS_MASK        DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        PLARGE_INTEGER     MaximumSize,
        ULONG              SectionPageProtection,
        ULONG              AllocationAttributes,
        HANDLE             FileHandle
    );

    NTSTATUS gh_ObOpenObjectByName(
        __in POBJECT_ATTRIBUTES ObjectAttributes,
        __in_opt POBJECT_TYPE ObjectType,
        __in KPROCESSOR_MODE AccessMode,
        __inout_opt PACCESS_STATE AccessState,
        __in_opt ACCESS_MASK DesiredAccess,
        __inout_opt PVOID ParseContext,
        __out PHANDLE Handle
    );

    NTSTATUS gh_ZwMapViewOfSection(
        HANDLE          SectionHandle,
        HANDLE          ProcessHandle,
        PVOID* BaseAddress,
        ULONG_PTR       ZeroBits,
        SIZE_T          CommitSize,
        PLARGE_INTEGER  SectionOffset,
        PSIZE_T         ViewSize,
        SECTION_INHERIT InheritDisposition,
        ULONG           AllocationType,
        ULONG           Win32Protect
    );

    NTSTATUS gh_MmCopyVirtualMemory
    (
        PEPROCESS SourceProcess,
        PVOID SourceAddress,
        PEPROCESS TargetProcess,
        PVOID TargetAddress,
        SIZE_T BufferSize,
        KPROCESSOR_MODE PreviousMode,
        PSIZE_T ReturnSize
    );

    void gh_IofCompleteRequest(
        PIRP  Irp,
        CCHAR PriorityBoost
    );

    PVOID gh_MmGetSystemRoutineAddress(
        PUNICODE_STRING SystemRoutineName
    );

    PVOID gh_FltGetRoutineAddress(
        PCSTR FltMgrRoutineName
    );

    VOID gh_KeBugCheckEx(
        ULONG     BugCheckCode,
        ULONG_PTR BugCheckParameter1,
        ULONG_PTR BugCheckParameter2,
        ULONG_PTR BugCheckParameter3,
        ULONG_PTR BugCheckParameter4
    );

    int gh_strnicmp(
        const char* string1,
        const char* string2,
        size_t count
    );

    int gh_stricmp(
        const char* string1,
        const char* string2
    );

    VOID LoadImageNotifyRoutine(
        PUNICODE_STRING FullImageName,
        HANDLE ProcessId,
        PIMAGE_INFO ImageInfo
    );
}
```

`bedaisy-master/BEDaisy/Memory.cpp`:

```cpp
#include "Memory.h"

namespace Memory
{
    void WriteProtectOff()
    {
        auto cr0 = __readcr0();
        cr0 &= 0xfffffffffffeffff;
        __writecr0(cr0);
        _disable();
    }

    void WriteProtectOn()
    {
        auto cr0 = __readcr0();
        cr0 |= 0x10000;
        _enable();
        __writecr0(cr0);
    }
}
```

`bedaisy-master/BEDaisy/Memory.h`:

```h
#pragma once
#include <intrin.h>

namespace Memory
{
	void WriteProtectOff();
	void WriteProtectOn();
}
```

`bedaisy-master/BEDaisy/Types.h`:

```h
#pragma once
#include <ntifs.h>
#include <cstddef>

#define MAX_PATH 260
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define POOLTAG 'MEME'

#if true
#define DBG_PRINT(...) DbgPrintEx( DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, "[GoodEye]" __VA_ARGS__);
#else
#define DBG_PRINT(...)
#endif

#ifndef DWORD
#define DWORD unsigned
#endif

#ifndef WORD
#define WORD unsigned short
#endif

extern "C" NTSTATUS ObReferenceObjectByName(
	__in PUNICODE_STRING ObjectName,
	__in ULONG Attributes,
	__in_opt PACCESS_STATE AccessState,
	__in_opt ACCESS_MASK DesiredAccess,
	__in POBJECT_TYPE ObjectType,
	__in KPROCESSOR_MODE AccessMode,
	__inout_opt PVOID ParseContext,
	__out PVOID* Object
);

extern "C" NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

extern "C" NTSTATUS ObOpenObjectByName(
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in_opt POBJECT_TYPE ObjectType,
	__in KPROCESSOR_MODE AccessMode,
	__inout_opt PACCESS_STATE AccessState,
	__in_opt ACCESS_MASK DesiredAccess,
	__inout_opt PVOID ParseContext,
	__out PHANDLE Handle
);

extern "C" NTKERNELAPI UCHAR* PsGetProcessImageFileName(
	_In_ PEPROCESS Process
);

extern "C" NTSTATUS ZwQueryDirectoryObject(
	IN HANDLE DirectoryHandle,
	OUT PVOID Buffer,
	IN ULONG BufferLength,
	IN BOOLEAN ReturnSingleEntry,
	IN BOOLEAN RestartScan,
	IN OUT PULONG Context,
	OUT PULONG ReturnLength OPTIONAL
);

extern "C" NTSTATUS ZwQuerySystemInformation(
	ULONG InfoClass, 
	PVOID Buffer,
	ULONG Length, 
	PULONG ReturnLength
);

extern "C" ULONG RtlWalkFrameChain(
	__out PVOID * Callers,
	__in ULONG 	Count,
	__in ULONG 	Flags
);

extern "C" NTKERNELAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
	_In_ PVOID ImageBase,
	_In_ PCCH RoutineName
);

typedef struct _IMAGE_THUNK_DATA64 {
	union {
		ULONGLONG ForwarderString;  // PBYTE 
		ULONGLONG Function;         // PDWORD
		ULONGLONG Ordinal;
		ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
	} u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64* PIMAGE_THUNK_DATA64;

typedef struct _DEVICE_MAP* PDEVICE_MAP;
typedef PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;

typedef struct _OBJECT_DIRECTORY_ENTRY
{
	_OBJECT_DIRECTORY_ENTRY* ChainLink;
	PVOID Object;
	ULONG HashValue;
} OBJECT_DIRECTORY_ENTRY, * POBJECT_DIRECTORY_ENTRY;

typedef struct _OBJECT_DIRECTORY
{
	POBJECT_DIRECTORY_ENTRY HashBuckets[37];
	EX_PUSH_LOCK Lock;
	PDEVICE_MAP DeviceMap;
	ULONG SessionId;
	PVOID NamespaceEntry;
	ULONG Flags;
} OBJECT_DIRECTORY, * POBJECT_DIRECTORY;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
	union {
		DWORD   Characteristics;            // 0 for terminating null import descriptor
		DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
	} DUMMYUNIONNAME;
	DWORD   TimeDateStamp;                  // 0 if not bound,
											// -1 if bound, and real date\time stamp
											//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
											// O.W. date/time stamp of DLL bound to (Old BIND)

	DWORD   ForwarderChain;                 // -1 if no forwarders
	DWORD   Name;
	DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED* PIMAGE_IMPORT_DESCRIPTOR;

typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	unsigned char Reserved1[48];
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	PVOID Reserved2;
	ULONG HandleCount;
	ULONG SessionId;
	PVOID Reserved3;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG Reserved4;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	PVOID Reserved5;
	SIZE_T QuotaPagedPoolUsage;
	PVOID Reserved6;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER Reserved7[6];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _IMAGE_DOS_HEADER {  // DOS .EXE header
	USHORT e_magic;         // Magic number
	USHORT e_cblp;          // Bytes on last page of file
	USHORT e_cp;            // Pages in file
	USHORT e_crlc;          // Relocations
	USHORT e_cparhdr;       // Size of header in paragraphs
	USHORT e_minalloc;      // Minimum extra paragraphs needed
	USHORT e_maxalloc;      // Maximum extra paragraphs needed
	USHORT e_ss;            // Initial (relative) SS value
	USHORT e_sp;            // Initial SP value
	USHORT e_csum;          // Checksum
	USHORT e_ip;            // Initial IP value
	USHORT e_cs;            // Initial (relative) CS value
	USHORT e_lfarlc;        // File address of relocation table
	USHORT e_ovno;          // Overlay number
	USHORT e_res[4];        // Reserved words
	USHORT e_oemid;         // OEM identifier (for e_oeminfo)
	USHORT e_oeminfo;       // OEM information; e_oemid specific
	USHORT e_res2[10];      // Reserved words
	LONG   e_lfanew;        // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;

typedef struct _IMAGE_FILE_HEADER {
	short  Machine;
	short  NumberOfSections;
	unsigned TimeDateStamp;
	unsigned PointerToSymbolTable;
	unsigned NumberOfSymbols;
	short  SizeOfOptionalHeader;
	short  Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _IMAGE_IMPORT_BY_NAME {
	WORD    Hint;
	CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, * PIMAGE_IMPORT_BY_NAME;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;


typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation = 0x0B
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;


typedef struct _IMAGE_DATA_DIRECTORY {
	unsigned VirtualAddress;
	unsigned Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	short                 Magic;
	unsigned char                 MajorLinkerVersion;
	unsigned char                 MinorLinkerVersion;
	unsigned                SizeOfCode;
	unsigned                SizeOfInitializedData;
	unsigned                SizeOfUninitializedData;
	unsigned                AddressOfEntryPoint;
	unsigned                BaseOfCode;
	ULONGLONG            ImageBase;
	unsigned                SectionAlignment;
	unsigned                FileAlignment;
	short                 MajorOperatingSystemVersion;
	short                 MinorOperatingSystemVersion;
	short                 MajorImageVersion;
	short                 MinorImageVersion;
	short                 MajorSubsystemVersion;
	short                 MinorSubsystemVersion;
	unsigned                Win32VersionValue;
	unsigned                SizeOfImage;
	unsigned                SizeOfHeaders;
	unsigned                CheckSum;
	short                 Subsystem;
	short                 DllCharacteristics;
	ULONGLONG            SizeOfStackReserve;
	ULONGLONG            SizeOfStackCommit;
	ULONGLONG            SizeOfHeapReserve;
	ULONGLONG            SizeOfHeapCommit;
	unsigned                 LoaderFlags;
	unsigned                NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
	unsigned                   Signature;
	IMAGE_FILE_HEADER       FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER {
	unsigned char Name[8];
	union {
		unsigned PhysicalAddress;
		unsigned VirtualSize;
	} Misc;
	unsigned VirtualAddress;
	unsigned SizeOfRawData;
	unsigned PointerToRawData;
	unsigned PointerToRelocations;
	unsigned PointerToLinenumbers;
	short  NumberOfRelocations;
	short  NumberOfLinenumbers;
	unsigned Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

```