Project Path: arc_gmh5225_Il2CppAssemblyUnhollower_cq3by73r

Source Tree:

```txt
arc_gmh5225_Il2CppAssemblyUnhollower_cq3by73r
├── AssemblyUnhollower
│   ├── AssemblyKnownImports.cs
│   ├── AssemblyUnhollower.csproj
│   ├── Contexts
│   │   ├── AssemblyRewriteContext.cs
│   │   ├── FieldRewriteContext.cs
│   │   ├── MethodRewriteContext.cs
│   │   ├── RewriteGlobalContext.cs
│   │   └── TypeRewriteContext.cs
│   ├── DeobfuscationMapGenerator.cs
│   ├── Extensions
│   │   ├── CollectionEx.cs
│   │   ├── CustomAttributeEx.cs
│   │   ├── EnumEx.cs
│   │   ├── StringEx.cs
│   │   ├── TypeReferenceEx.cs
│   │   └── WriterEx.cs
│   ├── FieldAccessorGenerator.cs
│   ├── MetadataAccess
│   │   ├── CecilMetadataAccess.cs
│   │   ├── IIl2CppMetadataAccess.cs
│   │   ├── IMetadataAccess.cs
│   │   └── NullMetadataAccess.cs
│   ├── Passes
│   │   ├── Pass05CreateRenameGroups.cs
│   │   ├── Pass10CreateTypedefs.cs
│   │   ├── Pass11ComputeTypeSpecifics.cs
│   │   ├── Pass12FillTypedefs.cs
│   │   ├── Pass13FillGenericConstraints.cs
│   │   ├── Pass15GenerateMemberContexts.cs
│   │   ├── Pass16ScanMethodRefs.cs
│   │   ├── Pass18FinalizeMethodContexts.cs
│   │   ├── Pass19CopyMethodParameters.cs
│   │   ├── Pass20GenerateStaticConstructors.cs
│   │   ├── Pass21GenerateValueTypeFields.cs
│   │   ├── Pass22GenerateEnums.cs
│   │   ├── Pass23GeneratePointerConstructors.cs
│   │   ├── Pass24GenerateTypeStaticGetters.cs
│   │   ├── Pass25GenerateNonBlittableValueTypeDefaultCtors.cs
│   │   ├── Pass30GenerateGenericMethodStoreConstructors.cs
│   │   ├── Pass40GenerateFieldAccessors.cs
│   │   ├── Pass50GenerateMethods.cs
│   │   ├── Pass60AddImplicitConversions.cs
│   │   ├── Pass70GenerateProperties.cs
│   │   ├── Pass79UnstripTypes.cs
│   │   ├── Pass80UnstripFields.cs
│   │   ├── Pass80UnstripMethods.cs
│   │   ├── Pass81FillUnstrippedMethodBodies.cs
│   │   ├── Pass89GenerateForwarders.cs
│   │   ├── Pass89GenerateMethodXrefCache.cs
│   │   ├── Pass90WriteToDisk.cs
│   │   └── Pass91GenerateMethodPointerMap.cs
│   ├── Program.cs
│   ├── TargetTypeSystemHandler.cs
│   ├── TimingCookie.cs
│   ├── UnhollowerOptions.cs
│   ├── UtilGenerator.cs
│   └── Utils
│       ├── UniquificationContext.cs
│       ├── UnstripGenerator.cs
│       ├── UnstripTranslator.cs
│       └── XrefScanMetadataGenerationUtil.cs
├── AssemblyUnhollower.sln
├── AssemblyUnhollower.sln.DotSettings
├── COPYING.LESSER
├── Documentation
│   ├── Class-Injection.md
│   ├── Command-Line-Usage.md
│   ├── Common-Problems.md
│   └── Injected-Components-In-Asset-Bundles.md
├── LICENSE
├── README.md
├── ReleaseChangelog.md
├── UnhollowerBaseLib
│   ├── AssemblyInfo.cs
│   ├── Attributes
│   │   ├── AlsoInitializeAttribute.cs
│   │   ├── CachedScanResultsAttribute.cs
│   │   ├── CallerCountAttribute.cs
│   │   ├── ClassInjectionAssemblyTargetAttribute.cs
│   │   ├── HideFromIl2CppAttribute.cs
│   │   └── ObfuscatedNameAttribute.cs
│   ├── ClassInjector.cs
│   ├── DelegateSupport.cs
│   ├── GeneratedDatabasesUtil.cs
│   ├── IL2CPP.cs
│   ├── Il2CppArrayBase.cs
│   ├── Il2CppClassPointerStore.cs
│   ├── Il2CppException.cs
│   ├── Il2CppObjectBase.cs
│   ├── Il2CppReferenceArray.cs
│   ├── Il2CppStringArray.cs
│   ├── Il2CppStructArray.cs
│   ├── Il2CppType.cs
│   ├── Libs
│   │   └── Il2Cppmscorlib.dll
│   ├── LogSupport.cs
│   ├── Maps
│   │   ├── MethodAddressToTokenMap.cs
│   │   ├── MethodAddressToTokenMapBase.cs
│   │   └── MethodXrefScanCache.cs
│   ├── MiniILParser.cs
│   ├── ObjectCollectedException.cs
│   ├── Runtime
│   │   ├── ClassInjectorBase.cs
│   │   ├── Il2CppApi.cs
│   │   ├── Il2CppStructs.cs
│   │   ├── NativeStructUtils.cs
│   │   ├── StructHandlerInterfaces.cs
│   │   ├── UnityVersionHandler.cs
│   │   └── VersionSpecific
│   │       ├── Assembly
│   │       │   ├── Assembly_16_0.cs
│   │       │   ├── Assembly_20_0.cs
│   │       │   ├── Assembly_24_0_B.cs
│   │       │   ├── Assembly_24_1.cs
│   │       │   ├── Assembly_24_4.cs
│   │       │   └── Interfaces.cs
│   │       ├── Class
│   │       │   ├── Class_16_0.cs
│   │       │   ├── Class_19_0.cs
│   │       │   ├── Class_20_0.cs
│   │       │   ├── Class_21_0_B.cs
│   │       │   ├── Class_21_0_C.cs
│   │       │   ├── Class_22_0_A.cs
│   │       │   ├── Class_22_0_B.cs
│   │       │   ├── Class_23_0.cs
│   │       │   ├── Class_24_0_B.cs
│   │       │   ├── Class_24_0_C.cs
│   │       │   ├── Class_24_1_A.cs
│   │       │   ├── Class_24_1_B.cs
│   │       │   ├── Class_24_2.cs
│   │       │   ├── Class_27_0.cs
│   │       │   ├── Class_27_2.cs
│   │       │   ├── Class_27_3.cs
│   │       │   └── Interfaces.cs
│   │       ├── EventInfo
│   │       │   ├── EventInfo_16_0.cs
│   │       │   ├── EventInfo_19_0.cs
│   │       │   ├── EventInfo_24_1.cs
│   │       │   └── Interfaces.cs
│   │       ├── Exception
│   │       │   ├── Exception_16_0.cs
│   │       │   ├── Exception_21_0.cs
│   │       │   ├── Exception_22_0.cs
│   │       │   ├── Exception_27_3.cs
│   │       │   └── Interfaces.cs
│   │       ├── FieldInfo
│   │       │   ├── FieldInfo_16_0.cs
│   │       │   ├── FieldInfo_19_0.cs
│   │       │   ├── FieldInfo_24_1.cs
│   │       │   └── Interfaces.cs
│   │       ├── Image
│   │       │   ├── Images_16_0.cs
│   │       │   ├── Images_19_0.cs
│   │       │   ├── Images_24_0_A.cs
│   │       │   ├── Images_24_0_B.cs
│   │       │   ├── Images_24_0_C.cs
│   │       │   ├── Images_24_1.cs
│   │       │   ├── Images_24_2.cs
│   │       │   ├── Images_27_0.cs
│   │       │   └── Interfaces.cs
│   │       ├── MethodInfo
│   │       │   ├── Interfaces.cs
│   │       │   ├── MethodInfo_16_0.cs
│   │       │   ├── MethodInfo_24_1.cs
│   │       │   └── MethodInfo_27_3.cs
│   │       ├── ParameterInfo
│   │       │   ├── Interfaces.cs
│   │       │   ├── ParameterInfo_16_0.cs
│   │       │   ├── ParameterInfo_24_1.cs
│   │       │   └── ParameterInfo_27_3.cs
│   │       ├── PropertyInfo
│   │       │   ├── Interfaces.cs
│   │       │   ├── PropertyInfo_16_0.cs
│   │       │   ├── PropertyInfo_19_0.cs
│   │       │   └── PropertyInfo_24_1.cs
│   │       └── Type
│   │           ├── Interfaces.cs
│   │           ├── Type_16_0.cs
│   │           ├── Type_27_0.cs
│   │           └── Type_27_2.cs
│   ├── RuntimeReflectionHelper.cs
│   ├── RuntimeSpecificsStore.cs
│   ├── UnhollowerBaseLib.csproj
│   ├── UnhollowerUtils.cs
│   └── XrefScans
│       ├── XrefInstance.cs
│       ├── XrefScanMetadataRuntimeUtil.cs
│       ├── XrefScanMethodDb.cs
│       ├── XrefScanUtilFinder.cs
│       ├── XrefScanner.cs
│       ├── XrefScannerLowLevel.cs
│       └── XrefType.cs
├── UnhollowerPdbGen
│   ├── MethodAddressToTokenMapCecil.cs
│   ├── MsPdbCore.cs
│   ├── PdbGenMain.cs
│   └── UnhollowerPdbGen.csproj
└── UnhollowerRuntimeLib
    ├── Forwarders.cs
    └── UnhollowerRuntimeLib.csproj

```

`AssemblyUnhollower.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31402.337
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyUnhollower", "AssemblyUnhollower\AssemblyUnhollower.csproj", "{7C3FD45B-A563-47AF-90DF-8B051A8C33A0}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnhollowerBaseLib", "UnhollowerBaseLib\UnhollowerBaseLib.csproj", "{F6405B5F-9162-49EA-9C8A-CE1AA0916CF3}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{463B7E3B-94E8-4EEB-B54A-EF15AD9C7C7E}"
	ProjectSection(SolutionItems) = preProject
		.gitignore = .gitignore
		.github\workflows\dotnet.yml = .github\workflows\dotnet.yml
		README.md = README.md
		ReleaseChangelog.md = ReleaseChangelog.md
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnhollowerRuntimeLib", "UnhollowerRuntimeLib\UnhollowerRuntimeLib.csproj", "{7B7E5024-385D-4A46-9196-A6AF8F7FBDD5}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Documentation", "Documentation", "{99E71726-78FB-4376-89DA-90E5C08F5CD4}"
	ProjectSection(SolutionItems) = preProject
		Documentation\Class-Injection.md = Documentation\Class-Injection.md
		Documentation\Command-Line-Usage.md = Documentation\Command-Line-Usage.md
		Documentation\Common-Problems.md = Documentation\Common-Problems.md
		Documentation\Injected-Components-In-Asset-Bundles.md = Documentation\Injected-Components-In-Asset-Bundles.md
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UnhollowerPdbGen", "UnhollowerPdbGen\UnhollowerPdbGen.csproj", "{7508A51A-9721-4E03-A484-477EC71F3E54}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7C3FD45B-A563-47AF-90DF-8B051A8C33A0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7C3FD45B-A563-47AF-90DF-8B051A8C33A0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7C3FD45B-A563-47AF-90DF-8B051A8C33A0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7C3FD45B-A563-47AF-90DF-8B051A8C33A0}.Release|Any CPU.Build.0 = Release|Any CPU
		{F6405B5F-9162-49EA-9C8A-CE1AA0916CF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F6405B5F-9162-49EA-9C8A-CE1AA0916CF3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F6405B5F-9162-49EA-9C8A-CE1AA0916CF3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F6405B5F-9162-49EA-9C8A-CE1AA0916CF3}.Release|Any CPU.Build.0 = Release|Any CPU
		{7B7E5024-385D-4A46-9196-A6AF8F7FBDD5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7B7E5024-385D-4A46-9196-A6AF8F7FBDD5}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7B7E5024-385D-4A46-9196-A6AF8F7FBDD5}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7B7E5024-385D-4A46-9196-A6AF8F7FBDD5}.Release|Any CPU.Build.0 = Release|Any CPU
		{7508A51A-9721-4E03-A484-477EC71F3E54}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7508A51A-9721-4E03-A484-477EC71F3E54}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7508A51A-9721-4E03-A484-477EC71F3E54}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7508A51A-9721-4E03-A484-477EC71F3E54}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{99E71726-78FB-4376-89DA-90E5C08F5CD4} = {463B7E3B-94E8-4EEB-B54A-EF15AD9C7C7E}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CA7C3EAB-EDE4-4DB0-BEEF-9E74940B2978}
	EndGlobalSection
EndGlobal

```

`AssemblyUnhollower.sln.DotSettings`:

```DotSettings
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeStyle/Naming/CSharpNaming/PredefinedNamingRules/=PrivateInstanceFields/@EntryIndexedValue">&lt;Policy Inspect="True" Prefix="my" Suffix="" Style="AaBb" /&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CSharpNaming/PredefinedNamingRules/=PrivateStaticFields/@EntryIndexedValue">&lt;Policy Inspect="True" Prefix="our" Suffix="" Style="AaBb" /&gt;</s:String>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=Unhollower/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=Unmangle/@EntryIndexedValue">True</s:Boolean></wpf:ResourceDictionary>
```

`AssemblyUnhollower/AssemblyKnownImports.cs`:

```cs
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;
using UnhollowerBaseLib;
using UnhollowerBaseLib.Attributes;
using UnhollowerRuntimeLib;

namespace AssemblyUnhollower
{
    public class AssemblyKnownImports
    {
        private static readonly Dictionary<ModuleDefinition, AssemblyKnownImports> AssemblyMap = new Dictionary<ModuleDefinition, AssemblyKnownImports>();

        public static AssemblyKnownImports For(ModuleDefinition module, RewriteGlobalContext context)
        {
            return AssemblyMap.GetOrCreate(module, mod => new AssemblyKnownImports(mod, context));
        }

        public readonly ModuleDefinition Module;
        private readonly RewriteGlobalContext myContext;

        private readonly Lazy<TypeReference> myVoidReference;
        private readonly Lazy<TypeReference> myIntPtrReference;
        private readonly Lazy<TypeReference> myStringReference;
        private readonly Lazy<TypeReference> myIntReference;
        private readonly Lazy<TypeReference> myLongReference;
        private readonly Lazy<TypeDefinition> myTypeReference;
        private readonly Lazy<TypeReference> myEnumReference;
        private readonly Lazy<TypeReference> myDelegateReference;
        private readonly Lazy<TypeReference> myMulticastDelegateReference;
        private readonly Lazy<TypeReference> myValueTypeReference;
        private readonly Lazy<TypeReference> myObjectReference;
        private readonly Lazy<TypeReference> myIl2CppClassPointerStoreReference;
        private readonly Lazy<TypeReference> myIl2CppObjectBaseReference;
        private readonly Lazy<TypeReference> myIl2CppReferenceArray;
        private readonly Lazy<TypeReference> myIl2CppStructArray;
        private readonly Lazy<TypeReference> myIl2CppStringArray;
        private readonly Lazy<TypeReference> myIl2CppArrayBase;
        private readonly Lazy<TypeReference> myIl2CppArrayBaseSetlfSubst;
        private readonly Lazy<TypeReference> myDefaultMemberAttribute;

        public TypeReference Void => myVoidReference.Value;
        public TypeReference IntPtr => myIntPtrReference.Value;
        public TypeReference String => myStringReference.Value;
        public TypeReference Int => myIntReference.Value;
        public TypeReference Long => myLongReference.Value;
        public TypeDefinition Type => myTypeReference.Value;
        public TypeReference Enum => myEnumReference.Value;
        public TypeReference Delegate => myDelegateReference.Value;
        public TypeReference MulticastDelegate => myMulticastDelegateReference.Value;
        public TypeReference ValueType => myValueTypeReference.Value;
        public TypeReference Object => myObjectReference.Value;
        public TypeReference Il2CppClassPointerStore => myIl2CppClassPointerStoreReference.Value;
        public TypeReference Il2CppObjectBase => myIl2CppObjectBaseReference.Value;
        public TypeReference Il2CppReferenceArray => myIl2CppReferenceArray.Value;
        public TypeReference Il2CppStructArray => myIl2CppStructArray.Value;
        public TypeReference Il2CppStringArray => myIl2CppStringArray.Value;
        public TypeReference Il2CppArrayBase => myIl2CppArrayBase.Value;
        public TypeReference Il2CppArrayBaseSelfSubst => myIl2CppArrayBaseSetlfSubst.Value;
        public TypeReference DefaultMemberAttribute => myDefaultMemberAttribute.Value;

        public MethodReference Il2CppObjectBaseToPointer => myIl2CppObjectToPointer.Value;
        public MethodReference Il2CppObjectBaseToPointerNotNull => myIl2CppObjectToPointerNotNull.Value;
        public MethodReference StringToNative => myStringToNative.Value;
        public MethodReference StringFromNative => myStringFromNative.Value;
        public MethodReference Il2CppObjectCast => myIl2CppObjectCast.Value;
        public MethodReference Il2CppObjectTryCast => myIl2CppObjectTryCast.Value;
        public MethodReference Il2CppResolveICall => myIl2CppResolveICall.Value;
        public MethodReference WriteFieldWBarrier => myWriteFieldWBarrier.Value;

        private readonly Lazy<MethodReference> myIl2CppObjectToPointer;
        private readonly Lazy<MethodReference> myIl2CppObjectToPointerNotNull;
        private readonly Lazy<MethodReference> myStringToNative;
        private readonly Lazy<MethodReference> myStringFromNative;
        private readonly Lazy<MethodReference> myIl2CppObjectCast;
        private readonly Lazy<MethodReference> myIl2CppObjectTryCast;
        private readonly Lazy<MethodReference> myIl2CppResolveICall;
        private readonly Lazy<MethodReference> myWriteFieldWBarrier;
        
        private readonly Lazy<MethodReference> myFieldGetOffset;
        private readonly Lazy<MethodReference> myFieldStaticGet;
        private readonly Lazy<MethodReference> myFieldStaticSet;
        
        private readonly Lazy<MethodReference> myRuntimeInvoke;
        private readonly Lazy<MethodReference> myRuntimeClassInit;
        private readonly Lazy<MethodReference> myObjectUnbox;
        private readonly Lazy<MethodReference> myObjectBox;
        private readonly Lazy<MethodReference> myValueSizeGet;
        private readonly Lazy<MethodReference> myObjectGetClass;
        private readonly Lazy<MethodReference> myClassIsValueType;
        private readonly Lazy<MethodReference> myRaiseExceptionIfNecessary;
        private readonly Lazy<MethodReference> myGetVirtualMethod;
        private readonly Lazy<MethodReference> myGetFieldPtr;
        private readonly Lazy<MethodReference> myGetIl2CppNestedClass;
        private readonly Lazy<MethodReference> myGetIl2CppGlobalClass;
        private readonly Lazy<MethodReference> myGetIl2CppMethod;
        private readonly Lazy<MethodReference> myGetIl2CppMethodFromToken;
        private readonly Lazy<MethodReference> myGetIl2CppTypeFromClass;
        private readonly Lazy<MethodReference> myGetIl2CppTypeToClass;
        private readonly Lazy<MethodReference> myIl2CppNewObject;
        private readonly Lazy<MethodReference> myIl2CppMethodInfoToReflection;
        private readonly Lazy<MethodReference> myIl2CppMethodInfoFromReflection;
        private readonly Lazy<MethodReference> myIl2CppPointerToGeneric;
        private readonly Lazy<MethodReference> myIl2CppRenderTypeNameGeneric;
        
        private readonly Lazy<MethodReference> myDelegateCombine;
        private readonly Lazy<MethodReference> myDelegateRemove;

        private readonly Lazy<MethodReference> myLdTokUnstrippedImpl;
        
        private readonly Lazy<MethodReference> myFlagsAttributeCtor;
        private readonly Lazy<MethodReference> myObsoleteAttributeCtor;
        private readonly Lazy<MethodReference> myNotSupportedExceptionCtor;
        private readonly Lazy<MethodReference> myObfuscatedNameAttributeCtor;
        private readonly Lazy<MethodReference> myCallerCountAttributeCtor;
        private readonly Lazy<MethodReference> myCachedScanResultsAttributeCtor;
        private readonly Lazy<MethodReference> myExtensionAttributeCtor;
        
        public MethodReference FieldGetOffset => myFieldGetOffset.Value;
        public MethodReference FieldStaticGet => myFieldStaticGet.Value;
        public MethodReference FieldStaticSet => myFieldStaticSet.Value;
        
        public MethodReference RuntimeInvoke => myRuntimeInvoke.Value;
        public MethodReference RuntimeClassInit => myRuntimeClassInit.Value;
        public MethodReference ObjectUnbox => myObjectUnbox.Value;
        public MethodReference ObjectBox => myObjectBox.Value;
        public MethodReference ValueSizeGet => myValueSizeGet.Value;
        public MethodReference ClassIsValueType => myClassIsValueType.Value;
        public MethodReference ObjectGetClass => myObjectGetClass.Value;
        public MethodReference RaiseExceptionIfNecessary => myRaiseExceptionIfNecessary.Value;
        public MethodReference GetVirtualMethod => myGetVirtualMethod.Value;
        public MethodReference GetFieldPointer => myGetFieldPtr.Value;
        public MethodReference GetIl2CppNestedClass => myGetIl2CppNestedClass.Value;
        public MethodReference GetIl2CppGlobalClass => myGetIl2CppGlobalClass.Value;
        public MethodReference GetIl2CppMethod => myGetIl2CppMethod.Value;
        public MethodReference GetIl2CppMethodFromToken => myGetIl2CppMethodFromToken.Value;
        public MethodReference GetIl2CppTypeFromClass => myGetIl2CppTypeFromClass.Value;
        public MethodReference GetIl2CppTypeToClass => myGetIl2CppTypeToClass.Value;
        public MethodReference Il2CppNewObject => myIl2CppNewObject.Value;
        public MethodReference Il2CppMethodInfoToReflection => myIl2CppMethodInfoToReflection.Value;
        public MethodReference Il2CppMethodInfoFromReflection => myIl2CppMethodInfoFromReflection.Value;
        public MethodReference Il2CppPointerToGeneric => myIl2CppPointerToGeneric.Value;
        public MethodReference Il2CppRenderTypeNameGeneric => myIl2CppRenderTypeNameGeneric.Value;

        public MethodReference DelegateCombine => myDelegateCombine.Value;
        public MethodReference DelegateRemove => myDelegateRemove.Value;
        
        public MethodReference LdTokUnstrippedImpl => myLdTokUnstrippedImpl.Value;
        
        public MethodReference FlagsAttributeCtor => myFlagsAttributeCtor.Value;
        public MethodReference ObsoleteAttributeCtor => myObsoleteAttributeCtor.Value;
        public MethodReference NotSupportedExceptionCtor => myNotSupportedExceptionCtor.Value;
        public MethodReference ObfuscatedNameAttributeCtor => myObfuscatedNameAttributeCtor.Value;
        public MethodReference CallerCountAttributeCtor => myCallerCountAttributeCtor.Value;
        public MethodReference CachedScanResultsAttributeCtor => myCachedScanResultsAttributeCtor.Value;
        public MethodReference ExtensionAttributeCtor => myExtensionAttributeCtor.Value;
        

        public AssemblyKnownImports(ModuleDefinition module, RewriteGlobalContext context)
        {
            Module = module;
            myContext = context;
            
            myVoidReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.Void));
            myIntPtrReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.IntPtr));
            myStringReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.String));
            myIntReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.Int));
            myLongReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.Long));
            myTypeReference = new Lazy<TypeDefinition>(() => TargetTypeSystemHandler.Type);
            myEnumReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.Enum));
            myDelegateReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.Delegate));
            myMulticastDelegateReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.MulticastDelegate));
            myValueTypeReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.ValueType));
            myObjectReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.Object));
            myIl2CppClassPointerStoreReference = new Lazy<TypeReference>(() => Module.ImportReference(typeof(Il2CppClassPointerStore<>)));
            myIl2CppReferenceArray = new Lazy<TypeReference>(() => Module.ImportReference(typeof(Il2CppReferenceArray<>)));
            myIl2CppStructArray = new Lazy<TypeReference>(() => Module.ImportReference(typeof(Il2CppStructArray<>)));
            myIl2CppStringArray = new Lazy<TypeReference>(() => Module.ImportReference(typeof(Il2CppStringArray)));
            myIl2CppArrayBase = new Lazy<TypeReference>(() => Module.ImportReference(typeof(Il2CppArrayBase<>)));
            myIl2CppArrayBaseSetlfSubst = new Lazy<TypeReference>(() => Module.ImportReference(new GenericInstanceType(Il2CppArrayBase) { GenericArguments = { Il2CppArrayBase.GenericParameters[0] }}));
            myIl2CppObjectBaseReference = new Lazy<TypeReference>(() => Module.ImportReference(typeof(Il2CppObjectBase)));
            myDefaultMemberAttribute = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.DefaultMemberAttribute));
            // myIl2CppObjectReference = new Lazy<TypeReference>(() => Module.ImportReference(TargetTypeSystemHandler.Object));// todo!
            
            myIl2CppObjectToPointer = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("Il2CppObjectBaseToPtr")));
            myIl2CppObjectToPointerNotNull = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("Il2CppObjectBaseToPtrNotNull")));
            myStringFromNative = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("Il2CppStringToManaged")));
            myStringToNative = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("ManagedStringToIl2Cpp")));
            myIl2CppObjectCast = new Lazy<MethodReference>(() => Module.ImportReference(typeof(Il2CppObjectBase).GetMethod("Cast")));
            myIl2CppObjectTryCast = new Lazy<MethodReference>(() => Module.ImportReference(typeof(Il2CppObjectBase).GetMethod("TryCast")));
            myIl2CppResolveICall = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.ResolveICall))));
            myWriteFieldWBarrier = new Lazy<MethodReference>(() =>
                Module.ImportReference(myContext.HasGcWbarrierFieldWrite
                    ? typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_gc_wbarrier_set_field))
                    : typeof(IL2CPP).GetMethod(nameof(IL2CPP.FieldWriteWbarrierStub))));
            
            myFieldGetOffset = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("il2cpp_field_get_offset")));
            myFieldStaticGet = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("il2cpp_field_static_get_value")));
            myFieldStaticSet = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("il2cpp_field_static_set_value")));
            
            myRuntimeInvoke = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("il2cpp_runtime_invoke")));
            myRuntimeClassInit = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("il2cpp_runtime_class_init")));
            myObjectUnbox = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("il2cpp_object_unbox")));
            myObjectBox = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_value_box))));
            myValueSizeGet = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_class_value_size))));
            myObjectGetClass = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_object_get_class))));
            myClassIsValueType = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_class_is_valuetype))));
            myRaiseExceptionIfNecessary = new Lazy<MethodReference>(() => Module.ImportReference(typeof(Il2CppException).GetMethod("RaiseExceptionIfNecessary")));
            myGetVirtualMethod = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("il2cpp_object_get_virtual_method")));
            myGetFieldPtr = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("GetIl2CppField")));
            myGetIl2CppNestedClass = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("GetIl2CppNestedType")));
            myGetIl2CppGlobalClass = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("GetIl2CppClass")));
            myGetIl2CppMethod = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod("GetIl2CppMethod")));
            myGetIl2CppMethodFromToken = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.GetIl2CppMethodByToken))));
            myGetIl2CppTypeFromClass = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_class_get_type))));
            myGetIl2CppTypeToClass = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_class_from_type))));
            myIl2CppNewObject = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_object_new))));
            myIl2CppMethodInfoFromReflection = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_method_get_from_reflection))));
            myIl2CppMethodInfoToReflection = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_method_get_object))));
            myIl2CppPointerToGeneric = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.PointerToValueGeneric))));
            myIl2CppRenderTypeNameGeneric = new Lazy<MethodReference>(() => Module.ImportReference(typeof(IL2CPP).GetMethod(nameof(IL2CPP.RenderTypeName), new [] {typeof(bool)})));

            myDelegateCombine = new Lazy<MethodReference>(() =>
                Module.ImportReference(myContext.GetAssemblyByName("mscorlib").NewAssembly.MainModule.GetType("Il2CppSystem.Delegate").Methods.Single(m => m.Name == "Combine" && m.Parameters.Count == 2)));
            myDelegateRemove = new Lazy<MethodReference>(() =>
                Module.ImportReference(myContext.GetAssemblyByName("mscorlib").NewAssembly.MainModule.GetType("Il2CppSystem.Delegate").Methods.Single(m => m.Name == "Remove")));

            myLdTokUnstrippedImpl = new Lazy<MethodReference>(() =>
            {
                var declaringTypeRef = Module.ImportReference(typeof(RuntimeReflectionHelper));
                var returnTypeRef = Module.ImportReference(myContext.GetAssemblyByName("mscorlib").NewAssembly.MainModule.GetType("Il2CppSystem.RuntimeTypeHandle"));
                var methodReference = new MethodReference("GetRuntimeTypeHandle", returnTypeRef, declaringTypeRef) { HasThis = false };
                methodReference.GenericParameters.Add(new GenericParameter("T", methodReference));
                return Module.ImportReference(methodReference);
            });
            
            myFlagsAttributeCtor = new Lazy<MethodReference>(() => new MethodReference(".ctor", Void, Module.ImportReference(TargetTypeSystemHandler.FlagsAttribute)) { HasThis = true});
            myObsoleteAttributeCtor = new Lazy<MethodReference>(() =>
                new MethodReference(".ctor", Void, Module.ImportReference(TargetTypeSystemHandler.ObsoleteAttribute))
                    {HasThis = true, Parameters = {new ParameterDefinition(String)}});
            
            myNotSupportedExceptionCtor = new Lazy<MethodReference>(() =>
                new MethodReference(".ctor", Void, Module.ImportReference(TargetTypeSystemHandler.NotSupportedException))
                    {HasThis = true, Parameters = {new ParameterDefinition(String)}});
            
            myObfuscatedNameAttributeCtor = new Lazy<MethodReference>(() =>
                new MethodReference(".ctor", Void, Module.ImportReference(typeof(ObfuscatedNameAttribute)))
                    {HasThis = true, Parameters = {new ParameterDefinition(String)}});
            
            myCallerCountAttributeCtor = new Lazy<MethodReference>(() =>
                new MethodReference(".ctor", Void, Module.ImportReference(typeof(CallerCountAttribute)))
                    {HasThis = true, Parameters = {new ParameterDefinition(Int)}});
            
            myCachedScanResultsAttributeCtor = new Lazy<MethodReference>(() =>
                new MethodReference(".ctor", Void, Module.ImportReference(typeof(CachedScanResultsAttribute)))
                    {HasThis = true, Parameters = {}});

            myExtensionAttributeCtor = new Lazy<MethodReference>(() =>
                new MethodReference(".ctor", Void, Module.ImportReference(typeof(ExtensionAttribute))) { HasThis = true }
            );
        }
    }
}
```

`AssemblyUnhollower/AssemblyUnhollower.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFrameworks>net4.7.2;net5.0;netstandard2.1</TargetFrameworks>
        <Nullable>enable</Nullable>
        <Version>0.4.18.0</Version>
        <LangVersion>latest</LangVersion>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Mono.Cecil" Version="0.11.3" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\UnhollowerBaseLib\UnhollowerBaseLib.csproj" />
      <ProjectReference Include="..\UnhollowerRuntimeLib\UnhollowerRuntimeLib.csproj" />
    </ItemGroup>
</Project>

```

`AssemblyUnhollower/Contexts/AssemblyRewriteContext.cs`:

```cs
using System.Collections.Generic;
using Mono.Cecil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Contexts
{
    public class AssemblyRewriteContext
    {
        public readonly RewriteGlobalContext GlobalContext;
        
        public readonly AssemblyDefinition OriginalAssembly;
        public readonly AssemblyDefinition NewAssembly;

        private readonly Dictionary<TypeDefinition, TypeRewriteContext> myOldTypeMap = new Dictionary<TypeDefinition, TypeRewriteContext>();
        private readonly Dictionary<TypeDefinition, TypeRewriteContext> myNewTypeMap = new Dictionary<TypeDefinition, TypeRewriteContext>();
        private readonly Dictionary<string, TypeRewriteContext> myNameTypeMap = new Dictionary<string, TypeRewriteContext>();

        public readonly AssemblyKnownImports Imports;

        public IEnumerable<TypeRewriteContext> Types => myOldTypeMap.Values;

        public AssemblyRewriteContext(RewriteGlobalContext globalContext, AssemblyDefinition originalAssembly, AssemblyDefinition newAssembly)
        {
            OriginalAssembly = originalAssembly;
            NewAssembly = newAssembly;
            GlobalContext = globalContext;

            Imports = AssemblyKnownImports.For(newAssembly.MainModule, globalContext);
        }

        public TypeRewriteContext GetContextForOriginalType(TypeDefinition type) => myOldTypeMap[type];
        public TypeRewriteContext? TryGetContextForOriginalType(TypeDefinition type) => myOldTypeMap.TryGetValue(type, out var result) ? result : null;
        public TypeRewriteContext GetContextForNewType(TypeDefinition type) => myNewTypeMap[type];

        public void RegisterTypeRewrite(TypeRewriteContext context)
        {
            if (context.OriginalType != null)
                myOldTypeMap[context.OriginalType] = context;
            myNewTypeMap[context.NewType] = context;
            myNameTypeMap[(context.OriginalType ?? context.NewType).FullName] = context;
        }

        public MethodReference RewriteMethodRef(MethodReference methodRef)
        {
            var newType = GlobalContext.GetNewTypeForOriginal(methodRef.DeclaringType.Resolve());
            return newType.GetMethodByOldMethod(methodRef.Resolve()).NewMethod; 
        }
        
        public TypeReference RewriteTypeRef(TypeReference? typeRef)
        {
            if (typeRef == null) return Imports.Il2CppObjectBase;
            
            var sourceModule = NewAssembly.MainModule;

            if (typeRef is ArrayType arrayType)
            {
                if (arrayType.Rank != 1)
                    return Imports.Il2CppObjectBase;
                
                var elementType = arrayType.ElementType;
                if (elementType.FullName == "System.String")
                    return Imports.Il2CppStringArray;

                var convertedElementType = RewriteTypeRef(elementType);
                if (elementType.IsGenericParameter)
                    return new GenericInstanceType(Imports.Il2CppArrayBase) {GenericArguments = {convertedElementType}};
                
                return new GenericInstanceType(convertedElementType.IsValueType
                    ? Imports.Il2CppStructArray
                    : Imports.Il2CppReferenceArray) {GenericArguments = {convertedElementType}};
            }

            if (typeRef is GenericParameter genericParameter)
            {
                var genericParameterDeclaringType = genericParameter.DeclaringType;
                if(genericParameterDeclaringType != null)
                    return RewriteTypeRef(genericParameterDeclaringType).GenericParameters[genericParameter.Position];

                return RewriteMethodRef(genericParameter.DeclaringMethod).GenericParameters[genericParameter.Position];
            }

            if (typeRef is ByReferenceType byRef)
                return new ByReferenceType(RewriteTypeRef(byRef.ElementType));

            if(typeRef is PointerType pointerType)
                return new PointerType(RewriteTypeRef(pointerType.ElementType));

            if (typeRef is GenericInstanceType genericInstance)
            {
                var newRef = new GenericInstanceType(RewriteTypeRef(genericInstance.ElementType));
                foreach (var originalParameter in genericInstance.GenericArguments)
                    newRef.GenericArguments.Add(RewriteTypeRef(originalParameter));

                return newRef;
            }

            if (typeRef.IsPrimitive || typeRef.FullName == "System.TypedReference")
                return sourceModule.ImportReference(TargetTypeSystemHandler.Object.Module.GetType(typeRef.Namespace, typeRef.Name));
            
            if (typeRef.FullName == "System.Void")
                return Imports.Void;

            if (typeRef.FullName == "System.String")
                return Imports.String;

            if(typeRef.FullName == "System.Object")
                return sourceModule.ImportReference(GlobalContext.GetAssemblyByName("mscorlib").GetTypeByName("System.Object").NewType);

            if (typeRef.FullName == "System.Attribute")
                return sourceModule.ImportReference(GlobalContext.GetAssemblyByName("mscorlib").GetTypeByName("System.Attribute").NewType);

            var originalTypeDef = typeRef.Resolve();
            var targetAssembly = GlobalContext.GetNewAssemblyForOriginal(originalTypeDef.Module.Assembly);
            var target = targetAssembly.GetContextForOriginalType(originalTypeDef).NewType;

            return sourceModule.ImportReference(target);
        }

        public TypeRewriteContext GetTypeByName(string name)
        {
            return myNameTypeMap[name];
        }
        
        public TypeRewriteContext? TryGetTypeByName(string name)
        {
            return myNameTypeMap.TryGetValue(name, out var result) ? result : null;
        }
    }
}
```

`AssemblyUnhollower/Contexts/FieldRewriteContext.cs`:

```cs
using System;
using System.Collections.Generic;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;

namespace AssemblyUnhollower.Contexts
{
    public class FieldRewriteContext
    {
        public readonly TypeRewriteContext DeclaringType;
        public readonly FieldDefinition OriginalField;
        public readonly string UnmangledName;

        public readonly FieldReference PointerField;

        public FieldRewriteContext(TypeRewriteContext declaringType, FieldDefinition originalField, Dictionary<string, int>? renamedFieldCounts = null)
        {
            DeclaringType = declaringType;
            OriginalField = originalField;

            UnmangledName = UnmangleFieldName(originalField, declaringType.AssemblyContext.GlobalContext.Options, renamedFieldCounts);
            var pointerField = new FieldDefinition("NativeFieldInfoPtr_" + UnmangledName, FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.InitOnly, declaringType.AssemblyContext.Imports.IntPtr);
            
            declaringType.NewType.Fields.Add(pointerField);
            
            PointerField = new FieldReference(pointerField.Name, pointerField.FieldType, DeclaringType.SelfSubstitutedRef);
        }

        private static readonly string[] MethodAccessTypeLabels = { "CompilerControlled", "Private", "FamAndAssem", "Internal", "Protected", "FamOrAssem", "Public"};
        private string UnmangleFieldNameBase(FieldDefinition field, UnhollowerOptions options)
        {
            if (options.PassthroughNames) return field.Name;
            
            if (!field.Name.IsObfuscated(options))
            {
                if(!field.Name.IsInvalidInSource())
                    return field.Name;
                return field.Name.FilterInvalidInSourceChars();
            }

            var accessModString = MethodAccessTypeLabels[(int) (field.Attributes & FieldAttributes.FieldAccessMask)];
            var staticString = field.IsStatic ? "_Static" : "";
            return "field_" + accessModString + staticString + "_" + DeclaringType.AssemblyContext.RewriteTypeRef(field.FieldType).GetUnmangledName();
        }
        
        private string UnmangleFieldName(FieldDefinition field, UnhollowerOptions options, Dictionary<string, int>? renamedFieldCounts)
        {
            if (options.PassthroughNames) return field.Name;
            
            if (!field.Name.IsObfuscated(options))
            {
                if(!field.Name.IsInvalidInSource())
                    return field.Name;
                return field.Name.FilterInvalidInSourceChars();
            }

            if (renamedFieldCounts == null) throw new ArgumentNullException(nameof(renamedFieldCounts));

            var unmangleFieldNameBase = UnmangleFieldNameBase(field, options);

            renamedFieldCounts.TryGetValue(unmangleFieldNameBase, out var count);
            renamedFieldCounts[unmangleFieldNameBase] = count + 1;

            unmangleFieldNameBase += "_" + count;
            
            if (DeclaringType.AssemblyContext.GlobalContext.Options.RenameMap.TryGetValue(
                DeclaringType.NewType.GetNamespacePrefix() + "." + DeclaringType.NewType.Name + "::" + unmangleFieldNameBase, out var newName))
                unmangleFieldNameBase = newName;
            
            return unmangleFieldNameBase;
        }
    }
}
```

`AssemblyUnhollower/Contexts/MethodRewriteContext.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using AssemblyUnhollower.Extensions;
using AssemblyUnhollower.Passes;
using Mono.Cecil;
using UnhollowerRuntimeLib.XrefScans;

namespace AssemblyUnhollower.Contexts
{
    public class MethodRewriteContext
    {
        public readonly TypeRewriteContext DeclaringType;
        public readonly MethodDefinition OriginalMethod;
        public readonly MethodDefinition NewMethod;

        public readonly bool OriginalNameObfuscated;

        public readonly long FileOffset;
        public readonly long Rva;

        public long MetadataInitFlagRva;
        public long MetadataInitTokenRva;

        public string UnmangledName { get; private set; }
        public string UnmangledNameWithSignature { get; private set; }
        
        public TypeDefinition? GenericInstantiationsStore { get; private set; }
        public TypeReference? GenericInstantiationsStoreSelfSubstRef { get; private set; }
        public TypeReference? GenericInstantiationsStoreSelfSubstMethodRef { get; private set; }
        public FieldReference NonGenericMethodInfoPointerField { get; private set; }

        public readonly List<XrefInstance> XrefScanResults = new List<XrefInstance>();

        public MethodRewriteContext(TypeRewriteContext declaringType, MethodDefinition originalMethod)
        {
            DeclaringType = declaringType;
            OriginalMethod = originalMethod;

            var passthroughNames = declaringType.AssemblyContext.GlobalContext.Options.PassthroughNames;

            OriginalNameObfuscated = !passthroughNames &&
                                     (OriginalMethod?.Name?.IsObfuscated(declaringType.AssemblyContext.GlobalContext
                                         .Options) ?? false);

            var newMethod = new MethodDefinition("", AdjustAttributes(originalMethod.Attributes), declaringType.AssemblyContext.Imports.Void);
            NewMethod = newMethod;

            if (originalMethod.CustomAttributes.Any(x => x.AttributeType.FullName == typeof(ExtensionAttribute).FullName))
            {
                newMethod.CustomAttributes.Add(new CustomAttribute(declaringType.AssemblyContext.Imports.ExtensionAttributeCtor));
            }

            if (originalMethod.HasGenericParameters)
            {
                var genericParams = originalMethod.GenericParameters;

                foreach (var oldParameter in genericParams)
                {
                    var genericParameter = new GenericParameter(oldParameter.Name, newMethod);
                    genericParameter.Attributes = oldParameter.Attributes.StripValueTypeConstraint();
                    newMethod.GenericParameters.Add(genericParameter);
                }
            }

            if (!Pass15GenerateMemberContexts.HasObfuscatedMethods && !passthroughNames && originalMethod.Name.IsObfuscated(declaringType.AssemblyContext.GlobalContext.Options))
                Pass15GenerateMemberContexts.HasObfuscatedMethods = true;

            FileOffset = originalMethod.ExtractOffset();
            Rva = originalMethod.ExtractRva();
            if (FileOffset != 0)
                declaringType.AssemblyContext.GlobalContext.MethodStartAddresses.Add(FileOffset);
        }

        public void CtorPhase2()
        {
            UnmangledName = UnmangleMethodName();
            UnmangledNameWithSignature = UnmangleMethodNameWithSignature();

            NewMethod.Name = UnmangledName;
            NewMethod.ReturnType = DeclaringType.AssemblyContext.RewriteTypeRef(OriginalMethod.ReturnType);
                
            var nonGenericMethodInfoPointerField = new FieldDefinition(
                "NativeMethodInfoPtr_" + UnmangledNameWithSignature,
                FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.InitOnly,
                DeclaringType.AssemblyContext.Imports.IntPtr);
            DeclaringType.NewType.Fields.Add(nonGenericMethodInfoPointerField);

            NonGenericMethodInfoPointerField = new FieldReference(nonGenericMethodInfoPointerField.Name,
                nonGenericMethodInfoPointerField.FieldType, DeclaringType.SelfSubstitutedRef);
            
            if (OriginalMethod.HasGenericParameters)
            {
                var genericParams = OriginalMethod.GenericParameters;
                var genericMethodInfoStoreType = new TypeDefinition("", "MethodInfoStoreGeneric_" + UnmangledNameWithSignature + "`" + genericParams.Count, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit, DeclaringType.AssemblyContext.Imports.Object);
                genericMethodInfoStoreType.DeclaringType = DeclaringType.NewType;
                DeclaringType.NewType.NestedTypes.Add(genericMethodInfoStoreType);
                GenericInstantiationsStore = genericMethodInfoStoreType;
                
                var selfSubstRef = new GenericInstanceType(genericMethodInfoStoreType);
                var selfSubstMethodRef = new GenericInstanceType(genericMethodInfoStoreType);

                for (var index = 0; index < genericParams.Count; index++)
                {
                    var oldParameter = genericParams[index];
                    var genericParameter = new GenericParameter(oldParameter.Name, genericMethodInfoStoreType);
                    genericMethodInfoStoreType.GenericParameters.Add(genericParameter);
                    selfSubstRef.GenericArguments.Add(genericParameter);
                    var newParameter = NewMethod.GenericParameters[index];
                    selfSubstMethodRef.GenericArguments.Add(newParameter);
                    
                    foreach (var oldConstraint in oldParameter.Constraints)
                    {
                        if (oldConstraint.ConstraintType.FullName == "System.ValueType" || oldConstraint.ConstraintType.Resolve()?.IsInterface == true) continue;
                        
                        newParameter.Constraints.Add(new GenericParameterConstraint(
                            DeclaringType.AssemblyContext.RewriteTypeRef(oldConstraint.ConstraintType)));
                    }
                }

                var pointerField = new FieldDefinition("Pointer", FieldAttributes.Assembly | FieldAttributes.Static, DeclaringType.AssemblyContext.Imports.IntPtr);
                genericMethodInfoStoreType.Fields.Add(pointerField);

                GenericInstantiationsStoreSelfSubstRef = DeclaringType.NewType.Module.ImportReference(selfSubstRef);
                GenericInstantiationsStoreSelfSubstMethodRef = DeclaringType.NewType.Module.ImportReference(selfSubstMethodRef);
            }
            
            DeclaringType.NewType.Methods.Add(NewMethod);
        }

        private MethodAttributes AdjustAttributes(MethodAttributes original)
        {
            original &= ~(MethodAttributes.MemberAccessMask); // todo: handle Object overload correctly
            original &= ~(MethodAttributes.PInvokeImpl);
            original &= ~(MethodAttributes.Abstract);
            original &= ~(MethodAttributes.Virtual);
            original &= ~(MethodAttributes.Final);
            original &= ~(MethodAttributes.NewSlot);
            original &= ~(MethodAttributes.ReuseSlot);
            original &= ~(MethodAttributes.CheckAccessOnOverride);
            original |= MethodAttributes.Public;
            return original;
        }

        private string UnmangleMethodName()
        {
            var method = OriginalMethod;
            
            if (method.Name == "GetType" && method.Parameters.Count == 0)
                return "GetIl2CppType";
            
            if (DeclaringType.AssemblyContext.GlobalContext.Options.PassthroughNames)
                return method.Name;
            
            if (method.Name == ".ctor")
                return ".ctor";
            
            if(method.Name.IsObfuscated(DeclaringType.AssemblyContext.GlobalContext.Options))
                return UnmangleMethodNameWithSignature();

            if (method.Name.IsInvalidInSource())
                return method.Name.FilterInvalidInSourceChars();

            return method.Name;
        }

        private static readonly string[] MethodAccessTypeLabels = { "CompilerControlled", "Private", "FamAndAssem", "Internal", "Protected", "FamOrAssem", "Public"};
        private static readonly (MethodSemanticsAttributes, string)[] SemanticsToCheck =
        {
            (MethodSemanticsAttributes.Setter, "_set"),
            (MethodSemanticsAttributes.Getter, "_get"),
            (MethodSemanticsAttributes.Other, "_oth"),
            (MethodSemanticsAttributes.AddOn, "_add"),
            (MethodSemanticsAttributes.RemoveOn, "_rem"),
            (MethodSemanticsAttributes.Fire, "_fire"),
        };
        private string ProduceMethodSignatureBase()
        {
            var method = OriginalMethod;
            
            var name = method.Name;
            if (method.Name.IsObfuscated(DeclaringType.AssemblyContext.GlobalContext.Options))
                name = "Method";

            if (name.IsInvalidInSource())
                name = name.FilterInvalidInSourceChars();

            if (method.Name == "GetType" && method.Parameters.Count == 0)
                name = "GetIl2CppType";

            var builder = new StringBuilder();
            builder.Append(name);
            builder.Append('_');
            builder.Append(MethodAccessTypeLabels[(int) (method.Attributes & MethodAttributes.MemberAccessMask)]);
            if (method.IsAbstract) builder.Append("_Abstract");
            if (method.IsVirtual) builder.Append("_Virtual");
            if (method.IsStatic) builder.Append("_Static");
            if (method.IsFinal) builder.Append("_Final");
            if (method.IsNewSlot) builder.Append("_New");
            foreach (var (semantic, str) in SemanticsToCheck)
                if ((semantic & method.SemanticsAttributes) != 0)
                    builder.Append(str);

            builder.Append('_');
            builder.Append(DeclaringType.AssemblyContext.RewriteTypeRef(method.ReturnType).GetUnmangledName());
            
            foreach (var param in method.Parameters)
            {
                builder.Append('_');
                builder.Append(DeclaringType.AssemblyContext.RewriteTypeRef(param.ParameterType).GetUnmangledName());
            }
            
            var address = Rva;
            if (address != 0 && Pass15GenerateMemberContexts.HasObfuscatedMethods && !Pass16ScanMethodRefs.NonDeadMethods.Contains(address)) builder.Append("_PDM");

            return builder.ToString();
        }

        
        private string UnmangleMethodNameWithSignature()
        {
            var unmangleMethodNameWithSignature = ProduceMethodSignatureBase() + "_" + DeclaringType.Methods.Where(ParameterSignatureMatchesThis).TakeWhile(it => it != this).Count();
            if (DeclaringType.AssemblyContext.GlobalContext.Options.RenameMap.TryGetValue(
                DeclaringType.NewType.GetNamespacePrefix() + "::" + unmangleMethodNameWithSignature, out var newName))
                unmangleMethodNameWithSignature = newName;
            return unmangleMethodNameWithSignature;
        }
        
        private bool ParameterSignatureMatchesThis(MethodRewriteContext otherRewriteContext)
        {
            var aM = otherRewriteContext.OriginalMethod;
            var bM = OriginalMethod;
            
            if (!otherRewriteContext.OriginalNameObfuscated)
                return false;
            
            var comparisonMask = MethodAttributes.MemberAccessMask | MethodAttributes.Static | MethodAttributes.Final |
                                 MethodAttributes.Abstract | MethodAttributes.Virtual | MethodAttributes.NewSlot;
            if ((aM.Attributes & comparisonMask) !=
                (bM.Attributes & comparisonMask))
                return false;

            if (aM.SemanticsAttributes != bM.SemanticsAttributes)
                return false;

            if (aM.ReturnType.FullName != bM.ReturnType.FullName)
                return false;

            var a = aM.Parameters;
            var b = bM.Parameters;
            
            if (a.Count != b.Count)
                return false;

            for (var i = 0; i < a.Count; i++)
            {
                if (a[i].ParameterType.FullName != b[i].ParameterType.FullName)
                    return false;
            }

            if (Pass15GenerateMemberContexts.HasObfuscatedMethods)
            {
                var addressA = otherRewriteContext.Rva;
                var addressB = Rva;
                if (addressA != 0 && addressB != 0)
                    if (Pass16ScanMethodRefs.NonDeadMethods.Contains(addressA) != Pass16ScanMethodRefs.NonDeadMethods.Contains(addressB))
                        return false;
            }

            return true;
        }
    }
}
```

`AssemblyUnhollower/Contexts/RewriteGlobalContext.cs`:

```cs
using System;
using System.Collections.Generic;
using AssemblyUnhollower.Extensions;
using AssemblyUnhollower.MetadataAccess;
using Mono.Cecil;

namespace AssemblyUnhollower.Contexts
{
    public class RewriteGlobalContext : IDisposable
    {
        public UnhollowerOptions Options { get; }
        public IIl2CppMetadataAccess GameAssemblies { get; }
        public IMetadataAccess SystemAssemblies { get; }
        public IMetadataAccess UnityAssemblies { get; }
        
        private readonly Dictionary<string, AssemblyRewriteContext> myAssemblies = new Dictionary<string, AssemblyRewriteContext>();
        private readonly Dictionary<AssemblyDefinition, AssemblyRewriteContext> myAssembliesByOld = new Dictionary<AssemblyDefinition, AssemblyRewriteContext>();
        
        internal readonly Dictionary<(object, string, int), List<TypeDefinition>> RenameGroups = new Dictionary<(object, string, int), List<TypeDefinition>>();
        internal readonly Dictionary<TypeDefinition, string> RenamedTypes = new Dictionary<TypeDefinition, string>();
        internal readonly Dictionary<TypeDefinition, string> PreviousRenamedTypes = new Dictionary<TypeDefinition, string>();

        internal readonly List<long> MethodStartAddresses = new List<long>();

        public IEnumerable<AssemblyRewriteContext> Assemblies => myAssemblies.Values;
        
        internal bool HasGcWbarrierFieldWrite { get; set; }
        
        public RewriteGlobalContext(UnhollowerOptions options, IIl2CppMetadataAccess gameAssemblies, IMetadataAccess systemAssemblies, IMetadataAccess unityAssemblies)
        {
            Options = options;
            GameAssemblies = gameAssemblies;
            SystemAssemblies = systemAssemblies;
            UnityAssemblies = unityAssemblies;
            
            TargetTypeSystemHandler.Init(systemAssemblies);
            
            foreach (var sourceAssembly in gameAssemblies.Assemblies)
            {
                var assemblyName = sourceAssembly.Name.Name;
                if (assemblyName == "Il2CppDummyDll") continue;
                
                var newAssembly = AssemblyDefinition.CreateAssembly(
                    new AssemblyNameDefinition(sourceAssembly.Name.Name.UnSystemify(options), sourceAssembly.Name.Version),
                    sourceAssembly.MainModule.Name.UnSystemify(options), sourceAssembly.MainModule.Kind);

                var assemblyRewriteContext = new AssemblyRewriteContext(this, sourceAssembly, newAssembly);
                AddAssemblyContext(assemblyName, assemblyRewriteContext);
            }
        }

        internal void AddAssemblyContext(string assemblyName, AssemblyRewriteContext context)
        {
            myAssemblies[assemblyName] = context;
            if (context.OriginalAssembly != null)
                myAssembliesByOld[context.OriginalAssembly] = context;
        }

        public AssemblyRewriteContext GetNewAssemblyForOriginal(AssemblyDefinition oldAssembly)
        {
            return myAssembliesByOld[oldAssembly];
        }

        public TypeRewriteContext GetNewTypeForOriginal(TypeDefinition originalType)
        {
            return GetNewAssemblyForOriginal(originalType.Module.Assembly)
                .GetContextForOriginalType(originalType);
        }
        
        public TypeRewriteContext? TryGetNewTypeForOriginal(TypeDefinition originalType)
        {
            if (!myAssembliesByOld.TryGetValue(originalType.Module.Assembly, out var assembly))
                return null;
            return assembly.TryGetContextForOriginalType(originalType);
        }
        
        public TypeRewriteContext.TypeSpecifics JudgeSpecificsByOriginalType(TypeReference typeRef)
        {
            if (typeRef.IsPrimitive || typeRef.IsPointer || typeRef.FullName == "System.TypedReference") return TypeRewriteContext.TypeSpecifics.BlittableStruct;
            if (typeRef.FullName == "System.String" || typeRef.FullName == "System.Object" || typeRef.IsArray || typeRef.IsByReference || typeRef.IsGenericParameter || typeRef.IsGenericInstance)
                return TypeRewriteContext.TypeSpecifics.ReferenceType;

            var fieldTypeContext = GetNewTypeForOriginal(typeRef.Resolve());
            return fieldTypeContext.ComputedTypeSpecifics;
        }

        public AssemblyRewriteContext GetAssemblyByName(string name)
        {
            return myAssemblies[name];
        }
        
        public AssemblyRewriteContext? TryGetAssemblyByName(string name)
        {
            if (myAssemblies.TryGetValue(name, out var result))
                return result;

            if (name == "netstandard")
                return myAssemblies.TryGetValue("mscorlib", out var result2) ? result2 : null;
            
            return null;
        }

        public void Dispose()
        {
            foreach (var assembly in Assemblies)
            {
                assembly.NewAssembly.Dispose();
                assembly.OriginalAssembly.Dispose();
            }
        }
    }
}
```

`AssemblyUnhollower/Contexts/TypeRewriteContext.cs`:

```cs
using System;
using System.Collections.Generic;
using Mono.Cecil;

namespace AssemblyUnhollower.Contexts
{
    public class TypeRewriteContext
    {
        public readonly AssemblyRewriteContext AssemblyContext;
        public readonly TypeDefinition OriginalType;
        public readonly TypeDefinition NewType;

        public readonly bool OriginalNameWasObfuscated;

        public FieldReference ClassPointerFieldRef { get; private set; }
        public TypeReference SelfSubstitutedRef { get; private set; }

        public TypeSpecifics ComputedTypeSpecifics;

        private readonly Dictionary<FieldDefinition, FieldRewriteContext> myFieldContexts = new Dictionary<FieldDefinition, FieldRewriteContext>();
        private readonly Dictionary<MethodDefinition, MethodRewriteContext> myMethodContexts = new Dictionary<MethodDefinition, MethodRewriteContext>();
        private readonly Dictionary<string, MethodRewriteContext> myMethodContextsByName = new Dictionary<string, MethodRewriteContext>();

        public IEnumerable<FieldRewriteContext> Fields => myFieldContexts.Values;
        public IEnumerable<MethodRewriteContext> Methods => myMethodContexts.Values;

        public TypeRewriteContext(AssemblyRewriteContext assemblyContext, TypeDefinition originalType, TypeDefinition newType)
        {
            AssemblyContext = assemblyContext ?? throw new ArgumentNullException(nameof(assemblyContext));
            OriginalType = originalType;
            NewType = newType ?? throw new ArgumentNullException(nameof(newType));

            if (OriginalType == null) return;
            
            OriginalNameWasObfuscated = OriginalType.Name != NewType.Name;
            if (OriginalNameWasObfuscated)
                NewType.CustomAttributes.Add(new CustomAttribute(assemblyContext.Imports.ObfuscatedNameAttributeCtor)
                    {ConstructorArguments = {new CustomAttributeArgument(assemblyContext.Imports.String, originalType.FullName)}});

            if (!OriginalType.IsValueType)
                ComputedTypeSpecifics = TypeSpecifics.ReferenceType;
            else if (OriginalType.IsEnum)
                ComputedTypeSpecifics = TypeSpecifics.BlittableStruct;
            else if (OriginalType.HasGenericParameters)
                ComputedTypeSpecifics = TypeSpecifics.NonBlittableStruct; // not reference type, covered by first if
        }

        public void AddMembers()
        {
            if (NewType.HasGenericParameters)
            {
                var genericInstanceType = new GenericInstanceType(NewType);
                foreach (var newTypeGenericParameter in NewType.GenericParameters)
                    genericInstanceType.GenericArguments.Add(newTypeGenericParameter);
                SelfSubstitutedRef = NewType.Module.ImportReference(genericInstanceType);
                var genericTypeRef = new GenericInstanceType(AssemblyContext.Imports.Il2CppClassPointerStore)
                    {GenericArguments = {SelfSubstitutedRef}};
                ClassPointerFieldRef = new FieldReference("NativeClassPtr", AssemblyContext.Imports.IntPtr,
                    NewType.Module.ImportReference(genericTypeRef));
            }
            else
            {
                SelfSubstitutedRef = NewType;
                var genericTypeRef = new GenericInstanceType(AssemblyContext.Imports.Il2CppClassPointerStore);
                if(OriginalType.IsPrimitive || OriginalType.FullName == "System.String")
                    genericTypeRef.GenericArguments.Add(NewType.Module.ImportReference(TargetTypeSystemHandler.Type.Module.GetType(OriginalType.FullName)));
                else
                    genericTypeRef.GenericArguments.Add(SelfSubstitutedRef);
                ClassPointerFieldRef = new FieldReference("NativeClassPtr", AssemblyContext.Imports.IntPtr,
                    NewType.Module.ImportReference(genericTypeRef));
            }

            if (OriginalType.IsEnum) return;

            var renamedFieldCounts = new Dictionary<string, int>();
            
            foreach (var originalTypeField in OriginalType.Fields)
                myFieldContexts[originalTypeField] = new FieldRewriteContext(this, originalTypeField, renamedFieldCounts);

            foreach (var originalTypeMethod in OriginalType.Methods)
            {
                if (originalTypeMethod.Name == ".cctor") continue;
                if (originalTypeMethod.Name == ".ctor" && originalTypeMethod.Parameters.Count == 1 &&
                    originalTypeMethod.Parameters[0].ParameterType.FullName == "System.IntPtr") continue;

                var methodRewriteContext = new MethodRewriteContext(this, originalTypeMethod);
                myMethodContexts[originalTypeMethod] = methodRewriteContext;
                myMethodContextsByName[originalTypeMethod.Name] = methodRewriteContext;
            }
        }

        public FieldRewriteContext GetFieldByOldField(FieldDefinition field) => myFieldContexts[field];
        public MethodRewriteContext GetMethodByOldMethod(MethodDefinition method) => myMethodContexts[method];
        public MethodRewriteContext? TryGetMethodByOldMethod(MethodDefinition method) => myMethodContexts.TryGetValue(method, out var result) ? result : null;
        public MethodRewriteContext? TryGetMethodByName(string name) => myMethodContextsByName.TryGetValue(name, out var result) ? result : null;
        public MethodRewriteContext? TryGetMethodByUnityAssemblyMethod(MethodDefinition method)
        {
            foreach (var methodRewriteContext in myMethodContexts)
            {
                var originalMethod = methodRewriteContext.Value.OriginalMethod;
                if (originalMethod.Name != method.Name) continue;
                if (originalMethod.Parameters.Count != method.Parameters.Count) continue;
                var badMethod = false;
                for (var i = 0; i < originalMethod.Parameters.Count; i++)
                {
                    if (originalMethod.Parameters[i].ParameterType.FullName != method.Parameters[i].ParameterType.FullName)
                    {
                        badMethod = true;
                        break;
                    }
                }
                if (badMethod) continue;

                return methodRewriteContext.Value;
            }

            return null;
        }
        
        public FieldRewriteContext? TryGetFieldByUnityAssemblyField(FieldDefinition field)
        {
            foreach (var fieldRewriteContext in myFieldContexts)
            {
                var originalField = fieldRewriteContext.Value.OriginalField;
                if (originalField.Name != field.Name) continue;

                if (originalField.FieldType.FullName != field.FieldType.FullName)
                    continue;

                return fieldRewriteContext.Value;
            }

            return null;
        }

        public enum TypeSpecifics
        {
            NotComputed,
            Computing,
            ReferenceType,
            BlittableStruct,
            NonBlittableStruct
        }
    }
}
```

`AssemblyUnhollower/DeobfuscationMapGenerator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using AssemblyUnhollower.MetadataAccess;
using AssemblyUnhollower.Passes;
using Mono.Cecil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower
{
    public static class DeobfuscationMapGenerator
    {
        public static void GenerateDeobfuscationMap(UnhollowerOptions options)
        {
            if (string.IsNullOrEmpty(options.SourceDir))
            {
                Console.WriteLine("No input dir specified; use -h for help");
                return;
            }
            
            if (string.IsNullOrEmpty(options.OutputDir))
            {
                Console.WriteLine("No target dir specified; use -h for help");
                return;
            }
            if (string.IsNullOrEmpty(options.DeobfuscationNewAssembliesPath))
            {
                Console.WriteLine("No obfuscated assembly path specified; use -h for help");
                return;
            }

            if (!Directory.Exists(options.OutputDir))
                Directory.CreateDirectory(options.OutputDir);

            RewriteGlobalContext rewriteContext;
            IIl2CppMetadataAccess inputAssemblies;
            IIl2CppMetadataAccess systemAssemblies;
            using (new TimingCookie("Reading assemblies"))
                inputAssemblies = new CecilMetadataAccess(Directory.EnumerateFiles(options.DeobfuscationNewAssembliesPath, "*.dll"));
            
            using (new TimingCookie("Reading system assemblies"))
            {
                if (!string.IsNullOrEmpty(options.SystemLibrariesPath)) 
                    systemAssemblies = new CecilMetadataAccess(Directory.EnumerateFiles(options.SystemLibrariesPath, "*.dll")
                        .Where(it => Path.GetFileName(it).StartsWith("System.") || Path.GetFileName(it) == "mscorlib.dll" || Path.GetFileName(it) == "netstandard.dll"));
                else
                    systemAssemblies = new CecilMetadataAccess(new[] {options.MscorlibPath});

            }
            
            using(new TimingCookie("Creating rewrite assemblies"))
                rewriteContext = new RewriteGlobalContext(options, inputAssemblies, systemAssemblies, NullMetadataAccess.Instance);
            using(new TimingCookie("Computing renames"))
                Pass05CreateRenameGroups.DoPass(rewriteContext);
            using(new TimingCookie("Creating typedefs"))
                Pass10CreateTypedefs.DoPass(rewriteContext);
            using(new TimingCookie("Computing struct blittability"))
                Pass11ComputeTypeSpecifics.DoPass(rewriteContext);
            using(new TimingCookie("Filling typedefs"))
                Pass12FillTypedefs.DoPass(rewriteContext);
            using(new TimingCookie("Filling generic constraints"))
                Pass13FillGenericConstraints.DoPass(rewriteContext);
            using(new TimingCookie("Creating members"))
                Pass15GenerateMemberContexts.DoPass(rewriteContext);


            RewriteGlobalContext cleanContext;
            IIl2CppMetadataAccess cleanAssemblies;
            using (new TimingCookie("Reading clean assemblies"))
                cleanAssemblies = new CecilMetadataAccess(Directory.EnumerateFiles(options.SourceDir, "*.dll"));
            
            using(new TimingCookie("Creating clean rewrite assemblies"))
                cleanContext = new RewriteGlobalContext(options, cleanAssemblies, systemAssemblies, NullMetadataAccess.Instance);
            using(new TimingCookie("Computing clean assembly renames"))
                Pass05CreateRenameGroups.DoPass(cleanContext);
            using(new TimingCookie("Creating clean assembly typedefs"))
                Pass10CreateTypedefs.DoPass(cleanContext);


            var usedNames = new Dictionary<TypeDefinition, (string OldName, int Penalty, bool ForceNs)>();
            
            using var fileOutput = new FileStream(options.OutputDir + Path.DirectorySeparatorChar + "RenameMap.csv.gz", FileMode.Create, FileAccess.Write);
            using var gzipStream = new GZipStream(fileOutput, CompressionLevel.Optimal, true);
            using var writer = new StreamWriter(gzipStream, Encoding.UTF8, 65536, true);

            void DoEnum(TypeRewriteContext obfuscatedType, TypeRewriteContext cleanType)
            {
                foreach (var originalTypeField in obfuscatedType.OriginalType.Fields)
                {
                    if (!originalTypeField.Name.IsObfuscated(obfuscatedType.AssemblyContext.GlobalContext.Options)) continue;
                    var matchedField = cleanType.OriginalType.Fields[obfuscatedType.OriginalType.Fields.IndexOf(originalTypeField)];
                    
                    writer.WriteLine(obfuscatedType.NewType.GetNamespacePrefix() + "." + obfuscatedType.NewType.Name + "::" + Pass22GenerateEnums.GetUnmangledName(originalTypeField) + ";" + matchedField.Name + ";0");
                }
            }
            
            foreach (var assemblyContext in rewriteContext.Assemblies)
            {
                if (options.DeobfuscationGenerationAssemblies.Count > 0 &&
                    !options.DeobfuscationGenerationAssemblies.Contains(assemblyContext.NewAssembly.Name.Name))
                    continue;

                var cleanAssembly = cleanContext.GetAssemblyByName(assemblyContext.OriginalAssembly.Name.Name);

                void DoType(TypeRewriteContext typeContext, TypeRewriteContext? enclosingType)
                {
                    if (!typeContext.OriginalNameWasObfuscated) return;

                    var cleanType = FindBestMatchType(typeContext, cleanAssembly, enclosingType);
                    if (cleanType.Item1 == null) return;
                    
                    if (!usedNames.TryGetValue(cleanType.Item1.NewType, out var existing) || existing.Item2 < cleanType.Item2)
                    {
                        usedNames[cleanType.Item1.NewType] = (typeContext.NewType.GetNamespacePrefix() + "." + typeContext.NewType.Name, cleanType.Item2, typeContext.OriginalType.Namespace != cleanType.Item1.OriginalType.Namespace);
                    } else 
                        return;

                    if (typeContext.OriginalType.IsEnum) 
                        DoEnum(typeContext, cleanType.Item1);

                    foreach (var originalTypeNestedType in typeContext.OriginalType.NestedTypes)
                        DoType(typeContext.AssemblyContext.GetContextForOriginalType(originalTypeNestedType), cleanType.Item1);
                }
                
                foreach (var typeContext in assemblyContext.Types)
                {
                    if(typeContext.NewType.DeclaringType != null) continue;
                    
                    DoType(typeContext, null);
                }
            }
            
            
            foreach (var keyValuePair in usedNames)
                writer.WriteLine(keyValuePair.Value.Item1 + ";" + (keyValuePair.Value.ForceNs ? keyValuePair.Key.Namespace + "." : "") + keyValuePair.Key.Name + ";" + keyValuePair.Value.Item2);

            LogSupport.Info("Done!");

            rewriteContext.Dispose();
        }

        private static (TypeRewriteContext?, int) FindBestMatchType(TypeRewriteContext obfType, AssemblyRewriteContext cleanAssembly, TypeRewriteContext? enclosingCleanType)
        {
            var inheritanceDepthOfOriginal = 0;
            var currentBase = obfType.OriginalType.BaseType;
            while (true)
            {
                if (currentBase == null) break;
                var currentBaseContext = obfType.AssemblyContext.GlobalContext.TryGetNewTypeForOriginal(currentBase.Resolve());
                if (currentBaseContext == null || !currentBaseContext.OriginalNameWasObfuscated) break;

                inheritanceDepthOfOriginal++;
                currentBase = currentBaseContext.OriginalType.BaseType;
            }

            var bestPenalty = int.MinValue;
            TypeRewriteContext? bestMatch = null;

            var source = enclosingCleanType?.OriginalType.NestedTypes.Select(it => cleanAssembly.GlobalContext.GetNewTypeForOriginal(it)) ??
                         cleanAssembly.Types.Where(it => it.NewType.DeclaringType == null); 
            
            foreach (var candidateCleanType in source)
            {
                if(obfType.OriginalType.HasMethods != candidateCleanType.OriginalType.HasMethods)
                    continue;
                
                if(obfType.OriginalType.HasFields != candidateCleanType.OriginalType.HasFields)
                    continue;
                
                if (obfType.OriginalType.IsEnum)
                    if (obfType.OriginalType.Fields.Count != candidateCleanType.OriginalType.Fields.Count)
                        continue;
                
                int currentPenalty = 0;
                
                var tryBase = candidateCleanType.OriginalType.BaseType;
                var actualBaseDepth = 0;
                while (tryBase != null)
                {
                    if (tryBase?.Name == currentBase?.Name && tryBase?.Namespace == currentBase?.Namespace)
                        break;
                    
                    tryBase = tryBase?.Resolve().BaseType;
                    actualBaseDepth++;
                }
                
                if (tryBase == null && currentBase != null)
                    continue;

                var baseDepthDifference = Math.Abs(actualBaseDepth - inheritanceDepthOfOriginal);
                if(baseDepthDifference > 1) continue; // heuristic optimization
                currentPenalty -= baseDepthDifference * 50;

                currentPenalty -= Math.Abs(candidateCleanType.OriginalType.Fields.Count - obfType.OriginalType.Fields.Count) * 5;

                currentPenalty -= Math.Abs(obfType.OriginalType.NestedTypes.Count - candidateCleanType.OriginalType.NestedTypes.Count) * 10;
                
                currentPenalty -= Math.Abs(obfType.OriginalType.Properties.Count - candidateCleanType.OriginalType.Properties.Count) * 5;
                
                currentPenalty -= Math.Abs(obfType.OriginalType.Interfaces.Count - candidateCleanType.OriginalType.Interfaces.Count) * 35;

                var options = obfType.AssemblyContext.GlobalContext.Options;

                foreach (var obfuscatedField in obfType.OriginalType.Fields)
                {
                    if (obfuscatedField.Name.IsObfuscated(options))
                    {
                        
                        var bestFieldScore = candidateCleanType.OriginalType.Fields.Max(it => TypeMatchWeight(obfuscatedField.FieldType, it.FieldType, options));
                        currentPenalty += bestFieldScore * (bestFieldScore < 0 ? 10 : 2);
                        continue;
                    }
                    
                    if (candidateCleanType.OriginalType.Fields.Any(it => it.Name == obfuscatedField.Name))
                        currentPenalty += 10;
                }
                
                foreach (var obfuscatedMethod in obfType.OriginalType.Methods)
                {
                    if (obfuscatedMethod.Name.Contains(".ctor")) continue;
                    
                    if (obfuscatedMethod.Name.IsObfuscated(options))
                    {
                        var bestMethodScore = candidateCleanType.OriginalType.Methods.Max(it => MethodSignatureMatchWeight(obfuscatedMethod, it, options));
                        currentPenalty += bestMethodScore * (bestMethodScore < 0 ? 10 : 1);
                        
                        continue;
                    }

                    if (candidateCleanType.OriginalType.Methods.Any(it => it.Name == obfuscatedMethod.Name))
                        currentPenalty += obfuscatedMethod.Name.Length / 10 * 5 + 1;
                }

                if (currentPenalty == bestPenalty)
                {
                    bestMatch = null;
                } else if (currentPenalty > bestPenalty)
                {
                    bestPenalty = currentPenalty;
                    bestMatch = candidateCleanType;
                }
            }

            // if (bestPenalty < -100)
                // bestMatch = null;

            return (bestMatch, bestPenalty);
        }

        private static int TypeMatchWeight(TypeReference a, TypeReference b, UnhollowerOptions options)
        {
            if (a.GetType() != b.GetType())
                return -1;

            var runningSum = 0;

            void Accumulate(int i)
            {
                if (i < 0 || runningSum < 0)
                    runningSum = -1;
                else
                    runningSum += i;
            }
            
            switch (a)
            {
                case ArrayType arr:
                    if (!(b is ArrayType brr))
                        return -1;
                    return TypeMatchWeight(arr.ElementType, brr.ElementType, options) * 5;
                case ByReferenceType abr:
                    if (!(b is ByReferenceType bbr))
                        return -1;
                    return TypeMatchWeight(abr.ElementType, bbr.ElementType, options) * 5;
                case GenericInstanceType agi:
                    if (!(b is GenericInstanceType bgi))
                        return -1;
                    if (agi.GenericArguments.Count != bgi.GenericArguments.Count) return -1;
                    Accumulate(TypeMatchWeight(agi.ElementType, bgi.ElementType, options));
                    for (var i = 0; i < agi.GenericArguments.Count; i++)
                        Accumulate(TypeMatchWeight(agi.GenericArguments[i], bgi.GenericArguments[i], options));
                    return runningSum * 5;
                case GenericParameter:
                    if (!(b is GenericParameter))
                        return -1;
                    return 5;
                default:
                    if (a.IsNested)
                    {
                        if (!b.IsNested)
                            return -1;
                        
                        if (a.Name.IsObfuscated(options))
                            return 0;
                        
                        var declMatch = TypeMatchWeight(a.DeclaringType, b.DeclaringType, options);
                        if (declMatch == -1 || a.Name != b.Name)
                            return -1;

                        return 1;
                    }
                    if (a.Name.IsObfuscated(options))
                        return 0;
                    return a.Name == b.Name && a.Namespace == b.Namespace ? 1 : -1;
            }
        }

        private static int MethodSignatureMatchWeight(MethodDefinition a, MethodDefinition b, UnhollowerOptions options)
        {
            if (a.Parameters.Count != b.Parameters.Count || a.IsStatic != b.IsStatic ||
                (a.Attributes & MethodAttributes.MemberAccessMask) !=
                (b.Attributes & MethodAttributes.MemberAccessMask))
                return -1;

            var runningSum = TypeMatchWeight(a.ReturnType, b.ReturnType, options);
            if (runningSum == -1)
                return -1;

            void Accumulate(int i)
            {
                if (i < 0 || runningSum < 0)
                    runningSum = -1;
                else
                    runningSum += i;
            }
            
            for (var i = 0; i < a.Parameters.Count; i++)
                Accumulate(TypeMatchWeight(a.Parameters[i].ParameterType, b.Parameters[i].ParameterType, options));

            return runningSum * (a.Parameters.Count + 1);
        }
    }
}
```

`AssemblyUnhollower/Extensions/CollectionEx.cs`:

```cs
using System;
using System.Collections.Generic;

namespace AssemblyUnhollower.Extensions
{
    public static class CollectionEx
    {
        public static TV GetOrCreate<TK, TV>(this IDictionary<TK, TV> dict, TK key, Func<TK, TV> valueFactory) where TK : notnull
        {
            if (!dict.TryGetValue(key, out var result))
            {
                result = valueFactory(key);
                dict[key] = result;
            }

            return result;
        }

        public static void AddLocked<T>(this List<T> list, T value)
        {
            lock (list)
                list.Add(value);
        }
    }
}
```

`AssemblyUnhollower/Extensions/CustomAttributeEx.cs`:

```cs
using System.Globalization;
using System.Linq;
using Mono.Cecil;

namespace AssemblyUnhollower.Extensions
{
    public static class CustomAttributeEx
    {
        public static long ExtractOffset(this ICustomAttributeProvider originalMethod) => Extract(originalMethod, "AddressAttribute", "Offset");
        public static long ExtractRva(this ICustomAttributeProvider originalMethod) => Extract(originalMethod, "AddressAttribute", "RVA");
        public static long ExtractToken(this ICustomAttributeProvider originalMethod) => Extract(originalMethod, "TokenAttribute", "Token");

        private static long Extract(this ICustomAttributeProvider originalMethod, string attributeName, string parameterName)
        {
            var addressAttribute = originalMethod.CustomAttributes.SingleOrDefault(it => it.AttributeType.Name == attributeName);
            var rvaField = addressAttribute?.Fields.SingleOrDefault(it => it.Name == parameterName);

            if (rvaField?.Name == null) return 0;

            var addressString = (string) rvaField.Value.Argument.Value;
            long.TryParse(addressString.Substring(2), NumberStyles.HexNumber, null, out var address);
            return address;
        }
    }
}
```

`AssemblyUnhollower/Extensions/EnumEx.cs`:

```cs
using Mono.Cecil;

namespace AssemblyUnhollower.Extensions
{
    public static class EnumEx
    {
        public static FieldAttributes ForcePublic(this FieldAttributes fieldAttributes)
        {
            return fieldAttributes & ~FieldAttributes.FieldAccessMask & ~FieldAttributes.HasFieldMarshal | FieldAttributes.Public;
        }

        public static GenericParameterAttributes StripValueTypeConstraint(this GenericParameterAttributes parameterAttributes)
        {
            return parameterAttributes & ~GenericParameterAttributes.NotNullableValueTypeConstraint;
        }
    }
}
```

`AssemblyUnhollower/Extensions/StringEx.cs`:

```cs
using System.Text;
using Mono.Cecil;

namespace AssemblyUnhollower.Extensions
{
    public static class StringEx
    {
        public static string UnSystemify(this string str, UnhollowerOptions options)
        {
            foreach (var prefix in options.NamespacesAndAssembliesToPrefix)
                if (str.StartsWith(prefix))
                    return "Il2Cpp" + str;

            return str;
        }

        public static string FilterInvalidInSourceChars(this string str)
        {
            var chars = str.ToCharArray();
            for (var i = 0; i < chars.Length; i++)
            {
                var it = chars[i];
                if (!char.IsDigit(it) && !(it >= 'a' && it <= 'z' || it >= 'A' && it <= 'Z') && it != '_' &&
                    it != '`') chars[i] = '_';
            }

            return new string(chars);
        }
        
        public static bool IsInvalidInSource(this string str)
        {
            for (var i = 0; i < str.Length; i++)
            {
                var it = str[i];
                if (!char.IsDigit(it) && !(it >= 'a' && it <= 'z' || it >= 'A' && it <= 'Z') && it != '_' &&
                    it != '`') return true;
            }

            return false;
        }

        public static bool IsObfuscated(this string str, UnhollowerOptions options)
        {
            if (options.ObfuscatedNamesRegex != null)
                return options.ObfuscatedNamesRegex.IsMatch(str);

            foreach (var it in str)
            {
                if (!char.IsDigit(it) && !(it >= 'a' && it <= 'z' || it >= 'A' && it <= 'Z') && it != '_' && it != '`' && it != '.' && it != '<' && it != '>') return true;
            }

            return false;
        }

        public static ulong StableHash(this string str)
        {
            ulong hash = 0;
            for (var i = 0; i < str.Length; i++) 
                hash = hash * 37 + str[i];

            return hash;
        }

        public static string GetUnmangledName(this TypeReference typeRef)
        {
            StringBuilder builder = new StringBuilder();
            if (typeRef is GenericInstanceType genericInstance)
            {
                builder.Append(genericInstance.ElementType.GetUnmangledName());
                foreach (var genericArgument in genericInstance.GenericArguments)
                {
                    builder.Append("_");
                    builder.Append(genericArgument.GetUnmangledName());
                }
            } else if (typeRef is ByReferenceType byRef)
            {
                builder.Append("byref_");
                builder.Append(byRef.ElementType.GetUnmangledName());
            } else if (typeRef is PointerType pointer)
            {
                builder.Append("ptr_");
                builder.Append(pointer.ElementType.GetUnmangledName());
            }
            else
            {
                if (typeRef.Namespace == nameof(UnhollowerBaseLib) && typeRef.Name.StartsWith("Il2Cpp") && typeRef.Name.Contains("Array"))
                {
                    builder.Append("ArrayOf");
                } else
                    builder.Append(typeRef.Name.Replace('`', '_'));
            }

            return builder.ToString();
        }
    }
}
```

`AssemblyUnhollower/Extensions/TypeReferenceEx.cs`:

```cs
using Mono.Cecil;

namespace AssemblyUnhollower.Extensions
{
    public static class TypeReferenceEx
    {
        public static bool UnmangledNamesMatch(this TypeReference typeRefA, TypeReference typeRefB)
        {
            var aIsDefOrRef = typeRefA.GetType() == typeof(TypeReference) || typeRefA.GetType() == typeof(TypeDefinition);
            var bIsDefOrRef = typeRefB.GetType() == typeof(TypeReference) || typeRefB.GetType() == typeof(TypeDefinition);
            if (!(aIsDefOrRef && bIsDefOrRef) && typeRefA.GetType() != typeRefB.GetType())
                return false;
            
            switch (typeRefA)
            {
                case PointerType pointer:
                    return pointer.ElementType.UnmangledNamesMatch(((PointerType) typeRefB).ElementType);
                case ByReferenceType byRef:
                    return byRef.ElementType.UnmangledNamesMatch(((ByReferenceType) typeRefB).ElementType);
                case ArrayType array:
                    return array.ElementType.UnmangledNamesMatch(((ArrayType) typeRefB).ElementType);
                case GenericInstanceType genericInstance:
                {
                    var elementA = genericInstance.ElementType;
                    var genericInstanceB = (GenericInstanceType) typeRefB;
                    var elementB = genericInstanceB.ElementType;
                    if (!elementA.UnmangledNamesMatch(elementB))
                        return false;
                    if (genericInstance.GenericArguments.Count != genericInstanceB.GenericArguments.Count)
                        return false;
                    
                    for (var i = 0; i < genericInstance.GenericArguments.Count; i++)
                    {
                        if (!genericInstance.GenericArguments[i].UnmangledNamesMatch(genericInstanceB.GenericArguments[i]))
                            return false;
                    }

                    return true;
                }
                default:
                    return typeRefA.Name == typeRefB.Name;
            }
        }
        
        public static string GetNamespacePrefix(this TypeReference type)
        {
            if (type.IsNested)
                return GetNamespacePrefix(type.DeclaringType) + "." + type.DeclaringType.Name;

            return type.Namespace;
        }
    }
}
```

`AssemblyUnhollower/Extensions/WriterEx.cs`:

```cs
using System;
using System.IO;
using System.Runtime.InteropServices;

namespace AssemblyUnhollower.Extensions
{
    public static class WriterEx
    {
        [ThreadStatic]
        private static byte[]? ourBuffer;
        
        public static unsafe void Write<T>(this BinaryWriter writer, T value) where T : unmanaged
        {
            var structSize = Marshal.SizeOf<T>();
            
            if (ourBuffer == null || ourBuffer.Length < structSize) 
                ourBuffer = new byte[structSize];

            fixed (byte* bytes = ourBuffer) 
                *(T*) bytes = value;

            writer.Write(ourBuffer, 0, structSize);
        }
    }
}
```

`AssemblyUnhollower/FieldAccessorGenerator.cs`:

```cs
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower
{
    public static class FieldAccessorGenerator
    {
        public static void MakeGetter(FieldDefinition field, FieldRewriteContext fieldContext, PropertyDefinition property, AssemblyKnownImports imports)
        {
            var getter = new MethodDefinition("get_" + property.Name, Field2MethodAttrs(field.Attributes) | MethodAttributes.SpecialName | MethodAttributes.HideBySig, property.PropertyType);
            
            var getterBody = getter.Body.GetILProcessor();
            property.DeclaringType.Methods.Add(getter);

            if (field.IsStatic)
            {
                var local0 = new VariableDefinition(property.PropertyType.IsValueType ? property.PropertyType : imports.IntPtr);
                getter.Body.Variables.Add(local0);

                bool localIsPointer = false;
                if (field.FieldType.IsValueType && !property.PropertyType.IsValueType)
                {
                    var pointerStore = new GenericInstanceType(imports.Il2CppClassPointerStore);
                    pointerStore.GenericArguments.Add(property.PropertyType);
                    var pointerStoreType = property.DeclaringType.Module.ImportReference(pointerStore);
                    getterBody.Emit(OpCodes.Ldsfld, new FieldReference(nameof(Il2CppClassPointerStore<int>.NativeClassPtr), imports.IntPtr, pointerStoreType));
                    getterBody.Emit(OpCodes.Ldc_I4, 0);
                    getterBody.Emit(OpCodes.Conv_U);
                    getterBody.Emit(OpCodes.Call, imports.ValueSizeGet);
                    getterBody.Emit(OpCodes.Conv_U);
                    getterBody.Emit(OpCodes.Localloc);
                    getterBody.Emit(OpCodes.Stloc, local0);
                    localIsPointer = true;
                }
                
                getterBody.Emit(OpCodes.Ldsfld, fieldContext.PointerField);
                if (localIsPointer)
                    getterBody.Emit(OpCodes.Ldloc, local0);
                else
                    getterBody.Emit(OpCodes.Ldloca_S, local0);
                getterBody.Emit(OpCodes.Conv_U);
                getterBody.Emit(OpCodes.Call, imports.FieldStaticGet);

                if (property.PropertyType.IsValueType)
                {
                    getterBody.Emit(OpCodes.Ldloc, local0);
                    getterBody.Emit(OpCodes.Ret);

                    property.GetMethod = getter;
                    return;
                }
            }
            else
            {
                var local0 = new VariableDefinition(imports.IntPtr);
                getter.Body.Variables.Add(local0);
                
                getterBody.EmitObjectToPointer(fieldContext.DeclaringType.OriginalType, fieldContext.DeclaringType.NewType, fieldContext.DeclaringType, 0, false, false, false, out _);
                getterBody.Emit(OpCodes.Ldsfld, fieldContext.PointerField);
                getterBody.Emit(OpCodes.Call, imports.FieldGetOffset);
                getterBody.Emit(OpCodes.Add);
                
                getterBody.Emit(OpCodes.Stloc_0);
            }

            getterBody.EmitPointerToObject(fieldContext.OriginalField.FieldType, property.PropertyType, fieldContext.DeclaringType, getterBody.Create(OpCodes.Ldloc_0), !field.IsStatic, false);

            getterBody.Emit(OpCodes.Ret);

            property.GetMethod = getter;
        }
        
        public static void MakeSetter(FieldDefinition field, FieldRewriteContext fieldContext, PropertyDefinition property, AssemblyKnownImports imports)
        {
            var setter = new MethodDefinition("set_" + property.Name, Field2MethodAttrs(field.Attributes) | MethodAttributes.SpecialName | MethodAttributes.HideBySig, imports.Void);
            setter.Parameters.Add(new ParameterDefinition(property.PropertyType));
            property.DeclaringType.Methods.Add(setter);
            var setterBody = setter.Body.GetILProcessor();

            if (field.IsStatic)
            {
                setterBody.Emit(OpCodes.Ldsfld, fieldContext.PointerField);
                setterBody.EmitObjectToPointer(field.FieldType, property.PropertyType, fieldContext.DeclaringType, 0, false, true, true, out _);
                setterBody.Emit(OpCodes.Call, imports.FieldStaticSet);
            }
            else
            {
                setterBody.EmitObjectToPointer(fieldContext.DeclaringType.OriginalType, fieldContext.DeclaringType.NewType, fieldContext.DeclaringType, 0, false, false, false, out _);
                setterBody.Emit(OpCodes.Dup);
                setterBody.Emit(OpCodes.Ldsfld, fieldContext.PointerField);
                setterBody.Emit(OpCodes.Call, imports.FieldGetOffset);
                setterBody.Emit(OpCodes.Add);
                setterBody.EmitObjectStore(field.FieldType, property.PropertyType, fieldContext.DeclaringType, 1);
            }
            
            setterBody.Emit(OpCodes.Ret);

            property.SetMethod = setter;
        }
        
        private static MethodAttributes Field2MethodAttrs(FieldAttributes fieldAttributes)
        {
            if ((fieldAttributes & FieldAttributes.Static) != 0)
                return MethodAttributes.Public | MethodAttributes.Static;
            return MethodAttributes.Public;
        }
    }
}
```

`AssemblyUnhollower/MetadataAccess/CecilMetadataAccess.cs`:

```cs
using System.Collections.Generic;
using Mono.Cecil;

namespace AssemblyUnhollower.MetadataAccess
{
    public class CecilMetadataAccess : IIl2CppMetadataAccess
    {
        private readonly Resolver myAssemblyResolver = new();
        private readonly List<AssemblyDefinition> myAssemblies = new();
        private readonly Dictionary<string, AssemblyDefinition> myAssembliesByName = new();
        private readonly Dictionary<(string AssemblyName, string TypeName), TypeDefinition> myTypesByName = new();
        
        public CecilMetadataAccess(IEnumerable<string> assemblyPaths)
        {
            var metadataResolver = new MetadataResolver(myAssemblyResolver);
            
            foreach (var sourceAssemblyPath in assemblyPaths)
            {
                var sourceAssembly = AssemblyDefinition.ReadAssembly(sourceAssemblyPath, new ReaderParameters(ReadingMode.Deferred) {MetadataResolver = metadataResolver});
                myAssemblyResolver.Register(sourceAssembly);
                myAssemblies.Add(sourceAssembly);
                myAssembliesByName[sourceAssembly.Name.Name] = sourceAssembly;
            }
            
            foreach (var sourceAssembly in myAssemblies)
            {
                var sourceAssemblyName = sourceAssembly.Name.Name;
                foreach (var type in sourceAssembly.MainModule.Types)
                {
                    // todo: nested types?
                    myTypesByName[(sourceAssemblyName, type.FullName)] = type;
                }
            }
        }

        public void Dispose()
        {
            foreach (var assemblyDefinition in myAssemblies) 
                assemblyDefinition.Dispose();
            
            myAssemblies.Clear();
            myAssembliesByName.Clear();
            myAssemblyResolver.Dispose();
        }

        public AssemblyDefinition? GetAssemblyBySimpleName(string name) => myAssembliesByName.TryGetValue(name, out var result) ? result : null;

        public TypeDefinition? GetTypeByName(string assemblyName, string typeName) => myTypesByName.TryGetValue((assemblyName, typeName), out var result) ? result : null;

        public IList<AssemblyDefinition> Assemblies => myAssemblies;

        public IList<GenericInstanceType>? GetKnownInstantiationsFor(TypeDefinition genericDeclaration) => null;
        public string? GetStringStoredAtAddress(long offsetInMemory) => null;
        public MethodReference? GetMethodRefStoredAt(long offsetInMemory) => null;
        
        private class Resolver : DefaultAssemblyResolver
        {
            public void Register(AssemblyDefinition ass) => RegisterAssembly(ass);
        }
    }
}
```

`AssemblyUnhollower/MetadataAccess/IIl2CppMetadataAccess.cs`:

```cs
using System.Collections.Generic;
using Mono.Cecil;

namespace AssemblyUnhollower.MetadataAccess
{
    public interface IIl2CppMetadataAccess : IMetadataAccess
    {
        IList<GenericInstanceType>? GetKnownInstantiationsFor(TypeDefinition genericDeclaration);
        string? GetStringStoredAtAddress(long offsetInMemory);
        MethodReference? GetMethodRefStoredAt(long offsetInMemory);
    }
}
```

`AssemblyUnhollower/MetadataAccess/IMetadataAccess.cs`:

```cs
using System;
using System.Collections.Generic;
using Mono.Cecil;

namespace AssemblyUnhollower.MetadataAccess
{
    public interface IMetadataAccess : IDisposable
    {
        IList<AssemblyDefinition> Assemblies { get; }

        AssemblyDefinition? GetAssemblyBySimpleName(string name);
        TypeDefinition? GetTypeByName(string assemblyName, string typeName);
    }
}
```

`AssemblyUnhollower/MetadataAccess/NullMetadataAccess.cs`:

```cs
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Collections.Generic;

namespace AssemblyUnhollower.MetadataAccess
{
    public class NullMetadataAccess : IMetadataAccess
    {
        public static readonly NullMetadataAccess Instance = new();
        
        public void Dispose()
        {
        }

        public IList<AssemblyDefinition> Assemblies => ReadOnlyCollection<AssemblyDefinition>.Empty;
        public AssemblyDefinition? GetAssemblyBySimpleName(string name) => null;
        public TypeDefinition? GetTypeByName(string assemblyName, string typeName) => null;
        public IList<GenericInstanceType>? GetKnownInstantiationsFor(TypeReference genericDeclaration) => null;
        public string? GetStringStoredAtAddress(long offsetInMemory) => null;
        public MethodReference? GetMethodRefStoredAt(long offsetInMemory) => null;
    }
}
```

`AssemblyUnhollower/Passes/Pass05CreateRenameGroups.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using AssemblyUnhollower.Utils;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass05CreateRenameGroups
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            foreach (var originalType in assemblyContext.OriginalAssembly.MainModule.Types)
                ProcessType(context, originalType, false);

            var typesToRemove = context.RenameGroups.Where(it => it.Value.Count > 1).ToList();
            foreach (var keyValuePair in typesToRemove)
            {
                context.RenameGroups.Remove(keyValuePair.Key);
                foreach (var typeDefinition in keyValuePair.Value) 
                    context.RenamedTypes.Remove(typeDefinition);
            }
            
            foreach (var contextRenamedType in context.RenamedTypes)
                context.PreviousRenamedTypes[contextRenamedType.Key] = contextRenamedType.Value;

            foreach (var assemblyContext in context.Assemblies)
            foreach (var originalType in assemblyContext.OriginalAssembly.MainModule.Types)
                ProcessType(context, originalType, true);
        }

        private static void ProcessType(RewriteGlobalContext context, TypeDefinition originalType, bool allowExtraHeuristics)
        {
            foreach (var nestedType in originalType.NestedTypes) 
                ProcessType(context, nestedType, allowExtraHeuristics);

            if (context.RenamedTypes.ContainsKey(originalType)) return;
            
            var unobfuscatedName = GetUnobfuscatedNameBase(context, originalType, allowExtraHeuristics);
            if (unobfuscatedName == null) return;
                    
            context.RenameGroups.GetOrCreate(((object) originalType.DeclaringType ?? originalType.Namespace, unobfuscatedName, originalType.GenericParameters.Count), _ => new List<TypeDefinition>()).Add(originalType);
            context.RenamedTypes[originalType] = unobfuscatedName;
        }

        private static readonly string[] ClassAccessNames = { "Private", "Public", "NPublic", "NPrivate", "NProtected", "NInternal", "NFamAndAssem", "NFamOrAssem" };
        private static string? GetUnobfuscatedNameBase(RewriteGlobalContext context, TypeDefinition typeDefinition, bool allowExtraHeuristics)
        {
            var options = context.Options;
            if (options.PassthroughNames || !typeDefinition.Name.IsObfuscated(context.Options)) return null;

            var inheritanceDepth = 0;
            var firstUnobfuscatedType = typeDefinition.BaseType;
            while (firstUnobfuscatedType != null && firstUnobfuscatedType.Name.IsObfuscated(context.Options))
            {
                firstUnobfuscatedType = firstUnobfuscatedType.Resolve().BaseType?.Resolve();
                inheritanceDepth++;
            }

            var unobfuscatedInterfacesList = typeDefinition.Interfaces.Select(it => it.InterfaceType).Where(it => !it.Name.IsObfuscated(context.Options));
            var accessName = ClassAccessNames[(int) (typeDefinition.Attributes & TypeAttributes.VisibilityMask)];

            var classifier = typeDefinition.IsInterface ? "Interface" : (typeDefinition.IsValueType ? "Struct" : "Class");
            var compilerGenertaedString = typeDefinition.Name.StartsWith("<") ? "CompilerGenerated" : "";
            var abstractString = typeDefinition.IsAbstract ? "Abstract" : "";
            var sealedString = typeDefinition.IsSealed ? "Sealed" : "";
            var specialNameString = typeDefinition.IsSpecialName ? "SpecialName" : "";

            var nameBuilder = new StringBuilder();
            nameBuilder.Append(firstUnobfuscatedType?.GenericNameToStrings(context)?.ConcatAll() ?? classifier);
            if (inheritanceDepth > 0)
                nameBuilder.Append(inheritanceDepth);
            nameBuilder.Append(compilerGenertaedString);
            nameBuilder.Append(accessName);
            nameBuilder.Append(abstractString);
            nameBuilder.Append(sealedString);
            nameBuilder.Append(specialNameString);
            foreach (var interfaceRef in unobfuscatedInterfacesList) 
                nameBuilder.Append(interfaceRef.GenericNameToStrings(context).ConcatAll());

            var uniqContext = new UniquificationContext(options);
            foreach (var fieldDef in typeDefinition.Fields)
            {
                if (!typeDefinition.IsEnum)
                    uniqContext.Push(fieldDef.FieldType.GenericNameToStrings(context));
                
                uniqContext.Push(fieldDef.Name);
                
                if (uniqContext.CheckFull()) break;
            }

            if (typeDefinition.IsEnum) 
                uniqContext.Push(typeDefinition.Fields.Count + "v");

            foreach (var propertyDef in typeDefinition.Properties)
            {
                uniqContext.Push(propertyDef.PropertyType.GenericNameToStrings(context));
                uniqContext.Push(propertyDef.Name);

                if (uniqContext.CheckFull()) break;
            }

            if (firstUnobfuscatedType?.Name == "MulticastDelegate")
            {
                var invokeMethod = typeDefinition.Methods.SingleOrDefault(it => it.Name == "Invoke");
                if (invokeMethod != null)
                {
                    uniqContext.Push(invokeMethod.ReturnType.GenericNameToStrings(context));

                    foreach (var parameterDef in invokeMethod.Parameters)
                    {
                        uniqContext.Push(parameterDef.ParameterType.GenericNameToStrings(context));
                        if (uniqContext.CheckFull()) break;
                    }
                }
            }
            
            if (typeDefinition.IsInterface || allowExtraHeuristics) // method order on non-interface types appears to be unstable
                foreach (var methodDefinition in typeDefinition.Methods)
                {
                    uniqContext.Push(methodDefinition.Name);
                    uniqContext.Push(methodDefinition.ReturnType.GenericNameToStrings(context));

                    foreach (var parameter in methodDefinition.Parameters)
                    {
                        uniqContext.Push(parameter.Name);
                        uniqContext.Push(parameter.ParameterType.GenericNameToStrings(context));

                        if (uniqContext.CheckFull()) break;
                    }

                    if (uniqContext.CheckFull()) break;
                }

            nameBuilder.Append(uniqContext.GetTop());

            return nameBuilder.ToString();
        }

        private static string ConcatAll(this List<string> strings) => string.Concat(strings);

        private static string NameOrRename(this TypeReference typeRef, RewriteGlobalContext context)
        {
            var resolved = typeRef.Resolve();
            if (resolved != null && context.PreviousRenamedTypes.TryGetValue(resolved, out var rename))
                return (rename.StableHash() % (ulong) Math.Pow(10, context.Options.TypeDeobfuscationCharsPerUniquifier)).ToString();
            
            return typeRef.Name;
        }

        private static List<string> GenericNameToStrings(this TypeReference typeRef, RewriteGlobalContext context)
        {
            if (typeRef is ArrayType arrayType)
                return arrayType.ElementType.GenericNameToStrings(context);

            if (typeRef is GenericInstanceType genericInstance)
            {
                var baseTypeName = genericInstance.GetElementType().NameOrRename(context);
                var indexOfBacktick = baseTypeName.IndexOf('`');
                if (indexOfBacktick >= 0)
                    baseTypeName = baseTypeName.Substring(0, indexOfBacktick);

                var entries = new List<string>();
                
                entries.Add(baseTypeName);
                entries.Add(genericInstance.GenericArguments.Count.ToString());
                foreach (var genericArgument in genericInstance.GenericArguments) 
                    entries.AddRange(genericArgument.GenericNameToStrings(context));
                return entries;
            }

            if (typeRef.NameOrRename(context).IsObfuscated(context.Options))
                return new List<string> {"Obf"};

            return new List<string> {typeRef.NameOrRename(context)};
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass10CreateTypedefs.cs`:

```cs
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass10CreateTypedefs
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var type in assemblyContext.OriginalAssembly.MainModule.Types)
                    ProcessType(type, assemblyContext, null);
            }
        }

        private static void ProcessType(TypeDefinition type, AssemblyRewriteContext assemblyContext, TypeDefinition? parentType)
        {
            var convertedTypeName = GetConvertedTypeName(assemblyContext.GlobalContext, type, parentType);
            var newType = new TypeDefinition(convertedTypeName.Namespace ?? type.Namespace.UnSystemify(assemblyContext.GlobalContext.Options), convertedTypeName.Name, AdjustAttributes(type.Attributes));

            if (type.IsSealed && type.IsAbstract) // is static
            {
                newType.IsSealed = newType.IsAbstract = true;
            }
            
            if(parentType == null)
                assemblyContext.NewAssembly.MainModule.Types.Add(newType);
            else
            {
                parentType.NestedTypes.Add(newType);
                newType.DeclaringType = parentType;
            }
            
            foreach (var typeNestedType in type.NestedTypes) 
                ProcessType(typeNestedType, assemblyContext, newType);

            assemblyContext.RegisterTypeRewrite(new TypeRewriteContext(assemblyContext, type, newType));
        }

        internal static (string? Namespace, string Name) GetConvertedTypeName(RewriteGlobalContext assemblyContextGlobalContext, TypeDefinition type, TypeDefinition? enclosingType)
        {
            if (assemblyContextGlobalContext.Options.PassthroughNames)
                return (null, type.Name);

            if (type.Name.IsObfuscated(assemblyContextGlobalContext.Options))
            {
                var newNameBase = assemblyContextGlobalContext.RenamedTypes[type];
                var genericParametersCount = type.GenericParameters.Count;
                var renameGroup =
                    assemblyContextGlobalContext.RenameGroups[((object) type.DeclaringType ?? type.Namespace, newNameBase, genericParametersCount)];
                var genericSuffix = genericParametersCount == 0 ? "" : "`" + genericParametersCount;
                var convertedTypeName = newNameBase + (renameGroup.Count == 1 ? "Unique" : renameGroup.IndexOf(type).ToString()) + genericSuffix;

                var fullName = enclosingType == null
                    ? type.Namespace
                    : (enclosingType.GetNamespacePrefix() + "." + enclosingType.Name);

                if (assemblyContextGlobalContext.Options.RenameMap.TryGetValue(fullName + "." + convertedTypeName, out var newName))
                {
                    var lastDotPosition = newName.LastIndexOf(".");
                    if (lastDotPosition >= 0)
                    {
                        var ns = newName.Substring(0, lastDotPosition);
                        var name = newName.Substring(lastDotPosition + 1);
                        return (ns, name);
                    } else 
                        convertedTypeName = newName;
                }

                return (null, convertedTypeName);
            }

            if (type.Name.IsInvalidInSource())
                return (null, type.Name.FilterInvalidInSourceChars());

            return (null, type.Name);
        }

        private static TypeAttributes AdjustAttributes(TypeAttributes typeAttributes)
        {
            typeAttributes |= TypeAttributes.BeforeFieldInit;
            typeAttributes &= ~(TypeAttributes.Abstract | TypeAttributes.Interface);
            
            var visibility = typeAttributes & TypeAttributes.VisibilityMask;
            if (visibility == 0 || visibility == TypeAttributes.Public)
                return typeAttributes | TypeAttributes.Public;

            return typeAttributes & ~(TypeAttributes.VisibilityMask) | TypeAttributes.NestedPublic;
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass11ComputeTypeSpecifics.cs`:

```cs
using System;
using AssemblyUnhollower.Contexts;

namespace AssemblyUnhollower.Passes
{
    public static class Pass11ComputeTypeSpecifics
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            foreach (var typeContext in assemblyContext.Types)
            {
                ComputeSpecifics(typeContext);
            }
        }

        private static void ComputeSpecifics(TypeRewriteContext typeContext)
        {
            if (typeContext.ComputedTypeSpecifics != TypeRewriteContext.TypeSpecifics.NotComputed) return;
            typeContext.ComputedTypeSpecifics = TypeRewriteContext.TypeSpecifics.Computing;
            
            foreach (var originalField in typeContext.OriginalType.Fields)
            {
                if(originalField.IsStatic) continue;
                
                var fieldType = originalField.FieldType;
                if (fieldType.IsPrimitive || fieldType.IsPointer) continue;
                if (fieldType.FullName == "System.String" || fieldType.FullName == "System.Object" || fieldType.IsArray || fieldType.IsByReference || fieldType.IsGenericParameter || fieldType.IsGenericInstance)
                {
                    typeContext.ComputedTypeSpecifics = TypeRewriteContext.TypeSpecifics.NonBlittableStruct;
                    return;
                }

                var fieldTypeContext = typeContext.AssemblyContext.GlobalContext.GetNewTypeForOriginal(fieldType.Resolve());
                ComputeSpecifics(fieldTypeContext);
                if (fieldTypeContext.ComputedTypeSpecifics != TypeRewriteContext.TypeSpecifics.BlittableStruct)
                {
                    typeContext.ComputedTypeSpecifics = TypeRewriteContext.TypeSpecifics.NonBlittableStruct;
                    return;
                }
            }

            typeContext.ComputedTypeSpecifics = TypeRewriteContext.TypeSpecifics.BlittableStruct;
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass12FillTypedefs.cs`:

```cs
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass12FillTypedefs
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    foreach (var originalParameter in typeContext.OriginalType.GenericParameters)
                    {
                        var newParameter = new GenericParameter(originalParameter.Name, typeContext.NewType);
                        typeContext.NewType.GenericParameters.Add(newParameter);
                        newParameter.Attributes = originalParameter.Attributes.StripValueTypeConstraint();
                    }

                    if (typeContext.OriginalType.IsEnum)
                    {
                        typeContext.NewType.BaseType = assemblyContext.Imports.Enum;
                    } else if (typeContext.ComputedTypeSpecifics == TypeRewriteContext.TypeSpecifics.BlittableStruct) {
                        typeContext.NewType.BaseType = assemblyContext.Imports.ValueType;
                    }
                }
            }
            
            // Second pass is explicitly done after first to account for rewriting of generic base types - value-typeness is important there
            foreach (var assemblyContext in context.Assemblies)
            foreach (var typeContext in assemblyContext.Types)
                if (!typeContext.OriginalType.IsEnum && typeContext.ComputedTypeSpecifics !=
                    TypeRewriteContext.TypeSpecifics.BlittableStruct)
                    typeContext.NewType.BaseType = assemblyContext.RewriteTypeRef(typeContext.OriginalType.BaseType);
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass13FillGenericConstraints.cs`:

```cs
using AssemblyUnhollower.Contexts;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass13FillGenericConstraints
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    for (var i = 0; i < typeContext.OriginalType.GenericParameters.Count; i++)
                    {
                        var originalParameter = typeContext.OriginalType.GenericParameters[i];
                        var newParameter = typeContext.NewType.GenericParameters[i];
                        foreach (var originalConstraint in originalParameter.Constraints)
                        {
                            if (originalConstraint.ConstraintType.FullName == "System.ValueType" || originalConstraint.ConstraintType.Resolve()?.IsInterface == true) continue;
                            
                            newParameter.Constraints.Add(
                                new GenericParameterConstraint(
                                    assemblyContext.RewriteTypeRef(originalConstraint.ConstraintType)));
                        }
                    }
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass15GenerateMemberContexts.cs`:

```cs
using AssemblyUnhollower.Contexts;

namespace AssemblyUnhollower.Passes
{
    public static class Pass15GenerateMemberContexts
    {
        public static bool HasObfuscatedMethods;
        
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            foreach (var typeContext in assemblyContext.Types)
                typeContext.AddMembers();
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass16ScanMethodRefs.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Linq;
using System.Text;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using UnhollowerBaseLib;
using UnhollowerRuntimeLib.XrefScans;

namespace AssemblyUnhollower.Passes
{
    public static class Pass16ScanMethodRefs
    {
        public static readonly HashSet<long> NonDeadMethods = new HashSet<long>();
        public static IDictionary<long, List<XrefInstance>> MapOfCallers = new Dictionary<long, List<XrefInstance>>();

        public static void DoPass(RewriteGlobalContext context, UnhollowerOptions options)
        {
            if (string.IsNullOrEmpty(options.GameAssemblyPath))
            {
                Pass15GenerateMemberContexts.HasObfuscatedMethods = false;
                return;
            }
            
            using var mappedFile = MemoryMappedFile.CreateFromFile(options.GameAssemblyPath, FileMode.Open, null, 0, MemoryMappedFileAccess.Read);
            using var accessor = mappedFile.CreateViewAccessor(0, 0, MemoryMappedFileAccess.Read);

            IntPtr gameAssemblyPtr;

            unsafe
            {
                byte* fileStartPtr = null;
                accessor.SafeMemoryMappedViewHandle.AcquirePointer(ref fileStartPtr);
                gameAssemblyPtr = (IntPtr) fileStartPtr;
            }
            
            context.HasGcWbarrierFieldWrite = FindByteSequence(gameAssemblyPtr, accessor.Capacity, nameof(IL2CPP.il2cpp_gc_wbarrier_set_field));
            
            if (!Pass15GenerateMemberContexts.HasObfuscatedMethods) return;

            var methodToCallersMap = new ConcurrentDictionary<long, List<XrefInstance>>();
            var methodToCalleesMap = new ConcurrentDictionary<long, List<long>>();
            
            context.MethodStartAddresses.Sort();

            // Scan xrefs
            context.Assemblies.SelectMany(it => it.Types).SelectMany(it => it.Methods).AsParallel().ForAll(
                originalTypeMethod =>
                {
                    var address = originalTypeMethod.FileOffset;
                    if (address == 0) return;

                    if (!options.NoXrefCache)
                    {
                        var pair = XrefScanMetadataGenerationUtil.FindMetadataInitForMethod(originalTypeMethod, (long) gameAssemblyPtr);
                        originalTypeMethod.MetadataInitFlagRva = pair.FlagRva;
                        originalTypeMethod.MetadataInitTokenRva = pair.TokenRva;
                    }

                    var nextMethodStart = context.MethodStartAddresses.BinarySearch(address + 1);
                    if (nextMethodStart < 0) nextMethodStart = ~nextMethodStart;
                    var length = nextMethodStart >= context.MethodStartAddresses.Count ? 1024 * 1024 : (context.MethodStartAddresses[nextMethodStart] - address);
                    foreach (var callTargetGlobal in XrefScanner.XrefScanImpl(XrefScanner.DecoderForAddress(IntPtr.Add(gameAssemblyPtr, (int) address), (int) length), true))
                    {
                        var callTarget = callTargetGlobal.RelativeToBase((long) gameAssemblyPtr + originalTypeMethod.FileOffset - originalTypeMethod.Rva);
                        if (callTarget.Type == XrefType.Method)
                        {
                            var targetRelative = (long) callTarget.Pointer;
                            methodToCallersMap.GetOrAdd(targetRelative, _ => new List<XrefInstance>()).AddLocked(new XrefInstance(XrefType.Method, (IntPtr) originalTypeMethod.Rva, callTarget.FoundAt));
                            methodToCalleesMap.GetOrAdd(originalTypeMethod.Rva, _ => new List<long>()).AddLocked(targetRelative);
                        }

                        if (!options.NoXrefCache)
                            originalTypeMethod.XrefScanResults.Add(callTarget);
                    }
                });

            MapOfCallers = methodToCallersMap;

            void MarkMethodAlive(long address)
            {
                if (!NonDeadMethods.Add(address)) return;
                if (!methodToCalleesMap.TryGetValue(address, out var calleeList)) return;
                
                foreach (var callee in calleeList) 
                    MarkMethodAlive(callee);
            }
            
            // Now decided which of them are possible dead code
            foreach (var assemblyRewriteContext in context.Assemblies)
            foreach (var typeRewriteContext in assemblyRewriteContext.Types)
            foreach (var methodRewriteContext in typeRewriteContext.Methods)
            {
                if (methodRewriteContext.FileOffset == 0) continue;
                
                var originalMethod = methodRewriteContext.OriginalMethod;
                if (!originalMethod.Name.IsObfuscated(options) || originalMethod.IsVirtual)
                    MarkMethodAlive(methodRewriteContext.Rva);
            }
        }

        private unsafe static bool FindByteSequence(IntPtr basePtr, long length, string str)
        {
            byte* bytes = (byte*)basePtr;
            var sequence = Encoding.UTF8.GetBytes(str);
            for (var i = 0L; i < length; i++)
            {
                for (var j = 0; j < sequence.Length; j++)
                {
                    if (bytes[i + j] != sequence[j])
                        goto next;
                }

                return true;
                
                next: ;
            }

            return false;
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass18FinalizeMethodContexts.cs`:

```cs
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Passes
{
    public static class Pass18FinalizeMethodContexts
    {
        public static int TotalPotentiallyDeadMethods;
        
        public static void DoPass(RewriteGlobalContext context)
        {
            var pdmNested0Caller = 0;
            var pdmNestedNZCaller = 0;
            var pdmTop0Caller = 0;
            var pdmTopNZCaller = 0;

            foreach (var assemblyContext in context.Assemblies)
            foreach (var typeContext in assemblyContext.Types)
            foreach (var methodContext in typeContext.Methods)
            {
                methodContext.CtorPhase2();

                int callerCount = 0;
                if (Pass16ScanMethodRefs.MapOfCallers.TryGetValue(methodContext.Rva, out var callers))
                    callerCount = callers.Count;

                methodContext.NewMethod.CustomAttributes.Add(
                    new CustomAttribute(assemblyContext.Imports.CallerCountAttributeCtor)
                    {
                        ConstructorArguments =
                            {new CustomAttributeArgument(assemblyContext.Imports.Int, callerCount)}
                    });
                
                if (!Pass15GenerateMemberContexts.HasObfuscatedMethods) continue;
                if (!methodContext.UnmangledName.Contains("_PDM_")) continue;
                TotalPotentiallyDeadMethods++;
                    
                var hasZeroCallers = callerCount == 0;
                if (methodContext.DeclaringType.OriginalType.IsNested)
                {
                    if (hasZeroCallers)
                        pdmNested0Caller++;
                    else
                        pdmNestedNZCaller++;
                }
                else
                {
                    if (hasZeroCallers)
                        pdmTop0Caller++;
                    else
                        pdmTopNZCaller++;
                }
            }
            
            LogSupport.Trace("");
            LogSupport.Trace($"Dead method statistics: 0t={pdmTop0Caller} mt={pdmTopNZCaller} 0n={pdmNested0Caller} mn={pdmNestedNZCaller}");
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass19CopyMethodParameters.cs`:

```cs
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass19CopyMethodParameters
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    foreach (var methodRewriteContext in typeContext.Methods)
                    {
                        var originalMethod = methodRewriteContext.OriginalMethod;
                        var newMethod = methodRewriteContext.NewMethod;

                        foreach (var originalMethodParameter in originalMethod.Parameters)
                        {
                            var newName = originalMethodParameter.Name.IsObfuscated(context.Options)
                                ? $"param_{originalMethodParameter.Sequence}"
                                : originalMethodParameter.Name;
                            
                            var newParameter = new ParameterDefinition(newName,
                                originalMethodParameter.Attributes & ~ParameterAttributes.HasFieldMarshal,
                                assemblyContext.RewriteTypeRef(originalMethodParameter.ParameterType));

                            if (originalMethodParameter.HasConstant && (originalMethodParameter.Constant == null ||
                                                                        originalMethodParameter.Constant is string ||
                                                                        originalMethodParameter.Constant is bool))
                                newParameter.Constant = originalMethodParameter.Constant;
                            else
                                newParameter.Attributes &= ~ParameterAttributes.HasDefault;

                            newMethod.Parameters.Add(newParameter);
                        }
                    }
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass20GenerateStaticConstructors.cs`:

```cs
using System;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;
using Mono.Cecil.Cil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Passes
{
    public static class Pass20GenerateStaticConstructors
    {
        private static int ourTokenlessMethods = 0;
        
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            foreach (var typeContext in assemblyContext.Types)
                GenerateStaticProxy(assemblyContext, typeContext);
            
            LogSupport.Trace($"\nTokenless method count: {ourTokenlessMethods}");
        }

        private static void GenerateStaticProxy(AssemblyRewriteContext assemblyContext, TypeRewriteContext typeContext)
        {
            var oldType = typeContext.OriginalType;
            var newType = typeContext.NewType;

            var staticCtorMethod = new MethodDefinition(".cctor",
                MethodAttributes.Static | MethodAttributes.Private | MethodAttributes.SpecialName |
                MethodAttributes.HideBySig | MethodAttributes.RTSpecialName, assemblyContext.Imports.Void);
            newType.Methods.Add(staticCtorMethod);
            
            var ctorBuilder = staticCtorMethod.Body.GetILProcessor();

            if (newType.IsNested) {
                ctorBuilder.Emit(OpCodes.Ldsfld, assemblyContext.GlobalContext.GetNewTypeForOriginal(oldType.DeclaringType).ClassPointerFieldRef);
                ctorBuilder.Emit(OpCodes.Ldstr, oldType.Name);
                ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppNestedClass);
            } else {
                ctorBuilder.Emit(OpCodes.Ldstr, oldType.Module.Name);
                ctorBuilder.Emit(OpCodes.Ldstr, oldType.Namespace);
                ctorBuilder.Emit(OpCodes.Ldstr, oldType.Name);
                ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppGlobalClass);
            }

            if (oldType.HasGenericParameters)
            {
                var il2CppTypeTypeRewriteContext = assemblyContext.GlobalContext.GetAssemblyByName("mscorlib").GetTypeByName("System.Type");
                var il2CppSystemTypeRef = newType.Module.ImportReference(il2CppTypeTypeRewriteContext.NewType);
                
                var il2CppTypeHandleTypeRewriteContext = assemblyContext.GlobalContext.GetAssemblyByName("mscorlib").GetTypeByName("System.RuntimeTypeHandle");
                var il2CppSystemTypeHandleRef = newType.Module.ImportReference(il2CppTypeHandleTypeRewriteContext.NewType);
                
                ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppTypeFromClass);
                ctorBuilder.Emit(OpCodes.Call, new MethodReference("internal_from_handle", il2CppSystemTypeRef, il2CppSystemTypeRef) { Parameters = { new ParameterDefinition(assemblyContext.Imports.IntPtr) }});

                ctorBuilder.EmitLdcI4(oldType.GenericParameters.Count);
                
                ctorBuilder.Emit(OpCodes.Newarr, il2CppSystemTypeRef);
                
                for (var i = 0; i < oldType.GenericParameters.Count; i++)
                {
                    ctorBuilder.Emit(OpCodes.Dup);
                    ctorBuilder.EmitLdcI4(i);
                    
                    var param = oldType.GenericParameters[i];
                    var storeRef = new GenericInstanceType(assemblyContext.Imports.Il2CppClassPointerStore) { GenericArguments = { param }};
                    var fieldRef = new FieldReference(nameof(Il2CppClassPointerStore<object>.NativeClassPtr), assemblyContext.Imports.IntPtr, storeRef);
                    ctorBuilder.Emit(OpCodes.Ldsfld, fieldRef);
                    
                    ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppTypeFromClass);
                    
                    ctorBuilder.Emit(OpCodes.Call, new MethodReference("internal_from_handle", il2CppSystemTypeRef, il2CppSystemTypeRef) { Parameters = { new ParameterDefinition(assemblyContext.Imports.IntPtr) }});
                    ctorBuilder.Emit(OpCodes.Stelem_Ref);
                }

                var il2CppTypeArray = new GenericInstanceType(assemblyContext.Imports.Il2CppReferenceArray) { GenericArguments = { il2CppSystemTypeRef }};
                ctorBuilder.Emit(OpCodes.Newobj, new MethodReference(".ctor", assemblyContext.Imports.Void, il2CppTypeArray) {HasThis = true, Parameters = { new ParameterDefinition(new ArrayType(assemblyContext.Imports.Il2CppReferenceArray.GenericParameters[0])) }});
                ctorBuilder.Emit(OpCodes.Call, new MethodReference(nameof(Type.MakeGenericType), il2CppSystemTypeRef, il2CppSystemTypeRef) { HasThis = true, Parameters = { new ParameterDefinition(il2CppTypeArray) }});
                
                ctorBuilder.Emit(OpCodes.Call, new MethodReference(typeof(Type).GetProperty(nameof(Type.TypeHandle))!.GetMethod!.Name, il2CppSystemTypeHandleRef, il2CppSystemTypeRef) { HasThis = true });
                ctorBuilder.Emit(OpCodes.Ldfld, new FieldReference("value", assemblyContext.Imports.IntPtr, il2CppSystemTypeHandleRef));
                
                ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppTypeToClass);
            }
            
            ctorBuilder.Emit(OpCodes.Stsfld, typeContext.ClassPointerFieldRef);
            
            if (oldType.IsBeforeFieldInit)
            {
                ctorBuilder.Emit(OpCodes.Ldsfld, typeContext.ClassPointerFieldRef);
                ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.RuntimeClassInit);
            }

            if (oldType.IsEnum)
            {
                ctorBuilder.Emit(OpCodes.Ret);
                return;
            }

            foreach (var field in typeContext.Fields)
            {
                ctorBuilder.Emit(OpCodes.Ldsfld, typeContext.ClassPointerFieldRef);
                ctorBuilder.Emit(OpCodes.Ldstr, field.OriginalField.Name);
                ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetFieldPointer);
                ctorBuilder.Emit(OpCodes.Stsfld, field.PointerField);
            }

            foreach (var method in typeContext.Methods)
            {
                ctorBuilder.Emit(OpCodes.Ldsfld, typeContext.ClassPointerFieldRef);
                
                var token = method.OriginalMethod.ExtractToken();
                if (token == 0)
                {
                    ourTokenlessMethods++;
                    
                    ctorBuilder.Emit(method.OriginalMethod.GenericParameters.Count > 0 ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
                    ctorBuilder.Emit(OpCodes.Ldstr, method.OriginalMethod.Name);
                    ctorBuilder.EmitLoadTypeNameString(assemblyContext.Imports, method.OriginalMethod, method.OriginalMethod.ReturnType, method.NewMethod.ReturnType);
                    ctorBuilder.Emit(OpCodes.Ldc_I4, method.OriginalMethod.Parameters.Count);
                    ctorBuilder.Emit(OpCodes.Newarr, assemblyContext.Imports.String);

                    for (var i = 0; i < method.OriginalMethod.Parameters.Count; i++)
                    {
                        ctorBuilder.Emit(OpCodes.Dup);
                        ctorBuilder.EmitLdcI4(i);
                        ctorBuilder.EmitLoadTypeNameString(assemblyContext.Imports, method.OriginalMethod, method.OriginalMethod.Parameters[i].ParameterType, method.NewMethod.Parameters[i].ParameterType);
                        ctorBuilder.Emit(OpCodes.Stelem_Ref);
                    }

                    ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppMethod);
                }
                else
                {
                    ctorBuilder.EmitLdcI4((int) token);
                    ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppMethodFromToken);
                }

                ctorBuilder.Emit(OpCodes.Stsfld, method.NonGenericMethodInfoPointerField);
            }
            
            ctorBuilder.Emit(OpCodes.Ret);
        }

        private static void EmitLoadTypeNameString(this ILProcessor ctorBuilder, AssemblyKnownImports imports, MethodDefinition originalMethod, TypeReference originalTypeReference, TypeReference newTypeReference)
        {
            if (originalMethod.HasGenericParameters || originalTypeReference.FullName == "System.Void")
                ctorBuilder.Emit(OpCodes.Ldstr, originalTypeReference.FullName);
            else
            {
                ctorBuilder.Emit(newTypeReference.IsByReference ? OpCodes.Ldc_I4_1 :  OpCodes.Ldc_I4_0);
                ctorBuilder.Emit(OpCodes.Call, imports.Module.ImportReference(new GenericInstanceMethod(imports.Il2CppRenderTypeNameGeneric) {GenericArguments = {newTypeReference}}));
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass21GenerateValueTypeFields.cs`:

```cs
using System;
using System.Linq;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass21GenerateValueTypeFields
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                var il2CppTypeTypeRewriteContext = assemblyContext.GlobalContext.GetAssemblyByName("mscorlib").GetTypeByName("System.Object");
                var il2CppSystemTypeRef = assemblyContext.NewAssembly.MainModule.ImportReference(il2CppTypeTypeRewriteContext.NewType);
                
                foreach (var typeContext in assemblyContext.Types)
                {
                    if (typeContext.ComputedTypeSpecifics != TypeRewriteContext.TypeSpecifics.BlittableStruct || typeContext.OriginalType.IsEnum) continue;

                    var newType = typeContext.NewType;
                    newType.Attributes = newType.Attributes & ~(TypeAttributes.LayoutMask) |
                                         TypeAttributes.ExplicitLayout;
                    
                    UtilGenerator.GenerateBoxMethod(newType, typeContext.ClassPointerFieldRef, il2CppSystemTypeRef);
                    
                    foreach (var fieldContext in typeContext.Fields)
                    {
                        var field = fieldContext.OriginalField;
                        if(field.IsStatic) continue;
                        
                        var newField = new FieldDefinition(fieldContext.UnmangledName, field.Attributes.ForcePublic(),
                            !field.FieldType.IsValueType
                                ? assemblyContext.Imports.IntPtr
                                : assemblyContext.RewriteTypeRef(field.FieldType));
                        
                        newField.Offset = Convert.ToInt32(
                            (string) field.CustomAttributes
                                .Single(it => it.AttributeType.Name == "FieldOffsetAttribute")
                                .Fields.Single().Argument.Value, 16);
                        
                        newType.Fields.Add(newField);
                    }
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass22GenerateEnums.cs`:

```cs
using System.Linq;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass22GenerateEnums
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    if (!typeContext.OriginalType.IsEnum) continue;

                    var type = typeContext.OriginalType;
                    var newType = typeContext.NewType;
                    
                    if (type.CustomAttributes.Any(it => it.AttributeType.FullName == "System.FlagsAttribute"))
                        newType.CustomAttributes.Add(new CustomAttribute(assemblyContext.Imports.FlagsAttributeCtor));

                    foreach (var fieldDefinition in type.Fields)
                    {
                        var fieldName = fieldDefinition.Name;
                        if (!context.Options.PassthroughNames && fieldName.IsObfuscated(context.Options))
                            fieldName = GetUnmangledName(fieldDefinition);
                        
                        if (context.Options.RenameMap.TryGetValue(typeContext.NewType.GetNamespacePrefix() + "." + typeContext.NewType.Name + "::" + fieldName, out var newName))
                            fieldName = newName;
                        
                        var newDef = new FieldDefinition(fieldName, fieldDefinition.Attributes | FieldAttributes.HasDefault, assemblyContext.RewriteTypeRef(fieldDefinition.FieldType));
                        newType.Fields.Add(newDef);

                        newDef.Constant = fieldDefinition.Constant;
                    }
                }
            }
        }

        public static string GetUnmangledName(FieldDefinition field)
        {
            return "EnumValue" + field.Constant;
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass23GeneratePointerConstructors.cs`:

```cs
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass23GeneratePointerConstructors
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    if (typeContext.ComputedTypeSpecifics == TypeRewriteContext.TypeSpecifics.BlittableStruct || typeContext.OriginalType.IsEnum) continue;
                    
                    var newType = typeContext.NewType;
                    var nativeCtor = new MethodDefinition(".ctor",
                        MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName |
                        MethodAttributes.HideBySig, assemblyContext.Imports.Void);

                    nativeCtor.Parameters.Add(new ParameterDefinition(assemblyContext.Imports.IntPtr));
                    
                    var ctorBody = nativeCtor.Body.GetILProcessor();
                    newType.Methods.Add(nativeCtor);

                    ctorBody.Emit(OpCodes.Ldarg_0);
                    ctorBody.Emit(OpCodes.Ldarg_1);
                    ctorBody.Emit(OpCodes.Call,
                        new MethodReference(".ctor", assemblyContext.Imports.Void, newType.BaseType)
                            {Parameters = {new ParameterDefinition(assemblyContext.Imports.IntPtr)}, HasThis = true});
                    ctorBody.Emit(OpCodes.Ret);
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass24GenerateTypeStaticGetters.cs`:

```cs
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass24GenerateTypeStaticGetters
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                var il2CppTypeTypeRewriteContext = assemblyContext.GlobalContext
                    .GetAssemblyByName("mscorlib").GetTypeByName("System.Type");
                var il2CppSystemTypeRef =
                    assemblyContext.NewAssembly.MainModule.ImportReference(il2CppTypeTypeRewriteContext.NewType);
                
                foreach (var typeContext in assemblyContext.Types)
                {
                    var typeGetMethod = new MethodDefinition("get_Il2CppType", MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.Static, il2CppSystemTypeRef);
                    typeContext.NewType.Methods.Add(typeGetMethod);
                    var typeProperty = new PropertyDefinition("Il2CppType", PropertyAttributes.None, il2CppSystemTypeRef);
                    typeProperty.GetMethod = typeGetMethod;
                    typeContext.NewType.Properties.Add(typeProperty);

                    typeProperty.CustomAttributes.Add(new CustomAttribute(assemblyContext.Imports.ObsoleteAttributeCtor)
                    {
                        ConstructorArguments =
                        {
                            new CustomAttributeArgument(assemblyContext.Imports.String,
                                "Use Il2CppType.Of<T>() instead. This will be removed in a future version of unhollower.")
                        }
                    });
                    
                    var bodyBuilder = typeGetMethod.Body.GetILProcessor();
                    
                    bodyBuilder.Emit(OpCodes.Ldsfld, typeContext.ClassPointerFieldRef);
                    bodyBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppTypeFromClass);

                    bodyBuilder.Emit(OpCodes.Call,
                        new MethodReference("internal_from_handle", il2CppSystemTypeRef,
                                il2CppSystemTypeRef)
                            {Parameters = {new ParameterDefinition(assemblyContext.Imports.IntPtr)}});
                    
                    bodyBuilder.Emit(OpCodes.Ret);
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass25GenerateNonBlittableValueTypeDefaultCtors.cs`:

```cs
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass25GenerateNonBlittableValueTypeDefaultCtors
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    if (typeContext.ComputedTypeSpecifics !=
                        TypeRewriteContext.TypeSpecifics.NonBlittableStruct) continue;

                    var emptyCtor = new MethodDefinition(".ctor",
                        MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName |
                        MethodAttributes.HideBySig, assemblyContext.Imports.Void);
                    
                    typeContext.NewType.Methods.Add(emptyCtor);

                    var local0 = new VariableDefinition(assemblyContext.Imports.IntPtr);
                    emptyCtor.Body.Variables.Add(local0);
                    
                    var bodyBuilder = emptyCtor.Body.GetILProcessor();
                    bodyBuilder.Emit(OpCodes.Ldsfld, typeContext.ClassPointerFieldRef);
                    bodyBuilder.Emit(OpCodes.Ldc_I4_0);
                    bodyBuilder.Emit(OpCodes.Conv_U);
                    bodyBuilder.Emit(OpCodes.Call, assemblyContext.Imports.ValueSizeGet);
                    bodyBuilder.Emit(OpCodes.Conv_U);
                    bodyBuilder.Emit(OpCodes.Localloc);
                    bodyBuilder.Emit(OpCodes.Stloc_0);
                    bodyBuilder.Emit(OpCodes.Ldarg_0);
                    bodyBuilder.Emit(OpCodes.Ldsfld, typeContext.ClassPointerFieldRef);
                    bodyBuilder.Emit(OpCodes.Ldloc_0);
                    bodyBuilder.Emit(OpCodes.Call, assemblyContext.Imports.ObjectBox);
                    bodyBuilder.Emit(OpCodes.Call, new MethodReference(".ctor", assemblyContext.Imports.Void, typeContext.NewType.BaseType) { HasThis = true, Parameters = { new ParameterDefinition(assemblyContext.Imports.IntPtr) }});
                    bodyBuilder.Emit(OpCodes.Ret);
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass30GenerateGenericMethodStoreConstructors.cs`:

```cs
using System.Reflection;
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;
using UnhollowerBaseLib;
using MethodAttributes = Mono.Cecil.MethodAttributes;

namespace AssemblyUnhollower.Passes
{
    public static class Pass30GenerateGenericMethodStoreConstructors
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    foreach (var methodContext in typeContext.Methods)
                    {
                        var oldMethod = methodContext.OriginalMethod;
                        
                        var storeType = methodContext.GenericInstantiationsStore;
                        if (storeType != null)
                        {
                            var cctor = new MethodDefinition(".cctor",
                                MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.SpecialName |
                                MethodAttributes.RTSpecialName | MethodAttributes.HideBySig,
                                assemblyContext.Imports.Void);
                            storeType.Methods.Add(cctor);

                            var ctorBuilder = cctor.Body.GetILProcessor();

                            var il2CppTypeTypeRewriteContext = assemblyContext.GlobalContext
                                .GetAssemblyByName("mscorlib").GetTypeByName("System.Type");
                            var il2CppSystemTypeRef =
                                assemblyContext.NewAssembly.MainModule.ImportReference(il2CppTypeTypeRewriteContext.NewType);
                            
                            var il2CppMethodInfoTypeRewriteContext = assemblyContext.GlobalContext
                                .GetAssemblyByName("mscorlib").GetTypeByName("System.Reflection.MethodInfo");
                            var il2CppSystemReflectionMethodInfoRef =
                                assemblyContext.NewAssembly.MainModule.ImportReference(il2CppMethodInfoTypeRewriteContext.NewType);

                            ctorBuilder.Emit(OpCodes.Ldsfld, methodContext.NonGenericMethodInfoPointerField);
                            ctorBuilder.Emit(OpCodes.Ldsfld, typeContext.ClassPointerFieldRef);
                            ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.Il2CppMethodInfoToReflection);
                            ctorBuilder.Emit(OpCodes.Newobj,
                                new MethodReference(".ctor", assemblyContext.Imports.Void,
                                    il2CppSystemReflectionMethodInfoRef)
                                {
                                    HasThis = true,
                                    Parameters = {new ParameterDefinition(assemblyContext.Imports.IntPtr)}
                                });

                            ctorBuilder.EmitLdcI4(oldMethod.GenericParameters.Count);

                            ctorBuilder.Emit(OpCodes.Newarr, il2CppSystemTypeRef);

                            for (var i = 0; i < oldMethod.GenericParameters.Count; i++)
                            {
                                ctorBuilder.Emit(OpCodes.Dup);
                                ctorBuilder.EmitLdcI4(i);

                                var param = storeType.GenericParameters[i];
                                var storeRef = new GenericInstanceType(assemblyContext.Imports.Il2CppClassPointerStore)
                                    {GenericArguments = {param}};
                                var fieldRef = new FieldReference(
                                    nameof(Il2CppClassPointerStore<object>.NativeClassPtr),
                                    assemblyContext.Imports.IntPtr, storeRef);
                                ctorBuilder.Emit(OpCodes.Ldsfld, fieldRef);

                                ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.GetIl2CppTypeFromClass);

                                ctorBuilder.Emit(OpCodes.Call,
                                    new MethodReference("internal_from_handle", il2CppSystemTypeRef,
                                            il2CppSystemTypeRef)
                                        {Parameters = {new ParameterDefinition(assemblyContext.Imports.IntPtr)}});
                                ctorBuilder.Emit(OpCodes.Stelem_Ref);
                            }

                            var il2CppTypeArray = new GenericInstanceType(assemblyContext.Imports.Il2CppReferenceArray)
                                {GenericArguments = {il2CppSystemTypeRef}};
                            ctorBuilder.Emit(OpCodes.Newobj,
                                new MethodReference(".ctor", assemblyContext.Imports.Void, il2CppTypeArray)
                                {
                                    HasThis = true,
                                    Parameters = {new ParameterDefinition(new ArrayType(assemblyContext.Imports.Il2CppReferenceArray.GenericParameters[0]))}
                                });
                            ctorBuilder.Emit(OpCodes.Call,
                                new MethodReference(nameof(MethodInfo.MakeGenericMethod), il2CppSystemReflectionMethodInfoRef,
                                        il2CppSystemReflectionMethodInfoRef)
                                    {HasThis = true, Parameters = {new ParameterDefinition(il2CppTypeArray)}});
                            ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.Il2CppObjectBaseToPointerNotNull);

                            ctorBuilder.Emit(OpCodes.Call, assemblyContext.Imports.Il2CppMethodInfoFromReflection);
                            ctorBuilder.Emit(OpCodes.Stsfld, new FieldReference("Pointer", assemblyContext.Imports.IntPtr, methodContext.GenericInstantiationsStoreSelfSubstRef));
                            
                            ctorBuilder.Emit(OpCodes.Ret);
                        }
                    }
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass40GenerateFieldAccessors.cs`:

```cs
using AssemblyUnhollower.Contexts;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass40GenerateFieldAccessors
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    foreach (var fieldContext in typeContext.Fields)
                    {
                        if (typeContext.ComputedTypeSpecifics == TypeRewriteContext.TypeSpecifics.BlittableStruct && !fieldContext.OriginalField.IsStatic) continue;

                        var field = fieldContext.OriginalField;
                        var unmangleFieldName = fieldContext.UnmangledName;

                        var property = new PropertyDefinition(unmangleFieldName, PropertyAttributes.None,
                            assemblyContext.RewriteTypeRef(fieldContext.OriginalField.FieldType));
                        typeContext.NewType.Properties.Add(property);

                        FieldAccessorGenerator.MakeGetter(field, fieldContext, property, assemblyContext.Imports);
                        FieldAccessorGenerator.MakeSetter(field, fieldContext, property, assemblyContext.Imports);
                    }
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass50GenerateMethods.cs`:

```cs
using System.Collections.Generic;
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass50GenerateMethods
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    foreach (var methodRewriteContext in typeContext.Methods)
                    {
                        var originalMethod = methodRewriteContext.OriginalMethod;
                        var newMethod = methodRewriteContext.NewMethod;
                        var imports = assemblyContext.Imports;

                        var bodyBuilder = newMethod.Body.GetILProcessor();
                        var exceptionLocal = new VariableDefinition(imports.IntPtr);
                        var argArray = new VariableDefinition(new PointerType(imports.IntPtr));
                        var resultVar = new VariableDefinition(imports.IntPtr);
                        var valueTypeLocal = new VariableDefinition(newMethod.ReturnType);
                        newMethod.Body.Variables.Add(exceptionLocal);
                        newMethod.Body.Variables.Add(argArray);
                        newMethod.Body.Variables.Add(resultVar);

                        if (valueTypeLocal.VariableType.FullName != "System.Void")
                            newMethod.Body.Variables.Add(valueTypeLocal);

                        if (!originalMethod.DeclaringType.IsValueType)
                        {
                            if (originalMethod.IsConstructor)
                            {
                                bodyBuilder.Emit(OpCodes.Ldarg_0);
                                bodyBuilder.Emit(OpCodes.Ldsfld, typeContext.ClassPointerFieldRef);
                                bodyBuilder.Emit(OpCodes.Call,imports.Il2CppNewObject);
                                bodyBuilder.Emit(OpCodes.Call,
                                    new MethodReference(".ctor", imports.Void, typeContext.SelfSubstitutedRef)
                                        {Parameters = {new ParameterDefinition(imports.IntPtr)}, HasThis = true});
                            }
                            else if (!originalMethod.IsStatic)
                            {
                                bodyBuilder.Emit(OpCodes.Ldarg_0);
                                bodyBuilder.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointerNotNull);
                                bodyBuilder.Emit(OpCodes.Pop);
                            }
                        }

                        if (originalMethod.Parameters.Count == 0)
                        {
                            bodyBuilder.Emit(OpCodes.Ldc_I4_0);
                            bodyBuilder.Emit(OpCodes.Conv_U);
                        }
                        else
                        {
                            bodyBuilder.EmitLdcI4(originalMethod.Parameters.Count);
                            bodyBuilder.Emit(OpCodes.Conv_U);
                            bodyBuilder.Emit(OpCodes.Sizeof, imports.IntPtr);
                            bodyBuilder.Emit(OpCodes.Mul_Ovf_Un);
                            bodyBuilder.Emit(OpCodes.Localloc);
                        }
                        bodyBuilder.Emit(OpCodes.Stloc, argArray);

                        var argOffset = originalMethod.IsStatic ? 0 : 1;

                        var byRefParams = new List<(int, VariableDefinition)>();

                        for (var i = 0; i < newMethod.Parameters.Count; i++)
                        {
                            bodyBuilder.Emit(OpCodes.Ldloc, argArray);
                            if (i > 0) {
                                bodyBuilder.EmitLdcI4(i);
                                bodyBuilder.Emit(OpCodes.Conv_U);
                                bodyBuilder.Emit(OpCodes.Sizeof, imports.IntPtr);
                                bodyBuilder.Emit(OpCodes.Mul_Ovf_Un);
                                bodyBuilder.Emit(OpCodes.Add);
                            }

                            var newParam = newMethod.Parameters[i];
                            bodyBuilder.EmitObjectToPointer(originalMethod.Parameters[i].ParameterType, newParam.ParameterType, methodRewriteContext.DeclaringType, argOffset + i, false, true, true, out var refVar);
                            bodyBuilder.Emit(OpCodes.Stind_I);
                            
                            if(refVar != null)
                                byRefParams.Add((i, refVar));
                        }

                        if (!originalMethod.DeclaringType.IsSealed && !originalMethod.IsFinal && (originalMethod.IsVirtual && !originalMethod.DeclaringType.IsValueType || originalMethod.IsAbstract))
                        {
                            bodyBuilder.Emit(OpCodes.Ldarg_0);
                            bodyBuilder.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointer);
                            if (methodRewriteContext.GenericInstantiationsStoreSelfSubstRef != null)
                                bodyBuilder.Emit(OpCodes.Ldsfld, new FieldReference("Pointer", imports.IntPtr, methodRewriteContext.GenericInstantiationsStoreSelfSubstMethodRef));
                            else
                                bodyBuilder.Emit(OpCodes.Ldsfld, methodRewriteContext.NonGenericMethodInfoPointerField);
                            bodyBuilder.Emit(OpCodes.Call, imports.GetVirtualMethod);
                        }
                        else if (methodRewriteContext.GenericInstantiationsStoreSelfSubstRef != null)
                            bodyBuilder.Emit(OpCodes.Ldsfld, new FieldReference("Pointer", imports.IntPtr, methodRewriteContext.GenericInstantiationsStoreSelfSubstMethodRef));
                        else
                            bodyBuilder.Emit(OpCodes.Ldsfld, methodRewriteContext.NonGenericMethodInfoPointerField);

                        if (originalMethod.IsStatic)
                            bodyBuilder.Emit(OpCodes.Ldc_I4_0);
                        else
                            bodyBuilder.EmitObjectToPointer(originalMethod.DeclaringType, newMethod.DeclaringType, typeContext, 0, true, false, true, out _);

                        bodyBuilder.Emit(OpCodes.Ldloc, argArray);
                        bodyBuilder.Emit(OpCodes.Ldloca, exceptionLocal);
                        bodyBuilder.Emit(OpCodes.Call, imports.RuntimeInvoke);
                        bodyBuilder.Emit(OpCodes.Stloc, resultVar);

                        bodyBuilder.Emit(OpCodes.Ldloc, exceptionLocal);
                        bodyBuilder.Emit(OpCodes.Call, imports.RaiseExceptionIfNecessary);
                        
                        foreach (var byRefParam in byRefParams)
                        {
                            var paramIndex = byRefParam.Item1;
                            var paramVariable = byRefParam.Item2;
                            bodyBuilder.EmitUpdateRef(newMethod.Parameters[paramIndex], paramIndex + argOffset, paramVariable, imports);
                        }

                        bodyBuilder.EmitPointerToObject(originalMethod.ReturnType, newMethod.ReturnType, typeContext, bodyBuilder.Create(OpCodes.Ldloc, resultVar), false, true);

                        bodyBuilder.Emit(OpCodes.Ret);
                    }
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass60AddImplicitConversions.cs`:

```cs
using System.Linq;
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;
using UnhollowerRuntimeLib;

namespace AssemblyUnhollower.Passes
{
    public static class Pass60AddImplicitConversions
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            var assemblyContext = context.GetAssemblyByName("mscorlib");
            var typeContext = assemblyContext.GetTypeByName("System.String");
            var objectTypeContext = assemblyContext.GetTypeByName("System.Object");
            
            var methodFromMonoString = new MethodDefinition("op_Implicit", MethodAttributes.Static | MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, typeContext.NewType);
            methodFromMonoString.Parameters.Add(new ParameterDefinition(assemblyContext.Imports.String));
            typeContext.NewType.Methods.Add(methodFromMonoString);
            var fromBuilder = methodFromMonoString.Body.GetILProcessor();

            var createIl2CppStringNop = fromBuilder.Create(OpCodes.Nop);
            
            fromBuilder.Emit(OpCodes.Ldarg_0);
            fromBuilder.Emit(OpCodes.Dup);
            fromBuilder.Emit(OpCodes.Brtrue_S, createIl2CppStringNop);
            fromBuilder.Emit(OpCodes.Ret);
            
            fromBuilder.Append(createIl2CppStringNop);
            fromBuilder.Emit(OpCodes.Call, assemblyContext.Imports.StringToNative);
            fromBuilder.Emit(OpCodes.Newobj,
                new MethodReference(".ctor", assemblyContext.Imports.Void, typeContext.NewType)
                {
                    HasThis = true, Parameters = {new ParameterDefinition(assemblyContext.Imports.IntPtr)}
                });
            fromBuilder.Emit(OpCodes.Ret);
            
            var methodToObject = new MethodDefinition("op_Implicit", MethodAttributes.Static | MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, objectTypeContext.NewType);
            methodToObject.Parameters.Add(new ParameterDefinition(assemblyContext.Imports.String));
            objectTypeContext.NewType.Methods.Add(methodToObject);
            var toObjectBuilder = methodToObject.Body.GetILProcessor();
            toObjectBuilder.Emit(OpCodes.Ldarg_0);
            toObjectBuilder.Emit(OpCodes.Call, methodFromMonoString);
            toObjectBuilder.Emit(OpCodes.Ret);
            
            var methodToMonoString = new MethodDefinition("op_Implicit", MethodAttributes.Static | MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, assemblyContext.Imports.String);
            methodToMonoString.Parameters.Add(new ParameterDefinition(typeContext.NewType));
            typeContext.NewType.Methods.Add(methodToMonoString);
            var toBuilder = methodToMonoString.Body.GetILProcessor();

            var createStringNop = toBuilder.Create(OpCodes.Nop);
            
            toBuilder.Emit(OpCodes.Ldarg_0);
            toBuilder.Emit(OpCodes.Call, assemblyContext.Imports.Il2CppObjectBaseToPointer);
            toBuilder.Emit(OpCodes.Dup);
            toBuilder.Emit(OpCodes.Brtrue_S, createStringNop);
            toBuilder.Emit(OpCodes.Pop);
            toBuilder.Emit(OpCodes.Ldnull);
            toBuilder.Emit(OpCodes.Ret);
            
            toBuilder.Append(createStringNop);
            toBuilder.Emit(OpCodes.Call, assemblyContext.Imports.StringFromNative);
            toBuilder.Emit(OpCodes.Ret);

            AddDelegateConversions(context);
        }

        private static void AddDelegateConversions(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    if (typeContext.OriginalType.BaseType?.FullName != "System.MulticastDelegate") continue;

                    var invokeMethod = typeContext.NewType.Methods.Single(it => it.Name == "Invoke");
                    if (invokeMethod.Parameters.Count > 8) continue; // mscorlib only contains delegates of up to 8 parameters

                    // Don't generate implicit conversions for pointers and byrefs, as they can't be specified in generics
                    if (invokeMethod.Parameters.Any(it => it.ParameterType.IsByReference || it.ParameterType.IsPointer))
                        continue;
                    
                    var implicitMethod = new MethodDefinition("op_Implicit", MethodAttributes.Static | MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, typeContext.SelfSubstitutedRef);
                    typeContext.NewType.Methods.Add(implicitMethod);

                    var hasReturn = invokeMethod.ReturnType.FullName != "System.Void";
                    var hasParameters = invokeMethod.Parameters.Count > 0;

                    TypeReference monoDelegateType;
                    if (!hasReturn && !hasParameters)
                        monoDelegateType =
                            typeContext.NewType.Module.ImportReference(
                                assemblyContext.Imports.Type.Module.GetType("System.Action"));
                    else if (!hasReturn)
                    {
                        monoDelegateType =
                            typeContext.NewType.Module.ImportReference(
                                assemblyContext.Imports.Type.Module.GetType(
                                    "System.Action`" + invokeMethod.Parameters.Count));
                    } else 
                        monoDelegateType = 
                            typeContext.NewType.Module.ImportReference(
                                assemblyContext.Imports.Type.Module.GetType(
                                    "System.Func`" + (invokeMethod.Parameters.Count + 1)));

                    GenericInstanceType? genericInstanceType = null;
                    if (hasParameters)
                    {
                        genericInstanceType = new GenericInstanceType(monoDelegateType);
                        for (var i = 0; i < invokeMethod.Parameters.Count; i++)
                            genericInstanceType.GenericArguments.Add(invokeMethod.Parameters[i].ParameterType);
                    }

                    if (hasReturn)
                    {
                        genericInstanceType ??= new GenericInstanceType(monoDelegateType);
                        genericInstanceType.GenericArguments.Add(invokeMethod.ReturnType);
                    }

                    implicitMethod.Parameters.Add(new ParameterDefinition(genericInstanceType != null
                        ? typeContext.NewType.Module.ImportReference(genericInstanceType)
                        : monoDelegateType));

                    var bodyBuilder = implicitMethod.Body.GetILProcessor();
                    
                    bodyBuilder.Emit(OpCodes.Ldarg_0);
                    var delegateSupportTypeRef = typeContext.NewType.Module.ImportReference(typeof(DelegateSupport));
                    var genericConvertRef = new MethodReference(nameof(DelegateSupport.ConvertDelegate), assemblyContext.Imports.Void, delegateSupportTypeRef) { HasThis = false, Parameters = { new ParameterDefinition(assemblyContext.Imports.Delegate)}};
                    genericConvertRef.GenericParameters.Add(new GenericParameter(genericConvertRef));
                    genericConvertRef.ReturnType = genericConvertRef.GenericParameters[0];
                    var convertMethodRef = new GenericInstanceMethod(genericConvertRef) { GenericArguments = { typeContext.SelfSubstitutedRef }};
                    bodyBuilder.Emit(OpCodes.Call, typeContext.NewType.Module.ImportReference(convertMethodRef));
                    bodyBuilder.Emit(OpCodes.Ret);

                    // public static T operator+(T lhs, T rhs) => Il2CppSystem.Delegate.Combine(lhs, rhs).Cast<T>();
                    var addMethod = new MethodDefinition("op_Addition", MethodAttributes.Static | MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, typeContext.SelfSubstitutedRef);
                    typeContext.NewType.Methods.Add(addMethod);
                    addMethod.Parameters.Add(new ParameterDefinition(typeContext.SelfSubstitutedRef));
                    addMethod.Parameters.Add(new ParameterDefinition(typeContext.SelfSubstitutedRef));
                    var addBody = addMethod.Body.GetILProcessor();
                    addBody.Emit(OpCodes.Ldarg_0);
                    addBody.Emit(OpCodes.Ldarg_1);
                    addBody.Emit(OpCodes.Call, assemblyContext.Imports.DelegateCombine);
                    addBody.Emit(OpCodes.Call, assemblyContext.Imports.Module.ImportReference(new GenericInstanceMethod(assemblyContext.Imports.Il2CppObjectCast) { GenericArguments = { typeContext.SelfSubstitutedRef }}));
                    addBody.Emit(OpCodes.Ret);

                    // public static T operator-(T lhs, T rhs) => Il2CppSystem.Delegate.Remove(lhs, rhs)?.Cast<T>();
                    var subtractMethod = new MethodDefinition("op_Subtraction", MethodAttributes.Static | MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, typeContext.SelfSubstitutedRef);
                    typeContext.NewType.Methods.Add(subtractMethod);
                    subtractMethod.Parameters.Add(new ParameterDefinition(typeContext.SelfSubstitutedRef));
                    subtractMethod.Parameters.Add(new ParameterDefinition(typeContext.SelfSubstitutedRef));
                    var subtractBody = subtractMethod.Body.GetILProcessor();
                    subtractBody.Emit(OpCodes.Ldarg_0);
                    subtractBody.Emit(OpCodes.Ldarg_1);
                    subtractBody.Emit(OpCodes.Call, assemblyContext.Imports.DelegateRemove);
                    subtractBody.Emit(OpCodes.Dup);
                    var ret = subtractBody.Create(OpCodes.Ret);
                    subtractBody.Emit(OpCodes.Brfalse_S, ret);
                    subtractBody.Emit(OpCodes.Call, assemblyContext.Imports.Module.ImportReference(new GenericInstanceMethod(assemblyContext.Imports.Il2CppObjectCast) { GenericArguments = { typeContext.SelfSubstitutedRef }}));
                    subtractBody.Append(ret);
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass70GenerateProperties.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;

namespace AssemblyUnhollower.Passes
{
    public static class Pass70GenerateProperties
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            foreach (var assemblyContext in context.Assemblies)
            {
                foreach (var typeContext in assemblyContext.Types)
                {
                    var type = typeContext.OriginalType;
                    var propertyCountsByName = new Dictionary<string, int>();
                    
                    foreach (var oldProperty in type.Properties)
                    {
                        var unmangledPropertyName = UnmanglePropertyName(assemblyContext, oldProperty, typeContext.NewType, propertyCountsByName);

                        var property = new PropertyDefinition(unmangledPropertyName, oldProperty.Attributes,
                            assemblyContext.RewriteTypeRef(oldProperty.PropertyType));
                        foreach (var oldParameter in oldProperty.Parameters)
                            property.Parameters.Add(new ParameterDefinition(oldParameter.Name, oldParameter.Attributes,
                                assemblyContext.RewriteTypeRef(oldParameter.ParameterType)));
                        
                        typeContext.NewType.Properties.Add(property);

                        if (oldProperty.GetMethod != null)
                            property.GetMethod = typeContext.GetMethodByOldMethod(oldProperty.GetMethod).NewMethod;

                        if (oldProperty.SetMethod != null)
                            property.SetMethod = typeContext.GetMethodByOldMethod(oldProperty.SetMethod).NewMethod;
                    }

                    string? defaultMemberName = null;
                    var defaultMemberAttributeAttribute = type.CustomAttributes.FirstOrDefault(it =>
                        it.AttributeType.Name == "AttributeAttribute" && it.Fields.Any(it =>
                            it.Name == "Name" && (string)it.Argument.Value == nameof(DefaultMemberAttribute)));
                    if (defaultMemberAttributeAttribute != null)
                        defaultMemberName = "Item";
                    else
                    {
                        var realDefaultMemberAttribute = type.CustomAttributes.FirstOrDefault(it => it.AttributeType.Name == nameof(DefaultMemberAttribute));
                        if (realDefaultMemberAttribute != null)
                            defaultMemberName = realDefaultMemberAttribute.ConstructorArguments[0].Value.ToString();
                    }

                    if (defaultMemberName != null)
                    {
                        typeContext.NewType.CustomAttributes.Add(new CustomAttribute(
                            new MethodReference(".ctor", assemblyContext.Imports.Void,
                                assemblyContext.Imports.DefaultMemberAttribute)
                            {
                                HasThis = true,
                                Parameters = {new ParameterDefinition(assemblyContext.Imports.String)}
                            })
                        {
                            ConstructorArguments = { new CustomAttributeArgument(assemblyContext.Imports.String, defaultMemberName) }
                        });
                    }
                }
            }
        }
        
        private static string UnmanglePropertyName(AssemblyRewriteContext assemblyContext, PropertyDefinition prop, TypeReference declaringType, Dictionary<string, int> countsByBaseName)
        {
            if (assemblyContext.GlobalContext.Options.PassthroughNames || !prop.Name.IsObfuscated(assemblyContext.GlobalContext.Options)) return prop.Name;

            var baseName = "prop_" + assemblyContext.RewriteTypeRef(prop.PropertyType).GetUnmangledName();

            countsByBaseName.TryGetValue(baseName, out var index);
            countsByBaseName[baseName] = index + 1;
            
            var unmanglePropertyName = baseName + "_" + index;
                        
            if (assemblyContext.GlobalContext.Options.RenameMap.TryGetValue(declaringType.GetNamespacePrefix() + "::" + unmanglePropertyName, out var newName))
                unmanglePropertyName = newName;
            
            return unmanglePropertyName;
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass79UnstripTypes.cs`:

```cs
using System.IO;
using System.Linq;
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Passes
{
    public static class Pass79UnstripTypes
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            var typesUnstripped = 0;
            
            foreach (var unityAssembly in context.UnityAssemblies.Assemblies)
            {
                var processedAssembly = context.TryGetAssemblyByName(unityAssembly.Name.Name);
                if (processedAssembly == null)
                {
                    var newAssembly = new AssemblyRewriteContext(context, unityAssembly,
                        AssemblyDefinition.CreateAssembly(unityAssembly.Name, unityAssembly.MainModule.Name,
                            ModuleKind.Dll));
                    context.AddAssemblyContext(unityAssembly.Name.Name, newAssembly);
                    processedAssembly = newAssembly;
                }
                var imports = processedAssembly.Imports;
                
                foreach (var unityType in unityAssembly.MainModule.Types)
                    ProcessType(processedAssembly, unityType, null, imports, ref typesUnstripped);
            }
            
            LogSupport.Trace(""); // end the progress message
            LogSupport.Trace($"{typesUnstripped} types restored");
        }

        private static void ProcessType(AssemblyRewriteContext processedAssembly, TypeDefinition unityType,
            TypeDefinition? enclosingNewType, AssemblyKnownImports imports, ref int typesUnstripped)
        {
            var processedType = enclosingNewType == null ? processedAssembly.TryGetTypeByName(unityType.FullName)?.NewType : enclosingNewType.NestedTypes.SingleOrDefault(it => it.Name == unityType.Name);
            if (unityType.IsEnum)
            {
                if (processedType != null) return;

                typesUnstripped++;
                var clonedType = CloneEnum(unityType, imports);
                if (enclosingNewType == null)
                    processedAssembly.NewAssembly.MainModule.Types.Add(clonedType);
                else
                {
                    enclosingNewType.NestedTypes.Add(clonedType);
                    clonedType.DeclaringType = enclosingNewType;
                }

                processedAssembly.RegisterTypeRewrite(new TypeRewriteContext(processedAssembly, null, clonedType));
                
                return;
            }

            if (processedType == null && !unityType.IsEnum && !HasNonBlittableFields(unityType) && !unityType.HasGenericParameters) // restore all types even if it would be not entirely correct
            {
                typesUnstripped++;
                var clonedType = CloneStatic(unityType, imports);
                if (enclosingNewType == null)
                    processedAssembly.NewAssembly.MainModule.Types.Add(clonedType);
                else
                {
                    enclosingNewType.NestedTypes.Add(clonedType);
                    clonedType.DeclaringType = enclosingNewType;
                }

                processedAssembly.RegisterTypeRewrite(new TypeRewriteContext(processedAssembly, null, clonedType));
            }

            foreach (var nestedUnityType in unityType.NestedTypes)
                ProcessType(processedAssembly, nestedUnityType, processedType, imports, ref typesUnstripped);
        }

        private static TypeDefinition CloneEnum(TypeDefinition sourceEnum, AssemblyKnownImports imports)
        {
            var newType = new TypeDefinition(sourceEnum.Namespace, sourceEnum.Name, ForcePublic(sourceEnum.Attributes), imports.Enum);
            foreach (var sourceEnumField in sourceEnum.Fields)
            {
                var newField = new FieldDefinition(sourceEnumField.Name, sourceEnumField.Attributes, sourceEnumField.Name == "value__" ? TargetTypeSystemHandler.String.Module.GetType(sourceEnumField.FieldType.FullName) : newType);
                newField.Constant = sourceEnumField.Constant;
                newType.Fields.Add(newField);
            }

            return newType;
        }

        private static bool HasNonBlittableFields(TypeDefinition type)
        {
            if (!type.IsValueType) return false;

            foreach (var fieldDefinition in type.Fields)
            {
                if (fieldDefinition.IsStatic || fieldDefinition.FieldType == type) continue;

                if (!fieldDefinition.FieldType.IsValueType)
                    return true;

                if (fieldDefinition.FieldType.Namespace.StartsWith("System") && HasNonBlittableFields(fieldDefinition.FieldType.Resolve()))
                    return true;
            }

            return false;
        }

        private static TypeDefinition CloneStatic(TypeDefinition sourceEnum, AssemblyKnownImports imports)
        {
            var newType = new TypeDefinition(sourceEnum.Namespace, sourceEnum.Name, ForcePublic(sourceEnum.Attributes),
                sourceEnum.BaseType?.FullName == "System.ValueType" ? imports.ValueType : imports.Object);
            return newType;
        }

        private static TypeAttributes ForcePublic(TypeAttributes typeAttributes)
        {
            var visibility = typeAttributes & TypeAttributes.VisibilityMask;
            if (visibility == 0 || visibility == TypeAttributes.Public)
                return typeAttributes | TypeAttributes.Public;
            
            return typeAttributes & ~(TypeAttributes.VisibilityMask) | TypeAttributes.NestedPublic;
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass80UnstripFields.cs`:

```cs
using System.IO;
using System.Linq;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Utils;
using Mono.Cecil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Passes
{
    public static class Pass80UnstripFields
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            int fieldsUnstripped = 0;
            int fieldsIgnored = 0;
            
            foreach (var unityAssembly in context.UnityAssemblies.Assemblies)
            {
                var processedAssembly = context.TryGetAssemblyByName(unityAssembly.Name.Name);
                if (processedAssembly == null) continue;
                var imports = processedAssembly.Imports;
                
                foreach (var unityType in unityAssembly.MainModule.Types)
                {
                    var processedType = processedAssembly.TryGetTypeByName(unityType.FullName);
                    if (processedType == null) continue;
                    
                    if (!unityType.IsValueType || unityType.IsEnum || processedType.NewType.IsExplicitLayout)
                        continue;

                    foreach (var unityField in unityType.Fields)
                    {
                        if(unityField.IsStatic) continue;
                        
                        var processedField = processedType.TryGetFieldByUnityAssemblyField(unityField);
                        if (processedField != null) continue;

                        var fieldType = Pass80UnstripMethods.ResolveTypeInNewAssemblies(context, unityField.FieldType, imports);
                        if (fieldType == null)
                        {
                            LogSupport.Trace($"Field {unityField} on type {unityType.FullName} has unsupported type {unityField.FieldType}, the type will be unusable");
                            fieldsIgnored++;
                            continue;
                        }
                        
                        var newMethod = new FieldDefinition(unityField.Name, unityField.Attributes & ~FieldAttributes.FieldAccessMask | FieldAttributes.Public, fieldType);
                        
                        processedType.NewType.Fields.Add(newMethod);
                        
                        fieldsUnstripped++;
                    }
                }
            }
            
            LogSupport.Info(""); // finish the progress line
            LogSupport.Info($"{fieldsUnstripped} fields restored");
            LogSupport.Info($"{fieldsIgnored} fields failed to restore");
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass80UnstripMethods.cs`:

```cs
using System.IO;
using System.Linq;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Utils;
using Mono.Cecil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Passes
{
    public static class Pass80UnstripMethods
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            int methodsUnstripped = 0;
            int methodsIgnored = 0;
            
            foreach (var unityAssembly in context.UnityAssemblies.Assemblies)
            {
                var processedAssembly = context.TryGetAssemblyByName(unityAssembly.Name.Name);
                if (processedAssembly == null) continue;
                var imports = processedAssembly.Imports;
                
                foreach (var unityType in unityAssembly.MainModule.Types)
                {
                    var processedType = processedAssembly.TryGetTypeByName(unityType.FullName);
                    if (processedType == null) continue;
                    
                    foreach (var unityMethod in unityType.Methods)
                    {
                        if (unityMethod.Name == ".cctor" || unityMethod.Name == ".ctor") continue;
                        if (unityMethod.IsAbstract) continue;
                        
                        var processedMethod = processedType.TryGetMethodByUnityAssemblyMethod(unityMethod);
                        if (processedMethod != null) continue;

                        var returnType = ResolveTypeInNewAssemblies(context, unityMethod.ReturnType, imports);
                        if (returnType == null)
                        {
                            LogSupport.Trace($"Method {unityMethod} has unsupported return type {unityMethod.ReturnType}");
                            methodsIgnored++;
                            continue;
                        }
                        
                        var newMethod = new MethodDefinition(unityMethod.Name, unityMethod.Attributes & ~MethodAttributes.MemberAccessMask | MethodAttributes.Public, returnType);
                        var hadBadParameter = false;
                        foreach (var unityMethodParameter in unityMethod.Parameters)
                        {
                            var convertedType = ResolveTypeInNewAssemblies(context, unityMethodParameter.ParameterType, imports);
                            if (convertedType == null)
                            {
                                hadBadParameter = true;
                                LogSupport.Trace($"Method {unityMethod} has unsupported parameter type {unityMethodParameter.ParameterType}");
                                break;
                            }

                            newMethod.Parameters.Add(new ParameterDefinition(unityMethodParameter.Name, unityMethodParameter.Attributes, convertedType));
                        }

                        if (hadBadParameter)
                        {
                            methodsIgnored++;
                            continue;
                        }
                        
                        foreach (var unityMethodGenericParameter in unityMethod.GenericParameters)
                        {
                            var newParameter = new GenericParameter(unityMethodGenericParameter.Name, newMethod);
                            newParameter.Attributes = unityMethodGenericParameter.Attributes;
                            foreach (var genericParameterConstraint in unityMethodGenericParameter.Constraints)
                            {
                                if (genericParameterConstraint.ConstraintType.FullName == "System.ValueType") continue;
                                if (genericParameterConstraint.ConstraintType.Resolve().IsInterface) continue;

                                var newType = ResolveTypeInNewAssemblies(context, genericParameterConstraint.ConstraintType, imports);
                                if (newType != null)
                                    newParameter.Constraints.Add(new GenericParameterConstraint(newType));
                            }
                            
                            newMethod.GenericParameters.Add(newParameter);
                        }

                        if ((unityMethod.ImplAttributes & MethodImplAttributes.InternalCall) != 0)
                        {
                            var delegateType = UnstripGenerator.CreateDelegateTypeForICallMethod(unityMethod, newMethod, imports);
                            processedType.NewType.NestedTypes.Add(delegateType);
                            delegateType.DeclaringType = processedType.NewType;
                        
                            processedType.NewType.Methods.Add(newMethod);

                            var delegateField = UnstripGenerator.GenerateStaticCtorSuffix(processedType.NewType, delegateType, unityMethod, imports);
                            UnstripGenerator.GenerateInvokerMethodBody(newMethod, delegateField, delegateType, processedType, imports);
                        }
                        else
                        {
                            Pass81FillUnstrippedMethodBodies.PushMethod(unityMethod, newMethod, processedType, imports);
                            processedType.NewType.Methods.Add(newMethod);
                        }

                        if (unityMethod.IsGetter)
                            GetOrCreateProperty(unityMethod, newMethod).GetMethod = newMethod;
                        else if(unityMethod.IsSetter)
                            GetOrCreateProperty(unityMethod, newMethod).SetMethod = newMethod;

                        methodsUnstripped++;
                    }
                }
            }
            
            LogSupport.Info(""); // finish the progress line
            LogSupport.Info($"{methodsUnstripped} methods restored");
            LogSupport.Info($"{methodsIgnored} methods failed to restore");
        }

        private static PropertyDefinition GetOrCreateProperty(MethodDefinition unityMethod, MethodDefinition newMethod)
        {
            var unityProperty = unityMethod.DeclaringType.Properties.Single(it => it.SetMethod == unityMethod || it.GetMethod == unityMethod);
            var newProperty = newMethod.DeclaringType.Properties.SingleOrDefault(it => it.Name == unityProperty.Name && it.Parameters.Count == unityProperty.Parameters.Count);
            if (newProperty == null)
            {
                newProperty = new PropertyDefinition(unityProperty.Name, PropertyAttributes.None, unityMethod.IsGetter ? newMethod.ReturnType : newMethod.Parameters.Last().ParameterType);
                newMethod.DeclaringType.Properties.Add(newProperty);
            }

            return newProperty;
        } 

        internal static TypeReference? ResolveTypeInNewAssemblies(RewriteGlobalContext context, TypeReference unityType,
            AssemblyKnownImports imports)
        {
            var resolved = ResolveTypeInNewAssembliesRaw(context, unityType, imports);
            return resolved != null ? imports.Module.ImportReference(resolved) : null;
        }

        internal static TypeReference? ResolveTypeInNewAssembliesRaw(RewriteGlobalContext context, TypeReference unityType, AssemblyKnownImports imports)
        {
            if (unityType is ByReferenceType)
            {
                var resolvedElementType = ResolveTypeInNewAssemblies(context, unityType.GetElementType(), imports);
                return resolvedElementType == null ? null : new ByReferenceType(resolvedElementType);
            }

            if (unityType is GenericParameter)
                return null;

            if (unityType is ArrayType arrayType)
            {
                if (arrayType.Rank != 1) return null;
                var resolvedElementType = ResolveTypeInNewAssemblies(context, unityType.GetElementType(), imports);
                if (resolvedElementType == null) return null;
                if (resolvedElementType.FullName == "System.String")
                    return imports.Il2CppStringArray;
                var genericBase = resolvedElementType.IsValueType
                    ? imports.Il2CppStructArray
                    : imports.Il2CppReferenceArray;
                return new GenericInstanceType(genericBase) { GenericArguments = { resolvedElementType }};
            }

            if (unityType.DeclaringType != null)
            {
                var enclosingResolvedType = ResolveTypeInNewAssembliesRaw(context, unityType.DeclaringType, imports);
                if (enclosingResolvedType == null) return null;
                var resolvedNestedType = enclosingResolvedType.Resolve().NestedTypes.FirstOrDefault(it => it.Name == unityType.Name);
                if (resolvedNestedType == null) return null;
                return resolvedNestedType;
            }

            if (unityType is PointerType)
            {
                var resolvedElementType = ResolveTypeInNewAssemblies(context, unityType.GetElementType(), imports);
                return resolvedElementType == null ? null : new PointerType(resolvedElementType);
            }

            if (unityType is GenericInstanceType genericInstance)
            {
                var baseRef = ResolveTypeInNewAssemblies(context, genericInstance.ElementType, imports);
                if (baseRef == null) return null;
                var newInstance = new GenericInstanceType(baseRef);
                foreach (var unityGenericArgument in genericInstance.GenericArguments)
                {
                    var resolvedArgument = ResolveTypeInNewAssemblies(context, unityGenericArgument, imports);
                    if (resolvedArgument == null) return null;
                    newInstance.GenericArguments.Add(resolvedArgument);
                }

                return newInstance;
            }

            var targetAssemblyName = unityType.Scope.Name;
            if (targetAssemblyName.EndsWith(".dll"))
                targetAssemblyName = targetAssemblyName.Substring(0, targetAssemblyName.Length - 4);
            if ((targetAssemblyName == "mscorlib" || targetAssemblyName == "netstandard") && (unityType.IsValueType || unityType.FullName == "System.String" || unityType.FullName == "System.Void") && unityType.FullName != "System.RuntimeTypeHandle")
                return TargetTypeSystemHandler.Type.Module.GetType(unityType.FullName);

            if (targetAssemblyName == "UnityEngine")
                foreach (var assemblyRewriteContext in context.Assemblies)
                {
                    if (!assemblyRewriteContext.NewAssembly.Name.Name.StartsWith("UnityEngine")) continue;

                    var newTypeInAnyUnityAssembly =
                        assemblyRewriteContext.TryGetTypeByName(unityType.FullName)?.NewType;
                    if (newTypeInAnyUnityAssembly != null)
                        return newTypeInAnyUnityAssembly;
                }

            var targetAssembly = context.TryGetAssemblyByName(targetAssemblyName);
            var newType = targetAssembly?.TryGetTypeByName(unityType.FullName)?.NewType;
            
            return newType;
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass81FillUnstrippedMethodBodies.cs`:

```cs
using System.Collections.Generic;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Utils;
using Mono.Cecil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Passes
{
    public static class Pass81FillUnstrippedMethodBodies
    {
        private static readonly
            List<(MethodDefinition unityMethod, MethodDefinition newMethod, TypeRewriteContext processedType, AssemblyKnownImports imports)> StuffToProcess =
                new List<(MethodDefinition unityMethod, MethodDefinition newMethod, TypeRewriteContext processedType, AssemblyKnownImports imports)>();
        
        public static void DoPass(RewriteGlobalContext context)
        {
            int methodsSucceeded = 0;
            int methodsFailed = 0;
            
            foreach (var (unityMethod, newMethod, processedType, imports) in StuffToProcess)
            {
                var success = UnstripTranslator.TranslateMethod(unityMethod, newMethod, processedType, imports);
                if (success == false)
                {
                    methodsFailed++;
                    UnstripTranslator.ReplaceBodyWithException(newMethod, imports);
                }
                else
                    methodsSucceeded++;
            }
            
            LogSupport.Info(""); // finish progress line
            LogSupport.Info($"IL unstrip statistics: {methodsSucceeded} successful, {methodsFailed} failed");
        }

        public static void PushMethod(MethodDefinition unityMethod, MethodDefinition newMethod, TypeRewriteContext processedType, AssemblyKnownImports imports)
        {
            StuffToProcess.Add((unityMethod, newMethod, processedType, imports));
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass89GenerateForwarders.cs`:

```cs
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Passes
{
    public static class Pass89GenerateForwarders
    {
        public static void DoPass(RewriteGlobalContext context)
        {
            var targetAssembly = context.TryGetAssemblyByName("UnityEngine");
            if (targetAssembly == null)
            {
                LogSupport.Info("No UnityEngine.dll, will not generate forwarders");
                return;
            }

            var targetModule = targetAssembly.NewAssembly.MainModule;
            
            foreach (var assemblyRewriteContext in context.Assemblies)
            {
                if (!assemblyRewriteContext.NewAssembly.Name.Name.StartsWith("UnityEngine.")) continue;
                foreach (var mainModuleType in assemblyRewriteContext.NewAssembly.MainModule.Types)
                {
                    var importedType = targetModule.ImportReference(mainModuleType);
                    var exportedType = new ExportedType(mainModuleType.Namespace, mainModuleType.Name, importedType.Module, importedType.Scope) { Attributes = TypeAttributes.Forwarder };
                    targetModule.ExportedTypes.Add(exportedType);

                    AddNestedTypes(mainModuleType, exportedType, targetModule);
                }
            }
        }

        private static void AddNestedTypes(TypeDefinition mainModuleType, ExportedType importedType, ModuleDefinition targetModule)
        {
            foreach (var nested in mainModuleType.NestedTypes)
            {
                if((nested.Attributes & TypeAttributes.VisibilityMask) != TypeAttributes.NestedPublic) continue;
                
                var nestedImport = targetModule.ImportReference(nested);
                var nestedExport = new ExportedType(nestedImport.Namespace, nestedImport.Name, nestedImport.Module, nestedImport.Scope) { Attributes = TypeAttributes.Forwarder };
                nestedExport.DeclaringType = importedType; 
                targetModule.ExportedTypes.Add(nestedExport);
                
                AddNestedTypes(nested, nestedExport, targetModule);
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass89GenerateMethodXrefCache.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Text;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using Mono.Cecil;
using UnhollowerBaseLib.Attributes;
using UnhollowerBaseLib.Maps;
using UnhollowerRuntimeLib.XrefScans;

namespace AssemblyUnhollower.Passes
{
    public static class Pass89GenerateMethodXrefCache
    {
        public static void DoPass(RewriteGlobalContext context, UnhollowerOptions options)
        {
            var data = new List<MethodXrefScanCache.MethodData>();
            var existingAttributesPerAddress = new Dictionary<long, CachedScanResultsAttribute>();

            if (options.NoXrefCache)
                goto skipDataGather;
            
            foreach (var assemblyRewriteContext in context.Assemblies)
            {
                if (options.AdditionalAssembliesBlacklist.Contains(assemblyRewriteContext.NewAssembly.Name.Name))
                    continue;
                
                var imports = assemblyRewriteContext.Imports;

                foreach (var typeRewriteContext in assemblyRewriteContext.Types)
                {
                    foreach (var methodRewriteContext in typeRewriteContext.Methods)
                    {
                        var address = methodRewriteContext.Rva;

                        if (existingAttributesPerAddress.TryGetValue(address, out var attribute))
                        {
                            methodRewriteContext.NewMethod.CustomAttributes.Add(
                                new CustomAttribute(imports.CachedScanResultsAttributeCtor)
                                {
                                    Fields =
                                    {
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.RefRangeStart),
                                            new CustomAttributeArgument(imports.Int, attribute.RefRangeStart)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.RefRangeEnd),
                                            new CustomAttributeArgument(imports.Int, attribute.RefRangeEnd)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.XrefRangeStart),
                                            new CustomAttributeArgument(imports.Int, attribute.RefRangeStart)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.XrefRangeEnd),
                                            new CustomAttributeArgument(imports.Int, attribute.RefRangeEnd)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.MetadataInitTokenRva),
                                            new CustomAttributeArgument(imports.Int, attribute.MetadataInitTokenRva)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.MetadataInitFlagRva),
                                            new CustomAttributeArgument(imports.Int, attribute.MetadataInitFlagRva)),
                                    }
                                });
                            continue;
                        }

                        var xrefStart = data.Count;
                        
                        foreach (var xrefScanResult in methodRewriteContext.XrefScanResults)
                            data.Add(MethodXrefScanCache.MethodData.FromXrefInstance(xrefScanResult));

                        var xrefEnd = data.Count;

                        var refStart = 0;
                        var refEnd = 0;
                        
                        if (address != 0)
                        {
                            if (Pass16ScanMethodRefs.MapOfCallers.TryGetValue(address, out var callerMap))
                            {
                                refStart = data.Count;
                                foreach (var xrefInstance in callerMap)
                                    data.Add(MethodXrefScanCache.MethodData.FromXrefInstance(xrefInstance));

                                refEnd = data.Count;
                            }
                        }

                        if (xrefEnd != xrefStart || refStart != refEnd)
                        {
                            methodRewriteContext.NewMethod.CustomAttributes.Add(
                                new CustomAttribute(imports.CachedScanResultsAttributeCtor)
                                {
                                    Fields =
                                    {
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.RefRangeStart),
                                            new CustomAttributeArgument(imports.Int, refStart)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.RefRangeEnd),
                                            new CustomAttributeArgument(imports.Int, refEnd)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.XrefRangeStart),
                                            new CustomAttributeArgument(imports.Int, xrefStart)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.XrefRangeEnd),
                                            new CustomAttributeArgument(imports.Int, xrefEnd)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.MetadataInitTokenRva),
                                            new CustomAttributeArgument(imports.Long, methodRewriteContext.MetadataInitTokenRva)),
                                        new CustomAttributeNamedArgument(
                                            nameof(CachedScanResultsAttribute.MetadataInitFlagRva),
                                            new CustomAttributeArgument(imports.Long, methodRewriteContext.MetadataInitFlagRva)),
                                    }
                                });

                            existingAttributesPerAddress[address] = new CachedScanResultsAttribute
                            {
                                RefRangeStart = refStart,
                                RefRangeEnd = refEnd,
                                XrefRangeStart = xrefStart,
                                XrefRangeEnd = xrefEnd,
                                MetadataInitFlagRva = methodRewriteContext.MetadataInitFlagRva,
                                MetadataInitTokenRva = methodRewriteContext.MetadataInitTokenRva
                            };
                        }
                    }
                }
            }
            
            skipDataGather:
            
            var header = new MethodXrefScanCache.FileHeader
            {
                Magic = MethodXrefScanCache.Magic,
                Version = MethodXrefScanCache.Version,
                InitMethodMetadataRva = XrefScanMetadataGenerationUtil.MetadataInitForMethodRva
            };
            
            using var writer = new BinaryWriter(new FileStream(Path.Combine(options.OutputDir, MethodXrefScanCache.FileName), FileMode.Create, FileAccess.Write), Encoding.UTF8, false);
            writer.Write(header);

            foreach (var valueTuple in data) 
                writer.Write(valueTuple);

            if (options.Verbose)
            {
                using var plainTextWriter = new StreamWriter(Path.Combine(options.OutputDir, MethodXrefScanCache.FileName + ".txt"));
                for (var i = 0; i < data.Count; i++)
                {
                    plainTextWriter.WriteLine($"{i}\t{data[i].Type}\t{data[i].Address}\t{data[i].FoundAt}");
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass90WriteToDisk.cs`:

```cs
using System.Linq;
using System.Threading.Tasks;
using AssemblyUnhollower.Contexts;

namespace AssemblyUnhollower.Passes
{
    public static class Pass90WriteToDisk
    {
        public static void DoPass(RewriteGlobalContext context, UnhollowerOptions options)
        {
            var tasks = context.Assemblies.Where(it => !options.AdditionalAssembliesBlacklist.Contains(it.NewAssembly.Name.Name)).Select(assemblyContext => Task.Run(() => {
                assemblyContext.NewAssembly.Write(options.OutputDir + "/" + assemblyContext.NewAssembly.Name.Name + ".dll");
            })).ToArray();

            Task.WaitAll(tasks);
        }
    }
}
```

`AssemblyUnhollower/Passes/Pass91GenerateMethodPointerMap.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Text;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;
using UnhollowerBaseLib.Maps;

namespace AssemblyUnhollower.Passes
{
    public static class Pass91GenerateMethodPointerMap
    {
        public static void DoPass(RewriteGlobalContext context, UnhollowerOptions options)
        {
            var data = new List<(long, int, int)>();
            var assemblyList = new List<string>();
            
            foreach (var assemblyRewriteContext in context.Assemblies)
            {
                if (options.AdditionalAssembliesBlacklist.Contains(assemblyRewriteContext.NewAssembly.Name.Name))
                    continue;
                
                assemblyList.Add(assemblyRewriteContext.NewAssembly.FullName);
                
                foreach (var typeRewriteContext in assemblyRewriteContext.Types)
                {
                    foreach (var methodRewriteContext in typeRewriteContext.Methods)
                    {
                        var address = methodRewriteContext.Rva;
                        
                        if (address != 0)
                            data.Add((address, methodRewriteContext.NewMethod.MetadataToken.ToInt32(), assemblyList.Count - 1));
                    }
                }
            }
            
            data.Sort((a, b) => a.Item1.CompareTo(b.Item1));

            var header = new MethodAddressToTokenMapFileHeader
            {
                Magic = MethodAddressToTokenMap.Magic,
                Version = MethodAddressToTokenMap.Version,
                NumMethods = data.Count,
                NumAssemblies = assemblyList.Count
            };
            
            using var writer = new BinaryWriter(new FileStream(Path.Combine(options.OutputDir, MethodAddressToTokenMap.FileName), FileMode.Create, FileAccess.Write), Encoding.UTF8, false);
            writer.Write(header);
            
            foreach (var s in assemblyList) 
                writer.Write(s);

            header.DataOffset = (int) writer.BaseStream.Position;
            
            foreach (var valueTuple in data) 
                writer.Write(valueTuple.Item1);

            foreach (var valueTuple in data)
            {
                writer.Write(valueTuple.Item2);
                writer.Write(valueTuple.Item3);
            }

            writer.BaseStream.Position = 0;
            writer.Write(header);

            if (options.Verbose)
            {
                using var plainTextWriter = new StreamWriter(Path.Combine(options.OutputDir, MethodAddressToTokenMap.FileName + ".txt"));
                for (var i = 0; i < data.Count; i++)
                {
                    plainTextWriter.WriteLine($"{i}\t{data[i].Item1}\t{data[i].Item2}\t{data[i].Item3}");
                }
            }
        }
    }
}
```

`AssemblyUnhollower/Program.cs`:

```cs
using System;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.MetadataAccess;
using AssemblyUnhollower.Passes;
using UnhollowerBaseLib;
using UnhollowerRuntimeLib;
using Decoder = Iced.Intel.Decoder;

namespace AssemblyUnhollower
{
    public class Program
    {
        public static void AnalyzeDeobfuscationParams(UnhollowerOptions options)
        {
            RewriteGlobalContext rewriteContext;
            IIl2CppMetadataAccess inputAssemblies;
            using (new TimingCookie("Reading assemblies"))
                inputAssemblies = new CecilMetadataAccess(Directory.EnumerateFiles(options.SourceDir, "*.dll"));
            
            using(new TimingCookie("Creating assembly contexts"))
                rewriteContext = new RewriteGlobalContext(options, inputAssemblies, NullMetadataAccess.Instance, NullMetadataAccess.Instance);

            for (var chars = 1; chars <= 3; chars++)
            for (var uniq = 3; uniq <= 15; uniq++)
            {
                options.TypeDeobfuscationCharsPerUniquifier = chars;
                options.TypeDeobfuscationMaxUniquifiers = uniq;
                
                rewriteContext.RenamedTypes.Clear();
                rewriteContext.RenameGroups.Clear();

                Pass05CreateRenameGroups.DoPass(rewriteContext);

                var uniqueTypes = rewriteContext.RenameGroups.Values.Count(it => it.Count == 1);
                var nonUniqueTypes = rewriteContext.RenameGroups.Values.Count(it => it.Count > 1);
                
                Console.WriteLine($"Chars=\t{chars}\tMaxU=\t{uniq}\tUniq=\t{uniqueTypes}\tNonUniq=\t{nonUniqueTypes}");
            }
        }

        private const string ParamInputDir = "--input=";
        private const string ParamOutputDir = "--output=";
        private const string ParamMscorlibPath = "--mscorlib=";
        private const string ParamSystemLibsPath = "--system-libs=";
        private const string ParamUnityDir = "--unity=";
        private const string ParamGameAssemblyPath = "--gameassembly=";
        private const string ParamUniqChars = "--deobf-uniq-chars=";
        private const string ParamUniqMax = "--deobf-uniq-max=";
        private const string ParamAnalyze = "--deobf-analyze";
        private const string ParamGenerateDeobMap = "--deobf-generate";
        private const string ParamGenerateDeobMapAssembly = "--deobf-generate-asm=";
        private const string ParamGenerateDeobMapNew = "--deobf-generate-new=";
        private const string ParamBlacklistAssembly = "--blacklist-assembly=";
        private const string ParamAddPrefix = "--add-prefix-to=";
        private const string ParamNoXrefCache = "--no-xref-cache";
        private const string ParamNoCopyUnhollowerLibs = "--no-copy-unhollower-libs";
        private const string ParamObfRegex = "--obf-regex=";
        private const string ParamRenameMap = "--rename-map=";
        private const string ParamPassthroughNames = "--passthrough-names";
        private const string ParamVerbose = "--verbose";
        private const string ParamHelp = "--help";
        private const string ParamHelpShort = "-h";
        private const string ParamHelpShortSlash = "/?";

        private static void PrintUsage()
        {
            Console.WriteLine("Usage: AssemblyUnhollower [parameters]");
            Console.WriteLine("Possible parameters:");
            Console.WriteLine($"\t{ParamHelp}, {ParamHelpShort}, {ParamHelpShortSlash} - Optional. Show this help");
            Console.WriteLine($"\t{ParamVerbose} - Optional. Produce more console output");
            Console.WriteLine($"\t{ParamInputDir}<directory path> - Required. Directory with Il2CppDumper's dummy assemblies");
            Console.WriteLine($"\t{ParamOutputDir}<directory path> - Required. Directory to put results into");
            Console.WriteLine($"\t{ParamMscorlibPath}<file path> - Deprecated. mscorlib.dll of target runtime system (typically loader's)");
            Console.WriteLine($"\t{ParamSystemLibsPath}<file path> - Required. Directory with system libraries of target runtime system (typically loader's)");
            Console.WriteLine($"\t{ParamUnityDir}<directory path> - Optional. Directory with original Unity assemblies for unstripping");
            Console.WriteLine($"\t{ParamGameAssemblyPath}<file path> - Optional. Path to GameAssembly.dll. Used for certain analyses");
            Console.WriteLine($"\t{ParamUniqChars}<number> - Optional. How many characters per unique token to use during deobfuscation");
            Console.WriteLine($"\t{ParamUniqMax}<number> - Optional. How many maximum unique tokens per type are allowed during deobfuscation");
            Console.WriteLine($"\t{ParamAnalyze} - Optional. Analyze deobfuscation performance with different parameter values. Will not generate assemblies.");
            Console.WriteLine($"\t{ParamBlacklistAssembly}<assembly name> - Optional. Don't write specified assembly to output. Can be used multiple times");
            Console.WriteLine($"\t{ParamAddPrefix}<assembly name/namespace> - Optional. Assemblies and namespaces starting with these will get an Il2Cpp prefix in generated assemblies. Can be used multiple times.");
            Console.WriteLine($"\t{ParamNoXrefCache} - Optional. Don't generate xref scanning cache. All scanning will be done at runtime.");
            Console.WriteLine($"\t{ParamNoCopyUnhollowerLibs} - Optional. Don't copy unhollower libraries to output directory");
            Console.WriteLine($"\t{ParamObfRegex}<regex> - Optional. Specifies a regex for obfuscated names. All types and members matching will be renamed");
            Console.WriteLine($"\t{ParamRenameMap}<file path> - Optional. Specifies a file specifying rename map for obfuscated types and members");
            Console.WriteLine($"\t{ParamPassthroughNames} - Optional. If specified, names will be copied from input assemblies as-is without renaming or deobfuscation");
            Console.WriteLine("Deobfuscation map generation mode:");
            Console.WriteLine($"\t{ParamGenerateDeobMap} - Generate a deobfuscation map for input files. Will not generate assemblies.");
            Console.WriteLine($"\t{ParamGenerateDeobMapAssembly}<assembly name> - Optional. Include this assembly for deobfuscation map generation. If none are specified, all assemblies will be included.");
            Console.WriteLine($"\t{ParamGenerateDeobMapNew}<directory path> - Required. Specifies the directory with new (obfuscated) assemblies. The --input parameter specifies old (unobfuscated) assemblies.");
        }

        public static void Main(string[] args)
        {
            LogSupport.InstallConsoleHandlers();
            
            var options = new UnhollowerOptions();
            var analyze = false;
            var generateMap = false;
            
            foreach (var s in args)
            {
                if (s == ParamAnalyze) 
                    analyze = true;
                else if (s == ParamGenerateDeobMap)
                    generateMap = true;
                else if (s == ParamHelp || s == ParamHelpShort || s == ParamHelpShortSlash)
                {
                    PrintUsage();
                    return;
                } else if (s == ParamVerbose)
                {
                    LogSupport.TraceHandler += Console.WriteLine;
                    options.Verbose = true;
                } else if (s == ParamNoXrefCache)
                    options.NoXrefCache = true;
                else if (s == ParamNoCopyUnhollowerLibs)
                    options.NoCopyUnhollowerLibs = true;
                else if (s.StartsWith(ParamInputDir))
                    options.SourceDir = s.Substring(ParamInputDir.Length);
                else if (s.StartsWith(ParamOutputDir))
                    options.OutputDir = s.Substring(ParamOutputDir.Length);
                else if (s.StartsWith(ParamMscorlibPath))
                    options.MscorlibPath = s.Substring(ParamMscorlibPath.Length);
                else if (s.StartsWith(ParamSystemLibsPath))
                    options.SystemLibrariesPath = s.Substring(ParamSystemLibsPath.Length);
                else if (s.StartsWith(ParamUnityDir))
                    options.UnityBaseLibsDir = s.Substring(ParamUnityDir.Length);
                else if (s.StartsWith(ParamGameAssemblyPath))
                    options.GameAssemblyPath = s.Substring(ParamGameAssemblyPath.Length);
                else if(s.StartsWith(ParamUniqChars))
                    options.TypeDeobfuscationCharsPerUniquifier = Int32.Parse(s.Substring(ParamUniqChars.Length));
                else if(s.StartsWith(ParamUniqMax))
                    options.TypeDeobfuscationMaxUniquifiers = Int32.Parse(s.Substring(ParamUniqMax.Length));
                else if(s.StartsWith(ParamBlacklistAssembly))
                    options.AdditionalAssembliesBlacklist.Add(s.Substring(ParamBlacklistAssembly.Length));
                else if(s.StartsWith(ParamAddPrefix))
                    options.NamespacesAndAssembliesToPrefix.Add(s.Substring(ParamAddPrefix.Length));
                else if (s.StartsWith(ParamObfRegex))
                    options.ObfuscatedNamesRegex = new Regex(s.Substring(ParamObfRegex.Length), RegexOptions.Compiled);
                else if(s.StartsWith(ParamRenameMap))
                    ReadRenameMap(s.Substring(ParamRenameMap.Length), options);
                else if(s.StartsWith(ParamGenerateDeobMapAssembly))
                    options.DeobfuscationGenerationAssemblies.Add(s.Substring(ParamGenerateDeobMapAssembly.Length));
                else if (s.StartsWith(ParamGenerateDeobMapNew))
                    options.DeobfuscationNewAssembliesPath = s.Substring(ParamGenerateDeobMapNew.Length);
                else
                {
                    LogSupport.Error($"Unrecognized option {s}; use -h for help");
                    return;
                }
            }

            if (analyze && generateMap)
            {
                LogSupport.Error($"Can't use {ParamAnalyze} and {ParamGenerateDeobMap} at the same time");
                return;
            }
            
            if (analyze)
                AnalyzeDeobfuscationParams(options);
            else if (generateMap)
                DeobfuscationMapGenerator.GenerateDeobfuscationMap(options);
            else
                Main(options);
        }
        
        public static void Main(UnhollowerOptions options)
        {
            if (string.IsNullOrEmpty(options.SourceDir))
            {
                Console.WriteLine("No input dir specified; use -h for help");
                return;
            }
            
            if (string.IsNullOrEmpty(options.OutputDir))
            {
                Console.WriteLine("No target dir specified; use -h for help");
                return;
            }
            if (string.IsNullOrEmpty(options.MscorlibPath) && string.IsNullOrEmpty(options.SystemLibrariesPath))
            {
                Console.WriteLine("No mscorlib or system libraries specified; use -h for help");
                return;
            }

            if (!Directory.Exists(options.OutputDir))
                Directory.CreateDirectory(options.OutputDir);

            RewriteGlobalContext rewriteContext;
            IIl2CppMetadataAccess gameAssemblies;
            IMetadataAccess systemAssemblies;
            IMetadataAccess unityAssemblies;

            using (new TimingCookie("Reading assemblies"))
                gameAssemblies = new CecilMetadataAccess(Directory.EnumerateFiles(options.SourceDir, "*.dll"));

            using (new TimingCookie("Reading system assemblies"))
            {
                if (!string.IsNullOrEmpty(options.SystemLibrariesPath)) 
                    systemAssemblies = new CecilMetadataAccess(Directory.EnumerateFiles(options.SystemLibrariesPath, "*.dll")
                        .Where(it => Path.GetFileName(it).StartsWith("System.") || Path.GetFileName(it) == "mscorlib.dll" || Path.GetFileName(it) == "netstandard.dll"));
                else
                    systemAssemblies = new CecilMetadataAccess(new[] {options.MscorlibPath});

            }

            if (!string.IsNullOrEmpty(options.UnityBaseLibsDir))
            {
                using (new TimingCookie("Reading unity assemblies"))
                    unityAssemblies = new CecilMetadataAccess(Directory.EnumerateFiles(options.UnityBaseLibsDir, "*.dll"));
            }
            else
                unityAssemblies = NullMetadataAccess.Instance;

            using(new TimingCookie("Creating rewrite assemblies"))
                rewriteContext = new RewriteGlobalContext(options, gameAssemblies, systemAssemblies, unityAssemblies);

            using(new TimingCookie("Computing renames"))
                Pass05CreateRenameGroups.DoPass(rewriteContext);
            using(new TimingCookie("Creating typedefs"))
                Pass10CreateTypedefs.DoPass(rewriteContext);
            using(new TimingCookie("Computing struct blittability"))
                Pass11ComputeTypeSpecifics.DoPass(rewriteContext);
            using(new TimingCookie("Filling typedefs"))
                Pass12FillTypedefs.DoPass(rewriteContext);
            using(new TimingCookie("Filling generic constraints"))
                Pass13FillGenericConstraints.DoPass(rewriteContext);
            using(new TimingCookie("Creating members"))
                Pass15GenerateMemberContexts.DoPass(rewriteContext);
            using(new TimingCookie("Scanning method cross-references"))
                Pass16ScanMethodRefs.DoPass(rewriteContext, options);
            using(new TimingCookie("Finalizing method declarations"))
                Pass18FinalizeMethodContexts.DoPass(rewriteContext);
            LogSupport.Info($"{Pass18FinalizeMethodContexts.TotalPotentiallyDeadMethods} total potentially dead methods");
            using(new TimingCookie("Filling method parameters"))
                Pass19CopyMethodParameters.DoPass(rewriteContext);
            
            using(new TimingCookie("Creating static constructors"))
                Pass20GenerateStaticConstructors.DoPass(rewriteContext);
            using(new TimingCookie("Creating value type fields"))
                Pass21GenerateValueTypeFields.DoPass(rewriteContext);
            using(new TimingCookie("Creating enums"))
                Pass22GenerateEnums.DoPass(rewriteContext);
            using(new TimingCookie("Creating IntPtr constructors"))
                Pass23GeneratePointerConstructors.DoPass(rewriteContext);
            using(new TimingCookie("Creating type getters"))
                Pass24GenerateTypeStaticGetters.DoPass(rewriteContext);
            using(new TimingCookie("Creating non-blittable struct constructors"))
                Pass25GenerateNonBlittableValueTypeDefaultCtors.DoPass(rewriteContext);
            
            using(new TimingCookie("Creating generic method static constructors"))
                Pass30GenerateGenericMethodStoreConstructors.DoPass(rewriteContext);
            using(new TimingCookie("Creating field accessors"))
                Pass40GenerateFieldAccessors.DoPass(rewriteContext);
            using(new TimingCookie("Filling methods"))
                Pass50GenerateMethods.DoPass(rewriteContext);
            using(new TimingCookie("Generating implicit conversions"))
                Pass60AddImplicitConversions.DoPass(rewriteContext);
            using(new TimingCookie("Creating properties"))
                Pass70GenerateProperties.DoPass(rewriteContext);

            if (options.UnityBaseLibsDir != null)
            {
                using (new TimingCookie("Unstripping types"))
                    Pass79UnstripTypes.DoPass(rewriteContext);
                using (new TimingCookie("Unstripping fields"))
                    Pass80UnstripFields.DoPass(rewriteContext);
                using (new TimingCookie("Unstripping methods"))
                    Pass80UnstripMethods.DoPass(rewriteContext);
                using (new TimingCookie("Unstripping method bodies"))
                    Pass81FillUnstrippedMethodBodies.DoPass(rewriteContext);
            }
            else
                LogSupport.Warning("Not performing unstripping as unity libs are not specified");
            
            using(new TimingCookie("Generating forwarded types"))
                Pass89GenerateForwarders.DoPass(rewriteContext);
            
            using(new TimingCookie("Writing xref cache"))
                Pass89GenerateMethodXrefCache.DoPass(rewriteContext, options);
            
            using(new TimingCookie("Writing assemblies"))
                Pass90WriteToDisk.DoPass(rewriteContext, options);
            
            using(new TimingCookie("Writing method pointer map"))
                Pass91GenerateMethodPointerMap.DoPass(rewriteContext, options);

            if (!options.NoCopyUnhollowerLibs)
            {
                File.Copy(typeof(IL2CPP).Assembly.Location, Path.Combine(options.OutputDir, typeof(IL2CPP).Assembly.GetName().Name + ".dll"), true);
                File.Copy(typeof(RuntimeLibMarker).Assembly.Location, Path.Combine(options.OutputDir, typeof(RuntimeLibMarker).Assembly.GetName().Name + ".dll"), true);
                File.Copy(typeof(Decoder).Assembly.Location, Path.Combine(options.OutputDir, typeof(Decoder).Assembly.GetName().Name + ".dll"), true);
            }
            
            LogSupport.Info("Done!");

            rewriteContext.Dispose();
        }

        /// <summary>
        /// Reads a rename map from the specified name into the specified instance of options
        /// </summary>
        public static void ReadRenameMap(string fileName, UnhollowerOptions options)
        {
            using var fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read);
            ReadRenameMap(fileStream, fileName.EndsWith(".gz"), options);
        }

        /// <summary>
        /// Reads a rename map from the specified name into the specified instance of options.
        /// The stream is not closed by this method.
        /// </summary>
        public static void ReadRenameMap(Stream fileStream, bool isGzip, UnhollowerOptions options)
        {
            if (isGzip)
            {
                using var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress, true);
                ReadRenameMap(gzipStream, false, options);
                return;
            }

            using var reader = new StreamReader(fileStream, Encoding.UTF8, false, 65536, true);
            while (!reader.EndOfStream)
            {
                var line = reader.ReadLine();
                if(string.IsNullOrEmpty(line) || line.StartsWith("#")) continue;
                var split = line.Split(';');
                if(split.Length < 2) continue;
                options.RenameMap[split[0]] = split[1];
            }
        }
    }
}
```

`AssemblyUnhollower/TargetTypeSystemHandler.cs`:

```cs
using System;
using AssemblyUnhollower.MetadataAccess;
using Mono.Cecil;

namespace AssemblyUnhollower
{
    public static class TargetTypeSystemHandler
    {
        public static TypeReference Void { get; private set; }
        public static TypeReference IntPtr { get; private set; }
        public static TypeDefinition String { get; private set; }
        public static TypeDefinition Int { get; private set; }
        public static TypeDefinition Long { get; private set; }
        public static TypeDefinition Type { get; private set; }
        public static TypeReference Object { get; private set; }
        public static TypeReference Enum { get; private set; }
        public static TypeReference ValueType { get; private set; }
        public static TypeReference Delegate { get; private set; }
        public static TypeReference MulticastDelegate { get; private set; }
        public static TypeReference DefaultMemberAttribute { get; private set; }
        public static TypeReference NotSupportedException { get; private set; }
        public static TypeReference FlagsAttribute { get; private set; }
        public static TypeReference ObsoleteAttribute { get; private set; }

        public static void Init(IMetadataAccess systemLibraries)
        {
            var mscorlib = systemLibraries.GetAssemblyBySimpleName("mscorlib") ??
                           systemLibraries.GetAssemblyBySimpleName("netstandard") ?? throw new ArgumentException("System libraries metadata access doesn't contain mscorlib or netstandard");
            
            Void = mscorlib.MainModule.TypeSystem.Void;
            IntPtr = mscorlib.MainModule.TypeSystem.IntPtr;
            String = mscorlib.MainModule.GetType("System.String");
            Int = mscorlib.MainModule.GetType("System.Int32");
            Long = mscorlib.MainModule.GetType("System.Int64");
            Type = mscorlib.MainModule.GetType("System.Type");
            Object = mscorlib.MainModule.TypeSystem.Object;
            Enum = mscorlib.MainModule.GetType("System.Enum");
            ValueType = mscorlib.MainModule.GetType("System.ValueType");
            Delegate = mscorlib.MainModule.GetType("System.Delegate");
            MulticastDelegate = mscorlib.MainModule.GetType("System.MulticastDelegate");
            DefaultMemberAttribute = mscorlib.MainModule.GetType("System.Reflection.DefaultMemberAttribute");
            NotSupportedException = mscorlib.MainModule.GetType("System.NotSupportedException");
            FlagsAttribute = mscorlib.MainModule.GetType("System.FlagsAttribute");
            ObsoleteAttribute = mscorlib.MainModule.GetType("System.ObsoleteAttribute");
        }
    }
}
```

`AssemblyUnhollower/TimingCookie.cs`:

```cs
using System;
using System.Diagnostics;
using UnhollowerBaseLib;

namespace AssemblyUnhollower
{
    internal readonly struct TimingCookie : IDisposable
    {
        private readonly Stopwatch myStopwatch;
        public TimingCookie(string message)
        {
            LogSupport.Info(message + "... ");
            myStopwatch = Stopwatch.StartNew();
        }

        public void Dispose()
        {
            LogSupport.Info($"Done in {myStopwatch.Elapsed}");
        }
    }
}
```

`AssemblyUnhollower/UnhollowerOptions.cs`:

```cs
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace AssemblyUnhollower
{
    public class UnhollowerOptions
    {
        public string SourceDir { get; set; }
        public string OutputDir { get; set; }
        public string MscorlibPath { get; set; }
        public string SystemLibrariesPath { get; set; }
        
        public string? UnityBaseLibsDir { get; set; }
        public List<string> AdditionalAssembliesBlacklist { get; } = new List<string>();
        public int TypeDeobfuscationCharsPerUniquifier { get; set; } = 2;
        public int TypeDeobfuscationMaxUniquifiers { get; set; } = 10;
        public string GameAssemblyPath { get; set; }
        public bool Verbose { get; set; }
        public bool NoXrefCache { get; set; }
        public bool NoCopyUnhollowerLibs { get; set; }
        public Regex? ObfuscatedNamesRegex { get; set; }
        public Dictionary<string, string> RenameMap { get; } = new Dictionary<string, string>();
        public bool PassthroughNames { get; set; }
        public HashSet<string> NamespacesAndAssembliesToPrefix { get; } = new() {"System", "mscorlib", "Microsoft", "Mono", "I18N"};
        
        public List<string> DeobfuscationGenerationAssemblies { get; } = new List<string>();
        public string DeobfuscationNewAssembliesPath { get; set; }
        
    }
}
```

`AssemblyUnhollower/UtilGenerator.cs`:

```cs
using System;
using System.Linq;
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower
{
    public static class UtilGenerator
    {
        private static readonly OpCode[] I4Constants = {
            OpCodes.Ldc_I4_M1,
            OpCodes.Ldc_I4_0,
            OpCodes.Ldc_I4_1,
            OpCodes.Ldc_I4_2,
            OpCodes.Ldc_I4_3,
            OpCodes.Ldc_I4_4,
            OpCodes.Ldc_I4_5,
            OpCodes.Ldc_I4_6,
            OpCodes.Ldc_I4_7,
            OpCodes.Ldc_I4_8,
        };

        public static void EmitLdcI4(this ILProcessor body, int constant)
        {
            if(constant >= -1 && constant <= 8)
                body.Emit(I4Constants[constant + 1]);
            else if(constant >= byte.MinValue && constant <= byte.MaxValue)
                body.Emit(OpCodes.Ldc_I4_S, (sbyte) constant);
            else
                body.Emit(OpCodes.Ldc_I4, constant);
        }

        public static void EmitObjectStore(this ILProcessor body, TypeReference originalType, TypeReference newType, TypeRewriteContext enclosingType, int argumentIndex)
        {
            // input stack: object address, target address
            // output: nothing
            if (originalType is GenericParameter)
            {
                EmitObjectStoreGeneric(body, originalType, newType, enclosingType, argumentIndex);
                return;
            }
            
            var imports = enclosingType.AssemblyContext.Imports;
            
            if (originalType.FullName == "System.String")
            {
                body.Emit(OpCodes.Ldarg, argumentIndex);
                body.Emit(OpCodes.Call, imports.StringToNative);
                body.Emit(OpCodes.Call, imports.WriteFieldWBarrier);
            } else if (originalType.IsValueType)
            {
                var typeSpecifics =  enclosingType.AssemblyContext.GlobalContext.JudgeSpecificsByOriginalType(originalType);
                if (typeSpecifics == TypeRewriteContext.TypeSpecifics.BlittableStruct)
                {
                    body.Emit(OpCodes.Ldarg, argumentIndex);
                    body.Emit(OpCodes.Stobj, newType);
                    body.Emit(OpCodes.Pop);
                }
                else
                {
                    body.Emit(OpCodes.Ldarg, argumentIndex);
                    body.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointer);
                    body.Emit(OpCodes.Call, imports.ObjectUnbox);
                    var classPointerTypeRef = new GenericInstanceType(imports.Il2CppClassPointerStore) { GenericArguments = { newType }};
                    var classPointerFieldRef = new FieldReference(nameof(Il2CppClassPointerStore<int>.NativeClassPtr), imports.IntPtr, classPointerTypeRef);
                    body.Emit(OpCodes.Ldsfld, enclosingType.NewType.Module.ImportReference(classPointerFieldRef));
                    body.Emit(OpCodes.Ldc_I4_0);
                    body.Emit(OpCodes.Conv_U);
                    body.Emit(OpCodes.Call, imports.ValueSizeGet);
                    body.Emit(OpCodes.Cpblk);
                    body.Emit(OpCodes.Pop);
                }
            } else {
                body.Emit(OpCodes.Ldarg, argumentIndex);
                body.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointer);
                body.Emit(OpCodes.Call, imports.WriteFieldWBarrier);
            }
        }

        private static void EmitObjectStoreGeneric(ILProcessor body, TypeReference originalType, TypeReference newType, TypeRewriteContext enclosingType, int argumentIndex)
        {
            // input stack: object address, target address
            // output: nothing
            
            var imports = enclosingType.AssemblyContext.Imports;
            
            body.Emit(OpCodes.Ldtoken, newType);
            body.Emit(OpCodes.Call, enclosingType.NewType.Module.ImportReference(imports.Type.Methods.Single(it => it.Name == nameof(Type.GetTypeFromHandle))));
            body.Emit(OpCodes.Dup);
            body.Emit(OpCodes.Callvirt, enclosingType.NewType.Module.ImportReference(imports.Type.Methods.Single(it => it.Name == typeof(Type).GetProperty(nameof(Type.IsValueType))!.GetMethod!.Name)));

            var finalNop = body.Create(OpCodes.Nop);
            var stringNop = body.Create(OpCodes.Nop);
            var valueTypeNop = body.Create(OpCodes.Nop);
            var storePointerNop = body.Create(OpCodes.Nop);

            body.Emit(OpCodes.Brtrue, valueTypeNop);
            
            body.Emit(OpCodes.Callvirt, enclosingType.NewType.Module.ImportReference(imports.Type.Methods.Single(it => it.Name == typeof(Type).GetProperty(nameof(Type.FullName))!.GetMethod!.Name)));
            body.Emit(OpCodes.Ldstr, "System.String");
            body.Emit(OpCodes.Call, enclosingType.NewType.Module.ImportReference(TargetTypeSystemHandler.String.Methods.Single(it => it.Name == nameof(String.Equals) && it.IsStatic && it.Parameters.Count == 2)));
            body.Emit(OpCodes.Brtrue_S, stringNop);
            
            body.Emit(OpCodes.Ldarg, argumentIndex);
            body.Emit(OpCodes.Box, newType);
            body.Emit(OpCodes.Isinst, imports.Il2CppObjectBase);
            body.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointer);
            body.Emit(OpCodes.Dup);
            body.Emit(OpCodes.Brfalse_S, storePointerNop);
            
            body.Emit(OpCodes.Dup);
            body.Emit(OpCodes.Call, imports.ObjectGetClass);
            body.Emit(OpCodes.Call, imports.ClassIsValueType);
            body.Emit(OpCodes.Brfalse_S, storePointerNop);
            
            body.Emit(OpCodes.Dup);
            var tempLocal = new VariableDefinition(imports.IntPtr);
            body.Body.Variables.Add(tempLocal);
            body.Emit(OpCodes.Stloc, tempLocal);
            body.Emit(OpCodes.Call, imports.ObjectUnbox);
            body.Emit(OpCodes.Ldloc, tempLocal);
            body.Emit(OpCodes.Call, imports.ObjectGetClass);
            body.Emit(OpCodes.Ldc_I4_0);
            body.Emit(OpCodes.Conv_U);
            body.Emit(OpCodes.Call, imports.ValueSizeGet);
            body.Emit(OpCodes.Cpblk);
            body.Emit(OpCodes.Pop);
            body.Emit(OpCodes.Br_S, finalNop);

            body.Append(storePointerNop);
            body.Emit(OpCodes.Call, imports.WriteFieldWBarrier);
            body.Emit(OpCodes.Br_S, finalNop);
            
            body.Append(stringNop);
            body.Emit(OpCodes.Ldarg, argumentIndex);
            body.Emit(OpCodes.Box, newType);
            body.Emit(OpCodes.Isinst, imports.String);
            body.Emit(OpCodes.Call, imports.StringToNative);
            body.Emit(OpCodes.Call, imports.WriteFieldWBarrier);
            body.Emit(OpCodes.Br_S, finalNop);
            
            body.Append(valueTypeNop);
            body.Emit(OpCodes.Pop); // pop extra typeof(T)
            body.Emit(OpCodes.Ldarg, argumentIndex);
            body.Emit(OpCodes.Stobj, newType);
            body.Emit(OpCodes.Pop);
            
            body.Append(finalNop);
        }

        public static void EmitObjectToPointer(this ILProcessor body, TypeReference originalType, TypeReference newType, TypeRewriteContext enclosingType, int argumentIndex, bool valueTypeArgument0IsAPointer, bool allowNullable, bool unboxNonBlittableType, out VariableDefinition refVariable)
        {
            // input stack: not used
            // output stack: IntPtr to either Il2CppObject or IL2CPP value type
            refVariable = null;

            if (originalType is GenericParameter)
            {
                EmitObjectToPointerGeneric(body, originalType, newType, enclosingType, argumentIndex, valueTypeArgument0IsAPointer, allowNullable, unboxNonBlittableType);
                return;
            }

            var imports = enclosingType.AssemblyContext.Imports;
            if (originalType is ByReferenceType)
            {
                if (newType.GetElementType().IsValueType)
                {
                    body.Emit(OpCodes.Ldarg, argumentIndex);
                    body.Emit(OpCodes.Conv_I);
                } else if (originalType.GetElementType().IsValueType)
                {
                    body.Emit(OpCodes.Ldarg, argumentIndex);
                    body.Emit(OpCodes.Ldind_Ref);
                    body.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointerNotNull);
                }
                else 
                {
                    var pointerVar = new VariableDefinition(imports.IntPtr);
                    refVariable = pointerVar;
                    body.Body.Variables.Add(pointerVar);
                    body.Emit(OpCodes.Ldarg, argumentIndex);
                    body.Emit(OpCodes.Ldind_Ref);
                    if (originalType.GetElementType().FullName == "System.String")
                        body.Emit(OpCodes.Call, imports.StringToNative);
                    else
                        body.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointer);
                    body.Emit(OpCodes.Stloc, pointerVar);
                    body.Emit(OpCodes.Ldloca, pointerVar);
                    body.Emit(OpCodes.Conv_I);
                }
            }
            else if (originalType.IsValueType)
            {
                if (newType.IsValueType)
                {
                    if (argumentIndex == 0 && valueTypeArgument0IsAPointer)
                        body.Emit(OpCodes.Ldarg_0);
                    else
                        body.Emit(OpCodes.Ldarga, argumentIndex);
                }
                else
                {
                    body.Emit(OpCodes.Ldarg, argumentIndex);
                    body.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointerNotNull);
                    if (unboxNonBlittableType)
                        body.Emit(OpCodes.Call, imports.ObjectUnbox);
                }
            }
            else if (originalType.FullName == "System.String")
            {
                body.Emit(OpCodes.Ldarg, argumentIndex);
                body.Emit(OpCodes.Call, imports.StringToNative);
            } 
            else 
            {
                body.Emit(OpCodes.Ldarg, argumentIndex);
                body.Emit(OpCodes.Call, allowNullable ? imports.Il2CppObjectBaseToPointer : imports.Il2CppObjectBaseToPointerNotNull);
            }
        }

        private static void EmitObjectToPointerGeneric(ILProcessor body, TypeReference originalType,
            TypeReference newType, TypeRewriteContext enclosingType, int argumentIndex,
            bool valueTypeArgument0IsAPointer, bool allowNullable, bool unboxNonBlittableType)
        {
            var imports = enclosingType.AssemblyContext.Imports;
            
            body.Emit(OpCodes.Ldtoken, newType);
            body.Emit(OpCodes.Call, enclosingType.NewType.Module.ImportReference(imports.Type.Methods.Single(it => it.Name == nameof(Type.GetTypeFromHandle))));
            body.Emit(OpCodes.Callvirt, enclosingType.NewType.Module.ImportReference(imports.Type.Methods.Single(it => it.Name == typeof(Type).GetProperty(nameof(Type.IsValueType))!.GetMethod!.Name)));

            var finalNop = body.Create(OpCodes.Nop);
            var valueTypeNop = body.Create(OpCodes.Nop);
            var stringNop = body.Create(OpCodes.Nop);
            
            body.Emit(OpCodes.Brtrue, valueTypeNop);

            body.Emit(OpCodes.Ldarg, argumentIndex);
            body.Emit(OpCodes.Box, newType);
            body.Emit(OpCodes.Dup);
            body.Emit(OpCodes.Isinst, imports.String);
            body.Emit(OpCodes.Brtrue_S, stringNop);

            body.Emit(OpCodes.Isinst, imports.Il2CppObjectBase);
            body.Emit(OpCodes.Call, allowNullable ? imports.Il2CppObjectBaseToPointer : imports.Il2CppObjectBaseToPointerNotNull);
            if (unboxNonBlittableType)
            {
                body.Emit(OpCodes.Dup);
                body.Emit(OpCodes.Brfalse_S, finalNop); // return null immediately
                body.Emit(OpCodes.Dup);
                body.Emit(OpCodes.Call, imports.ObjectGetClass);
                body.Emit(OpCodes.Call, imports.ClassIsValueType);
                body.Emit(OpCodes.Brfalse_S, finalNop); // return reference types immediately
                body.Emit(OpCodes.Call, imports.ObjectUnbox);
            }

            body.Emit(OpCodes.Br, finalNop);
            
            body.Append(stringNop);
            body.Emit(OpCodes.Isinst, imports.String);
            body.Emit(OpCodes.Call, imports.StringToNative);
            body.Emit(OpCodes.Br_S, finalNop);
            
            body.Append(valueTypeNop);
            body.Emit(OpCodes.Ldarga, argumentIndex);
            
            body.Append(finalNop);
        }

        public static void EmitPointerToObject(this ILProcessor body, TypeReference originalReturnType, TypeReference convertedReturnType, TypeRewriteContext enclosingType, Instruction loadPointer, bool extraDerefForNonValueTypes, bool unboxValueType)
        {
            // input stack: not used
            // output stack: converted result
            
            if (originalReturnType is GenericParameter)
            {
                EmitPointerToObjectGeneric(body, originalReturnType, convertedReturnType, enclosingType, loadPointer, extraDerefForNonValueTypes, unboxValueType);
                return;
            }

            var imports = enclosingType.AssemblyContext.Imports;
            if (originalReturnType.FullName == "System.Void")
            {
                // do nothing
            }
            else if (originalReturnType.IsValueType)
            {
                if (convertedReturnType.IsValueType)
                {
                    body.Append(loadPointer);
                    if (unboxValueType) body.Emit(OpCodes.Call, imports.ObjectUnbox);
                    body.Emit(OpCodes.Ldobj, convertedReturnType);
                }
                else
                {
                    if (!unboxValueType)
                    {
                        var classPointerTypeRef = new GenericInstanceType(imports.Il2CppClassPointerStore)
                            {GenericArguments = {convertedReturnType}};
                        var classPointerFieldRef =
                            new FieldReference(nameof(Il2CppClassPointerStore<int>.NativeClassPtr), imports.IntPtr,
                                classPointerTypeRef);
                        body.Emit(OpCodes.Ldsfld, enclosingType.NewType.Module.ImportReference(classPointerFieldRef));
                        body.Append(loadPointer);
                        body.Emit(OpCodes.Call, imports.ObjectBox);
                    }
                    else // already boxed
                    {
                        body.Append(loadPointer);
                    }

                    body.Emit(OpCodes.Newobj,
                        new MethodReference(".ctor", imports.Void, convertedReturnType)
                            {Parameters = {new ParameterDefinition(imports.IntPtr)}, HasThis = true});
                }
            } else if (originalReturnType.FullName == "System.String")
            {
                body.Append(loadPointer);
                if (extraDerefForNonValueTypes) body.Emit(OpCodes.Ldind_I);
                body.Emit(OpCodes.Call, imports.StringFromNative);
            }
            else if (originalReturnType.IsArray && originalReturnType.GetElementType().IsGenericParameter)
            {
                body.Append(loadPointer);
                var actualReturnType = imports.Il2CppArrayBaseSelfSubst;
                var methodRef = new MethodReference(nameof(Il2CppArrayBase<int>.WrapNativeGenericArrayPointer),
                    actualReturnType,
                    convertedReturnType) {HasThis = false, Parameters = {new ParameterDefinition(imports.IntPtr)}};
                body.Emit(OpCodes.Call, methodRef);
            } else
            {
                var createRealObject = body.Create(OpCodes.Newobj,
                    new MethodReference(".ctor", imports.Void, convertedReturnType)
                        {Parameters = {new ParameterDefinition(imports.IntPtr)}, HasThis = true});
                var endNop = body.Create(OpCodes.Nop);
                
                body.Append(loadPointer);
                if (extraDerefForNonValueTypes) body.Emit(OpCodes.Ldind_I);
                body.Emit(OpCodes.Dup);
                body.Emit(OpCodes.Brtrue_S, createRealObject);
                body.Emit(OpCodes.Pop);
                body.Emit(OpCodes.Ldnull);
                body.Emit(OpCodes.Br, endNop);
                
                body.Append(createRealObject);
                body.Append(endNop);
            }
        }

        private static void EmitPointerToObjectGeneric(ILProcessor body, TypeReference originalReturnType,
            TypeReference newReturnType,
            TypeRewriteContext enclosingType, Instruction loadPointer, bool extraDerefForNonValueTypes,
            bool unboxValueType)
        {
            var imports = enclosingType.AssemblyContext.Imports;
            
            body.Append(loadPointer);
            
            body.Emit(extraDerefForNonValueTypes ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            body.Emit(unboxValueType ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            body.Emit(OpCodes.Call, imports.Module.ImportReference(new GenericInstanceMethod(imports.Il2CppPointerToGeneric) { GenericArguments = { newReturnType }}));
        }

        public static void GenerateBoxMethod(TypeDefinition targetType, FieldReference classHandle, TypeReference il2CppObjectTypeDef)
        {
            var method = new MethodDefinition("BoxIl2CppObject", MethodAttributes.Public | MethodAttributes.HideBySig, targetType.Module.ImportReference(il2CppObjectTypeDef));
            targetType.Methods.Add(method);

            var methodBody = method.Body.GetILProcessor();
            methodBody.Emit(OpCodes.Ldsfld, classHandle);
            methodBody.Emit(OpCodes.Ldarg_0);
            methodBody.Emit(OpCodes.Call, targetType.Module.ImportReference(typeof(IL2CPP).GetMethod("il2cpp_value_box")));

            methodBody.Emit(OpCodes.Newobj, new MethodReference(".ctor", targetType.Module.ImportReference(TargetTypeSystemHandler.Void), il2CppObjectTypeDef) { Parameters = { new ParameterDefinition(targetType.Module.ImportReference(TargetTypeSystemHandler.IntPtr))}, HasThis = true});
            
            methodBody.Emit(OpCodes.Ret);
        }

        public static void EmitUpdateRef(this ILProcessor body, ParameterDefinition newMethodParameter, int argIndex, VariableDefinition paramVariable, AssemblyKnownImports imports)
        {
            body.Emit(OpCodes.Ldarg, argIndex);
            body.Emit(OpCodes.Ldloc, paramVariable);
            if (newMethodParameter.ParameterType.GetElementType().FullName == "System.String")
                body.Emit(OpCodes.Call, imports.StringFromNative);
            else
            {
                body.Emit(OpCodes.Dup);
                var nullbr = body.Create(OpCodes.Pop);
                var stnop = body.Create(OpCodes.Nop);
                body.Emit(OpCodes.Brfalse_S, nullbr);
                
                body.Emit(OpCodes.Newobj,
                    new MethodReference(".ctor", imports.Void, newMethodParameter.ParameterType.GetElementType())
                        {HasThis = true, Parameters = {new ParameterDefinition(imports.IntPtr)}});
                body.Emit(OpCodes.Br_S, stnop);
                
                body.Append(nullbr);
                body.Emit(OpCodes.Ldnull);
                body.Append(stnop);
            }

            body.Emit(OpCodes.Stind_Ref);
        }
    }
}
```

`AssemblyUnhollower/Utils/UniquificationContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using AssemblyUnhollower.Extensions;

namespace AssemblyUnhollower.Utils
{
    public class UniquificationContext
    {
        private readonly UnhollowerOptions myUnhollowerOptions;
        private readonly Dictionary<string, int> myUniquifiersCount = new Dictionary<string, int>();
        private readonly SortedSet<(string, float)> myPrefixes = new SortedSet<(string, float)>(new Item2Comparer());

        public UniquificationContext(UnhollowerOptions unhollowerOptions)
        {
            myUnhollowerOptions = unhollowerOptions;
        }

        public bool CheckFull()
        {
            return myUniquifiersCount.Count >= myUnhollowerOptions.TypeDeobfuscationMaxUniquifiers;
        }

        public void Push(string str, bool noSubstring = false)
        {
            if (str.IsInvalidInSource()) return;
            
            var stringPrefix = noSubstring ? str : SubstringBounded(str, 0, myUnhollowerOptions.TypeDeobfuscationCharsPerUniquifier);
            var currentCount = myUniquifiersCount[stringPrefix] = myUniquifiersCount.GetOrCreate(stringPrefix, _ => 0) + 1;
            myPrefixes.Add((stringPrefix, myUniquifiersCount.Count + currentCount * 2 + myPrefixes.Count / 100f));
        }
        
        public void Push(List<string> strings, bool noSubstring = false)
        {
            foreach (var str in strings) 
                Push(str, noSubstring);
        }

        public string GetTop()
        {
            return string.Join("", myPrefixes.Take(myUnhollowerOptions.TypeDeobfuscationMaxUniquifiers).Select(it => it.Item1));
        }

        private class Item2Comparer : IComparer<(string, float)>
        {
            public int Compare((string, float) x, (string, float) y) => x.Item2.CompareTo(y.Item2);
        }
        
        private static string SubstringBounded(string str, int startIndex, int length)
        {
            length = Math.Min(length, str.Length);
            return str.Substring(startIndex, length);
        }
    }
}
```

`AssemblyUnhollower/Utils/UnstripGenerator.cs`:

```cs
using System.Linq;
using System.Text;
using AssemblyUnhollower.Contexts;
using Mono.Cecil;
using Mono.Cecil.Cil;
using UnhollowerBaseLib;

namespace AssemblyUnhollower.Utils
{
    public static class UnstripGenerator
    {
        public static TypeDefinition CreateDelegateTypeForICallMethod(MethodDefinition unityMethod, MethodDefinition convertedMethod, AssemblyKnownImports imports)
        {
            var delegateType = new TypeDefinition("", unityMethod.Name + "Delegate", TypeAttributes.Sealed | TypeAttributes.NestedPrivate, imports.MulticastDelegate);
            
            var constructor = new MethodDefinition(".ctor", MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName | MethodAttributes.Public, imports.Void);
            constructor.Parameters.Add(new ParameterDefinition(imports.Object));
            constructor.Parameters.Add(new ParameterDefinition(imports.IntPtr));
            constructor.ImplAttributes = MethodImplAttributes.CodeTypeMask;
            delegateType.Methods.Add(constructor);
            
            var invokeMethod = new MethodDefinition("Invoke", MethodAttributes.HideBySig | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Public, imports.Void); // todo
            invokeMethod.ImplAttributes = MethodImplAttributes.CodeTypeMask;
            delegateType.Methods.Add(invokeMethod);

            invokeMethod.ReturnType = convertedMethod.ReturnType.IsValueType ? convertedMethod.ReturnType : imports.IntPtr;
            if (convertedMethod.HasThis)
                invokeMethod.Parameters.Add(new ParameterDefinition("@this", ParameterAttributes.None, imports.IntPtr));
            foreach (var convertedParameter in convertedMethod.Parameters)
                invokeMethod.Parameters.Add(new ParameterDefinition(convertedParameter.Name,
                    convertedParameter.Attributes & ~ParameterAttributes.Optional,
                    convertedParameter.ParameterType.IsValueType ? convertedParameter.ParameterType : imports.IntPtr));

            return delegateType;
        }

        public static void GenerateInvokerMethodBody(MethodDefinition newMethod, FieldDefinition delegateField, TypeDefinition delegateType, TypeRewriteContext enclosingType, AssemblyKnownImports imports)
        {
            var body = newMethod.Body.GetILProcessor();
            
            body.Emit(OpCodes.Ldsfld, delegateField);
            if (newMethod.HasThis)
            {
                body.Emit(OpCodes.Ldarg_0);
                body.Emit(OpCodes.Call, imports.Il2CppObjectBaseToPointerNotNull);
            }

            var argOffset = newMethod.HasThis ? 1 : 0;

            for (var i = 0; i < newMethod.Parameters.Count; i++)
            {
                var param = newMethod.Parameters[i];
                var paramType = param.ParameterType;
                if(paramType.IsValueType || paramType.IsByReference && paramType.GetElementType().IsValueType)
                    body.Emit(OpCodes.Ldarg, i + argOffset);
                else
                {
                    body.EmitObjectToPointer(param.ParameterType, param.ParameterType, enclosingType, i + argOffset, false, true, true, out var refVar);
                    if (refVar != null)
                        LogSupport.Trace($"Method {newMethod} has a reference-typed ref parameter, this will be ignored");
                }
            }

            body.Emit(OpCodes.Call, delegateType.Methods.Single(it => it.Name == "Invoke"));
            if (!newMethod.ReturnType.IsValueType)
            {
                var pointerVar = new VariableDefinition(imports.IntPtr);
                newMethod.Body.Variables.Add(pointerVar);
                body.Emit(OpCodes.Stloc, pointerVar);
                var loadInstr = body.Create(OpCodes.Ldloc, pointerVar);
                body.EmitPointerToObject(newMethod.ReturnType, newMethod.ReturnType, enclosingType, loadInstr, false, false);
            }
            body.Emit(OpCodes.Ret);
        }

        public static FieldDefinition GenerateStaticCtorSuffix(TypeDefinition enclosingType, TypeDefinition delegateType, MethodDefinition unityMethod, AssemblyKnownImports imports)
        {
            var delegateField = new FieldDefinition(delegateType.Name + "Field", FieldAttributes.Static | FieldAttributes.Private | FieldAttributes.InitOnly, delegateType);
            enclosingType.Fields.Add(delegateField);
            
            var staticCtor = enclosingType.Methods.SingleOrDefault(it => it.Name == ".cctor");
            if (staticCtor == null)
            {
                staticCtor = new MethodDefinition(".cctor",
                    MethodAttributes.Static | MethodAttributes.Private | MethodAttributes.SpecialName |
                    MethodAttributes.HideBySig | MethodAttributes.RTSpecialName, imports.Void);
                staticCtor.Body.GetILProcessor().Emit(OpCodes.Ret);
                enclosingType.Methods.Add(staticCtor);
            }
            var bodyProcessor = staticCtor.Body.GetILProcessor();

            bodyProcessor.Remove(staticCtor.Body.Instructions.Last()); // remove ret
            
            bodyProcessor.Emit(OpCodes.Ldstr, GetICallSignature(unityMethod));
            
            var methodRef = new GenericInstanceMethod(imports.Il2CppResolveICall);
            methodRef.GenericArguments.Add(delegateType);
            bodyProcessor.Emit(OpCodes.Call, enclosingType.Module.ImportReference(methodRef));
            bodyProcessor.Emit(OpCodes.Stsfld, delegateField);
            
            bodyProcessor.Emit(OpCodes.Ret); // restore ret

            return delegateField;
        }

        private static string GetICallSignature(MethodDefinition unityMethod)
        {
            var builder = new StringBuilder();
            builder.Append(unityMethod.DeclaringType.FullName);
            builder.Append("::");
            builder.Append(unityMethod.Name);

            return builder.ToString();
        }
    }
}
```

`AssemblyUnhollower/Utils/UnstripTranslator.cs`:

```cs
using System.Linq;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Passes;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace AssemblyUnhollower.Utils
{
    public static class UnstripTranslator
    {
        public static bool TranslateMethod(MethodDefinition original, MethodDefinition target, TypeRewriteContext typeRewriteContext, AssemblyKnownImports imports)
        {
            if (!original.HasBody) return true;
            
            var globalContext = typeRewriteContext.AssemblyContext.GlobalContext;
            foreach (var variableDefinition in original.Body.Variables)
            {
                var variableType = Pass80UnstripMethods.ResolveTypeInNewAssemblies(globalContext, variableDefinition.VariableType, imports);
                if (variableType == null) return false;
                target.Body.Variables.Add(new VariableDefinition(variableType));
            }
            
            var targetBuilder = target.Body.GetILProcessor();
            foreach (var bodyInstruction in original.Body.Instructions)
            {
                if (bodyInstruction.OpCode.OperandType == OperandType.InlineField)
                {
                    var fieldArg = (FieldReference) bodyInstruction.Operand;
                    var fieldDeclarer = Pass80UnstripMethods.ResolveTypeInNewAssembliesRaw(globalContext, fieldArg.DeclaringType, imports);
                    if (fieldDeclarer == null) return false;
                    var newField = fieldDeclarer.Resolve().Fields.SingleOrDefault(it => it.Name == fieldArg.Name);
                    if (newField != null)
                    {
                        targetBuilder.Emit(bodyInstruction.OpCode, imports.Module.ImportReference(newField));
                    }
                    else
                    {
                        if (bodyInstruction.OpCode == OpCodes.Ldfld || bodyInstruction.OpCode == OpCodes.Ldsfld)
                        {
                            var getterMethod = fieldDeclarer.Resolve().Properties.SingleOrDefault(it => it.Name == fieldArg.Name)?.GetMethod;
                            if (getterMethod == null) return false;

                            targetBuilder.Emit(OpCodes.Call, imports.Module.ImportReference(getterMethod));
                        } else if (bodyInstruction.OpCode == OpCodes.Stfld || bodyInstruction.OpCode == OpCodes.Stsfld)
                        {
                            var setterMethod = fieldDeclarer.Resolve().Properties.SingleOrDefault(it => it.Name == fieldArg.Name)?.SetMethod;
                            if (setterMethod == null) return false;

                            targetBuilder.Emit(OpCodes.Call, imports.Module.ImportReference(setterMethod));
                        }
                        else
                            return false;
                    }
                } else if (bodyInstruction.OpCode.OperandType == OperandType.InlineMethod)
                {
                    var methodArg = (MethodReference) bodyInstruction.Operand;
                    var methodDeclarer = Pass80UnstripMethods.ResolveTypeInNewAssemblies(globalContext, methodArg.DeclaringType, imports);
                    if (methodDeclarer == null) return false; // todo: generic methods

                    var newReturnType = Pass80UnstripMethods.ResolveTypeInNewAssemblies(globalContext, methodArg.ReturnType, imports);
                    if (newReturnType == null) return false;
                    
                    var newMethod = new MethodReference(methodArg.Name, newReturnType, methodDeclarer);
                    newMethod.HasThis = methodArg.HasThis;
                    foreach (var methodArgParameter in methodArg.Parameters)
                    {
                        var newParamType = Pass80UnstripMethods.ResolveTypeInNewAssemblies(globalContext, methodArgParameter.ParameterType, imports);
                        if (newParamType == null) return false;
                        
                        var newParam = new ParameterDefinition(methodArgParameter.Name, methodArgParameter.Attributes, newParamType);
                        newMethod.Parameters.Add(newParam);
                    }
                    
                    targetBuilder.Emit(bodyInstruction.OpCode, imports.Module.ImportReference(newMethod));
                } else if (bodyInstruction.OpCode.OperandType == OperandType.InlineType)
                {
                    var targetType = (TypeReference) bodyInstruction.Operand;
                    if (targetType is GenericParameter genericParam)
                    {
                        if (genericParam.Owner is TypeReference paramOwner)
                        {
                            var newTypeOwner = Pass80UnstripMethods.ResolveTypeInNewAssemblies(globalContext, paramOwner, imports);
                            if (newTypeOwner == null) return false;
                            targetType = newTypeOwner.GenericParameters.Single(it => it.Name == targetType.Name);
                        } else
                            targetType = target.GenericParameters.Single(it => it.Name == targetType.Name);
                    }
                    else
                    {
                        targetType = Pass80UnstripMethods.ResolveTypeInNewAssemblies(globalContext, targetType, imports);
                        if (targetType == null) return false;
                    }

                    if (bodyInstruction.OpCode == OpCodes.Castclass && !targetType.IsValueType)
                    {
                        targetBuilder.Emit(OpCodes.Call, imports.Module.ImportReference(new GenericInstanceMethod(imports.Il2CppObjectCast) { GenericArguments = { targetType }}));
                    } else if (bodyInstruction.OpCode == OpCodes.Isinst && !targetType.IsValueType)
                    {
                        targetBuilder.Emit(OpCodes.Call, imports.Module.ImportReference(new GenericInstanceMethod(imports.Il2CppObjectTryCast) { GenericArguments = { targetType }}));
                    } else
                        targetBuilder.Emit(bodyInstruction.OpCode, targetType);
                } else if (bodyInstruction.OpCode.OperandType == OperandType.InlineSig)
                {
                    // todo: rewrite sig if this ever happens in unity types
                    return false;
                } else if (bodyInstruction.OpCode.OperandType == OperandType.InlineTok)
                {
                    var targetTok = bodyInstruction.Operand as TypeReference;
                    if (targetTok == null) 
                        return false;
                    if (targetTok is GenericParameter genericParam)
                    {
                        if (genericParam.Owner is TypeReference paramOwner)
                        {
                            var newTypeOwner = Pass80UnstripMethods.ResolveTypeInNewAssemblies(globalContext, paramOwner, imports);
                            if (newTypeOwner == null) return false;
                            targetTok = newTypeOwner.GenericParameters.Single(it => it.Name == targetTok.Name);
                        } else
                            targetTok = target.GenericParameters.Single(it => it.Name == targetTok.Name);
                    }
                    else
                    {
                        targetTok = Pass80UnstripMethods.ResolveTypeInNewAssemblies(globalContext, targetTok, imports);
                        if (targetTok == null) return false;
                    }
                    
                    targetBuilder.Emit(OpCodes.Call, imports.Module.ImportReference(new GenericInstanceMethod(imports.LdTokUnstrippedImpl) { GenericArguments = { targetTok }}));
                }
                else
                {
                    targetBuilder.Append(bodyInstruction);
                }
            }

            return true;
        }

        public static void ReplaceBodyWithException(MethodDefinition newMethod, AssemblyKnownImports imports)
        {
            newMethod.Body.Variables.Clear();
            newMethod.Body.Instructions.Clear();
            var processor = newMethod.Body.GetILProcessor();
            
            processor.Emit(OpCodes.Ldstr, "Method unstripping failed");
            processor.Emit(OpCodes.Newobj, imports.NotSupportedExceptionCtor);
            processor.Emit(OpCodes.Throw);
            processor.Emit(OpCodes.Ret);
        }
    }
}
```

`AssemblyUnhollower/Utils/XrefScanMetadataGenerationUtil.cs`:

```cs
using System;
using System.Linq;
using AssemblyUnhollower.Contexts;
using AssemblyUnhollower.Extensions;

namespace UnhollowerRuntimeLib.XrefScans
{
    internal static class XrefScanMetadataGenerationUtil
    {
        internal static long MetadataInitForMethodRva;
        internal static IntPtr MetadataInitForMethodFileOffset;

        private static readonly (string Assembly, string Type, string Method)[] MetadataInitCandidates = {
            ("UnityEngine.CoreModule", "UnityEngine.Object", ".cctor"),
            ("mscorlib", "System.Exception", "get_Message"),
            ("mscorlib", "System.IntPtr", "Equals")
        };

        private static void FindMetadataInitForMethod(RewriteGlobalContext context, long gameAssemblyBase)
        {
            foreach (var metadataInitCandidate in MetadataInitCandidates)
            {
                var assembly = context.Assemblies.FirstOrDefault(it => it.OriginalAssembly.Name.Name == metadataInitCandidate.Assembly);
                var unityObjectCctor = assembly?.TryGetTypeByName(metadataInitCandidate.Type)?.OriginalType.Methods.FirstOrDefault(it => it.Name == metadataInitCandidate.Method);
                
                if(unityObjectCctor == null) continue;
                
                MetadataInitForMethodFileOffset =
                    (IntPtr) ((long) XrefScannerLowLevel.JumpTargets((IntPtr) (gameAssemblyBase + unityObjectCctor.ExtractOffset())).First());
                MetadataInitForMethodRva = (long) MetadataInitForMethodFileOffset - gameAssemblyBase - unityObjectCctor.ExtractOffset() + unityObjectCctor.ExtractRva();

                return;
            }

            throw new ApplicationException("Unable to find a method with metadata init reference");
        }

        internal static (long FlagRva, long TokenRva) FindMetadataInitForMethod(MethodRewriteContext method, long gameAssemblyBase)
        {
            if (MetadataInitForMethodRva == 0)
                FindMetadataInitForMethod(method.DeclaringType.AssemblyContext.GlobalContext, gameAssemblyBase);
            
            var codeStart = (IntPtr) (gameAssemblyBase + method.FileOffset);
            var firstCall = XrefScannerLowLevel.JumpTargets(codeStart).FirstOrDefault();
            if (firstCall != MetadataInitForMethodFileOffset || firstCall == IntPtr.Zero) return (0, 0);

            var tokenPointer = XrefScanUtilFinder.FindLastRcxReadAddressBeforeCallTo(codeStart, MetadataInitForMethodFileOffset);
            var initFlagPointer = XrefScanUtilFinder.FindByteWriteTargetRightAfterCallTo(codeStart, MetadataInitForMethodFileOffset);

            if (tokenPointer == IntPtr.Zero || initFlagPointer == IntPtr.Zero) return (0, 0);

            return ((long) initFlagPointer - gameAssemblyBase - method.FileOffset + method.Rva, (long) tokenPointer - gameAssemblyBase - method.FileOffset + method.Rva);
        } 
    }
}
```

`COPYING.LESSER`:

```LESSER
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

```

`Documentation/Class-Injection.md`:

```md
# Class injection
Starting with version `0.4.0.0`, managed classes can be injected into IL2CPP domain. Currently this is fairly limited, but functional enough for GC integration and implementing custom MonoBehaviors.

## How-to
 * Your class must inherit from a non-abstract IL2CPP class.
 * You must include a constructor that takes IntPtr and passes it to base class constructor. It will be called when objects of your class are created from IL2CPP side.
 * To create your object from managed side, call base class IntPtr constructor with result of `ClassInjector.DerivedConstructorPointer<T>()`, where T is your class type, and call `ClassInjector.DerivedConstructorBody(this)` in constructor body.
 * An example of injected class is `Il2CppToMonoDelegateReference` in [DelegateSupport.cs](UnhollowerRuntimeLib/DelegateSupport.cs)
 * Call `ClassInjector.RegisterTypeInIl2Cpp<T>()` before first use of class to be injected
 * The injected class can be used normally afterwards, for example a custom MonoBehavior implementation would work with `AddComponent<T>`
 
## Fine-tuning
  * `[HideFromIl2Cpp]` can be used to prevent a method from being exposed to il2cpp
 
## Caveats
 * Injected class instances are handled by IL2CPP garbage collection. This means that an object may be collected even if it's referenced from managed domain. Attempting to use that object afterwards will result in `ObjectCollectedException`. Conversely, managed representation of injected object will not be garbage collected as long as it's referenced from IL2CPP domain.
 * It might be possible to create a cross-domain reference loop that will prevent objects from being garbage collected. Avoid doing anything that will result in injected class instances (indirectly) storing references to itself. The simplest example of how to leak memory is this:
```c#
class Injected: Il2CppSystem.Object {
    Il2CppSystem.Collections.Generic.List<Il2CppSystem.Object> list = new ...;
    public Injected() {
        list.Add(this); // reference to itself through an IL2CPP list. This will prevent both this and list from being garbage collected, ever.
    }
}
```

## Limitations
 * Interfaces can't be implemented
 * Virtual methods can't be overridden
 * Only instance methods are exposed to IL2CPP side - no fields, properties, events or static methods will be visible to IL2CPP reflection
 * Only a limited set of types is supported for method signatures
 
```

`Documentation/Command-Line-Usage.md`:

```md
# Command-Line Usage

 ## Basic Usage
  0. Build or get a release
  1. Obtain dummy assemblies using [Il2CppDumper](https://github.com/Perfare/Il2CppDumper)
  2. Run `AssemblyUnhollower --input=<path to Il2CppDumper's dummy dll dir> --output=<output directory> --mscorlib=<path to target mscorlib>`    
       
 Resulting assemblies may be used with your favorite loader that offers a Mono domain in the IL2CPP game process, such as [MelonLoader](https://github.com/HerpDerpinstine/MelonLoader).    
 This appears to be working reasonably well for Unity 2018.4.x games, but more extensive testing is required.  
 Generated assemblies appear to be invalid according to .NET Core/.NET Framework, but run fine on Mono.

## Command-line parameter reference


| Parameter | Explanation |
| --------- | ----------- |
| `--help`, -h, /? | Optional. Show this help |
| `--verbose` | Optional. Produce more console output |
| `--input=<directory path>` | Required. Directory with Il2CppDumper's dummy assemblies |
| `--output=<directory path>` | Required. Directory to put results into |
| `--mscorlib=<file path>` | Required. mscorlib.dll of target runtime system (typically loader's) |
| `--unity=<directory path>` | Optional. Directory with original Unity assemblies for unstripping |
| `--gameassembly=<file path>` | Optional. Path to GameAssembly.dll. Used for certain analyses |
| `--deobf-uniq-chars=<number>` | Optional. How many characters per unique token to use during deobfuscation |
| `--deobf-uniq-max=<number>` | Optional. How many maximum unique tokens per type are allowed during deobfuscation |
| `--deobf-analyze` | Optional. Analyze deobfuscation performance with different parameter values. Will not generate assemblies. |
| `--blacklist-assembly=<assembly name>` | Optional. Don't write specified assembly to output. Can be used multiple times |
| `--no-xref-cache` | Optional. Don't generate xref scanning cache. All scanning will be done at runtime. |
| `--no-copy-unhollower-libs` | Optional. Don't copy unhollower libraries to output directory |
| `--obf-regex=<regex>` | Optional. Specifies a regex for obfuscated names. All types and members matching will be renamed |
| `--rename-map=<file path>` | Optional. Specifies a file specifying rename map for obfuscated types and members |
| `--passthrough-names` | Optional. If specified, names will be copied from input assemblies as-is without renaming or deobfuscation |
| Deobfuscation map generation mode: | |
| `--deobf-generate` | Generate a deobfuscation map for input files. Will not generate assemblies. |
| `--deobf-generate-asm=<assembly name>` | Optional. Include this assembly for deobfuscation map generation. If none are specified, all assemblies will be included. |
| `--deobf-generate-new=<directory path>` | Required. Specifies the directory with new (obfuscated) assemblies. The `--input` parameter specifies old (unobfuscated) assemblies. |


## Required external setup
Before certain features can be used (namely class injection and delegate conversion), some external setup is required.
 * Set `ClassInjector.Detour` to an implementation of a managed detour with semantics as described in the interface 
 * Alternatively, set `ClassInjector.DoHook` to an Action with same semantics as `DetourAttach` (signature `void**, void*`, first is a pointer to a variable containing pointer to hooked code start, second is a pointer to patch code start, a pointer to call-original code start is written to the first parameter)
 * Call `UnityVersionHandler.Initialize` with appropriate Unity version (default is 2018.4.20)

```

`Documentation/Common-Problems.md`:

```md
# Common Problems

## Wrong mscorlib

You may be getting this error when running assembly generation:

```
Unhandled Exception: System.ArgumentNullException: Value cannot be null.
Parameter name: type
at Mono.Cecil.Mixin.CheckType(Object type)
at Mono.Cecil.ModuleDefinition.ImportReference(TypeReference type, IGenericParameterProvider context)
at AssemblyUnhollower.Passes.Pass60AddImplicitConversions.AddDelegateConversions(RewriteGlobalContext context)
at AssemblyUnhollower.Passes.Pass60AddImplicitConversions.DoPass(RewriteGlobalContext context)
at AssemblyUnhollower.Program.Main(UnhollowerOptions options)
at AssemblyUnhollower.Program.Main(String[] args)
```

This is because `--mscorlib` should point at the mod loader's mscorlib (or at the very least GAC mscorlib). It should not point to the dummy dll mscorlib.
```

`Documentation/Injected-Components-In-Asset-Bundles.md`:

```md
# Injected Components in Asset Bundles

Starting with version `0.4.15.0`, injected components can be used in asset bundles.

## How-to
 * Your class must meet the critereon mentioned in Class Injection.
 * Add a dummy script for your component into Unity. Remove any methods, constructors, and properties. Fields can optionally be left in for future deserialization support.
 * Apply the component to your intended objects in Unity and build the asset bundle.
 * At runtime, register your component with `RegisterTypeInIl2Cpp` before loading any objects from the asset bundle.

## Limitations
 * Currently, deserialization for component fields is not supported. Any fields on the component will initially have their default value as defined in the mono assembly.
```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# Il2CppAssemblyUnhollower
A tool to generate Managed->IL2CPP proxy assemblies from
 [Il2CppDumper](https://github.com/Perfare/Il2CppDumper )'s output.

This allows the use of IL2CPP domain and objects in it from a managed domain. 
This includes generic types and methods, arrays, and new object creation. Some things may be horribly broken. 
 
## Usage
  0. Build or get a release
  1. Obtain dummy assemblies using [Il2CppDumper](https://github.com/Perfare/Il2CppDumper)
  2. Run `AssemblyUnhollower --input=<path to Il2CppDumper's dummy dll dir> --output=<output directory> --mscorlib=<path to target mscorlib>`    
       
 Resulting assemblies may be used with your favorite loader that offers a Mono domain in the IL2CPP game process, such as [MelonLoader](https://github.com/HerpDerpinstine/MelonLoader).    
 This appears to be working reasonably well for Unity 2018.4.x games, but more extensive testing is required.  
 Generated assemblies appear to be invalid according to .NET Core/.NET Framework, but run fine on Mono.

### Command-line parameter reference
```
Usage: AssemblyUnhollower [parameters]
Possible parameters:
        --help, -h, /? - Optional. Show this help
        --verbose - Optional. Produce more console output
        --input=<directory path> - Required. Directory with Il2CppDumper's dummy assemblies
        --output=<directory path> - Required. Directory to put results into
        --mscorlib=<file path> - Required. mscorlib.dll of target runtime system (typically loader's)
        --unity=<directory path> - Optional. Directory with original Unity assemblies for unstripping
        --gameassembly=<file path> - Optional. Path to GameAssembly.dll. Used for certain analyses
        --deobf-uniq-chars=<number> - Optional. How many characters per unique token to use during deobfuscation
        --deobf-uniq-max=<number> - Optional. How many maximum unique tokens per type are allowed during deobfuscation
        --deobf-analyze - Optional. Analyze deobfuscation performance with different parameter values. Will not generate assemblies.
        --blacklist-assembly=<assembly name> - Optional. Don't write specified assembly to output. Can be used multiple times
        --add-prefix-to=<assembly name/namespace> - Optional. Assemblies and namespaces starting with these will get an Il2Cpp prefix in generated assemblies. Can be used multiple times.
        --no-xref-cache - Optional. Don't generate xref scanning cache. All scanning will be done at runtime.
        --no-copy-unhollower-libs - Optional. Don't copy unhollower libraries to output directory
        --obf-regex=<regex> - Optional. Specifies a regex for obfuscated names. All types and members matching will be renamed
        --rename-map=<file path> - Optional. Specifies a file specifying rename map for obfuscated types and members
        --passthrough-names - Optional. If specified, names will be copied from input assemblies as-is without renaming or deobfuscation
Deobfuscation map generation mode:
        --deobf-generate - Generate a deobfuscation map for input files. Will not generate assemblies.
        --deobf-generate-asm=<assembly name> - Optional. Include this assembly for deobfuscation map generation. If none are specified, all assemblies will be included.
        --deobf-generate-new=<directory path> - Required. Specifies the directory with new (obfuscated) assemblies. The --input parameter specifies old (unobfuscated) assemblies. 
```

## Required external setup
Before certain features can be used (namely class injection and delegate conversion), some external setup is required.
 * Set `ClassInjector.Detour` to an implementation of a managed detour with semantics as described in the interface 
 * Alternatively, set `ClassInjector.DoHook` to an Action with same semantics as `DetourAttach` (signature `void**, void*`, first is a pointer to a variable containing pointer to hooked code start, second is a pointer to patch code start, a pointer to call-original code start is written to the first parameter)
 * Call `UnityVersionHandler.Initialize` with appropriate Unity version (default is 2018.4.20)

## Known Issues
 * Non-blittable structs can't be used in delegates
 * Types implementing interfaces, particularly IEnumerable, may be arbitrarily janky with interface methods. Additionally, using them in foreach may result in implicit casts on managed side (instead of `Cast<T>`, see below), leading to exceptions. Use `var` in `foreach` or use `for` instead of `foreach` when possible as a workaround, or cast them to the specific interface you want to use.
 * in/out/ref parameters on generic parameter types (like `out T` in `Dictionary.TryGetValue`) are currently broken
 * Unity unstripping only partially restores types, and certain methods can't be unstripped still; some calls to unstripped methods might result in crashes
 * Unstripped methods with array operations inside contain invalid bytecode
 * Unstripped methods with casts inside will likely throw invalid cast exceptions or produce nulls
 * Some unstripped methods are stubbed with `NotSupportedException` in cases where rewrite failed
 * Nullables have issues when returned from field/property getters and methods

## Generated assemblies caveats
 * IL2CPP types must be cast using `.Cast<T>` or `.TryCast<T>` methods instead of C-style casts or `as`.
 * When IL2CPP code requires a `System.Type`, use `Il2CppType.Of<T>()` instead of `typeof(T)`
 * For IL2CPP delegate types, use the implicit conversion from `System.Action` or `System.Func`, like this: `UnityAction a = new Action(() => {})` or `var x = (UnityAction) new Action(() => {})`
 * IL2CPP assemblies are stripped, so some methods or even classes could be missing compared to pre-IL2CPP assemblies. This is mostly applicable to Unity assemblies.
 * Using generics with value types may lead to exceptions or crashes because of missing method bodies. If a specific value-typed generic signature was not used in original game code, it can't be used externally either.

## Class injection
Starting with version 0.4.0.0, managed classes can be injected into IL2CPP domain. Currently this is fairly limited, but functional enough for GC integration and implementing custom MonoBehaviors.

How-to:
 * Your class must inherit from a non-abstract IL2CPP class.
 * You must include a constructor that takes IntPtr and passes it to base class constructor. It will be called when objects of your class are created from IL2CPP side.
 * To create your object from managed side, call base class IntPtr constructor with result of `ClassInjector.DerivedConstructorPointer<T>()`, where T is your class type, and call `ClassInjector.DerivedConstructorBody(this)` in constructor body.
 * An example of injected class is `Il2CppToMonoDelegateReference` in [DelegateSupport.cs](UnhollowerRuntimeLib/DelegateSupport.cs)
 * Call `ClassInjector.RegisterTypeInIl2Cpp<T>()` before first use of class to be injected
 * The injected class can be used normally afterwards, for example a custom MonoBehavior implementation would work with `AddComponent<T>`
 
Fine-tuning:
  * `[HideFromIl2Cpp]` can be used to prevent a method from being exposed to il2cpp
 
Caveats:
 * Injected class instances are handled by IL2CPP garbage collection. This means that an object may be collected even if it's referenced from managed domain. Attempting to use that object afterwards will result in `ObjectCollectedException`. Conversely, managed representation of injected object will not be garbage collected as long as it's referenced from IL2CPP domain.
 * It might be possible to create a cross-domain reference loop that will prevent objects from being garbage collected. Avoid doing anything that will result in injected class instances (indirectly) storing references to itself. The simplest example of how to leak memory is this:
```c#
class Injected: Il2CppSystem.Object {
    Il2CppSystem.Collections.Generic.List<Il2CppSystem.Object> list = new ...;
    public Injected() {
        list.Add(this); // reference to itself through an IL2CPP list. This will prevent both this and list from being garbage collected, ever.
    }
}
```

Limitations:
 * Interfaces can't be implemented
 * Virtual methods can't be overridden
 * Only instance methods are exposed to IL2CPP side - no fields, properties, events or static methods will be visible to IL2CPP reflection
 * Only a limited set of types is supported for method signatures
 
## Injected components in asset bundles
 Starting with version 0.4.15.0, injected components can be used in asset bundles. Currently, deserialization for component fields is not supported. Any fields on the component will initially have their default value as defined in the mono assembly.

 How-to:
 * Your class must meet the above critereon mentioned in Class Injection.
 * Add a dummy script for your component into Unity. Remove any methods, constructors, and properties. Fields can optionally be left in for future deserialization support.
 * Apply the component to your intended objects in Unity and build the asset bundle.
 * At runtime, register your component with `RegisterTypeInIl2Cpp` before loading any objects from the asset bundle.

## Implementing interfaces with injected types
Starting with 0.4.16.0, injected types can implement IL2CPP interfaces.  
Just like previously, your type can't implement the interface directly, as it's still generated as a class.  
However, you can pass additional interface types to `RegisterTypeInIl2CppWithInterfaces`, and they will be implemented as interfaces on the IL2CPP version of your type.  
Interface methods are matched to methods in your class by name, parameter count and genericness.  
Known caveats:   
 * `obj.Cast<InterfaceType>()` will fail if you try to cast an object of your injected type to an interface. You can work around that with `new InterfaceType(obj.Pointer)` if you're absolutely sure it implements that interface.
 * Limited method matching might result in some interfaces being trickier or impossible to implement, namely those with overloads differing only in parameter types.

## PDB generator
UnhollowerPdbGen builds an executable that can be ran to generate a Microsoft PDB file (debug symbols) for GameAssembly.dll based on unhollower-generated names.  
This can be useful for analyzing code of obfuscated games. For unobfuscated games, using [Il2CppInspector](https://github.com/djkaty/Il2CppInspector) would provide way better results for code analysis.  
Generated PDBs were tested with windbg, lldb, WPA viewer/ETL performance analysis and IDA.  
Generated PDBs only include generated methods, and don't include type info, generic method info and IL2CPP internals.   
You need to manually copy the following Microsoft-provided libraries from Visual Studio (or other build tools) for this to work - I'm not redistributing them as license on them is not clear.  
 * `mspdbcore.dll`
 * `msobj140.dll`
 * `tbbmalloc.dll`

These need to be placed next to the built .exe file. Use file search to find `mspdbcore` in VS install. 

## Upcoming features (aka TODO list)
 * Unstripping engine code - fix current issues with unstripping failing or generating invalid bytecode
 * Proper interface support - IL2CPP interfaces will be generated as interfaces and properly implemented by IL2CPP types
 * Improve class injection to support virtual methods and interfaces
 * Improve class injection to support deserializing fields

## Used libraries
Bundled into output files:
 * [iced](https://github.com/0xd4d/iced) by 0xd4d, an x86 disassembler used for xref scanning and possibly more in the future

Used by generator itself:
 * [Mono.Cecil](https://github.com/jbevain/cecil) by jbevain, the main tool to produce assemblies

Parts of source used:
 * [microsoft-pdb](https://github.com/microsoft/microsoft-pdb) for the PDB generator
```

`ReleaseChangelog.md`:

```md
This is a small bugfix update. Generated assemblies should be fully compatible with those generated by 0.4.17.x.  
  
New features:
 * Fixed compatibility with Unity versions 2021.2.0 and above
 * Fixed setters of non-blittable-value-type non-generic fields having invalid IL

```

`UnhollowerBaseLib/AssemblyInfo.cs`:

```cs

using System.Runtime.CompilerServices;

[assembly:InternalsVisibleTo("AssemblyUnhollower")]
```

`UnhollowerBaseLib/Attributes/AlsoInitializeAttribute.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Attributes
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface)]
    public class AlsoInitializeAttribute : Attribute
    {
        public readonly Type LinkedType;

        public AlsoInitializeAttribute(Type linkedType)
        {
            LinkedType = linkedType;
        }
    }
}
```

`UnhollowerBaseLib/Attributes/CachedScanResultsAttribute.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Attributes
{
    [AttributeUsage(AttributeTargets.Method, Inherited = false)]
    public class CachedScanResultsAttribute : Attribute
    {
        // Items that this method calls/uses
        public int XrefRangeStart;
        public int XrefRangeEnd;
        
        // Methods that call this method
        public int RefRangeStart;
        public int RefRangeEnd;

        // Data for metadata init call
        public long MetadataInitFlagRva;
        public long MetadataInitTokenRva;
    }
}
```

`UnhollowerBaseLib/Attributes/CallerCountAttribute.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Attributes
{
    [AttributeUsage(AttributeTargets.Method, Inherited = false)]
    public class CallerCountAttribute : Attribute
    {
        public readonly int Count;

        public CallerCountAttribute(int count)
        {
            Count = count;
        }
    }
}
```

`UnhollowerBaseLib/Attributes/ClassInjectionAssemblyTargetAttribute.cs`:

```cs
using System;
using System.Collections.Generic;

namespace UnhollowerRuntimeLib
{
    [Obsolete("UnhollowerRuntimeLib.ClassInjectionAssemblyTargetAttribute is obsolete. Use UnhollowerBaseLib.Attributes.ClassInjectionAssemblyTargetAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class)]
    public class ClassInjectionAssemblyTargetAttribute : UnhollowerBaseLib.Attributes.ClassInjectionAssemblyTargetAttribute
    {
        public ClassInjectionAssemblyTargetAttribute(string assembly) : base(assembly) { }
        public ClassInjectionAssemblyTargetAttribute(string[] assemblies) : base(assemblies) { }
    }
}

namespace UnhollowerBaseLib.Attributes
{
    [AttributeUsage(AttributeTargets.Class)]
    public class ClassInjectionAssemblyTargetAttribute : Attribute
    {
        string[] assemblies;

        public ClassInjectionAssemblyTargetAttribute(string assembly)
        {
            if (string.IsNullOrWhiteSpace(assembly)) assemblies = new string[0];
            else assemblies = new string[] { assembly };
        }
        public ClassInjectionAssemblyTargetAttribute(string[] assemblies)
        {
            if (assemblies is null) this.assemblies = new string[0];
            else this.assemblies = assemblies;
        }
        internal IntPtr[] GetImagePointers()
        {
            List<IntPtr> result = new List<IntPtr>();
            foreach (string assembly in assemblies)
            {
                IntPtr intPtr = IL2CPP.GetIl2CppImage(assembly);
                if (intPtr != IntPtr.Zero) result.Add(intPtr);
            }
            return result.ToArray();
        }
    }
}

```

`UnhollowerBaseLib/Attributes/HideFromIl2CppAttribute.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Attributes
{
    /// <summary>
    /// This attribute indicates that the target should not be exposed to IL2CPP in injected classes
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Property)]
    public class HideFromIl2CppAttribute : Attribute
    {
    }
}
```

`UnhollowerBaseLib/Attributes/ObfuscatedNameAttribute.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Attributes
{
    [AttributeUsage(AttributeTargets.All, Inherited = false)]
    public class ObfuscatedNameAttribute : Attribute
    {
        public readonly string ObfuscatedName;
        
        public ObfuscatedNameAttribute(string obfuscatedName)
        {
            ObfuscatedName = obfuscatedName;
        }
    }
}
```

`UnhollowerBaseLib/ClassInjector.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using UnhollowerBaseLib;
using UnhollowerBaseLib.Attributes;
using UnhollowerBaseLib.Runtime;
using UnhollowerBaseLib.Runtime.VersionSpecific.Assembly;
using UnhollowerBaseLib.Runtime.VersionSpecific.Class;
using UnhollowerBaseLib.Runtime.VersionSpecific.Image;
using UnhollowerRuntimeLib.XrefScans;
using Void = Il2CppSystem.Void;

namespace UnhollowerRuntimeLib
{
    public unsafe static class ClassInjector
    {
        private static INativeAssemblyStruct FakeAssembly;
        private static INativeImageStruct FakeImage;

        /// <summary> type.FullName </summary>
        private static readonly HashSet<string> InjectedTypes = new HashSet<string>();
        /// <summary> (namespace, class, image) : pointer </summary>
        private static readonly Dictionary<(string, string, IntPtr), IntPtr> ClassFromNameDictionary = new Dictionary<(string, string, IntPtr), IntPtr>();
        /// <summary> (method) : (method_inst, method) </summary>
        private static readonly Dictionary<IntPtr, (MethodInfo, Dictionary<IntPtr, IntPtr>)> InflatedMethodFromContextDictionary = new Dictionary<IntPtr, (MethodInfo, Dictionary<IntPtr, IntPtr>)>();

        static void CreateFakeAssembly()
        {
            FakeAssembly = UnityVersionHandler.NewAssembly();
            FakeImage = UnityVersionHandler.NewImage();

            FakeAssembly.Name = Marshal.StringToHGlobalAnsi("InjectedMonoTypes");

            FakeImage.Assembly = FakeAssembly.AssemblyPointer;
            FakeImage.Dynamic = 1;
            FakeImage.Name = FakeAssembly.Name;
            if (FakeImage.HasNameNoExt)
                FakeImage.NameNoExt = FakeImage.Name;
        }

        public static void ProcessNewObject(Il2CppObjectBase obj)
        {
            var pointer = obj.Pointer;
            var handle = GCHandle.Alloc(obj, GCHandleType.Normal);
            AssignGcHandle(pointer, handle);
        }

        public static IntPtr DerivedConstructorPointer<T>()
        {
            return IL2CPP.il2cpp_object_new(Il2CppClassPointerStore<T>.NativeClassPtr); // todo: consider calling base constructor
        }

        public static void DerivedConstructorBody(Il2CppObjectBase objectBase)
        {
            var ownGcHandle = GCHandle.Alloc(objectBase, GCHandleType.Normal);
            AssignGcHandle(objectBase.Pointer, ownGcHandle);
        }

        public static void AssignGcHandle(IntPtr pointer, GCHandle gcHandle)
        {
            var handleAsPointer = GCHandle.ToIntPtr(gcHandle);
            if (pointer == IntPtr.Zero) throw new NullReferenceException(nameof(pointer));
            var objectKlass = (Il2CppClass*)IL2CPP.il2cpp_object_get_class(pointer);
            var targetGcHandlePointer = IntPtr.Add(pointer, (int)UnityVersionHandler.Wrap(objectKlass).InstanceSize - IntPtr.Size);
            *(IntPtr*)targetGcHandlePointer = handleAsPointer;
        }

        public static void RegisterTypeInIl2Cpp<T>() where T : class => RegisterTypeInIl2CppImpl(typeof(T), true, Array.Empty<INativeClassStruct>());
        public static void RegisterTypeInIl2Cpp<T>(bool logSuccess) where T : class => RegisterTypeInIl2CppImpl(typeof(T), logSuccess, Array.Empty<INativeClassStruct>());
        public static void RegisterTypeInIl2Cpp(Type type, bool logSuccess) => RegisterTypeInIl2CppImpl(type, logSuccess, Array.Empty<INativeClassStruct>());
        public static void RegisterTypeInIl2CppWithInterfaces<T>(params Type[] interfaces) where T : class => RegisterTypeInIl2CppWithInterfaces(typeof(T), true, interfaces);
        public static void RegisterTypeInIl2CppWithInterfaces<T>(bool logSuccess, params Type[] interfaces) where T : class => RegisterTypeInIl2CppWithInterfaces(typeof(T), logSuccess, interfaces);
        public static void RegisterTypeInIl2CppWithInterfaces(Type type, bool logSuccess, params Type[] interfaces)
        {
            RegisterTypeInIl2CppImpl(type, logSuccess, interfaces.Select(it =>
            {
                var classPointer = ReadClassPointerForType(it);
                if (classPointer == IntPtr.Zero)
                    throw new ArgumentException($"Type {it} doesn't have an IL2CPP class pointer, which means it's not an IL2CPP interface");
                return UnityVersionHandler.Wrap((Il2CppClass*)classPointer);
            }).ToArray());
        }
        
        public static void RegisterTypeInIl2CppImpl(Type type, bool logSuccess, params INativeClassStruct[] interfaces)
        {
            if(type == null)
                throw new ArgumentException($"Type argument cannot be null");

            if (type.IsGenericType || type.IsGenericTypeDefinition)
                throw new ArgumentException($"Type {type} is generic and can't be used in il2cpp");

            var currentPointer = ReadClassPointerForType(type);
            if (currentPointer != IntPtr.Zero)
                return;//already registered in il2cpp

            var baseType = type.BaseType;
            if (baseType == null)
                throw new ArgumentException($"Class {type} does not inherit from a class registered in il2cpp");

            var baseClassPointer = UnityVersionHandler.Wrap((Il2CppClass*)ReadClassPointerForType(baseType));
            if (baseClassPointer == null)
            {
                RegisterTypeInIl2Cpp(baseType, logSuccess);
                baseClassPointer = UnityVersionHandler.Wrap((Il2CppClass*)ReadClassPointerForType(baseType));
            }

            if (baseClassPointer.ValueType || baseClassPointer.EnumType)
                throw new ArgumentException($"Base class {baseType} is value type and can't be inherited from");

            if (baseClassPointer.IsGeneric)
                throw new ArgumentException($"Base class {baseType} is generic and can't be inherited from");

            if ((baseClassPointer.Flags & Il2CppClassAttributes.TYPE_ATTRIBUTE_SEALED) != 0)
                throw new ArgumentException($"Base class {baseType} is sealed and can't be inherited from");

            if ((baseClassPointer.Flags & Il2CppClassAttributes.TYPE_ATTRIBUTE_INTERFACE) != 0)
                throw new ArgumentException($"Base class {baseType} is an interface and can't be inherited from");

            if (interfaces.Any(i => (i.Flags & Il2CppClassAttributes.TYPE_ATTRIBUTE_INTERFACE) == 0))
                throw new ArgumentException($"Interfaces {interfaces} are not interfaces");

            lock (InjectedTypes)
                if (!InjectedTypes.Add(type.FullName))
                    throw new ArgumentException($"Type with FullName {type.FullName} is already injected. Don't inject the same type twice, or use a different namespace");

            if (ourOriginalGenericGetMethod == null) HookGenericMethodGetMethod();
            if (ourOriginalTypeToClassMethod == null) HookClassFromType();
            if (originalClassFromNameMethod == null) HookClassFromName();
            if (FakeAssembly == null) CreateFakeAssembly();

            var interfaceFunctionCount = interfaces.Sum(i => i.MethodCount);
            var classPointer = UnityVersionHandler.NewClass(baseClassPointer.VtableCount + interfaceFunctionCount);

            classPointer.Image = FakeImage.ImagePointer;
            classPointer.Parent = baseClassPointer.ClassPointer;
            classPointer.ElementClass = classPointer.Class = classPointer.CastClass = classPointer.ClassPointer;
            classPointer.NativeSize = -1;
            classPointer.ActualSize = classPointer.InstanceSize = baseClassPointer.InstanceSize + (uint)IntPtr.Size;

            classPointer.Initialized = true;
            classPointer.InitializedAndNoError = true;
            classPointer.SizeInited = true;
            classPointer.HasFinalize = true;
            classPointer.IsVtableInitialized = true;

            classPointer.Name = Marshal.StringToHGlobalAnsi(type.Name);
            classPointer.Namespace = Marshal.StringToHGlobalAnsi(type.Namespace);

            classPointer.ThisArg.Type = classPointer.ByValArg.Type = Il2CppTypeEnum.IL2CPP_TYPE_CLASS;
            classPointer.ThisArg.ByRef = true;

            classPointer.Flags = baseClassPointer.Flags; // todo: adjust flags?

            var eligibleMethods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly).Where(IsMethodEligible).ToArray();
            var methodCount = 2 + eligibleMethods.Length; // 1 is the finalizer, 1 is empty ctor

            classPointer.MethodCount = (ushort)methodCount;
            var methodPointerArray = (Il2CppMethodInfo**)Marshal.AllocHGlobal(methodCount * IntPtr.Size);
            classPointer.Methods = methodPointerArray;

            methodPointerArray[0] = ConvertStaticMethod(FinalizeDelegate, "Finalize", classPointer);
            var finalizeMethod = UnityVersionHandler.Wrap(methodPointerArray[0]);
            methodPointerArray[1] = ConvertStaticMethod(CreateEmptyCtor(type), ".ctor", classPointer);
            Dictionary<(string name, int paramCount, bool isGeneric), int> infos = new Dictionary<(string, int, bool), int>(eligibleMethods.Length);
            for (var i = 0; i < eligibleMethods.Length; i++)
            {
                var methodInfo = eligibleMethods[i];
                var methodInfoPointer = methodPointerArray[i + 2] = ConvertMethodInfo(methodInfo, classPointer);
                if (methodInfo.IsGenericMethod)
                    InflatedMethodFromContextDictionary.Add((IntPtr)methodInfoPointer, (methodInfo, new Dictionary<IntPtr, IntPtr>()));
                var methodName = methodInfo.Name;
                infos[(methodInfo.Name, methodInfo.GetParameters().Length, methodInfo.IsGenericMethod)] = i + 2;
            }

            var vTablePointer = (VirtualInvokeData*)classPointer.VTable;
            var baseVTablePointer = (VirtualInvokeData*)baseClassPointer.VTable;
            classPointer.VtableCount = (ushort)(baseClassPointer.VtableCount + interfaceFunctionCount);
            for (var i = 0; i < baseClassPointer.VtableCount; i++)
            {
                vTablePointer[i] = baseVTablePointer[i];
                var vTableMethod = UnityVersionHandler.Wrap(vTablePointer[i].method);
                if (Marshal.PtrToStringAnsi(vTableMethod.Name) == "Finalize") // slot number is not static
                {
                    vTablePointer[i].method = methodPointerArray[0];
                    vTablePointer[i].methodPtr = finalizeMethod.MethodPointer;
                }
            }

            var offsets = new int[interfaces.Length];

            var index = baseClassPointer.VtableCount;
            for (var i = 0; i < interfaces.Length; i++)
            {
                offsets[i] = index;
                for (var j = 0; j < interfaces[i].MethodCount; j++)
                {
                    var vTableMethod = UnityVersionHandler.Wrap(interfaces[i].Methods[j]);
                    var methodName = Marshal.PtrToStringAnsi(vTableMethod.Name);
                    if (!infos.TryGetValue((methodName, vTableMethod.ParametersCount, vTableMethod.IsGeneric), out var methodIndex))
                    {
                        ++index;
                        continue;
                    }
                    var method = methodPointerArray[methodIndex];
                    vTablePointer[index].method = method;
                    vTablePointer[index].methodPtr = UnityVersionHandler.Wrap(method).MethodPointer;
                    ++index;
                }
            }

            var interfaceCount = baseClassPointer.InterfaceCount + interfaces.Length;
            classPointer.InterfaceCount = (ushort)interfaceCount;
            classPointer.ImplementedInterfaces = (Il2CppClass**)Marshal.AllocHGlobal(interfaceCount * IntPtr.Size);
            for (int i = 0; i < baseClassPointer.InterfaceCount; i++)
                classPointer.ImplementedInterfaces[i] = baseClassPointer.ImplementedInterfaces[i];
            for (int i = baseClassPointer.InterfaceCount; i < interfaceCount; i++)
                classPointer.ImplementedInterfaces[i] = interfaces[i - baseClassPointer.InterfaceCount].ClassPointer;

            var interfaceOffsetsCount = baseClassPointer.InterfaceOffsetsCount + interfaces.Length;
            classPointer.InterfaceOffsetsCount = (ushort)interfaceOffsetsCount;
            classPointer.InterfaceOffsets = (Il2CppRuntimeInterfaceOffsetPair*)Marshal.AllocHGlobal(interfaceOffsetsCount * Marshal.SizeOf<Il2CppRuntimeInterfaceOffsetPair>());
            for (int i = 0; i < baseClassPointer.InterfaceOffsetsCount; i++)
                classPointer.InterfaceOffsets[i] = baseClassPointer.InterfaceOffsets[i];
            for (int i = baseClassPointer.InterfaceOffsetsCount; i < interfaceOffsetsCount; i++)
                classPointer.InterfaceOffsets[i] = new Il2CppRuntimeInterfaceOffsetPair {
                    interfaceType = interfaces[i - baseClassPointer.InterfaceOffsetsCount].ClassPointer,
                    offset = offsets[i - baseClassPointer.InterfaceOffsetsCount]
                };

            var TypeHierarchyDepth = 1 + baseClassPointer.TypeHierarchyDepth;
            classPointer.TypeHierarchyDepth = (byte)TypeHierarchyDepth;
            classPointer.TypeHierarchy = (Il2CppClass**)Marshal.AllocHGlobal(TypeHierarchyDepth * IntPtr.Size);
            for (var i = 0; i < TypeHierarchyDepth; i++)
                classPointer.TypeHierarchy[i] = baseClassPointer.TypeHierarchy[i];
            classPointer.TypeHierarchy[TypeHierarchyDepth - 1] = classPointer.ClassPointer;

            var newCounter = Interlocked.Decrement(ref ourClassOverrideCounter);
            FakeTokenClasses[newCounter] = classPointer.Pointer;
            classPointer.ByValArg.Data = classPointer.ThisArg.Data = (IntPtr)newCounter;

            RuntimeSpecificsStore.SetClassInfo(classPointer.Pointer, true, true);
            WriteClassPointerForType(type, classPointer.Pointer);

            AddToClassFromNameDictionary(type, classPointer.Pointer);

            if (logSuccess) LogSupport.Info($"Registered mono type {type} in il2cpp domain");
        }

        private static void AddToClassFromNameDictionary<T>(IntPtr typePointer) where T : class => AddToClassFromNameDictionary(typeof(T), typePointer);
        private static void AddToClassFromNameDictionary(Type type, IntPtr typePointer)
        {
            string klass = type.Name;
            if (klass == null) return;
            string namespaze = type.Namespace ?? string.Empty;
            var attribute = Attribute.GetCustomAttribute(type, typeof(UnhollowerBaseLib.Attributes.ClassInjectionAssemblyTargetAttribute)) as UnhollowerBaseLib.Attributes.ClassInjectionAssemblyTargetAttribute;

            foreach (IntPtr image in ((attribute is null) ? IL2CPP.GetIl2CppImages() : attribute.GetImagePointers()) )
            {
                ClassFromNameDictionary.Add((namespaze, klass, image), typePointer);
            }
        }

        internal static IntPtr ReadClassPointerForType(Type type)
        {
            if (type == typeof(void)) return Il2CppClassPointerStore<Void>.NativeClassPtr;
            return (IntPtr)typeof(Il2CppClassPointerStore<>).MakeGenericType(type)
                .GetField(nameof(Il2CppClassPointerStore<int>.NativeClassPtr)).GetValue(null);
        }

        internal static void WriteClassPointerForType(Type type, IntPtr value)
        {
            typeof(Il2CppClassPointerStore<>).MakeGenericType(type)
                .GetField(nameof(Il2CppClassPointerStore<int>.NativeClassPtr)).SetValue(null, value);
        }

        private static bool IsTypeSupported(Type type)
        {
            if (type.IsValueType ||
                type == typeof(string) ||
                type.IsGenericParameter) return true;
            if (typeof(Il2CppSystem.ValueType).IsAssignableFrom(type)) return false;

            return typeof(Il2CppObjectBase).IsAssignableFrom(type);
        }

        private static bool IsMethodEligible(MethodInfo method)
        {
            if (method.Name == "Finalize") return false;
            if (method.IsStatic || method.IsAbstract) return false;
            if (method.CustomAttributes.Any(it => it.AttributeType == typeof(HideFromIl2CppAttribute))) return false;

            if (
                method.DeclaringType != null &&
                method.DeclaringType.GetProperties()
                    .Where(property => property.GetAccessors(true).Contains(method))
                    .Any(property => property.CustomAttributes.Any(it => it.AttributeType == typeof(HideFromIl2CppAttribute)))
            )
            {
                return false;
            }

            if (!IsTypeSupported(method.ReturnType))
            {
                LogSupport.Warning($"Method {method} on type {method.DeclaringType} has unsupported return type {method.ReturnType}");
                return false;
            }

            foreach (var parameter in method.GetParameters())
            {
                var parameterType = parameter.ParameterType;
                if (!IsTypeSupported(parameterType))
                {
                    LogSupport.Warning($"Method {method} on type {method.DeclaringType} has unsupported parameter {parameter} of type {parameterType}");
                    return false;
                }
            }

            return true;
        }

        private static Il2CppMethodInfo* ConvertStaticMethod(VoidCtorDelegate voidCtor, string methodName, INativeClassStruct declaringClass)
        {
            var converted = UnityVersionHandler.NewMethod();
            converted.Name = Marshal.StringToHGlobalAnsi(methodName);
            converted.Class = declaringClass.ClassPointer;

            converted.InvokerMethod = Marshal.GetFunctionPointerForDelegate(new InvokerDelegate(StaticVoidIntPtrInvoker));
            converted.MethodPointer = Marshal.GetFunctionPointerForDelegate(voidCtor);
            converted.Slot = ushort.MaxValue;
            converted.ReturnType = (Il2CppTypeStruct*)IL2CPP.il2cpp_class_get_type(Il2CppClassPointerStore<Void>.NativeClassPtr);

            converted.Flags = Il2CppMethodFlags.METHOD_ATTRIBUTE_PUBLIC |
                               Il2CppMethodFlags.METHOD_ATTRIBUTE_HIDE_BY_SIG | Il2CppMethodFlags.METHOD_ATTRIBUTE_SPECIAL_NAME | Il2CppMethodFlags.METHOD_ATTRIBUTE_RT_SPECIAL_NAME;

            return converted.MethodInfoPointer;
        }

        private static Il2CppMethodInfo* ConvertMethodInfo(MethodInfo monoMethod, INativeClassStruct declaringClass)
        {
            var converted = UnityVersionHandler.NewMethod();
            converted.Name = Marshal.StringToHGlobalAnsi(monoMethod.Name);
            converted.Class = declaringClass.ClassPointer;

            var parameters = monoMethod.GetParameters();
            if (parameters.Length > 0)
            {
                converted.ParametersCount = (byte)parameters.Length;
                var paramsArray = UnityVersionHandler.NewMethodParameterArray(parameters.Length);
                converted.Parameters = paramsArray[0];
                for (var i = 0; i < parameters.Length; i++)
                {
                    var parameterInfo = parameters[i];
                    var param = UnityVersionHandler.Wrap(paramsArray[i]);
                    if (UnityVersionHandler.ParameterInfoHasNamePosToken())
                    {
                        param.Name = Marshal.StringToHGlobalAnsi(parameterInfo.Name);
                        param.Position = i;
                        param.Token = 0;
                    }
                    var parameterType = parameterInfo.ParameterType;
                    if (!parameterType.IsGenericParameter)
                        param.ParameterType = (Il2CppTypeStruct*)IL2CPP.il2cpp_class_get_type(ReadClassPointerForType(parameterType));
                    else
                    {
                        var type = UnityVersionHandler.NewType();
                        type.Type = Il2CppTypeEnum.IL2CPP_TYPE_MVAR;
                        param.ParameterType = type.TypePointer;
                    }
                }
            }

            if (monoMethod.IsGenericMethod)
            {
                if (monoMethod.ContainsGenericParameters)
                    converted.IsGeneric = true;
                else
                    converted.IsInflated = true;
            }

            if (!monoMethod.ContainsGenericParameters)
            {
                converted.InvokerMethod = Marshal.GetFunctionPointerForDelegate(GetOrCreateInvoker(monoMethod));
                converted.MethodPointer = Marshal.GetFunctionPointerForDelegate(GetOrCreateTrampoline(monoMethod));
            }
            converted.Slot = ushort.MaxValue;

            if (!monoMethod.ReturnType.IsGenericParameter)
                converted.ReturnType = (Il2CppTypeStruct*)IL2CPP.il2cpp_class_get_type(ReadClassPointerForType(monoMethod.ReturnType));
            else
            {
                var type = UnityVersionHandler.NewType();
                type.Type = Il2CppTypeEnum.IL2CPP_TYPE_MVAR;
                converted.ReturnType = type.TypePointer;
            }

            converted.Flags = Il2CppMethodFlags.METHOD_ATTRIBUTE_PUBLIC |
                               Il2CppMethodFlags.METHOD_ATTRIBUTE_HIDE_BY_SIG;

            return converted.MethodInfoPointer;
        }

        private static VoidCtorDelegate CreateEmptyCtor(Type targetType)
        {
            var method = new DynamicMethod("FromIl2CppCtorDelegate", MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, typeof(void), new[] { typeof(IntPtr) }, targetType, true);

            var body = method.GetILGenerator();

            body.Emit(OpCodes.Ldarg_0);
            body.Emit(OpCodes.Newobj, targetType.GetConstructor(new[] { typeof(IntPtr) })!);
            body.Emit(OpCodes.Call, typeof(ClassInjector).GetMethod(nameof(ProcessNewObject))!);

            body.Emit(OpCodes.Ret);

            var @delegate = (VoidCtorDelegate)method.CreateDelegate(typeof(VoidCtorDelegate));
            GCHandle.Alloc(@delegate); // pin it forever
            return @delegate;
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate IntPtr InvokerDelegate(IntPtr methodPointer, Il2CppMethodInfo* methodInfo, IntPtr obj, IntPtr* args);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate Il2CppClass* TypeToClassDelegate(Il2CppTypeStruct* type);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate void VoidCtorDelegate(IntPtr objectPointer);

        public static void Finalize(IntPtr ptr)
        {
            var gcHandle = ClassInjectorBase.GetGcHandlePtrFromIl2CppObject(ptr);
            GCHandle.FromIntPtr(gcHandle).Free();
        }

        private static readonly ConcurrentDictionary<string, InvokerDelegate> InvokerCache = new ConcurrentDictionary<string, InvokerDelegate>();

        private static InvokerDelegate GetOrCreateInvoker(MethodInfo monoMethod)
        {
            return InvokerCache.GetOrAdd(ExtractSignature(monoMethod), (_, monoMethodInner) => CreateInvoker(monoMethodInner), monoMethod);
        }

        private static Delegate GetOrCreateTrampoline(MethodInfo monoMethod)
        {
            return CreateTrampoline(monoMethod);
        }

        private static InvokerDelegate CreateInvoker(MethodInfo monoMethod)
        {
            var parameterTypes = new[] { typeof(IntPtr), typeof(Il2CppMethodInfo*), typeof(IntPtr), typeof(IntPtr*) };

            var method = new DynamicMethod("Invoker_" + ExtractSignature(monoMethod), MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, typeof(IntPtr), parameterTypes, monoMethod.DeclaringType, true);

            var body = method.GetILGenerator();

            body.Emit(OpCodes.Ldarg_2);
            for (var i = 0; i < monoMethod.GetParameters().Length; i++)
            {
                var parameterInfo = monoMethod.GetParameters()[i];
                body.Emit(OpCodes.Ldarg_3);
                body.Emit(OpCodes.Ldc_I4, i * IntPtr.Size);
                body.Emit(OpCodes.Add_Ovf_Un);
                var nativeType = parameterInfo.ParameterType.NativeType();
                body.Emit(OpCodes.Ldobj, typeof(IntPtr));
                if (nativeType != typeof(IntPtr))
                    body.Emit(OpCodes.Ldobj, nativeType);
            }

            body.Emit(OpCodes.Ldarg_0);
            body.EmitCalli(OpCodes.Calli, CallingConvention.Cdecl, monoMethod.ReturnType.NativeType(), new[] { typeof(IntPtr) }.Concat(monoMethod.GetParameters().Select(it => it.ParameterType.NativeType())).ToArray());

            if (monoMethod.ReturnType == typeof(void))
            {
                body.Emit(OpCodes.Ldc_I4_0);
                body.Emit(OpCodes.Conv_I);
            }
            else if (monoMethod.ReturnType.IsValueType)
            {
                var returnValue = body.DeclareLocal(monoMethod.ReturnType);
                body.Emit(OpCodes.Stloc, returnValue);
                var classField = typeof(Il2CppClassPointerStore<>).MakeGenericType(monoMethod.ReturnType)
                                                                  .GetField(nameof(Il2CppClassPointerStore<int>.NativeClassPtr));
                body.Emit(OpCodes.Ldsfld, classField);
                body.Emit(OpCodes.Ldloca, returnValue);
                body.Emit(OpCodes.Call, typeof(IL2CPP).GetMethod(nameof(IL2CPP.il2cpp_value_box))!);
            }

            body.Emit(OpCodes.Ret);

            return (InvokerDelegate)method.CreateDelegate(typeof(InvokerDelegate));
        }

        private static IntPtr StaticVoidIntPtrInvoker(IntPtr methodPointer, Il2CppMethodInfo* methodInfo, IntPtr obj, IntPtr* args)
        {
            Marshal.GetDelegateForFunctionPointer<VoidCtorDelegate>(methodPointer)(obj);
            return IntPtr.Zero;
        }

        private static Delegate CreateTrampoline(MethodInfo monoMethod)
        {
            var nativeParameterTypes = new[] { typeof(IntPtr) }.Concat(monoMethod.GetParameters()
                .Select(it => it.ParameterType.NativeType()).Concat(new[] { typeof(Il2CppMethodInfo*) })).ToArray();

            var managedParameters = new[] { monoMethod.DeclaringType }.Concat(monoMethod.GetParameters().Select(it => it.ParameterType)).ToArray();

            var method = new DynamicMethod("Trampoline_" + ExtractSignature(monoMethod) + monoMethod.DeclaringType + monoMethod.Name,
                MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard,
                monoMethod.ReturnType.NativeType(), nativeParameterTypes,
                monoMethod.DeclaringType, true);

            var signature = new DelegateSupport.MethodSignature(monoMethod, true);
            var delegateType = DelegateSupport.GetOrCreateDelegateType(signature, monoMethod);

            var body = method.GetILGenerator();

            body.BeginExceptionBlock();

            body.Emit(OpCodes.Ldarg_0);
            body.Emit(OpCodes.Call, typeof(ClassInjectorBase).GetMethod(nameof(ClassInjectorBase.GetMonoObjectFromIl2CppPointer))!);
            body.Emit(OpCodes.Castclass, monoMethod.DeclaringType);

            for (var i = 1; i < managedParameters.Length; i++)
            {
                body.Emit(OpCodes.Ldarg, i);
                var parameter = managedParameters[i];
                if (!parameter.IsValueType)
                {
                    if (parameter == typeof(string))
                        body.Emit(OpCodes.Call, typeof(IL2CPP).GetMethod(nameof(IL2CPP.Il2CppStringToManaged))!);
                    else
                    {
                        var labelNull = body.DefineLabel();
                        var labelNotNull = body.DefineLabel();
                        body.Emit(OpCodes.Dup);
                        body.Emit(OpCodes.Brfalse, labelNull);
                        body.Emit(OpCodes.Newobj, parameter.GetConstructor(new[] { typeof(IntPtr) })!);
                        body.Emit(OpCodes.Br, labelNotNull);
                        body.MarkLabel(labelNull);
                        body.Emit(OpCodes.Pop);
                        body.Emit(OpCodes.Ldnull);
                        body.MarkLabel(labelNotNull);
                    }
                }
            }

            body.Emit(OpCodes.Call, monoMethod);
            if (monoMethod.ReturnType == typeof(void))
            {
                // do nothing
            }
            else if (monoMethod.ReturnType == typeof(string))
            {
                body.Emit(OpCodes.Call, typeof(IL2CPP).GetMethod(nameof(IL2CPP.ManagedStringToIl2Cpp))!);
            }
            else if (!monoMethod.ReturnType.IsValueType)
            {
                body.Emit(OpCodes.Call, typeof(IL2CPP).GetMethod(nameof(IL2CPP.Il2CppObjectBaseToPtr))!);
            }
            body.Emit(OpCodes.Ret);

            var exceptionLocal = body.DeclareLocal(typeof(Exception));
            body.BeginCatchBlock(typeof(Exception));
            body.Emit(OpCodes.Stloc, exceptionLocal);
            body.Emit(OpCodes.Ldstr, "Exception in IL2CPP-to-Managed trampoline, not passing it to il2cpp: ");
            body.Emit(OpCodes.Ldloc, exceptionLocal);
            body.Emit(OpCodes.Callvirt, typeof(object).GetMethod(nameof(ToString))!);
            body.Emit(OpCodes.Call, typeof(string).GetMethod(nameof(string.Concat), new[] { typeof(string), typeof(string) })!);
            body.Emit(OpCodes.Call, typeof(LogSupport).GetMethod(nameof(LogSupport.Error))!);

            body.EndExceptionBlock();

            if (monoMethod.ReturnType != typeof(void))
            {
                if (monoMethod.ReturnType.IsValueType)
                {
                    if(monoMethod.ReturnType.IsPrimitive)
                    { 
                        if(monoMethod.ReturnType == typeof(float))
                            body.Emit(OpCodes.Ldc_R4, 0);
                        else if (monoMethod.ReturnType == typeof(double))
                            body.Emit(OpCodes.Ldc_R8, 0);
                        else
                        {
                            body.Emit(OpCodes.Ldc_I4_0);
                            if(monoMethod.ReturnType == typeof(long) || monoMethod.ReturnType == typeof(ulong))
                            {
                                body.Emit(OpCodes.Conv_I8);
                            }
                        }
                    }
                    else
                    {
                        var local = body.DeclareLocal(monoMethod.ReturnType);

                        body.Emit(OpCodes.Ldloca_S, local);
                        body.Emit(OpCodes.Initobj, monoMethod.ReturnType);
                        body.Emit(OpCodes.Ldloc_S, local);
                    }
                } else {
                    body.Emit(OpCodes.Ldc_I4_0);
                    body.Emit(OpCodes.Conv_I);
                }
            }
            body.Emit(OpCodes.Ret);

            var @delegate = method.CreateDelegate(delegateType);
            GCHandle.Alloc(@delegate); // pin it forever
            return @delegate;
        }

        private static string ExtractSignature(MethodInfo monoMethod)
        {
            var builder = new StringBuilder();
            builder.Append(monoMethod.ReturnType.NativeType().Name);
            builder.Append(monoMethod.IsStatic ? "" : "This");
            foreach (var parameterInfo in monoMethod.GetParameters())
                builder.Append(parameterInfo.ParameterType.NativeType().Name);
            return builder.ToString();
        }

        private static Type NativeType(this Type type)
        {
            return type.IsValueType ? type : typeof(IntPtr);
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate Il2CppMethodInfo* GenericGetMethodDelegate(Il2CppGenericMethod* gmethod, bool copyMethodPtr);
        private static volatile GenericGetMethodDelegate ourOriginalGenericGetMethod;

        private static void HookGenericMethodGetMethod()
        {
            var lib = LoadLibrary("GameAssembly.dll");
            var getVirtualMethodEntryPoint = GetProcAddress(lib, nameof(IL2CPP.il2cpp_object_get_virtual_method));
            LogSupport.Trace($"il2cpp_object_get_virtual_method entry address: {getVirtualMethodEntryPoint}");

            var getVirtualMethodMethod = XrefScannerLowLevel.JumpTargets(getVirtualMethodEntryPoint).Single();
            LogSupport.Trace($"Xref scan target 1: {getVirtualMethodMethod}");

            var targetMethod = XrefScannerLowLevel.JumpTargets(getVirtualMethodMethod).Last();
            LogSupport.Trace($"Xref scan target 2: {targetMethod}");

            if (targetMethod == IntPtr.Zero)
                return;

            var targetTargets = XrefScannerLowLevel.JumpTargets(targetMethod).Take(2).ToList();
            if (targetTargets.Count == 1) // U2021.2.0+, there's additional shim that takes 3 parameters
                targetMethod = targetTargets[0];

            ourOriginalGenericGetMethod = Detour.Detour(targetMethod, new GenericGetMethodDelegate(GenericGetMethodPatch));
            LogSupport.Trace("il2cpp_class_from_il2cpp_type patched");
        }

        private static System.Type SystemTypeFromIl2CppType(Il2CppTypeStruct *typePointer)
        {
            var klass = UnityVersionHandler.Wrap(ClassFromTypePatch(typePointer));
            var fullName = Marshal.PtrToStringAnsi(klass.Namespace) + "." + Marshal.PtrToStringAnsi(klass.Name);
            if (fullName == "System.String")
                return typeof(string);

            var type = Type.GetType(fullName);
            if (type.IsValueType)
                return type;

            if (fullName.StartsWith("System"))
                fullName = "Il2Cpp" + fullName;
            var systemType = AppDomain.CurrentDomain.GetAssemblies()
                                .SelectMany(a => a.GetTypes())
                                .First(t => t.FullName == fullName);
            return systemType;
        }

        private static Il2CppMethodInfo* GenericGetMethodPatch(Il2CppGenericMethod* gmethod, bool copyMethodPtr)
        {
            if (InflatedMethodFromContextDictionary.TryGetValue((IntPtr)gmethod->methodDefinition, out var methods))
            {
                var instancePointer = gmethod->context.method_inst;
                if (methods.Item2.TryGetValue((IntPtr)instancePointer, out var inflatedMethodPointer))
                    return (Il2CppMethodInfo*)inflatedMethodPointer;

                var typeArguments = new Type[instancePointer->type_argc];
                for (var i = 0; i < instancePointer->type_argc; i++)
                    typeArguments[i] = SystemTypeFromIl2CppType(instancePointer->type_argv[i]);
                var inflatedMethod = methods.Item1.MakeGenericMethod(typeArguments);
                LogSupport.Trace("Inflated method: " + inflatedMethod.Name);
                inflatedMethodPointer = (IntPtr)ConvertMethodInfo(inflatedMethod, UnityVersionHandler.Wrap(UnityVersionHandler.Wrap(gmethod->methodDefinition).Class));
                methods.Item2.Add((IntPtr)instancePointer, inflatedMethodPointer);

                return (Il2CppMethodInfo*)inflatedMethodPointer;
            }
            return ourOriginalGenericGetMethod(gmethod, copyMethodPtr);
        }

        private static void HookClassFromType()
        {
            var lib = LoadLibrary("GameAssembly.dll");
            var classFromTypeEntryPoint = GetProcAddress(lib, nameof(IL2CPP.il2cpp_class_from_il2cpp_type));
            LogSupport.Trace($"il2cpp_class_from_il2cpp_type entry address: {classFromTypeEntryPoint}");

            var targetMethod = XrefScannerLowLevel.JumpTargets(classFromTypeEntryPoint).Single();
            LogSupport.Trace($"Xref scan target: {targetMethod}");

            if (targetMethod == IntPtr.Zero)
                return;

            ourOriginalTypeToClassMethod = Detour.Detour(targetMethod, new TypeToClassDelegate(ClassFromTypePatch));
            LogSupport.Trace("il2cpp_class_from_il2cpp_type patched");
        }


        public static IManagedDetour Detour = new DoHookDetour();
        [Obsolete("Set Detour instead")]
        public static Action<IntPtr, IntPtr> DoHook;

        private static long ourClassOverrideCounter = -2;
        private static readonly ConcurrentDictionary<long, IntPtr> FakeTokenClasses = new ConcurrentDictionary<long, IntPtr>();

        private static volatile TypeToClassDelegate ourOriginalTypeToClassMethod;
        private static readonly VoidCtorDelegate FinalizeDelegate = Finalize;

        private static Il2CppClass* ClassFromTypePatch(Il2CppTypeStruct* type)
        {
            var wrappedType = UnityVersionHandler.Wrap(type);
            if ((long)wrappedType.Data < 0 && (wrappedType.Type == Il2CppTypeEnum.IL2CPP_TYPE_CLASS || wrappedType.Type == Il2CppTypeEnum.IL2CPP_TYPE_VALUETYPE))
            {
                FakeTokenClasses.TryGetValue((long)wrappedType.Data, out var classPointer);
                return (Il2CppClass*)classPointer;
            }
            // possible race: other threads can try resolving classes after the hook is installed but before delegate field is set
            while (ourOriginalTypeToClassMethod == null) Thread.Sleep(1);
            return ourOriginalTypeToClassMethod(type);
        }

        #region Class From Name Patch
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate IntPtr ClassFromNameDelegate(IntPtr intPtr, IntPtr str1, IntPtr str2);

        private static ClassFromNameDelegate originalClassFromNameMethod;
        private static readonly ClassFromNameDelegate hookedClassFromName = new ClassFromNameDelegate(ClassFromNamePatch);

        private static void HookClassFromName()
        {
            var lib = LoadLibrary("GameAssembly.dll");
            var classFromNameEntryPoint = GetProcAddress(lib, nameof(IL2CPP.il2cpp_class_from_name));
            LogSupport.Trace($"il2cpp_class_from_name entry address: {classFromNameEntryPoint}");

            if (classFromNameEntryPoint == IntPtr.Zero) return;

            originalClassFromNameMethod = Detour.Detour(classFromNameEntryPoint, hookedClassFromName);
            LogSupport.Trace("il2cpp_class_from_name patched");
        }

        private static IntPtr ClassFromNamePatch(IntPtr param1, IntPtr param2, IntPtr param3)
        {
            try
            {
                // possible race: other threads can try resolving classes after the hook is installed but before delegate field is set
                while (originalClassFromNameMethod == null) Thread.Sleep(1);
                IntPtr intPtr = originalClassFromNameMethod.Invoke(param1, param2, param3);

                if (intPtr == IntPtr.Zero)
                {
                    string namespaze = Marshal.PtrToStringAnsi(param2);
                    string klass = Marshal.PtrToStringAnsi(param3);
                    ClassFromNameDictionary.TryGetValue((namespaze, klass, param1),out intPtr);
                }

                return intPtr;
            }
            catch (Exception e)
            {
                LogSupport.Error(e.Message);
                return IntPtr.Zero;
            }
        }
        #endregion

        [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
        static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        [DllImport("kernel32", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string lpFileName);

        private class DoHookDetour : IManagedDetour
        {
            // In some cases garbage collection of delegates can release their native function pointer too - keep all of them alive to avoid that
            // ReSharper disable once CollectionNeverQueried.Local
            private static readonly List<object> PinnedDelegates = new List<object>();

            public T Detour<T>(IntPtr @from, T to) where T : Delegate
            {
                IntPtr* targetVarPointer = &from;
                PinnedDelegates.Add(to);
                DoHook((IntPtr)targetVarPointer, Marshal.GetFunctionPointerForDelegate(to));
                return Marshal.GetDelegateForFunctionPointer<T>(from);
            }
        }
    }

    public interface IManagedDetour
    {
        /// <summary>
        /// Patch the native function at address specified in `from`, replacing it with `to`, and return a delegate to call the original native function
        /// </summary>
        T Detour<T>(IntPtr from, T to) where T : Delegate;
    }
}
```

`UnhollowerBaseLib/DelegateSupport.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;
using UnhollowerBaseLib;
using UnhollowerBaseLib.Runtime;
using Object = Il2CppSystem.Object;
using ValueType = Il2CppSystem.ValueType;

namespace UnhollowerRuntimeLib
{
    public static unsafe class DelegateSupport
    {
        private static readonly ConcurrentDictionary<MethodSignature, Type> ourDelegateTypes = new ConcurrentDictionary<MethodSignature, Type>();

        internal static Type GetOrCreateDelegateType(MethodSignature signature, MethodInfo managedMethod)
        {
            return ourDelegateTypes.GetOrAdd(signature, (signature, managedMethodInner) => CreateDelegateType(managedMethodInner, signature.HasThis, signature.ConstructedFromNative), managedMethod);
        }

        private static readonly AssemblyBuilder AssemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("Il2CppTrampolineDelegates"), AssemblyBuilderAccess.Run);
        private static readonly ModuleBuilder ModuleBuilder = AssemblyBuilder.DefineDynamicModule("Il2CppTrampolineDelegates");

        private static Type CreateDelegateType(MethodInfo managedMethodInner, bool addIntPtrForThis, bool addNamingDisambig)
        {
            var newType = ModuleBuilder.DefineType("Il2CppToManagedDelegate_" + ExtractSignature(managedMethodInner) + (addIntPtrForThis ? "HasThis" : "") + (addNamingDisambig ? "FromNative" : ""), TypeAttributes.Sealed | TypeAttributes.Public, typeof(MulticastDelegate));
            newType.SetCustomAttribute(new CustomAttributeBuilder(typeof(UnmanagedFunctionPointerAttribute).GetConstructor(new []{typeof(CallingConvention)})!, new object[]{CallingConvention.Cdecl}));

            var ctor = newType.DefineConstructor(MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName | MethodAttributes.Public, CallingConventions.HasThis, new []{typeof(object), typeof(IntPtr)});
            ctor.SetImplementationFlags(MethodImplAttributes.CodeTypeMask);

            var parameterOffset = addIntPtrForThis ? 1 : 0;
            var managedParameters = managedMethodInner.GetParameters();
            var parameterTypes = new Type[managedParameters.Length + 1 + parameterOffset];

            if (addIntPtrForThis)
                parameterTypes[0] = typeof(IntPtr);
            
            parameterTypes[parameterTypes.Length - 1] = typeof(Il2CppMethodInfo*);
            for (var i = 0; i < managedParameters.Length; i++)
            {
                parameterTypes[i + parameterOffset] = managedParameters[i].ParameterType.IsValueType
                    ? managedParameters[i].ParameterType
                    : typeof(IntPtr);
            }

            newType.DefineMethod("Invoke",
                MethodAttributes.HideBySig | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Public,
                CallingConventions.HasThis,
                managedMethodInner.ReturnType.IsValueType ? managedMethodInner.ReturnType : typeof(IntPtr),
                parameterTypes).SetImplementationFlags(MethodImplAttributes.CodeTypeMask);

            newType.DefineMethod("BeginInvoke",
                MethodAttributes.HideBySig | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Public,
                CallingConventions.HasThis, typeof(IAsyncResult),
                parameterTypes.Concat(new[] {typeof(AsyncCallback), typeof(object)}).ToArray()).SetImplementationFlags(MethodImplAttributes.CodeTypeMask);

            newType.DefineMethod("EndInvoke",
                MethodAttributes.HideBySig | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Public,
                CallingConventions.HasThis,
                managedMethodInner.ReturnType.IsValueType ? managedMethodInner.ReturnType : typeof(IntPtr),
                new[] {typeof(IAsyncResult)}).SetImplementationFlags(MethodImplAttributes.CodeTypeMask);
            
            return newType.CreateType();
        }

        private static string ExtractSignature(MethodInfo methodInfo)
        {
            var builder = new StringBuilder();
            builder.Append(methodInfo.ReturnType.FullName);
            foreach (var parameterInfo in methodInfo.GetParameters())
            {
                builder.Append('_');
                builder.Append(parameterInfo.ParameterType.FullName);
            }

            return builder.ToString();
        }


        private static readonly ConcurrentDictionary<MethodInfo, Delegate> NativeToManagedTrampolines = new ConcurrentDictionary<MethodInfo, Delegate>();

        private static Delegate GetOrCreateNativeToManagedTrampoline(MethodSignature signature, Il2CppSystem.Reflection.MethodInfo nativeMethod, MethodInfo managedMethod)
        {
            return NativeToManagedTrampolines.GetOrAdd(managedMethod,
                (_, tuple) => GenerateNativeToManagedTrampoline(tuple.nativeMethod, tuple.managedMethod, tuple.signature), (nativeMethod, managedMethod, signature));
        }

        private static Delegate GenerateNativeToManagedTrampoline(Il2CppSystem.Reflection.MethodInfo nativeMethod,
            MethodInfo managedMethod, MethodSignature signature)
        {
            var returnType = nativeMethod.ReturnType.IsValueType
                ? managedMethod.ReturnType
                : typeof(IntPtr);

            var managedParameters = managedMethod.GetParameters();
            var nativeParameters = nativeMethod.GetParameters();
            var parameterTypes = new Type[managedParameters.Length + 1 + 1]; // thisptr for target, methodInfo last arg
            parameterTypes[0] = typeof(IntPtr);
            parameterTypes[managedParameters.Length + 1] = typeof(Il2CppMethodInfo*);
            for (var i = 0; i < managedParameters.Length; i++)
            {
                parameterTypes[i + 1] = nativeParameters[i].ParameterType.IsValueType
                    ? managedParameters[i].ParameterType
                    : typeof(IntPtr);
            }
            
            var trampoline = new DynamicMethod("(il2cpp delegate trampoline) " + ExtractSignature(managedMethod), MethodAttributes.Static, CallingConventions.Standard, returnType, parameterTypes, typeof(DelegateSupport), true);
            var bodyBuilder = trampoline.GetILGenerator();

            var tryLabel = bodyBuilder.BeginExceptionBlock();

            bodyBuilder.Emit(OpCodes.Ldarg_0);
            bodyBuilder.Emit(OpCodes.Call, typeof(ClassInjectorBase).GetMethod(nameof(ClassInjectorBase.GetMonoObjectFromIl2CppPointer))!);
            bodyBuilder.Emit(OpCodes.Castclass, typeof(Il2CppToMonoDelegateReference));
            bodyBuilder.Emit(OpCodes.Ldfld, typeof(Il2CppToMonoDelegateReference).GetField(nameof(Il2CppToMonoDelegateReference.ReferencedDelegate)));

            for (var i = 0; i < managedParameters.Length; i++)
            {
                var parameterType = managedParameters[i].ParameterType;
                
                bodyBuilder.Emit(OpCodes.Ldarg, i + 1);
                if (parameterType == typeof(string))
                {
                    bodyBuilder.Emit(OpCodes.Call, typeof(IL2CPP).GetMethod(nameof(IL2CPP.Il2CppStringToManaged))!);
                }
                else if (!parameterType.IsValueType)
                {
                    var labelNull = bodyBuilder.DefineLabel();
                    var labelDone = bodyBuilder.DefineLabel();
                    bodyBuilder.Emit(OpCodes.Brfalse, labelNull);
                    bodyBuilder.Emit(OpCodes.Ldarg, i + 1);
                    bodyBuilder.Emit(OpCodes.Newobj, parameterType.GetConstructor(new[] {typeof(IntPtr)})!);
                    bodyBuilder.Emit(OpCodes.Br, labelDone);
                    bodyBuilder.MarkLabel(labelNull);
                    bodyBuilder.Emit(OpCodes.Ldnull);
                    bodyBuilder.MarkLabel(labelDone);
                }
            }
            
            bodyBuilder.Emit(OpCodes.Call, managedMethod);

            if (returnType == typeof(string))
                bodyBuilder.Emit(OpCodes.Call, typeof(IL2CPP).GetMethod(nameof(IL2CPP.ManagedStringToIl2Cpp))!);
            else if (!returnType.IsValueType)
            {
                var labelNull = bodyBuilder.DefineLabel();
                var labelDone = bodyBuilder.DefineLabel();
                bodyBuilder.Emit(OpCodes.Dup);
                bodyBuilder.Emit(OpCodes.Brfalse, labelNull);
                bodyBuilder.Emit(OpCodes.Call, typeof(Il2CppObjectBase).GetProperty(nameof(Il2CppObjectBase.Pointer))!.GetMethod);
                bodyBuilder.Emit(OpCodes.Br, labelDone);
                bodyBuilder.MarkLabel(labelNull);
                bodyBuilder.Emit(OpCodes.Pop);
                bodyBuilder.Emit(OpCodes.Ldc_I4_0);
                bodyBuilder.Emit(OpCodes.Conv_I);
                bodyBuilder.MarkLabel(labelDone);
            }

            LocalBuilder returnLocal = null;
            if (returnType != typeof(void))
            {
                returnLocal = bodyBuilder.DeclareLocal(returnType);
                bodyBuilder.Emit(OpCodes.Stloc, returnLocal);
            }

            var exceptionLocal = bodyBuilder.DeclareLocal(typeof(Exception));
            bodyBuilder.BeginCatchBlock(typeof(Exception));
            bodyBuilder.Emit(OpCodes.Stloc, exceptionLocal);
            bodyBuilder.Emit(OpCodes.Ldstr, "Exception in IL2CPP-to-Managed trampoline, not passing it to il2cpp: ");
            bodyBuilder.Emit(OpCodes.Ldloc, exceptionLocal);
            bodyBuilder.Emit(OpCodes.Callvirt, typeof(object).GetMethod(nameof(ToString))!);
            bodyBuilder.Emit(OpCodes.Call, typeof(string).GetMethod(nameof(string.Concat), new []{typeof(string), typeof(string)})!);
            bodyBuilder.Emit(OpCodes.Call, typeof(LogSupport).GetMethod(nameof(LogSupport.Error))!);
            
            bodyBuilder.EndExceptionBlock();

            if (returnLocal != null)
                bodyBuilder.Emit(OpCodes.Ldloc, returnLocal);
            bodyBuilder.Emit(OpCodes.Ret);

            return trampoline.CreateDelegate(GetOrCreateDelegateType(signature, managedMethod));
        }

        public static TIl2Cpp ConvertDelegate<TIl2Cpp>(Delegate @delegate) where TIl2Cpp : Il2CppObjectBase
        {
            if (@delegate == null)
                return null;
            
            if(!typeof(Il2CppSystem.Delegate).IsAssignableFrom(typeof(TIl2Cpp)))
                throw new ArgumentException($"{typeof(TIl2Cpp)} is not a delegate");
            
            var managedInvokeMethod = @delegate.GetType().GetMethod("Invoke")!;
            var parameterInfos = managedInvokeMethod.GetParameters();
            foreach (var parameterInfo in parameterInfos)
            {
                var parameterType = parameterInfo.ParameterType;
                if (parameterType.IsGenericParameter)
                    throw new ArgumentException($"Delegate has unsubstituted generic parameter ({parameterType}) which is not supported");
                
                if (parameterType.BaseType == typeof(ValueType))
                    throw new ArgumentException($"Delegate has parameter of type {parameterType} (non-blittable struct) which is not supported");
            }

            var classTypePtr = Il2CppClassPointerStore<TIl2Cpp>.NativeClassPtr;
            if (classTypePtr == IntPtr.Zero)
                throw new ArgumentException($"Type {typeof(TIl2Cpp)} has uninitialized class pointer");
            
            if (Il2CppClassPointerStore<Il2CppToMonoDelegateReference>.NativeClassPtr == IntPtr.Zero)
                ClassInjector.RegisterTypeInIl2Cpp<Il2CppToMonoDelegateReference>();

            var il2CppDelegateType = Il2CppSystem.Type.internal_from_handle(IL2CPP.il2cpp_class_get_type(classTypePtr));
            var nativeDelegateInvokeMethod = il2CppDelegateType.GetMethod("Invoke");

            var nativeParameters = nativeDelegateInvokeMethod.GetParameters();
            if (nativeParameters.Count != parameterInfos.Length)
                throw new ArgumentException($"Managed delegate has {parameterInfos.Length} parameters, native has {nativeParameters.Count}, these should match");

            for (var i = 0; i < nativeParameters.Count; i++)
            {
                var nativeType = nativeParameters[i].ParameterType;
                var managedType = parameterInfos[i].ParameterType;

                if (nativeType.IsPrimitive || managedType.IsPrimitive)
                {
                    if (nativeType.FullName != managedType.FullName)
                        throw new ArgumentException($"Parameter type mismatch at parameter {i}: {nativeType.FullName} != {managedType.FullName}");
                    
                    continue;
                }

                var classPointerFromManagedType = (IntPtr) typeof(Il2CppClassPointerStore<>).MakeGenericType(managedType)
                    .GetField(nameof(Il2CppClassPointerStore<int>.NativeClassPtr)).GetValue(null);

                var classPointerFromNativeType = IL2CPP.il2cpp_class_from_type(nativeType._impl.value);
                
                if (classPointerFromManagedType != classPointerFromNativeType)
                    throw new ArgumentException($"Parameter type at {i} has mismatched native type pointers; types: {nativeType.FullName} != {managedType.FullName}");
                
                if (nativeType.IsByRef || managedType.IsByRef)
                    throw new ArgumentException($"Parameter at {i} is passed by reference, this is not supported");
            }

            var signature = new MethodSignature(nativeDelegateInvokeMethod, true);
            var managedTrampoline =
                GetOrCreateNativeToManagedTrampoline(signature, nativeDelegateInvokeMethod, managedInvokeMethod);

            var methodInfo = UnityVersionHandler.NewMethod();
            methodInfo.MethodPointer = Marshal.GetFunctionPointerForDelegate(managedTrampoline);
            methodInfo.ParametersCount = (byte) parameterInfos.Length;
            methodInfo.Slot = ushort.MaxValue;
            methodInfo.IsMarshalledFromNative = true;
            
            var delegateReference = new Il2CppToMonoDelegateReference(@delegate, methodInfo.Pointer);

            Il2CppSystem.Delegate converted;
            if (UnityVersionHandler.MustUseDelegateConstructor)
            {
                converted = ((TIl2Cpp) Activator.CreateInstance(typeof(TIl2Cpp), delegateReference.Cast<Object>(), methodInfo.Pointer)).Cast<Il2CppSystem.Delegate>();
            }
            else
            {
                var nativeDelegatePtr = IL2CPP.il2cpp_object_new(classTypePtr);
                converted = new Il2CppSystem.Delegate(nativeDelegatePtr);
            }

            converted.method_ptr = methodInfo.MethodPointer;
            converted.method_info = nativeDelegateInvokeMethod; // todo: is this truly a good hack?
            converted.method = methodInfo.Pointer;
            converted.m_target = delegateReference;

            if (UnityVersionHandler.MustUseDelegateConstructor)
            { // U2021.2.0+ hack in case the constructor did the wrong thing anyway
                converted.invoke_impl = converted.method_ptr;
                converted.method_code = converted.m_target.Pointer;
            }

            return converted.Cast<TIl2Cpp>();
        }

        internal class MethodSignature : IEquatable<MethodSignature>
        {
            public readonly bool HasThis;
            public readonly bool ConstructedFromNative;
            private readonly IntPtr myReturnType;
            private readonly IntPtr[] myParameterTypes;

            public MethodSignature(Il2CppSystem.Reflection.MethodInfo methodInfo, bool hasThis)
            {
                HasThis = hasThis;
                myReturnType = methodInfo.ReturnType.IsValueType ? methodInfo.ReturnType._impl.value : IntPtr.Zero;
                myParameterTypes = methodInfo.GetParameters().Select(it => it.ParameterType.IsValueType ? it.ParameterType._impl.value : IntPtr.Zero).ToArray();
                ConstructedFromNative = true;
            }
            
            public MethodSignature(MethodInfo methodInfo, bool hasThis)
            {
                HasThis = hasThis;
                myReturnType = methodInfo.ReturnType.IsValueType ? methodInfo.ReturnType.TypeHandle.Value : IntPtr.Zero;
                myParameterTypes = methodInfo.GetParameters().Select(it => it.ParameterType.IsValueType ? it.ParameterType.TypeHandle.Value : IntPtr.Zero).ToArray();
                ConstructedFromNative = false;
            }

            public bool Equals(MethodSignature other)
            {
                if (ReferenceEquals(null, other)) return false;
                if (ReferenceEquals(this, other)) return true;
                if (!myReturnType.Equals(other.myReturnType)) return false;
                if (HasThis != other.HasThis) return false;
                if (myParameterTypes.Length != other.myParameterTypes.Length) return false;
                for (var i = 0; i < myParameterTypes.Length; i++)
                    if (myParameterTypes[i] != other.myParameterTypes[i])
                        return false;

                return true;
            }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                if (ReferenceEquals(this, obj)) return true;
                if (obj.GetType() != GetType()) return false;
                return Equals((MethodSignature) obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    int hashCode = myReturnType.GetHashCode() ^ HasThis.GetHashCode();
                    foreach (var parameterType in myParameterTypes)
                        hashCode = hashCode * 397 + parameterType.GetHashCode();

                    return hashCode;
                }
            }

            public static bool operator ==(MethodSignature left, MethodSignature right)
            {
                return Equals(left, right);
            }

            public static bool operator !=(MethodSignature left, MethodSignature right)
            {
                return !Equals(left, right);
            }
        }

        private class Il2CppToMonoDelegateReference : Object
        {
            public Delegate ReferencedDelegate;
            public IntPtr MethodInfo;
            
            public Il2CppToMonoDelegateReference(IntPtr obj0) : base(obj0)
            {
            }

            public Il2CppToMonoDelegateReference(Delegate referencedDelegate, IntPtr methodInfo) : base(ClassInjector.DerivedConstructorPointer<Il2CppToMonoDelegateReference>())
            {
                ClassInjector.DerivedConstructorBody(this);
                
                ReferencedDelegate = referencedDelegate;
                MethodInfo = methodInfo;
            }

            ~Il2CppToMonoDelegateReference()
            {
                Marshal.FreeHGlobal(MethodInfo);
                MethodInfo = IntPtr.Zero;
                ReferencedDelegate = null;
            }
        }
    }
}
```

`UnhollowerBaseLib/GeneratedDatabasesUtil.cs`:

```cs
using System.IO;
using System.Reflection;

namespace UnhollowerBaseLib
{
    public static class GeneratedDatabasesUtil
    {
        public static string DatabasesLocationOverride { get; set; } = null;

        public static string GetDatabasePath(string databaseName) => Path.Combine(
            (DatabasesLocationOverride ?? Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location))!,
            databaseName);
    }
}
```

`UnhollowerBaseLib/IL2CPP.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using UnhollowerBaseLib.Attributes;
using UnhollowerBaseLib.Runtime;
using UnhollowerRuntimeLib;

namespace UnhollowerBaseLib
{
    public static unsafe class IL2CPP
    {
        private static Dictionary<string, IntPtr> ourImagesMap = new Dictionary<string, IntPtr>();
        
        static IL2CPP()
        {
            var domain = il2cpp_domain_get();
            if (domain == IntPtr.Zero)
            {
                LogSupport.Error("No il2cpp domain found; sad!");
                return;
            }
            uint assembliesCount = 0;
            var assemblies = il2cpp_domain_get_assemblies(domain, ref assembliesCount);
            for (var i = 0; i < assembliesCount; i++)
            {
                var image = il2cpp_assembly_get_image(assemblies[i]);
                var name = Marshal.PtrToStringAnsi(il2cpp_image_get_name(image));
                ourImagesMap[name] = image;
            }
        }

        internal static IntPtr GetIl2CppImage(string name)
        {
            if (ourImagesMap.ContainsKey(name)) return ourImagesMap[name];
            else return IntPtr.Zero;
        }

        internal static IntPtr[] GetIl2CppImages()
        {
            return ourImagesMap.Values.ToArray<IntPtr>();
        }

        public static IntPtr GetIl2CppClass(string assemblyName, string namespaze, string className)
        {
            if (!ourImagesMap.TryGetValue(assemblyName, out var image))
            {
                LogSupport.Error($"Assembly {assemblyName} is not registered in il2cpp");
                return IntPtr.Zero;
            }
            
            var clazz = il2cpp_class_from_name(image, namespaze, className);
            return clazz;
        }

        public static IntPtr GetIl2CppField(IntPtr clazz, string fieldName)
        {
            if(clazz == IntPtr.Zero) return IntPtr.Zero;

            var field = il2cpp_class_get_field_from_name(clazz, fieldName);
            if (field == IntPtr.Zero)
                LogSupport.Error($"Field {fieldName} was not found on class {Marshal.PtrToStringAnsi(il2cpp_class_get_name(clazz))}");
            return field;
        }

        public static IntPtr GetIl2CppMethodByToken(IntPtr clazz, int token)
        {
            if (clazz == IntPtr.Zero)
                return NativeStructUtils.GetMethodInfoForMissingMethod(token.ToString());
            
            IntPtr iter = IntPtr.Zero;
            IntPtr method;
            while ((method = il2cpp_class_get_methods(clazz, ref iter)) != IntPtr.Zero)
            {
                if (il2cpp_method_get_token(method) == token)
                    return method;
            }
            
            var className = Marshal.PtrToStringAnsi(il2cpp_class_get_name(clazz));
            LogSupport.Trace($"Unable to find method {className}::{token}");
            
            return NativeStructUtils.GetMethodInfoForMissingMethod(className + "::" + token);
        }

        public static IntPtr GetIl2CppMethod(IntPtr clazz, bool isGeneric, string methodName, string returnTypeName, params string[] argTypes)
        {
            if(clazz == IntPtr.Zero) return NativeStructUtils.GetMethodInfoForMissingMethod(methodName + "(" + string.Join(", ", argTypes) + ")");

            returnTypeName = Regex.Replace(returnTypeName, "\\`\\d+", "").Replace('/', '.').Replace('+', '.');
            for (var index = 0; index < argTypes.Length; index++)
            {
                var argType = argTypes[index];
                argTypes[index] = Regex.Replace(argType, "\\`\\d+", "").Replace('/', '.').Replace('+', '.');
            }

            var methodsSeen = 0;
            var lastMethod = IntPtr.Zero;
            IntPtr iter = IntPtr.Zero;
            IntPtr method;
            while ((method = il2cpp_class_get_methods(clazz, ref iter)) != IntPtr.Zero)
            {
                if(Marshal.PtrToStringAnsi(il2cpp_method_get_name(method)) != methodName)
                    continue;
                
                if(il2cpp_method_get_param_count(method) != argTypes.Length)
                    continue;
                
                if(il2cpp_method_is_generic(method) != isGeneric) 
                    continue;

                var returnType = il2cpp_method_get_return_type(method);
                var returnTypeNameActual = Marshal.PtrToStringAnsi(il2cpp_type_get_name(returnType));
                if (returnTypeNameActual != returnTypeName)
                    continue;
                
                methodsSeen++;
                lastMethod = method;

                var badType = false;
                for (var i = 0; i < argTypes.Length; i++)
                {
                    var paramType = il2cpp_method_get_param(method, (uint) i);
                    var typeName = Marshal.PtrToStringAnsi(il2cpp_type_get_name(paramType));
                    if (typeName != argTypes[i])
                    {
                        badType = true;
                        break;
                    }
                }
                
                if(badType) continue;

                return method;
            }

            var className = Marshal.PtrToStringAnsi(il2cpp_class_get_name(clazz));

            if (methodsSeen == 1)
            {
                LogSupport.Trace($"Method {className}::{methodName} was stubbed with a random matching method of the same name");
                LogSupport.Trace($"Stubby return type/target: {Marshal.PtrToStringAnsi(il2cpp_type_get_name(il2cpp_method_get_return_type(lastMethod)))} / {returnTypeName}");
                LogSupport.Trace("Stubby parameter types/targets follow:");
                for (var i = 0; i < argTypes.Length; i++)
                {
                    var paramType = il2cpp_method_get_param(lastMethod, (uint) i);
                    var typeName = Marshal.PtrToStringAnsi(il2cpp_type_get_name(paramType));
                    LogSupport.Trace($"    {typeName} / {argTypes[i]}");
                }
                
                return lastMethod;
            }
            
            LogSupport.Trace($"Unable to find method {className}::{methodName}; signature follows");
            LogSupport.Trace($"    return {returnTypeName}");
            foreach (var argType in argTypes) LogSupport.Trace($"    {argType}");
            LogSupport.Trace("Available methods of this name follow:");
            iter = IntPtr.Zero;
            while ((method = il2cpp_class_get_methods(clazz, ref iter)) != IntPtr.Zero)
            {
                if(Marshal.PtrToStringAnsi(il2cpp_method_get_name(method)) != methodName)
                    continue;

                var nParams = il2cpp_method_get_param_count(method);
                LogSupport.Trace("Method starts");
                LogSupport.Trace($"     return {Marshal.PtrToStringAnsi(il2cpp_type_get_name(il2cpp_method_get_return_type(method)))}");
                for (var i = 0; i < nParams; i++)
                {
                    var paramType = il2cpp_method_get_param(method, (uint) i);
                    var typeName = Marshal.PtrToStringAnsi(il2cpp_type_get_name(paramType));
                    LogSupport.Trace($"    {typeName}");
                }
                
                return method;
            }

            return NativeStructUtils.GetMethodInfoForMissingMethod(className + "::" + methodName + "(" + string.Join(", ", argTypes) + ")");
        }

        public static string Il2CppStringToManaged(IntPtr il2CppString)
        {
            if (il2CppString == IntPtr.Zero) return null;
            
            var length = il2cpp_string_length(il2CppString);
            var chars = il2cpp_string_chars(il2CppString);
            
            return new string(chars, 0, length);
        }

        public static IntPtr ManagedStringToIl2Cpp(string str)
        {
            if(str == null) return IntPtr.Zero;
            
            fixed (char* chars = str)
                return il2cpp_string_new_utf16(chars, str.Length);
        }

        public static IntPtr Il2CppObjectBaseToPtr(Il2CppObjectBase obj)
        {
            return obj?.Pointer ?? IntPtr.Zero;
        }
        
        public static IntPtr Il2CppObjectBaseToPtrNotNull(Il2CppObjectBase obj)
        {
            return obj?.Pointer ?? throw new NullReferenceException();
        }

        public static IntPtr GetIl2CppNestedType(IntPtr enclosingType, string nestedTypeName)
        {
            if(enclosingType == IntPtr.Zero) return IntPtr.Zero;
            
            IntPtr iter = IntPtr.Zero;
            IntPtr nestedTypePtr;
            if (il2cpp_class_is_inflated(enclosingType))
            {
                LogSupport.Trace("Original class was inflated, falling back to reflection");
                
                return RuntimeReflectionHelper.GetNestedTypeViaReflection(enclosingType, nestedTypeName);
            }
            while((nestedTypePtr = il2cpp_class_get_nested_types(enclosingType, ref iter)) != IntPtr.Zero)
            {
                if (Marshal.PtrToStringAnsi(il2cpp_class_get_name(nestedTypePtr)) == nestedTypeName)
                    return nestedTypePtr;
            }
            
            LogSupport.Error($"Nested type {nestedTypeName} on {Marshal.PtrToStringAnsi(il2cpp_class_get_name(enclosingType))} not found!");
            
            return IntPtr.Zero;
        }

        public static void ThrowIfNull(object arg)
        {
            if (arg == null)
                throw new NullReferenceException();
        }

        public static T ResolveICall<T>(string signature) where T : Delegate
        {
            
            var icallPtr = il2cpp_resolve_icall(signature);
            if (icallPtr == IntPtr.Zero)
            {
                LogSupport.Trace($"ICall {signature} not resolved");
                return GenerateDelegateForMissingICall<T>(signature);
            }

            return Marshal.GetDelegateForFunctionPointer<T>(icallPtr);
        }

        private static T GenerateDelegateForMissingICall<T>(string signature) where T: Delegate
        {
            var invoke = typeof(T).GetMethod("Invoke")!;
            
            var trampoline = new DynamicMethod("(missing icall delegate) " + typeof(T).FullName, MethodAttributes.Static, CallingConventions.Standard, invoke.ReturnType, invoke.GetParameters().Select(it => it.ParameterType).ToArray(), typeof(IL2CPP), true);
            var bodyBuilder = trampoline.GetILGenerator();

            bodyBuilder.Emit(OpCodes.Ldstr, $"ICall with signature {signature} was not resolved");
            bodyBuilder.Emit(OpCodes.Newobj, typeof(Exception).GetConstructor(new[]{ typeof(string)})!);
            bodyBuilder.Emit(OpCodes.Throw);

            return (T) trampoline.CreateDelegate(typeof(T));
        }

        private static readonly MethodInfo UnboxMethod = typeof(Il2CppObjectBase).GetMethod(nameof(Il2CppObjectBase.Unbox));
        private static readonly MethodInfo CastMethod = typeof(Il2CppObjectBase).GetMethod(nameof(Il2CppObjectBase.Cast));
        public static T PointerToValueGeneric<T>(IntPtr objectPointer, bool isFieldPointer, bool valueTypeWouldBeBoxed)
        {
            if (isFieldPointer)
            {
                if (il2cpp_class_is_valuetype(Il2CppClassPointerStore<T>.NativeClassPtr))
                    objectPointer = il2cpp_value_box(Il2CppClassPointerStore<T>.NativeClassPtr, objectPointer);
                else
                    objectPointer = *(IntPtr*) objectPointer;
            }
            
            if (!valueTypeWouldBeBoxed && il2cpp_class_is_valuetype(Il2CppClassPointerStore<T>.NativeClassPtr))
                objectPointer = il2cpp_value_box(Il2CppClassPointerStore<T>.NativeClassPtr, objectPointer);

            if (typeof(T) == typeof(string))
                return (T) (object) Il2CppStringToManaged(objectPointer);

            if (objectPointer == IntPtr.Zero)
                return default;
            
            var nativeObject = new Il2CppObjectBase(objectPointer);
            if (typeof(T).IsValueType)
                return (T) UnboxMethod.MakeGenericMethod(typeof(T)).Invoke(nativeObject, new object[0]);
            return (T) CastMethod.MakeGenericMethod(typeof(T)).Invoke(nativeObject, new object[0]);
        }

        public static string RenderTypeName<T>(bool addRefMarker = false)
        {
            return RenderTypeName(typeof(T), addRefMarker);
        }

        public static string RenderTypeName(Type t, bool addRefMarker = false)
        {
            if (addRefMarker) return RenderTypeName(t) + "&";
            if (t.IsArray) return RenderTypeName(t.GetElementType()) + "[]";
            if (t.IsByRef) return RenderTypeName(t.GetElementType()) + "&";
            if (t.IsPointer) return RenderTypeName(t.GetElementType()) + "*";
            if (t.IsGenericParameter) return t.Name;

            if (t.IsGenericType)
            {
                if (t.TypeHasIl2CppArrayBase())
                    return RenderTypeName(t.GetGenericArguments()[0]) + "[]";
                
                var builder = new StringBuilder();
                builder.Append(t.GetGenericTypeDefinition().FullNameObfuscated().TrimIl2CppPrefix());
                builder.Append('<');
                var genericArguments = t.GetGenericArguments();
                for (var i = 0; i < genericArguments.Length; i++)
                {
                    if (i != 0) builder.Append(',');
                    builder.Append(RenderTypeName(genericArguments[i]));
                }
                builder.Append('>');
                return builder.ToString();
            }

            if (t == typeof(Il2CppStringArray))
                return "System.String[]";

            return t.FullNameObfuscated().TrimIl2CppPrefix();
        }

        private static string FullNameObfuscated(this Type t)
        {
            var obfuscatedNameAnnotations = t.GetCustomAttribute<ObfuscatedNameAttribute>();
            if (obfuscatedNameAnnotations == null) return t.FullName;
            return obfuscatedNameAnnotations.ObfuscatedName;
        }

        private static string TrimIl2CppPrefix(this string s)
        {
            return s.StartsWith("Il2Cpp") ? s.Substring("Il2Cpp".Length) : s;
        }

        private static bool TypeHasIl2CppArrayBase(this Type type)
        {
            if (type == null) return false;
            if (type.IsConstructedGenericType) type = type.GetGenericTypeDefinition();
            if (type == typeof(Il2CppArrayBase<>)) return true;
            return TypeHasIl2CppArrayBase(type.BaseType);
        }

        // this is called if there's no actual il2cpp_gc_wbarrier_set_field()
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FieldWriteWbarrierStub(IntPtr obj, IntPtr targetAddress, IntPtr value)
        {
            // ignore obj
            *(IntPtr*)targetAddress = value;
        }

        // IL2CPP Functions
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_init(IntPtr domain_name);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_init_utf16(IntPtr domain_name);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_shutdown();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_config_dir(IntPtr config_path);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_data_dir(IntPtr data_path);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_temp_dir(IntPtr temp_path);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_commandline_arguments(int argc, IntPtr argv, IntPtr basedir);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_commandline_arguments_utf16(int argc, IntPtr argv, IntPtr basedir);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_config_utf16(IntPtr executablePath);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_config(IntPtr executablePath);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_memory_callbacks(IntPtr callbacks);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_get_corlib();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_add_internal_call(IntPtr name, IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_resolve_icall([MarshalAs(UnmanagedType.LPStr)] string name);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_alloc(uint size);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_free(IntPtr ptr);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_array_class_get(IntPtr element_class, uint rank);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_array_length(IntPtr array);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_array_get_byte_length(IntPtr array);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_array_new(IntPtr elementTypeInfo, ulong length);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_array_new_specific(IntPtr arrayTypeInfo, ulong length);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_array_new_full(IntPtr array_class, ref ulong lengths, ref ulong lower_bounds);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_bounded_array_class_get(IntPtr element_class, uint rank, bool bounded);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_array_element_size(IntPtr array_class);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_assembly_get_image(IntPtr assembly);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_enum_basetype(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_generic(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_inflated(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_assignable_from(IntPtr klass, IntPtr oklass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_subclass_of(IntPtr klass, IntPtr klassc, bool check_interfaces);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_has_parent(IntPtr klass, IntPtr klassc);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_from_il2cpp_type(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_from_name(IntPtr image, [MarshalAs(UnmanagedType.LPStr)] string namespaze, [MarshalAs(UnmanagedType.LPStr)] string name);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_from_system_type(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_element_class(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_events(IntPtr klass, ref IntPtr iter);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_fields(IntPtr klass, ref IntPtr iter);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_nested_types(IntPtr klass, ref IntPtr iter);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_interfaces(IntPtr klass, ref IntPtr iter);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_properties(IntPtr klass, ref IntPtr iter);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_property_from_name(IntPtr klass, IntPtr name);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_field_from_name(IntPtr klass, [MarshalAs(UnmanagedType.LPStr)] string name);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_methods(IntPtr klass, ref IntPtr iter);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_method_from_name(IntPtr klass, [MarshalAs(UnmanagedType.LPStr)] string name, int argsCount);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_name(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_namespace(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_parent(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_declaring_type(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_class_instance_size(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_class_num_fields(IntPtr enumKlass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_valuetype(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_class_value_size(IntPtr klass, ref uint align);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_blittable(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_class_get_flags(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_abstract(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_interface(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_class_array_element_size(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_from_type(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_type(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_class_get_type_token(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_has_attribute(IntPtr klass, IntPtr attr_class);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_has_references(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_class_is_enum(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_image(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_class_get_assemblyname(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_class_get_rank(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_class_get_bitmap_size(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_class_get_bitmap(IntPtr klass, ref uint bitmap);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_stats_dump_to_file(IntPtr path);
        //[DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        //public extern static ulong il2cpp_stats_get_value(IL2CPP_Stat stat);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_domain_get();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_domain_assembly_open(IntPtr domain, IntPtr name);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr* il2cpp_domain_get_assemblies(IntPtr domain, ref uint size);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_exception_from_name_msg(IntPtr image, IntPtr name_space, IntPtr name, IntPtr msg);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_get_exception_argument_null(IntPtr arg);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_format_exception(IntPtr ex, void* message, int message_size);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_format_stack_trace(IntPtr ex, void* output, int output_size);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_unhandled_exception(IntPtr ex);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_field_get_flags(IntPtr field);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_field_get_name(IntPtr field);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_field_get_parent(IntPtr field);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_field_get_offset(IntPtr field);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_field_get_type(IntPtr field);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_field_get_value(IntPtr obj, IntPtr field, void* value);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_field_get_value_object(IntPtr field, IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_field_has_attribute(IntPtr field, IntPtr attr_class);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_field_set_value(IntPtr obj, IntPtr field, void* value);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_field_static_get_value(IntPtr field, void* value);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_field_static_set_value(IntPtr field, void* value);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_field_set_value_object(IntPtr instance, IntPtr field, IntPtr value);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_gc_collect(int maxGenerations);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_gc_collect_a_little();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_gc_disable();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_gc_enable();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_gc_is_disabled();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern long il2cpp_gc_get_used_size();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern long il2cpp_gc_get_heap_size();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_gc_wbarrier_set_field(IntPtr obj, IntPtr targetAddress, IntPtr gcObj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_gchandle_new(IntPtr obj, bool pinned);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_gchandle_new_weakref(IntPtr obj, bool track_resurrection);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_gchandle_get_target(uint gchandle);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_gchandle_free(uint gchandle);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_unity_liveness_calculation_begin(IntPtr filter, int max_object_count, IntPtr callback, IntPtr userdata, IntPtr onWorldStarted, IntPtr onWorldStopped);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_unity_liveness_calculation_end(IntPtr state);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_unity_liveness_calculation_from_root(IntPtr root, IntPtr state);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_unity_liveness_calculation_from_statics(IntPtr state);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_method_get_return_type(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_method_get_declaring_type(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_method_get_name(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_method_get_from_reflection(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_method_get_object(IntPtr method, IntPtr refclass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_method_is_generic(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_method_is_inflated(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_method_is_instance(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_method_get_param_count(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_method_get_param(IntPtr method, uint index);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_method_get_class(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_method_has_attribute(IntPtr method, IntPtr attr_class);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_method_get_flags(IntPtr method, ref uint iflags);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_method_get_token(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_method_get_param_name(IntPtr method, uint index);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_profiler_install(IntPtr prof, IntPtr shutdown_callback);
        // [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        // public extern static void il2cpp_profiler_set_events(IL2CPP_ProfileFlags events);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_profiler_install_enter_leave(IntPtr enter, IntPtr fleave);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_profiler_install_allocation(IntPtr callback);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_profiler_install_gc(IntPtr callback, IntPtr heap_resize_callback);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_profiler_install_fileio(IntPtr callback);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_profiler_install_thread(IntPtr start, IntPtr end);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_property_get_flags(IntPtr prop);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_property_get_get_method(IntPtr prop);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_property_get_set_method(IntPtr prop);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_property_get_name(IntPtr prop);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_property_get_parent(IntPtr prop);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_object_get_class(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_object_get_size(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_object_get_virtual_method(IntPtr obj, IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_object_new(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_object_unbox(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_value_box(IntPtr klass, IntPtr data);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_monitor_enter(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_monitor_try_enter(IntPtr obj, uint timeout);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_monitor_exit(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_monitor_pulse(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_monitor_pulse_all(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_monitor_wait(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_monitor_try_wait(IntPtr obj, uint timeout);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern unsafe IntPtr il2cpp_runtime_invoke(IntPtr method, IntPtr obj, void** param, ref IntPtr exc);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        // param can be of Il2CppObject*
        public static extern unsafe IntPtr il2cpp_runtime_invoke_convert_args(IntPtr method, IntPtr obj, void** param, int paramCount, ref IntPtr exc);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_runtime_class_init(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_runtime_object_init(IntPtr obj);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_runtime_object_init_exception(IntPtr obj, ref IntPtr exc);
        // [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        // public extern static void il2cpp_runtime_unhandled_exception_policy_set(IL2CPP_RuntimeUnhandledExceptionPolicy value);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_string_length(IntPtr str);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern unsafe char* il2cpp_string_chars(IntPtr str);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_string_new(string str);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_string_new_len(string str, uint length);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_string_new_utf16(char* text, int len);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_string_new_wrapper(string str);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_string_intern(string str);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_string_is_interned(string str);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_thread_current();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_thread_attach(IntPtr domain);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_thread_detach(IntPtr thread);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern unsafe void** il2cpp_thread_get_all_attached_threads(ref uint size);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_is_vm_thread(IntPtr thread);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_current_thread_walk_frame_stack(IntPtr func, IntPtr user_data);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_thread_walk_frame_stack(IntPtr thread, IntPtr func, IntPtr user_data);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_current_thread_get_top_frame(IntPtr frame);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_thread_get_top_frame(IntPtr thread, IntPtr frame);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_current_thread_get_frame_at(int offset, IntPtr frame);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_thread_get_frame_at(IntPtr thread, int offset, IntPtr frame);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_current_thread_get_stack_depth();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_thread_get_stack_depth(IntPtr thread);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_type_get_object(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern int il2cpp_type_get_type(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_type_get_class_or_element_class(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_type_get_name(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_type_is_byref(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_type_get_attrs(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_type_equals(IntPtr type, IntPtr otherType);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_type_get_assembly_qualified_name(IntPtr type);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_image_get_assembly(IntPtr image);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_image_get_name(IntPtr image);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_image_get_filename(IntPtr image);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_image_get_entry_point(IntPtr image);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern uint il2cpp_image_get_class_count(IntPtr image);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_image_get_class(IntPtr image, uint index);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_capture_memory_snapshot();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_free_captured_memory_snapshot(IntPtr snapshot);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_set_find_plugin_callback(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_register_log_callback(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_debugger_set_agent_options(IntPtr options);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_is_debugger_attached();
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern unsafe void il2cpp_unity_install_unitytls_interface(void* unitytlsInterfaceStruct);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_custom_attrs_from_class(IntPtr klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_custom_attrs_from_method(IntPtr method);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_custom_attrs_get_attr(IntPtr ainfo, IntPtr attr_klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern bool il2cpp_custom_attrs_has_attr(IntPtr ainfo, IntPtr attr_klass);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern IntPtr il2cpp_custom_attrs_construct(IntPtr cinfo);
        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        public static extern void il2cpp_custom_attrs_free(IntPtr ainfo);
    }
}

```

`UnhollowerBaseLib/Il2CppArrayBase.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using UnhollowerRuntimeLib;

namespace UnhollowerBaseLib
{
    public abstract class Il2CppArrayBase<T> : Il2CppObjectBase, IList<T>
    {
        protected static void StaticCtorBody(Type ownType)
        {
            var nativeClassPtr = Il2CppClassPointerStore<T>.NativeClassPtr;
            if (nativeClassPtr == IntPtr.Zero)
                return;
            
            var targetClassType = IL2CPP.il2cpp_array_class_get(nativeClassPtr, 1);
            if (targetClassType == IntPtr.Zero)
                return;
            
            ClassInjector.WriteClassPointerForType(ownType, targetClassType);
            ClassInjector.WriteClassPointerForType(typeof(Il2CppArrayBase<T>), targetClassType);
            Il2CppClassPointerStore<Il2CppArrayBase<T>>.CreatedTypeRedirect = ownType;
        }

        protected Il2CppArrayBase(IntPtr pointer) : base(pointer)
        {
        }

        public int Length => (int) IL2CPP.il2cpp_array_length(Pointer);

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public IEnumerator<T> GetEnumerator()
        {
            return new IndexEnumerator(this);
        }

        void ICollection<T>.Add(T item) => ThrowImmutableLength();

        private static bool ThrowImmutableLength() => throw new NotSupportedException("Arrays have immutable length");

        void ICollection<T>.Clear() => ThrowImmutableLength();
        public bool Contains(T item) => IndexOf(item) != -1;
        public void CopyTo(T[] array, int arrayIndex)
        {
            if (array == null) throw new ArgumentNullException(nameof(array));
            if (arrayIndex < 0) throw new ArgumentOutOfRangeException(nameof(arrayIndex));
            if (array.Length - arrayIndex < Length) throw new ArgumentException($"Not enough space in target array: need {Length} slots, have {array.Length - arrayIndex}");

            for (var i = 0; i < Length; i++)
                array[i + arrayIndex] = this[i];
        }

        bool ICollection<T>.Remove(T item) => ThrowImmutableLength();

        public int Count => Length;
        public bool IsReadOnly => false;
        
        public int IndexOf(T item)
        {
            for (var i = 0; i < Length; i++)
                if (Equals(item, this[i]))
                    return i;

            return -1;
        }

        void IList<T>.Insert(int index, T item) => ThrowImmutableLength();
        void IList<T>.RemoveAt(int index) => ThrowImmutableLength();

        public static implicit operator T[](Il2CppArrayBase<T> il2CppArray)
        {
            if (il2CppArray == null)
                return null;

            var arr = new T[il2CppArray.Length];
            for (var i = 0; i < arr.Length; i++)
                arr[i] = il2CppArray[i];
            
            return arr;
        }

        public abstract T this[int index]
        {
            get;
            set;
        }

        public static Il2CppArrayBase<T> WrapNativeGenericArrayPointer(IntPtr pointer)
        {
            if (pointer == IntPtr.Zero) return null;

            if (typeof(T) == typeof(string)) 
                return new Il2CppStringArray(pointer) as Il2CppArrayBase<T>;
            if (typeof(T).IsValueType) // can't construct required types here directly because of unfulfilled generic constraint
                return Activator.CreateInstance(typeof(Il2CppStructArray<>).MakeGenericType(typeof(T)), pointer) as Il2CppArrayBase<T>;
            if (typeof(Il2CppObjectBase).IsAssignableFrom(typeof(T)))
                return Activator.CreateInstance(typeof(Il2CppReferenceArray<>).MakeGenericType(typeof(T)), pointer) as Il2CppArrayBase<T>;
            
            throw new ArgumentException($"{typeof(T)} is not a value type, not a string and not an IL2CPP object; it can't be used in IL2CPP arrays");
        }

        private class IndexEnumerator : IEnumerator<T>
        {
            private Il2CppArrayBase<T> myArray;
            private int myIndex = -1;

            public IndexEnumerator(Il2CppArrayBase<T> array) => myArray = array;
            public void Dispose() => myArray = null;
            public bool MoveNext() => ++myIndex < myArray.Count;
            public void Reset() => myIndex = -1;
            object IEnumerator.Current => Current;
            public T Current => myArray[myIndex];
        }
    }
}
```

`UnhollowerBaseLib/Il2CppClassPointerStore.cs`:

```cs
using System;
using System.Linq;
using System.Runtime.CompilerServices;
using UnhollowerBaseLib.Attributes;

namespace UnhollowerBaseLib
{
    public static class Il2CppClassPointerStore<T>
    {
        public static IntPtr NativeClassPtr;
        public static Type CreatedTypeRedirect;
        
        static Il2CppClassPointerStore()
        {
            var targetType = typeof(T);
            RuntimeHelpers.RunClassConstructor(targetType.TypeHandle);
            if (targetType.IsPrimitive || targetType == typeof(string))
            {
                RuntimeHelpers.RunClassConstructor(AppDomain.CurrentDomain.GetAssemblies()
                    .Single(it => it.GetName().Name == "Il2Cppmscorlib").GetType("Il2Cpp" + targetType.FullName)
                    .TypeHandle);
            }
            
            foreach (var customAttribute in targetType.CustomAttributes)
            {
                if (customAttribute.AttributeType != typeof(AlsoInitializeAttribute)) continue;
                
                var linkedType = (Type) customAttribute.ConstructorArguments[0].Value;
                RuntimeHelpers.RunClassConstructor(linkedType.TypeHandle);
            }
        }
    }
}
```

`UnhollowerBaseLib/Il2CppException.cs`:

```cs
using System;
using System.Text;

namespace UnhollowerBaseLib
{
    public class Il2CppException : Exception
    {
        [ThreadStatic] private static byte[] ourMessageBytes;

        public static Func<IntPtr, string> ParseMessageHook;

        public Il2CppException(IntPtr exception) : base(BuildMessage(exception))
        {
        }

        private static unsafe string BuildMessage(IntPtr exception)
        {
            if (ParseMessageHook != null) return ParseMessageHook(exception);
            ourMessageBytes ??= new byte[65536];
            fixed (byte* message = ourMessageBytes)
                IL2CPP.il2cpp_format_exception(exception, message, ourMessageBytes.Length);
            string builtMessage = Encoding.UTF8.GetString(ourMessageBytes, 0, Array.IndexOf(ourMessageBytes, (byte) 0));
            fixed (byte* message = ourMessageBytes)
                IL2CPP.il2cpp_format_stack_trace(exception, message, ourMessageBytes.Length);
            builtMessage +=
                "\n" + Encoding.UTF8.GetString(ourMessageBytes, 0, Array.IndexOf(ourMessageBytes, (byte) 0));
            return builtMessage;
        }

        public static void RaiseExceptionIfNecessary(IntPtr returnedException)
        {
            if (returnedException == IntPtr.Zero) return;
            throw new Il2CppException(returnedException);
        }
    }
}
```

`UnhollowerBaseLib/Il2CppObjectBase.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime;

namespace UnhollowerBaseLib
{
    public class Il2CppObjectBase
    {
        public IntPtr Pointer
        {
            get
            {
                var handleTarget = IL2CPP.il2cpp_gchandle_get_target(myGcHandle);
                if (handleTarget == IntPtr.Zero) throw new ObjectCollectedException("Object was garbage collected in IL2CPP domain");
                return handleTarget;
            }
        }

        public bool WasCollected
        {
            get
            {
                var handleTarget = IL2CPP.il2cpp_gchandle_get_target(myGcHandle);
                if (handleTarget == IntPtr.Zero) return true;
                return false;
            }
        }

        private readonly uint myGcHandle;

        public Il2CppObjectBase(IntPtr pointer)
        {
            if (pointer == IntPtr.Zero)
                throw new NullReferenceException();

            myGcHandle = RuntimeSpecificsStore.ShouldUseWeakRefs(IL2CPP.il2cpp_object_get_class(pointer))
                ? IL2CPP.il2cpp_gchandle_new_weakref(pointer, false)
                : IL2CPP.il2cpp_gchandle_new(pointer, false);
        }

        public T Cast<T>() where T: Il2CppObjectBase
        {
            return TryCast<T>() ?? throw new InvalidCastException($"Can't cast object of type {Marshal.PtrToStringAnsi(IL2CPP.il2cpp_class_get_name(IL2CPP.il2cpp_object_get_class(Pointer)))} to type {typeof(T)}");
        }

        public T Unbox<T>() where T : unmanaged
        {
            var nestedTypeClassPointer = Il2CppClassPointerStore<T>.NativeClassPtr;
            if (nestedTypeClassPointer == IntPtr.Zero)
                throw new ArgumentException($"{typeof(T)} is not an Il2Cpp reference type");
            
            var ownClass = IL2CPP.il2cpp_object_get_class(Pointer);
            if (!IL2CPP.il2cpp_class_is_assignable_from(nestedTypeClassPointer, ownClass))
                throw new InvalidCastException($"Can't cast object of type {Marshal.PtrToStringAnsi(IL2CPP.il2cpp_class_get_name(IL2CPP.il2cpp_object_get_class(Pointer)))} to type {typeof(T)}");

            return Marshal.PtrToStructure<T>(IL2CPP.il2cpp_object_unbox(Pointer));
        } 
        
        public T TryCast<T>() where T: Il2CppObjectBase
        {
            var nestedTypeClassPointer = Il2CppClassPointerStore<T>.NativeClassPtr;
            if (nestedTypeClassPointer == IntPtr.Zero)
                throw new ArgumentException($"{typeof(T)} is not an Il2Cpp reference type");

            var ownClass = IL2CPP.il2cpp_object_get_class(Pointer);
            if (!IL2CPP.il2cpp_class_is_assignable_from(nestedTypeClassPointer, ownClass))
                return null;

            if (RuntimeSpecificsStore.IsInjected(ownClass))
                return ClassInjectorBase.GetMonoObjectFromIl2CppPointer(Pointer) as T;

            return (T) Activator.CreateInstance(Il2CppClassPointerStore<T>.CreatedTypeRedirect ?? typeof(T), Pointer);
        }

        ~Il2CppObjectBase()
        {
            IL2CPP.il2cpp_gchandle_free(myGcHandle);
        }
    }
}
```

`UnhollowerBaseLib/Il2CppReferenceArray.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib
{
    public class Il2CppReferenceArray<T> : Il2CppArrayBase<T> where T: Il2CppObjectBase
    {
        private static ConstructorInfo ourCachedInstanceCtor;
        private static int ourElementTypeSize;
        private static bool ourElementIsValueType;
        
        public Il2CppReferenceArray(IntPtr nativeObject) : base(nativeObject)
        {
        }

        public Il2CppReferenceArray(long size) : base(AllocateArray(size))
        {
        }

        public Il2CppReferenceArray(T[] arr) : base(AllocateArray(arr.Length))
        {
            for (var i = 0; i < arr.Length; i++) 
                this[i] = arr[i];
        }

        static Il2CppReferenceArray()
        {
            ourElementTypeSize = IntPtr.Size;
            var nativeClassPtr = Il2CppClassPointerStore<T>.NativeClassPtr;
            if (nativeClassPtr == IntPtr.Zero) return;
            uint align = 0;
            if (IL2CPP.il2cpp_class_is_valuetype(nativeClassPtr))
            {
                ourElementIsValueType = true;
                ourElementTypeSize = IL2CPP.il2cpp_class_value_size(nativeClassPtr, ref align);
            }
            
            StaticCtorBody(typeof(Il2CppReferenceArray<T>));
        }
        
        public static implicit operator Il2CppReferenceArray<T>(T[] arr)
        {
            if (arr == null) return null;
            
            return new Il2CppReferenceArray<T>(arr);
        }

        public override T this[int index]
        {
            get
            {
                if(index < 0 || index >= Length)
                    throw new ArgumentOutOfRangeException(nameof(index), "Array index may not be negative or above length of the array");
                var arrayStartPointer = IntPtr.Add(Pointer, 4 * IntPtr.Size);
                var elementPointer = IntPtr.Add(arrayStartPointer, index * ourElementTypeSize);
                return WrapElement(elementPointer);
            }
            set
            {
                if(index < 0 || index >= Length)
                    throw new ArgumentOutOfRangeException(nameof(index), "Array index may not be negative or above length of the array");
                var arrayStartPointer = IntPtr.Add(Pointer, 4 * IntPtr.Size);
                var elementPointer = IntPtr.Add(arrayStartPointer, index * ourElementTypeSize);
                StoreValue(elementPointer, value?.Pointer ?? IntPtr.Zero);
            }
        }

        private static unsafe void StoreValue(IntPtr targetPointer, IntPtr valuePointer)
        {
            if (ourElementIsValueType)
            {
                if(valuePointer == IntPtr.Zero)
                    throw new NullReferenceException();
                
                var valueRawPointer = (byte*) IL2CPP.il2cpp_object_unbox(valuePointer);
                var targetRawPointer = (byte*) targetPointer;
                for (var i = 0; i < ourElementTypeSize; i++) 
                    targetRawPointer[i] = valueRawPointer[i];
            }
            else
            {
                *(IntPtr*) targetPointer = valuePointer;
            }
        }

        private static unsafe T WrapElement(IntPtr memberPointer)
        {
            if (ourCachedInstanceCtor == null)
            {
                ourCachedInstanceCtor = typeof(T).GetConstructor(new[] {typeof(IntPtr)});
            }

            if (ourElementIsValueType)
                return (T) ourCachedInstanceCtor.Invoke(new object[]
                    {IL2CPP.il2cpp_value_box(Il2CppClassPointerStore<T>.NativeClassPtr, memberPointer)});

            var referencePointer = *(IntPtr*) memberPointer;
            if (referencePointer == IntPtr.Zero) return null;
            
            return (T) ourCachedInstanceCtor.Invoke(new object[] {referencePointer});
        }

        private static IntPtr AllocateArray(long size)
        {
            if(size < 0)
                throw new ArgumentOutOfRangeException(nameof(size), "Array size must not be negative");

            var elementTypeClassPointer = Il2CppClassPointerStore<T>.NativeClassPtr;
            if(elementTypeClassPointer == IntPtr.Zero)
                throw new ArgumentException($"{nameof(Il2CppReferenceArray<T>)} requires an Il2Cpp reference type, which {typeof(T)} isn't");
            return IL2CPP.il2cpp_array_new(elementTypeClassPointer, (ulong) size);
        }
    }
}
```

`UnhollowerBaseLib/Il2CppStringArray.cs`:

```cs
using System;

namespace UnhollowerBaseLib
{
    public class Il2CppStringArray : Il2CppArrayBase<string>
    {
        public Il2CppStringArray(IntPtr pointer) : base(pointer)
        {
        }
        
        public Il2CppStringArray(long size) : base(AllocateArray(size))
        {
        }

        public Il2CppStringArray(string[] arr) : base(AllocateArray(arr.Length))
        {
            for (var i = 0; i < arr.Length; i++) 
                this[i] = arr[i];
        }

        static Il2CppStringArray()
        {
            StaticCtorBody(typeof(Il2CppStringArray));
        }
        
        public static implicit operator Il2CppStringArray(string[] arr)
        {
            if (arr == null) return null;
            
            return new Il2CppStringArray(arr);
        }
        
        private static IntPtr AllocateArray(long size)
        {
            if(size < 0)
                throw new ArgumentOutOfRangeException(nameof(size), "Array size must not be negative");

            var elementTypeClassPointer = Il2CppClassPointerStore<string>.NativeClassPtr;
            if (elementTypeClassPointer == IntPtr.Zero)
                throw new ArgumentException("String class pointer is missing, something is very wrong");
            return IL2CPP.il2cpp_array_new(elementTypeClassPointer, (ulong) size);
        }

        public override unsafe string this[int index]
        {
            get
            {
                if(index < 0 || index >= Length)
                    throw new ArgumentOutOfRangeException(nameof(index), "Array index may not be negative or above length of the array");
                var arrayStartPointer = IntPtr.Add(Pointer, 4 * IntPtr.Size);
                var elementPointer = IntPtr.Add(arrayStartPointer, index * IntPtr.Size);
                return IL2CPP.Il2CppStringToManaged(*(IntPtr*) elementPointer);
            }
            set
            {
                if(index < 0 || index >= Length)
                    throw new ArgumentOutOfRangeException(nameof(index), "Array index may not be negative or above length of the array");
                var arrayStartPointer = IntPtr.Add(Pointer, 4 * IntPtr.Size);
                var elementPointer = IntPtr.Add(arrayStartPointer, index * IntPtr.Size);
                *(IntPtr*)elementPointer = IL2CPP.ManagedStringToIl2Cpp(value);
            }
        }
    }
}
```

`UnhollowerBaseLib/Il2CppStructArray.cs`:

```cs
using System;

namespace UnhollowerBaseLib
{
    public class Il2CppStructArray<T> : Il2CppArrayBase<T> where T: unmanaged
    {
        public Il2CppStructArray(IntPtr nativeObject) : base(nativeObject)
        {
        }

        public Il2CppStructArray(long size) : base(AllocateArray(size))
        {
        }

        static Il2CppStructArray()
        {
            StaticCtorBody(typeof(Il2CppStructArray<T>));
        }
        
        public static implicit operator Il2CppStructArray<T>(T[] arr)
        {
            if (arr == null) return null;
            
            var il2CppArray = new Il2CppStructArray<T>(arr.Length);
            for (var i = 0; i < arr.Length; i++) il2CppArray[i] = arr[i];

            return il2CppArray;
        }

        public override unsafe T this[int index]
        {
            get
            {
                if(index < 0 || index >= Length)
                    throw new ArgumentOutOfRangeException(nameof(index), "Array index may not be negative or above length of the array");
                var arrayStartPointer = IntPtr.Add(Pointer, 4 * IntPtr.Size);
                return ((T*) arrayStartPointer.ToPointer())[index];
            }
            set
            {
                if(index < 0 || index >= Length)
                    throw new ArgumentOutOfRangeException(nameof(index), "Array index may not be negative or above length of the array");
                var arrayStartPointer = IntPtr.Add(Pointer, 4 * IntPtr.Size);
                ((T*) arrayStartPointer.ToPointer())[index] = value;
            }
        }
        
        private static IntPtr AllocateArray(long size)
        {
            if(size < 0)
                throw new ArgumentOutOfRangeException(nameof(size), "Array size must not be negative");

            var elementTypeClassPointer = Il2CppClassPointerStore<T>.NativeClassPtr;
            if(elementTypeClassPointer == IntPtr.Zero)
                throw new ArgumentException($"{nameof(Il2CppStructArray<T>)} requires an Il2Cpp reference type, which {typeof(T)} isn't");
            return IL2CPP.il2cpp_array_new(elementTypeClassPointer, (ulong) size);
        }
    }
}
```

`UnhollowerBaseLib/Il2CppType.cs`:

```cs
using System;
using UnhollowerBaseLib;

namespace UnhollowerRuntimeLib
{
    public static class Il2CppType
    {
        public static Il2CppSystem.Type TypeFromPointer(IntPtr classPointer, string typeName = "<unknown type>") => TypeFromPointerInternal(classPointer, typeName, true);

        private static Il2CppSystem.Type TypeFromPointerInternal(IntPtr classPointer, string typeName, bool throwOnFailure)
        {
            if (classPointer == IntPtr.Zero)
            {
                if (throwOnFailure) throw new ArgumentException($"{typeName} does not have a corresponding IL2CPP class pointer");
                else return null;
            }
            var il2CppType = IL2CPP.il2cpp_class_get_type(classPointer);
            if (il2CppType == IntPtr.Zero)
            {
                if (throwOnFailure) throw new ArgumentException($"{typeName} does not have a corresponding IL2CPP type pointer");
                else return null;
            }
            return Il2CppSystem.Type.internal_from_handle(il2CppType);
        }

        public static Il2CppSystem.Type From(Type type) => From(type, true);

        public static Il2CppSystem.Type From(Type type, bool throwOnFailure)
        {
            var pointer = ClassInjector.ReadClassPointerForType(type);
            return TypeFromPointerInternal(pointer, type.Name, throwOnFailure);
        }

        public static Il2CppSystem.Type Of<T>() => Of<T>(true);

        public static Il2CppSystem.Type Of<T>(bool throwOnFailure)
        {
            var classPointer = Il2CppClassPointerStore<T>.NativeClassPtr;
            return TypeFromPointerInternal(classPointer, typeof(T).Name, throwOnFailure);
        }
    }

    [Obsolete("Use Il2CppType.Of<T>()", false)]
    public static class Il2CppTypeOf<T>
    {
        [Obsolete("Use Il2CppType.Of<T>()", true)]
        public static Il2CppSystem.Type Type => Il2CppType.Of<T>();
    }
}
```

`UnhollowerBaseLib/LogSupport.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib
{
    public static class LogSupport
    {
        public static event Action<string> ErrorHandler;
        public static event Action<string> WarningHandler;
        public static event Action<string> InfoHandler;
        public static event Action<string> TraceHandler;

        public static void InstallConsoleHandlers()
        {
            ErrorHandler += Console.WriteLine;
            WarningHandler += Console.WriteLine;
            InfoHandler += Console.WriteLine;
        }
        
        public static void RemoveAllHandlers()
        {
            ErrorHandler = null;
            WarningHandler = null;
            InfoHandler = null;
            TraceHandler = null;
        }

        public static void Error(string message) => ErrorHandler?.Invoke(message);
        public static void Warning(string message) => WarningHandler?.Invoke(message);
        public static void Info(string message) => InfoHandler?.Invoke(message);
        public static void Trace(string message) => TraceHandler?.Invoke(message);
    }
}
```

`UnhollowerBaseLib/Maps/MethodAddressToTokenMap.cs`:

```cs
using System;
using System.Reflection;

#nullable enable

namespace UnhollowerBaseLib.Maps
{
    public class MethodAddressToTokenMap : MethodAddressToTokenMapBase<Assembly, MethodBase>
    {
        [Obsolete("Use the constant in MethodAddressToTokenMapBase")]
        public new const int Magic = MethodAddressToTokenMapBase<Assembly, MethodBase>.Magic;
        [Obsolete("Use the constant in MethodAddressToTokenMapBase")]
        public new const int Version = MethodAddressToTokenMapBase<Assembly, MethodBase>.Version;
        [Obsolete("Use the constant in MethodAddressToTokenMapBase")]
        public new const string FileName = MethodAddressToTokenMapBase<Assembly, MethodBase>.FileName;

        public MethodAddressToTokenMap(string filePath) : base(filePath)
        {
        }

        protected override Assembly LoadAssembly(string assemblyName) => Assembly.Load(assemblyName);

        protected override MethodBase? ResolveMethod(Assembly? assembly, int token) => assembly?.ManifestModule.ResolveMethod(token);
    }
}
```

`UnhollowerBaseLib/Maps/MethodAddressToTokenMapBase.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Runtime.InteropServices;
using System.Text;

#nullable enable

namespace UnhollowerBaseLib.Maps
{
    public abstract class MethodAddressToTokenMapBase<TAssembly, TMethod> : IDisposable, IEnumerable<(long, TMethod?)>
    {
        public const int Magic = 0x4D544D55; // UMTM
        public const int Version = 1;
        public const string FileName = "MethodAddressToToken.db";
        
        private readonly MemoryMappedFile? myMapFile;
        private readonly MemoryMappedViewAccessor? myAccessor;
        
        private unsafe long* myPointers;
        private unsafe int* myValues;
        
        private readonly MethodAddressToTokenMapFileHeader myHeader;
        private readonly List<TAssembly?> myAssemblyList = new();

        protected readonly string myFilePath;

        public MethodAddressToTokenMapBase(string filePath)
        {
            myFilePath = filePath;
            myMapFile = MemoryMappedFile.CreateFromFile(filePath, FileMode.Open, null, 0, MemoryMappedFileAccess.Read);

            var headerView = myMapFile.CreateViewAccessor(0, 0, MemoryMappedFileAccess.Read);
            myAccessor = headerView;

            headerView.Read(0, out myHeader);

            if (myHeader.Magic != Magic)
            {
                myMapFile.Dispose();
                throw new FileLoadException($"File magic mismatched for {filePath}; Expected {Magic:X}, got {myHeader.Magic:X}");
            }
            
            if (myHeader.Version != Version)
            {
                myMapFile.Dispose();
                throw new FileLoadException($"File version mismatched for {filePath}; Expected {Version}, got {myHeader.Version}");
            }
            
            var offset = Marshal.SizeOf<MethodAddressToTokenMapFileHeader>();
            using var reader = new BinaryReader(myMapFile.CreateViewStream(offset, 0, MemoryMappedFileAccess.Read), Encoding.UTF8, false);
            for (var i = 0; i < myHeader.NumAssemblies; i++)
            {
                var assemblyName = reader.ReadString();
                myAssemblyList.Add(LoadAssembly(assemblyName));
            }

            unsafe
            {
                byte* pointersPointer = null;

                myAccessor.SafeMemoryMappedViewHandle.AcquirePointer(ref pointersPointer);

                myPointers = (long*) (pointersPointer + myHeader.DataOffset);
                myValues = (int*) (pointersPointer + myHeader.DataOffset + myHeader.NumMethods * 8);
            }
        }

        protected abstract TAssembly? LoadAssembly(string assemblyName);

        private void ReleaseUnmanagedResources()
        {
            myAccessor?.SafeMemoryMappedViewHandle.ReleasePointer();
            unsafe
            {
                myPointers = null;
                myValues = null;
            }
        }

        private void Dispose(bool disposing)
        {
            ReleaseUnmanagedResources();
            if (disposing)
            {
                myAccessor?.Dispose();
                myMapFile?.Dispose();
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~MethodAddressToTokenMapBase()
        {
            Dispose(false);
        }

        public unsafe TMethod? Lookup(long parsedRva)
        {
            var left = 0;
            var right = myHeader.NumMethods;

            while (right - left > 1)
            {
                var mid = (left + right) / 2;
                var pointerAt = myPointers[mid];
                if (pointerAt > parsedRva)
                    right = mid;
                else
                    left = mid;
            }

            if (myPointers[left] != parsedRva)
                return default;

            var dataToken = myValues[left * 2];
            var assemblyIdx = myValues[left * 2 + 1];

            return ResolveMethod(myAssemblyList[assemblyIdx], dataToken);
        }

        protected abstract TMethod? ResolveMethod(TAssembly? assembly, int token);
        
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        IEnumerator<(long, TMethod?)> IEnumerable<(long, TMethod?)>.GetEnumerator() => GetEnumerator();

        public Enumerator GetEnumerator() => new(this);

        public class Enumerator : IEnumerator<(long, TMethod?)>
        {
            private readonly MethodAddressToTokenMapBase<TAssembly, TMethod> myMap;
            private int myOffset = -1;

            public Enumerator(MethodAddressToTokenMapBase<TAssembly, TMethod> map)
            {
                myMap = map;
            }

            public unsafe bool MoveNext()
            {
                myOffset++;
                if (myOffset < myMap.myHeader.NumMethods)
                {
                    var dataToken = myMap.myValues[myOffset * 2];
                    var assemblyIdx = myMap.myValues[myOffset * 2 + 1];
                    
                    Current = (myMap.myPointers[myOffset], myMap.ResolveMethod(myMap.myAssemblyList[assemblyIdx], dataToken));
                    
                    return true;
                }

                return false;
            }

            public void Reset()
            {
                myOffset = -1;
            }

            object IEnumerator.Current => Current;

            public void Dispose()
            {
            }

            public (long, TMethod?) Current { get; private set; }
        }
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct MethodAddressToTokenMapFileHeader
    {
        public int Magic;
        public int Version;
        public int NumAssemblies;
        public int NumMethods;
        public int DataOffset;
            
        // data is long[NumMethods] pointers, (int, int)[NumMethods] (tokens, assemblyIds)
    }
}
```

`UnhollowerBaseLib/Maps/MethodXrefScanCache.cs`:

```cs
using System;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Runtime.InteropServices;
using UnhollowerRuntimeLib.XrefScans;

namespace UnhollowerBaseLib.Maps
{
    public class MethodXrefScanCache : IDisposable
    {
        public const int Magic = 0x43584D55; // UMXC
        public const int Version = 1;
        public const string FileName = "MethodXrefScanCache.db";
        
        private readonly MemoryMappedFile myMapFile;
        private readonly MemoryMappedViewAccessor myAccessor;
        
        private unsafe MethodData* myData;

        public readonly FileHeader Header;

        public MethodXrefScanCache(string filePath)
        {
            myMapFile = MemoryMappedFile.CreateFromFile(filePath, FileMode.Open, null, 0, MemoryMappedFileAccess.Read);

            var headerView = myMapFile.CreateViewAccessor(0, 0, MemoryMappedFileAccess.Read);
            myAccessor = headerView;

            headerView.Read(0, out Header);

            if (Header.Magic != Magic)
            {
                myMapFile.Dispose();
                throw new FileLoadException($"File magic mismatched for {filePath}; Expected {Magic:X}, got {Header.Magic:X}");
            }
            
            if (Header.Version != Version)
            {
                myMapFile.Dispose();
                throw new FileLoadException($"File version mismatched for {filePath}; Expected {Version}, got {Header.Version}");
            }
            
            var offset = Marshal.SizeOf<FileHeader>();

            unsafe
            {
                byte* pointersPointer = null;

                myAccessor.SafeMemoryMappedViewHandle.AcquirePointer(ref pointersPointer);

                myData = (MethodData*) (pointersPointer + offset);
            }
        }

        private void ReleaseUnmanagedResources()
        {
            myAccessor.SafeMemoryMappedViewHandle.ReleasePointer();
            unsafe
            {
                myData = null;
            }
        }

        private void Dispose(bool disposing)
        {
            ReleaseUnmanagedResources();
            if (disposing)
            {
                myAccessor?.Dispose();
                myMapFile?.Dispose();
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~MethodXrefScanCache()
        {
            Dispose(false);
        }

        internal unsafe ref MethodData GetAt(int index)
        {
            return ref *(myData + index);
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct FileHeader
        {
            public int Magic;
            public int Version;
            public long InitMethodMetadataRva;

            // data is MethodData[]
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MethodData
        {
            public long Address;
            public long FoundAt;
            public XrefType Type;

            public XrefInstance AsXrefInstance(long baseAddress)
            {
                return new XrefInstance(Type, (IntPtr) (baseAddress + Address), (IntPtr) (baseAddress + FoundAt));
            }

            public static MethodData FromXrefInstance(XrefInstance instance)
            {
                return new MethodData
                {
                    Address = (long) instance.Pointer,
                    FoundAt = (long) instance.FoundAt,
                    Type = instance.Type
                };
            }
        }
    }
}
```

`UnhollowerBaseLib/MiniILParser.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;

namespace UnhollowerBaseLib
{
    public static class MiniIlParser
    {
        private static readonly Dictionary<short, OpCode> OpCodesMap = new Dictionary<short, OpCode>();
        private static readonly HashSet<short> PrefixCodes = new HashSet<short>();

        static MiniIlParser()
        {
            foreach (var fieldInfo in typeof(OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public))
            {
                if (fieldInfo.FieldType != typeof(OpCode)) continue;

                var fieldValue = (OpCode) fieldInfo.GetValue(null);
                OpCodesMap[fieldValue.Value] = fieldValue;
                if ((ushort) fieldValue.Value > byte.MaxValue) 
                    PrefixCodes.Add((byte) ((ushort) fieldValue.Value >> 8));
            }
        }

        public static IEnumerable<(OpCode, long)> Decode(byte[] ilBytes)
        {
            int index = 0;
            while (index < ilBytes.Length)
            {
                short currentOp = ilBytes[index++];
                if (PrefixCodes.Contains(currentOp)) 
                    currentOp = (short) ((ushort) (currentOp << 8) | ilBytes[index++]);

                if (!OpCodesMap.TryGetValue(currentOp, out var opCode))
                    throw new NotSupportedException($"Unknown opcode {currentOp} encountered");

                var argLength = GetOperandSize(opCode);
                
                switch (argLength)
                {
                    case 0:
                        yield return (opCode, 0);
                        break;
                    case 1:
                        yield return (opCode, ilBytes[index]);
                        break;
                    case 2:
                        yield return (opCode, BitConverter.ToInt16(ilBytes, index));
                        break;
                    case 4:
                        yield return (opCode, BitConverter.ToInt32(ilBytes, index));
                        break;
                    case 8:
                        yield return (opCode, BitConverter.ToInt64(ilBytes, index));
                        break;
                    default:
                        throw new NotSupportedException($"Unsupported opcode argument length {argLength}");
                }
                
                index += argLength;
            }
        }

        private static int GetOperandSize(OpCode opCode)
        {
            switch (opCode.OperandType)
            {
                case OperandType.InlineField:
                case OperandType.InlineBrTarget:
                case OperandType.InlineI:
                case OperandType.InlineMethod:
                case OperandType.InlineSig:
                case OperandType.InlineString:
                case OperandType.InlineSwitch:
                case OperandType.InlineTok:
                case OperandType.InlineType:
                case OperandType.ShortInlineR:
                    return 4;
                case OperandType.InlineI8:
                case OperandType.InlineR:
                    return 8;
                case OperandType.InlineNone:
                    return 0;
                case OperandType.InlineVar:
                    return 2;
                case OperandType.ShortInlineBrTarget:
                case OperandType.ShortInlineVar:
                case OperandType.ShortInlineI:
                    return 1;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
}
```

`UnhollowerBaseLib/ObjectCollectedException.cs`:

```cs
using System;

namespace UnhollowerBaseLib
{
    public class ObjectCollectedException : Exception
    {
        public ObjectCollectedException(string message) : base(message)
        {
        }
    }
}
```

`UnhollowerBaseLib/Runtime/ClassInjectorBase.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime
{
    public static class ClassInjectorBase
    {
        public static object GetMonoObjectFromIl2CppPointer(IntPtr pointer)
        {
            var gcHandle = GetGcHandlePtrFromIl2CppObject(pointer);
            return GCHandle.FromIntPtr(gcHandle).Target;
        }

        public static unsafe IntPtr GetGcHandlePtrFromIl2CppObject(IntPtr pointer)
        {
            if (pointer == IntPtr.Zero) throw new NullReferenceException();
            var objectKlass = (Il2CppClass*) IL2CPP.il2cpp_object_get_class(pointer);
            var targetGcHandlePointer = IntPtr.Add(pointer, (int) UnityVersionHandler.Wrap(objectKlass).InstanceSize - IntPtr.Size);
            var gcHandle = *(IntPtr*) targetGcHandlePointer;
            return gcHandle;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/Il2CppApi.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime
{
    internal unsafe static class Il2CppApi
    {
        #region IL2CPP Functions

        public static void il2cpp_init(IntPtr domain_name) => IL2CPP.il2cpp_init(domain_name);

        public static void il2cpp_init_utf16(IntPtr domain_name) => IL2CPP.il2cpp_init_utf16(domain_name);

        public static void il2cpp_shutdown() => IL2CPP.il2cpp_shutdown();

        public static void il2cpp_set_config_dir(IntPtr config_path) => IL2CPP.il2cpp_set_config_dir(config_path);

        public static void il2cpp_set_data_dir(IntPtr data_path) => IL2CPP.il2cpp_set_data_dir(data_path);

        public static void il2cpp_set_temp_dir(IntPtr temp_path) => IL2CPP.il2cpp_set_temp_dir(temp_path);

        public static void il2cpp_set_commandline_arguments(int argc, IntPtr argv, IntPtr basedir) => IL2CPP.il2cpp_set_commandline_arguments(argc, argv, basedir);

        public static void il2cpp_set_commandline_arguments_utf16(int argc, IntPtr argv, IntPtr basedir) => IL2CPP.il2cpp_set_commandline_arguments_utf16(argc, argv, basedir);

        public static void il2cpp_set_config_utf16(IntPtr executablePath) => IL2CPP.il2cpp_set_config_utf16(executablePath);

        public static void il2cpp_set_config(IntPtr executablePath) => IL2CPP.il2cpp_set_config(executablePath);

        public static void il2cpp_set_memory_callbacks(IntPtr callbacks) => IL2CPP.il2cpp_set_memory_callbacks(callbacks);

        public static IntPtr il2cpp_get_corlib() => IL2CPP.il2cpp_get_corlib();

        public static void il2cpp_add_internal_call(IntPtr name, IntPtr method) => IL2CPP.il2cpp_add_internal_call(name, method);

        public static IntPtr il2cpp_resolve_icall([MarshalAs(UnmanagedType.LPStr)] string name) => IL2CPP.il2cpp_resolve_icall(name);

        public static IntPtr il2cpp_alloc(uint size) => IL2CPP.il2cpp_alloc(size);

        public static void il2cpp_free(IntPtr ptr) => IL2CPP.il2cpp_free(ptr);

        #endregion

        #region Arrays

        public static IntPtr il2cpp_array_class_get(IntPtr element_class, uint rank) => IL2CPP.il2cpp_array_class_get(element_class, rank);

        public static uint il2cpp_array_length(IntPtr array) => IL2CPP.il2cpp_array_length(array);

        public static uint il2cpp_array_get_byte_length(IntPtr array) => IL2CPP.il2cpp_array_get_byte_length(array);

        public static IntPtr il2cpp_array_new(IntPtr elementTypeInfo, ulong length) => IL2CPP.il2cpp_array_new(elementTypeInfo, length);

        public static IntPtr il2cpp_array_new_specific(IntPtr arrayTypeInfo, ulong length) => IL2CPP.il2cpp_array_new_specific(arrayTypeInfo, length);

        public static IntPtr il2cpp_array_new_full(IntPtr array_class, ref ulong lengths, ref ulong lower_bounds) => IL2CPP.il2cpp_array_new_full(array_class, ref lengths, ref lower_bounds);

        public static IntPtr il2cpp_bounded_array_class_get(IntPtr element_class, uint rank, bool bounded) => IL2CPP.il2cpp_bounded_array_class_get(element_class, rank, bounded);

        public static int il2cpp_array_element_size(IntPtr array_class) => IL2CPP.il2cpp_array_element_size(array_class);

        #endregion

        #region Assemblies

        public static IntPtr il2cpp_assembly_get_image(IntPtr assembly) => IL2CPP.il2cpp_assembly_get_image(assembly);

        public static IntPtr il2cpp_assembly_get_name(IntPtr assembly) => UnityVersionHandler.assemblyStructHandler.il2cpp_assembly_get_name(assembly);

        #endregion

        #region Classes

        public static IntPtr il2cpp_class_enum_basetype(IntPtr klass) => IL2CPP.il2cpp_class_enum_basetype(klass);

        public static bool il2cpp_class_is_generic(IntPtr klass) => IL2CPP.il2cpp_class_is_generic(klass);

        public static bool il2cpp_class_is_inflated(IntPtr klass) => IL2CPP.il2cpp_class_is_inflated(klass);

        public static bool il2cpp_class_is_assignable_from(IntPtr klass, IntPtr oklass) => IL2CPP.il2cpp_class_is_assignable_from(klass, oklass);

        public static bool il2cpp_class_is_subclass_of(IntPtr klass, IntPtr klassc, bool check_interfaces) => IL2CPP.il2cpp_class_is_subclass_of(klass, klassc, check_interfaces);

        public static bool il2cpp_class_has_parent(IntPtr klass, IntPtr klassc) => IL2CPP.il2cpp_class_has_parent(klass, klassc);

        public static IntPtr il2cpp_class_from_il2cpp_type(IntPtr type) => IL2CPP.il2cpp_class_from_il2cpp_type(type);

        public static IntPtr il2cpp_class_from_name(IntPtr image, [MarshalAs(UnmanagedType.LPStr)] string namespaze, [MarshalAs(UnmanagedType.LPStr)] string name) => IL2CPP.il2cpp_class_from_name(image, namespaze, name);

        public static IntPtr il2cpp_class_from_system_type(IntPtr type) => IL2CPP.il2cpp_class_from_system_type(type);

        public static IntPtr il2cpp_class_get_element_class(IntPtr klass) => IL2CPP.il2cpp_class_get_element_class(klass);

        public static IntPtr il2cpp_class_get_events(IntPtr klass, ref IntPtr iter) => IL2CPP.il2cpp_class_get_events(klass, ref iter);

        public static IntPtr il2cpp_class_get_fields(IntPtr klass, ref IntPtr iter) => IL2CPP.il2cpp_class_get_fields(klass, ref iter);

        public static IntPtr il2cpp_class_get_nested_types(IntPtr klass, ref IntPtr iter) => IL2CPP.il2cpp_class_get_nested_types(klass, ref iter);

        public static IntPtr il2cpp_class_get_interfaces(IntPtr klass, ref IntPtr iter) => IL2CPP.il2cpp_class_get_interfaces(klass, ref iter);

        public static IntPtr il2cpp_class_get_properties(IntPtr klass, ref IntPtr iter) => IL2CPP.il2cpp_class_get_properties(klass, ref iter);

        public static IntPtr il2cpp_class_get_property_from_name(IntPtr klass, IntPtr name) => IL2CPP.il2cpp_class_get_property_from_name(klass, name);

        public static IntPtr il2cpp_class_get_field_from_name(IntPtr klass, [MarshalAs(UnmanagedType.LPStr)] string name) => IL2CPP.il2cpp_class_get_field_from_name(klass, name);

        public static IntPtr il2cpp_class_get_methods(IntPtr klass, ref IntPtr iter) => IL2CPP.il2cpp_class_get_methods(klass, ref iter);

        public static IntPtr il2cpp_class_get_method_from_name(IntPtr klass, [MarshalAs(UnmanagedType.LPStr)] string name, int argsCount) => IL2CPP.il2cpp_class_get_method_from_name(klass, name, argsCount);

        public static IntPtr il2cpp_class_get_name(IntPtr klass) => IL2CPP.il2cpp_class_get_name(klass);

        public static IntPtr il2cpp_class_get_namespace(IntPtr klass) => IL2CPP.il2cpp_class_get_namespace(klass);

        public static IntPtr il2cpp_class_get_parent(IntPtr klass) => IL2CPP.il2cpp_class_get_parent(klass);

        public static IntPtr il2cpp_class_get_declaring_type(IntPtr klass) => IL2CPP.il2cpp_class_get_declaring_type(klass);

        public static int il2cpp_class_instance_size(IntPtr klass) => IL2CPP.il2cpp_class_instance_size(klass);

        public static uint il2cpp_class_num_fields(IntPtr enumKlass) => IL2CPP.il2cpp_class_num_fields(enumKlass);

        public static bool il2cpp_class_is_valuetype(IntPtr klass) => IL2CPP.il2cpp_class_is_valuetype(klass);

        public static int il2cpp_class_value_size(IntPtr klass, ref uint align) => IL2CPP.il2cpp_class_value_size(klass, ref align);

        public static bool il2cpp_class_is_blittable(IntPtr klass) => IL2CPP.il2cpp_class_is_blittable(klass);

        public static int il2cpp_class_get_flags(IntPtr klass) => IL2CPP.il2cpp_class_get_flags(klass);

        public static bool il2cpp_class_is_abstract(IntPtr klass) => IL2CPP.il2cpp_class_is_abstract(klass);

        public static bool il2cpp_class_is_interface(IntPtr klass) => IL2CPP.il2cpp_class_is_interface(klass);

        public static int il2cpp_class_array_element_size(IntPtr klass) => IL2CPP.il2cpp_class_array_element_size(klass);

        public static IntPtr il2cpp_class_from_type(IntPtr type) => IL2CPP.il2cpp_class_from_type(type);

        public static IntPtr il2cpp_class_get_type(IntPtr klass) => IL2CPP.il2cpp_class_get_type(klass);

        public static uint il2cpp_class_get_type_token(IntPtr klass) => IL2CPP.il2cpp_class_get_type_token(klass);

        public static bool il2cpp_class_has_attribute(IntPtr klass, IntPtr attr_class) => IL2CPP.il2cpp_class_has_attribute(klass, attr_class);

        public static bool il2cpp_class_has_references(IntPtr klass) => IL2CPP.il2cpp_class_has_references(klass);

        public static bool il2cpp_class_is_enum(IntPtr klass) => IL2CPP.il2cpp_class_is_enum(klass);

        public static IntPtr il2cpp_class_get_image(IntPtr klass) => IL2CPP.il2cpp_class_get_image(klass);

        public static IntPtr il2cpp_class_get_assemblyname(IntPtr klass) => IL2CPP.il2cpp_class_get_assemblyname(klass);

        public static int il2cpp_class_get_rank(IntPtr klass) => IL2CPP.il2cpp_class_get_rank(klass);

        public static uint il2cpp_class_get_bitmap_size(IntPtr klass) => IL2CPP.il2cpp_class_get_bitmap_size(klass);

        public static void il2cpp_class_get_bitmap(IntPtr klass, ref uint bitmap) => IL2CPP.il2cpp_class_get_bitmap(klass, ref bitmap);

        #endregion

        #region Custom Attributes

        public static IntPtr il2cpp_custom_attrs_from_class(IntPtr klass) => IL2CPP.il2cpp_custom_attrs_from_class(klass);

        public static IntPtr il2cpp_custom_attrs_from_method(IntPtr method) => IL2CPP.il2cpp_custom_attrs_from_method(method);

        public static IntPtr il2cpp_custom_attrs_get_attr(IntPtr ainfo, IntPtr attr_klass) => IL2CPP.il2cpp_custom_attrs_get_attr(ainfo, attr_klass);

        public static bool il2cpp_custom_attrs_has_attr(IntPtr ainfo, IntPtr attr_klass) => IL2CPP.il2cpp_custom_attrs_has_attr(ainfo, attr_klass);

        public static IntPtr il2cpp_custom_attrs_construct(IntPtr cinfo) => IL2CPP.il2cpp_custom_attrs_construct(cinfo);

        public static void il2cpp_custom_attrs_free(IntPtr ainfo) => IL2CPP.il2cpp_custom_attrs_free(ainfo);

        #endregion

        #region Debugging

        public static void il2cpp_set_find_plugin_callback(IntPtr method) => IL2CPP.il2cpp_set_find_plugin_callback(method);

        public static void il2cpp_register_log_callback(IntPtr method) => IL2CPP.il2cpp_register_log_callback(method);

        public static void il2cpp_debugger_set_agent_options(IntPtr options) => IL2CPP.il2cpp_debugger_set_agent_options(options);

        public static bool il2cpp_is_debugger_attached() => IL2CPP.il2cpp_is_debugger_attached();

        public static unsafe void il2cpp_unity_install_unitytls_interface(void* unitytlsInterfaceStruct) => IL2CPP.il2cpp_unity_install_unitytls_interface(unitytlsInterfaceStruct);

        #endregion

        #region Domains

        public static IntPtr il2cpp_domain_get() => IL2CPP.il2cpp_domain_get();

        public static IntPtr il2cpp_domain_assembly_open(IntPtr domain, IntPtr name) => IL2CPP.il2cpp_domain_assembly_open(domain, name);

        public static IntPtr* il2cpp_domain_get_assemblies(IntPtr domain, ref uint size) => IL2CPP.il2cpp_domain_get_assemblies(domain, ref size);

        #endregion

        #region Exceptions

        public static IntPtr il2cpp_exception_from_name_msg(IntPtr image, IntPtr name_space, IntPtr name, IntPtr msg) => IL2CPP.il2cpp_exception_from_name_msg(image, name_space, name, msg);

        public static IntPtr il2cpp_get_exception_argument_null(IntPtr arg) => IL2CPP.il2cpp_get_exception_argument_null(arg);

        public static void il2cpp_format_exception(IntPtr ex, void* message, int message_size) => IL2CPP.il2cpp_format_exception(ex, message, message_size);

        public static void il2cpp_format_stack_trace(IntPtr ex, void* output, int output_size) => IL2CPP.il2cpp_format_stack_trace(ex, output, output_size);

        public static void il2cpp_unhandled_exception(IntPtr ex) => IL2CPP.il2cpp_unhandled_exception(ex);

        #endregion

        #region Fields

        public static int il2cpp_field_get_flags(IntPtr field) => IL2CPP.il2cpp_field_get_flags(field);

        public static IntPtr il2cpp_field_get_name(IntPtr field) => UnityVersionHandler.fieldInfoStructHandler.il2cpp_field_get_name(field);

        public static IntPtr il2cpp_field_get_parent(IntPtr field) => UnityVersionHandler.fieldInfoStructHandler.il2cpp_field_get_parent(field);

        public static uint il2cpp_field_get_offset(IntPtr field) => UnityVersionHandler.fieldInfoStructHandler.il2cpp_field_get_offset(field);

        public static IntPtr il2cpp_field_get_type(IntPtr field) => UnityVersionHandler.fieldInfoStructHandler.il2cpp_field_get_type(field);

        public static void il2cpp_field_get_value(IntPtr obj, IntPtr field, void* value) => IL2CPP.il2cpp_field_get_value(obj, field, value);

        public static IntPtr il2cpp_field_get_value_object(IntPtr field, IntPtr obj) => IL2CPP.il2cpp_field_get_value_object(field, obj);

        public static bool il2cpp_field_has_attribute(IntPtr field, IntPtr attr_class) => IL2CPP.il2cpp_field_has_attribute(field, attr_class);

        public static void il2cpp_field_set_value(IntPtr obj, IntPtr field, void* value) => IL2CPP.il2cpp_field_set_value(obj, field, value);

        public static void il2cpp_field_static_get_value(IntPtr field, void* value) => IL2CPP.il2cpp_field_static_get_value(field, value);

        public static void il2cpp_field_static_set_value(IntPtr field, void* value) => IL2CPP.il2cpp_field_static_set_value(field, value);

        public static void il2cpp_field_set_value_object(IntPtr instance, IntPtr field, IntPtr value) => IL2CPP.il2cpp_field_set_value_object(instance, field, value);

        #endregion

        #region Garbage Collector

        public static void il2cpp_gc_collect(int maxGenerations) => IL2CPP.il2cpp_gc_collect(maxGenerations);

        public static int il2cpp_gc_collect_a_little() => IL2CPP.il2cpp_gc_collect_a_little();

        public static void il2cpp_gc_disable() => IL2CPP.il2cpp_gc_disable();

        public static void il2cpp_gc_enable() => IL2CPP.il2cpp_gc_enable();

        public static bool il2cpp_gc_is_disabled() => IL2CPP.il2cpp_gc_is_disabled();

        public static long il2cpp_gc_get_used_size() => IL2CPP.il2cpp_gc_get_used_size();

        public static long il2cpp_gc_get_heap_size() => IL2CPP.il2cpp_gc_get_heap_size();

        public static void il2cpp_gc_wbarrier_set_field(IntPtr obj, IntPtr targetAddress, IntPtr gcObj) => IL2CPP.il2cpp_gc_wbarrier_set_field(obj, targetAddress, gcObj);

        #endregion

        #region GC Handles

        public static uint il2cpp_gchandle_new(IntPtr obj, bool pinned) => IL2CPP.il2cpp_gchandle_new(obj, pinned);

        public static uint il2cpp_gchandle_new_weakref(IntPtr obj, bool track_resurrection) => IL2CPP.il2cpp_gchandle_new_weakref(obj, track_resurrection);

        public static IntPtr il2cpp_gchandle_get_target(uint gchandle) => IL2CPP.il2cpp_gchandle_get_target(gchandle);

        public static void il2cpp_gchandle_free(uint gchandle) => IL2CPP.il2cpp_gchandle_free(gchandle);

        #endregion

        #region Images

        public static IntPtr il2cpp_image_get_assembly(IntPtr image) => IL2CPP.il2cpp_image_get_assembly(image);

        public static IntPtr il2cpp_image_get_name(IntPtr image) => IL2CPP.il2cpp_image_get_name(image);

        public static IntPtr il2cpp_image_get_filename(IntPtr image) => IL2CPP.il2cpp_image_get_filename(image);

        public static IntPtr il2cpp_image_get_entry_point(IntPtr image) => IL2CPP.il2cpp_image_get_entry_point(image);

        public static uint il2cpp_image_get_class_count(IntPtr image) => IL2CPP.il2cpp_image_get_class_count(image);

        public static IntPtr il2cpp_image_get_class(IntPtr image, uint index) => IL2CPP.il2cpp_image_get_class(image, index);

        #endregion

        #region Memory

        public static IntPtr il2cpp_capture_memory_snapshot() => IL2CPP.il2cpp_capture_memory_snapshot();

        public static void il2cpp_free_captured_memory_snapshot(IntPtr snapshot) => IL2CPP.il2cpp_free_captured_memory_snapshot(snapshot);

        #endregion

        #region Methods

        public static IntPtr il2cpp_method_get_return_type(IntPtr method) => UnityVersionHandler.methodInfoStructHandler.il2cpp_method_get_return_type(method);

        public static IntPtr il2cpp_method_get_declaring_type(IntPtr method) => IL2CPP.il2cpp_method_get_declaring_type(method);

        public static IntPtr il2cpp_method_get_name(IntPtr method) => UnityVersionHandler.methodInfoStructHandler.il2cpp_method_get_name(method);

        public static IntPtr il2cpp_method_get_from_reflection(IntPtr method) => IL2CPP.il2cpp_method_get_from_reflection(method);

        public static IntPtr il2cpp_method_get_object(IntPtr method, IntPtr refclass) => IL2CPP.il2cpp_method_get_object(method, refclass);

        public static bool il2cpp_method_is_generic(IntPtr method) => IL2CPP.il2cpp_method_is_generic(method);

        public static bool il2cpp_method_is_inflated(IntPtr method) => IL2CPP.il2cpp_method_is_inflated(method);

        public static bool il2cpp_method_is_instance(IntPtr method) => IL2CPP.il2cpp_method_is_instance(method);

        public static uint il2cpp_method_get_param_count(IntPtr method) => UnityVersionHandler.methodInfoStructHandler.il2cpp_method_get_param_count(method);

        public static IntPtr il2cpp_method_get_param(IntPtr method, uint index) => IL2CPP.il2cpp_method_get_param(method, index);

        public static IntPtr il2cpp_method_get_class(IntPtr method) => UnityVersionHandler.methodInfoStructHandler.il2cpp_method_get_class(method);

        public static bool il2cpp_method_has_attribute(IntPtr method, IntPtr attr_class) => IL2CPP.il2cpp_method_has_attribute(method, attr_class);

        public static uint il2cpp_method_get_flags(IntPtr method, ref uint iflags) => IL2CPP.il2cpp_method_get_flags(method, ref iflags);

        public static uint il2cpp_method_get_token(IntPtr method) => UnityVersionHandler.methodInfoStructHandler.il2cpp_method_get_token(method);

        public static IntPtr il2cpp_method_get_param_name(IntPtr method, uint index) => IL2CPP.il2cpp_method_get_param_name(method, index);

        #endregion

        #region Monitors

        public static void il2cpp_monitor_enter(IntPtr obj) => IL2CPP.il2cpp_monitor_enter(obj);

        public static bool il2cpp_monitor_try_enter(IntPtr obj, uint timeout) => IL2CPP.il2cpp_monitor_try_enter(obj, timeout);

        public static void il2cpp_monitor_exit(IntPtr obj) => IL2CPP.il2cpp_monitor_exit(obj);

        public static void il2cpp_monitor_pulse(IntPtr obj) => IL2CPP.il2cpp_monitor_pulse(obj);

        public static void il2cpp_monitor_pulse_all(IntPtr obj) => IL2CPP.il2cpp_monitor_pulse_all(obj);

        public static void il2cpp_monitor_wait(IntPtr obj) => IL2CPP.il2cpp_monitor_wait(obj);

        public static bool il2cpp_monitor_try_wait(IntPtr obj, uint timeout) => IL2CPP.il2cpp_monitor_try_wait(obj, timeout);

        #endregion

        #region Objects

        public static IntPtr il2cpp_object_get_class(IntPtr obj) => IL2CPP.il2cpp_object_get_class(obj);

        public static uint il2cpp_object_get_size(IntPtr obj) => IL2CPP.il2cpp_object_get_size(obj);

        public static IntPtr il2cpp_object_get_virtual_method(IntPtr obj, IntPtr method) => IL2CPP.il2cpp_object_get_virtual_method(obj, method);

        public static IntPtr il2cpp_object_new(IntPtr klass) => IL2CPP.il2cpp_object_new(klass);

        public static IntPtr il2cpp_object_unbox(IntPtr obj) => IL2CPP.il2cpp_object_unbox(obj);

        public static IntPtr il2cpp_value_box(IntPtr klass, IntPtr data) => IL2CPP.il2cpp_value_box(klass, data);

        #endregion

        #region Profilers

        public static void il2cpp_profiler_install(IntPtr prof, IntPtr shutdown_callback) => IL2CPP.il2cpp_profiler_install(prof, shutdown_callback);

        // public static void il2cpp_profiler_set_events(IL2CPP_ProfileFlags events) => IL2CPP.il2cpp_profiler_set_events(events);

        public static void il2cpp_profiler_install_enter_leave(IntPtr enter, IntPtr leave) => IL2CPP.il2cpp_profiler_install_enter_leave(enter, leave);

        public static void il2cpp_profiler_install_allocation(IntPtr callback) => IL2CPP.il2cpp_profiler_install_allocation(callback);

        public static void il2cpp_profiler_install_gc(IntPtr callback, IntPtr heap_resize_callback) => IL2CPP.il2cpp_profiler_install_gc(callback, heap_resize_callback);

        public static void il2cpp_profiler_install_fileio(IntPtr callback) => IL2CPP.il2cpp_profiler_install_fileio(callback);

        public static void il2cpp_profiler_install_thread(IntPtr start, IntPtr end) => IL2CPP.il2cpp_profiler_install_thread(start, end);

        #endregion

        #region Properties

        public static uint il2cpp_property_get_flags(IntPtr prop) => IL2CPP.il2cpp_property_get_flags(prop);

        public static IntPtr il2cpp_property_get_get_method(IntPtr prop) => UnityVersionHandler.propertyInfoStructHandler.il2cpp_property_get_get_method(prop);

        public static IntPtr il2cpp_property_get_set_method(IntPtr prop) => UnityVersionHandler.propertyInfoStructHandler.il2cpp_property_get_set_method(prop);

        public static IntPtr il2cpp_property_get_name(IntPtr prop) => UnityVersionHandler.propertyInfoStructHandler.il2cpp_property_get_name(prop);

        public static IntPtr il2cpp_property_get_parent(IntPtr prop) => UnityVersionHandler.propertyInfoStructHandler.il2cpp_property_get_parent(prop);

        #endregion

        #region Runtime Invoke

        public static unsafe IntPtr il2cpp_runtime_invoke(IntPtr method, IntPtr obj, void** param, ref IntPtr exc) => IL2CPP.il2cpp_runtime_invoke(method, obj, param, ref exc);

        // param can be of Il2CppObject*
        public static unsafe IntPtr il2cpp_runtime_invoke_convert_args(IntPtr method, IntPtr obj, void** param, int paramCount, ref IntPtr exc) => IL2CPP.il2cpp_runtime_invoke_convert_args(method, obj, param, paramCount, ref exc);

        public static void il2cpp_runtime_class_init(IntPtr klass) => IL2CPP.il2cpp_runtime_class_init(klass);

        public static void il2cpp_runtime_object_init(IntPtr obj) => IL2CPP.il2cpp_runtime_object_init(obj);

        public static void il2cpp_runtime_object_init_exception(IntPtr obj, ref IntPtr exc) => IL2CPP.il2cpp_runtime_object_init_exception(obj, ref exc);

        // public static void il2cpp_runtime_unhandled_exception_policy_set(IL2CPP_RuntimeUnhandledExceptionPolicy value) => IL2CPP.il2cpp_runtime_unhandled_exception_policy_set(value);

        #endregion

        #region Stats

        public static bool il2cpp_stats_dump_to_file(IntPtr path) => IL2CPP.il2cpp_stats_dump_to_file(path);

        //public static ulong il2cpp_stats_get_value(IL2CPP_Stat stat) => IL2CPP.il2cpp_stats_get_value(stat);

        #endregion

        #region Strings

        public static int il2cpp_string_length(IntPtr str) => IL2CPP.il2cpp_string_length(str);

        public static unsafe char* il2cpp_string_chars(IntPtr str) => IL2CPP.il2cpp_string_chars(str);

        public static IntPtr il2cpp_string_new(string str) => IL2CPP.il2cpp_string_new(str);

        public static IntPtr il2cpp_string_new_len(string str, uint length) => IL2CPP.il2cpp_string_new_len(str, length);

        public static IntPtr il2cpp_string_new_utf16(char* text, int len) => IL2CPP.il2cpp_string_new_utf16(text, len);

        public static IntPtr il2cpp_string_new_wrapper(string str) => IL2CPP.il2cpp_string_new_wrapper(str);

        public static IntPtr il2cpp_string_intern(string str) => IL2CPP.il2cpp_string_intern(str);

        public static IntPtr il2cpp_string_is_interned(string str) => IL2CPP.il2cpp_string_is_interned(str);

        #endregion

        #region Threads

        public static IntPtr il2cpp_thread_current() => IL2CPP.il2cpp_thread_current();

        public static IntPtr il2cpp_thread_attach(IntPtr domain) => IL2CPP.il2cpp_thread_attach(domain);

        public static void il2cpp_thread_detach(IntPtr thread) => IL2CPP.il2cpp_thread_detach(thread);

        public static void** il2cpp_thread_get_all_attached_threads(ref uint size) => IL2CPP.il2cpp_thread_get_all_attached_threads(ref size);

        public static bool il2cpp_is_vm_thread(IntPtr thread) => IL2CPP.il2cpp_is_vm_thread(thread);

        public static void il2cpp_current_thread_walk_frame_stack(IntPtr func, IntPtr user_data) => IL2CPP.il2cpp_current_thread_walk_frame_stack(func, user_data);

        public static void il2cpp_thread_walk_frame_stack(IntPtr thread, IntPtr func, IntPtr user_data) => IL2CPP.il2cpp_thread_walk_frame_stack(thread, func, user_data);

        public static bool il2cpp_current_thread_get_top_frame(IntPtr frame) => IL2CPP.il2cpp_current_thread_get_top_frame(frame);

        public static bool il2cpp_thread_get_top_frame(IntPtr thread, IntPtr frame) => IL2CPP.il2cpp_thread_get_top_frame(thread, frame);

        public static bool il2cpp_current_thread_get_frame_at(int offset, IntPtr frame) => IL2CPP.il2cpp_current_thread_get_frame_at(offset, frame);

        public static bool il2cpp_thread_get_frame_at(IntPtr thread, int offset, IntPtr frame) => IL2CPP.il2cpp_thread_get_frame_at(thread, offset, frame);

        public static int il2cpp_current_thread_get_stack_depth() => IL2CPP.il2cpp_current_thread_get_stack_depth();

        public static int il2cpp_thread_get_stack_depth(IntPtr thread) => IL2CPP.il2cpp_thread_get_stack_depth(thread);

        #endregion

        #region Types

        public static IntPtr il2cpp_type_get_object(IntPtr type) => IL2CPP.il2cpp_type_get_object(type);

        public static int il2cpp_type_get_type(IntPtr type) => IL2CPP.il2cpp_type_get_type(type);

        public static IntPtr il2cpp_type_get_class_or_element_class(IntPtr type) => IL2CPP.il2cpp_type_get_class_or_element_class(type);

        public static IntPtr il2cpp_type_get_name(IntPtr type) => IL2CPP.il2cpp_type_get_name(type);

        public static bool il2cpp_type_is_byref(IntPtr type) => IL2CPP.il2cpp_type_is_byref(type);

        public static uint il2cpp_type_get_attrs(IntPtr type) => IL2CPP.il2cpp_type_get_attrs(type);

        public static bool il2cpp_type_equals(IntPtr type, IntPtr otherType) => IL2CPP.il2cpp_type_equals(type, otherType);

        public static IntPtr il2cpp_type_get_assembly_qualified_name(IntPtr type) => IL2CPP.il2cpp_type_get_assembly_qualified_name(type);

        #endregion

        #region Unity Liveness

        public static IntPtr il2cpp_unity_liveness_calculation_begin(IntPtr filter, int max_object_count, IntPtr callback, IntPtr userdata, IntPtr onWorldStarted, IntPtr onWorldStopped) => IL2CPP.il2cpp_unity_liveness_calculation_begin(filter, max_object_count, callback, userdata, onWorldStarted, onWorldStopped);

        public static void il2cpp_unity_liveness_calculation_end(IntPtr state) => IL2CPP.il2cpp_unity_liveness_calculation_end(state);

        public static void il2cpp_unity_liveness_calculation_from_root(IntPtr root, IntPtr state) => IL2CPP.il2cpp_unity_liveness_calculation_from_root(root, state);

        public static void il2cpp_unity_liveness_calculation_from_statics(IntPtr state) => IL2CPP.il2cpp_unity_liveness_calculation_from_statics(state);

        #endregion
    }
}

```

`UnhollowerBaseLib/Runtime/Il2CppStructs.cs`:

```cs
using System;
using System.Runtime.InteropServices;

// ReSharper disable FieldCanBeMadeReadOnly.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable NotAccessedField.Global
// ReSharper disable IdentifierTypo
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global

namespace UnhollowerBaseLib.Runtime
{
    //Stub structs
    public struct Il2CppAssembly { }
    public struct Il2CppClass { }
    public struct Il2CppEventInfo { }
    public struct Il2CppException { }
    public struct Il2CppFieldInfo { }
    public struct Il2CppImage { }
    public struct Il2CppMethodInfo { }
    public struct Il2CppParameterInfo { }
    public struct Il2CppPropertyInfo { }
    public struct Il2CppTypeStruct { }


    [Flags]
    public enum Il2CppMethodImplFlags : ushort
    {
        METHOD_IMPL_ATTRIBUTE_CODE_TYPE_MASK = 0x0003,
        METHOD_IMPL_ATTRIBUTE_IL = 0x0000,
        METHOD_IMPL_ATTRIBUTE_NATIVE = 0x0001,
        METHOD_IMPL_ATTRIBUTE_OPTIL = 0x0002,
        METHOD_IMPL_ATTRIBUTE_RUNTIME = 0x0003,

        METHOD_IMPL_ATTRIBUTE_MANAGED_MASK = 0x0004,
        METHOD_IMPL_ATTRIBUTE_UNMANAGED = 0x0004,
        METHOD_IMPL_ATTRIBUTE_MANAGED = 0x0000,

        METHOD_IMPL_ATTRIBUTE_FORWARD_REF = 0x0010,
        METHOD_IMPL_ATTRIBUTE_PRESERVE_SIG = 0x0080,
        METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL = 0x1000,
        METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED = 0x0020,
        METHOD_IMPL_ATTRIBUTE_NOINLINING = 0x0008,
        METHOD_IMPL_ATTRIBUTE_MAX_METHOD_IMPL_VAL = 0xffff,
    }

    [Flags]
    public enum Il2CppMethodFlags : ushort
    {
        METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK = 0x0007,
        METHOD_ATTRIBUTE_COMPILER_CONTROLLED = 0x0000,
        METHOD_ATTRIBUTE_PRIVATE = 0x0001,
        METHOD_ATTRIBUTE_FAM_AND_ASSEM = 0x0002,
        METHOD_ATTRIBUTE_ASSEM = 0x0003,
        METHOD_ATTRIBUTE_FAMILY = 0x0004,
        METHOD_ATTRIBUTE_FAM_OR_ASSEM = 0x0005,
        METHOD_ATTRIBUTE_PUBLIC = 0x0006,

        METHOD_ATTRIBUTE_STATIC = 0x0010,
        METHOD_ATTRIBUTE_FINAL = 0x0020,
        METHOD_ATTRIBUTE_VIRTUAL = 0x0040,
        METHOD_ATTRIBUTE_HIDE_BY_SIG = 0x0080,

        METHOD_ATTRIBUTE_VTABLE_LAYOUT_MASK = 0x0100,
        METHOD_ATTRIBUTE_REUSE_SLOT = 0x0000,
        METHOD_ATTRIBUTE_NEW_SLOT = 0x0100,

        METHOD_ATTRIBUTE_STRICT = 0x0200,
        METHOD_ATTRIBUTE_ABSTRACT = 0x0400,
        METHOD_ATTRIBUTE_SPECIAL_NAME = 0x0800,

        METHOD_ATTRIBUTE_PINVOKE_IMPL = 0x2000,
        METHOD_ATTRIBUTE_UNMANAGED_EXPORT = 0x0008,

        /*
         * For runtime use only
         */
        METHOD_ATTRIBUTE_RESERVED_MASK = 0xd000,
        METHOD_ATTRIBUTE_RT_SPECIAL_NAME = 0x1000,
        METHOD_ATTRIBUTE_HAS_SECURITY = 0x4000,
        METHOD_ATTRIBUTE_REQUIRE_SEC_OBJECT = 0x8000,
    }

    [Flags]
    public enum Il2CppClassAttributes : uint
    {
        TYPE_ATTRIBUTE_VISIBILITY_MASK = 0x00000007,
        TYPE_ATTRIBUTE_NOT_PUBLIC = 0x00000000,
        TYPE_ATTRIBUTE_PUBLIC = 0x00000001,
        TYPE_ATTRIBUTE_NESTED_PUBLIC = 0x00000002,
        TYPE_ATTRIBUTE_NESTED_PRIVATE = 0x00000003,
        TYPE_ATTRIBUTE_NESTED_FAMILY = 0x00000004,
        TYPE_ATTRIBUTE_NESTED_ASSEMBLY = 0x00000005,
        TYPE_ATTRIBUTE_NESTED_FAM_AND_ASSEM = 0x00000006,
        TYPE_ATTRIBUTE_NESTED_FAM_OR_ASSEM = 0x00000007,

        TYPE_ATTRIBUTE_LAYOUT_MASK = 0x00000018,
        TYPE_ATTRIBUTE_AUTO_LAYOUT = 0x00000000,
        TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT = 0x00000008,
        TYPE_ATTRIBUTE_EXPLICIT_LAYOUT = 0x00000010,

        TYPE_ATTRIBUTE_CLASS_SEMANTIC_MASK = 0x00000020,
        TYPE_ATTRIBUTE_CLASS = 0x00000000,
        TYPE_ATTRIBUTE_INTERFACE = 0x00000020,

        TYPE_ATTRIBUTE_ABSTRACT = 0x00000080,
        TYPE_ATTRIBUTE_SEALED = 0x00000100,
        TYPE_ATTRIBUTE_SPECIAL_NAME = 0x00000400,

        TYPE_ATTRIBUTE_IMPORT = 0x00001000,
        TYPE_ATTRIBUTE_SERIALIZABLE = 0x00002000,

        TYPE_ATTRIBUTE_STRING_FORMAT_MASK = 0x00030000,
        TYPE_ATTRIBUTE_ANSI_CLASS = 0x00000000,
        TYPE_ATTRIBUTE_UNICODE_CLASS = 0x00010000,
        TYPE_ATTRIBUTE_AUTO_CLASS = 0x00020000,

        TYPE_ATTRIBUTE_BEFORE_FIELD_INIT = 0x00100000,
        TYPE_ATTRIBUTE_FORWARDER = 0x00200000,

        TYPE_ATTRIBUTE_RESERVED_MASK = 0x00040800,
        TYPE_ATTRIBUTE_RT_SPECIAL_NAME = 0x00000800,
        TYPE_ATTRIBUTE_HAS_SECURITY = 0x00040000,
    }

    public enum Il2CppTypeEnum : byte
    {
        IL2CPP_TYPE_END         = 0x00,       /* End of List */
        IL2CPP_TYPE_VOID        = 0x01,
        IL2CPP_TYPE_BOOLEAN     = 0x02,
        IL2CPP_TYPE_CHAR        = 0x03,
        IL2CPP_TYPE_I1          = 0x04,
        IL2CPP_TYPE_U1          = 0x05,
        IL2CPP_TYPE_I2          = 0x06,
        IL2CPP_TYPE_U2          = 0x07,
        IL2CPP_TYPE_I4          = 0x08,
        IL2CPP_TYPE_U4          = 0x09,
        IL2CPP_TYPE_I8          = 0x0a,
        IL2CPP_TYPE_U8          = 0x0b,
        IL2CPP_TYPE_R4          = 0x0c,
        IL2CPP_TYPE_R8          = 0x0d,
        IL2CPP_TYPE_STRING      = 0x0e,
        IL2CPP_TYPE_PTR         = 0x0f,       /* arg: <type> token */
        IL2CPP_TYPE_BYREF       = 0x10,       /* arg: <type> token */
        IL2CPP_TYPE_VALUETYPE   = 0x11,       /* arg: <type> token */
        IL2CPP_TYPE_CLASS       = 0x12,       /* arg: <type> token */
        IL2CPP_TYPE_VAR         = 0x13,       /* Generic parameter in a generic type definition, represented as number (compressed unsigned integer) number */
        IL2CPP_TYPE_ARRAY       = 0x14,       /* type, rank, boundsCount, bound1, loCount, lo1 */
        IL2CPP_TYPE_GENERICINST = 0x15,     /* <type> <type-arg-count> <type-1> \x{2026} <type-n> */
        IL2CPP_TYPE_TYPEDBYREF  = 0x16,
        IL2CPP_TYPE_I           = 0x18,
        IL2CPP_TYPE_U           = 0x19,
        IL2CPP_TYPE_FNPTR       = 0x1b,        /* arg: full method signature */
        IL2CPP_TYPE_OBJECT      = 0x1c,
        IL2CPP_TYPE_SZARRAY     = 0x1d,       /* 0-based one-dim-array */
        IL2CPP_TYPE_MVAR        = 0x1e,       /* Generic parameter in a generic method definition, represented as number (compressed unsigned integer)  */
        IL2CPP_TYPE_CMOD_REQD   = 0x1f,       /* arg: typedef or typeref token */
        IL2CPP_TYPE_CMOD_OPT    = 0x20,       /* optional arg: typedef or typref token */
        IL2CPP_TYPE_INTERNAL    = 0x21,       /* CLR internal type */

        IL2CPP_TYPE_MODIFIER    = 0x40,       /* Or with the following types */
        IL2CPP_TYPE_SENTINEL    = 0x41,       /* Sentinel for varargs method signature */
        IL2CPP_TYPE_PINNED      = 0x45,       /* Local var that points to pinned object */

        IL2CPP_TYPE_ENUM        = 0x55        /* an enumeration */
    }

    [Flags]
    public enum MethodInfoExtraFlags : byte
    {
        is_generic = 0x1,
        is_inflated = 0x2,
        wrapper_type = 0x4,
        is_marshalled_from_native = 0x8
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct VirtualInvokeData
    {
        public IntPtr methodPtr;
        public Il2CppMethodInfo* method;
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct Il2CppRuntimeInterfaceOffsetPair
    {
        public Il2CppClass* interfaceType;
        public int offset;
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct Il2CppObject
    {
        IntPtr data;
        IntPtr monitor;
    }


    [Flags]
    public enum ClassBitfield1 : byte
    {
        initialized_and_no_error = 0x1,
        valuetype = 0x2,
        initialized = 0x4,
        enumtype = 0x8,
        is_generic = 0x10,
        has_references = 0x20,
        init_pending = 0x40,
        size_inited = 0x80
    }

    [Flags]
    public enum ClassBitfield2 : byte
    {
        has_finalize = 0x1,
        has_cctor = 0x2,
        is_blittable = 0x4,
        is_import_or_windows_runtime = 0x8,
        is_vtable_initialized = 0x10,
        has_initialization_error = 0x20
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct Il2CppClassPart1
    {
        // The following fields are always valid for a Il2CppClass structure
        public Il2CppImage* image; // const
        public IntPtr gc_desc;
        public IntPtr name; // const char*
        public IntPtr namespaze; // const char*
        public Il2CppTypeStruct byval_arg; // not const, no ptr
        public Il2CppTypeStruct this_arg; // not const, no ptr
        public Il2CppClass* element_class; // not const
        public Il2CppClass* castClass; // not const
        public Il2CppClass* declaringType; // not const
        public Il2CppClass* parent; // not const
        public /*Il2CppGenericClass**/IntPtr generic_class;
        public /*Il2CppTypeDefinition**/IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions
        public /*Il2CppInteropData**/IntPtr interopData; // const
        public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
        // End always valid fields

        // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
        public Il2CppFieldInfo* fields; // Initialized in SetupFields
        public Il2CppEventInfo* events; // const; Initialized in SetupEvents
        public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
        public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
        public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
        public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
        public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
        public IntPtr static_fields; // not const; Initialized in Init
        public /*Il2CppRGCTXData**/IntPtr rgctx_data; // const; Initialized in Init
        // used for fast parent checks
        public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
        // End initialization required fields
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Il2CppClassPart2
    {
        public uint initializationExceptionGCHandle;

        public uint cctor_started;
        public uint cctor_finished;
        /*ALIGN_TYPE(8)*/ulong cctor_thread;

        // Remaining fields are always valid except where noted
        public /*GenericContainerIndex*/ int genericContainerIndex;
        public uint instance_size;
        public uint actualSize;
        public uint element_size;
        public int native_size;
        public uint static_fields_size;
        public uint thread_static_fields_size;
        public int thread_static_fields_offset;
        public Il2CppClassAttributes flags;
        public uint token;

        public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
        public ushort property_count;
        public ushort field_count;
        public ushort event_count;
        public ushort nested_type_count;
        public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
        public ushort interfaces_count;
        public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

        public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
        public byte genericRecursionDepth;
        public byte rank;
        public byte minimumAlignment; // Alignment of this type
        public byte naturalAligment; // Alignment of this type without accounting for packing
        public byte packingSize;

        // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
        // Use Class::UpdateInitializedAndNoError to update
        public ClassBitfield1 bitfield_1;
        /*uint8_t initialized_and_no_error : 1;

        uint8_t valuetype : 1;
        uint8_t initialized : 1;
        uint8_t enumtype : 1;
        uint8_t is_generic : 1;
        uint8_t has_references : 1;
        uint8_t init_pending : 1;
        uint8_t size_inited : 1;*/

        public ClassBitfield2 bitfield_2;
        /*uint8_t has_finalize : 1;
        uint8_t has_cctor : 1;
        uint8_t is_blittable : 1;
        uint8_t is_import_or_windows_runtime : 1;
        uint8_t is_vtable_initialized : 1;
        uint8_t has_initialization_error : 1;*/

        //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct Il2CppGenericInst
    {
        public uint type_argc;
        public Il2CppTypeStruct **type_argv;
    };

    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct Il2CppGenericContext
    {
        /* The instantiation corresponding to the class generic parameters */
        public Il2CppGenericInst *class_inst;
        /* The instantiation corresponding to the method generic parameters */
        public Il2CppGenericInst *method_inst;
    };


    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct Il2CppGenericMethod
    {
        public Il2CppMethodInfo* methodDefinition;
        public Il2CppGenericContext context;
    };

}
```

`UnhollowerBaseLib/Runtime/NativeStructUtils.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime
{
    public static class NativeStructUtils
    {
        public static IntPtr GetMethodInfoForMissingMethod(string methodName)
        {
            var methodInfo = UnityVersionHandler.NewMethod();
            methodInfo.Name = Marshal.StringToHGlobalAnsi(methodName);
            methodInfo.Slot = ushort.MaxValue;
            return methodInfo.Pointer;
        }

        public static unsafe bool CheckBit(this INativeStruct self, int startOffset, int bit)
        {
            var byteOffset = bit / 8;
            var bitOffset = bit % 8;
            var p = self.Pointer + startOffset + byteOffset;
            
            var mask = 1 << bitOffset;
            var val = *(byte*) p.ToPointer();
            var masked = val & mask;
            return masked == mask;
        }

        public static unsafe void SetBit(this INativeStruct self, int startOffset, int bit, bool value)
        {
            var byteOffset = bit / 8;
            var bitOffset = bit % 8;
            var p = self.Pointer + startOffset + byteOffset;

            var mask = ~(1 << bitOffset);
            var ptr = (byte*) p.ToPointer();
            var val = *ptr;
            var newVal = (byte)(val & mask | ((value ? 1 : 0) << bitOffset));
            *ptr = newVal;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/StructHandlerInterfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime
{
    public interface INativeStructHandler {}
    
    public interface INativeStruct
    {
        IntPtr Pointer { get; }
    }
}

```

`UnhollowerBaseLib/Runtime/UnityVersionHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnhollowerBaseLib.Runtime.VersionSpecific.Assembly;
using UnhollowerBaseLib.Runtime.VersionSpecific.Class;
using UnhollowerBaseLib.Runtime.VersionSpecific.EventInfo;
using UnhollowerBaseLib.Runtime.VersionSpecific.Exception;
using UnhollowerBaseLib.Runtime.VersionSpecific.FieldInfo;
using UnhollowerBaseLib.Runtime.VersionSpecific.Image;
using UnhollowerBaseLib.Runtime.VersionSpecific.MethodInfo;
using UnhollowerBaseLib.Runtime.VersionSpecific.ParameterInfo;
using UnhollowerBaseLib.Runtime.VersionSpecific.PropertyInfo;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    internal class ApplicableToUnityVersionsSinceAttribute : Attribute
    {
        public string StartVersion { get; }

        public ApplicableToUnityVersionsSinceAttribute(string startVersion)
        {
            StartVersion = startVersion;
        }
    }

    public static class UnityVersionHandler
    {
        private static readonly Type[] InterfacesOfInterest;
        private static readonly Dictionary<Type, List<(Version Version, object Handler)>> VersionedHandlers = new();
        private static readonly Dictionary<Type, object> Handlers = new();

        private static Version UnityVersion = new(2018, 4, 20);
        // Version since which extra_arg is set to invoke_multicast, necessitating constructor calls
        private static readonly Version DelegatesGotComplexVersion = new Version(2021, 2, 0);

        internal static INativeAssemblyStructHandler assemblyStructHandler;
        internal static INativeClassStructHandler classStructHandler;
        internal static INativeEventInfoStructHandler eventInfoStructHandler;
        internal static INativeExceptionStructHandler exceptionStructHandler;
        internal static INativeFieldInfoStructHandler fieldInfoStructHandler;
        internal static INativeImageStructHandler imageStructHandler;
        internal static INativeMethodInfoStructHandler methodInfoStructHandler;
        internal static INativeParameterInfoStructHandler parameterInfoStructHandler;
        internal static INativePropertyInfoStructHandler propertyInfoStructHandler;
        internal static INativeTypeStructHandler typeStructHandler;

        static UnityVersionHandler()
        {
            var allTypes = GetAllTypesSafe();
            var interfacesOfInterest = allTypes.Where(t => t.IsInterface && typeof(INativeStructHandler).IsAssignableFrom(t) && t != typeof(INativeStructHandler)).ToArray();
            InterfacesOfInterest = interfacesOfInterest;

            foreach (var i in interfacesOfInterest) VersionedHandlers[i] = new();

            foreach (var handlerImpl in allTypes.Where(t => !t.IsAbstract && interfacesOfInterest.Any(i => i.IsAssignableFrom(t))))
                foreach (var startVersion in handlerImpl.GetCustomAttributes<ApplicableToUnityVersionsSinceAttribute>())
                {
                    var instance = Activator.CreateInstance(handlerImpl);
                    foreach (var i in handlerImpl.GetInterfaces())
                        if (interfacesOfInterest.Contains(i))
                            VersionedHandlers[i].Add((Version.Parse(startVersion.StartVersion), instance));
                }

            foreach (var handlerList in VersionedHandlers.Values)
                handlerList.Sort((a, b) => -a.Version.CompareTo(b.Version));

            RecalculateHandlers();
        }

        public static bool MustUseDelegateConstructor { get; private set; }

        private static void RecalculateHandlers()
        {
            Handlers.Clear();
            foreach (var type in InterfacesOfInterest)
            {
                foreach (var valueTuple in VersionedHandlers[type])
                {
                    if (valueTuple.Version > UnityVersion) continue;

                    Handlers[type] = valueTuple.Handler;
                    break;
                }
            }
            assemblyStructHandler = GetHandler<INativeAssemblyStructHandler>();
            classStructHandler = GetHandler<INativeClassStructHandler>();
            eventInfoStructHandler = GetHandler<INativeEventInfoStructHandler>();
            exceptionStructHandler = GetHandler<INativeExceptionStructHandler>();
            fieldInfoStructHandler = GetHandler<INativeFieldInfoStructHandler>();
            imageStructHandler = GetHandler<INativeImageStructHandler>();
            methodInfoStructHandler = GetHandler<INativeMethodInfoStructHandler>();
            parameterInfoStructHandler = GetHandler<INativeParameterInfoStructHandler>();
            propertyInfoStructHandler = GetHandler<INativePropertyInfoStructHandler>();
            typeStructHandler = GetHandler<INativeTypeStructHandler>();

            MustUseDelegateConstructor = UnityVersion >= DelegatesGotComplexVersion;
        }

        private static T GetHandler<T>()
        {
            if (Handlers.TryGetValue(typeof(T), out var result))
                return (T) result;

            LogSupport.Error($"No direct for {typeof(T).FullName} found for Unity {UnityVersion}; this likely indicates a severe error somewhere");

            throw new ApplicationException("No handler");
        }

        public static IntPtr CopyMethodInfoStruct(IntPtr origMethodInfo)
        {
            return GetHandler<INativeMethodInfoStructHandler>().CopyMethodInfoStruct(origMethodInfo);
        }

        private static Type[] GetAllTypesSafe()
        {
            try
            {
                return typeof(UnityVersionHandler).Assembly.GetTypes();
            }
            catch (ReflectionTypeLoadException re)
            {
                return re.Types.Where(t => t != null).ToArray();
            }
        }

        /// <summary>
        ///     Initializes Unity interface for specified Unity version.
        /// </summary>
        /// <example>For Unity 2018.4.20, call <c>Initialize(2018, 4, 20)</c></example>
        public static void Initialize(int majorVersion, int minorVersion, int patchVersion)
        {
            UnityVersion = new Version(majorVersion, minorVersion, patchVersion);
            RecalculateHandlers();
        }



        //Assemblies
        public static INativeAssemblyStruct NewAssembly() =>
            assemblyStructHandler.CreateNewAssemblyStruct();

        public static unsafe INativeAssemblyStruct Wrap(Il2CppAssembly* assemblyPointer) =>
            assemblyStructHandler.Wrap(assemblyPointer);


        //Classes
        public static INativeClassStruct NewClass(int vTableSlots) =>
            classStructHandler.CreateNewClassStruct(vTableSlots);

        public static unsafe INativeClassStruct Wrap(Il2CppClass* classPointer) =>
            classStructHandler.Wrap(classPointer);


        //Events
        public static INativeEventInfoStruct NewEvent() =>
            eventInfoStructHandler.CreateNewEventInfoStruct();

        public static unsafe INativeEventInfoStruct Wrap(Il2CppEventInfo* eventInfoPointer) =>
            eventInfoStructHandler.Wrap(eventInfoPointer);


        //Exceptions
        public static INativeExceptionStruct NewException() =>
            exceptionStructHandler.CreateNewExceptionStruct();

        public static unsafe INativeExceptionStruct Wrap(Il2CppException* exceptionPointer) =>
            exceptionStructHandler.Wrap(exceptionPointer);


        //Fields
        public static INativeFieldInfoStruct NewField() =>
            fieldInfoStructHandler.CreateNewFieldInfoStruct();

        public static unsafe INativeFieldInfoStruct Wrap(Il2CppFieldInfo* fieldInfoPointer) =>
            fieldInfoStructHandler.Wrap(fieldInfoPointer);


        //Images
        public static INativeImageStruct NewImage() =>
            imageStructHandler.CreateNewImageStruct();
        
        public static unsafe INativeImageStruct Wrap(Il2CppImage* imagePointer) =>
            imageStructHandler.Wrap(imagePointer);
        

        //Methods
        public static INativeMethodInfoStruct NewMethod() =>
            methodInfoStructHandler.CreateNewMethodStruct();

        public static unsafe INativeMethodInfoStruct Wrap(Il2CppMethodInfo* methodPointer) =>
            methodInfoStructHandler.Wrap(methodPointer);

        public static IntPtr GetMethodFromReflection(IntPtr method) =>
            methodInfoStructHandler.GetMethodFromReflection(method);


        //Parameters
        public static unsafe Il2CppParameterInfo*[] NewMethodParameterArray(int count) =>
            parameterInfoStructHandler.CreateNewParameterInfoArray(count);

        public static unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* parameterInfo) =>
            parameterInfoStructHandler.Wrap(parameterInfo);

        public static unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* parameterInfo, int index) =>
            parameterInfoStructHandler.Wrap(parameterInfo, index);

        public static bool ParameterInfoHasNamePosToken() =>
            parameterInfoStructHandler.HasNamePosToken;


        //Properties
        public static INativePropertyInfoStruct NewProperty() =>
            propertyInfoStructHandler.CreateNewPropertyInfoStruct();

        public static unsafe INativePropertyInfoStruct Wrap(Il2CppPropertyInfo* propertyInfoPointer) =>
            propertyInfoStructHandler.Wrap(propertyInfoPointer);


        //Types
        public static INativeTypeStruct NewType() =>
            typeStructHandler.CreateNewTypeStruct();

        public static unsafe INativeTypeStruct Wrap(Il2CppTypeStruct* typePointer) =>
            typeStructHandler.Wrap(typePointer);
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Assembly/Assembly_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Assembly
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public unsafe class NativeAssemblyStructHandler_16_0 : INativeAssemblyStructHandler
    {
        public INativeAssemblyStruct CreateNewAssemblyStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppAssembly_16_0>());

            *(Il2CppAssembly_16_0*)pointer = default;

            return new NativeAssemblyStruct(pointer);
        }

        public INativeAssemblyStruct Wrap(Il2CppAssembly* assemblyPointer)
        {
            if ((IntPtr)assemblyPointer == IntPtr.Zero) return null;
            else return new NativeAssemblyStruct((IntPtr)assemblyPointer);
        }

        public IntPtr il2cpp_assembly_get_name(IntPtr assembly) => ((Il2CppAssembly_16_0*)assembly)->aname.name;

#if DEBUG
        public string GetName() => "NativeAssemblyStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssembly_16_0
        {
            public int imageIndex;
            public int customAttributeIndex;
            public Il2CppAssemblyName_16_0 aname;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssemblyName_16_0
        {
            public IntPtr name; // const char* 
            public IntPtr culture; // const char*
            public IntPtr hash_value; // const char*
            public IntPtr public_key; // const char*
            public uint hash_alg;
            public int hash_len;
            public uint flags;
            public int major;
            public int minor;
            public int build;
            public int revision;
            public long public_key_token; // PUBLIC_KEY_BYTE_LENGTH
        }

        internal class NativeAssemblyStruct : INativeAssemblyStruct
        {
            public NativeAssemblyStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppAssembly* AssemblyPointer => (Il2CppAssembly*)Pointer;

            private Il2CppAssembly_16_0* NativeAssembly => (Il2CppAssembly_16_0*)Pointer;

            private Il2CppImage* dummyImagePointer;

            public ref Il2CppImage* Image => ref dummyImagePointer;

            public ref IntPtr Name => ref NativeAssembly->aname.name;

            public ref int Major => ref NativeAssembly->aname.major;

            public ref int Minor => ref NativeAssembly->aname.minor;

            public ref int Build => ref NativeAssembly->aname.build;

            public ref int Revision => ref NativeAssembly->aname.revision;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Assembly/Assembly_20_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Assembly
{
    [ApplicableToUnityVersionsSince("5.3.3")]
    public unsafe class NativeAssemblyStructHandler_20_0 : INativeAssemblyStructHandler
    {
        public INativeAssemblyStruct CreateNewAssemblyStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppAssembly_20_0>());

            *(Il2CppAssembly_20_0*)pointer = default;

            return new NativeAssemblyStruct(pointer);
        }

        public INativeAssemblyStruct Wrap(Il2CppAssembly* assemblyPointer)
        {
            if ((IntPtr)assemblyPointer == IntPtr.Zero) return null;
            else return new NativeAssemblyStruct((IntPtr)assemblyPointer);
        }

        public IntPtr il2cpp_assembly_get_name(IntPtr assembly) => ((Il2CppAssembly_20_0*)assembly)->aname.name;

#if DEBUG
        public string GetName() => "NativeAssemblyStructHandler_20_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssembly_20_0
        {
            public int imageIndex;
            public int customAttributeIndex;
            public int referencedAssemblyStart;
            public int referencedAssemblyCount;
            public Il2CppAssemblyName_20_0 aname;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssemblyName_20_0
        {
            public IntPtr name; // const char* 
            public IntPtr culture; // const char*
            public IntPtr hash_value; // const char*
            public IntPtr public_key; // const char*
            public uint hash_alg;
            public int hash_len;
            public uint flags;
            public int major;
            public int minor;
            public int build;
            public int revision;
            public long public_key_token; // PUBLIC_KEY_BYTE_LENGTH
        }

        internal class NativeAssemblyStruct : INativeAssemblyStruct
        {
            public NativeAssemblyStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppAssembly* AssemblyPointer => (Il2CppAssembly*)Pointer;

            private Il2CppAssembly_20_0* NativeAssembly => (Il2CppAssembly_20_0*)Pointer;

            private Il2CppImage* dummyImagePointer;

            public ref Il2CppImage* Image => ref dummyImagePointer;

            public ref IntPtr Name => ref NativeAssembly->aname.name;

            public ref int Major => ref NativeAssembly->aname.major;

            public ref int Minor => ref NativeAssembly->aname.minor;

            public ref int Build => ref NativeAssembly->aname.build;

            public ref int Revision => ref NativeAssembly->aname.revision;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Assembly/Assembly_24_0_B.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Assembly
{
    [ApplicableToUnityVersionsSince("2018.1.0")]
    public unsafe class NativeAssemblyStructHandler_24_0_B : INativeAssemblyStructHandler
    {
        public INativeAssemblyStruct CreateNewAssemblyStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppAssembly_24_0_B>());

            *(Il2CppAssembly_24_0_B*)pointer = default;

            return new NativeAssemblyStruct(pointer);
        }

        public INativeAssemblyStruct Wrap(Il2CppAssembly* assemblyPointer)
        {
            if ((IntPtr)assemblyPointer == IntPtr.Zero) return null;
            else return new NativeAssemblyStruct((IntPtr)assemblyPointer);
        }

        public IntPtr il2cpp_assembly_get_name(IntPtr assembly) => ((Il2CppAssembly_24_0_B*)assembly)->aname.name;

#if DEBUG
        public string GetName() => "NativeAssemblyStructHandler_24_0_B";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssembly_24_0_B
        {
            public Il2CppImage* image;
            public int customAttributeIndex;
            public int referencedAssemblyStart;
            public int referencedAssemblyCount;
            public Il2CppAssemblyName_24_0_B aname;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssemblyName_24_0_B
        {
            public IntPtr name; // const char* 
            public IntPtr culture; // const char*
            public IntPtr hash_value; // const char*
            public IntPtr public_key; // const char*
            public uint hash_alg;
            public int hash_len;
            public uint flags;
            public int major;
            public int minor;
            public int build;
            public int revision;
            public long public_key_token; // PUBLIC_KEY_BYTE_LENGTH
        }

        internal class NativeAssemblyStruct : INativeAssemblyStruct
        {
            public NativeAssemblyStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppAssembly* AssemblyPointer => (Il2CppAssembly*)Pointer;

            private Il2CppAssembly_24_0_B* NativeAssembly => (Il2CppAssembly_24_0_B*)Pointer;

            public ref Il2CppImage* Image => ref NativeAssembly->image;

            public ref IntPtr Name => ref NativeAssembly->aname.name;

            public ref int Major => ref NativeAssembly->aname.major;

            public ref int Minor => ref NativeAssembly->aname.minor;

            public ref int Build => ref NativeAssembly->aname.build;

            public ref int Revision => ref NativeAssembly->aname.revision;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Assembly/Assembly_24_1.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Assembly
{
    [ApplicableToUnityVersionsSince("2018.3.0")]
    [ApplicableToUnityVersionsSince("2020.1.0")]
    public unsafe class NativeAssemblyStructHandler_24_1 : INativeAssemblyStructHandler
    {
        public INativeAssemblyStruct CreateNewAssemblyStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppAssembly_24_1>());

            *(Il2CppAssembly_24_1*)pointer = default;

            return new NativeAssemblyStruct(pointer);
        }

        public INativeAssemblyStruct Wrap(Il2CppAssembly* assemblyPointer)
        {
            if ((IntPtr)assemblyPointer == IntPtr.Zero) return null;
            else return new NativeAssemblyStruct((IntPtr)assemblyPointer);
        }

        public IntPtr il2cpp_assembly_get_name(IntPtr assembly) => ((Il2CppAssembly_24_1*)assembly)->aname.name;

#if DEBUG
        public string GetName() => "NativeAssemblyStructHandler_24_1";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssembly_24_1
        {
            public Il2CppImage* image;
            public uint token;
            public int referencedAssemblyStart;
            public int referencedAssemblyCount;
            public Il2CppAssemblyName_24_1 aname;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssemblyName_24_1
        {
            public IntPtr name; // const char* 
            public IntPtr culture; // const char*
            public IntPtr hash_value; // const char*
            public IntPtr public_key; // const char*
            public uint hash_alg;
            public int hash_len;
            public uint flags;
            public int major;
            public int minor;
            public int build;
            public int revision;
            public long public_key_token; // PUBLIC_KEY_BYTE_LENGTH
        }

        internal class NativeAssemblyStruct : INativeAssemblyStruct
        {
            public NativeAssemblyStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppAssembly* AssemblyPointer => (Il2CppAssembly*)Pointer;

            private Il2CppAssembly_24_1* NativeAssembly => (Il2CppAssembly_24_1*)Pointer;

            public ref Il2CppImage* Image => ref NativeAssembly->image;

            public ref IntPtr Name => ref NativeAssembly->aname.name;

            public ref int Major => ref NativeAssembly->aname.major;

            public ref int Minor => ref NativeAssembly->aname.minor;

            public ref int Build => ref NativeAssembly->aname.build;

            public ref int Revision => ref NativeAssembly->aname.revision;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Assembly/Assembly_24_4.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Assembly
{
    [ApplicableToUnityVersionsSince("2018.4.34")]
    [ApplicableToUnityVersionsSince("2019.4.15")]
    [ApplicableToUnityVersionsSince("2020.1.11")]
    public unsafe class NativeAssemblyStructHandler_24_4 : INativeAssemblyStructHandler
    {
        public INativeAssemblyStruct CreateNewAssemblyStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppAssembly_24_4>());

            *(Il2CppAssembly_24_4*)pointer = default;

            return new NativeAssemblyStruct(pointer);
        }

        public INativeAssemblyStruct Wrap(Il2CppAssembly* assemblyPointer)
        {
            if ((IntPtr)assemblyPointer == IntPtr.Zero) return null;
            else return new NativeAssemblyStruct((IntPtr)assemblyPointer);
        }

        public IntPtr il2cpp_assembly_get_name(IntPtr assembly) => ((Il2CppAssembly_24_4*)assembly)->aname.name;

#if DEBUG
        public string GetName() => "NativeAssemblyStructHandler_24_4";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssembly_24_4
        {
            public Il2CppImage* image;
            public uint token;
            public int referencedAssemblyStart;
            public int referencedAssemblyCount;
            public Il2CppAssemblyName_24_4 aname;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppAssemblyName_24_4
        {
            public IntPtr name; // const char* 
            public IntPtr culture; // const char*
            public IntPtr public_key; // const char*
            public uint hash_alg;
            public int hash_len;
            public uint flags;
            public int major;
            public int minor;
            public int build;
            public int revision;
            public long public_key_token; // PUBLIC_KEY_BYTE_LENGTH
        }

        internal class NativeAssemblyStruct : INativeAssemblyStruct
        {
            public NativeAssemblyStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppAssembly* AssemblyPointer => (Il2CppAssembly*)Pointer;

            private Il2CppAssembly_24_4* NativeAssembly => (Il2CppAssembly_24_4*)Pointer;

            public ref Il2CppImage* Image => ref NativeAssembly->image;

            public ref IntPtr Name => ref NativeAssembly->aname.name;

            public ref int Major => ref NativeAssembly->aname.major;

            public ref int Minor => ref NativeAssembly->aname.minor;

            public ref int Build => ref NativeAssembly->aname.build;

            public ref int Revision => ref NativeAssembly->aname.revision;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Assembly/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Assembly
{
    public interface INativeAssemblyStructHandler : INativeStructHandler
    {
        INativeAssemblyStruct CreateNewAssemblyStruct();
        unsafe INativeAssemblyStruct Wrap(Il2CppAssembly* assemblyPointer);
        IntPtr il2cpp_assembly_get_name(IntPtr assembly);
#if DEBUG
        string GetName();
#endif
    }

    public interface INativeAssemblyStruct : INativeStruct
    {
        unsafe Il2CppAssembly* AssemblyPointer { get; }

        unsafe ref Il2CppImage* Image { get; }

        ref IntPtr Name { get; }

        ref int Major { get; }

        ref int Minor { get; }

        ref int Build { get; }

        ref int Revision { get; }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;
using UnhollowerBaseLib.Runtime.VersionSpecific.MethodInfo;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public class NativeClassStructHandler_16_0 : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_16_0>() +
                                               Marshal.SizeOf<IntPtr>() * vTableSlots);

            var il2CppClass = (Il2CppClass_16_0*)pointer;
            *il2CppClass = default;

            il2CppClass->byval_arg = il2CppClass->this_arg =
                (NativeTypeStructHandler_16_0.Il2CppType_16_0*)Marshal.AllocHGlobal(Marshal.SizeOf<NativeTypeStructHandler_16_0.Il2CppType_16_0>());
            *il2CppClass->byval_arg = *il2CppClass->this_arg = default;

            il2CppClass->vtable = (NativeMethodInfoStructHandler_16_0.Il2CppMethodInfo_16_0**)IntPtr.Add(pointer, Marshal.SizeOf<Il2CppClass_16_0>());
            *il2CppClass->vtable = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_16_0
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* byval_arg; // not const
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* this_arg; // not const
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public NativeMethodInfoStructHandler_16_0.Il2CppMethodInfo_16_0** vtable; // const
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;*/
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            private Il2CppClass_16_0* NativeClass => (Il2CppClass_16_0*)Pointer;

            public IntPtr VTable => (IntPtr)NativeClass->vtable;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_16_0>(nameof(Il2CppClass_16_0.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_16_0>(nameof(Il2CppClass_16_0.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => false;
                set { }
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->byval_arg);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->this_arg);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_19_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;
using UnhollowerBaseLib.Runtime.VersionSpecific.MethodInfo;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("5.3.2")]
    public class NativeClassStructHandler_19_0 : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_19_0>() +
                                               Marshal.SizeOf<IntPtr>() * vTableSlots);

            var il2CppClass = (Il2CppClass_19_0*)pointer;
            *il2CppClass = default;

            il2CppClass->byval_arg = il2CppClass->this_arg =
                (NativeTypeStructHandler_16_0.Il2CppType_16_0*)Marshal.AllocHGlobal(Marshal.SizeOf<NativeTypeStructHandler_16_0.Il2CppType_16_0>());
            *il2CppClass->byval_arg = *il2CppClass->this_arg = default;

            il2CppClass->vtable = (NativeMethodInfoStructHandler_16_0.Il2CppMethodInfo_16_0**)IntPtr.Add(pointer, Marshal.SizeOf<Il2CppClass_19_0>());
            *il2CppClass->vtable = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_19_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_19_0
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* byval_arg; // not const
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* this_arg; // not const
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public NativeMethodInfoStructHandler_16_0.Il2CppMethodInfo_16_0** vtable; // const
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;*/
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            private Il2CppClass_19_0* NativeClass => (Il2CppClass_19_0*)Pointer;

            public IntPtr VTable => (IntPtr)NativeClass->vtable;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_19_0>(nameof(Il2CppClass_19_0.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_19_0>(nameof(Il2CppClass_19_0.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => false;
                set { }
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->byval_arg);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->this_arg);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_20_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;
using UnhollowerBaseLib.Runtime.VersionSpecific.MethodInfo;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("5.3.3")]
    public class NativeClassStructHandler_20_0 : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_20_0>() +
                                               Marshal.SizeOf<IntPtr>() * vTableSlots);

            var il2CppClass = (Il2CppClass_20_0*)pointer;
            *il2CppClass = default;

            il2CppClass->byval_arg = il2CppClass->this_arg =
                (NativeTypeStructHandler_16_0.Il2CppType_16_0*)Marshal.AllocHGlobal(Marshal.SizeOf<NativeTypeStructHandler_16_0.Il2CppType_16_0>());
            *il2CppClass->byval_arg = *il2CppClass->this_arg = default;

            il2CppClass->vtable = (NativeMethodInfoStructHandler_16_0.Il2CppMethodInfo_16_0**)IntPtr.Add(pointer, Marshal.SizeOf<Il2CppClass_20_0>());
            *il2CppClass->vtable = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_20_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_20_0
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* byval_arg; // not const
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* this_arg; // not const
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public NativeMethodInfoStructHandler_16_0.Il2CppMethodInfo_16_0** vtable; // const
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import : 1;*/
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            private Il2CppClass_20_0* NativeClass => (Il2CppClass_20_0*)Pointer;

            public IntPtr VTable => (IntPtr)NativeClass->vtable;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_20_0>(nameof(Il2CppClass_20_0.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_20_0>(nameof(Il2CppClass_20_0.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => false;
                set { }
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->byval_arg);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->this_arg);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_21_0_B.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("5.3.6")]
    public class NativeClassStructHandler_21_0_B : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_21_0_B>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            var il2CppClass = (Il2CppClass_21_0_B*)pointer;
            *il2CppClass = default;

            il2CppClass->byval_arg = il2CppClass->this_arg =
                (NativeTypeStructHandler_16_0.Il2CppType_16_0*)Marshal.AllocHGlobal(Marshal.SizeOf<NativeTypeStructHandler_16_0.Il2CppType_16_0>());
            *il2CppClass->byval_arg = *il2CppClass->this_arg = default;

            il2CppClass->vtable = (VirtualInvokeData*)IntPtr.Add(pointer, Marshal.SizeOf<Il2CppClass_21_0_B>());
            *il2CppClass->vtable = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_21_0_B";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_21_0_B
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* byval_arg; // not const
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* this_arg; // not const
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public VirtualInvokeData* vtable; // not const
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1*/
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            private Il2CppClass_21_0_B* NativeClass => (Il2CppClass_21_0_B*)Pointer;

            public IntPtr VTable => (IntPtr)NativeClass->vtable;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_21_0_B>(nameof(Il2CppClass_21_0_B.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_21_0_B>(nameof(Il2CppClass_21_0_B.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => false;
                set { }
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->byval_arg);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->this_arg);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_21_0_C.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("5.4.4")]
    public class NativeClassStructHandler_21_0_C : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_21_0_C>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            var il2CppClass = (Il2CppClass_21_0_C*)pointer;
            *il2CppClass = default;

            il2CppClass->byval_arg = il2CppClass->this_arg =
                (NativeTypeStructHandler_16_0.Il2CppType_16_0*)Marshal.AllocHGlobal(Marshal.SizeOf<NativeTypeStructHandler_16_0.Il2CppType_16_0>());
            *il2CppClass->byval_arg = *il2CppClass->this_arg = default;

            il2CppClass->vtable = (VirtualInvokeData*)IntPtr.Add(pointer, Marshal.SizeOf<Il2CppClass_21_0_C>());
            *il2CppClass->vtable = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_21_0_C";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_21_0_C
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* byval_arg; // not const
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* this_arg; // not const
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public VirtualInvokeData* vtable; // not const
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1*/
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            private Il2CppClass_21_0_C* NativeClass => (Il2CppClass_21_0_C*)Pointer;

            public IntPtr VTable => (IntPtr)NativeClass->vtable;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_21_0_C>(nameof(Il2CppClass_21_0_C.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_21_0_C>(nameof(Il2CppClass_21_0_C.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => false;
                set { }
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->byval_arg);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->this_arg);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_22_0_A.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("5.5.0")]
    public class NativeClassStructHandler_22_0_A : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_22_0_A>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            var il2CppClass = (Il2CppClass_22_0_A*)pointer;
            *il2CppClass = default;

            il2CppClass->byval_arg = il2CppClass->this_arg =
                (NativeTypeStructHandler_16_0.Il2CppType_16_0*)Marshal.AllocHGlobal(Marshal.SizeOf<NativeTypeStructHandler_16_0.Il2CppType_16_0>());
            *il2CppClass->byval_arg = *il2CppClass->this_arg = default;


            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_22_0_A";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_22_0_A
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* byval_arg; // not const
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* this_arg; // not const
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_22_0_A>());

            private Il2CppClass_22_0_A* NativeClass => (Il2CppClass_22_0_A*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_22_0_A>(nameof(Il2CppClass_22_0_A.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_22_0_A>(nameof(Il2CppClass_22_0_A.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 3);
                set => this.SetBit(bitfield2offset, 3, value);
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->byval_arg);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->this_arg);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_22_0_B.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("5.5.1")]
    public class NativeClassStructHandler_22_0_B : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_22_0_B>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            var il2CppClass = (Il2CppClass_22_0_B*)pointer;
            *il2CppClass = default;

            il2CppClass->byval_arg = il2CppClass->this_arg =
                (NativeTypeStructHandler_16_0.Il2CppType_16_0*)Marshal.AllocHGlobal(Marshal.SizeOf<NativeTypeStructHandler_16_0.Il2CppType_16_0>());
            *il2CppClass->byval_arg = *il2CppClass->this_arg = default;


            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_22_0_B";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_22_0_B
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* byval_arg; // not const
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* this_arg; // not const
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_22_0_B>());

            private Il2CppClass_22_0_B* NativeClass => (Il2CppClass_22_0_B*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_22_0_B>(nameof(Il2CppClass_22_0_B.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_22_0_B>(nameof(Il2CppClass_22_0_B.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 3);
                set => this.SetBit(bitfield2offset, 3, value);
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->byval_arg);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->this_arg);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_23_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("5.6.0")]
    public class NativeClassStructHandler_23_0 : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_23_0>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            var il2CppClass = (Il2CppClass_23_0*)pointer;
            *il2CppClass = default;

            il2CppClass->byval_arg = il2CppClass->this_arg =
                (NativeTypeStructHandler_16_0.Il2CppType_16_0*)Marshal.AllocHGlobal(Marshal.SizeOf<NativeTypeStructHandler_16_0.Il2CppType_16_0>());
            *il2CppClass->byval_arg = *il2CppClass->this_arg = default;


            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_23_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_23_0
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* byval_arg; // not const
            public NativeTypeStructHandler_16_0.Il2CppType_16_0* this_arg; // not const
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_23_0>());

            private Il2CppClass_23_0* NativeClass => (Il2CppClass_23_0*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_23_0>(nameof(Il2CppClass_23_0.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_23_0>(nameof(Il2CppClass_23_0.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 3);
                set => this.SetBit(bitfield2offset, 3, value);
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->byval_arg);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap((Il2CppTypeStruct*)NativeClass->this_arg);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_24_0_B.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("2018.1.0")]
    public class NativeClassStructHandler_24_0_B : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_24_0_B>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            *(Il2CppClass_24_0_B*)pointer = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_24_0_B";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_24_0_B
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 byval_arg; // not const, no ptr
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 this_arg; // not const, no ptr
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_24_0_B>());

            private Il2CppClass_24_0_B* NativeClass => (Il2CppClass_24_0_B*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_24_0_B>(nameof(Il2CppClass_24_0_B.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_24_0_B>(nameof(Il2CppClass_24_0_B.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 3);
                set => this.SetBit(bitfield2offset, 3, value);
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            private Il2CppTypeStruct* ByValArgPointer => (Il2CppTypeStruct*)(&(NativeClass->byval_arg));

            private Il2CppTypeStruct* ThisArgPointer => (Il2CppTypeStruct*)(&(NativeClass->this_arg));

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap(ByValArgPointer);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap(ThisArgPointer);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_24_0_C.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("2018.2.0")]
    public class NativeClassStructHandler_24_0_C : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_24_0_C>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            *(Il2CppClass_24_0_C*)pointer = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_24_0_C";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_24_0_C
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 byval_arg; // not const, no ptr
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 this_arg; // not const, no ptr
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint initializationExceptionGCHandle;

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public int customAttributeIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;
            uint8_t has_finalize : 1;*/

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_24_0_C>());

            private Il2CppClass_24_0_C* NativeClass => (Il2CppClass_24_0_C*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_24_0_C>(nameof(Il2CppClass_24_0_C.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_24_0_C>(nameof(Il2CppClass_24_0_C.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            // Not present
            public bool InitializedAndNoError
            {
                get => true;
                set { }
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 3);
                set => this.SetBit(bitfield2offset, 3, value);
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            private Il2CppTypeStruct* ByValArgPointer => (Il2CppTypeStruct*)(&(NativeClass->byval_arg));

            private Il2CppTypeStruct* ThisArgPointer => (Il2CppTypeStruct*)(&(NativeClass->this_arg));

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap(ByValArgPointer);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap(ThisArgPointer);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_24_1_A.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("2018.3.0")]
    public class NativeClassStructHandler_24_1_A : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_24_1_A>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            *(Il2CppClass_24_1_A*)pointer = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_24_1_A";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_24_1_A
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 byval_arg; // not const, no ptr
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 this_arg; // not const, no ptr
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint initializationExceptionGCHandle;

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*uint8_t initialized_and_no_error : 1;
    
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;*/

            public byte bitfield_2;
            /*uint8_t has_finalize : 1;
            uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;
            uint8_t has_initialization_error : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_24_1_A>());

            private Il2CppClass_24_1_A* NativeClass => (Il2CppClass_24_1_A*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_24_1_A>(nameof(Il2CppClass_24_1_A.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_24_1_A>(nameof(Il2CppClass_24_1_A.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 4);
                set => this.SetBit(bitfield1offset, 4, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool InitializedAndNoError
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield2offset, 0);
                set => this.SetBit(bitfield2offset, 0, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 4);
                set => this.SetBit(bitfield2offset, 4, value);
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            private Il2CppTypeStruct* ByValArgPointer => (Il2CppTypeStruct*)(&(NativeClass->byval_arg));

            private Il2CppTypeStruct* ThisArgPointer => (Il2CppTypeStruct*)(&(NativeClass->this_arg));

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap(ByValArgPointer);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap(ThisArgPointer);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_24_1_B.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("2018.3.8")]
    public class NativeClassStructHandler_24_1_B : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_24_1_B>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            *(Il2CppClass_24_1_B*)pointer = default;

            return new NativeClassStructWrapper(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStructWrapper((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_24_1_B";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_24_1_B
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 byval_arg; // not const, no ptr
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 this_arg; // not const, no ptr
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            public uint initializationExceptionGCHandle;

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private ulong cctor_thread;

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte naturalAligment; // Alignment of this type without accounting for packing
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*uint8_t initialized_and_no_error : 1;
    
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;*/

            public byte bitfield_2;
            /*uint8_t has_finalize : 1;
            uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;
            uint8_t has_initialization_error : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStructWrapper : INativeClassStruct
        {
            public NativeClassStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_24_1_B>());

            private Il2CppClass_24_1_B* NativeClass => (Il2CppClass_24_1_B*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_24_1_B>(nameof(Il2CppClass_24_1_B.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_24_1_B>(nameof(Il2CppClass_24_1_B.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 4);
                set => this.SetBit(bitfield1offset, 4, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool InitializedAndNoError
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield2offset, 0);
                set => this.SetBit(bitfield2offset, 0, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 4);
                set => this.SetBit(bitfield2offset, 4, value);
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            private Il2CppTypeStruct* ByValArgPointer => (Il2CppTypeStruct*)(&(NativeClass->byval_arg));

            private Il2CppTypeStruct* ThisArgPointer => (Il2CppTypeStruct*)(&(NativeClass->this_arg));

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap(ByValArgPointer);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap(ThisArgPointer);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_24_2.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("2019.1.0")]
    public class NativeClassStructHandler_24_2 : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_24_2>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            *(Il2CppClass_24_2*)pointer = default;

            return new NativeClassStruct(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr) classPointer == IntPtr.Zero) return null;
            else return new NativeClassStruct((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_24_2";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_24_2
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 byval_arg; // not const, no ptr
            public NativeTypeStructHandler_16_0.Il2CppType_16_0 this_arg; // not const, no ptr
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public /*Il2CppTypeDefinition**/
                IntPtr typeDefinition; // const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init

            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            // U2019 specific field
            public IntPtr unity_user_data;

            public uint initializationExceptionGCHandle;

            public uint cctor_started;

            public uint cctor_finished;

            /*ALIGN_TYPE(8)*/
            private IntPtr cctor_thread; // was uint64 in 2018.4, is size_t in 2019.3.1

            // Remaining fields are always valid except where noted
            public /*GenericContainerIndex*/ int genericContainerIndex;
            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte naturalAligment; // Alignment of this type without accounting for packing
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            /*uint8_t initialized_and_no_error : 1;
    
            uint8_t valuetype : 1;
            uint8_t initialized : 1;
            uint8_t enumtype : 1;
            uint8_t is_generic : 1;
            uint8_t has_references : 1;
            uint8_t init_pending : 1;
            uint8_t size_inited : 1;*/

            public byte bitfield_2;
            /*uint8_t has_finalize : 1;
            uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;
            uint8_t has_initialization_error : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStruct : INativeClassStruct
        {
            public NativeClassStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_24_2>());

            private Il2CppClass_24_2* NativeClass => (Il2CppClass_24_2*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_24_2>(nameof(Il2CppClass_24_2.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_24_2>(nameof(Il2CppClass_24_2.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 4);
                set => this.SetBit(bitfield1offset, 4, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool InitializedAndNoError
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield2offset, 0);
                set => this.SetBit(bitfield2offset, 0, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 4);
                set => this.SetBit(bitfield2offset, 4, value);
            }

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            private Il2CppTypeStruct* ByValArgPointer => (Il2CppTypeStruct*)(&(NativeClass->byval_arg));

            private Il2CppTypeStruct* ThisArgPointer => (Il2CppTypeStruct*)(&(NativeClass->this_arg));

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap(ByValArgPointer);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap(ThisArgPointer);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_27_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("2020.2.0")]
    public class NativeClassStructHandler_27_0 : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_27_0>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            *(Il2CppClass_27_0*)pointer = default;

            return new NativeClassStruct(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStruct((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_27_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_27_0
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_27_0.Il2CppType_27_0 byval_arg; // not const, no ptr
            public NativeTypeStructHandler_27_0.Il2CppType_27_0 this_arg; // not const, no ptr
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public IntPtr typeMetadataHandle; // not const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init
            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            // public IntPtr typeDefinition;

            // U2020 specific field
            public IntPtr unity_user_data;

            public uint initializationExceptionGCHandle;


            public uint cctor_started;
            public uint cctor_finished;

            ///*ALIGN_TYPE(8)*/
            public IntPtr cctor_thread; // was uint64 in 2018.4, is size_t in >=2019.3.1


            ///*ALIGN_TYPE(8)*/ IntPtr cctor_thread; // was uint64 in 2018.4, is size_t in 2020.3.1

            // Remaining fields are always valid except where noted
            //public /*GenericContainerIndex*/ int genericContainerIndex;
            public IntPtr genericContainerHandle;

            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte naturalAligment; // Alignment of this type without accounting for packing
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            //uint8_t initialized_and_no_error : 1;

            //uint8_t valuetype : 1;
            //uint8_t initialized : 1;
            //uint8_t enumtype : 1;
            //uint8_t is_generic : 1;
            //uint8_t has_references : 1;
            //uint8_t init_pending : 1;
            //uint8_t size_inited : 1;

            public byte bitfield_2;
            /*uint8_t has_finalize : 1;
            uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;
            uint8_t has_initialization_error : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStruct : INativeClassStruct
        {
            public NativeClassStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_27_0>());

            private Il2CppClass_27_0* NativeClass => (Il2CppClass_27_0*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            // public ref ClassBitfield1 Bitfield1 => ref NativeClass->bitfield_1;

            // public ref ClassBitfield2 Bitfield2 => ref NativeClass->bitfield_2;

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_27_0>(nameof(Il2CppClass_27_0.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_27_0>(nameof(Il2CppClass_27_0.bitfield_2)).ToInt32();

            public bool ValueType
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 4);
                set => this.SetBit(bitfield1offset, 4, value);
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool InitializedAndNoError
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield2offset, 0);
                set => this.SetBit(bitfield2offset, 0, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 4);
                set => this.SetBit(bitfield2offset, 4, value);
            }

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            private Il2CppTypeStruct* ByValArgPointer => (Il2CppTypeStruct*)(&(NativeClass->byval_arg));

            private Il2CppTypeStruct* ThisArgPointer => (Il2CppTypeStruct*)(&(NativeClass->this_arg));

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap(ByValArgPointer);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap(ThisArgPointer);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_27_2.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("2021.1.0")]
    public class NativeClassStructHandler_27_2 : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_27_2>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            *(Il2CppClass_27_2*)pointer = default;

            return new NativeClassStruct(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStruct((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_27_2";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_27_2
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_27_2.Il2CppType_27_2 byval_arg; // not const, no ptr
            public NativeTypeStructHandler_27_2.Il2CppType_27_2 this_arg; // not const, no ptr
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public IntPtr
                typeMetadataHandle; //  // const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init
            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            // public IntPtr typeDefinition;

            // U2020 specific field
            public IntPtr unity_user_data;

            public uint initializationExceptionGCHandle;


            public uint cctor_started;
            public uint cctor_finished;

            ///*ALIGN_TYPE(8)*/
            public IntPtr cctor_thread; // was uint64 in 2018.4, is size_t in >=2019.3.1


            ///*ALIGN_TYPE(8)*/ IntPtr cctor_thread; // was uint64 in 2018.4, is size_t in 2020.3.1

            // Remaining fields are always valid except where noted
            //public /*GenericContainerIndex*/ int genericContainerIndex;
            public IntPtr genericContainerHandle;

            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte naturalAligment; // Alignment of this type without accounting for packing
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            //uint8_t initialized_and_no_error : 1;

            //uint8_t initialized : 1;
            //uint8_t enumtype : 1;
            //uint8_t is_generic : 1;
            //uint8_t has_references : 1;
            //uint8_t init_pending : 1;
            //uint8_t size_inited : 1;
            //uint8_t has_finalize : 1;

            public byte bitfield_2;
            /*uint8_t has_cctor : 1;
            uint8_t is_blittable : 1;
            uint8_t is_import_or_windows_runtime : 1;
            uint8_t is_vtable_initialized : 1;
            uint8_t has_initialization_error : 1;*/

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStruct : INativeClassStruct
        {
            public NativeClassStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_27_2>());

            private Il2CppClass_27_2* NativeClass => (Il2CppClass_27_2*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            // public ref ClassBitfield1 Bitfield1 => ref NativeClass->bitfield_1;

            // public ref ClassBitfield2 Bitfield2 => ref NativeClass->bitfield_2;

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_27_2>(nameof(Il2CppClass_27_2.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_27_2>(nameof(Il2CppClass_27_2.bitfield_2)).ToInt32();

            private static int byval_arg_mods_byref_pin_offset =
                Marshal.OffsetOf<Il2CppClass_27_2>(nameof(Il2CppClass_27_2.byval_arg)).ToInt32() +
                Marshal.OffsetOf<NativeTypeStructHandler_27_2.Il2CppType_27_2>(nameof(NativeTypeStructHandler_27_2.Il2CppType_27_2.mods_byref_pin)).ToInt32();

            private static int this_arg_mods_byref_pin_offset =
                Marshal.OffsetOf<Il2CppClass_27_2>(nameof(Il2CppClass_27_2.this_arg)).ToInt32() + 
                Marshal.OffsetOf<NativeTypeStructHandler_27_2.Il2CppType_27_2>(nameof(NativeTypeStructHandler_27_2.Il2CppType_27_2.mods_byref_pin)).ToInt32();

            public bool InitializedAndNoError
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool ValueType
            {
                get
                {
                    return this.CheckBit(byval_arg_mods_byref_pin_offset, 7) && this.CheckBit(this_arg_mods_byref_pin_offset, 7);
                }
                set
                {
                    this.SetBit(byval_arg_mods_byref_pin_offset, 7, value);
                    this.SetBit(this_arg_mods_byref_pin_offset, 7, value);
                }
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 3);
                set => this.SetBit(bitfield1offset, 3, value);
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield1offset, 6);
                set => this.SetBit(bitfield1offset, 6, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield1offset, 7);
                set => this.SetBit(bitfield1offset, 7, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 3);
                set => this.SetBit(bitfield2offset, 3, value);
            }

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            private Il2CppTypeStruct* ByValArgPointer => (Il2CppTypeStruct*)(&(NativeClass->byval_arg));

            private Il2CppTypeStruct* ThisArgPointer => (Il2CppTypeStruct*)(&(NativeClass->this_arg));

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap(ByValArgPointer);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap(ThisArgPointer);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Class_27_3.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    [ApplicableToUnityVersionsSince("2021.2.0")]
    public class NativeClassStructHandler_27_3 : INativeClassStructHandler
    {
        public unsafe INativeClassStruct CreateNewClassStruct(int vTableSlots)
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppClass_27_3>() +
                                               Marshal.SizeOf<VirtualInvokeData>() * vTableSlots);

            *(Il2CppClass_27_3*)pointer = default;

            return new NativeClassStruct(pointer);
        }

        public unsafe INativeClassStruct Wrap(Il2CppClass* classPointer)
        {
            if ((IntPtr)classPointer == IntPtr.Zero) return null;
            else return new NativeClassStruct((IntPtr)classPointer);
        }

#if DEBUG
        public string GetName() => "NativeClassStructHandler_27_3";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppClass_27_3
        {
            // The following fields are always valid for a Il2CppClass structure
            public Il2CppImage* image; // const
            public IntPtr gc_desc;
            public IntPtr name; // const char*
            public IntPtr namespaze; // const char*
            public NativeTypeStructHandler_27_2.Il2CppType_27_2 byval_arg; // not const, no ptr
            public NativeTypeStructHandler_27_2.Il2CppType_27_2 this_arg; // not const, no ptr
            public Il2CppClass* element_class; // not const
            public Il2CppClass* castClass; // not const
            public Il2CppClass* declaringType; // not const
            public Il2CppClass* parent; // not const
            public /*Il2CppGenericClass**/ IntPtr generic_class;

            public IntPtr
                typeMetadataHandle; //  // const; non-NULL for Il2CppClass's constructed from type defintions

            public /*Il2CppInteropData**/ IntPtr interopData; // const

            public Il2CppClass* klass; // not const; hack to pretend we are a MonoVTable. Points to ourself
            // End always valid fields

            // The following fields need initialized before access. This can be done per field or as an aggregate via a call to Class::Init
            public Il2CppFieldInfo* fields; // Initialized in SetupFields
            public Il2CppEventInfo* events; // const; Initialized in SetupEvents
            public Il2CppPropertyInfo* properties; // const; Initialized in SetupProperties
            public Il2CppMethodInfo** methods; // const; Initialized in SetupMethods
            public Il2CppClass** nestedTypes; // not const; Initialized in SetupNestedTypes
            public Il2CppClass** implementedInterfaces; // not const; Initialized in SetupInterfaces
            public Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets; // not const; Initialized in Init
            public IntPtr static_fields; // not const; Initialized in Init
            public /*Il2CppRGCTXData**/ IntPtr rgctx_data; // const; Initialized in Init

            // used for fast parent checks
            public Il2CppClass** typeHierarchy; // not const; Initialized in SetupTypeHierachy
            // End initialization required fields

            // public IntPtr typeDefinition;

            // U2020 specific field
            public IntPtr unity_user_data;

            public uint initializationExceptionGCHandle;


            public uint cctor_started;
            public uint cctor_finished_or_no_cctor;

            ///*ALIGN_TYPE(8)*/
            public IntPtr cctor_thread; // was uint64 in 2018.4, is size_t in >=2019.3.1


            ///*ALIGN_TYPE(8)*/ IntPtr cctor_thread; // was uint64 in 2018.4, is size_t in 2020.3.1

            // Remaining fields are always valid except where noted
            //public /*GenericContainerIndex*/ int genericContainerIndex;
            public IntPtr genericContainerHandle;

            public uint instance_size;
            public uint actualSize;
            public uint element_size;
            public int native_size;
            public uint static_fields_size;
            public uint thread_static_fields_size;
            public int thread_static_fields_offset;
            public Il2CppClassAttributes flags;
            public uint token;

            public ushort method_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort property_count;
            public ushort field_count;
            public ushort event_count;
            public ushort nested_type_count;
            public ushort vtable_count; // lazily calculated for arrays, i.e. when rank > 0
            public ushort interfaces_count;
            public ushort interface_offsets_count; // lazily calculated for arrays, i.e. when rank > 0

            public byte typeHierarchyDepth; // Initialized in SetupTypeHierachy
            public byte genericRecursionDepth;
            public byte rank;
            public byte minimumAlignment; // Alignment of this type
            public byte naturalAligment; // Alignment of this type without accounting for packing
            public byte packingSize;

            // this is critical for performance of Class::InitFromCodegen. Equals to initialized && !has_initialization_error at all times.
            // Use Class::UpdateInitializedAndNoError to update
            public byte bitfield_1;
            //uint8_t initialized_and_no_error : 1;
            //uint8_t initialized : 1;
            //uint8_t enumtype : 1;
            //uint8_t nullabletype : 1;
            //uint8_t is_generic : 1;
            //uint8_t has_references : 1;
            //uint8_t init_pending : 1;
            //uint8_t size_inited : 1;

            public byte bitfield_2;
            //uint8_t has_finalize : 1;
            //uint8_t has_cctor : 1;
            //uint8_t is_blittable : 1;
            //uint8_t is_import_or_windows_runtime : 1;
            //uint8_t is_vtable_initialized : 1;
            //uint8_t is_byref_like : 1;

            //VirtualInvokeData vtable[IL2CPP_ZERO_LEN_ARRAY];
        }

        internal unsafe class NativeClassStruct : INativeClassStruct
        {
            public NativeClassStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }
            public Il2CppClass* ClassPointer => (Il2CppClass*)Pointer;

            public IntPtr VTable => IntPtr.Add(Pointer, Marshal.SizeOf<Il2CppClass_27_3>());

            private Il2CppClass_27_3* NativeClass => (Il2CppClass_27_3*)Pointer;

            public ref uint InstanceSize => ref NativeClass->instance_size;

            public ref ushort VtableCount => ref NativeClass->vtable_count;

            public ref ushort InterfaceCount => ref NativeClass->interfaces_count;

            public ref ushort InterfaceOffsetsCount => ref NativeClass->interface_offsets_count;

            public ref byte TypeHierarchyDepth => ref NativeClass->typeHierarchyDepth;

            public ref int NativeSize => ref NativeClass->native_size;

            public ref uint ActualSize => ref NativeClass->actualSize;

            public ref ushort MethodCount => ref NativeClass->method_count;

            // public ref ClassBitfield1 Bitfield1 => ref NativeClass->bitfield_1;

            // public ref ClassBitfield2 Bitfield2 => ref NativeClass->bitfield_2;

            public ref Il2CppClassAttributes Flags => ref NativeClass->flags;

            private static int bitfield1offset =
                Marshal.OffsetOf<Il2CppClass_27_3>(nameof(Il2CppClass_27_3.bitfield_1)).ToInt32();

            private static int bitfield2offset =
                Marshal.OffsetOf<Il2CppClass_27_3>(nameof(Il2CppClass_27_3.bitfield_2)).ToInt32();

            private static int byval_arg_mods_byref_pin_offset =
                Marshal.OffsetOf<Il2CppClass_27_3>(nameof(Il2CppClass_27_3.byval_arg)).ToInt32() +
                Marshal.OffsetOf<NativeTypeStructHandler_27_2.Il2CppType_27_2>(nameof(NativeTypeStructHandler_27_2.Il2CppType_27_2.mods_byref_pin)).ToInt32();

            private static int this_arg_mods_byref_pin_offset =
                Marshal.OffsetOf<Il2CppClass_27_3>(nameof(Il2CppClass_27_3.this_arg)).ToInt32() + 
                Marshal.OffsetOf<NativeTypeStructHandler_27_2.Il2CppType_27_2>(nameof(NativeTypeStructHandler_27_2.Il2CppType_27_2.mods_byref_pin)).ToInt32();

            public bool InitializedAndNoError
            {
                get => this.CheckBit(bitfield1offset, 0);
                set => this.SetBit(bitfield1offset, 0, value);
            }

            public bool ValueType
            {
                get
                {
                    return this.CheckBit(byval_arg_mods_byref_pin_offset, 7) && this.CheckBit(this_arg_mods_byref_pin_offset, 7);
                }
                set
                {
                    this.SetBit(byval_arg_mods_byref_pin_offset, 7, value);
                    this.SetBit(this_arg_mods_byref_pin_offset, 7, value);
                }
            }

            public bool Initialized
            {
                get => this.CheckBit(bitfield1offset, 1);
                set => this.SetBit(bitfield1offset, 1, value);
            }

            public bool EnumType
            {
                get => this.CheckBit(bitfield1offset, 2);
                set => this.SetBit(bitfield1offset, 2, value);
            }

            public bool IsGeneric
            {
                get => this.CheckBit(bitfield1offset, 4);
                set => this.SetBit(bitfield1offset, 4, value);
            }

            public bool SizeInited
            {
                get => this.CheckBit(bitfield2offset, 0);
                set => this.SetBit(bitfield2offset, 0, value);
            }

            public bool HasFinalize
            {
                get => this.CheckBit(bitfield2offset, 1);
                set => this.SetBit(bitfield2offset, 1, value);
            }

            public bool IsVtableInitialized
            {
                get => this.CheckBit(bitfield2offset, 5);
                set => this.SetBit(bitfield2offset, 5, value);
            }

            public ref IntPtr Name => ref NativeClass->name;

            public ref IntPtr Namespace => ref NativeClass->namespaze;

            private Il2CppTypeStruct* ByValArgPointer => (Il2CppTypeStruct*)(&(NativeClass->byval_arg));

            private Il2CppTypeStruct* ThisArgPointer => (Il2CppTypeStruct*)(&(NativeClass->this_arg));

            public INativeTypeStruct ByValArg => UnityVersionHandler.Wrap(ByValArgPointer);

            public INativeTypeStruct ThisArg => UnityVersionHandler.Wrap(ThisArgPointer);

            public ref Il2CppImage* Image => ref NativeClass->image;

            public ref Il2CppClass* Parent => ref NativeClass->parent;

            public ref Il2CppClass* ElementClass => ref NativeClass->element_class;

            public ref Il2CppClass* CastClass => ref NativeClass->castClass;

            public ref Il2CppClass* Class => ref NativeClass->klass;

            public ref Il2CppMethodInfo** Methods => ref NativeClass->methods;

            public ref Il2CppClass** ImplementedInterfaces => ref NativeClass->implementedInterfaces;

            public ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets => ref NativeClass->interfaceOffsets;

            public ref Il2CppClass** TypeHierarchy => ref NativeClass->typeHierarchy;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Class/Interfaces.cs`:

```cs
using System;
using UnhollowerBaseLib.Runtime.VersionSpecific.Type;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Class
{
    public interface INativeClassStructHandler : INativeStructHandler
    {
        INativeClassStruct CreateNewClassStruct(int vTableSlots);
        unsafe INativeClassStruct Wrap(Il2CppClass* classPointer);
#if DEBUG
        string GetName();
#endif
    }

    public interface INativeClassStruct : INativeStruct
    {
        unsafe Il2CppClass* ClassPointer { get; }
        IntPtr VTable { get; }

        ref uint InstanceSize { get; }
        ref ushort VtableCount { get; }
        ref ushort InterfaceCount { get; }
        ref ushort InterfaceOffsetsCount { get; }
        ref byte TypeHierarchyDepth { get; }
        ref int NativeSize { get; }
        ref uint ActualSize { get; }
        ref ushort MethodCount { get; }
        ref Il2CppClassAttributes Flags { get; }

        bool ValueType { get; set; }
        bool EnumType { get; set; }
        bool IsGeneric { get; set; }
        bool Initialized { get; set; }
        bool InitializedAndNoError { get; set; }
        bool SizeInited { get; set; }
        bool HasFinalize { get; set; }
        bool IsVtableInitialized { get; set; }

        ref IntPtr Name { get; }
        ref IntPtr Namespace { get; }

        INativeTypeStruct ByValArg { get; }
        INativeTypeStruct ThisArg { get; }

        unsafe ref Il2CppImage* Image { get; }
        unsafe ref Il2CppClass* Parent { get; }
        unsafe ref Il2CppClass* ElementClass { get; }
        unsafe ref Il2CppClass* CastClass { get; }
        unsafe ref Il2CppClass* Class { get; }

        unsafe ref Il2CppMethodInfo** Methods { get; }
        unsafe ref Il2CppClass** ImplementedInterfaces { get; }
        unsafe ref Il2CppRuntimeInterfaceOffsetPair* InterfaceOffsets { get; }
        unsafe ref Il2CppClass** TypeHierarchy { get; }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/EventInfo/EventInfo_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.EventInfo
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public unsafe class NativeEventInfoStructHandler_16_0 : INativeEventInfoStructHandler
    {
        public INativeEventInfoStruct CreateNewEventInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppEventInfo_16_0>());

            *(Il2CppEventInfo_16_0*)pointer = default;

            return new NativeEventInfoStruct(pointer);
        }

        public INativeEventInfoStruct Wrap(Il2CppEventInfo* eventInfoPointer)
        {
            if ((IntPtr)eventInfoPointer == IntPtr.Zero) return null;
            else return new NativeEventInfoStruct((IntPtr)eventInfoPointer);
        }

#if DEBUG
        public string GetName() => "NativeEventInfoStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppEventInfo_16_0
        {
            public IntPtr name; // const char*
            public Il2CppTypeStruct* eventType; // const
            public Il2CppClass* parent; // non const
            public Il2CppMethodInfo* add; // const
            public Il2CppMethodInfo* remove; // const
            public Il2CppMethodInfo* raise; // const
            public int customAttributeIndex;
        }

        internal class NativeEventInfoStruct : INativeEventInfoStruct
        {
            public NativeEventInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppEventInfo* EventInfoPointer => (Il2CppEventInfo*)Pointer;

            private Il2CppEventInfo_16_0* NativeEvent => (Il2CppEventInfo_16_0*)Pointer;

            public ref IntPtr Name => ref NativeEvent->name;

            public ref Il2CppTypeStruct* EventType => ref NativeEvent->eventType;

            public ref Il2CppClass* Parent => ref NativeEvent->parent;

            public ref Il2CppMethodInfo* Add => ref NativeEvent->add;

            public ref Il2CppMethodInfo* Remove => ref NativeEvent->remove;

            public ref Il2CppMethodInfo* Raise => ref NativeEvent->raise;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/EventInfo/EventInfo_19_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.EventInfo
{
    [ApplicableToUnityVersionsSince("5.3.2")]
    public unsafe class NativeEventInfoStructHandler_19_0 : INativeEventInfoStructHandler
    {
        public INativeEventInfoStruct CreateNewEventInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppEventInfo_19_0>());

            *(Il2CppEventInfo_19_0*)pointer = default;

            return new NativeEventInfoStruct(pointer);
        }

        public INativeEventInfoStruct Wrap(Il2CppEventInfo* eventInfoPointer)
        {
            if ((IntPtr)eventInfoPointer == IntPtr.Zero) return null;
            else return new NativeEventInfoStruct((IntPtr)eventInfoPointer);
        }

#if DEBUG
        public string GetName() => "NativeEventInfoStructHandler_19_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
       internal struct Il2CppEventInfo_19_0
        {
            public IntPtr name; // const char*
            public Il2CppTypeStruct* eventType; // const
            public Il2CppClass* parent; // non const
            public Il2CppMethodInfo* add; // const
            public Il2CppMethodInfo* remove; // const
            public Il2CppMethodInfo* raise; // const
            public int customAttributeIndex;
            public uint token;
        }

        internal class NativeEventInfoStruct : INativeEventInfoStruct
        {
            public NativeEventInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppEventInfo* EventInfoPointer => (Il2CppEventInfo*)Pointer;

            private Il2CppEventInfo_19_0* NativeEvent => (Il2CppEventInfo_19_0*)Pointer;

            public ref IntPtr Name => ref NativeEvent->name;

            public ref Il2CppTypeStruct* EventType => ref NativeEvent->eventType;

            public ref Il2CppClass* Parent => ref NativeEvent->parent;

            public ref Il2CppMethodInfo* Add => ref NativeEvent->add;

            public ref Il2CppMethodInfo* Remove => ref NativeEvent->remove;

            public ref Il2CppMethodInfo* Raise => ref NativeEvent->raise;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/EventInfo/EventInfo_24_1.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.EventInfo
{
    [ApplicableToUnityVersionsSince("2018.3.0")]
    public unsafe class NativeEventInfoStructHandler_24_1 : INativeEventInfoStructHandler
    {
        public INativeEventInfoStruct CreateNewEventInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppEventInfo_24_1>());

            *(Il2CppEventInfo_24_1*)pointer = default;

            return new NativeEventInfoStruct(pointer);
        }

        public INativeEventInfoStruct Wrap(Il2CppEventInfo* eventInfoPointer)
        {
            if ((IntPtr)eventInfoPointer == IntPtr.Zero) return null;
            else return new NativeEventInfoStruct((IntPtr)eventInfoPointer);
        }

#if DEBUG
        public string GetName() => "NativeEventInfoStructHandler_24_1";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppEventInfo_24_1
        {
            public IntPtr name; // const char*
            public Il2CppTypeStruct* eventType; // const
            public Il2CppClass* parent; // non const
            public Il2CppMethodInfo* add; // const
            public Il2CppMethodInfo* remove; // const
            public Il2CppMethodInfo* raise; // const
            public uint token;
        }

        internal class NativeEventInfoStruct : INativeEventInfoStruct
        {
            public NativeEventInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppEventInfo* EventInfoPointer => (Il2CppEventInfo*)Pointer;

            private Il2CppEventInfo_24_1* NativeEvent => (Il2CppEventInfo_24_1*)Pointer;

            public ref IntPtr Name => ref NativeEvent->name;

            public ref Il2CppTypeStruct* EventType => ref NativeEvent->eventType;

            public ref Il2CppClass* Parent => ref NativeEvent->parent;

            public ref Il2CppMethodInfo* Add => ref NativeEvent->add;

            public ref Il2CppMethodInfo* Remove => ref NativeEvent->remove;

            public ref Il2CppMethodInfo* Raise => ref NativeEvent->raise;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/EventInfo/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.EventInfo
{
    public interface INativeEventInfoStructHandler : INativeStructHandler
    {
        INativeEventInfoStruct CreateNewEventInfoStruct();
        unsafe INativeEventInfoStruct Wrap(Il2CppEventInfo* eventInfoPointer);
#if DEBUG
        string GetName();
#endif
    }

    public interface INativeEventInfoStruct : INativeStruct
    {
        unsafe Il2CppEventInfo* EventInfoPointer { get; }

        ref IntPtr Name { get; }

        unsafe ref Il2CppTypeStruct* EventType { get; }

        unsafe ref Il2CppClass* Parent { get; }

        unsafe ref Il2CppMethodInfo* Add { get; }

        unsafe ref Il2CppMethodInfo* Remove { get; }

        unsafe ref Il2CppMethodInfo* Raise { get; }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Exception/Exception_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Exception
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public unsafe class NativeExceptionStructHandler_16_0 : INativeExceptionStructHandler
    {
        public INativeExceptionStruct CreateNewExceptionStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppException_16_0>());

            *(Il2CppException_16_0*)pointer = default;

            return new NativeExceptionStruct(pointer);
        }

        public INativeExceptionStruct Wrap(Il2CppException* exceptionPointer)
        {
            if ((IntPtr)exceptionPointer == IntPtr.Zero) return null;
            else return new NativeExceptionStruct((IntPtr)exceptionPointer);
        }

#if DEBUG
        public string GetName() => "NativeExceptionStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppException_16_0
        {
            public Il2CppObject @object;
            public IntPtr /* Il2CppArray* */ trace_ips;
            public IntPtr /* Il2CppObject* */ inner_ex;
            public IntPtr /* Il2CppString* */ message;
            public IntPtr /* Il2CppString* */ help_link;
            public IntPtr /* Il2CppString* */ class_name;
            public IntPtr /* Il2CppString* */ stack_trace;
            public IntPtr /* Il2CppString* */ remote_stack_trace;
            public int remote_stack_index;
            public int hresult;
            public IntPtr /* Il2CppString* */ source;
            public IntPtr /* Il2CppObject* */ _data;
        }

        internal class NativeExceptionStruct : INativeExceptionStruct
        {
            public NativeExceptionStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppException* ExceptionPointer => (Il2CppException*)Pointer;

            private Il2CppException_16_0* NativeException => (Il2CppException_16_0*)Pointer;

            private Il2CppException* dummyInnerException = (Il2CppException*)IntPtr.Zero;

            public ref Il2CppException* InnerException => ref dummyInnerException;

            public INativeExceptionStruct InnerExceptionWrapped
            {
                get
                {
                    IntPtr ptr = (IntPtr)InnerException;
                    if (ptr == IntPtr.Zero) return null;
                    else return new NativeExceptionStruct(ptr);
                }
            }

            public ref IntPtr Message => ref NativeException->message;

            public ref IntPtr HelpLink => ref NativeException->help_link;

            public ref IntPtr ClassName => ref NativeException->class_name;

            public ref IntPtr StackTrace => ref NativeException->stack_trace;

            public ref IntPtr RemoteStackTrace => ref NativeException->remote_stack_trace;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Exception/Exception_21_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Exception
{
    [ApplicableToUnityVersionsSince("5.3.5")]
    public unsafe class NativeExceptionStructHandler_21_0 : INativeExceptionStructHandler
    {
        public INativeExceptionStruct CreateNewExceptionStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppException_21_0>());

            *(Il2CppException_21_0*)pointer = default;

            return new NativeExceptionStruct(pointer);
        }

        public INativeExceptionStruct Wrap(Il2CppException* exceptionPointer)
        {
            if ((IntPtr)exceptionPointer == IntPtr.Zero) return null;
            else return new NativeExceptionStruct((IntPtr)exceptionPointer);
        }

#if DEBUG
        public string GetName() => "NativeExceptionStructHandler_21_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppException_21_0
        {
            public Il2CppObject @object;
            public IntPtr /* Il2CppArray* */ trace_ips;
            public Il2CppException* inner_ex;
            public IntPtr /* Il2CppString* */ message;
            public IntPtr /* Il2CppString* */ help_link;
            public IntPtr /* Il2CppString* */ class_name;
            public IntPtr /* Il2CppString* */ stack_trace;
            public IntPtr /* Il2CppString* */ remote_stack_trace;
            public int remote_stack_index;
            public int hresult;
            public IntPtr /* Il2CppString* */ source;
            public IntPtr /* Il2CppObject* */ _data;
        }

        internal class NativeExceptionStruct : INativeExceptionStruct
        {
            public NativeExceptionStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppException* ExceptionPointer => (Il2CppException*)Pointer;

            private Il2CppException_21_0* NativeException => (Il2CppException_21_0*)Pointer;

            public ref Il2CppException* InnerException => ref NativeException->inner_ex;

            public INativeExceptionStruct InnerExceptionWrapped
            {
                get
                {
                    IntPtr ptr = (IntPtr)NativeException->inner_ex;
                    if (ptr == IntPtr.Zero) return null;
                    else return new NativeExceptionStruct(ptr);
                }
            }

            public ref IntPtr Message => ref NativeException->message;

            public ref IntPtr HelpLink => ref NativeException->help_link;

            public ref IntPtr ClassName => ref NativeException->class_name;

            public ref IntPtr StackTrace => ref NativeException->stack_trace;

            public ref IntPtr RemoteStackTrace => ref NativeException->remote_stack_trace;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Exception/Exception_22_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Exception
{
    [ApplicableToUnityVersionsSince("5.5.0")]
    public unsafe class NativeExceptionStructHandler_22_0 : INativeExceptionStructHandler
    {
        public INativeExceptionStruct CreateNewExceptionStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppException_22_0>());

            *(Il2CppException_22_0*)pointer = default;

            return new NativeExceptionStruct(pointer);
        }

        public INativeExceptionStruct Wrap(Il2CppException* exceptionPointer)
        {
            if ((IntPtr)exceptionPointer == IntPtr.Zero) return null;
            else return new NativeExceptionStruct((IntPtr)exceptionPointer);
        }

#if DEBUG
        public string GetName() => "NativeExceptionStructHandler_22_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppException_22_0
        {
            Il2CppObject @object;
            public IntPtr /* Il2CppString* */ className;
            public IntPtr /* Il2CppString* */ message;
            public IntPtr /* Il2CppObject* */ _data;
            public Il2CppException* inner_ex;
            public IntPtr /* Il2CppString* */ _helpURL;
            public IntPtr /* Il2CppArray* */ trace_ips;
            public IntPtr /* Il2CppString* */ stack_trace;
            public IntPtr /* Il2CppString* */ remote_stack_trace;
            public int remote_stack_index;
            public IntPtr /* Il2CppObject* */ _dynamicMethods;
            public int hresult;
            public IntPtr /* Il2CppString* */ source;
            public IntPtr /* Il2CppObject* */ safeSerializationManager;
            public IntPtr /* Il2CppArray* */ captured_traces;
            public IntPtr /* Il2CppArray* */ native_trace_ips;
        }

        internal class NativeExceptionStruct : INativeExceptionStruct
        {
            public NativeExceptionStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppException* ExceptionPointer => (Il2CppException*)Pointer;

            private Il2CppException_22_0* NativeException => (Il2CppException_22_0*)Pointer;

            public ref Il2CppException* InnerException => ref NativeException->inner_ex;

            public INativeExceptionStruct InnerExceptionWrapped
            {
                get
                {
                    IntPtr ptr = (IntPtr)NativeException->inner_ex;
                    if (ptr == IntPtr.Zero) return null;
                    else return new NativeExceptionStruct(ptr);
                }
            }

            public ref IntPtr Message => ref NativeException->message;

            public ref IntPtr HelpLink => ref NativeException->_helpURL;

            public ref IntPtr ClassName => ref NativeException->className;

            public ref IntPtr StackTrace => ref NativeException->stack_trace;

            public ref IntPtr RemoteStackTrace => ref NativeException->remote_stack_trace;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Exception/Exception_27_3.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Exception
{
    [ApplicableToUnityVersionsSince("2021.2.0")]
    public unsafe class NativeExceptionStructHandler_27_3 : INativeExceptionStructHandler
    {
        public INativeExceptionStruct CreateNewExceptionStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppException_27_3>());

            *(Il2CppException_27_3*)pointer = default;

            return new NativeExceptionStruct(pointer);
        }

        public INativeExceptionStruct Wrap(Il2CppException* exceptionPointer)
        {
            if ((IntPtr)exceptionPointer == IntPtr.Zero) return null;
            else return new NativeExceptionStruct((IntPtr)exceptionPointer);
        }

#if DEBUG
        public string GetName() => "NativeExceptionStructHandler_27_3";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppException_27_3
        {
            Il2CppObject @object;
            public IntPtr /* Il2CppString* */ className;
            public IntPtr /* Il2CppString* */ message;
            public IntPtr /* Il2CppObject* */ _data;
            public Il2CppException* inner_ex;
            public IntPtr /* Il2CppString* */ _helpURL;
            public IntPtr /* Il2CppArray* */ trace_ips;
            public IntPtr /* Il2CppString* */ stack_trace;
            public IntPtr /* Il2CppString* */ remote_stack_trace;
            public int remote_stack_index;
            public IntPtr /* Il2CppObject* */ _dynamicMethods;
            public int hresult;
            public IntPtr /* Il2CppString* */ source;
            public IntPtr /* Il2CppObject* */ safeSerializationManager;
            public IntPtr /* Il2CppArray* */ captured_traces;
            public IntPtr /* Il2CppArray* */ native_trace_ips;
            public int caught_in_unmanaged;
        }

        internal class NativeExceptionStruct : INativeExceptionStruct
        {
            public NativeExceptionStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppException* ExceptionPointer => (Il2CppException*)Pointer;

            private Il2CppException_27_3* NativeException => (Il2CppException_27_3*)Pointer;

            public ref Il2CppException* InnerException => ref NativeException->inner_ex;

            public INativeExceptionStruct InnerExceptionWrapped
            {
                get
                {
                    IntPtr ptr = (IntPtr)NativeException->inner_ex;
                    if (ptr == IntPtr.Zero) return null;
                    else return new NativeExceptionStruct(ptr);
                }
            }

            public ref IntPtr Message => ref NativeException->message;

            public ref IntPtr HelpLink => ref NativeException->_helpURL;

            public ref IntPtr ClassName => ref NativeException->className;

            public ref IntPtr StackTrace => ref NativeException->stack_trace;

            public ref IntPtr RemoteStackTrace => ref NativeException->remote_stack_trace;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Exception/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Exception
{
    public interface INativeExceptionStructHandler : INativeStructHandler
    {
        INativeExceptionStruct CreateNewExceptionStruct();
        unsafe INativeExceptionStruct Wrap(Il2CppException* exceptionPointer);
#if DEBUG
        string GetName();
#endif
    }

    public interface INativeExceptionStruct : INativeStruct
    {
        unsafe Il2CppException* ExceptionPointer { get; }

        unsafe ref Il2CppException* InnerException { get; }

        INativeExceptionStruct InnerExceptionWrapped { get; }

        ref IntPtr Message { get; }

        ref IntPtr HelpLink { get; }

        ref IntPtr ClassName { get; }

        ref IntPtr StackTrace { get; }

        ref IntPtr RemoteStackTrace { get; }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/FieldInfo/FieldInfo_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.FieldInfo
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public unsafe class NativeFieldInfoStructHandler_16_0 : INativeFieldInfoStructHandler
    {
        public INativeFieldInfoStruct CreateNewFieldInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppFieldInfo_16_0>());

            *(Il2CppFieldInfo_16_0*)pointer = default;

            return new NativeFieldInfoStruct(pointer);
        }

        public INativeFieldInfoStruct Wrap(Il2CppFieldInfo* fieldInfoPointer)
        {
            if ((IntPtr)fieldInfoPointer == IntPtr.Zero) return null;
            else return new NativeFieldInfoStruct((IntPtr)fieldInfoPointer);
        }

        public IntPtr il2cpp_field_get_name(IntPtr field) => ((Il2CppFieldInfo_16_0*)field)->name;
        public uint il2cpp_field_get_offset(IntPtr field) => (uint)((Il2CppFieldInfo_16_0*)field)->offset;
        public IntPtr il2cpp_field_get_parent(IntPtr field) => (IntPtr)((Il2CppFieldInfo_16_0*)field)->parent;
        public IntPtr il2cpp_field_get_type(IntPtr field) => (IntPtr)((Il2CppFieldInfo_16_0*)field)->type;

#if DEBUG
        public string GetName() => "NativeFieldInfoStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppFieldInfo_16_0
        {
            public IntPtr name; // const char*
            public Il2CppTypeStruct* type; // const
            public Il2CppClass* parent; // non-const?
            public int offset; // If offset is -1, then it's thread static
            public int customAttributeIndex;
        }

        internal class NativeFieldInfoStruct : INativeFieldInfoStruct
        {
            public NativeFieldInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppFieldInfo* FieldInfoPointer => (Il2CppFieldInfo*)Pointer;

            private Il2CppFieldInfo_16_0* NativeField => (Il2CppFieldInfo_16_0*)Pointer;

            public ref IntPtr Name => ref NativeField->name;

            public ref Il2CppTypeStruct* Type => ref NativeField->type;

            public ref Il2CppClass* Parent => ref NativeField->parent;

            public ref int Offset => ref NativeField->offset;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/FieldInfo/FieldInfo_19_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.FieldInfo
{
    [ApplicableToUnityVersionsSince("5.3.2")]
    public unsafe class NativeFieldInfoStructHandler_19_0 : INativeFieldInfoStructHandler
    {
        public INativeFieldInfoStruct CreateNewFieldInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppFieldInfo_19_0>());

            *(Il2CppFieldInfo_19_0*)pointer = default;

            return new NativeFieldInfoStruct(pointer);
        }

        public INativeFieldInfoStruct Wrap(Il2CppFieldInfo* fieldInfoPointer)
        {
            if ((IntPtr)fieldInfoPointer == IntPtr.Zero) return null;
            else return new NativeFieldInfoStruct((IntPtr)fieldInfoPointer);
        }

        public IntPtr il2cpp_field_get_name(IntPtr field) => ((Il2CppFieldInfo_19_0*)field)->name;
        public uint il2cpp_field_get_offset(IntPtr field) => (uint)((Il2CppFieldInfo_19_0*)field)->offset;
        public IntPtr il2cpp_field_get_parent(IntPtr field) => (IntPtr)((Il2CppFieldInfo_19_0*)field)->parent;
        public IntPtr il2cpp_field_get_type(IntPtr field) => (IntPtr)((Il2CppFieldInfo_19_0*)field)->type;

#if DEBUG
        public string GetName() => "NativeFieldInfoStructHandler_19_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppFieldInfo_19_0
        {
            public IntPtr name; // const char*
            public Il2CppTypeStruct* type; // const
            public Il2CppClass* parent; // non-const?
            public int offset; // If offset is -1, then it's thread static
            public int customAttributeIndex;
            public uint token;
        }

        internal class NativeFieldInfoStruct : INativeFieldInfoStruct
        {
            public NativeFieldInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppFieldInfo* FieldInfoPointer => (Il2CppFieldInfo*)Pointer;

            private Il2CppFieldInfo_19_0* NativeField => (Il2CppFieldInfo_19_0*)Pointer;

            public ref IntPtr Name => ref NativeField->name;

            public ref Il2CppTypeStruct* Type => ref NativeField->type;

            public ref Il2CppClass* Parent => ref NativeField->parent;

            public ref int Offset => ref NativeField->offset;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/FieldInfo/FieldInfo_24_1.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.FieldInfo
{
    [ApplicableToUnityVersionsSince("2018.3.0")]
    public unsafe class NativeFieldInfoStructHandler_24_1 : INativeFieldInfoStructHandler
    {
        public INativeFieldInfoStruct CreateNewFieldInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppFieldInfo_24_1>());

            *(Il2CppFieldInfo_24_1*)pointer = default;

            return new NativeFieldInfoStruct(pointer);
        }

        public INativeFieldInfoStruct Wrap(Il2CppFieldInfo* fieldInfoPointer)
        {
            if ((IntPtr)fieldInfoPointer == IntPtr.Zero) return null;
            else return new NativeFieldInfoStruct((IntPtr)fieldInfoPointer);
        }

        public IntPtr il2cpp_field_get_name(IntPtr field) => ((Il2CppFieldInfo_24_1*)field)->name;
        public uint il2cpp_field_get_offset(IntPtr field) => (uint)((Il2CppFieldInfo_24_1*)field)->offset;
        public IntPtr il2cpp_field_get_parent(IntPtr field) => (IntPtr)((Il2CppFieldInfo_24_1*)field)->parent;
        public IntPtr il2cpp_field_get_type(IntPtr field) => (IntPtr)((Il2CppFieldInfo_24_1*)field)->type;

#if DEBUG
        public string GetName() => "NativeFieldInfoStructHandler_24_1";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppFieldInfo_24_1
        {
            public IntPtr name; // const char*
            public Il2CppTypeStruct* type; // const
            public Il2CppClass* parent; // non-const?
            public int offset; // If offset is -1, then it's thread static
            public uint token;
        }

        internal class NativeFieldInfoStruct : INativeFieldInfoStruct
        {
            public NativeFieldInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppFieldInfo* FieldInfoPointer => (Il2CppFieldInfo*)Pointer;

            private Il2CppFieldInfo_24_1* NativeField => (Il2CppFieldInfo_24_1*)Pointer;

            public ref IntPtr Name => ref NativeField->name;

            public ref Il2CppTypeStruct* Type => ref NativeField->type;

            public ref Il2CppClass* Parent => ref NativeField->parent;

            public ref int Offset => ref NativeField->offset;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/FieldInfo/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.FieldInfo
{
    public interface INativeFieldInfoStructHandler : INativeStructHandler
    {
        INativeFieldInfoStruct CreateNewFieldInfoStruct();
        unsafe INativeFieldInfoStruct Wrap(Il2CppFieldInfo* fieldInfoPointer);
        IntPtr il2cpp_field_get_name(IntPtr field);
        uint il2cpp_field_get_offset(IntPtr field);
        IntPtr il2cpp_field_get_parent(IntPtr field);
        IntPtr il2cpp_field_get_type(IntPtr field);
#if DEBUG
        string GetName();
#endif
    }

    public interface INativeFieldInfoStruct : INativeStruct
    {
        unsafe Il2CppFieldInfo* FieldInfoPointer { get; }

        ref IntPtr Name { get; }

        unsafe ref Il2CppTypeStruct* Type { get; }

        unsafe ref Il2CppClass* Parent { get; }

        ref int Offset { get; }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Images_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public unsafe class NativeImageStructHandler_16_0 : INativeImageStructHandler
    {
        public INativeImageStruct CreateNewImageStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImage_16_0>());

            *(Il2CppImage_16_0*)pointer = default;

            return new NativeImageStruct(pointer);
        }

        public INativeImageStruct Wrap(Il2CppImage* imagePointer)
        {
            if ((IntPtr)imagePointer == IntPtr.Zero) return null;
            else return new NativeImageStruct((IntPtr)imagePointer);
        }

#if DEBUG
        public string GetName() => "NativeImageStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImage_16_0
        {
            public IntPtr name;      // const char*
            public /*AssemblyIndex*/ int assemblyIndex;

            public /*TypeDefinitionIndex*/ int typeStart;
            public uint typeCount;

            public /*MethodIndex*/ int entryPointIndex;

            public /*Il2CppNameToTypeDefinitionIndexHashTable **/ IntPtr nameToClassHashTable;
        }

        internal class NativeImageStruct : INativeImageStruct
        {
            private static byte dynamicDummy;

            public NativeImageStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppImage* ImagePointer => (Il2CppImage*)Pointer;

            private Il2CppImage_16_0* NativeImage => (Il2CppImage_16_0*)Pointer;

            public ref Il2CppAssembly* Assembly => throw new NotSupportedException();

            public ref byte Dynamic => ref dynamicDummy;

            public ref IntPtr Name => ref NativeImage->name;

            public bool HasNameNoExt => false;

            public ref IntPtr NameNoExt => throw new NotSupportedException();
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Images_19_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    [ApplicableToUnityVersionsSince("5.3.2")]
    public unsafe class NativeImageStructHandler_19_0 : INativeImageStructHandler
    {
        public INativeImageStruct CreateNewImageStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImage_19_0>());

            *(Il2CppImage_19_0*)pointer = default;

            return new NativeImageStruct(pointer);
        }

        public INativeImageStruct Wrap(Il2CppImage* imagePointer)
        {
            if ((IntPtr)imagePointer == IntPtr.Zero) return null;
            else return new NativeImageStruct((IntPtr)imagePointer);
        }

#if DEBUG
        public string GetName() => "NativeImageStructHandler_19_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImage_19_0
        {
            public IntPtr name;      // const char*
            public /*AssemblyIndex*/ int assemblyIndex;

            public /*TypeDefinitionIndex*/ int typeStart;
            public uint typeCount;
            
            public /*MethodIndex*/ int entryPointIndex;

            public /*Il2CppNameToTypeDefinitionIndexHashTable **/ IntPtr nameToClassHashTable;

            public uint token;
        }

        internal class NativeImageStruct : INativeImageStruct
        {
            private static byte dynamicDummy;

            public NativeImageStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppImage* ImagePointer => (Il2CppImage*)Pointer;

            private Il2CppImage_19_0* NativeImage => (Il2CppImage_19_0*)Pointer;

            public ref Il2CppAssembly* Assembly => throw new NotSupportedException();

            public ref byte Dynamic => ref dynamicDummy;

            public ref IntPtr Name => ref NativeImage->name;

            public bool HasNameNoExt => false;

            public ref IntPtr NameNoExt => throw new NotSupportedException();
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Images_24_0_A.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    [ApplicableToUnityVersionsSince("2017.1.0")]
    [ApplicableToUnityVersionsSince("2017.2.0")]
    public unsafe class NativeImageStructHandler_24_0_A : INativeImageStructHandler
    {
        public INativeImageStruct CreateNewImageStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImage_24_0_A>());

            *(Il2CppImage_24_0_A*)pointer = default;

            return new NativeImageStruct(pointer);
        }

        public INativeImageStruct Wrap(Il2CppImage* imagePointer)
        {
            if ((IntPtr)imagePointer == IntPtr.Zero) return null;
            else return new NativeImageStruct((IntPtr)imagePointer);
        }

#if DEBUG
        public string GetName() => "NativeImageStructHandler_24_0_A";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImage_24_0_A
        {
            public IntPtr name;      // const char*
            public /*AssemblyIndex*/ int assemblyIndex;

            public /*TypeDefinitionIndex*/ int typeStart;
            public uint typeCount;

            public /*TypeDefinitionIndex*/ int exportedTypeStart;
            public uint exportedTypeCount;
            
            public /*MethodIndex*/ int entryPointIndex;

            public /*Il2CppNameToTypeDefinitionIndexHashTable **/ IntPtr nameToClassHashTable;

            public uint token;
        }

        internal class NativeImageStruct : INativeImageStruct
        {
            private static byte dynamicDummy;

            public NativeImageStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppImage* ImagePointer => (Il2CppImage*)Pointer;

            private Il2CppImage_24_0_A* NativeImage => (Il2CppImage_24_0_A*)Pointer;

            public ref Il2CppAssembly* Assembly => throw new NotSupportedException();

            public ref byte Dynamic => ref dynamicDummy;

            public ref IntPtr Name => ref NativeImage->name;

            public bool HasNameNoExt => false;

            public ref IntPtr NameNoExt => throw new NotSupportedException();
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Images_24_0_B.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    [ApplicableToUnityVersionsSince("2017.1.3")]
    [ApplicableToUnityVersionsSince("2017.2.1")]
    public unsafe class NativeImageStructHandler_24_0_B : INativeImageStructHandler
    {
        public INativeImageStruct CreateNewImageStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImage_24_0_B>());

            *(Il2CppImage_24_0_B*)pointer = default;

            return new NativeImageStruct(pointer);
        }

        public INativeImageStruct Wrap(Il2CppImage* imagePointer)
        {
            if ((IntPtr)imagePointer == IntPtr.Zero) return null;
            else return new NativeImageStruct((IntPtr)imagePointer);
        }

#if DEBUG
        public string GetName() => "NativeImageStructHandler_24_0_B";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImage_24_0_B
        {
            public IntPtr name; // const char*
            public IntPtr nameNoExt; // const char*
            public /*AssemblyIndex*/ int assemblyIndex;

            public /*TypeDefinitionIndex*/ int typeStart;
            public uint typeCount;

            public /*TypeDefinitionIndex*/ int exportedTypeStart;
            public uint exportedTypeCount;
            
            public /*MethodIndex*/ int entryPointIndex;

            public /*Il2CppNameToTypeDefinitionIndexHashTable **/ IntPtr nameToClassHashTable;

            public uint token;
        }

        internal class NativeImageStruct : INativeImageStruct
        {
            private static byte dynamicDummy;

            public NativeImageStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppImage* ImagePointer => (Il2CppImage*)Pointer;

            private Il2CppImage_24_0_B* NativeImage => (Il2CppImage_24_0_B*)Pointer;

            public ref Il2CppAssembly* Assembly => throw new NotSupportedException();

            public ref byte Dynamic => ref dynamicDummy;

            public ref IntPtr Name => ref NativeImage->name;

            public bool HasNameNoExt => true;

            public ref IntPtr NameNoExt => ref NativeImage->nameNoExt;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Images_24_0_C.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    [ApplicableToUnityVersionsSince("2018.1.0")]
    public unsafe class NativeImageStructHandler_24_0_C : INativeImageStructHandler
    {
        public INativeImageStruct CreateNewImageStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImage_24_0_C>());

            *(Il2CppImage_24_0_C*)pointer = default;

            return new NativeImageStruct(pointer);
        }

        public INativeImageStruct Wrap(Il2CppImage* imagePointer)
        {
            if ((IntPtr)imagePointer == IntPtr.Zero) return null;
            else return new NativeImageStruct((IntPtr)imagePointer);
        }

#if DEBUG
        public string GetName() => "NativeImageStructHandler_24_0_C";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImage_24_0_C
        {
            public IntPtr name; // const char*
            public IntPtr nameNoExt; // const char*
            public Il2CppAssembly* assembly;

            public /*TypeDefinitionIndex*/ int typeStart;
            public uint typeCount;

            public /*TypeDefinitionIndex*/ int exportedTypeStart;
            public uint exportedTypeCount;

            public /*MethodIndex*/ int entryPointIndex;

            public /*Il2CppNameToTypeDefinitionIndexHashTable **/ IntPtr nameToClassHashTable;

            public uint token;
            public byte dynamic;
        }

        internal class NativeImageStruct : INativeImageStruct
        {
            public NativeImageStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppImage* ImagePointer => (Il2CppImage*)Pointer;

            private Il2CppImage_24_0_C* NativeImage => (Il2CppImage_24_0_C*)Pointer;

            public ref Il2CppAssembly* Assembly => ref NativeImage->assembly;

            public ref byte Dynamic => ref NativeImage->dynamic;

            public ref IntPtr Name => ref NativeImage->name;

            public bool HasNameNoExt => true;

            public ref IntPtr NameNoExt => ref NativeImage->nameNoExt;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Images_24_1.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    [ApplicableToUnityVersionsSince("2018.3.0")]
    public unsafe class NativeImageStructHandler_24_1 : INativeImageStructHandler
    {
        public INativeImageStruct CreateNewImageStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImage_24_1>());

            *(Il2CppImage_24_1*)pointer = default;

            return new NativeImageStruct(pointer);
        }

        public INativeImageStruct Wrap(Il2CppImage* imagePointer)
        {
            if ((IntPtr)imagePointer == IntPtr.Zero) return null;
            else return new NativeImageStruct((IntPtr)imagePointer);
        }

#if DEBUG
        public string GetName() => "NativeImageStructHandler_24_1";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImage_24_1
        {
            public IntPtr name; // const char*
            public IntPtr nameNoExt; // const char*
            public Il2CppAssembly* assembly;

            public /*TypeDefinitionIndex*/ int typeStart;
            public uint typeCount;

            public /*TypeDefinitionIndex*/ int exportedTypeStart;
            public uint exportedTypeCount;

            public /*CustomAttributeIndex*/ int customAttributeStart;
            public uint customAttributeCount;

            public /*MethodIndex*/ int entryPointIndex;

            public /*Il2CppNameToTypeDefinitionIndexHashTable **/ IntPtr nameToClassHashTable;

            public uint token;
            public byte dynamic;
        }

        internal class NativeImageStruct : INativeImageStruct
        {
            public NativeImageStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppImage* ImagePointer => (Il2CppImage*)Pointer;

            private Il2CppImage_24_1* NativeImage => (Il2CppImage_24_1*)Pointer;

            public ref Il2CppAssembly* Assembly => ref NativeImage->assembly;

            public ref byte Dynamic => ref NativeImage->dynamic;

            public ref IntPtr Name => ref NativeImage->name;

            public bool HasNameNoExt => true;

            public ref IntPtr NameNoExt => ref NativeImage->nameNoExt;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Images_24_2.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    [ApplicableToUnityVersionsSince("2019.1.0")]
    public unsafe class NativeImageStructHandler_24_2 : INativeImageStructHandler
    {
        public INativeImageStruct CreateNewImageStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImage_24_2>());

            *(Il2CppImage_24_2*)pointer = default;

            return new NativeImageStruct(pointer);
        }

        public INativeImageStruct Wrap(Il2CppImage* imagePointer)
        {
            if ((IntPtr)imagePointer == IntPtr.Zero) return null;
            else return new NativeImageStruct((IntPtr)imagePointer);
        }

#if DEBUG
        public string GetName() => "NativeImageStructHandler_24_2";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImage_24_2
        {
            public IntPtr name; // const char*
            public IntPtr nameNoExt; // const char*
            public Il2CppAssembly* assembly;

            public /*TypeDefinitionIndex*/ int typeStart;
            public uint typeCount;

            public /*TypeDefinitionIndex*/ int exportedTypeStart;
            public uint exportedTypeCount;

            public /*CustomAttributeIndex*/ int customAttributeStart;
            public uint customAttributeCount;

            public /*MethodIndex*/ int entryPointIndex;

            public /*Il2CppNameToTypeDefinitionIndexHashTable **/ IntPtr nameToClassHashTable;

            public /*Il2CppCodeGenModule*/ IntPtr codeGenModule;

            public uint token;
            public byte dynamic;
        }

        internal class NativeImageStruct : INativeImageStruct
        {
            public NativeImageStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppImage* ImagePointer => (Il2CppImage*)Pointer;

            private Il2CppImage_24_2* NativeImage => (Il2CppImage_24_2*)Pointer;

            public ref Il2CppAssembly* Assembly => ref NativeImage->assembly;

            public ref byte Dynamic => ref NativeImage->dynamic;

            public ref IntPtr Name => ref NativeImage->name;

            public bool HasNameNoExt => true;

            public ref IntPtr NameNoExt => ref NativeImage->nameNoExt;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Images_27_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    [ApplicableToUnityVersionsSince("2020.2.0")]
    public unsafe class NativeImageStructHandler_27_0 : INativeImageStructHandler
    {
        public INativeImageStruct CreateNewImageStruct()
        {
            var pointer = (Il2CppImage_27_0*) Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImage_27_0>());
            var metadataPointer = (Il2CppImageGlobalMetadata_27_0*) Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppImageGlobalMetadata_27_0>());

            *pointer = default;
            *metadataPointer = default;
            pointer->metadataHandle = metadataPointer;
            metadataPointer->image = pointer;

            return new NativeImageStruct((IntPtr) pointer);
        }

        public INativeImageStruct Wrap(Il2CppImage* imagePointer)
        {
            if ((IntPtr)imagePointer == IntPtr.Zero) return null;
            else return new NativeImageStruct((IntPtr)imagePointer);
        }

#if DEBUG
        public string GetName() => "NativeImageStructHandler_27_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImage_27_0
        {
            public IntPtr name; // const char*
            public IntPtr nameNoExt; // const char*
            public Il2CppAssembly* assembly;

            public uint typeCount;

            public uint exportedTypeCount;
            public uint customAttributeCount;

            public Il2CppImageGlobalMetadata_27_0* metadataHandle;

            public /*Il2CppNameToTypeDefinitionIndexHashTable **/ IntPtr nameToClassHashTable;
            public IntPtr codeGenModule;

            public uint token;
            public byte dynamic;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppImageGlobalMetadata_27_0
        {
            public int typeStart;
            public int exportedTypeStart;
            public int customAttributeStart;
            public int entryPointIndex;
            public Il2CppImage_27_0* image;
        }

        internal class NativeImageStruct : INativeImageStruct
        {
            public NativeImageStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppImage* ImagePointer => (Il2CppImage*)Pointer;

            private Il2CppImage_27_0* NativeImage => (Il2CppImage_27_0*)Pointer;

            public ref Il2CppAssembly* Assembly => ref NativeImage->assembly;

            public ref byte Dynamic => ref NativeImage->dynamic;

            public ref IntPtr Name => ref NativeImage->name;

            public bool HasNameNoExt => true;

            public ref IntPtr NameNoExt => ref NativeImage->nameNoExt;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/Image/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Image
{
    public interface INativeImageStructHandler : INativeStructHandler
    {
        INativeImageStruct CreateNewImageStruct();
        unsafe INativeImageStruct Wrap(Il2CppImage* imagePointer);
#if DEBUG
        string GetName();
#endif
    }

    public interface INativeImageStruct : INativeStruct
    {
        unsafe Il2CppImage* ImagePointer { get; }

        unsafe ref Il2CppAssembly* Assembly { get; }

        ref byte Dynamic { get; }

        ref IntPtr Name { get; }

        bool HasNameNoExt { get; }

        ref IntPtr NameNoExt { get; }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/MethodInfo/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.MethodInfo
{
    public interface INativeMethodInfoStructHandler : INativeStructHandler
    {
        INativeMethodInfoStruct CreateNewMethodStruct();
        unsafe INativeMethodInfoStruct Wrap(Il2CppMethodInfo* methodPointer);
        IntPtr GetMethodFromReflection(IntPtr method);
        IntPtr CopyMethodInfoStruct(IntPtr origMethodInfo);
        IntPtr il2cpp_method_get_class(IntPtr method);
        IntPtr il2cpp_method_get_name(IntPtr method);
        uint il2cpp_method_get_param_count(IntPtr method);
        IntPtr il2cpp_method_get_return_type(IntPtr method);
        uint il2cpp_method_get_token(IntPtr method);
#if DEBUG
        string GetName();
#endif
    }


    public interface INativeMethodInfoStruct : INativeStruct
    {
        int StructSize { get; }
        unsafe Il2CppMethodInfo* MethodInfoPointer { get; }
        ref IntPtr Name { get; }
        ref ushort Slot { get; }
        ref IntPtr MethodPointer { get; }
        unsafe ref Il2CppClass* Class { get; }
        ref IntPtr InvokerMethod { get; }
        unsafe ref Il2CppTypeStruct* ReturnType { get; }
        ref Il2CppMethodFlags Flags { get; }
        ref byte ParametersCount { get; }
        unsafe ref Il2CppParameterInfo* Parameters { get; }
        bool IsGeneric { get; set; }
        bool IsInflated { get; set; }
        bool IsMarshalledFromNative { get; set; }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/MethodInfo/MethodInfo_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.MethodInfo
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public unsafe class NativeMethodInfoStructHandler_16_0 : INativeMethodInfoStructHandler
    {
        public INativeMethodInfoStruct CreateNewMethodStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppMethodInfo_16_0>());
            *(Il2CppMethodInfo_16_0*)pointer = default;

            return new NativeMethodInfoStructWrapper(pointer);
        }

        public INativeMethodInfoStruct Wrap(Il2CppMethodInfo* methodPointer)
        {
            if ((IntPtr)methodPointer == IntPtr.Zero) return null;
            else return new NativeMethodInfoStructWrapper((IntPtr)methodPointer);
        }

        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        private static extern IntPtr il2cpp_method_get_from_reflection(IntPtr method);

        public IntPtr GetMethodFromReflection(IntPtr method)
        {
            return il2cpp_method_get_from_reflection(method);
        }

        public IntPtr CopyMethodInfoStruct(IntPtr origMethodInfo)
        {
            int sizeOfMethodInfo = Marshal.SizeOf<Il2CppMethodInfo_16_0>();
            IntPtr copiedMethodInfo = Marshal.AllocHGlobal(sizeOfMethodInfo);

            object temp = Marshal.PtrToStructure<Il2CppMethodInfo_16_0>(origMethodInfo);
            Marshal.StructureToPtr(temp, copiedMethodInfo, false);

            return copiedMethodInfo;
        }

        public IntPtr il2cpp_method_get_class(IntPtr method) => (IntPtr)((Il2CppMethodInfo_16_0*)method)->klass;
        public IntPtr il2cpp_method_get_name(IntPtr method) => ((Il2CppMethodInfo_16_0*)method)->name;
        public uint il2cpp_method_get_param_count(IntPtr method) => ((Il2CppMethodInfo_16_0*)method)->parameters_count;
        public IntPtr il2cpp_method_get_return_type(IntPtr method) => (IntPtr)((Il2CppMethodInfo_16_0*)method)->return_type;
        public uint il2cpp_method_get_token(IntPtr method) => ((Il2CppMethodInfo_16_0*)method)->token;

#if DEBUG
        public string GetName() => "NativeMethodInfoStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppMethodInfo_16_0
        {
            public IntPtr methodPointer;
            public IntPtr invoker_method;
            public IntPtr name; // const char*
            public Il2CppClass* klass;
            public Il2CppTypeStruct* return_type;
            public Il2CppParameterInfo* parameters;

            public IntPtr someRtData;
            /*union
            {
                const Il2CppRGCTXData* rgctx_data; /* is_inflated is true and is_generic is false, i.e. a generic instance method #1#
                const Il2CppMethodDefinition* methodDefinition;
            };*/

            public IntPtr someGenericData;
            /*/* note, when is_generic == true and is_inflated == true the method represents an uninflated generic method on an inflated type. #1#
            union
            {
                const Il2CppGenericMethod* genericMethod; /* is_inflated is true #1#
                const Il2CppGenericContainer* genericContainer; /* is_inflated is false and is_generic is true #1#
            };*/

            public int customAttributeIndex;
            public uint token;
            public Il2CppMethodFlags flags;
            public Il2CppMethodImplFlags iflags;
            public ushort slot;
            public byte parameters_count;

            public MethodInfoExtraFlags extra_flags;
            /*uint8_t is_generic : 1; /* true if method is a generic method definition #1#
            uint8_t is_inflated : 1; /* true if declaring_type is a generic instance or if method is a generic instance#1#
            uint8_t wrapper_type : 1; /* always zero (MONO_WRAPPER_NONE) needed for the debugger #1#
            uint8_t is_marshaled_from_native : 1*/
        }


        internal class NativeMethodInfoStructWrapper : INativeMethodInfoStruct
        {
            public NativeMethodInfoStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public int StructSize => Marshal.SizeOf<Il2CppMethodInfo_16_0>();

            public IntPtr Pointer { get; }

            public Il2CppMethodInfo* MethodInfoPointer => (Il2CppMethodInfo*)Pointer;

            private Il2CppMethodInfo_16_0* NativeMethod => (Il2CppMethodInfo_16_0*)Pointer;

            public ref IntPtr Name => ref NativeMethod->name;

            public ref ushort Slot => ref NativeMethod->slot;

            public ref IntPtr MethodPointer => ref NativeMethod->methodPointer;

            public ref Il2CppClass* Class => ref NativeMethod->klass;

            public ref IntPtr InvokerMethod => ref NativeMethod->invoker_method;

            public ref Il2CppTypeStruct* ReturnType => ref NativeMethod->return_type;

            public ref Il2CppMethodFlags Flags => ref NativeMethod->flags;

            public ref byte ParametersCount => ref NativeMethod->parameters_count;

            public ref Il2CppParameterInfo* Parameters => ref NativeMethod->parameters;

            public bool IsGeneric
            {
                get => (NativeMethod->extra_flags & MethodInfoExtraFlags.is_generic) != 0;
                set
                {
                    if (value) NativeMethod->extra_flags |= MethodInfoExtraFlags.is_generic;
                    else NativeMethod->extra_flags &= ~MethodInfoExtraFlags.is_generic;
                }
            }

            public bool IsInflated
            {
                get => (NativeMethod->extra_flags & MethodInfoExtraFlags.is_inflated) != 0;
                set
                {
                    if (value) NativeMethod->extra_flags |= MethodInfoExtraFlags.is_inflated;
                    else NativeMethod->extra_flags &= ~MethodInfoExtraFlags.is_inflated;
                }
            }

            public bool IsMarshalledFromNative
            {
                get => (NativeMethod->extra_flags & MethodInfoExtraFlags.is_marshalled_from_native) != 0;
                set
                {
                    if (value) NativeMethod->extra_flags |= MethodInfoExtraFlags.is_marshalled_from_native;
                    else NativeMethod->extra_flags &= ~MethodInfoExtraFlags.is_marshalled_from_native;
                }
            }
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/MethodInfo/MethodInfo_24_1.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.MethodInfo
{
    [ApplicableToUnityVersionsSince("2018.3.0")]
    public unsafe class NativeMethodInfoStructHandler_24_1 : INativeMethodInfoStructHandler
    {
        public INativeMethodInfoStruct CreateNewMethodStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppMethodInfo_24_1>());
            *(Il2CppMethodInfo_24_1*)pointer = default;

            return new NativeMethodInfoStructWrapper(pointer);
        }

        public INativeMethodInfoStruct Wrap(Il2CppMethodInfo* methodPointer)
        {
            if ((IntPtr)methodPointer == IntPtr.Zero) return null;
            else return new NativeMethodInfoStructWrapper((IntPtr)methodPointer);
        }

        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        private static extern IntPtr il2cpp_method_get_from_reflection(IntPtr method);

        public IntPtr GetMethodFromReflection(IntPtr method)
        {
            return il2cpp_method_get_from_reflection(method);
        }

        public IntPtr CopyMethodInfoStruct(IntPtr origMethodInfo)
        {
            int sizeOfMethodInfo = Marshal.SizeOf<Il2CppMethodInfo_24_1>();
            IntPtr copiedMethodInfo = Marshal.AllocHGlobal(sizeOfMethodInfo);

            object temp = Marshal.PtrToStructure<Il2CppMethodInfo_24_1>(origMethodInfo);
            Marshal.StructureToPtr(temp, copiedMethodInfo, false);

            return copiedMethodInfo;
        }

        public IntPtr il2cpp_method_get_class(IntPtr method) => (IntPtr)((Il2CppMethodInfo_24_1*)method)->klass;
        public IntPtr il2cpp_method_get_name(IntPtr method) => ((Il2CppMethodInfo_24_1*)method)->name;
        public uint il2cpp_method_get_param_count(IntPtr method) => ((Il2CppMethodInfo_24_1*)method)->parameters_count;
        public IntPtr il2cpp_method_get_return_type(IntPtr method) => (IntPtr)((Il2CppMethodInfo_24_1*)method)->return_type;
        public uint il2cpp_method_get_token(IntPtr method) => ((Il2CppMethodInfo_24_1*)method)->token;

#if DEBUG
        public string GetName() => "NativeMethodInfoStructHandler_24_1";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppMethodInfo_24_1
        {
            public IntPtr methodPointer;
            public IntPtr invoker_method;
            public IntPtr name; // const char*
            public Il2CppClass* klass;
            public Il2CppTypeStruct* return_type;
            public Il2CppParameterInfo* parameters;

            public IntPtr someRtData;
            /*union
            {
                const Il2CppRGCTXData* rgctx_data; /* is_inflated is true and is_generic is false, i.e. a generic instance method #1#
                const Il2CppMethodDefinition* methodDefinition;
            };*/

            public IntPtr someGenericData;
            /*/* note, when is_generic == true and is_inflated == true the method represents an uninflated generic method on an inflated type. #1#
            union
            {
                const Il2CppGenericMethod* genericMethod; /* is_inflated is true #1#
                const Il2CppGenericContainer* genericContainer; /* is_inflated is false and is_generic is true #1#
            };*/

            public uint token;
            public Il2CppMethodFlags flags;
            public Il2CppMethodImplFlags iflags;
            public ushort slot;
            public byte parameters_count;

            public MethodInfoExtraFlags extra_flags;
            /*uint8_t is_generic : 1; /* true if method is a generic method definition #1#
            uint8_t is_inflated : 1; /* true if declaring_type is a generic instance or if method is a generic instance#1#
            uint8_t wrapper_type : 1; /* always zero (MONO_WRAPPER_NONE) needed for the debugger #1#
            uint8_t is_marshaled_from_native : 1*/
        }


        internal class NativeMethodInfoStructWrapper : INativeMethodInfoStruct
        {
            public NativeMethodInfoStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public int StructSize => Marshal.SizeOf<Il2CppMethodInfo_24_1>();

            public IntPtr Pointer { get; }

            public Il2CppMethodInfo* MethodInfoPointer => (Il2CppMethodInfo*)Pointer;

            private Il2CppMethodInfo_24_1* NativeMethod => (Il2CppMethodInfo_24_1*)Pointer;

            public ref IntPtr Name => ref NativeMethod->name;

            public ref ushort Slot => ref NativeMethod->slot;

            public ref IntPtr MethodPointer => ref NativeMethod->methodPointer;

            public ref Il2CppClass* Class => ref NativeMethod->klass;

            public ref IntPtr InvokerMethod => ref NativeMethod->invoker_method;

            public ref Il2CppTypeStruct* ReturnType => ref NativeMethod->return_type;

            public ref Il2CppMethodFlags Flags => ref NativeMethod->flags;

            public ref byte ParametersCount => ref NativeMethod->parameters_count;

            public ref Il2CppParameterInfo* Parameters => ref NativeMethod->parameters;

            public bool IsGeneric
            {
                get => (NativeMethod->extra_flags & MethodInfoExtraFlags.is_generic) != 0;
                set
                {
                    if (value) NativeMethod->extra_flags |= MethodInfoExtraFlags.is_generic;
                    else NativeMethod->extra_flags &= ~MethodInfoExtraFlags.is_generic;
                }
            }

            public bool IsInflated
            {
                get => (NativeMethod->extra_flags & MethodInfoExtraFlags.is_inflated) != 0;
                set
                {
                    if (value) NativeMethod->extra_flags |= MethodInfoExtraFlags.is_inflated;
                    else NativeMethod->extra_flags &= ~MethodInfoExtraFlags.is_inflated;
                }
            }

            public bool IsMarshalledFromNative
            {
                get => (NativeMethod->extra_flags & MethodInfoExtraFlags.is_marshalled_from_native) != 0;
                set
                {
                    if (value) NativeMethod->extra_flags |= MethodInfoExtraFlags.is_marshalled_from_native;
                    else NativeMethod->extra_flags &= ~MethodInfoExtraFlags.is_marshalled_from_native;
                }
            }
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/MethodInfo/MethodInfo_27_3.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.MethodInfo
{
    [ApplicableToUnityVersionsSince("2021.2.0")]
    public unsafe class NativeMethodInfoStructHandler_27_3 : INativeMethodInfoStructHandler
    {
        public INativeMethodInfoStruct CreateNewMethodStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppMethodInfo_27_3>());
            *(Il2CppMethodInfo_27_3*)pointer = default;

            return new NativeMethodInfoStructWrapper(pointer);
        }

        public INativeMethodInfoStruct Wrap(Il2CppMethodInfo* methodPointer)
        {
            if ((IntPtr)methodPointer == IntPtr.Zero) return null;
            else return new NativeMethodInfoStructWrapper((IntPtr)methodPointer);
        }

        [DllImport("GameAssembly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        private static extern IntPtr il2cpp_method_get_from_reflection(IntPtr method);

        public IntPtr GetMethodFromReflection(IntPtr method)
        {
            return il2cpp_method_get_from_reflection(method);
        }

        public IntPtr CopyMethodInfoStruct(IntPtr origMethodInfo)
        {
            int sizeOfMethodInfo = Marshal.SizeOf<Il2CppMethodInfo_27_3>();
            IntPtr copiedMethodInfo = Marshal.AllocHGlobal(sizeOfMethodInfo);

            object temp = Marshal.PtrToStructure<Il2CppMethodInfo_27_3>(origMethodInfo);
            Marshal.StructureToPtr(temp, copiedMethodInfo, false);

            return copiedMethodInfo;
        }

        public IntPtr il2cpp_method_get_class(IntPtr method) => (IntPtr)((Il2CppMethodInfo_27_3*)method)->klass;
        public IntPtr il2cpp_method_get_name(IntPtr method) => ((Il2CppMethodInfo_27_3*)method)->name;
        public uint il2cpp_method_get_param_count(IntPtr method) => ((Il2CppMethodInfo_27_3*)method)->parameters_count;
        public IntPtr il2cpp_method_get_return_type(IntPtr method) => (IntPtr)((Il2CppMethodInfo_27_3*)method)->return_type;
        public uint il2cpp_method_get_token(IntPtr method) => ((Il2CppMethodInfo_27_3*)method)->token;

#if DEBUG
        public string GetName() => "NativeMethodInfoStructHandler_27_3";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppMethodInfo_27_3
        {
            public IntPtr methodPointer;
            public IntPtr virtualMethodPointer;
            public IntPtr invoker_method;
            public IntPtr name; // const char*
            public Il2CppClass* klass;
            public Il2CppTypeStruct* return_type;
            
            public /* Il2CppTypeStruct** */ Il2CppParameterInfo* parameters;
            // Actually a type pointer array but left as parameter info because
            // it's the same size, and it makes the wrapper code much cleaner.

            public IntPtr someRtData;
            /*union
            {
                const Il2CppRGCTXData* rgctx_data; /* is_inflated is true and is_generic is false, i.e. a generic instance method #1#
                const Il2CppMethodDefinition* methodDefinition;
            };*/

            public IntPtr someGenericData;
            /*/* note, when is_generic == true and is_inflated == true the method represents an uninflated generic method on an inflated type. #1#
            union
            {
                const Il2CppGenericMethod* genericMethod; /* is_inflated is true #1#
                const Il2CppGenericContainer* genericContainer; /* is_inflated is false and is_generic is true #1#
            };*/

            public uint token;
            public Il2CppMethodFlags flags;
            public Il2CppMethodImplFlags iflags;
            public ushort slot;
            public byte parameters_count;

            public MethodInfoExtraFlags_27_3 extra_flags;
        }
        
        [Flags]
        public enum MethodInfoExtraFlags_27_3 : byte
        {
            is_generic = 0x1,
            is_inflated = 0x2,
            wrapper_type = 0x4,
            has_full_generic_sharing_signature = 0x8,
            indirect_call_via_invokers = 0x10
        }


        internal class NativeMethodInfoStructWrapper : INativeMethodInfoStruct
        {
            public NativeMethodInfoStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public int StructSize => Marshal.SizeOf<Il2CppMethodInfo_27_3>();

            public IntPtr Pointer { get; }

            public Il2CppMethodInfo* MethodInfoPointer => (Il2CppMethodInfo*)Pointer;

            private Il2CppMethodInfo_27_3* NativeMethod => (Il2CppMethodInfo_27_3*)Pointer;

            public ref IntPtr Name => ref NativeMethod->name;

            public ref ushort Slot => ref NativeMethod->slot;

            public ref IntPtr MethodPointer => ref NativeMethod->methodPointer;

            public ref Il2CppClass* Class => ref NativeMethod->klass;

            public ref IntPtr InvokerMethod => ref NativeMethod->invoker_method;

            public ref Il2CppTypeStruct* ReturnType => ref NativeMethod->return_type;

            public ref Il2CppMethodFlags Flags => ref NativeMethod->flags;

            public ref byte ParametersCount => ref NativeMethod->parameters_count;

            public ref Il2CppParameterInfo* Parameters => ref NativeMethod->parameters;

            public bool IsGeneric
            {
                get => (NativeMethod->extra_flags & MethodInfoExtraFlags_27_3.is_generic) != 0;
                set
                {
                    if (value) NativeMethod->extra_flags |= MethodInfoExtraFlags_27_3.is_generic;
                    else NativeMethod->extra_flags &= ~MethodInfoExtraFlags_27_3.is_generic;
                }
            }

            public bool IsInflated
            {
                get => (NativeMethod->extra_flags & MethodInfoExtraFlags_27_3.is_inflated) != 0;
                set
                {
                    if (value) NativeMethod->extra_flags |= MethodInfoExtraFlags_27_3.is_inflated;
                    else NativeMethod->extra_flags &= ~MethodInfoExtraFlags_27_3.is_inflated;
                }
            }

            public bool IsMarshalledFromNative
            {
                get => false;
                set { /* no-op */ }
            }
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/ParameterInfo/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.ParameterInfo
{
    public interface INativeParameterInfoStructHandler : INativeStructHandler
    {
        unsafe Il2CppParameterInfo*[] CreateNewParameterInfoArray(int paramCount);
        unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* paramInfoPointer);
        unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* paramInfoListBegin, int index);
        bool HasNamePosToken { get; }
#if DEBUG
        string GetName();
#endif
    }

    public interface INativeParameterInfoStruct : INativeStruct
    {
        unsafe Il2CppParameterInfo* ParameterInfoPointer { get; }
        bool HasNamePosToken { get; }
        ref IntPtr Name { get; }
        ref int Position { get; }
        ref uint Token { get; }
        unsafe ref Il2CppTypeStruct* ParameterType { get; }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/ParameterInfo/ParameterInfo_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.ParameterInfo
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    internal class NativeParameterInfoStructHandler_16_0 : INativeParameterInfoStructHandler
    {
        public unsafe Il2CppParameterInfo*[] CreateNewParameterInfoArray(int paramCount)
        {
            var ptr = (Il2CppParameterInfo_16_0*) Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppParameterInfo_16_0>() * paramCount);
            var res = new Il2CppParameterInfo*[paramCount];
            for (var i = 0; i < paramCount; i++)
            {
                ptr[i] = default;
                res[i] = (Il2CppParameterInfo*) &ptr[i];
            }
            return res;
        }

        public unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* paramInfoPointer)
        {
            if ((IntPtr)paramInfoPointer == IntPtr.Zero) return null;
            else return new NativeParameterInfoStructWrapper((IntPtr) paramInfoPointer);
        }

        public unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* paramInfoListBegin, int index)
        {
            if ((IntPtr)paramInfoListBegin == IntPtr.Zero) return null;
            else return new NativeParameterInfoStructWrapper((IntPtr) paramInfoListBegin + (Marshal.SizeOf<Il2CppParameterInfo_16_0>() * index));
        }

        public bool HasNamePosToken => true;

#if DEBUG
        public string GetName() => "NativeParameterInfoStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppParameterInfo_16_0
        {
            public IntPtr name; // const char*
            public int position;
            public uint token;
            public int customAttributeIndex;
            public Il2CppTypeStruct* parameter_type; // const
        }

        internal unsafe class NativeParameterInfoStructWrapper : INativeParameterInfoStruct
        {
            public NativeParameterInfoStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppParameterInfo* ParameterInfoPointer => (Il2CppParameterInfo*)Pointer;

            public bool HasNamePosToken => true;

            private Il2CppParameterInfo_16_0* NativeParameter => (Il2CppParameterInfo_16_0*)Pointer;

            public ref IntPtr Name => ref NativeParameter->name;

            public ref int Position => ref NativeParameter->position;

            public ref uint Token => ref NativeParameter->token;

            public ref Il2CppTypeStruct* ParameterType => ref NativeParameter->parameter_type;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/ParameterInfo/ParameterInfo_24_1.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.ParameterInfo
{
    [ApplicableToUnityVersionsSince("2018.3.0")]
    internal class NativeParameterInfoStructHandler_24_1 : INativeParameterInfoStructHandler
    {
        public unsafe Il2CppParameterInfo*[] CreateNewParameterInfoArray(int paramCount)
        {
            var ptr = (Il2CppParameterInfo_24_1*) Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppParameterInfo_24_1>() * paramCount);
            var res = new Il2CppParameterInfo*[paramCount];
            for (var i = 0; i < paramCount; i++)
            {
                ptr[i] = default;
                res[i] = (Il2CppParameterInfo*) &ptr[i];
            }
            return res;
        }

        public unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* paramInfoPointer)
        {
            if ((IntPtr)paramInfoPointer == IntPtr.Zero) return null;
            else return new NativeParameterInfoStructWrapper((IntPtr) paramInfoPointer);
        }

        public unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* paramInfoListBegin, int index)
        {
            if ((IntPtr)paramInfoListBegin == IntPtr.Zero) return null;
            else return new NativeParameterInfoStructWrapper((IntPtr) paramInfoListBegin + (Marshal.SizeOf<Il2CppParameterInfo_24_1>() * index));
        }

        public bool HasNamePosToken => true;

#if DEBUG
        public string GetName() => "NativeParameterInfoStructHandler_24_1";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppParameterInfo_24_1
        {
            public IntPtr name; // const char*
            public int position;
            public uint token;
            public Il2CppTypeStruct* parameter_type; // const
        }

        internal unsafe class NativeParameterInfoStructWrapper : INativeParameterInfoStruct
        {
            public NativeParameterInfoStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppParameterInfo* ParameterInfoPointer => (Il2CppParameterInfo*)Pointer;

            public bool HasNamePosToken => true;

            private Il2CppParameterInfo_24_1* NativeParameter => (Il2CppParameterInfo_24_1*)Pointer;

            public ref IntPtr Name => ref NativeParameter->name;

            public ref int Position => ref NativeParameter->position;

            public ref uint Token => ref NativeParameter->token;

            public ref Il2CppTypeStruct* ParameterType => ref NativeParameter->parameter_type;
        }
    }
}
```

`UnhollowerBaseLib/Runtime/VersionSpecific/ParameterInfo/ParameterInfo_27_3.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.ParameterInfo
{
    [ApplicableToUnityVersionsSince("2021.2.0")]
    internal class NativeParameterInfoStructHandler_27_3 : INativeParameterInfoStructHandler
    {
        public unsafe Il2CppParameterInfo*[] CreateNewParameterInfoArray(int paramCount)
        {
            var ptr = (Il2CppParameterInfo_27_3*)Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppParameterInfo_27_3>() * paramCount);
            var res = new Il2CppParameterInfo*[paramCount];
            for (var i = 0; i < paramCount; i++)
            {
                ptr[i] = default;
                res[i] = (Il2CppParameterInfo*)&ptr[i];
            }
            return res;
        }

        public unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* paramInfoPointer)
        {
            if ((IntPtr)paramInfoPointer == IntPtr.Zero) return null;
            else return new NativeParameterInfoStructWrapper((IntPtr)paramInfoPointer);
        }

        public unsafe INativeParameterInfoStruct Wrap(Il2CppParameterInfo* paramInfoListBegin, int index)
        {
            if ((IntPtr)paramInfoListBegin == IntPtr.Zero) return null;
            else return new NativeParameterInfoStructWrapper((IntPtr) paramInfoListBegin + (Marshal.SizeOf<Il2CppParameterInfo_27_3>() * index));
        }

        public bool HasNamePosToken => false;

#if DEBUG
        public string GetName() => "NativeParameterInfoStructHandler_27_3";
#endif

        //Doesn't actually exist; just using this for type pointer storage in MethodInfo 27_3 +
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct Il2CppParameterInfo_27_3
        {
            public Il2CppTypeStruct* parameter_type;
        }

        internal unsafe class NativeParameterInfoStructWrapper : INativeParameterInfoStruct
        {
            public NativeParameterInfoStructWrapper(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppParameterInfo* ParameterInfoPointer => (Il2CppParameterInfo*)Pointer;

            public bool HasNamePosToken => false;

            private Il2CppParameterInfo_27_3* NativeParameter => (Il2CppParameterInfo_27_3*)Pointer;

            public ref IntPtr Name => throw new NotSupportedException("ParameterInfo does not exist in Unity 2021.2.0+");

            public ref int Position => throw new NotSupportedException("ParameterInfo does not exist in Unity 2021.2.0+");

            public ref uint Token => throw new NotSupportedException("ParameterInfo does not exist in Unity 2021.2.0+");

            public ref Il2CppTypeStruct* ParameterType => ref NativeParameter->parameter_type;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/PropertyInfo/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.PropertyInfo
{
    public interface INativePropertyInfoStructHandler : INativeStructHandler
    {
        INativePropertyInfoStruct CreateNewPropertyInfoStruct();
        unsafe INativePropertyInfoStruct Wrap(Il2CppPropertyInfo* propertyInfoPointer);
        IntPtr il2cpp_property_get_name(IntPtr prop);
        IntPtr il2cpp_property_get_parent(IntPtr prop);
        IntPtr il2cpp_property_get_get_method(IntPtr prop);
        IntPtr il2cpp_property_get_set_method(IntPtr prop);
#if DEBUG
        string GetName();
#endif
    }

    public interface INativePropertyInfoStruct : INativeStruct
    {
        unsafe Il2CppPropertyInfo* PropertyInfoPointer { get; }

        ref IntPtr Name { get; }

        unsafe ref Il2CppClass* Parent { get; }

        unsafe ref Il2CppMethodInfo* Get { get; }

        unsafe ref Il2CppMethodInfo* Set { get; }

        ref uint Attrs { get; }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/PropertyInfo/PropertyInfo_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.PropertyInfo
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public unsafe class NativePropertyInfoStructHandler_16_0 : INativePropertyInfoStructHandler
    {
        public INativePropertyInfoStruct CreateNewPropertyInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppPropertyInfo_16_0>());

            *(Il2CppPropertyInfo_16_0*)pointer = default;

            return new NativePropertyInfoStruct(pointer);
        }

        public INativePropertyInfoStruct Wrap(Il2CppPropertyInfo* propertyInfoPointer)
        {
            if ((IntPtr)propertyInfoPointer == IntPtr.Zero) return null;
            else return new NativePropertyInfoStruct((IntPtr)propertyInfoPointer);
        }

        public IntPtr il2cpp_property_get_name(IntPtr prop) => ((Il2CppPropertyInfo_16_0*)prop)->name;
        public IntPtr il2cpp_property_get_parent(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_16_0*)prop)->parent;
        public IntPtr il2cpp_property_get_get_method(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_16_0*)prop)->get;
        public IntPtr il2cpp_property_get_set_method(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_16_0*)prop)->set;

#if DEBUG
        public string GetName() => "NativePropertyInfoStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppPropertyInfo_16_0
        {
            public Il2CppClass* parent;
            public IntPtr name; // const char*
            public Il2CppMethodInfo* get; // const
            public Il2CppMethodInfo* set; // const
            public uint attrs;
            public int customAttributeIndex;
        }

        internal class NativePropertyInfoStruct : INativePropertyInfoStruct
        {
            public NativePropertyInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppPropertyInfo* PropertyInfoPointer => (Il2CppPropertyInfo*)Pointer;

            private Il2CppPropertyInfo_16_0* NativeProperty => (Il2CppPropertyInfo_16_0*)Pointer;

            public ref IntPtr Name => ref NativeProperty->name;

            public ref Il2CppClass* Parent => ref NativeProperty->parent;

            public ref Il2CppMethodInfo* Get => ref NativeProperty->get;

            public ref Il2CppMethodInfo* Set => ref NativeProperty->set;

            public ref uint Attrs => ref NativeProperty->attrs;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/PropertyInfo/PropertyInfo_19_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.PropertyInfo
{
    [ApplicableToUnityVersionsSince("5.3.2")]
    public unsafe class NativePropertyInfoStructHandler_19_0 : INativePropertyInfoStructHandler
    {
        public INativePropertyInfoStruct CreateNewPropertyInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppPropertyInfo_19_0>());

            *(Il2CppPropertyInfo_19_0*)pointer = default;

            return new NativePropertyInfoStruct(pointer);
        }

        public INativePropertyInfoStruct Wrap(Il2CppPropertyInfo* propertyInfoPointer)
        {
            if ((IntPtr)propertyInfoPointer == IntPtr.Zero) return null;
            else return new NativePropertyInfoStruct((IntPtr)propertyInfoPointer);
        }

        public IntPtr il2cpp_property_get_name(IntPtr prop) => ((Il2CppPropertyInfo_19_0*)prop)->name;
        public IntPtr il2cpp_property_get_parent(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_19_0*)prop)->parent;
        public IntPtr il2cpp_property_get_get_method(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_19_0*)prop)->get;
        public IntPtr il2cpp_property_get_set_method(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_19_0*)prop)->set;

#if DEBUG
        public string GetName() => "NativePropertyInfoStructHandler_19_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppPropertyInfo_19_0
        {
            public Il2CppClass* parent;
            public IntPtr name; // const char*
            public Il2CppMethodInfo* get; // const
            public Il2CppMethodInfo* set; // const
            public uint attrs;
            public int customAttributeIndex;
            public uint token;
        }

        internal class NativePropertyInfoStruct : INativePropertyInfoStruct
        {
            public NativePropertyInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppPropertyInfo* PropertyInfoPointer => (Il2CppPropertyInfo*)Pointer;

            private Il2CppPropertyInfo_19_0* NativeProperty => (Il2CppPropertyInfo_19_0*)Pointer;

            public ref IntPtr Name => ref NativeProperty->name;

            public ref Il2CppClass* Parent => ref NativeProperty->parent;

            public ref Il2CppMethodInfo* Get => ref NativeProperty->get;

            public ref Il2CppMethodInfo* Set => ref NativeProperty->set;

            public ref uint Attrs => ref NativeProperty->attrs;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/PropertyInfo/PropertyInfo_24_1.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.PropertyInfo
{
    [ApplicableToUnityVersionsSince("2018.3.0")]
    public unsafe class NativePropertyInfoStructHandler_24_1 : INativePropertyInfoStructHandler
    {
        public INativePropertyInfoStruct CreateNewPropertyInfoStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppPropertyInfo_24_1>());

            *(Il2CppPropertyInfo_24_1*)pointer = default;

            return new NativePropertyInfoStruct(pointer);
        }

        public INativePropertyInfoStruct Wrap(Il2CppPropertyInfo* propertyInfoPointer)
        {
            if ((IntPtr)propertyInfoPointer == IntPtr.Zero) return null;
            else return new NativePropertyInfoStruct((IntPtr)propertyInfoPointer);
        }

        public IntPtr il2cpp_property_get_name(IntPtr prop) => ((Il2CppPropertyInfo_24_1*)prop)->name;
        public IntPtr il2cpp_property_get_parent(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_24_1*)prop)->parent;
        public IntPtr il2cpp_property_get_get_method(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_24_1*)prop)->get;
        public IntPtr il2cpp_property_get_set_method(IntPtr prop) => (IntPtr)((Il2CppPropertyInfo_24_1*)prop)->set;

#if DEBUG
        public string GetName() => "NativePropertyInfoStructHandler_24_1";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppPropertyInfo_24_1
        {
            public Il2CppClass* parent;
            public IntPtr name; // const char*
            public Il2CppMethodInfo* get; // const
            public Il2CppMethodInfo* set; // const
            public uint attrs;
            public uint token;
        }

        internal class NativePropertyInfoStruct : INativePropertyInfoStruct
        {
            public NativePropertyInfoStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            public IntPtr Pointer { get; }

            public Il2CppPropertyInfo* PropertyInfoPointer => (Il2CppPropertyInfo*)Pointer;

            private Il2CppPropertyInfo_24_1* NativeProperty => (Il2CppPropertyInfo_24_1*)Pointer;

            public ref IntPtr Name => ref NativeProperty->name;

            public ref Il2CppClass* Parent => ref NativeProperty->parent;

            public ref Il2CppMethodInfo* Get => ref NativeProperty->get;

            public ref Il2CppMethodInfo* Set => ref NativeProperty->set;

            public ref uint Attrs => ref NativeProperty->attrs;
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Type/Interfaces.cs`:

```cs
using System;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Type
{
    public interface INativeTypeStructHandler : INativeStructHandler
    {
        INativeTypeStruct CreateNewTypeStruct();
        unsafe INativeTypeStruct Wrap(Il2CppTypeStruct* typePointer);
#if DEBUG
        string GetName();
#endif
    }

    public interface INativeTypeStruct : INativeStruct
    {
        unsafe Il2CppTypeStruct* TypePointer { get; }

        ref IntPtr Data { get; }

        ref Il2CppTypeEnum Type { get; }

        bool ByRef { get; set; }

        bool Pinned { get; set; }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Type/Type_16_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Type
{
    [ApplicableToUnityVersionsSince("5.3.0")]
    public unsafe class NativeTypeStructHandler_16_0 : INativeTypeStructHandler
    {
        public INativeTypeStruct CreateNewTypeStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppType_16_0>());

            *(Il2CppType_16_0*)pointer = default;

            return new NativeTypeStruct(pointer);
        }

        public INativeTypeStruct Wrap(Il2CppTypeStruct* typePointer)
        {
            if ((IntPtr)typePointer == IntPtr.Zero) return null;
            else return new NativeTypeStruct((IntPtr)typePointer);
        }

#if DEBUG
        public string GetName() => "NativeTypeStructHandler_16_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppType_16_0
        {
            /*union
            {
                // We have this dummy field first because pre C99 compilers (MSVC) can only initializer the first value in a union.
                void* dummy;
                TypeDefinitionIndex klassIndex; /* for VALUETYPE and CLASS #1#
                const Il2CppType *type;   /* for PTR and SZARRAY #1#
                Il2CppArrayType *array; /* for ARRAY #1#
                //MonoMethodSignature *method;
                GenericParameterIndex genericParameterIndex; /* for VAR and MVAR #1#
                Il2CppGenericClass *generic_class; /* for GENERICINST #1#
            } data;*/
            public IntPtr data;

            public ushort attrs;
            public Il2CppTypeEnum type;
            public byte mods_byref_pin;
            /*unsigned int attrs    : 16; /* param attributes or field flags #1#
            Il2CppTypeEnum type     : 8;
            unsigned int num_mods : 6;  /* max 64 modifiers follow at the end #1#
            unsigned int byref    : 1;
            unsigned int pinned   : 1;  /* valid when included in a local var signature #1#*/
            //MonoCustomMod modifiers [MONO_ZERO_LEN_ARRAY]; /* this may grow */
        }

        private class NativeTypeStruct : INativeTypeStruct
        {
            public NativeTypeStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            private static int mods_byref_pin_offset =
                Marshal.OffsetOf<Il2CppType_16_0>(nameof(Il2CppType_16_0.mods_byref_pin)).ToInt32();

            public IntPtr Pointer { get; }

            public Il2CppTypeStruct* TypePointer => (Il2CppTypeStruct*)Pointer;

            private Il2CppType_16_0* NativeType => (Il2CppType_16_0*)Pointer;

            public ref IntPtr Data => ref NativeType->data;

            public ref Il2CppTypeEnum Type => ref NativeType->type;

            public bool ByRef
            {
                get => this.CheckBit(mods_byref_pin_offset, 6);
                set => this.SetBit(mods_byref_pin_offset, 6, value);
            }

            public bool Pinned
            {
                get => this.CheckBit(mods_byref_pin_offset, 7);
                set => this.SetBit(mods_byref_pin_offset, 7, value);
            }
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Type/Type_27_0.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Type
{
    [ApplicableToUnityVersionsSince("2020.2.0")]
    public unsafe class NativeTypeStructHandler_27_0 : INativeTypeStructHandler
    {
        public INativeTypeStruct CreateNewTypeStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppType_27_0>());

            *(Il2CppType_27_0*)pointer = default;

            return new NativeTypeStruct(pointer);
        }

        public INativeTypeStruct Wrap(Il2CppTypeStruct* typePointer)
        {
            if ((IntPtr)typePointer == IntPtr.Zero) return null;
            else return new NativeTypeStruct((IntPtr)typePointer);
        }

#if DEBUG
        public string GetName() => "NativeTypeStructHandler_27_0";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppType_27_0
        {
            /*union
            {
                // We have this dummy field first because pre C99 compilers (MSVC) can only initializer the first value in a union.
                void* dummy;
                TypeDefinitionIndex klassIndex; /* for VALUETYPE and CLASS #1#
                Il2CppMetadataTypeHandle typeHandle;
                const Il2CppType *type;   /* for PTR and SZARRAY #1#
                Il2CppArrayType *array; /* for ARRAY #1#
                //MonoMethodSignature *method;
                GenericParameterIndex genericParameterIndex; /* for VAR and MVAR #1#
                Il2CppMetadataGenericParameterHandle genericParameterHandle;
                Il2CppGenericClass *generic_class; /* for GENERICINST #1#
            } data;*/
            public IntPtr data;

            public ushort attrs;
            public Il2CppTypeEnum type;
            public byte mods_byref_pin;
            /*unsigned int attrs    : 16; /* param attributes or field flags #1#
            Il2CppTypeEnum type     : 8;
            unsigned int num_mods : 6;  /* max 64 modifiers follow at the end #1#
            unsigned int byref    : 1;
            unsigned int pinned   : 1;  /* valid when included in a local var signature #1#*/
            //MonoCustomMod modifiers [MONO_ZERO_LEN_ARRAY]; /* this may grow */
        }

        private class NativeTypeStruct : INativeTypeStruct
        {
            public NativeTypeStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            private static int mods_byref_pin_offset =
                Marshal.OffsetOf<Il2CppType_27_0>(nameof(Il2CppType_27_0.mods_byref_pin)).ToInt32();

            public IntPtr Pointer { get; }

            public Il2CppTypeStruct* TypePointer => (Il2CppTypeStruct*)Pointer;

            private Il2CppType_27_0* NativeType => (Il2CppType_27_0*)Pointer;

            public ref IntPtr Data => ref NativeType->data;

            public ref Il2CppTypeEnum Type => ref NativeType->type;

            public bool ByRef
            {
                get => this.CheckBit(mods_byref_pin_offset, 6);
                set => this.SetBit(mods_byref_pin_offset, 6, value);
            }

            public bool Pinned
            {
                get => this.CheckBit(mods_byref_pin_offset, 7);
                set => this.SetBit(mods_byref_pin_offset, 7, value);
            }
        }
    }
}

```

`UnhollowerBaseLib/Runtime/VersionSpecific/Type/Type_27_2.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace UnhollowerBaseLib.Runtime.VersionSpecific.Type
{
    [ApplicableToUnityVersionsSince("2021.1.0")]
    public unsafe class NativeTypeStructHandler_27_2 : INativeTypeStructHandler
    {
        public INativeTypeStruct CreateNewTypeStruct()
        {
            var pointer = Marshal.AllocHGlobal(Marshal.SizeOf<Il2CppType_27_2>());

            *(Il2CppType_27_2*)pointer = default;

            return new NativeTypeStruct(pointer);
        }

        public INativeTypeStruct Wrap(Il2CppTypeStruct* typePointer)
        {
            if ((IntPtr)typePointer == IntPtr.Zero) return null;
            else return new NativeTypeStruct((IntPtr)typePointer);
        }

#if DEBUG
        public string GetName() => "NativeTypeStructHandler_27_2";
#endif

        [StructLayout(LayoutKind.Sequential)]
        internal struct Il2CppType_27_2
        {
            /*union
            {
                // We have this dummy field first because pre C99 compilers (MSVC) can only initializer the first value in a union.
                void* dummy;
                TypeDefinitionIndex klassIndex; /* for VALUETYPE and CLASS #1#
                Il2CppMetadataTypeHandle typeHandle;
                const Il2CppType *type;   /* for PTR and SZARRAY #1#
                Il2CppArrayType *array; /* for ARRAY #1#
                //MonoMethodSignature *method;
                GenericParameterIndex genericParameterIndex; /* for VAR and MVAR #1#
                Il2CppMetadataGenericParameterHandle genericParameterHandle;
                Il2CppGenericClass *generic_class; /* for GENERICINST #1#
            } data;*/
            public IntPtr data;

            public ushort attrs;
            public Il2CppTypeEnum type;
            public byte mods_byref_pin;
            /*unsigned int attrs    : 16; /* param attributes or field flags #1#
            Il2CppTypeEnum type     : 8;
            unsigned int num_mods : 5;  /* max 32 modifiers follow at the end #1#
            unsigned int byref    : 1;
            unsigned int pinned   : 1;  /* valid when included in a local var signature #1#
            unsigned int valuetype : 1;*/
            //MonoCustomMod modifiers [MONO_ZERO_LEN_ARRAY]; /* this may grow */
        }

        private class NativeTypeStruct : INativeTypeStruct
        {
            public NativeTypeStruct(IntPtr pointer)
            {
                Pointer = pointer;
            }

            private static int mods_byref_pin_offset =
                Marshal.OffsetOf<Il2CppType_27_2>(nameof(Il2CppType_27_2.mods_byref_pin)).ToInt32();

            public IntPtr Pointer { get; }

            public Il2CppTypeStruct* TypePointer => (Il2CppTypeStruct*)Pointer;

            private Il2CppType_27_2* NativeType => (Il2CppType_27_2*)Pointer;

            public ref IntPtr Data => ref NativeType->data;

            public ref Il2CppTypeEnum Type => ref NativeType->type;

            public bool ByRef
            {
                get => this.CheckBit(mods_byref_pin_offset, 5);
                set => this.SetBit(mods_byref_pin_offset, 5, value);
            }

            public bool Pinned
            {
                get => this.CheckBit(mods_byref_pin_offset, 6);
                set => this.SetBit(mods_byref_pin_offset, 6, value);
            }
        }
    }
}

```

`UnhollowerBaseLib/RuntimeReflectionHelper.cs`:

```cs
using System;
using Il2CppSystem.Reflection;
using UnhollowerBaseLib;
using RuntimeTypeHandle = Il2CppSystem.RuntimeTypeHandle;
using Type = Il2CppSystem.Type;

namespace UnhollowerRuntimeLib
{
    public static class RuntimeReflectionHelper
    {
        public static IntPtr GetNestedTypeViaReflection(IntPtr enclosingClass, string nestedTypeName)
        {
            var reflectionType = Type.internal_from_handle(IL2CPP.il2cpp_class_get_type(enclosingClass));
            var nestedType = reflectionType.GetNestedType(nestedTypeName, BindingFlags.Public | BindingFlags.NonPublic);
            
            return nestedType != null ? IL2CPP.il2cpp_class_from_system_type(nestedType.Pointer) : IntPtr.Zero;
        }

        public static RuntimeTypeHandle GetRuntimeTypeHandle<T>()
        {
            return Il2CppType.Of<T>().TypeHandle;
        }
    }
}
```

`UnhollowerBaseLib/RuntimeSpecificsStore.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading;

namespace UnhollowerBaseLib
{
    public static class RuntimeSpecificsStore
    {
        private static readonly ReaderWriterLockSlim Lock = new ReaderWriterLockSlim();
        private static readonly Dictionary<IntPtr, bool> UsesWeakRefsStore = new Dictionary<IntPtr, bool>();
        private static readonly Dictionary<IntPtr, bool> WasInjectedStore = new Dictionary<IntPtr, bool>();

        public static bool ShouldUseWeakRefs(IntPtr nativeClass)
        {
            Lock.EnterReadLock();
            try
            {
                return UsesWeakRefsStore.TryGetValue(nativeClass, out var result) && result;
            }
            finally
            {
                Lock.ExitReadLock();
            }
        }
        
        public static bool IsInjected(IntPtr nativeClass)
        {
            Lock.EnterReadLock();
            try
            {
                return WasInjectedStore.TryGetValue(nativeClass, out var result) && result;
            }
            finally
            {
                Lock.ExitReadLock();
            }
        }

        public static void SetClassInfo(IntPtr nativeClass, bool useWeakRefs, bool wasInjected)
        {
            Lock.EnterWriteLock();
            try
            {
                UsesWeakRefsStore[nativeClass] = useWeakRefs;
                WasInjectedStore[nativeClass] = wasInjected;
            }
            finally
            {
                Lock.ExitWriteLock();
            }
        }
    }
}
```

`UnhollowerBaseLib/UnhollowerBaseLib.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net4.7.2;netstandard2.1</TargetFrameworks>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <LangVersion>latest</LangVersion>
        <Version>0.4.18.0</Version>
    </PropertyGroup>

    <ItemGroup>
        <Reference Include="Il2Cppmscorlib, Version=3.7.1.6, Culture=neutral, PublicKeyToken=null">
            <Private>false</Private>
            <HintPath>Libs\Il2Cppmscorlib.dll</HintPath>
        </Reference>
    </ItemGroup>

    <ItemGroup>
        <Folder Include="Libs" />
    </ItemGroup>

    <ItemGroup>
        <None Remove="Libs\Il2Cppmscorlib.dll" />
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Iced" Version="1.10.0" />
        <PackageReference Include="IsExternalInit" Version="1.0.0">
          <PrivateAssets>all</PrivateAssets>
          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>
</Project>

```

`UnhollowerBaseLib/UnhollowerUtils.cs`:

```cs
using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;

namespace UnhollowerBaseLib
{
    public class UnhollowerUtils
    {
        private static FieldInfo GetFieldInfoFromMethod(MethodBase method, string prefix)
        {
            var body = method.GetMethodBody();
            if (body == null) throw new ArgumentException("Target method may not be abstract");
            var methodModule = method.DeclaringType.Assembly.Modules.Single();
            foreach (var (opCode, opArg) in MiniIlParser.Decode(body.GetILAsByteArray()))
            {
                if (opCode != OpCodes.Ldsfld) continue;
                var fieldInfo = methodModule.ResolveField((int) opArg);
                if (fieldInfo?.FieldType != typeof(IntPtr) || !fieldInfo.Name.StartsWith(prefix)) continue;
                return fieldInfo;
            }
            return null;
        }

        public static FieldInfo GetIl2CppMethodInfoPointerFieldForGeneratedMethod(MethodBase method)
        {
            return GetFieldInfoFromMethod(method, "NativeMethodInfoPtr_");
        }

        public static FieldInfo GetIl2CppFieldInfoPointerFieldForGeneratedFieldAccessor(MethodBase method)
        {
            return GetFieldInfoFromMethod(method, "NativeFieldInfoPtr_");
        }
    }
}
```

`UnhollowerBaseLib/XrefScans/XrefInstance.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace UnhollowerRuntimeLib.XrefScans
{
    public readonly struct XrefInstance
    {
        public readonly XrefType Type;
        public readonly IntPtr Pointer;
        public readonly IntPtr FoundAt;

        public XrefInstance(XrefType type, IntPtr pointer, IntPtr foundAt)
        {
            Type = type;
            Pointer = pointer;
            FoundAt = foundAt;
        }

        internal XrefInstance RelativeToBase(long baseAddress)
        {
            return new XrefInstance(Type, (IntPtr) ((long) Pointer - baseAddress), (IntPtr) ((long) FoundAt - baseAddress));
        }

        public Il2CppSystem.Object ReadAsObject()
        {
            if (Type != XrefType.Global) throw new InvalidOperationException("Can't read non-global xref as object");

            var valueAtPointer = Marshal.ReadIntPtr(Pointer);
            if (valueAtPointer == IntPtr.Zero)
                return null;
            
            return new Il2CppSystem.Object(valueAtPointer);
        }

        public MethodBase TryResolve()
        {
            if (Type != XrefType.Method) throw new InvalidOperationException("Can't resolve non-method xrefs");

            return XrefScanMethodDb.TryResolvePointer(Pointer);
        }
    }
}
```

`UnhollowerBaseLib/XrefScans/XrefScanMetadataRuntimeUtil.cs`:

```cs
using System;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using UnhollowerBaseLib;
using UnhollowerBaseLib.Runtime;
using AppDomain = Il2CppSystem.AppDomain;
using BindingFlags = Il2CppSystem.Reflection.BindingFlags;

namespace UnhollowerRuntimeLib.XrefScans
{
    internal static class XrefScanMetadataRuntimeUtil
    {
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void InitMetadataForMethod(int metadataUsageToken);

        private static InitMetadataForMethod ourMetadataInitForMethodDelegate;
        private static IntPtr ourMetadataInitForMethodPointer;

        private static unsafe void FindMetadataInitForMethod()
        {
            var unityObjectCctor = AppDomain.CurrentDomain.GetAssemblies()
                .Single(it => it.GetSimpleName() == "UnityEngine.CoreModule").GetType("UnityEngine.Object")
                .GetConstructors(BindingFlags.Static | BindingFlags.NonPublic).Single();
            var nativeMethodInfo = UnityVersionHandler.GetMethodFromReflection(unityObjectCctor.Pointer);
            ourMetadataInitForMethodPointer = XrefScannerLowLevel.JumpTargets(*(IntPtr*) nativeMethodInfo).First();
            ourMetadataInitForMethodDelegate = Marshal.GetDelegateForFunctionPointer<InitMetadataForMethod>(ourMetadataInitForMethodPointer);
        }

        internal static unsafe bool CallMetadataInitForMethod(MethodBase method)
        {
            if (ourMetadataInitForMethodPointer == IntPtr.Zero)
                FindMetadataInitForMethod();

            var nativeMethodInfoObject = UnhollowerUtils.GetIl2CppMethodInfoPointerFieldForGeneratedMethod(method)?.GetValue(null);
            if (nativeMethodInfoObject == null) return false;
            var nativeMethodInfo = (IntPtr) nativeMethodInfoObject;
            var codeStart = *(IntPtr*) nativeMethodInfo;
            var firstCall = XrefScannerLowLevel.JumpTargets(codeStart).FirstOrDefault();
            if (firstCall != ourMetadataInitForMethodPointer || firstCall == IntPtr.Zero) return false;

            var tokenPointer = XrefScanUtilFinder.FindLastRcxReadAddressBeforeCallTo(codeStart, ourMetadataInitForMethodPointer);
            var initFlagPointer = XrefScanUtilFinder.FindByteWriteTargetRightAfterCallTo(codeStart, ourMetadataInitForMethodPointer);

            if (tokenPointer == IntPtr.Zero || initFlagPointer == IntPtr.Zero) return false;

            if (Marshal.ReadByte(initFlagPointer) == 0)
            {
                ourMetadataInitForMethodDelegate(Marshal.ReadInt32(tokenPointer));
                Marshal.WriteByte(initFlagPointer, 1);
            }

            return true;
        } 
    }
}
```

`UnhollowerBaseLib/XrefScans/XrefScanMethodDb.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using UnhollowerBaseLib;
using UnhollowerBaseLib.Attributes;
using UnhollowerBaseLib.Maps;

namespace UnhollowerRuntimeLib.XrefScans
{
    public static class XrefScanMethodDb
    {
        private static readonly MethodAddressToTokenMap MethodMap;
        private static readonly MethodXrefScanCache XrefScanCache;
        private static readonly long GameAssemblyBase;
        
        private static XrefScanMetadataRuntimeUtil.InitMetadataForMethod ourMetadataInitForMethodDelegate;

        static XrefScanMethodDb()
        {
            MethodMap = new MethodAddressToTokenMap(GeneratedDatabasesUtil.GetDatabasePath(MethodAddressToTokenMap.FileName));
            XrefScanCache = new MethodXrefScanCache(GeneratedDatabasesUtil.GetDatabasePath(MethodXrefScanCache.FileName));
            
            foreach (ProcessModule module in Process.GetCurrentProcess().Modules)
            {
                if (module.ModuleName == "GameAssembly.dll")
                {
                    GameAssemblyBase = (long) module.BaseAddress;
                    break;
                }
            }
        }

        public static MethodBase TryResolvePointer(IntPtr methodStart)
        {
            return MethodMap.Lookup((long) methodStart - GameAssemblyBase);
        }

        internal static IEnumerable<XrefInstance> ListUsers(CachedScanResultsAttribute attribute)
        {
            for (var i = attribute.RefRangeStart; i < attribute.RefRangeEnd; i++)
                yield return XrefScanCache.GetAt(i).AsXrefInstance(GameAssemblyBase);
        }

        internal static IEnumerable<XrefInstance> CachedXrefScan(CachedScanResultsAttribute attribute)
        {
            for (var i = attribute.XrefRangeStart; i < attribute.XrefRangeEnd; i++)
                yield return XrefScanCache.GetAt(i).AsXrefInstance(GameAssemblyBase);
        }
        
        internal static void CallMetadataInitForMethod(CachedScanResultsAttribute attribute)
        {
            if (attribute.MetadataInitFlagRva == 0 || attribute.MetadataInitTokenRva == 0)
                return;

            if (Marshal.ReadByte((IntPtr) (GameAssemblyBase + attribute.MetadataInitFlagRva)) != 0)
                return;

            if (ourMetadataInitForMethodDelegate == null)
                ourMetadataInitForMethodDelegate =
                    Marshal.GetDelegateForFunctionPointer<XrefScanMetadataRuntimeUtil.InitMetadataForMethod>(
                        (IntPtr) (GameAssemblyBase + XrefScanCache.Header.InitMethodMetadataRva));

            var token = Marshal.ReadInt32((IntPtr) (GameAssemblyBase + attribute.MetadataInitTokenRva));

            ourMetadataInitForMethodDelegate(token);
            
            Marshal.WriteByte((IntPtr) (GameAssemblyBase + attribute.MetadataInitFlagRva), 1);
        }

        [Obsolete("Type registration is no longer needed")]
        public static void RegisterType(Type type)
        {
        }

        [Obsolete("Type registration is no longer needed")]
        public static void RegisterType<T>()
        {
        }
    }
}
```

`UnhollowerBaseLib/XrefScans/XrefScanUtilFinder.cs`:

```cs
using System;
using Iced.Intel;

namespace UnhollowerRuntimeLib.XrefScans
{
    internal static class XrefScanUtilFinder
    {
        public static IntPtr FindLastRcxReadAddressBeforeCallTo(IntPtr codeStart, IntPtr callTarget)
        {
            var decoder = XrefScanner.DecoderForAddress(codeStart);
            IntPtr lastRcxRead = IntPtr.Zero;
            
            while (true)
            {
                decoder.Decode(out var instruction);
                if (decoder.LastError == DecoderError.NoMoreBytes) return IntPtr.Zero;

                if (instruction.FlowControl == FlowControl.Return)
                    return IntPtr.Zero;

                if (instruction.FlowControl == FlowControl.UnconditionalBranch)
                    continue;

                if (instruction.Mnemonic == Mnemonic.Int || instruction.Mnemonic == Mnemonic.Int1)
                    return IntPtr.Zero;

                if (instruction.Mnemonic == Mnemonic.Call)
                {
                    var target = ExtractTargetAddress(instruction);
                    if ((IntPtr) target == callTarget)
                        return lastRcxRead;
                }

                if (instruction.Mnemonic == Mnemonic.Mov)
                {
                    if (instruction.Op0Kind == OpKind.Register && instruction.Op0Register == Register.ECX && instruction.Op1Kind == OpKind.Memory && instruction.IsIPRelativeMemoryOperand)
                    {
                        var movTarget = (IntPtr) instruction.IPRelativeMemoryAddress;
                        if (instruction.MemorySize != MemorySize.UInt32 && instruction.MemorySize != MemorySize.Int32) 
                            continue;
                        
                        lastRcxRead = movTarget;
                    }
                }
            }
        }
        
        public static IntPtr FindByteWriteTargetRightAfterCallTo(IntPtr codeStart, IntPtr callTarget)
        {
            var decoder = XrefScanner.DecoderForAddress(codeStart);
            var seenCall = false;
            
            while (true)
            {
                decoder.Decode(out var instruction);
                if (decoder.LastError == DecoderError.NoMoreBytes) return IntPtr.Zero;

                if (instruction.FlowControl == FlowControl.Return)
                    return IntPtr.Zero;

                if (instruction.FlowControl == FlowControl.UnconditionalBranch)
                    continue;

                if (instruction.Mnemonic == Mnemonic.Int || instruction.Mnemonic == Mnemonic.Int1)
                    return IntPtr.Zero;

                if (instruction.Mnemonic == Mnemonic.Call)
                {
                    var target = ExtractTargetAddress(instruction);
                    if ((IntPtr) target == callTarget)
                        seenCall = true;
                }

                if (instruction.Mnemonic == Mnemonic.Mov && seenCall)
                {
                    if (instruction.Op0Kind == OpKind.Memory && (instruction.MemorySize == MemorySize.Int8 || instruction.MemorySize == MemorySize.UInt8))
                        return (IntPtr) instruction.IPRelativeMemoryAddress;
                }
            }
        }
        
        private static ulong ExtractTargetAddress(in Instruction instruction)
        {
            switch (instruction.Op0Kind)
            {
                case OpKind.NearBranch16:
                    return instruction.NearBranch16;
                case OpKind.NearBranch32:
                    return instruction.NearBranch32;
                case OpKind.NearBranch64:
                    return instruction.NearBranch64;
                case OpKind.FarBranch16:
                    return instruction.FarBranch16;
                case OpKind.FarBranch32:
                    return instruction.FarBranch32;
                default:
                    return 0;
            }
        }
    }
}
```

`UnhollowerBaseLib/XrefScans/XrefScanner.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using Iced.Intel;
using UnhollowerBaseLib;
using UnhollowerBaseLib.Attributes;
using Type = Il2CppSystem.Type;

namespace UnhollowerRuntimeLib.XrefScans
{
    public static class XrefScanner
    {
        public static unsafe IEnumerable<XrefInstance> XrefScan(MethodBase methodBase)
        {
            var fieldValue = UnhollowerUtils.GetIl2CppMethodInfoPointerFieldForGeneratedMethod(methodBase)?.GetValue(null);
            if (fieldValue == null) return Enumerable.Empty<XrefInstance>();
            
            var cachedAttribute = methodBase.GetCustomAttribute<CachedScanResultsAttribute>(false);
            if (cachedAttribute == null)
            {
                XrefScanMetadataRuntimeUtil.CallMetadataInitForMethod(methodBase);
                
                return XrefScanImpl(DecoderForAddress(*(IntPtr*) (IntPtr) fieldValue));
            }

            if (cachedAttribute.XrefRangeStart == cachedAttribute.XrefRangeEnd)
                return Enumerable.Empty<XrefInstance>();
            
            XrefScanMethodDb.CallMetadataInitForMethod(cachedAttribute);

            return XrefScanMethodDb.CachedXrefScan(cachedAttribute).Where(it => it.Type == XrefType.Method || XrefGlobalClassFilter(it.Pointer));
        }

        public static IEnumerable<XrefInstance> UsedBy(MethodBase methodBase)
        {
            var cachedAttribute = methodBase.GetCustomAttribute<CachedScanResultsAttribute>(false);
            if (cachedAttribute == null || cachedAttribute.RefRangeStart == cachedAttribute.RefRangeEnd)
                return Enumerable.Empty<XrefInstance>();

            return XrefScanMethodDb.ListUsers(cachedAttribute);
        }

        internal static unsafe Decoder DecoderForAddress(IntPtr codeStart, int lengthLimit = 1000)
        {
            if (codeStart == IntPtr.Zero) throw new NullReferenceException(nameof(codeStart));
            
            var stream = new UnmanagedMemoryStream((byte*) codeStart, lengthLimit, lengthLimit, FileAccess.Read);
            var codeReader = new StreamCodeReader(stream);
            var decoder = Decoder.Create(IntPtr.Size * 8, codeReader);
            decoder.IP = (ulong) codeStart;

            return decoder;
        }

        internal static IEnumerable<XrefInstance> XrefScanImpl(Decoder decoder, bool skipClassCheck = false)
        {
            while (true)
            {
                decoder.Decode(out var instruction);
                if (decoder.LastError == DecoderError.NoMoreBytes) yield break;

                if (instruction.FlowControl == FlowControl.Return)
                    yield break;

                if (instruction.Mnemonic == Mnemonic.Int || instruction.Mnemonic == Mnemonic.Int1)
                    yield break;

                if (instruction.Mnemonic == Mnemonic.Call || instruction.Mnemonic == Mnemonic.Jmp)
                {
                    var targetAddress = ExtractTargetAddress(instruction);
                    if (targetAddress != 0)
                        yield return new XrefInstance(XrefType.Method, (IntPtr) targetAddress, (IntPtr) instruction.IP);
                    continue;
                }
                
                if (instruction.FlowControl == FlowControl.UnconditionalBranch)
                    continue;

                if (IsMoveMnemonic(instruction.Mnemonic))
                {
                    XrefInstance? result = null;
                    try
                    {
                        if (instruction.Op1Kind == OpKind.Memory && instruction.IsIPRelativeMemoryOperand)
                        {
                            var movTarget = (IntPtr) instruction.IPRelativeMemoryAddress;
                            if (instruction.MemorySize != MemorySize.UInt64) 
                                continue;
                            
                            if (skipClassCheck || XrefGlobalClassFilter(movTarget))
                                result = new XrefInstance(XrefType.Global, movTarget, (IntPtr) instruction.IP);
                        }
                    }
                    catch (Exception ex)
                    {
                        LogSupport.Error(ex.ToString());
                    }

                    if (result != null)
                        yield return result.Value;
                }
            }
        }

        internal static bool XrefGlobalClassFilter(IntPtr movTarget)
        {
            var valueAtMov = (IntPtr) Marshal.ReadInt64(movTarget);
            if (valueAtMov != IntPtr.Zero)
            {
                var targetClass = (IntPtr) Marshal.ReadInt64(valueAtMov);
                return targetClass == Il2CppClassPointerStore<string>.NativeClassPtr ||
                       targetClass == Il2CppClassPointerStore<Type>.NativeClassPtr;
            }

            return false;
        }

        internal static bool IsMoveMnemonic(Mnemonic mnemonic)
        {
            return mnemonic is Mnemonic.Mov or >= Mnemonic.Cmova and <= Mnemonic.Cmovs;
        }

        internal static ulong ExtractTargetAddress(in Instruction instruction)
        {
            switch (instruction.Op0Kind)
            {
                case OpKind.NearBranch16:
                    return instruction.NearBranch16;
                case OpKind.NearBranch32:
                    return instruction.NearBranch32;
                case OpKind.NearBranch64:
                    return instruction.NearBranch64;
                case OpKind.FarBranch16:
                    return instruction.FarBranch16;
                case OpKind.FarBranch32:
                    return instruction.FarBranch32;
                default:
                    return 0;
            }
        }
    }
}
```

`UnhollowerBaseLib/XrefScans/XrefScannerLowLevel.cs`:

```cs
using System;
using System.Collections.Generic;
using Iced.Intel;
using Decoder = Iced.Intel.Decoder;

namespace UnhollowerRuntimeLib.XrefScans
{
    public static class XrefScannerLowLevel
    {
        public static IEnumerable<IntPtr> JumpTargets(IntPtr codeStart)
        {
            return JumpTargetsImpl(XrefScanner.DecoderForAddress(codeStart));
        }

        private static IEnumerable<IntPtr> JumpTargetsImpl(Decoder myDecoder)
        {
            while (true)
            {
                myDecoder.Decode(out var instruction);
                if (myDecoder.LastError == DecoderError.NoMoreBytes) yield break;
                if (instruction.FlowControl == FlowControl.Return)
                    yield break;

                if (instruction.FlowControl == FlowControl.UnconditionalBranch || instruction.FlowControl == FlowControl.Call)
                {
                    yield return (IntPtr) ExtractTargetAddress(in instruction);
                    if(instruction.FlowControl == FlowControl.UnconditionalBranch) yield break;
                }
            }
        }

        public static IEnumerable<IntPtr> CallAndIndirectTargets(IntPtr pointer) => CallAndIndirectTargetsImpl(XrefScanner.DecoderForAddress(pointer, 1024 * 1024));

        private static IEnumerable<IntPtr> CallAndIndirectTargetsImpl(Decoder decoder)
        {
            while (true)
            {
                decoder.Decode(out var instruction);
                if (decoder.LastError == DecoderError.NoMoreBytes) yield break;

                if (instruction.FlowControl == FlowControl.Return)
                    yield break;

                if (instruction.Mnemonic == Mnemonic.Int || instruction.Mnemonic == Mnemonic.Int1)
                    yield break;

                if (instruction.Mnemonic == Mnemonic.Call || instruction.Mnemonic == Mnemonic.Jmp)
                {
                    var targetAddress = XrefScanner.ExtractTargetAddress(instruction);
                    if (targetAddress != 0)
                        yield return (IntPtr) targetAddress;
                    continue;
                }

                if (instruction.Mnemonic == Mnemonic.Lea)
                {
                    if (instruction.MemoryBase == Register.RIP)
                    {
                        var targetAddress = instruction.IPRelativeMemoryAddress;
                        if (targetAddress != 0)
                            yield return (IntPtr) targetAddress;
                    }
                }
            }
        }

        private static ulong ExtractTargetAddress(in Instruction instruction)
        {
            switch (instruction.Op0Kind)
            {
                case OpKind.NearBranch16:
                    return instruction.NearBranch16;
                case OpKind.NearBranch32:
                    return instruction.NearBranch32;
                case OpKind.NearBranch64:
                    return instruction.NearBranch64;
                case OpKind.FarBranch16:
                    return instruction.FarBranch16;
                case OpKind.FarBranch32:
                    return instruction.FarBranch32;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
}
```

`UnhollowerBaseLib/XrefScans/XrefType.cs`:

```cs
namespace UnhollowerRuntimeLib.XrefScans
{
    public enum XrefType
    {
        Global,
        Method,
    }
}
```

`UnhollowerPdbGen/MethodAddressToTokenMapCecil.cs`:

```cs
using System.IO;
using Mono.Cecil;
using UnhollowerBaseLib.Maps;

#nullable enable

namespace UnhollowerPdbGen
{
    public class MethodAddressToTokenMapCecil : MethodAddressToTokenMapBase<AssemblyDefinition, MethodDefinition>
    {
        public MethodAddressToTokenMapCecil(string filePath) : base(filePath)
        {
        }

        protected override AssemblyDefinition? LoadAssembly(string assemblyName)
        {
            var filesDirt = Path.GetDirectoryName(myFilePath)!;
            assemblyName = assemblyName.Substring(0, assemblyName.IndexOf(','));
            return AssemblyDefinition.ReadAssembly(Path.Combine(filesDirt, assemblyName + ".dll"));
        }

        protected override MethodDefinition? ResolveMethod(AssemblyDefinition? assembly, int token)
        {
            return (MethodDefinition?) assembly?.MainModule.LookupToken(token);
        }
    }
}
```

`UnhollowerPdbGen/MsPdbCore.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Text;

// Source/reference: https://github.com/microsoft/microsoft-pdb, MIT license
namespace UnhollowerPdbGen
{
    enum PDBErrors: int {
        EC_OK,                          // no problem
        EC_USAGE,                       // invalid parameter or call order
        EC_OUT_OF_MEMORY,               // out of heap
        EC_FILE_SYSTEM,                 // "pdb name", can't write file, out of disk, etc.
        EC_NOT_FOUND,                   // "pdb name", PDB file not found
        EC_INVALID_SIG,                 // "pdb name", PDB::OpenValidate() and its clients only
        EC_INVALID_AGE,                 // "pdb name", PDB::OpenValidate() and its clients only
        EC_PRECOMP_REQUIRED,            // "obj name", Mod::AddTypes() only
        EC_OUT_OF_TI,                   // "pdb name", TPI::QueryTiForCVRecord() only
        EC_NOT_IMPLEMENTED,             // -
        EC_V1_PDB,                      // "pdb name", PDB::Open* only (obsolete)
        EC_UNKNOWN_FORMAT = EC_V1_PDB,  // pdb can't be opened because it has newer versions of stuff
        EC_FORMAT,                      // accessing pdb with obsolete format
        EC_LIMIT,
        EC_CORRUPT,                     // cv info corrupt, recompile mod
        EC_TI16,                        // no 16-bit type interface present
        EC_ACCESS_DENIED,               // "pdb name", PDB file read-only
        EC_ILLEGAL_TYPE_EDIT,           // trying to edit types in read-only mode
        EC_INVALID_EXECUTABLE,          // not recogized as a valid executable
        EC_DBG_NOT_FOUND,               // A required .DBG file was not found
        EC_NO_DEBUG_INFO,               // No recognized debug info found
        EC_INVALID_EXE_TIMESTAMP,       // Invalid timestamp on Openvalidate of exe
        EC_CORRUPT_TYPEPOOL,            // A corrupted type record was found in a PDB
        EC_DEBUG_INFO_NOT_IN_PDB,       // returned by OpenValidateX
        EC_RPC,                         // Error occured during RPC
        EC_UNKNOWN,                     // Unknown error
        EC_BAD_CACHE_PATH,              // bad cache location specified with symsrv
        EC_CACHE_FULL,                  // symsrv cache is full
        EC_TOO_MANY_MOD_ADDTYPE,        // Addtype is called more then once per mod
        EC_MAX
    }
    
    [Flags]
    enum CV_PUBSYMFLAGS_e: int
    {
        cvpsfNone     = 0,
        cvpsfCode     = 0x00000001,
        cvpsfFunction = 0x00000002,
        cvpsfManaged  = 0x00000004,
        cvpsfMSIL     = 0x00000008,
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct PdbPtr
    {
        public IntPtr InnerPtr;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct DbiPtr
    {
        public IntPtr InnerPtr;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct ModPtr
    {
        public IntPtr InnerPtr;
    }
    
    public static unsafe class MsPdbCore
    {
        private const string dllName = "mspdbcore.dll";
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool PDBOpen2W(char* wszPDB, byte* szMode, out PDBErrors pec, char* wszError, nuint cchErrMax, out PdbPtr pppdb);

        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool PDBCommit(PdbPtr ppdb);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool PDBOpenDBI(PdbPtr ppdb, byte* szMode, byte* szTarget, out DbiPtr ppdbi);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool DBIOpenModW(DbiPtr pdbi, char* szModule, char* szFile, out ModPtr ppmod);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool DBIAddPublic2(DbiPtr pdbi, byte* szPublic, ushort isect, int off, CV_PUBSYMFLAGS_e cvpsf=0);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool ModAddPublic2(ModPtr pmod, byte* szPublic, ushort isect, int off, CV_PUBSYMFLAGS_e cvpsf=0);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool DBIAddSec(DbiPtr pdbi, ushort isect, ushort flags, int off, int cb);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool ModClose(ModPtr ppdb);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool DBIClose(DbiPtr ppdb);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool PDBClose(PdbPtr ppdb);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool PDBQuerySignature2(PdbPtr ppdb, out Guid guid);
        
        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern uint PDBQueryAge(PdbPtr ppdb);


        internal static bool PDBOpen2W(string wszPDB, string szMode, out PDBErrors pec, out string error, out PdbPtr pppdb)
        {
            wszPDB += '\0';
            szMode += '\0';

            var chars = wszPDB.ToCharArray();
            var bytes = Encoding.UTF8.GetBytes(szMode);
            var errorChars = new char[2048];
            bool result = false;
            
            fixed(char* cp = chars)
            fixed(byte* bp = bytes)
            fixed (char* ep = errorChars)
                result = PDBOpen2W(cp, bp, out pec, ep, (nuint) errorChars.Length, out pppdb);

            var firstZero = Array.IndexOf(errorChars, '\0');
            error = new string(errorChars, 0, firstZero);

            return result;
        }

        internal static bool PDBOpenDBI(PdbPtr ppdb, string szMode, string szTarget, out DbiPtr ppdbi)
        {
            szMode += '\0';
            szTarget += '\0';
            
            fixed(byte* mb = Encoding.UTF8.GetBytes(szMode))
            fixed (byte* tb = Encoding.UTF8.GetBytes(szTarget))
                return PDBOpenDBI(ppdb, mb, tb, out ppdbi);
        }

        internal static bool DBIOpenModW(DbiPtr pdbi, string szModule, string szFile, out ModPtr ppmod)
        {
            szFile += '\0';
            szModule += '\0';
            
            fixed(char* fp = szFile)
            fixed (char* mp = szModule)
                return DBIOpenModW(pdbi, mp, fp, out ppmod);
        }

        internal static bool ModAddPublic2(ModPtr pmod, string szPublic, ushort isect, int off, CV_PUBSYMFLAGS_e cvpsf = 0)
        {
            szPublic += '\0';
            fixed (byte* mb = Encoding.UTF8.GetBytes(szPublic))
                return ModAddPublic2(pmod, mb, isect, off, cvpsf);
        }
    }
}
```

`UnhollowerPdbGen/PdbGenMain.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection.PortableExecutable;

namespace UnhollowerPdbGen
{
    public class PdbGenMain
    {
        public static void Main(string[] args)
        {
            if (args.Length <= 1)
            {
                Console.WriteLine($"Usage: UnhollowerPdbGen.exe <path to GameAssembly.dll> <path to {MethodAddressToTokenMapCecil.FileName}>");
            }
            var rootPath = Path.GetDirectoryName(args[0])!;
            var map = new MethodAddressToTokenMapCecil(args[1]);

            using var peStream = new FileStream(args[0], FileMode.Open, FileAccess.Read);
            using var peReader = new PEReader(peStream);


            string openError;
            PDBErrors err;
            var pdbFilePath = Path.Combine(rootPath, "GameAssembly.pdb");
            MsPdbCore.PDBOpen2W(pdbFilePath, "w", out err, out openError, out var pdb);

            MsPdbCore.PDBOpenDBI(pdb, "w", "", out var dbi);

            MsPdbCore.DBIOpenModW(dbi, "__Globals", "__Globals", out var mod);

            ushort secNum = 1;
            ushort i2cs = 1;
            foreach (var sectionHeader in peReader.PEHeaders.SectionHeaders)
            {
                if (sectionHeader.Name == "il2cpp") i2cs = secNum;
                MsPdbCore.DBIAddSec(dbi, secNum++, 0 /* TODO? */, sectionHeader.VirtualAddress, sectionHeader.VirtualSize);
            }
            
            foreach (var valueTuple in map)
            {
                ushort targetSect = 0;
                long tsva = 0;
                ushort sc = 1;
                foreach (var sectionHeader in peReader.PEHeaders.SectionHeaders)
                {
                    if (valueTuple.Item1 > sectionHeader.VirtualAddress)
                    {
                        targetSect = sc;
                        tsva = sectionHeader.VirtualAddress;
                    }
                    else
                        break;

                    sc++;
                }

                if (targetSect == 0) throw new ApplicationException("Bad segment");
                MsPdbCore.ModAddPublic2(mod, valueTuple.Item2.FullName, targetSect, (int)(valueTuple.Item1 - tsva * 2), CV_PUBSYMFLAGS_e.cvpsfFunction);
            }
            
            MsPdbCore.ModClose(mod);
            MsPdbCore.DBIClose(dbi);

            MsPdbCore.PDBCommit(pdb);
            
            MsPdbCore.PDBQuerySignature2(pdb, out var wrongGuid);
            
            MsPdbCore.PDBClose(pdb);
            
            // Hack: manually replace guid and age in generated .pdb, because there's no API on mspdbcore to set them manually
            var targetDebugInfo = peReader.ReadCodeViewDebugDirectoryData(peReader.ReadDebugDirectory()
                .Single(it => it.Type == DebugDirectoryEntryType.CodeView));

            var wrongGuidBytes = wrongGuid.ToByteArray();
            var allPdbBytes = File.ReadAllBytes(pdbFilePath);

            var patchTarget = IndexOfBytes(allPdbBytes, wrongGuidBytes);
            targetDebugInfo.Guid.TryWriteBytes(allPdbBytes.AsSpan(patchTarget));
            
            Console.WriteLine(targetDebugInfo.Guid);
            Console.WriteLine(targetDebugInfo.Age);

            BitConverter.TryWriteBytes(allPdbBytes.AsSpan(patchTarget - 4), targetDebugInfo.Age);
            File.WriteAllBytes(pdbFilePath, allPdbBytes);
        }

        private static int IndexOfBytes(byte[] haystack, byte[] needle)
        {
            for (var i = 0; i < haystack.Length - needle.Length; i++)
            {
                for (var j = 0; j < needle.Length; j++)
                {
                    if (haystack[i + j] != needle[j])
                        goto moveOn;
                }

                return i;
                moveOn: ;
            }

            return -1;
        }
    }
}
```

`UnhollowerPdbGen/UnhollowerPdbGen.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net5.0</TargetFramework>
        <OutputType>Exe</OutputType>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <LangVersion>latest</LangVersion>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Mono.Cecil" Version="0.11.3" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\UnhollowerBaseLib\UnhollowerBaseLib.csproj" />
    </ItemGroup>

</Project>

```

`UnhollowerRuntimeLib/Forwarders.cs`:

```cs
using System.Runtime.CompilerServices;
using UnhollowerRuntimeLib;
using UnhollowerRuntimeLib.XrefScans;

#pragma warning disable CS0618

[assembly:TypeForwardedTo(typeof(Il2CppType))]
[assembly:TypeForwardedTo(typeof(Il2CppTypeOf<>))]
[assembly:TypeForwardedTo(typeof(RuntimeReflectionHelper))]
[assembly:TypeForwardedTo(typeof(ClassInjector))]
[assembly:TypeForwardedTo(typeof(DelegateSupport))]
[assembly:TypeForwardedTo(typeof(XrefInstance))]
[assembly:TypeForwardedTo(typeof(XrefScanner))]
[assembly:TypeForwardedTo(typeof(XrefScanMethodDb))]
[assembly:TypeForwardedTo(typeof(XrefScannerLowLevel))]
[assembly:TypeForwardedTo(typeof(XrefType))]

namespace UnhollowerRuntimeLib
{
    public static class RuntimeLibMarker
    {
    }
}
```

`UnhollowerRuntimeLib/UnhollowerRuntimeLib.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net4.7.2;netstandard2.1</TargetFrameworks>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <LangVersion>latest</LangVersion>
        <Version>0.4.10.0</Version>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\UnhollowerBaseLib\UnhollowerBaseLib.csproj" />
    </ItemGroup>
</Project>

```