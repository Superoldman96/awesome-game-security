Project Path: arc_gmh5225_drvtrace_0ojg6f8k

Source Tree:

```txt
arc_gmh5225_drvtrace_0ojg6f8k
├── DriverTrace.sln
├── DriverTrace.vcxproj
├── DriverTrace.vcxproj.filters
├── DriverTrace.vcxproj.user
├── README.md
├── framework.h
├── pch.cpp
├── pch.h
├── tracedrv.cpp
├── utils.cpp
└── utils.h

```

`DriverTrace.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36717.8 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DriverTrace", "DriverTrace.vcxproj", "{35CA47C7-FB28-408B-9EC6-44560665B5E1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{35CA47C7-FB28-408B-9EC6-44560665B5E1}.Debug|x64.ActiveCfg = Debug|x64
		{35CA47C7-FB28-408B-9EC6-44560665B5E1}.Debug|x64.Build.0 = Debug|x64
		{35CA47C7-FB28-408B-9EC6-44560665B5E1}.Debug|x86.ActiveCfg = Debug|Win32
		{35CA47C7-FB28-408B-9EC6-44560665B5E1}.Debug|x86.Build.0 = Debug|Win32
		{35CA47C7-FB28-408B-9EC6-44560665B5E1}.Release|x64.ActiveCfg = Release|x64
		{35CA47C7-FB28-408B-9EC6-44560665B5E1}.Release|x64.Build.0 = Release|x64
		{35CA47C7-FB28-408B-9EC6-44560665B5E1}.Release|x86.ActiveCfg = Release|Win32
		{35CA47C7-FB28-408B-9EC6-44560665B5E1}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E0108C63-BC73-47E5-9364-C249D8ACECD7}
	EndGlobalSection
EndGlobal

```

`DriverTrace.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{35ca47c7-fb28-408b-9ec6-44560665b5e1}</ProjectGuid>
    <RootNamespace>DriverTrace</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DRIVERTRACE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DRIVERTRACE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DRIVERTRACE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>C:\Program Files (x86)\Windows Kits\10\Debuggers\inc</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>$(CoreLibraryDependencies);%(AdditionalDependencies);dbgeng.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>C:\Program Files (x86)\Windows Kits\10\Debuggers\lib\x64</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;DRIVERTRACE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="framework.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="tracedrv.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DriverTrace.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="tracedrv.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`DriverTrace.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`README.md`:

```md
# tracedrv

Tiny WinDbg extension to trace transitions from a debugged driver into other modules (i.e. to trace function calls).

## Usage 

```windbg
!tracedrv 4000 # trace for 4000 instructions
```

<img width="589" height="389" alt="image" src="https://github.com/user-attachments/assets/320e6d77-3a36-48c8-9e32-bac0c9407a90" />

```

`framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>

```

`pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#include "framework.h"
#include <windows.h>
#include <wdbgexts.h>
#include <dbgeng.h>

// Standard library headers
#include <cstdio>
#include <cstring>
#include <map>
#include <vector>
#include <string>
#include <memory>

// WinDbg extension specific
#include <engextcpp.hpp>

#endif //PCH_H

```

`tracedrv.cpp`:

```cpp
#include "pch.h"
#include "utils.h"
#include <string>

utils::DebugInterfaces g_debug;
std::string g_mainModule;

// Return the module name for the given instruction pointer. Empty string if unknown.
static std::string GetModuleForIp(ULONG64 ip) {
    char modName[260]{};
    ULONG64 base{};
    if (SUCCEEDED(g_debug.symbols->GetModuleByOffset(ip, 0, nullptr, &base))) {
        // Only request the module name; all other buffers/sizes are null/zero.
        if (SUCCEEDED(g_debug.symbols->GetModuleNames(
                DEBUG_ANY_ID,
                base,
                nullptr, 0, nullptr,          // ImageNameBuffer / Size / SizeOut
                modName, sizeof(modName), nullptr, // ModuleNameBuffer / Size / SizeOut
                nullptr, 0, nullptr))) {      // LoadedImageNameBuffer / Size / SizeOut
            return std::string(modName);
        }
    }
    return std::string();
}

HRESULT CALLBACK DebugExtensionInitializeInternal(PULONG version, PULONG flags) {
    *version = DEBUG_EXTENSION_VERSION(1, 0);
    *flags = 0;
    return utils::InitializeDebugInterfaces(&g_debug);
}

HRESULT CALLBACK DebugExtensionUninitializeInternal() {
    return utils::UninitializeDebugInterfaces(&g_debug);
}

static bool WaitForBreak(ULONG timeoutMs = INFINITE) {
    return SUCCEEDED(g_debug.control->WaitForEvent(DEBUG_WAIT_DEFAULT, timeoutMs));
}

static bool StepInto() {
    if (FAILED(g_debug.control->SetExecutionStatus(DEBUG_STATUS_STEP_INTO))) {
        return false;
    }
    return WaitForBreak();
}

static bool StepOut() {
    if (FAILED(g_debug.control->Execute(DEBUG_OUTCTL_THIS_CLIENT, "gu", DEBUG_EXECUTE_NOT_LOGGED))) {
        return false;
    }
    return WaitForBreak();
}

static std::string GetNearestSymbolForIp(ULONG64 ip) {
    char name[1024];
    ULONG64 displacement = 0;

    HRESULT hr = g_debug.symbols->GetNameByOffset(
        ip,
        name,
        sizeof(name),
        nullptr,
        &displacement);

    if (FAILED(hr)) return std::string();

    // name is already the nearest symbol; displacement is the byte delta.
    if (displacement == 0) {
        return std::string(name);
    }

    char out[1200];
    _snprintf_s(out, sizeof(out), "%s+0x%llx", name, displacement);
    return std::string(out);
}

HRESULT CALLBACK TracedrvInternal(IDebugClient* client, const char* args) {
    if (!args || !*args) return E_INVALIDARG;

    int count = atoi(args);
    if (count <= 0) return E_INVALIDARG;

    //
    // Current module is the module of interest
    //
    ULONG64 ip{};
    g_debug.registers->GetInstructionOffset(&ip);
	g_mainModule = GetModuleForIp(ip);

	DOUT("Tracing from module: %s for %d steps\n", g_mainModule.c_str(), count);

    std::string mod = g_mainModule;
    ULONG64 lastip;

    //
	// Step for the specified amount of times
    //
    for (int i = 0; i < count; i++) 
    {
        lastip = ip;

        //
        // Single step
        //
        StepInto();

        //
        // End trace if we have exited the main module
        //
        if (mod != g_mainModule)
        {
			DOUT("Exit module: %s. Finishing trace\n", mod.c_str());
            return S_OK;
        }

        g_debug.registers->GetInstructionOffset(&ip);
        mod = GetModuleForIp(ip);
        
        //
        // Check for module transition
        //
		if (!mod.empty() && mod != g_mainModule) {
            DOUT("%p -> %s\n", lastip, GetNearestSymbolForIp(ip).c_str());
            //
            // Step out of the function to get back to the main module
            //
            StepOut();

            g_debug.registers->GetInstructionOffset(&ip);
            mod = GetModuleForIp(ip);
        }
        else {
            //DOUT("[%p] %s\n", (void*)ip, mod.c_str());
        }
    }

    return S_OK;
}

extern "C" {
    __declspec(dllexport) HRESULT CALLBACK DebugExtensionInitialize(PULONG version, PULONG flags) {
        return DebugExtensionInitializeInternal(version, flags);
    }

    __declspec(dllexport) HRESULT CALLBACK DebugExtensionUninitialize(void) {
        return DebugExtensionUninitializeInternal();
    }

    __declspec(dllexport) HRESULT CALLBACK tracedrv(IDebugClient* client, const char* args) {
        return TracedrvInternal(client, args);
    }
}


```

`utils.cpp`:

```cpp
// Copyright (c) 2025 Piet Hein Schouten
// SPDX-License-Identifier: MIT

#include "pch.h"
#include "utils.h"

#include <algorithm>
#include <filesystem>

namespace utils {

    namespace {

        class CommandOutputCapture : public IDebugOutputCallbacks {
        public:
            CommandOutputCapture() : m_ref_count(1), m_capturing(false) {}

            // IUnknown methods
            STDMETHOD(QueryInterface)(REFIID InterfaceId, PVOID* Interface) {
                *Interface = nullptr;
                if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
                    IsEqualIID(InterfaceId, __uuidof(IDebugOutputCallbacks))) {
                    *Interface = (IDebugOutputCallbacks*)this;
                    AddRef();
                    return S_OK;
                }
                return E_NOINTERFACE;
            }

            STDMETHOD_(ULONG, AddRef)() { return InterlockedIncrement(&m_ref_count); }

            STDMETHOD_(ULONG, Release)() {
                LONG ret = InterlockedDecrement(&m_ref_count);
                if (ret == 0) {
                    delete this;
                }
                return ret;
            }

            // IDebugOutputCallbacks method
            STDMETHOD(Output)(ULONG mask, PCSTR text) {
                if (m_capturing && text) {
                    m_output += text;
                }
                return S_OK;
            }

            void StartCapture() {
                m_capturing = true;
                m_output.clear();
            }

            void StopCapture() { m_capturing = false; }

            std::string GetOutput() const { return m_output; }

        private:
            LONG m_ref_count;
            bool m_capturing;
            std::string m_output;
        };

        // Wait for the debugger status to indicate a break.
        // This method will time out after 20 seconds.
        // If an error occurs while waiting or retrieving the status
        // then the method will return early.
        void WaitForBreakStatus(const DebugInterfaces* interfaces) {
            HRESULT hr;
            ULONG status;
            int retries = 0;

            while (true) {
                hr = interfaces->control->GetExecutionStatus(&status);
                if (FAILED(hr) && retries < 10) {
                    Sleep(100);
                }
                else {
                    break;
                }
                retries++;
            }

            if (FAILED(hr)) {
                return;
            }

            if (status == DEBUG_STATUS_BREAK) {
                return;
            }

            if (status == DEBUG_STATUS_GO || status == DEBUG_STATUS_GO_HANDLED ||
                status == DEBUG_STATUS_GO_NOT_HANDLED ||
                status == DEBUG_STATUS_STEP_INTO || status == DEBUG_STATUS_STEP_OVER ||
                status == DEBUG_STATUS_STEP_BRANCH) {
                // Wait for a total of 20 seconds for the target to break
                hr = interfaces->control->WaitForEvent(DEBUG_WAIT_DEFAULT, 20000);
                if (FAILED(hr)) {
                    return;
                }
            }
        }

    }  // namespace

    std::string Trim(const std::string& str) {
        size_t start = str.find_first_not_of(" \t\n\r\f\v");
        size_t end = str.find_last_not_of(" \t\n\r\f\v");
        return (start == std::string::npos) ? "" : str.substr(start, end - start + 1);
    }

    bool ContainsCI(const std::string& string, const std::string& substr) {
        auto it = std::search(
            string.begin(), string.end(), substr.begin(), substr.end(),
            [](char a, char b) { return std::tolower(a) == std::tolower(b); });
        return it != string.end();
    }

    bool IsWholeNumber(const std::string& input_str) {
        if (input_str.empty()) {
            return false;
        }
        return std::all_of(input_str.begin(), input_str.end(), ::isdigit);
    }

    std::string RemoveFileExtension(const std::string& filename) {
        // Find the last dot in the filename
        size_t last_dot = filename.find_last_of(".");

        // If no dot is found or it's at the beginning of the string
        // (hidden file in Unix), return the original string
        if (last_dot == std::string::npos || last_dot == 0) {
            return filename;
        }

        // Check if there's a directory separator after the last dot
        // If so, this is not an extension but part of a directory name
        size_t last_separator = filename.find_last_of("/\\");
        if (last_separator != std::string::npos && last_separator > last_dot) {
            return filename;
        }

        // Return the substring before the last dot
        return filename.substr(0, last_dot);
    }

    std::string EscapeQuotes(const std::string& input) {
        std::string escaped;
        size_t backslash_count = 0;

        for (size_t i = 0; i < input.length(); ++i) {
            if (input[i] == '\\') {
                // Count consecutive backslashes
                backslash_count++;
                escaped += '\\';
            }
            else if (input[i] == '"') {
                // If even number of backslashes (including 0), the quote is not escaped
                if (backslash_count % 2 == 0) {
                    escaped += "\\\"";
                }
                else {
                    // Odd number of backslashes means the quote is already escaped
                    escaped += '"';
                }
                backslash_count = 0;  // Reset after encountering a quote
            }
            else {
                // Any other character resets the backslash count
                backslash_count = 0;
                escaped += input[i];
            }
        }
        return escaped;
    }

    std::string GetCurrentExtensionDir() {
        HMODULE hModule = NULL;

        // Get the handle to the current DLL
        BOOL result = GetModuleHandleExA(
            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
            GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
            (LPCSTR)&GetCurrentExtensionDir,  // Use the address of this function as a
            // reference point
            &hModule);

        if (!result || hModule == NULL) {
            // Fallback if we couldn't get the module handle
            return "";
        }

        char buffer[MAX_PATH] = { 0 };
        GetModuleFileNameA(hModule, buffer, MAX_PATH);
        std::string path(buffer);
        size_t last_slash = path.find_last_of("\\");
        if (last_slash != std::string::npos) {
            return path.substr(0, last_slash);
        }
        return "";
    }

    std::vector<std::string> SplitString(const std::string& input,
        const std::string& delimiter,
        bool combine_consecutive_delimiters) {
        std::vector<std::string> tokens;
        if (input.empty()) {
            return tokens;
        }

        size_t start = 0;
        size_t end = input.find(delimiter);

        while (end != std::string::npos) {
            if (!combine_consecutive_delimiters || end > start) {
                tokens.push_back(input.substr(start, end - start));
            }
            start = end + delimiter.length();
            end = input.find(delimiter, start);
        }

        // Add the last token
        if (start < input.length()) {
            tokens.push_back(input.substr(start));
        }

        return tokens;
    }

    std::vector<size_t> GetIndicesFromString(const std::string& input_str) {
        std::vector<size_t> indices;
        std::vector<std::string> tokens;

        // First split by spaces
        std::vector<std::string> space_tokens =
            utils::SplitString(utils::Trim(input_str), " ");

        for (const auto& token : space_tokens) {
            // Check if token contains a range (has a hyphen)
            if (token.find('-') != std::string::npos) {
                std::vector<std::string> range_parts = utils::SplitString(token, "-");
                if (range_parts.size() == 2) {
                    int start = std::stoi(range_parts[0]);
                    int end = std::stoi(range_parts[1]);

                    // Handle both ascending and descending ranges
                    if (start <= end) {
                        for (int i = start; i <= end; i++) {
                            indices.push_back(i);
                        }
                    }
                    else {
                        for (int i = start; i >= end; i--) {
                            indices.push_back(i);
                        }
                    }
                }
                else {
                    // Invalid range format
                    continue;
                }
            }
            else {
                // Regular number
                indices.push_back(std::stoi(token));
            }
        }

        // Sort and remove duplicates
        std::sort(indices.begin(), indices.end());
        indices.erase(std::unique(indices.begin(), indices.end()), indices.end());
        return indices;
    }

    bool ParseNumberOrDottedPair(const std::string& input,
        size_t& first_number,
        std::optional<size_t>& second_number) {
        second_number.reset();

        if (input.empty()) {
            return false;
        }

        size_t dot_pos = input.find('.');
        bool has_dot = (dot_pos != std::string::npos);

        if (has_dot) {
            // Format: "number1.number2"
            std::string first_part = input.substr(0, dot_pos);
            std::string second_part = input.substr(dot_pos + 1);

            if (IsWholeNumber(first_part) && IsWholeNumber(second_part)) {
                first_number = std::stoul(first_part);
                second_number = std::stoul(second_part);
                return true;
            }
        }
        else {
            // Single number format
            if (IsWholeNumber(input)) {
                first_number = std::stoul(input);
                return true;
            }
        }

        return false;
    }

    std::vector<std::string> ParseCommandLine(const char* cmd_line) {
        std::vector<std::string> args;
        if (!cmd_line || !*cmd_line) {
            return args;
        }

        bool in_single_quotes = false;
        std::string current_arg;

        for (const char* p = cmd_line; *p; p++) {
            if (*p == '\\') {
                // Count consecutive backslashes
                int backslash_count = 0;
                while (p[backslash_count] == '\\') {
                    backslash_count++;
                }

                // Check what follows the backslashes
                if (p[backslash_count] == '\'') {
                    // Any backslashes beyond 3 are
                    // treated as regular backslashes
                    while (backslash_count >= 4) {
                        current_arg += '\\';
                        backslash_count--;
                        p++;
                    }

                    if (backslash_count == 1) {
                        // p = \'
                        // One backslash followed by a quote escapes
                        // the quote so insert a single quote.
                        current_arg += '\'';
                        p++;  // Move the pointer to the quote character
                    }
                    else if (backslash_count == 2) {
                        // p = \\'
                        // The first backslash escapes the second backslash and
                        // the quote should be seen as an arg delimiter like normal.
                        current_arg += "\\";
                        // Only move the pointer forward by one backslash so that
                        // the quote is processed normally on the next iteration.
                        p++;
                    }
                    else if (backslash_count == 3) {
                        // p = \\\'
                        // The first backlash escapes the second backslash.
                        // The third backslash escapes the single quote.
                        current_arg += "\\'";
                        p += 3;  // Skip the backslashes and the quote
                    }
                }
                else {
                    // Backslashes not followed by quote are
                    // treated as regular backslashes
                    for (int i = 0; i < backslash_count; i++) {
                        current_arg += "\\";
                    }
                    p += backslash_count - 1;
                }
                continue;
            }

            if (*p == '\'') {
                if (!current_arg.empty() || in_single_quotes) {
                    args.push_back(current_arg);
                    current_arg.clear();
                }
                in_single_quotes = !in_single_quotes;
                continue;
            }

            if (isspace(*p) && !in_single_quotes) {
                // End of argument
                if (!current_arg.empty()) {
                    args.push_back(current_arg);
                    current_arg.clear();
                }
                continue;
            }

            // Regular character
            current_arg += *p;
        }

        // Add the last argument if exists
        if (!current_arg.empty()) {
            args.push_back(current_arg);
        }

        return args;
    }

    SourceInfo GetCurrentSourceInfo(const DebugInterfaces* interfaces) {
        SourceInfo info;

        if (!interfaces || !interfaces->control || !interfaces->symbols) {
            return info;
        }

        // Get the current instruction pointer
        ULONG64 offset = 0;
        HRESULT hr = interfaces->symbols->GetScope(&offset, nullptr, nullptr, 0);
        if (FAILED(hr)) {
            return info;
        }

        // Get source file and line information for the current position
        char file_path[MAX_PATH] = { 0 };
        ULONG line_number = 0;

        hr = interfaces->symbols->GetLineByOffset(
            offset, &line_number, file_path, sizeof(file_path), nullptr, nullptr);
        if (SUCCEEDED(hr) && file_path[0] != '\0') {
            info.line = line_number;
            std::string full_path = std::string(file_path);

            // Separate file name from path
            size_t last_slash = full_path.find_last_of("\\/");
            if (last_slash != std::string::npos) {
                info.file_name = full_path.substr(last_slash + 1);
                info.file_path =
                    full_path.substr(0, last_slash);  // Store only the path portion
            }
            else {
                // No slashes found, the whole string is the filename
                info.file_name = full_path;
                info.file_path = "";  // No path component
            }

            info.full_path = full_path;
            info.source_context = ExecuteCommand(interfaces, "lsa .");
            info.is_valid = true;
        }

        return info;
    }

    HRESULT InitializeDebugInterfaces(DebugInterfaces* interfaces) {
        if (!interfaces) {
            return E_INVALIDARG;
        }

        interfaces->client = nullptr;
        interfaces->control = nullptr;
        interfaces->symbols = nullptr;
        interfaces->data_spaces = nullptr;
        interfaces->system_objects = nullptr;
        interfaces->registers = nullptr;

        HRESULT hr = DebugCreate(__uuidof(IDebugClient), (void**)&interfaces->client);
        if (FAILED(hr)) {
            return hr;
        }

        hr = interfaces->client->QueryInterface(__uuidof(IDebugControl),
            (void**)&interfaces->control);
        if (FAILED(hr)) {
            interfaces->client->Release();
            interfaces->client = nullptr;
            return hr;
        }

        hr = interfaces->client->QueryInterface(__uuidof(IDebugSymbols),
            (void**)&interfaces->symbols);
        if (FAILED(hr)) {
            interfaces->control->Release();
            interfaces->client->Release();
            interfaces->control = nullptr;
            interfaces->client = nullptr;
            return hr;
        }

        hr = interfaces->client->QueryInterface(__uuidof(IDebugDataSpaces4),
            (void**)&interfaces->data_spaces);
        if (FAILED(hr)) {
            interfaces->symbols->Release();
            interfaces->control->Release();
            interfaces->client->Release();
            interfaces->symbols = nullptr;
            interfaces->control = nullptr;
            interfaces->client = nullptr;
            return hr;
        }

        hr = interfaces->client->QueryInterface(__uuidof(IDebugSystemObjects),
            (void**)&interfaces->system_objects);
        if (FAILED(hr)) {
            interfaces->data_spaces->Release();
            interfaces->symbols->Release();
            interfaces->control->Release();
            interfaces->client->Release();
            interfaces->data_spaces = nullptr;
            interfaces->symbols = nullptr;
            interfaces->control = nullptr;
            interfaces->client = nullptr;
            return hr;
        }

        hr = interfaces->client->QueryInterface(__uuidof(IDebugRegisters),
            (void**)&interfaces->registers);
        if (FAILED(hr)) {
            interfaces->system_objects->Release();
            interfaces->data_spaces->Release();
            interfaces->symbols->Release();
            interfaces->control->Release();
            interfaces->client->Release();
            interfaces->system_objects = nullptr;
            interfaces->data_spaces = nullptr;
            interfaces->symbols = nullptr;
            interfaces->control = nullptr;
            interfaces->client = nullptr;
            return hr;
        }

        return S_OK;
    }

    HRESULT UninitializeDebugInterfaces(DebugInterfaces* interfaces) {
        if (!interfaces) {
            return E_INVALIDARG;
        }

        // Release interfaces in reverse order of acquisition
        if (interfaces->registers) {
            interfaces->registers->Release();
            interfaces->registers = nullptr;
        }

        if (interfaces->system_objects) {
            interfaces->system_objects->Release();
            interfaces->system_objects = nullptr;
        }

        if (interfaces->data_spaces) {
            interfaces->data_spaces->Release();
            interfaces->data_spaces = nullptr;
        }

        if (interfaces->symbols) {
            interfaces->symbols->Release();
            interfaces->symbols = nullptr;
        }

        if (interfaces->control) {
            interfaces->control->Release();
            interfaces->control = nullptr;
        }

        if (interfaces->client) {
            interfaces->client->Release();
            interfaces->client = nullptr;
        }

        return S_OK;
    }

    std::string ExecuteCommand(const DebugInterfaces* interfaces,
        const std::string& command,
        bool wait_for_break_status) {
        if (!interfaces || !interfaces->client || !interfaces->control) {
            return "";
        }

        if (wait_for_break_status) {
            WaitForBreakStatus(interfaces);
        }

        // Save the current output callbacks
        IDebugOutputCallbacks* previous_callbacks = nullptr;
        interfaces->client->GetOutputCallbacks(&previous_callbacks);

        // Create and set our capture callbacks
        CommandOutputCapture* capture = new CommandOutputCapture();
        interfaces->client->SetOutputCallbacks(capture);

        // Execute the command and capture output
        capture->StartCapture();
        HRESULT hr = interfaces->control->Execute(
            DEBUG_OUTCTL_THIS_CLIENT, command.c_str(), DEBUG_EXECUTE_DEFAULT);

        if (wait_for_break_status) {
            WaitForBreakStatus(interfaces);
        }

        capture->StopCapture();

        std::string output = capture->GetOutput();

        // Restore previous callbacks
        interfaces->client->SetOutputCallbacks(previous_callbacks);
        if (previous_callbacks) {
            previous_callbacks->Release();
        }

        // Release our capture object
        capture->Release();
        return output;
    }

    std::string ConvertToBreakpointFilePath(const std::string& input_path,
        bool check_exists) {
        if (input_path.empty()) {
            return "";
        }

        try {
            std::filesystem::path p(input_path);

            // Check if it's a UNC path
            if (p.has_root_name() && p.root_name().string().substr(0, 2) == "\\\\") {
                return "";
            }

            if (p.is_relative()) {
                return "";
            }

            p = p.lexically_normal();

            if (std::filesystem::is_directory(p)) {
                return "";
            }

            if (check_exists && (!std::filesystem::exists(p))) {
                return "";
            }

            // Get the native path and double the backslashes
            std::string native = p.string();
            std::string doubled_path;
            for (char c : native) {
                if (c == '\\') {
                    doubled_path += "\\\\";
                }
                else {
                    doubled_path += c;
                }
            }

            return doubled_path;
        }
        catch (...) {
            return "";
        }
    }

    DebugContextGuard::DebugContextGuard(const DebugInterfaces* interfaces)
        : interfaces_(interfaces),
        original_process_id_(0),
        original_thread_id_(0),
        is_valid_(false) {
        if (!interfaces_ || !interfaces_->system_objects) {
            return;
        }

        // Get the current process ID
        HRESULT hr =
            interfaces_->system_objects->GetCurrentProcessId(&original_process_id_);
        if (FAILED(hr)) {
            return;
        }

        // Get the current thread ID
        hr = interfaces_->system_objects->GetCurrentThreadId(&original_thread_id_);
        if (FAILED(hr)) {
            return;
        }

        is_valid_ = true;
    }

    bool DebugContextGuard::RestoreIfChanged() {
        if (!is_valid_ || !interfaces_ || !interfaces_->system_objects) {
            return false;
        }

        // Get the current process and thread IDs
        ULONG current_process_id = 0;
        ULONG current_thread_id = 0;

        HRESULT hr =
            interfaces_->system_objects->GetCurrentProcessId(&current_process_id);
        if (FAILED(hr)) {
            return false;
        }

        hr = interfaces_->system_objects->GetCurrentThreadId(&current_thread_id);
        if (FAILED(hr)) {
            return false;
        }

        // Check if the context has changed
        if (current_process_id != original_process_id_ ||
            current_thread_id != original_thread_id_) {
            interfaces_->control->Output(
                DEBUG_OUTPUT_NORMAL,
                "Process or thread has changed. Attempting to restore original process %u and thread %u context.\n",
                original_process_id_, original_thread_id_);

            // Switch back to the original process
            if (current_process_id != original_process_id_) {
                interfaces_->system_objects->SetCurrentProcessId(original_process_id_);
                WaitForBreakStatus(interfaces_);
            }

            // Switch back to the original thread
            if (current_thread_id != original_thread_id_) {
                interfaces_->system_objects->SetCurrentThreadId(original_thread_id_);
                WaitForBreakStatus(interfaces_);
            }
        }

        hr = interfaces_->system_objects->GetCurrentProcessId(&current_process_id);
        if (FAILED(hr)) {
            return false;
        }

        hr = interfaces_->system_objects->GetCurrentThreadId(&current_thread_id);
        if (FAILED(hr)) {
            return false;
        }

        if (current_process_id != original_process_id_ ||
            current_thread_id != original_thread_id_) {
            interfaces_->control->Output(
                DEBUG_OUTPUT_ERROR,
                "Failed to restore original context. Current process: %u, thread: %u\n",
                current_process_id, current_thread_id);
            return false;
        }

        return true;
    }

    std::vector<std::string> GetTopOfCallStack(const DebugInterfaces* interfaces,
        size_t max_depth,
        bool symbol_only) {
        std::vector<std::string> symbols;

        if (!interfaces || !interfaces->control || !interfaces->symbols ||
            max_depth == 0) {
            return symbols;
        }

        // TODO: Update this to use the IDebugControl::GetStackTrace
        // IDebugControl::GetStackTrace (and the Ex version) were tried here
        // followed by IDebugSymbols::GetNameByOffset but this didn't return
        // return the same output as the "kc" command in the majority of cases.
        // Need to investigate further why this is the case. It might be related
        // to the inline function handling?

        std::string command = symbol_only ? "kc " : "kp ";
        command += std::to_string(max_depth);
        std::string kcOutput = ExecuteCommand(interfaces, command, true);

        // Parse the output
        std::vector<std::string> lines = SplitString(kcOutput, "\n");
        for (const auto& line : lines) {
            if (line.empty()) {
                continue;
            }

            // Skip the header line
            if (line.find("Call Site") != std::string::npos) {
                continue;
            }

            // Extract everything after the frame number
            size_t pos = line.find(' ');
            if (pos != std::string::npos) {
                std::string symbol = Trim(line.substr(pos + 1));
                if (!symbol.empty()) {
                    symbols.push_back(symbol);
                }
            }
        }

        return symbols;
    }

}  // namespace utils
```

`utils.h`:

```h
// Copyright (c) 2025 Piet Hein Schouten
// SPDX-License-Identifier: MIT

#ifndef UTILS_H_
#define UTILS_H_

#include <dbgeng.h>
#include <windows.h>
#include <optional>
#include <string>
#include <vector>

// Macros for debug output to make code less verbose
#define DOUT(format, ...) \
  g_debug.control->Output(DEBUG_OUTPUT_NORMAL, format, ##__VA_ARGS__)
#define DERROR(format, ...) \
  g_debug.control->Output(DEBUG_OUTPUT_ERROR, format, ##__VA_ARGS__)

namespace utils {

    // Remove leading and trailing whitespace from a string
    std::string Trim(const std::string& str);

    // Case-insensitive string comparison
    bool ContainsCI(const std::string& string, const std::string& substr);

    // Check if a string represents a whole number.
    bool IsWholeNumber(const std::string& input_str);

    // Remove the file extension from a filename.
    std::string RemoveFileExtension(const std::string& filename);

    // Escape quotes in a string by replacing " with \"
    std::string EscapeQuotes(const std::string& input);

    // Get the directory of the current extension dll.
    std::string GetCurrentExtensionDir();

    struct DebugInterfaces {
        IDebugClient* client = nullptr;
        IDebugControl* control = nullptr;
        IDebugSymbols* symbols = nullptr;
        IDebugDataSpaces4* data_spaces = nullptr;
        IDebugSystemObjects* system_objects = nullptr;
        IDebugRegisters* registers = nullptr;
    };

    HRESULT InitializeDebugInterfaces(DebugInterfaces* interfaces);
    HRESULT UninitializeDebugInterfaces(DebugInterfaces* interfaces);

    struct SourceInfo {
        ULONG line = 0;
        std::string file_path;
        std::string file_name;
        std::string full_path;
        std::string source_context;
        bool is_valid = false;
    };

    // Get current source file and line information from the debugger
    SourceInfo GetCurrentSourceInfo(const DebugInterfaces* interfaces);

    // Splits a string into tokens based on a delimiter.
    // If combine_consecutive_delimiters is true,
    // consecutive delimiters are treated as a single delimiter.
    // For example, "a,,b" with delimiter "," will yield ["a", "b"] if true,
    // and ["a", "", "b"] if false.
    std::vector<std::string> SplitString(
        const std::string& input,
        const std::string& delimiter,
        bool combine_consecutive_delimiters = true);

    // Parses a string containing indices and returns a vector of size_t values.
    // Supports multiple formats:
    //  - Individual numbers: "1", "42"
    //  - Space-separated numbers: "1 2 3"
    //  - Ranges with hyphens: "1-5" (expands to 1,2,3,4,5)
    //  - Mixed formats: "1 3-5 7" (expands to 1,3,4,5,7)
    // Handles both ascending (1-5) and descending (5-1) ranges.
    // Returns a vector with all parsed indices, sorted and with duplicates removed.
    std::vector<size_t> GetIndicesFromString(const std::string& input_str);

    // Parses a string containing numbers or dotted pairs (e.g., "1", "2.3").
    // Returns true if the input is a valid number or dotted pair.
    // If a dotted pair is found, first_number will contain the first part,
    // and second_number will contain the second part as an optional size_t.
    // If the input is a single number, second_number will be std::nullopt.
    bool ParseNumberOrDottedPair(const std::string& input,
        size_t& first_number,
        std::optional<size_t>& second_number);

    // Parse command-line arguments. Due to the way that WinDbg
    // parses command arguments this implementation uses single
    // quotes to delimit text with spaces that should be considered
    // a single argument. For example:
    //   !myext.cmd 'arg1 arg2' arg3
    // will yield ["arg1 arg2", "arg3"].
    // Double quotes could not be used because if a double quote
    // is present in the command line as the first non-whitespace
    // character, WinDbg will not pass it to the extension.
    // Note: Backslashes are only used for escaping when they
    // are immediately followed by a single quote. A backslash
    // not before a single quote will be treated as a regular character.
    std::vector<std::string> ParseCommandLine(const char* cmdLine);

    // Execute a command and capture its output.
    // Note, this function is a little bit of a hack and should only be used
    // when there is no other direct way to achieve the desired result using
    // the existing debug interfaces.
    // Also note, this function sets the output callbacks temporarily to
    // capture the output, so it can interfere with existing output callbacks
    // if they are set by the calling extension.
    std::string ExecuteCommand(const DebugInterfaces* interfaces,
        const std::string& command,
        bool wait_for_break_status = false);

    // Converts a file path to a breakpoint file path which is a path that
    // uses double backslashes for the path separators.
    std::string ConvertToBreakpointFilePath(const std::string& input_path,
        bool check_exists = false);

    // A class to manage debugger context switching.
    // Saves the current process and thread context on construction
    // and can restore it when RestoreIfChanged() is called if the
    // context has changed.
    class DebugContextGuard {
    public:
        explicit DebugContextGuard(const DebugInterfaces* interfaces);
        ~DebugContextGuard() = default;

        // Restores the original process and thread context if it has
        // changed. Returns true if the current context is the same as
        // the original context. Returns false if the current context
        // does not match the original context and can not be restored.
        // false is also returned if there was any error while attempting
        // to retrieve or restore the context.
        bool RestoreIfChanged();

    private:
        const DebugInterfaces* interfaces_;
        ULONG original_process_id_;
        ULONG original_thread_id_;
        bool is_valid_;
    };

    // Returns the top max_depth symbols of the current call stack.
    // If symbol_only is true, only symbols are returned (kc). If
    // symbol_only is false all the parameters and extra details
    // are returned as well (kp).
    std::vector<std::string> GetTopOfCallStack(const DebugInterfaces* interfaces,
        size_t max_depth = 5,
        bool symbol_only = true);

}  // namespace utils

#endif  // UTILS_H_
```