Project Path: arc_gmh5225_linjector-rs_upt1o2fs

Source Tree:

```txt
arc_gmh5225_linjector-rs_upt1o2fs
├── Cargo.toml
├── LICENSE
├── README.md
├── bin
│   └── cmd.rs
├── build.rs
└── src
    ├── lib.rs
    ├── remote_mem.rs
    ├── remote_module.rs
    ├── remote_proc.rs
    ├── shellcode.rs
    └── utils.rs

```

`Cargo.toml`:

```toml
[package]
name = "linjector-rs"
version = "0.1.0"
edition = "2021"

[lib]
name = "linjector_rs"
path = "src/lib.rs"

[[bin]]
name = "linjector-cmd"
path = "bin/cmd.rs"

[dependencies]
android_logger = "0.13.3"
backtrace = "0.3.69"
clap = { version = "4.4.7", features = ["derive"] }
dynasm = "2.0.0"
dynasmrt = "2.0.0"
goblin = "0.7.1"
hxdmp = "0.2.1"
jni = { version = "0.21.1", default-features = false }
log = "0.4.20"
nix = { version = "0.27.1", features = ["uio"] }
pretty-hex = "0.4.0"
proc-maps = "0.3.2"
simple_logger = "4.3.3"

```

`LICENSE`:

```
MIT License

Copyright 2024 erfur

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
# linjector-rs

Android port of [linux-injector](https://github.com/namazso/linux_injector). Library injection using /proc/mem, without ptrace. Only aarch64 is supported.

## Usage

```
Inject code into a running process using /proc/mem

Usage: linjector-cmd [OPTIONS] --pid <PID> --file <FILE>

Options:
  -p, --pid <PID>
          pid of the target process

  -f, --file <FILE>
          path of the library/shellcode to inject

  -i, --injection-type <INJECTION_TYPE>
          type of injection

          [default: raw-dlopen]

          Possible values:
          - raw-dlopen:    Use dlopen to inject a library
          - memfd-dlopen:  Use memfd_create and dlopen to inject a library
          - raw-shellcode: Inject raw shellcode

      --func-sym <FUNC_SYM>
          function to hijack for injection, in the form "lib.so!symbol_name"

      --var-sym <VAR_SYM>
          variable to hijack for injection, in the form "lib.so!symbol_name"

  -d, --debug
          enable debug logs

      --logcat
          print logs to logcat

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
```

## Modes

**Currently only raw dlopen mode works**. Since SELinux doesn't allow calling dlopen on a memfd, memfd dlopen will not work. Shellcode mode is not yet implemented.


```

`bin/cmd.rs`:

```rs
use android_logger::Config;
use clap::{Parser, ValueEnum};
use log::{error, info, warn, LevelFilter};
use simple_logger::SimpleLogger;

/// Inject code into a running process using /proc/mem
#[derive(Parser, Debug)]
#[command(version, about)]
struct Args {
    /// pid of the target process
    #[arg(short, long)]
    pid: i32,

    /// path of the library/shellcode to inject
    #[arg(short, long)]
    file: String,

    /// type of injection
    #[arg(short, long, value_enum, default_value_t = InjectionType::RawDlopen)]
    injection_type: InjectionType,

    /// function to hijack for injection,
    /// in the form "lib.so!symbol_name"
    #[arg(long)]
    func_sym: Option<String>,

    /// variable to hijack for injection,
    /// in the form "lib.so!symbol_name"
    #[arg(long)]
    var_sym: Option<String>,

    /// enable debug logs
    #[arg(short, long)]
    debug: bool,

    /// print logs to logcat
    #[arg(long)]
    logcat: bool,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
enum InjectionType {
    /// Use dlopen to inject a library
    RawDlopen,
    /// Use memfd_create and dlopen to inject a library
    MemfdDlopen,
    /// Inject raw shellcode
    RawShellcode,
}

fn main() {
    let args = Args::parse();

    if args.logcat {
        if args.debug {
            android_logger::init_once(Config::default().with_max_level(LevelFilter::Debug));
        } else {
            android_logger::init_once(Config::default().with_max_level(LevelFilter::Info));
        }
    } else {
        if args.debug {
            SimpleLogger::new()
                .with_level(LevelFilter::Debug)
                .init()
                .unwrap();
        } else {
            SimpleLogger::new()
                .with_level(LevelFilter::Info)
                .init()
                .unwrap();
        }
    }

    let mut injector = match linjector_rs::Injector::new(args.pid) {
        Ok(injector) => injector,
        Err(e) => {
            error!("Error creating injector: {:?}", e);
            std::process::exit(1);
        }
    };

    match injector.set_file_path(args.file) {
        Ok(_) => {}
        Err(e) => {
            error!("Error setting file path: {:?}", e);
            std::process::exit(1);
        }
    }

    match args.injection_type {
        InjectionType::RawDlopen => {
            injector.use_raw_dlopen().unwrap();
        }
        InjectionType::MemfdDlopen => {
            injector.use_memfd_dlopen().unwrap();
        }
        InjectionType::RawShellcode => {
            injector.use_raw_shellcode().unwrap();
        }
    }

    if let Some(func_sym) = &args.func_sym {
        let sym_pair: Vec<&str> = func_sym.split('!').collect();
        if sym_pair.len() != 2 {
            error!("Invalid function symbol format, use lib.so!symbol_name");
            std::process::exit(1);
        }
        match injector.set_func_sym(sym_pair[0], sym_pair[1]) {
            Ok(_) => {}
            Err(e) => {
                error!("Error setting function symbol: {:?}", e);
                std::process::exit(1);
            }
        };
    }

    if let Some(var_sym) = &args.var_sym {
        let sym_pair: Vec<&str> = var_sym.split('!').collect();
        if sym_pair.len() != 2 {
            error!("Invalid variable symbol format, use lib.so!symbol_name");
            std::process::exit(1);
        }
        match injector.set_var_sym(sym_pair[0], sym_pair[1]) {
            Ok(_) => {}
            Err(e) => {
                error!("Error setting variable symbol: {:?}", e);
                std::process::exit(1);
            }
        };
    }

    // if either func_sym or var_sym is not provided, use default symbols
    if args.func_sym.is_none() || args.var_sym.is_none() {
        warn!("function or variable symbol not specified, using defaults");
        match injector.set_default_syms() {
            Ok(_) => {}
            Err(e) => {
                error!("Error setting default symbols: {:?}", e);
                std::process::exit(1);
            }
        };
    }

    match injector.inject() {
        Ok(_) => {
            info!("injection successful");
        }
        Err(e) => {
            error!("Error injecting: {:?}", e);
            std::process::exit(1);
        }
    }
}

```

`build.rs`:

```rs
use std::{env, path::{Path, PathBuf}};

fn main() {
    if env::var("CARGO_CFG_TARGET_OS").unwrap() == "android" {
        android();
    }
}

fn android() {
    println!("cargo:rustc-link-lib=c++_shared");

    if let Ok(output_path) = env::var("CARGO_NDK_OUTPUT_PATH") {
        let sysroot_libs_path =
            PathBuf::from(env::var_os("CARGO_NDK_SYSROOT_LIBS_PATH").unwrap());
        let lib_path = sysroot_libs_path.join("libc++_shared.so");
        std::fs::copy(
            lib_path,
            Path::new(&output_path)
                .join(&env::var("CARGO_NDK_ANDROID_TARGET").unwrap())
                .join("libc++_shared.so"),
        )
        .unwrap();

        let lib_path2 = sysroot_libs_path.join("liblogger.so");
        std::fs::copy(
            lib_path2,
            Path::new(&output_path)
                .join(&env::var("CARGO_NDK_ANDROID_TARGET").unwrap())
                .join("liblogger.so"),
        )
        .unwrap();
    }
}

```

`src/lib.rs`:

```rs
mod remote_mem;
mod remote_module;
mod remote_proc;
mod shellcode;
mod utils;

use std::collections::HashMap;

#[macro_use]
extern crate log;

#[derive(Debug)]
pub enum InjectionError {
    RemoteProcessError,
    RemoteMemoryError,
    RemoteModuleError,
    ModuleNotFound,
    SymbolNotFound,
    FileError,
    CommandError,
    ShellcodeError,
}

pub struct Injector {
    pid: i32,
    remote_proc: remote_proc::RemoteProc,
    file_path: String,
    injection_type: InjectionType,
    target_func_sym_name: String,
    target_func_sym_addr: usize,
    target_var_sym_name: String,
    target_var_sym_addr: usize,
    module_cache: HashMap<String, remote_module::RemoteModule>,
    sym_cache: HashMap<String, usize>,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
enum InjectionType {
    /// Use dlopen to inject a library
    RawDlopen,
    /// Use memfd_create and dlopen to inject a library
    MemFdDlopen,
    /// Inject raw shellcode
    RawShellcode,
}

impl Injector {
    pub fn new(pid: i32) -> Result<Injector, InjectionError> {
        info!("new injector for pid: {}", pid);
        Ok(Injector {
            pid,
            remote_proc: remote_proc::RemoteProc::new(pid)?,
            file_path: String::new(),
            injection_type: InjectionType::RawDlopen,
            target_func_sym_name: String::new(),
            target_func_sym_addr: 0,
            target_var_sym_name: String::new(),
            target_var_sym_addr: 0,
            module_cache: HashMap::new(),
            sym_cache: HashMap::new(),
        })
    }

    pub fn set_file_path(&mut self, file_path: String) -> Result<&mut Self, InjectionError> {
        let file = std::fs::File::open(&file_path);
        if file.is_err() {
            error!("File not found: {}", file_path);
            return Err(InjectionError::FileError);
        }

        self.file_path = file_path;
        Ok(self)
    }

    fn prepare_file(&self) -> Result<String, InjectionError> {
        if self.injection_type == InjectionType::RawDlopen
            || self.injection_type == InjectionType::MemFdDlopen
        {
            utils::verify_elf_file(self.file_path.as_str())?;
        }

        let tmp_file_path = utils::copy_file_to_tmp(self.file_path.as_str())?;
        utils::fix_file_context(tmp_file_path.as_str())?;
        utils::fix_file_permissions(tmp_file_path.as_str())?;
        utils::print_file_hexdump(tmp_file_path.as_str())?;
        Ok(tmp_file_path)
    }

    fn add_sym(&mut self, module_name: &str, sym_name: &str) -> Result<usize, InjectionError> {
        debug!("add_sym: {}!{}", module_name, sym_name);

        if !self.module_cache.contains_key(module_name) {
            let module = self.remote_proc.module(module_name)?;
            self.module_cache.insert(module_name.to_string(), module);
        }

        let module = self.module_cache.get(module_name).unwrap();
        debug!("add_sym: {} 0x{:x}", module_name, module.vm_addr);

        if !self.sym_cache.contains_key(sym_name) {
            let sym = module.dlsym_from_fs(sym_name)?;
            self.sym_cache.insert(sym_name.to_string(), sym);
        }

        debug!(
            "add_sym: {} 0x{:x}",
            sym_name,
            self.sym_cache.get(sym_name).unwrap()
        );
        Ok(*self.sym_cache.get(sym_name).unwrap())
    }

    pub fn set_func_sym(
        &mut self,
        module_name: &str,
        sym_name: &str,
    ) -> Result<&mut Self, InjectionError> {
        let sym_addr = self.add_sym(module_name, sym_name)?;
        self.target_func_sym_name = sym_name.to_string();
        self.target_func_sym_addr = sym_addr;
        debug!("set_func_sym: {} 0x{:x}", sym_name, sym_addr);
        Ok(self)
    }

    pub fn set_var_sym(
        &mut self,
        module_name: &str,
        sym_name: &str,
    ) -> Result<&mut Self, InjectionError> {
        let sym_addr = self.add_sym(module_name, sym_name)?;
        self.target_var_sym_name = sym_name.to_string();
        self.target_var_sym_addr = sym_addr;
        debug!("set_var_sym: {} 0x{:x}", sym_name, sym_addr);
        Ok(self)
    }

    pub fn set_default_syms(&mut self) -> Result<&mut Self, InjectionError> {
        self.set_func_sym("libc.so", "malloc")?;
        self.set_var_sym("libc.so", "timezone")?;
        Ok(self)
    }

    pub fn set_test_syms(&mut self) -> Result<&mut Self, InjectionError> {
        self.set_func_sym(
            "liblasso.so",
            "Java_com_github_erfur_lasso_MainActivity_testFunction",
        )?;
        self.set_var_sym("liblasso.so", "test_var")?;
        Ok(self)
    }

    pub fn use_raw_dlopen(&mut self) -> Result<&mut Self, InjectionError> {
        self.set_func_sym("libdl.so", "dlopen")?;
        self.injection_type = InjectionType::RawDlopen;
        Ok(self)
    }

    pub fn use_memfd_dlopen(&mut self) -> Result<&mut Self, InjectionError> {
        self.set_func_sym("libdl.so", "dlopen")?;
        self.set_func_sym("libc.so", "sprintf")?;
        self.injection_type = InjectionType::MemFdDlopen;
        Ok(self)
    }

    pub fn use_raw_shellcode(&mut self) -> Result<&mut Self, InjectionError> {
        self.injection_type = InjectionType::RawShellcode;
        Ok(self)
    }

    pub fn inject(&mut self) -> Result<(), InjectionError> {
        let file_path = self.prepare_file()?;
        let proc = remote_proc::RemoteProc::new(self.pid)?;

        if self.target_func_sym_name.is_empty() || self.target_var_sym_name.is_empty() {
            warn!("target_func_sym or target_var_sym is empty, using defaults");
            self.set_default_syms()?;
        }

        info!("build second stage shellcode");
        let second_stage: Vec<u8>;
        match self.injection_type {
            InjectionType::RawDlopen => {
                second_stage = shellcode::raw_dlopen_shellcode(
                    *self.sym_cache.get("dlopen").unwrap(),
                    file_path,
                    *self.sym_cache.get("malloc").unwrap(),
                )
                .unwrap();
            }
            InjectionType::MemFdDlopen => {
                second_stage = shellcode::memfd_dlopen_shellcode(
                    *self.sym_cache.get("dlopen").unwrap(),
                    *self.sym_cache.get("malloc").unwrap(),
                    &std::fs::read(file_path.as_str()).unwrap(),
                    *self.sym_cache.get("sprintf").unwrap(),
                )
                .unwrap();
            }
            InjectionType::RawShellcode => {
                second_stage = shellcode::raw_shellcode().unwrap();
            }
        }

        info!("build first stage shellcode");
        let first_stage =
            shellcode::main_shellcode(self.target_var_sym_addr, second_stage.len()).unwrap();

        info!("read original bytes");
        let func_original_bytes = proc
            .mem
            .read(self.target_func_sym_addr, first_stage.len())
            .unwrap();
        let var_original_bytes = proc.mem.read(self.target_var_sym_addr, 0x8).unwrap();

        info!("write first stage shellcode");
        proc.mem
            .write(self.target_var_sym_addr, &vec![0x0; 0x8])
            .unwrap();
        proc.mem
            .write(self.target_func_sym_addr, &first_stage)
            .unwrap();

        info!("wait for shellcode to trigger");
        let mut new_map: u64;
        loop {
            let data = proc.mem.read(self.target_var_sym_addr, 0x8).unwrap();
            // u64 from val
            new_map = u64::from_le_bytes(data[0..8].try_into().unwrap());
            if (new_map & 0x1 != 0) && (new_map & 0xffff_ffff_ffff_fff0 != 0) {
                break;
            }
        }

        new_map &= 0xffff_ffff_ffff_fff0;
        info!("new map: 0x{:x}", new_map);

        info!("overwrite malloc with loop");
        proc.mem
            .write(self.target_func_sym_addr, &shellcode::self_jmp().unwrap())
            .unwrap();

        // wait for 100ms
        std::thread::sleep(std::time::Duration::from_millis(100));

        info!("restore original bytes");
        proc.mem
            .write_code(self.target_func_sym_addr, &func_original_bytes, 1)
            .unwrap();
        proc.mem
            .write(self.target_var_sym_addr, &var_original_bytes)
            .unwrap();

        info!("overwrite new map");
        proc.mem
            .write_code(new_map as usize, &second_stage, 1)
            .unwrap();

        info!("injection done.");
        Ok(())
    }
}

```

`src/remote_mem.rs`:

```rs
use nix::sys::uio::{pread, pwrite};
use std::fs::{File, OpenOptions};

use crate::InjectionError;

#[derive(Debug)]
pub(crate) struct RemoteMem {
    fd: File,
}

impl RemoteMem {
    pub fn new(pid: i32) -> Result<Self, InjectionError> {
        let mem_path: String = format!("/proc/{}/mem", pid);
        // open file in read-write mode
        let fd = OpenOptions::new()
            .read(true)
            .write(true)
            .open(&mem_path)
            .map_err(|_| InjectionError::RemoteMemoryError)?;

        Ok(Self { fd })
    }

    pub fn read(&self, addr: usize, len: usize) -> Result<Vec<u8>, InjectionError> {
        let mut buf = vec![0; len];
        self.read_vec(addr, &mut buf)?;
        Ok(buf)
    }

    pub fn read_vec(&self, addr: usize, buf: &mut Vec<u8>) -> Result<(), InjectionError> {
        debug!(
            "reading from remote memory: addr: 0x{:x}, len: {}",
            addr,
            buf.len()
        );
        match pread(&self.fd, buf, addr as i64) {
            Ok(_) => {}
            Err(e) => {
                error!("error while reading from remote memory: {:?}", e);
                return Err(InjectionError::RemoteMemoryError);
            }
        }
        Ok(())
    }

    pub fn write(&self, addr: usize, buf: &Vec<u8>) -> Result<(), InjectionError> {
        debug!(
            "writing into remote memory: addr: 0x{:x}, len: {}",
            addr,
            buf.len()
        );
        match pwrite(&self.fd, &buf, addr as i64) {
            Ok(_) => Ok(()),
            Err(e) => {
                error!("error while writing into remote memory: {:?}", e);
                Err(InjectionError::RemoteMemoryError)
            }
        }
    }

    /// Write code into remote memory, leaving the first `skip` instructions to last.
    /// This is (hopefully) useful when overwriting code that is currently being executed.
    pub fn write_code(
        &self,
        addr: usize,
        buf: &Vec<u8>,
        skip: usize,
    ) -> Result<(), InjectionError> {
        let skip_offset = skip * 4;
        match pwrite(&self.fd, &buf[skip_offset..], (addr + skip_offset) as i64) {
            Ok(_) => {}
            Err(e) => {
                error!("error while writing into remote memory: {:?}", e);
                return Err(InjectionError::RemoteMemoryError);
            }
        }

        match pwrite(&self.fd, &buf[..skip_offset], (addr) as i64) {
            Ok(_) => {}
            Err(e) => {
                error!("error while writing into remote memory: {:?}", e);
                return Err(InjectionError::RemoteMemoryError);
            }
        }

        Ok(())
    }
}

#[cfg(test)]

mod tests {
    use proc_maps::{get_process_maps, Pid};

    use super::*;

    #[test]
    fn test_read_mem() {
        let remote_mem = RemoteMem::new(std::process::id() as i32).unwrap();
        let buf = remote_mem.read(0x7f7f7f7f7f7f, 0x10);
        println!("{:?}", buf);
    }

    #[test]
    fn test_list_self_maps() {
        let pid: u32 = std::process::id();
        let maps = get_process_maps(Pid::from(pid as u16)).unwrap();
        for map in maps {
            println!("{:?}", map);
        }
    }
}

```

`src/remote_module.rs`:

```rs
use crate::InjectionError;

pub(crate) struct RemoteModule {
    pub name: String,
    pub vm_addr: usize,
    #[allow(dead_code)]
    pub bytes: Vec<u8>,
}

impl RemoteModule {
    pub fn new(name: &str, vm_addr: usize, bytes: Vec<u8>) -> Self {
        Self {
            name: name.to_string(),
            vm_addr,
            bytes,
        }
    }

    pub fn dlsym_from_fs(&self, symbol_name: &str) -> Result<usize, InjectionError> {
        let bytes = std::fs::read(&self.name).map_err(|_| InjectionError::FileError)?;
        let elf = goblin::elf::Elf::parse(&bytes).map_err(|_| InjectionError::RemoteModuleError)?;

        let result = elf
            .syms
            .iter()
            .find(|sym| symbol_name == elf.strtab.get_at(sym.st_name).unwrap());

        if !result.is_none() {
            let offset = result.unwrap().st_value as usize;
            return Ok(offset + self.vm_addr);
        }

        warn!(
            "symbol not found in .symtab, trying .dynsym: {}",
            symbol_name
        );

        let result = elf
            .dynsyms
            .iter()
            .find(|sym| symbol_name == elf.dynstrtab.get_at(sym.st_name).unwrap());

        if result.is_none() {
            error!("symbol not found: {}", symbol_name);
            return Err(InjectionError::SymbolNotFound);
        }

        let offset = result.unwrap().st_value as usize;
        Ok(offset + self.vm_addr)
    }

    fn _dlsym_from_mem(&self, _symbol_name: &str) -> Result<usize, InjectionError> {
        unimplemented!("dlsym_from_mem");
    }
}

```

`src/remote_proc.rs`:

```rs
use proc_maps::{get_process_maps, MapRange, Pid};

use crate::{remote_mem::RemoteMem, remote_module::RemoteModule, InjectionError};

pub(crate) struct RemoteProc {
    pid: i32,
    pub mem: RemoteMem,
}

impl RemoteProc {
    pub fn new(pid: i32) -> Result<Self, InjectionError> {
        let mem = RemoteMem::new(pid)?;
        Ok(Self { pid, mem })
    }

    fn maps(&self) -> Result<Vec<MapRange>, InjectionError> {
        get_process_maps(self.pid as Pid).map_err(|_| InjectionError::RemoteProcessError)
    }

    fn maps_by_name(&self, name: &str) -> Result<Vec<MapRange>, InjectionError> {
        let maps = self.maps()?;
        let mut maps_by_name: Vec<MapRange> = Vec::new();
        for map in maps {
            match map.filename() {
                None => continue,
                Some(filename) => {
                    if filename.ends_with(name) {
                        maps_by_name.push(map);
                    }
                }
            }
        }

        if maps_by_name.is_empty() {
            return Err(InjectionError::ModuleNotFound);
        }

        Ok(maps_by_name)
    }

    fn module_bytes(&self, module_name: &str) -> Result<Vec<u8>, InjectionError> {
        let maps = self.maps_by_name(module_name)?;
        let mut module_bytes: Vec<u8> = Vec::new();
        for map in maps {
            // debug!("map: {:?}", map);
            module_bytes.resize(map.offset, 0);
            let mut buf = self.mem.read(map.start(), map.size())?;
            module_bytes.append(&mut buf);
        }

        Ok(module_bytes)
    }

    pub fn module(&self, module_name: &str) -> Result<RemoteModule, InjectionError> {
        let maps = self.maps_by_name(module_name)?;
        Ok(RemoteModule::new(
            maps[0].filename().unwrap().to_str().unwrap(),
            maps[0].start(),
            self.module_bytes(module_name)?,
        ))
    }
}

```

`src/shellcode.rs`:

```rs
use dynasmrt::{dynasm, DynasmApi, DynasmLabelApi};

use crate::InjectionError;

pub fn main_shellcode(var_addr: usize, alloc_len: usize) -> Result<Vec<u8>, InjectionError> {
    let mut ops = dynasmrt::aarch64::Assembler::new().unwrap();

    dynasm!(ops
        ; .arch aarch64

        ; ->start:
        // check if the bit is set
        ; ldr x6, ->var_addr
        ; ldxrb w1, [x6]
        ; cbnz w1, ->start

        // set the bit
        ; mov w2, 0x1
        ; stxrb w1, w2, [x6]
        ; cbnz w1, ->start

        // save the registers
        ; sub sp, sp, #0x100
        ; stp x0, x1, [sp, #0x0]
        ; stp x2, x3, [sp, #0x10]
        ; stp x4, x5, [sp, #0x20]
        ; stp x6, x7, [sp, #0x30]
        ; stp x8, x9, [sp, #0x40]
        ; stp x10, x11, [sp, #0x50]
        ; stp x12, x13, [sp, #0x60]
        ; stp x14, x15, [sp, #0x70]
        ; stp x16, x17, [sp, #0x80]
        ; stp x18, x19, [sp, #0x90]
        ; stp x20, x21, [sp, #0xa0]
        ; stp x22, x23, [sp, #0xb0]
        ; stp x24, x25, [sp, #0xc0]
        ; stp x26, x27, [sp, #0xd0]
        ; stp x28, x29, [sp, #0xe0]
        ; stp x30, xzr, [sp, #0xf0]

        // mmap call
        ; mov x0, #0x0                  // addr       (NULL)
        ; mov x1, alloc_len as _        // len        (0x1000)
        ; mov x2, #0x7                  // prot       (RWX)
        ; mov x3, #0x22                 // flags      (MAP_PRIVATE | MAP_ANONYMOUS)
        ; mvn x4, xzr                   // fd         (-1)
        ; mov x5, #0x0                  // offset     (ignored)
        ; mov x8, #0xde                 // syscall no (mmap)
        ; svc #0x0                      // syscall

        // write self loop instruction to the new map
        ; ldr w1, ->self_jmp
        ; str w1, [x0]

        // flush cache
        // https://chromium.googlesource.com/v8/v8/+/9405fcfdd1984341ea06a192b3b08bdb6069db15/src/arm64/cpu-arm64.cc
        // ; dc civac, x0
        // ; dsb ish
        // ; ic ivau, x0
        ; dsb ish
        ; isb

        // save mmap addr (with bit set to keep the other threads spinning)
        ; orr x0, x0, #0x1
        ; str x0, [x6, #0x0]

        // turn off the bit
        ; eor x0, x0, #0x1

        // jump to the new map
        ; br x0

        ; .align 4
        ; ->minus_one:
        ; .qword -1 as _

        ; .align 4
        ; ->var_addr:
        ; .qword var_addr as _

        ; .align 4
        ; ->alloc_len:
        ; .qword alloc_len as _

        ; .align 4
        ; ->self_jmp:
        ; b ->self_jmp
    );

    match ops.finalize() {
        Ok(shellcode) => Ok(shellcode.to_vec()),
        Err(_) => Err(InjectionError::ShellcodeError),
    }
}

pub fn raw_dlopen_shellcode(
    dlopen_addr: usize,
    dlopen_path: String,
    jmp_addr: usize,
) -> Result<Vec<u8>, InjectionError> {
    let mut ops = dynasmrt::aarch64::Assembler::new().unwrap();

    // dlopen flags RTLD_NOW
    let dlopen_flags: usize = 0x2;
    let dlopen_path_bytes: &[u8] = dlopen_path.as_bytes();

    dynasm!(ops
        ; .arch aarch64

        // for testing
        // ; brk #0x1

        // load args
        ; adr x0, ->dlopen_path
        ; ldr x1, ->dlopen_flags

        // call dlopen
        ; ldr x8, ->dlopen
        ; blr x8

        // if dlopen fails, crash
        ; cbz x0, ->crash

        // load the original args
        ; ldp x0, x1, [sp, #0x0]
        ; ldp x2, x3, [sp, #0x10]
        ; ldp x4, x5, [sp, #0x20]
        ; ldp x6, x7, [sp, #0x30]
        ; ldp x8, x9, [sp, #0x40]
        ; ldp x10, x11, [sp, #0x50]
        ; ldp x12, x13, [sp, #0x60]
        ; ldp x14, x15, [sp, #0x70]
        ; ldp x16, x17, [sp, #0x80]
        ; ldp x18, x19, [sp, #0x90]
        ; ldp x20, x21, [sp, #0xa0]
        ; ldp x22, x23, [sp, #0xb0]
        ; ldp x24, x25, [sp, #0xc0]
        ; ldp x26, x27, [sp, #0xd0]
        ; ldp x28, x29, [sp, #0xe0]
        ; ldp x30, xzr, [sp, #0xf0]
        ; add sp, sp, #0x100

        // jump to the original function
        ; ldr x8, ->oldfun
        ; br x8

        ; ->crash:
        ; brk #0x1

        ; .align 4
        ; ->dlopen_path:
        ; .bytes dlopen_path_bytes
        ; .bytes [0x0]

        ; .align 4
        ; ->dlopen_flags:
        ; .qword dlopen_flags as _

        ; .align 4
        ; ->dlopen:
        ; .qword dlopen_addr as _

        ; .align 4
        ; ->oldfun:
        ; .qword jmp_addr as _
    );

    match ops.finalize() {
        Ok(shellcode) => Ok(shellcode.to_vec()),
        Err(_) => Err(InjectionError::ShellcodeError),
    }
}

pub fn memfd_dlopen_shellcode(
    dlopen_addr: usize,
    jmp_addr: usize,
    library_data_bytes: &Vec<u8>,
    sprintf_addr: usize,
) -> Result<Vec<u8>, InjectionError> {
    let mut ops = dynasmrt::aarch64::Assembler::new().unwrap();

    // dlopen flags RTLD_NOW
    let dlopen_flags: usize = 0x2;

    dynasm!(ops
        ; .arch aarch64

        // call memfd_create
        ; adr x0, ->memfd_name // name
        ; mov x1, #0x0         // flags
        ; mov x8, #0x117       // syscall no (memfd_create)
        ; svc #0x0             // syscall

        // create the path string with sprintf
        ; mov x2, x0
        ; adr x0, ->fd_format_buffer
        ; adr x1, ->fd_template
        ; ldr x8, ->sprintf
        ; blr x8

        // write data to memfd
        ; mov x0, x2              // fd
        ; adr x1, ->library_data  // offset
        ; mov x2, library_data_bytes.len() as u64 // len
        ; mov x8, #0x40           // syscall no (write)
        ; svc #0x0                // syscall

        // call dlopen
        ; adr x0, ->fd_format_buffer
        ; ldr x1, ->dlopen_flags
        ; ldr x8, ->dlopen
        ; blr x8

        // load the original args
        ; ldp x0, x1, [sp, #0x0]
        ; ldp x2, x3, [sp, #0x10]
        ; ldp x4, x5, [sp, #0x20]
        ; ldp x6, x7, [sp, #0x30]
        ; ldp x8, x9, [sp, #0x40]
        ; ldp x10, x11, [sp, #0x50]
        ; ldp x12, x13, [sp, #0x60]
        ; ldp x14, x15, [sp, #0x70]
        ; ldp x16, x17, [sp, #0x80]
        ; ldp x18, x19, [sp, #0x90]
        ; ldp x20, x21, [sp, #0xa0]
        ; ldp x22, x23, [sp, #0xb0]
        ; ldp x24, x25, [sp, #0xc0]
        ; ldp x26, x27, [sp, #0xd0]
        ; ldp x28, x29, [sp, #0xe0]
        ; ldp x30, xzr, [sp, #0xf0]
        ; add sp, sp, #0x100

        // jump to the original function
        ; ldr x8, ->oldfun
        ; br x8

        ; .align 4
        ; ->memfd_name:
        ; .bytes "".as_bytes()

        ; .align 4
        ; ->dlopen_flags:
        ; .qword dlopen_flags as _

        ; .align 4
        ; ->dlopen:
        ; .qword dlopen_addr as _

        ; .align 4
        ; ->oldfun:
        ; .qword jmp_addr as _

        ; .align 4
        ; ->sprintf:
        ; .qword sprintf_addr as _

        ; .align 4
        ; ->fd_template:
        ; .bytes "/proc/self/fd/%d\0".as_bytes()

        ; .align 4
        ; ->fd_format_buffer:
        ; .bytes [0x0; 0x20]

        ; .align 4
        ; ->library_data:
        ; .bytes library_data_bytes
    );

    match ops.finalize() {
        Ok(shellcode) => Ok(shellcode.to_vec()),
        Err(_) => Err(InjectionError::ShellcodeError),
    }
}

pub fn raw_shellcode() -> Result<Vec<u8>, InjectionError> {
    unimplemented!()
}

pub(crate) fn self_jmp() -> Result<Vec<u8>, InjectionError> {
    let mut ops = dynasmrt::aarch64::Assembler::new().unwrap();

    dynasm!(ops
        ; .arch aarch64
        ; ->self_jmp:
        ; b ->self_jmp
    );

    match ops.finalize() {
        Ok(shellcode) => Ok(shellcode.to_vec()),
        Err(_) => Err(InjectionError::ShellcodeError),
    }
}

```

`src/utils.rs`:

```rs
use hxdmp::hexdump;
use std::io::{ErrorKind, Read};

use crate::InjectionError;

const HEXDUMP_BUFFER_SIZE: usize = 0x200;
const TMP_DIR_PATH: &str = "/data/local/tmp";

pub fn print_file_hexdump(file_path: &str) -> Result<(), InjectionError> {
    let mut file = match std::fs::File::open(file_path) {
        Ok(file) => file,
        Err(e) => {
            error!("Error opening file: {}", e);
            return Err(InjectionError::FileError);
        }
    };

    let mut in_buffer = [0; HEXDUMP_BUFFER_SIZE];
    let mut out_buffer = Vec::new();

    match file.read_exact(&mut in_buffer) {
        Ok(_) => {}
        Err(e) => {
            if e.kind() == ErrorKind::UnexpectedEof {
                // ignore
            } else {
                error!("Error reading file: {}", e);
                return Err(InjectionError::FileError);
            }
        }
    }

    hexdump(&in_buffer, &mut out_buffer).unwrap();

    debug!("Hexdump of file: {}", String::from_utf8_lossy(&out_buffer));
    Ok(())
}

pub fn verify_elf_file(file_path: &str) -> Result<(), InjectionError> {
    let file = match std::fs::File::open(file_path) {
        Ok(file) => file,
        Err(e) => {
            error!("Error opening file: {}", e);
            return Err(InjectionError::FileError);
        }
    };

    let mut magic = [0; 4];
    match file.take(4).read_exact(&mut magic) {
        Ok(_) => {}
        Err(e) => {
            error!("Error reading file: {}", e);
            return Err(InjectionError::FileError);
        }
    }

    if magic != [0x7f, 0x45, 0x4c, 0x46] {
        error!("File is not an ELF file");
        return Err(InjectionError::FileError);
    }

    Ok(())
}

pub fn copy_file_to_tmp(file_path: &str) -> Result<String, InjectionError> {
    let file_name = match std::path::Path::new(file_path).file_name() {
        Some(name) => name.to_str().unwrap(),
        None => {
            error!("Error getting file name");
            return Err(InjectionError::FileError);
        }
    };

    // copy file to /data/local/tmp so that the target app can access it
    let tmp_file_path = std::path::Path::new(TMP_DIR_PATH)
        .join(file_name)
        .as_os_str()
        .to_str()
        .unwrap()
        .to_string();

    info!("Copying file {} to {}", file_path, tmp_file_path);
    match std::fs::copy(file_path, &tmp_file_path) {
        Ok(_) => {
            info!("File copied successfully");
            Ok(tmp_file_path)
        }
        Err(e) => {
            error!("Error copying file: {}", e);
            Err(InjectionError::FileError)
        }
    }
}

pub fn fix_file_context(file_path: &str) -> Result<(), InjectionError> {
    // set file context to apk_data_file for dlopen to succeed
    info!("Fixing file context for {}", file_path);
    match std::process::Command::new("chcon")
        .arg("u:object_r:apk_data_file:s0")
        .arg(file_path)
        .output()
    {
        Ok(output) => {
            if !output.status.success() {
                error!(
                    "Error running chcon: {}",
                    String::from_utf8_lossy(&output.stderr)
                );
                Err(InjectionError::CommandError)
            } else {
                info!("File context fixed");
                Ok(())
            }
        }
        Err(e) => {
            error!("Error running chcon: {}", e);
            Err(InjectionError::CommandError)
        }
    }
}

pub fn fix_file_permissions(file_path: &str) -> Result<(), InjectionError> {
    // add executable permission to file
    info!("Fixing file permissions for {}", file_path);
    match std::process::Command::new("chmod")
        .arg("+r")
        .arg(file_path)
        .output()
    {
        Ok(output) => {
            if !output.status.success() {
                error!(
                    "Error running chmod: {}",
                    String::from_utf8_lossy(&output.stderr)
                );
                Err(InjectionError::CommandError)
            } else {
                info!("File permissions fixed");
                Ok(())
            }
        }
        Err(e) => {
            error!("Error running chmod: {}", e);
            Err(InjectionError::CommandError)
        }
    }
}

```