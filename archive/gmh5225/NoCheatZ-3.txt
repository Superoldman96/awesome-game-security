Project Path: arc_gmh5225_NoCheatZ-3_xb8_2eq9

Source Tree:

```txt
arc_gmh5225_NoCheatZ-3_xb8_2eq9
├── A LIRE - Preparation.txt
├── Descriptif.txt
├── LICENSE
├── README.md
├── csgo-sdk
├── ep1-sdk
├── nocheatz.sln
├── old-nocheatz3
│   ├── AutoRecord.h
│   ├── AutoStatus.cpp
│   ├── AutoStatus.h
│   ├── BaseDetection.cpp
│   ├── BaseDetection.h
│   ├── EntityProps.cpp
│   ├── EntityProps.h
│   ├── Globals.h
│   ├── IFaceManager.h
│   ├── IFaces.h
│   ├── LocalEvents.h
│   ├── MRecipientFilter.cpp
│   ├── MRecipientFilter.h
│   ├── Makefile
│   ├── MostUsedPointers.h
│   ├── NczDelay.h
│   ├── NczHttpSockHandler.cpp
│   ├── NczHttpSockHandler.h
│   ├── NczPlayer.h
│   ├── NczThread.h
│   ├── NczThreads.cpp
│   ├── Preprocessors.h
│   ├── Tools.h
│   ├── Types.h
│   ├── hacks.h
│   ├── nocheatz.cpp
│   ├── nocheatz.h
│   └── nocheatz3_autoupdate
│       ├── BaseDef.h
│       ├── Makefile
│       ├── Misc.cpp
│       ├── Misc.h
│       ├── NczHttpSockHandler.cpp
│       ├── NczHttpSockHandler.h
│       ├── NczThread.h
│       ├── NczThreads.cpp
│       └── serverplugin_empty.cpp
├── server-plugin
│   ├── Code
│   │   ├── Hooks
│   │   │   ├── Hook.cpp
│   │   │   ├── Hook.h
│   │   │   ├── OnGroundHookListener.cpp
│   │   │   ├── OnGroundHookListener.h
│   │   │   ├── PlayerRunCommandHookListener.cpp
│   │   │   ├── PlayerRunCommandHookListener.h
│   │   │   ├── TeleportHookListener.cpp
│   │   │   └── TeleportHookListener.h
│   │   ├── Misc
│   │   │   ├── EventManagerWrap.h
│   │   │   ├── Helpers.cpp
│   │   │   ├── Helpers.h
│   │   │   ├── IFaceManager.cpp
│   │   │   ├── IFaceManager.h
│   │   │   ├── MRecipientFilter.cpp
│   │   │   ├── MRecipientFilter.h
│   │   │   ├── RMS.cpp
│   │   │   ├── RMS.h
│   │   │   ├── Types.h
│   │   │   ├── include_windows_headers.h
│   │   │   ├── temp_BaseDataStruct.h
│   │   │   └── temp_Singleton.h
│   │   ├── Players
│   │   │   ├── NczFilteredPlayersList.cpp
│   │   │   ├── NczFilteredPlayersList.h
│   │   │   ├── NczPlayer.cpp
│   │   │   ├── NczPlayer.h
│   │   │   ├── NczPlayerManager.cpp
│   │   │   ├── NczPlayerManager.h
│   │   │   └── temp_PlayerDataStruct.h
│   │   ├── Preprocessors.h
│   │   ├── Systems
│   │   │   ├── BanRequest.cpp
│   │   │   ├── BanRequest.h
│   │   │   ├── BaseSystem.cpp
│   │   │   ├── BaseSystem.h
│   │   │   ├── Logger.cpp
│   │   │   ├── Logger.h
│   │   │   └── Testers
│   │   │       ├── BaseFramedTester.cpp
│   │   │       ├── BaseFramedTester.h
│   │   │       ├── BaseTimedTester.cpp
│   │   │       ├── BaseTimedTester.h
│   │   │       ├── ConVarTester.cpp
│   │   │       ├── ConVarTester.h
│   │   │       ├── Detections
│   │   │       │   └── temp_BaseDetection.h
│   │   │       ├── EyeAnglesTester.cpp
│   │   │       ├── EyeAnglesTester.h
│   │   │       ├── JumpTester.cpp
│   │   │       ├── JumpTester.h
│   │   │       ├── ShotTester.cpp
│   │   │       ├── ShotTester.h
│   │   │       ├── SpeedTester.cpp
│   │   │       ├── SpeedTester.h
│   │   │       ├── ValidationTester.cpp
│   │   │       └── ValidationTester.h
│   │   ├── plugin.cpp
│   │   └── plugin.h
│   ├── Makefile
│   ├── Res
│   │   └── nocheatz.vdf
│   ├── nocheatz.vcxproj
│   └── nocheatz.vcxproj.filters
└── source-sdk-2013

```

`A LIRE - Preparation.txt`:

```txt
======== Utilisation du code source sous Windows ========

Doit être installé : Microsoft Visual Studio Express 2010 ou >
Lien pour télécharger gratuitement : https://www.microsoft.com/fr-fr/download/details.aspx?id=34673

Ce fichier .txt doit être placé à la racine de la solution.
La racine de la solution doit se trouver dans C:\nocheatz\
Pour le debogage et les tests, le serveur CSS doit être installé dans C:\steamcmd\CSS
							   le serveur CSGO doit être installé dans C:\steamcmd\CSGO
Téléchargez le SDK du/des jeu.
https://github.com/ValveSoftware/source-sdk-2013
https://hg.alliedmods.net/hl2sdks/

Lien utile : https://developer.valvesoftware.com/wiki/Main_Page

======== Installation d'un serveur sur son PC pour le debug ========

Télécharger SteamCMD pour Windows, voir http://forums.steampowered.com/forums/showthread.php?t=3202121
Placer steamcmd.exe dans C:\steamcmd\

Lancer steamcmd.exe.
Après la mise à jour, entrer quit
Relancer steamcmd.
Se loger en anonyme : login anonymous
Entrer : force_install_dir C:\steamcmd\CSS\
Entrer :
	-	Pour un serveur CS:S : app_update 232330 validate
	-	Pour un serveur CS:GO : app_update 740 validate
	-	Pour un serveur CS:P : http://cspromod.com/mirror/mirror1_full_zip/    http://cspromod.com/#download
	-	Pour un autre serveur : https://developer.valvesoftware.com/wiki/SteamCMD:fr#Serveurs_support.C3.A9
Attendre ...
Ne pas oublier de se déconnecter avec quit à la fin de l'installation.

Placer le fichier .vdf dans C:\steamcmd\CSS\cstrike\addons\

```

`Descriptif.txt`:

```txt
-------------- Plugin -------------- 
Besoins :
- SDK

Action:
- Intégration au jeu

-------------- Config -------------- 
Besoins :
- Fichier de configuration utilisateur
- Fichier de calibrage des systèmes de détection
- Fichier de hash des commandes
- Commandes consoles

Action :
- Permettre la configuration du plugin
- Mettre à jour régulièrement le fichier de calibrage et hash avec le serveur maître
- S'assurer de la bonne configuration du jeu

-------------- Protection des commandes -------------- 
Besoins :
- Connaître chacune des commandres reçus

Action :
- Boquer l'usage de commandes interdites

-------------- Gestion du round --------------
Besoins :
- Connaître l'êtat du round

Action :
- Empêcher la venue d'autres joueurs après le début d'un round, restart le round si le joueur est seul

-------------- Détections --------------
Besoins :
- Une détection et ses informations
- Configuration des actions à prendre

Action :
- Communiquer au serveur maître les détections, selon la configuration
- Communiquer au joueurs et aux spectateurs les détections, selon la configuration
- Prendre les mesures nécessaires face à la détection, selon la configuration

-------------- Validation des Steam ID --------------

Besoins :
- Temps réel
- Savoir si le serveur est sécurisé par VAC ou non (= Si la validation devrait avoir lieu)
- Un joueur qui se connecte

Action :
- Empêcher le joueur de rejoindre une équipe tant que la validation n'est pas faite
- Kicker au bout de 30 secondes

-------------- Test BunnyHop --------------

Besoins :
- Temps réel
- Être activé depuis la configuration
- Joueur en vie, round en cours.
- Connaître à tout moment la fréquence des sauts parfaits réalisés, dans un round
- Connaître à tout moment la fréquence de la commande Sauter, dans un round
- Connaître à tout moment le pourcentage de sauts parfaits par rapport aux sauts ratés, dans un round

Action :
- Analyser régulièrement les fréquences et le pourcentage
- Déterminer si l'usage vient d'un script (kicker - bloquer) ou d'un programme (bannir)

-------------- Test Autopistol --------------

Besoins :
- Temps réel
- Être activé depuis la configuration
- Joueur en vie, round en cours.
- Connaître à tout moment la fréquence de la commande Tirer, dans un round

Action :
- Lancer une sous-détection si la fréquence est inférieure à 3 ticks
- Kicker au bout de 5 sous-détections consécutives (pour aviter de prendre en compte les problèmes de souris)

-------------- Test TriggerBot --------------

Besoins :
- Temps réel
- Être activé depuis la configuration
- Joueur en vie, round en cours.
- Connaître à tout moment les fronts-montant / fronts-descendant de la commande Tirer, dans un round
- Connaître à tout moment si le joueur a un adversaire QUI APPARAIT dans le viseur
- Connaître les moments où cet adversaire est touché

Action :
- Compter le nombre de fois où le temps de tir est anormalement court
- Comparer au nombre de fois (Et au moment) où le joueur a un adversaire qui entre dans sa mire
- Comparer au moment / nombre de fois que l'adversaire est touché
- Si c'est presque équivalent, bannir.

-------------- Test EyeAngles --------------

Besoins :
- Temps réel
- Être activé depuis la configuration
- Joueur en vie, round en cours, désactiver en cas de spawn et de téléportation
- Connaître à tout moment les angles de vue du joueur, sur chacune des commandes envoyées

Action :
- Vérifier si l'angle absolu X est plus petit ou égal à 90.0
	- Si c'est pas le cas, vérifier si l'angle est un entier ou non
	- Si c'est un entier, c'est probablement un anti-aim
	- Sinon, c'est probablement un no-recoil
- Vérifier si l'angle absolu Y est plus petit ou égal à 180.0
	- Si c'est pas le cas, vérifier si l'angle est un entier ou non
	- Si c'est un entier, c'est probablement un anti-aim
	- Sinon, c'est probablement un no-spread
- Vérifier si l'angle Z est égal à 0.0
	- Si c'est pas le cas, vérifier si l'angle est un entier ou non
	- Si c'est un entier, c'est probablement un anti-aim
	- Sinon, c'est probablement un no-spread
- Comparer les variations des angles de vue à celles de la souris
	- S'inquiéter si les angles varient alors que la souris, non
	- S'inquiéter si les angles varient dans un autre sens que la souris
- Analyser les variations importantes qui interviennent un cours laps de temps

-------------- Test Speedhack --------------

Besoins :
- Temps réel
- Être activé depuis la configuration
- Joueur en vie, round en cours, désactiver en cas de spawn et de téléportation
- Fréquence des packets reçus
- Nombre de ticks client et serveur

Action :
- Comparer la similitude des trois

-------------- Test Configuration --------------

Besoins :
- Être activé depuis la configuration
- Connaître le netcode du joueur à tout moment

Action :
- Analyser le netcode
- Kicker les pings masqués
- Empêcher le joueur de rejoindre une équipe tant que sa configuration n'est pas conforme.

-------------- Test ConVars --------------

Besoins :
- Temps réel
- Être activé depuis la configuration
- Joueur en vie, round en cours
- Accès aux ConVars du joueur

Action :
- Analyser régulièrement, de façon aléatoire, les convars du joueur.

-------------- Bloqueur ESP --------------
Besoins :
- Temps du jeu
- Être activé depuis la configuration
- Joueurs en vie, round en cours

Action :
- Gérer l'envoie de la position des joueurs selon leur visibilité

-------------- Fake Client ---------------
Besoins :
- Être activé depuis la configuration
- Joueur suspect

Action :
- Créer un bot replay/ghost visible uniquement depuis un wallhack et rapporter qui lui tire dessus

-------------- Besoins communs -------------- 
- Assignation au temps / à l'état du round
- Gestion des joueurs



```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


```

`README.md`:

```md
# NoCheatZ-3
Source Engine serverside anti-cheat plugin. (CS:S, CS:GO, CS:P, TF2). Project aborted in 2014.

```

`nocheatz.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nocheatzX", "server-plugin\nocheatz.vcxproj", "{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debub-CSGO|Win32 = Debub-CSGO|Win32
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
		Release-CSGO|Win32 = Release-CSGO|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}.Debub-CSGO|Win32.ActiveCfg = Debug-CSGO|Win32
		{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}.Debub-CSGO|Win32.Build.0 = Debug-CSGO|Win32
		{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}.Debug|Win32.ActiveCfg = Release-CSS|Win32
		{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}.Debug|Win32.Build.0 = Release-CSS|Win32
		{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}.Release|Win32.ActiveCfg = Release-CSGO|Win32
		{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}.Release|Win32.Build.0 = Release-CSGO|Win32
		{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}.Release-CSGO|Win32.ActiveCfg = Release-CSGO|Win32
		{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}.Release-CSGO|Win32.Build.0 = Release-CSGO|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`old-nocheatz3/AutoRecord.h`:

```h
#ifndef H_AUTORECORD
#define H_AUTORECORD

struct edict_t;

#define TRUNK_DEMO_AT 241200

class AutoRecord
{
public:
	AutoRecord();
	~AutoRecord();

	void Update();
	void setAutoRecord(bool AutoRecord);
	void registerUnexpectedRecord(const char * DemoName);

	bool isRecording();
	bool isTVConnected();
	edict_t * getTV();

private:
	void StartRecord(const char * DemoName);
	void StopRecord();
	void TrunkRecord();

	long m_ulTickCount;
	const char * m_sDemoName;
	bool m_bIsRecording;
	bool m_bAutoRecord;
};

#endif

```

`old-nocheatz3/AutoStatus.cpp`:

```cpp
#include "AutoStatus.h"
#include "nocheatz.h"
#include "Cg_NCZ_Player.h"

#define STATUS_MAX_JOB_PER_FRAME 1

class NoCheatZ;
extern NoCheatZ g_NoCheatZPlugin;
extern IVEngineServer * engine;
extern CGlobalVars*               gpGlobals;

AutoStatus::AutoStatus(void) :
	isStarted(false),
	allow_status(true),
	ccl(1),
	stage(1),
	job_done(1)
{
}


AutoStatus::~AutoStatus(void)
{
}

void AutoStatus::AutoStatusStart()
{
	if(!isStarted && allow_status)
	{
		isStarted = true;
		ccl = 1;
		stage = 1;

		AutoStatusAllConTell("[NoCheatZ 3] %s :", GetTranslate("AutoStatus").c_str());
		AutoStatusAllConTell("--------------------------");
		AutoStatusAllConTell("uID  - NAME             [     Steam-ID     ] - %s      - K/D - rate / cmd / update / interp (ratio)", GetTranslate("Team").c_str());
	}
}

void AutoStatus::AutoStatusFrame()
{
	if(isStarted && allow_status)
	{
		Cg_NCZ_PlayerManager *pm = g_NoCheatZPlugin.get_m_pm();
		switch(stage)
		{
		case 1 :
			{
				MyInfo = NULL;
				MyPlayer = NULL;
				while(ccl != pm->getMaxClients())
				{
					if(ccl > 0)
					{
						MyPlayer = pm->getPlayer(ccl);
						if(MyPlayer)
						{
							MyInfo = MyPlayer->getPlayerInfo();
							if(MyInfo)
							{
								if(MyInfo->IsConnected())
								{
									if(MyPlayer->isRealPlayer())
									{
										const char * team = GetTranslate("Spectator").c_str();
										if (MyInfo->GetTeamIndex() == 2)
										{
											team = "Terrorist";
										}
										else if (MyInfo->GetTeamIndex() == 3)
										{
											team = "CT";
										}
										AutoStatusAllConTell(
											"%s - %s [%s] - %s - %d/%d - %s", 
											minStrf(tostring(MyPlayer->getUserid()), 4).c_str(),
											minStrf(MyPlayer->getName(), 16).c_str(),
											minStrf(MyPlayer->getSteamID(), 16).c_str(),
											minStrf(team, 9).c_str(),
											MyInfo->GetFragCount(),
											MyInfo->GetDeathCount(),
											getStrRates(ccl).c_str());
									
									}
								}
							}
						}
						++job_done;
					}
					else
					{
						ccl = 0;
					}
					++ccl;
					if(job_done > STATUS_MAX_JOB_PER_FRAME)
					{
						job_done = 1;
						break;
					}
				}

				if(ccl == pm->getMaxClients())
				{
					ccl = 1;
					++stage;
				}
			}
			break;

		case 2 :
			{
				MyEdict = getSourceTV();
				if(MyEdict)
				{
					MyPlayer = pm->getPlayer(MyEdict);
					AutoStatusAllConTell("%s - %s [     Source TV    ] -> TV Delay : %s s, TV Port : %s", minStrf(format("%d", MyPlayer->getUserid()), 4).c_str(), minStrf(MyPlayer->getName(), 16).c_str(), g_pCVar->FindVar("tv_delay")->GetString(), g_pCVar->FindVar("tv_port")->GetString());
				}
				AutoStatusAllConTell("--------------------------");
				AutoStatusAllConTell("Steam Community Links :");
				++stage;
			}
			break;

		case 3 :
			{
				MyPlayer = NULL;
				while(ccl != pm->getMaxClients())
				{
					if(ccl > 0)
					{
						MyPlayer = pm->getPlayer(ccl);
						if(MyPlayer)
						{
							if(MyPlayer->isRealPlayer())
							{
								AutoStatusAllConTell("%s -> %s", MyPlayer->getName(), getCommunityID(MyPlayer->getSteamID()).c_str());
							}
						}
						++job_done;
					}
					else
					{
						ccl = 0;
					}
					++ccl;
					if(job_done > STATUS_MAX_JOB_PER_FRAME)
					{
						job_done = 1;
						break;
					}
				}
				if(ccl == pm->getMaxClients())
				{
					this->End();
				}
			}
			break;

		default:
			ccl = 1;
			stage = 1;
			isStarted = false;
			break;
		}
	}
}

void AutoStatus::AutoStatusAllConTell(const char * fmt, ...)
{
	va_list		argptr;
	static char		string[512];

	va_start(argptr, fmt);
	Q_vsnprintf(string, sizeof(string), fmt, argptr);
	va_end(argptr);

	MyEdict = NULL;
	for (int i=1; i<=gpGlobals->maxClients; i++) // EntIndex 0 is worldspawn, after which come the players
	{
		MyEdict = PEntityOfEntIndex(i);
		if(MyEdict)
		{
			contell(MyEdict, string);
		}
	}
}

void AutoStatus::End()
{
	AutoStatusAllConTell("--------------------------");

	isStarted = false;
	ccl = 1;
	stage = 1;
	job_done = 1;
}

```

`old-nocheatz3/AutoStatus.h`:

```h
//#pragma once
#include "MostUsedPointers.h"

#ifndef C_AUTOSTATUS
#define C_AUTOSTATUS

class AutoStatus : public MostUsedPointers
{
public:
	virtual void SetStatusState(bool allowed){allow_status = allowed;};

protected:
	AutoStatus(void);

	virtual void AutoStatusStart();
	virtual void AutoStatusFrame();
	virtual void AutoStatusAllConTell(const char * fmt, ...);
	virtual ~AutoStatus(void);

private:
	//virtual bool isStarted(){return isStarted;};
	virtual void End();

private:
	bool isStarted;
	bool allow_status;
	int ccl;
	int stage;
	int job_done;
	//float last_auto_status;
};

#endif
```

`old-nocheatz3/BaseDetection.cpp`:

```cpp
#include "BaseDetection.h"
#include "Preprocessors.h"

//////////////////////////////////////////////////
~BaseDetectionSystem::BaseDetectionSystem(){}
//////////////////////////////////////////////////

BaseDetectionSystem*::GetBaseDetectionSystem()
{
	return this;
}

BaseDetectionSystem::BaseDetectionSystem()
{
	SetProcessInterval(1.0/66.0);
	On();
	wPlayer_manager = NULL;
	wLast_time_done = 0.0f;
}

BaseDetectionSystem::BaseDetectionSystem(time_z process_interval)
{
	SetProcessInterval(process_interval);
	On();
	wPlayer_manager = NULL;
	wLast_time_done = 0.0f;
}

void BaseDetectionSystem::On()
{
	wIs_active = true;
}

void BaseDetectionSystem::Off()
{
	wIs_active = false;
}

void BaseDetectionSystem::SetProcessInterval(time_z process_interval)
{
	wProcess_interval = process_interval;
}

const char * BaseDetectionSystem::GetName()
{
	return "BaseDetectionSystem";
}

time_z BaseDetectionSystem::GetProcessInterval()
{
	return wProcess_interval;
}

void BaseDetectionSystem::HandleProcess()
{
	if(!IsActive()) return;
	if(GetTime() - wLast_time_done >= this->GetProcessInterval())
	{
		// Additionnaly add metrics
		Process();
		wLast_time_done = GetTime();
	}
}

bool BaseDetectionSystem::IsActive()
{
	return wIs_active;
}

void BaseDetectionSystem::AttachPlayerManager(Cg_NCZ_PlayerManager * player_manager)
{
	if(playerManager) wPlayer_manager = playerManager;
}

//////////////////////////////////////////////////
~DetectionTrigger::DetectionTrigger(){}
//////////////////////////////////////////////////

DetectionTrigger::DetectionTrigger(bool initial_trigger_state)
{
	wTrigger_state = initial_trigger_state;
	ResetTriggerCount();
}

void DetectionTrigger::Trigger()
{
	wTrigger_state = !wTrigger_state;
	++wTrigger_count;
}

const char * DetectionTrigger::GetName()
{
	return "DetectionTrigger";
}

count_z DetectionTrigger::GetTriggerCount()
{
	return wTrigger_count;
}

void DetectionTrigger::ResetTriggerCount()
{
	wTrigger_count = 0;
}




```

`old-nocheatz3/BaseDetection.h`:

```h
#include "Types.h"
#include "PlayerManager.h"

/*
Each detection system will inherite from a Base Detection System class and will be called by PlayerManager class (Which is unique).
Iterate between all players in order to test for detections in Process().
*/

#ifndef C_DETECTION_SYSTEM
#define C_DETECTION_SYSTEM

class BaseDetectionSystem
{
public:
	BaseDetectionSystem();
	BaseDetectionSystem(time_z process_interval);
	virtual AttachPlayerManager(Cg_NCZ_PlayerManager * player_manager);
	virtual ~BaseDetectionSystem();
	
	/* Called by PlayerManager in ProcessDetectionsTests() */
	virtual void HandleProcess();
	virtual void On();
	virtual void Off();
	
	virtual void SetProcessInterval(time_z process_interval);
	
	virtual const char * GetName();
	virtual time_z GetProcessInterval();
	virtual BaseDetectionSystem * GetBaseDetectionSystem();
	virtual bool IsActive();
	
	virtual void Process() = 0;
	
	virtual void OnDetection() = 0;

private:
	time_z wProcess_interval; // s
	time_z wLast_time_done; // s
	Cg_NCZ_PlayerManager * wPlayer_manager;
	bool wIs_active;
};

class DetectionTrigger: public BaseDetectionSystem
{
public:
	DetectionTrigger(bool initial_trigger_state);
	virtual ~DetectionTrigger();
	
	virtual void Process() = 0;
	virtual void OnDetection() = 0;
	virtual void Trigger();
	virtual void ResetTriggerCount();
	
	virtual count_z GetTriggerCount();
	virtual const char * GetName();
	
private:
	bool wTrigger_state;
	count_z wTrigger_count;
};

#endif

```

`old-nocheatz3/EntityProps.cpp`:

```cpp
#include <string>
#include <vector>
#include "EntityProps.h"
#include "nocheatz.h"
#include "eiface.h"
#include "edict.h"

#ifdef NCZ_CSS

extern IServerGameDLL* gamedll;

#undef GetProp // If you are using a lib that make GetProp be GetPropA ...

EntityPropsManager::EntityPropsManager()
{
}

EntityPropsManager::~EntityPropsManager()
{
}


int EntityPropsManager::getIndexInList(const std::string &path)
{
	const int vsize = EntityPropsList.size();
	if(!vsize == 0)
	{
		for (int index = 0; index < vsize; index ++)
		{
			if(EntityPropsList[index].propPath == path)
			{
				return index;
			}
		}
	}
	return -1;
}

bool EntityPropsManager::isPropAlreadyRegistered(const std::string &path)
{
	return (this->getIndexInList(path) > -1);
}

void EntityPropsManager::registerEntityProp(const std::string &path)
{
	if(!isPropAlreadyRegistered(path))
	{
		int offset = this->getPropOffset(path);
		if(offset)
		{
			struct EntityProps entity;
			entity.propOffset = offset;
			entity.propPath = path;
			EntityPropsList.push_back(entity);
		}
	}
	/*else // FIXME : Update offset if it's not the same. Becarfull with the return value of getIndexInList(path).
	{
		if(!(this->getPropOffset(path) == EntityPropsList.at(this->getIndexInList(path)).propOffset))
		{
			int offset = this->getPropOffset(path);
			if(offset)
			{
				struct EntityProps entity;
				entity.propOffset = offset;
				entity.propPath = path;
				EntityPropsList.push_back(entity);
			}
		}
	}*/
}

int EntityPropsManager::getPropOffset(const std::string &path)
{
	// Try to find if we have already this offset
	int iOffset = 0;
	int index = this->getIndexInList(path);
	if(index > -1)
	{
		iOffset = EntityPropsList.at(index).propOffset;
	}
	if(iOffset)
	{
		return iOffset;
	}
	// If not, we have to find it.

	iOffset = 0;
	int i = 0;
	std::string cpath;
	std::vector<std::string> props;

	strSplit(path, ".", &props);

	ServerClass *pAllClasses = gamedll->GetAllServerClasses();
	while(pAllClasses)
	{
		if(pAllClasses->GetName() == props.at(0)) // If we found the class
		{
			const int pSize = props.size(); // The use of const will accelerate the for instruction
			if(pSize > 2) // path containing class.datatable.(...).prop
			{
				SendTable *lastTable = pAllClasses->m_pTable;
				int iProps = 0;
				for(int iPath = 1; iPath < pSize-1; iPath++) // get the last datatable in path
				{
					cpath = props.at(iPath);
					iProps = lastTable->GetNumProps();
					for(i = 0; i < iProps; i++)
					{
						if(lastTable->GetProp(i)->GetName() == props.at(iPath))
						{
							lastTable = lastTable->GetProp(i)->GetDataTable();
							i = iProps;
						}
					}
				}
				iProps = lastTable->m_nProps;
				for(i = 0; i < iProps; i++) // get the prop offset
				{
					if(lastTable->GetProp(i)->GetName() == props.back())
					{
						iOffset = lastTable->GetProp(i)->GetOffset();
						if(iOffset < 0) // The offset must be not negative
						{
							iOffset *= -1;
						}
						return iOffset;
					}
				}
			}
			else // path containing only class.prop
			{
				const int iProps = pAllClasses->m_pTable->GetNumProps();
				for(i = 0; i < iProps; i++)
				{
					//Msg(pAllClasses->m_pTable->GetProp(i)->GetName());
					//Msg("\n");
					if(pAllClasses->m_pTable->GetProp(i)->GetName() == props.back())
					{
						iOffset = pAllClasses->m_pTable->GetProp(i)->GetOffset();
						if(iOffset < 0) // The offset must be not negative
						{
							iOffset *= -1;
						}
						return iOffset;
					}
				}
				break;
			}
		} // End if(pAllClasses->GetName() == props.at(0))
		pAllClasses = pAllClasses->m_pNext;
	} // End while(!pAllClasses)
	return 0;
}

#endif

```

`old-nocheatz3/EntityProps.h`:

```h
#include <string>
#include <vector>
#include "edict.h"
#include "eiface.h"
#include "nocheatz.h"

#ifndef EntityPropsManagerCLASS
#define EntityPropsManagerCLASS

struct EntityProps
{
	std::string propPath; // Unique identifier
	int propOffset; // Offset of prop
};

class EntityPropsManager
{
public:
	// Inits

	EntityPropsManager();
	~EntityPropsManager();

	// Methods

	bool isPropAlreadyRegistered(const std::string &path);

	template<class T>
	T & getPropValue(const std::string &path, edict_t *pPlayer)
	{
		int offset = this->getPropOffset(path);
		CBaseEntity *pBase = pPlayer->GetUnknown()->GetBaseEntity();
		T * prop = NULL;

		if(!offset) // Try to find the offset if it's NULL
		{
			this->registerEntityProp(path);
			offset = this->getPropOffset(path);
			if(!offset)
			{
				return *prop;
			}
		}

		prop = reinterpret_cast<T *>(reinterpret_cast<char *>(pBase) + offset);
		return *prop;
	}

	// Functions

	void registerEntityProp(const std::string &path);

private:
	// Methods

	int getPropOffset(const std::string &path);

	int getIndexInList(const std::string &path);

	// Vars

	std::vector<struct EntityProps> EntityPropsList;

};

#endif

```

`old-nocheatz3/Globals.h`:

```h
#ifndef NCZ_GLOBALS
#define NCZ_GLOBALS

bool                       check_client_vars;
bool                       check_aimbots;
bool                       aimbots_extra_filter;
bool                       check_bunny;
bool                       check_triggerbot;
bool                       report_cheats;
bool                       kick_ban;
bool                       auto_dem;
bool                       use_banlists;
bool                       use_ncz_banlists;
bool                       recording;
bool                       ncz_active;
bool                       cvarCheckLaunched;
//bool                       web_thread_killed        = false;
bool                       report_ukcmd;
bool                       test_config;
bool                       registered;
//bool                       unregister_asked         = false;
//bool                       needtokill               = false;
bool                       ForceConsistency;
bool                       NoTell_active;
//bool                       isRoundPlaying           = false;
bool                       must_thread_be_killed;
bool                       UseNet;
bool                       FirstGameFrame;
bool                       teleport_lock;
bool                       lockServer;
bool                       requireRestart;
//bool                       allow_status             =  true;

//int                        vax_offset               =     0;
//int                        vay_offset               =     0;
//int                        ground_offset            =     0;
int                        player_count;
int                        t_tickrate; 
int                        tickrate;
//int                        maxplayers               =     0;
int                        frameStage;
int                        frameStage_PVAC;

int               demoticks;
//int               n_tick                   =     0;

float                      nextSecond;
//float                      lastTickrateCheck        =   0.0;
//float                      nextTickrateCheck        =   0.0;
float                      UkCmdCheck;
float                      nextstopcheck;
//float                      next_cvar_check          =  0.0f;
//float                      next_cvar_check_timer    = 20.0f;
//float                      roundPlayingCheck        =  0.0f;
float                      lastNetOff;
int                        disconnectNumber;

std::string                recordFilename;
std::string                gb_admin_id;
std::string                gb_reason_id;
std::string                our_ip;

Cg_NCZ_Queue*              queue_send_report;
Cg_NCZ_Queue*              banlists;
Cg_NCZ_Queue*              disconnectingPlayers;
Cg_NCZ_Queue*              serverMessages;
//Cg_NCZ_Queue*              player_conf              =  NULL;

CGlobalVars*               gpGlobals;

std::map<const char *, const char *>   g_cvars;

std::map<std::string, std::string> g_translate;

edict_t *                  PlayerList;

IVEngineServer *           engine;
IGameEventManager2 *       gameeventmanager;
IPlayerInfoManager *       playerinfomanager;
IServerPluginHelpers *     helpers;
IServerGameDLL *           gamedll;
IServerGameEnts *          gameents;
IServerGameClients *       gameclients;
EntityPropsManager *       entpropsmanager;
IEngineTrace *             enginetrace;

NczThread *TheWebThread;
NczThread *UpdateThread;

#endif
```

`old-nocheatz3/IFaceManager.h`:

```h
#include "interface.h"

class IVEngineServer;
class IGameEventManager2;
class IPlayerInfoManager;
class IServerPluginHelpers;
class IServerGameDLL;
class IServerGameEnts;
class IServerGameClients;
class EntityPropsManager;
class IEngineTrace;
class CGlobalVars;

enum interfaceOffset
{
	ENGINE,
	EVENT,
	HELPERS,
	DLL,
	ENTS,
	CLIENTS,
	ENTITYPROPS,
	TRACE,
	GVARS
}

#ifndef IFaceManagerClass
#define IFaceManagerClass

class IFaceManager
{
private:
	IVEngineServer *           engine;
	IGameEventManager2 *       gameeventmanager;
	IPlayerInfoManager *       playerinfomanager;
	IServerPluginHelpers *     helpers;
	IServerGameDLL *           gamedll;
	IServerGameEnts *          gameents;
	IServerGameClients *       gameclients;
	EntityPropsManager *       entpropsmanager;
	IEngineTrace *             enginetrace;
	CGlobalVars*               gpGlobals;
	CreateInterfaceFn gameFactory;
	CreateInterfaceFn interfaceFactory;
	bool isinit;

	template<class T>
	T *FindIFace(const char *IFaceName, CreateInterfaceFn Factory);

public:
	IFaceManager();
	~IFaceManager();

	void Init(CreateInterfaceFn gameFactory, CreateInterfaceFn interfaceFactory);
	template<class T>
	T *GetIFace(interfaceOffset offset);
};

#endif
```

`old-nocheatz3/LocalEvents.h`:

```h

#ifndef NCZ_EVENTS_CLASS
#define NCZ_EVENTS_CLASS

class BaseLocalEvent
{
public:
	BaseLocalEvent();
	virtual ~BaseLocalEvent();

	virtual void TriggerEvent();
	virtual void OnTrigger();
	virtual void Enable();
	virtual void Disable();

	virtual bool isEnabled() const;
private:
	bool active;
	float delay;
};

class LocalEvent : public BaseLocalEvent
{
public:
	LocalEvent();
	virtual ~LocalEvent();

	virtual void TriggerEvent();
	virtual void OnTrigger();
	virtual void Enable();
	virtual void Disable();

	virtual bool isEnabled() const;
private:
	bool active;
	float delay;
};

#endif

```

`old-nocheatz3/MRecipientFilter.cpp`:

```cpp
#include "MRecipientFilter.h"
#include "nocheatz.h"
#include "interface.h"
#include "filesystem.h"
#include "engine/iserverplugin.h"
#ifndef NCZ_EP1
#include "game/server/iplayerinfo.h"
#else
#include "dlls/iplayerinfo.h"
#endif
#include "eiface.h"
#include "igameevents.h"
#include "convar.h"
#include "Color.h"
#include "Preprocessors.h"

extern IVEngineServer      *engine;
extern IPlayerInfoManager   *playerinfomanager;
extern IServerPluginHelpers   *helpers;

// memdbgon must be the last include file in a .cpp file!!!
#include "tier0/memdbgon.h"

MRecipientFilter::MRecipientFilter(void)
{
}

MRecipientFilter::~MRecipientFilter(void)
{
}

int MRecipientFilter::GetRecipientCount() const
{
#ifdef NCZ_CSGO
    return m_Recipients.Count();
#else
	return m_Recipients.Size();
#endif
}

int MRecipientFilter::GetRecipientIndex(int slot) const
{
    if ( slot < 0 || slot >= GetRecipientCount() )
        return -1;

    return m_Recipients[ slot ];
}

bool MRecipientFilter::IsInitMessage() const
{
    return false;
}

bool MRecipientFilter::IsReliable() const
{
    return false;
}

void MRecipientFilter::AddAllPlayers(int maxClients)
{
    m_Recipients.RemoveAll();
    for ( int i = 1; i <= maxClients; i++ )
    {
        edict_t *pPlayer = PEntityOfEntIndex(i);
        if ( !pPlayer || pPlayer->IsFree())
            continue;
        //AddRecipient( pPlayer );
        m_Recipients.AddToTail(i);
    }
}
void MRecipientFilter::AddRecipient( int iPlayer )
{
    // Already in list
    if ( m_Recipients.Find( iPlayer ) != m_Recipients.InvalidIndex() )
        return;

    m_Recipients.AddToTail( iPlayer );
}

```

`old-nocheatz3/MRecipientFilter.h`:

```h
#ifndef _MRECIPIENT_FILTER_H
#define _MRECIPIENT_FILTER_H
#include "irecipientfilter.h"
#include "bitvec.h"
#include "utlvector.h"

class MRecipientFilter : public IRecipientFilter
{
public:
    MRecipientFilter(void);
    ~MRecipientFilter(void);

    virtual bool IsReliable( void ) const;
    virtual bool IsInitMessage( void ) const;

    virtual int GetRecipientCount( void ) const;
    virtual int GetRecipientIndex( int slot ) const;
    void AddAllPlayers( int maxClients );
    void AddRecipient (int iPlayer );

private:
    bool m_bReliable;
    bool m_bInitMessage;
    CUtlVector< int > m_Recipients;
};

#endif

```

`old-nocheatz3/Makefile`:

```
# Dossier de travail
BASE_DIR = .

GAMEDIR = CSS
SDKREDIR = CSS
TIER0SO_CSP = tier0_i486.so
TIER0SO_CSS = libtier0_srv.so
TIER0 = $(TIER0SO_CSS)
OTHER_PREPROCESSORS = -DNCZ_CSS -DCOMPILER_GCC -DPOSIX

# Compilateur
#CXX = g++-3.4 # maximise la compatibilité
#CXX = g++-4.1 # disponible sur les distri récentes
CXX = g++

# Nom du fichier binaire de sortie
BINARY_NAME = nocheatz3.so

# Dossier de sortie du fichier binaire
BINARY_DIR = $(BASE_DIR)/Releases/nocheatz3-$(GAMEDIR)/addons/nocheatz/

# Code source du SDK de VALVE
SDK_SRC_DIR = $(BASE_DIR)/$(SDKREDIR)
SDK_PUBLIC_DIR = $(SDK_SRC_DIR)/public
SDK_TIER0_DIR = $(SDK_SRC_DIR)/public/tier0
SDK_TIER1_DIR = $(SDK_SRC_DIR)/tier1
SDK_GAME_DIR = $(SDK_SRC_DIR)/game
SDK_GAMESHARED_DIR = $(SDK_GAME_DIR)/shared
SDK_GAMESERVER_DIR = $(SDK_GAME_DIR)/server

# Dossiers de sortie
RELEASE_DIR = Release/linux
DEBUG_DIR = Debug/linux

# Dossier contenant les librairies dynamiques
#SRCDS_DIR = ./
SRCDS_BIN_DIR = bin

# Dossier contenant les librairies statiques
SRCDS_A_DIR = $(SDK_SRC_DIR)/lib/linux

# Paramètres du compilateur
ARCH_CFLAGS = -mtune=i486 -march=pentium  -mmmx
USER_CFLAGS = -DTIXML_USE_TICPP
BASE_CFLAGS =   -msse \
                                -fpermissive \
                                -D_LINUX \
                                -DNDEBUG \
                                -Dstricmp=strcasecmp \
                                -D_stricmp=strcasecmp \
                                -D_strnicmp=strncasecmp \
                                -Dstrnicmp=strncasecmp \
                                -D_snprintf=snprintf \
                                -D_vsnprintf=vsnprintf \
                                -D_alloca=alloca \
                                -Dstrcmpi=strcasecmp \
                                -fPIC \
                                -Wno-deprecated \
                                -msse 
#OPT_FLAGS = -O3 -funroll-loops -s -pipe $(OTHER_PREPROCESSORS)
DEBUG_FLAGS = -g -ggdb3 -O0 -D_DEBUG $(OTHER_PREPROCESSORS)               
#DEBUG_FLAGS = $(OPT_FLAGS)
OPT_FLAGS = $(DEBUG_FLAGS)
# Fichiers à compiler
SRC= $(wildcard *.cpp) 
# $(wildcard */*.cpp) $(wildcard */*/*.cpp)                        

# Fichiers à lier
LINK_SO =       $(SRCDS_BIN_DIR)/$(TIER0) \
				$(SRCDS_BIN_DIR)/libvstdlib_srv.so
LINK_A =        $(SRCDS_A_DIR)/tier1_i486.a \
		#		$(SRCDS_A_DIR)/interfaces_i486.a \
				$(SRCDS_A_DIR)/mathlib_i486.a

LINK = -lm -ldl --export-dynamic $(LINK_A) $(LINK_SO)

# Dossiers des fichiers inclus
INCLUDE =       -I. \
                        -I$(SDK_PUBLIC_DIR) \
                        -I$(SDK_PUBLIC_DIR)/engine \
                        -I$(SDK_PUBLIC_DIR)/tier0 \
                        -I$(SDK_PUBLIC_DIR)/tier1 \
                        -I$(SDK_PUBLIC_DIR)/vstdlib \
						-I$(SDK_PUBLIC_DIR)/mathlib \
                        -I$(SDK_PUBLIC_DIR)/game/server \
                        -I$(SDK_SRC_DIR)/tier1 \
                        -I$(SDK_SRC_DIR)/game \
                        -I$(SDK_SRC_DIR)/game/server \
                        -I$(SDK_SRC_DIR)/game/shared \
						-I$(SDK_SRC_DIR)/public \
						-I$(SDK_SRC_DIR)/public/game/server \
						-I$(SDK_SRC_DIR)/public/engine \
						-I$(SDK_SRC_DIR)/public/tier0 \
						-I$(SDK_SRC_DIR)/public/tier1 \
						-I$(SDK_SRC_DIR)/common \
						-I$(SDK_SRC_DIR)/interfaces \
                        

# Règles de compilation

ifeq "$(DEBUG)" "false"
	BIN_DIR = $(RELEASE_DIR)
	CFLAGS = $(OPT_FLAGS)
else
	BIN_DIR = $(DEBUG_DIR)
	CFLAGS = $(DEBUG_FLAGS)
endif
CFLAGS += $(USER_CFLAGS) $(BASE_CFLAGS) $(ARCH_CFLAGS)

OBJECTS := $(SRC:%.cpp=$(BIN_DIR)/%.o)

compile_object = \
	@mkdir -p $(2); \
	echo "$(1) => $(3)"; \
	$(CXX) $(INCLUDE) $(CFLAGS) -o $(3) -c $(1) 2> "/sdk/error_triggerbot.txt";

$(BIN_DIR)/%.o: %.cpp %.h
	$(call compile_object, $<, $(@D), $@)

$(BIN_DIR)/%.o: %.cpp
	$(call compile_object, $<, $(@D), $@)

all: $(OBJECTS)
	@$(CXX) $(INCLUDE) $(CFLAGS) $(OBJECTS) $(LINK) -shared -o $(BINARY_DIR)/$(BINARY_NAME)
        
release:
	@$(MAKE) all DEBUG=false
	
remake:
	@$(MAKE) clean
	@$(MAKE)
	
debug:
	@$(MAKE) all DEBUG=true

clean:
	@rm -rf $(RELEASE_DIR)
	@rm -rf $(DEBUG_DIR)
	@rm -rf $(BINARY_DIR)/$(BINARY_NAME)
        
.PHONY: clean
```

`old-nocheatz3/MostUsedPointers.h`:

```h
//#include "edict.h"
//#include "nocheatz.h"
//#include "game/server/iplayerinfo.h"

#ifndef NULL
#define NULL 0 // C2065
#endif

class Cg_NCZ_Player;
struct edict_t;
class IPlayerInfo;

#ifndef C_MOSTUSEDPOINTERS
#define C_MOSTUSEDPOINTERS

// Class which avoid creating pointers multiple time in the same class.

class MostUsedPointers
{
protected:
	MostUsedPointers()
	{
		MyPlayer = NULL;
		MyInfo = NULL;
		MyEdict = NULL;
	};
	virtual ~MostUsedPointers(){};

protected:
	Cg_NCZ_Player *MyPlayer;
	IPlayerInfo *MyInfo;
	edict_t *MyEdict;
};

#endif
```

`old-nocheatz3/NczDelay.h`:

```h
#include "eiface.h"
#include <map>
#include <string>

class IVEngineServer;
extern IVEngineServer *engine;

#ifndef NCZ_DELAY_CLASS
#define NCZ_DELAY_CLASS

class NczBaseDelay
{
public:

	NczBaseDelay(float Time)
	{
		AddTime = Time;
		EndTime = this->GetTime() + AddTime;
	};

	NczBaseDelay()
	{
		AddTime = 0.0;
		EndTime = 0.0;
		theFunc = 0;
	};

	virtual ~NczBaseDelay(){};

	virtual float GetTime(void)
	{
		if(engine)
		{
			return engine->Time();
		}
		return 0.0;
	};

	virtual void SetP(bool (*fptr)(void))
	{
		theFunc = fptr;
	};

	virtual void SetTime(float Time)
	{
		AddTime = Time;
		EndTime = this->GetTime() + AddTime;
	};

	virtual void LaunchFunc()
	{
		if(theFunc)
		{
			theFunc();
		}
	};

	virtual bool IsEnd(void)
	{
		if(this->GetTime() >= EndTime)
		{
			return true;
		}
		return false;
	};

	float EndTime;
	float AddTime;
	bool (*theFunc)(void);
};

class NczDelay : public NczBaseDelay
{
public:
	NczDelay(float Time, bool (*fptr)(void))
	{
		theFunc = fptr;
		EndTime = this->GetTime() + Time;
		fLaunched = false;
	};

	virtual ~NczDelay(){};

	virtual void Update(void)
	{
		if((this->IsEnd()) && (!fLaunched))
		{
			theFunc();
			fLaunched = true;
		}
	};

private:
	bool fLaunched;
};

class NczDeamonDelay : public NczBaseDelay
{
public:
	NczDeamonDelay(float Time, bool (*fptr)(void))
	{
		theFunc = fptr;
		AddTime = Time;
		EndTime = this->GetTime() + AddTime;
	};

	virtual ~NczDeamonDelay(){};

	virtual void Update(void)
	{
		if(this->IsEnd())
		{
			EndTime += AddTime;
			theFunc();
		}
	};
};

enum DelayType
{
	SINGLE_DELAY,
	DEAMON_DELAY
};

class NczDelayManager
{
public:
	NczDelayManager();
	~NczDelayManager();

	void CreateDelay(std::string DelayName, DelayType Type, float Interval, bool (*fptr)(void))
	{
		if(!IsDelayExists(DelayName, Type))
		{
			if(Type == SINGLE_DELAY)
			{
				Delays[DelayName] = new NczDelay(Interval, fptr);
			}
			else
			{
				DeamonDelays[DelayName] = new NczDeamonDelay(Interval, fptr);
			}
		}
	};

	void Update(void)
	{
		std::map<std::string, NczDelay*>::const_iterator db(Delays.begin()), de(Delays.end());

	};

	void DeleteDelay(std::string DelayName, DelayType Type)
	{
		if(!IsDelayExists(DelayName, Type))
		{
			if(Type == SINGLE_DELAY)
			{
				delete Delays[DelayName];
				Delays.erase(Delays.find(DelayName));
			}
			else
			{
				delete DeamonDelays[DelayName];
				DeamonDelays.erase(DeamonDelays.find(DelayName));
			}
		}
	};

	bool IsDelayExists(std::string DelayName, DelayType Type)
	{
		if(Type == SINGLE_DELAY)
		{
			std::map<std::string, NczDelay*>::const_iterator db(Delays.find(DelayName)), de(Delays.end());
			if(db != de)
			{
				return true;
			}
		}
		else
		{
			std::map<std::string, NczDeamonDelay*>::const_iterator db(DeamonDelays.find(DelayName)), de(DeamonDelays.end());
			if(db != de)
			{
				return true;
			}
		}
		return false;
	};

private:
	std::map<std::string, NczDeamonDelay*> DeamonDelays;
	std::map<std::string, NczDelay*> Delays;
};
#endif // NCZ_DELAY_CLASS

```

`old-nocheatz3/NczHttpSockHandler.cpp`:

```cpp
#include "NczHttpSockHandler.h"
#include <string>
#include <fcntl.h>
#include <cstring>
#include <stdlib.h>
#include <memory.h> 

#ifndef WIN32
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#else
#include <winsock2.h>
#include <ws2tcpip.h>
#endif

#undef h_addr
#include "NczHttpSockHandler.h"
#include <fcntl.h>

std::string shost_name( "" );
std::string g_inetaddr( "" );

std::string NczHttpSockHandler::Resolve( char *hostname )
{
	if(!g_inetaddr.empty())
		return g_inetaddr;

	 struct addrinfo hints, *res;
	 struct in_addr addr;

	 memset( &hints, 0, sizeof( hints ) );
	 hints.ai_socktype = SOCK_STREAM;
	 hints.ai_family = AF_INET;

	 while( getaddrinfo(hostname, NULL, &hints, &res) != 0 );
	 addr.s_addr = (( struct sockaddr_in * )( res->ai_addr ))->sin_addr.s_addr;
	 shost_name = hostname;

	 g_inetaddr = inet_ntoa( addr );

	 freeaddrinfo( res );

	 return g_inetaddr;
}

bool NczHttpSockHandler::Connect(const char *host_name, u_short port)
{
	sip = this->Resolve((char *)host_name);
	sock = socket(AF_INET, SOCK_STREAM, 0);
	sin.sin_addr.s_addr = inet_addr(sip.c_str());
	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);
	if(connect(sock, (SOCKADDR*)&sin, sizeof(sin)) != SOCKET_ERROR)
	{
		return true;
	}
	return false;
}

std::string NczHttpSockHandler::MakeGetPacket(std::string file)
{
	std::ostringstream buf;
	buf << "GET http://" << shost_name << file << " HTTP/1.0" << crlf
	<< "Host: " << shost_name << crlf
		<< "Connection: Keep-Alive" << crlf
		<< "User-Agent: nocheatz3" << crlf
		<< crlf;
	return buf.str();
}

std::string NczHttpSockHandler::MakePostPacket(std::string file, std::string content)
{
	std::ostringstream buf;
	buf << "POST http://" << shost_name << file << " HTTP/1.0" << crlf
	<< "Host: " << shost_name << crlf
		<< "Connection: Close" << crlf
		<< "User-Agent: nocheatz3" << crlf
		<< "Content-type: application/x-www-form-urlencoded" << crlf
		<< "Content-Length: " << content.length() << crlf
		<< crlf
		<< content << crlf
		<< crlf;
	return buf.str();
}

void NczHttpSockHandler::Send(std::string packet)
{
	send(sock, packet.c_str(), packet.length()+1, 0);
	shutdown(sock, 0x01);
	nonblock(sock);
}

void NczHttpSockHandler::SendGet(std::string file)
{
	this->Send(this->MakeGetPacket(file));
}

void NczHttpSockHandler::SendPost(std::string file, std::string content)
{
	this->Send(this->MakePostPacket(file, content));
}

void NczHttpSockHandler::nonblock(int sock)
{
#ifdef WIN32

#else
	int opts;

	if ((opts = fcntl(sock, F_GETFL)) < 0) {
		perror("fcntl(F_GETFL)");
	}

	opts = (opts | O_NONBLOCK);

	if (fcntl(sock, F_SETFL, opts) < 0) {
		perror("fcntl(F_SETFL)");
	}
#endif
}


#define buffsize 1024

std::string NczHttpSockHandler::GetContent()
{
	char response[buffsize];
	int bytes;
	int package = 0;
	int start = 0;
	int bytesWritten = 0;
	int cl = 0;

	std::ostringstream resp;
	int ready = 0;

	while(1)
	{
		fd_set readfs;
		FD_ZERO(&readfs);
		FD_SET(sock, &readfs);
		timeval timeout = {10L,0L};
		ready = select(sock+1, &readfs, NULL, NULL, &timeout);
		switch(ready)
		{
		case SOCKET_ERROR:
			return "";
			break;

		case 0:
			break;

		default:
			if(FD_ISSET(sock,&readfs))
			{
				if((bytes = recv(sock, response, sizeof(response), 0)) > 0)
				{
					if (package == 0)
					{
						std::string sort = response;
						start = sort.find("\r\n\r\n");

						int posA = sort.find("Content-Length: ")+16;
						int posB = sort.find("\r\n", posA)-posA;
						std::string cl_s(sort,posA,posB);
						cl = atoi(cl_s.c_str());

						size_t dataStart = start + strlen("\r\n\r\n");
						// Get the length of the data in this packet                      
						size_t dataLen = bytes - dataStart;
						// Write the data to the string  
						resp.write(&response[dataStart], dataLen);
						bytesWritten = dataLen;
						package++;
					}
					else
					{
						resp.write(response, bytes);
						bytesWritten += bytes;
					}
				}
				else
				{
					return resp.str();
				}
			}
		}
	}
	return resp.str();
}

void NczHttpSockHandler::WriteBinaryContentTo(std::string pathEfilew)
{
	char response[buffsize];
	int bytes;
	int package = 0;
	int start = 0;
	int bytesWritten = 0;
	int cl = 0;

	std::ostringstream resp;
	int ready = 0;
	std::ofstream outfile(pathEfilew.c_str(), std::ios_base::binary | std::ios_base::out);
	while(1)
	{
		fd_set readfs;
		FD_ZERO(&readfs);
		FD_SET(sock, &readfs);
		timeval timeout = {10L,0L};
		ready = select(sock+1, &readfs, NULL, NULL, &timeout);
		switch(ready)
		{
		case SOCKET_ERROR:
			return;
			break;

		case 0:
			break;

		default:
			if(FD_ISSET(sock,&readfs))
			{
				if((bytes = recv(sock, response, sizeof(response), 0)) > 0)
				{
					if (package == 0)
					{
						std::string sort = response;
						start = sort.find("\r\n\r\n");

						int posA = sort.find("Content-Length: ")+16;
						int posB = sort.find("\r\n", posA)-posA;
						std::string cl_s(sort,posA,posB);
						cl = atoi(cl_s.c_str());

						size_t dataStart = start + strlen("\r\n\r\n");
						// Get the length of the data in this packet                      
						size_t dataLen = bytes - dataStart;
						// Write the data to the file    
						outfile.write(&response[dataStart], dataLen);
						bytesWritten = dataLen;
						package++;
					}
					else
					{
						outfile.write(response, bytes);
						bytesWritten += bytes;
					}
				}
				else
				{
					outfile.close();
					return;
				}
			}
		}
	}
	outfile.close();
	return;
}

```

`old-nocheatz3/NczHttpSockHandler.h`:

```h
#ifdef _WIN32

#pragma comment(lib,"ws2_32.lib")
#include <winsock2.h>
#define SOCKET_ERROR_CODE WSAGetLastError()

#else

#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h> // close
#include <netdb.h> // gethostbyname
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define closesocket(s) close(s)
#define SD_BOTH SHUT_RDWR
typedef int SOCKET;
typedef sockaddr_in SOCKADDR_IN; // typedef struct sockaddr_in SOCKADDR_IN;
typedef sockaddr SOCKADDR;
typedef in_addr IN_ADDR;
#define SOCKET_ERROR_CODE errno

#endif
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include <fcntl.h>

#ifndef __NCZ_HTTP_SOCK_HANDLER_CLASS
#define __NCZ_HTTP_SOCK_HANDLER_CLASS

class NczHttpSockHandler
{
public:
		NczHttpSockHandler() : crlf("\r\n")
		{
#ifdef _WIN32
		WSADATA wsadata;
		WSAStartup(MAKEWORD(2,2),&wsadata);
#endif // _WIN32

		};

		~NczHttpSockHandler()
		{
		};

		void End()
		{
				closesocket(sock);
#ifdef _WIN32
		WSACleanup();
#endif // _WIN32
		};

		std::string Resolve(char *host_name);

		bool Connect(const char *host_name, u_short port);

		std::string MakeGetPacket(std::string file);

		std::string MakePostPacket(std::string file, std::string content);

		void Send(std::string packet);

		void SendGet(std::string file);

		void SendPost(std::string file, std::string content);

		std::string GetContent();

		void nonblock(int sock);

		void WriteBinaryContentTo(std::string pathEfilew);

private:
		in_addr addr;
		hostent* host;
		SOCKET sock;
		SOCKADDR_IN sin;
		std::string sip;
		//std::string shost_name;
		std::string crlf;
};

#endif // __NCZ_HTTP_SOCK_HANDLER_CLASS
 
```

`old-nocheatz3/NczPlayer.h`:

```h
#include "Preprocessors.h"
#include <string>
#ifndef NCZ_EP1
#include "mathlib/vector.h"
#else
#include "vector.h"
#endif
#include "Core.h"
#include "igameevents.h"

class IPlayerInfo;
class INetChannelInfo;
class INetChannel;
class CUserCmd;
struct edict_t;

#ifndef NCZPCLASS
#define NCZPCLASS

#define MAX_PLAYERS 64

enum SlotStatus
{
	INVALID = -1,
	BOT = 0,
	PLAYER_OUT_OF_GAME,
	PLAYER_IN_GAME
};

struct PlayerHandler
{
	NczPlayer* playerClass;
	SlotStatus status;
};

class NczPlayerManager : public IGameEventListener2
{
public:
	NczPlayerManager();
	virtual ~NczPlayerManager();

	virtual PlayerHandler* GetPlayerHandler(int slot) const;

private:
	PlayerHandler FullPlayersList[MAX_PLAYERS];
};

class NczPlayer
{
public:
	NczPlayer(const int index);
	virtual ~NczPlayer();

	virtual int getIndex() const; 
	virtual int getUserid() const;
	virtual int getTimeConnected() const;
	virtual const char * getName() const;
	virtual const char * getSteamID() const;
	virtual const char * getIPAddress() const;
	virtual edict_t * getEdict() const;
	virtual IPlayerInfo * getPlayerInfo() const;
	virtual INetChannelInfo* getChannelInfo() const;
	virtual bool isValidEdict() const;

private:
	const int cIndex;
};
#endif
```

`old-nocheatz3/NczThread.h`:

```h
#include "threadtools.h"

#ifndef NCZ_THREAD_CLASS
#define NCZ_THREAD_CLASS

extern int WebThread();

class NczThread : public CThread
{
public:
	NczThread();
	~NczThread();

	virtual int Run();

	virtual bool MustBeKilled();
private:
	bool mustbekilled;
};

#endif // NCZ_THREAD_CLASS

```

`old-nocheatz3/NczThreads.cpp`:

```cpp
#include "NczThread.h"
#include <stdio.h>

NczThread::NczThread() :
	mustbekilled(false)
{
}

NczThread::~NczThread()
{
}

int NczThread::Run()
{
	mustbekilled = false;
	int res =  WebThread();
	mustbekilled = true;
	return res;
}

bool NczThread::MustBeKilled()
{
	return mustbekilled;
}

```

`old-nocheatz3/Preprocessors.h`:

```h
#ifndef NCZ_PREPROCESSORS
#define NCZ_PREPROCESSORS

#ifdef WIN32
#define PLAT "Windows"
#else
#define PLAT "Linux"
#endif

#ifdef NCZ_CSS
#define NCZ_VERSION_STR	"3.3.49.144 r58 CS:S"
#define PIPELINE_ADDRESS "pipeline.nocheatz.com"
#define GAMEDIR "cstrike"
#endif
#ifdef NCZ_CSP
#define NCZ_VERSION_STR	"3.3.0.0 b1 Beta CS:Promod"
#define PIPELINE_ADDRESS "pipeline-csp.nocheatz.com"
#define GAMEDIR "cspromod"
#endif
#ifdef NCZ_CSGO
#define NCZ_VERSION_STR	"3.3.0.0 b1 Beta CS:GO"
#define PIPELINE_ADDRESS "pipeline-csgo.nocheatz.com"
#define GAMEDIR "csgo"
#endif

/////////////////////////////////////////////////////
//// UPDATE THIS WHEN YOU UPDATE THE PLUGIN /////////
/////////////////////////////////////////////////////
//#define DEV " (Debug)"

#ifndef DEV
#define DEV ""
#else
#define SETDEV
#endif

#ifdef WIN32 // verify often ( http://www.sourcemodplugins.org/vtableoffsets )
//#define VTABLE_CMD 417
#define VTABLE_CMD 408
#define VTABLE_SHOULD_TRANSMIT 18
#define VTABLE_UPDATE_TRANSMIT 19
#else
//#define VTABLE_CMD 418
#define VTABLE_CMD 409
#define VTABLE_SHOULD_TRANSMIT 19
#define VTABLE_UPDATE_TRANSMIT 20
#endif

//DEV
//#define NCZ_VERSION_INT 301030080
/* TODO :
- Affichage des steam id lors de la connexion.
- Anti connect flood.
- Anti-NoFlash.
- Anti RadarHack.
- Détecteur SpeedHack.
- Séparation en class polymorphes des systèmes de détection.
*/

/* 3.3.49.142 r56 CS:S
- Suppression du flood lors d'une détection pour convar bypass
- Compatibilité avec les plugins SlowMotion
- Ajout d'une commande pour éviter l'auto restart en cas de mise à jour (ncz_update_norestart), utile si votre serveur redémarre déjà périodiquement.
- Mise à jour de nocheatz_autoexec.cfg

/* 3.3.48.140 r55 CS:S
- Modification du détecteur de triggerbot
- Modification du détecteur de bunnyhop script
- Automatisation des bannissements pour aimbot / convar bypass.
- Mise à jour du détecteur de convar bypass
- Mise à jour du bloqueur d'aimbot
- Build x64 pour linux
*/

/* 3.3.47.138 r54 CS:S
- Ajout de variables consoles interdites.
- Correction du lien affiché dans le message de kick.
- Suppression du vérificateur de rates, devenu inutile.
- Suppression de la compatibilité avec Mani Admin Plugin.
- (En Test) Changement de la façon d'entretenir les bans avec SourceMod/SourceBans.
- Correction d'un crash lors du refus du chargement du plugin.
- Correction du redémarrage forcé du serveur.
*/

/* 3.3.46.132 r53 CS:S
- Suppression des systèmes anti-aimbot 2 & 3.
- Suppression du guardien sv_consistency.
- Désactivation temporaire du bloqueur d'aimbot.
- Mise à jour du vérificateur de convars.
- Modification de nocheatz_autoexec.cfg.
- Ajout d'un lien vers la page de rapports NoCheatZ dans le message de bannissement, si ncz_report_cheat est actif.

*/
/* 3.3.45.126 r52 CS:S
+ Evite le flood dans les logs.
+ Rétablissement du bloqueur d'aimbot sous Linux.
+ Mise à jour de nocheatz_autoexec.cfg
+ Ne coupe plus le serveur lorsque des joueurs sont présents et qu'une mise à jour est disponible.

3.3.45.114 r46
- Blocage de mp_playerid à 2.
- Correction du système de vérification des Convars qui faisait lag le jeu.
- Ajout de l'option +ncz_changelevel_at_start à la commande de lancement pour activer ou non le changement de map automatique au lancement du serveur. (1 - Activer, 2 - Ne pas autoriser)
- Correction des connexions sous Windows.
- Optimisations
*/
/* 3.3.43.111 r45
- Modification des commandes serveur ncz_check_aimbots et ncz_banlists, voir cfg/nocheatz/nocheatz_autoexec.cfg
- Optimisations
- Suppression anti-aimbot par vitesse de visée.
*/
/* 3.3.42.109 r44
- Correction d'un crash
*/
/* 3.3.42.108 r43
- Calibrage
*/
/* 3.3.42.107 r42
- Ajout du rechargement automatique de la map au lancement du serveur, puis après l'activation SourceTV si nécessaire.
- Ajout du système anti-aimbot (Vitesse de visée)
- Ajout du système bloqueur d'aimbot.
- Amélioration de l'auto-update.
- Correction anti bunny hop script.
- Correction d'un second crash au changement de map.
- Correction d'un problème de connexion sous Windows.
*/
/* 3.2.39.103 r41
- Compatibilité avec libc concernant gethostbyname(). Nécessite la réinstallation manuelle du plugin et de l'autoupdate.
- Ajout des banlists ESL, ESEA, EAC.

*/
/*  3.2.37.101 r39
- Amélioration de l'anti bunny hop script
*/
/*  3.2.36.99 r38
- Petite correction de l'auto status
- Mise à jour des liens vers le serveur maître (Réinstallation de l'auto-update)
*/
/*  3.2.36.99 r37
- Correction de la vérification de l'angle Z (Roll) contre les fausses détections dues aux plugins d'administration, lors du Drug.
*/
/*  3.2.35.98 r36
- Amélioration du nouveau anti-aimbot.
- Ajout de l'angle Z (Roll) à vérifier dans l'ancien anti aimbot.
- Correction de l'anti TriggerBot.
*/
/*  3.2.34.95 r35
- Mise à jour de l'ancien anti aimbot pour déteter les anomalies dans l'angle Z.
*/
/*  3.2.34.95 r35
- Mise à jour du nouveau détecteur contre les fausses détections
*/
/*  3.2.34.94 r34
- 2 joueurs minimum avant de lancer la record auto.
- Nouveau détecteur d'aimbot.
- Changement de l'extension des fichiers logs en .log
- Correction du temps de connexion des joueurs (Mauvaise initialisation d'une variable)
*/
/*  3.1.33.91 r33
- Correction d'un crash avec l'auto status.
- Correction des connexions au serveur.
*/
/*  3.1.33.89 r32
- Correction du redémarrage automatique pour les mises à jour.
*/
/*  3.1.33.88 r31
- Vérifie si une mise à jour est disponbile en fin de round puis reboot le serveur automatiquement sous Linux si une mise à jour est disponible et si personne n'est sur le serveur.
- Fix pour éviter de clôner les threads.
- Correction de la compatibilité avec SourceBans.
- Correction d'un crash
/*  3.1.32.85 r30
- Correction d'un crash lors de la déconnexion d'un joueur
- Ajout Anti Name Changer
*/
/*  3.1.31.84 r29
- Limite le travail du vérificateur de convars
- Anti-flood sur l'auto status et commande client ncz_status.
*/
/*  3.1.31.82 r28
- Ajout de la commande ncz_allow_status (Autorise ou non autostatus et commande client ncz_status)
- Correction d'un flood dans les logs lors du bannissement.
- Correction des ajouts de bannissements pour les plugins d'administration.
- Correction d'un bug dans le compteur de détections pour TriggerBot.
*/

/* 3.1.26.73 r27
- Ajout de l'Auto Update (Fonctionne au démarrage du serveur)
- Allégement du vérificateur de commandes console inconnues.
- Ajout de convars à vérifier.
- Les convars à vérifier ne sont plus modifiables.
- Personne ne pourra se connecter si un SSH est détecté sur le serveur.
- Supression des messages GameFrame
- Suppression des messages Probably dans les logs.
- Désactivation de l'anti SpeedHack
- Optimisations
- Fix d'un détecteur qui s'éxécutait 2 fois.
- Fix des erreurs en fin de round qui kickait tout le monde.
- Fix d'un thread qui utilisait toute la charge CPU.

- Fin de la Bêta.
*/
/* 3.1.25.69 r25
- Kick les utilisateurs de LSS et hldj.
- La téléportation ne génére plus de faux positif.
*/
/* 3.1.25.69 r24
- Ajout de la commande wait au niveau serveur.
- Kick les utilisateurs de openscript
- Rétablissement de l'enregistrement automatique Source TV.
- Rétablissement du système anti-aimbot.
- Correction d'un bug lorsqu'un joueur banni est kické.
- Correction des déconnexions mal prises en compte.
*/
/* 3.1.23.67 r23
- Ajout de commandes clientes connues.
- Ajout d'un système de post-détection des crash.
- Vérification du code, correction des Warning.
- Affiche l'adresse IP du joueur dans les logs NoCheatZ 3 lorsqu'il se connecte.

- Allégement des logs.
- Fix d'un bug avec le comptage du nombre de détections.
- N'envoie plus d'alerte de commande console inconnue pour les cvar.
- Fix d'un crash lors de connexion.
- Suppression des calculs inutiles pour l'anti aimbot.
*/
/* 3.1.19.61 r22
- Correction d'un bug avec les commandes clientes inconnues.
*/
/* 3.1.19.60 r21
- Correction de l'affichage de message de détections lors d'une déconnexion d'un joueur.
- Ajout d'une marge pour le système de dépassement du temps d'éxecution.
- Suppression de la mémoire inutile.
- Modificiation du code pour utiliser des float strictes.
- La vérification de la version se fait dans un thread.
- Autres corrections
*/
/* 3.1.19.54 r20
- Correction d'un crash avec la nouvelle vérification pour le système anti TriggerBot.
*/
/*
- Correction des systèmes de message dans le chat (Textes mal placés / Overflow va_list).
- Correction d'un doublon dans les logs lors de détections.
- Modification du comportement lors de la vérification d'un joueur dans une banlist.
- Ajout d'un test de dépassement de vitesse (spatial) pour le système anti speedhack.
- Ajout d'un test qui vérifie si un adversaire est dans le viseur lors d'une détection triggerbot, sait différencier l'Autopistol et le Triggerbot.
- Correction de la protection contre les fausses détections Aimbot.
*/

 // 3 . 00 . 000 . 000
#define NCZ_PLUGIN_NAME "NoCheatZ 3"

#define NCZ_REPORT_FIRST_LINE NCZ_PLUGIN_NAME " (" NCZ_VERSION_STR ") - HOSTNAME : " + tostring(g_pCVar->FindVar("hostname")->GetString()) + " - PORT : " + tostring(g_pCVar->FindVar("hostport")->GetString()) + " - SYSTEM : " + PLAT + " - GAME : " + tostring(gamedll->GetGameDescription()) + " - MAP : " + getMapName() +  " - Date Time : " + getStrDateTime("%x %X") + "\n";

#define compa(a) if(V_strcmp(cmd, a) == 0)\
{\
return false;\
}

#define scomp(a) if(commandline.find(a) != std::string::npos)\
{\
return true;\
}

#define getClCV(a, b) engine->GetClientConVarValue(a, b)

#include <assert.h>

#define STOP_HERE ASSERT(0)

#define Y_CHECK(a, b) ((!(a > 0.0f && b < 0.0f) && !(a < 0.0f && b > 0.0f)) && (!(a > -180.0f && b < 0.0f) && !(a < 0.0f && b > 0.0f)))

#define IN_ATTACK		(1 << 0)
#define IN_JUMP (1<<1) 

#ifdef NCZ_EP1
#define RETRIEVE_ARGV(a) engine->Cmd_Argv(a)
#define RETRIEVE_ARGS engine->Cmd_Args()
#define RETRIEVE_ARGC engine->Cmd_Argc()
#define FINDCOMMAND(a) g_pCVar->GetCommands()->FindCommand(a)
#define IsFlagSet IsBitSet
#else
#define RETRIEVE_ARGV(a) args.Arg(a)
#define RETRIEVE_ARGC args.ArgC()
#define RETRIEVE_ARGS args.GetCommandString()
#define FINDCOMMAND(a) g_pCVar->FindCommand(a)
#endif

#endif


```

`old-nocheatz3/Tools.h`:

```h
#ifndef H_TOOLS
#define H_TOOLS

class Tools
{
	Tools()
	~Tools();

	int getPlayerCount(int team);
	int getHumanPlayerCount(int team);
	int getBotCount(int team);


};

#endif
```

`old-nocheatz3/Types.h`:

```h
typedef time_z float;
typedef count_z unsigned int;
```

`old-nocheatz3/hacks.h`:

```h
#ifndef CSSRPG_SIGSCAN_H
#define CSSRPG_SIGSCAN_H

#ifdef WIN32
	#define WIN32_LEAN_AND_MEAN
	#include <windows.h>
	#include <tlhelp32.h>
#endif

/* Forward Declarations */
class CBaseEntity;
class Vector;
class QAngle;
//enum MoveType_t;

#ifdef WIN32
class NCZ_SigScan
{
	/* Private Variables */
	static unsigned char *base_addr;
	static size_t base_len;

	unsigned char *sig_str;
	char *sig_mask;
	unsigned long sig_len;

	/* Private Functions */
	void parse_sig(char *sig);
	void* find_sig(void);

public:
	/* Public Variables */
	char sig_name[64];
	bool is_set; /* if the scan was successful or not */
	void *sig_addr;

	/* Public Functions */
	NCZ_SigScan(void): sig_str(NULL), sig_addr(NULL), sig_len(0) {}
	~NCZ_SigScan(void);

	static bool GetDllMemInfo(void);
	void Init(char *name, char *sig);

	unsigned long hextoul(char* hex);
};

unsigned int mistrcmp(char *str1, char* str2);

void init_sigs(void);
#endif

#ifndef WIN32 /* !WIN32 */
void init_lsym_funcs(void);
#endif

/* TempEnts Hacked Pointer */
//extern class ITempEntsSystem* tempents;
//void Initialize_TE_Pointer(class IEffects *effects);

/* Hacked Functions */
void CBaseEntity_Teleport(CBaseEntity *cbe, const Vector *newPosition, const QAngle *newAngles, const Vector *newVelocity);

#endif

```

`old-nocheatz3/nocheatz.cpp`:

```cpp
//===== Copyright 2011, DJ Fire-Black production, All rights reserved. ======//
//
// Purpose:
//
// $NoKeywords: $
//
//===========================================================================//

/*
TODO list :
Finir le nouveau détecteur
2 joueurs minimum avant de lancer la record auto
Fix traductions
Ajouter traductions
Pouvoir envoyer la tv si détection

2 joueurs minimum avant de lancer la record auto.
Nouveau détecteur d'aimbot.
Changement de l'extension des fichiers logs en .log
Correction du temps de connexion des joueurs (Mauvaise initialisation d'une variable)
*/


#include <vector> 
#include <sstream>
#include <string>
#include <iostream>
#include <stdio.h>
#include <exception>
#include <fstream>
#include <sstream>
#include <cctype>
#include <stdexcept>
#include <map>
#include <exception>
#include <list>
#include <time.h>
#include "Preprocessors.h"
#include "MRecipientFilter.h"
#include "bitbuf.h"
#include "nocheatz.h"
#include "interface.h"
#include "engine/iserverplugin.h"
#include "eiface.h"
#include "igameevents.h"
#include "convar.h"
#include "tier2/tier2.h"
#ifndef NCZ_EP1
#include "game/server/iplayerinfo.h"
#else
#include "dlls/iplayerinfo.h"
#endif
#include "server_class.h"
#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
#include "EntityProps.h"
#endif
#include "AutoStatus.h"
#include "NczHttpSockHandler.h"
#include "NczThread.h"
#include "Cg_NCZ_Player.h"
#include "iservernetworkable.h"

//#include "baseentity.h"

#ifdef WIN32
#include <tchar.h>
#else
#include <wchar.h>
#endif
#include "inetchannelinfo.h"
#ifdef WIN32
#include <winsock2.h>
#pragma comment(lib, "ws2_32")
typedef int socklen_t;
WSADATA wsaData; // structure needed to initialize a WinSock library
HOSTENT* host;         // structure which is used to store information about the host
IN_ADDR addr;         // this structure contains the g
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define closesocket(s) close(s)
typedef int SOCKET;
typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr SOCKADDR;
in_addr addr;
hostent* host;
#endif

// memdbgon must be the last include file in a .cpp file!!!
//#include "tier0/memdbgon.h"

#undef fopen
//#define GAME_DLL

NoCheatZ g_NoCheatZPlugin;
EXPOSE_SINGLE_INTERFACE_GLOBALVAR(NoCheatZ, IServerPluginCallbacks, INTERFACEVERSION_ISERVERPLUGINCALLBACKS, g_NoCheatZPlugin );


bool                       norestart                = false;
bool                       check_client_vars        =  true;
bool                       check_aimbots            =  true;
bool                       aimbots_extra_filter     = false;
bool                       check_bunny              =  true;
bool                       check_triggerbot         =  true;
bool                       report_cheats            =  true;
bool                       kick_ban                 = false;
bool                       auto_dem                 = false;
bool                       use_banlists             = true;
bool                       use_ncz_banlists         =  true;
bool                       use_lgz_banlists         =  true;
bool                       use_eac_banlists         =  true;
bool                       use_esl_banlists         =  true;
bool                       use_esea_banlists         =  true;
bool                       recording                = false;
bool                       ncz_active               =  true;
bool                       cvarCheckLaunched        = false;
//bool                       web_thread_killed        = false;
bool                       report_ukcmd             =  true;
bool                       test_config              =  true;
bool                       registered               = false;
//bool                       unregister_asked         = false;
//bool                       needtokill               = false;
bool                       ForceConsistency         = false;
bool                       NoTell_active            =  true;
bool                       isRoundPlaying           = false;
bool                       must_thread_be_killed    = false;
bool                       UseNet                   =  true;
bool                       FirstGameFrame           =  true;
bool                       teleport_lock            =  true;
bool                       lockServer               = false;
bool                       requireRestart           = false;
bool                       maySendHeartbeat         = true;
bool                       firstMapOfGame           = true;
#ifdef NCZ_CSS
int                        aimbot_system_number     = 1;
#else
int                        aimbot_system_number     = 1;
#endif
int                        HeartbeatRemain          = 0;
//bool                       allow_status             =  true;

//int                        vax_offset               =     0;
//int                        vay_offset               =     0;
//int                        ground_offset            =     0;
//int                        player_count             =     0;
int                        t_tickrate               =     0; 
int                        tickrate                 =     0;
//int                        maxplayers               =     0;
int                        frameStage               =     0;
int                        frameStage_PVAC          =     0;

int               demoticks                =     0;
//int               n_tick                   =     0;

float                      nextSecond               =   0.0f;
//float                      lastTickrateCheck        =   0.0;
//float                      nextTickrateCheck        =   0.0;
float                      UkCmdCheck               =   0.0f;
float                      nextstopcheck            =   0.0f;
float mapstart = 0.0f;
#define GET_MAPTIME (GetTime()-mapstart)

//float                      next_cvar_check          =  0.0f;
//float                      next_cvar_check_timer    = 20.0f;
//float                      roundPlayingCheck        =  0.0f;
float                      lastNetOff               =  0.0f;
int                        disconnectNumber         =     0;

std::string                recordFilename           =    "";
std::string                gb_admin_id              =    "";
std::string                gb_reason_id             =    "";
std::string                our_ip                   =    "";

Cg_NCZ_Queue*              queue_send_report        =  NULL;
Cg_NCZ_Queue*              banlists                 =  NULL;
Cg_NCZ_Queue*              disconnectingPlayers     =  NULL;
Cg_NCZ_Queue*              serverMessages           =  NULL;
//Cg_NCZ_Queue*              player_conf              =  NULL;

CGlobalVars*               gpGlobals                =  NULL;

std::map<std::string, std::string> g_translate;

edict_t *                  PlayerList               =  NULL;

IVEngineServer *           engine                   =  NULL;
IGameEventManager2 *       gameeventmanager         =  NULL;
IPlayerInfoManager *       playerinfomanager        =  NULL;
IServerPluginHelpers *     helpers                  =  NULL;
IServerGameDLL *           gamedll                  =  NULL;
IServerGameEnts *          gameents                 =  NULL;
IServerGameClients *       gameclients              =  NULL;
#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
EntityPropsManager *       entpropsmanager          =  NULL;
#endif
IEngineTrace *             enginetrace              =  NULL;

NczThread *TheWebThread = NULL;
//NczThread *UpdateThread = NULL;

#ifdef NCZ_EP1
static ICvar *g_pCVar;
#endif

class CCSPlayer;

#include "usercmd.h"
#ifdef WIN32
#include <Windows.h>
#else
#include <signal.h>
#include <sys/mman.h>
#include <assert.h>
#include <errno.h>
#endif

#ifdef WIN32
typedef int (__stdcall *ShouldTransmit_t)(const CCheckTransmitInfo *);
typedef int (__stdcall *UpdateTransmitState_t)();
#else
typedef int (*ShouldTransmit_t)(CCSPlayer *, const CCheckTransmitInfo *);
typedef int (*UpdateTransmitState_t)(CCSPlayer *);
#endif

#ifdef WIN32
typedef void (__stdcall *PlayerRunCommand_t)(CUserCmd*, IMoveHelper*);
#else
typedef void (*PlayerRunCommand_t)(CCSPlayer *, CUserCmd*, IMoveHelper*);
#endif

void xMsg(const char *fmt, ...);

/*
inline DWORD GetVFuncAddr( DWORD* classptr, int vtable)
{
	VirtualProtect( &classptr[vtable], sizeof(DWORD), PAGE_EXECUTE_READWRITE, NULL );
	return classptr[vtable];
}*/
bool hasBeenHooked = false;

ConvarList g_cvars;

DWORD VirtualTableHook( DWORD* classptr, int vtable, DWORD newInterface )
{
		DWORD dwOld, dwStor = 0x0;
		if(!(classptr || vtable || newInterface)) return NULL;
	#ifdef WIN32
		if(!VirtualProtect(&classptr[vtable], (vtable * sizeof(void *)) + 4, PAGE_EXECUTE_READWRITE, &dwOld ))
		{
			xMsg("VirtualProtect: GetLastError() -> %X", GetLastError());
			xMsg("Unable to use anti-aimbot system level 2 (Hook failed). Switching to system level 1.");
			aimbot_system_number = 1;
			return NULL;
		}
	#else

        DWORD psize = sysconf(_SC_PAGESIZE);
		void *p = (void *)((DWORD)(&classptr[vtable]) & ~(psize-1));
		if(mprotect(p, ((vtable * sizeof(void *)) + ((DWORD)(&classptr[vtable]) & (psize-1))), PROT_READ | PROT_WRITE | PROT_EXEC ) < 0)
		{
			xMsg("mprotect: errno -> %d", errno);
			xMsg("Unable to use anti-aimbot system level 2 (Hook failed). Switching to system level 1.");
			aimbot_system_number = 1;
			return NULL;
		}
	#endif
		dwStor = classptr[vtable];
	#ifdef WIN32
		*(DWORD*)&(classptr[vtable]) = newInterface;
		VirtualProtect(&classptr[vtable], (vtable * sizeof(void *)) + 4, dwOld, &dwOld);
	#else
		*(DWORD*)&(classptr[vtable]) = newInterface;
		mprotect(p, ((vtable * sizeof(void *)) + ((DWORD)(&classptr[vtable]) & (psize-1))), PROT_READ | PROT_EXEC );
	#endif
		return dwStor;
}

PlayerRunCommand_t gpPlayerRunCommand = NULL;
ShouldTransmit_t gpShouldTransmit = NULL;
UpdateTransmitState_t gpUpdateTransmitState = NULL;
DWORD* pdwNewInterface = NULL;


void UnhookCmd()
{
#ifdef NCZ_CSS
	if(pdwNewInterface && gpPlayerRunCommand && hasBeenHooked)
	{
		VirtualTableHook(pdwNewInterface, VTABLE_CMD, (DWORD)gpPlayerRunCommand);
		//VirtualTableHook(pdwNewInterface, VTABLE_SHOULD_TRANSMIT, (DWORD)gpShouldTransmit);
		//VirtualTableHook(pdwNewInterface, VTABLE_UPDATE_TRANSMIT, (DWORD)gpUpdateTransmitState);
		pdwNewInterface = NULL;
		gpPlayerRunCommand = NULL;
		hasBeenHooked = false;
	}
#endif
}

inline float GetTime()
{
#ifdef NCZ_CSGO
	if(gpGlobals) return gpGlobals->realtime;
	else return 0.0f;
#else
	if(engine) return engine->Time();
	else return 0.0f;
#endif
}

#ifdef WIN32

void __stdcall nPlayerRunCommand(CUserCmd* pCmd, IMoveHelper* pMoveHelper)
{

	__asm pushad;

	CCSPlayer * thisptr = NULL;
	if(pCmd/* && pMoveHelper*/)
	{
		__asm mov thisptr, ecx;

		bool allowThisCmd = true;
		if(thisptr && check_aimbots && !teleport_lock && (aimbot_system_number > 1))
		{
			__asm pushad;
			//Msg("PLAYERCOMMAND\n");
			Cg_NCZ_Player * MyPlayer = g_NoCheatZPlugin.get_m_pm()->getPlayer(reinterpret_cast<void *>(thisptr));
			if(MyPlayer)
			{
				__asm pushad;
				//Msg("RealPlayerInfex : %d\n", MyPlayer->getIndex());
				CUserCmd MyCmd = *pCmd;
				MyPlayer->testEyeAngles(&MyCmd);
				//printf("Seed : %d\n", pCmd->random_seed);
				//pCmd->random_seed = 0;
				if(fabs(pCmd->viewangles.x) > 89.0f || fabs(pCmd->viewangles.y) > 180.0f || fabs(pCmd->viewangles.z) > 89.0f)
				{
					
					allowThisCmd = false;
					//Msg("[NoCheatZ 3] Blocking bad command from %s [%s] (bad eyeangles).\n", MyPlayer->getName(), MyPlayer->getSteamID());
				}
				if(pCmd->hasbeenpredicted)
				{
					__asm pushad;
					allowThisCmd = false;
					xMsg("[NoCheatZ 3] Blocking bad command from %s [%s] (fake prediction).\n", MyPlayer->getName(), MyPlayer->getSteamID());
				}
				__asm popad;
			}
		}
		if(!allowThisCmd) return;
	}
	//__asm mov ecx, thisptr;
	__asm popad;

	gpPlayerRunCommand(pCmd, pMoveHelper);
}
#undef GetClassName

int __stdcall nUpdateTransmitState()
{
	__asm pushad;

	CCSPlayer * thisptr = NULL;
	__asm mov thisptr, ecx;

	if(thisptr)
	{
		Cg_NCZ_Player * MyPlayer = g_NoCheatZPlugin.get_m_pm()->getPlayer(reinterpret_cast<void *>(thisptr));
		if(MyPlayer)
		{
			edict_t * MyEdict = MyPlayer->getEdict();
			if(MyEdict)
			{
				MyEdict->ClearTransmitState();
				int oldFlags = MyEdict->m_fStateFlags;
				MyEdict->m_fStateFlags = FL_EDICT_FULLCHECK;
				if ( (oldFlags & FL_EDICT_DONTSEND) != (MyEdict->m_fStateFlags & FL_EDICT_DONTSEND) ) engine->NotifyEdictFlagsChange(MyPlayer->getIndex());
			}
		}
	}

	__asm mov ecx, thisptr;
	__asm popad;
}

int __stdcall nShouldTransmit(const CCheckTransmitInfo *pInfo)
{
	__asm pushad;

	CCSPlayer * thisptr = NULL;
	__asm mov thisptr, ecx;


	__asm mov ecx, thisptr;
	__asm popad;

	gpShouldTransmit(pInfo);
}



#ifdef SETDEVV
void __stdcall nSetTransmit(CCheckTransmitInfo *pInfo, bool bAlways)
{
	__asm pushad;
	CCSPlayer * thisptr = NULL;
	__asm mov thisptr, ecx;
	bool allowThisCmd = true;
	if(thisptr)
	{
		/*for(int bit = 1; bit < pInfo->m_pTransmitEdict->GetNumBits(); ++bit)
		{
			if(pInfo->m_pTransmitEdict->IsBitSet(bit)) // Is already marked for transmition ?
			{
				edict_t *pEntity = PEntityOfEntIndex(bit);
				//CCSPlayer *nptr = reinterpret_cast<CCSPlayer *>(pEntity->GetUnknown()->GetBaseEntity());
				//if(thisptr == nptr)
				//{
				//	Msg("MyPlayerIndex : %d\n", bit);
				//	continue;
				//}
				if(strcmp(pEntity->GetClassName(), "player") == 0)
				{
					Msg("Transmission between %x and %s (%x) %d killed.\n", thisptr, pEntity->GetClassName(), pEntity, bit);
					pInfo->m_pTransmitEdict->Set(bit, 0);
					//return;
				//Msg("%s\n", pEntity->GetClassName());
				}
				if(std::string(pEntity->GetClassName()).find("weapon") != std::string::npos)
				{
					Msg("Transmission between %x and %s (%x) %d killed.\n", thisptr, pEntity->GetClassName(), pEntity, bit);
					pInfo->m_pTransmitEdict->Set(bit, 0);
					//return;
				}
				
			}
		}*/
		CBitVecT<CFixedBitVecBase<2048>> * myInfo = new CBitVec<2048>;
		pInfo->m_pTransmitEdict->SetAll();
		pInfo->m_pTransmitEdict->Not(myInfo);
	}
	//return FL_EDICT_DONTSEND;
	__asm popad;

	gpSetTransmit(pInfo, true);
}
#endif
#else
void nPlayerRunCommand(CCSPlayer * thisptr, CUserCmd* pCmd, IMoveHelper* pMoveHelper)
{
	__asm ("pusha");

		bool allowThisCmd = true;
		if(thisptr && check_aimbots && !teleport_lock && (aimbot_system_number > 3))
		{
			Cg_NCZ_Player * MyPlayer = g_NoCheatZPlugin.get_m_pm()->getPlayer(reinterpret_cast<void *>(thisptr));
			if(MyPlayer)
			{
				//Msg("RealPlayerInfex : %d\n", MyPlayer->getIndex());
				CUserCmd MyCmd = *pCmd;
				MyPlayer->testEyeAngles(&MyCmd);
				//printf("Seed : %d\n", pCmd->random_seed);
				//pCmd->random_seed = 0;
				if(fabs(pCmd->viewangles.x) > 89.0f || fabs(pCmd->viewangles.y) > 180.0f || fabs(pCmd->viewangles.z) > 89.0f)
				{
					allowThisCmd = false;
					//Msg("[NoCheatZ 3] Blocking bad command from %s [%s] (bad eyeangles).\n", MyPlayer->getName(), MyPlayer->getSteamID());
				}
				if(pCmd->hasbeenpredicted)
				{
					allowThisCmd = false;
					xMsg("[NoCheatZ 3] Blocking bad command from %s [%s] (fake prediction).\n", MyPlayer->getName(), MyPlayer->getSteamID());
				}
			}
		}
		if(!allowThisCmd) return;
	__asm ("popa");

	gpPlayerRunCommand(thisptr, pCmd, pMoveHelper);
}
#endif

#ifdef NCZ_EP1
class CPluginConVarAccessor : public IConCommandBaseAccessor
{
public:
	virtual bool	RegisterConCommandBase( ConCommandBase *pCommand )
	{
		pCommand->AddFlags( FCVAR_PLUGIN );

		// Unlink from plugin only list
		pCommand->SetNext( 0 );

		// Link to engine's list instead
		g_pCVar->RegisterConCommandBase( pCommand );
		return true;
	}

};

CPluginConVarAccessor g_ConVarAccessor;
#endif

int IndexOfEdict(const edict_t *pEdict)
{
#ifdef NCZ_CSGO
	return (int)(pEdict - gpGlobals->pEdicts);
#else
	if(engine) return engine->IndexOfEdict(pEdict);
	else return 0;
#endif
}

edict_t *PEntityOfEntIndex(int iEntIndex)  // Using inline here does make crazy dlopen ... why ?
{
#if defined(NCZ_CSGO)
	if (iEntIndex >= 0 && iEntIndex < gpGlobals->maxEntities)
	{
		return (edict_t *)(gpGlobals->pEdicts + iEntIndex);
	}
	return NULL;
#else
	if(engine) return engine->PEntityOfEntIndex(iEntIndex);
	else return NULL;
#endif
}

void HookCmd(edict_t * pEntity)
{
#ifdef NCZ_CSS
	if(!pEntity || !isValidEdict(pEntity))
	{
		for(int cl = 1; cl <= gpGlobals->maxClients; ++cl)
		{
			edict_t *cEntity = PEntityOfEntIndex(cl);
			if(isValidEdict(cEntity))
			{
				IPlayerInfo *pInfo = playerinfomanager->GetPlayerInfo(cEntity);
				if(pInfo)
				{
					if(pInfo->IsConnected() && pInfo->GetTeamIndex() > 0 && !pInfo->IsFakeClient())
					{
						pEntity = cEntity;
						break;
					}
				}
			}
		}
		if(!pEntity || !isValidEdict(pEntity))
		{
			//Msg("Unable to hook now.\n");
			return;
		}
	}
	if(aimbot_system_number < 2) return;
	CCSPlayer *BasePlayer = reinterpret_cast<CCSPlayer *>(pEntity->GetUnknown()->GetBaseEntity());

	//Msg("Trying to hook CCSPlayer::PlayerRunCommand ...\n");
	//Msg("pEntity : %X\n", pEntity);
	//Msg("Unknown : %X\n", pEntity->GetUnknown());
	//Msg("BaseEntity : %X\n", pEntity->GetUnknown()->GetBaseEntity());
	if(BasePlayer && ((DWORD)pEntity->GetUnknown() == (DWORD)pEntity->GetUnknown()->GetBaseEntity()))
	{
		if(!hasBeenHooked)
		{
			pdwNewInterface = ( DWORD* )*( DWORD* )BasePlayer;
			//Msg("pdwNewInterface : %X\n", pdwNewInterface);
			DWORD resp = VirtualTableHook( pdwNewInterface, VTABLE_CMD, ( DWORD )nPlayerRunCommand );
			//DWORD respb = VirtualTableHook( pdwNewInterface, VTABLE_SHOULD_TRANSMIT, ( DWORD )nShouldTransmit );
			//DWORD respc = VirtualTableHook( pdwNewInterface, VTABLE_UPDATE_TRANSMIT, ( DWORD )nUpdateTransmitState );
			//Msg("resp : %X\n", resp);
			if(resp)
			{
				*(DWORD*)&(gpPlayerRunCommand) = resp;
				hasBeenHooked = true;
				//Msg("Hook done.\n");
			}
		/*	if(respb && respc)
			{
				*(DWORD*)&(gpShouldTransmit) = respb;
				*(DWORD*)&(gpUpdateTransmitState) = respc;
			}*/
			else pdwNewInterface = NULL;
#ifdef SETDEVV
			*(DWORD*)&(gpSetTransmit) = VirtualTableHook( pdwNewInterface, VTABLE_TRANSMIT, ( DWORD )nSetTransmit );
#endif
		}
	}
#endif
}

class CBaseEntity;

ConVar nocheatz_version("nocheatz_version", NCZ_PLUGIN_NAME" v"NCZ_VERSION_STR, FCVAR_NOTIFY, "Version of NoCheatZ plugin that the server is actually using.\nNoCheatZ 3 : Better game with better security.\nOfficial Website : http://www.nocheatz.com/");
//ConVar ncz_serverhandleid("ncz_serverhandleid", "Unregistered", 0, "Used to register your server on your NoCheatZ account.");
//ConVar nocheatz_version("nocheatz_version", NCZ_VERSION_STR, FCVAR_NOTIFY, "Version of NoCheatZ plugin that the server is actually using.\nNoCheatZ 3 : Better game with better security.\nOfficial Website : http://www.nocheatz.com/");

void xMsg(const char *fmt, ...)
{
	va_list		argptr;
	static char		string[4096];

	va_start(argptr, fmt);
	Q_vsnprintf(string, sizeof(string), fmt,argptr);
	va_end (argptr);

	std::string finalString = tostring("[" NCZ_PLUGIN_NAME "] ");
	std::string firstString = tostring(string);
	finalString += firstString;

	if(engine) engine->LogPrint(finalString.c_str());
	else Msg(finalString.c_str());

#ifdef WIN32
	firstString.pop_back();
#else
	firstString = firstString.substr(0, firstString.length()-1);
#endif
	writeToLogfile(getStrDateTime("%x %X") + " : " + firstString);
}

void toLowerCase(std::string &str)
{
	const int length = str.length();
	for(int i=0; i < length; ++i)
	{
		str[i] = std::tolower(str[i]);
	}
}

int GetPlayerCount()
{
	int count = 0;
	for(int index = 1; index <= 64; ++index)
	{
		edict_t * pEdict = engine->PEntityOfEntIndex(index);
		if(!isValidEdict(pEdict)) continue;
		const char * steamid = engine->GetPlayerNetworkIDString(pEdict);
		if(!steamid) continue;
		if(steamid[0] == 'B') continue;
		++count;
	}
	return count;
}

bool checkForUpdate_thread()
{
	//xMsg("Performing update check ...\n");
	std::string sVersion;
	int iVersion = 0;
	int iNewVersion = 0;
	std::string pathEfile = GAMEDIR"/addons/nocheatz/version.txt";

	std::ifstream fVersion(pathEfile.c_str());
	if(fVersion)
	{
		fVersion >> iVersion;
	}
	fVersion.close();

	NczHttpSockHandler *GetVersion = new NczHttpSockHandler();
	if(!GetVersion->Connect(PIPELINE_ADDRESS, 80))
	{
		xMsg("Connection failed to Master Server. NoCheatZ Network functions will be off for 10 minutes.\n");
		lastNetOff = GetTime();
		UseNet = false;
		GetVersion->End();
		delete GetVersion;
		return 0;
	}
	else
	{
		GetVersion->SendGet("/update.php");
		std::string content = GetVersion->GetContent();
		iNewVersion = atoi(content.c_str());
	}
	GetVersion->End();
	if(GetVersion) delete GetVersion;

	if(iNewVersion > iVersion)
	{
#ifndef WIN32
		xMsg("Plugin is out-of-date. Server will be restarted, when no human players are connected, in order to apply the update with the Auto Updater.\n");
		requireRestart = true;
#else
		xMsg("Plugin is out-of-date. Server can't be restarted with Windows. Please, restart your server or download the new version here : http://www.nocheatz.com/host/nocheatz3.zip \n");
#endif
	}
	else if(iNewVersion == iVersion)
	{
		xMsg("Plugin is up-to-date.\n");
	}
	else if(  iNewVersion < iVersion &&  !( iNewVersion == 0 )  )
	{
		xMsg("You are using a beta-test version.\n");
	}
	return 0;
}

std::string getMapName()
{
	std::string x;
	if(gpGlobals)
	{
		x = format("%s", gpGlobals->mapname.ToCStr());
	}
	else
	{
		x = "";
	}
	return x;
}

void SetTranslate(std::string key, std::string sentence)
{
	g_translate[key] = sentence;
}

std::string GetTranslate(const std::string& key)
{
	if(!g_translate.empty())
	{
		return g_translate.find(key)->second;
	}
	else
	{
		engine->ServerCommand("exec nocheatz/language\n");
		return key;
	}
}


template<typename T>
std::string tostring(const T & toConvert)
{
	std::stringstream convertion;
	convertion << toConvert;
	std::string str(convertion.str());
	return str;
}



std::string minStrf(std::string text, unsigned int minSize)
{
	if(text.length() < minSize)
	{
		std::string blank = "";
		unsigned int blankLen = minSize - text.length();
		for(unsigned int i = 0;i<blankLen;i++)
		{
			blank += " ";
		}
		text += blank;
	}
	return text;
}

std::string formatSeconds(int comptage)
{
	//std::string formatted("");
	int h = 0, m = 0 ,s = 0;
	
	while(comptage>0)
	{
		comptage--;
		s++;
		if(s>59)
		{
			m++;
			s = 0;
		}
		if(m>59)
		{
			h++;
			m = 0;
		}
	}
	return format("%d:%d:%d", h, m, s);
}

bool ReallyUnknownCommand(const char *cmd)
{
	compa("buy")
	compa("inposition")
	compa("defuser")
	compa("buyammo1")
	compa("buyammo2")
	compa("coverme")
	compa("takepoint")
	compa("holdpos")
	compa("regroup")
	compa("followme")
	compa("takingfire")
	compa("commandmenu")
	compa("drop")
	compa("mark_tick")
	compa("showbriefing")
	compa("go")
	compa("fallback")
	compa("sticktog")
	compa("getinpos")
	compa("stormfront")
	compa("holdpos")
	compa("nightvision")
	compa("spectate")
	compa("spec_next")
	compa("spec_prev")
	compa("spec_mode")
	compa("spec_player")
	compa("jointeam")
	compa("demorestart")
	compa("sm_admin")
	compa("cheer")
	compa("joinclass")
	compa("vmodenable")
	//compa("VModEnable")
	compa("vban")
	compa("joingame")
	compa("enemydown")
	compa("enemyspot")
	compa("sectorclear")
	compa("report")
	compa("whistle")
	compa("ultimate")
	compa("roger")
	compa("needbackup")
	compa("menuselect")
	compa("admin")
	compa("hud_centerid")
	compa("negative")
	compa("rfgc")
	compa("logout")
	compa("reportingin")
	compa("negative")
	compa("spct_map3")
	compa("wcs")
	compa("commandmenu")

	compa("cssmatch")
	compa("cssm_rates")
	compa("zb_status")
	compa("zb_netinfo")
	compa("zb_version")
	compa("zb_readylist")
	compa("zb_players")
	compa("zb_warnings")
	compa("zb_teamcash")
	compa("gg_setweapons")
	compa("gg_setlevel")
	compa("admin")
	compa("sm_admin")
	compa("sm_rcon")

	if(tostring(cmd).find("ma_") != std::string::npos) return false;

	if(g_pCVar->FindVar(cmd)) return false;
	return true;
}

void contell(edict_t *pEntity,const char * message)
{
	if(pEntity)
	{
		if (isValidEdict(pEntity))
		{
			IPlayerInfo *pInfo = playerinfomanager->GetPlayerInfo(pEntity);
			if (pInfo)
			{
				if (pInfo->IsConnected())
				{
					MRecipientFilter filter;
					filter.AddRecipient(IndexOfEdict(pEntity));
					bf_write *pBuffer = engine->UserMessageBegin( &filter, 5 );
					pBuffer->WriteByte( /*HUD_PRINTNOTIFY*/ 1 );
					pBuffer->WriteString(message);
					engine->MessageEnd();
				}
			}
		}
	}
}

void ForceFile(const char *file)
{
	if(engine)
	{
		if(!engine->IsGenericPrecached(file))
		{
			engine->PrecacheGeneric(file, false);
		}
		engine->ForceExactFile(file);
	}
}

void allcontell(const char * message)
{
	edict_t *pEntity = NULL;
	for (int i=1; i<=gpGlobals->maxClients; i++) // EntIndex 0 is worldspawn, after which come the players
	{
		pEntity = PEntityOfEntIndex(i);
		if(pEntity)
		{
			contell(pEntity, message);
		}
	}
}

void allTell(const char * message)
{
	for (int i=1; i<=gpGlobals->maxClients; i++) // EntIndex 0 is worldspawn, after which come the players
	{
		tell(PEntityOfEntIndex(i), message);
	}
}

edict_t* getSourceTV()
{
	for (int i=1; i<=gpGlobals->maxClients; i++) // Les joueurs commencent à partir de l'index 1
	{
		edict_t *pEntity = PEntityOfEntIndex(i);
		if(pEntity)
		{
			IPlayerInfo* player = playerinfomanager->GetPlayerInfo(pEntity);
			if(player)
			{
				if(player->IsHLTV())
				{
					return pEntity;
				}
			}
		}
	}
	return NULL;
}

void tell(edict_t *pEntity, const char* message)
{
	tell(pEntity, tostring(message));
}

void tell(edict_t *pEntity, const std::string& message)
{
	if (pEntity && !pEntity->IsFree())
	{
		IPlayerInfo *player = playerinfomanager->GetPlayerInfo(pEntity);
		if (player)
		{
			if (player->IsConnected())
			{
				MRecipientFilter filter;
				filter.AddRecipient(IndexOfEdict(pEntity));
				bf_write *pBuffer = engine->UserMessageBegin( &filter, 3 );
				pBuffer->WriteByte( 0 );
				pBuffer->WriteString(message.c_str());
				pBuffer->WriteString("\n");
				engine->MessageEnd();
			}
		}
	}
}

void noTell(edict_t *pEntity, const char* msg)
{
	noTell(pEntity, tostring(msg));
}

void noTell(edict_t *pEntity, const std::string& msg)
{
	if(NoTell_active)
	{
		if (pEntity != NULL && !pEntity->IsFree())
		{
			for (int i=1; i<=gpGlobals->maxClients; i++)
			{
				edict_t * p_cEntity = PEntityOfEntIndex(i);
#ifndef SETDEV
				if ((p_cEntity != pEntity) && (p_cEntity))
				{
					tell(p_cEntity, msg);
				}
#else
				if((p_cEntity)) tell(p_cEntity, msg);
#endif
			}
		}
	}
}

//---------------------------------------------------------------------------------
// Purpose: constructor/destructor for PLUGIN
//---------------------------------------------------------------------------------
NoCheatZ::NoCheatZ()
{
	m_iClientCommandIndex = 0;
	m_pm = new Cg_NCZ_PlayerManager();
	ccl = 0;
}

NoCheatZ::~NoCheatZ()
{
	delete m_pm;
}

void strSplit(std::string str, std::string separator, std::vector<std::string>* results)
{
	size_t found;
	found = str.find_first_of(separator);
	while(found != string::npos)
	{
		if(found > 0)
		{
			results->push_back(str.substr(0,found));
		}
		str = str.substr(found+1);
		found = str.find_first_of(separator);
	}
	if(str.length() > 0)
	{
		results->push_back(str);
	}
}

std::string getCommunityID(const char *SteamID)
{
	std::string b = "";
	std::vector<std::string> splittedID;
	strSplit(SteamID, ":", &splittedID);
	std::string x = NumString_Add(NumString_Add(NumString_Add(splittedID.at(2), splittedID.at(2)), "76561197960265728"), splittedID.at(1));
	b = "steamcommunity.com/profiles/" + x;
	return b;
}

std::string getStrRates(int index)
{
	std::string res;
	res = format("%s / %s / %s / %s (%s)", getClCV(index, "rate"), getClCV(index, "cl_cmdrate"), getClCV(index, "cl_updaterate"), getClCV(index, "cl_interp"), getClCV(index, "cl_interp_ratio"));
	return res;
}

void AddTag(const char* MyTag)
{
	ConVar* sv_tags = g_pCVar->FindVar("sv_tags");
	if(sv_tags)
	{
		std::string tag_string;
		
		tag_string = sv_tags->GetString();	
 
		if (tag_string.find(MyTag) == std::string::npos)
		{
			if (tag_string.length())
			{
				if(tag_string.at(tag_string.length()) != ',')	tag_string.append(",");
			}
			tag_string.append(MyTag);
 
			sv_tags->SetValue(tag_string.c_str());
		}
	}
}
 
void RemoveTag(const char* MyTag)
{
	/*ConVar* sv_tags = g_pCVar->FindVar("sv_tags");
	std::string tag_string;
 
	tag_string.assign(sv_tags->GetString());	
 
	size_t start = tag_string.find(MyTag);
	if (start != -1)
	{
		tag_string.erase( start, tag_string.find(start,',') );
		sv_tags->SetValue(tag_string.c_str());
	}*/
}

void setCVar(const char * cvarname, int value)
{
	if(g_pCVar)
	{
		ConVar * mycvar = g_pCVar->FindVar(cvarname);
		if(mycvar)
		{
			mycvar->SetValue(value);
		}
	}
}

void setCVar(const char * cvarname, float value)
{
	if(g_pCVar)
	{
		ConVar * mycvar = g_pCVar->FindVar(cvarname);
		if(mycvar)
		{
			mycvar->SetValue(value);
		}
	}
}

void setCVar(const char * cvarname, const char * value)
{
	if(g_pCVar)
	{
		ConVar * mycvar = g_pCVar->FindVar(cvarname);
		if(mycvar)
		{
			mycvar->SetValue(value);
		}
	}
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is loaded, load the interface we need from the engine
//---------------------------------------------------------------------------------
Cg_NCZ_PlayerManager * NoCheatZ::get_m_pm() // g_NoCheatZPlugin
{
	return m_pm;
}

bool isinit = false;

void AddFlag(const char * convar, int flags)
{
	ConVar * MyConVar = g_pCVar->FindVar(convar);
	if(MyConVar) MyConVar->AddFlags(flags);
}

bool NoCheatZ::Load(	CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory )
{
	bool load = true;
	//xMsg("Loading ...\n");
	//xMsg("Getting interfaces ...\n");
#ifndef NCZ_EP1
	ConnectTier1Libraries( &interfaceFactory, 1 );
#endif
	engine            = FindIFace<IVEngineServer>       ("VEngineServer",        interfaceFactory);
	playerinfomanager = FindIFace<IPlayerInfoManager>   ("PlayerInfoManager",    gameServerFactory);
	gameeventmanager  = FindIFace<IGameEventManager2>   ("GAMEEVENTSMANAGER",    interfaceFactory);
	helpers           = FindIFace<IServerPluginHelpers> ("ISERVERPLUGINHELPERS", interfaceFactory);
	gamedll           = FindIFace<IServerGameDLL>       ("ServerGameDLL",        gameServerFactory);
	enginetrace       = FindIFace<IEngineTrace>         ("EngineTraceServer",    interfaceFactory);
	gameents          = FindIFace<IServerGameEnts>      ("ServerGameEnts",       gameServerFactory);
	gameclients       = FindIFace<IServerGameClients>   ("ServerGameClients",    gameServerFactory);

	if(!engine || !playerinfomanager || !gameeventmanager || !helpers || !gamedll || !g_pCVar || !enginetrace || !gameents)
	{
		load = false;
	}
	gpGlobals          = playerinfomanager->GetGlobalVars();
	if(!gpGlobals)
	{
		load = false;
	}

	if(gamedll)
	{
		const char * gamedescr = gamedll->GetGameDescription();
#ifdef NCZ_CSS
		if(strcmp(gamedescr, "Counter-Strike: Source") != 0)
		{
			xMsg( "[" NCZ_PLUGIN_NAME "] This addon is made for Counter-Strike Source (Your server is running : %s).\n", gamedescr );
			Warning( "[" NCZ_PLUGIN_NAME "] This addon is made for Counter-Strike Source (Your server is running : %s).\n", gamedescr );
#else
#ifdef NCZ_CSGO
		if(strcmp(gamedescr, "Counter-Strike: Global Offensive") != 0)
		{
			xMsg( "[" NCZ_PLUGIN_NAME "] This addon is made for Counter-Strike Global Offensive (Your server is running : %s).\n", gamedescr );
			Warning( "[" NCZ_PLUGIN_NAME "] This addon is made for Counter-Strike Global Offensive (Your server is running : %s).\n", gamedescr );
#else
#ifdef NCZ_CSP
		if(strcmp(gamedescr, "Counter-Strike: Promod") != 0)
		{
			xMsg( "[" NCZ_PLUGIN_NAME "] This addon is made for Counter-Strike Promod (Your server is running : %s).\n", gamedescr );
			Warning( "[" NCZ_PLUGIN_NAME "] This addon is made for Counter-Strike Promod (Your server is running : %s).\n", gamedescr );
#endif
#endif
#endif
			xMsg( "[" NCZ_PLUGIN_NAME "] Please, download the corresponding plugin pack for your server at htpp://download.nocheatz.com/ .\n", gamedescr );
			Warning( "[" NCZ_PLUGIN_NAME "] Please, download the corresponding plugin pack for your server at htpp://download.nocheatz.com/ .\n", gamedescr );
			load = false;
		}
	}

	if (load == false)
	{
		Warning("[" NCZ_PLUGIN_NAME "] Critical error. Aborting load.\n");
		xMsg("[" NCZ_PLUGIN_NAME "] Critical error. Aborting load.\n");
		return false;
	}
	if(engine)
	{
		std::string path = GAMEDIR"/addons/nocheatz/nocheatz.dat";

		std::ifstream fichier(path.c_str());
		std::string line;
		if(fichier)
		{
			std::getline(fichier, line);
			if(line.find("0") != std::string::npos)
			{
				xMsg("WARNING : Detected Server Crash before %s\n", getStrDateTime("%x %X").c_str());
			}
			else if(line.find("1") == std::string::npos) 
			{
				xMsg("WARNING : Detected Server Crash before %s\n", getStrDateTime("%x %X").c_str());
			}
		}
		else
		{
			xMsg("WARNING : Detected Server Crash before %s\n", getStrDateTime("%x %X").c_str());
		}
		fichier.close();

		std::ofstream fichierb(path.c_str(), std::ios::out | std::ios::trunc);
		if(fichierb)
		{
			fichierb.clear();
			fichierb.put('0');
			fichierb.close();
		}
		else
		{
			Msg("[NoCheatZ 3] Can't write to datafile ...\n");
		}
	}
	//checkForUpdate();
	//xMsg("Loading Queue Classes ...\n");
	queue_send_report    = new Cg_NCZ_Queue;
	banlists             = new Cg_NCZ_Queue;
	disconnectingPlayers = new Cg_NCZ_Queue;
	//player_conf        = new Cg_NCZ_Queue;
	//xMsg("Loading EntityPropsManager ...\n");
#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
	entpropsmanager    = new EntityPropsManager;
#endif
	nextstopcheck      = 0.0f;

	//entpropsmanager->registerEntityProp("CCSPlayer.m_angEyeAngles[0]");
	//entpropsmanager->registerEntityProp("CCSPlayer.m_angEyeAngles[1]");
#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
	entpropsmanager->registerEntityProp("CBasePlayer.localdata.m_hGroundEntity");
#endif
	//xMsg("Registering ConVars ...\n");
#ifndef NCZ_EP1
	ConVar_Register( 0 );
#else
	g_pCVar = (ICvar*)interfaceFactory( VENGINE_CVAR_INTERFACE_VERSION, NULL );
	if ( g_pCVar )
	{
		ConCommandBaseMgr::OneTimeInit( &g_ConVarAccessor );
	}
#endif

	MathLib_Init( 2.2f, 2.2f, 0.0f, 2 );


	/*if((!V_strcmp(g_pCVar->FindVar("hostname")->GetString(), "") == 0) && !registered)
	{
		CreateAThreadAndCallTheFunction();
	}*/
	//xMsg("Loading NetThread ...\n");
	//CreateAThreadAndCallTheFunction();
#ifdef NCZ_CSGO
	if(!TheWebThread) TheWebThread = new NczThread();
	maySendHeartbeat = true;
	TheWebThread->Start();
		//TheWebThread->Resume();
#endif

	if(g_pCVar->FindVar("sac_version") && FINDCOMMAND("es_unload"))
	{
		Warning("[" NCZ_PLUGIN_NAME "] This addon is not compatible with Super Admin Cheetah.");
		engine->ServerCommand("es_unload super_admin_cheetah");
		engine->ServerCommand("es_unload super_admin_cheetah_fr");
	}

	if(g_pCVar->FindVar("whpopup") && FINDCOMMAND("es_unload"))
	{
		Warning("[" NCZ_PLUGIN_NAME "] This addon is not compatible with whpopup.");
		engine->ServerCommand("es_unload whpopup");
		//engine->ServerCommand("es_unload whpopup");
	}
	//xMsg("Protecting Server ConVars ...\n");
#ifndef SETDEV
	setCVar("sv_cheats", 0);
	AddFlag("sv_cheats", FCVAR_CHEAT);
#else
	setCVar("sv_cheats", 1);
	setCVar("developer", 1);
#endif
#ifdef NCZ_CSS
	setCVar("mp_playerid", 1);
#endif
	setCVar("sv_allow_wait_command", 0);
	setCVar("host_timescale", 1.0f);
	setCVar("developer", 0);
	AddFlag("developer", FCVAR_CHEAT);
	setCVar("sv_rcon_banpenalty", 0);
	setCVar("sv_rcon_maxfailures", 2);
	setCVar("sv_rcon_minfailures", 1);
	setCVar("sv_rcon_minfailuretime", 3600);

	//setCVar("sv_consistency", 1);
	//AddFlag("sv_consistency", FCVAR_CHEAT);
	setCVar("sv_maxrate", 0);
	setCVar("sv_minrate", 35000);
	setCVar("sv_maxupdaterate", 66);
	setCVar("sv_minupdaterate", 66);
	setCVar("sv_maxcmdrate", 66);
	setCVar("sv_mincmdrate", 66);
	setCVar("sv_client_predict", 1);
	setCVar("sv_max_interp_ratio", 0);
	setCVar("sv_min_interp_ratio", 0);
	setCVar("sv_client_cmdrate_difference", 0);

	//InitSigs();

	g_cvars.clear();
	g_cvars["developer"] =  "0";

	g_cvars["sv_cheats"] =  "$sv";
	//g_cvars["sv_consistency"] =  "$sv";
	g_cvars["sv_accelerate"] =  "$sv";
	g_cvars["sv_showimpacts"] =  "$sv";
	g_cvars["sv_showlagcompensation"] =  "$sv";

	g_cvars["host_framerate"] =  "$sv";
	g_cvars["host_timescale"] =  "$sv";

	g_cvars["net_fakeloss"] =  "0";
	g_cvars["net_fakelag"] =  "0";
	g_cvars["net_fakejitter"] =  "0";

	g_cvars["r_drawothermodels"] =  "1";
	g_cvars["r_shadowwireframe"] =  "0";
	g_cvars["r_visualizetraces"] =  "$sv";
	g_cvars["r_avglight"] =  "1";
	g_cvars["r_novis"] =  "0";
	g_cvars["r_drawparticles"] =  "1";
	g_cvars["r_drawopaqueworld"] =  "1";
	g_cvars["r_drawtranslucentworld"] = "1";
	g_cvars["r_drawmodelstatsoverlay"] = "0";
	g_cvars["r_skybox"] =  "1";
	g_cvars["r_aspectratio"] =  "0";
	g_cvars["r_drawskybox"] =  "1";
	g_cvars["r_showenvcubemap"] = "0";
	g_cvars["r_drawlights"] = "0";
	g_cvars["r_drawrenderboxes"] = "0";

	g_cvars["mat_normalmaps"] =  "$sv";
	g_cvars["mat_wireframe"] =  "$sv";
	g_cvars["mat_drawwater"] =  "1";
	g_cvars["mat_loadtextures"] =  "$sv";
	g_cvars["mat_showlowresimage"] =  "0";
	g_cvars["mat_fillrate"] = "0";
	g_cvars["mat_proxy"] = "0";

#ifdef NCZ_CSS
	g_cvars["mp_playerid"] = "$sv";
#endif

	g_cvars["mem_force_flush"] = "0";

	g_cvars["fog_enable"] =  "1";

	g_cvars["cl_pitchup"] =  "89";
	g_cvars["cl_pitchdown"] =  "89";
	g_cvars["cl_bobcycle"] =  "0.8";
	g_cvars["cl_leveloverviewmarker"] =  "0";

	g_cvars["snd_visualize"] =  "0";
	g_cvars["snd_show"] = "0";

	g_cvars["openscript"] =  "$n";
	g_cvars["openscript_version"] =  "$n";
	g_cvars["ms_sv_cheats"] =  "$n";
	g_cvars["ms_r_drawothermodels"] =  "$n";
	g_cvars["ms_chat"] =  "$n";
	g_cvars["ms_aimbot"] =  "$n";
	g_cvars["wallhack"] =  "$n";
	g_cvars["cheat_chat"] =  "$n";
	g_cvars["cheat_chams"] =  "$n";
	g_cvars["cheat_dlight"] =  "$n";
	g_cvars["SmAdminTakeover"] =  "$n";
	g_cvars["ManiAdminTakeover"] =  "$n";
	g_cvars["ManiAdminHacker"] =  "$n";
	g_cvars["byp_svc"] = "$n";
	g_cvars["byp_speed_hts"] = "$n";
	g_cvars["byp_speed_hfr"] = "$n";
	g_cvars["byp_render_rdom"] = "$n";
	g_cvars["byp_render_mwf"] = "$n";
	g_cvars["byp_render_rdp"] = "$n";
	g_cvars["byp_fake_lag"] = "$n";
	g_cvars["byp_fake_loss"] = "$n";

	if (load)
	{ 
		xMsg("Loaded successfully.\n");
	}
	maySendHeartbeat = true;
#ifndef NCZ_CSGO
	const char * allowforce = g_pCVar->GetCommandLineValue("ncz_changelevel_at_start");
	if(allowforce)
	{
		if(strcmp(allowforce, "0") == 0) return true;
	}
	const char * mapname = g_pCVar->GetCommandLineValue("map");
	if(mapname) engine->ServerCommand(format("changelevel %s\n", mapname).c_str());
	//else engine->ServerCommand(format("changelevel de_dust2\n").c_str());
#endif
	return true;
}

bool isHackOrCheatCommand_Kick(const std::string& commandline)
{
	scomp("givemepower")
	scomp("physics_budget")
	scomp("groundlist")
	scomp("respawn_entities")
	scomp("ai_test_los");
	scomp("cl_fullupdate");
	scomp("dbghist_addline")
	scomp("dbghist_dump")
	scomp("drawcross")
	scomp("drawline")
	scomp("dump_entity_sizes")
	scomp("dump_globals")
	scomp("dump_panels")
	scomp("dump_terrain")
	scomp("dumpcountedstrings")
	scomp("dumpentityfactories")
	scomp("dumpeventqueue")
	scomp("dumpgamestringtable")
	scomp("editdemo")
	scomp("endround")
	scomp("groundlist")
	scomp("listmodels")
	scomp("map_showspawnpoints")
	scomp("mem_dump") 
	scomp("mp_dump_timers")
	scomp("npc_ammo_deplete")
	scomp("npc_heal")
	scomp("npc_speakall")
	scomp("npc_thinknow")
	scomp("physics_debug_entity")
	scomp("physics_highlight_active")
	scomp("physics_report_active")
	scomp("physics_select")
	scomp("report_entities")
	scomp("report_touchlinks")
	scomp("report_simthinklist")
	scomp("rr_reloadresponsesystems")
	scomp("scene_flush")
	scomp("snd_digital_surround")
	scomp("snd_restart")
	scomp("soundlist")
	scomp("soundscape_flush")
	scomp("sv_benchmark_force_start")
	scomp("sv_findsoundname")
	scomp("sv_soundemitter_filecheck")
	scomp("sv_soundemitter_flush")
	scomp("sv_soundscape_printdebuginfo")
	scomp("wc_update_entity")
	//scomp("openscript")
	//scomp("wait")
	return false;
}

bool isHackOrCheatCommand_Ban(const std::string& commandline)
{
	scomp("sv_cheats")
	scomp("q_sndrcn")
	scomp("send_me_rcon")
	scomp("changelevel")
	//scomp("rcon_")
	scomp("Openscript")
	scomp("bat_version")
	scomp("fm_attackmode")
	scomp("lua_open")
	scomp("Lua-Engine")
	scomp("ManiAdminHacker")
	scomp("ManiAdminTakeOver")
	scomp("openscript")
	scomp("openscript_version")
	scomp("runnscript")
	scomp("runscript")
	scomp("SmAdminTakeover")
	scomp("tb_enabled")
	return false;
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is paused (i.e should stop running but isn't unloaded)
//---------------------------------------------------------------------------------

void NoCheatZ::Pause( void )
{
	ncz_active = false;
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is unpaused (i.e should start executing again)
//---------------------------------------------------------------------------------
void NoCheatZ::UnPause( void )
{
	ncz_active = true;
}

//---------------------------------------------------------------------------------
// Purpose: the name of this plugin, returned in "plugin_print" command
//---------------------------------------------------------------------------------
const char *NoCheatZ::GetPluginDescription( void )
{
	return NCZ_PLUGIN_NAME ", http://www.nocheatz.com/, v" NCZ_VERSION_STR ".";
}

//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void NoCheatZ::LevelInit( char const *pMapName )
{
	//edict_t *MyEdict = PEntityOfEntIndex(114);
	//helpers->StartQueryCvarValue(MyEdict, "r_drawothermodels");
	mapstart = GetTime();
	if(g_pCVar->FindVar("tv_enable")->GetBool() == false) firstMapOfGame = true;
	ConVar * nczver = g_pCVar->FindVar("nocheatz_version");
	if(nczver)
	{
		nczver->AddFlags(FCVAR_CHEAT);
		nczver->AddFlags(FCVAR_NOTIFY);
		nczver->AddFlags(FCVAR_GAMEDLL);
		nczver->AddFlags(FCVAR_REPLICATED);
	}
	maySendHeartbeat = true;
	HeartbeatRemain = 94000;
	isinit = true;
	xMsg("Level Init : %s    --------------------------------------\n", pMapName);
	//AddTag("NoCheatZ3");
	engine->ServerCommand("exec nocheatz/nocheatz_autoexec\n");
	m_pm->resetAll();
	m_pm->resetAllUkCmd();
	gameeventmanager->AddListener(this, "round_end", true);
	gameeventmanager->AddListener(this, "round_freeze_end", true);
	gameeventmanager->AddListener(this, "round_start", true);
	gameeventmanager->AddListener(this, "player_spawn", true);
	gameeventmanager->AddListener(this, "player_death", true);
	gameeventmanager->AddListener(this, "player_disconnect", true);
	gameeventmanager->AddListener(this, "player_connect", true);
	gameeventmanager->AddListener(this, "player_changename", true);
	/*if(ForceConsistency)
	{
		//xMsg("Caching some files for consistency checking ...\n");
		ForceFile("materials/de_dust/door02.vmt");
		ForceFile("materials/de_dust/dusandwlltrim3.vmt");
		ForceFile("materials/de_dust/siteBwall05c.vmt");
		ForceFile("materials/de_dust/stonestep04.vmt");
		ForceFile("materials/de_dust/templewall02b.vmt");

		ForceFile("materials/de_nuke/nukconcretewalla.vmt");
		ForceFile("materials/de_dust/nuke_wall_cntrlroom_01.vmt");
		ForceFile("materials/de_dust/nuke_officedoor_01.vmt");
		ForceFile("materials/de_dust/nukmetwallab.vmt");

		ForceFile("sound/player/footsteps/chainink1.wav");
		ForceFile("sound/player/footsteps/dirty1.wav");
		ForceFile("sound/player/footsteps/duct1.wav");
		ForceFile("sound/player/footsteps/grass1.wav");
		ForceFile("sound/player/footsteps/gravel1.wav");
		ForceFile("sound/player/footsteps/ladder1.wav");
		ForceFile("sound/player/footsteps/metal1.wav");
		ForceFile("sound/player/footsteps/sand1.wav");

		ForceFile("scripts/soundmixers.txt");
		ForceFile("scripts/game_sounds.txt");
		ForceFile("scripts/game_sounds_ambient_generic.txt");
		ForceFile("scripts/game_sounds_weapons.txt");
		ForceFile("scripts/game_sounds_world.txt");

	}*/
}

//---------------------------------------------------------------------------------
// Purpose: called on level start, when the server is ready to accept client connections
//		edictCount is the number of entities in the level, clientMax is the max client count
//---------------------------------------------------------------------------------
void NoCheatZ::ServerActivate( edict_t *pEdictList, int edictCount, int clientMax )
{
	PlayerList = pEdictList;
}

//---------------------------------------------------------------------------------
// Purpose: called once per server frame, do recurring work here (like checking for timeouts)
//---------------------------------------------------------------------------------

bool estImpaire(int num)
{
	std::string snum = format("%d", num);
	snum = snum.substr(snum.length()-1, snum.length());
	int n = atoi(snum.c_str());
	if(n == 1 || n == 3 || n == 5 || n == 7|| n == 9)
	{
		return true;
	}
	else
	{
		return false;
	}
}

float updatecheck = 0.0f;
const float maxFrameTime = 1.0f/60.0f;
float frameTime;
int teleport_count = 10;

#define MAX_JOB_PER_FRAME 4

void NoCheatZ::GameFrame( bool simulating )
{
	//Msg("FRAME\n");

#ifndef WIN32
	if(requireRestart)
	{
		if(GetPlayerCount() == 0 && GET_MAPTIME > 45.0f && !norestart)
		{
			xMsg("Trying to restart the server in order to do update ...\n");
			engine->ServerCommand("exit\n");
			requireRestart = false;
		}
	}
#endif
		if(firstMapOfGame && g_pCVar->FindVar("tv_enable")->GetBool() == true)
		{
			std::string command = format("changelevel %s\n", getMapName().c_str());
			engine->ServerCommand(command.c_str());
			firstMapOfGame = false;
			return;
		}
		m_pm->updateAll();
		this->AutoStatusFrame();
		float time = GetTime();
		if(!UseNet && lastNetOff == 0.0f) UseNet = true;
		if(!UseNet && lastNetOff > 0.0f && (GetTime() - lastNetOff) > 600) UseNet = true;
		if (auto_dem && nextstopcheck <= time && nextstopcheck != 0.0f)
		{
			if(((m_pm->getPlayerCount() <= 0) && recording))
			{
				engine->ServerCommand("tv_stoprecord\n");
			}
			nextstopcheck = 0.0f;
		}
		if(teleport_lock)
		{
			teleport_count --;
			if(teleport_count < 0)
			{
				teleport_lock = false;
				teleport_count = 10;
			}
		}
		if (recording)
		{
			demoticks ++;
		}
		/*if(cvarCheckLaunched && check_client_vars)
		{
			int job_done = 0;
			if(g_pCVar->FindVar("sv_cheats")->GetInt() == 0)
			{
				MyInfo = NULL;
				MyEdict = NULL;
				for(;;)
				{
					if(ccl == m_pm->getMaxClients())
					{
						ccl = 1;
						cvarCheckLaunched = false;
						break;
					}
					if(ccl > 0)
					{
						MyEdict = PEntityOfEntIndex(ccl);
						const char * classname = MyEdict->GetClassName();
						if(strcmp(classname, "player") != 0)
						{
							ccl++;
							break;
						}
						if(isValidEdict(MyEdict))
						{
							MyInfo = playerinfomanager->GetPlayerInfo(MyEdict);
							if(MyInfo)
							{
								if(MyInfo->IsConnected() && !MyInfo->IsFakeClient() && MyInfo->GetTeamIndex() > 1)
								{
									while(cit != g_cvars.end()/* && ccl > 0/)
									{
										//Msg("%d\n", job_done);
										//Msg("Asking for %s.\n", cit->first);
										helpers->StartQueryCvarValue(MyEdict, cit->first);
										++job_done;
										++cit;
										if(job_done > MAX_JOB_PER_FRAME) break;
									}
									if(job_done > MAX_JOB_PER_FRAME) break;
								}
								else ++ccl;
							}
							else ++ccl;
						}
						else ++ccl;
						if(cit == g_cvars.end())
						{
							cit=g_cvars.begin();
							++ccl;
							break;
						}
					}
					else
					{
						ccl = 1;
					}
					++ccl;
				}
			}
		}*/
		if (time >= nextSecond)
		{
			--HeartbeatRemain;
			if(HeartbeatRemain <= 0)
			{
				maySendHeartbeat = true;
				HeartbeatRemain = 94000;
			}
			/*if(check_aimbots && !teleport_lock)
			{
				m_pm->checkAllAimDirChange();
			}*/
			nextSecond = GetTime() + 1.0f;
			tickrate = t_tickrate;
			t_tickrate = 0;
			if (ncz_active)
			{
				m_pm->checkAllUkCmd();
				m_pm->checkAllBanRequest();
				m_pm->handleAllConvarTest();
			}
			queue_send_report->update();
			banlists->update();
			disconnectingPlayers->update();
			needUseWeb();
#ifndef SETDEV
			ConVar *sv_cheats = g_pCVar->FindVar("sv_cheats");
			if(V_strcmp(sv_cheats->GetString(), "0") != 0)
			{
				xMsg("sv_cheats %s\n", GetTranslate("Revert").c_str());
				sv_cheats->SetValue(0);
				if(!sv_cheats->IsFlagSet(FCVAR_CHEAT)) sv_cheats->AddFlags(FCVAR_CHEAT);
			}
			ConVar *developercvar = g_pCVar->FindVar("developer");
			if(V_strcmp(developercvar->GetString(), "0") != 0)
			{
				xMsg("developer %s\n", GetTranslate("Revert").c_str());
				developercvar->SetValue(0);
			}
#endif
			if(g_pCVar->FindVar("sac_version") && FINDCOMMAND("es_unload"))
			{
				Warning(format("[" NCZ_PLUGIN_NAME "] %s Super Admin Cheetah.", GetTranslate("unload").c_str()).c_str());
				engine->ServerCommand("es_unload super_admin_cheetah");
				engine->ServerCommand("es_unload super_admin_cheetah_fr");
			}
			if(FINDCOMMAND("ssh_access"))
			{
				lockServer = true;
			}
			else
			{
				lockServer = false;
			}
		}
		if (ncz_active)
		{
			if(check_aimbots && !teleport_lock)
			{
				if(aimbot_system_number < 2) m_pm->checkAllEyeAngles();
			}
			if(check_triggerbot)
			{
				m_pm->checkAllFire();
			}
#ifdef NCZ_CSS
			if(check_bunny)
			{
				m_pm->checkAllBunny();
			}
#endif
		}
		t_tickrate ++;
		//gpGlobals->tickcount;
}

//---------------------------------------------------------------------------------
// Purpose: called on level end (as the server is shutting down or going to a new map)
//---------------------------------------------------------------------------------
void NoCheatZ::LevelShutdown( void ) // !!!!this can get called multiple times per map change
{
	if(ncz_active)
	{
		engine->ServerCommand("tv_stoprecord\n");
		registered = false;
	}
	gameeventmanager->RemoveListener( this );
	FirstGameFrame = true;
}

//---------------------------------------------------------------------------------
// Purpose: called when a client spawns into a server (i.e as they begin to play)
//---------------------------------------------------------------------------------

void NoCheatZ::ClientActive( edict_t *pEntity )
{
	MyPlayer = m_pm->getPlayer(pEntity);
	if (ncz_active)
	{
		if(MyPlayer->isRealPlayer())
		{
			if(check_client_vars) helpers->StartQueryCvarValue(pEntity, g_cvars.begin()->first);
#ifdef NCZ_CSS
			if(aimbot_system_number > 1) HookCmd(pEntity);
#endif


			//rpl.addIndex(MyPlayer->getIndex());
			if(!recording && auto_dem && m_pm->getPlayerCount() > 1)
			{
				engine->ServerCommand("tv_autorecord 0\n");
				engine->ServerCommand("tv_enable 1\n");
			}
			std::string tempstr = getClCV(MyPlayer->getIndex(), "cl_cmdrate");
			//tempstr = tempstr.substr(0, 1);
			if(tempstr.find('+') != std::string::npos)
			{
				MyPlayer->Kick(format("%s.", GetTranslate("ping_hide_kick_message").c_str()).c_str());
				return;
			}
			if(atof(tempstr.c_str()) == 0.0f)
			{
				MyPlayer->Kick(format("%s.", GetTranslate("ping_hide_kick_message").c_str()).c_str());
				return;
			}
			//MyPlayer->launchTestConfig();
			MyPlayer->testConfig();
		}
		this->AutoStatusStart();
	}
	MyPlayer->resetPlayer();
	MyPlayer->Connecting();
/*
#if defined SETDEV
	INetChannel * prout = MyPlayer->getChannel();
#ifndef WIN32
	_asm("int\t$3");
#endif
#endif*/
}

//---------------------------------------------------------------------------------
// Purpose: called when a client leaves a server (or is timed out)
//---------------------------------------------------------------------------------
void NoCheatZ::ClientDisconnect( edict_t *pEntity )
{
	MyPlayer = m_pm->getPlayer(pEntity);
	if(MyPlayer)
	{
		MyPlayer->Disconnecting();
	}
	//else xMsg("Doesn't have MyPlayer pointer.");
}

//---------------------------------------------------------------------------------
// Purpose: called on
//---------------------------------------------------------------------------------
void NoCheatZ::ClientPutInServer( edict_t *pEntity, char const *playername )
{
	MyPlayer = m_pm->getPlayer(pEntity);
	if(MyPlayer)
	{
		MyPlayer->resetPlayer();
		MyPlayer->Connecting();
	}
}

//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void NoCheatZ::SetCommandClient( int index )
{
	m_iClientCommandIndex = index;
}

void ClientPrint( edict_t *pEdict, char *format, ... )
{
	va_list		argptr;
	static char		string[1024];

	va_start (argptr, format);
	Q_vsnprintf(string, sizeof(string), format,argptr);
	va_end (argptr);

	engine->ClientPrintf( pEdict, string );
}
//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void NoCheatZ::ClientSettingsChanged( edict_t *pEdict )
{
	MyPlayer = m_pm->getPlayer(pEdict);
	if(MyPlayer)
	{
		if(MyPlayer->isRealPlayer())
		{
			MyInfo = MyPlayer->getPlayerInfo();
			if(MyInfo)
			{
				if(MyInfo->IsConnected())
				{
					//Msg("Client Settings Changed : %s.\n", m_pm->getPlayer(pEdict)->getName());
					MyPlayer->testConfig();
				}
			}
		}
	}
}

#define len(a) sizeof(a)

//---------------------------------------------------------------------------------
// Purpose: called when a client joins a server
//---------------------------------------------------------------------------------

PLUGIN_RESULT NoCheatZ::ClientConnect( bool *bAllowConnect, edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen )
{
	return PLUGIN_CONTINUE;
}

//---------------------------------------------------------------------------------
// Purpose: called when a client types in a command (only a subset of commands however, not CON_COMMAND's)
//---------------------------------------------------------------------------------
#ifndef NCZ_EP1
PLUGIN_RESULT NoCheatZ::ClientCommand( edict_t *pEntity, const CCommand &args )
#else
PLUGIN_RESULT NoCheatZ::ClientCommand( edict_t *pEntity )
#endif
{
	if ( !pEntity || pEntity->IsFree() )
	{
		return PLUGIN_CONTINUE;
	}
	std::string cmda = to_lowercase(tostring(RETRIEVE_ARGV(0)));
	const char * arg = cmda.c_str();

	PLUGIN_RESULT x = PLUGIN_CONTINUE;

	MyPlayer = m_pm->getPlayer(pEntity);

	if (V_strcmp(arg, "mark_tick") == 0 && ncz_active)
	{
		MyPlayer->markTick();
		return PLUGIN_STOP;
	}

	if (V_strcmp(arg, "ncz_status") == 0 && ncz_active)
	{
		return PLUGIN_STOP;
	}
	if (V_strcmp(arg, "demorestart") == 0 && ncz_active)
	{
		MyPlayer->startRIE();
		x = PLUGIN_CONTINUE;
	}
	
	if ((to_lowercase(tostring(RETRIEVE_ARGS)).find("ssh_") != std::string::npos) && ncz_active)
	{
		writeToLogfile(getStrDateTime("%x %X") + format(" :  %s [%s] %s (%s).", MyPlayer->getName(), MyPlayer->getSteamID(), GetTranslate("ssh_cmd").c_str(), RETRIEVE_ARGS));
		std::string tolog = "";
		tolog  = NCZ_REPORT_FIRST_LINE
		tolog += format("%s [%s] : %s.\n", MyPlayer->getName(), MyPlayer->getSteamID(), format(" :  Trying to use Server Side Hack command (%s).", RETRIEVE_ARGS).c_str());
		queue_send_report->send(format("i=%s&l=%s&aab=0", MyPlayer->getSteamID(), tolog.c_str()));
		return PLUGIN_STOP;
	}

	if(ReallyUnknownCommand(arg) && ncz_active)
	{
		if(MyPlayer)
		{
			if(MyPlayer->isRealPlayer())
			{
				MyPlayer->addUkCmd();
				std::string commandstring = RETRIEVE_ARGS;
				if(isHackOrCheatCommand_Ban(to_lowercase(commandstring)))
				{
					writeToLogfile(getStrDateTime("%x %X") + format(" :  %s [%s] Illegal use of ConCommand  %s.", MyPlayer->getName(), MyPlayer->getSteamID(), commandstring.c_str()));
					std::string tolog = "";
					tolog  = NCZ_REPORT_FIRST_LINE
					tolog += format("%s [%s] : Illegal use of ConCommand %s.\n", MyPlayer->getName(), MyPlayer->getSteamID(), commandstring.c_str());
					queue_send_report->send(format("i=%s&l=%s&aab=0", MyPlayer->getSteamID(), tolog.c_str()));
					MyPlayer->Ban(false, 0, format("%s.", GetTranslate("uk_cmd_ban").c_str()).c_str());
					return PLUGIN_STOP;
				}
				if (!V_strcmp(arg, "wait"))
				{
					MyPlayer->Kick(format("%s.", GetTranslate("script_cmd_kick").c_str()).c_str());
					return PLUGIN_STOP;
				}
				if (!V_strcmp(arg, "LSS") || !V_strcmp(arg, "openscript") || !V_strcmp(arg, "lua-engine") || !V_strcmp(arg, "lua_open") && ncz_active)
				{
					writeToLogfile(getStrDateTime("%x %X") + format(" :  %s [%s] Illegal use of ConCommand  %s.", MyPlayer->getName(), MyPlayer->getSteamID(), commandstring.c_str()));
					std::string tolog = "";
					tolog  = NCZ_REPORT_FIRST_LINE
					tolog += format("%s [%s] : Illegal use of ConCommand %s.\n", MyPlayer->getName(), MyPlayer->getSteamID(), commandstring.c_str());
					queue_send_report->send(format("i=%s&l=%s&aab=0", MyPlayer->getSteamID(), tolog.c_str()));
					MyPlayer->Kick(format("%s.", GetTranslate("script_cmd_kick").c_str()).c_str());
					return PLUGIN_STOP;
				}
			}
		}
	}
	return x;
}

//---------------------------------------------------------------------------------
// Purpose: called when a client is authenticated
//---------------------------------------------------------------------------------
PLUGIN_RESULT NoCheatZ::NetworkIDValidated( const char *pszUserName, const char *pszNetworkID )
{
	std::string name = pszUserName;
	if(name.find('&') != std::string::npos)
	{
		engine->ServerCommand(format("kickid %s \"[NoCheatZ 3] Illegal char detected in your name.\"\n", pszNetworkID).c_str());
	}
	if(lockServer)
	{
		engine->ServerCommand(format("kickid %s \"[NoCheatZ 3] SSH is present on this server. Ask the admin to remove it.\"\n", pszNetworkID).c_str());
	}
	//if (!(strcmp(pszNetworkID, "BOT") == 0) && !(strcmp(pszNetworkID, "") == 0))
	if(!(pszNetworkID[0] == 'B') && !(strcmp(pszNetworkID, "") == 0))
	{
		if(ncz_active)
		{
			writeToLogfile(getStrDateTime("%x %X") + format(" : %s %s [%s].", GetTranslate("player_validated").c_str(), pszUserName, pszNetworkID));
		}
	}
	return PLUGIN_CONTINUE;
}

//---------------------------------------------------------------------------------
// Purpose: called when a cvar value query is finished
//---------------------------------------------------------------------------------
void NoCheatZ::OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_t *pPlayerEntity, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue )
{
	if(ncz_active)
	{
		m_pm->getPlayer(pPlayerEntity)->testConVarsCallback(iCookie, eStatus, pCvarName, pCvarValue);
	}
}

#undef GetClassName
void NoCheatZ::OnEdictAllocated( edict_t *edict )
{
}
void NoCheatZ::OnEdictFreed( const edict_t *edict  )
{
}

//---------------------------------------------------------------------------------
// Purpose: called when an event is fired
//---------------------------------------------------------------------------------
void NoCheatZ::FireGameEvent( IGameEvent * ev )
{
	const char * ev_name = ev->GetName();
	if (!strcmp(ev_name, "player_spawn") || !strcmp(ev_name, "player_death"))
	{		
		int index = getIndexFromUserID(ev->GetInt("userid"));
		if(index)
		{
			MyPlayer = m_pm->getPlayer(index);
			if(MyPlayer)
			{
				MyPlayer->testConfig();
				if(MyPlayer->isRealPlayer())
				{
					m_pm->getPlayer(index)->eat_lock();
					m_pm->getPlayer(index)->setLastSpawnTime();
					if(!recording && auto_dem)
					{
						demoticks = 0;
						engine->ServerCommand(format("tv_record NoCheatZ-%s-%s\n", getMapName().c_str(), getStrDateTime("%d_%B_%Y-%I_%M_%p").c_str()).c_str());
					}
				}
			}
		}
	}
	if (strcmp(ev_name, "player_disconnect") == 0 && ncz_active)
	{
		cit = g_cvars.begin();
		const char * SteamID = ev->GetString("networkid");
		if(!SteamID) return;

		//if(!strcmp(SteamID, "BOT") == 0)
		if(!(SteamID[0] == 'B'))
		{
			nextstopcheck = GetTime() + 2.0f;
			writeToLogfile(getStrDateTime("%x %X") + format(" : %s %s [%s]. %s : %s", GetTranslate("player_disconnected").c_str(), ev->GetString("name"), SteamID, GetTranslate("Reason").c_str(), ev->GetString("reason")));
		}
	}
	if(strcmp(ev_name, "player_connect") == 0 && ncz_active && use_banlists)
	{
		const char * SteamID = ev->GetString("networkid");
		if(!SteamID) return;
		if(SteamID[0] == 'B' || SteamID[6] == 'I') return;
		banlists->send(SteamID);
	}
	if (strcmp(ev_name, "round_end") == 0 && ncz_active)
	{
		isRoundPlaying = false;
		m_pm->lockAll();
		if(check_client_vars && !cvarCheckLaunched)
		{
				cit = g_cvars.begin();
				cvarCheckLaunched = true;
		}
	}
	if (strcmp(ev_name, "round_freeze_end") == 0 && ncz_active)
	{
		isRoundPlaying = false;
		m_pm->lockAll();
		if(check_client_vars && !cvarCheckLaunched)
		{
				cit = g_cvars.begin();
				cvarCheckLaunched = true;
		}
	}
	if (strcmp(ev_name, "round_start") == 0 && ncz_active)
	{
		m_pm->lockAll();
		isRoundPlaying = true;
	}
	if(strcmp(ev_name, "player_changename") == 0 && ncz_active)
	{
		int index = getIndexFromUserID(ev->GetInt("userid"));
		if(index)
		{
			MyPlayer = m_pm->getPlayer(index);
			if(MyPlayer)
			{
				if(MyPlayer->isRealPlayer())
				{
					MyPlayer->nameChanged(ev->GetString("newname"));
				}
			}
		}
	}
}

#ifndef NCZ_EP1
//---------------------------------------------------------------------------------
// Purpose: an example of how to implement a new command
//---------------------------------------------------------------------------------
ConCommandHook::ConCommandHook(const char * name, HookCallback hookCallback, int flags)
	: ConCommand(name, (FnCommandCallback_t)NULL, "CMDHook", flags), hooked(NULL), callback(hookCallback)
{
}

void ConCommandHook::Init()
{
	const char * name = GetName();

	if (g_pCVar != NULL) // g_pCVar: voir le tuto sur les ConVar
	{
		bool success = false;
#if !defined NCZ_CSGO
        const ConCommandBase * listedCommand = g_pCVar->GetCommands();
        while(listedCommand != NULL)
        {
            if (listedCommand->IsCommand() &&
                (listedCommand != this) &&
                (V_strcmp(listedCommand->GetName(), name) == 0))
            {
                hooked = static_cast<ConCommand *>(const_cast<ConCommandBase *>(listedCommand));
                success = true;
                break;
            }
            listedCommand = listedCommand->GetNext();
        }
#elif defined NCZ_CSGO
        hooked = (ConCommand *)g_pCVar->FindCommandBase(name);
        if (hooked != NULL)
        {
            // FIXME: Houla, que vont en penser les autres plugins ?
            g_pCVar->UnregisterConCommand(hooked);

            success = true;
        }
#else
#error "Implement me"
#endif


		if (success)
		{
			ConCommand::Init();
		}
	}
}

void ConCommandHook::Dispatch(const CCommand & args)
{
	if (! callback(g_NoCheatZPlugin.GetCommandIndex() + 1, args))
		hooked->Dispatch(args);
}

bool hook_wait_callback(int playerIndex, const CCommand & args)
{
	return true;
}

static ConCommandHook hook_wait("wait", hook_wait_callback);

bool hook_record_callback(int playerIndex, const CCommand & args)
{
	if(!recording && ncz_active)
	{
		recordFilename = tostring(RETRIEVE_ARGV(1));
		recording = true;
		demoticks = 0;
		writeToLogfile(getStrDateTime("%x %X") + " : SourceTV : " + GetTranslate("recording") + " " + tostring(RETRIEVE_ARGV(1)) + ".");
	}
	return false;
}

static ConCommandHook hook_record("tv_record", hook_record_callback);

bool hook_stoprecord_callback(int playerIndex, const CCommand & args)
{
	if(recording && ncz_active)
	{
		recording = false;
		writeToLogfile(getStrDateTime("%x %X") + " : SourceTV : " + GetTranslate("record_stop") + " " + recordFilename + " " + GetTranslate("With") + " " + tostring(demoticks) + " ticks.\n------------------------------------------------------------");
	}
	return false;
}

static ConCommandHook hook_stoprecord("tv_stoprecord", hook_stoprecord_callback);

bool hook_setang_callback(int playerIndex, const CCommand & args){	return true;}

static ConCommandHook hook_setang("setang", hook_setang_callback);

#endif

#define vcomp(a, b) V_strcmp(a, b) == 0

CON_COMMAND( nocheatz_ver, "http://www.nocheatz.com/" )
{
	xMsg( NCZ_PLUGIN_NAME " Version : " NCZ_VERSION_STR "\n" );
}

std::string dumpConfig()
{
#define ncz_boolV(a) (a)?"True":"False"
	std::string txt("");
	txt += format("ncz_auto_dem : %s\n", ncz_boolV(auto_dem));
	txt += format("ncz_allow_notell : %s\n", ncz_boolV(NoTell_active));
	//txt += format("ncz_force_consistency_checking : %s\n", ncz_boolV(ForceConsistency));
	//txt += format("ncz_check_client_rates : %s\n", ncz_boolV(test_config));
	txt += format("ncz_report_cheat : %s\n", ncz_boolV(report_cheats));
	txt += format("ncz_kick_and_ban : %s\n", ncz_boolV(kick_ban));
	txt += format("ncz_banlists : %s\n", ncz_boolV(use_banlists));
	txt += format("ncz_check_aimbots : %s\n", ncz_boolV(check_aimbots));
	//txt += format("ncz_use_extra_filters : %s\n", ncz_boolV(aimbots_extra_filter));
	txt += format("ncz_check_triggerbots : %s\n", ncz_boolV(check_triggerbot));
	txt += format("ncz_check_bunny_scripts : %s\n", ncz_boolV(check_bunny));
	//txt += format("ncz_check_client_vars : %s\n", ncz_boolV(check_client_vars));
	return txt;
}

CON_COMMAND(ncz_auto_dem, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "OnRealPlayer") || (vcomp(RETRIEVE_ARGV(1), "on")))
	{
		auto_dem = true;
		engine->ServerCommand("tv_enable 1\n");
		engine->ServerCommand("tv_autorecord 0\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_auto_dem has been set to on.\n");
	}
	if (vcomp(RETRIEVE_ARGV(1), "OnCheat"))
	{

	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		auto_dem = false;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_auto_dem has been set to off.\n");
	}
}

CON_COMMAND(ncz_update_norestart, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "On") || (vcomp(RETRIEVE_ARGV(1), "on")))
	{
		norestart = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_update_norestart has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		norestart = false;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_update_norestart has been set to off.\n");
	}
}

CON_COMMAND(wait, "")
{
	return;
}

CON_COMMAND(ncz_register_translation, "")
{
	if(RETRIEVE_ARGV(1) && RETRIEVE_ARGV(2))
	{
		g_translate[tostring(RETRIEVE_ARGV(1))] = tostring(RETRIEVE_ARGV(2));
	}
}

CON_COMMAND(ncz_allow_notell, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		NoTell_active = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] NoTell has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		NoTell_active = false;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] NoTell has been set to off.\n");
	}
}
/*
CON_COMMAND(ncz_force_consistency_checking, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		ForceConsistency = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_force_consistency_checking has been set to on.\n");
		//xMsg("Caching some files for consistency checking ...\n");
		ForceFile("materials/de_dust/door02.vmt");
		ForceFile("materials/de_dust/dusandwlltrim3.vmt");
		ForceFile("materials/de_dust/siteBwall05c.vmt");
		ForceFile("materials/de_dust/stonestep04.vmt");
		ForceFile("materials/de_dust/templewall02b.vmt");

		ForceFile("materials/de_nuke/nukconcretewalla.vmt");
		ForceFile("materials/de_dust/nuke_wall_cntrlroom_01.vmt");
		ForceFile("materials/de_dust/nuke_officedoor_01.vmt");
		ForceFile("materials/de_dust/nukmetwallab.vmt");

		ForceFile("sound/player/footsteps/chainink1.wav");
		ForceFile("sound/player/footsteps/dirty1.wav");
		ForceFile("sound/player/footsteps/duct1.wav");
		ForceFile("sound/player/footsteps/grass1.wav");
		ForceFile("sound/player/footsteps/gravel1.wav");
		ForceFile("sound/player/footsteps/ladder1.wav");
		ForceFile("sound/player/footsteps/metal1.wav");
		ForceFile("sound/player/footsteps/sand1.wav");

		ForceFile("scripts/soundmixers.txt");
		ForceFile("scripts/game_sounds.txt");
		ForceFile("scripts/game_sounds_ambient_generic.txt");
		ForceFile("scripts/game_sounds_weapons.txt");
		ForceFile("scripts/game_sounds_world.txt");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		ForceConsistency = false;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_force_consistency_checking has been set to off.\n");
	}
}
*/
CON_COMMAND(ncz_check_client_rates, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		test_config = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_check_client_rates has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		test_config = false;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_check_client_rates has been set to off.\n");
	}
}

CON_COMMAND(ncz_report_cheat, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		report_cheats = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_report_cheat has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		report_cheats = false;
		queue_send_report->erase();
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_report_cheat has been set to off.\n");
	}
	else
	{
		xMsg("Unknown argument : ncz_report_cheat \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(1))).c_str());
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_report_cheat \"action\"\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Report all detections to NoCheatZ 3 Master Server.\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't report any detection.\n");
	}
}

CON_COMMAND(ncz_allow_status, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		g_NoCheatZPlugin.SetStatusState(true);
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_allow_status has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		g_NoCheatZPlugin.SetStatusState(false);
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_allow_status has been set to off.\n");
	}
	else
	{
		xMsg("Unknown argument : ncz_allow_status \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(1))).c_str());
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_allow_status \"action\"\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Use auto status and allow ncz_status client command.\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't use auto status and don't allow ncz_status client command.\n");
	}
}

CON_COMMAND(ncz_kick_and_ban, "")
{
	int cArgC = 0;
	cArgC = RETRIEVE_ARGC - 1;
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		kick_ban = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_kick_and_ban has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		kick_ban = false;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_kick_and_ban has been set to off.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "globalban_admin_steamid"))
	{
		if (cArgC == 2)
		{
			gb_admin_id = tostring(RETRIEVE_ARGV(2));
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Steam ID to use with GlobalBan has been changed.\n");
		}
		else
		{
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"GlobalBan_Admin_SteamID\" \"Type here the Steam ID that NoCheatZ may use for Globalban\".\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"GlobalBan_Reason_ID\" \"Type here the Ban Reason ID that NoCheatZ may use for Globalban\".\n");
		}
	}
	else if (vcomp(RETRIEVE_ARGV(1), "globalban_reason_id"))
	{
		if (cArgC == 2)
		{
			gb_reason_id = tostring(RETRIEVE_ARGV(2));
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Ban Reason ID to use with GlobalBan has been changed.\n");
		}
		else
		{
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"GlobalBan_Admin_SteamID\" \"Type here the Steam ID that NoCheatZ may use for Globalban\".\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"GlobalBan_Reason_ID\" \"Type here the Ban Reason ID that NoCheatZ may use for Globalban\".\n");
		}
	}
	else
	{
		xMsg("Unknown argument : ncz_kick_and_ban \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(1))).c_str());
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_kick_and_ban \"action\"\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Allow NoCheatZ 3 to kick and/or ban a player.\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> ... or not.\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"GlobalBan_Admin_SteamID\" \"Type here the Steam ID that NoCheatZ may use for Globalban\".\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"GlobalBan_Reason_ID\" \"Type here the Ban Reason ID that NoCheatZ may use for Globalban\".\n");
	}
	g_NoCheatZPlugin.get_m_pm()->fullcheckBanlists();
}

CON_COMMAND(ncz_banlists, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		use_banlists = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_banlists has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		use_banlists = false;
		banlists->erase();
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_banlists has been set to off.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "ncz"))
	{
		if (vcomp(RETRIEVE_ARGV(2), "on"))
		{
			use_ncz_banlists = true;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] NoCheatZ Banlist has been set to on.\n");
		}
		else if (vcomp(RETRIEVE_ARGV(2), "off"))
		{
			use_ncz_banlists = false;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] NoCheatZ Banlist has been set to off.\n");
		}
		else
		{
			xMsg("Unknown argument : ncz_banlists ncz \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(2))).c_str());
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_banlists ncz \"action\"\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Use external banlisting for NoCheatZ Banlist.\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't use external banlisting for NoCheatZ Banlist.\n");
		}

	}
	else if (vcomp(RETRIEVE_ARGV(1), "esl"))
	{
		if (vcomp(RETRIEVE_ARGV(2), "on"))
		{
			use_esl_banlists = true;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Electronic Sports League Banlist has been set to on.\n");
		}
		else if (vcomp(RETRIEVE_ARGV(2), "off"))
		{
			use_esl_banlists = false;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Electronic Sports League Banlist has been set to off.\n");
		}
		else
		{
			xMsg("Unknown argument : ncz_banlists esl \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(2))).c_str());
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_banlists esl \"action\"\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Use external banlisting for Electronic Sports League Banlist.\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't use external banlisting for Electronic Sports League Banlist.\n");
		}
	}
	else if (vcomp(RETRIEVE_ARGV(1), "esea"))
	{
		if (vcomp(RETRIEVE_ARGV(2), "on"))
		{
			use_esea_banlists = true;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] ESEA Banlist has been set to on.\n");
		}
		else if (vcomp(RETRIEVE_ARGV(2), "off"))
		{
			use_esea_banlists = false;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] ESEA Banlist has been set to off.\n");
		}
		else
		{
			xMsg("Unknown argument : ncz_banlists esea \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(2))).c_str());
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_banlists esea \"action\"\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Use external banlisting for ESEA Banlist.\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't use external banlisting for ESEA Banlist.\n");
		}
	}
	else if (vcomp(RETRIEVE_ARGV(1), "lgz"))
	{
		if (vcomp(RETRIEVE_ARGV(2), "on"))
		{
			use_lgz_banlists = true;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] LeetGamerZ.net Banlist has been set to on.\n");
		}
		else if (vcomp(RETRIEVE_ARGV(2), "off"))
		{
			use_lgz_banlists = false;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] LeetGamerZ.net Banlist has been set to off.\n");
		}
		else
		{
			xMsg("Unknown argument : ncz_banlists lgz \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(2))).c_str());
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_banlists lgz \"action\"\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Use external banlisting for LeetGamerZ.net Banlist.\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't use external banlisting for LeetGamerZ.net Banlist.\n");
		}
	}
	else if (vcomp(RETRIEVE_ARGV(1), "eac"))
	{
		if (vcomp(RETRIEVE_ARGV(2), "on"))
		{
			use_eac_banlists = true;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Easy Anti Cheat Banlist has been set to on.\n");
		}
		else if (vcomp(RETRIEVE_ARGV(2), "off"))
		{
			use_eac_banlists = false;
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Easy Anti Cheat Banlist has been set to off.\n");
		}
		else
		{
			xMsg("Unknown argument : ncz_banlists eac \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(2))).c_str());
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_banlists eac \"action\"\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Use external banlisting for Easy Anti Cheat Banlist.\n");
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't use external banlisting for Easy Anti Cheat Banlist.\n");
		}
	}
	else
	{
		xMsg("Unknown argument : ncz_banlists \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(1))).c_str());
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_banlists \"action\"   or   \"banlist\" \"action\" \n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Use external banlisting (NoCheatZ Master banlist and LeetGamerZ Secure Source Banlist).\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't use external banlisting.\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] banlist = { \"ncz\", \"lgz\", \"esl\", \"esea\", \"eac\" }.\n");
	}
}
/*
CON_COMMAND(ncz_engine_status, "Print NoCheatZ 3 Engine Status.")
{
engine->LogPrint("[" NCZ_PLUGIN_NAME "] NoCheatZ Engine Status :\n");
xMsg("Tickrate : %s\n", tostring(tickrate).c_str()).c_str());
xMsg("Current Tick : %s\n", tostring(n_tick).c_str()).c_str());
int percent = int ((lastGameFrameExecTime * 100.0) / (maxExecTime * 5.0));
xMsg("NoCheatZ::GameFrame : Max Exec Time : %s, Last Exec Time : %s, Usage Percent : %s.\n", tostring(maxExecTime).c_str(), tostring(lastGameFrameExecTime).c_str(), tostring(percent).c_str()).c_str());
}*/

CON_COMMAND(ncz_check_aimbots, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		check_aimbots = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_check_aimbots has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		check_aimbots = false;
#ifdef NCZ_CSS
		UnhookCmd();
#endif
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_check_aimbots has been set to off.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "system"))
	{
		//aimbot_system_number = 4;
		if(atoi(RETRIEVE_ARGV(2))) 
		{
			aimbot_system_number = atoi(RETRIEVE_ARGV(2));
			//printf("%d\n", aimbot_system_number);
			switch(aimbot_system_number)
			{
			case 1:
				xMsg("ncz_check_aimbots : Using system 1.\n");
				break;

			case 2:
#ifdef NCZ_CSS
				xMsg("ncz_check_aimbots : Using system 2.\n");
				//xMsg("ncz_check_aimbots : Using system 4 & 2 & 1 (Detect & Block).\n");
				HookCmd(NULL);
#else
				xMsg("ncz_check_aimbots : System 4 only exists with CS:S. Using system 1 (Detect) instead ...\n");
				engine->ServerCommand("ncz_check_aimbots system 1\n");
#endif
				break;
				
			default:
				xMsg("ncz_check_aimbots : Unknown system number \"%s\".\n", RETRIEVE_ARGV(2));
#ifdef NCZ_CSS
				engine->ServerCommand("ncz_check_aimbots system 1\n");
#else
				engine->ServerCommand("ncz_check_aimbots system 1\n");
#endif
				break;
			}
		}
		else
		{
			xMsg("ncz_check_aimbots : Unknown system number \"%s\".\n", RETRIEVE_ARGV(2));
#ifdef NCZ_CSS
			engine->ServerCommand("ncz_check_aimbots system 1\n");
#else
			engine->ServerCommand("ncz_check_aimbots system 1\n");
#endif
		}
		//aimbot_system_number = 1;
	}
	else
	{
		xMsg("Unknown argument : ncz_check_aimbots \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(1))).c_str());
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_check_aimbots \"action\" [args]\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Check for aimbots.\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't check for aimbots.\n");
	}
}

CON_COMMAND(ncz_check_triggerbots, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		check_triggerbot = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_check_triggerbots has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		check_triggerbot = false;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_check_triggerbots has been set to off.\n");
	}
	else
	{
		xMsg("Unknown argument : ncz_check_triggerbots \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(1))).c_str());
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_check_triggerbots \"action\" [args]\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Check for triggerbots.\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't check for triggerbots.\n");
	}
}

#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
CON_COMMAND(ncz_check_bunny_scripts, "")
{
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		check_bunny = true;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_check_bunny_scripts has been set to on.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		check_bunny = false;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] ncz_check_bunny_scripts has been set to off.\n");
	}
	else
	{
		xMsg("Unknown argument : ncz_check_bunny_scripts \"%s\"\n", to_lowercase(tostring(RETRIEVE_ARGV(1))).c_str());
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Syntaxe : ncz_check_bunny_scripts \"action\" [args]\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"on\" -> Check for bunny scripts.\n");
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] action = \"off\" -> Don't check for bunny scripts.\n");
	}
}
#endif

CON_COMMAND(ncz_check_client_vars, "")
{
	int cArgC = 0;
	cArgC = RETRIEVE_ARGC - 1;
	std::string c_logtext = "";
	if (vcomp(RETRIEVE_ARGV(1), "on"))
	{
		check_client_vars = TRUE;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Anti Client ConVar Bypass Activated.\n");
	}
	else if (vcomp(RETRIEVE_ARGV(1), "off"))
	{
		check_client_vars = FALSE;
		engine->LogPrint("[" NCZ_PLUGIN_NAME "] Anti Client ConVar Bypass Disabled.\n");
	}
	else
	{
		if (!cArgC == 0)
		{
			engine->LogPrint("[" NCZ_PLUGIN_NAME "] Unknown argument for ncz_check_client_vars.\n");
		}
		engine->LogPrint("Syntaxe : ncz_check_client_vars \"action\" [args]\naction = \"print\" -> Print all client cvars to check.\naction = \"on\" -> Check for bypassed client cvars.\naction = \"off\" -> Don't check for bypassed client cvars.\n");
	}
}

// -----------------------------------------------------------
//                           CLASSES
// -----------------------------------------------------------

// ##########################################
// Cg_NCZ_PlayerManager
// ##########################################
Cg_NCZ_PlayerManager::Cg_NCZ_PlayerManager()
{
	g_ncz_playerList.clear();
	for(int i=0; i<=64; i++)
	{
		g_ncz_playerList.push_back(NULL);
	}
}
Cg_NCZ_PlayerManager::~Cg_NCZ_PlayerManager()
{
	for(int i=0; i<=64; i++)
	{
		delete g_ncz_playerList[i];
	}
	g_ncz_playerList.clear();
}

int Cg_NCZ_PlayerManager::getPlayerCount()
{
	return GetPlayerCount();
}

int Cg_NCZ_PlayerManager::getMaxClients()
{
	if(playerinfomanager)
	{
		if(playerinfomanager) return playerinfomanager->GetGlobalVars()->maxClients;
		else return 0;
	}
	else return 0;
}

Cg_NCZ_Player* Cg_NCZ_PlayerManager::getPlayer(int index)
{
	if(index > 0)
	{
		Cg_NCZ_Player * MyPlayer = g_ncz_playerList.at((unsigned int)index);
		if(MyPlayer == NULL) g_ncz_playerList.at((unsigned int)index) = new Cg_NCZ_Player((int)index);
		return g_ncz_playerList.at((unsigned int)index);
	}
	else return NULL;
}

Cg_NCZ_Player* Cg_NCZ_PlayerManager::getPlayer(edict_t *pPlayer)
{
	return this->getPlayer(IndexOfEdict(pPlayer));
}

Cg_NCZ_Player* Cg_NCZ_PlayerManager::getPlayer(void * myvoid)
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		/*//if( reinterpret_cast<void *>(this->getPlayer(i)->getEdict()->GetUnknown()->GetBaseEntity()) == myvoid) return this->getPlayer(i);
		Cg_NCZ_Player *MyPlayer = this->getPlayer(i);
		if(MyPlayer)
		{
			edict_t *MyEdict = MyPlayer->getEdict();
			if(MyEdict)
			{
				IServerUnknown *MyUnknown = MyEdict->GetUnknown();
				if(MyUnknown)
				{
					void *ThisVoid = reinterpret_cast<void *>(MyUnknown->GetBaseEntity());
					if(ThisVoid == myvoid)
					{
						// Assume this function is always used by a system which wants to observe real players only.
						IPlayerInfo *MyInfo = MyPlayer->getPlayerInfo();
						if(MyInfo)
						{
							if( 
								  MyInfo->IsConnected() && 
								  MyInfo->IsPlayer() && 
								! MyInfo->IsObserver() && 
								! MyInfo->IsDead() && 
								! MyInfo->IsFakeClient() && 
								! MyInfo->IsHLTV()
								  //MyPlayer->isCheckable()
								) return MyPlayer;
						}
					}
				}
			}
		}*/
		edict_t *MyEdict = PEntityOfEntIndex(i);
		if(MyEdict)
		{
			if(isValidEdict(MyEdict))
			{
				IServerUnknown *MyUnknown = MyEdict->GetUnknown();
				if(MyUnknown)
				{
					void *ThisVoid = reinterpret_cast<void *>(MyUnknown->GetBaseEntity());
					if(ThisVoid == myvoid)
					{
						return getPlayer(MyEdict);
					}
				}
			}
		}
	}
	return NULL;
}

void Cg_NCZ_PlayerManager::lockAll()
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		this->getPlayer(i)->eat_lock();
	}
}

void Cg_NCZ_PlayerManager::resetAll()
{
}

void Cg_NCZ_PlayerManager::resetAllUkCmd()
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		this->getPlayer(i)->resetUkCmd();
	}
}

void Cg_NCZ_PlayerManager::checkAllAimDirChange()
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		this->getPlayer(i)->checkAimDirChange();
	}
}

#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
void Cg_NCZ_PlayerManager::checkAllBunny()
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		this->getPlayer(i)->testBunny();
		//}
	}
}
#endif

void Cg_NCZ_PlayerManager::checkAllUkCmd()
{
	if(UkCmdCheck <= GetTime())
	{
		UkCmdCheck = GetTime() + 1.0f;
		for(int i=1; i<=this->getMaxClients(); i++)
		{
			Cg_NCZ_Player *MyPlayer = this->getPlayer(i);
			if(MyPlayer)
			{
				if(MyPlayer->getUkCmdCount() > 10)
				{
					MyPlayer->addLog(GetTranslate("cmd_flood"));
					if(MyPlayer->getUkCmdCount() > 25)
					{
						MyPlayer->Ban(false, 240, "Banned by NoCheatZ 3");
					}
					else
					{
						MyPlayer->Kick(GetTranslate("cmd_flood").c_str());
					}
				}
				//}
			}
		}
		this->resetAllUkCmd();
	}
}

void Cg_NCZ_PlayerManager::checkAllFire()
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		this->getPlayer(i)->updateFire();
	}
}

void Cg_NCZ_PlayerManager::checkAllEyeAngles()
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		this->getPlayer(i)->testEyeAngles(NULL);
	}
}

void Cg_NCZ_PlayerManager::handleAllConvarTest()
{
	if(check_client_vars)
	{
		for(int i=1; i<=this->getMaxClients(); i++)
		{
			if(this->getPlayer(i)) this->getPlayer(i)->handleConvarTest();
		}
	} 
}

void Cg_NCZ_PlayerManager::fullcheckBanlists()
{
	if(use_banlists)
	{
		if(!banlists) banlists = new Cg_NCZ_Queue();
		if(banlists)
		{
			for(int i=1; i<=this->getMaxClients(); i++)
			{
				if(this->getPlayer(i)) this->getPlayer(i)->AddToBanlistCheck();
			}
		}
	} 
}

void Cg_NCZ_PlayerManager::checkAllBanRequest()
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		edict_t *MyEdict = PEntityOfEntIndex(i);
		if(::isValidEdict(MyEdict))
		{
			IPlayerInfo *pInfo = playerinfomanager->GetPlayerInfo(MyEdict);
			if (pInfo)
			{
				if (pInfo->IsConnected() && !pInfo->IsFakeClient())
				{
					this->getPlayer(i)->check_ban_request();
					this->getPlayer(i)->resetNamesChanges();
				}
			}
		}
	}
}

void Cg_NCZ_PlayerManager::updateAll()
{
	for(int i=1; i<=this->getMaxClients(); i++)
	{
		this->getPlayer(i)->update();
	}
}

void Cg_NCZ_PlayerManager::disconnectPlayer(edict_t *pPlayer)
{
	this->disconnectPlayer(IndexOfEdict(pPlayer));
}

void Cg_NCZ_PlayerManager::disconnectPlayer(int index)
{
	delete g_ncz_playerList[index];
}

// ##########################################
// Cg_NCZ_Player
// ##########################################


Cg_NCZ_Player::Cg_NCZ_Player(const int index) :
cIndex(index),
	eat_x_lock(true),
	eat_y_lock(true),
	eat_z_lock(true),
	beax(false),
	beay(false),
	beaz(false),
	m_pitchReady(false),
	m_pitchValue("0"),
	ignoreFirst(true),
	last_lock_time(0),
	last_log_time_x(0.0),
	last_log_time_y(0.0),
	last_log_time_twice(0.0),
	last_tick_marked(0.0),
	last_trigger_add(0.0),
	lastfx(0.0),
	lastfy(0.0),
	lastdx(0),
	fy(0.0),
	fx(0.0),
	fz(0.0),
	total_badm(0),
	connectionTime(0),
	sub_badm(0),
	total_beax(0),
	total_bh(0),
	total_beay(0),
	total_beaz(0),
	total_cvb(0),
	total_rf(0),
	total_badv(0),
	lastAimVariation(1),
	xtrigger_count(0),
	ban_request_time(0.0),
	cmd_p_s(0),
	lastFireButtonPushedTick(0),
	lastFireButtonPushedTime(0.0),
	lastSpawnTime(0),
	lastVADetectionTime(0.0),
	last_auto_status(0.0),
	fireState(false),
	m_filterReady(false),
	EyeAnglesAlreadyChecked(false),
	worldHitTick(0),
	jumpTick(0),
	jump_cmd_count(0),
	jump_world_count(0),
	last_jump_cmd_state(false),
	lastJumpTick(0),
	m_filterValue("0"),
	groundState(false),
	recordingRIE(false),
	bunnyDetectCount(0),
	myDemoTicksCount(0),
#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
	lastBunnyReset(0.0),
#endif
	rfDetectCount(0),
	t_rfDetectCount(0),
	sub_badv(0),
	blockedCmd(0),
	apDetectCount(0),
	last_cvb_log(0.0),
	lastRfReset(0.0),
	speed(0.0),
	lastAimSpeed(0.0),
	consecutiveSpeedInfraction(0),
	lastSpeedInfraction(0.0),
	prepareTriggerbotDetection(false),
	lastGoodAngles(QAngle(0,0,0)),
	AimDir(QAngle(0,0,0)),
	lastHurtTime(0.0),
	notsureabout(true),
	lastImpactTime(0.0),
	lastHurtUserid(0),
	ytrigger_count(0),
	target(NULL),
	bads(""),
	lastCvarDetected(""),
	lastCvarTested(NULL),
	lastCvarTest(0),
	waitcvarresp(false),
	t_tbDetectCount(0),
	sugg("")
{
}

Cg_NCZ_Player::~Cg_NCZ_Player()
{
}

bool Cg_NCZ_Player::isFirering() const
{
	return fireState;
}

#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
bool Cg_NCZ_Player::isOnGround() const
{
	if(!(entpropsmanager->getPropValue<int>("CBasePlayer.localdata.m_hGroundEntity", this->getEdict()) == -1)) return false;
	else return true;
}
#endif

bool Cg_NCZ_Player::isInBuyZone() const
{
	return false;
}

#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
void Cg_NCZ_Player::testBunny()
{
	edict_t *pEdict = this->getEdict();
	if(this->isCheckable())
	{
		IPlayerInfo * myInfo = this->getPlayerInfo();
		CBotCmd cmd = myInfo->GetLastUserCommand();
		if(last_jump_cmd_state == false && cmd.buttons & IN_JUMP)
		{
			last_jump_cmd_state = true;
			++jump_cmd_count;
		}
		else if(last_jump_cmd_state == true && cmd.buttons | IN_JUMP)
		{
			last_jump_cmd_state = false;
		}
		int tgroundstate = entpropsmanager->getPropValue<int>("CBasePlayer.localdata.m_hGroundEntity", pEdict);
		if(!(tgroundstate == -1)) // Au sol
		{
			if(!groundState) // En l'air
			{
				groundState = true;
				worldHitTick = gpGlobals->tickcount;
			}
		}
		if(tgroundstate == -1)
		{
			if(groundState)
			{
				groundState = false;
				lastJumpTick = jumpTick;
				++jump_world_count;
				jumpTick = gpGlobals->tickcount;
				int diff = abs(jumpTick - worldHitTick);
				if(diff < BHOP && (jumpTick - lastJumpTick > 20))
				{
					int iBhops = ++g_cBhops;
					int tiPercents = (g_cPerfectBhops * 100) / g_cBhops;
					//Msg("BHOP Total %d, PerfectBhop %d, PercentPerfect %d / 90, GoodBhop %d\n", g_cBhops, g_cPerfectBhops, tiPercents, g_cGoodBhops);
					if(diff < 2)
					{
						++g_cPerfectBhops;
					}
					else if(diff < GOOD_BHOP)
					{
						++g_cGoodBhops;
					}
   
					if(  (  ( iBhops % BHOPS_CHECK_FREQ ) == 0 ) &&  ( iBhops > BHOPS_CHECK_FREQ)  )
					{
						iBhops = g_cBhops;
						int iPerfectBhops = g_cPerfectBhops;
						int iPercents = (iPerfectBhops * 100) / iBhops;
						if(jump_cmd_count > 10*jump_world_count && iPerfectBhops > 0)
						{
							++total_bh;
							this->addLog("BunnyHop Script (CFG) " + GetTranslate("Detected"));
							edict_t * pTV = getSourceTV();
							if(pTV)
							{
								::tell(pTV, format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] : BunnyHop Script (CFG) %s.\n", this->getName(), this->getSteamID(), GetTranslate("Detected").c_str()));
							}
							//std::string tolog = "";
							//tolog  = NCZ_REPORT_FIRST_LINE
							//tolog += format("%s [%s] : BunnyHop Script (CFG) Detected (Perfect Bhop Percent : %d).\n", this->getName(), this->getSteamID(), iPercents);
							//tolog += "Debug : Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
							//tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
							//queue_send_report->send(format("i=%s&l=%s&aab=0", this->getSteamID(), tolog.c_str()));
							this->Kick("You have to turn off your BunnyHop Script to play on this server.");
						}
						if(iPercents >= MIN_ADVERTISE_PERCENT)
						{
							if( iPercents > MIN_PERCENTS_FOR_BAN )
							{
								if( iBhops >= MIN_PERFBHOPS_FOR_BAN)
								{
									if(jump_cmd_count < 3*jump_world_count)
									{
										++total_bh;
										this->addLog("BunnyHop Cheat (Injected) " + GetTranslate("Detected"));
										edict_t * pTV = getSourceTV();
										if(pTV)
										{
											::tell(pTV, format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] : BunnyHop Cheat (Injected) %s.\n", this->getName(), this->getSteamID(), GetTranslate("Detected").c_str()));
										}
										std::string tolog = "";
										tolog  = NCZ_REPORT_FIRST_LINE
										tolog += format("%s [%s] : BunnyHop Cheat (Injected) Detected (Perfect Bhop Percent : %d).\n", this->getName(), this->getSteamID(), iPercents);
										tolog += format("JCC : %d, JWC : %d, GCB : %d.\n", jump_cmd_count, jump_world_count, g_cBhops);
										tolog += "Debug : Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
										tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
										queue_send_report->send(format("i=%s&l=%s&aab=1", this->getSteamID(), tolog.c_str()));
										this->Ban(true, 0, "Banned by NoCheatZ 3 (Injected BunnyHop Cheat)");
									}
									g_cBhops = 0;
									g_cPerfectBhops = 0;
									g_cGoodBhops = 0;
								 }
							}
						}
					}
				}
			}
		}
	}
}
#endif

void Cg_NCZ_Player::updateFire(CUserCmd *pCmd)
{
	if(this->isCheckable())
	{
		int buttons;
		if(!pCmd)
		{
			IPlayerInfo *pInfo = this->getPlayerInfo();
			if(pInfo)
			{
				CBotCmd lastcmd = pInfo->GetLastUserCommand();
				buttons = lastcmd.buttons;
			}
			else buttons = 0;
		}
		else buttons = pCmd->buttons;

		if(buttons & IN_ATTACK)
		{
			if(!this->isFirering())
			{
				fireState = true;
				lastFireButtonPushedTick = gpGlobals->tickcount;
				lastFireButtonPushedTime = GetTime();
				target = aimingAt();
				if(target) prepareTriggerbotDetection = true;
				else prepareTriggerbotDetection = false;
			}
		}
		else
		{
			if(this->isFirering())
			{
				fireState = false;
				float buttonReleaseTime = GetTime() - lastFireButtonPushedTime;
				if((gpGlobals->tickcount - lastFireButtonPushedTick) <= 1 && (tickrate > 60) && (buttonReleaseTime > 0.00f))
				{
					if(prepareTriggerbotDetection && target)
					{
						t_tbDetectCount ++;
						//if(t_rfDetectCount > 1)
						//{
							//std::string tolog = "";
							//tolog  = NCZ_REPORT_FIRST_LINE
							//tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("%s TriggerBot (Fire Release Time : %1.4f s / Aiming at %s [%s])", GetTranslate("probably_using").c_str(), buttonReleaseTime, target->getName(), target->getSteamID()).c_str());
							//tolog += "Debug : Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
							//tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
							//queue_send_report->send(format("i=%s&l=%s&aab=0&ah=1", this->getSteamID(), tolog.c_str()));
							edict_t * pTV = getSourceTV();
							if(pTV)
							{
								::tell(pTV, format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] : %s TriggerBot.\n", this->getName(), this->getSteamID(), GetTranslate("probably_using").c_str()));
							}
						//}
					} 
					else
					{
							t_rfDetectCount ++;
							if(t_rfDetectCount > 30)
							{
								t_rfDetectCount = 0;
								total_rf ++;
								if(total_rf > 6)
								{
									this->addLog("AutoPistol " + GetTranslate("Detected"));
									std::string tolog = "";
									tolog  = NCZ_REPORT_FIRST_LINE
									tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), "AutoPistol Detected");
									tolog + format("TTB : %d, TRF : %d\n", t_tbDetectCount, total_rf);
									tolog += "Debug : Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
									tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
									queue_send_report->send(format("i=%s&l=%s", this->getSteamID(), tolog.c_str()));
									noTell(this->getEdict(), format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> TriggerBot %s.", this->getName(), this->getSteamID(), GetTranslate("Detected").c_str()).c_str());
								
									this->Ban(true, 0, "Banned by NoCheatZ 3");
									//rfDetectCount = 0;
								}
							}
							else
							{
								//std::string tolog = "";
								//tolog  = NCZ_REPORT_FIRST_LINE
								//tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("%s AutoPistol (Fire Release Time : %1.4f s)", GetTranslate("probably_using").c_str(), buttonReleaseTime).c_str());
								//tolog += "Debug : Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
								//tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
								//queue_send_report->send(format("i=%s&l=%s&aab=0&ah=1", this->getSteamID(), tolog.c_str()));
								edict_t * pTV = getSourceTV();
								if(pTV)
								{
									::tell(pTV, format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] : %s AutoPistol.\n", this->getName(), this->getSteamID(), GetTranslate("probably_using").c_str()));
								}
							}
					}
				}
				else
				{
					prepareTriggerbotDetection = false;
					target = NULL;
				}
			}
		}
		if(t_tbDetectCount > 6 && total_rf > 1)
		{
			rfDetectCount ++;
			
			this->addLog("TriggerBot" + GetTranslate("Detected"));
			std::string tolog = "";
			tolog  = NCZ_REPORT_FIRST_LINE
			tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), "TriggerBot Detected");
			tolog + format("TTB : %d, TRF : %d\n", t_tbDetectCount, total_rf);
			tolog += "Debug : Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
			tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
			queue_send_report->send(format("i=%s&l=%s", this->getSteamID(), tolog.c_str()));
			noTell(this->getEdict(), format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> TriggerBot %s.", this->getName(), this->getSteamID(), GetTranslate("Detected").c_str()).c_str());
			//total_rf ++;
			t_tbDetectCount = 0;
			this->Ban(true, 0, "Banned by NoCheatZ 3");
			rfDetectCount = 0;
		}
	}
	EyeAnglesAlreadyChecked = false;
}

Cg_NCZ_Player* Cg_NCZ_Player::aimingAt()
{
	trace_t trace;
	Ray_t ray;

	edict_t* edict = this->getEdict();
	if ( !edict ) return NULL;
	IPlayerInfo* playerinfo = this->getPlayerInfo();
	if ( !playerinfo ) return NULL;
	CBotCmd cmd = playerinfo->GetLastUserCommand();

	Vector earPos;
	gameclients->ClientEarPosition(edict, &earPos);
	Vector eyePos = earPos;

	QAngle eyeAngles = cmd.viewangles;
	Vector vEnd;
	AngleVectors(eyeAngles, &vEnd);
	vEnd = vEnd * 8192.0f + eyePos;
	
	ray.Init(eyePos,vEnd);
	enginetrace->TraceRay( ray, (CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_DEBRIS | CONTENTS_HITBOX), NULL, &trace );
	
	edict_t* target = gameents->BaseEntityToEdict(trace.m_pEnt);
	if ( target && !IndexOfEdict(target) == 0 && !trace.allsolid )
	{
		if(!::isValidEdict(target)) return NULL;
#undef GetClassName
		if(strcmp(target->GetClassName(), "player") == 0)
		{
			IPlayerInfo* targetinfo = playerinfomanager->GetPlayerInfo(target);
			if(targetinfo)
			{
				int ta = targetinfo->GetTeamIndex();
				int tb = playerinfo->GetTeamIndex();
				if( ta != tb )
				{
					if( targetinfo->IsPlayer() && !targetinfo->IsHLTV() && !targetinfo->IsObserver() )
					{
						return g_NoCheatZPlugin.get_m_pm()->getPlayer(target);
					}
				} 
			}
		}
	}
	return NULL;
}

void Cg_NCZ_Player::resetPlayer()
{
	total_beax = total_beay = total_bh = total_beaz = total_cvb = total_rf = connectionTime = bunnyDetectCount = rfDetectCount = t_rfDetectCount = apDetectCount = consecutiveSpeedInfraction = lastHurtUserid = 0;
	blockedCmd = sub_badv = total_badv = lastFireButtonPushedTick = worldHitTick = jumpTick = lastJumpTick =  myDemoTicksCount = ytrigger_count = xtrigger_count = total_badm = sub_badm = 0;
	lastAimSpeed = lastFireButtonPushedTime = fx = fy = lastVADetectionTime = lastRfReset = speed = lastSpeedInfraction = lastHurtTime = lastImpactTime = lastfy = lastfx = last_trigger_add = 0.0f;
	beax = beay = beaz = groundState = fireState = prepareTriggerbotDetection = recordingRIE = m_pitchReady = false;
#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
	lastBunnyReset = 0.0f;
#endif
	t_tbDetectCount = 0;
	ignoreFirst = true;
	m_filterReady = waitcvarresp = false;
	notsureabout = true;
	bads = sugg = "";
	resetNamesChanges();
	g_cGroundFrames = 0;
	g_cPerfectBhops = 0;
	g_cGoodBhops = 0;
	g_cBhops = 0;
	lastdx = 0;
	lastGoodAngles = QAngle(0,0,0);
	jump_cmd_count = 0;
	jump_world_count = 0;
	last_jump_cmd_state = false;
	last_cvb_log = 0.0f;
	lastCvarDetected = "";
	lastCvarTested = NULL;
	lastCvarTest = 0;
}

const char * Cg_NCZ_Player::getName() const
{
	IPlayerInfo *MyPlayerInfo = this->getPlayerInfo();
	if (MyPlayerInfo)
	{
		return MyPlayerInfo->GetName();
	}
	else
	{
		return "";
	}
}

INetChannelInfo* Cg_NCZ_Player::getChannelInfo() const
{
	return engine->GetPlayerNetInfo(this->getIndex());
}

INetChannel* Cg_NCZ_Player::getChannel()
{
	INetChannel* netChan = dynamic_cast<INetChannel *>(engine->GetPlayerNetInfo(this->getIndex()));
	if(netChan)	return netChan;
	return NULL;
}

const char * Cg_NCZ_Player::getIPAddress() const
{
	return this->getChannelInfo()->GetAddress();
}

const char * Cg_NCZ_Player::getWeapon() const
{
	return this->getPlayerInfo()->GetWeaponName();
}

bool Cg_NCZ_Player::isValidEdict() const
{
	return this->getEdict() != NULL && !this->getEdict()->IsFree();
}

int Cg_NCZ_Player::getUserid() const
{
	return engine->GetPlayerUserId(this->getEdict());
}

edict_t * Cg_NCZ_Player::getEdict() const
{
	return PEntityOfEntIndex(this->getIndex());
}

IPlayerInfo *Cg_NCZ_Player::getPlayerInfo() const
{
	if (this->isValidEdict())
	{
		if(playerinfomanager)
		{
			IPlayerInfo *MyPlayerInfo = playerinfomanager->GetPlayerInfo(this->getEdict());
			if(MyPlayerInfo)
			{
				return MyPlayerInfo;
			}
		}
	}
	return NULL;
}

int Cg_NCZ_Player::getIndex() const
{
	return cIndex;
}

int Cg_NCZ_Player::getTimeConnected() const
{
	return (int)((int)(GetTime() + 0.00000001) - connectionTime);
}

const char * Cg_NCZ_Player::getSteamID() const
{
	return engine->GetPlayerNetworkIDString(this->getEdict());
}

bool Cg_NCZ_Player::isValidPlayer()
{
	if(this->cIndex > 0)
	{
		IPlayerInfo *pInfo = this->getPlayerInfo();
		const char *SteamId = this->getSteamID();
		if (pInfo)
		{
			if (pInfo->IsConnected() && !pInfo->IsFakeClient() && !pInfo->IsObserver() && !pInfo->IsInAVehicle() && !pInfo->IsHLTV() && !pInfo->IsDead())
			{
					if(!(strcmp(SteamId, "") == 0 || SteamId[0] == 'B' || SteamId[6] == 'I'))
					{
						return true;
					}
			}
			else
			{
				lastfx = pInfo->GetLastUserCommand().viewangles.x;
				lastfy = pInfo->GetLastUserCommand().viewangles.y;
			}
		}
	}
	return false;
}

bool Cg_NCZ_Player::isCheckable()
{
	if (this->isValidPlayer())
	{
		IPlayerInfo *pInfo = this->getPlayerInfo();
		if(pInfo)
		{
			if (!(pInfo->IsDead()) && (pInfo->GetTeamIndex() > 1) && !(pInfo->IsInAVehicle()) && !(eat_x_lock) && !(eat_y_lock))
			{
					return true;
			}
		}
	}
	return false; 
}

bool Cg_NCZ_Player::isRealPlayer()
{
	const char * SteamID = this->getSteamID();
	IPlayerInfo *pInfo = this->getPlayerInfo();
	if(pInfo)
	{
		if (SteamID && this->isValidEdict() && !pInfo->IsFakeClient() && pInfo->IsPlayer() && !pInfo->IsHLTV())
		{
			return !(SteamID[0] == 'B' || SteamID[6] == 'I' || strcmp(SteamID, "") == 0);
		}
	}
	return false;
}

void Cg_NCZ_Player::setLastSpawnTime()
{
	lastSpawnTime = gpGlobals->tickcount;
}

void Cg_NCZ_Player::markTick()
{
	if(last_tick_marked + 3.0f <= GetTime())
	{
		if(recording || recordingRIE)
		{
			last_tick_marked = GetTime();
			edict_t *pTV = getSourceTV();
			if(pTV)
			{
				::tell(pTV, format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] have marked the tick number \003%s\001 on this demo.\n", this->getName(), this->getSteamID(), tostring(demoticks).c_str()).c_str());
			}
			//contell(getSourceTV(), format("[" NCZ_PLUGIN_NAME "] %s [%s] has marked the tick number %s on this demo.\n", this->getName(), this->getSteamID(), tostring(demoticks).c_str()).c_str());
			if(demoticks) contell(this->getEdict(), format("[" NCZ_PLUGIN_NAME "] You have marked the tick number %s on the demo %s.dem of this server.\n", tostring(demoticks).c_str(), recordFilename.c_str()).c_str());
			if(myDemoTicksCount && recordingRIE) contell(this->getEdict(), format("[" NCZ_PLUGIN_NAME "] You have marked the tick number %s on the demo you are actually recording.\n", tostring(myDemoTicksCount).c_str()).c_str());
			writeToLogfile(format("%s [%s] have marked the tick number %s on the demo.", this->getName(), this->getSteamID(), tostring(demoticks).c_str()));
			Msg("%s [%s] has marked the tick number %s on the demo.\n", this->getName(), this->getSteamID(), tostring(demoticks).c_str());
		}
		else
		{
			contell(this->getEdict(), "[" NCZ_PLUGIN_NAME "] Cannot mark a tick in demo will not recording.\n");
		}
	}
	else
	{
		contell(this->getEdict(), "[" NCZ_PLUGIN_NAME "] Please, dont flood this function.\n");
	}
}

void Cg_NCZ_Player::Connecting()
{
	connectionTime = (int)(GetTime() + 0.00000001);
}

void Cg_NCZ_Player::AddToBanlistCheck()
{
	if(banlists)
	{
		const char * SteamID = this->getSteamID();
		if(!SteamID) return;

		if(!(SteamID[0] == 'B' || SteamID[6] == 'I'))
		{
			banlists->send(tostring(SteamID));
		}
	}
}

void Cg_NCZ_Player::mystatus()
{
	if(/*allow_status &&*/(last_auto_status + 1.0f < GetTime()))
	{
		last_auto_status = GetTime();
		edict_t* edict = this->getEdict();
		contell(edict, format("[" NCZ_PLUGIN_NAME "] %s :", GetTranslate("AutoStatus").c_str()).c_str());
		contell(edict, "--------------------------");
		contell(edict, format("uID  - NAME             [     Steam-ID     ] - %s      - K/D - rate / cmd / update / interp (ratio)", GetTranslate("Team").c_str()).c_str());
		for (int i=1; i<=gpGlobals->maxClients; i++)
		{
			Cg_NCZ_Player *MyPlayer = g_NoCheatZPlugin.get_m_pm()->getPlayer(i);
			if(MyPlayer)
			{
				IPlayerInfo* PlayerInfo = MyPlayer->getPlayerInfo();
				if(PlayerInfo)
				{
					if(PlayerInfo->IsConnected())
					{
						if(MyPlayer->isRealPlayer())
						{
							const char * team = GetTranslate("Spectator").c_str();
							if (PlayerInfo->GetTeamIndex() == 2)
							{
								team = "Terrorist";
							}
							else if (PlayerInfo->GetTeamIndex() == 3)
							{
								team = "CT";
							}
							contell(edict, format("%s - %s [%s] - %s - %d/%d - %s", minStrf(tostring(MyPlayer->getUserid()), 4).c_str(), minStrf(MyPlayer->getName(), 16).c_str(), minStrf(MyPlayer->getSteamID(), 16).c_str(), minStrf(team, 9).c_str(), PlayerInfo->GetFragCount(), PlayerInfo->GetDeathCount(), getStrRates(i).c_str()).c_str());
							//delete team;
						}
					}
				}
			}
		}
		edict_t *pTV = getSourceTV();
		if(pTV)
		{
			Cg_NCZ_Player *MyTV = g_NoCheatZPlugin.get_m_pm()->getPlayer(pTV);
			contell(edict, format("%s - %s [     Source TV    ] -> TV Delay : %s s, TV Port : %s", minStrf(format("%d", MyTV->getUserid()), 4).c_str(), minStrf(MyTV->getName(), 16).c_str(), g_pCVar->FindVar("tv_delay")->GetString(), g_pCVar->FindVar("tv_port")->GetString()).c_str());
		}
		contell(edict, "--------------------------");
		contell(edict, "Steam Community Links :");
		for (int i=1; i<=gpGlobals->maxClients; i++)
		{
			Cg_NCZ_Player *MyPlayer = g_NoCheatZPlugin.get_m_pm()->getPlayer(i);
			if(MyPlayer)
			{
				if(MyPlayer->isRealPlayer())
				{
					contell(edict, format("%s -> %s", MyPlayer->getName(), getCommunityID(MyPlayer->getSteamID()).c_str()).c_str());
				}
			}
		}
		contell(edict, "--------------------------");
	}
}

void Cg_NCZ_Player::setBanRequestTime()
{
	if(ban_request_time == 0.0f)
	{
		ban_request_time = GetTime() + 11.0f;
	}
	else
	{
		ban_request_time = GetTime() + 60.0f;
	}
}

void Cg_NCZ_Player::Disconnecting()
{
	if (this->getTotalDetectionsCount() > 0)
	{
		std::string tolog = "";
		tolog  = NCZ_REPORT_FIRST_LINE
		tolog += format("%s [%s] disconnected with %d detections.", this->getName(), this->getSteamID(), this->getTotalDetectionsCount());
		tolog += format("Detection Details -> Bad Eye Angle X : %d, Bad Eye Angle Y : %d, Bad Eye Angle Z : %d, Aimbot : %d, ConVar Bypass : %d, TriggerBot : %d, BunnyHop Script %d.\n", this->total_beax, this->total_beay, this->total_beaz, total_badm, this->total_cvb, this->total_rf, total_bh);
		queue_send_report->send(format("i=%s&l=%s&aab=0", this->getSteamID(), tolog.c_str()));
		writeToLogfile(format("%s : Player %s [%s] disconnected with %d detections.\n------------------------------------------------------------", getStrDateTime("%x %X").c_str(), this->getName(), this->getSteamID(), this->getTotalDetectionsCount()));
		if(kick_ban)
		{
			//xMsg("Can't ban %d %s [%s] - %s (ncz_kick_and_ban = 0).\n");
			engine->ServerCommand("writeid\n");
			engine->ServerCommand("writeip\n");
		}
	}
	ban_request_time = 0.0f;
	total_beax = 0;
	total_beay = 0;
	total_beaz = 0;
	total_cvb = 0;
	total_rf = 0;
	total_badm = 0;
	xtrigger_count = 0;
	ytrigger_count = 0;
	sub_badm = 0;
	total_bh = 0;
	lastGoodAngles = QAngle(0,0,0);
}

void Cg_NCZ_Player::nameChanged(const char * newName)
{
	std::string name = newName;
	if(name.find('&') != std::string::npos)
	{
		engine->ServerCommand(format("kickid %s \"Illegal char detected in your name.\"\n", this->getSteamID()).c_str());
	}
	++nameChanges;
	if(nameChanges > 1)
	{
		this->addLog("Too many name changes.");
		std::string tolog = "";
		tolog  = NCZ_REPORT_FIRST_LINE
		tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), "Too many name changes.");
		queue_send_report->send(format("i=%s&l=%s", this->getSteamID(), tolog.c_str()));
		noTell(this->getEdict(), format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> Too many name changes.", this->getName(), this->getSteamID()).c_str());
		this->Ban(false, 0, "Banned by NoCheatZ 3");
	}
}

void Cg_NCZ_Player::resetNamesChanges()
{
	nameChanges = 0;
}

void Cg_NCZ_Player::Ban(bool wait, int minutes, const char * msg)
{
	if(kick_ban)
	{
		if(!wait)
		{
			const char * SteamID = this->getSteamID();
			if(SteamID)
			{
				bool isConnected = this->getPlayerInfo()->IsConnected();
				bool banHandled = false;
				if (isConnected)
				{
					if(FINDCOMMAND("gb_externalBanUser"))
					{
						engine->ServerCommand(format("gb_externalBanUser \"%s\" \"%s\" \"%s\" %d minutes \"%s\"\n", gb_admin_id.c_str(), SteamID, gb_reason_id.c_str(), minutes, this->getName()).c_str());
						//banHandled = true;
					}
					if(FINDCOMMAND("sm_ban"))
					{
						engine->ServerCommand(format("sm_ban %d %d \"%s\"\n", this->getUserid(), minutes, msg).c_str());
						banHandled = true;
					}
					//if(FINDCOMMAND("ma_ban")) engine->ServerCommand(format("ma_ban \"%s\" %d \"%s\"\n", SteamID, minutes, msg).c_str());
				}
			
				if(!banHandled && isConnected)
				{
					engine->ServerCommand(format("banid %d %s\n", minutes, this->getSteamID()).c_str());
					this->Kick(msg);
					engine->ServerCommand("writeid\n");
					if (strcmp("127.0.0.1", this->getIPAddress()) != 0 && !banHandled)
					{
						engine->ServerCommand(format("addip 1440 \"%s\"\n", this->getIPAddress()).c_str());
						engine->ServerCommand("writeip\n");
					}
				}
			}
			ban_request_time = 0.0f;
		}
		else
		{
			if (kick_ban && (ban_request_time < GetTime()))
			{
				xMsg("Delayed ban for %s [%s] - %s, waiting for other detections ...\n", this->getName(), this->getSteamID(), this->getIPAddress());
				this->setBanRequestTime();
			}
		}
	}
}

void Cg_NCZ_Player::startRIE()
{
	writeToLogfile(getStrDateTime("%x %X") + format(" : %s [%s] %s.", this->getName(), this->getSteamID(), GetTranslate("player_record").c_str()));
	myDemoTicksCount = 0;
	recordingRIE = true;
}

void Cg_NCZ_Player::check_ban_request()
{
	if((ban_request_time <= GetTime()) && (!ban_request_time == 0.0f))
	{
		if(total_beay == 1) total_beay = 0; // Supress false detection.
		if(this->getTotalDetectionsCount() > 20 || this->total_cvb > 1 || this->total_beax > 40 || this->total_beay > 40 || this->total_beaz > 10 || this->total_rf > 1 || total_badm > 6 || total_bh > 1)
		{
			if (kick_ban)
			{
				xMsg("Ban of %d %s [%s] - %s permanently.\n", this->getUserid(), this->getName(), this->getSteamID(), this->getIPAddress());
			}
			const char * msg = "Banned by NoCheatZ 3";
			if(report_cheats) msg = format("Banned by NoCheatZ 3 (http://nocheatz.com/?id=%s)", this->getSteamID()).c_str();
			this->Ban(false, 0, msg);
		}
		else
		{
			/*if (kick_ban)
			{
				//xMsg("Ban delayed for %d %s [%s] - %s. Need more detections.\n", this->getUserid(), this->getName(), this->getSteamID(), this->getIPAddress());
			}*/
			ban_request_time += 11.0f;
		}
	}
}

void Cg_NCZ_Player::Kick(const char * msg)
{
	if (kick_ban)
	{
		engine->ServerCommand(format("kickid %d [" NCZ_PLUGIN_NAME "] %s\n", this->getUserid(), msg).c_str());
	}
}

int Cg_NCZ_Player::getTotalDetectionsCount() const
{
	return (total_beax + total_beay + total_beaz + total_cvb + total_rf + total_badm + total_bh);
}

void Cg_NCZ_Player::addLog(std::string text)
{
	Msg("%s [%s - %s] : %s.\n", this->getName(), this->getSteamID(), this->getIPAddress(), text.c_str());

	std::string tolog = "";
	tolog  = "MAP : " + getMapName() +  " - Date Time : " + getStrDateTime("%x %X") + " : ";
	tolog += format("%s [%s - %s] : %s.\n", this->getName(), this->getSteamID(), this->getIPAddress(), text.c_str());
	if(recording)
	{
		tolog += format("Demo  : %s.dem -> Tick number %d.\n", recordFilename.c_str(), demoticks);
	}
	writeToLogfile(tolog);
}

void Cg_NCZ_Player::testConfig()
{
#ifndef NCZ_CSS
	if(this->isValidPlayer() && ncz_active && test_config)
	{
		if(this->isRealPlayer())
		{
			float rate = atof(getClCV(this->getIndex(), "rate"));
			float cmdrate = atof(getClCV(this->getIndex(), "cl_cmdrate"));
			float updaterate = atof(getClCV(this->getIndex(), "cl_cmdrate"));
			float interp = atof(getClCV(this->getIndex(), "cl_interp"));
			if(rate != 0 && rate <= 10000.0f)
			{
				this->Kick(GetTranslate("rate_kick").c_str());
			}
			if(!between(cmdrate, 30.0f, 101.0f))
			{
				this->Kick(GetTranslate("cl_cmdrate_kick").c_str());
			}
			if(!between(updaterate, 20.0f, 101.0f))
			{
				this->Kick(GetTranslate("cl_updaterate_kick").c_str());
			}
			if(!between(interp, 0.0f, 0.1f))
			{
				this->Kick(GetTranslate("cl_interp_kick").c_str());
			}
		}
	}
#endif
}

void Cg_NCZ_Player::handleConvarTest()
{
	if(check_client_vars) return;
	if(lastCvarTest + 33 > gpGlobals->tickcount) return;
	if(!this->isCheckable()) return;
	if(waitcvarresp) return;

	lastCvarTest = gpGlobals->tickcount;
	ConvarList::iterator it;

	if(lastCvarTested)
	{
		for(it = g_cvars.begin(); it != g_cvars.end(); ++it)
		{
			if(strcmp(it->first, lastCvarTested) == 0)
			{
				++it;
				break;
			}
		}
	}
	else it = g_cvars.begin();

	//if(it != g_cvars.end())
	//{
		
		if(it != g_cvars.end())
		{
			waitcvarresp = true;
			helpers->StartQueryCvarValue(this->getEdict(), it->first);
			//Msg("Asking %s.\n", it->first);
		}
		else 
		{
			waitcvarresp = true;
			helpers->StartQueryCvarValue(this->getEdict(), g_cvars.begin()->first);
			//Msg("Asking %s.\n", g_cvars.begin()->first);
		}

	//}
}

void Cg_NCZ_Player::testConVarsCallback(QueryCvarCookie_t iCookie, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue)
{
	//Msg("Got %s = %s.\n", pCvarName, pCvarValue);
	ConvarList::iterator it;
	/*if(strcmp("m_pitch", pCvarName) == 0)
	{
		//m_pitchValue = pCvarValue;
		last_m_pitchValue = m_pitchValue;
		m_pitchValue = pCvarValue;
		m_pitchReady = true;
	}
	if(strcmp("m_filter", pCvarName) == 0)
	{
		//m_filterValue = pCvarValue;
		m_filterValue = pCvarValue;
		m_filterReady = true;
	}*/
	if (check_client_vars)
	{
		bool isOurVar = false;
		if (eStatus == eQueryCvarValueStatus_ValueIntact)
		{
			for(it = g_cvars.begin(); it != g_cvars.end(); ++it)
			{
				if(strcmp(it->first, pCvarName) == 0) break;
			}
			if(it != g_cvars.end()) isOurVar = true;
			if (isOurVar)
			{
				std::string value(it->second);
				ConVar * convar_to_link = g_pCVar->FindVar(pCvarName);
				if (value == "$sv" && convar_to_link)
				{
					value = convar_to_link->GetString();
				}
				if (value.find(pCvarValue) == std::string::npos && value != "$n")
				{
					if(tostring(pCvarName) == "host_framerate")
					{
							//total_cvb ++;
							//std::string tolog = "";
							//tolog  = NCZ_REPORT_FIRST_LINE
							//tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("Bad ConVar value : %s = %s (Must be equal to 0)", pCvarName, pCvarValue, value.c_str()).c_str());
							//queue_send_report->send(format("i=%s&l=%s", this->getSteamID(), tolog.c_str()));
							noTell(this->getEdict(), format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> Bad host_framerate.", this->getName(), this->getSteamID()).c_str());
							this->Kick(format("%s host_framerate %s %s.", GetTranslate("Type").c_str(), value.c_str(), GetTranslate("into_console").c_str()).c_str());
					}
					else if(tostring(pCvarName) == "host_timescale")
					{
						if (strcmp("1.0", pCvarValue) != 0)
						{
							total_cvb ++;
							std::string tolog = "";
							tolog  = NCZ_REPORT_FIRST_LINE
							tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("Bad ConVar value : %s = %s (Must be equal to %s)", pCvarName, pCvarValue, value.c_str()).c_str());
							queue_send_report->send(format("i=%s&l=%s", this->getSteamID(), tolog.c_str()));
							noTell(this->getEdict(), format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> Bad host_timescale.", this->getName(), this->getSteamID()).c_str());
							this->Kick(format("%s host_timescale %s %s.", GetTranslate("Type").c_str(), value.c_str(), GetTranslate("into_console").c_str()).c_str());
						}
					}
					else
					{
						total_cvb ++;
						if(last_cvb_log + 10.0f < GetTime() && lastCvarDetected.find(pCvarName) == std::string::npos)
						{
							lastCvarDetected = pCvarName;
							last_cvb_log = GetTime();
							this->addLog(format("%s : %s = %s (%s %s)", GetTranslate("bad_value").c_str(), pCvarName, pCvarValue, GetTranslate("must_be_equal").c_str(), value.c_str()));
							std::string tolog = "";
							tolog  = NCZ_REPORT_FIRST_LINE
							tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("Bad ConVar value : %s = %s (Must be equal to %s)", pCvarName, pCvarValue, value.c_str()).c_str());
							queue_send_report->send(format("i=%s&l=%s&fab=1", this->getSteamID(), tolog.c_str()));
							noTell(this->getEdict(), format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> %s ConVar Bypass %s.", this->getName(), this->getSteamID(), pCvarName, GetTranslate("Detected").c_str()).c_str());
						}
						this->Ban(true, 0, "Banned by NoCheatZ 3");
					}
				}
				if(value == "$n")
				{
					total_cvb ++;
					if(last_cvb_log + 10.0f < GetTime() && lastCvarDetected.find(pCvarName) == std::string::npos)
					{
						lastCvarDetected = pCvarName;
						this->addLog(format("ConVar must not exists : %s.", pCvarName));
						std::string tolog = "";
						tolog  = NCZ_REPORT_FIRST_LINE
						tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("ConVar must not exists : %s.", pCvarName).c_str());
						queue_send_report->send(format("i=%s&l=%s&aab=1&fab=1", this->getSteamID(), tolog.c_str()));
						noTell(this->getEdict(), format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> Illegal ConVar Detected.", this->getName(), this->getSteamID()).c_str());
					}
					this->Ban(true, 0, "Banned by NoCheatZ 3");
				}
			}
		}
		else if (eStatus == eQueryCvarValueStatus_CvarNotFound)
		{
			for(it = g_cvars.begin(); it != g_cvars.end(); ++it)
			{
				if(strcmp(it->first, pCvarName) == 0) break;
			}
			if(it != g_cvars.end()) isOurVar = true;
			if(isOurVar)
			{
				std::string value = it->second;
				if(!(value == "$n"))
				{
					std::string tolog = "";
					tolog  = NCZ_REPORT_FIRST_LINE
					tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("Cvar Not Found : %s", pCvarName).c_str());
					queue_send_report->send(format("i=%s&l=%s&aab=0&fab=1", this->getSteamID(), tolog.c_str()));
				}
			}
		}
		else if (eStatus == eQueryCvarValueStatus_NotACvar)
		{
			std::string tolog = "";
			tolog  = NCZ_REPORT_FIRST_LINE
			tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("Not A Cvar : %s", pCvarName).c_str());
			queue_send_report->send(format("i=%s&l=%s&aab=0", this->getSteamID(), tolog.c_str()));
		}
		else if (eStatus == eQueryCvarValueStatus_CvarProtected)
		{
			std::string tolog = "";
			tolog  = NCZ_REPORT_FIRST_LINE
			tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("Cvar protected : %s", pCvarName).c_str());
			queue_send_report->send(format("i=%s&l=%s&aab=0", this->getSteamID(), tolog.c_str()));
		}
		waitcvarresp = false;
	}
}

void Cg_NCZ_Player::tell(const char *message)
{
	if (this->isValidPlayer())
	{
		MRecipientFilter filter;
		filter.AddRecipient(this->getIndex());
		bf_write *pBuffer = engine->UserMessageBegin( &filter, 3 );
		pBuffer->WriteByte( 0 );
		pBuffer->WriteString(message);
		pBuffer->WriteString("\n");
		engine->MessageEnd();
	}
}

float Cg_NCZ_Player::getLastLogTime(int ang) const
{
	if (ang == 0)
	{
		return this->last_log_time_x;
	}
	else if (ang == 1)
	{
		return this->last_log_time_y;
	}
	else if (ang == 3)
	{
		return this->last_log_time_twice;
	}
	else
	{
		return GetTime();
	}
}

void Cg_NCZ_Player::setLastLogTime(int ang)
{
	if (ang == 0)
	{
		last_log_time_x = GetTime() + 3.0f;
	}
	else if (ang == 1)
	{
		last_log_time_y = GetTime() + 3.0f;
	}
	else if (ang == 3)
	{
		last_log_time_twice = GetTime() + 3.0f;
	}
}

void Cg_NCZ_Player::addUkCmd()
{
	cmd_p_s ++;
}

void Cg_NCZ_Player::resetUkCmd()
{
	cmd_p_s = 0;
}

int Cg_NCZ_Player::getUkCmdCount() const
{
	return cmd_p_s;
}

bool testSurfAA(int y)
{
	if((tostring(gpGlobals->mapname.ToCStr()).find("surf") != std::string::npos) && (y == 270))
	{
		return false;
	}
	return true;
}

bool testSurfAA(float y)
{
	if((tostring(gpGlobals->mapname.ToCStr()).find("surf") != std::string::npos) && (y == 270.0f))
	{
		return false;
	}
	return true;
}

bool testFloatInt(float y)
{
	int iy = (int)y;
	float fy = (float)iy;
	if(y == fy) return true;
	return false;
}

bool testFloatY(float y)
{
	int iy = (int)(y + 0.000001);
	float fy = (float)iy;
	if(((y == fy) && aimbots_extra_filter))
	{
		return false;
	}
	return true;
}

void Cg_NCZ_Player::setIgnoreFirst()
{
	ignoreFirst = true;
}

#define DIR_RIGHT_UP 0
#define DIR_RIGHT 1
#define DIR_RIGHT_DOWN 2
#define DIR_DOWN 3
#define DIR_LEFT_DOWN 4
#define DIR_LEFT 5
#define DIR_LEFT_UP 6
#define DIR_UP 7

float maxAimSpeed = 0.0f;

void Cg_NCZ_Player::checkAimDirChange()
{
	if(sub_badv > 7)
	{
		//Msg("Aimbot Detection\n");
		++total_badv;
		sub_badv = 0;
		if(total_badv > 1)
		{
			//this->addLog("Aimbot Detected (System 3 - Aim Speed)");
			//std::string msg = format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> Aimbot Detected (System 3).\n", this->getName(), this->getSteamID());
			//noTell(this->getEdict(), msg.c_str());
			//edict_t * pTV = getSourceTV();
			//if(pTV)
			//{
			//	::tell(pTV, msg.c_str());
			//}
			//std::string tolog = "";
			//xMsg(
			//tolog  = NCZ_REPORT_FIRST_LINE
			//tolog += format("%s [%s] : Aimbot Detected (System 3).\n", this->getName(), this->getSteamID());
			//tolog += "Debug : (Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
			//tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
			//queue_send_report->send(format("i=%s&l=%s", this->getSteamID(), tolog.c_str()));
			//this->Ban(true, 0, "Banned by NoCheatZ 3");
			
		}
	}
}

void Cg_NCZ_Player::testEyeAngles(CUserCmd * pCmd)
{
	if(EyeAnglesAlreadyChecked) return;
	if((aimbot_system_number < 2) && pCmd) return;
	if(!check_aimbots) return;
	if(!this->isRealPlayer()) return;
	if(!this->isCheckable()) return;
	bool detect = false;
	edict_t *pEdict = this->getEdict();
	if(!::isValidEdict(pEdict)) return;
	INetChannelInfo *channel = this->getChannelInfo();
	QAngle hisangles = QAngle(0,0,0);
	short accum = 0;
	short xaccum = 0;
	int command_number = 0;
	if(pCmd)
	{
		//Msg("We got pCmd.\n");
		hisangles = QAngle(pCmd->viewangles);
		accum = pCmd->mousedy;
		xaccum = pCmd->mousedx;
		EyeAnglesAlreadyChecked = true;
	}
	else
	{
		hisangles = this->getPlayerInfo()->GetLastUserCommand().viewangles;
		accum = this->getPlayerInfo()->GetLastUserCommand().mousedy;
		xaccum = this->getPlayerInfo()->GetLastUserCommand().mousedx;
		//if(this->getPlayerInfo()->GetLastUserCommand().weaponselect != 0) printf("%d\n", this->getPlayerInfo()->GetLastUserCommand().weaponselect);
	}
	// New hack detection which can detect aimbots that is modifying Eye Angles even if they fix angles from going too far.

	float aimSpeed = 0.0f;
	float x = (hisangles.x - lastfx);
	float absCurY = fabs(hisangles.y);
	float absLastY = fabs(lastfy);
	float y = (absCurY - absLastY);

	aimSpeed = sqrt(x) + sqrt(y);


	if(fabs(hisangles.x) < 89.0f && fabs(hisangles.y) < 180.0f && fabs(hisangles.z) < 90.0f)
	{
		/*                                                 FIXME
		if(aimbot_system_number >= 3)
		{
		if(aimSpeed > maxAimSpeed)
		{
		maxAimSpeed = aimSpeed;
		//Msg("MAX Aim Speed : %3.12f \n", aimSpeed);
		}

		if(aimSpeed > 80.0f && !eat_x_lock)
		{
		//Msg("Aim Speed : {%3.3f, %3.3f} {%3.3f, %3.3f} => %3.12f \n", hisangles.x, hisangles.y, lastfx, lastfy, aimSpeed);
		++sub_badv;
		}
		}
		*/

#ifndef NCZ_CSGO
		//lastAimSpeed = aimSpeed;
		Cg_NCZ_Player *ptarget = aimingAt();
		if(aimbot_system_number > 1)
		{
			/*
			if(m_pitchReady && m_filterReady)
			{
				if(notsureabout)
				{
					if(last_m_pitchValue)
					{
						if(strcmp(last_m_pitchValue, m_pitchValue) != 0)
						{
							if(sub_badm)
							{
								//xMsg("Removed %d false pre-detections on anti-aimbot system 2 for %s [%s].", sub_badm, this->getName(), this->getSteamID());
								sub_badm = 0;
							}
						}
						last_m_pitchValue = m_pitchValue;
					}
					notsureabout = false;
				}

				fx = hisangles.x;
				fy = hisangles.y;
				//Msg("%3.6f (%3.6f) : %3.6f : %3.6f\n", hisangles.x, fx, hisangles.y, hisangles.z);

				// Is he using inverted mouse ?
				//const char *sPitch = engine->GetClientConVarValue(this->getIndex(), "m_pitch");
				if(std::string(m_pitchValue).find("-") != std::string::npos) accum *= -1; // If so then invert his accumm too.
				int iFilter = atoi(m_filterValue);

#define SUBPROCEDURE_DETECT_SENDINFO(a) std::string sublog = ""; \
	sublog  = NCZ_REPORT_FIRST_LINE \
	sublog += format("Aimbot SubDetection Case "a" : CM {%d, %d} CVA {%3.4f, %3.4f, %3.1f} LM {%d, %d} LVA {%3.4f, %3.4f} TC {%d}\n", accum, xaccum, hisangles.x, hisangles.y, hisangles.z, lastdy, lastdx, lastfx, lastfy, xtrigger_count); \
	if(ptarget) sublog += format("+ Aiming at : %s [%s]\n", target->getName(), target->getSteamID()); \
	sublog += "Debug : (Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n"; \
	sublog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount()); \
	queue_send_report->send(format("i=%s&l=%s&aab=0&ah=1", this->getSteamID(), sublog.c_str()));
				
				if(ptarget)
				{
					if(!lastdy == 0)
					{
						if(accum == 0 && lastdy == 0 && xaccum == 0)
						{
							if(fabs(fabs(fx) - fabs(lastfx)) > 0.5f || fabs(fabs(fy) - fabs(lastfy)) > 0.5f)
							{
								if(!ignoreFirst && iFilter > 0) // Avoid false detection at spawn
								{
									SUBPROCEDURE_DETECT_SENDINFO("1")
										detect = true;
								}
								else
								{
									ignoreFirst = false;
								}
							}
						}
						if((fx != lastfx || fy != lastfy)) // Si la souris bouge avec la visée
						{
							if((accum > 0) && !(lastdy < 0))
							{
								if(!(fx >= lastfx) && !((fabs(fx) == 90.0f) || (fabs(lastfx) == 90.0f)) )
								{
									if(!ignoreFirst) // Avoid false detection at spawn
									{
										SUBPROCEDURE_DETECT_SENDINFO("2")
											detect = true;
									}
									else
									{
										ignoreFirst = false;
									}
								}
							}
							else if((accum < 0) && !(lastdy > 0))
							{		
								if(!(fx <= lastfx) && !((fabs(fx) == 90.0f) || (fabs(lastfx) == 90.0f)) )
								{
									if(!ignoreFirst) // Avoid false detection at spawn
									{
										SUBPROCEDURE_DETECT_SENDINFO("3")
											detect = true;
									}
									else
									{
										ignoreFirst = false;
									}
								}
							}
							if((xaccum > 0) && !(lastdx < 0))
							{
								if(!(fy <= lastfy) && (!(fy > 0.0f && lastfy < 0.0f) && !((fy < 0.0f && lastfy > 0.0f)) && !(lastfy == 0.0f)))
								{
									if(!ignoreFirst) // Avoid false detection at spawn
									{
										SUBPROCEDURE_DETECT_SENDINFO("4")
											detect = true;
									}
									else
									{
										ignoreFirst = false;
									}
								}
							}
							else if((xaccum < 0) && !(lastdx > 0))
							{
								if(!(fy >= lastfy) && (!(fy > 0.0f && lastfy < 0.0f) && !((fy < 0.0f && lastfy > 0.0f)) && !(lastfy == 0.0f)))
								{
									if(!ignoreFirst) // Avoid false detection at spawn
									{
										SUBPROCEDURE_DETECT_SENDINFO("5")
											detect = true;
									}
									else
									{
										ignoreFirst = false;
									}
								}
							}
						}
					}
				}
			}
			else
			{
				notsureabout = true;
				helpers->StartQueryCvarValue(pEdict, "m_pitch");
				helpers->StartQueryCvarValue(pEdict, "m_filter");
				//m_pitchReady = false;
				//m_filterReady = false;
			}

			lastdy = accum;
			lastdx = xaccum;
			lastfx = fx;
			lastfy = fy;

			if(!detect)
			{
				xtrigger_count = 0;
			}
			else
			{
				++xtrigger_count;
				last_trigger_add = GetTime();
			}


			if(xtrigger_count > 8)
			{
				SUBPROCEDURE_DETECT_SENDINFO("6")
				++sub_badm;
				xtrigger_count = 0;
				helpers->StartQueryCvarValue(pEdict, "m_pitch");
				notsureabout = true;
				last_m_pitchValue = m_pitchValue;
				m_pitchReady = false;
			}

			if(sub_badm > 12 && notsureabout == false)
			{
				++total_badm;
				sub_badm = 0;
				this->addLog("Aimbot Detected (System 2)");
				std::string msg = format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> Aimbot Detected (System 2).\n", this->getName(), this->getSteamID());
				//this->addLog(format("Latency : %3.9f (%3.9f)\n", channel->GetLatency(FLOW_INCOMING), channel->GetAvgLatency(FLOW_INCOMING)));
				noTell(this->getEdict(), msg.c_str());
				edict_t * pTV = getSourceTV();
				if(pTV)
				{
					::tell(pTV, msg.c_str());
				}
				std::string tolog = "";
				tolog  = NCZ_REPORT_FIRST_LINE
					tolog += format("%s [%s] : Aimbot Detected (System2).\n", this->getName(), this->getSteamID());
				if(ptarget) tolog += format("+ Aiming at : %s [%s]\n", target->getName(), target->getSteamID());
				//tolog += format("Latency : %3.9f (%3.9f)\n", channel->GetLatency(FLOW_INCOMING), channel->GetAvgLatency(FLOW_INCOMING));
				tolog += "Debug : (Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
				tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
				queue_send_report->send(format("i=%s&l=%s&aab=0", this->getSteamID(), tolog.c_str()));
				this->Ban(true, 0, "Banned by NoCheatZ 3");
			}*/
		}
#endif
	}
	else
	{

		beax = false;
		beay = false;
		beaz = false;
		const float currentTime = GetTime();
		fx = fabs(hisangles.x);
		fy = fabs(hisangles.y);
		fz = fabs(hisangles.z);


		bads = "";
		sugg = "";
		if (fx > 89.0f)
		{
			beax = true;
		}
		if(fz > 90.0f)
		{
			beaz = true;
		}
		if((fy > 180.0f) && !(fy == 255.0f) )
		{
			bool tsAA = testSurfAA(fy);
			bool tempCond = true;
			if(aimbots_extra_filter && (fy == 270.0f)) tempCond = false;
			if(tempCond && tsAA)
			{
				if(!this->isInBuyZone())
				{
					beay = true;
				}
				else if(this->isInBuyZone() && !beax) return;
			}
			else if(!tempCond && !tsAA)
			{
				if (this->getLastLogTime(2) < currentTime)
				{
					fy = hisangles.y;
					std::string message(getStrDateTime("%x %X") + format(" : Eye Angles Extra Filter -> Ignoring this detection : Bad Y (Yaw) Eye Angle (Y = %3.4f) (Probably Anti Aim Hack) for %s [%s - %s].", fy, this->getName(), this->getSteamID(), this->getIPAddress()));
					writeToLogfile(message);
				}
			}
		}

		if(!beay) ytrigger_count = 0;
		else ytrigger_count ++;

		if(ytrigger_count < 3) beay = false;

		if(!beax && !beay && !beaz) return;

		fx = hisangles.x;
		fy = hisangles.y;
		fz = hisangles.z;

		bool already = false;
		bool sugg_already = false;
		bool aah = false;
		bool aimbot = false;
		bool spinhack = false;
		bool nospread = false;
		bool norecoil = false;
		if(beax)
		{
			already = true;
			bads.append("Bad X (Pitch)");
			if(testFloatInt(fx))
			{
				aah = true;
			}
			else
			{
				norecoil = true;
			}
		}
		if(beay)
		{
			if(already)
			{
				bads.append(" and ");
			}
			already = true;
			bads.append("Bad Y (Yaw)");
			if(testFloatInt(fy))
			{
				aah = true;
				spinhack = true;
			}
			else
			{
				nospread = true;
				aimbot = true;
			}
		}
		if(beaz)
		{
			if(already)
			{
				bads.append(" and ");
			}
			already = true;
			bads.append("Bad Z (Roll)");
			aah = true;
		}
		if(aah)
		{
			sugg.append("Anti Aim Hack");
			sugg_already = true;
		}
		if(aimbot)
		{
			if(sugg_already)
			{
				sugg.append("/");
			}
			sugg_already = true;
			sugg.append("Aimbot");
		}
		if(spinhack)
		{
			if(sugg_already)
			{
				sugg.append("/");
			}
			sugg_already = true;
			sugg.append("Spinhack");
		}
		if(nospread || norecoil)
		{
			if(sugg_already)
			{
				sugg.append("/");
			}
			sugg_already = true;
			sugg.append("Accuracy Hack");
		}
		if(pCmd) sugg.append(" (System 4 - Blocked and Detected)");
		else sugg.append(" (System 1 - Detected)");
		if((gpGlobals->tickcount - lastSpawnTime > 335) && lastSpawnTime > 0)
		{
			if(beax) total_beax ++;
			if(beay) total_beay ++;
			if(beaz) total_beaz ++;
			if (this->getLastLogTime(3) < currentTime )
			{
				this->setLastLogTime(3);
				this->addLog(format("%s Eye Angles (x=%3.4f, y=%3.4f, z=%3.4f) -> %s", bads.c_str(), fx, fy, fz, sugg.c_str()));
				noTell(this->getEdict(), format("\1[\004" NCZ_PLUGIN_NAME "\001] %s [\003%s\001] -> %s %s.\n", this->getName(), this->getSteamID(), sugg.c_str()).c_str());
				std::string tolog = "";
				tolog  = NCZ_REPORT_FIRST_LINE
					tolog += format("%s [%s] : %s.\n", this->getName(), this->getSteamID(), format("%s Eye Angles (x=%3.4f, y=%3.4f, z=%3.4f) -> %s", bads.c_str(), fx, fy, fz, sugg.c_str()).c_str());
				tolog += "Debug : (Weapon, Time Connected,  Kills/Deaths, Total Detections Count)\n";
				tolog += format("------> (%s, %s, %s/%s, %d)\n", this->getWeapon(), formatSeconds(this->getTimeConnected()).c_str(), tostring(this->getPlayerInfo()->GetFragCount()).c_str(), tostring(this->getPlayerInfo()->GetDeathCount()).c_str(), this->getTotalDetectionsCount());
				queue_send_report->send(format("i=%s&l=%s&fab=1", this->getSteamID(), tolog.c_str()));
				this->Ban(true, 0, "Banned by NoCheatZ 3");
				//entpropsmanager->getPropValue<float>("CCSPlayer.m_angEyeAngles[0]", pEdict) = lastGoodAngles.x;
				//entpropsmanager->getPropValue<float>("CCSPlayer.m_angEyeAngles[1]", pEdict) = lastGoodAngles.y;
			}
		}
	}
}

void Cg_NCZ_Player::update()
{
	if(recordingRIE) myDemoTicksCount ++;
	if(GetTime() > nextSecond) this->eat_unlock();
}

void Cg_NCZ_Player::setLastLockTime()
{
	last_lock_time = gpGlobals->tickcount;
}

void Cg_NCZ_Player::eat_lock()
{
	this->setLastLockTime();
	eat_x_lock = true;
	eat_y_lock = true;
	eat_z_lock = true;
	ignoreFirst = true;
}

void Cg_NCZ_Player::eat_unlock()
{
	if (this->isValidPlayer())
	{
		IPlayerInfo* pInfo = this->getPlayerInfo();
		if(pInfo)
		{
			if(!pInfo->IsDead() && pInfo->GetTeamIndex() > 1)
			{
				if ((last_lock_time + 330 <= gpGlobals->tickcount) && last_lock_time)
				{
					eat_x_lock = false;
					eat_y_lock = false;
					eat_z_lock = false;
					return;
				}
			}
		}
	}
}


// -------------------------------------------------------------------------------------------------------------
// Others Functions
// -------------------------------------------------------------------------------------------------------------

void needUseWeb()
{
	if(!report_cheats && !queue_send_report->empty())
	{
		queue_send_report->erase();
	}
	if(!banlists->empty() && !use_banlists)
	{
		banlists->erase();
	}
	if ((!queue_send_report->empty() && report_cheats) || !disconnectingPlayers->empty() /*|| !player_conf->empty()*/ || (!banlists->empty() && use_banlists) || maySendHeartbeat)
	{
		//Msg("Waking up WebThread.\n");
#ifndef NCZ_CSGO
		if(!TheWebThread) TheWebThread = new NczThread();
		if(!TheWebThread->IsAlive())
		{
			TheWebThread->Start();
		}
#else
		if(!TheWebThread) TheWebThread = new NczThread();
		if(TheWebThread->MustBeKilled())
		{
			TheWebThread->Terminate(0);
			//delete TheWebThread;
			TheWebThread = new NczThread();
		}
		if(!TheWebThread->IsAlive()) TheWebThread->Start();
#endif
	}
}

#ifdef WIN32
std::string NumString_Add(std::string num, std::string add)
{
	int numero1, numero2, temp, retenue = 0;
	std::string resultat = "";

	while(num.length() || add.length())
	{

		numero1 = 0;
		numero2 = 0;
		if(num.length())
		{
			numero1 = atoi(tostring(num.back()).c_str());
			num.pop_back();
		}
		if(add.length())
		{
			numero2 = atoi(tostring(add.back()).c_str());
			add.pop_back();
		}

		temp = numero1 + numero2 + retenue;

		if(temp > 9)
		{
			std::string tretenue = tostring(format("%d", temp).at(0));
			retenue = atoi(tretenue.c_str());
		}
		else
		{
			retenue = 0;
		}
		std::string fix = format("%d", temp);
		resultat = fix.back() + resultat;
	}
	return resultat;
}
#else
std::string NumString_Add(std::string num, std::string add)
{
	int numero1, numero2, temp, retenue = 0;
	std::string resultat = "";

	while(num.length() || add.length())
	{
		//if(isdigit(num.back()) && isdigit(add.back()))

		numero1 = 0;
		numero2 = 0;
		if(num.length())
		{
			numero1 = atoi(tostring(num.substr(num.length()-1, num.length())).c_str());
			num = num.substr(0, num.length()-1);
		}
		if(add.length())
		{
			numero2 = atoi(tostring(add.substr(add.length()-1, add.length())).c_str());
			add = add.substr(0, add.length()-1);
		}

		temp = numero1 + numero2 + retenue;

		if(temp > 9)
		{
			std::string tretenue = tostring(format("%d", temp).at(0));
			retenue = atoi(tretenue.c_str());
		}
		else
		{
			retenue = 0;
		}
		std::string fix = format("%d", temp);
		fix = fix.substr(fix.length()-1, fix.length());
		resultat = fix + resultat;
	}
	return resultat;
}
#endif

bool between(const int n, const int min, const int max) // min and max Included
{
	if ((n <= max) && (n >= min))
	{
		return true;
	}
	return false;
}

bool between(const float n, const float min, const float max) // min and max Included
{
	if ((n <= max) && (n >= min))
	{
		return true;
	}
	return false;
}

std::string to_lowercase(const std::string& s)
{
	std::string k = s;
	toLowerCase(k);
	return k;
}


std::string format(const char *fmt, ...)
{
	va_list		argptr;
	static char		string[4096];

	va_start(argptr, fmt);
	Q_vsnprintf(string, sizeof(string), fmt,argptr);
	va_end (argptr);

	return tostring(string);
}

template<class T>
T *FindIFace(const char *IFaceName, CreateInterfaceFn Factory)
{
	T *pIFace = NULL;
	int i_v = 40;
	char s_v[64];
	while ( !pIFace )
	{
		if(i_v < 0)
		{
			return NULL;
		}
		if(i_v < 10)
		{
			sprintf(s_v, "%s00%d", IFaceName, i_v);
			//s_v = format("%s00%d", IFaceName, i_v);
		}
		else if(i_v < 100 && i_v > 9)
		{
			sprintf(s_v, "%s0%d", IFaceName, i_v);
			//s_v = format("%s0%d", IFaceName, i_v);
		}
		pIFace = (T*)Factory(s_v,NULL);
		--i_v;
	}
	return pIFace;
}

char* long2ip(unsigned long v) 
{ 
	struct in_addr x;
	x.s_addr = htonl(v);
	return inet_ntoa(x);
} 

float positiv(const float n)
{
	float x = n;
	if(x < 0)
	{
		x = x * -1;
	}
	return x;
}

int positiv(const int n)
{
	int x = n;
	if(x < 0)
	{
		x = x * -1;
	}
	return x;
}

int getIndexFromUserID(int userid)
{
	for(int i = 1; i <= playerinfomanager->GetGlobalVars()->maxClients; i++)
	{
		if(playerinfomanager->GetPlayerInfo(PlayerList+i))
		{
			if(playerinfomanager->GetPlayerInfo(PlayerList+i)->GetUserID() == userid)
			{
				return i;
			}
		}
	}
	return -1;
}

bool isValidEdict(edict_t * entity)
{
	return entity != NULL && !entity->IsFree() && !entity->GetUnknown() == NULL;
}

std::string getStrGameDir()
{
	return tostring(GAMEDIR);
}

std::string getStrDateTime(const char *format)
{
	time_t rawtime;
	struct tm * timeinfo;
	char date[256];
	time ( &rawtime );
	timeinfo = localtime ( &rawtime );
	strftime(date,sizeof(date),format,timeinfo);
	date[255] = '\0';
	return tostring(date);
}

void writeToLogfile(std::string text)
{
	if(engine)
	{
		std::string path = GAMEDIR"/logs/NoCheatZ_3_Logs/" + getStrDateTime("NoCheatZ-%d-%b-%Y") + ".log";
		std::ofstream fichier;
		fichier.open(path.c_str(), std::ios::out | std::ios::app);
		if(fichier)
		{
			fichier << text << std::endl;
			fichier.close();
		}
		else
		{
			Msg("[NoCheatZ 3] Can't write to logfile ...\n");
			Msg("[NoCheatZ 3] Ensure we have permissions to write in  ...\n");
			Msg(
		}
	}
}

#define PORT 80

std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems)
{
	std::stringstream ss(s);
	std::string item;
	while(std::getline(ss, item, delim))
	{
		elems.push_back(item);
	}
	return elems;
}

std::vector<std::string> split(const std::string &s, char delim)
{
	std::vector<std::string> elems;
	return split(s, delim, elems);
}

edict_t * getEdictFromSteamID(const char *SteamID)
{
	const int imax = gpGlobals->maxClients;
	for(int i = 1;i<=imax;i++)
	{
		edict_t* pEntity = PEntityOfEntIndex(i);
		if(V_strcmp(engine->GetPlayerNetworkIDString(pEntity), SteamID) == 0)
		{
			return pEntity;
		}
	}
	return NULL;
}

int WebThread()
{
	//while(!must_thread_be_killed)
	//{
		while((!queue_send_report->empty()) && UseNet)
		{
			std::string elem = queue_send_report->get();
			if(!report_cheats) continue;
			elem += "&d=";
			elem += dumpConfig();

			NczHttpSockHandler *SendReport = new NczHttpSockHandler();
			if(SendReport->Connect(PIPELINE_ADDRESS, 80))
			{
				SendReport->SendPost("/reportcheat.php", elem);
				SendReport->End();
			}
			else
			{
				xMsg("Connection failed to Master Server. NoCheatZ Network functions will be off for 10 minutes.\n");
				lastNetOff = GetTime();
				UseNet = false;
			}
			delete SendReport;
		}
		if(maySendHeartbeat && UseNet)
		{
			std::string ip;
			if(g_pCVar->GetCommandLineValue("ip") == NULL) ip = "127.0.0.1";
			else ip = g_pCVar->GetCommandLineValue("ip");
			std::string port = g_pCVar->FindVar("hostport")->GetString();
			//if(ip.empty()) ip = "127.0.0.1";

			std::string content = "ip=" + ip + "&port=" + port + "&players=" + tostring(GetPlayerCount()) + "&version=NoCheatZ v" + NCZ_VERSION_STR;

			NczHttpSockHandler *Heartbeat = new NczHttpSockHandler();
			if(Heartbeat->Connect(PIPELINE_ADDRESS, 80))
			{
				Heartbeat->SendPost("/register.php", content);
				Heartbeat->End();
			}
			else
			{
				xMsg("Connection failed to Master Server. NoCheatZ Network functions will be off for 10 minutes.\n");
				lastNetOff = GetTime();
				UseNet = false;
			}
			delete Heartbeat;

			// Check for an update as well

			std::string sVersion;
			int iVersion = 0;
			int iNewVersion = 0;
			std::string pathEfile = GAMEDIR"/addons/nocheatz/version.txt";

			std::ifstream fVersion(pathEfile.c_str());
			if(fVersion)
			{
				fVersion >> iVersion;
			}
			fVersion.close();

			NczHttpSockHandler *GetVersion = new NczHttpSockHandler();
			if(!GetVersion->Connect(PIPELINE_ADDRESS, 80))
			{
				xMsg("Connection failed to Master Server. NoCheatZ Network functions will be off for 10 minutes.\n");
				lastNetOff = GetTime();
				UseNet = false;
				GetVersion->End();
				delete GetVersion;
			}
			else
			{
				GetVersion->SendGet("/update.php");
				std::string content = GetVersion->GetContent();
				iNewVersion = atoi(content.c_str());
			}
			GetVersion->End();
			delete GetVersion;

			if(iNewVersion > iVersion)
			{
		#ifndef WIN32
				xMsg("Plugin is out-of-date. Server will be restarted, when no human players are connected, in order to apply the update with the Auto Updater.\n");
				requireRestart = true;
		#else
				xMsg("Plugin is out-of-date. Server can't be restarted with Windows. Please, restart your server or download the new version here : http://download.nocheatz.com/ \n");
		#endif
			}
			else if(iNewVersion == iVersion)
			{
				xMsg("Plugin is up-to-date.\n");
			}
			else if(  iNewVersion < iVersion &&  !( iNewVersion == 0 )  )
			{
				xMsg("You are using a beta-test version.\n");
			}

			maySendHeartbeat = false;
		}
		while ((!banlists->empty()) && UseNet)
		{
			std::string elem = banlists->get();
			if(!use_banlists) continue;
			std::string content = "i=" + elem;

			NczHttpSockHandler *Banlisting = new NczHttpSockHandler();
			std::string sbuf;
			if(Banlisting->Connect(PIPELINE_ADDRESS, 80))
			{
				Banlisting->SendPost("/get_v3.php", content);
				sbuf = Banlisting->GetContent();
				Banlisting->End();
			}
			else
			{
				xMsg("Connection failed to Master Server. NoCheatZ Network functions will be off for 10 minutes.\n");
				lastNetOff = GetTime();
				UseNet = false;
			}
			delete Banlisting;
			int from = atoi(sbuf.substr(0, 1).c_str());
			if(from > 0 /* && kick_ban */)
			{
				switch(from)
				{
				case 1:
					{
						if(use_ncz_banlists)
						{
							engine->ServerCommand(format("kickid %s \"[" NCZ_PLUGIN_NAME "] WEB BANNED (NoCheatZ Master Banlist)\"\n", elem.c_str()).c_str());
							engine->ServerCommand(format("banid 1440 %s\n", elem.c_str()).c_str());
							engine->ServerCommand("writeid\n");
						}
						break;
					}

				case 2:
					{
						if(use_lgz_banlists)
						{
							engine->ServerCommand(format("kickid %s \"[" NCZ_PLUGIN_NAME "] WEB BANNED (LeetGamerZ Secure Source Banlist)\"\n",elem.c_str()).c_str());
							engine->ServerCommand(format("banid 1440 %s\n", elem.c_str()).c_str());
							engine->ServerCommand("writeid\n");
						}
						break;
					}

				case 4:
					{
						if(use_esl_banlists)
						{
							engine->ServerCommand(format("kickid %s \"[" NCZ_PLUGIN_NAME "] WEB BANNED (Electronic Sports League Banlist)\"\n",elem.c_str()).c_str());
							engine->ServerCommand(format("banid 1440 %s\n", elem.c_str()).c_str());
							engine->ServerCommand("writeid\n");
						}
					break;
					}

				case 5:
					{
						if(use_esea_banlists)
						{
							engine->ServerCommand(format("kickid %s \"[" NCZ_PLUGIN_NAME "] WEB BANNED (ESEA Anti-Cheat Banlist)\"\n",elem.c_str()).c_str());
							engine->ServerCommand(format("banid 1440 %s\n", elem.c_str()).c_str());
							engine->ServerCommand("writeid\n");
						}
					break;
					}

				/*case 6:
					{
						if(use_eac_banlists)
						{
							engine->ServerCommand(format("kickid %s \"[" NCZ_PLUGIN_NAME "] WEB BANNED (Easy Anti Cheat Banlist)\"\n",elem.c_str()).c_str());
							engine->ServerCommand(format("banid 1440 %s\n", elem.c_str()).c_str());
							engine->ServerCommand("writeid\n");
						}
					break;
					}*/
				default:
					break;
				}
			}
		}
		while(!disconnectingPlayers->empty() && UseNet)
		{
			std::string elem = disconnectingPlayers->get();
			if(!UseNet) continue;
			NczHttpSockHandler *Disconnect = new NczHttpSockHandler();
			std::string content = "i=" + elem;
			if(Disconnect->Connect(PIPELINE_ADDRESS, 80))
			{
				Disconnect->SendPost("/disconnect.php", content);
				Disconnect->End();
			}
			else
			{
				xMsg("Connection failed to Master Server. NoCheatZ Network functions will be off for 10 minutes.\n");
				lastNetOff = GetTime();
				UseNet = false;
			}
			delete Disconnect;
		}
		//break;
	//}
	return 0;
}

bool CreateAThreadAndCallTheFunction()
{
	if(!TheWebThread) TheWebThread = new NczThread();
	if(!TheWebThread->IsAlive())
	{
		//TheWebThread->SetName("NCZ_WEB_THREAD");
		//TheWebThread->SetPriority(10);
		maySendHeartbeat = true;
		TheWebThread->Start();
	}
	return true;
}

/*
bool checkForUpdate()
{
	if(!UpdateThread)
		UpdateThread = new NczThread(checkForUpdate_thread);
	if(!UpdateThread->IsAlive())
	{
		UpdateThread->SetName("NCZ_UPDATE_THREAD");
		UpdateThread->SetPriority(1);
		UpdateThread->Start();
	}
	return true;
}

char * nghost(char *host_name)
{
#ifdef WIN32
//	WSADATA wsaData;
	int iResult;
	//DWORD dwError;
	struct hostent *remoteHost;
//	struct in_addr addr;
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	remoteHost = gethostbyname(host_name);
	if (!(remoteHost == NULL))
	{
		addr.s_addr = *(u_long *) remoteHost->h_addr_list[0];
		return inet_ntoa(addr);
	}
	return NULL;
#else
	struct hostent *host;
	struct in_addr addr;
	host = gethostbyname(host_name);
	if (!(host == NULL))
	{
#undef h_addr
		addr.s_addr = *((unsigned long *) host->h_addr_list[0]);
		return inet_ntoa(addr);
	}
	return NULL;
#endif
}*/

std::string urlencode(std::string str)
{
	return str;
}

// ##########################################
// Cg_NCZ_Queue
// ##########################################


Cg_NCZ_Queue::Cg_NCZ_Queue()
{
	locked = false;
}

Cg_NCZ_Queue::~Cg_NCZ_Queue()
{
}

bool Cg_NCZ_Queue::isLocked()
{
	return locked;
}

void Cg_NCZ_Queue::lock()
{
	locked = true;
}

void Cg_NCZ_Queue::unlock()
{
	locked = false;
}

void Cg_NCZ_Queue::erase()
{
	this->lock();
	queue.clear();
	temp_queue.clear();
	this->unlock();
}

bool Cg_NCZ_Queue::empty()
{
	return queue.empty();
}

std::string Cg_NCZ_Queue::get()
{
	this->lock();
	std::string x = queue.front();
	queue.erase(queue.begin());
	this->unlock();
	return x;
}

void Cg_NCZ_Queue::send(std::string text)
{
	if(!this->isLocked())
	{
		queue.push_back(text);
	}
	else
	{
		temp_queue.push_back(text);
	}
}

void Cg_NCZ_Queue::update()
{
	while(!this->isLocked() && !temp_queue.empty())
	{
		queue.push_back(temp_queue.front());
		temp_queue.erase(temp_queue.begin());
	}
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is unloaded (turned off)
//---------------------------------------------------------------------------------
void NoCheatZ::Unload( void )
{
	Msg("[NoCheatZ 3] Unloading ...\n");
	gameeventmanager->RemoveListener( this ); // make sure we are unloaded from the event system
	//xMsg("Waiting for threads to be terminated ...\n");
	must_thread_be_killed = true;
	//TheWebThread->ResumeExec();
	if(TheWebThread)
	{
		if(TheWebThread->IsAlive()) TheWebThread->Join();
	}
	//TheWebThread->Stop(0);
	if(engine)
	{
		std::string path = GAMEDIR"/addons/nocheatz/nocheatz.dat";
		std::ofstream fichier(path.c_str(), std::ios::out | std::ios::trunc);
		if(fichier)
		{
			fichier.clear();
			fichier.put('1');
			fichier.close();
		}
		else
		{
			Msg("[NoCheatZ 3] Can't write to datafile ...\n");
		}
	}
	//if(TheWebThread) delete TheWebThread;
	if(queue_send_report) delete queue_send_report;
	if(banlists) delete banlists;
#if !defined(NCZ_CSGO) && !defined(NCZ_CSP)
	if(entpropsmanager) delete entpropsmanager;
#endif
	UnhookCmd();
	RemoveTag("NoCheatZ3");
#ifndef NCZ_EP1
	ConVar_Unregister( );
#endif
	Msg("[NoCheatZ 3] Unloaded.\n");
#ifndef NCZ_EP1
	DisconnectTier1Libraries( );
#endif
}

```

`old-nocheatz3/nocheatz.h`:

```h
//===== Copyright © 2011, DJ Fire-Black production, All rights reserved. ======//
//
// Purpose:
//
// $NoKeywords: $
//
//===========================================================================//

//#include "player.h"
#include <functional>
#include <cstring>
#include <stdio.h>
#include <ctype.h>
#include <vector>
#include <algorithm>
#include <string>
#include <list>
#include <map>
#include "MRecipientFilter.h"
#include "bitbuf.h"
#include "interface.h"
#include "engine/iserverplugin.h"
#include "eiface.h"
#include "igameevents.h"
#include "convar.h"
#include "engine/IEngineTrace.h"
#include "tier2/tier2.h"
#ifndef NCZ_EP1
#include "game/server/iplayerinfo.h"
#else
#include "dlls/iplayerinfo.h"
#endif
#ifndef NCZ_CSGO
#include "util.h"
#endif
#include "AutoStatus.h"
#include "MostUsedPointers.h"
#ifdef WIN32
#include <tchar.h>
#else
#ifndef _LINUX
#define _LINUX
#endif
#include <wchar.h>
#define TCHAR wchar_t
#endif
#include <sstream>
//#include "server_class.h"
#include "edict.h"
#include "threadtools.h"
#include "inetchannelinfo.h"
#ifndef NCZ_EP1
#include "mathlib/vector.h"
#else
#include "vector.h"
#endif
//#include "C:\nocheatz3\hl2sdk-ob-valve-77da091662a6\utils\serverplugin_sample\dns.h"

typedef std::basic_string<TCHAR, std::char_traits<TCHAR>, std::allocator<TCHAR> > tstring;
typedef std::basic_ostringstream<TCHAR, std::char_traits<TCHAR>, std::allocator<TCHAR> > tostringstream;

template<typename T>
std::string tostring(const T & toConvert);
std::string to_lowercase(const std::string& s);

template<class T>
T *FindIFace(const char *IFaceName, CreateInterfaceFn Factory); // factory 

edict_t* getSourceTV();

bool isValidEdict(edict_t * entity);

void noTell(edict_t *pEdict, const char *msg); // Send message to all players but not to him (pEdict)

void noTell(edict_t *pEntity, const std::string& msg);

void ForceFile(const char *file);

void contell(edict_t *pEntity,const char * message);

void allTell(const char *message);

std::string formatSeconds(int sec);

bool CreateAThreadAndCallTheFunction();

std::string dumpConfig();

void setCVar(const char * cvarname, int value);

void setCVar(const char * cvarname, float value);

void setCVar(const char * cvarname, const char * value);

void tell(edict_t *pEntity,const char * message);

void tell(edict_t *pEntity, const std::string& message);

int getIndexFromUserID(int userid);

int IndexOfEdict(const edict_t *pEdict);

edict_t *PEntityOfEntIndex(int iEntIndex);

void messagetous(int joueursmax,const char * message);

void message(int index_joueur,const char * message);

//int GetOffset(std::string path);

bool between(const int n, const int min, const int max);

bool between(const float n, const float min, const float max);

bool ReallyUnknownCommand(const char *ccmd);

//void register_va_offset();

std::string NumString_Add(std::string num, std::string add);

void strSplit(std::string str, std::string separator, std::vector<string>* results);

std::string getCommunityID(const char *SteamID);

std::string getStrRates(int index);

void writeToLogfile(std::string text);

int getClosestTeleportEntDistanceFrom(float x, float y, float z);

float GetTime();

std::string getStrGameDir();

bool estImpaire(int num);

void AddTag(char* MyTag);

bool checkForUpdate_thread();

void RemoveTag(char* MyTag);

bool checkForUpdate();

bool isHackOrCheatCommand_Kick(const std::string& commandline);

bool isHackOrCheatCommand_Ban(const std::string& commandline);

std::string quoteQuotes(std::string str);

void SetTranslate(std::string key, std::string sentence);

std::string GetTranslate(const std::string& key);

std::string minStrf(std::string text, unsigned int minSize);

void needUseWeb();

bool estImpaire(int num);

void charencode (unsigned char ch, char dest[4]);

void strSplit(std::string str, std::string separator, std::vector<std::string>* results);

std::string urlencode (const std::string &str);

std::string getStrDateTime(const char *format);

char * nghost(char *host_name);

int WebThread();

void* WebThread_l(void* args);

/*
template<class T>
T & GetPVA(edict_t *pPlayer, bool angle_id);
template<class T>
T & GetGround(edict_t *pPlayer);*/

bool	CreateAThreadAndCallTheFunction();

float positiv(const float n); // Convert unknown float to only positive float
int positiv(const int n);

/*template<class T>
T & GetPVA(CBaseEntity *pBase);*/

std::string format(const char *fmt, ...); // format the specified text
const tchar * format(std::string fmt, ...);

#ifndef NCZ_EP1
#ifndef DEF_HOOKCLASS
#define DEF_HOOKCLASS
/* Prototype de la fonction à appeler lorsque la commande est utilisée
* La fonction pourra retourner true pour interdire l'exécution de la commande hookée
*/
typedef bool (* HookCallback)(int playerIndex, const CCommand & args);

/** Dérivée de ConCommand afin de surcharger ConCommand::Dispatch */
class ConCommandHook : public ConCommand
{
protected:
	/** Pointeur sur la commande hookée */
	ConCommand * hooked;

	/** Fonction à appeler lorsque la commande est utilisée */
	HookCallback callback;
public:
	ConCommandHook(const char * name, HookCallback hookCallback, int flags = FCVAR_NONE);

	// Fonctions héritées de ConCommand
	void Init();
	void Dispatch(const CCommand & args);
};

#endif
#endif

// ##########################################
// Cg_NCZ_PlayerManager
// ##########################################

#ifndef DEF_CGNCZPMANAGERCLASS
#define DEF_CGNCZPMANAGERCLASS
class Cg_NCZ_PlayerManager
{
public:
	// Inits

	Cg_NCZ_PlayerManager();
	~Cg_NCZ_PlayerManager();
	// Methods

	int getPlayerCount();
	int getMaxClients();
	Cg_NCZ_Player* getPlayer(int index);
	Cg_NCZ_Player* getPlayer(edict_t *pPlayer);
	Cg_NCZ_Player* getPlayer(void * myvoid); // CBaseEntity, CCSPlayer ...

	// Functions

	void resetAll();
	void lockAll();
	//void checkAllCvars();
	void checkAllEyeAngles();
	//void checkAllSpeedhacks();
	void checkAllBanRequest();
	void checkAllAimDirChange();
	void checkAllFire();
	void checkAllBunny();
	void updateAll();
	void disconnectPlayer(edict_t *pPlayer);
	void disconnectPlayer(int index);
	void resetAllUkCmd();
	void checkAllUkCmd();
	void fullcheckBanlists();
	void handleAllConvarTest();

	//void updateCheckList();

	std::vector<Cg_NCZ_Player*> g_ncz_playerList;
};

#endif

// ##########################################
// Cg_NCZ_RealPlayers
// ##########################################

/*#ifndef DEF_CGNCZREALP
#define DEF_CGNCZREALP
class Cg_NCZ_RealPlayers
{
public:
	// Inits

	Cg_NCZ_RealPlayers();
	~Cg_NCZ_RealPlayers();

	// Functions

	void addIndex(int index);
	void removeIndex(int index);
	
	// Methods

	bool isInList(int index);

private:
	std::vector<int> rpList;
};

#endif*/
#ifndef NCZPLUGIN
#define NCZPLUGIN

struct StrCompare : public std::binary_function<const char*, const char*, bool> {
public:
    bool operator() (const char* str1, const char* str2) const
    { return std::strcmp(str1, str2) < 0; }
};

typedef std::map<const char*, const char*, StrCompare> ConvarList;


//---------------------------------------------------------------------------------
// Purpose: a sample 3rd party plugin class
//---------------------------------------------------------------------------------
class NoCheatZ: public IServerPluginCallbacks, public IGameEventListener2, public AutoStatus
{
public:
	NoCheatZ();
	~NoCheatZ();

	// IServerPluginCallbacks methods
	virtual bool			Load(	CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory );
	virtual void			Unload( void );
	virtual void			Pause( void );
	virtual void			UnPause( void );
	virtual const char     *GetPluginDescription( void );
	virtual void			LevelInit( char const *pMapName );
	virtual void			ServerActivate( edict_t *pEdictList, int edictCount, int clientMax );
	virtual void			GameFrame( bool simulating );
	virtual void			LevelShutdown( void );
	virtual void			ClientActive( edict_t *pEntity );
#ifdef NCZ_CSGO
	virtual void            ClientFullyConnect(edict_t *) {};
#endif
	virtual void			ClientDisconnect( edict_t *pEntity );
	virtual void			ClientPutInServer( edict_t *pEntity, char const *playername );
	virtual void			SetCommandClient( int index );
	virtual void			ClientSettingsChanged( edict_t *pEdict );
	virtual PLUGIN_RESULT	ClientConnect( bool *bAllowConnect, edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen );
#ifndef NCZ_EP1
	virtual PLUGIN_RESULT	ClientCommand( edict_t *pEntity, const CCommand &args );
#else
	virtual PLUGIN_RESULT	ClientCommand( edict_t *pEntity );
#endif
	virtual PLUGIN_RESULT	NetworkIDValidated( const char *pszUserName, const char *pszNetworkID );
	virtual void			OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_t *pPlayerEntity, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue );

	// added with version 3 of the interface.
	virtual void			OnEdictAllocated( edict_t *edict );
	virtual void			OnEdictFreed( const edict_t *edict  );
	//virtual void allstatus();
	//virtual void ForceUnload();

	// IGameEventListener Interface
	virtual void FireGameEvent( IGameEvent * event );
#ifdef NCZ_CSGO
	virtual int	 GetEventDebugID( void ) { return 42; };
#endif

	virtual int GetCommandIndex()
	{
		return m_iClientCommandIndex;
	}
	virtual Cg_NCZ_PlayerManager * get_m_pm();
	//Cg_NCZ_RealPlayers rpl;
private:
	int m_iClientCommandIndex;
	Cg_NCZ_PlayerManager *m_pm;
	ConvarList::iterator cit;
	int ccl;
	//float last_auto_status;
};

#endif

// ##########################################
// Cg_NCZ_Queue
// ##########################################

#ifndef DEF_Cg_NCZ_Queue
#define DEF_Cg_NCZ_Queue
class Cg_NCZ_Queue
{
public:
	Cg_NCZ_Queue();
	~Cg_NCZ_Queue();

	// Methods

	std::string get(); // Get the first element and delete the element after, so you have to register it.
	bool empty();
	void erase();
	// Functions

	void update();
	void send(std::string text);

private:
	// Methods

	bool isLocked();

	// Functions

	void lock();
	void unlock();

	// Vars

	std::vector<std::string> queue;
	std::vector<std::string> temp_queue;
	bool locked;
};
#endif

/*#ifdef WIN32
#ifndef ClassCNCZWebThread
#define ClassCNCZWebThread
class CNCZWebThread: public CWorkerThread
{
public:
	CNCZWebThread()
	{
		SetName( "NCZWebThread" );
	}

	~CNCZWebThread()
	{
	}

	enum
	{
		CALL_FUNC,
		EXIT,
	};

	bool	CallThreadFunction()
	{
		CallWorker( CALL_FUNC );
		return true;
	}

	int Run()
	{
		unsigned nCall;
		while ( WaitForCall( &nCall ) )
		{
			if ( nCall == EXIT )
			{
				Reply( 1 );
				break;
			}

			Reply( 1 );
			WebThread();

		}
		return 0;
	}

private:
};

static CNCZWebThread g_CNCZWebThread;
#endif
#endif*/
/*
// ##########################################
// Cg_NCZ_Lang
// ##########################################

typedef struct ncz_lang ncz_lang;
struct ncz_lang
{
	std::string textIndex;
	std::string dg;
};

#ifndef DEF_Cg_NCZ_Lang
#define DEF_Cg_NCZ_Lang
class Cg_NCZ_Lang
{
public:
	Cg_NCZ_Lang();
	~Cg_NCZ_Lang();

	// Methods

	std::string get(std::string textIndex); // Get the first element and delete the element after, so you have to register it.
	bool empty();

	// Functions

	void init(std::string PathToLangFile);
	void setLang(std::string Lang);

private:

};
#endif*/
/*
class CNczBasePlayer : public CBasePlayer
{
	CNczBasePlayer();
	virtual ~CNczBasePlayer();

	virtual int ShouldTransmit( const CCheckTransmitInfo *pInfo );
};*/

```

`old-nocheatz3/nocheatz3_autoupdate/BaseDef.h`:

```h
#ifdef WIN32
#define NCZ_SYS "Windows"
#else
#define NCZ_SYS "Linux"
#endif

#ifdef WIN32
#define NCZ_EXT "dll"
#else
#define NCZ_EXT "so"
#endif
```

`old-nocheatz3/nocheatz3_autoupdate/Makefile`:

```
# Dossier de travail
BASE_DIR = ../

GAMEDIR = CSS
SDKREDIR = CSS
TIER0SO_CSP = tier0_i486.so
TIER0SO_CSS = libtier0_srv.so
TIER0 = $(TIER0SO_CSS)
OTHER_PREPROCESSORS = -DNCZ_CSS -DCOMPILER_GCC -DPOSIX

# Compilateur
#CXX = g++-3.4 # maximise la compatibilité
#CXX = g++-4.1 # disponible sur les distri récentes
CXX = g++

# Nom du fichier binaire de sortie
BINARY_NAME = nocheatz3_autoupdate.so

# Dossier de sortie du fichier binaire
BINARY_DIR = $(BASE_DIR)/Releases/nocheatz3-$(GAMEDIR)/addons/nocheatz/

# Code source du SDK de VALVE
SDK_SRC_DIR = $(BASE_DIR)/$(SDKREDIR)
SDK_PUBLIC_DIR = $(SDK_SRC_DIR)/public
SDK_TIER0_DIR = $(SDK_SRC_DIR)/public/tier0
SDK_TIER1_DIR = $(SDK_SRC_DIR)/tier1
SDK_GAME_DIR = $(SDK_SRC_DIR)/game
SDK_GAMESHARED_DIR = $(SDK_GAME_DIR)/shared
SDK_GAMESERVER_DIR = $(SDK_GAME_DIR)/server

# Dossiers de sortie
RELEASE_DIR = Release/linux
DEBUG_DIR = Debug/linux

# Dossier contenant les librairies dynamiques
#SRCDS_DIR = ./
SRCDS_BIN_DIR = bin

# Dossier contenant les librairies statiques
SRCDS_A_DIR = $(SDK_SRC_DIR)/lib/linux

# Paramètres du compilateur
ARCH_CFLAGS = -mtune=i486 -march=pentium  -mmmx
USER_CFLAGS = -DTIXML_USE_TICPP
BASE_CFLAGS =   -msse \
                                -fpermissive \
                                -D_LINUX \
                                -DNDEBUG \
                                -Dstricmp=strcasecmp \
                                -D_stricmp=strcasecmp \
                                -D_strnicmp=strncasecmp \
                                -Dstrnicmp=strncasecmp \
                                -D_snprintf=snprintf \
                                -D_vsnprintf=vsnprintf \
                                -D_alloca=alloca \
                                -Dstrcmpi=strcasecmp \
                                -fPIC \
                                -Wno-deprecated \
                                -msse 
OPT_FLAGS = -O3 -funroll-loops -s -pipe $(OTHER_PREPROCESSORS)
#DEBUG_FLAGS = -g -ggdb3 -O0 -D_DEBUG $(OTHER_PREPROCESSORS)               
DEBUG_FLAGS = $(OPT_FLAGS)
#OPT_FLAGS = $(DEBUG_FLAGS)
# Fichiers à compiler
SRC= $(wildcard *.cpp) 
# $(wildcard */*.cpp) $(wildcard */*/*.cpp)                        

# Fichiers à lier
LINK_SO =       $(SRCDS_BIN_DIR)/$(TIER0)                 
LINK_A =        $(SRCDS_A_DIR)/tier1_i486.a \
			#	$(SRCDS_A_DIR)/interfaces_i486.a \
				$(SRCDS_A_DIR)/mathlib_i486.a

LINK = -lm -ldl --export-dynamic $(LINK_A) $(LINK_SO)

# Dossiers des fichiers inclus
INCLUDE =       -I. \
                        -I$(SDK_PUBLIC_DIR) \
                        -I$(SDK_PUBLIC_DIR)/engine \
                        -I$(SDK_PUBLIC_DIR)/tier0 \
                        -I$(SDK_PUBLIC_DIR)/tier1 \
                        -I$(SDK_PUBLIC_DIR)/vstdlib \
						-I$(SDK_PUBLIC_DIR)/mathlib \
                        -I$(SDK_PUBLIC_DIR)/game/server \
                        -I$(SDK_SRC_DIR)/tier1 \
                        -I$(SDK_SRC_DIR)/game \
                        -I$(SDK_SRC_DIR)/game/server \
                        -I$(SDK_SRC_DIR)/game/shared \
						-I$(SDK_SRC_DIR)/public \
						-I$(SDK_SRC_DIR)/public/game/server \
						-I$(SDK_SRC_DIR)/public/engine \
						-I$(SDK_SRC_DIR)/public/tier0 \
						-I$(SDK_SRC_DIR)/public/tier1 \
						-I$(SDK_SRC_DIR)/common \
						-I$(SDK_SRC_DIR)/interfaces \
                        

# Règles de compilation

ifeq "$(DEBUG)" "false"
	BIN_DIR = $(RELEASE_DIR)
	CFLAGS = $(OPT_FLAGS)
else
	BIN_DIR = $(DEBUG_DIR)
	CFLAGS = $(DEBUG_FLAGS)
endif
CFLAGS += $(USER_CFLAGS) $(BASE_CFLAGS) $(ARCH_CFLAGS)

OBJECTS := $(SRC:%.cpp=$(BIN_DIR)/%.o)

compile_object = \
	@mkdir -p $(2); \
	echo "$(1) => $(3)"; \
	$(CXX) $(INCLUDE) $(CFLAGS) -o $(3) -c $(1) 2> "/sdk/error_triggerbot.txt";

$(BIN_DIR)/%.o: %.cpp %.h
	$(call compile_object, $<, $(@D), $@)

$(BIN_DIR)/%.o: %.cpp
	$(call compile_object, $<, $(@D), $@)

all: $(OBJECTS)
	@$(CXX) $(INCLUDE) $(CFLAGS) $(OBJECTS) $(LINK) -shared -o $(BINARY_DIR)/$(BINARY_NAME)
        
release:
	@$(MAKE) all DEBUG=false
	
remake:
	@$(MAKE) clean
	@$(MAKE)
	
debug:
	@$(MAKE) all DEBUG=true

clean:
	@rm -rf $(RELEASE_DIR)
	@rm -rf $(DEBUG_DIR)
	@rm -rf $(BINARY_DIR)/$(BINARY_NAME)
        
.PHONY: clean
```

`old-nocheatz3/nocheatz3_autoupdate/Misc.cpp`:

```cpp
#include "Misc.h"



```

`old-nocheatz3/nocheatz3_autoupdate/Misc.h`:

```h
#include "stdarg.h"

#include <string>

std::string format(const char *fmt, ...);
```

`old-nocheatz3/nocheatz3_autoupdate/NczHttpSockHandler.cpp`:

```cpp
#include "NczHttpSockHandler.h"
#include <string>
#include <fcntl.h>
#include <cstring>
#include <stdlib.h>
#include <memory.h> 

#ifndef WIN32
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#else
#include <winsock2.h>
#include <ws2tcpip.h>
#endif

#undef h_addr
#include "NczHttpSockHandler.h"
#include <fcntl.h>

std::string shost_name( "" );
std::string g_inetaddr( "" );

std::string NczHttpSockHandler::Resolve( char *hostname )
{
	if(!g_inetaddr.empty())
		return g_inetaddr;

	 struct addrinfo hints, *res;
	 struct in_addr addr;

	 memset( &hints, 0, sizeof( hints ) );
	 hints.ai_socktype = SOCK_STREAM;
	 hints.ai_family = AF_INET;

	 while( getaddrinfo(hostname, NULL, &hints, &res) != 0 );
	 addr.s_addr = (( struct sockaddr_in * )( res->ai_addr ))->sin_addr.s_addr;
	 shost_name = hostname;

	 g_inetaddr = inet_ntoa( addr );

	 freeaddrinfo( res );

	 return g_inetaddr;
}

bool NczHttpSockHandler::Connect(const char *host_name, u_short port)
{
	sip = this->Resolve((char *)host_name);
	sock = socket(AF_INET, SOCK_STREAM, 0);
	sin.sin_addr.s_addr = inet_addr(sip.c_str());
	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);
	if(connect(sock, (SOCKADDR*)&sin, sizeof(sin)) != SOCKET_ERROR)
	{
		return true;
	}
	return false;
}

std::string NczHttpSockHandler::MakeGetPacket(std::string file)
{
	std::ostringstream buf;
	buf << "GET http://" << shost_name << file << " HTTP/1.0" << crlf
	<< "Host: " << shost_name << crlf
		<< "Connection: Keep-Alive" << crlf
		<< "User-Agent: nocheatz3" << crlf
		<< crlf;
	return buf.str();
}

std::string NczHttpSockHandler::MakePostPacket(std::string file, std::string content)
{
	std::ostringstream buf;
	buf << "POST http://" << shost_name << file << " HTTP/1.0" << crlf
	<< "Host: " << shost_name << crlf
		<< "Connection: Close" << crlf
		<< "User-Agent: nocheatz3" << crlf
		<< "Content-type: application/x-www-form-urlencoded" << crlf
		<< "Content-Length: " << content.length() << crlf
		<< crlf
		<< content << crlf
		<< crlf;
	return buf.str();
}

void NczHttpSockHandler::Send(std::string packet)
{
	send(sock, packet.c_str(), packet.length()+1, 0);
	shutdown(sock, 0x01);
	nonblock(sock);
}

void NczHttpSockHandler::SendGet(std::string file)
{
	this->Send(this->MakeGetPacket(file));
}

void NczHttpSockHandler::SendPost(std::string file, std::string content)
{
	this->Send(this->MakePostPacket(file, content));
}

void NczHttpSockHandler::nonblock(int sock)
{
#ifdef WIN32

#else
	int opts;

	if ((opts = fcntl(sock, F_GETFL)) < 0) {
		perror("fcntl(F_GETFL)");
	}

	opts = (opts | O_NONBLOCK);

	if (fcntl(sock, F_SETFL, opts) < 0) {
		perror("fcntl(F_SETFL)");
	}
#endif
}


#define buffsize 1024

std::string NczHttpSockHandler::GetContent()
{
	char response[buffsize];
	int bytes;
	int package = 0;
	int start = 0;
	int bytesWritten = 0;
	int cl = 0;

	std::ostringstream resp;
	int ready = 0;

	while(1)
	{
		fd_set readfs;
		FD_ZERO(&readfs);
		FD_SET(sock, &readfs);
		timeval timeout = {10L,0L};
		ready = select(sock+1, &readfs, NULL, NULL, &timeout);
		switch(ready)
		{
		case SOCKET_ERROR:
			return "";
			break;

		case 0:
			break;

		default:
			if(FD_ISSET(sock,&readfs))
			{
				if((bytes = recv(sock, response, sizeof(response), 0)) > 0)
				{
					if (package == 0)
					{
						std::string sort = response;
						start = sort.find("\r\n\r\n");

						int posA = sort.find("Content-Length: ")+16;
						int posB = sort.find("\r\n", posA)-posA;
						std::string cl_s(sort,posA,posB);
						cl = atoi(cl_s.c_str());

						size_t dataStart = start + strlen("\r\n\r\n");
						// Get the length of the data in this packet                      
						size_t dataLen = bytes - dataStart;
						// Write the data to the string  
						resp.write(&response[dataStart], dataLen);
						bytesWritten = dataLen;
						package++;
					}
					else
					{
						resp.write(response, bytes);
						bytesWritten += bytes;
					}
				}
				else
				{
					return resp.str();
				}
			}
		}
	}
	return resp.str();
}

void NczHttpSockHandler::WriteBinaryContentTo(std::string pathEfilew)
{
	char response[buffsize];
	int bytes;
	int package = 0;
	int start = 0;
	int bytesWritten = 0;
	int cl = 0;

	std::ostringstream resp;
	int ready = 0;
	std::ofstream outfile(pathEfilew.c_str(), std::ios_base::binary | std::ios_base::out);
	while(1)
	{
		fd_set readfs;
		FD_ZERO(&readfs);
		FD_SET(sock, &readfs);
		timeval timeout = {10L,0L};
		ready = select(sock+1, &readfs, NULL, NULL, &timeout);
		switch(ready)
		{
		case SOCKET_ERROR:
			return;
			break;

		case 0:
			break;

		default:
			if(FD_ISSET(sock,&readfs))
			{
				if((bytes = recv(sock, response, sizeof(response), 0)) > 0)
				{
					if (package == 0)
					{
						std::string sort = response;
						start = sort.find("\r\n\r\n");

						int posA = sort.find("Content-Length: ")+16;
						int posB = sort.find("\r\n", posA)-posA;
						std::string cl_s(sort,posA,posB);
						cl = atoi(cl_s.c_str());

						size_t dataStart = start + strlen("\r\n\r\n");
						// Get the length of the data in this packet                      
						size_t dataLen = bytes - dataStart;
						// Write the data to the file    
						outfile.write(&response[dataStart], dataLen);
						bytesWritten = dataLen;
						package++;
					}
					else
					{
						outfile.write(response, bytes);
						bytesWritten += bytes;
					}
				}
				else
				{
					outfile.close();
					return;
				}
			}
		}
	}
	outfile.close();
	return;
}

```

`old-nocheatz3/nocheatz3_autoupdate/NczHttpSockHandler.h`:

```h
#ifdef _WIN32

#pragma comment(lib,"ws2_32.lib")
#include <winsock2.h>
#define SOCKET_ERROR_CODE WSAGetLastError()

#else

#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h> // close
#include <netdb.h> // gethostbyname
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define closesocket(s) close(s)
#define SD_BOTH SHUT_RDWR
typedef int SOCKET;
typedef sockaddr_in SOCKADDR_IN; // typedef struct sockaddr_in SOCKADDR_IN;
typedef sockaddr SOCKADDR;
typedef in_addr IN_ADDR;
#define SOCKET_ERROR_CODE errno

#endif
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include <fcntl.h>

#ifndef __NCZ_HTTP_SOCK_HANDLER_CLASS
#define __NCZ_HTTP_SOCK_HANDLER_CLASS

class NczHttpSockHandler
{
public:
		NczHttpSockHandler() : crlf("\r\n")
		{
#ifdef _WIN32
		WSADATA wsadata;
		WSAStartup(MAKEWORD(2,2),&wsadata);
#endif // _WIN32

		};

		~NczHttpSockHandler()
		{
		};

		void End()
		{
				closesocket(sock);
#ifdef _WIN32
		WSACleanup();
#endif // _WIN32
		};

		std::string Resolve(char *host_name);

		bool Connect(const char *host_name, u_short port);

		std::string MakeGetPacket(std::string file);

		std::string MakePostPacket(std::string file, std::string content);

		void Send(std::string packet);

		void SendGet(std::string file);

		void SendPost(std::string file, std::string content);

		std::string GetContent();

		void nonblock(int sock);

		void WriteBinaryContentTo(std::string pathEfilew);

private:
		in_addr addr;
		hostent* host;
		SOCKET sock;
		SOCKADDR_IN sin;
		std::string sip;
		//std::string shost_name;
		std::string crlf;
};

#endif // __NCZ_HTTP_SOCK_HANDLER_CLASS
 
```

`old-nocheatz3/nocheatz3_autoupdate/NczThread.h`:

```h
#include "threadtools.h"

#ifndef NCZ_THREAD_CLASS
#define NCZ_THREAD_CLASS

extern int UpdateThread_job();

class NczThread : public CThread
{
public:
	NczThread();
	~NczThread();

	virtual int Run();

	virtual bool MustBeKilled();
private:
	bool mustbekilled;
};

#endif // NCZ_THREAD_CLASS

```

`old-nocheatz3/nocheatz3_autoupdate/NczThreads.cpp`:

```cpp
#include "NczThread.h"
#include <stdio.h>

NczThread::NczThread() :
	mustbekilled(false)
{
}

NczThread::~NczThread()
{
}

int NczThread::Run()
{
	mustbekilled = false;
	int res = UpdateThread_job();
	mustbekilled = true;
	return res;
}

bool NczThread::MustBeKilled()
{
	return mustbekilled;
}

```

`old-nocheatz3/nocheatz3_autoupdate/serverplugin_empty.cpp`:

```cpp
//===== Copyright © 1996-2005, Valve Corporation, All rights reserved. ======//
//
// Purpose: 
//
// $NoKeywords: $
//
//===========================================================================//

#include "interface.h"
#include "engine/iserverplugin.h"
#include "eiface.h"
#include "tier1.h"
#include "convar.h"
#include "strtools.h"
#include "../Preprocessors.h"

//#include "Misc.h"
#include "NczHttpSockHandler.h"
#include "NczThread.h"
#include "BaseDef.h"

#include <stdio.h>
#include <iostream>
#include <string>
#include <fstream>
#include "stdarg.h"

// memdbgon must be the last include file in a .cpp file!!!
//#include "tier0/memdbgon.h"

template<class T>
T *FindIFace(const char *IFaceName, CreateInterfaceFn Factory)
{
	T *pIFace = NULL;
	int i_v = 40;
	char s_v[64];
	while ( !pIFace )
	{
		if(i_v < 0)
		{
			return NULL;
		}
		if(i_v < 10)
		{
			sprintf(s_v, "%s00%d", IFaceName, i_v);
			//s_v = format("%s00%d", IFaceName, i_v);
		}
		else if(i_v < 100 && i_v > 9)
		{
			sprintf(s_v, "%s0%d", IFaceName, i_v);
			//s_v = format("%s0%d", IFaceName, i_v);
		}
		pIFace = (T*)Factory(s_v,NULL);
		--i_v;
	}
	return pIFace;
}

template<typename T>
std::string tostring(const T & toConvert)
{
	std::stringstream convertion;
	convertion << toConvert;
	std::string str(convertion.str());
	return str;
}

std::string format(const char *fmt, ...)
{
	va_list		argptr;
	static char		string[4096];

	va_start(argptr, fmt);
	Q_vsnprintf(string, sizeof(string), fmt,argptr);
	va_end (argptr);

	return tostring(string);
}


// Interfaces from the engine
IVEngineServer	*engine = NULL;
//ICvar *g_pCVar;
NczHttpSockHandler *UpdateSock = NULL;
NczHttpSockHandler *DownloadSock = NULL;
NczThread *UpdateThread = NULL;

int UpdateThread_job();

bool isThreadAlive = true;

bool plugin_loaded = false;

//---------------------------------------------------------------------------------
// Purpose: a sample 3rd party plugin class
//---------------------------------------------------------------------------------
class CEmptyServerPlugin: public IServerPluginCallbacks
{
public:
	CEmptyServerPlugin();
	~CEmptyServerPlugin();

	// IServerPluginCallbacks methods
	virtual bool			Load(	CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory );
	virtual void			Unload( void );
	virtual void			Pause( void );
	virtual void			UnPause( void );
	virtual const char     *GetPluginDescription( void );      
	virtual void			LevelInit( char const *pMapName );
	virtual void			ServerActivate( edict_t *pEdictList, int edictCount, int clientMax );
	virtual void			GameFrame( bool simulating );
	virtual void			LevelShutdown( void );
	virtual void			ClientActive( edict_t *pEntity );
#ifdef NCZ_CSGO
	virtual void            ClientFullyConnect(edict_t *) {};
#endif
	virtual void			ClientDisconnect( edict_t *pEntity );
	virtual void			ClientPutInServer( edict_t *pEntity, char const *playername );
	virtual void			SetCommandClient( int index );
	virtual void			ClientSettingsChanged( edict_t *pEdict );
	virtual PLUGIN_RESULT	ClientConnect( bool *bAllowConnect, edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen );
	virtual PLUGIN_RESULT	ClientCommand( edict_t *pEntity, const CCommand &args );
	virtual PLUGIN_RESULT	NetworkIDValidated( const char *pszUserName, const char *pszNetworkID );
	virtual void			OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_t *pPlayerEntity, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue );

	virtual void			OnEdictAllocated( edict_t *edict ) {};
	virtual void			OnEdictFreed( const edict_t *edict  ) {};

#ifdef NCZ_CSGO
	virtual int	 GetEventDebugID( void ) { return 42; };
#endif

	virtual int GetCommandIndex() { return m_iClientCommandIndex; }
private:
	int m_iClientCommandIndex;
};


// 
// The plugin is a static singleton that is exported as an interface
//
CEmptyServerPlugin g_EmtpyServerPlugin;
EXPOSE_SINGLE_INTERFACE_GLOBALVAR(CEmptyServerPlugin, IServerPluginCallbacks, INTERFACEVERSION_ISERVERPLUGINCALLBACKS, g_EmtpyServerPlugin );

//---------------------------------------------------------------------------------
// Purpose: constructor/destructor
//---------------------------------------------------------------------------------
CEmptyServerPlugin::CEmptyServerPlugin()
{
	m_iClientCommandIndex = 0;
}

CEmptyServerPlugin::~CEmptyServerPlugin()
{
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is loaded, load the interface we need from the engine
//---------------------------------------------------------------------------------
bool CEmptyServerPlugin::Load(	CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory )
{
	ConnectTier1Libraries( &interfaceFactory, 1 );
	engine            = FindIFace<IVEngineServer>       ("VEngineServer",        interfaceFactory);
	if(!engine) return false;

	//if(UpdateThread) delete[] UpdateThread;
	if(!UpdateThread) UpdateThread = new NczThread();
	if(UpdateThread) UpdateThread->Start();
	else return false;

	return true;
}

int UpdateThread_job()
{
	// Prepare vars
	bool needupdate = false;
	const char * domain = PIPELINE_ADDRESS;
	std::string page = "/update.php";
	int version = 0;
	std::ifstream fichierv(GAMEDIR"/addons/nocheatz/version.txt", std::ios::in);
	if(fichierv)
	{
		version = 0;
		fichierv >> version;
		printf("[NoCheatZ 3 AutoUpdate] Your version : %d.\n", version);
		fichierv.close();
	}
	else
	{
		needupdate = true;
	}
	std::string filename = "nocheatz3."NCZ_EXT;
	std::string pathtofile = GAMEDIR"/addons/nocheatz/" + filename;
	std::ifstream fichier(pathtofile.c_str(), std::ios::in);
	if(fichier)
	{
		fichier.close();
	}
	else
	{
		needupdate = true;
	}
	UpdateSock = new NczHttpSockHandler();
	int iNewVersion = version;
	if(UpdateSock->Connect(domain, 80))
	{
		UpdateSock->SendGet(page);
		std::string resp = UpdateSock->GetContent();
		//printf("Resp : %s\n", resp.c_str());
		iNewVersion = atoi(resp.c_str());
		if(iNewVersion == 0)
		{
			printf("[NoCheatZ 3 AutoUpdate] Unable to get in touch with the master server.\n", iNewVersion);
			isThreadAlive = false;
			return 0;
		}
		else printf("[NoCheatZ 3 AutoUpdate] Last version : %d.\n", iNewVersion);
	}
	UpdateSock->End();
	delete UpdateSock;
	if(iNewVersion > version)
	{
		needupdate = true;
		printf("[NoCheatZ 3 AutoUpdate] Update needed.\n", iNewVersion);
	}
	else
	{
		printf("[NoCheatZ 3 AutoUpdate] No update needed.\n", iNewVersion);
	}
	if(needupdate)
	{
		DownloadSock = new NczHttpSockHandler();
		if(DownloadSock->Connect(domain, 80))
		{
			std::string remotefile = "/bin/" + filename;
			std::string localfile = GAMEDIR"/addons/nocheatz/" + filename;
			printf("[NoCheatZ 3 AutoUpdate] Downloading new plugin ...\n");
			DownloadSock->SendGet(remotefile);
			DownloadSock->WriteBinaryContentTo(localfile);
			std::ofstream fichier(GAMEDIR"/addons/nocheatz/version.txt", std::ios::out | std::ios::trunc);
			if(fichier)
			{
				fichier << iNewVersion;
				fichier.close();
			}
		}
		delete DownloadSock;
		printf("[NoCheatZ 3 AutoUpdate] Update done.\n");
	}
	isThreadAlive = false;
	return 0;
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is unloaded (turned off)
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::Unload( void )
{
	DisconnectTier1Libraries();
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is paused (i.e should stop running but isn't unloaded)
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::Pause( void )
{
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is unpaused (i.e should start executing again)
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::UnPause( void )
{
}

//---------------------------------------------------------------------------------
// Purpose: the name of this plugin, returned in "plugin_print" command
//---------------------------------------------------------------------------------
const char *CEmptyServerPlugin::GetPluginDescription( void )
{
	return "NoCheatZ 3 AutoUpdate";
}

//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::LevelInit( char const *pMapName )
{
}

//---------------------------------------------------------------------------------
// Purpose: called on level start, when the server is ready to accept client connections
//		edictCount is the number of entities in the level, clientMax is the max client count
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::ServerActivate( edict_t *pEdictList, int edictCount, int clientMax )
{
}

//---------------------------------------------------------------------------------
// Purpose: called once per server frame, do recurring work here (like checking for timeouts)
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::GameFrame( bool simulating )
{
	if(!plugin_loaded && !isThreadAlive && engine)
	{
		/*std::string filename = "nocheatz3."NCZ_EXT;
		std::string localfile = "addons/nocheatz/" + filename;*/
		//std::string command = "plugin_load addons/nocheatz/nocheatz3\n";
		printf("[NoCheatZ 3 AutoUpdate] Trying to load NoCheatZ 3 ...\n");
#ifndef NCZ_CSP
		engine->ServerCommand("plugin_load addons/nocheatz/nocheatz3\n");
#else
#ifdef WIN32
		engine->ServerCommand("plugin_load addons/nocheatz/nocheatz3.dll\n");
#else
		engine->ServerCommand("plugin_load addons/nocheatz/nocheatz3.so\n");
#endif
#endif
		plugin_loaded = true;
	}
	//UpdateThread->ResumeExec();
	//if(isThreadAlive) Msg("Thread Alive\n");
}

//---------------------------------------------------------------------------------
// Purpose: called on level end (as the server is shutting down or going to a new map)
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::LevelShutdown( void ) // !!!!this can get called multiple times per map change
{
}

//---------------------------------------------------------------------------------
// Purpose: called when a client spawns into a server (i.e as they begin to play)
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::ClientActive( edict_t *pEntity )
{
}

//---------------------------------------------------------------------------------
// Purpose: called when a client leaves a server (or is timed out)
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::ClientDisconnect( edict_t *pEntity )
{
}

//---------------------------------------------------------------------------------
// Purpose: called on 
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::ClientPutInServer( edict_t *pEntity, char const *playername )
{
}

//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::SetCommandClient( int index )
{
	m_iClientCommandIndex = index;
}

//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::ClientSettingsChanged( edict_t *pEdict )
{
}

//---------------------------------------------------------------------------------
// Purpose: called when a client joins a server
//---------------------------------------------------------------------------------
PLUGIN_RESULT CEmptyServerPlugin::ClientConnect( bool *bAllowConnect, edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen )
{
	return PLUGIN_CONTINUE;
}

//---------------------------------------------------------------------------------
// Purpose: called when a client types in a command (only a subset of commands however, not CON_COMMAND's)
//---------------------------------------------------------------------------------
PLUGIN_RESULT CEmptyServerPlugin::ClientCommand( edict_t *pEntity, const CCommand &args )
{
	return PLUGIN_CONTINUE;
}

//---------------------------------------------------------------------------------
// Purpose: called when a client is authenticated
//---------------------------------------------------------------------------------
PLUGIN_RESULT CEmptyServerPlugin::NetworkIDValidated( const char *pszUserName, const char *pszNetworkID )
{
	return PLUGIN_CONTINUE;
}

//---------------------------------------------------------------------------------
// Purpose: called when a cvar value query is finished
//---------------------------------------------------------------------------------
void CEmptyServerPlugin::OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_t *pPlayerEntity, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue )
{
}

```

`server-plugin/Code/Hooks/Hook.cpp`:

```cpp
#include "Hook.h"

DWORD VirtualTableHook(DWORD* classptr, const int vtable, const DWORD newInterface )
{
		DWORD dwOld, dwStor = 0x0;
		if(!(classptr || vtable || newInterface)) return 0;
#ifdef WIN32
		if(!VirtualProtect(&classptr[vtable], (vtable * sizeof(void *)) + 4, PAGE_EXECUTE_READWRITE, &dwOld ))
		{
			return 0;
		}
#else // LINUX

        DWORD psize = sysconf(_SC_PAGESIZE);
		void *p = (void *)((DWORD)(&classptr[vtable]) & ~(psize-1));
		if(mprotect(p, ((vtable * sizeof(void *)) + ((DWORD)(&classptr[vtable]) & (psize-1))), PROT_READ | PROT_WRITE | PROT_EXEC ) < 0)
		{
			return 0;
		}
#endif // WIN32
		dwStor = classptr[vtable];
#ifdef WIN32
		*(DWORD*)&(classptr[vtable]) = newInterface;
		VirtualProtect(&classptr[vtable], (vtable * sizeof(void *)) + 4, dwOld, &dwOld);
#else // LINUX
		*(DWORD*)&(classptr[vtable]) = newInterface;
		mprotect(p, ((vtable * sizeof(void *)) + ((DWORD)(&classptr[vtable]) & (psize-1))), PROT_READ | PROT_EXEC );
#endif // WIN32
		return dwStor;
}

```

`server-plugin/Code/Hooks/Hook.h`:

```h
#ifndef HOOK_H
#define HOOK_H

#include "dbg.h"
#include "Players/NczPlayer.h"

#ifdef WIN32
#	include "Misc/include_windows_headers.h"
#	define HOOKFN_EXT __thiscall
#	define HOOKFN_INT __fastcall
#else
#	include <sys/mman.h>
#	include <unistd.h>
#	define HOOKFN_EXT
#	define HOOKFN_INT __attribute__((cdecl))
#endif



DWORD VirtualTableHook(DWORD* classptr, const int vtable, const DWORD newInterface );

class EmptyClass { };

#endif

```

`server-plugin/Code/Hooks/OnGroundHookListener.cpp`:

```cpp
#include "OnGroundHookListener.h"

std::list<OnGroundHookListener*> OnGroundHookListener::m_listeners;
GroundEntity_t OnGroundHookListener::gpOldGroundFn = nullptr;
DWORD* OnGroundHookListener::pdwInterface = nullptr;

//https://www.sourcemodplugins.org/vtableoffsets
// CBasePlayer::NetworkStateChanged_m_hGroundEntity(void*)

#ifdef NCZ_CSS
#	ifdef GNUC
#		define DEFAULT_GROUND_OFFSET "179"
#	else
#		define DEFAULT_GROUND_OFFSET "177"
#	endif
#else
#	ifdef NCZ_CSGO
#		ifdef GNUC
#			define DEFAULT_GROUND_OFFSET "177"
#		else
#			define DEFAULT_GROUND_OFFSET "175"
#		endif
#	else
#		ifdef NCZ_CSP

#		endif
#	endif
#endif

static ConVar var_onground_offset("ncz_onground_offset", DEFAULT_GROUND_OFFSET);

OnGroundHookListener::OnGroundHookListener()
{
}

OnGroundHookListener::~OnGroundHookListener()
{
}

void OnGroundHookListener::HookOnGround(NczPlayer* player)
{
	IServerUnknown * p1 = player->GetEdict()->GetUnknown();
	CBaseEntity * p2 = p1->GetBaseEntity();
	CBasePlayer *BasePlayer = reinterpret_cast<CBasePlayer *>(p2);

	if(pdwInterface != ( DWORD* )*( DWORD* )BasePlayer)
	{
		pdwInterface = ( DWORD* )*( DWORD* )BasePlayer;

#		ifdef DEBUG
		Msg("OnGroundHookListener::HookOnGround(NczPlayer* player)\n- var_onground_offset.GetInt() = %d\n- BasePlayer = %X\n- pdwInterface = %X\n", var_onground_offset.GetInt(), BasePlayer, pdwInterface);
#		endif

		DWORD OldFunc = VirtualTableHook(pdwInterface, var_onground_offset.GetInt(), ( DWORD )nNetworkStateChanged_m_hGroundEntity );
		*(DWORD*)&(gpOldGroundFn) = OldFunc;
	}
}

void OnGroundHookListener::UnhookOnGround()
{
	if(pdwInterface && gpOldGroundFn)
	{
		VirtualTableHook(pdwInterface, var_onground_offset.GetInt(), (DWORD)gpOldGroundFn);
		pdwInterface = nullptr;
		gpOldGroundFn = nullptr;
	}
}

#ifdef GNUC
void HOOKFN_INT OnGroundHookListener::nNetworkStateChanged_m_hGroundEntity(CBasePlayer* basePlayer, int * new_m_hGroundEntity)
#else
void HOOKFN_INT OnGroundHookListener::nNetworkStateChanged_m_hGroundEntity(CBasePlayer* basePlayer, void*, int * new_m_hGroundEntity)
#endif
{
	PlayerHandler* ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByBasePlayer(basePlayer);
	bool new_isOnground = true;

	if(ph->status >= PLAYER_CONNECTED)
	{
		if(*new_m_hGroundEntity == -1) new_isOnground = true;
		else new_isOnground = false;

		for(std::list<OnGroundHookListener*>::iterator it = m_listeners.begin(); it != m_listeners.end(); ++it)
			(*it)->m_hGroundEntityStateChangedCallback(ph->playerClass, new_isOnground);
	}

	gpOldGroundFn(basePlayer, new_m_hGroundEntity);
}

void OnGroundHookListener::RegisterOnGroundHookListener(OnGroundHookListener* listener)
{
	m_listeners.push_back(listener);
}

void OnGroundHookListener::RemoveOnGroundHookListener(OnGroundHookListener* listener)
{
	m_listeners.remove(listener);
}

```

`server-plugin/Code/Hooks/OnGroundHookListener.h`:

```h
#include <list>

#include "Hook.h"
#include "Players/NczPlayerManager.h"
#include "plugin.h"

#ifndef ONGROUNDHOOKLISTENER
#define ONGROUNDHOOKLISTENER

/////////////////////////////////////////////////////////////////////////
// CBasePlayer::NetworkStateChanged_m_hGroundEntity(void*)
/////////////////////////////////////////////////////////////////////////

class CBasePlayer;

typedef void (HOOKFN_EXT *GroundEntity_t)(CBasePlayer *, int*);

class OnGroundHookListener
{
public:
	OnGroundHookListener();
	~OnGroundHookListener();

	/*
		Hook and unhook functions.
		FIXME : May not works well with others plugins ...
	*/
	static void HookOnGround(NczPlayer* player);
	static void UnhookOnGround();

protected:
	static void RegisterOnGroundHookListener(OnGroundHookListener* listener);
	static void RemoveOnGroundHookListener(OnGroundHookListener* listener);
	
	virtual void m_hGroundEntityStateChangedCallback(NczPlayer* player, bool new_isOnGround) = 0;

private:
#ifdef GNUC
	static void HOOKFN_INT nNetworkStateChanged_m_hGroundEntity(CBasePlayer* basePlayer, int * new_m_hGroundEntity);
#else
	static void HOOKFN_INT nNetworkStateChanged_m_hGroundEntity(CBasePlayer* basePlayer, void*, int * new_m_hGroundEntity);
#endif
	
	static std::list<OnGroundHookListener*> m_listeners;
	static GroundEntity_t gpOldGroundFn;
	static DWORD* pdwInterface;
};

#endif

```

`server-plugin/Code/Hooks/PlayerRunCommandHookListener.cpp`:

```cpp
#include "PlayerRunCommandHookListener.h"
#include "plugin.h"

/////////////////////////////////////////////////////////////////////////
// PlayerRunCommandHookListener
/////////////////////////////////////////////////////////////////////////

PlayerRunCommand_t PlayerRunCommandHookListener::gpOldPlayerRunCommand = nullptr;
DWORD* PlayerRunCommandHookListener::pdwInterface = nullptr;
std::list<PlayerRunCommandHookListener*> PlayerRunCommandHookListener::m_listeners;
CUserCmd PlayerRunCommandHookListener::m_lastCUserCmd[MAX_PLAYERS];

//https://www.sourcemodplugins.org/vtableoffsets
// CCSPlayer::PlayerRunCommand(CUserCmd*, IMoveHelper*)

#ifdef NCZ_CSS
#	ifdef GNUC
#		define DEFAULT_RUNCOMMAND_OFFSET "420"
#	else
#		define DEFAULT_RUNCOMMAND_OFFSET "419"
#	endif
#else
#	ifdef NCZ_CSGO
#		ifdef GNUC
#			define DEFAULT_RUNCOMMAND_OFFSET "467"
#		else
#			define DEFAULT_RUNCOMMAND_OFFSET "466"
#		endif
#	else
#		ifdef NCZ_CSP

#		endif
#	endif
#endif

ConVar var_runcommand_offset("ncz_runcommand_offset", DEFAULT_RUNCOMMAND_OFFSET);

PlayerRunCommandHookListener::PlayerRunCommandHookListener()
{
	memset(m_lastCUserCmd, 0, sizeof(CUserCmd)*MAX_PLAYERS);
}

PlayerRunCommandHookListener::~PlayerRunCommandHookListener()
{
}

CUserCmd* PlayerRunCommandHookListener::GetLastUserCmd(NczPlayer* player)
{
	return &(m_lastCUserCmd[player->GetIndex()]);
}

void PlayerRunCommandHookListener::HookPlayerRunCommand(NczPlayer* player)
{
	IServerUnknown * p1 = player->GetEdict()->GetUnknown();
	CBaseEntity * p2 = p1->GetBaseEntity();
	CCSPlayer *BasePlayer = reinterpret_cast<CCSPlayer *>(p2);

	if(pdwInterface != ( DWORD* )*( DWORD* )BasePlayer)
	{
		pdwInterface = ( DWORD* )*( DWORD* )BasePlayer;

#		ifdef DEBUG
		Msg("PlayerRunCommandHookListener::HookPlayerRunCommand(NczPlayer* player)\n- var_runcommand_offset.GetInt() = %d\n- BasePlayer = %X\n- pdwInterface = %X\n", var_runcommand_offset.GetInt(), BasePlayer, pdwInterface);
#		endif

		DWORD OldFunc = VirtualTableHook(pdwInterface, var_runcommand_offset.GetInt(), (DWORD)nPlayerRunCommand );
		*(DWORD*)&(gpOldPlayerRunCommand) = OldFunc;
	}
}

void PlayerRunCommandHookListener::UnhookPlayerRunCommand()
{
	if(pdwInterface && gpOldPlayerRunCommand)
	{
		VirtualTableHook(pdwInterface, var_runcommand_offset.GetInt(), (DWORD)gpOldPlayerRunCommand);
		pdwInterface = nullptr;
		gpOldPlayerRunCommand = nullptr;
	}
}

#ifdef GNUC
void PlayerRunCommandHookListener::nPlayerRunCommand(void* This, CUserCmd* pCmd, IMoveHelper* pMoveHelper)
#else
void HOOKFN_INT PlayerRunCommandHookListener::nPlayerRunCommand(void* This, void*, CUserCmd* pCmd, IMoveHelper* pMoveHelper)
#endif
{
	PlayerHandler* ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByBasePlayer(This);

	if(ph->status == PLAYER_IN_TESTS)
	{
		for(std::list<PlayerRunCommandHookListener*>::iterator it = m_listeners.begin(); it != m_listeners.end(); ++it)
		{
			if((*it)->PlayerRunCommandCallback(ph->playerClass, pCmd))
			{
				pCmd->MakeInert();
				break;
			}
		}
	}

	m_lastCUserCmd[ph->playerClass->GetIndex()] = *pCmd;

	gpOldPlayerRunCommand(This, pCmd, pMoveHelper);
}

void PlayerRunCommandHookListener::RegisterPlayerRunCommandHookListener(PlayerRunCommandHookListener* listener)
{
	m_listeners.push_back(listener);
}

void PlayerRunCommandHookListener::RemovePlayerRunCommandHookListener(PlayerRunCommandHookListener* listener)
{
	m_listeners.remove(listener);
}

```

`server-plugin/Code/Hooks/PlayerRunCommandHookListener.h`:

```h
#include <list>

#include "Hook.h"
#include "Players/NczPlayerManager.h"
#include "Misc/IFaceManager.h"

#ifndef PLAYERRUNCOMMANDHOOKLISTENER
#define PLAYERRUNCOMMANDHOOKLISTENER

/////////////////////////////////////////////////////////////////////////
// CCSPlayer::PlayerRunCommand(CUserCmd*, IMoveHelper*)
/////////////////////////////////////////////////////////////////////////

class CUserCmd
{
public:
        CUserCmd()
        {
                Reset();
        }

        virtual ~CUserCmd() { };

        void Reset()
        {
                command_number = 0;
                tick_count = 0;
                viewangles.Init();
                forwardmove = 0.0f;
                sidemove = 0.0f;
                upmove = 0.0f;
                buttons = 0;
                impulse = 0;
                weaponselect = 0;
                weaponsubtype = 0;
                random_seed = 0;
                mousedx = 0;
                mousedy = 0;
        }

        CUserCmd& operator =( const CUserCmd& src )
        {
                if ( this == &src )
                        return *this;

                command_number                = src.command_number;
                tick_count                        = src.tick_count;
                viewangles                        = src.viewangles;
                forwardmove                        = src.forwardmove;
                sidemove                        = src.sidemove;
                upmove                                = src.upmove;
                buttons                                = src.buttons;
                impulse                                = src.impulse;
                weaponselect                = src.weaponselect;
                weaponsubtype                = src.weaponsubtype;
                random_seed                        = src.random_seed;
                mousedx                                = src.mousedx;
                mousedy                                = src.mousedy;
                return *this;
        }

        CUserCmd( const CUserCmd& src )
        {
                *this = src;
        }

        void GetChecksum( void ) const
        {
        }

        // Allow command, but negate gameplay-affecting values
        void MakeInert( void )
        {
                viewangles = vec3_angle;
                forwardmove = 0.f;
                sidemove = 0.f;
                upmove = 0.f;
                buttons = 0;
                impulse = 0;
        }

        // For matching server and client commands for debugging
        int                command_number;
        
        // the tick the client created this command
        int                tick_count;
        
        // Player instantaneous view angles.
        QAngle        viewangles;
        // Intended velocities
        //        forward velocity.
        float        forwardmove;
        // sideways velocity.
        float        sidemove;
        // upward velocity.
        float        upmove;
        // Attack button states
        int                buttons;                
        // Impulse command issued.
        byte impulse;
        // Current weapon id
        int                weaponselect;        
        int                weaponsubtype;

        int                random_seed;        // For shared random functions

        short        mousedx;                // mouse accum in x from create move
        short        mousedy;                // mouse accum in y from create move
};

class CCSPlayer;
class IMoveHelper;

//typedef void (HOOKFN_EXT *PlayerRunCommand_t)(void*, CUserCmd*, IMoveHelper*);
typedef void (HOOKFN_EXT *PlayerRunCommand_t)(void*, CUserCmd*, IMoveHelper*);

class PlayerRunCommandHookListener
{
public:
	PlayerRunCommandHookListener();
	~PlayerRunCommandHookListener();

	static void HookPlayerRunCommand(NczPlayer* player);

	static void UnhookPlayerRunCommand();
	static CUserCmd* GetLastUserCmd(NczPlayer* player);

protected:
	static void RegisterPlayerRunCommandHookListener(PlayerRunCommandHookListener* listener);
	static void RemovePlayerRunCommandHookListener(PlayerRunCommandHookListener* listener);

	virtual bool PlayerRunCommandCallback(NczPlayer* player, CUserCmd* cmd) = 0;

private:
#ifdef GNUC
	static void HOOKFN_INT nPlayerRunCommand(void* This, CUserCmd* pCmd, IMoveHelper* pMoveHelper);
#else
	static void HOOKFN_INT nPlayerRunCommand(void* This, void*, CUserCmd* pCmd, IMoveHelper* pMoveHelper);
#endif
	static std::list<PlayerRunCommandHookListener*> m_listeners;
	static CUserCmd m_lastCUserCmd[MAX_PLAYERS];
	static PlayerRunCommand_t gpOldPlayerRunCommand;
	static DWORD* pdwInterface;
};

#endif

```

`server-plugin/Code/Hooks/TeleportHookListener.cpp`:

```cpp
#include "TeleportHookListener.h"

std::list<TeleportHookListener*> TeleportHookListener::m_listeners;
Teleport_t TeleportHookListener::gpOldTeleportFn = nullptr;
DWORD* TeleportHookListener::pdwInterface = nullptr;

//https://www.sourcemodplugins.org/vtableoffsets
// CBaseFlex::Teleport(Vector const*, QAngle const*, Vector const*)

#ifdef NCZ_CSS
#	ifdef GNUC
#		define DEFAULT_TELEPORT_OFFSET "109"
#	else
#		define DEFAULT_TELEPORT_OFFSET "108"
#	endif
#else
#	ifdef NCZ_CSGO
#		ifdef GNUC
#			define DEFAULT_TELEPORT_OFFSET "114"
#		else
#			define DEFAULT_TELEPORT_OFFSET "113"
#		endif
#	else
#		ifdef NCZ_CSP

#		endif
#	endif
#endif

ConVar var_teleport_offset("ncz_teleport_offset", DEFAULT_TELEPORT_OFFSET);

TeleportHookListener::TeleportHookListener()
{
}

TeleportHookListener::~TeleportHookListener()
{
}

void TeleportHookListener::HookTeleport(NczPlayer* player)
{
	IServerUnknown * p1 = player->GetEdict()->GetUnknown();
	CBaseEntity * p2 = p1->GetBaseEntity();
	CBaseFlex *BasePlayer = reinterpret_cast<CBaseFlex *>(p2);

	if(pdwInterface != ( DWORD* )*( DWORD* )BasePlayer)
	{
		pdwInterface = ( DWORD* )*( DWORD* )BasePlayer;

#		ifdef DEBUG
		Msg("TeleportHookListener::HookTeleport(NczPlayer* player)\n- var_teleport_offset.GetInt() = %d\n- BasePlayer = %X\n- pdwInterface = %X\n", var_teleport_offset.GetInt(), BasePlayer, pdwInterface);
#		endif

		DWORD OldFunc = VirtualTableHook(pdwInterface, var_teleport_offset.GetInt(), ( DWORD )nTeleport);
		*(DWORD*)&(gpOldTeleportFn) = OldFunc;
	}
}

void TeleportHookListener::UnhookTeleport()
{
	if(pdwInterface && gpOldTeleportFn)
	{
		VirtualTableHook(pdwInterface, var_teleport_offset.GetInt(), (DWORD)gpOldTeleportFn);
		pdwInterface = nullptr;
		gpOldTeleportFn = nullptr;
	}
}

#ifdef GNUC
void TeleportHookListener::nTeleport(CBaseFlex * basePlayer, Vector const* va, QAngle const* qa, Vector const* vb)
#else
void HOOKFN_INT TeleportHookListener::nTeleport(CBaseFlex * basePlayer, void*, Vector const* va, QAngle const* qa, Vector const* vb)
#endif
{
	PlayerHandler* ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByBasePlayer(basePlayer);

	if(ph->status != BOT)
	{
		for(std::list<TeleportHookListener*>::iterator it = m_listeners.begin(); it != m_listeners.end(); ++it)
			(*it)->TeleportCallback(ph->playerClass, va, qa, vb);
	}

	gpOldTeleportFn(basePlayer, va, qa, vb);
}

void TeleportHookListener::RegisterTeleportHookListener(TeleportHookListener* listener)
{
	m_listeners.push_back(listener);
}

void TeleportHookListener::RemoveTeleportHookListener(TeleportHookListener* listener)
{
	m_listeners.remove(listener);
}

```

`server-plugin/Code/Hooks/TeleportHookListener.h`:

```h
#include <list>

#include "Hook.h"
#include "Players/NczPlayerManager.h"

#ifndef TELEPORTHOOKLISTENER
#define TELEPORTHOOKLISTENER

/////////////////////////////////////////////////////////////////////////
// CBaseFlex::Teleport(Vector const*, QAngle const*, Vector const*)
/////////////////////////////////////////////////////////////////////////

class CBaseFlex;

typedef void (HOOKFN_EXT *Teleport_t)(CBaseFlex *, Vector const*, QAngle const*, Vector const*);

class TeleportHookListener
{
public:
	TeleportHookListener();
	~TeleportHookListener();

	static void HookTeleport(NczPlayer* player);
	static void UnhookTeleport();

protected:
	static void RegisterTeleportHookListener(TeleportHookListener* listener);
	static void RemoveTeleportHookListener(TeleportHookListener* listener);
	
	virtual void TeleportCallback(NczPlayer* player, Vector const*, QAngle const*, Vector const*) = 0;

private:
#ifdef GNUC
	static void HOOKFN_INT nTeleport(CBaseFlex * basePlayer, Vector const* va, QAngle const* qa, Vector const* vb);
#else
	static void HOOKFN_INT nTeleport(CBaseFlex * basePlayer, void *, Vector const* va, QAngle const* qa, Vector const* vb);
#endif
	
	static std::list<TeleportHookListener*> m_listeners;
	static Teleport_t gpOldTeleportFn;
	static DWORD* pdwInterface;
};

#endif

```

`server-plugin/Code/Misc/EventManagerWrap.h`:

```h
#include "igameevents.h"

#ifndef EV_MANAGER_WRAP
#define EV_MANAGER_WRAP

#ifndef EVENT_DEBUG_ID_INIT
#	define EVENT_DEBUG_ID_INIT 42
#endif
#ifndef EVENT_DEBUG_ID_SHUTDOWN
#	define EVENT_DEBUG_ID_SHUTDOWN 13
#endif

class EventManagerWrap : public IGameEventListener2
{
public:
	EventManagerWrap()
	{
		m_debugid = EVENT_DEBUG_ID_INIT;
	};
	virtual ~EventManagerWrap()
	{
		m_debugid = EVENT_DEBUG_ID_SHUTDOWN;
	};

	virtual void FireGameEvent(IGameEvent* ev) = 0;

	virtual int GetEventDebugID()
	{
		return m_debugid;
	};

private:
	int m_debugid;
};

#endif

```

`server-plugin/Code/Misc/Helpers.cpp`:

```cpp
#include "Helpers.h"

#ifdef NCZ_CSGO
#	include <cstrike15_usermessage_helpers.h>
#endif

namespace Helpers
{
	edict_t * m_EdictList = nullptr;
	int  m_edictCount = 0;
	int  m_clientMax = 0;

	void toLowerCase(std::string &str)
	{
		std::locale loc;
		const int length = str.length();
		for(int i=0; i < length; ++i)
		{
			str[i] = std::tolower(str[i], loc);
		}
	}

	void xMsg(const char *fmt, ...)
	{
		va_list		argptr;
		static char		string[4096];

		va_start(argptr, fmt);
		vsnprintf(string, sizeof(string), fmt,argptr);
		va_end (argptr);

		std::string finalString = tostring("[" NCZ_PLUGIN_NAME "] ");
		std::string firstString = tostring(string);
		finalString += firstString;

		CIFaceManager::GetInstance()->GetIengine()->LogPrint(finalString.c_str());

	#ifdef WIN32
		firstString.pop_back();
	#else
		firstString = firstString.substr(0, firstString.length()-1);
	#endif
		writeToLogfile(getStrDateTime("%x %X") + " : " + firstString);	
	}

	std::string getStrGameDir()
	{
		char szGamedir[128];
		CIFaceManager::GetInstance()->GetIengine()->GetGameDir(szGamedir, 128);
		return tostring(szGamedir);
	}

	std::string getStrDateTime(const char *format)
	{
		time_t rawtime;
		struct tm * timeinfo;
		char date[256];
		time(&rawtime);
		timeinfo = localtime(&rawtime);
		strftime(date, sizeof(date), format, timeinfo);
		date[255] = '\0';
		return tostring(date);
	}

	bool bStrEq(const char *sz1, const char *sz2, size_t start_offset, size_t length)
	{
		size_t len = strlen(sz1);
		if(len != strlen(sz2)) return false;


		for(size_t x = start_offset, c = 0; x < len && c < length; ++x, ++c)
			if(sz1[x] != sz2[x]) return false;

		return true;
	}

	bool bStriEq(const char *sz1, const char *sz2, size_t start_offset, size_t length)
	{
		size_t len = strlen(sz1);
		if(len != strlen(sz2)) return false;

		char t1, t2;
		for(size_t x = start_offset, c = 0; x < len && c < length; ++x, ++c)
		{
			t1 = sz1[x];
			t2 = sz2[x];
			if(sz1[x] <= 'Z' && sz1[x] >= 'A')
				t1 = sz1[x] + 0x20;
			if(sz2[x] <= 'Z' && sz2[x] >= 'A')
				t2 = sz2[x] + 0x20;
			if(t1 != t2) return false;
		}

		return true;
	}

	bool bBytesEq(const char *sz1, const char *sz2, size_t start_offset, size_t length)
	{
		for(size_t x = start_offset, c = 0; c < length; ++x, ++c)
			if(sz1[x] != sz2[c]) return false;

		return true;
	}

	void split(const std::string &s, char delim, std::vector<std::string> &elems)
	{
		std::stringstream ss(s);
		std::string item;
		while (std::getline(ss, item, delim)) {
			elems.push_back(item);
		}
	}

	// At this point, steamid is from a valid human player.
	edict_t * getEdictFromSteamID(const char *SteamID)
	{
		const int imax = m_clientMax;
		for(int i = 1; i <= imax; i++)
		{
			edict_t* pEntity = PEntityOfEntIndex(i);
			// FIXME : Size of steamid is no more 8 digits.
			if(bStrEq(CIFaceManager::GetInstance()->GetIengine()->GetPlayerNetworkIDString(pEntity), SteamID, 8))
			{
				return pEntity;
			}
		}
		return nullptr;
	}

	// At this point, steamid if from a valid human player.
	int getIndexFromSteamID(const char *SteamID)
	{
		return IndexOfEdict(getEdictFromSteamID(SteamID));
	}

	edict_t * PEntityOfEntIndex(const int iEntIndex)
	{
#		ifdef ENGINE_HOLES
			return (edict_t *)(CIFaceManager::GetInstance()->GetGlobals()->pEdicts + iEntIndex);
#		else
			return CIFaceManager::GetInstance()->GetIengine()->PEntityOfEntIndex(iEntIndex);
#		endif
	}

	int IndexOfEdict(const edict_t *pEdict)
	{
#		ifdef ENGINE_HOLES
			return (int)(pEdict - (CIFaceManager::GetInstance()->GetGlobals()->pEdicts));
#		else
			return CIFaceManager::GetInstance()->GetIengine()->IndexOfEdict(pEdict);
#		endif
	}

	const unsigned char * FastScan_Internal(SigInst instructions)
	{
		ptr pAddr = CIFaceManager::GetInstance()->GetIFace(instructions.base_mod);
		if(!pAddr) return 0;
		const unsigned char * base_addr = nullptr;
		size_t base_len = 0;
	
#ifdef WIN32
		MEMORY_BASIC_INFORMATION mem;
		if(!VirtualQuery(pAddr, &mem, sizeof(mem))) return 0;

		base_addr = (const unsigned char *)mem.AllocationBase;
		IMAGE_DOS_HEADER *dos = (IMAGE_DOS_HEADER*)mem.AllocationBase;
		IMAGE_NT_HEADERS *pe = (IMAGE_NT_HEADERS*)((unsigned long)dos+(unsigned long)dos->e_lfanew);
		if(pe->Signature != IMAGE_NT_SIGNATURE) return 0;
		base_len = (size_t)pe->OptionalHeader.SizeOfImage;

#else
		Dl_info info;
		struct stat buf;

		if(!dladdr(pAddr, &info)) return 0;
		if(!info.dli_fbase || !info.dli_fname) return 0;
		if(stat(info.dli_fname, &buf) != 0) return 0;

		base_addr = (unsigned char *)info.dli_fbase;
		base_len = buf.st_size;
#endif

		const unsigned char * cur_addr = base_addr;
		const unsigned char * occurance_addr = cur_addr;
		unsigned int sig_pos = 0;
		bool in_occurance = false;
		for(; (DWORD)cur_addr < (DWORD)base_addr + (DWORD)base_len; ++cur_addr)
		{
			if(instructions.mask[sig_pos] == 'x')
			{
				if(instructions.sig[sig_pos] == *(unsigned char *)(cur_addr))
				{
					in_occurance = true;
					if(sig_pos == 0) occurance_addr = cur_addr;
					++sig_pos;
				}
				else if(in_occurance)
				{
					in_occurance = false;
					cur_addr = occurance_addr;
					sig_pos = 0;
				}
			}
			else if(instructions.mask[sig_pos] == '?' && in_occurance)
			{
				++sig_pos;
			}
			if(sig_pos == instructions.sig_len)
			{
				occurance_addr += instructions.final_address_offset;
				break;
			}
		}
		if(!in_occurance)
		{
			printf("Sigscan failed.\n");
			return 0;
		}
		else
		{
			return occurance_addr;
		}
	}

	void FastScan_EntList()
	{
		if(m_EdictList) return;
		SigInst EntSig;
		EntSig.base_mod = EngineServer;
#ifdef WIN32
		EntSig.sig = (unsigned char *)"\x55\x8B\xEC\x56\x8B\x75\x08\x3B\x35\x10\x11\x5E\x10\x72\x0E\x56\x68\x30\x2D\x33"
									  "\x10\xE8\xC6\xEF\x01\x00\x83\xC4\x08\x8B\x0D\x14\x11\x5E\x10\x8D\x04\xB6\x8D\x04"
									  "\x81\x5E\x5D\xC3";
		EntSig.mask =			"xxxxxxxx???????x????"
								"?x????xxxxx????xxxxx"
								"xxxx";
		EntSig.final_address_offset = 31;
		EntSig.sig_len = 44;
#else
		EntSig.sig = (unsigned char *)"\x55\x89\xE5\x53\x83\xEC\x14\x8B\x5D\x08\x3B\x1D\x00\xFC\x2F\x00\x72\x10\x89\x5C"
									  "\x24\x04\xC7\x04\x24\x4A\x91\x22\x00\xE8\x4E\x4E\x04\x00\x8B\x15\x04\xFC\x2F\x00"
									  "\x8D\x04\x9B\x83\xC4\x14\x5B\x8D\x04\x82\x5D\xC3";
		EntSig.mask =			"xxxxxxxxxxx???????x?"
								"??xx?????x????xx????"
								"xxxxxxxxxxxx";
		EntSig.final_address_offset = 36;
		EntSig.sig_len = 52;
#endif
		edict_t * *const *const addr = (edict_t * *const *const)FastScan_Internal(EntSig);
		if(!addr) return;
		m_EdictList = **addr;
		m_edictCount = *(int*)((*addr)-0x4);
	}

	int GetPlayerCount()
	{
		int count = 0;
		for(int index = 1; index <= 64; ++index)
		{
			edict_t * pEdict = Helpers::PEntityOfEntIndex(index);
			if(!isValidEdict(pEdict)) continue;
			const char * steamid = CIFaceManager::GetInstance()->GetIengine()->GetPlayerNetworkIDString(pEdict);
			if(!steamid) continue;
			if(steamid[0] == 'B') continue;
			++count;
		}
		return count;
	}

	std::string format(const char *fmt, ...)
	{
		va_list		argptr;
		static char		string[4096];

		va_start(argptr, fmt);
		Q_vsnprintf(string, sizeof(string), fmt,argptr);
		va_end (argptr);

		return tostring(string);
	}

	bool isValidEdict(const edict_t * entity)
	{
		return entity != nullptr && !entity->IsFree();
	}

	template<typename T>
	std::string tostring(const T & toConvert)
	{
		// FIXME : Use locale
		std::stringstream convertion;
		convertion << toConvert;
		return convertion.str();
	}

	float fabs(const float n)
	{
		float x = n;
		if(x < 0)
		{
			x = x * -1.0;
		}
		return x;
	}

	int abs(const int value)
	{
		//if((value>>31) & 1) return (~value)+1; Unsafe
		if(value < 0) return value*-1;
		return value;
	}

	bool isOdd(const int value)
	{
		if(value & 1) return true;
		return false;
	}

	int getIndexFromUserID(const int userid)
	{
		for(int i = 0; i <= CIFaceManager::GetInstance()->GetIengine()->GetEntityCount(); i++)
		{
			if(CIFaceManager::GetInstance()->GetIengine()->GetPlayerUserId(m_EdictList+i) == userid)
			{
				return i;
			}
		}
		return -1;
	}

	bool IsInt(const double value)
	{
		double n;
		if(std::modf(value, &n) == 0.0f) return true;
		return false;
	}
}

void Helpers::tell(edict_t *pEntity, const std::string& message)
{
	IPlayerInfo * const player =  CIFaceManager::GetInstance()->GetIplayers()->GetPlayerInfo(pEntity);
	if (player)
	{
		if (player->IsConnected())
		{
			const int ent_id = Helpers::IndexOfEdict(pEntity);
			MRecipientFilter filter;
			filter.AddRecipient(ent_id);
#			ifndef NCZ_CSGO
				bf_write *pBuffer = CIFaceManager::GetInstance()->GetIengine()->UserMessageBegin( &filter, 3 );
				pBuffer->WriteByte(ent_id);
				pBuffer->WriteString(message.c_str());
				CIFaceManager::GetInstance()->GetIengine()->MessageEnd();
#			else
				CCSUsrMsg_SayText* pBuffer = (CCSUsrMsg_SayText *)g_Cstrike15UsermessageHelpers.GetPrototype(CS_UM_SayText)->New();
				pBuffer->set_ent_idx(ent_id);
				pBuffer->set_text(message.c_str());
				pBuffer->set_chat(true);
				CIFaceManager::GetInstance()->GetIengine()->SendUserMessage(filter, CS_UM_SayText, *pBuffer);
				delete pBuffer;
#			endif
		}
	}
}

void Helpers::noTell(const edict_t *pEntity, const std::string& msg)
{
	for (int i=1; i <= CIFaceManager::GetInstance()->GetGlobals()->maxClients; i++)
	{
		edict_t * ent_id = Helpers::PEntityOfEntIndex(i);
		if(ent_id == pEntity) continue;

		IPlayerInfo * const player = CIFaceManager::GetInstance()->GetIplayers()->GetPlayerInfo(ent_id);

		if (player)
		{
			if (player->IsConnected())
			{
				Helpers::tell(ent_id, msg);
			}
		}
	}
}

void Helpers::chatmsg(const std::string& msg)
{
	for (int i=1; i <= CIFaceManager::GetInstance()->GetGlobals()->maxClients; i++)
	{
		edict_t * ent_id = Helpers::PEntityOfEntIndex(i);
		IPlayerInfo * const player = CIFaceManager::GetInstance()->GetIplayers()->GetPlayerInfo(ent_id);

		if (player)
		{
			if (player->IsConnected())
			{
				Helpers::tell(ent_id, msg);
			}
		}
	}
}

```

`server-plugin/Code/Misc/Helpers.h`:

```h
#ifndef HELPERS
#define HELPERS

#include <iostream>
#include <string>
#include <locale>
#include <cstdarg>
#include <fstream>
#include <vector>
#include <sstream>
#undef min
#undef max
#include <algorithm>
#include <iterator>
#include <cmath>

#include "Preprocessors.h"
#include "Types.h"
#include "IFaceManager.h"
#include "temp_Singleton.h"
#include "edict.h"
#include "MRecipientFilter.h"

#ifdef WIN32
#	include "include_windows_headers.h"
#	include "TlHelp32.h"
#else
#	include <sys/types.h>
#	include <wchar.h>
#	include <dlfcn.h>
#	include <sys/types.h>
#	include <sys/stat.h>
#endif

struct SigInst
{
	IFaceIndex base_mod;
	unsigned char* sig;
	const char* mask;
	size_t sig_len;
	size_t final_address_offset;
};

namespace Helpers
{
	/* Convertis une chaine de caractères en caractères minuscules */
	void toLowerCase(std::string &p_str);

	/* Envoie un message */
	void xMsg(const char *p_fmt, ...);

	/* Vérifie que 2 chaines de caractères sont strictement identiques
	   Possibilité de se servir de sz1 comme un buffer à l'aide de start_offset et length */
	bool bStrEq(const char *sz1, const char *sz2, size_t start_offset = 0, size_t length = 0xFFFFFFFF);

	/* Même utilité que bStrEq, sz1 est un buffer obligatoirement */
	bool bBytesEq(const char *sz1, const char *sz2, size_t start_offset, size_t length);

	/* Même utilité que bStrEq, n'est pas sensible à la casse */
	bool bStriEq(const char *sz1, const char *sz2, size_t start_offset = 0, size_t length = 0xFFFFFFFF);

	/* Ecrit dans le fichier de log. Doit être remplacé par une classe du même style que BanRequest */
	void writeToLogfile(const std::string &p_text);

	/* Retourne la date selon le format */
	std::string getStrDateTime(const char *p_format);

	/* Retourne le chemin absolu du dossier contenant le gameinfo.txt en cours */
	std::string getStrGameDir();


	edict_t * getEdictFromSteamID(const char *p_SteamID);
	int getIndexFromSteamID(const char *SteamID);
	edict_t * PEntityOfEntIndex(const int p_iEntIndex);
	int getIndexFromUserID(const int p_userid);
	int IndexOfEdict(const edict_t *p_pEdict);
	bool isValidEdict(const edict_t * p_entity);
	int GetPlayerCount();

	/* Permet d'avoir un format style C dans un conteneur C++ */
	std::string format(const char *fmt, ...);
	
	/* Retourne vrai si la valeur est impaire ... */
	bool isOdd(const int value);

	/* Découpe une chaine de caractère */
	void split(const std::string &p_s, char p_delim, std::vector<std::string> &elems);

	/* Conversion des chars vers std::string */
	template<typename T>
	std::string tostring(const T & p_toConvert);

	/* Retourne vrai si value est un entier ... (140.000, 1587.000 etc) */
	bool IsInt(double value);

	/* Envoie un message chat à tous les clients sauf pEntity */
	void noTell(const edict_t *pEntity, const std::string& msg);

	void chatmsg(const std::string& msg);

	/* Envoie un message chat à pEntity */
	void tell(edict_t *pEntity, const std::string& message);

	/* Aide au sigscan, retourne l'endroit qui est intéressant dans la mémoire du module sinon 0 */
	const unsigned char * FastScan_Internal(SigInst instructions);

	/* Essaie de récupérer m_EdictList si null */
	void FastScan_EntList();

	/* C'est la base ... */
	extern edict_t* m_EdictList;

	/* N'est pas utilisé */
	extern int m_edictCount;

	/* Ne doit pas être utilisé */
	extern int m_clientMax;
};

#endif

```

`server-plugin/Code/Misc/IFaceManager.cpp`:

```cpp
#include "IFaceManager.h"

////////////////////////////////////////
CIFaceManager::~CIFaceManager()
{
}
////////////////////////////////////////

CIFaceManager::CIFaceManager()
{
	IFaces[gameFactory].name = "CreateInterfaceFn gameFactory";
	IFaces[interfaceFactory].name = "CreateInterfaceFn interfaceFactory";
	IFaces[EngineServer].name = "VEngineServer";
	IFaces[EventManager2].name = "GAMEEVENTSMANAGER";
	IFaces[PlayerInfoManager].name = "PlayerInfoManager";
	IFaces[ServerPluginHelpers].name = "ISERVERPLUGINHELPERS";
	IFaces[GameDLL].name = "ServerGameDLL";
	IFaces[GameEnts].name = "ServerGameEnts";
	IFaces[GameClients].name = "ServerGameClients";
	IFaces[Trace].name = "EngineTraceServer";

	IFaces[EngineServer].compiled_version = INTERFACEVERSION_VENGINESERVER_INT;
	IFaces[EventManager2].compiled_version = INTERFACEVERSION_GAMEEVENTSMANAGER2_INT;
	IFaces[PlayerInfoManager].compiled_version = INTERFACEVERSION_PLAYERINFOMANAGER_INT;
	IFaces[ServerPluginHelpers].compiled_version = INTERFACEVERSION_PLUGINHELPERSCHECK_INT;
	IFaces[GameDLL].compiled_version = INTERFACEVERSION_SERVERGAMEDLL_INT;
	IFaces[GameEnts].compiled_version = INTERFACEVERSION_SERVERGAMEENTS_INT;
	IFaces[GameClients].compiled_version = INTERFACEVERSION_SERVERGAMECLIENTS_INT;
	IFaces[Trace].compiled_version = INTERFACEVERSION_ENGINETRACE_SERVER_INT;

	IFaces[gameFactory].factory = gameFactory;
	IFaces[interfaceFactory].factory = interfaceFactory;
	IFaces[EngineServer].factory = interfaceFactory;
	IFaces[EventManager2].factory = interfaceFactory;
	IFaces[PlayerInfoManager].factory = gameFactory;
	IFaces[ServerPluginHelpers].factory = interfaceFactory;
	IFaces[GameDLL].factory = gameFactory;
	IFaces[GameEnts].factory = gameFactory;
	IFaces[GameClients].factory = gameFactory;
	IFaces[Trace].factory = interfaceFactory;

	for(int x = 0; x < INTERFACES_COUNT; ++x)
	{
		IFaces[x].version = 0;
		IFaces[x].IFacePtr = nullptr;
	}
}

ptr CIFaceManager::_GetIFacePtr(IFaceIndex Index) const
{
	return IFaces[Index].IFacePtr;
}

const char * CIFaceManager::_GetIFaceName(IFaceIndex Index) const
{
	return IFaces[Index].name;
}

ptr CIFaceManager::_GetFactoryPtr(IFactoryIndex Index) const
{
	return IFaces[Index].IFacePtr;
}

ptr CIFaceManager::_GetIFaceFactoryPtr(IFaceIndex Index) const
{
	return _GetFactoryPtr(IFaces[Index].factory);
}

void CIFaceManager::_UpdateIFacePtr(IFaceIndex Index, ptr newPtr)
{
	IFaces[Index].IFacePtr = newPtr;
}

void CIFaceManager::UpdateIFactoryPtr(IFactoryIndex Index, ptr newPtr)
{
	Msg("[NoCheatZ 4] CIFaceManager - Info : Registering %s at %x.\n", IFaces[Index].name, newPtr);
	IFaces[Index].IFacePtr = newPtr;

#ifdef IFACEMANAGER_AUTOINIT
	if(IFaces[interfaceFactory].IFacePtr && IFaces[gameFactory].IFacePtr)
	{
		for(int x = EngineServer; x <= Trace; x++)
		{
			if(IFaces[x].IFacePtr != nullptr) continue;
			if(x == Globals) continue;

			ptr pIFace = nullptr;
			CreateInterfaceFn Factory = reinterpret_cast<CreateInterfaceFn>(_GetFactoryPtr(IFaces[x].factory));

			int i_v = 40;
			char s_v[64];
			while ( !pIFace )
			{
				--i_v;
				if(i_v == 0)
				{
					pIFace = nullptr;
					break;
				}
				if(i_v < 10)
				{
					sprintf(s_v, "%s00%d\0", IFaces[x].name, i_v);
				}
				else if(i_v > 9)
				{
					sprintf(s_v, "%s0%d\0", IFaces[x].name, i_v);
				}
				pIFace = (ptr)Factory(s_v, nullptr);
			}
			IFaces[x].version = i_v;
			IFaces[x].IFacePtr = pIFace;
			Msg("[NoCheatZ 4] CIFaceManager - Info : Registering interface %s at %x.\n", s_v, IFaces[x].IFacePtr);
			if(IFaces[x].version != IFaces[x].compiled_version) Msg("CIFaceManager - Warning : Using other version of interface %s.\n", IFaces[x].name);
		}
		if(this->GetIplayers() && IFaces[Globals].IFacePtr == nullptr)
		{
			Msg("[NoCheatZ 4] CIFaceManager - Info : Registering GlobalVars at %x.\n", this->GetIplayers()->GetGlobalVars());
			IFaces[Globals].IFacePtr = this->GetIplayers()->GetGlobalVars();
		}

	}
#endif
}

void CIFaceManager::_UpdateIFaceName(IFaceIndex Index, const char * name)
{
	IFaces[Index].name = name;
}

#ifndef IFACEMANAGER_AUTOINIT
ptr CIFaceManager::GetIFace(IFaceIndex Index)
{
	ptr pIFace = nullptr;
	CreateInterfaceFn Factory = reinterpret_cast<CreateInterfaceFn>(_GetIFaceFactoryPtr(Index));
	if(_GetIFacePtr(Index) != nullptr) return _GetIFacePtr(Index);

	int i_v = 40;
	char s_v[64];
	while ( !pIFace )
	{
		--i_v;
		if(i_v < 0)
		{
			return nullptr;
		}
		if(i_v < 10)
		{
			sMsg(s_v, "%s00%d", IFaces[Index].name, i_v);
		}
		else if(i_v > 9)
		{
			sMsg(s_v, "%s0%d", IFaces[Index].name, i_v);
		}
		pIFace = (ptr)Factory(s_v, nullptr);
	}
	IFaces[Index].version = i_v;
	_UpdateIFacePtr(Index, pIFace);
	return pIFace;
}

IVEngineServer* CIFaceManager::GetIengine()
{
	return reinterpret_cast<IVEngineServer*>(GetIFace(IFaceIndex::EngineServer));
}

IGameEventManager2* CIFaceManager::GetIevents()
{
	return reinterpret_cast<IGameEventManager2*>(GetIFace(IFaceIndex::EventManager2));
}

IPlayerInfoManager* CIFaceManager::GetIplayers()
{
	return reinterpret_cast<IPlayerInfoManager*>(GetIFace(IFaceIndex::PlayerInfoManager));
}

IServerPluginHelpers* CIFaceManager::GetIpluginhelpers()
{
	return reinterpret_cast<IServerPluginHelpers*>(GetIFace(IFaceIndex::ServerPluginHelpers));
}

IServerGameDLL* CIFaceManager::GetIgamedll()
{
	return reinterpret_cast<IServerGameDLL*>(GetIFace(IFaceIndex::GameDLL));
}

IEngineTrace* CIFaceManager::GetItrace()
{
	return reinterpret_cast<IEngineTrace*>(GetIFace(IFaceIndex::Trace));
}

IServerGameEnts* CIFaceManager::GetIents()
{
	return reinterpret_cast<IServerGameEnts*>(GetIFace(IFaceIndex::GameEnts));
}

IServerGameClients* CIFaceManager::GetIclients()
{
	return reinterpret_cast<IServerGameClients*>(GetIFace(IFaceIndex::GameClients));
}

CGlobalVars* CIFaceManager::GetGlobals()
{
	if((ptr)(GetIFace(IFaceIndex::Globals))) return reinterpret_cast<CGlobalVars*>(GetIFace(IFaceIndex::Globals));
	if((ptr)(GetIFace(IFaceIndex::PlayerInfoManager)))
	{
		if(GetIplayers()->GetGlobalVars())
		{
			_UpdateIFacePtr(IFaceIndex::Globals, GetIplayers()->GetGlobalVars());
			return GetIplayers()->GetGlobalVars();
		}
	}
	return nullptr;
}

#else

ptr CIFaceManager::GetIFace(IFaceIndex Index) const
{
	return _GetIFacePtr(Index);
}

IVEngineServer* CIFaceManager::GetIengine() const
{
	return reinterpret_cast<IVEngineServer*>(GetIFace(EngineServer));
}

IGameEventManager2* CIFaceManager::GetIevents() const
{
	return reinterpret_cast<IGameEventManager2*>(GetIFace(EventManager2));
}

IPlayerInfoManager* CIFaceManager::GetIplayers() const
{
	return reinterpret_cast<IPlayerInfoManager*>(GetIFace(PlayerInfoManager));
}

IServerPluginHelpers* CIFaceManager::GetIpluginhelpers() const
{
	return reinterpret_cast<IServerPluginHelpers*>(GetIFace(ServerPluginHelpers));
}

IServerGameDLL* CIFaceManager::GetIgamedll() const
{
	return reinterpret_cast<IServerGameDLL*>(GetIFace(GameDLL));
}

IEngineTrace* CIFaceManager::GetItrace() const
{
	return reinterpret_cast<IEngineTrace*>(GetIFace(Trace));
}

IServerGameEnts* CIFaceManager::GetIents() const
{
	return reinterpret_cast<IServerGameEnts*>(GetIFace(GameEnts));
}

IServerGameClients* CIFaceManager::GetIclients() const
{
	return reinterpret_cast<IServerGameClients*>(GetIFace(GameClients));
}

CGlobalVars* CIFaceManager::GetGlobals() const
{
	return reinterpret_cast<CGlobalVars*>(GetIFace(Globals));
}

#endif


```

`server-plugin/Code/Misc/IFaceManager.h`:

```h
#include "Preprocessors.h"
#include "interface.h"
#include "Types.h"
#include "eiface.h"
#include "igameevents.h"
#include "game/server/iplayerinfo.h"
#include "engine/iserverplugin.h"
#include "engine/IEngineTrace.h"
#include "temp_Singleton.h"

#ifndef IFaceManagerClass
#define IFaceManagerClass

enum IFactoryIndex
{
	gameFactory = 0,
	interfaceFactory
};

enum IFaceIndex
{
	EngineServer = 2,
	EventManager2,
	PlayerInfoManager,
	ServerPluginHelpers,
	GameDLL,
	GameEnts,
	GameClients,
	Globals,
	Trace
};

struct IFaceElement
{
	ptr IFacePtr;
	const char *name;
	IFactoryIndex factory;
	unsigned short version;
	unsigned short compiled_version;
};

#define INTERFACES_COUNT 12

class CIFaceManager : public Singleton<CIFaceManager>
{
public:
	CIFaceManager();
	~CIFaceManager();

#ifndef IFACEMANAGER_AUTOINIT
	IVEngineServer* GetIengine();
	IGameEventManager2* GetIevents();
	IPlayerInfoManager* GetIplayers();
	IServerPluginHelpers* GetIpluginhelpers();
	IServerGameDLL* GetIgamedll();
	IEngineTrace* GetItrace();
	IServerGameEnts* GetIents();
	IServerGameClients* GetIclients();
	CGlobalVars* GetGlobals();
	virtual ptr GetIFace(IFaceIndex Index);
#else
	IVEngineServer* GetIengine() const;
	IGameEventManager2* GetIevents() const;
	IPlayerInfoManager* GetIplayers() const;
	IServerPluginHelpers* GetIpluginhelpers() const;
	IServerGameDLL* GetIgamedll() const;
	IEngineTrace* GetItrace() const;
	IServerGameEnts* GetIents() const;
	IServerGameClients* GetIclients() const;
	CGlobalVars* GetGlobals() const;
	ptr GetIFace(IFaceIndex Index) const;
#endif

	void UpdateIFactoryPtr(IFactoryIndex Index, ptr newPtr);


	ptr				_GetIFacePtr(IFaceIndex Index) const;
	ptr				_GetIFaceFactoryPtr(IFaceIndex Index) const;
	ptr				_GetFactoryPtr(IFactoryIndex Index) const;
private:
	void			_UpdateIFacePtr(IFaceIndex Index, ptr newPtr);
	void			_UpdateIFaceName(IFaceIndex Index, const char * name);
	const char *	_GetIFaceName(IFaceIndex Index) const;

	IFaceElement IFaces[INTERFACES_COUNT];
};

#endif

```

`server-plugin/Code/Misc/MRecipientFilter.cpp`:

```cpp
#include "MRecipientFilter.h"

MRecipientFilter::MRecipientFilter(void)
{
}

MRecipientFilter::~MRecipientFilter(void)
{
}

int MRecipientFilter::GetRecipientCount() const
{
#ifdef NCZ_CSGO
    return m_Recipients.Count();
#else
	return m_Recipients.Size();
#endif
}

int MRecipientFilter::GetRecipientIndex(int slot) const
{
    if ( slot < 0 || slot >= GetRecipientCount() )
        return -1;

    return m_Recipients[ slot ];
}

bool MRecipientFilter::IsInitMessage() const
{
    return false;
}

bool MRecipientFilter::IsReliable() const
{
    return false;
}

void MRecipientFilter::AddAllPlayers(int maxClients)
{
    m_Recipients.RemoveAll();
    for ( int i = 1; i <= maxClients; i++ )
    {
        edict_t *pPlayer = Helpers::PEntityOfEntIndex(i);
        if ( !pPlayer || pPlayer->IsFree())
            continue;
        //AddRecipient( pPlayer );
        m_Recipients.AddToTail(i);
    }
}
void MRecipientFilter::AddRecipient( int iPlayer )
{
    // Already in list
    if ( m_Recipients.Find( iPlayer ) != m_Recipients.InvalidIndex() )
        return;

    m_Recipients.AddToTail( iPlayer );
}

```

`server-plugin/Code/Misc/MRecipientFilter.h`:

```h
#ifndef _MRECIPIENT_FILTER_H
#define _MRECIPIENT_FILTER_H
#include "irecipientfilter.h"
#include "bitvec.h"
#include "utlvector.h"
#ifdef GNUC
#undef min
#undef max
#endif
#include "Helpers.h"

class MRecipientFilter : public IRecipientFilter
{
public:
    MRecipientFilter(void);
    ~MRecipientFilter(void);

    virtual bool IsReliable( void ) const;
    virtual bool IsInitMessage( void ) const;

    virtual int GetRecipientCount( void ) const;
    virtual int GetRecipientIndex( int slot ) const;
    void AddAllPlayers( int maxClients );
    void AddRecipient (int iPlayer );

private:
    bool m_bReliable;
    bool m_bInitMessage;
    CUtlVector< int > m_Recipients;
};

#endif

```

`server-plugin/Code/Misc/RMS.cpp`:

```cpp
#include "RMS.h"

RMS::RMS()
{
	rms_array.clear();
	rms_array.resize(0);
}

RMS::RMS(size_t N)
{
	rms_array.resize(N, 0);
}

RMS::~RMS()
{
}

void RMS::Add(T_RMS Value)
{
	rms_array.push_back(fabs(Value));
	rms_array.pop_front();
}

void RMS::SetN(size_t N)
{
	rms_array.resize(N, 0);
}

T_RMS RMS::GetRMS(void)
{
	T_RMS addy = 0;
	for(std::list<T_RMS>::iterator it = rms_array.begin(); it != rms_array.end(); ++it)	addy += (*it) * (*it);
	T_RMS rms = sqrt(addy / (float)(rms_array.size()));
	return rms;
}

T_RMS RMS::GetRMSSigned(void)
{
	T_RMS addy = 0;
	for(std::list<T_RMS>::iterator it = rms_array.begin(); it != rms_array.end(); ++it)	addy += (*it) * (*it);
	T_RMS rms = sqrt(addy / (float)(rms_array.size()));
	if(rms_array.back() > 0.0f) rms *= -1.0f;
	return rms;
}

```

`server-plugin/Code/Misc/RMS.h`:

```h
#include <list>

#ifdef GNUC
#include <cmath>
typedef unsigned long size_t;
#endif

#ifndef RMS_CLASS
#define RMS_CLASS

typedef float T_RMS;

class RMS
{
public:
	RMS();
	RMS(size_t N);
	~RMS();

	void Add(T_RMS Value);
	void SetN(size_t N);

	T_RMS GetRMS(void);
	T_RMS GetRMSSigned(void);
private:
	std::list<T_RMS> rms_array;
};

#endif

```

`server-plugin/Code/Misc/Types.h`:

```h
typedef double time_z ;
typedef unsigned long count_z ; // How do you do with reverse ? Hmmm ?
typedef unsigned int rate_z;
typedef void * ptr;
typedef unsigned long hash_t;
typedef unsigned char int_8b;
typedef int tick_t;
typedef char Byte;
typedef Byte* BytesTable;

// This file is almost completly useless ... It makes everything overdone and not readable.
```

`server-plugin/Code/Misc/include_windows_headers.h`:

```h
#ifndef WINSOCKWRAPPERH
#define WINSOCKWRAPPERH

#pragma once

/*
#define _WINSOCKAPI_
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
*/

#include <Windows.h>

#include "wchartypes.h"
#include <tchar.h>

//typedef int socklen_t;
 
#endif

```

`server-plugin/Code/Misc/temp_BaseDataStruct.h`:

```h
#include "dbg.h"

#ifndef BASEDATASTRUCT
#define BASEDATASTRUCT

template <typename DataT, int MAX_ELEM>
class BaseDataStructHandler
{
public:
	BaseDataStructHandler()
	{
		for(int x = 0; x < MAX_ELEM; ++x)
			m_dataStruct[x] = DataT();
	};
	~BaseDataStructHandler()
	{
	};

	void ResetAll(const DataT* src)
	{
		if(src)
		{
			for(size_t index = 0; index < MAX_ELEM; ++index)
				m_dataStruct[index] = *src;
		}
		else
		{
			for(int x = 0; x < MAX_ELEM; ++x)
			{
				m_dataStruct[x] = DataT();
			}
		}
	};

protected:
	const DataT& GetDataStruct(const int elem) const
	{
		return m_dataStruct[elem];
	};

	void ResetDataStruct(const int elem)
	{
		m_dataStruct[elem] = DataT();
	};

protected:
	DataT m_dataStruct[MAX_ELEM];
};

#endif

```

`server-plugin/Code/Misc/temp_Singleton.h`:

```h
#ifdef GNUC
#undef min
#undef max
#endif
#include "Preprocessors.h"

#ifndef SINGLETON_CLASS
#define SINGLETON_CLASS

template <typename SingletonT>
class Singleton
{
protected:
  Singleton () {};
  ~Singleton () {};

public:

	static SingletonT * GetInstance()
	{
		//m_mtx.lock();
		if (_singleton == nullptr)
		{
			_singleton = new SingletonT;
		}
		//m_mtx.unlock();
		return (static_cast<SingletonT*> (_singleton));
	};

	static void Delete()
	{
		if (_singleton != nullptr)
		{
			delete _singleton;
			_singleton = nullptr;
		}
	};

public:
	 //static std::mutex m_mtx;

private:
  static SingletonT *_singleton;
};

template <typename T>
T *Singleton<T>::_singleton = nullptr;

//template <typename T>
//std::mutex Singleton<T>::m_mtx;

#endif

```

`server-plugin/Code/Players/NczFilteredPlayersList.cpp`:

```cpp
#include "NczFilteredPlayersList.h"

NczFilteredPlayersList::NczFilteredPlayersList()
{
	m_nextPlayer = nullptr;
}

NczPlayer* NczFilteredPlayersList::GetNextPlayer()
{
	// Met à jour le prochain pointeur en interne et retourne celui en cours
	NczPlayer* playerStor = m_nextPlayer->playerClass;
	if(playerStor == nullptr) return nullptr; // Liste vide

	for(int index = playerStor->GetIndex()+1; index < MAX_PLAYERS; ++index)
	{
		m_nextPlayer = NczPlayerManager::GetInstance()->GetPlayerHandlerByIndex(index);
		if(m_nextPlayer->status != GetFilter()) continue;
		break;
	}
	if(playerStor == m_nextPlayer->playerClass) return nullptr; // Fin de liste
	return playerStor;
}

void NczFilteredPlayersList::ResetNextPlayer()
{
	// Remet l'itération à zero
	m_nextPlayer = nullptr;
	PLAYERS_LOOP_RUNTIME
	{
		if(ph->status < GetFilter()) continue;
		m_nextPlayer = ph;
		break;
	}
	END_PLAYERS_LOOP
}

NczPlayer* AsyncNczFilteredPlayersList::GetNextPlayer()
{
	// On re-vérifie le pointeur actuel
	if(m_nextPlayer == nullptr) ResetNextPlayer();
	if(m_nextPlayer == nullptr) return nullptr;
	if(m_nextPlayer->status < GetFilter())
	{
		ResetNextPlayer();
		if(m_nextPlayer == nullptr) return nullptr;
	}
	if(m_nextPlayer->status == INVALID) return nullptr;

	NczPlayer* playerStor = m_nextPlayer->playerClass;
	
	int index = m_nextPlayer->playerClass->GetIndex();
	int loop_count = 0;
	while((m_nextPlayer = NczPlayerManager::GetInstance()->GetPlayerHandlerByIndex(++index)) == nullptr && (++loop_count) != MAX_PLAYERS)
	{
		index %= MAX_PLAYERS;
	}
	return playerStor;
}

```

`server-plugin/Code/Players/NczFilteredPlayersList.h`:

```h
//#include <mutex>
#include "NczPlayer.h"
#include "NczPlayerManager.h"

#ifndef NCZFILTEREDPLAYERLIST
#define NCZFILTEREDPLAYERLIST

/*
	Gives a list to Systems.
	May be used to iterate over all players in the filter specifyed
	in one frame.
*/
class NczFilteredPlayersList
{
public:
	NczFilteredPlayersList();
	virtual ~NczFilteredPlayersList(){};

	// Systems use this to know which playerlist to test
	virtual SlotStatus GetFilter() = 0;

	virtual NczPlayer* GetNextPlayer(); 
	virtual void ResetNextPlayer();

protected:
	PlayerHandler* m_nextPlayer;
};

/*
	Gives a list to Systems.
	May be used to iterate over all players in the filter specifyed
	in multiple frames.
	NOT THREAD SAFE.
*/
class AsyncNczFilteredPlayersList : public NczFilteredPlayersList
{
public:
	AsyncNczFilteredPlayersList() : NczFilteredPlayersList() {};
	virtual ~AsyncNczFilteredPlayersList(){};

	// Returns null only if no players are available
	virtual NczPlayer* GetNextPlayer();
};

#endif

```

`server-plugin/Code/Players/NczPlayer.cpp`:

```cpp
#include "NczPlayer.h"

//---------------------------------------------------------------------------------
// NczPlayer
//---------------------------------------------------------------------------------

NczPlayer::NczPlayer(const int index) : cIndex(index), m_time_connected(0.0)
{
	m_edict = Helpers::PEntityOfEntIndex(index);
	m_userid = CIFaceManager::GetInstance()->GetIengine()->GetPlayerUserId(m_edict);
	m_channelinfo = CIFaceManager::GetInstance()->GetIengine()->GetPlayerNetInfo(index);
}

int NczPlayer::GetUserid() const
{
	return m_userid;
}

float NczPlayer::GetTimeConnected()
{
	return Plat_FloatTime() - m_time_connected;
}

const char * NczPlayer::GetName()
{
	return GetPlayerInfo()->GetName();
}

IPlayerInfo * NczPlayer::GetPlayerInfo()
{
	return CIFaceManager::GetInstance()->GetIplayers()->GetPlayerInfo(m_edict);
}

const char * NczPlayer::GetSteamID()
{
	return CIFaceManager::GetInstance()->GetIengine()->GetPlayerNetworkIDString(m_edict);
}

const char * NczPlayer::GetIPAddress()
{
	return GetChannelInfo()->GetAddress();
}

WpnShotType NczPlayer::GetWpnShotType()
{
	IPlayerInfo* playerinfo = GetPlayerInfo();

	if(playerinfo)
	{
		const char * const wpn_name = playerinfo->GetWeaponName();

		switch(wpn_name[7])
		{
		case 's': //scout & sg550 & smokegrenade
			switch(wpn_name[8])
			{
			case 'c':
				return PISTOL;
			case 'g':
				return AUTO;
			
			default: //m
				return HAND;
			};

		case 'a': //awp & ak47
			switch(wpn_name[8])
			{
			case 'w':
				return PISTOL;
			case 'k':
				return AUTO;
			};
		case 'f': //fiveseven & flashbang
			switch(wpn_name[8])
			{
			case 'i':
				return PISTOL;
			default: //l
				return HAND;
			};
		case 'g': //glock & g3sg1
			switch(wpn_name[8])
			{
			case 'l':
				return PISTOL;
			case '3':
				return AUTO;
			};
		case 'p': //p228
		case 'e': //elite
		case 'u': //usp
		case 'd': //deagle
		case 'x': //xm1014
			return PISTOL;
		case 'm': //m3 & m4a1
			switch(wpn_name[8])
			{
			case '3':
				return PISTOL;
			case '4':
				return AUTO;
			};

		default:
			return HAND;
		};
	}
	return HAND;
}

int NczPlayer::aimingAt()
{
	trace_t trace;
	Ray_t ray;

	edict_t* edict = GetEdict();
	if(!edict) return -1;
	IPlayerInfo* playerinfo = GetPlayerInfo();
	if(!playerinfo) return -1;
	CBotCmd cmd = playerinfo->GetLastUserCommand();

	Vector earPos;
	CIFaceManager::GetInstance()->GetIclients()->ClientEarPosition(edict, &earPos);
	Vector eyePos = earPos;

	QAngle eyeAngles = cmd.viewangles;
	Vector vEnd;
	AngleVectors(eyeAngles, &vEnd);
	vEnd = vEnd * 8192.0f + eyePos;
	
	ray.Init(eyePos,vEnd);
	CIFaceManager::GetInstance()->GetItrace()->TraceRay( ray, (CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_DEBRIS | CONTENTS_HITBOX), NULL, &trace );
	
	edict_t* target = CIFaceManager::GetInstance()->GetIents()->BaseEntityToEdict(trace.m_pEnt);
	if ( target && !Helpers::IndexOfEdict(target) == 0 && !trace.allsolid )
	{
		if(!Helpers::isValidEdict(target)) return -1;
#undef GetClassName
		if(strcmp(target->GetClassName(), "player") == 0)
		{
			IPlayerInfo* targetinfo = CIFaceManager::GetInstance()->GetIplayers()->GetPlayerInfo(target);
			if(targetinfo)
			{
				int ta = targetinfo->GetTeamIndex();
				int tb = playerinfo->GetTeamIndex();
				if( ta != tb )
				{
					if( targetinfo->IsPlayer() && !targetinfo->IsHLTV() && !targetinfo->IsObserver() )
					{
						return Helpers::IndexOfEdict(target);
					}
				} 
			}
		}
	}
	return -1;
}

INetChannelInfo* NczPlayer::GetChannelInfo()
{
	return m_channelinfo;
}

edict_t * NczPlayer::GetEdict()
{
	return m_edict;
}

bool NczPlayer::isValidEdict()
{
	return Helpers::isValidEdict(m_edict);
}

void NczPlayer::OnConnect()
{
	m_time_connected = Plat_FloatTime();
}

void NczPlayer::Kick(const char * msg)
{
	//if (Config::GetInstance()->GetConfigData()->kick_ban)
	{
		CIFaceManager::GetInstance()->GetIengine()->ServerCommand(
				Helpers::format(
				"kickid %d [NoCheatZ 4] %s\n", this->GetUserid(), msg).c_str()
											);
	}
}

void NczPlayer::Ban(const char * msg, int minutes)
{
	//if (Config::GetInstance()->GetConfigData()->kick_ban)
	{
		CIFaceManager::GetInstance()->GetIengine()->ServerCommand(Helpers::format("banid %d %s\n", minutes, GetSteamID()).c_str());
		Kick(msg);
		CIFaceManager::GetInstance()->GetIengine()->ServerCommand("writeid\n");
		if(!Helpers::bStrEq("127.0.0.1", GetIPAddress()))
		{
			CIFaceManager::GetInstance()->GetIengine()->ServerCommand(Helpers::format("addip 1440 \"%s\"\n", GetIPAddress()).c_str());
			CIFaceManager::GetInstance()->GetIengine()->ServerCommand("writeip\n");
		}
	}
}

```

`server-plugin/Code/Players/NczPlayer.h`:

```h
#include <string>
#include <list>

#include "inetchannelinfo.h"
#include "inetchannel.h"
#include "edict.h"

#ifdef GNUC
#undef min
#undef max
#endif

#include "Preprocessors.h"
#include "Misc/Helpers.h"
#include "Misc/IFaceManager.h"

class IPlayerInfo;
class CUserCmd;

#ifndef NCZPCLASS
#define NCZPCLASS

// 64 players + SourceTV + Server itself
#define MAX_PLAYERS 66

/* Permet de connaître l'état d'un slot du serveur rapidement */
enum SlotStatus
{
	INVALID = -1, // Slot not used
	BOT = 0,
	PLAYER_CONNECTED, // Spectator or dead or ...
	PLAYER_IN_TESTS, // Playing the round
};

enum WpnShotType
{
	HAND,
	AUTO,
	PISTOL
};

class NczPlayer
{
public:
	NczPlayer(const int index);
	~NczPlayer(){};

	const int GetIndex(){ return cIndex; }; 
	int GetUserid() const;
	edict_t * GetEdict();
	IPlayerInfo * GetPlayerInfo();
	INetChannelInfo* GetChannelInfo();
	const char * GetName();
	const char * GetSteamID();
	const char * GetIPAddress();
	WpnShotType GetWpnShotType();
	int aimingAt(); // Retourne index de la cible présente sur le viseur

	float GetTimeConnected();

	bool isValidEdict();

	void OnConnect();

	void Kick(const char * msg = "Kicked by NoCheatZ 4");
	void Ban(const char * msg = "Banned by NoCheatZ 4", int minutes = 0);

private:
	const int cIndex;
	int m_userid;
	edict_t * m_edict;
	INetChannelInfo* m_channelinfo;
	float m_time_connected;
};

#endif

```

`server-plugin/Code/Players/NczPlayerManager.cpp`:

```cpp
#include "NczPlayerManager.h"
#include "Misc/IFaceManager.h"
#include "Misc/Helpers.h"

//---------------------------------------------------------------------------------
// NczPlayerManager
//---------------------------------------------------------------------------------

NczPlayerManager::NczPlayerManager()
{
	_PLAYERS_LOOP_INIT
	{
		ph->playerClass = nullptr;
		ph->status = INVALID;
	}
	END_PLAYERS_LOOP
}

NczPlayerManager::~NczPlayerManager()
{
	CIFaceManager::GetInstance()->GetIevents()->RemoveListener(this);
	PLAYERS_LOOP_RUNTIME
	{
		if(ph->playerClass != nullptr)
		{
			delete ph->playerClass;
			ph->status = INVALID;
		}
	}
	END_PLAYERS_LOOP
}

void NczPlayerManager::LoadPlayerManager()
{
	CIFaceManager::GetInstance()->GetIevents()->AddListener(this, "player_death", true);
	CIFaceManager::GetInstance()->GetIevents()->AddListener(this, "round_end", true);
	CIFaceManager::GetInstance()->GetIevents()->AddListener(this, "round_freeze_end", true);

	//Helpers::FastScan_EntList();
	Helpers::m_EdictList = Helpers::PEntityOfEntIndex(0);

	if(Helpers::m_EdictList)
	{
		PLAYERS_LOOP_RUNTIME
		{
			edict_t* pEntity = Helpers::PEntityOfEntIndex(x);
			if(CIFaceManager::GetInstance()->GetIplayers()->GetPlayerInfo(pEntity))
			{
				if(CIFaceManager::GetInstance()->GetIplayers()->GetPlayerInfo(pEntity)->IsFakeClient())
				{
					ph->status = BOT;
					ph->playerClass = new NczPlayer(x);
				}
				else if (CIFaceManager::GetInstance()->GetIplayers()->GetPlayerInfo(pEntity)->IsConnected())
				{
					ph->status = PLAYER_CONNECTED;
					ph->playerClass = new NczPlayer(x);
					ph->playerClass->OnConnect();
				}
			}
		}
		END_PLAYERS_LOOP
	}
}

void NczPlayerManager::ClientConnect(edict_t* pEntity)
{
	short index = Helpers::IndexOfEdict(pEntity);
	if(index > 0)
	{
		if(FullHandlersList[index].status == INVALID)
		{
			FullHandlersList[index].playerClass = new NczPlayer(index);
		}
		FullHandlersList[index].status = PLAYER_CONNECTED;
		FullHandlersList[index].playerClass->OnConnect();
		return;
	}
}

void NczPlayerManager::ClientActive(edict_t* pEntity)
{
	short index = Helpers::IndexOfEdict(pEntity);
	if(index > 0)
	{
		if(FullHandlersList[index].status == INVALID)
		{
			FullHandlersList[index].playerClass = new NczPlayer(index);
			FullHandlersList[index].status = BOT;
		}
		return;
	}
}

void NczPlayerManager::ClientDisconnect(edict_t* pEntity)
{
	short index = Helpers::IndexOfEdict(pEntity);
	if(index > 0)
	{
		if(FullHandlersList[index].status > INVALID)
		{
			if(FullHandlersList[index].playerClass) delete FullHandlersList[index].playerClass;
			FullHandlersList[index].status = INVALID;
			FullHandlersList[index].playerClass = nullptr;
		}
		return;
	}
}

void NczPlayerManager::FireGameEvent(IGameEvent* ev)
{
	Msg("%f - %s\n", Plat_FloatTime(), ev->GetName());

	if(ev->GetInt("userid") > 0)
	{
		PlayerHandler* ph = GetPlayerHandlerByUserId(ev->GetInt("userid"));
		switch(ev->GetName()[7])
		{
			case 'd': // player_death
			{
				if(ph->status <= PLAYER_CONNECTED) return;
				ph->status = PLAYER_CONNECTED;
				return;
			}
		}
	}
	else
	{
		switch(ev->GetName()[6])
		{
			case 'e': // round_end
			{
				PLAYERS_LOOP_RUNTIME
				{
					if(ph->status == PLAYER_IN_TESTS)
						ph->status = PLAYER_CONNECTED;
				}
				END_PLAYERS_LOOP
				ILogger.Flush();
				return;
			}
			case 'f': // round_freeze_end = round_start
			{
				PLAYERS_LOOP_RUNTIME
				{
					if(ph->status == PLAYER_CONNECTED)
					{
						if(ph->playerClass->GetPlayerInfo())
						{
							if(ph->playerClass->GetPlayerInfo()->GetTeamIndex() > 1)
								ph->status = PLAYER_IN_TESTS;
						}
					}
				}
				END_PLAYERS_LOOP
				return;
			}
		}
	}
}

PlayerHandler* NczPlayerManager::GetPlayerHandlerByIndex(int slot, SlotStatus filter)
{
	if(filter == INVALID)
	{
		if(FullHandlersList[slot].status != INVALID)
		{
			return (PlayerHandler*)(&FullHandlersList[slot]);
		}
		else
		{
			return (PlayerHandler*)(&FullHandlersList[0]); // Always INVALID
		}
	}
	else
	{
		if(FullHandlersList[slot].status == filter)
		{
			return (PlayerHandler*)(&FullHandlersList[slot]);
		}
		else
		{
			return (PlayerHandler*)(&FullHandlersList[0]); // Always INVALID
		}
	}
}

PlayerHandler* NczPlayerManager::GetPlayerHandlerByUserId(int userid, SlotStatus filter)
{
	return GetPlayerHandlerByIndex(Helpers::getIndexFromUserID(userid), filter);
}

PlayerHandler* NczPlayerManager::GetPlayerHandlerByBasePlayer(void* BasePlayer, SlotStatus filter)
{
	void* tBasePlayer = nullptr;
	if(filter == INVALID)
	{
		PLAYERS_LOOP_RUNTIME
		{
			tBasePlayer = reinterpret_cast<void*>(ph->playerClass->GetEdict()->GetUnknown()->GetBaseEntity());
			if(tBasePlayer == BasePlayer) return ph;
		}
		END_PLAYERS_LOOP
	}
	else
	{
		PLAYERS_LOOP_RUNTIME
		{
			if(ph->status <= filter) continue;
		
			tBasePlayer = reinterpret_cast<void*>(ph->playerClass->GetEdict()->GetUnknown()->GetBaseEntity());
			if(tBasePlayer == BasePlayer) return ph;
		}
		END_PLAYERS_LOOP
	}
	
	return (&FullHandlersList[0]);
}

PlayerHandler* NczPlayerManager::GetPlayerHandlerBySteamID(const char * steamid, SlotStatus filter)
{
	const char *tSteamid;
	if(filter == INVALID)
	{
		PLAYERS_LOOP_RUNTIME
		{
			tSteamid = ph->playerClass->GetSteamID();
			if(Helpers::bStrEq(tSteamid, steamid)) return ph;
		}
		END_PLAYERS_LOOP
	}
	else
	{
		PLAYERS_LOOP_RUNTIME
		{
			if(ph->status != filter) continue;

			tSteamid = ph->playerClass->GetSteamID();
			if(Helpers::bStrEq(tSteamid, steamid)) return ph;
		}
		END_PLAYERS_LOOP
	}
		
	return (&FullHandlersList[0]);
}

PlayerHandler* NczPlayerManager::GetPlayerHandlerByEdict(edict_t * pEdict, SlotStatus filter)
{
	edict_t * tEdict;
	if(filter == INVALID)
	{
		PLAYERS_LOOP_RUNTIME
		{
			tEdict = ph->playerClass->GetEdict();
			if(tEdict == pEdict) return ph;
		}
		END_PLAYERS_LOOP
	}
	else
	{
		PLAYERS_LOOP_RUNTIME
		{
			if(ph->status != filter) continue;

			tEdict = ph->playerClass->GetEdict();
			if(tEdict == pEdict) return ph;
		}
		END_PLAYERS_LOOP
	}
		
	return (&FullHandlersList[0]);
}

PlayerHandler* NczPlayerManager::GetPlayerHandlerByName(const char * playerName, SlotStatus filter)
{
	const char * tName;
	if(filter == INVALID)
	{
		PLAYERS_LOOP_RUNTIME
		{
			tName = ph->playerClass->GetName();
			if(Helpers::bStrEq(tName, playerName)) return ph;
		}
		END_PLAYERS_LOOP
	}
	else
	{
		PLAYERS_LOOP_RUNTIME
		{
			if(ph->status != filter) continue;

			tName = ph->playerClass->GetName();
			if(Helpers::bStrEq(tName, playerName)) return ph;
		}
		END_PLAYERS_LOOP
	}
	return (&FullHandlersList[0]);
}

short NczPlayerManager::GetPlayerCount(SlotStatus filter)
{
	short count = 0;
	if(filter == INVALID)
	{
		PLAYERS_LOOP_RUNTIME
			if(ph->status != filter) ++count;
		END_PLAYERS_LOOP
	}
	else
	{
		PLAYERS_LOOP_RUNTIME
			if(ph->status == filter) ++count;
		END_PLAYERS_LOOP
	}
	return count;
}

```

`server-plugin/Code/Players/NczPlayerManager.h`:

```h
#include "Misc/EventManagerWrap.h"
#include "Misc/temp_Singleton.h"
#include "Systems/Logger.h"
#include "NczPlayer.h"

#ifndef NCZPLAYERMANAGER
#define NCZPLAYERMANAGER

struct PlayerHandler
{
	NczPlayer* playerClass;
	SlotStatus status;
};

class CCSPlayer;

/* Distribue et met à jour l'état des slots du serveur */
class NczPlayerManager : public EventManagerWrap, public Singleton<NczPlayerManager>
{
public:
	NczPlayerManager();
	virtual ~NczPlayerManager();

	/* Force la mise à jour des slots en scannant la mémoire pour EdictList
	   S'inscrit aux événements pour mettre à jour les slots en temps réel */
	void LoadPlayerManager();

	/* Get player by filter. If filter is INVALID, we don't filter */
	PlayerHandler* GetPlayerHandlerByIndex(int slot, SlotStatus filter = INVALID);
	PlayerHandler* GetPlayerHandlerByUserId(int userid, SlotStatus filter = INVALID);
	PlayerHandler* GetPlayerHandlerByBasePlayer(void* BasePlayer, SlotStatus filter = INVALID);
	PlayerHandler* GetPlayerHandlerBySteamID(const char * steamid, SlotStatus filter = INVALID);
	PlayerHandler* GetPlayerHandlerByEdict(edict_t * pEdict, SlotStatus filter = INVALID);
	PlayerHandler* GetPlayerHandlerByName(const char * playerName, SlotStatus filter = INVALID);
	
	short GetPlayerCount(SlotStatus filter = INVALID);

	void ClientConnect(edict_t* pEntity); // Bots don't call this ...
	void ClientActive(edict_t* pEntity); // ... they call this at first
	void ClientDisconnect(edict_t *pEntity);
	void FireGameEvent(IGameEvent* ev);

private:
	PlayerHandler FullHandlersList[MAX_PLAYERS+1];
	double lastSpawnTime[MAX_PLAYERS];
};

/* Utilisé en interne pour initialiser le tableau, des petites fonctions
  Ajout d'une case supplémentaire à FullHandlersList pour pouvoir quitter proprement la boucle PLAYERS_LOOP_RUNTIME */
#define _PLAYERS_LOOP_INIT { \
		int x = 0; \
		PlayerHandler* ph = &(FullHandlersList[x]); \
		for(; x < MAX_PLAYERS+1; ++x, ph = &(FullHandlersList[x]))

/* Boucle classique pour les utilisations externes
   Donne la variable ph et x dans la boucle */
#define PLAYERS_LOOP_RUNTIME { \
		int x = 1; \
		PlayerHandler* ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByIndex(x); \
		for(; ph->status != INVALID; ++x, ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByIndex(x))

#define END_PLAYERS_LOOP }

#endif

```

`server-plugin/Code/Players/temp_PlayerDataStruct.h`:

```h
#include "Misc/temp_BaseDataStruct.h"
#include "NczPlayer.h"

#ifndef PLAYERDATASTRUCT
#define PLAYERDATASTRUCT

template <typename DataT>
class PlayerDataStructHandler :
	public BaseDataStructHandler<DataT, MAX_PLAYERS>
{
	typedef BaseDataStructHandler<DataT, MAX_PLAYERS> BaseClass;
public:
	PlayerDataStructHandler() : BaseClass()
	{
	};
	~PlayerDataStructHandler(){};

	DataT* GetPlayerDataStruct(NczPlayer * player)
	{
		return (DataT*)(&(this->m_dataStruct[player->GetIndex()]));
	};

	void ResetPlayerDataStruct(NczPlayer * player)
	{
		this->m_dataStruct[player->GetIndex()] = DataT();
	};
};

#endif

```

`server-plugin/Code/Preprocessors.h`:

```h
/*
	This file makes it easier to cross-compile between all the games and all the os they use.
	Because I use Makefile with Linux and VisualStudio Compiler with Windows, I think it is easier to have only one place to make sure everything works everywhere for anything ...
	It may be included everywhere.
*/

#ifndef NCZ_PREPROCESSORS
#define NCZ_PREPROCESSORS

#ifdef GNUC
#include <cstdlib>
#endif

//#define PIPELINE_ADDRESS "pipeline.nocheatz.com" // No more pipelining nor master server, the plugin is now independant.

/*
	Scripts that launch the compiler defines what game the plugin must be compiled for. (NCZ_CSS or NCZ_CSP or ...)
	This is where we make sure the plugin will be compatible.

	NCZ_VERSION_STR		Full string version
	GAMEDIR				Root directory name of the server
	ENGINE_DLIB_LINUX	Dynamic library name of the server if used with linux
	ENGINE_DLIB			Library name resulting of the OS we compile for
*/
#ifdef NCZ_CSS // Counter Strike : Source
#define NCZ_VERSION_STR	" 4.0 Alpha CSS"
#define GAMEDIR "cstrike"
#define ENGINE_DLIB_LINUX "engine_srv.so"
#endif
#ifdef NCZ_CSP
#define NCZ_VERSION_STR	" 4.0 Alpha CSPROMOD"
#define GAMEDIR "cspromod"
#define ENGINE_DLIB_LINUX "engine_i486.so"
#endif
#ifdef NCZ_CSGO
#define NCZ_VERSION_STR	" 4.0 Alpha CSGO"
#define GAMEDIR "csgo"
#define ENGINE_DLIB_LINUX "engine_srv.so"
#define ENGINE_HOLES
#ifdef WIN32
	#pragma comment(lib, "libprotobuf.lib")
#endif
#endif

#ifdef WIN32
#define ENGINE_DLIB "engine.dll"
#else
#define ENGINE_DLIB ENGINE_DLIB_LINUX
#endif

#define NCZ_PLUGIN_NAME			"NoCheatZ" // Name of the plugin

/*
	Defines if we dynamically load the latest interfaces of the engine or if they are loaded statically.
	Comment this to go static.

	Dynamic = More chance to be loaded if the engine code changes, but more risk of heavy crashes if our code isn't compatible.
	Static = Won't load if any change is made to the source engine, even if this should work.
*/
#define IFACEMANAGER_AUTOINIT

#define IN_ATTACK (1 << 0)
#define IN_JUMP   (1 << 1)

/*
	Use for backward compatibility.
	EP1 (Older version of Source Engine) = Counter-Strike : Promod
*/
#ifdef NCZ_EP1
#define GET_ARGV(a) engine->Cmd_Argv(a)
#define GET_ARGS engine->Cmd_Args()
#define GET_ARGC engine->Cmd_Argc()
#define FINDCOMMAND(a) g_pCVar->GetCommands()->FindCommand(a)
#define IsFlagSet IsBitSet
#else
#define GET_ARGV(a) args.Arg(a)
#define GET_ARGC args.ArgC()
#define GET_ARGS args.GetCommandString()
#define FINDCOMMAND(a) g_pCVar->FindCommand(a)
#endif

/*
	gcc is f*cking strict ...
*/
#ifdef GNUC
#include <cstring>
#define strcpy_s(a, b, c) strncpy(a, c, b)
#define nullptr 0
#ifndef DWORD
#	define DWORD unsigned long long
#endif
#endif

#define StrLen(x) strlen(x)
#define FStrEq(x,y) (Q_stricmp(x,y) == 0)

#include "platform.h"


#endif

```

`server-plugin/Code/Systems/BanRequest.cpp`:

```cpp
#include "Systems/BanRequest.h"

void BanRequest::SetWaitTime(double wait_time)
{
	m_wait_time = wait_time;
}

void BanRequest::AddAsyncBan(NczPlayer* player, int ban_time, const char * kick_message)
{
//	if (Config::GetInstance()->GetConfigData()->kick_ban)
	{
		PlayerBanRequestT* req = new PlayerBanRequestT;
		req->ban_time = ban_time;
		req->userid = player->GetUserid();
		req->request_time = Plat_FloatTime();
		req->kick_message = kick_message;
		strcpy_s(req->player_name, 24, player->GetName());
		strcpy_s(req->steamid, 24, player->GetSteamID());
		strcpy_s(req->ip, 24, player->GetIPAddress());
		m_requests.push_back(req);
	}
}

void BanRequest::Think()
{
	bool end = false;
	while(!end)
	{
		end = true;
		for(std::list<PlayerBanRequestT*>::iterator it = m_requests.begin(); it != m_requests.end(); ++it)
		{
			if((*it)->request_time + m_wait_time < Plat_FloatTime())
			{
				CIFaceManager::GetInstance()->GetIengine()->ServerCommand(Helpers::format("banid %d %s\n", (*it)->ban_time, (*it)->steamid).c_str());
				CIFaceManager::GetInstance()->GetIengine()->ServerCommand(Helpers::format("kickid %d [NoCheatZ 4] %s\n", (*it)->userid, (*it)->kick_message).c_str());
				if(!Helpers::bStrEq("127.0.0.1", (*it)->ip))
				{
					CIFaceManager::GetInstance()->GetIengine()->ServerCommand(Helpers::format("addip 1440 \"%s\"\n", (*it)->ip).c_str());
					do_writeid = true;
				}
				CIFaceManager::GetInstance()->GetIengine()->ServerExecute();

				ClearRequests((*it)->steamid);
				end = false;
			}
		}
	}
}

void BanRequest::ClearRequests(const char * SteamID)
{
	for(std::list<PlayerBanRequestT*>::iterator it = m_requests.begin(); it != m_requests.end(); ++it)
	{
		if(Helpers::bStrEq((*it)->steamid, SteamID, 8))
		{
			m_requests.remove(*it);
		}
	}
}

```

`server-plugin/Code/Systems/BanRequest.h`:

```h
#include <list>

#include "Preprocessors.h"
#include "Players/NczPlayer.h"
#include "Misc/temp_Singleton.h"

#ifndef BANREQUEST_H
#define BANREQUEST_H

typedef struct PlayerBanRequest
{
	int ban_time;
	int userid;
	double request_time;
	const char * kick_message;
	char player_name[24];
	char steamid[24];
	char ip[24];

	// FIXME : Ctors
} PlayerBanRequestT;

class BanRequest : public Singleton<BanRequest>
{
public:
	BanRequest() : m_wait_time(10.0), do_writeid(false) {};
	~BanRequest(){for(std::list<PlayerBanRequestT*>::iterator it = m_requests.begin(); it != m_requests.end(); ++it) delete *it;};

	bool NeedWriteID()
	{
		if(do_writeid)
		{
			do_writeid = false;
			return true;
		}
		return false;
	}

	void SetWaitTime(double wait_time);

	void AddAsyncBan(NczPlayer* player, int ban_time, const char * kick_message);

	void Think();

	void ClearRequests(const char * SteamID);

private:
	bool do_writeid;
	double m_wait_time;

	std::list<PlayerBanRequestT*> m_requests; // FIXME : Do not use pointers here
};

#endif

```

`server-plugin/Code/Systems/BaseSystem.cpp`:

```cpp
#include "BaseSystem.h"
#include "plugin.h"

/////////////////////////////////////////////////////////////////////////
// BaseSystem
/////////////////////////////////////////////////////////////////////////

std::list<BaseSystem*> BaseSystem::m_systemsList;

BaseSystem::BaseSystem() : m_isActive(false), m_verbose(false), m_isDisabled(false), m_configState(true)
{
	BaseSystem::m_systemsList.push_back(this);
}

BaseSystem::~BaseSystem()
{
	BaseSystem::m_systemsList.remove(this);
}

void BaseSystem::UnloadAllSystems()
{
	for(std::list<BaseSystem*>::iterator it = m_systemsList.begin(); it != m_systemsList.end(); ++it)
	{
		(*it)->SetActive(false);
	}
}

void BaseSystem::SetVerbose(bool verbose)
{
	m_verbose = verbose;
}

void BaseSystem::SetActive(bool active)
{
	if(m_isActive == active) return;
	else if(active)
	{
		if(!m_isDisabled)
		{
			if(m_configState)
			{
				if(NczPlayerManager::GetInstance()->GetPlayerCount(PLAYER_CONNECTED) + NczPlayerManager::GetInstance()->GetPlayerCount(PLAYER_IN_TESTS) > 0)
				{
					if(HasVerbose()) Msg("%f : Starting %s\n", Plat_FloatTime(), GetName());
					m_isActive = true;
					Load();
				}
				else
				{
					if(HasVerbose()) Msg("%f : Wont start system %s : No player present\n", Plat_FloatTime(), GetName());
				}
			}
			else
			{
				if(HasVerbose()) Msg("%f : Wont start system %s : Disabled by server configuration file\n", Plat_FloatTime(), GetName());
			}
		}
	}
	else
	{
		if(HasVerbose()) Msg("%f : Stoping %s\n", Plat_FloatTime(), GetName());
		m_isActive = false;
		Unload();
	}
}

void BaseSystem::ncz_cmd_fn ( const CCommand &args )
{
	if(args.ArgC() > 1)
	{
		for(std::list<BaseSystem*>::iterator it = m_systemsList.begin(); it != m_systemsList.end(); ++it)
		{
			if(Helpers::bStriEq((*it)->GetName(), args.Arg(1)))
			{
				if(Helpers::bStriEq("enable", args.Arg(2)))
				{
					(*it)->SetConfig(true);
					(*it)->SetActive(true);
				}
				else if(Helpers::bStriEq("disable", args.Arg(2)))
				{
					(*it)->SetConfig(false);
					(*it)->SetActive(false);
				}
				else if(Helpers::bStriEq("verbose", args.Arg(2)))
				{
					if(args.ArgC() > 2)
					{
						if(Helpers::bStriEq("on", args.Arg(3)))
						{
							(*it)->SetVerbose(true);
							return;
						}
						else if(Helpers::bStriEq("off", args.Arg(3)))
						{
							(*it)->SetVerbose(false);
							return;
						}
						Msg("arg %s not found. Try :\non\noff\n\n");
					}
					if((*it)->HasVerbose()) Msg("verbose is on\n");
					else  Msg("verbose is off\n");
					return;
				}
				else if(!(*it)->sys_cmd_fn(args))
				{
					Msg("action %s not found.\nTry : %s\n", args.Arg(2), (*it));
				}

				return;
			}		
		}
		Msg("System %s not found.\n", args.Arg(1));
	}
	else
	{
		Msg("Usage: ncz system arg1 arg2 ...\n");
		Msg("Systems list :\n");
		for(std::list<BaseSystem*>::iterator it = m_systemsList.begin(); it != m_systemsList.end(); ++it)
		{
			Msg("%s", (*it)->GetName());
			if((*it)->IsActive())
			{
				Msg(" (Running)\n");
			}
			else if(!(*it)->IsEnabledByConfig())
			{
				Msg(" (Disabled by config)\n");
			}
			else
			{
				Msg(" (Sleeping - Waiting for players)\n");
			}
		}
		Msg("\n");
	}
}
 
ConCommand ncz_cmd( "ncz", BaseSystem::ncz_cmd_fn , "NoCheatZ", 0);

```

`server-plugin/Code/Systems/BaseSystem.h`:

```h
#include <list>

#include "platform.h"
#include "dbg.h"
#include "convar.h"

#ifdef GNUC
#undef min
#undef max
#endif

#include "Preprocessors.h"
#include "Misc/Helpers.h"
#include "Players/NczPlayerManager.h"

#ifndef BASESYSTEM
#define BASESYSTEM

/////////////////////////////////////////////////////////////////////////
// BaseSystem
/////////////////////////////////////////////////////////////////////////

class BaseSystem
{
public:
	BaseSystem();
	virtual ~BaseSystem();

	/* Permet de détruire tous les systèmes créés jusqu'à présent */
	static void UnloadAllSystems();

	/* Commande console de base "ncz" */
	static	void ncz_cmd_fn ( const CCommand &args );
	/* Commande(s) console du système,
		donne vrai si la commande existe
		Le premier argument est en fait le troisième */
	virtual bool sys_cmd_fn ( const CCommand &args ){return false;};
	virtual const char * cmd_list () {return "enable\ndisable\nor verbose\n";};

	/* Donne le nom du système pour pouvoir être identifié dans la console */
	const char * GetName() const {return m_name;};

	/* Process Load when m_isActive changes to true
	      "    Unload when m_isActive changes to false */
	void SetActive(bool active);

	/* Must be used before all processing operations */
	bool IsActive() const {return m_isActive;};

	/* Retourne vrai si le fichier de configuration dit d'activer ce système */
	bool IsEnabledByConfig() const {return m_configState;};

	void SetConfig(bool enabled){m_configState = enabled;};
	
	/* Used for debugging */
	void SetVerbose(bool verbose);
	bool HasVerbose() const {return m_verbose;};

protected:
	const char* m_name;

private: // called by SetActive()
	virtual void Load() = 0; // Defined by child, attach to callbacks
	virtual void Unload() = 0; // Defined by child, unregister from callbacks

	bool m_isActive;
	bool m_isDisabled;
	bool m_configState;
	bool m_verbose;
	static std::list<BaseSystem*> m_systemsList;
};

#endif

```

`server-plugin/Code/Systems/Logger.cpp`:

```cpp
#include "Logger.h"
#include "Misc/Helpers.h"

Logger ILogger;

void Logger::Push(const std::string& msg)
{
	m_msg.insert(m_msg.end(), msg);
}

void Logger::Flush()
{
	if(m_msg.empty()) return;
	if(CIFaceManager::GetInstance()->GetIengine())
	{
		std::string path = Helpers::getStrGameDir() + "/logs/NoCheatZ_4_Logs/" + Helpers::getStrDateTime("NoCheatZ-%d-%b-%Y") + ".log";
		std::ofstream fichier(path.c_str(), std::ios::out | std::ios::app);
		if(fichier)
		{
			std::list<std::string>::iterator it = m_msg.begin();
			do
			{
				fichier << *it;
			}
			while(it != m_msg.end());
			m_msg.clear();
		}
		else
		{
			Msg("[NoCheatZ 4] Can't write to logfile at %s ... Please check write access and if the directory exists.\n", path.c_str());
			CIFaceManager::GetInstance()->GetIengine()->LogPrint(Helpers::format("[NoCheatZ 4] Can't write to logfile at %s ... Please check write access and if the directory exists.\n", path.c_str()).c_str());
		}
	}
}

void Helpers::writeToLogfile(const std::string &text)
{
	ILogger.Push(text);
}

```

`server-plugin/Code/Systems/Logger.h`:

```h
#include <list>
#include <string>
#include <fstream>

#include "Preprocessors.h"
#include "Misc/Helpers.h"

#ifndef LOGGER_H
#define LOGGER_H


/*
	Messages to be written on the plugin's logfile.

	To prevent the game to hang on write, the flush is done only when we are outside a round.

	This class should be threadsafe.
*/

class Logger
{
public:
	Logger() {};
	~Logger(){};

	void Push(const std::string& msg);
	void Flush();

private:
	std::list<std::string> m_msg;
};

extern Logger ILogger;

#endif

```

`server-plugin/Code/Systems/Testers/BaseFramedTester.cpp`:

```cpp
#include "BaseFramedTester.h"

/////////////////////////////////////////////////////////////////////////
// BaseFramedTester
/////////////////////////////////////////////////////////////////////////

std::list<BaseFramedTester*> BaseFramedTester::m_framedTestersList;

BaseFramedTester::BaseFramedTester()
{
}

void BaseFramedTester::ProcessTests()
{
	PLAYERS_LOOP_RUNTIME
	{
		if(ph->status == GetFilter())
		{
			ProcessPlayerTest(ph->playerClass);
		}
	}
	END_PLAYERS_LOOP
}

void BaseFramedTester::RegisterFramedTester(BaseFramedTester* tester)
{
	m_framedTestersList.push_back(tester);
}

void BaseFramedTester::RemoveFramedTester(BaseFramedTester* tester)
{
	m_framedTestersList.remove(tester);
}

void BaseFramedTester::OnFrame()
{
	for (std::list<BaseFramedTester*>::iterator it = m_framedTestersList.begin(); it != m_framedTestersList.end(); ++it)
	{
		(*it)->ProcessTests();
	}
}

```

`server-plugin/Code/Systems/Testers/BaseFramedTester.h`:

```h
#include <list>
#include "Players/NczPlayerManager.h"

#ifndef BASEFRAMEDTESTER
#define BASEFRAMEDTESTER

/////////////////////////////////////////////////////////////////////////
// BaseFramedTester
/////////////////////////////////////////////////////////////////////////

class BaseFramedTester
{
public:
	BaseFramedTester();
	virtual ~BaseFramedTester(){};

	/* Appelé par le plugin à chaque frame
	   Permet d'appeler les classes filles qui sont à l'écoute */
	static void OnFrame();

	/* Filtre du testeur, peut/doit être redéfinit dans la classe fille */
	virtual SlotStatus GetFilter(){return PLAYER_CONNECTED;};

protected:
	/* Appelé par OnFrame, sert à iétrer entre les différents joueurs en fonction du filtre */
	virtual void ProcessTests();

	/* Appelé par ProcessTests() lorsque le joueur correspond au filtre */
	virtual void ProcessPlayerTest(NczPlayer* player) = 0;

	/* Permet de se mettre à l'écoute de l'événement, appelé par Load/Unload des testeurs */
	static void RegisterFramedTester(BaseFramedTester* tester);
	static void RemoveFramedTester(BaseFramedTester* tester);

private:
	static std::list<BaseFramedTester*> m_framedTestersList;
};

#endif

```

`server-plugin/Code/Systems/Testers/BaseTimedTester.cpp`:

```cpp
#include "BaseTimedTester.h"

/////////////////////////////////////////////////////////////////////////
// BaseTimedTester
/////////////////////////////////////////////////////////////////////////

BaseTimedTester::BaseTimedTester() : BaseFramedTester(), m_lastTestDone(0.0), m_jobMinPeriod(1.0)
{
	m_timeBase = SERVER;
}

BaseTimedTester::BaseTimedTester(double time, TimeBase timeBase) : BaseFramedTester(), m_lastTestDone(0.0), m_jobMinPeriod(time)
{
	m_timeBase = timeBase;
}

double BaseTimedTester::GetTesterTime() const
{
	/*if(this->m_timeBase == GAME)
	{
		return (double)(CIFaceManager::GetInstance()->GetIengine()->Time());
	}
	else
	{
		return Plat_FloatTime();
	}*/
	return Plat_FloatTime();
}

void BaseTimedTester::ProcessTests()
{
	if((Plat_FloatTime() - m_lastTestDone) < m_jobMinPeriod) return;
	m_lastTestDone = Plat_FloatTime();

	PlayerHandler* h = nullptr;
	for(int x = 1; x <= MAX_PLAYERS; ++x)
	{
		h = NczPlayerManager::GetInstance()->GetPlayerHandlerByIndex(x);
		if(h->status == GetFilter())
		{
			ProcessPlayerTest(h->playerClass);
		}
	}
}

```

`server-plugin/Code/Systems/Testers/BaseTimedTester.h`:

```h
#include "BaseFramedTester.h"
#include "Misc/IFaceManager.h"

#ifndef BASETIMEDTESTER
#define BASETIMEDTESTER


enum TimeBase
{
	GAME = 0,
	SERVER
};

class BaseTimedTester : public BaseFramedTester
{
public:
	BaseTimedTester();
	BaseTimedTester(double time, TimeBase timeBase = SERVER);
	~BaseTimedTester(){};

	double GetTesterTime() const;

	/* Combien de secondes attendre avant de lancer un nouveau cycle */
	void SetJobPeriod(double time){m_jobMinPeriod = time;};

	/* Nouvelle version prenant en compte le temps entre les cycles */
	virtual void ProcessTests();

	virtual void ProcessPlayerTest(NczPlayer* player) = 0;

protected:
	double m_lastTestDone;
	double m_jobMinPeriod;
	TimeBase m_timeBase;
};

#endif

```

`server-plugin/Code/Systems/Testers/ConVarTester.cpp`:

```cpp
#include "ConVarTester.h"
#include "plugin.h"

/////////////////////////////////////////////////////////////////////////
// ConVarTester
/////////////////////////////////////////////////////////////////////////

ConVarTester::ConVarTester() : 
	BaseSystem(),
	AsyncNczFilteredPlayersList(),
	BaseFramedTester(),
	PlayerDataStructHandler<CurrentConVarRequestT>(),
	Singleton<ConVarTester>()
{
	m_name = "ConVarTester";
}

ConVarTester::~ConVarTester()
{
	Unload();
}

SlotStatus ConVarTester::GetFilter()
{
	return PLAYER_CONNECTED;
}

void ConVarTester::ProcessTests()
{
	if(!IsActive()) return;
	if(g_pCVar->FindVar("sv_cheats")->GetBool())
	{
		if(HasVerbose()) Msg("%f : sv_cheats set to 1. Skipping ConVarTest ...\n", Plat_FloatTime());
		return;
	}
	NczPlayer* player = GetNextPlayer();
	if(player)
	{
		ProcessPlayerTest(player);
	}
}

void ConVarTester::ProcessPlayerTest(NczPlayer* player)
{
	CurrentConVarRequestT* req = GetPlayerDataStruct(player);
	if(req->isSent && !req->isReplyed)
	{
		if(Plat_FloatTime() - 30.0 > req->timeStart)
		{
			player->Kick("ConVar request timed out");
		}
	}
	else if(!req->isSent && req->isReplyed)
	{
		ConVarInfoT* nextConvar = GetNextConvar(req->ruleset->name);
		CIFaceManager::GetInstance()->GetIpluginhelpers()->StartQueryCvarValue(player->GetEdict(), nextConvar->name);
		req->isSent = true;
		req->isReplyed = false;
		req->ruleset = nextConvar;
		req->timeStart = Plat_FloatTime();
		if(HasVerbose()) Msg("%f : Sending %s ConVar request to ent-id %d\n", Plat_FloatTime(), nextConvar->name, player->GetIndex());
	}
	else
	{
		CIFaceManager::GetInstance()->GetIpluginhelpers()->StartQueryCvarValue(player->GetEdict(), "developer");
		req->isSent = true;
		req->isReplyed = false;
		req->ruleset = FindConvarRuleset("developer");
		req->timeStart = Plat_FloatTime();
		if(HasVerbose()) Msg("%f : Sending %s ConVar request to ent-id %d\n", Plat_FloatTime(), "developer", player->GetIndex());
	}
}

ConVarInfoT* ConVarTester::FindConvarRuleset(const char * name)
{
	for(std::list<ConVarInfoT>::iterator it = m_convars_rules.begin(); it != m_convars_rules.end(); ++it)
	{
		if(Helpers::bStriEq((*it).name, name))
		{
			return &*it;
		}
	}
	return nullptr;
}

ConVarInfoT* ConVarTester::GetNextConvar(const char * current_convar_name)
{
	for(std::list<ConVarInfoT>::iterator it = m_convars_rules.begin(); it != m_convars_rules.end(); ++it)
	{
		if(Helpers::bStriEq((*it).name, current_convar_name))
		{
			++it;
			if(it != m_convars_rules.end()) return &(*it);
			else return &(*(m_convars_rules.begin()));
		}
	}
	return &(*(m_convars_rules.begin()));
}

bool ConVarTester::sys_cmd_fn ( const CCommand &args )
{
	if(Helpers::bStriEq("AddRule", args.Arg(2))) 
		// example : ncz ConVarTester AddRule sv_cheats 0 NO_VALUE
	{
		if(args.ArgC() >= 5)
		{
			ConVarRuleT rule;
			if(args.ArgC() == 6)
			{
				if(Helpers::bStriEq("NO_VALUE", args.Arg(5))) rule = NO_VALUE;
				else if(Helpers::bStriEq("SAME", args.Arg(5))) rule = SAME;
				else if(Helpers::bStriEq("SAME_FLOAT", args.Arg(5))) rule = SAME_FLOAT;
				else if(Helpers::bStriEq("SAME_AS_SERVER", args.Arg(5))) rule = SAME_AS_SERVER;
				else if(Helpers::bStriEq("SAME_FLOAT_AS_SERVER", args.Arg(5))) rule = SAME_FLOAT_AS_SERVER;
				else
				{
					Msg("Arg %s not found.\n", args.Arg(5));
					
				}
				return true;
			}
			else
			{
				if(Helpers::bStriEq("sv_", args.Arg(3), 0U, 3)) rule = SAME_AS_SERVER;
				else rule = SAME;

				std::string value = args.Arg(4);
				if(value.find('.') != std::string::npos)
				{
					if(rule == SAME_AS_SERVER) rule = SAME_FLOAT_AS_SERVER;
					else rule = SAME_FLOAT;
				}
				else
				{
					if(rule != SAME_AS_SERVER) rule = SAME_FLOAT_AS_SERVER;
					else rule = SAME_FLOAT;
				}
				return true;
			}
			AddConvarRuleset(args.Arg(3), args.Arg(4), rule, false);
			
		}
	}
	if(Helpers::bStriEq("ResetRules", args.Arg(2)))
		// example : ncz ConVarTester ResetRules
	{
		Unload();
		Load();
		return true;
	}
	return false;
}

void ConVarTester::AddConvarRuleset(const char * name, const char * value, ConVarRuleT rule, bool safe)
{
	const char * sv_value = value;
	if(rule == SAME_AS_SERVER)
	{
		ConVar * sv_cvar = g_pCVar->FindVar(name);
		if(sv_cvar)
		{
			sv_value = sv_cvar->GetString();
		}
	}
	m_convars_rules.push_back(ConVarInfo(name, value, rule, safe));
}

void ConVarTester::OnQueryCvarValueFinished(NczPlayer* player, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue)
{
	if(!IsActive()) return;
	if(HasVerbose()) Msg("%f : Received %s ConVar reply for ent-id %d\n", Plat_FloatTime(), pCvarName, player->GetIndex());

	if(g_pCVar->FindVar("sv_cheats")->GetBool())
	{
		if(HasVerbose()) Msg("%f : sv_cheats set to 1. Skipping ...\n", Plat_FloatTime());
		return;
	}

	ConVarInfoT* ruleset = FindConvarRuleset(pCvarName);
	if(!ruleset)
	{
unexpected:
		if(HasVerbose()) Msg("%f : Unexpected reply. Skipping ...\n", Plat_FloatTime());
		return;
	}
	CurrentConVarRequest* req = GetPlayerDataStruct(player);

	if(!req->isSent) goto unexpected;
	if(!Helpers::bStriEq(req->ruleset->name, ruleset->name)) goto unexpected;

	req->isReplyed = true;

	switch(eStatus)
	{
	case eQueryCvarValueStatus_ValueIntact:
		{
			if(HasVerbose()) Msg("%f : eQueryCvarValueStatus_ValueIntact\n", Plat_FloatTime());
			if(ruleset->rule == NO_VALUE)
			{
				if(HasVerbose()) Msg("%f : Was expecting eQueryCvarValueStatus_CvarNotFound\n", Plat_FloatTime());
				player->Kick();
			}
			else if(ruleset->rule == SAME)
			{
				if(Helpers::bStrEq(ruleset->value, pCvarValue))
				{
					if(HasVerbose()) Msg("%f : Value %s is correct\n", Plat_FloatTime(), pCvarValue);
				}
				else
				{
					if(HasVerbose()) Msg("%f : Value %s is NOT correct\n", Plat_FloatTime(), pCvarValue);
					Detection_ConVar pDetection = Detection_ConVar();
					pDetection.PrepareDetectionData(req);
					pDetection.PrepareDetectionLog(player, this);
					pDetection.Log();
					BanRequest::GetInstance()->AddAsyncBan(player, 0, "Banned by NoCheatZ 4");
				}
			}
			else if(ruleset->rule == SAME_AS_SERVER)
			{
				if(Helpers::bStrEq(g_pCVar->FindVar(ruleset->name)->GetString(), pCvarValue))
				{
					if(HasVerbose()) Msg("%f : Value %s is correct\n", Plat_FloatTime(), pCvarValue);
				}
				else
				{
					if(HasVerbose()) Msg("%f : Value %s is NOT correct\n", Plat_FloatTime(), pCvarValue);
					Detection_ConVar pDetection = Detection_ConVar();
					pDetection.PrepareDetectionData(req);
					pDetection.PrepareDetectionLog(player, this);
					pDetection.Log();
					BanRequest::GetInstance()->AddAsyncBan(player, 0, "Banned by NoCheatZ 4");
				}
			}
			else if(ruleset->rule == SAME_FLOAT)
			{
				double fcval = atoi(pCvarValue);
				double fsval = atoi(ruleset->value);
				if(fcval == fsval)
				{
					if(HasVerbose()) Msg("%f : Value %s is correct\n", Plat_FloatTime(), pCvarValue);
				}
				else
				{
					if(HasVerbose()) Msg("%f : Value %s is NOT correct\n", Plat_FloatTime(), pCvarValue);
					Detection_ConVar pDetection = Detection_ConVar();
					pDetection.PrepareDetectionData(req);
					pDetection.PrepareDetectionLog(player, this);
					pDetection.Log();
					BanRequest::GetInstance()->AddAsyncBan(player, 0, "Banned by NoCheatZ 4");
				}
			}
			else if(ruleset->rule == SAME_FLOAT_AS_SERVER)
			{
				double fcval = atoi(pCvarValue);
				double fsval = atoi(g_pCVar->FindVar(ruleset->name)->GetString());
				if(fcval == fsval)
				{
					if(HasVerbose()) Msg("%f : Value %s is correct\n", Plat_FloatTime(), pCvarValue);
				}
				else
				{
					if(HasVerbose()) Msg("%f : Value %s is NOT correct\n", Plat_FloatTime(), pCvarValue);
					Detection_ConVar pDetection = Detection_ConVar();
					pDetection.PrepareDetectionData(req);
					pDetection.PrepareDetectionLog(player, this);
					pDetection.Log();
					BanRequest::GetInstance()->AddAsyncBan(player, 0, "Banned by NoCheatZ 4");
				}
			}
			break;
		}

	case eQueryCvarValueStatus_CvarNotFound:
		{
			if(HasVerbose()) Msg("%f : eQueryCvarValueStatus_CvarNotFound\n", Plat_FloatTime());
			if(ruleset->rule != NO_VALUE)
			{
				if(HasVerbose()) Msg("%f : Was expecting eQueryCvarValueStatus_ValueIntact\n", Plat_FloatTime());
				Detection_ConVar pDetection = Detection_ConVar();
				pDetection.PrepareDetectionData(req);
				pDetection.PrepareDetectionLog(player, this);
				pDetection.Log();
				BanRequest::GetInstance()->AddAsyncBan(player, 0, "Banned by NoCheatZ 4");
			}
			break;
		}

	case eQueryCvarValueStatus_NotACvar:
		{
			if(HasVerbose()) Msg("%f : eQueryCvarValueStatus_NotACvar\n", Plat_FloatTime());
			goto unexpected2;
		}

	case eQueryCvarValueStatus_CvarProtected:
		{
			if(HasVerbose()) Msg("%f : eQueryCvarValueStatus_CvarProtected\n", Plat_FloatTime());
			goto unexpected2;
		}

	default:
		{
			if(HasVerbose()) Msg("%f : eQueryCvarValueStatus_UnknownStatus\n", Plat_FloatTime());
			goto unexpected2;
		}
	}
	
	req->isSent = false;
	return;
unexpected2:
	if(HasVerbose()) Msg("%f : Was expecting eQueryCvarValueStatus_ValueIntact\n", Plat_FloatTime());
	Detection_ConVar pDetection = Detection_ConVar();
	pDetection.PrepareDetectionData(req);
	pDetection.PrepareDetectionLog(player, this);
	pDetection.Log();
	BanRequest::GetInstance()->AddAsyncBan(player, 0, "Banned by NoCheatZ 4");
}

void ConVarTester::Load()
{
	AddConvarRuleset("developer", "0", SAME);
	AddConvarRuleset("sv_cheats", "0", SAME_AS_SERVER);
	AddConvarRuleset("sv_accelerate", "0", SAME_AS_SERVER);
	AddConvarRuleset("sv_showimpacts", "0", SAME_AS_SERVER);
	AddConvarRuleset("sv_showlagcompensation", "0", SAME_AS_SERVER);
	AddConvarRuleset("host_framerate", "0", SAME_FLOAT_AS_SERVER);
	AddConvarRuleset("host_timescale", "0", SAME_FLOAT_AS_SERVER);
	AddConvarRuleset("r_visualizetraces", "0", SAME_AS_SERVER);
	AddConvarRuleset("mat_normalmaps", "0", SAME_AS_SERVER);
	AddConvarRuleset("mp_playerid", "0", SAME_AS_SERVER);
	AddConvarRuleset("net_fakeloss", "0", SAME);
	AddConvarRuleset("net_fakelag", "0", SAME);
	AddConvarRuleset("net_fakejitter", "0", SAME);
	AddConvarRuleset("r_drawothermodels", "1", SAME);
	AddConvarRuleset("r_shadowwireframe", "0", SAME);
	AddConvarRuleset("r_avglight", "1", SAME);
	AddConvarRuleset("r_novis", "0", SAME);
	AddConvarRuleset("r_drawparticles", "1", SAME);
	AddConvarRuleset("r_drawopaqueworld", "1", SAME);
	AddConvarRuleset("r_drawtranslucentworld", "1", SAME);
	AddConvarRuleset("r_drawmodelstatsoverlay", "0", SAME);
	AddConvarRuleset("r_skybox", "1", SAME);
	AddConvarRuleset("r_aspectratio", "0", SAME);
	AddConvarRuleset("r_drawskybox", "1", SAME);
	AddConvarRuleset("r_showenvcubemap", "0", SAME);
	AddConvarRuleset("r_drawlights", "0", SAME);
	AddConvarRuleset("r_drawrenderboxes", "0", SAME);
	AddConvarRuleset("mat_wireframe", "0", SAME);
	AddConvarRuleset("mat_drawwater", "1", SAME);
	AddConvarRuleset("mat_loadtextures", "1", SAME);
	AddConvarRuleset("mat_showlowresimage", "0", SAME);
	AddConvarRuleset("mat_fillrate", "0", SAME);
	AddConvarRuleset("mat_proxy", "0", SAME);
	AddConvarRuleset("mem_force_flush", "0", SAME);
	AddConvarRuleset("fog_enable", "1", SAME);
	AddConvarRuleset("cl_pitchup", "89", SAME);
	AddConvarRuleset("cl_pitchdown", "89", SAME);
	AddConvarRuleset("cl_bobcycle", "0.8", SAME_FLOAT);
	AddConvarRuleset("cl_leveloverviewmarker", "0", SAME);
	AddConvarRuleset("snd_visualize", "0", SAME);
	AddConvarRuleset("snd_show", "0", SAME);
	AddConvarRuleset("openscript", "", NO_VALUE);
	AddConvarRuleset("openscript_version", "", NO_VALUE);
	AddConvarRuleset("ms_sv_cheats", "", NO_VALUE);
	AddConvarRuleset("ms_r_drawothermodels", "", NO_VALUE);
	AddConvarRuleset("ms_chat", "", NO_VALUE);
	AddConvarRuleset("ms_aimbot", "", NO_VALUE);
	AddConvarRuleset("wallhack", "", NO_VALUE);
	AddConvarRuleset("cheat_chat", "", NO_VALUE);
	AddConvarRuleset("cheat_chams", "", NO_VALUE);
	AddConvarRuleset("cheat_dlight", "", NO_VALUE);
	AddConvarRuleset("SmAdminTakeover", "", NO_VALUE);
	AddConvarRuleset("ManiAdminTakeover", "", NO_VALUE);
	AddConvarRuleset("ManiAdminHacker", "", NO_VALUE);
	AddConvarRuleset("byp_svc", "", NO_VALUE);
	AddConvarRuleset("byp_speed_hts", "", NO_VALUE);
	AddConvarRuleset("byp_speed_hfr", "", NO_VALUE);
	AddConvarRuleset("byp_render_rdom", "", NO_VALUE);
	AddConvarRuleset("byp_render_mwf", "", NO_VALUE);
	AddConvarRuleset("byp_render_rdp", "", NO_VALUE);
	AddConvarRuleset("byp_fake_lag", "", NO_VALUE);
	AddConvarRuleset("byp_fake_loss", "", NO_VALUE);

	BaseFramedTester::RegisterFramedTester(this);
}

void ConVarTester::Unload()
{
	BaseFramedTester::RemoveFramedTester(this);

	PLAYERS_LOOP_RUNTIME
	{
		ResetPlayerDataStruct(ph->playerClass);
	}
	END_PLAYERS_LOOP

	m_convars_rules.clear();
}

const char * Detection_ConVar::GetDataDump()
{
	return Helpers::format("CurrentConVarRequest { %d, %d, %f, ConVarInfo { %s, %s, %d} }\0",
							GetDataStruct()->isSent, GetDataStruct()->isReplyed, GetDataStruct()->timeStart,
							GetDataStruct()->ruleset->name, GetDataStruct()->ruleset->value, GetDataStruct()->ruleset->rule).c_str();
}

const char * Detection_ConVar::GetDetectionLogMessage()
{
	return Helpers::format("%s ConVar Bypasser", GetDataStruct()->ruleset->name).c_str();
}


```

`server-plugin/Code/Systems/Testers/ConVarTester.h`:

```h
#include "BaseFramedTester.h"
#include "Misc/temp_Singleton.h"
#include "Systems/Testers/Detections/temp_BaseDetection.h"
#include "Systems/BaseSystem.h"
#include "Players/NczPlayerManager.h"
#include "Players/NczFilteredPlayersList.h"
#include "Players/temp_PlayerDataStruct.h"
#include "Misc/IFaceManager.h"
#include "Misc/Helpers.h"
#include "Systems/BanRequest.h"

/////////////////////////////////////////////////////////////////////////
// ConVarTester
/////////////////////////////////////////////////////////////////////////

typedef enum ConVarRule
{
	SAME = 0,
	SAME_FLOAT,
	SAME_AS_SERVER,
	SAME_FLOAT_AS_SERVER,
	NO_VALUE
} ConVarRuleT;

typedef struct ConVarInfo
{
	char name[64];
	char value[64];
	ConVarRuleT rule;
	bool safe;

	ConVarInfo()
	{
		*name='\0';
		*value='\0';
		rule=SAME;
		safe=false;
	};
	ConVarInfo(const char* pname, const char* pvalue, ConVarRuleT prule, bool psafe)
	{
		strcpy(name, pname);
		strcpy(value, pvalue);
		rule=prule;
		safe=psafe;
	};
	ConVarInfo(const ConVarInfo& other)
	{
		strcpy(name, other.name);
		strcpy(value, other.value);
		rule=other.rule;
		safe=other.safe;
	};
} ConVarInfoT;

typedef struct CurrentConVarRequest
{
	bool isSent;
	bool isReplyed;
	double timeStart;
	ConVarInfoT* ruleset;

	CurrentConVarRequest(){isSent=false;isReplyed=false;timeStart=0.0;ruleset=nullptr;};
	CurrentConVarRequest(const CurrentConVarRequest& other){isSent=other.isSent;isReplyed=other.isReplyed;timeStart=other.timeStart;ruleset=other.ruleset;};
} CurrentConVarRequestT;

class Detection_ConVar : public LogDetection<CurrentConVarRequestT>
{
	typedef LogDetection<CurrentConVarRequestT> hClass;
public:
	Detection_ConVar() : hClass() {};
	~Detection_ConVar(){};

	virtual const char * GetDataDump();
	virtual const char * GetDetectionLogMessage();
};

class ConVarTester :
	public BaseSystem,
	public AsyncNczFilteredPlayersList,
	public BaseFramedTester,
	public PlayerDataStructHandler<CurrentConVarRequestT>,
	public Singleton<ConVarTester>
{
public:
	ConVarTester();
	~ConVarTester();

	virtual void Load();
	virtual void Unload();

	/* Nouvelle version de la fonction qui va faire en sorte de ne tester qu'un seul joueur par frame */
	virtual void ProcessTests();

	virtual void ProcessPlayerTest(NczPlayer* player);

	virtual SlotStatus GetFilter();

	virtual bool sys_cmd_fn ( const CCommand &args );

	void OnQueryCvarValueFinished(NczPlayer* player, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue);

private:
	ConVarInfoT* GetNextConvar(const char * current_convar_name);
	void AddConvarRuleset(const char * name, const char * value, ConVarRuleT rule, bool safe = true);
	ConVarInfoT* FindConvarRuleset(const char * name);

	std::list<ConVarInfoT> m_convars_rules;
};

```

`server-plugin/Code/Systems/Testers/Detections/temp_BaseDetection.h`:

```h
#include <list>
#include <string>

#include "Preprocessors.h"
#include "Misc/Helpers.h"
#include "Misc/IFaceManager.h"
#include "Players/NczPlayer.h"
#include "Systems/BaseSystem.h"

#ifndef BASEDETECTION
#define BASEDETECTION

class BaseDetection
{
public:
	BaseDetection(){};
	virtual ~BaseDetection(){};
};

template <typename playerDataStructT>
class SubDetection : public BaseDetection
{
public:
	SubDetection()
	{
		this->m_timestamp = 0.0;
		this->m_tick = 0;
		this->m_dataStruct = playerDataStructT();
	};
	~SubDetection(){};

	void PrepareDetectionData(playerDataStructT* dataStruct)
	{
		this->m_timestamp = Plat_FloatTime();
		this->m_tick = CIFaceManager::GetInstance()->GetGlobals()->tickcount;
		this->m_dataStruct = *dataStruct;
	};

	playerDataStructT* GetDataStruct() const
	{
		return (playerDataStructT*)(&(this->m_dataStruct));
	};

	virtual const char * GetDataDump(){return nullptr;};

protected:
	double m_timestamp;
	int m_tick;
	playerDataStructT m_dataStruct;
};

template <typename playerDataStructT>
class LogDetection : public SubDetection<playerDataStructT>
{
	typedef SubDetection<playerDataStructT> BaseClass;
public:
	LogDetection() : BaseClass()
	{
		this->m_playerName[0] = 0;
		this->m_playerAdress[0] = 0;
		this->m_playerSteamID[0] = 0;
		this->m_testerName = nullptr;
	};
	~LogDetection(){};

	virtual const char * GetDetectionLogMessage(){return nullptr;};

	virtual void Log()
	{
		std::string msg;
		msg = Helpers::format("%f %d - %s triggered a detection : %s [%s - %s] is using a %s.\0", this->m_timestamp, this->m_tick, this->m_testerName, this->m_playerName, this->m_playerSteamID, this->m_playerAdress, this->GetDetectionLogMessage()); 
		Helpers::writeToLogfile(msg);
		msg = Helpers::format("[" NCZ_PLUGIN_NAME "] %s\0", msg.c_str());
		CIFaceManager::GetInstance()->GetIengine()->LogPrint(msg.c_str());
		if(NczPlayerManager::GetInstance()->GetPlayerHandlerBySteamID(m_playerSteamID)->status != INVALID)
		{
#ifdef DEBUG
			Helpers::chatmsg(msg);
#else
			Helpers::noTell(NczPlayerManager::GetInstance()->GetPlayerHandlerBySteamID(m_playerSteamID)->playerClass->GetEdict(), msg);
#endif
		}
		else
		{
			Helpers::chatmsg(msg);
		}
	};

	void PrepareDetectionLog(NczPlayer* player, BaseSystem* tester)
	{
		m_testerName = tester->GetName();
		
		for(int x = 0; x < 32; ++x)
		{
			this->m_playerName[x] = player->GetName()[x];
		}
		this->m_playerName[32] = '\0'; 

		for(int x = 0; x < 32; ++x)
		{
			this->m_playerAdress[x] = player->GetIPAddress()[x];
		}
		this->m_playerAdress[32] = '\0';

		for(int x = 0; x < 32; ++x)
		{
			this->m_playerSteamID[x] = player->GetSteamID()[x];
		}
		this->m_playerAdress[32] = '\0';
	};

	virtual const char * GetDataDump(){return nullptr;};

protected:
	const char * m_testerName;
	char m_playerName[32];
	char m_playerAdress[32];
	char m_playerSteamID[32];
};

template <typename playerDataStructT>
class FalseDetection : public LogDetection<playerDataStructT>
{
	typedef LogDetection<playerDataStructT> BaseClass;
public:
	FalseDetection() : BaseClass()
	{
		this->m_playerName[0] = 0;
		this->m_playerAdress[0] = 0;
		this->m_playerSteamID[0] = 0;
		this->m_testerName = nullptr;
	};
	~FalseDetection(){};

	virtual const char * GetDetectionLogMessage(){return nullptr;};

	virtual void Log()
	{
		std::string msg;
		msg = Helpers::format("%f %d - %s triggered a false detection on %s [%s - %s].\0", this->m_timestamp, this->m_tick, this->m_testerName, this->m_playerName, this->m_playerSteamID, this->m_playerAdress); 
		Helpers::writeToLogfile(msg);
	};

	void PrepareDetectionLog(NczPlayer* player, BaseSystem* tester)
	{
		this->m_testerName = tester->GetName();
		
		for(int x = 0; x < 32; ++x)
		{
			this->m_playerName[x] = player->GetName()[x];
		}
		this->m_playerName[32] = '\0'; 

		for(int x = 0; x < 32; ++x)
		{
			this->m_playerAdress[x] = player->GetIPAddress()[x];
		}
		this->m_playerAdress[32] = '\0';

		for(int x = 0; x < 32; ++x)
		{
			this->m_playerSteamID[x] = player->GetSteamID()[x];
		}
		this->m_playerAdress[32] = '\0';
	};

	virtual const char * GetDataDump(){return nullptr;};
};

#endif

```

`server-plugin/Code/Systems/Testers/EyeAnglesTester.cpp`:

```cpp
#include "EyeAnglesTester.h"

EyeAnglesTester::EyeAnglesTester(void) :
	BaseSystem(),
	PlayerRunCommandHookListener(),
	PlayerDataStructHandler<EyeAngleInfoT>(),
	EventManagerWrap(),
	Singleton<EyeAnglesTester>()
{
	m_name = "EyeAnglesTester";
}

EyeAnglesTester::~EyeAnglesTester(void)
{
	Unload();
}

SlotStatus EyeAnglesTester::GetFilter()
{
	return PLAYER_IN_TESTS;
}

void EyeAnglesTester::Load()
{
	CIFaceManager::GetInstance()->GetIevents()->AddListener(this, "round_end", true);
	PlayerRunCommandHookListener::RegisterPlayerRunCommandHookListener(this);
}

void EyeAnglesTester::Unload()
{
	PlayerRunCommandHookListener::RemovePlayerRunCommandHookListener(this);
	CIFaceManager::GetInstance()->GetIevents()->RemoveListener(this);

	PLAYERS_LOOP_RUNTIME
	{
		ResetPlayerDataStruct(ph->playerClass);
	}
	END_PLAYERS_LOOP
}

bool EyeAnglesTester::PlayerRunCommandCallback(NczPlayer* player, CUserCmd* pCmd)
{	
	bool drop_cmd = false;

	EyeAngleInfoT* playerData = GetPlayerDataStruct(player);
	playerData->x.abs_value = fabs(    playerData->x.value = pCmd->viewangles.x    );
	playerData->y.abs_value = fabs(    playerData->y.value = pCmd->viewangles.y    );
	playerData->z.abs_value = fabs(    playerData->z.value = pCmd->viewangles.z    );

	if (playerData->x.abs_value > 89.0f || playerData->z.abs_value > 0.0f || playerData->y.abs_value > 180.0f)
	{
#		ifdef DEBUG
			Msg("Player %s : Bad Eye Angles %f, %f, %f\n", player->GetName(), playerData->x.value, playerData->y.value, playerData->z.value);
#		endif
		if(playerData->ignore_last) --(playerData->ignore_last);
		else drop_cmd = true;
	}

	if(drop_cmd)
	{
#		ifdef DEBUG
			Msg("Player %s : Droping command #%d\n", player->GetName(), pCmd->command_number);
#		endif
		if(playerData->x.abs_value > 89.0f)
		{
			++playerData->x.detectionsCount;
			if(playerData->x.lastDetectionPrintTime + 10.0 < Plat_FloatTime())
			{
				playerData->x.lastDetectionPrintTime = Plat_FloatTime();

				Detection_EyeAngleX pDetection = Detection_EyeAngleX();
				pDetection.PrepareDetectionData(playerData);
				pDetection.PrepareDetectionLog(player, this);
				pDetection.Log();
			}
		}
		if(playerData->y.abs_value > 180.0f)
		{
			++playerData->y.detectionsCount;
			if(playerData->y.lastDetectionPrintTime + 10.0 < Plat_FloatTime())
			{
				playerData->y.lastDetectionPrintTime = Plat_FloatTime();

				Detection_EyeAngleY pDetection = Detection_EyeAngleY();
				pDetection.PrepareDetectionData(playerData);
				pDetection.PrepareDetectionLog(player, this);
				pDetection.Log();
			}
		}
		if(playerData->z.abs_value > 0.0f)
		{
			++playerData->z.detectionsCount;
			if(playerData->z.lastDetectionPrintTime + 10.0 < Plat_FloatTime())
			{
				playerData->z.lastDetectionPrintTime = Plat_FloatTime();

				Detection_EyeAngleZ pDetection = Detection_EyeAngleZ();
				pDetection.PrepareDetectionData(playerData);
				pDetection.PrepareDetectionLog(player, this);
				pDetection.Log();
			}
		}
	}
	return drop_cmd;
}

void EyeAnglesTester::FireGameEvent(IGameEvent *ev) // round_end
{
	for(int index = 1; index < MAX_PLAYERS; ++index)
	{
		PlayerHandler* ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByIndex(index);
		if(ph->status > BOT) ++(GetPlayerDataStruct(ph->playerClass)->ignore_last);
	}
}

void EyeAnglesTester::TeleportCallback(NczPlayer* player, Vector const* va, QAngle const* qa, Vector const* vb)
{
#	ifdef DEBUG
		Msg("Player %s : EyeAnglesTester::TeleportCallback\n", player->GetName());
#	endif
	EyeAngleInfoT* playerData = GetPlayerDataStruct(player);
	++playerData->ignore_last;
}

const char * Detection_EyeAngle::GetDataDump()
{
	return Helpers::format("EyeAngleInfo { %d, EyeAngleX { %f, %f, %f, %d }, EyeAngleY { %f, %f, %f, %d }, EyeAngleZ { %f, %f, %f, %d } }\0",
							GetDataStruct()->ignore_last, 
							GetDataStruct()->x.value, GetDataStruct()->x.abs_value, GetDataStruct()->x.lastDetectionPrintTime, GetDataStruct()->x.detectionsCount,
							GetDataStruct()->y.value, GetDataStruct()->y.abs_value, GetDataStruct()->y.lastDetectionPrintTime, GetDataStruct()->y.detectionsCount,
							GetDataStruct()->z.value, GetDataStruct()->z.abs_value, GetDataStruct()->z.lastDetectionPrintTime, GetDataStruct()->z.detectionsCount).c_str();
}

const char * Detection_EyeAngleX::GetDetectionLogMessage()
{
	if(Helpers::IsInt(GetDataStruct()->x.value))
	{
		return "Anti-Aim";
	}
	else
	{
		return "No recoil";
	}
}

const char * Detection_EyeAngleY::GetDetectionLogMessage()
{
	if(Helpers::IsInt(GetDataStruct()->y.value))
	{
		return "Anti-Aim";
	}
	else
	{
		return "No spread";
	}
}

const char * Detection_EyeAngleZ::GetDetectionLogMessage()
{
	if(Helpers::IsInt(GetDataStruct()->z.value))
	{
		return "Anti-Aim";
	}
	else
	{
		return "No spread";
	}
}

```

`server-plugin/Code/Systems/Testers/EyeAnglesTester.h`:

```h
#include "Misc/EventManagerWrap.h"

#ifdef GNUC
#undef min
#undef max
#endif

#include "Systems/BaseSystem.h"
#include "Systems/Testers/Detections/temp_BaseDetection.h"
#include "Hooks/PlayerRunCommandHookListener.h"
#include "Hooks/TeleportHookListener.h"
#include "Players/temp_PlayerDataStruct.h"
#include "Players/NczFilteredPlayersList.h"
#include "Misc/temp_Singleton.h"
#include "Misc/IFaceManager.h"

#ifndef EYEANGLESTESTER
#define EYEANGLESTESTER

typedef struct EyeAngle
{
	vec_t value; // Raw value of the angle
	vec_t abs_value; // Abs value so it's easier to test

	double lastDetectionPrintTime;
	unsigned int detectionsCount;

	EyeAngle()
	{
		value = abs_value = 0.0;
		lastDetectionPrintTime = 0.0;
		detectionsCount = 0;
	};
	EyeAngle(const EyeAngle& other)
	{
		value = other.value;
		abs_value = other.abs_value;
		lastDetectionPrintTime = other.lastDetectionPrintTime;
		detectionsCount = other.detectionsCount;
	};
} EyeAngleT;

typedef struct EyeAngleInfo
{
	unsigned int ignore_last; // Ignore values potentially not initialized by the engine

	EyeAngleT x;
	EyeAngleT y;
	EyeAngleT z;

	EyeAngleInfo()
	{
		ignore_last = 0;
		x = y = z = EyeAngle();
	};
	EyeAngleInfo(const EyeAngleInfo& other)
	{
		ignore_last = other.ignore_last;
		x = other.x;
		y = other.y;
		z = other.z;
	};
} EyeAngleInfoT;

class Detection_EyeAngle : public LogDetection<EyeAngleInfoT>
{
	typedef LogDetection<EyeAngleInfoT> hClass;
public:
	Detection_EyeAngle() : hClass() {};
	~Detection_EyeAngle(){};

	virtual const char * GetDataDump();
};

class Detection_EyeAngleX : public Detection_EyeAngle
{
public:
	Detection_EyeAngleX(){};
	~Detection_EyeAngleX(){};

	virtual const char * GetDetectionLogMessage();
};

class Detection_EyeAngleY : public Detection_EyeAngle
{
public:
	Detection_EyeAngleY(){};
	~Detection_EyeAngleY(){};

	virtual const char * GetDetectionLogMessage();
};

class Detection_EyeAngleZ : public Detection_EyeAngle
{
public:
	Detection_EyeAngleZ(){};
	~Detection_EyeAngleZ(){};

	virtual const char * GetDetectionLogMessage();
};

class EyeAnglesTester :
	public BaseSystem,
	public PlayerRunCommandHookListener,
	public TeleportHookListener,
	public PlayerDataStructHandler<EyeAngleInfoT>,
	public EventManagerWrap,
	public Singleton<EyeAnglesTester>
{
public:
	EyeAnglesTester();
	virtual ~EyeAnglesTester();

	virtual void Load();
	virtual void Unload();
	virtual SlotStatus GetFilter();
	virtual bool PlayerRunCommandCallback(NczPlayer* player, CUserCmd* pCmd);
	virtual void FireGameEvent(IGameEvent *ev);
	virtual void TeleportCallback(NczPlayer* player, Vector const* va, QAngle const* qa, Vector const* vb);
};

#endif

```

`server-plugin/Code/Systems/Testers/JumpTester.cpp`:

```cpp
#include "JumpTester.h"

/*
	Test each player to see if they use any script to help BunnyHop.

	Some players jumps just-in-time without using any script.
	We have to make the difference by using statistics.
*/

JumpTester::JumpTester() :
	BaseSystem(),
	BaseTimedTester(10.0),
	OnGroundHookListener(),
	PlayerRunCommandHookListener(),
	PlayerDataStructHandler<JumpInfoT>(),
	Singleton<JumpTester>()
{
	m_name = "JumpTester";
}

JumpTester::~JumpTester()
{
	Unload();
}

SlotStatus JumpTester::GetFilter()
{
	return PLAYER_IN_TESTS;
}

void JumpTester::Load()
{
	BaseTimedTester::RegisterFramedTester(this);
	OnGroundHookListener::RegisterOnGroundHookListener(this);
	PlayerRunCommandHookListener::RegisterPlayerRunCommandHookListener(this);
}

void JumpTester::Unload()
{
	BaseTimedTester::RemoveFramedTester(this);
	OnGroundHookListener::RemoveOnGroundHookListener(this);
	PlayerRunCommandHookListener::RemovePlayerRunCommandHookListener(this);

	PLAYERS_LOOP_RUNTIME
	{
		ResetPlayerDataStruct(ph->playerClass);
	}
	END_PLAYERS_LOOP
}

void JumpTester::m_hGroundEntityStateChangedCallback(NczPlayer* player, bool new_isOnGround)
{
	JumpInfoT* playerData = GetPlayerDataStruct(player);

	if(new_isOnGround)
	{
		playerData->onGroundHolder.onGround_Tick = CIFaceManager::GetInstance()->GetGlobals()->tickcount;
		playerData->isOnGround = true;
		if(HasVerbose()) Msg("Player %s : Now on ground at %f %d\n", player->GetName(), Plat_FloatTime(), CIFaceManager::GetInstance()->GetGlobals()->tickcount);
		if(playerData->jumpCmdHolder.outsideJumpCmdCount > 10) // Il serait plus judicieux d'utiliser le RMS
		{
			Detection_BunnyHopScript pDetection = Detection_BunnyHopScript();
			pDetection.PrepareDetectionData(playerData);
			pDetection.PrepareDetectionLog(player, this);
			pDetection.Log();
			player->Kick("You have to turn off your BunnyHop Script to play on this server.");
		}
		else if(playerData->jumpCmdHolder.outsideJumpCmdCount == 0 && playerData->perfectBhopsCount > 5)
		{
			Detection_BunnyHopProgram pDetection = Detection_BunnyHopProgram();
			pDetection.PrepareDetectionData(playerData);
			pDetection.PrepareDetectionLog(player, this);
			pDetection.Log();

			player->Ban("[NoCheatZ 4] You have been banned for using BunnyHop on this server.");
		}
		playerData->jumpCmdHolder.outsideJumpCmdCount = 0;
	}
	else
	{
		playerData->onGroundHolder.notOnGround_Tick = CIFaceManager::GetInstance()->GetGlobals()->tickcount;
		++playerData->onGroundHolder.jumpCount;
		playerData->isOnGround = false;
		if(HasVerbose()) Msg("Player %s : Now not on ground at %f %d\n", player->GetName(), Plat_FloatTime(), CIFaceManager::GetInstance()->GetGlobals()->tickcount);
	}
}

void JumpTester::ProcessPlayerTest(NczPlayer* player)
{

}

bool JumpTester::PlayerRunCommandCallback(NczPlayer* player, CUserCmd* pCmd)
{
	bool drop_cmd = false;

	JumpInfoT* playerData = GetPlayerDataStruct(player);

	if((playerData->jumpCmdHolder.lastJumpCmdState == false) && (pCmd->buttons & IN_JUMP))
	{
		playerData->jumpCmdHolder.JumpDown_Tick = CIFaceManager::GetInstance()->GetGlobals()->tickcount;
		if(playerData->isOnGround)
		{
			int diff = abs(playerData->jumpCmdHolder.JumpDown_Tick - playerData->onGroundHolder.onGround_Tick);
			if(diff < 10)
			{
				++playerData->total_bhopCount;
#				ifdef DEBUG
					Msg("Player %s : total_bhopCount = %d\n", player->GetName(), playerData->total_bhopCount);
#				endif
				if(diff < 3 && diff > 0)
				{
					++playerData->goodBhopsCount;
#					ifdef DEBUG
						Msg("Player %s : goodBhopsCount = %d\n", player->GetName(), playerData->goodBhopsCount);
#					endif
					drop_cmd = true;
				}
				if(diff == 0)
				{
					++playerData->perfectBhopsCount;
#					ifdef DEBUG
						Msg("Player %s : perfectBhopsCount = %d\n", player->GetName(), playerData->perfectBhopsCount);
#					endif
					drop_cmd = true;
				}
			}

			if(HasVerbose()) Msg("Player %s : %f %d : Now using jump button (delta %d)\n", player->GetName(), Plat_FloatTime(), CIFaceManager::GetInstance()->GetGlobals()->tickcount, diff);
		}
		else
		{
			++playerData->jumpCmdHolder.outsideJumpCmdCount;
			if(HasVerbose()) Msg("Player %s : %f %d : Now using jump button (outside count %d)\n", player->GetName(), Plat_FloatTime(), CIFaceManager::GetInstance()->GetGlobals()->tickcount, playerData->jumpCmdHolder.outsideJumpCmdCount);
		}
		playerData->jumpCmdHolder.lastJumpCmdState = true;
	}
	else if((playerData->jumpCmdHolder.lastJumpCmdState == true) && ((pCmd->buttons & IN_JUMP) == 0))
	{
		playerData->jumpCmdHolder.lastJumpCmdState = false;
		playerData->jumpCmdHolder.JumpUp_Tick = CIFaceManager::GetInstance()->GetGlobals()->tickcount;
		if(HasVerbose()) Msg("Player %s : %f %d : Now not using jump button\n", player->GetName(), Plat_FloatTime(), CIFaceManager::GetInstance()->GetGlobals()->tickcount);
	}
#	ifdef DEBUG
		if(drop_cmd) Msg("Player %s : UserCmd will be dropped\n", player->GetName());
#	endif
	return drop_cmd;
}

const char * Detection_BunnyHopScript::GetDataDump()
{
	return Helpers::format("BunnyHopInfoT { OnGroundHolderT { %d, %d, %d }, JumpCmdHolderT { %d, %d, %d, %d }, %d, %d, %d, %d }\0",
							GetDataStruct()->onGroundHolder.onGround_Tick, GetDataStruct()->onGroundHolder.notOnGround_Tick, GetDataStruct()->onGroundHolder.jumpCount,
							GetDataStruct()->jumpCmdHolder.lastJumpCmdState, GetDataStruct()->jumpCmdHolder.JumpDown_Tick, GetDataStruct()->jumpCmdHolder.JumpUp_Tick, GetDataStruct()->jumpCmdHolder.outsideJumpCmdCount,
							GetDataStruct()->total_bhopCount,
							GetDataStruct()->goodBhopsCount,
							GetDataStruct()->perfectBhopsPercent,
							GetDataStruct()->perfectBhopsCount,
							GetDataStruct()->isOnGround).c_str();
}

const char * Detection_BunnyHopProgram::GetDataDump()
{
	return Helpers::format("BunnyHopInfoT { OnGroundHolderT { %d, %d, %d }, JumpCmdHolderT { %d, %d, %d, %d }, %d, %d, %d, %d }\0",
							GetDataStruct()->onGroundHolder.onGround_Tick, GetDataStruct()->onGroundHolder.notOnGround_Tick, GetDataStruct()->onGroundHolder.jumpCount,
							GetDataStruct()->jumpCmdHolder.lastJumpCmdState, GetDataStruct()->jumpCmdHolder.JumpDown_Tick, GetDataStruct()->jumpCmdHolder.JumpUp_Tick, GetDataStruct()->jumpCmdHolder.outsideJumpCmdCount,
							GetDataStruct()->total_bhopCount,
							GetDataStruct()->goodBhopsCount,
							GetDataStruct()->perfectBhopsPercent,
							GetDataStruct()->perfectBhopsCount,
							GetDataStruct()->isOnGround).c_str();
}

```

`server-plugin/Code/Systems/Testers/JumpTester.h`:

```h
#include <string>

#include "BaseTimedTester.h"
#include "Misc/temp_Singleton.h"
#include "Misc/IFaceManager.h"
#include "Misc/Helpers.h"
#include "Systems/Testers/Detections/temp_BaseDetection.h"
#include "Players/NczPlayerManager.h"
#include "Players/temp_PlayerDataStruct.h"
#include "Systems/BaseSystem.h"
#include "Hooks/OnGroundHookListener.h"
#include "Hooks/PlayerRunCommandHookListener.h"

/////////////////////////////////////////////////////////////////////////
// JumpTester
/////////////////////////////////////////////////////////////////////////

typedef struct OnGroundHolder
{
	int onGround_Tick;
	int notOnGround_Tick;

	int jumpCount;

	OnGroundHolder()
	{
		onGround_Tick = notOnGround_Tick = jumpCount = 0;
	};
	OnGroundHolder(const OnGroundHolder& other)
	{
		onGround_Tick = other.onGround_Tick;
		notOnGround_Tick = other.notOnGround_Tick;
		jumpCount = other.jumpCount;
	};
} OnGroundHolderT;

typedef struct JumpCmdHolder
{
	bool lastJumpCmdState;

	int JumpDown_Tick;
	int JumpUp_Tick;

	int outsideJumpCmdCount; // Jumps made while the player doesn't touch the ground

	JumpCmdHolder()
	{
		lastJumpCmdState = false;
		JumpDown_Tick = JumpUp_Tick = outsideJumpCmdCount = 0;
	};
	JumpCmdHolder(const JumpCmdHolder& other)
	{
		lastJumpCmdState = other.lastJumpCmdState;
		JumpDown_Tick = other.JumpDown_Tick;
		JumpUp_Tick = other.JumpUp_Tick;
		outsideJumpCmdCount = other.outsideJumpCmdCount;
	};
} JumpCmdHolderT;

typedef struct JumpInfo
{
	OnGroundHolderT onGroundHolder;
	JumpCmdHolderT jumpCmdHolder;
	int total_bhopCount;

	int goodBhopsCount;
	int perfectBhopsPercent;
	int perfectBhopsCount;

	bool isOnGround;

	JumpInfo()
	{
		onGroundHolder = OnGroundHolder();
		jumpCmdHolder = JumpCmdHolder();
		total_bhopCount = goodBhopsCount = perfectBhopsPercent = perfectBhopsCount = 0;
		isOnGround = false;
	};
	JumpInfo(const JumpInfo& other)
	{
		onGroundHolder = other.onGroundHolder;
		jumpCmdHolder = other.jumpCmdHolder;
		total_bhopCount = other.total_bhopCount;
		goodBhopsCount = other.goodBhopsCount;
		perfectBhopsPercent = other.perfectBhopsPercent;
		perfectBhopsCount = other.perfectBhopsCount;
		isOnGround = other.isOnGround;
	};
} JumpInfoT;

class Detection_BunnyHopScript : public LogDetection<JumpInfoT>
{
	typedef LogDetection<JumpInfoT> hClass;
public:
	Detection_BunnyHopScript() : hClass() {};
	~Detection_BunnyHopScript(){};

	virtual const char * GetDataDump();
	virtual const char * GetDetectionLogMessage()
	{
		return "BunnyHop Script";
	};
};

class Detection_BunnyHopProgram : public LogDetection<JumpInfoT>
{
	typedef LogDetection<JumpInfoT> hClass;
public:
	Detection_BunnyHopProgram() : hClass() {};
	~Detection_BunnyHopProgram(){};

	virtual const char * GetDataDump();
	virtual const char * GetDetectionLogMessage()
	{
		return "BunnyHop Program";
	};
};

class JumpTester :
	public BaseSystem,
	public BaseTimedTester,
	public OnGroundHookListener,
	public PlayerRunCommandHookListener,
	public PlayerDataStructHandler<JumpInfoT>,
	public Singleton<JumpTester>
{
public:
	JumpTester();
	~JumpTester();

	virtual void Load();
	virtual void Unload();
	virtual bool PlayerRunCommandCallback(NczPlayer* player, CUserCmd* cmd);
	virtual void m_hGroundEntityStateChangedCallback(NczPlayer* player, bool new_isOnGround);
	virtual void ProcessPlayerTest(NczPlayer* player);
	virtual SlotStatus GetFilter();
};

```

`server-plugin/Code/Systems/Testers/ShotTester.cpp`:

```cpp
#include "ShotTester.h"

/*
	Test each player to see if they use any script to help them fire more bullets (= RapidFire)

	Some old mouses can also make multiple clicks because of an electronic issue, not because the player itself use a script.
	We have to make the difference by using statistics.
*/

ShotTester::ShotTester(void) :
	BaseSystem(),
	Logger(),
	PlayerRunCommandHookListener(),
	PlayerDataStructHandler<ShotStatsT>(),
	Singleton<ShotTester>()
{
	m_name = "ShotTester";
}

ShotTester::~ShotTester(void)
{
	Unload();
}

SlotStatus ShotTester::GetFilter()
{
	return PLAYER_IN_TESTS;
}

void ShotTester::Load()
{
	PlayerRunCommandHookListener::RegisterPlayerRunCommandHookListener(this);
}

void ShotTester::Unload()
{
	PlayerRunCommandHookListener::RemovePlayerRunCommandHookListener(this);

	PLAYERS_LOOP_RUNTIME
	{
		ResetPlayerDataStruct(ph->playerClass);
	}
	END_PLAYERS_LOOP
}

void TriggerStat(ShotStatHandlerT* handler, double up_time, double down_time, size_t clicks)
{
	++(handler->n);
	handler->avg_time = (handler->avg_time + (up_time - down_time) / (double)(handler->n));
	handler->ratio = ((double)(handler->n) / (double)(clicks)) * 100.0;
}

void OutputStat(ShotStatHandlerT* handler)
{
	Msg(Helpers::format("{ count %lu, ratio %3.2f, avg %3.2f }", handler->n, handler->ratio, handler->avg_time).c_str());
}

bool ShotTester::PlayerRunCommandCallback(NczPlayer* player, CUserCmd* pCmd)
{	
	bool drop_cmd = false;

	ShotStatsT* playerData = GetPlayerDataStruct(player);
	CUserCmd* lastcmd = PlayerRunCommandHookListener::GetLastUserCmd(player);

	if((pCmd->buttons & IN_ATTACK) && !(lastcmd->buttons & IN_ATTACK))
	{
		if(HasVerbose()) Msg("Player %s : %f : IN_ATTACK button down.\n", player->GetName(), Plat_FloatTime());
		playerData->down_time = Plat_FloatTime();
	}
	else if((lastcmd->buttons & IN_ATTACK) && !(pCmd->buttons & IN_ATTACK))
	{
		playerData->up_time = Plat_FloatTime();
		TriggerStat(&(playerData->clicks), playerData->up_time, playerData->down_time, playerData->clicks.n);
		if(HasVerbose()) Msg("Player %s : %f : IN_ATTACK button up.\n", player->GetName(), Plat_FloatTime());

		if(playerData->up_time - playerData->down_time <= SHORT_TIME)
		{
			if(Plat_FloatTime() - playerData->last_detection > 1.0)
			{
				if(playerData->row == 1)
				{
					if(playerData->on_target.ratio > 25.0 && playerData->clicks.n > 50)
					{
						Detection_TriggerBot pDetection = Detection_TriggerBot();
						pDetection.PrepareDetectionData(playerData);
						pDetection.PrepareDetectionLog(player, this);
						pDetection.Log();
					}
				}
				playerData->row = 0;
			}
			if(playerData->row > 10)
			{
				if(playerData->short_clicks.ratio > 40.0 && playerData->clicks.n > 50)
				{
					Detection_AutoPistol pDetection = Detection_AutoPistol();
					pDetection.PrepareDetectionData(playerData);
					pDetection.PrepareDetectionLog(player, this);
					pDetection.Log();
				}
			}
			playerData->last_detection = Plat_FloatTime();
			++(playerData->row);

			TriggerStat(&(playerData->short_clicks), playerData->up_time, playerData->down_time, playerData->clicks.n);
			if(player->GetWpnShotType() == HAND) TriggerStat(&(playerData->with_hand), playerData->up_time, playerData->down_time, playerData->clicks.n);
			else if(player->GetWpnShotType() == PISTOL) TriggerStat(&(playerData->with_pistol), playerData->up_time, playerData->down_time, playerData->clicks.n);
			else TriggerStat(&(playerData->with_auto), playerData->up_time, playerData->down_time, playerData->clicks.n);
			if(player->aimingAt() > 0) TriggerStat(&(playerData->on_target), playerData->up_time, playerData->down_time, playerData->clicks.n);
			drop_cmd = true;

			if(HasVerbose())
			{
				Msg("%f - clicks ", Plat_FloatTime());
				OutputStat(&(playerData->clicks));
				Msg(", short_clicks ");
				OutputStat(&(playerData->short_clicks));
				Msg(", with_hand ");
				OutputStat(&(playerData->with_hand));
				Msg(", with_pistol ");
				OutputStat(&(playerData->with_pistol));
				Msg(", with_auto ");
				OutputStat(&(playerData->with_auto));
				Msg(", on_target ");
				OutputStat(&(playerData->on_target));
				Msg(", row %d\n", playerData->row);
			}
		}
	}
	return drop_cmd;
}


const char * ShotDetection::GetDataDump()
{
	return Helpers::format("ShotStatsT { %f, %f, Clicks { %lu, %f, %f }, ShortClicks { %lu, %f, %f }, WithHand { %lu, %f, %f }, WithPistol { %lu, %f, %f }, WithAuto { %lu, %f, %f }, OnTarget { %lu, %f, %f }, %lu, %f }",
							GetDataStruct()->up_time, GetDataStruct()->down_time, 
							GetDataStruct()->clicks.n, GetDataStruct()->clicks.ratio, GetDataStruct()->clicks.avg_time, 
							GetDataStruct()->short_clicks.n, GetDataStruct()->short_clicks.ratio, GetDataStruct()->short_clicks.avg_time, 
							GetDataStruct()->with_hand.n, GetDataStruct()->with_hand.ratio, GetDataStruct()->with_hand.avg_time, 
							GetDataStruct()->with_pistol.n, GetDataStruct()->with_pistol.ratio, GetDataStruct()->with_pistol.avg_time, 
							GetDataStruct()->with_auto.n, GetDataStruct()->with_auto.ratio, GetDataStruct()->with_auto.avg_time, 
							GetDataStruct()->on_target.n, GetDataStruct()->on_target.ratio, GetDataStruct()->on_target.avg_time, 
							GetDataStruct()->row, GetDataStruct()->last_detection).c_str();
}

```

`server-plugin/Code/Systems/Testers/ShotTester.h`:

```h
#include <list>

#ifdef GNUC
#undef min
#undef max
#endif

#include "Systems/BaseSystem.h"
#include "Systems/Logger.h"
#include "Systems/Testers/Detections/temp_BaseDetection.h"
#include "Hooks/PlayerRunCommandHookListener.h"
#include "Players/temp_PlayerDataStruct.h"
#include "Misc/temp_Singleton.h"
#include "Misc/IFaceManager.h"

#ifndef ShotTester_H
#define ShotTester_H

#define SHORT_TIME 0.04 // sec

typedef struct ShotStatHandler
{
	size_t n;
	double avg_time;
	double ratio;

	ShotStatHandler()
	{
		n = 0;
		avg_time = ratio = 0.0;
	};
	ShotStatHandler(const ShotStatHandler& other)
	{
		n = other.n;
		avg_time = other.avg_time;
		ratio = other.ratio;
	};
} ShotStatHandlerT;

void TriggerStat(ShotStatHandlerT* handler);
void OutputStat(ShotStatHandlerT* handler);

typedef struct ShotStats
{
	double up_time; // Heure où le bouton est appuyé
	double down_time; // Heure où le bouton est relâché
	ShotStatHandlerT clicks; // Nombre de click total
	ShotStatHandlerT short_clicks; // Nombre de click trop courts :
	ShotStatHandlerT with_hand;    // - Désarmé
	ShotStatHandlerT with_pistol;  // - Avec un pistolet ou un fusil à pompe
	ShotStatHandlerT with_auto;    // - Avec une arme automatique
	ShotStatHandlerT on_target;    // - En visant un adversaire
	size_t row; // Détections consécutives
	double last_detection; // Heure de la dernière détection

	ShotStats()
	{
		up_time = down_time = last_detection = 0;
		row = 0;
		clicks = short_clicks = with_hand = with_pistol = with_auto = on_target = ShotStatHandler();
	};
	ShotStats(const ShotStats& other)
	{
		up_time = other.up_time;
		down_time = other.down_time;
		clicks = other.clicks;
		short_clicks = other.short_clicks;
		with_hand = other.with_hand;
		with_pistol = other.with_pistol;
		with_auto = other.with_auto;
		on_target = other.on_target;
		row = other.row;
		last_detection = other.last_detection;
	};
} ShotStatsT;

class ShotTester :
	public BaseSystem,
	public Logger,
	public PlayerRunCommandHookListener,
	public PlayerDataStructHandler<ShotStatsT>,
	public Singleton<ShotTester>
{
public:
	ShotTester();
	virtual ~ShotTester();

	virtual void Load();
	virtual void Unload();
	virtual SlotStatus GetFilter();
	virtual bool PlayerRunCommandCallback(NczPlayer* player, CUserCmd* pCmd);
};

class ShotDetection : public LogDetection<ShotStats>
{
	typedef LogDetection<ShotStats> hClass;
public:
	ShotDetection() : hClass() {};
	~ShotDetection(){};

	virtual const char * GetDataDump();
	virtual const char * GetDetectionLogMessage()
	{
		return "ShotDetection";
	};
};

class Detection_TriggerBot : public ShotDetection
{
public:
	Detection_TriggerBot() : ShotDetection() {};
	~Detection_TriggerBot(){};

	virtual const char * GetDetectionLogMessage()
	{
		return "TriggerBot";
	};
};

class Detection_AutoPistol : public ShotDetection
{
public:
	Detection_AutoPistol() : ShotDetection() {};
	~Detection_AutoPistol(){};

	virtual const char * GetDetectionLogMessage()
	{
		return "AutoPistol";
	};
};

#endif

```

`server-plugin/Code/Systems/Testers/SpeedTester.cpp`:

```cpp
#include "SpeedTester.h"

SpeedTester::SpeedTester() :
	BaseSystem(),
	BaseTimedTester(0.1, GAME),
	PlayerRunCommandHookListener(),
	PlayerDataStructHandler<SpeedHolderT>(),
	Singleton<SpeedTester>()
{
	m_name = "SpeedTester";
}

SpeedTester::~SpeedTester()
{
	Unload();
}

SlotStatus SpeedTester::GetFilter()
{
	return PLAYER_IN_TESTS;
}

void SpeedTester::Load()
{
	BaseTimedTester::RegisterFramedTester(this);
	PlayerRunCommandHookListener::RegisterPlayerRunCommandHookListener(this);
}

void SpeedTester::Unload()
{
	BaseTimedTester::RemoveFramedTester(this);
	PlayerRunCommandHookListener::RemovePlayerRunCommandHookListener(this);

	PLAYERS_LOOP_RUNTIME
	{
		ResetPlayerDataStruct(ph->playerClass);
	}
	END_PLAYERS_LOOP
}

void SpeedTester::ProcessPlayerTest(NczPlayer* player)
{
	const double game_time = Plat_FloatTime();
	SpeedHolderT* const pInfo = this->GetPlayerDataStruct(player);
	const size_t newTicks = std::ceil((game_time - pInfo->lastTest) / CIFaceManager::GetInstance()->GetIgamedll()->GetTickInterval());
	const double latency = player->GetChannelInfo()->GetLatency(FLOW_OUTGOING);

	if (!pInfo->ticksLeft && std::fabs(pInfo->previousLatency - latency) <= 0.005)
	{
		++(pInfo->detections);

#		ifdef DEBUG
			Msg("Player %s : Speedhack pre-detection #%d\n", player->GetName(), pInfo->detections);
#		endif

		if (pInfo->detections >= 30 && game_time > pInfo->lastDetectionTime + 30.0)
		{

#		ifdef DEBUG
			Msg("Player %s : Speedhack detected\n", player->GetName());
#		endif

			Detection_SpeedHack pDetection = Detection_SpeedHack();
			pDetection.PrepareDetectionData(pInfo);
			pDetection.PrepareDetectionLog(player, this);
			pDetection.Log();

			pInfo->lastDetectionTime = game_time;
		}
	}
	else if(pInfo->detections)
	{
		--(pInfo->detections);
	}

	if ((pInfo->ticksLeft += newTicks) > std::ceil((1.0 / CIFaceManager::GetInstance()->GetIgamedll()->GetTickInterval()) * 2.0))
	{
		pInfo->ticksLeft = std::ceil((1.0 / CIFaceManager::GetInstance()->GetIgamedll()->GetTickInterval()) * 2.0);
	}
			
	pInfo->previousLatency = latency;
	pInfo->lastTest = game_time;
}

bool SpeedTester::PlayerRunCommandCallback(NczPlayer* player, CUserCmd* pCmd)
{
	size_t& tl = this->GetPlayerDataStruct(player)->ticksLeft;

	if(!tl) return true;

	--tl;
	
	return false;
}

const char * Detection_SpeedHack::GetDataDump()
{
	return Helpers::format("SpeedHolderT {%lu, %lu, %f, %f, %f}",
						GetDataStruct()->ticksLeft, GetDataStruct()->detections, GetDataStruct()->lastDetectionTime, GetDataStruct()->previousLatency, GetDataStruct()->lastTest).c_str();					
}

```

`server-plugin/Code/Systems/Testers/SpeedTester.h`:

```h
#include <string>

#include "BaseTimedTester.h"
#include "Misc/temp_Singleton.h"
#include "Misc/IFaceManager.h"
#include "Misc/Helpers.h"
#include "Systems/Testers/Detections/temp_BaseDetection.h"
#include "Players/NczPlayerManager.h"
#include "Players/temp_PlayerDataStruct.h"
#include "Systems/BaseSystem.h"
#include "Hooks/PlayerRunCommandHookListener.h"

/////////////////////////////////////////////////////////////////////////
// SpeedTester
/////////////////////////////////////////////////////////////////////////

typedef struct SpeedHolder
{
	size_t ticksLeft;
	size_t detections;
	double lastDetectionTime;
	double previousLatency;
	double lastTest;

	SpeedHolder()
	{
		ticksLeft = std::ceil((1.0 / CIFaceManager::GetInstance()->GetIgamedll()->GetTickInterval()) * 2.0);
		detections = 0;
		lastDetectionTime = previousLatency = lastTest = 0.0;
	};
	SpeedHolder(const SpeedHolder& other)
	{
		ticksLeft = other.ticksLeft;
		detections = other.detections;
		lastDetectionTime = other.lastDetectionTime;
		previousLatency = other.previousLatency;
		lastTest = other.lastTest;
	};
} SpeedHolderT;

class Detection_SpeedHack : public LogDetection<SpeedHolderT>
{
	typedef LogDetection<SpeedHolderT> hClass;
public:
	Detection_SpeedHack() : hClass() {};
	~Detection_SpeedHack(){};

	virtual const char * GetDataDump();
	virtual const char * GetDetectionLogMessage()
	{
		return "SpeedHack";
	};
};

class SpeedTester :
	public BaseSystem,
	public BaseTimedTester,
	public PlayerRunCommandHookListener,
	public PlayerDataStructHandler<SpeedHolderT>,
	public Singleton<SpeedTester>
{
public:
	SpeedTester();
	~SpeedTester();

	virtual void Load();
	virtual void Unload();
	virtual bool PlayerRunCommandCallback(NczPlayer* player, CUserCmd* cmd);
	virtual void ProcessPlayerTest(NczPlayer* player);
	virtual SlotStatus GetFilter();
};

```

`server-plugin/Code/Systems/Testers/ValidationTester.cpp`:

```cpp
#include "ValidationTester.h"

/////////////////////////////////////////////////////////////////////////
// ValidationTester
/////////////////////////////////////////////////////////////////////////

ValidationTester::ValidationTester() : 
	BaseSystem(),
	NczFilteredPlayersList(),
	BaseTimedTester(),
	PlayerDataStructHandler<ValidationInfoT>(),
	Singleton<ValidationTester>()
{
	m_name = "ValidationTester";
}

ValidationTester::~ValidationTester()
{
	Unload();
}

SlotStatus ValidationTester::GetFilter()
{
	return PLAYER_CONNECTED;
}

void ValidationTester::SetValidated(NczPlayer* player)
{
	GetPlayerDataStruct(player)->b = false;
	if(!HasVerbose()) return;
	Msg("%f : %d validated\n", Plat_FloatTime(), player->GetIndex());
	if(GetJobCount() == 0) SetActive(false);
}

void ValidationTester::ProcessPlayerTest(NczPlayer* player)
{
	if(!GetPlayerDataStruct(player)->b)
	{
		if(HasVerbose())
		{
			Msg("%f : %d validated\n", Plat_FloatTime(), player->GetIndex());
		}
		return;
	}
	if(HasVerbose())
	{
		Msg("%f : %d not validated\n", Plat_FloatTime(), player->GetIndex());
		Msg("%f : %d validation time left : %f\n", Plat_FloatTime(), player->GetIndex(), 20.0 - player->GetTimeConnected());
	}

	if(player->GetTimeConnected() < 20.0) return;
	player->Kick();
}

void ValidationTester::Load()
{
	BaseFramedTester::RegisterFramedTester(this);
}

void ValidationTester::Unload()
{
	BaseFramedTester::RemoveFramedTester(this);

	PLAYERS_LOOP_RUNTIME
	{
		ResetPlayerDataStruct(ph->playerClass);
	}
	END_PLAYERS_LOOP
}

short ValidationTester::GetJobCount()
{
	NczPlayer* player = nullptr;
	short count = 0;
	ResetNextPlayer();
	while((player = GetNextPlayer()) != nullptr)
	{
		if(GetPlayerDataStruct(player)->b) ++count;
	}
	return count;
}

```

`server-plugin/Code/Systems/Testers/ValidationTester.h`:

```h
#include "BaseTimedTester.h"
#include "Misc/temp_Singleton.h"
#include "Systems/BaseSystem.h"
#include "Players/NczPlayerManager.h"
#include "Players/NczFilteredPlayersList.h"
#include "Players/temp_PlayerDataStruct.h"
#include "Misc/IFaceManager.h"
#include "Misc/Helpers.h"

/////////////////////////////////////////////////////////////////////////
// ValidationTester
/////////////////////////////////////////////////////////////////////////

typedef struct ValidationInfo
{
	bool b;

	ValidationInfo()
	{
		b = false;
	};
	ValidationInfo(const ValidationInfo& other)
	{
		b = other.b;
	};
} ValidationInfoT;

class ValidationTester :
	public BaseSystem,
	public NczFilteredPlayersList,
	public BaseTimedTester,
	public PlayerDataStructHandler<ValidationInfoT>,
	public Singleton<ValidationTester>
{
public:
	ValidationTester();
	~ValidationTester();

	virtual void Load();
	virtual void Unload();
	virtual void SetValidated(NczPlayer* player);
	virtual void ProcessPlayerTest(NczPlayer* player);
	virtual SlotStatus GetFilter();

	short GetJobCount();
};

```

`server-plugin/Code/plugin.cpp`:

```cpp
//===== Copyright © 1996-2005, Valve Corporation, All rights reserved. ======//
//
// Purpose: 
//
// $NoKeywords: $
//
//===========================================================================//

#include "Preprocessors.h"
#include "plugin.h"
#include "Players/NczPlayerManager.h"
#include "Misc/IFaceManager.h"
#include "Misc/Helpers.h"
#include "Systems/Testers/ValidationTester.h"
#include "Systems/Testers/JumpTester.h"
#include "Systems/Testers/EyeAnglesTester.h"
#include "Systems/Testers/ConVarTester.h"
#include "Systems/Testers/ShotTester.h"
#include "Systems/Testers/SpeedTester.h"
#include "Hooks/PlayerRunCommandHookListener.h"
#include "Hooks/OnGroundHookListener.h"
#include "Systems/BanRequest.h"
#include "Systems/Logger.h"

// 
// The plugin is a static singleton that is exported as an interface
//
CNoCheatZPlugin g_NoCheatZPlugin;
EXPOSE_SINGLE_INTERFACE_GLOBALVAR(CNoCheatZPlugin, IServerPluginCallbacks, INTERFACEVERSION_ISERVERPLUGINCALLBACKS, g_NoCheatZPlugin );

//---------------------------------------------------------------------------------
// Purpose: constructor/destructor
//---------------------------------------------------------------------------------
CNoCheatZPlugin::CNoCheatZPlugin()
{
	m_iClientCommandIndex = 0;
	m_bAlreadyLoaded = false;
}

CNoCheatZPlugin::~CNoCheatZPlugin()
{
}

static ConVar nocheatz_instance("nocheatz_instance", "0");

void LoadTestersByConfig()
{
	EyeAnglesTester::GetInstance()->SetActive(true);
	EyeAnglesTester::GetInstance()->SetVerbose(false);

	JumpTester::GetInstance()->SetActive(true);
	JumpTester::GetInstance()->SetVerbose(false);

	ValidationTester::GetInstance()->SetActive(true);
	ValidationTester::GetInstance()->SetVerbose(false);

	ConVarTester::GetInstance()->SetActive(true);
	ConVarTester::GetInstance()->SetVerbose(false);

	ShotTester::GetInstance()->SetActive(true);
	ShotTester::GetInstance()->SetVerbose(true);

	SpeedTester::GetInstance()->SetActive(true);
	SpeedTester::GetInstance()->SetVerbose(true);
}

void HookBasePlayer(NczPlayer* player)
{
	OnGroundHookListener::HookOnGround(player);
	PlayerRunCommandHookListener::HookPlayerRunCommand(player);
	TeleportHookListener::HookTeleport(player);
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is loaded, load the interface we need from the engine
//---------------------------------------------------------------------------------
bool CNoCheatZPlugin::Load(CreateInterfaceFn _interfaceFactory, CreateInterfaceFn gameServerFactory )
{
	ConnectTier1Libraries( &_interfaceFactory, 1 );
	if(g_pCVar->FindVar("nocheatz_instance"))
	{
		if(g_pCVar->FindVar("nocheatz_instance")->GetInt() == 1)
		{
			Error("[NoCheatZ 4] CNoCheatZPlugin - Error : CNoCheatZPlugin already loaded.\n");
			m_bAlreadyLoaded = true;
			return false;
		}
	}
	//ConnectTier2Libraries( &interfaceFactory, 1 );

	CIFaceManager::GetInstance()->UpdateIFactoryPtr(interfaceFactory, (void*)_interfaceFactory);
	CIFaceManager::GetInstance()->UpdateIFactoryPtr(gameFactory, (void*)gameServerFactory);
	NczPlayerManager::GetInstance()->LoadPlayerManager(); // Mark any present player as PLAYER_CONNECTED

	ConVar_Register( 0 );

	EyeAnglesTester::GetInstance();
	JumpTester::GetInstance();
	ValidationTester::GetInstance();
	ConVarTester::GetInstance();
	ShotTester::GetInstance();
	SpeedTester::GetInstance();

	CIFaceManager::GetInstance()->GetIengine()->ServerExecute();
	CIFaceManager::GetInstance()->GetIengine()->ServerCommand("exec nocheatz.cfg\n");
	CIFaceManager::GetInstance()->GetIengine()->ServerExecute();

	for(int i = 0; i < MAX_PLAYERS; ++i)
	{
		PlayerHandler* ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByIndex(i);
		if(ph->status == PLAYER_CONNECTED)
		{
			HookBasePlayer(ph->playerClass);
			LoadTestersByConfig();
			ValidationTester::GetInstance()->ResetPlayerDataStruct(ph->playerClass);
			JumpTester::GetInstance()->ResetPlayerDataStruct(ph->playerClass);
			EyeAnglesTester::GetInstance()->ResetPlayerDataStruct(ph->playerClass);
			ConVarTester::GetInstance()->ResetPlayerDataStruct(ph->playerClass);
			ShotTester::GetInstance()->ResetPlayerDataStruct(ph->playerClass);
			SpeedTester::GetInstance()->ResetPlayerDataStruct(ph->playerClass);
		}
	}

	//---------------

	//MathLib_Init( 2.2f, 2.2f, 0.0f, 2 );
	
	g_pCVar->FindVar("nocheatz_instance")->SetValue("1");
	return true;
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is unloaded (turned off)
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::Unload( void )
{
	if(BanRequest::GetInstance()->NeedWriteID())
	{
		CIFaceManager::GetInstance()->GetIengine()->ServerCommand("writeid\n");
		CIFaceManager::GetInstance()->GetIengine()->ServerCommand("writeip\n");
		CIFaceManager::GetInstance()->GetIengine()->ServerExecute();
	}

	if(!m_bAlreadyLoaded && g_pCVar)
	{
		ConVar* inst = nullptr;
		inst = g_pCVar->FindVar("nocheatz_instance");
		if(inst) inst->SetValue("0");
	}

	ValidationTester::Delete();
#ifndef NCZ_CSGO
	JumpTester::Delete();
#endif
	EyeAnglesTester::Delete();
	ConVarTester::Delete();
	ShotTester::Delete();
	SpeedTester::Delete();
	NczPlayerManager::Delete();

	CIFaceManager::Delete();
	BanRequest::Delete();

	PlayerRunCommandHookListener::UnhookPlayerRunCommand();
	OnGroundHookListener::UnhookOnGround();
	TeleportHookListener::UnhookTeleport();

	ILogger.Flush();

	ConVar_Unregister( );
	//DisconnectTier2Libraries( );
	DisconnectTier1Libraries( );
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is paused (i.e should stop running but isn't unloaded)
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::Pause( void )
{
}

//---------------------------------------------------------------------------------
// Purpose: called when the plugin is unpaused (i.e should start executing again)
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::UnPause( void )
{
}

//---------------------------------------------------------------------------------
// Purpose: the name of this plugin, returned in "plugin_print" command
//---------------------------------------------------------------------------------
const char *CNoCheatZPlugin::GetPluginDescription( void )
{
	return NCZ_PLUGIN_NAME " v" NCZ_VERSION_STR;
}

//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::LevelInit( char const *pMapName )
{
	ILogger.Flush();
}

//---------------------------------------------------------------------------------
// Purpose: called on level start, when the server is ready to accept client connections
//		edictCount is the number of entities in the level, clientMax is the max client count
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::ServerActivate( edict_t *pEdictList, int edictCount, int clientMax )
{
	Helpers::m_EdictList = pEdictList;
	//Helpers::m_edictCount = edictCount;
	//Helpers::m_clientMax = clientMax;

	NczPlayerManager::GetInstance()->LoadPlayerManager();
}

//---------------------------------------------------------------------------------
// Purpose: called once per server frame, do recurring work here (like checking for timeouts)
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::GameFrame( bool simulating )
{
	BaseFramedTester::OnFrame();
	BanRequest::GetInstance()->Think();
}

//---------------------------------------------------------------------------------
// Purpose: called on level end (as the server is shutting down or going to a new map)
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::LevelShutdown( void ) // !!!!this can get called multiple times per map change
{
	if(BanRequest::GetInstance()->NeedWriteID())
	{
		CIFaceManager::GetInstance()->GetIengine()->ServerCommand("writeid\n");
		CIFaceManager::GetInstance()->GetIengine()->ServerCommand("writeip\n");
		CIFaceManager::GetInstance()->GetIengine()->ServerExecute();
	}
	BaseSystem::UnloadAllSystems();
	ILogger.Flush();
}

//---------------------------------------------------------------------------------
// Purpose: called when a client spawns into a server (i.e as they begin to play)
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::ClientActive( edict_t *pEntity )
{
	Msg("%f : CNoCheatZPlugin::ClientActive\n", Plat_FloatTime());
	NczPlayerManager::GetInstance()->ClientActive(pEntity);

	PlayerHandler* ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByEdict(pEntity);
	if(ph->status > BOT) HookBasePlayer(ph->playerClass);
}

//---------------------------------------------------------------------------------
// Purpose: called when a client leaves a server (or is timed out)
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::ClientDisconnect( edict_t *pEntity )
{
	NczPlayerManager::GetInstance()->ClientDisconnect(pEntity);
    if(		NczPlayerManager::GetInstance()->GetPlayerCount(PLAYER_CONNECTED) 
		  + NczPlayerManager::GetInstance()->GetPlayerCount(PLAYER_IN_TESTS)
										==
			                                                        0   )
	{
		BaseSystem::UnloadAllSystems();
	}
}

//---------------------------------------------------------------------------------
// Purpose: called on 
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::ClientPutInServer( edict_t *pEntity, char const *playername )
{
}

//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::SetCommandClient( int index )
{
	m_iClientCommandIndex = index;
}

//---------------------------------------------------------------------------------
// Purpose: called on level start
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::ClientSettingsChanged( edict_t *pEdict )
{
}

//---------------------------------------------------------------------------------
// Purpose: called when a client joins a server
//---------------------------------------------------------------------------------
PLUGIN_RESULT CNoCheatZPlugin::ClientConnect( bool *bAllowConnect, edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen )
{
#define MAX_CHARS_NAME 32
	Msg("%f - CNoCheatZPlugin::ClientConnect (%s, %s)\n", Plat_FloatTime(), pszName, pszAddress);

	// Scan for overflow in name
	int char_count = 0;
	for(;pszName[char_count] != '\0' && char_count <= MAX_CHARS_NAME; ++char_count);
	if(char_count == MAX_CHARS_NAME)
	{
		*bAllowConnect = false;
		strcpy(reject, "Buffer overflow in name.");
		return PLUGIN_STOP;
	}
	if(char_count > 32)
	{
		*bAllowConnect = false;
		strcpy(reject, "Your name is too long.");
		return PLUGIN_STOP;
	}
	if(Helpers::bStrEq(pszName, "unnamed") || Helpers::bStrEq(pszName, "disconnected"))
	{
		*bAllowConnect = false;
		strcpy(reject, "\0"); // No name, no message. Sorry. :)
		return PLUGIN_STOP;
	}

	NczPlayerManager::GetInstance()->ClientConnect(pEntity);
	NczPlayer* player = NczPlayerManager::GetInstance()->GetPlayerHandlerByEdict(pEntity)->playerClass;
	
	LoadTestersByConfig();
	
	ValidationTester::GetInstance()->ResetPlayerDataStruct(player);
	JumpTester::GetInstance()->ResetPlayerDataStruct(player);
	EyeAnglesTester::GetInstance()->ResetPlayerDataStruct(player);
	ConVarTester::GetInstance()->ResetPlayerDataStruct(player);
	ShotTester::GetInstance()->ResetPlayerDataStruct(player);
	SpeedTester::GetInstance()->ResetPlayerDataStruct(player);
	return PLUGIN_CONTINUE;
}

//---------------------------------------------------------------------------------
// Purpose: called when a client types in a command (only a subset of commands however, not CON_COMMAND's)
//---------------------------------------------------------------------------------
PLUGIN_RESULT CNoCheatZPlugin::ClientCommand( edict_t *pEntity, const CCommand &args )
{
	Msg("ClientCommand(%x, %s)\n", pEntity, args.GetCommandString());
	
	if ( !pEntity || pEntity->IsFree() ) 
	{
		return PLUGIN_CONTINUE;
	}

	NczPlayer* myPlayer = NczPlayerManager::GetInstance()->GetPlayerHandlerByEdict(pEntity)->playerClass;
	/*ActionID result = HashTable::GetInstance()->ScanCommandString(args.GetCommandString());
	if(result > SAFE)
	{
		if(result == BAN)
		{
			myPlayer->Ban();
		}
		if(result == KICK)
		{
			myPlayer->Kick();
		}
		return PLUGIN_STOP;
	}*/

	return PLUGIN_CONTINUE;
}

//---------------------------------------------------------------------------------
// Purpose: called when a client is authenticated
//---------------------------------------------------------------------------------
PLUGIN_RESULT CNoCheatZPlugin::NetworkIDValidated( const char *pszUserName, const char *pszNetworkID )
{
	NczPlayer* player = NczPlayerManager::GetInstance()->GetPlayerHandlerBySteamID(pszNetworkID)->playerClass;
	ValidationTester::GetInstance()->SetValidated(player);
	
	return PLUGIN_CONTINUE;
}

//---------------------------------------------------------------------------------
// Purpose: called when a cvar value query is finished
//---------------------------------------------------------------------------------
void CNoCheatZPlugin::OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_t *pPlayerEntity, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue )
{
	PlayerHandler* ph = NczPlayerManager::GetInstance()->GetPlayerHandlerByEdict(pPlayerEntity);
	if(ph->status < ConVarTester::GetInstance()->GetFilter()) return;

	ConVarTester::GetInstance()->OnQueryCvarValueFinished(ph->playerClass, eStatus, pCvarName, pCvarValue);
}

void CNoCheatZPlugin::OnEdictAllocated( edict_t *edict )
{
	//Msg("OnEdictAllocated(%x)\n", edict);
}
void CNoCheatZPlugin::OnEdictFreed( const edict_t *edict  )
{
	//Msg("OnEdictFreed(%x)\n", edict);
}

```

`server-plugin/Code/plugin.h`:

```h
#include <stdio.h>
#include "engine/iserverplugin.h"
#include "tier1/tier1.h"
#include "Misc/temp_Singleton.h"

#ifndef CNOCHEATZ_PLUGIN
#define CNOCHEATZ_PLUGIN

class CNoCheatZPlugin: public IServerPluginCallbacks, public Singleton<CNoCheatZPlugin>
{
public:
	// IServerPluginCallbacks methods
	virtual bool			Load(CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory );
	virtual void			Unload( void );
	virtual void			Pause( void );
	virtual void			UnPause( void );
	virtual const char     *GetPluginDescription( void );      
	virtual void			LevelInit( char const *pMapName );
	virtual void			ServerActivate( edict_t *pEdictList, int edictCount, int clientMax );
	virtual void			GameFrame( bool simulating );
	virtual void			LevelShutdown( void );
	virtual void			ClientActive( edict_t *pEntity );
#ifdef NCZ_CSGO
	virtual void            ClientFullyConnect(edict_t *) {};
#endif
	virtual void			ClientDisconnect( edict_t *pEntity );
	virtual void			ClientPutInServer( edict_t *pEntity, char const *playername );
	virtual void			SetCommandClient( int index );
	virtual void			ClientSettingsChanged( edict_t *pEdict );
	virtual PLUGIN_RESULT	ClientConnect( bool *bAllowConnect, edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen );
#ifndef NCZ_EP1
	virtual PLUGIN_RESULT	ClientCommand( edict_t *pEntity, const CCommand &args );
#else
	virtual PLUGIN_RESULT	ClientCommand( edict_t *pEntity );
#endif
	virtual PLUGIN_RESULT	NetworkIDValidated( const char *pszUserName, const char *pszNetworkID );
	virtual void			OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_t *pPlayerEntity, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue );

	// added with version 3 of the interface.
	virtual void			OnEdictAllocated( edict_t *edict );
	virtual void			OnEdictFreed( const edict_t *edict  );

	virtual int GetCommandIndex() { return m_iClientCommandIndex; }

	CNoCheatZPlugin();
	~CNoCheatZPlugin();

private:
	CNoCheatZPlugin(const CNoCheatZPlugin & toCopy);
	CNoCheatZPlugin & operator =(const CNoCheatZPlugin & toCopy);
	int m_iClientCommandIndex;
	bool m_bAlreadyLoaded;
};

#endif

```

`server-plugin/Makefile`:

```
BASE = ..
PROJECT = server-plugin

ifeq "$(GAME)" "CSS"
	SDK_VERSION = source-sdk-2013/mp/src
	SDK_DEF = -DCSTRIKE_DLL -DNO_MALLOC_OVERRIDE -DGNUC -DPOSIX -DCOMPILER_GCC
endif
ifeq "$(GAME)" "CSP"
	SDK_VERSION = ep1-sdk
	SDK_DEF = -DPOSIX -DCOMPILER_GCC -DGNUC 
endif
ifeq "$(GAME)" "CSGO"
	SDK_VERSION = csgo-sdk
	SDK_DEF = -DPOSIX -DCOMPILER_GCC -DGNUC 
endif
ifeq "$(GAME)" "BMS"
	SDK_VERSION = bms-sdk
	SDK_DEF = -DPOSIX -DCOMPILER_GCC -DGNUC 
endif

SDK_DIR = $(BASE)/$(SDK_VERSION)
PROJECT_DIR = $(BASE)/$(PROJECT)
SRC_DIR = $(PROJECT_DIR)/Code

OTHER_PREPROCESSORS = -DNCZ_$(GAME) $(SDK_DEF)

# Compilateur
CXX = g++

# Nom du fichier binaire de sortie
BINARY_NAME = nocheatzX.so

# Dossier de sortie du fichier binaire
BUILD_DIR = $(BASE)/Builds/$(GAME)
BINARY_DIR = $(BUILD_DIR)/addons/NoCheatZ/

# Dossiers de sortie
RELEASE_DIR = Release/linux
DEBUG_DIR = Debug/linux

# Dossier contenant les librairies dynamiques
SRCDS_BIN_DIR = ./bin

# Dossier contenant les librairies statiques
SRCDS_A_DIR = $(SDK_DIR)/lib/public/linux32
ifeq "$(GAME)" "CSGO"
	SRCDS_A_DIR = $(SDK_DIR)/lib/linux
endif

# Paramètres du compilateur
ARCH_CFLAGS =   -mtune=i486 -march=pentium -mmmx
USER_CFLAGS =   -DTIXML_USE_TICPP
BASE_CFLAGS =   -msse \
		-D_LINUX \
		-D_alloca=alloca \
		-fPIC \
		-Wno-deprecated \
		-msse \
		-fpermissive

OPT_FLAGS = -O3 -funroll-loops -s -pipe $(OTHER_PREPROCESSORS)
DEBUG_FLAGS = -g -ggdb3 -O0 -D_DEBUG $(OTHER_PREPROCESSORS)               
# Fichiers à compiler
SRC= $(wildcard *.cpp) $(wildcard */*.cpp) $(wildcard */*/*.cpp) $(wildcard */*/*/*.cpp)                      

# Fichiers à lier
ifeq "$(GAME)" "CSS"
	LINK_SO =       $(SRCDS_BIN_DIR)/libtier0_srv.so \
			$(SRCDS_BIN_DIR)/libvstdlib_srv.so

	LINK_A =        $(SRCDS_A_DIR)/tier1.a \
			$(SRCDS_A_DIR)/mathlib.a
endif

ifeq "$(GAME)" "CSGO"
	LINK_SO =       $(SRCDS_BIN_DIR)/libtier0.so \
			$(SRCDS_BIN_DIR)/libvstdlib.so

	LINK_A =        $(SRCDS_A_DIR)/tier1_i486.a \
			$(SRCDS_A_DIR)/mathlib_i486.a \
			$(SRCDS_A_DIR)/interfaces_i486.a \
			$(SDK_DIR)/lib/linux32/release/libprotobuf.a
endif

ifeq "$(GAME)" "CSP"
	LINK_SO =       $(SRCDS_BIN_DIR)/tier0_i486.so \
			$(SRCDS_BIN_DIR)/vstdlib_i486.so

	LINK_A =        $(SRCDS_A_DIR)/tier1_i486.a \
			$(SRCDS_A_DIR)/mathlib_i486.a
endif

LINK = -lm -ldl $(LINK_A) $(LINK_SO)

# Dossiers des fichiers inclus
INCLUDE =       -I$(SRC_DIR) \
		-I$(SDK_DIR)/public \
		-I$(SDK_DIR)/public/game/server \
		-I$(SDK_DIR)/public/engine \
		-I$(SDK_DIR)/public/tier0 \
		-I$(SDK_DIR)/public/tier1 \
		-I$(SDK_DIR)/common
ifeq "$(GAME)" "CSGO"
		INCLUDE += -I$(SDK_DIR)/interfaces \
			-I$(SDK_DIR)/common/protobuf-2.5.0/src \
			-I$(SDK_DIR)/public/game/shared/csgo/protobuf \
			-I$(SDK_DIR)/public/engine/protobuf
endif
                        
# Règles de compilation

ifeq "$(DEBUG)" "false"
	BIN_DIR = $(RELEASE_DIR)
	CFLAGS = $(OPT_FLAGS)
else
	BIN_DIR = $(DEBUG_DIR)
	CFLAGS = $(DEBUG_FLAGS)
endif
CFLAGS += $(USER_CFLAGS) $(BASE_CFLAGS) $(ARCH_CFLAGS)

OBJECTS := $(SRC:%.cpp=$(BIN_DIR)/%.o)

compile_object = \
	@mkdir -p $(2); \
	echo "$(1) => $(3)"; \
	$(CXX) $(INCLUDE) $(CFLAGS) -o $(3) -c $(1) 2> "error.txt";

$(BIN_DIR)/%.o: %.cpp %.h
	$(call compile_object, $<, $(@D), $@)

$(BIN_DIR)/%.o: %.cpp
	$(call compile_object, $<, $(@D), $@)

all: $(OBJECTS)
	@$(CXX) $(INCLUDE) $(CFLAGS) $(OBJECTS) $(LINK) -shared -o $(BINARY_DIR)/$(BINARY_NAME)
        
release: prepare-build
	@$(MAKE) all DEBUG=false
	@rm -rf $(SRC_DIR)/temp_extern/
	
debug: prepare-build
	@$(MAKE) all DEBUG=true
	@rm -rf $(SRC_DIR)/temp_extern/

clean:
	@rm -rf $(RELEASE_DIR)
	@rm -rf $(DEBUG_DIR)
	@rm -rf $(BINARY_DIR)/$(BINARY_NAME)

prepare-build:
	@mkdir -p $(BUILD_DIR)/addons/NoCheatZ/
	@mkdir -p $(BUILD_DIR)/cfg/
	@mkdir -p $(BUILD_DIR)/logs/NoCheatZ_4_Logs/
	@cp ./Res/nocheatz.vdf $(BUILD_DIR)/addons/
	@cp ./Res/nocheatz-$(GAME).cfg $(BUILD_DIR)/cfg/nocheatz.cfg ;true
	@mkdir -p $(SRC_DIR)/temp_extern/
	@cp -R $(SDK_DIR)/public/engine/protobuf/ $(SRC_DIR)/temp_extern/ ;true
	@cp -R $(SDK_DIR)/public/game/shared/csgo/protobuf/ $(SRC_DIR)/temp_extern/ ;true
	@rename 's/.cc$$/.cpp/g' $(SRC_DIR)/temp_extern/**/*.cc
        
.PHONY: clean

```

`server-plugin/Res/nocheatz.vdf`:

```vdf
Plugin
{
	file "addons/NoCheatZ/nocheatzX"
}
```

`server-plugin/nocheatz.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug-CSGO|Win32">
      <Configuration>Debug-CSGO</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug-CSS|Win32">
      <Configuration>Debug-CSS</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release-CSGO|Win32">
      <Configuration>Release-CSGO</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release-CSS|Win32">
      <Configuration>Release-CSS</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectName>nocheatzX</ProjectName>
    <ProjectGuid>{B6572CBE-7C7F-4FFF-94DE-AFBBBAB11C64}</ProjectGuid>
    <RootNamespace>Serverplugin_empty</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug-CSS|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug-CSS|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug-CSS|Win32'">
    <OutDir>C:\steamcmd\CSS\cstrike\addons\NoCheatZ\</OutDir>
    <IntDir>Debug\</IntDir>
    <PreBuildEventUseInBuild>true</PreBuildEventUseInBuild>
    <PreLinkEventUseInBuild>true</PreLinkEventUseInBuild>
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">
    <OutDir>C:\steamcmd\CSGO\cstrike\addons\NoCheatZ\</OutDir>
    <IntDir>Debug\</IntDir>
    <PreBuildEventUseInBuild>true</PreBuildEventUseInBuild>
    <PreLinkEventUseInBuild>true</PreLinkEventUseInBuild>
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">
    <OutDir>.\Release\</OutDir>
    <IntDir>.\Release\</IntDir>
    <PreBuildEventUseInBuild>true</PreBuildEventUseInBuild>
    <PreLinkEventUseInBuild>true</PreLinkEventUseInBuild>
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">
    <OutDir>.\Release\</OutDir>
    <IntDir>.\Release\</IntDir>
    <PreBuildEventUseInBuild>true</PreBuildEventUseInBuild>
    <PreLinkEventUseInBuild>true</PreLinkEventUseInBuild>
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug-CSS|Win32'">
    <PreBuildEvent>
      <Command />
    </PreBuildEvent>
    <CustomBuildStep>
      <Command>if exist ..\..\..\game\bin\"$(TargetName)".dll attrib -r ..\..\..\game\bin\"$(TargetName)".dll
copy "$(TargetPath)" ..\..\..\game\bin\"$(TargetName)".dll
if exist ..\..\..\game\bin\"$(TargetName)".pdb attrib -r ..\..\..\game\bin\"$(TargetName)".pdb
copy "$(TargetPath)" ..\..\..\game\bin\"$(TargetName)".pdb
</Command>
      <Outputs>..\..\..\game\bin\serverplugin_empty.dll;..\..\..\game\bin\serverplugin_empty.pdb;%(Outputs)</Outputs>
    </CustomBuildStep>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>.\Code;..\source-sdk-2013\mp\src\common;..\source-sdk-2013\mp\src\public;..\source-sdk-2013\mp\src\public\tier0;..\source-sdk-2013\mp\src\public\tier1;..\source-sdk-2013\mp\src\game\server;..\source-sdk-2013\mp\src\game\shared;..\source-sdk-2013\mp\src\tier1;..\source-sdk-2013\mp\src\public\engine;..\source-sdk-2013\mp\src\public\filesystem;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_WIN32;_DEBUG;DEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_MBCS;_HAS_ITERATOR_DEBUGGING=0;NCZ_CSS;PLATFORM_WINDOWS_PC;CSTRIKE_DLL;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <MinimalRebuild>true</MinimalRebuild>
      <ExceptionHandling>Sync</ExceptionHandling>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
      <PrecompiledHeader />
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)</ProgramDataBaseFileName>
      <GenerateXMLDocumentationFiles>false</GenerateXMLDocumentationFiles>
      <BrowseInformation>true</BrowseInformation>
      <BrowseInformationFile>$(IntDir)</BrowseInformationFile>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <CompileAs>CompileAsCpp</CompileAs>
      <ErrorReporting>Prompt</ErrorReporting>
      <ShowIncludes>false</ShowIncludes>
      <MultiProcessorCompilation>false</MultiProcessorCompilation>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ShowProgress>NotSet</ShowProgress>
      <OutputFile>$(TargetPath)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\common;..\..\lib\public;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libc;libcd;libcmt;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>$(IntDir)$(TargetName).map</MapFileName>
      <SubSystem>Windows</SubSystem>
      <BaseAddress>
      </BaseAddress>
      <TargetMachine>MachineX86</TargetMachine>
      <LinkErrorReporting>PromptImmediately</LinkErrorReporting>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
    <Manifest>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </Manifest>
    <Xdcmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </Xdcmake>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(OutDir)serverplugin_empty.bsc</OutputFile>
      <PreserveSbr>true</PreserveSbr>
    </Bscmake>
    <PostBuildEvent>
      <Command />
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <CustomBuildStep>
      <Command>if exist ..\..\..\game\bin\"$(TargetName)".dll attrib -r ..\..\..\game\bin\"$(TargetName)".dll
copy "$(TargetPath)" ..\..\..\game\bin\"$(TargetName)".dll
if exist ..\..\..\game\bin\"$(TargetName)".pdb attrib -r ..\..\..\game\bin\"$(TargetName)".pdb
copy "$(TargetPath)" ..\..\..\game\bin\"$(TargetName)".pdb
</Command>
      <Outputs>..\..\..\game\bin\serverplugin_empty.dll;..\..\..\game\bin\serverplugin_empty.pdb;%(Outputs)</Outputs>
    </CustomBuildStep>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\csgo-sdk\public\game\shared\csgo\protobuf;..\csgo-sdk\public\engine\protobuf;..\csgo-sdk\common\protobuf-2.5.0\src;.\Code;..\csgo-sdk\common;..\csgo-sdk\public;..\csgo-sdk\public\tier0;..\csgo-sdk\public\tier1;..\csgo-sdk\game\server;..\csgo-sdk\game\shared;..\csgo-sdk\tier1;..\csgo-sdk\public\engine;..\csgo-sdk\public\filesystem;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_WIN32;_DEBUG;DEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_MBCS;_HAS_ITERATOR_DEBUGGING=0;NCZ_CSGO;PLATFORM_WINDOWS_PC;CSTRIKE_DLL;WIN32_LEAN_AND_MEAN;COMPILER_MSVC;COMPILER_MSVC32;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <MinimalRebuild>false</MinimalRebuild>
      <ExceptionHandling>Sync</ExceptionHandling>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)</ProgramDataBaseFileName>
      <GenerateXMLDocumentationFiles>false</GenerateXMLDocumentationFiles>
      <BrowseInformation>true</BrowseInformation>
      <BrowseInformationFile>$(IntDir)</BrowseInformationFile>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <CompileAs>CompileAsCpp</CompileAs>
      <ErrorReporting>Prompt</ErrorReporting>
      <ShowIncludes>false</ShowIncludes>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ShowProgress>NotSet</ShowProgress>
      <OutputFile>$(TargetPath)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\csgo-sdk\lib\win32\debug\vs2012\;..\csgo-sdk\lib\common;..\csgo-sdk\lib\public;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libc;libcd;libcmt;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>$(IntDir)$(TargetName).map</MapFileName>
      <SubSystem>Windows</SubSystem>
      <BaseAddress>
      </BaseAddress>
      <TargetMachine>MachineX86</TargetMachine>
      <LinkErrorReporting>PromptImmediately</LinkErrorReporting>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
    <Manifest>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </Manifest>
    <Xdcmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </Xdcmake>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(OutDir)serverplugin_empty.bsc</OutputFile>
      <PreserveSbr>true</PreserveSbr>
    </Bscmake>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">
    <PreBuildEvent>
      <Command />
    </PreBuildEvent>
    <CustomBuildStep>
      <Command>if exist ..\..\..\game\bin\"$(TargetName)".dll attrib -r ..\..\..\game\bin\"$(TargetName)".dll
copy "$(TargetPath)" ..\..\..\game\bin\"$(TargetName)".dll
if exist ..\..\..\game\bin\"$(TargetName)".pdb attrib -r ..\..\..\game\bin\"$(TargetName)".pdb
copy "$(TargetPath)" ..\..\..\game\bin\"$(TargetName)".pdb
</Command>
      <Outputs>..\..\..\game\bin\serverplugin_empty.dll;..\..\..\game\bin\serverplugin_empty.pdb;%(Outputs)</Outputs>
    </CustomBuildStep>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>.\Code;..\source-sdk-2013\mp\src\common;..\source-sdk-2013\mp\src\public;..\source-sdk-2013\mp\src\public\tier0;..\source-sdk-2013\mp\src\public\tier1;..\source-sdk-2013\mp\src\game\server;..\source-sdk-2013\mp\src\game\shared;..\source-sdk-2013\mp\src\tier1;..\source-sdk-2013\mp\src\public\engine;..\source-sdk-2013\mp\src\public\filesystem;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;serverplugin_emptyONLY;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling />
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
      <PrecompiledHeader />
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)</ProgramDataBaseFileName>
      <GenerateXMLDocumentationFiles>false</GenerateXMLDocumentationFiles>
      <BrowseInformation />
      <BrowseInformationFile>$(IntDir)</BrowseInformationFile>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CompileAs>CompileAsCpp</CompileAs>
      <ErrorReporting>Prompt</ErrorReporting>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ShowProgress>NotSet</ShowProgress>
      <OutputFile>$(OutDir)serverplugin_empty.dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\common;..\..\lib\public;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libc;libcd;libcmtd;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>$(IntDir)$(TargetName).map</MapFileName>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <BaseAddress>
      </BaseAddress>
      <TargetMachine>MachineX86</TargetMachine>
      <LinkErrorReporting>PromptImmediately</LinkErrorReporting>
    </Link>
    <Manifest>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </Manifest>
    <Xdcmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </Xdcmake>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(OutDir)serverplugin_empty.bsc</OutputFile>
    </Bscmake>
    <PostBuildEvent>
      <Command />
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <CustomBuildStep>
      <Command>if exist ..\..\..\game\bin\"$(TargetName)".dll attrib -r ..\..\..\game\bin\"$(TargetName)".dll
copy "$(TargetPath)" ..\..\..\game\bin\"$(TargetName)".dll
if exist ..\..\..\game\bin\"$(TargetName)".pdb attrib -r ..\..\..\game\bin\"$(TargetName)".pdb
copy "$(TargetPath)" ..\..\..\game\bin\"$(TargetName)".pdb
</Command>
      <Outputs>..\..\..\game\bin\serverplugin_empty.dll;..\..\..\game\bin\serverplugin_empty.pdb;%(Outputs)</Outputs>
    </CustomBuildStep>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>.\Code;..\source-sdk-2013\mp\src\common;..\source-sdk-2013\mp\src\public;..\source-sdk-2013\mp\src\public\tier0;..\source-sdk-2013\mp\src\public\tier1;..\source-sdk-2013\mp\src\game\server;..\source-sdk-2013\mp\src\game\shared;..\source-sdk-2013\mp\src\tier1;..\source-sdk-2013\mp\src\public\engine;..\source-sdk-2013\mp\src\public\filesystem;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_MBCS;_HAS_ITERATOR_DEBUGGING=0;NCZ_CSGO;PLATFORM_WINDOWS_PC;CSTRIKE_DLL;WIN32_LEAN_AND_MEAN;COMPILER_MSVC;COMPILER_MSVC32;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>
      </ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)</ProgramDataBaseFileName>
      <GenerateXMLDocumentationFiles>false</GenerateXMLDocumentationFiles>
      <BrowseInformation>
      </BrowseInformation>
      <BrowseInformationFile>$(IntDir)</BrowseInformationFile>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CompileAs>CompileAsCpp</CompileAs>
      <ErrorReporting>Prompt</ErrorReporting>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ShowProgress>NotSet</ShowProgress>
      <OutputFile>$(OutDir)serverplugin_empty.dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\common;..\..\lib\public;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libc;libcd;libcmtd;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>$(IntDir)$(TargetName).map</MapFileName>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <BaseAddress>
      </BaseAddress>
      <TargetMachine>MachineX86</TargetMachine>
      <LinkErrorReporting>PromptImmediately</LinkErrorReporting>
    </Link>
    <Manifest>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </Manifest>
    <Xdcmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </Xdcmake>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(OutDir)serverplugin_empty.bsc</OutputFile>
    </Bscmake>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="Makefile" />
    <None Include="Res\nocheatz.vdf" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\csgo-sdk\public\engine\protobuf\netmessages.pb.cc">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\csgo-sdk\public\game\shared\csgo\protobuf\cstrike15_usermessages.pb.cc">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\csgo-sdk\public\game\shared\csgo\protobuf\cstrike15_usermessage_helpers.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Code\Hooks\Hook.cpp" />
    <ClCompile Include="Code\Hooks\OnGroundHookListener.cpp" />
    <ClCompile Include="Code\Hooks\PlayerRunCommandHookListener.cpp" />
    <ClCompile Include="Code\Hooks\TeleportHookListener.cpp" />
    <ClCompile Include="Code\Misc\Helpers.cpp" />
    <ClCompile Include="Code\Misc\IFaceManager.cpp" />
    <ClCompile Include="Code\Misc\MRecipientFilter.cpp" />
    <ClCompile Include="Code\Players\NczFilteredPlayersList.cpp" />
    <ClCompile Include="Code\Players\NczPlayer.cpp" />
    <ClCompile Include="Code\Players\NczPlayerManager.cpp" />
    <ClCompile Include="Code\plugin.cpp" />
    <ClCompile Include="Code\Systems\BanRequest.cpp" />
    <ClCompile Include="Code\Systems\BaseSystem.cpp" />
    <ClCompile Include="Code\Systems\Logger.cpp" />
    <ClCompile Include="Code\Systems\Testers\ShotTester.cpp" />
    <ClCompile Include="Code\Systems\Testers\BaseFramedTester.cpp" />
    <ClCompile Include="Code\Systems\Testers\BaseTimedTester.cpp" />
    <ClCompile Include="Code\Systems\Testers\JumpTester.cpp" />
    <ClCompile Include="Code\Systems\Testers\ConVarTester.cpp" />
    <ClCompile Include="Code\Systems\Testers\EyeAnglesTester.cpp" />
    <ClCompile Include="Code\Systems\Testers\SpeedTester.cpp" />
    <ClCompile Include="Code\Systems\Testers\ValidationTester.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Code\Hooks\Hook.h" />
    <ClInclude Include="Code\Hooks\OnGroundHookListener.h" />
    <ClInclude Include="Code\Hooks\PlayerRunCommandHookListener.h" />
    <ClInclude Include="Code\Hooks\TeleportHookListener.h" />
    <ClInclude Include="Code\Misc\EventManagerWrap.h" />
    <ClInclude Include="Code\Misc\Helpers.h" />
    <ClInclude Include="Code\Misc\IFaceManager.h" />
    <ClInclude Include="Code\Misc\include_windows_headers.h" />
    <ClInclude Include="Code\Misc\MRecipientFilter.h" />
    <ClInclude Include="Code\Misc\temp_BaseDataStruct.h" />
    <ClInclude Include="Code\Misc\temp_Singleton.h" />
    <ClInclude Include="Code\Misc\Types.h" />
    <ClInclude Include="Code\Players\NczFilteredPlayersList.h" />
    <ClInclude Include="Code\Players\NczPlayer.h" />
    <ClInclude Include="Code\Players\NczPlayerManager.h" />
    <ClInclude Include="Code\Players\temp_PlayerDataStruct.h" />
    <ClInclude Include="Code\plugin.h" />
    <ClInclude Include="Code\Preprocessors.h" />
    <ClInclude Include="Code\Systems\BanRequest.h" />
    <ClInclude Include="Code\Systems\BaseSystem.h" />
    <ClInclude Include="Code\Systems\Logger.h" />
    <ClInclude Include="Code\Systems\Testers\ShotTester.h" />
    <ClInclude Include="Code\Systems\Testers\BaseFramedTester.h" />
    <ClInclude Include="Code\Systems\Testers\BaseTimedTester.h" />
    <ClInclude Include="Code\Systems\Testers\JumpTester.h" />
    <ClInclude Include="Code\Systems\Testers\ConVarTester.h" />
    <ClInclude Include="Code\Systems\Testers\Detections\temp_BaseDetection.h" />
    <ClInclude Include="Code\Systems\Testers\EyeAnglesTester.h" />
    <ClInclude Include="Code\Systems\Testers\SpeedTester.h" />
    <ClInclude Include="Code\Systems\Testers\ValidationTester.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="..\csgo-sdk\lib\public\interfaces.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\mathlib.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\raytrace.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\tier0.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\tier1.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\tier2.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\vstdlib.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSS|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\mathlib.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\raytrace.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\tier0.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\tier1.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\tier2.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\vstdlib.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug-CSGO|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-CSGO|Win32'">true</ExcludedFromBuild>
    </Library>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`server-plugin/nocheatz.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Link Libraries">
      <UniqueIdentifier>{48b933d1-0ee3-49bd-a210-302a0fd62f0b}</UniqueIdentifier>
      <Extensions>lib</Extensions>
    </Filter>
    <Filter Include="Resources">
      <UniqueIdentifier>{a49b0cc0-9e3e-4df1-99eb-450d891a9828}</UniqueIdentifier>
    </Filter>
    <Filter Include="Code">
      <UniqueIdentifier>{494a2659-d50f-4a89-b00a-ba4eb0303ccd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Code\Players">
      <UniqueIdentifier>{1e5072cd-4189-4a38-b1ba-98cb02c32964}</UniqueIdentifier>
    </Filter>
    <Filter Include="Code\Systems">
      <UniqueIdentifier>{f7d33d2a-d95c-42c0-aa21-cf26f6f4680c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Code\Hooks">
      <UniqueIdentifier>{0b158ab4-982f-4a7f-a96b-a346fea5301a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Code\Misc">
      <UniqueIdentifier>{535eff60-6da9-4b19-bef4-15585a3e84d6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Code\Systems\Testers">
      <UniqueIdentifier>{f556038f-1c52-4c3d-ab6a-abea9fd5eabe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Code\protobuf">
      <UniqueIdentifier>{ce971a8c-d93e-44b8-9595-5a0e77f22287}</UniqueIdentifier>
    </Filter>
    <Filter Include="Link Libraries\CSS">
      <UniqueIdentifier>{3a0490f3-67ce-4da8-9ed3-f019a0c7a05e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Link Libraries\CSGO">
      <UniqueIdentifier>{89df960f-5808-4673-970b-a400c20b64da}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="Res\nocheatz.vdf">
      <Filter>Resources</Filter>
    </None>
    <None Include="Makefile">
      <Filter>Resources</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Code\plugin.cpp">
      <Filter>Code</Filter>
    </ClCompile>
    <ClCompile Include="Code\Hooks\Hook.cpp">
      <Filter>Code\Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Code\Hooks\OnGroundHookListener.cpp">
      <Filter>Code\Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Code\Hooks\PlayerRunCommandHookListener.cpp">
      <Filter>Code\Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Code\Hooks\TeleportHookListener.cpp">
      <Filter>Code\Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Code\Misc\Helpers.cpp">
      <Filter>Code\Misc</Filter>
    </ClCompile>
    <ClCompile Include="Code\Misc\IFaceManager.cpp">
      <Filter>Code\Misc</Filter>
    </ClCompile>
    <ClCompile Include="Code\Players\NczFilteredPlayersList.cpp">
      <Filter>Code\Players</Filter>
    </ClCompile>
    <ClCompile Include="Code\Players\NczPlayer.cpp">
      <Filter>Code\Players</Filter>
    </ClCompile>
    <ClCompile Include="Code\Players\NczPlayerManager.cpp">
      <Filter>Code\Players</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Testers\BaseFramedTester.cpp">
      <Filter>Code\Systems\Testers</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Testers\BaseTimedTester.cpp">
      <Filter>Code\Systems\Testers</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Testers\EyeAnglesTester.cpp">
      <Filter>Code\Systems\Testers</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Testers\ValidationTester.cpp">
      <Filter>Code\Systems\Testers</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\BaseSystem.cpp">
      <Filter>Code\Systems</Filter>
    </ClCompile>
    <ClCompile Include="Code\Misc\MRecipientFilter.cpp">
      <Filter>Code\Misc</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\BanRequest.cpp">
      <Filter>Code\Systems</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Testers\ConVarTester.cpp">
      <Filter>Code\Systems\Testers</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Logger.cpp">
      <Filter>Code\Systems</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Testers\ShotTester.cpp">
      <Filter>Code\Systems\Testers</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Testers\JumpTester.cpp">
      <Filter>Code\Systems\Testers</Filter>
    </ClCompile>
    <ClCompile Include="Code\Systems\Testers\SpeedTester.cpp">
      <Filter>Code\Systems\Testers</Filter>
    </ClCompile>
    <ClCompile Include="..\csgo-sdk\public\engine\protobuf\netmessages.pb.cc">
      <Filter>Code\protobuf</Filter>
    </ClCompile>
    <ClCompile Include="..\csgo-sdk\public\game\shared\csgo\protobuf\cstrike15_usermessage_helpers.cpp">
      <Filter>Code\protobuf</Filter>
    </ClCompile>
    <ClCompile Include="..\csgo-sdk\public\game\shared\csgo\protobuf\cstrike15_usermessages.pb.cc">
      <Filter>Code\protobuf</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Code\plugin.h">
      <Filter>Code</Filter>
    </ClInclude>
    <ClInclude Include="Code\Hooks\Hook.h">
      <Filter>Code\Hooks</Filter>
    </ClInclude>
    <ClInclude Include="Code\Hooks\OnGroundHookListener.h">
      <Filter>Code\Hooks</Filter>
    </ClInclude>
    <ClInclude Include="Code\Hooks\PlayerRunCommandHookListener.h">
      <Filter>Code\Hooks</Filter>
    </ClInclude>
    <ClInclude Include="Code\Hooks\TeleportHookListener.h">
      <Filter>Code\Hooks</Filter>
    </ClInclude>
    <ClInclude Include="Code\Misc\Helpers.h">
      <Filter>Code\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Code\Misc\IFaceManager.h">
      <Filter>Code\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Code\Misc\Types.h">
      <Filter>Code\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Code\Players\NczFilteredPlayersList.h">
      <Filter>Code\Players</Filter>
    </ClInclude>
    <ClInclude Include="Code\Players\NczPlayer.h">
      <Filter>Code\Players</Filter>
    </ClInclude>
    <ClInclude Include="Code\Players\NczPlayerManager.h">
      <Filter>Code\Players</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\BaseFramedTester.h">
      <Filter>Code\Systems\Testers</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\BaseTimedTester.h">
      <Filter>Code\Systems\Testers</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\EyeAnglesTester.h">
      <Filter>Code\Systems\Testers</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\ValidationTester.h">
      <Filter>Code\Systems\Testers</Filter>
    </ClInclude>
    <ClInclude Include="Code\Players\temp_PlayerDataStruct.h">
      <Filter>Code\Players</Filter>
    </ClInclude>
    <ClInclude Include="Code\Misc\temp_BaseDataStruct.h">
      <Filter>Code\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Code\Misc\temp_Singleton.h">
      <Filter>Code\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\BaseSystem.h">
      <Filter>Code\Systems</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\Detections\temp_BaseDetection.h">
      <Filter>Code\Systems</Filter>
    </ClInclude>
    <ClInclude Include="Code\Misc\MRecipientFilter.h">
      <Filter>Code\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\BanRequest.h">
      <Filter>Code\Systems</Filter>
    </ClInclude>
    <ClInclude Include="Code\Misc\include_windows_headers.h">
      <Filter>Code\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Code\Preprocessors.h">
      <Filter>Code</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\ConVarTester.h">
      <Filter>Code\Systems\Testers</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Logger.h">
      <Filter>Code\Systems</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\ShotTester.h">
      <Filter>Code\Systems\Testers</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\JumpTester.h">
      <Filter>Code\Systems\Testers</Filter>
    </ClInclude>
    <ClInclude Include="Code\Systems\Testers\SpeedTester.h">
      <Filter>Code\Systems\Testers</Filter>
    </ClInclude>
    <ClInclude Include="Code\Misc\EventManagerWrap.h">
      <Filter>Code\Misc</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\mathlib.lib">
      <Filter>Link Libraries\CSS</Filter>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\raytrace.lib">
      <Filter>Link Libraries\CSS</Filter>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\tier0.lib">
      <Filter>Link Libraries\CSS</Filter>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\tier1.lib">
      <Filter>Link Libraries\CSS</Filter>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\tier2.lib">
      <Filter>Link Libraries\CSS</Filter>
    </Library>
    <Library Include="..\source-sdk-2013\mp\src\lib\public\vstdlib.lib">
      <Filter>Link Libraries\CSS</Filter>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\interfaces.lib">
      <Filter>Link Libraries\CSGO</Filter>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\mathlib.lib">
      <Filter>Link Libraries\CSGO</Filter>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\raytrace.lib">
      <Filter>Link Libraries\CSGO</Filter>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\tier0.lib">
      <Filter>Link Libraries\CSGO</Filter>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\tier1.lib">
      <Filter>Link Libraries\CSGO</Filter>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\tier2.lib">
      <Filter>Link Libraries\CSGO</Filter>
    </Library>
    <Library Include="..\csgo-sdk\lib\public\vstdlib.lib">
      <Filter>Link Libraries\CSGO</Filter>
    </Library>
  </ItemGroup>
</Project>
```