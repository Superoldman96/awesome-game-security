Project Path: arc_gmh5225_hwid_spoofer_4zt_0ypd

Source Tree:

```txt
arc_gmh5225_hwid_spoofer_4zt_0ypd
├── HWID.cpp
├── HWID.h
├── HWID_Spoofer.sln
├── HWID_Spoofer.vcxproj
├── HWID_Spoofer.vcxproj.filters
├── HWID_Spoofer.vcxproj.user
├── Main.cpp
├── NT.cpp
├── NT.h
├── README.md
├── util.cpp
└── util.h

```

`HWID.cpp`:

```cpp
#include "HWID.h"
#include "util.h"
#include <ntdddisk.h>

NTSTATUS ( *originalDeviceControl )( PDEVICE_OBJECT , PIRP ) {};

NTSTATUS smartRcvDriveDataCompletion ( PDEVICE_OBJECT deviceObject , PIRP irp , HWID::CompletionRoutineInfo* context ) {
	const auto ioStack = IoGetCurrentIrpStackLocation ( irp );

	if ( ioStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof ( SENDCMDOUTPARAMS ) ) {
		const auto serial = reinterpret_cast< PIDINFO >( reinterpret_cast< PSENDCMDOUTPARAMS >(
			irp->AssociatedIrp.SystemBuffer )->bBuffer )->sSerialNumber;

		memset ( serial , 0 , sizeof ( CHAR ) );
	}

	if ( context->oldRoutine && irp->StackCount > 1 ) {
		const auto oldRoutine = context->oldRoutine;
		const auto oldContext = context->oldContext;
		return oldRoutine ( deviceObject , irp , oldContext );
	}

	return STATUS_SUCCESS;
}

NTSTATUS DeviceControlHook ( const PDEVICE_OBJECT deviceObject , const PIRP irp ) {
	const auto stackLocation = IoGetCurrentIrpStackLocation ( irp );
	switch ( stackLocation->Parameters.DeviceIoControl.IoControlCode ) {
	case SMART_RCV_DRIVE_DATA: {
		const auto context = reinterpret_cast< HWID::CompletionRoutineInfo* >( ExAllocatePool ( NonPagedPool ,
			sizeof ( HWID::CompletionRoutineInfo ) ) );
		context->oldRoutine = stackLocation->CompletionRoutine;
		context->oldContext = stackLocation->Context;
		stackLocation->CompletionRoutine = reinterpret_cast< PIO_COMPLETION_ROUTINE >( smartRcvDriveDataCompletion );
		stackLocation->Context = context;
		break;
	}
	}

	return originalDeviceControl ( deviceObject , irp );
}

NTSTATUS HWID::ClearPropertyDriveSerials ( ) {
	// dont null the serials but randomise instead
	// returns STATUS_SUCCESS if the nulling off the property drive serials  was successful. 
	//  nulls it by using memset

	//Improve:
	//-Dont NULL the serials, but randomise.

	std::uint8_t serialNumberOffset {};
	{ // Find the serial number offset
		std::uintptr_t storportBase {};
		std::size_t storportSize {};
		Nt::findKernelModuleByName ( "storport.sys" , &storportBase , &storportSize );  // grabs the storport.sys base 

		if ( !storportBase ) { return STATUS_INVALID_ADDRESS; }


		// The code we're looking for is in the page section
		std::uintptr_t storportPage {};
		std::size_t storportPageSize {};
		Nt::findModuleSection ( storportBase , "PAGE" , &storportPage , &storportPageSize );

		if ( !storportPage ) { return STATUS_INVALID_ADDRESS; }


		const auto serialNumberFunc = SigScan::scanPattern ( reinterpret_cast< std::uint8_t* >( storportPage ) , storportPageSize ,
			"\x66\x41\x3B\xF8\x72\xFF\x48\x8B\x53" , "xxxxx?xxx" );  // scans for the function which contains the serialnumbers

		if ( !serialNumberFunc ) { return STATUS_INVALID_ADDRESS; }


		serialNumberOffset = *reinterpret_cast< std::uint8_t* >( serialNumberFunc + 0x9 );
		if ( !serialNumberOffset ) { return STATUS_INVALID_ADDRESS; }

	}

	const auto diskDriver = Nt::findDriverObjectByName ( L"\\Driver\\Disk" );

	if ( !diskDriver ) { return STATUS_NOT_FOUND; }


	auto currentDevice = diskDriver->DeviceObject;
	while ( currentDevice ) {
		auto physicalDriveObject = *reinterpret_cast< PDEVICE_OBJECT* >( reinterpret_cast< std::uintptr_t >( currentDevice->DeviceExtension ) + 0x200 );

		if ( !physicalDriveObject ) {
			physicalDriveObject = *reinterpret_cast< PDEVICE_OBJECT* >( reinterpret_cast< std::uintptr_t >( currentDevice->DeviceExtension ) + 0x10 );

		}

		const auto serialNumber = *reinterpret_cast< char** >( reinterpret_cast< std::uintptr_t >( physicalDriveObject->DeviceExtension ) + serialNumberOffset );
		if ( !MmIsAddressValid ( serialNumber ) ) {
			currentDevice = currentDevice->NextDevice;
			continue;
		}

		auto Test = currentDevice->Size;
		memset ( serialNumber , 0 , sizeof ( char** ) );

		currentDevice = currentDevice->NextDevice;
	}

	return STATUS_SUCCESS;
}

NTSTATUS HWID::ClearSmartDriveSerials ( ) {

	// find alternative for irp hook or use a stealthy irp hook
	// dont null the serials but randomise instead
	// returns STATUS_SUCCESS if the nulling off the smart drive serials  was successful. 
	//  nulls it by using memset


	//Improve:
	//-Dont NULL the serials, but randomise.

	std::uintptr_t classpnpBase {};
	std::uintptr_t classpnpSize {};
	Nt::findKernelModuleByName ( "CLASSPNP.SYS" , &classpnpBase , &classpnpSize ); // grabs the classpnp.sys base 

	if ( !classpnpBase ) { return STATUS_NOT_FOUND; }


	const auto diskDriver = Nt::findDriverObjectByName ( L"\\Driver\\Disk" );

	if ( !diskDriver ) { return STATUS_NOT_FOUND; }


	const auto majorFunctionTableFunc = SigScan::scanPattern ( reinterpret_cast< std::uint8_t* >( diskDriver->MajorFunction [ IRP_MJ_DEVICE_CONTROL ] ) , // find alternative for irp hook
		0x100 , "\x49\x8B\x81\xFF\xFF\xFF\xFF\x4A\x8B\x04\xC0\xFF\x15" , "xxx????xxxxxx" );

	if ( !majorFunctionTableFunc ) { return STATUS_NOT_FOUND; }


	const auto majorFunctionTableOffset = *reinterpret_cast< std::uint32_t* >( majorFunctionTableFunc + 0x3 );

	if ( !majorFunctionTableOffset ) { return STATUS_NOT_FOUND; }


	auto currentDevice = diskDriver->DeviceObject;
	std::size_t i {};

	const auto majorFunctionTable = *reinterpret_cast< std::uintptr_t** >( reinterpret_cast< std::uintptr_t >( currentDevice->DeviceExtension ) + majorFunctionTableOffset );
	originalDeviceControl = reinterpret_cast< decltype( originalDeviceControl ) >( majorFunctionTable [ IRP_MJ_DEVICE_CONTROL ] );
	while ( currentDevice ) {
		const auto majorFunctionTable = *reinterpret_cast< std::uintptr_t** >( reinterpret_cast< std::uintptr_t >( currentDevice->DeviceExtension ) + majorFunctionTableOffset );
		majorFunctionTable [ IRP_MJ_DEVICE_CONTROL ] = reinterpret_cast< std::uintptr_t >( &DeviceControlHook );

		currentDevice = currentDevice->NextDevice; ++i;
	}

	return STATUS_SUCCESS;
}


NTSTATUS HWID::ClearSMBIOS ( )
{

	/// Gets base of ntoskrnl.sys 
	/// scans for the physical memory address signature 
	/// gets the physical address and size
	///  nulls it by using memset
	/// returns STATUS_SUCCESS if the nulling off the smbios was successful. 

	//Improve:
	//-Dont NULL the serials, but randomise.

	std::size_t size {};
	std::uintptr_t ntoskrnlBase {};
	if ( !NT_SUCCESS ( Nt::findKernelModuleByName ( "ntoskrnl.exe" , &ntoskrnlBase , &size ) ) )
		return false;

	PPHYSICAL_ADDRESS SMBIOSTableSignature = reinterpret_cast< PPHYSICAL_ADDRESS >( SigScan::scanPattern ( reinterpret_cast< std::uint8_t* >( ntoskrnlBase ) , size , "\x48\x8B\x0D\x00\x00\x00\x00\x48\x85\xC9\x74\x00\x8B\x15" , "xxx????xxxx?xx" ) );
	// located  at  WmipSMBiosTablePhysicalAddres
	if ( !SMBIOSTableSignature ) { return STATUS_NOT_FOUND; }


	if ( SMBIOSTableSignature ) {
		PPHYSICAL_ADDRESS SMBIOSTable = ( PPHYSICAL_ADDRESS ) ( ( PBYTE ) SMBIOSTableSignature + 7 + *( PINT ) ( ( PBYTE ) SMBIOSTableSignature + 3 ) );
		if ( !SMBIOSTable ) { return STATUS_NOT_FOUND; }

		memset ( SMBIOSTable , 0 , sizeof ( PHYSICAL_ADDRESS ) );
	}

	return STATUS_SUCCESS;
}
```

`HWID.h`:

```h
#pragma once

#include "NT.h"
namespace HWID {
	NTSTATUS ClearPropertyDriveSerials();
	NTSTATUS ClearSMBIOS();
	NTSTATUS ClearSmartDriveSerials();

	struct CompletionRoutineInfo {
		PIO_COMPLETION_ROUTINE oldRoutine;
		PVOID oldContext;
	};
}
```

`HWID_Spoofer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29728.190
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HWID_Spoofer", "HWID_Spoofer.vcxproj", "{F28A8870-A2D5-496F-8EFD-03F6589C233D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|ARM.ActiveCfg = Debug|ARM
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|ARM.Build.0 = Debug|ARM
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|ARM.Deploy.0 = Debug|ARM
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|ARM64.Build.0 = Debug|ARM64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|x64.ActiveCfg = Debug|x64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|x64.Build.0 = Debug|x64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|x64.Deploy.0 = Debug|x64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|x86.ActiveCfg = Debug|Win32
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|x86.Build.0 = Debug|Win32
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Debug|x86.Deploy.0 = Debug|Win32
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|ARM.ActiveCfg = Release|ARM
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|ARM.Build.0 = Release|ARM
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|ARM.Deploy.0 = Release|ARM
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|ARM64.ActiveCfg = Release|ARM64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|ARM64.Build.0 = Release|ARM64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|ARM64.Deploy.0 = Release|ARM64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|x64.ActiveCfg = Release|x64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|x64.Build.0 = Release|x64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|x64.Deploy.0 = Release|x64
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|x86.ActiveCfg = Release|Win32
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|x86.Build.0 = Release|Win32
		{F28A8870-A2D5-496F-8EFD-03F6589C233D}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7D788A68-D064-4727-A8F0-E27A01BA016E}
	EndGlobalSection
EndGlobal

```

`HWID_Spoofer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F28A8870-A2D5-496F-8EFD-03F6589C233D}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>HWID_Spoofer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)Binary\</OutDir>
    <IntDir>$(SolutionDir)Intermediates\</IntDir>
    <TargetName>Driver</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)Binary\</OutDir>
    <TargetName>Driver</TargetName>
    <IntDir>$(SolutionDir)Intermediates\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableModules>true</EnableModules>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableModules>true</EnableModules>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HWID.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="NT.cpp" />
    <ClCompile Include="util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HWID.h" />
    <ClInclude Include="NT.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HWID_Spoofer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NT.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HWID.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NT.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HWID.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`HWID_Spoofer.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`Main.cpp`:

```cpp

#include "HWID.h"

NTSTATUS DriverEntry ( const PDRIVER_OBJECT driverObject , const PUNICODE_STRING registryPath )
{

	// instead of nulling the serials - randomise. 
	// Change the hook, or use a stealthy irp hook. 
	// remove the vulnerable driver you mapped with from piddcache and mmunloaded. // if your manual mapping.
	HWID::ClearPropertyDriveSerials ( );
	HWID::ClearSmartDriveSerials ( );
	HWID::ClearSMBIOS ( );


	return STATUS_SUCCESS;
}
```

`NT.cpp`:

```cpp
#include "NT.h"

NTSTATUS Nt::findKernelModuleByName ( const char* moduleName , std::uintptr_t* moduleStart , std::size_t* moduleSize ) {
	std::size_t size {};

	ZwQuerySystemInformation ( 0xB , nullptr , size , reinterpret_cast< PULONG >( &size ) );

	const auto listHeader = ExAllocatePool ( NonPagedPool , size );
	if ( !listHeader )
		return STATUS_MEMORY_NOT_ALLOCATED;

	if ( const auto status = ZwQuerySystemInformation ( 0xB , listHeader , size , reinterpret_cast< PULONG >( &size ) ) )
		return status;

	auto currentModule = reinterpret_cast< PSYSTEM_MODULE_INFORMATION >( listHeader )->Module;
	for ( std::size_t i {}; i < reinterpret_cast< PSYSTEM_MODULE_INFORMATION >( listHeader )->Count; ++i , ++currentModule ) {
		const auto currentModuleName = reinterpret_cast< const char* >( currentModule->FullPathName + currentModule->OffsetToFileName );
		if ( !strcmp ( moduleName , currentModuleName ) ) {
			*moduleStart = reinterpret_cast< std::uintptr_t >( currentModule->ImageBase );
			*moduleSize = currentModule->ImageSize;
			return STATUS_SUCCESS;
		}
	}

	return STATUS_NOT_FOUND;
}

NTSTATUS Nt::findModuleExportByName ( const std::uintptr_t imageBase , const char* exportName , std::uintptr_t* functionPointer ) {
	if ( !imageBase )
		return STATUS_INVALID_PARAMETER_1;

	if ( reinterpret_cast< PIMAGE_DOS_HEADER >( imageBase )->e_magic != 0x5A4D )
		return STATUS_INVALID_IMAGE_NOT_MZ;

	const auto ntHeader = reinterpret_cast< PIMAGE_NT_HEADERS64 >( imageBase + reinterpret_cast< PIMAGE_DOS_HEADER >( imageBase )->e_lfanew );
	const auto exportDirectory = reinterpret_cast< PIMAGE_EXPORT_DIRECTORY >( imageBase + ntHeader->OptionalHeader.DataDirectory [ 0 ].VirtualAddress );
	if ( !exportDirectory )
		STATUS_INVALID_IMAGE_FORMAT;

	const auto exportedFunctions = reinterpret_cast< std::uint32_t* >( imageBase + exportDirectory->AddressOfFunctions );
	const auto exportedNames = reinterpret_cast< std::uint32_t* >( imageBase + exportDirectory->AddressOfNames );
	const auto exportedNameOrdinals = reinterpret_cast< std::uint16_t* >( imageBase + exportDirectory->AddressOfNameOrdinals );

	for ( std::size_t i {}; i < exportDirectory->NumberOfNames; ++i ) {
		const auto functionName = reinterpret_cast< const char* >( imageBase + exportedNames [ i ] );
		if ( !strcmp ( exportName , functionName ) ) {
			*functionPointer = imageBase + exportedFunctions [ exportedNameOrdinals [ i ] ];
			return STATUS_SUCCESS;
		}
	}

	return STATUS_NOT_FOUND;
}

NTSTATUS Nt::findModuleSection ( std::uintptr_t imageAddress , const char* sectionName , std::uintptr_t* sectionBase , std::size_t* sectionSize ) {
	if ( !imageAddress || reinterpret_cast< PIMAGE_DOS_HEADER >( imageAddress )->e_magic != 0x5A4D )
		return {};

	const auto ntHeader = reinterpret_cast< PIMAGE_NT_HEADERS64 >( imageAddress + reinterpret_cast< PIMAGE_DOS_HEADER >(
		imageAddress )->e_lfanew );
	auto sectionHeader = IMAGE_FIRST_SECTION ( ntHeader );

	for ( std::uint16_t i = 0; i < ntHeader->FileHeader.NumberOfSections; ++i , ++sectionHeader )
		if ( strstr ( reinterpret_cast< const char* >( &sectionHeader->Name ) , sectionName ) ) {
			*sectionBase = imageAddress + sectionHeader->VirtualAddress;
			*sectionSize = sectionHeader->Misc.VirtualSize;
			return STATUS_SUCCESS;
		}

	return STATUS_NOT_FOUND;
}

PDRIVER_OBJECT Nt::findDriverObjectByName ( const wchar_t* driverPath ) {
	UNICODE_STRING driverPathUnicode {};
	PDRIVER_OBJECT driverObject {};

	RtlInitUnicodeString ( &driverPathUnicode , driverPath );
	ObReferenceObjectByName ( &driverPathUnicode , OBJ_CASE_INSENSITIVE , nullptr , 0 ,
		*IoDriverObjectType , KernelMode , nullptr , reinterpret_cast< PVOID* >( &driverObject ) );
	ObfDereferenceObject ( driverObject );

	return driverObject;
}

NTSTATUS Nt::findProcessByName ( const char* processName , PEPROCESS* process ) {
	auto currentEntry = reinterpret_cast< std::uintptr_t >( PsInitialSystemProcess );

	do {
		if ( strstr ( reinterpret_cast< char* >( currentEntry ) + NtOffsets::processImageFileName , processName ) ) {
			const auto activeThreads = *reinterpret_cast< std::uint32_t* >( currentEntry + NtOffsets::processActiveThreads );
			if ( activeThreads > 0 ) {
				*process = reinterpret_cast< PEPROCESS >( currentEntry );
				return STATUS_SUCCESS;
			}
		}

		const auto list = reinterpret_cast< PLIST_ENTRY >( currentEntry + NtOffsets::processActiveProcessLinks );
		currentEntry = reinterpret_cast< std::uintptr_t >( list->Flink );
		currentEntry = currentEntry - NtOffsets::processActiveProcessLinks;

	} while ( currentEntry != reinterpret_cast< std::uintptr_t >( PsInitialSystemProcess ) );

	return STATUS_NOT_FOUND;
}
```

`NT.h`:

```h
#pragma once

#include <ntifs.h>
#include <windef.h>

#include <cstdint>
#include <cstddef>

extern "C" {
	NTSTATUS WINAPI ZwQuerySystemInformation ( _In_ ULONG SystemInformationClass , _Inout_ PVOID SystemInformation ,
		_In_ ULONG SystemInformationLength , _Out_opt_ PULONG ReturnLength );
	NTKERNELAPI PVOID PsGetProcessSectionBaseAddress ( __in PEPROCESS Process );
	NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName ( PUNICODE_STRING ObjectPath , ULONG Attributes ,
		PACCESS_STATE PassedAccessState , ACCESS_MASK DesiredAccess ,
		POBJECT_TYPE ObjectType , KPROCESSOR_MODE AccessMode , PVOID ParseContext ,
		PVOID* ObjectPtr );
	NTKERNELAPI POBJECT_TYPE* IoDriverObjectType;
}

namespace Nt {
	NTSTATUS findKernelModuleByName ( const char* moduleName , std::uintptr_t* moduleStart , std::size_t* moduleSize );
	NTSTATUS findModuleExportByName ( const std::uintptr_t imageBase , const char* exportName , std::uintptr_t* functionPointer );
	PDRIVER_OBJECT findDriverObjectByName ( const wchar_t* driverPath );
	NTSTATUS findProcessByName ( const char* processName , PEPROCESS* process );
	NTSTATUS findModuleSection ( std::uintptr_t imageAddress , const char* sectionName , std::uintptr_t* sectionBase , std::size_t* sectionSize );
}

// ntoskrnl offsets hardcoded for Windows 10 x64 version 1903
namespace NtOffsets {
	constexpr auto flags = 0x30C;
	constexpr auto processFlags = 0x1B8;
	constexpr auto activeThreads = 0x498;
	constexpr auto processImageFileName = 0x450;
	constexpr auto processActiveThreads = 0x498;
	constexpr auto processActiveProcessLinks = 0x2F0;  // 0x2e8 1809
}

// PE and ntoskrnl internal structures

struct PiDDBCache
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028 [ 16 ]; // data from the shim engine, or uninitialized memory for custom drivers
};

typedef struct _SYSTEM_MODULE_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName [ 256 ];
} SYSTEM_MODULE_ENTRY , * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module [ 1 ];
} SYSTEM_MODULE_INFORMATION , * PSYSTEM_MODULE_INFORMATION;

typedef struct _IMAGE_DOS_HEADER {
	WORD   e_magic;
	WORD   e_cblp;
	WORD   e_cp;
	WORD   e_crlc;
	WORD   e_cparhdr;
	WORD   e_minalloc;
	WORD   e_maxalloc;
	WORD   e_ss;
	WORD   e_sp;
	WORD   e_csum;
	WORD   e_ip;
	WORD   e_cs;
	WORD   e_lfarlc;
	WORD   e_ovno;
	WORD   e_res [ 4 ];
	WORD   e_oemid;
	WORD   e_oeminfo;
	WORD   e_res2 [ 10 ];
	LONG   e_lfanew;
} IMAGE_DOS_HEADER , * PIMAGE_DOS_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD   VirtualAddress;
	DWORD   Size;
} IMAGE_DATA_DIRECTORY , * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD        Magic;
	BYTE        MajorLinkerVersion;
	BYTE        MinorLinkerVersion;
	DWORD       SizeOfCode;
	DWORD       SizeOfInitializedData;
	DWORD       SizeOfUninitializedData;
	DWORD       AddressOfEntryPoint;
	DWORD       BaseOfCode;
	ULONGLONG   ImageBase;
	DWORD       SectionAlignment;
	DWORD       FileAlignment;
	WORD        MajorOperatingSystemVersion;
	WORD        MinorOperatingSystemVersion;
	WORD        MajorImageVersion;
	WORD        MinorImageVersion;
	WORD        MajorSubsystemVersion;
	WORD        MinorSubsystemVersion;
	DWORD       Win32VersionValue;
	DWORD       SizeOfImage;
	DWORD       SizeOfHeaders;
	DWORD       CheckSum;
	WORD        Subsystem;
	WORD        DllCharacteristics;
	ULONGLONG   SizeOfStackReserve;
	ULONGLONG   SizeOfStackCommit;
	ULONGLONG   SizeOfHeapReserve;
	ULONGLONG   SizeOfHeapCommit;
	DWORD       LoaderFlags;
	DWORD       NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory [ 16 ];
} IMAGE_OPTIONAL_HEADER64 , * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_FILE_HEADER {
	WORD  Machine;
	WORD  NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD  SizeOfOptionalHeader;
	WORD  Characteristics;
} IMAGE_FILE_HEADER , * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_NT_HEADERS64 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64 , * PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD   Characteristics;
	DWORD   TimeDateStamp;
	WORD    MajorVersion;
	WORD    MinorVersion;
	DWORD   Name;
	DWORD   Base;
	DWORD   NumberOfFunctions;
	DWORD   NumberOfNames;
	DWORD   AddressOfFunctions;
	DWORD   AddressOfNames;
	DWORD   AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY , * PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_SECTION_HEADER {
	BYTE  Name [ 8 ];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD  NumberOfRelocations;
	WORD  NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER , * PIMAGE_SECTION_HEADER;

typedef struct _IDINFO
{
	USHORT	wGenConfig;
	USHORT	wNumCyls;
	USHORT	wReserved;
	USHORT	wNumHeads;
	USHORT	wBytesPerTrack;
	USHORT	wBytesPerSector;
	USHORT	wNumSectorsPerTrack;
	USHORT	wVendorUnique [ 3 ];
	CHAR	sSerialNumber [ 20 ];
	USHORT	wBufferType;
	USHORT	wBufferSize;
	USHORT	wECCSize;
	CHAR	sFirmwareRev [ 8 ];
	CHAR	sModelNumber [ 40 ];
	USHORT	wMoreVendorUnique;
	USHORT	wDoubleWordIO;
	struct {
		USHORT	Reserved : 8;
		USHORT	DMA : 1;
		USHORT	LBA : 1;
		USHORT	DisIORDY : 1;
		USHORT	IORDY : 1;
		USHORT	SoftReset : 1;
		USHORT	Overlap : 1;
		USHORT	Queue : 1;
		USHORT	InlDMA : 1;
	} wCapabilities;
	USHORT	wReserved1;
	USHORT	wPIOTiming;
	USHORT	wDMATiming;
	struct {
		USHORT	CHSNumber : 1;
		USHORT	CycleNumber : 1;
		USHORT	UnltraDMA : 1;
		USHORT	Reserved : 13;
	} wFieldValidity;
	USHORT	wNumCurCyls;
	USHORT	wNumCurHeads;
	USHORT	wNumCurSectorsPerTrack;
	USHORT	wCurSectorsLow;
	USHORT	wCurSectorsHigh;
	struct {
		USHORT	CurNumber : 8;
		USHORT	Multi : 1;
		USHORT	Reserved : 7;
	} wMultSectorStuff;
	ULONG	dwTotalSectors;
	USHORT	wSingleWordDMA;
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Reserved1 : 5;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Reserved2 : 5;
	} wMultiWordDMA;
	struct {
		USHORT	AdvPOIModes : 8;
		USHORT	Reserved : 8;
	} wPIOCapacity;
	USHORT	wMinMultiWordDMACycle;
	USHORT	wRecMultiWordDMACycle;
	USHORT	wMinPIONoFlowCycle;
	USHORT	wMinPOIFlowCycle;
	USHORT	wReserved69 [ 11 ];
	struct {
		USHORT	Reserved1 : 1;
		USHORT	ATA1 : 1;
		USHORT	ATA2 : 1;
		USHORT	ATA3 : 1;
		USHORT	ATA4 : 1;
		USHORT	ATA5 : 1;
		USHORT	ATA6 : 1;
		USHORT	ATA7 : 1;
		USHORT	ATA8 : 1;
		USHORT	ATA9 : 1;
		USHORT	ATA10 : 1;
		USHORT	ATA11 : 1;
		USHORT	ATA12 : 1;
		USHORT	ATA13 : 1;
		USHORT	ATA14 : 1;
		USHORT	Reserved2 : 1;
	} wMajorVersion;
	USHORT	wMinorVersion;
	USHORT	wReserved82 [ 6 ];
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Mode3 : 1;
		USHORT	Mode4 : 1;
		USHORT	Mode5 : 1;
		USHORT	Mode6 : 1;
		USHORT	Mode7 : 1;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Mode3Sel : 1;
		USHORT	Mode4Sel : 1;
		USHORT	Mode5Sel : 1;
		USHORT	Mode6Sel : 1;
		USHORT	Mode7Sel : 1;
	} wUltraDMA;
	USHORT	wReserved89 [ 167 ];
} IDINFO , * PIDINFO;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName [ 256 ];
} RTL_PROCESS_MODULE_INFORMATION , * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules [ 1 ];
} RTL_PROCESS_MODULES , * PRTL_PROCESS_MODULES;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0 ,
	SystemProcessorInformation = 0x1 ,
	SystemPerformanceInformation = 0x2 ,
	SystemTimeOfDayInformation = 0x3 ,
	SystemPathInformation = 0x4 ,
	SystemProcessInformation = 0x5 ,
	SystemCallCountInformation = 0x6 ,
	SystemDeviceInformation = 0x7 ,
	SystemProcessorPerformanceInformation = 0x8 ,
	SystemFlagsInformation = 0x9 ,
	SystemCallTimeInformation = 0xa ,
	SystemModuleInformation = 0xb ,
	SystemLocksInformation = 0xc ,
	SystemStackTraceInformation = 0xd ,
	SystemPagedPoolInformation = 0xe ,
	SystemNonPagedPoolInformation = 0xf ,
	SystemHandleInformation = 0x10 ,
	SystemObjectInformation = 0x11 ,
	SystemPageFileInformation = 0x12 ,
	SystemVdmInstemulInformation = 0x13 ,
	SystemVdmBopInformation = 0x14 ,
	SystemFileCacheInformation = 0x15 ,
	SystemPoolTagInformation = 0x16 ,
	SystemInterruptInformation = 0x17 ,
	SystemDpcBehaviorInformation = 0x18 ,
	SystemFullMemoryInformation = 0x19 ,
	SystemLoadGdiDriverInformation = 0x1a ,
	SystemUnloadGdiDriverInformation = 0x1b ,
	SystemTimeAdjustmentInformation = 0x1c ,
	SystemSummaryMemoryInformation = 0x1d ,
	SystemMirrorMemoryInformation = 0x1e ,
	SystemPerformanceTraceInformation = 0x1f ,
	SystemObsolete0 = 0x20 ,
	SystemExceptionInformation = 0x21 ,
	SystemCrashDumpStateInformation = 0x22 ,
	SystemKernelDebuggerInformation = 0x23 ,
	SystemContextSwitchInformation = 0x24 ,
	SystemRegistryQuotaInformation = 0x25 ,
	SystemExtendServiceTableInformation = 0x26 ,
	SystemPrioritySeperation = 0x27 ,
	SystemVerifierAddDriverInformation = 0x28 ,
	SystemVerifierRemoveDriverInformation = 0x29 ,
	SystemProcessorIdleInformation = 0x2a ,
	SystemLegacyDriverInformation = 0x2b ,
	SystemCurrentTimeZoneInformation = 0x2c ,
	SystemLookasideInformation = 0x2d ,
	SystemTimeSlipNotification = 0x2e ,
	SystemSessionCreate = 0x2f ,
	SystemSessionDetach = 0x30 ,
	SystemSessionInformation = 0x31 ,
	SystemRangeStartInformation = 0x32 ,
	SystemVerifierInformation = 0x33 ,
	SystemVerifierThunkExtend = 0x34 ,
	SystemSessionProcessInformation = 0x35 ,
	SystemLoadGdiDriverInSystemSpace = 0x36 ,
	SystemNumaProcessorMap = 0x37 ,
	SystemPrefetcherInformation = 0x38 ,
	SystemExtendedProcessInformation = 0x39 ,
	SystemRecommendedSharedDataAlignment = 0x3a ,
	SystemComPlusPackage = 0x3b ,
	SystemNumaAvailableMemory = 0x3c ,
	SystemProcessorPowerInformation = 0x3d ,
	SystemEmulationBasicInformation = 0x3e ,
	SystemEmulationProcessorInformation = 0x3f ,
	SystemExtendedHandleInformation = 0x40 ,
	SystemLostDelayedWriteInformation = 0x41 ,
	SystemBigPoolInformation = 0x42 ,
	SystemSessionPoolTagInformation = 0x43 ,
	SystemSessionMappedViewInformation = 0x44 ,
	SystemHotpatchInformation = 0x45 ,
	SystemObjectSecurityMode = 0x46 ,
	SystemWatchdogTimerHandler = 0x47 ,
	SystemWatchdogTimerInformation = 0x48 ,
	SystemLogicalProcessorInformation = 0x49 ,
	SystemWow64SharedInformationObsolete = 0x4a ,
	SystemRegisterFirmwareTableInformationHandler = 0x4b ,
	SystemFirmwareTableInformation = 0x4c ,
	SystemModuleInformationEx = 0x4d ,
	SystemVerifierTriageInformation = 0x4e ,
	SystemSuperfetchInformation = 0x4f ,
	SystemMemoryListInformation = 0x50 ,
	SystemFileCacheInformationEx = 0x51 ,
	SystemThreadPriorityClientIdInformation = 0x52 ,
	SystemProcessorIdleCycleTimeInformation = 0x53 ,
	SystemVerifierCancellationInformation = 0x54 ,
	SystemProcessorPowerInformationEx = 0x55 ,
	SystemRefTraceInformation = 0x56 ,
	SystemSpecialPoolInformation = 0x57 ,
	SystemProcessIdInformation = 0x58 ,
	SystemErrorPortInformation = 0x59 ,
	SystemBootEnvironmentInformation = 0x5a ,
	SystemHypervisorInformation = 0x5b ,
	SystemVerifierInformationEx = 0x5c ,
	SystemTimeZoneInformation = 0x5d ,
	SystemImageFileExecutionOptionsInformation = 0x5e ,
	SystemCoverageInformation = 0x5f ,
	SystemPrefetchPatchInformation = 0x60 ,
	SystemVerifierFaultsInformation = 0x61 ,
	SystemSystemPartitionInformation = 0x62 ,
	SystemSystemDiskInformation = 0x63 ,
	SystemProcessorPerformanceDistribution = 0x64 ,
	SystemNumaProximityNodeInformation = 0x65 ,
	SystemDynamicTimeZoneInformation = 0x66 ,
	SystemCodeIntegrityInformation = 0x67 ,
	SystemProcessorMicrocodeUpdateInformation = 0x68 ,
	SystemProcessorBrandString = 0x69 ,
	SystemVirtualAddressInformation = 0x6a ,
	SystemLogicalProcessorAndGroupInformation = 0x6b ,
	SystemProcessorCycleTimeInformation = 0x6c ,
	SystemStoreInformation = 0x6d ,
	SystemRegistryAppendString = 0x6e ,
	SystemAitSamplingValue = 0x6f ,
	SystemVhdBootInformation = 0x70 ,
	SystemCpuQuotaInformation = 0x71 ,
	SystemNativeBasicInformation = 0x72 ,
	SystemErrorPortTimeouts = 0x73 ,
	SystemLowPriorityIoInformation = 0x74 ,
	SystemBootEntropyInformation = 0x75 ,
	SystemVerifierCountersInformation = 0x76 ,
	SystemPagedPoolInformationEx = 0x77 ,
	SystemSystemPtesInformationEx = 0x78 ,
	SystemNodeDistanceInformation = 0x79 ,
	SystemAcpiAuditInformation = 0x7a ,
	SystemBasicPerformanceInformation = 0x7b ,
	SystemQueryPerformanceCounterInformation = 0x7c ,
	SystemSessionBigPoolInformation = 0x7d ,
	SystemBootGraphicsInformation = 0x7e ,
	SystemScrubPhysicalMemoryInformation = 0x7f ,
	SystemBadPageInformation = 0x80 ,
	SystemProcessorProfileControlArea = 0x81 ,
	SystemCombinePhysicalMemoryInformation = 0x82 ,
	SystemEntropyInterruptTimingInformation = 0x83 ,
	SystemConsoleInformation = 0x84 ,
	SystemPlatformBinaryInformation = 0x85 ,
	SystemThrottleNotificationInformation = 0x86 ,
	SystemHypervisorProcessorCountInformation = 0x87 ,
	SystemDeviceDataInformation = 0x88 ,
	SystemDeviceDataEnumerationInformation = 0x89 ,
	SystemMemoryTopologyInformation = 0x8a ,
	SystemMemoryChannelInformation = 0x8b ,
	SystemBootLogoInformation = 0x8c ,
	SystemProcessorPerformanceInformationEx = 0x8d ,
	SystemSpare0 = 0x8e ,
	SystemSecureBootPolicyInformation = 0x8f ,
	SystemPageFileInformationEx = 0x90 ,
	SystemSecureBootInformation = 0x91 ,
	SystemEntropyInterruptTimingRawInformation = 0x92 ,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93 ,
	SystemFullProcessInformation = 0x94 ,
	SystemKernelDebuggerInformationEx = 0x95 ,
	SystemBootMetadataInformation = 0x96 ,
	SystemSoftRebootInformation = 0x97 ,
	SystemElamCertificateInformation = 0x98 ,
	SystemOfflineDumpConfigInformation = 0x99 ,
	SystemProcessorFeaturesInformation = 0x9a ,
	SystemRegistryReconciliationInformation = 0x9b ,
	MaxSystemInfoClass = 0x9c ,
} SYSTEM_INFORMATION_CLASS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS64, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

```

`README.md`:

```md
# hwid_spoofer
HWID Spoofer which spoofs disk serials, smart disk serials and SMBIOS.

This project is something i made 2 years ago for fun. It is Detected as fuck. There is a lot of stuff which can be improved and I have stated some parts. It has  been sitting on my desktop for a while, thought someone can make use of it hopefully.

As by now i suppose everything in this project has already been documented on other sites or in other projects. 

Hopefully it helped someone. 

```

`util.cpp`:

```cpp
#include "util.h"

#include "NT.h"

namespace SigScan {
	std::uintptr_t scanPattern ( std::uint8_t* base , const std::size_t size , char* pattern , char* mask ) {
		const auto patternSize = strlen ( mask );

		if ( !patternSize ) { return NULL; }

		for ( std::size_t i = {}; i < size - patternSize; i++ )
		{
			for ( std::size_t j = {}; j < patternSize; j++ )
			{
				if ( mask [ j ] != '?' && *reinterpret_cast< std::uint8_t* >( base + i + j ) != static_cast< std::uint8_t >( pattern [ j ] ) )
					break;

				if ( j == patternSize - 1 )
					return reinterpret_cast< std::uintptr_t >( base ) + i;
			}
		}

		return {};
	}

	std::uintptr_t Dereference ( std::uintptr_t address , std::uint32_t offset ) {

		if ( !address ) { return NULL; }

		return address + ( int ) ( ( *( int* ) ( address + offset ) + offset ) + sizeof ( int ) );
	}
}

```

`util.h`:

```h
#pragma once

#include <cstdint>
#include <cstddef>

namespace SigScan {
	uintptr_t scanPattern ( std::uint8_t* base , const std::size_t size , char* pattern , char* mask );
	std::uintptr_t Dereference ( std::uintptr_t address , std::uint32_t offset );
}
```