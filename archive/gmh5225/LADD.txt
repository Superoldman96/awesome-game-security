Project Path: arc_gmh5225_LADD_924a7mf2

Source Tree:

```txt
arc_gmh5225_LADD_924a7mf2
├── README.md
├── ladd.c
└── ladd.py

```

`README.md`:

```md
# LADD
Linux Anti-Debugging Detector tool

```                                                     
     _____          _       ______   ______                   
    |_   _|        / \     |_   _ `.|_   _ `.                 
      | |         / _ \      | | `. \ | | `. \                
      | |   _    / ___ \     | |  | | | |  | |                
     _| |__/ | _/ /   \ \_  _| |_.' /_| |_.' /                
    |________||____| |____||______.'|______.'                 

```

## LD_PRELOAD environment variable
This environment variable is loaded before every library in the system (including the C runtime, libc.so). Thou, malwares can use it, by loading themselves and gain persistence using a command like `export LD_PRELOAD=/malware_path`.

## PTRACE_TRACEME Syscall
Many debuggers, like `gdb` use this syscall for attach the debugger to the target process. The `PTRACE_TRACEME` syscall can be used one time per process. Due to that reason, malwares can make a call to that syscall before the program's entry point, so no other similar syscall can be made. Or in other words, the process can not be debugged.

## /proc/{pid}/status
This file contains information about the process with the relevant PID. One of them is the `TracerPID` parameter.
When a process is running under debugger, the `TracerPID` parameter contain the PID of the parent process - the debugger. Otherwise, it will contain `0`.

## Usage
`python3 ./ladd.py {filepath}`

Copyright (c) 2022 Barak Aharoni.  All Rights Reserved.

```

`ladd.c`:

```c
/*

################################################################
#                                                              #
#                                                              #
#     _____          _       ______   ______                   #
#    |_   _|        / \     |_   _ `.|_   _ `.                 #
#      | |         / _ \      | | `. \ | | `. \                #
#      | |   _    / ___ \     | |  | | | |  | |                #
#     _| |__/ | _/ /   \ \_  _| |_.' /_| |_.' /                #
#    |________||____| |____||______.'|______.'                 #
#                                                              #
#    Linux Anti-Debugging Detector                             #
#                                                              #
#    Copyright (c) 2022 Barak Aharoni.  All Rights Reserved.   #
################################################################

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <regex.h>
#include <sys/ptrace.h>

const char* PROC_STATUS_PATH = "/proc/self/status";
const int NOT_DEBUGGED_TRACERPID = 0;
const char* CMDLINE_PATH = "/proc/%d/cmdline";
const char* LD_PRELOAD = "LD_PRELOAD";
const int DEBUGGER_PRESENT = -1;

inline void detectTracerPID();
inline void detectLD_PREALOAD();
inline void detectPtrace();

// Get process name by its PID
char* getProcnameByPID(int pid)
{
    char* name = (char*)calloc(1024, sizeof(char));
    if(name)
    {
        sprintf(name, CMDLINE_PATH, pid);
        FILE* f = fopen(name, "r");
        if(f)
        {
            size_t size;
            size = fread(name, sizeof(char), 1024, f);
            if(size > 0){
                if('\n' == name[size - 1])
                    name[size - 1]= '\0';
            }
            fclose(f);
        }
    }
    return name;
}

// Reads the /proc/self/status file and TracerPid field to detect an attached debugger
void detectTracerPID()
{
    printf("TracerPID Check\n");
    FILE *fptr;
    int lineLength = 255;
    char line[lineLength];

    char* tracer;
    int tracerPid;
    char* content;

    fptr = fopen(PROC_STATUS_PATH, "r");
    
    // Cannot open the file
    if(fptr == NULL)
    {
        printf("\t[-] Error opening: %s\n", PROC_STATUS_PATH);
        exit(1);
    }

    // Reads every line in the file until finding the 'TracerPid' field
    while(fgets(line, lineLength, fptr)) 
    {
        content = strstr(line, "TracerPid");
        if(content)
            break;
    }
    fclose(fptr);

    // Use sscanf to catch the PID of the debugger process
    int ret = sscanf(content, "%s %d" , tracer, &tracerPid);
    
    // The current process is being debugged
    if (tracerPid != NOT_DEBUGGED_TRACERPID)
        printf("\t[V] The process is being Debugged by PID: %d, ProcessName: %s\n", tracerPid, getProcnameByPID(tracerPid));
    
    // The current process is not debugged
    else
        printf("\t[X] The process is NOT Debugged\n");
        
}

// Checks the LD_PRELOAD environment variable
void detectLD_PREALOAD()
{
    printf("LD_PREALOAD Check\n");
    const char* ldEnvar = getenv(LD_PRELOAD);
    
    // LD_PRELOAD environment variable is empty
    if(ldEnvar != NULL)
        printf("\t[V] %s environment variable found: %s\n", LD_PRELOAD, ldEnvar);
    else
        printf("\t[X] %s environment variable not found\n", LD_PRELOAD);
}

// Use the PTRACE_TRACEME Syscall to detect an attached debugger
void detectPtrace()
{
    printf("Ptrace Check\n");
    
    // PTRACE_TRACEME Syscall is already in used
    if (ptrace(PTRACE_TRACEME, 0, 1, 0) == DEBUGGER_PRESENT) 
        printf("\t[V] Process is being debugged\n");
    else
        printf("\t[X] Process is NOT being debugged\n");
}

int main( void )
{
    printf("\n+---------------------------+\n| Linux Anti-Debug Detector |\n+---------------------------+\n\n");
    detectPtrace();
    detectLD_PREALOAD();
    detectTracerPID();
    
    return 0;
}

```

`ladd.py`:

```py
import re
from subprocess import check_output
import os
import sys

BANNER = """

################################################################
#                                                              #
#                                                              #
#     _____          _       ______   ______                   #
#    |_   _|        / \     |_   _ `.|_   _ `.                 #
#      | |         / _ \      | | `. \ | | `. \                #
#      | |   _    / ___ \     | |  | | | |  | |                #
#     _| |__/ | _/ /   \ \_  _| |_.' /_| |_.' /                #
#    |________||____| |____||______.'|______.'                 #
#                                                              #
#    Linux Anti-Debugging Detector                             #
#                                                              #
#    Copyright (c) 2022 Barak Aharoni.  All Rights Reserved.   #
################################################################

"""
LD_PRELOAD = "LD_PRELOAD"
PROC_STATUS_PATH = "/proc/{}/status"
TRACERPID_REGEX = "TracerPID:\s+(\d+)\s*"
LEGIT_TRACERPID = 0
PTRACE_SYSCALL_OPCODES = b"\x65\x00\x00\x00\x0F\x05"

# Checks if founds a PTRACE_TRACEME Syscall is the code
def detectPTRACESyscall(filepath):
    with open(filepath, 'rb') as f:
        data = f.read()
    detected = re.findall(PTRACE_SYSCALL_OPCODES, data)
    if detected:
        print("\t[-] PTRACE_TRACEME Syscall Detected {} times".format(len(detected)))
    else:
        print("\t[-] PTRACE_TRACEME Syscall not found")

# Checks if LD_PRELOAD environment variable contains the file
# If so, it meens that the file will run before every process in the system
def detectLD_PRELOAD(filepath):
    filename = filepath.split('/')[-1]
    ld_preload_env = os.getenv(LD_PRELOAD)
    if ld_preload_env:
        detected = re.findall(filename, ld_preload_env)
        if detected:
            print("\t[-] Filename detected in LD_PRELOAD environmet variable")
        else:
            print("\t[-] Filename NOT found in LD_PRELOAD environment variable")
    else:
        print("\t[-] Filename NOT found in LD_PRELOAD environment variable")
        
# Checks if the file is running under debugger
def detectTracerID(filepath):
    filename = filepath.split('/')[0]
    pid = getPIDFromName(filename)
    with open(PROC_STATUS_PATH, 'r') as f:
        content = f.read()
    
    tracerpid = re.findall(TRACERPID_REGEX, content)
    if tracerpid:
        if not(tracerpid[0] == LEGIT_TRACERPID):
            debuggerProcName = getNameFromPID(tracerpid[0])
            print("\t[-] Process is being debbuged by process: {} with PID: {}".format(debuggerProcName,tracerpid[0]))
        else:
            print("\t[-] Process is NOT being debbuged")
    else:
        print("\t[-] Process is NOT being debbuged")

# Get PID from procname
def getPIDFromName(procname):
    return int(check_output(['pidof', '-s', procname]))

# Get procname from PID
def getNameFromPID(pid):
    return check_output(['ps', '-p', pid, '-o', 'comm='])

def main():
    print(BANNER)

    if len(sys.argv) < 2:
        print("Usage: python {} <filepath>".format(sys.argv[0]))
        sys.exit()

    filepath = sys.argv[1]
    detectPTRACESyscall(filepath)
    detectLD_PRELOAD(filepath)
    detectTracerID(filepath)
```