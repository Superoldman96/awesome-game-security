Project Path: arc_gmh5225_MouHidInputHook_82rilwy9

Source Tree:

```txt
arc_gmh5225_MouHidInputHook_82rilwy9
├── Common
│   ├── ioctl.h
│   └── time.h
├── Image
│   └── mouse_input_processing_internals.png
├── LICENSE
├── MouHidInputHook
│   ├── LICENSE
│   ├── MouHidInputHook.inf
│   ├── MouHidInputHook.vcxproj
│   ├── MouHidInputHook.vcxproj.filters
│   ├── debug.h
│   ├── driver.cpp
│   ├── io_util.cpp
│   ├── io_util.h
│   ├── log.cpp
│   ├── log.h
│   ├── mouclass.cpp
│   ├── mouclass.h
│   ├── mouhid.cpp
│   ├── mouhid.h
│   ├── mouhid_hook_manager.cpp
│   ├── mouhid_hook_manager.h
│   ├── mouhid_monitor.cpp
│   ├── mouhid_monitor.h
│   ├── nt.h
│   ├── object_util.cpp
│   ├── object_util.h
│   ├── pe.cpp
│   └── pe.h
├── MouHidInputHook.sln
├── MouHidMonitor
│   ├── LICENSE
│   ├── MouHidMonitor.vcxproj
│   ├── MouHidMonitor.vcxproj.filters
│   ├── README.md
│   ├── debug.h
│   ├── driver.cpp
│   ├── driver.h
│   ├── log.cpp
│   ├── log.h
│   └── main.cpp
└── README.md

```

`Common/ioctl.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#if defined(_KERNEL_MODE)
#include <fltKernel.h>
#else
#include <Windows.h>
#endif

#include <devioctl.h>

//=============================================================================
// Names
//=============================================================================
#define DRIVER_NAME_U           L"MouHidInputHook"
#define LOCAL_DEVICE_PATH_U     (L"\\\\.\\" DRIVER_NAME_U)
#define NT_DEVICE_NAME_U        (L"\\Device\\" DRIVER_NAME_U)
#define SYMBOLIC_LINK_NAME_U    (L"\\DosDevices\\" DRIVER_NAME_U)

//=============================================================================
// Ioctls
//=============================================================================
#define FILE_DEVICE_MOUHID_INPUT_HOOK   51382

#define IOCTL_QUERY_MOUHID_INPUT_MONITOR    \
    CTL_CODE(                               \
        FILE_DEVICE_MOUHID_INPUT_HOOK,      \
        3300,                               \
        METHOD_BUFFERED,                    \
        FILE_ANY_ACCESS)

#define IOCTL_ENABLE_MOUHID_INPUT_MONITOR   \
    CTL_CODE(                               \
        FILE_DEVICE_MOUHID_INPUT_HOOK,      \
        3500,                               \
        METHOD_BUFFERED,                    \
        FILE_ANY_ACCESS)

#define IOCTL_DISABLE_MOUHID_INPUT_MONITOR  \
    CTL_CODE(                               \
        FILE_DEVICE_MOUHID_INPUT_HOOK,      \
        3501,                               \
        METHOD_BUFFERED,                    \
        FILE_ANY_ACCESS)

//=============================================================================
// IOCTL_QUERY_MOUHID_INPUT_MONITOR
//=============================================================================
typedef struct _QUERY_MOUHID_INPUT_MONITOR_REPLY
{
    BOOLEAN Enabled;

} QUERY_MOUHID_INPUT_MONITOR_REPLY, *PQUERY_MOUHID_INPUT_MONITOR_REPLY;

```

`Common/time.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#if defined(_KERNEL_MODE)
#include <fltKernel.h>
#else
#include <Windows.h>
#endif

//
// NT time is measured in units of 100-nanosecond intervals.
//
#define SYSTEM_TIME_UNIT_MICROSECOND    ((LONGLONG)(10))
#define SYSTEM_TIME_UNIT_MILLISECOND    ((LONGLONG)(10000))
#define SYSTEM_TIME_UNIT_SECOND         ((LONGLONG)(10000000))

#define RELATIVE_INTERVAL(Interval)     (-Interval)

FORCEINLINE
VOID
MakeRelativeIntervalSeconds(
    _Inout_ PLARGE_INTEGER pInterval,
    _In_ LONGLONG Seconds
)
{
    pInterval->QuadPart = RELATIVE_INTERVAL(Seconds * SYSTEM_TIME_UNIT_SECOND);
}

FORCEINLINE
VOID
MakeRelativeIntervalMilliseconds(
    _Inout_ PLARGE_INTEGER pInterval,
    _In_ LONGLONG Milliseconds
)
{
    pInterval->QuadPart =
        RELATIVE_INTERVAL(Milliseconds * SYSTEM_TIME_UNIT_MILLISECOND);
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 changeofpace

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`MouHidInputHook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.271
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MouHidInputHook", "MouHidInputHook\MouHidInputHook.vcxproj", "{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MouHidMonitor", "MouHidMonitor\MouHidMonitor.vcxproj", "{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Debug|x64.ActiveCfg = Debug|x64
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Debug|x64.Build.0 = Debug|x64
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Debug|x64.Deploy.0 = Debug|x64
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Debug|x86.ActiveCfg = Debug|Win32
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Debug|x86.Build.0 = Debug|Win32
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Debug|x86.Deploy.0 = Debug|Win32
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Release|x64.ActiveCfg = Release|x64
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Release|x64.Build.0 = Release|x64
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Release|x64.Deploy.0 = Release|x64
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Release|x86.ActiveCfg = Release|Win32
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Release|x86.Build.0 = Release|Win32
		{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}.Release|x86.Deploy.0 = Release|Win32
		{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}.Debug|x64.ActiveCfg = Debug|x64
		{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}.Debug|x64.Build.0 = Debug|x64
		{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}.Debug|x86.ActiveCfg = Debug|Win32
		{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}.Debug|x86.Build.0 = Debug|Win32
		{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}.Release|x64.ActiveCfg = Release|x64
		{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}.Release|x64.Build.0 = Release|x64
		{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}.Release|x86.ActiveCfg = Release|Win32
		{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D3BEAACE-9A8E-475A-9E2C-2C7B61293F9D}
	EndGlobalSection
EndGlobal

```

`MouHidInputHook/LICENSE`:

```
MIT License

Copyright (c) 2019 changeofpace

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`MouHidInputHook/MouHidInputHook.inf`:

```inf
;
; MouHidInputHook.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=MouHidInputHook.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="MouHidInputHook Source Disk"

```

`MouHidInputHook/MouHidInputHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B1633E0D-8DBF-4913-AAF7-8E3FB891FDC9}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>MouHidInputHook</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <DisableSpecificWarnings>28751;28175;4748;4505;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <DisableSpecificWarnings>28751;28175;4748;4505;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <DisableSpecificWarnings>28751;28175;4603;4627;4986;4987;4996;4505;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <DisableSpecificWarnings>28751;28175;4603;4627;4986;4987;4996;4505;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="io_util.cpp" />
    <ClCompile Include="log.cpp" />
    <ClCompile Include="mouclass.cpp" />
    <ClCompile Include="mouhid.cpp" />
    <ClCompile Include="mouhid_hook_manager.cpp" />
    <ClCompile Include="mouhid_monitor.cpp" />
    <ClCompile Include="object_util.cpp" />
    <ClCompile Include="pe.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Common\ioctl.h" />
    <ClInclude Include="..\Common\time.h" />
    <ClInclude Include="io_util.h" />
    <ClInclude Include="debug.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="mouclass.h" />
    <ClInclude Include="mouhid.h" />
    <ClInclude Include="mouhid_hook_manager.h" />
    <ClInclude Include="mouhid_monitor.h" />
    <ClInclude Include="nt.h" />
    <ClInclude Include="object_util.h" />
    <ClInclude Include="pe.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`MouHidInputHook/MouHidInputHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="object_util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pe.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="io_util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mouhid_monitor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mouclass.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mouhid_hook_manager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mouhid.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="object_util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pe.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="io_util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Common\ioctl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mouclass.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mouhid_monitor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Common\time.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mouhid_hook_manager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mouhid.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`MouHidInputHook/debug.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

#include "log.h"

/*++

Macro Name:

    DEBUG_BREAK

Macro Description:

    A software breakpoint which is only executed if all of the following
    conditions are true:

        1. Debug build configuration.

        2. Debugging was enabled on the machine at boot time.

        3. A kernel debugger is currently attached to the machine.

--*/
#if defined(DBG)
#define DEBUG_BREAK                 \
    if (!(KD_DEBUGGER_NOT_PRESENT)) \
    {                               \
        DbgBreakPoint();            \
    }
#else
#define DEBUG_BREAK
#endif

/*++

Macro Name:

    VERIFY

Macro Description:

    A validation macro which ASSERTs in debug build configurations and logs
    failures in release build configurations.

Remarks:

    NT_VERIFY and RTL_SOFT_ASSERT are similar utility macros.

--*/
#if defined(VERIFY)
#error "Unexpected identifier conflict. (VERIFY)"
#endif

#if defined(DBG)
#define VERIFY(NtExpression)    (NT_ASSERT(NT_SUCCESS(NtExpression)))
#else
#define VERIFY(NtExpression)                                                \
{                                                                           \
    NTSTATUS Verify_NtStatus_ = (NtExpression);                             \
    if (!NT_SUCCESS(Verify_NtStatus_))                                      \
    {                                                                       \
        ERR_PRINT("\'" #NtExpression "\' failed: 0x%X", Verify_NtStatus_);  \
    }                                                                       \
}
#endif

```

`MouHidInputHook/driver.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include <fltKernel.h>

#include "debug.h"
#include "log.h"
#include "mouhid.h"
#include "mouhid_hook_manager.h"
#include "mouhid_monitor.h"

#include "../Common/ioctl.h"


//=============================================================================
// Private Prototypes
//=============================================================================
EXTERN_C
DRIVER_INITIALIZE
DriverEntry;

EXTERN_C
static
DRIVER_UNLOAD
DriverUnload;

_Dispatch_type_(IRP_MJ_CREATE)
EXTERN_C
static
DRIVER_DISPATCH
DispatchCreate;

_Dispatch_type_(IRP_MJ_CLOSE)
EXTERN_C
static
DRIVER_DISPATCH
DispatchClose;

_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
EXTERN_C
static
DRIVER_DISPATCH
DispatchDeviceControl;


//=============================================================================
// Meta Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT pDriverObject,
    PUNICODE_STRING pRegistryPath
)
{
    PDEVICE_OBJECT pDeviceObject = NULL;
    UNICODE_STRING usDeviceName = {};
    UNICODE_STRING usSymbolicLinkName = {};
    BOOLEAN fSymbolicLinkCreated = FALSE;
    BOOLEAN fMclLoaded = FALSE;
    BOOLEAN fMhkLoaded = FALSE;
    BOOLEAN fMhmLoaded = FALSE;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pRegistryPath);

    DBG_PRINT("Loading %ls.", NT_DEVICE_NAME_U);

    usDeviceName = RTL_CONSTANT_STRING(NT_DEVICE_NAME_U);

    ntstatus = IoCreateDevice(
        pDriverObject,
        0,
        &usDeviceName,
        FILE_DEVICE_MOUHID_INPUT_HOOK,
        FILE_DEVICE_SECURE_OPEN,
        TRUE,
        &pDeviceObject);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("IoCreateDevice failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchClose;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
        DispatchDeviceControl;
    pDriverObject->DriverUnload = DriverUnload;

    //
    // Create a symbolic link for the user mode client.
    //
    usSymbolicLinkName = RTL_CONSTANT_STRING(SYMBOLIC_LINK_NAME_U);

    ntstatus = IoCreateSymbolicLink(&usSymbolicLinkName, &usDeviceName);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("IoCreateSymbolicLink failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fSymbolicLinkCreated = TRUE;

    //
    // Load the driver modules.
    //
    ntstatus = MhdDriverEntry();
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MhdDriverEntry failed: 0x%X", ntstatus);
        goto exit;
    }

    ntstatus = MclDriverEntry(pDriverObject);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MclDriverEntry failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fMclLoaded = TRUE;

    ntstatus = MhkDriverEntry();
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MhkDriverEntry failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fMhkLoaded = TRUE;

    ntstatus = MhmDriverEntry();
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MhmDriverEntry failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fMhmLoaded = TRUE;

    DBG_PRINT("%ls loaded.", NT_DEVICE_NAME_U);

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (fMhmLoaded)
        {
            MhmDriverUnload();
        }

        if (fMhkLoaded)
        {
            MhkDriverUnload();
        }

        if (fMclLoaded)
        {
            MclDriverUnload();
        }

        if (fSymbolicLinkCreated)
        {
            VERIFY(IoDeleteSymbolicLink(&usSymbolicLinkName));
        }

        if (pDeviceObject)
        {
            IoDeleteDevice(pDeviceObject);
        }
    }

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
static
VOID
DriverUnload(
    PDRIVER_OBJECT pDriverObject
)
{
    UNICODE_STRING usSymbolicLinkName = {};

    DBG_PRINT("Unloading %ls.", NT_DEVICE_NAME_U);

    //
    // Unload the driver modules.
    //
    MhmDriverUnload();
    MhkDriverUnload();
    MclDriverUnload();

    //
    // Release driver resources.
    //
    usSymbolicLinkName = RTL_CONSTANT_STRING(SYMBOLIC_LINK_NAME_U);

    VERIFY(IoDeleteSymbolicLink(&usSymbolicLinkName));

    if (pDriverObject->DeviceObject)
    {
        IoDeleteDevice(pDriverObject->DeviceObject);
    }

    DBG_PRINT("%ls unloaded.", NT_DEVICE_NAME_U);
}


//=============================================================================
// Private Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
DispatchCreate(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
)
{
    UNREFERENCED_PARAMETER(pDeviceObject);
    DBG_PRINT("Processing IRP_MJ_CREATE.");
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
DispatchClose(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pDeviceObject);

    DBG_PRINT("Processing IRP_MJ_CLOSE.");

    //
    // Manually disable the MouHid Monitor in case the user mode client failed
    //  to disable it.
    //
    VERIFY(MhmDisableMouHidMonitor());

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
DispatchDeviceControl(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
)
{
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    PVOID pSystemBuffer = pIrp->AssociatedIrp.SystemBuffer;
    ULONG cbInput = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG cbOutput = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    PQUERY_MOUHID_INPUT_MONITOR_REPLY pQueryMouHidInputMonitorReply = NULL;
    ULONG_PTR Information = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pDeviceObject);

    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_QUERY_MOUHID_INPUT_MONITOR:
            DBG_PRINT("Processing IOCTL_QUERY_MOUHID_INPUT_MONITOR.");

            if (cbInput)
            {
                ntstatus = STATUS_INVALID_PARAMETER_4;
                goto exit;
            }

            pQueryMouHidInputMonitorReply =
                (PQUERY_MOUHID_INPUT_MONITOR_REPLY)pSystemBuffer;
            if (!pQueryMouHidInputMonitorReply)
            {
                ntstatus = STATUS_INVALID_PARAMETER_5;
                goto exit;
            }

            if (sizeof(*pQueryMouHidInputMonitorReply) != cbOutput)
            {
                ntstatus = STATUS_INVALID_BUFFER_SIZE;
                goto exit;
            }

            ntstatus = MhmQueryMouHidMonitor(
                &pQueryMouHidInputMonitorReply->Enabled);
            if (!NT_SUCCESS(ntstatus))
            {
                ERR_PRINT("MhmQueryMouHidMonitor failed: 0x%X", ntstatus);
                goto exit;
            }

            Information = sizeof(*pQueryMouHidInputMonitorReply);

            break;

        case IOCTL_ENABLE_MOUHID_INPUT_MONITOR:
            DBG_PRINT("Processing IOCTL_ENABLE_MOUHID_INPUT_MONITOR.");

            if (cbInput || cbOutput)
            {
                ntstatus = STATUS_INVALID_PARAMETER;
                goto exit;
            }

            ntstatus = MhmEnableMouHidMonitor();
            if (!NT_SUCCESS(ntstatus))
            {
                ERR_PRINT("MhmEnableMouHidMonitor failed: 0x%X", ntstatus);
                goto exit;
            }

            break;

        case IOCTL_DISABLE_MOUHID_INPUT_MONITOR:
            DBG_PRINT("Processing IOCTL_DISABLE_MOUHID_INPUT_MONITOR.");

            if (cbInput || cbOutput)
            {
                ntstatus = STATUS_INVALID_PARAMETER;
                goto exit;
            }

            ntstatus = MhmDisableMouHidMonitor();
            if (!NT_SUCCESS(ntstatus))
            {
                ERR_PRINT("MhmDisableMouHidMonitor failed: 0x%X", ntstatus);
                goto exit;
            }

            break;

        default:
            ERR_PRINT(
                "Unhandled IOCTL."
                " (MajorFunction = %hhu, MinorFunction = %hhu)",
                pIrpStack->MajorFunction,
                pIrpStack->MinorFunction);
            ntstatus = STATUS_UNSUCCESSFUL;
            goto exit;
    }

exit:
    pIrp->IoStatus.Information = Information;
    pIrp->IoStatus.Status = ntstatus;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return ntstatus;
}

```

`MouHidInputHook/io_util.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "io_util.h"

#include "log.h"
#include "object_util.h"


_Use_decl_annotations_
EXTERN_C
NTSTATUS
IouEnumerateDeviceObjectList(
    PDRIVER_OBJECT pDriverObject,
    PDEVICE_OBJECT** pppDeviceObjectList,
    PULONG pnDeviceObjectList
)
/*++

Routine Description:

    A convenience wrapper for IoEnumerateDeviceObjectList.

Parameters:

    pDriverObject - Pointer to the target driver object.

    pppDeviceObjectList - Returns a pointer to an allocated device object list
        for the target driver object. This function increments the reference
        count of every device object in the list. The list is allocated from
        the NonPaged pool.

    pnDeviceObjectList - Returns the number of elements in the allocated list.

Remarks:

    If successful, the caller must free the returned list by calling
    IouFreeDeviceObjectList.

    NOTE The returned device object list is a snapshot of the devices which
    were attached to the target driver object at the time of the call.

--*/
{
    ULONG NumberOfElements = 0;
    PDEVICE_OBJECT* ppDeviceObjectList = NULL;
    ULONG cbDeviceObjectList = 0;
    ULONG nDeviceObjectList = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *pppDeviceObjectList = NULL;
    *pnDeviceObjectList = 0;

    //
    // NOTE We start with an initial list size of one so that we do not attempt
    //  to allocate zero memory.
    //
    for (NumberOfElements = 1;; NumberOfElements = nDeviceObjectList)
    {
        cbDeviceObjectList = NumberOfElements * sizeof(*ppDeviceObjectList);

        ppDeviceObjectList = (PDEVICE_OBJECT*)ExAllocatePool(
            NonPagedPool,
            cbDeviceObjectList);
        if (!ppDeviceObjectList)
        {
            ntstatus = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        //
        RtlSecureZeroMemory(ppDeviceObjectList, cbDeviceObjectList);

        ntstatus = IoEnumerateDeviceObjectList(
            pDriverObject,
            ppDeviceObjectList,
            cbDeviceObjectList,
            &nDeviceObjectList);
        if (NT_SUCCESS(ntstatus))
        {
            break;
        }
        else if (STATUS_BUFFER_TOO_SMALL != ntstatus)
        {
            ERR_PRINT("IoEnumerateDeviceObjectList failed: 0x%X", ntstatus);
            nDeviceObjectList = NumberOfElements;
            goto exit;
        }

        IouFreeDeviceObjectList(ppDeviceObjectList, NumberOfElements);
    }

    //
    // Set out parameters.
    //
    *pppDeviceObjectList = ppDeviceObjectList;
    *pnDeviceObjectList = nDeviceObjectList;

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (ppDeviceObjectList)
        {
            NT_ASSERT(nDeviceObjectList);

            IouFreeDeviceObjectList(ppDeviceObjectList, nDeviceObjectList);
        }
    }

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
VOID
IouFreeDeviceObjectList(
    PDEVICE_OBJECT* ppDeviceObjectList,
    ULONG nDeviceObjectList
)
{
    ULONG i = 0;

    for (i = 0; i < nDeviceObjectList; ++i)
    {
        if (ppDeviceObjectList[i])
        {
            ObDereferenceObject(ppDeviceObjectList[i]);
        }
    }

    ExFreePool(ppDeviceObjectList);
}


//
// KeReleaseQueuedSpinLock SAL annotations do not mirror
//  KeAcquireQueuedSpinLock annotations.
//
#pragma warning(suppress: 28166)
//
_Use_decl_annotations_
EXTERN_C
PDEVICE_OBJECT
IouGetUpperDeviceObject(
    PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

    Returns a referenced pointer to the next upper-level device object on the
    driver stack or NULL if there is no upper-level device.

Parameters:

    pDeviceObject - Pointer to the target device object.

Remarks:

    If successful, the caller must dereference the returned device object
    pointer by calling ObDereferenceObject.

--*/
{
    KIRQL PreviousIrql = 0;
    PDEVICE_OBJECT pAttachedDevice = NULL;

    PreviousIrql = KeAcquireQueuedSpinLock(LockQueueIoDatabaseLock);

    pAttachedDevice = pDeviceObject->AttachedDevice;
    if (pAttachedDevice)
    {
        ObReferenceObject(pAttachedDevice);
    }

    KeReleaseQueuedSpinLock(LockQueueIoDatabaseLock, PreviousIrql);

    return pAttachedDevice;
}


#if defined(DBG)
_Use_decl_annotations_
EXTERN_C
VOID
IouPrintDeviceObjectList(
    PWSTR pwzDriverName,
    PDEVICE_OBJECT* ppDeviceObjectList,
    ULONG nDeviceObjectList
)
{
    POBJECT_NAME_INFORMATION pObjectNameInfo = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Device Object List (DriverName = %ls):", pwzDriverName);

    for (ULONG i = 0; i < nDeviceObjectList; ++i)
    {
        ntstatus = ObuQueryNameString(ppDeviceObjectList[i], &pObjectNameInfo);
        if (!NT_SUCCESS(ntstatus))
        {
            ERR_PRINT("ObuQueryNameString failed: 0x%X (%u)", ntstatus, i);
            continue;
        }

        if (pObjectNameInfo->Name.Buffer)
        {
            DBG_PRINT("    %u: DeviceObject = %p, Name = %wZ",
                i,
                ppDeviceObjectList[i],
                pObjectNameInfo->Name);
        }
        else
        {
            DBG_PRINT("    %u: DeviceObject = %p, Name = (unnamed)",
                i,
                ppDeviceObjectList[i]);
        }

        ExFreePool(pObjectNameInfo);
    }
}
#endif

```

`MouHidInputHook/io_util.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
IouEnumerateDeviceObjectList(
    _In_ PDRIVER_OBJECT pDriverObject,
    _Outptr_result_nullonfailure_ PDEVICE_OBJECT** pppDeviceObjectList,
    _Out_ PULONG pnDeviceObjectList
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
VOID
IouFreeDeviceObjectList(
    _Pre_notnull_ __drv_freesMem(Mem) PDEVICE_OBJECT* ppDeviceObjectList,
    _In_ ULONG nDeviceObjectList
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
PDEVICE_OBJECT
IouGetUpperDeviceObject(
    _In_ PDEVICE_OBJECT pDeviceObject
);

#if defined(DBG)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
VOID
IouPrintDeviceObjectList(
    _In_ PWSTR pwzDriverName,
    _In_ PDEVICE_OBJECT* ppDeviceObjectList,
    _In_ ULONG nDeviceObjectList
);
#endif

```

`MouHidInputHook/log.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "log.h"

#define NTSTRSAFE_NO_CB_FUNCTIONS

#include <ntstrsafe.h>

#include "debug.h"
#include "nt.h"


//=============================================================================
// Constants
//=============================================================================
#define OUTPUT_BUFFER_CCH_MAX   512
#define TIME_BUFFER_CCH_MAX     20
#define MESSAGE_BUFFER_CCH_MAX  \
    (OUTPUT_BUFFER_CCH_MAX - TIME_BUFFER_CCH_MAX - 80)


//=============================================================================
// Public Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
LogPrint(
    LOG_LEVEL Level,
    ULONG Options,
    PCHAR pszFormat,
    ...
)
{
    PCHAR pszLogLevel = NULL;
    LARGE_INTEGER SystemTime = {};
    LARGE_INTEGER LocalTime = {};
    TIME_FIELDS TimeFields = {};
    CHAR szTimeBuffer[TIME_BUFFER_CCH_MAX] = {};
    va_list VarArgs = {};
    CHAR szMessageBuffer[MESSAGE_BUFFER_CCH_MAX] = {};
    PCHAR pszOutputFormat = NULL;
    CHAR szOutputBuffer[OUTPUT_BUFFER_CCH_MAX] = {};
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Set the log level prefix.
    //
    switch (Level)
    {
        case LogLevelDebug:     pszLogLevel = "DBG"; break;
        case LogLevelInfo:      pszLogLevel = "INF"; break;
        case LogLevelWarning:   pszLogLevel = "WRN"; break;
        case LogLevelError:     pszLogLevel = "ERR"; break;
        default:
            ntstatus = STATUS_INVALID_PARAMETER_1;
            DEBUG_BREAK;
            goto exit;
    }

    //
    // Query the current local time.
    //
    KeQuerySystemTime(&SystemTime);
    ExSystemTimeToLocalTime(&SystemTime, &LocalTime);
    RtlTimeToTimeFields(&LocalTime, &TimeFields);

    ntstatus = RtlStringCchPrintfA(
        szTimeBuffer,
        RTL_NUMBER_OF(szTimeBuffer),
        "%02hd:%02hd:%02hd.%03hd",
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second,
        TimeFields.Milliseconds);
    if (!NT_SUCCESS(ntstatus))
    {
        DEBUG_BREAK;
        goto exit;
    }

    va_start(VarArgs, pszFormat);
    ntstatus = RtlStringCchVPrintfA(
        szMessageBuffer,
        RTL_NUMBER_OF(szMessageBuffer),
        pszFormat,
        VarArgs);
    va_end(VarArgs);
    if (!NT_SUCCESS(ntstatus))
    {
        DEBUG_BREAK;
        goto exit;
    }

    if (LOG_OPTION_APPEND_CRLF & Options)
    {
        pszOutputFormat = "%s  %s  %04Iu:%04Iu  %-15s  %s\r\n";
    }
    else
    {
        pszOutputFormat = "%s  %s  %04Iu:%04Iu  %-15s  %s";
    }

    ntstatus = RtlStringCchPrintfA(
        szOutputBuffer,
        RTL_NUMBER_OF(szOutputBuffer),
        pszOutputFormat,
        szTimeBuffer,
        pszLogLevel,
        (ULONG_PTR)PsGetProcessId(PsGetCurrentProcess()),
        (ULONG_PTR)PsGetCurrentThreadId(),
        PsGetProcessImageFileName(PsGetCurrentProcess()),
        szMessageBuffer);
    if (!NT_SUCCESS(ntstatus))
    {
        DEBUG_BREAK;
        goto exit;
    }

    ntstatus = DbgPrintEx(
        DPFLTR_DEFAULT_ID,
        DPFLTR_ERROR_LEVEL,
        "%s",
        szOutputBuffer);
    if (!NT_SUCCESS(ntstatus))
    {
        DEBUG_BREAK;
        goto exit;
    }

exit:
    return ntstatus;
}

```

`MouHidInputHook/log.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

//=============================================================================
// Constants
//=============================================================================
#define LOG_OPTION_APPEND_CRLF          0x00000001

//=============================================================================
// Enumerations
//=============================================================================
typedef enum _LOG_LEVEL {
    LogLevelDebug,
    LogLevelInfo,
    LogLevelWarning,
    LogLevelError,
} LOG_LEVEL, *PLOG_LEVEL;

//=============================================================================
// Public Interface
//=============================================================================
_IRQL_requires_same_
EXTERN_C
NTSTATUS
LogPrint(
    _In_ LOG_LEVEL Level,
    _In_ ULONG Options,
    _In_z_ _Printf_format_string_ PCHAR pszFormat,
    ...
);

#if defined(DBG)
#define DBG_PRINT(Format, ...) \
    LogPrint(LogLevelDebug, LOG_OPTION_APPEND_CRLF, (Format), __VA_ARGS__)
#else
//
// Debug level messages are disabled in release builds.
//
#define DBG_PRINT(Format, ...)
#endif

#define INF_PRINT(Format, ...) \
    LogPrint(LogLevelInfo, LOG_OPTION_APPEND_CRLF, (Format), __VA_ARGS__)

#define WRN_PRINT(Format, ...)  \
    LogPrint(                   \
        LogLevelWarning,        \
        LOG_OPTION_APPEND_CRLF, \
        (Format),               \
        __VA_ARGS__)

#define ERR_PRINT(Format, ...) \
    LogPrint(LogLevelError, LOG_OPTION_APPEND_CRLF, (Format), __VA_ARGS__)

```

`MouHidInputHook/mouclass.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "mouclass.h"

#include <wdmguid.h>

#include "debug.h"
#include "log.h"

#if defined(DBG)
#include "io_util.h"
#include "nt.h"
#endif


//=============================================================================
// Constants
//=============================================================================
#define MODULE_TITLE    "MouClass Manager"


//=============================================================================
// Private Types
//=============================================================================
typedef struct _PNP_NOTIFICATION_CONTEXT
{
    _Interlocked_ volatile POINTER_ALIGNMENT LONG64 ArrivalEvents;
    _Interlocked_ volatile POINTER_ALIGNMENT LONG64 RemovalEvents;

} PNP_NOTIFICATION_CONTEXT, *PPNP_NOTIFICATION_CONTEXT;

typedef struct _MCL_REGISTRATION_ENTRY
{
    LIST_ENTRY ListEntry;
    PMOUSE_PNP_NOTIFICATION_CALLBACK_ROUTINE Callback;
    PVOID Context;

} MCL_REGISTRATION_ENTRY, *PMCL_REGISTRATION_ENTRY;

typedef struct _MOUCLASS_MANAGER
{
    PVOID PnpNotificationHandle;
    PNP_NOTIFICATION_CONTEXT PnpNotificationContext;

    POINTER_ALIGNMENT ERESOURCE Resource;
    _Guarded_by_(Resource) LIST_ENTRY RegisteredCallbackListHead;

} MOUCLASS_MANAGER, *PMOUCLASS_MANAGER;


//=============================================================================
// Module Globals
//=============================================================================
EXTERN_C static MOUCLASS_MANAGER g_MclManager = {};


//=============================================================================
// Private Prototypes
//=============================================================================
_Requires_lock_not_held_(g_MclManager.Resource)
EXTERN_C
static
DRIVER_NOTIFICATION_CALLBACK_ROUTINE
MclpPnpNotificationCallbackRoutine;


//=============================================================================
// Meta Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
MclDriverEntry(
    PDRIVER_OBJECT pDriverObject
)
/*++

Routine Description:

    Initializes the MouClass Manager module.

Parameters:

    pDriverObject - Pointer to the driver object for this driver.

Required Modules:

    None

Remarks:

    If successful, the caller must call MclDriverUnload when the driver is
    unloaded.

--*/
{
    PVOID PnpNotificationHandle = NULL;
    BOOLEAN fPnpCallbackRegistered = FALSE;
    BOOLEAN fResourceInitialized = FALSE;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Loading %s.", MODULE_TITLE);

#if defined(DBG)
    VERIFY(MclPrintMouClassDeviceObjects());
#endif

    //
    // Register for mouse device interface notifications.
    //
    ntstatus = IoRegisterPlugPlayNotification(
        EventCategoryDeviceInterfaceChange,
        0,
        (PVOID)&GUID_DEVINTERFACE_MOUSE,
        pDriverObject,
        MclpPnpNotificationCallbackRoutine,
        &g_MclManager.PnpNotificationContext,
        &PnpNotificationHandle);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("IoRegisterPlugPlayNotification failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fPnpCallbackRegistered = TRUE;

    ntstatus = ExInitializeResourceLite(&g_MclManager.Resource);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("ExInitializeResourceLite failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fResourceInitialized = TRUE;

    //
    // Initialize the global context.
    //
    g_MclManager.PnpNotificationHandle = PnpNotificationHandle;
    InitializeListHead(&g_MclManager.RegisteredCallbackListHead);

    DBG_PRINT("%s loaded.", MODULE_TITLE);

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (fResourceInitialized)
        {
            VERIFY(ExDeleteResourceLite(&g_MclManager.Resource));
        }

        if (fPnpCallbackRegistered)
        {
            VERIFY(IoUnregisterPlugPlayNotificationEx(PnpNotificationHandle));
        }
    }

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
VOID
MclDriverUnload()
{
    DBG_PRINT("Unloading %s.", MODULE_TITLE);

    NT_ASSERT(IsListEmpty(&g_MclManager.RegisteredCallbackListHead));

    VERIFY(IoUnregisterPlugPlayNotificationEx(
        g_MclManager.PnpNotificationHandle));

    VERIFY(ExDeleteResourceLite(&g_MclManager.Resource));

    DBG_PRINT("%s unloaded.", MODULE_TITLE);
}


//=============================================================================
// Public Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
MclRegisterMousePnpNotificationCallback(
    PMOUSE_PNP_NOTIFICATION_CALLBACK_ROUTINE pCallback,
    PVOID pContext,
    PHANDLE pRegistrationHandle
)
/*++

Routine Description:

    Registers a mouse PnP notification callback.

Parameters:

    pCallback - Pointer to the callback to be registered.

    pContext - Pointer to caller-defined data to be passed as the context
        parameter each time the callback is invoked.

    pRegistrationHandle - Returns an opaque registration handle to be used to
        unregister the callback.

Remarks:

    If successful, the caller must unregister the callback by calling
    MclUnregisterMousePnpNotificationCallback.

--*/
{
    PMCL_REGISTRATION_ENTRY pEntry = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *pRegistrationHandle = NULL;

    //
    // Allocate and initialize a new registration entry.
    //
    pEntry = (PMCL_REGISTRATION_ENTRY)ExAllocatePool(
        NonPagedPool,
        sizeof(*pEntry));
    if (!pEntry)
    {
        ntstatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    //
    RtlSecureZeroMemory(pEntry, sizeof(*pEntry));

    pEntry->Callback = pCallback;
    pEntry->Context = pContext;

    //
    // Insert the new entry into the registered callback list.
    //
    ExEnterCriticalRegionAndAcquireResourceExclusive(&g_MclManager.Resource);

    InsertTailList(
        &g_MclManager.RegisteredCallbackListHead,
        &pEntry->ListEntry);

    ExReleaseResourceAndLeaveCriticalRegion(&g_MclManager.Resource);

    DBG_PRINT(
        "Registered mouse PnP notification callback."
        " (Callback = %p, Context = %p, RegistrationHandle = %p)",
        pCallback,
        pContext,
        pEntry);

    //
    // Set out parameters.
    //
    *pRegistrationHandle = (HANDLE)pEntry;

exit:
    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
VOID
MclUnregisterMousePnpNotificationCallback(
    HANDLE RegistrationHandle
)
{
    PMCL_REGISTRATION_ENTRY pEntry = NULL;

    pEntry = (PMCL_REGISTRATION_ENTRY)RegistrationHandle;

    ExEnterCriticalRegionAndAcquireResourceExclusive(&g_MclManager.Resource);

    RemoveEntryList(&pEntry->ListEntry);

    ExReleaseResourceAndLeaveCriticalRegion(&g_MclManager.Resource);

    ExFreePool(pEntry);

    DBG_PRINT(
        "Unregistered mouse PnP notification callback."
        " (RegistrationHandle = %p)",
        RegistrationHandle);
}


_Use_decl_annotations_
EXTERN_C
VOID
MclPrintInputPacket(
    ULONG64 PacketId,
    PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallback,
    PDEVICE_OBJECT pDeviceObject,
    PMOUSE_INPUT_DATA pInputPacket
)
{
    INF_PRINT(
        "Mouse Packet %I64u: SC=%p DO=%p ID=%hu IF=0x%03hX BF=0x%03hX"
        " BD=0x%04hX RB=0x%X EX=0x%X LX=%d LY=%d",
        PacketId,
        pServiceCallback,
        pDeviceObject,
        pInputPacket->UnitId,
        pInputPacket->Flags,
        pInputPacket->ButtonFlags,
        pInputPacket->ButtonData,
        pInputPacket->RawButtons,
        pInputPacket->ExtraInformation,
        pInputPacket->LastX,
        pInputPacket->LastY);
}


//=============================================================================
// Private Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
MclpPnpNotificationCallbackRoutine(
    PVOID pNotificationStructure,
    PVOID pNotificationContext
)
{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION pNotification = NULL;
    PPNP_NOTIFICATION_CONTEXT pContext = NULL;
    MOUSE_PNP_NOTIFICATION_EVENT Event = {};
    ULONG64 nEvents = 0;
    BOOLEAN fResourceAcquired = FALSE;
    PLIST_ENTRY pListEntry = NULL;
    PMCL_REGISTRATION_ENTRY pEntry = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    pNotification =
        (PDEVICE_INTERFACE_CHANGE_NOTIFICATION)pNotificationStructure;
    pContext = (PPNP_NOTIFICATION_CONTEXT)pNotificationContext;

    if (IsEqualGUID(pNotification->Event, GUID_DEVICE_INTERFACE_ARRIVAL))
    {
        Event = MousePnpNotificationEventArrival;

        nEvents = InterlockedIncrement64(&pContext->ArrivalEvents);

        DBG_PRINT("Device interface arrival (%I64u): %wZ",
            nEvents,
            pNotification->SymbolicLinkName);
    }
    else if (IsEqualGUID(pNotification->Event, GUID_DEVICE_INTERFACE_REMOVAL))
    {
        Event = MousePnpNotificationEventRemoval;

        nEvents = InterlockedIncrement64(&pContext->RemovalEvents);

        DBG_PRINT("Device interface removal (%I64u): %wZ",
            nEvents,
            pNotification->SymbolicLinkName);
    }
    else
    {
        ERR_PRINT(
            "Unexpected device interface change GUID."
            " (SymbolicLinkName = %wZ)",
            pNotification->SymbolicLinkName);
        DEBUG_BREAK;
        goto exit;
    }

    //
    // Invoke each registered callback.
    //
    ExEnterCriticalRegionAndAcquireResourceShared(&g_MclManager.Resource);
    fResourceAcquired = TRUE;

    for (pListEntry = g_MclManager.RegisteredCallbackListHead.Flink;
        pListEntry != &g_MclManager.RegisteredCallbackListHead;
        pListEntry = pListEntry->Flink)
    {
        pEntry = CONTAINING_RECORD(
            pListEntry,
            MCL_REGISTRATION_ENTRY,
            ListEntry);

        pEntry->Callback(Event, pEntry->Context);
    }

exit:
    if (fResourceAcquired)
    {
        ExReleaseResourceAndLeaveCriticalRegion(&g_MclManager.Resource);
    }

    return ntstatus;
}


#if defined(DBG)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MclPrintMouClassDeviceObjects()
{
    UNICODE_STRING usDriverObject = {};
    PDRIVER_OBJECT pDriverObject = NULL;
    BOOLEAN fHasDriverObjectReference = FALSE;
    PDEVICE_OBJECT* ppDeviceObjectList = NULL;
    ULONG nDeviceObjectList = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    usDriverObject = RTL_CONSTANT_STRING(MOUCLASS_DRIVER_OBJECT_PATH_U);

    ntstatus = ObReferenceObjectByName(
        &usDriverObject,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        0,
        *IoDriverObjectType,
        KernelMode,
        NULL,
        (PVOID*)&pDriverObject);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("ObReferenceObjectByName failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fHasDriverObjectReference = TRUE;

    //
    // Get a snapshot of all the  device objects.
    //
    ntstatus = IouEnumerateDeviceObjectList(
        pDriverObject,
        &ppDeviceObjectList,
        &nDeviceObjectList);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("IouEnumerateDeviceObjectList failed: 0x%X", ntstatus);
        goto exit;
    }

    IouPrintDeviceObjectList(
        MOUCLASS_DRIVER_OBJECT_PATH_U,
        ppDeviceObjectList,
        nDeviceObjectList);

exit:
    if (ppDeviceObjectList)
    {
        IouFreeDeviceObjectList(ppDeviceObjectList, nDeviceObjectList);
    }

    if (fHasDriverObjectReference)
    {
        ObDereferenceObject(pDriverObject);
    }

    return ntstatus;
}
#endif

```

`MouHidInputHook/mouclass.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

#include <ntddmou.h>

//=============================================================================
// Constants
//=============================================================================
#define MOUCLASS_DRIVER_OBJECT_PATH_U   L"\\Driver\\mouclass"

//=============================================================================
// Enumerations
//=============================================================================
typedef enum _MOUSE_PNP_NOTIFICATION_EVENT
{
    MousePnpNotificationEventInvalid = 0,
    MousePnpNotificationEventArrival,
    MousePnpNotificationEventRemoval,

} MOUSE_PNP_NOTIFICATION_EVENT, *PMOUSE_PNP_NOTIFICATION_EVENT;

//=============================================================================
// Public Types
//=============================================================================
/*++

Type Name:

    MOUSE_SERVICE_CALLBACK_ROUTINE

Type Description:

    The mouse class service callback routine.

Parameters:

    pDeviceObject - Pointer to the mouse class device object to receive the
        mouse input data packets.

    pInputDataStart - Pointer to the array of input packets to be copied to the
        class data queue.

    pInputDataEnd - Pointer to the input packet which marks the end of the
        input packet array.

    pnInputDataConsumed - Returns the number of input packets copied to the
        class data queue by the routine.

Remarks:

    This is the mouse class implementation of a PSERVICE_CALLBACK_ROUTINE.

--*/
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
typedef
VOID
NTAPI
MOUSE_SERVICE_CALLBACK_ROUTINE(
    _In_    PDEVICE_OBJECT      pDeviceObject,
    _In_    PMOUSE_INPUT_DATA   pInputDataStart,
    _In_    PMOUSE_INPUT_DATA   pInputDataEnd,
    _Inout_ PULONG              pnInputDataConsumed
    );

typedef MOUSE_SERVICE_CALLBACK_ROUTINE *PMOUSE_SERVICE_CALLBACK_ROUTINE;

/*++

Type Name:

    MOUSE_PNP_NOTIFICATION_CALLBACK_ROUTINE

Type Description:

    A callback which is invoked each time a mouse device is added to or removed
    from the system.

Parameters:

    Event - The PnP device interface change event which caused the callback to
        be invoked.

    pContext - Pointer to caller-defined data specified at callback
        registration.

Remarks:

    WARNING Mouse PnP notification callbacks are invoked as part of the PnP
    notification chain so they must not block or execute for a significant
    amount of time.

    WARNING It is not safe for a mouse PnP notification callback to invoke
    MclRegisterMousePnpNotificationCallback or
    MclUnregisterMousePnpNotificationCallback.

--*/
_IRQL_requires_max_(PASSIVE_LEVEL)
typedef
VOID
NTAPI
MOUSE_PNP_NOTIFICATION_CALLBACK_ROUTINE(
    _In_        MOUSE_PNP_NOTIFICATION_EVENT    Event,
    _Inout_opt_ PVOID                           pContext
    );

typedef MOUSE_PNP_NOTIFICATION_CALLBACK_ROUTINE
    *PMOUSE_PNP_NOTIFICATION_CALLBACK_ROUTINE;

//=============================================================================
// Meta Interface
//=============================================================================
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MclDriverEntry(
    _In_ PDRIVER_OBJECT pDriverObject
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
VOID
MclDriverUnload();

//=============================================================================
// Public Interface
//=============================================================================
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MclRegisterMousePnpNotificationCallback(
    _In_ PMOUSE_PNP_NOTIFICATION_CALLBACK_ROUTINE pCallback,
    _In_opt_ PVOID pContext,
    _Outptr_result_nullonfailure_ PHANDLE pRegistrationHandle
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
VOID
MclUnregisterMousePnpNotificationCallback(
    _Inout_ HANDLE RegistrationHandle
);

_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_same_
EXTERN_C
VOID
MclPrintInputPacket(
    _In_ ULONG64 PacketId,
    _In_ PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallback,
    _In_ PDEVICE_OBJECT pDeviceObject,
    _In_ PMOUSE_INPUT_DATA pInputPacket
);

#if defined(DBG)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MclPrintMouClassDeviceObjects();
#endif

```

`MouHidInputHook/mouhid.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "mouhid.h"

#include <kbdmou.h>

#include "io_util.h"
#include "log.h"
#include "nt.h"
#include "pe.h"


//=============================================================================
// Constants
//=============================================================================
#define MODULE_TITLE    "MouHid Context"

//
// We choose a search limit by adding a small delta to the actual connect data
//  offset. This delta accounts for the field offset changing in future
//  versions of the MouHid driver.
//
// The actual offset can be found in the IOCTL_INTERNAL_MOUSE_CONNECT case of
//  the MouHid IRP_MJ_INTERNAL_DEVICE_CONTROL handler, mouhid!MouHid_IOCTL:
//
//  Platform:   Windows 7 x64
//  File:       mouhid.sys
//  Version:    6.1.7600.16385 (win7_rtm.090713-1255)
//  Ioctl Code: 0xF0203 (IOCTL_INTERNAL_MOUSE_CONNECT)
//
//  Annotated Assembly:
//
//      mov     rax, [rsi+_IO_STACK_LOCATION.Parameters.DeviceIoControl.Type3InputBuffer]
//      movdqu  xmm0, xmmword ptr [rax+CONNECT_DATA.ClassDeviceObject]
//      movdqu  xmmword ptr [r12+MOUHID_DEVICE_EXTENSION.ConnectData_B8.ClassDeviceObject], xmm0
//
//  Unannotated Assembly:
//
//      mov     rax, [rsi+20h]
//      movdqu  xmm0, xmmword ptr [rax]
//      movdqu  xmmword ptr [r12+0B8h], xmm0
//
#define DEVICE_EXTENSION_SEARCH_SIZE    0x100


//=============================================================================
// Private Types
//=============================================================================
typedef struct _MOUHID_CONTEXT
{
    //
    // The field offset, in bytes, of the CONNECT_DATA object in the device
    //  extension of a MouHid device object.
    //
    SIZE_T ConnectDataFieldOffset;

} MOUHID_CONTEXT, *PMOUHID_CONTEXT;


//=============================================================================
// Module Globals
//=============================================================================
EXTERN_C static MOUHID_CONTEXT g_MhdContext = {};


//=============================================================================
// Private Prototypes
//=============================================================================
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
static
NTSTATUS
MhdpResolveConnectDataFieldOffsetForDevice(
    _In_ PDEVICE_OBJECT pDeviceObject,
    _Out_ PSIZE_T pcbConnectDataFieldOffset
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
static
NTSTATUS
MhdpResolveConnectDataFieldOffset(
    _Out_ PSIZE_T pcbConnectDataFieldOffset
);


//=============================================================================
// Meta Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
MhdDriverEntry()
/*++

Routine Description:

    Initializes the MouHid Context module.

Required Modules:

    None

--*/
{
    SIZE_T cbConnectDataFieldOffset = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Loading %s.", MODULE_TITLE);

    ntstatus = MhdpResolveConnectDataFieldOffset(&cbConnectDataFieldOffset);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MhdpResolveConnectDataFieldOffset failed: 0x%X",
            ntstatus);
        goto exit;
    }

    //
    // Initialize the global context.
    //
    g_MhdContext.ConnectDataFieldOffset = cbConnectDataFieldOffset;

    DBG_PRINT("%s loaded:", MODULE_TITLE);
    DBG_PRINT("    ConnectDataFieldOffset:      0x%IX",
        g_MhdContext.ConnectDataFieldOffset);

exit:
    return ntstatus;
}


//=============================================================================
// Public Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
SIZE_T
MhdGetConnectDataFieldOffset()
{
    return g_MhdContext.ConnectDataFieldOffset;
}


//=============================================================================
// Private Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
MhdpResolveConnectDataFieldOffsetForDevice(
    PDEVICE_OBJECT pDeviceObject,
    PSIZE_T pcbConnectDataFieldOffset
)
/*++

Routine Description:

    Dynamically resolves the field offset of the CONNECT_DATA object in the
    device extension of the specified MouHid device object.

Parameters:

    pDeviceObject - Referenced pointer to a MouHid device object.

    pcbConnectDataFieldOffset - Returns the field offset of the CONNECT_DATA
        for the specified MouHid device object.

Remarks:

    This routine utilizes knowledge of the MouClass communication protocol as a
    heuristic for resolving the CONNECT_DATA field offset.

    Heuristic:

        1. Obtain a list of all the MouHid device objects.

        2. For each MouHid device object:

            2.a Get the device object attached to the MouHid device object.

            2.b Get the address range of every executable image section in the
                driver of the attached device object.

            2.c Search the device extension of the MouHid device object for a
                valid CONNECT_DATA object by interpreting each pointer-aligned
                address as a CONNECT_DATA candidate. A candidate is valid if it
                meets the following criteria:

                    i. The 'ClassDeviceObject' field matches the attached
                        device object.

                    ii. The 'ClassService' field points to an address contained
                        in one of the executable image sections from (2.b).

    NOTE This heuristic may be applicable to other types of mouse device
    stacks, e.g., PS/2.

--*/
{
    PDEVICE_OBJECT pAttachedDevice = NULL;
    PVOID pDriverStart = NULL;
    ULONG_PTR ImageBase = 0;
    PIMAGE_SECTION_HEADER* ppExecutableSections = NULL;
    ULONG nExecutableSections = 0;
    PVOID pDeviceExtension = NULL;
    SIZE_T Span = 0;
    ULONG_PTR SearchEnd = 0;
    PCONNECT_DATA pConnectData = NULL;
    ULONG i = 0;
    ULONG_PTR SectionBase = 0;
    BOOLEAN fClassServiceValidated = FALSE;
    SIZE_T cbConnectDataFieldOffset = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *pcbConnectDataFieldOffset = 0;

    DBG_PRINT(
        "Resolving MouHid connect data field offset for device."
        " (DeviceObject = %p)",
        pDeviceObject);

    //
    // Get a referenced pointer to the device object attached to the current
    //  MouHid device object.
    //
    pAttachedDevice = IouGetUpperDeviceObject(pDeviceObject);
    if (!pAttachedDevice)
    {
        ERR_PRINT("Unexpected AttachedDevice. (DeviceObject = %p)",
            pDeviceObject);
        ntstatus = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    //
    // Get the executable image sections for the driver of the attached device.
    //
    pDriverStart = pAttachedDevice->DriverObject->DriverStart;
    if (!pDriverStart)
    {
        ERR_PRINT("Unexpected DriverStart. (DriverObject = %p)",
            pAttachedDevice->DriverObject);
        ntstatus = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    if (!RtlPcToFileHeader(pDriverStart, (PVOID*)&ImageBase))
    {
        ERR_PRINT("RtlPcToFileHeader failed. (PcValue = %p)", pDriverStart);
        ntstatus = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    ntstatus = PeGetExecutableSections(
        ImageBase,
        &ppExecutableSections,
        &nExecutableSections);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("PeGetExecutableSections failed: 0x%X", ntstatus);
        goto exit;
    }

    pDeviceExtension = pDeviceObject->DeviceExtension;

    //
    // Clamp the search range.
    //
    Span = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
        pDeviceExtension,
        DEVICE_EXTENSION_SEARCH_SIZE);
    if (1 == Span)
    {
        SearchEnd =
            (ULONG_PTR)pDeviceExtension + DEVICE_EXTENSION_SEARCH_SIZE;
    }
    else
    {
        SearchEnd = (ULONG_PTR)(
            PAGE_ALIGN((ULONG_PTR)pDeviceExtension + PAGE_SIZE));
    }

    //
    // Search the device extension for a valid connect data object.
    //
    for (pConnectData = (PCONNECT_DATA)pDeviceExtension;
        (ULONG_PTR)pConnectData + sizeof(*pConnectData) <= SearchEnd;
        pConnectData =
            OFFSET_POINTER(pConnectData, sizeof(ULONG_PTR), CONNECT_DATA))
    {
        //
        // Filter invalid ClassDeviceObject values.
        //
        if (pConnectData->ClassDeviceObject != pAttachedDevice)
        {
            continue;
        }

        //
        // Filter ClassService values which do not point to an address inside
        //  an executable image section in the driver of the attached device
        //  object.
        //
        for (i = 0; i < nExecutableSections; ++i)
        {
            SectionBase = ImageBase + ppExecutableSections[i]->VirtualAddress;

            if ((ULONG_PTR)pConnectData->ClassService >= SectionBase &&
                (ULONG_PTR)pConnectData->ClassService <
                    SectionBase + ppExecutableSections[i]->Misc.VirtualSize)
            {
                fClassServiceValidated = TRUE;
                break;
            }
        }
        //
        if (!fClassServiceValidated)
        {
            continue;
        }

        //
        // If we found multiple matches then our heuristic is flawed.
        //
        if (cbConnectDataFieldOffset)
        {
            ERR_PRINT("Found multiple field offset candidates.");
            ntstatus = STATUS_INTERNAL_ERROR;
            goto exit;
        }

        cbConnectDataFieldOffset =
            POINTER_OFFSET(pConnectData, pDeviceExtension);
    }
    //
    if (!cbConnectDataFieldOffset)
    {
        ERR_PRINT(
            "Failed to resolve connect data field offset for device."
            " (DeviceObject = %p)",
            pDeviceObject);
        ntstatus = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    //
    // Set out parameters.
    //
    *pcbConnectDataFieldOffset = cbConnectDataFieldOffset;

exit:
    if (ppExecutableSections)
    {
        ExFreePool(ppExecutableSections);
    }

    if (pAttachedDevice)
    {
        ObDereferenceObject(pAttachedDevice);
    }

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
MhdpResolveConnectDataFieldOffset(
    PSIZE_T pcbConnectDataFieldOffset
)
{
    UNICODE_STRING usMouHidDriverObject = {};
    PDRIVER_OBJECT pMouHidDriverObject = NULL;
    BOOLEAN fHasDriverObjectReference = FALSE;
    PDEVICE_OBJECT* ppMouHidDeviceObjectList = NULL;
    ULONG nMouHidDeviceObjectList = 0;
    ULONG i = 0;
    SIZE_T cbFieldOffset = 0;
    SIZE_T cbFieldOffsetCandidate = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *pcbConnectDataFieldOffset = 0;

    DBG_PRINT("Resolving MouHid connect data field offset.");

    //
    // Open the MouHid driver object.
    //
    usMouHidDriverObject = RTL_CONSTANT_STRING(MOUHID_DRIVER_OBJECT_PATH_U);

    ntstatus = ObReferenceObjectByName(
        &usMouHidDriverObject,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        0,
        *IoDriverObjectType,
        KernelMode,
        NULL,
        (PVOID*)&pMouHidDriverObject);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("ObReferenceObjectByName failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fHasDriverObjectReference = TRUE;

    //
    // Get a snapshot of all the MouHid device objects.
    //
    ntstatus = IouEnumerateDeviceObjectList(
        pMouHidDriverObject,
        &ppMouHidDeviceObjectList,
        &nMouHidDeviceObjectList);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("IouEnumerateDeviceObjectList failed: 0x%X", ntstatus);
        goto exit;
    }

#if defined(DBG)
    IouPrintDeviceObjectList(
        MOUHID_DRIVER_OBJECT_PATH_U,
        ppMouHidDeviceObjectList,
        nMouHidDeviceObjectList);
#endif

    //
    // Apply the connect data heuristic to every MouHid device object to verify
    //  that each device object yields the same offset.
    //
    for (i = 0; i < nMouHidDeviceObjectList; ++i)
    {
        ntstatus = MhdpResolveConnectDataFieldOffsetForDevice(
            ppMouHidDeviceObjectList[i],
            &cbFieldOffset);
        if (!NT_SUCCESS(ntstatus))
        {
            ERR_PRINT(
                "MhdpResolveConnectDataFieldOffsetForDevice failed: 0x%X",
                ntstatus);
            goto exit;
        }

        if (cbFieldOffsetCandidate)
        {
            if (cbFieldOffsetCandidate != cbFieldOffset)
            {
                ERR_PRINT("Found multiple field offset candidates.");
                ntstatus = STATUS_INTERNAL_ERROR;
                goto exit;
            }
        }
        else
        {
            cbFieldOffsetCandidate = cbFieldOffset;
        }
    }
    //
    if (!cbFieldOffsetCandidate)
    {
        ERR_PRINT("Failed to resolve connect data field offset.");
        ntstatus = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    //
    // Set out parameters.
    //
    *pcbConnectDataFieldOffset = cbFieldOffsetCandidate;

exit:
    if (ppMouHidDeviceObjectList)
    {
        IouFreeDeviceObjectList(
            ppMouHidDeviceObjectList,
            nMouHidDeviceObjectList);
    }

    if (fHasDriverObjectReference)
    {
        ObDereferenceObject(pMouHidDriverObject);
    }

    return ntstatus;
}

```

`MouHidInputHook/mouhid.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

//=============================================================================
// Constants
//=============================================================================
#define MOUHID_DRIVER_OBJECT_PATH_U     L"\\Driver\\mouhid"

//=============================================================================
// Meta Interface
//=============================================================================
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MhdDriverEntry();

//=============================================================================
// Public Interface
//=============================================================================
_Check_return_
EXTERN_C
SIZE_T
MhdGetConnectDataFieldOffset();

```

`MouHidInputHook/mouhid_hook_manager.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "mouhid_hook_manager.h"

#include <kbdmou.h>
#include <ntddmou.h>
#include <wdmguid.h>

#include "debug.h"
#include "io_util.h"
#include "log.h"
#include "nt.h"
#include "mouclass.h"
#include "mouhid.h"
#include "object_util.h"

#include "../Common/time.h"


//=============================================================================
// Constants
//=============================================================================
#define MODULE_TITLE    "MouHid Hook Manager"

#define UNHOOK_DELAY_INTERVAL_MS    250


//=============================================================================
// Private Types
//=============================================================================
typedef struct _MOUHID_DEVICE_OBJECT
{
    //
    // Referenced device object pointer for this MouHid device.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to the connect data object in the device extension of
    //  'DeviceObject'.
    //
    POINTER_ALIGNMENT PCONNECT_DATA ConnectData;

    PMOUSE_SERVICE_CALLBACK_ROUTINE ServiceCallbackOriginal;

} MOUHID_DEVICE_OBJECT, *PMOUHID_DEVICE_OBJECT;

/*++

Type Name:

    MOUHID_HOOK_CONTEXT

Type Description:

    Contains the array of hooked MouHid device objects for a mouse device
    stack.

--*/
typedef struct _MOUHID_HOOK_CONTEXT
{
    PMOUSE_SERVICE_CALLBACK_ROUTINE ServiceCallbackHook;

    ULONG NumberOfDeviceObjects;
    MOUHID_DEVICE_OBJECT DeviceObjectArray[ANYSIZE_ARRAY];

} MOUHID_HOOK_CONTEXT, *PMOUHID_HOOK_CONTEXT;

typedef struct _MHK_REGISTRATION_ENTRY
{
    PMHK_HOOK_CALLBACK_ROUTINE HookCallback;
    PMHK_NOTIFICATION_CALLBACK_ROUTINE NotificationCallback;
    PVOID Context;

} MHK_REGISTRATION_ENTRY, *PMHK_REGISTRATION_ENTRY;

typedef struct _MOUHID_HOOK_MANAGER
{
    HANDLE MousePnpNotificationHandle;

    POINTER_ALIGNMENT ERESOURCE Resource;

    _Guarded_by_(Resource) BOOLEAN HookActive;
    _Guarded_by_(Resource) PMOUHID_HOOK_CONTEXT HookContext;

    _Guarded_by_(Resource) PMHK_REGISTRATION_ENTRY RegistrationEntry;

} MOUHID_HOOK_MANAGER, *PMOUHID_HOOK_MANAGER;


//=============================================================================
// Module Globals
//=============================================================================
EXTERN_C static MOUHID_HOOK_MANAGER g_MhkManager = {};


//=============================================================================
// Private Prototypes
//=============================================================================
_Requires_lock_not_held_(g_MhkManager.Resource)
EXTERN_C
static
MOUSE_PNP_NOTIFICATION_CALLBACK_ROUTINE
MhkpMousePnpNotificationCallbackRoutine;

_Requires_exclusive_lock_held_(g_MhkManager.Resource)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
static
NTSTATUS
MhkpUnregisterCallbacks(
    _Inout_ HANDLE RegistrationHandle
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
static
NTSTATUS
MhkpCreateHookContext(
    _In_ PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallbackHook,
    _Outptr_result_nullonfailure_ PMOUHID_HOOK_CONTEXT* ppHookContext
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
static
VOID
MhkpFreeHookContext(
    _Pre_notnull_ __drv_freesMem(Mem) PMOUHID_HOOK_CONTEXT pHookContext
);

#if defined(DBG)
_IRQL_requires_(HIGH_LEVEL)
_IRQL_requires_same_
EXTERN_C
static
VOID
MhkpPrintHookContext(
    _In_ PMOUHID_HOOK_CONTEXT pHookContext
);
#endif

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
static
VOID
MhkpInstallConnectDataHooks(
    _Inout_ PMOUHID_HOOK_CONTEXT pHookContext
);

_Requires_exclusive_lock_held_(g_MhkManager.Resource)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
static
NTSTATUS
MhkpHookMouHidDeviceObjects(
    _In_ PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallbackHook
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
static
VOID
MhkpUninstallConnectDataHooks(
    _Inout_ PMOUHID_HOOK_CONTEXT pHookContext
);

_Requires_exclusive_lock_held_(g_MhkManager.Resource)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
static
VOID
MhkpUnhookMouHidDeviceObjects();

EXTERN_C
static
MOUSE_SERVICE_CALLBACK_ROUTINE
MhkpServiceCallbackHook;


//=============================================================================
// Meta Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
MhkDriverEntry()
/*++

Routine Description:

    Initializes the MouHid Hook Manager module.

Required Modules:

    MouClass Manager

Remarks:

    If successful, the caller must call MhkDriverUnload when the driver is
    unloaded.

--*/
{
    BOOLEAN fResourceInitialized = FALSE;
    HANDLE MousePnpNotificationHandle = NULL;
    BOOLEAN fCallbackRegistered = FALSE;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Loading %s.", MODULE_TITLE);

    //
    // NOTE We must initialize the resource before registering the mouse
    //  notification callback because the notification callback uses the
    //  resource.
    //
    ntstatus = ExInitializeResourceLite(&g_MhkManager.Resource);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("ExInitializeResourceLite failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fResourceInitialized = TRUE;

    ntstatus = MclRegisterMousePnpNotificationCallback(
        MhkpMousePnpNotificationCallbackRoutine,
        NULL,
        &MousePnpNotificationHandle);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MclRegisterMousePnpNotificationCallback failed: 0x%X",
            ntstatus);
        goto exit;
    }
    //
    fCallbackRegistered = TRUE;

    //
    // Initialize the global context.
    //
    g_MhkManager.MousePnpNotificationHandle = MousePnpNotificationHandle;

    DBG_PRINT("%s loaded.", MODULE_TITLE);

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (fCallbackRegistered)
        {
            MclUnregisterMousePnpNotificationCallback(
                MousePnpNotificationHandle);
        }

        if (fResourceInitialized)
        {
            VERIFY(ExDeleteResourceLite(&g_MhkManager.Resource));
        }
    }

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
VOID
MhkDriverUnload()
{
    DBG_PRINT("Unloading %s.", MODULE_TITLE);

    NT_ASSERT(!g_MhkManager.HookActive);
    NT_ASSERT(!g_MhkManager.HookContext);
    NT_ASSERT(!g_MhkManager.RegistrationEntry);

    MclUnregisterMousePnpNotificationCallback(
        g_MhkManager.MousePnpNotificationHandle);

    VERIFY(ExDeleteResourceLite(&g_MhkManager.Resource));

    DBG_PRINT("%s unloaded.", MODULE_TITLE);
}


//=============================================================================
// Public Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
MhkRegisterCallbacks(
    PMHK_HOOK_CALLBACK_ROUTINE pHookCallback,
    PMHK_NOTIFICATION_CALLBACK_ROUTINE pNotificationCallback,
    PVOID pContext,
    PHANDLE pRegistrationHandle
)
/*++

Routine Description:

    Registers an MHK hook callback and an optional MHK notification callback.
    If registration succeeds then each MouHid device object is hooked.

Parameters:

    pHookCallback - Pointer to the MHK hook callback to be registered.

    pNotificationCallback - Pointer to the MHK notification callback to be
        registered.

    pContext - Pointer to caller-defined data to be passed as the context
        parameter each time the callbacks are invoked.

    pRegistrationHandle - Returns an opaque registration handle to be used to
        unregister the callbacks.

Remarks:

    If successful, the caller must unregister the callbacks by calling
    MhkUnregisterCallbacks.

    NOTE This routine modifies the device extension of every MouHid device
    object.

--*/
{
    PMHK_REGISTRATION_ENTRY pEntry = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *pRegistrationHandle = NULL;

    DBG_PRINT(
        "Registering MHK callbacks."
        " (HookCallback = %p, NotificationCallback = %p, Context = %p)",
        pHookCallback,
        pNotificationCallback,
        pContext);

    ExEnterCriticalRegionAndAcquireResourceExclusive(&g_MhkManager.Resource);

    //
    // Fail if a registration entry already exists.
    //
    if (g_MhkManager.RegistrationEntry)
    {
        ERR_PRINT("Registration limit reached.");
        ntstatus = STATUS_IMPLEMENTATION_LIMIT;
        goto exit;
    }

    //
    // Allocate and initialize the new registration entry.
    //
    pEntry = (PMHK_REGISTRATION_ENTRY)ExAllocatePool(
        NonPagedPool,
        sizeof(*pEntry));
    if (!pEntry)
    {
        ntstatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    //
    RtlSecureZeroMemory(pEntry, sizeof(*pEntry));

    pEntry->HookCallback = pHookCallback;
    pEntry->NotificationCallback = pNotificationCallback;
    pEntry->Context = pContext;

    //
    // Update the global context.
    //
    g_MhkManager.RegistrationEntry = pEntry;

    if (!g_MhkManager.HookActive)
    {
        ntstatus = MhkpHookMouHidDeviceObjects(MhkpServiceCallbackHook);
        if (!NT_SUCCESS(ntstatus))
        {
            ERR_PRINT("MhkpHookMouHidDeviceObjects failed: 0x%X", ntstatus);
            goto exit;
        }
    }

    DBG_PRINT("MHK callbacks registered. (RegistrationHandle = %p)", pEntry);

    //
    // Set out parameters.
    //
    *pRegistrationHandle = (HANDLE)pEntry;

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (g_MhkManager.RegistrationEntry)
        {
            g_MhkManager.RegistrationEntry = NULL;
        }

        if (pEntry)
        {
            ExFreePool(pEntry);
        }
    }

    ExReleaseResourceAndLeaveCriticalRegion(&g_MhkManager.Resource);

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
NTSTATUS
MhkUnregisterCallbacks(
    HANDLE RegistrationHandle
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;

    ExEnterCriticalRegionAndAcquireResourceExclusive(&g_MhkManager.Resource);

    ntstatus = MhkpUnregisterCallbacks(RegistrationHandle);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MhkpUnregisterCallbacks failed: 0x%X", ntstatus);
        goto exit;
    }

exit:
    ExReleaseResourceAndLeaveCriticalRegion(&g_MhkManager.Resource);

    return ntstatus;
}


//=============================================================================
// Private Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
static
VOID
MhkpMousePnpNotificationCallbackRoutine(
    MOUSE_PNP_NOTIFICATION_EVENT Event,
    PVOID pContext
)
{
    PMHK_REGISTRATION_ENTRY pEntry = NULL;
    HANDLE RegistrationHandle = NULL;
    PMHK_NOTIFICATION_CALLBACK_ROUTINE pRegisteredNotificationCallback = NULL;
    PVOID pRegisteredCallbackContext = NULL;

    UNREFERENCED_PARAMETER(pContext);

#if defined(DBG)
    if (MousePnpNotificationEventArrival == Event)
    {
        DBG_PRINT("Received mouse PnP notification. (Arrival)");
    }
    else if (MousePnpNotificationEventRemoval == Event)
    {
        DBG_PRINT("Received mouse PnP notification. (Removal)");
    }
    else
    {
        ERR_PRINT("Received mouse PnP notification. (Unknown)");
        DEBUG_BREAK;
    }
#else
    UNREFERENCED_PARAMETER(Event);
#endif

    ExEnterCriticalRegionAndAcquireResourceExclusive(&g_MhkManager.Resource);

    pEntry = g_MhkManager.RegistrationEntry;
    if (pEntry)
    {
        //
        // Store the registration entry information because it will be reset
        //  during the unregister call below.
        //
        RegistrationHandle = (HANDLE)pEntry;
        pRegisteredNotificationCallback = pEntry->NotificationCallback;
        pRegisteredCallbackContext = pEntry->Context;

        VERIFY(MhkpUnregisterCallbacks((HANDLE)pEntry));
    }

    ExReleaseResourceAndLeaveCriticalRegion(&g_MhkManager.Resource);

    //
    // Invoke the notification callback after releasing the resource so that
    //  the callback cannot deadlock the system by invoking a public MHK
    //  function.
    //
    // WARNING This strategy currently enables a race condition where the
    //  registrant attempts to unregister their MHK callbacks before their MHK
    //  notification callback is invoked below. This unregister attempt will
    //  fail because we previously unregistered the MHK callbacks.
    //
    if (pRegisteredNotificationCallback)
    {
        DBG_PRINT(
            "Invoking MHK notification callback. (RegistrationHandle = %p)",
            RegistrationHandle);

        //
        // NOTE 'RegistrationHandle' now points to freed memory.
        //
        pRegisteredNotificationCallback(
            RegistrationHandle,
            Event,
            pRegisteredCallbackContext);
    }
}


_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
MhkpUnregisterCallbacks(
    HANDLE RegistrationHandle
)
{
    PMHK_REGISTRATION_ENTRY pEntry = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Unregistering MHK callbacks. (RegistrationHandle = %p)",
        RegistrationHandle);

    pEntry = (PMHK_REGISTRATION_ENTRY)RegistrationHandle;

    //
    // Fail if the specified handle does not match the active registration
    //  entry.
    //
    if (pEntry != g_MhkManager.RegistrationEntry)
    {
        ERR_PRINT("Invalid registration handle: %p", RegistrationHandle);
        ntstatus = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if (g_MhkManager.HookActive)
    {
        MhkpUnhookMouHidDeviceObjects();
    }

    ExFreePool(g_MhkManager.RegistrationEntry);

    //
    // Update the global context.
    //
    g_MhkManager.RegistrationEntry = NULL;

    DBG_PRINT("MHK callbacks unregistered.");

exit:
    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
MhkpCreateHookContext(
    PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallbackHook,
    PMOUHID_HOOK_CONTEXT* ppHookContext
)
{
    SIZE_T cbConnectDataFieldOffset = 0;
    UNICODE_STRING usDriverObject = {};
    PDRIVER_OBJECT pDriverObject = NULL;
    BOOLEAN fHasDriverObjectReference = FALSE;
    PDEVICE_OBJECT* ppDeviceObjectList = NULL;
    ULONG nDeviceObjectList = 0;
    SIZE_T cbHookContext = 0;
    PMOUHID_HOOK_CONTEXT pHookContext = NULL;
    ULONG i = 0;
    PDEVICE_OBJECT pDeviceObject = NULL;
    PMOUHID_DEVICE_OBJECT pElement = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *ppHookContext = NULL;

    DBG_PRINT("Creating MouHid hook context.");

    cbConnectDataFieldOffset = MhdGetConnectDataFieldOffset();
    if (!cbConnectDataFieldOffset)
    {
        ERR_PRINT("MhdGetConnectDataFieldOffset failed.");
        ntstatus = STATUS_INTERNAL_ERROR;
        goto exit;
    }

    //
    // Open the MouHid driver object.
    //
    usDriverObject = RTL_CONSTANT_STRING(MOUHID_DRIVER_OBJECT_PATH_U);

    ntstatus = ObReferenceObjectByName(
        &usDriverObject,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        0,
        *IoDriverObjectType,
        KernelMode,
        NULL,
        (PVOID*)&pDriverObject);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("ObReferenceObjectByName failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fHasDriverObjectReference = TRUE;

    //
    // Get a snapshot of all the MouHid device objects.
    //
    ntstatus = IouEnumerateDeviceObjectList(
        pDriverObject,
        &ppDeviceObjectList,
        &nDeviceObjectList);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("IouEnumerateDeviceObjectList failed: 0x%X", ntstatus);
        goto exit;
    }

#if defined(DBG)
    IouPrintDeviceObjectList(
        MOUHID_DRIVER_OBJECT_PATH_U,
        ppDeviceObjectList,
        nDeviceObjectList);
#endif

    //
    // Allocate and initialize the new hook context.
    //
    cbHookContext = UFIELD_OFFSET(
        MOUHID_HOOK_CONTEXT,
        DeviceObjectArray[nDeviceObjectList]);

    pHookContext = (PMOUHID_HOOK_CONTEXT)ExAllocatePool(
        NonPagedPool,
        cbHookContext);
    if (!pHookContext)
    {
        ntstatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    //
    RtlSecureZeroMemory(pHookContext, cbHookContext);

    pHookContext->ServiceCallbackHook = pServiceCallbackHook;
    pHookContext->NumberOfDeviceObjects = nDeviceObjectList;

    for (i = 0; i < nDeviceObjectList; ++i)
    {
        pDeviceObject = ppDeviceObjectList[i];

        //
        // We reference each MouHid device object to ensure that the memory
        //  backing their device extensions remains valid even if the MouHid
        //  driver is unloaded. This allows us to safely uninstall connect data
        //  hooks from 'stale' MouHid device objects.
        //
        ObReferenceObject(pDeviceObject);

        pElement = &pHookContext->DeviceObjectArray[i];

        pElement->DeviceObject = pDeviceObject;

        pElement->ConnectData = OFFSET_POINTER(
            pDeviceObject->DeviceExtension,
            cbConnectDataFieldOffset,
            CONNECT_DATA);
    }

    //
    // Set out parameters.
    //
    *ppHookContext = pHookContext;

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (pHookContext)
        {
            ExFreePool(pHookContext);
        }
    }

    if (ppDeviceObjectList)
    {
        IouFreeDeviceObjectList(ppDeviceObjectList, nDeviceObjectList);
    }

    if (fHasDriverObjectReference)
    {
        ObDereferenceObject(pDriverObject);
    }

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
static
VOID
MhkpFreeHookContext(
    PMOUHID_HOOK_CONTEXT pHookContext
)
{
    ULONG i = 0;

    for (i = 0; i < pHookContext->NumberOfDeviceObjects; ++i)
    {
        ObDereferenceObject(pHookContext->DeviceObjectArray[i].DeviceObject);
    }

    ExFreePool(pHookContext);
}


#if defined(DBG)
_Use_decl_annotations_
EXTERN_C
static
VOID
MhkpPrintHookContext(
    PMOUHID_HOOK_CONTEXT pHookContext
)
{
    ULONG i = 0;
    PMOUHID_DEVICE_OBJECT pElement = NULL;

    DBG_PRINT("MouHid Hook Context:");

    for (i = 0; i < pHookContext->NumberOfDeviceObjects; ++i)
    {
        pElement = &pHookContext->DeviceObjectArray[i];

        DBG_PRINT("%u.", i);
        DBG_PRINT("    DeviceObject:        %p", pElement->DeviceObject);
        DBG_PRINT("    DeviceExtension:     %p",
            pElement->DeviceObject->DeviceExtension);
        DBG_PRINT("    ConnectData:         %p", pElement->ConnectData);
        DBG_PRINT("    ClassDeviceObject:   %p",
            pElement->ConnectData->ClassDeviceObject);
        DBG_PRINT("    ClassService:        %p",
            pElement->ConnectData->ClassService);
    }
}
#endif


_Use_decl_annotations_
EXTERN_C
static
VOID
MhkpInstallConnectDataHooks(
    PMOUHID_HOOK_CONTEXT pHookContext
)
{
    ULONG i = 0;
    PMOUHID_DEVICE_OBJECT pElement = NULL;

    DBG_PRINT("Installing connect data hooks:");

    for (i = 0; i < pHookContext->NumberOfDeviceObjects; ++i)
    {
        pElement = &pHookContext->DeviceObjectArray[i];

        pElement->ServiceCallbackOriginal =
            (PMOUSE_SERVICE_CALLBACK_ROUTINE)InterlockedExchangePointer(
                &pElement->ConnectData->ClassService,
                pHookContext->ServiceCallbackHook);

        DBG_PRINT(
            "    %u. Hooked: %p -> %p (DeviceObject = %p)",
            i,
            pElement->ServiceCallbackOriginal,
            pElement->ConnectData->ClassService,
            pElement->DeviceObject);
    }
}


_Use_decl_annotations_
EXTERN_C
static
NTSTATUS
MhkpHookMouHidDeviceObjects(
    PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallbackHook
)
{
    PMOUHID_HOOK_CONTEXT pHookContext = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Hooking MouHid device objects.");

    ntstatus = MhkpCreateHookContext(pServiceCallbackHook, &pHookContext);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MhkpCreateHookContext failed: 0x%X", ntstatus);
        goto exit;
    }

    //
    // Set the hook context pointer in the global context before we install the
    //  connect data hooks so that our service callback hook can access it.
    //
    g_MhkManager.HookContext = pHookContext;

    MhkpInstallConnectDataHooks(pHookContext);

    //
    // Update the global context.
    //
    g_MhkManager.HookActive = TRUE;

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (pHookContext)
        {
            MhkpFreeHookContext(pHookContext);
        }
    }

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
static
VOID
MhkpUninstallConnectDataHooks(
    PMOUHID_HOOK_CONTEXT pHookContext
)
{
    ULONG i = 0;
    PMOUHID_DEVICE_OBJECT pElement = NULL;
    PVOID pExchangeResult = NULL;

    DBG_PRINT("Uninstalling connect data hooks:");

    for (i = 0; i < pHookContext->NumberOfDeviceObjects; ++i)
    {
        pElement = &pHookContext->DeviceObjectArray[i];

        pExchangeResult = InterlockedExchangePointer(
            &pElement->ConnectData->ClassService,
            pElement->ServiceCallbackOriginal);
        if (pExchangeResult != pHookContext->ServiceCallbackHook)
        {
            ERR_PRINT("Unexpected ClassService: %p (DeviceObject = %p)",
                pExchangeResult,
                pElement->DeviceObject);
            DEBUG_BREAK;
        }

        DBG_PRINT(
            "    %u. Unhooked: %p -> %p (DeviceObject = %p)",
            i,
            pExchangeResult,
            pElement->ConnectData->ClassService,
            pElement->DeviceObject);
    }
}


_Use_decl_annotations_
EXTERN_C
static
VOID
MhkpUnhookMouHidDeviceObjects()
{
    PMOUHID_HOOK_CONTEXT pHookContext = NULL;
    LARGE_INTEGER DelayInterval = {};

    DBG_PRINT("Unhooking MouHid device objects.");

    pHookContext = g_MhkManager.HookContext;

    MhkpUninstallConnectDataHooks(pHookContext);

    //
    // Delay execution to mitigate the race condition where we free the hook
    //  context before all threads have exited the service callback hook.
    //
    MakeRelativeIntervalMilliseconds(&DelayInterval, UNHOOK_DELAY_INTERVAL_MS);

    VERIFY(KeDelayExecutionThread(KernelMode, FALSE, &DelayInterval));

    //
    // Update the global context.
    //
    g_MhkManager.HookActive = FALSE;
    g_MhkManager.HookContext = NULL;

    MhkpFreeHookContext(pHookContext);
}


_Use_decl_annotations_
EXTERN_C
static
VOID
NTAPI
MhkpServiceCallbackHook(
    PDEVICE_OBJECT pDeviceObject,
    PMOUSE_INPUT_DATA pInputDataStart,
    PMOUSE_INPUT_DATA pInputDataEnd,
    PULONG pnInputDataConsumed
)
/*++

Routine Description:

    The mouse class service callback hook.

Parameters:

    pDeviceObject - Pointer to the mouse class device object to receive the
        mouse input data packets.

    pInputDataStart - Pointer to the array of input packets to be copied to the
        class data queue.

    pInputDataEnd - Pointer to the input packet which marks the end of the
        input packet array.

    pnInputDataConsumed - Returns the number of input packets copied to the
        class data queue by the routine.

Remarks:

    This routine is installed in the 'ClassService' field of the CONNECT_DATA
    object inside the device extension of a hooked MouHid device object.

--*/
{
    PMOUHID_HOOK_CONTEXT pHookContext = NULL;
    ULONG i = 0;
    PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallbackOriginal = NULL;
    PMOUHID_DEVICE_OBJECT pElement = NULL;

    pHookContext = g_MhkManager.HookContext;

    //
    // Map the target class device object to its original service callback.
    //
    for (i = 0; i < pHookContext->NumberOfDeviceObjects; ++i)
    {
        pElement = &pHookContext->DeviceObjectArray[i];

        if (pElement->ConnectData->ClassDeviceObject == pDeviceObject)
        {
            pServiceCallbackOriginal = pElement->ServiceCallbackOriginal;
            break;
        }
    }
    //
    if (!pServiceCallbackOriginal)
    {
        ERR_PRINT("Unhandled class device object: %p", pDeviceObject);
        DEBUG_BREAK;
        goto exit;
    }

    g_MhkManager.RegistrationEntry->HookCallback(
        pServiceCallbackOriginal,
        pDeviceObject,
        pInputDataStart,
        pInputDataEnd,
        pnInputDataConsumed,
        g_MhkManager.RegistrationEntry->Context);

exit:
    return;
}

```

`MouHidInputHook/mouhid_hook_manager.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

#include "mouclass.h"

//=============================================================================
// Public Types
//=============================================================================
/*++

Type Name:

    MHK_HOOK_CALLBACK_ROUTINE

Type Description:

    An MHK hook callback is invoked each time the MouHid driver invokes a
    mouse class service callback to copy mouse input data packets from a hooked
    MouHid device object to the class data queue of a mouse class device
    object.

Parameters:

    pServiceCallbackOriginal - Pointer to the original class service callback.

    pClassDeviceObject - Pointer to the mouse class device object to receive
        the mouse input data packets.

    pInputDataStart - Pointer to the array of input packets to be copied to the
        class data queue.

    pInputDataEnd - Pointer to the input packet which marks the end of the
        input packet array.

    pnInputDataConsumed - Returns the number of input packets copied to the
        class data queue by the routine.

    pContext - Pointer to caller-defined data to be passed as the context
        parameter each time the callback is invoked. The context data must
        reside in NonPaged memory.

Remarks:

    An MHK hook callback can filter, modify, and inject input packets like a
    standard mouse filter driver. For example, a callback can inject ten mouse
    input data packets using the following strategy:

        1. Allocate storage for ten packets from the NonPaged pool.

        2. Initialize each packet.

        3. Invoke the original class service callback using the pointer to the
            synthesized packets for the 'pInputDataStart' parameter.

            NOTE This effectively drops the original packet(s).

        4. Inspect '*pnInputDataConsumed' to determine how many packets were
            copied to the class data queue by the routine.

--*/
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
typedef
VOID
NTAPI
MHK_HOOK_CALLBACK_ROUTINE(
    _In_        PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallbackOriginal,
    _In_        PDEVICE_OBJECT                  pClassDeviceObject,
    _In_        PMOUSE_INPUT_DATA               pInputDataStart,
    _In_        PMOUSE_INPUT_DATA               pInputDataEnd,
    _Inout_     PULONG                          pnInputDataConsumed,
    _Inout_opt_ PVOID                           pContext
    );

typedef MHK_HOOK_CALLBACK_ROUTINE *PMHK_HOOK_CALLBACK_ROUTINE;

/*++

Type Name:

    MHK_NOTIFICATION_CALLBACK_ROUTINE

Type Description:

    An MHK notification callback is invoked when a mouse related PNP event
    invalidates the hook environment established when the callback is
    registered.

Parameters:

    RegistrationHandle - The opaque registration handle returned from
        MhkRegisterCallbacks.

    Event - The PnP device interface change event which caused the callback to
        be invoked.

    pContext - Pointer to caller-defined data specified at callback
        registration.

Remarks:

    The MouHid Hook Manager unregisters the registration entry specified by
    'RegistrationHandle' before invoking its notification callback.

    WARNING It is not safe for an MHK notification callback to invoke
    MhkRegisterCallbacks or MhkUnregisterCallbacks.

--*/
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
typedef
VOID
NTAPI
MHK_NOTIFICATION_CALLBACK_ROUTINE(
    _In_        HANDLE                          RegistrationHandle,
    _In_        MOUSE_PNP_NOTIFICATION_EVENT    Event,
    _Inout_opt_ PVOID                           pContext
    );

typedef MHK_NOTIFICATION_CALLBACK_ROUTINE *PMHK_NOTIFICATION_CALLBACK_ROUTINE;

//=============================================================================
// Meta Interface
//=============================================================================
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MhkDriverEntry();

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
VOID
MhkDriverUnload();

//=============================================================================
// Public Interface
//=============================================================================
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MhkRegisterCallbacks(
    _In_ PMHK_HOOK_CALLBACK_ROUTINE pHookCallback,
    _In_opt_ PMHK_NOTIFICATION_CALLBACK_ROUTINE pNotificationCallback,
    _In_opt_ PVOID pContext,
    _Outptr_result_nullonfailure_ PHANDLE pRegistrationHandle
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MhkUnregisterCallbacks(
    _In_ HANDLE RegistrationHandle
);

```

`MouHidInputHook/mouhid_monitor.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "mouhid_monitor.h"

#include <ntddmou.h>

#include "debug.h"
#include "log.h"
#include "mouclass.h"
#include "mouhid_hook_manager.h"


//=============================================================================
// Constants
//=============================================================================
#define MODULE_TITLE    "MouHid Monitor"


//=============================================================================
// Private Types
//=============================================================================
typedef struct _HOOK_CALLBACK_CONTEXT
{
    _Interlocked_ volatile POINTER_ALIGNMENT LONG64 PacketIndex;

} HOOK_CALLBACK_CONTEXT, *PHOOK_CALLBACK_CONTEXT;

typedef struct _MOUHID_MONITOR_CONTEXT
{
    POINTER_ALIGNMENT ERESOURCE Resource;
    _Guarded_by_(Resource) HANDLE RegistrationHandle;
    _Guarded_by_(Resource) PHOOK_CALLBACK_CONTEXT CallbackContext;

} MOUHID_MONITOR_CONTEXT, *PMOUHID_MONITOR_CONTEXT;


//=============================================================================
// Module Globals
//=============================================================================
EXTERN_C static MOUHID_MONITOR_CONTEXT g_MhmContext = {};


//=============================================================================
// Private Prototypes
//=============================================================================
EXTERN_C
static
MHK_HOOK_CALLBACK_ROUTINE
MhmpHookCallback;

EXTERN_C
static
MHK_NOTIFICATION_CALLBACK_ROUTINE
MhmpNotificationCallback;


//=============================================================================
// Meta Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
MhmDriverEntry()
/*++

Routine Description:

    Initializes the MouHid Monitor module.

Required Modules:

    None

Remarks:

    If successful, the caller must call MhmDriverUnload when the driver is
    unloaded.

--*/
{
    BOOLEAN fResourceInitialized = FALSE;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Loading %s.", MODULE_TITLE);

    ntstatus = ExInitializeResourceLite(&g_MhmContext.Resource);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("ExInitializeResourceLite failed: 0x%X", ntstatus);
        goto exit;
    }
    //
    fResourceInitialized = TRUE;

    DBG_PRINT("%s loaded.", MODULE_TITLE);

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (fResourceInitialized)
        {
            VERIFY(ExDeleteResourceLite(&g_MhmContext.Resource));
        }
    }

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
VOID
MhmDriverUnload()
{
    DBG_PRINT("Unloading %s.", MODULE_TITLE);

    VERIFY(MhmDisableMouHidMonitor());

    VERIFY(ExDeleteResourceLite(&g_MhmContext.Resource));

    DBG_PRINT("%s unloaded.", MODULE_TITLE);
}


//=============================================================================
// Public Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
NTSTATUS
MhmQueryMouHidMonitor(
    PBOOLEAN pfEnabled
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *pfEnabled = FALSE;

    ExEnterCriticalRegionAndAcquireResourceShared(&g_MhmContext.Resource);

    //
    // Set out parameters.
    //
    if (g_MhmContext.RegistrationHandle)
    {
        *pfEnabled = TRUE;
    }

    ExReleaseResourceAndLeaveCriticalRegion(&g_MhmContext.Resource);

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
NTSTATUS
MhmEnableMouHidMonitor()
/*++

Routine Description:

    Registers an MHK callback which logs mouse input data packets in the input
    packet stream.

Remarks:

    If successful, the caller must disable the monitor by calling
    MhmDisableMouHidMonitor.

--*/
{
    PHOOK_CALLBACK_CONTEXT pCallbackContext = NULL;
    HANDLE RegistrationHandle = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Enabling %s.", MODULE_TITLE);

    ExEnterCriticalRegionAndAcquireResourceExclusive(&g_MhmContext.Resource);

    if (g_MhmContext.RegistrationHandle)
    {
        ERR_PRINT("%s is already enabled.", MODULE_TITLE);
        ntstatus = STATUS_ALREADY_REGISTERED;
        goto exit;
    }

    pCallbackContext = (PHOOK_CALLBACK_CONTEXT)ExAllocatePool(
        NonPagedPool,
        sizeof(*pCallbackContext));
    if (!pCallbackContext)
    {
        ntstatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    //
    RtlSecureZeroMemory(pCallbackContext, sizeof(*pCallbackContext));

    ntstatus = MhkRegisterCallbacks(
        MhmpHookCallback,
        MhmpNotificationCallback,
        pCallbackContext,
        &RegistrationHandle);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MhkRegisterCallbacks failed: 0x%X", ntstatus);
        goto exit;
    }

    DBG_PRINT("%s enabled.", MODULE_TITLE);

    //
    // Update the global context.
    //
    g_MhmContext.RegistrationHandle = RegistrationHandle;
    g_MhmContext.CallbackContext = pCallbackContext;

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (pCallbackContext)
        {
            ExFreePool(pCallbackContext);
        }
    }

    ExReleaseResourceAndLeaveCriticalRegion(&g_MhmContext.Resource);

    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
NTSTATUS
MhmDisableMouHidMonitor()
{
    HANDLE RegistrationHandle = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DBG_PRINT("Disabling %s.", MODULE_TITLE);

    ExEnterCriticalRegionAndAcquireResourceExclusive(&g_MhmContext.Resource);

    RegistrationHandle = g_MhmContext.RegistrationHandle;
    if (!RegistrationHandle)
    {
        WRN_PRINT("%s is not enabled.", MODULE_TITLE);
        goto exit;
    }

    ntstatus = MhkUnregisterCallbacks(RegistrationHandle);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("MhkUnregisterCallbacks failed: 0x%X", ntstatus);
        goto exit;
    }

    ExFreePool(g_MhmContext.CallbackContext);

    //
    // Update the global context.
    //
    g_MhmContext.RegistrationHandle = NULL;
    g_MhmContext.CallbackContext = NULL;

    DBG_PRINT("%s disabled.", MODULE_TITLE);

exit:
    ExReleaseResourceAndLeaveCriticalRegion(&g_MhmContext.Resource);

    return ntstatus;
}


//=============================================================================
// Private Interface
//=============================================================================
_Use_decl_annotations_
EXTERN_C
static
VOID
NTAPI
MhmpHookCallback(
    PMOUSE_SERVICE_CALLBACK_ROUTINE pServiceCallbackOriginal,
    PDEVICE_OBJECT pClassDeviceObject,
    PMOUSE_INPUT_DATA pInputDataStart,
    PMOUSE_INPUT_DATA pInputDataEnd,
    PULONG pnInputDataConsumed,
    PVOID pContext
)
{
    PHOOK_CALLBACK_CONTEXT pCallbackContext = NULL;
    PMOUSE_INPUT_DATA pInputPacket = NULL;
    ULONG64 PacketIndex = 0;

    pCallbackContext = (PHOOK_CALLBACK_CONTEXT)pContext;

    //
    // Log each packet in the input buffer.
    //
    for (pInputPacket = pInputDataStart;
        pInputPacket < pInputDataEnd;
        ++pInputPacket)
    {
        PacketIndex = InterlockedIncrement64(&pCallbackContext->PacketIndex);

        MclPrintInputPacket(
            PacketIndex,
            pServiceCallbackOriginal,
            pClassDeviceObject,
            pInputPacket);
    }

    //
    // Invoke the original service callback.
    //
    pServiceCallbackOriginal(
        pClassDeviceObject,
        pInputDataStart,
        pInputDataEnd,
        pnInputDataConsumed);
}


_Use_decl_annotations_
EXTERN_C
static
VOID
NTAPI
MhmpNotificationCallback(
    HANDLE RegistrationHandle,
    MOUSE_PNP_NOTIFICATION_EVENT Event,
    PVOID pContext
)
{
    UNREFERENCED_PARAMETER(pContext);

#if defined(DBG)
    if (MousePnpNotificationEventArrival == Event)
    {
        DBG_PRINT("Received MHK notification. (Arrival)");
    }
    else if (MousePnpNotificationEventRemoval == Event)
    {
        DBG_PRINT("Received MHK notification. (Removal)");
    }
    else
    {
        ERR_PRINT("Received MHK notification. (Unknown)");
        DEBUG_BREAK;
    }
#else
    UNREFERENCED_PARAMETER(Event);
#endif

    ExEnterCriticalRegionAndAcquireResourceExclusive(&g_MhmContext.Resource);

    if (g_MhmContext.RegistrationHandle != RegistrationHandle)
    {
        ERR_PRINT("Unexpected registration handle: %p", RegistrationHandle);
        DEBUG_BREAK;
        goto exit;
    }

    //
    // The MouHid Hook Manager unregistered our MHK callbacks before it
    //  invoked this notification routine. Release the callback context and
    //  update the global context.
    //
    ExFreePool(g_MhmContext.CallbackContext);

    g_MhmContext.RegistrationHandle = NULL;
    g_MhmContext.CallbackContext = NULL;

    DBG_PRINT("%s disabled.", MODULE_TITLE);

exit:
    ExReleaseResourceAndLeaveCriticalRegion(&g_MhmContext.Resource);
}

```

`MouHidInputHook/mouhid_monitor.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

//=============================================================================
// Meta Interface
//=============================================================================
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MhmDriverEntry();

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
EXTERN_C
VOID
MhmDriverUnload();

//=============================================================================
// Public Interface
//=============================================================================
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MhmQueryMouHidMonitor(
    _Out_ PBOOLEAN pfEnabled
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MhmEnableMouHidMonitor();

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
MhmDisableMouHidMonitor();

```

`MouHidInputHook/nt.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

//=============================================================================
// Macros
//=============================================================================
#define OFFSET_POINTER(Pointer, Offset, Type) \
    ((Type*)(((PUCHAR)(Pointer)) + (Offset)))

#define POINTER_OFFSET(Offset, Base) \
    ((SIZE_T)(((ULONG_PTR)(Offset)) - ((ULONG_PTR)(Base))))

//=============================================================================
// Globals
//=============================================================================
EXTERN_C POBJECT_TYPE* IoDriverObjectType;

//=============================================================================
// Object Interface
//=============================================================================
EXTERN_C
NTSTATUS
NTAPI
ObReferenceObjectByName(
    _In_        PUNICODE_STRING ObjectName,
    _In_        ULONG           Attributes,
    _In_opt_    PACCESS_STATE   AccessState,
    _In_opt_    ACCESS_MASK     DesiredAccess,
    _In_        POBJECT_TYPE    ObjectType,
    _In_        KPROCESSOR_MODE AccessMode,
    _Inout_opt_ PVOID           ParseContext,
    _Out_       PVOID*          Object
);

//=============================================================================
// Process Interface
//=============================================================================
EXTERN_C
PUCHAR
NTAPI
PsGetProcessImageFileName(
    _In_ PEPROCESS Process
);

EXTERN_C
NTSTATUS
NTAPI
PsAcquireProcessExitSynchronization(
    _In_ PEPROCESS Process
);

EXTERN_C
VOID
NTAPI
PsReleaseProcessExitSynchronization(
    _In_ PEPROCESS Process
);

//=============================================================================
// Rtl Interface
//=============================================================================
EXTERN_C
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID ImageBase
);

EXTERN_C
PVOID
NTAPI
RtlPcToFileHeader(
    _In_ PVOID PcValue,
    _Out_ PVOID* BaseOfImage
);

```

`MouHidInputHook/object_util.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "object_util.h"

#include "log.h"
#include "nt.h"


_Use_decl_annotations_
EXTERN_C
NTSTATUS
ObuQueryNameString(
    PVOID pObject,
    POBJECT_NAME_INFORMATION* ppObjectNameInfo
)
/*++

Routine Description:

    This function is a convenience wrapper for ObQueryNameString.

Parameters:

    pObject - Pointer to the object to be queried.

    ppObjectNameInfo - Returns a pointer to an allocated buffer for the object
        name information for the specified object. If the object is unnamed
        then the unicode string object in the returned buffer is zeroed. The
        buffer is allocated from the NonPaged pool.

Remarks:

    If successful, the caller must free the returned object name information
    buffer by calling ExFreePool.

--*/
{
    POBJECT_NAME_INFORMATION pObjectNameInfo = NULL;
    ULONG cbReturnLength = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *ppObjectNameInfo = NULL;

    ntstatus = ObQueryNameString(pObject, NULL, 0, &cbReturnLength);
    if (STATUS_INFO_LENGTH_MISMATCH != ntstatus)
    {
        ERR_PRINT("ObQueryNameString failed: 0x%X (Unexpected)", ntstatus);
        ntstatus = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    pObjectNameInfo = (POBJECT_NAME_INFORMATION)ExAllocatePool(
        NonPagedPool,
        cbReturnLength);
    if (!pObjectNameInfo)
    {
        ntstatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    //
    RtlSecureZeroMemory(pObjectNameInfo, cbReturnLength);

    ntstatus = ObQueryNameString(
        pObject,
        pObjectNameInfo,
        cbReturnLength,
        &cbReturnLength);
    if (!NT_SUCCESS(ntstatus))
    {
        ERR_PRINT("ObQueryNameString failed: 0x%X", ntstatus);
        goto exit;
    }

    //
    // Set out parameters.
    //
    *ppObjectNameInfo = pObjectNameInfo;

exit:
    if (!NT_SUCCESS(ntstatus))
    {
        if (pObjectNameInfo)
        {
            ExFreePool(pObjectNameInfo);
        }
    }

    return ntstatus;
}

```

`MouHidInputHook/object_util.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
ObuQueryNameString(
    _In_ PVOID pObject,
    _Outptr_result_nullonfailure_ POBJECT_NAME_INFORMATION* ppObjectNameInfo
);

```

`MouHidInputHook/pe.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "pe.h"

#include <ntimage.h>

#include "nt.h"


_Use_decl_annotations_
EXTERN_C
NTSTATUS
PeGetSectionsByCharacteristics(
    ULONG_PTR ImageBase,
    ULONG Characteristics,
    PIMAGE_SECTION_HEADER** pppSectionHeaders,
    PULONG pnSectionHeaders
)
/*++

Routine Description:

    Returns the image section header pointer of each section in the image with
    the specified characteristics.

Parameters:

    ImageBase - The base address of the target image.

    Characteristics - A bitmask of image section characteristics to match
        against.

    pppSectionHeaders - Returns a pointer to an allocated array of image
        section header pointers for sections with the specified
        characteristics. The array is allocated from the NonPaged pool.

    pnSectionHeaders - Returns the number of elements in the allocated array.

Remarks:

    If successful, the caller must free the returned array by calling
    ExFreePool.

--*/
{
    PIMAGE_NT_HEADERS pNtHeaders = NULL;
    PIMAGE_SECTION_HEADER pSectionHeader = NULL;
    USHORT i = 0;
    ULONG nSectionHeaders = 0;
    SIZE_T cbSectionHeaders = 0;
    ULONG j = 0;
    PIMAGE_SECTION_HEADER* ppSectionHeaders = NULL;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    //
    // Zero out parameters.
    //
    *pppSectionHeaders = NULL;
    *pnSectionHeaders = 0;

    pNtHeaders = RtlImageNtHeader((PVOID)ImageBase);
    if (!pNtHeaders)
    {
        ntstatus = STATUS_INVALID_IMAGE_FORMAT;
        goto exit;
    }

    //
    // Determine the number of sections which have the specified
    //  characteristics.
    //
    pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);

    for (i = 0;
        i < pNtHeaders->FileHeader.NumberOfSections;
        ++i, ++pSectionHeader)
    {
        if (pSectionHeader->Characteristics & Characteristics)
        {
            nSectionHeaders++;
        }
    }
    //
    if (!nSectionHeaders)
    {
        ntstatus = STATUS_NOT_FOUND;
        goto exit;
    }

    //
    // Allocate and initialize the returned array.
    //
    cbSectionHeaders = nSectionHeaders * sizeof(*ppSectionHeaders);

    ppSectionHeaders = (PIMAGE_SECTION_HEADER*)ExAllocatePool(
        NonPagedPool,
        cbSectionHeaders);
    if (!ppSectionHeaders)
    {
        ntstatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);

    for (i = 0, j = 0;
        i < pNtHeaders->FileHeader.NumberOfSections;
        ++i, ++pSectionHeader)
    {
        if (pSectionHeader->Characteristics & Characteristics)
        {
            ppSectionHeaders[j] = pSectionHeader;
            j++;
        }
    }

    //
    // Set out parameters.
    //
    *pppSectionHeaders = ppSectionHeaders;
    *pnSectionHeaders = nSectionHeaders;

exit:
    return ntstatus;
}


_Use_decl_annotations_
EXTERN_C
NTSTATUS
PeGetExecutableSections(
    ULONG_PTR ImageBase,
    PIMAGE_SECTION_HEADER** pppSectionHeaders,
    PULONG pnSectionHeaders
)
{
    return PeGetSectionsByCharacteristics(
        ImageBase,
        IMAGE_SCN_MEM_EXECUTE,
        pppSectionHeaders,
        pnSectionHeaders);
}

```

`MouHidInputHook/pe.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <fltKernel.h>

#include <ntimage.h>

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
PeGetSectionsByCharacteristics(
    _In_ ULONG_PTR ImageBase,
    _In_ ULONG Characteristics,
    _Outptr_result_nullonfailure_ PIMAGE_SECTION_HEADER** pppSectionHeaders,
    _Out_ PULONG pnSectionHeaders
);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Check_return_
EXTERN_C
NTSTATUS
PeGetExecutableSections(
    _In_ ULONG_PTR ImageBase,
    _Outptr_result_nullonfailure_ PIMAGE_SECTION_HEADER** pppSectionHeaders,
    _Out_ PULONG pnSectionHeaders
);

```

`MouHidMonitor/LICENSE`:

```
MIT License

Copyright (c) 2019 changeofpace

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`MouHidMonitor/MouHidMonitor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{84AFD7F5-416B-455C-81ED-1C7E5B11CDB6}</ProjectGuid>
    <RootNamespace>MouHidMonitor</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="log.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Common\ioctl.h" />
    <ClInclude Include="debug.h" />
    <ClInclude Include="driver.h" />
    <ClInclude Include="log.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`MouHidMonitor/MouHidMonitor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Common\ioctl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`MouHidMonitor/README.md`:

```md
# MouHidMonitor

MouHidMonitor is a user mode client for the **MouHidInputHook** driver which enables the logging of mouse input data packets in the input stream of HID USB mouse devices.

## Usage

1. Enable test signing on the host machine.
2. Load the MouHidInputHook driver.
3. Execute MouHidMonitor.exe.
4. Use a kernel debugger or the DbgView Sysinternals tool to read the logged packet data.
5. Press **ENTER** to terminate the MouHidMonitor session.

## Notes

* The debug configuration uses the multi-threaded debug runtime library to reduce library requirements.

```

`MouHidMonitor/debug.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <Windows.h>

#include <crtdbg.h>

#include "log.h"

/*++

Macro Name:

    DEBUG_BREAK

Macro Description:

    A software breakpoint which is only executed if a user mode debugger is
    attached to the executing process.

--*/
#if defined(_DEBUG)
#define DEBUG_BREAK             \
    if (IsDebuggerPresent())    \
    {                           \
        DebugBreak();           \
    }
#else
#define DEBUG_BREAK
#endif

/*++

Macro Name:

    VERIFY

Macro Description:

    A validation macro which ASSERTs in debug build configurations and logs
    failures in release build configurations.

--*/
#if defined(VERIFY)
#error "Unexpected identifier conflict. (VERIFY)"
#endif

#if defined(_DEBUG)
#define VERIFY(Expression)  (_ASSERT(Expression))
#else
#define VERIFY(Expression)                                              \
{                                                                       \
    if (!(Expression))                                                  \
    {                                                                   \
        ERR_PRINT("\'" #Expression "\' failed: %u", GetLastError());    \
    }                                                                   \
}
#endif

```

`MouHidMonitor/driver.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "driver.h"

#include "debug.h"

#include "../Common/ioctl.h"


//=============================================================================
// Private Types
//=============================================================================
typedef struct _DRIVER_CONTEXT
{
    HANDLE DeviceHandle;

} DRIVER_CONTEXT, *PDRIVER_CONTEXT;


//=============================================================================
// Module Globals
//=============================================================================
static DRIVER_CONTEXT g_DriverContext = {};


//=============================================================================
// Meta Interface
//=============================================================================
_Use_decl_annotations_
BOOL
DrvInitialization()
{
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    BOOL status = TRUE;

    hDevice = CreateFileW(
        LOCAL_DEVICE_PATH_U,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (INVALID_HANDLE_VALUE == hDevice)
    {
        status = FALSE;
        goto exit;
    }

    //
    // Initialize the global context.
    //
    g_DriverContext.DeviceHandle = hDevice;

exit:
    if (!status)
    {
        if (INVALID_HANDLE_VALUE != hDevice)
        {
            VERIFY(CloseHandle(hDevice));
        }
    }

    return status;
}


VOID
DrvTermination()
{
    VERIFY(CloseHandle(g_DriverContext.DeviceHandle));
}


//=============================================================================
// Public Interface
//=============================================================================

//
// Suppress signed/unsigned mismatch warnings for Ioctl codes.
//
#pragma warning(push)
#pragma warning(disable:4245)

_Use_decl_annotations_
BOOL
DrvQueryMouHidInputMonitor(
    PBOOL pfEnabled
)
{
    QUERY_MOUHID_INPUT_MONITOR_REPLY Reply = {};
    DWORD cbReturned = 0;
    BOOL status = TRUE;

    //
    // Zero out parameters.
    //
    *pfEnabled = FALSE;

    status = DeviceIoControl(
        g_DriverContext.DeviceHandle,
        IOCTL_QUERY_MOUHID_INPUT_MONITOR,
        NULL,
        0,
        &Reply,
        sizeof(Reply),
        &cbReturned,
        NULL);
    if (!status)
    {
        goto exit;
    }

    //
    // Set out parameters.
    //
    *pfEnabled = Reply.Enabled;

exit:
    return status;
}


_Use_decl_annotations_
BOOL
DrvEnableMouHidInputMonitor()
{
    DWORD cbReturned = 0;
    BOOL status = TRUE;

    status = DeviceIoControl(
        g_DriverContext.DeviceHandle,
        IOCTL_ENABLE_MOUHID_INPUT_MONITOR,
        NULL,
        0,
        NULL,
        0,
        &cbReturned,
        NULL);
    if (!status)
    {
        goto exit;
    }

exit:
    return status;
}


_Use_decl_annotations_
BOOL
DrvDisableMouHidInputMonitor()
{
    DWORD cbReturned = 0;
    BOOL status = TRUE;

    status = DeviceIoControl(
        g_DriverContext.DeviceHandle,
        IOCTL_DISABLE_MOUHID_INPUT_MONITOR,
        NULL,
        0,
        NULL,
        0,
        &cbReturned,
        NULL);
    if (!status)
    {
        goto exit;
    }

exit:
    return status;
}

#pragma warning(pop) // disable:4245

```

`MouHidMonitor/driver.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <Windows.h>

//=============================================================================
// Meta Interface
//=============================================================================
_Check_return_
BOOL
DrvInitialization();

VOID
DrvTermination();

//=============================================================================
// Public Interface
//=============================================================================
_Check_return_
BOOL
DrvQueryMouHidInputMonitor(
    _Out_ PBOOL pfEnabled
);

_Check_return_
BOOL
DrvEnableMouHidInputMonitor();

_Check_return_
BOOL
DrvDisableMouHidInputMonitor();

```

`MouHidMonitor/log.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include "log.h"

#define NTSTRSAFE_NO_CB_FUNCTIONS

#include <cstdio>
#include <strsafe.h>

#include "debug.h"


//=============================================================================
// Constants
//=============================================================================
#define OUTPUT_BUFFER_CCH_MAX       512
#define MESSAGE_BUFFER_CCH_MAX      (OUTPUT_BUFFER_CCH_MAX - 80)

#define VALID_CONFIG_OUTPUT_MASK    (LOG_CONFIG_STDOUT | LOG_CONFIG_DEBUGGER)


//=============================================================================
// Private Types
//=============================================================================
typedef struct _LOG_CONTEXT {
    ULONG Config;
} LOG_CONTEXT, *PLOG_CONTEXT;


//=============================================================================
// Module Globals
//=============================================================================
static LOG_CONTEXT g_LogContext = {};


//=============================================================================
// Public Interface
//=============================================================================
_Use_decl_annotations_
BOOL
LogInitialization(
    ULONG Config
)
{
    BOOL status = TRUE;

    if ((~VALID_CONFIG_OUTPUT_MASK) & Config)
    {
        status = FALSE;
        goto exit;
    }

    //
    // Initialize the global context.
    //
    g_LogContext.Config = Config;

exit:
    return status;
}


_Use_decl_annotations_
HRESULT
LogPrint(
    LOG_LEVEL Level,
    ULONG Options,
    PCSTR pszFormat,
    ...
)
{
    PCSTR pszLevel = NULL;
    va_list VarArgs = {};
    CHAR szMessageBuffer[MESSAGE_BUFFER_CCH_MAX] = {};
    PCSTR pszOutputFormat = NULL;
    CHAR szOutputBuffer[OUTPUT_BUFFER_CCH_MAX] = {};
    int printstatus = 0;
    HRESULT hresult = S_OK;

    //
    // Set the log level prefix.
    //
    switch (Level)
    {
        case LogLevelDebug:     pszLevel = "DBG"; break;
        case LogLevelInfo:      pszLevel = "INF"; break;
        case LogLevelWarning:   pszLevel = "WRN"; break;
        case LogLevelError:     pszLevel = "ERR"; break;
        default:
            hresult = E_INVALIDARG;
            DEBUG_BREAK;
            goto exit;
    }

    va_start(VarArgs, pszFormat);
    hresult = StringCchVPrintfA(
        szMessageBuffer,
        RTL_NUMBER_OF(szMessageBuffer),
        pszFormat,
        VarArgs);
    va_end(VarArgs);
    if (FAILED(hresult))
    {
        DEBUG_BREAK;
        goto exit;
    }

    if (LOG_OPTION_APPEND_CRLF & Options)
    {
        pszOutputFormat = "%s  %04u:%04u  %s\r\n";
    }
    else
    {
        pszOutputFormat = "%s  %04u:%04u  %s";
    }

    hresult = StringCchPrintfA(
        szOutputBuffer,
        RTL_NUMBER_OF(szOutputBuffer),
        pszOutputFormat,
        pszLevel,
        GetCurrentProcessId(),
        GetCurrentThreadId(),
        szMessageBuffer);
    if (FAILED(hresult))
    {
        DEBUG_BREAK;
        goto exit;
    }

    if (LOG_CONFIG_DEBUGGER & g_LogContext.Config)
    {
        OutputDebugStringA(szOutputBuffer);
    }

    if (LOG_CONFIG_STDOUT & g_LogContext.Config)
    {
        printstatus = printf("%s", szOutputBuffer);
        if (0 > printstatus)
        {
            hresult = E_FAIL;
            DEBUG_BREAK;
            goto exit;
        }
    }

exit:
    return hresult;
}

```

`MouHidMonitor/log.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#include <Windows.h>

//=============================================================================
// Constants
//=============================================================================
#define LOG_CONFIG_STDOUT               0x00000001
#define LOG_CONFIG_DEBUGGER             0x00000002

#define LOG_OPTION_APPEND_CRLF          0x00000001

//=============================================================================
// Enumerations
//=============================================================================
typedef enum _LOG_LEVEL {
    LogLevelDebug,
    LogLevelInfo,
    LogLevelWarning,
    LogLevelError,
} LOG_LEVEL, *PLOG_LEVEL;

//=============================================================================
// Meta Interface
//=============================================================================
_Check_return_
BOOL
LogInitialization(
    _In_ ULONG Config
);

//=============================================================================
// Public Interface
//=============================================================================
HRESULT
LogPrint(
    _In_ LOG_LEVEL Level,
    _In_ ULONG Options,
    _In_z_ _Printf_format_string_ PCSTR pszFormat,
    ...
);

#if defined(_DEBUG)
#define DBG_PRINT(Format, ...) \
    LogPrint(LogLevelDebug, LOG_OPTION_APPEND_CRLF, (Format), __VA_ARGS__)
#else
//
// Debug level messages are disabled in release builds.
//
#define DBG_PRINT(Format, ...)
#endif

#define INF_PRINT(Format, ...) \
    LogPrint(LogLevelInfo, LOG_OPTION_APPEND_CRLF, (Format), __VA_ARGS__)

#define WRN_PRINT(Format, ...)  \
    LogPrint(                   \
        LogLevelWarning,        \
        LOG_OPTION_APPEND_CRLF, \
        (Format),               \
        __VA_ARGS__)

#define ERR_PRINT(Format, ...) \
    LogPrint(LogLevelError, LOG_OPTION_APPEND_CRLF, (Format), __VA_ARGS__)

```

`MouHidMonitor/main.cpp`:

```cpp
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#include <Windows.h>

#include "debug.h"
#include "driver.h"

#include "log.h"


//=============================================================================
// Constants
//=============================================================================
#define CONSOLE_MODE_OPTIONS            0

#define INPUT_EVENT_BUFFER_SIZE         64

#define EXIT_PROCESS_VIRTUAL_KEY        (VK_RETURN)

#define QUERY_THREAD_INTERVAL_MS        5000
#define QUERY_THREAD_EXIT_TIMEOUT_MS    10000


//=============================================================================
// Private Types
//=============================================================================
typedef struct _CONSOLE_CONTEXT
{
    HANDLE StandardInputHandle;

    BOOL RestorePreviousMode;
    DWORD PreviousMode;

} CONSOLE_CONTEXT, *PCONSOLE_CONTEXT;

typedef struct _MOUHID_MONITOR_CLIENT_CONTEXT
{
    BOOL Active;
    CONSOLE_CONTEXT Console;

} MOUHID_MONITOR_CLIENT_CONTEXT, *PMOUHID_MONITOR_CLIENT_CONTEXT;


//=============================================================================
// Module Globals
//=============================================================================
EXTERN_C static MOUHID_MONITOR_CLIENT_CONTEXT g_ClientContext = {};


//=============================================================================
// Private Interface
//=============================================================================
_Check_return_
static
DWORD
WINAPI
QueryMouHidMonitorThread(
    _In_ PVOID pContext
)
{
    PMOUHID_MONITOR_CLIENT_CONTEXT pClientContext = NULL;
    BOOL fMouHidInputMonitorEnabled = FALSE;
    DWORD exitstatus = ERROR_SUCCESS;

    pClientContext = (PMOUHID_MONITOR_CLIENT_CONTEXT)pContext;

    for (; pClientContext->Active;)
    {
        Sleep(QUERY_THREAD_INTERVAL_MS);

        //
        // If either of these calls fail then continue to the next iteration so
        //  that we can make another attempt.
        //
        if (!DrvQueryMouHidInputMonitor(&fMouHidInputMonitorEnabled))
        {
            ERR_PRINT("DrvQueryMouHidInputMonitor failed: %u", GetLastError());
            continue;
        }
        //
        if (!fMouHidInputMonitorEnabled)
        {
            INF_PRINT(
                "Detected mouse device changes. Enabling MouHid Monitor.");

            if (!DrvEnableMouHidInputMonitor())
            {
                ERR_PRINT("DrvEnableMouHidInputMonitor failed: %u",
                    GetLastError());
                continue;
            }
        }
    }

    return exitstatus;
}


_Check_return_
static
BOOL
WaitForExitEvent(
    _In_ HANDLE hStdIn
)
{
    INPUT_RECORD InputEvents[INPUT_EVENT_BUFFER_SIZE] = {};
    DWORD nEventsRead = 0;
    DWORD i = 0;
    BOOL status = TRUE;

    INF_PRINT("MouHid Input Monitor enabled.");
    INF_PRINT("Press ENTER to exit.");

    for (;;)
    {
        status = ReadConsoleInputW(
            hStdIn,
            InputEvents,
            ARRAYSIZE(InputEvents),
            &nEventsRead);
        if (!status)
        {
            ERR_PRINT("ReadConsoleInputW failed: %u", GetLastError());
            goto exit;
        }

        for (i = 0; i < nEventsRead; ++i)
        {
            if (KEY_EVENT != InputEvents[i].EventType)
            {
                continue;
            }

            if (EXIT_PROCESS_VIRTUAL_KEY ==
                InputEvents[i].Event.KeyEvent.wVirtualKeyCode)
            {
                INF_PRINT("Exiting.");
                goto exit;
            }
        }
    }

exit:
    return status;
}


_Check_return_
static
BOOL
WINAPI
CtrlSignalHandlerRoutine(
    _In_ DWORD dwCtrlType
)
{
    switch (dwCtrlType)
    {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
            if (g_ClientContext.Console.RestorePreviousMode)
            {
                VERIFY(SetConsoleMode(
                    g_ClientContext.Console.StandardInputHandle,
                    g_ClientContext.Console.PreviousMode));

                g_ClientContext.Console.RestorePreviousMode = FALSE;
            }

            break;

        case CTRL_CLOSE_EVENT:
        case CTRL_LOGOFF_EVENT:
        case CTRL_SHUTDOWN_EVENT:
        default:
            break;
    }

    return FALSE;
}


//=============================================================================
// Meta Interface
//=============================================================================
int
main(
    _In_ int argc,
    _In_ char* argv[]
)
{
    HANDLE hStdIn = NULL;
    BOOL fDriverInitialized = FALSE;
    BOOL fMouHidInputMonitorEnabled = FALSE;
    DWORD PreviousMode = 0;
    HANDLE hThread = NULL;
    DWORD ThreadId = 0;
    DWORD waitstatus = 0;
    DWORD ThreadExitCode = 0;
    int mainstatus = EXIT_SUCCESS;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    if (!LogInitialization(LOG_CONFIG_STDOUT))
    {
        ERR_PRINT("LogInitialization failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }

    hStdIn = GetStdHandle(STD_INPUT_HANDLE);
    if (INVALID_HANDLE_VALUE == hStdIn || !hStdIn)
    {
        ERR_PRINT("GetStdHandle failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }
    //
    g_ClientContext.Console.StandardInputHandle = hStdIn;

    if (!SetConsoleCtrlHandler(CtrlSignalHandlerRoutine, TRUE))
    {
        ERR_PRINT("SetConsoleCtrlHandler failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }

    if (!DrvInitialization())
    {
        ERR_PRINT("DrvInitialization failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }
    //
    fDriverInitialized = TRUE;

    if (!DrvQueryMouHidInputMonitor(&fMouHidInputMonitorEnabled))
    {
        ERR_PRINT("DrvQueryMouHidInputMonitor failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }
    //
    if (fMouHidInputMonitorEnabled)
    {
        WRN_PRINT("MouHid Monitor is already enabled.");
        goto exit;
    }

    if (!GetConsoleMode(hStdIn, &PreviousMode))
    {
        ERR_PRINT("GetConsoleMode failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }
    //
    g_ClientContext.Console.PreviousMode = PreviousMode;
    g_ClientContext.Console.RestorePreviousMode = TRUE;

    //
    // Disable console input.
    //
    if (!SetConsoleMode(hStdIn, CONSOLE_MODE_OPTIONS))
    {
        ERR_PRINT("SetConsoleMode failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }

    if (!DrvEnableMouHidInputMonitor())
    {
        ERR_PRINT("DrvEnableMouHidInputMonitor failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }
    //
    fMouHidInputMonitorEnabled = TRUE;
    g_ClientContext.Active = TRUE;

    //
    // Create a thread which queries the MouHid monitor state at a defined
    //  interval.
    //
    hThread = CreateThread(
        NULL,
        0,
        QueryMouHidMonitorThread,
        &g_ClientContext,
        0,
        &ThreadId);
    if (!hThread)
    {
        ERR_PRINT("CreateThread failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }

    if (!WaitForExitEvent(hStdIn))
    {
        ERR_PRINT("WaitForExitEvent failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }

    //
    // Update the client context to indicate that the query thread should exit.
    //
    g_ClientContext.Active = FALSE;

    //
    // Wait for the query thread to exit.
    //
    waitstatus = WaitForSingleObject(hThread, QUERY_THREAD_EXIT_TIMEOUT_MS);
    switch (waitstatus)
    {
        case WAIT_OBJECT_0:
            break;

        case WAIT_TIMEOUT:
            ERR_PRINT("Timedout waiting for query thread to exit.");
            mainstatus = EXIT_FAILURE;
            goto exit;

        case WAIT_FAILED:
            ERR_PRINT("WaitForSingleObject failed: %u", GetLastError());
            mainstatus = EXIT_FAILURE;
            goto exit;

        default:
            ERR_PRINT("Unexpected wait status: %u", waitstatus);
            mainstatus = EXIT_FAILURE;
            goto exit;
    }

    if (!GetExitCodeThread(hThread, &ThreadExitCode))
    {
        ERR_PRINT("GetExitCodeThread failed: %u", GetLastError());
        mainstatus = EXIT_FAILURE;
        goto exit;
    }
    //
    if (ERROR_SUCCESS != ThreadExitCode)
    {
        ERR_PRINT("Unexpected query thread exit code: %u", ThreadExitCode);
        mainstatus = EXIT_FAILURE;
        goto exit;
    }

exit:
    if (hThread)
    {
        VERIFY(CloseHandle(hThread));
    }

    if (fMouHidInputMonitorEnabled)
    {
        VERIFY(DrvDisableMouHidInputMonitor());
    }

    if (hStdIn && g_ClientContext.Console.RestorePreviousMode)
    {
        VERIFY(SetConsoleMode(hStdIn, g_ClientContext.Console.PreviousMode));
    }

    if (fDriverInitialized)
    {
        DrvTermination();
    }

    return mainstatus;
}

```

`README.md`:

```md
# MouHidInputHook

MouHidInputHook enables users to filter, modify, and inject mouse input data packets into the input data stream of HID USB mouse devices without modifying the mouse device stacks.

The [MouHid Hook Manager](./MouHidInputHook/mouhid_hook_manager.cpp) emulates the hook strategy used by the [Moufiltr](https://github.com/microsoft/Windows-driver-samples/tree/master/input/moufiltr) driver by hooking the [CONNECT_DATA](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/kbdmou/ns-kbdmou-_connect_data "CONNECT_DATA structure") object inside each MouHid device object. The MouHid driver uses the **ClassService** field of a CONNECT_DATA object to transfer mouse input data packets to mouse class data queues. By emulating this strategy, we have access to each data packet generated by the mouse device without needing to install a mouse filter driver. This emulation technique has the following benefits:

1. We can safely unhook mouse device stacks and unload the MouHidInputHook driver without needing to unload the hooked device stacks. A standard filter driver for a PnP device can only be unloaded after all of the device objects attached to it are destroyed.

2. The technique is PatchGuard safe.

3. The technique is relatively stealthy from the perspective of a kernel anti-cheat because:

    1. The field offset of the CONNECT_DATA object inside a MouHid device object is not defined in a public header.

    2. We do not modify the HID USB mouse device stack(s) by attaching a filter device object.

    A kernel anti-cheat must resort to heuristics or other potentially unsafe vectors in order to detect the presence of this technique. This is generally impractical because an anti-cheat driver must be reliable, i.e., avoid using undocumented information, in order to support the player base of the protected video game.

    This project uses a heuristic to resolve the CONNECT_DATA field offset during driver initialization (described below).

The MouHid Hook Manager supports PnP events by registering a PnP notification callback for mouse device interface changes. This callback is invoked each time a MouClass device object is added to or removed from the system.

## MouHid Monitor

The [MouHid Monitor](./MouHidInputHook/mouhid_monitor.cpp) is an example hook callback which logs the content of each data packet generated by a HID USB mouse. Users can utilize this feature to debug how mouse actions, e.g., moving the mouse or clicking a mouse button, are represented as a sequence of one or more data packets.

For example, we can determine the sequence of data packets required to emulate a left mouse button click action by loading the driver, running the client, and manually clicking the left mouse button. The following items are log output excerpts after performing this action on a local machine and in a virtual machine:

    The column data elements refer to CONNECT_DATA and MOUSE_INPUT_DATA fields:

        SC: Class service callback invoked to transfer the packet.  CONNECT_DATA.ClassService
        DO: Device object which contains the target data queue.     CONNECT_DATA.ClassDeviceObject
        ID: Target device unit id, e.g., '\Device\PointerClassX'.   MOUSE_INPUT_DATA.UnitId
        IF: Indicator flags.                                        MOUSE_INPUT_DATA.Flags
        BF: Transition state of the mouse buttons.                  MOUSE_INPUT_DATA.ButtonFlags
        BD: Wheel data for 'SCROLL' action packets.                 MOUSE_INPUT_DATA.ButtonData
        RB: Raw button state.                                       MOUSE_INPUT_DATA.RawButtons
        EX: Device-specific data.                                   MOUSE_INPUT_DATA.ExtraInformation
        LX: Signed relative or absolute motion in X direction.      MOUSE_INPUT_DATA.LastX
        LY: Signed relative or absolute motion in Y direction.      MOUSE_INPUT_DATA.LastY

    ================================= OUTPUT ==================================

    Platform:       Windows 7 SP1 x64
    Environment:    Local machine
    Mouse:          Logitech G303
    Action:         Hold mouse in the air, click left mouse button, put mouse on surface, move the mouse

        Packet 63: SC=FFFFF880040A8858 DO=FFFFFA800FDE78B0 ID=1 IF=0x000 BF=0x000 BD=0 RB=0 EX=0 LX=0 LY=-1
    D ->Packet 64: SC=FFFFF880040A8858 DO=FFFFFA800FDE78B0 ID=1 IF=0x000 BF=0x001 BD=0 RB=0 EX=0 LX=0 LY=0
    U ->Packet 65: SC=FFFFF880040A8858 DO=FFFFFA800FDE78B0 ID=1 IF=0x000 BF=0x002 BD=0 RB=0 EX=0 LX=0 LY=0
        Packet 66: SC=FFFFF880040A8858 DO=FFFFFA800FDE78B0 ID=1 IF=0x000 BF=0x000 BD=0 RB=0 EX=0 LX=0 LY=1
        Packet 67: SC=FFFFF880040A8858 DO=FFFFFA800FDE78B0 ID=1 IF=0x000 BF=0x000 BD=0 RB=0 EX=0 LX=0 LY=1

    Platform:       Windows 7 SP1 x64
    Environment:    VMware virtual machine, vmusbmouse.sys mouse filter driver active
    Mouse:          Logitech G303
    Action:         Hold mouse in the air, click left mouse button, put mouse on surface, move the mouse

        Packet 75: SC=FFFFF880025630C0 DO=FFFFFA80040F6A40 ID=1 IF=0x003 BF=0x000 BD=0 RB=0 EX=0 LX=12580 LY=25436
    D ->Packet 76: SC=FFFFF88003FE5858 DO=FFFFFA8004106CF0 ID=2 IF=0x000 BF=0x001 BD=0 RB=0 EX=0 LX=0 LY=0
        Packet 77: SC=FFFFF880025630C0 DO=FFFFFA80040F6A40 ID=1 IF=0x003 BF=0x000 BD=0 RB=0 EX=0 LX=12580 LY=25436
    U ->Packet 78: SC=FFFFF88003FE5858 DO=FFFFFA8004106CF0 ID=2 IF=0x000 BF=0x002 BD=0 RB=0 EX=0 LX=0 LY=0
        Packet 79: SC=FFFFF880025630C0 DO=FFFFFA80040F6A40 ID=1 IF=0x003 BF=0x000 BD=0 RB=0 EX=0 LX=12580 LY=25436
        Packet 80: SC=FFFFF880025630C0 DO=FFFFFA80040F6A40 ID=1 IF=0x003 BF=0x000 BD=0 RB=0 EX=0 LX=12528 LY=25436
        Packet 81: SC=FFFFF880025630C0 DO=FFFFFA80040F6A40 ID=1 IF=0x003 BF=0x000 BD=0 RB=0 EX=0 LX=12474 LY=25544
        Packet 82: SC=FFFFF880025630C0 DO=FFFFFA80040F6A40 ID=1 IF=0x003 BF=0x000 BD=0 RB=0 EX=0 LX=12422 LY=25544

    Note: The above output was modified to increase readability.

The data packet for the left mouse button down action is indicated by **D ->**, and the data packet for the left mouse button up action is indicated by **U ->**.

We can infer the following rules for these environments:

1. The local machine environment uses **MOUSE_MOVE_RELATIVE** for mouse movement actions, and the virtual machine environment uses **MOUSE_MOVE_ABSOLUTE**.

2. The local machine environment contains one HID USB mouse device stack, and the virtual machine environment contains two HID USB mouse device stacks. The virtual machine environment uses different (ClassDeviceObject, ClassService) pairs for button action packets and movement action packets. Each pair is represented by a CONNECT_DATA object inside a MouHid device object. Therefore, there must be two MouHid device objects and two device stacks.

3. The virtual machine environment contains multiple unit ids. This implies that there are two named mouse class device objects: **\Device\PointerClass1** and **\Device\PointerClass2**. There must be two class data queues: one for button action packets and one for movement action packets. Therefore, a data packet should never contain both button data and movement data. Conversely, data packets in the local machine environment can contain both data types because there is one class data queue.

4. The virtual machine contains a third party filter driver, vmusbmouse, which generates a movement data packet between a button-down packet and its corresponding button-up packet. This may be related to the mouse smoothing feature of VMware Tools.

### MouClassInputInjection

The [MouClassInputInjection](https://github.com/changeofpace/MouClassInputInjection) project is an application of the knowledge acquired from using the **MouHid Monitor**. This project uses a MouHidInputHook hook callback to dynamically resolve the packet data rules for the HID USB mouse device stacks on the host machine. These rules are used to synthesize and inject valid data packets into the input data stream.

## Projects

### MouHidInputHook

The core driver project which implements the hook interface.

### MouHidMonitor

A command line **MouHidInputHook** client which enables the MouHid Monitor.

## Input Processing Internals

### Input Class Drivers

The input class drivers, kbdclass.sys and mouclass.sys, allow hardware-independent operation of input devices by enforcing a non-standard communication protocol between device objects in an input device stack. This protocol divides the device stack into two substacks: the hardware-independent upper stack and the hardware-dependent lower stack. The lower stack transfers input data from a physical device to the upper stack via the [class service callback](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/kbdmou/nc-kbdmou-pservice_callback_routine "PSERVICE_CALLBACK_ROUTINE callback function"). The class service callback ensures that the upper stack always receives input data in a normalized format.

### Class Service Callback

The class service callback for an input device stack is established by the input class driver's **AddDevice** routine. This routine performs the following actions:

1. Creates an upper-level class filter device object.
2. Attaches the new device object to the input device stack.
3. Initializes a [CONNECT_DATA](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/kbdmou/ns-kbdmou-_connect_data "CONNECT_DATA structure") object for this class device object.
4. Sends the connect data object inside a connect-device request down the device stack.

The device object whose driver completes this request is the top-level device object in the lower substack. This driver stores the connect data object inside the device extension of the corresponding device object.

### Class Data Queue

A class device object contains a circular buffer of input data packets in its device extension. This buffer, referred to as the class data queue, is effectively a producer/consumer queue.

The lower substack produces data packets by invoking the class service callback when new input data is available. The class service callback copies the input data from the input buffer maintained by the lower substack device to the class data queue.

The win32k subsystem consumes data packets by reading the input device via nt!ZwReadFile. ZwReadFile issues an irp to the top of the input device stack which is ultimately handled by the IRP_MJ_READ handler of the input class driver. This handler copies data packets from the class data queue to the irp's system buffer.

### Input Processing

The following diagram depicts the input processing system for a HID USB mouse device on Windows 7 SP1 x64.

<p align="center">
    <img src="Image/mouse_input_processing_internals.png" />
</p>

#### Upper Substack

1. The upper substack read cycle begins in win32k!StartDeviceRead. This routine issues a read request for a mouse device by invoking nt!ZwReadFile:

    ```C++
    ZwReadFile(
        MouseDeviceHandle,  // Handle to the mouse device to read packets from
                            //  (referred to as the 'target mouse device')
        NULL,
        win32k!InputApc,    // Apc routine executed when the read is completed
        MouseDeviceInfo,    // Pointer to the DEVICEINFO object for the target
                            //  mouse device (see win32k!gpDeviceInfoList)
        IoStatusBlock,
        Buffer,             // MOUSE_INPUT_DATA buffer inside MouseDeviceInfo
        Length,
        &win32k!gZero,
        0);
    ```

2. nt!ZwReadFile sends an IRP_MJ_READ irp to the top of the target mouse device stack.

3. The irp is ultimately processed by the MouClass IRP_MJ_READ handler, mouclass!MouseClassRead. This routine validates the irp then invokes mouclass!MouseClassHandleRead.

    If the class data queue of the target mouse device object contains new input data packets then mouclass!MouseClassHandleRead invokes mouclass!MouseClassReadCopyData. This routine copies the new data packets from the class data queue to the irp's system buffer.

    If the class data queue does not contain new input data packets then:

    1. The irp is appended to a linked list in the device extension of the target mouse device object (referred to as the pending irp list).

    2. STATUS_PENDING is returned to nt!NtReadFile.

4. The win32k!InputApc routine is invoked when the irp is completed. This routine invokes win32k!ProcessMouseInput via a function pointer in the DEVICE_TEMPLATE object for the mouse device type in the DEVICE_TEMPLATE array, win32k!aDeviceTemplate. win32k!ProcessMouseInput applies movement data from the data packets to the user desktop and queues each packet to win32k!gMouseEventQueue. The raw input thread processes this queue inside win32k!RawInputThread. Finally, win32k!InputApc restarts the read cycle by invoking win32k!StartDeviceRead.

#### Lower Substack

1. The lower substack read cycle begins in mouhid!MouHid_StartRead. This routine initializes (reuses) an IRP_MJ_READ irp, sets the completion routine to mouhid!MouHid_ReadComplete, and then sends it to the next lower device object in the device stack, a HidUsb device object, via nt!IofCallDriver. The irp is routed to the IRP_MJ_READ handler defined in the HidUsb driver object, HIDCLASS!HidpMajorHandler.

2. HIDCLASS!HidpMajorHandler invokes HIDCLASS!HidpIrpMajorRead. The irp routing and processing beyond this point is outside the scope of this analysis.

3. USBPORT!USBPORT_Core_iCompleteDoneTransfer invokes nt!IopfCompleteRequest to complete the irp after new input data is read from the physical device. The irp's completion routine, mouhid!MouHid_ReadComplete, is invoked. This routine converts the input data from its hardware-dependent format, HID report, to the hardware-independent format, [MOUSE_INPUT_DATA](https://docs.microsoft.com/en-us/windows/win32/api/ntddmou/ns-ntddmou-mouse_input_data "MOUSE_INPUT_DATA structure") packet. The converted packets are stored in the device extension of the MouHid device object associated with the completed irp.

4. mouhid!MouHid_ReadComplete invokes the [mouse class service callback](https://docs.microsoft.com/en-us/previous-versions/ff542394%28v%3dvs.85%29 "MouseClassServiceCallback"), mouclass!MouseClassServiceCallback, via the ClassService field of the CONNECT_DATA object in the device extension of the MouHid device object associated with the completed irp:

    ```C++
    PMOUHID_DEVICE_EXTENSION DeviceExtension = MouHidDeviceObject->DeviceExtension;
    PCONNECT_DATA ConnectData = &DeviceExtension->ConnectData;
    ULONG InputDataConsumed = 0;

    ((MOUSE_SERVICE_CALLBACK_ROUTINE)ConnectData->ClassService)(
        ConnectData->ClassDeviceObject,
        DeviceExtension->InputDataStart,
        DeviceExtension->InputDataEnd,
        &InputDataConsumed);
    ```

    mouclass!MouseClassServiceCallback uses data packets from the **InputDataStart** buffer to complete each irp in the pending irp list of the class device object. The remaining input data packets in the InputDataStart buffer are copied to the class data queue of the class device object. Finally, each serviced irp is completed via nt!IofCompleteRequest. This action is directly connected to item [4] in the **Upper Substack** description above.

5. mouhid!MouHid_ReadComplete restarts the read cycle by invoking mouhid!MouHid_StartRead. The **Hook Point** indicates where the MouHid Hook Manager installs the class service hook.

## Connect Data Heuristic

The [MouHid](./MouHidInputHook/mouhid.cpp) module uses a heuristic to dynamically resolve the **CONNECT_DATA** field inside the MouHid device extension. This heuristic is based on the MouClass initialiation protocol so it may be applicable to other mouse device types. i.e., This heuristic can potentially be used for any mouse device stack which uses the MouClass driver. The following is a summary of the heuristic:

1. Obtain a list of all the MouHid device objects.

2. For each MouHid device object:

    1. Get the device object attached to the MouHid device object.

    2. Get the address range of every executable image section in the driver of
        the attached device object.

    3. Search the device extension of the MouHid device object for a valid
        CONNECT_DATA object by interpreting each pointer-aligned address as a
        CONNECT_DATA candidate. A candidate is valid if it meets the following
        criteria:

        1. The **ClassDeviceObject** field matches the attached device object.

        2. The **ClassService** field points to an address contained in one of
            the executable image sections from (ii).

## Log Output

Use **DebugView** (or **DbgView**) from Sysinternals to read the driver's log output.

## Notes

* The MouHidInputHook project was developed for Windows 7 SP1 x64. Support for other platforms is unknown.
* The MouHidInputHook hook technique is PatchGuard safe.

```