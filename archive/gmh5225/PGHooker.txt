Project Path: arc_gmh5225_PGHooker_4mgj9cki

Source Tree:

```txt
arc_gmh5225_PGHooker_4mgj9cki
├── Examples.cpp
├── LICENSE
├── PGHooker.hpp
├── PGHooker.sln
├── PGHooker.vcxproj
├── PGHooker.vcxproj.filters
└── README.md

```

`Examples.cpp`:

```cpp
#include <iostream>

#include "PGHooker.hpp"

void PGHAPI CallbackRead0( PCONTEXT pCtx, E_CallbackFlags eType )
{
    printf( "-- CallbackRead0 \n" );
}

void PGHAPI CallbackWrite1( PCONTEXT pCtx, E_CallbackFlags eType )
{
    printf( "-- CallbackWrite1 \n" );
}

void PGHAPI CallbackReadWrite2( PCONTEXT pCtx, E_CallbackFlags eType )
{
    printf( "-- CallbackReadWrite2: %d \n", eType );
}

int WINAPI hkMessageBoxA( HWND hWnd,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType )
{
    printf( "MessageBoxA hook called !!! \n" );

    PGHooker::DisableHookForOnce( MessageBoxA );
    return MessageBoxA( hWnd, lpText, lpCaption, uType );
}

int main()
{
    PGHooker::Initialize( );

    printf( "RW hooking test \n--- \n" );
    { 
        volatile int temp {};
        volatile int* pMas = ( int* ) VirtualAlloc( NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE );

        PGHooker::CreateCallback( ( int* ) pMas, CF_READ, CallbackRead0 );
        PGHooker::CreateCallback( ( int* ) pMas + 1, CF_WRITE, CallbackWrite1 );
        PGHooker::CreateCallback( ( int* ) pMas + 2, CF_READ | CF_WRITE, CallbackReadWrite2 );

        printf( "reading pMas[0] \n" );
        temp = pMas[ 0 ];

        printf( "writing pMas[1] \n" );
        pMas[ 1 ] = 1;

        printf( "writing & reading pMas[2] \n" );
        pMas[ 2 ] = temp;
        temp = pMas[ 2 ];

        PGHooker::RemoveCallback( ( int* ) pMas );
        PGHooker::RemoveCallback( ( int* ) pMas + 1 );
    }

    printf( "\nFunction hooking test \n--- \n" );
    {
        PGHooker::CreateHook( MessageBoxA, hkMessageBoxA );

        printf( "Calling MessageBoxA \n" );

        MessageBoxA( NULL, "Text", "Caption", MB_ICONINFORMATION );

        PGHooker::RemoveHook( MessageBoxA );
    }

    PGHooker::Uninitilize( ); // also this function removes PAGE_GUARD from all used pages 

    printf( "End! \n" );

    return 0;
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 nelfo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PGHooker.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <list>

#ifdef _WIN64
#define GetPage(Ptr) ((uintptr_t)Ptr & 0xFFFFFFFFFFFFF000)
#else
#define GetPage(Ptr) ((uintptr_t)Ptr & 0xFFFFF000)
#endif

enum E_CallbackFlags : int
{
	CF_READ = 1 << 0,
	CF_WRITE = 1 << 1,
};

enum E_ExceptionInfoZero : int
{
	EIZ_READ,
	EIZ_WRITE,
	EIZ_DEPVIO = 8,
};

#define PGHAPI __fastcall
typedef void( PGHAPI* PGHCALLBACK )( PCONTEXT pCtx, E_CallbackFlags eType );

class C_CallbackInfo
{
public:
	const void* m_pAddress {};
	PGHCALLBACK m_pCallback {};
	E_CallbackFlags m_eFlags {};
};

class C_HookInfo
{
public:
	const void* m_pRedirectFrom {};
	const void* m_pRedirectTo {};
	bool m_bOnceDisabled {};
};

namespace PGHooker
{
	std::list < C_CallbackInfo > cCallbacksInfo {};
	std::list < C_HookInfo > cHooksInfo {};
	PVOID pVEHHandle {};

	void GuardPage( const void* pAddress )
	{
		DWORD oldProtect {};
		MEMORY_BASIC_INFORMATION mbi {};

		VirtualQuery( pAddress, &mbi, sizeof( MEMORY_BASIC_INFORMATION ) );
		VirtualProtect( ( LPVOID ) pAddress, 1, mbi.Protect | PAGE_GUARD, &oldProtect );
	}

	void UnGuardPage( const void* pAddress )
	{
		DWORD oldProtect {};
		MEMORY_BASIC_INFORMATION mbi {};

		VirtualQuery( pAddress, &mbi, sizeof( MEMORY_BASIC_INFORMATION ) );
		VirtualProtect( ( LPVOID ) pAddress, 1, mbi.Protect & ~PAGE_GUARD, &oldProtect );
	}

	LONG WINAPI VectoredHandler( PEXCEPTION_POINTERS pExceptionInfo )
	{
		static const void* pLastAddress = nullptr;

		if ( pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_GUARD_PAGE )
		{
			auto uType = pExceptionInfo->ExceptionRecord->ExceptionInformation[ 0 ];
			const void* pAddress = ( const void* ) pExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];

			pLastAddress = pAddress;

			if ( uType == EIZ_READ || uType == EIZ_WRITE )
			{
				for ( auto& cInfo : cCallbacksInfo )
				{
					if ( pAddress != cInfo.m_pAddress )
						continue;

					E_CallbackFlags eExFlag = E_CallbackFlags( 1 << uType );

					if ( !( cInfo.m_eFlags & eExFlag ) )
						continue;

					cInfo.m_pCallback( pExceptionInfo->ContextRecord, eExFlag );
				}
			}
			else if ( uType == EIZ_DEPVIO )
			{
				for ( auto& cInfo : cHooksInfo )
				{
					if ( pAddress != cInfo.m_pRedirectFrom )
						continue;

					if ( cInfo.m_bOnceDisabled )
					{
						cInfo.m_bOnceDisabled = false;
						continue;
					}
#ifdef _WIN64
					pExceptionInfo->ContextRecord->Rip = ( DWORD64 ) cInfo.m_pRedirectTo;
#else
					pExceptionInfo->ContextRecord->Eip = ( DWORD ) cInfo.m_pRedirectTo;
#endif
					break;
				}
			}

			pExceptionInfo->ContextRecord->EFlags |= 0x100ui32;
			return EXCEPTION_CONTINUE_EXECUTION;
		}
		else if ( pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP )
		{
			if ( pLastAddress )
			{
				GuardPage( pLastAddress );
				pLastAddress = nullptr;
			}

			return EXCEPTION_CONTINUE_EXECUTION;
		}

		return EXCEPTION_CONTINUE_SEARCH;
	}

	void Initialize( )
	{
		pVEHHandle = AddVectoredExceptionHandler( 1u, VectoredHandler );
	}

	void Uninitilize( )
	{
		for ( auto& cInfo : cHooksInfo )
			UnGuardPage( cInfo.m_pRedirectFrom );

		cHooksInfo.clear( );

		for ( auto& cInfo : cCallbacksInfo )
			UnGuardPage( cInfo.m_pAddress );

		cCallbacksInfo.clear( );

		RemoveVectoredExceptionHandler( pVEHHandle );
	}

	void CreateHook( const void* pFrom, const void* pTo )
	{
		bool bGuard = true;

		for ( auto& cInfo : cHooksInfo )
		{
			if ( cInfo.m_pRedirectFrom == pFrom )
				return;

			if ( GetPage( cInfo.m_pRedirectFrom ) == GetPage( pFrom ) )
				bGuard = false;
		}

		cHooksInfo.push_back( { pFrom, pTo, false } );

		if ( bGuard )
			GuardPage( pFrom );
	}

	void DisableHookForOnce( const void* pFrom )
	{
		for ( auto& cInfo : cHooksInfo )
		{
			if ( cInfo.m_pRedirectFrom != pFrom )
				continue;

			cInfo.m_bOnceDisabled = true;
			break;
		}
	}

	void RemoveHook( const void* pFrom )
	{
		std::list < C_HookInfo >::iterator i = cHooksInfo.begin( );
		bool bRemoved = false;

		while ( i != cHooksInfo.end( ) )
		{
			if ( i->m_pRedirectFrom == pFrom )
			{
				cHooksInfo.erase( i );
				bRemoved = true;
				break;
			}

			++i;
		}

		if ( !bRemoved )
			return;

		bool bUnGuard = true;

		for ( auto& cInfo : cHooksInfo )
		{
			if ( GetPage( cInfo.m_pRedirectFrom ) == GetPage( pFrom ) )
			{
				bUnGuard = false;
				break;
			}
		}

		if ( bUnGuard )
			UnGuardPage( pFrom );
	}

	void CreateCallback( const void* pAddress, int iFlags, PGHCALLBACK pCallback )
	{
		bool bGuard = true;

		for ( auto& cInfo : cCallbacksInfo )
		{
			if ( GetPage( cInfo.m_pAddress ) == GetPage( pAddress ) )
			{
				bGuard = false;
				break;
			}
		}

		cCallbacksInfo.push_back( { pAddress, pCallback, ( E_CallbackFlags ) iFlags } );

		if ( bGuard )
			GuardPage( pAddress );
	}

	void RemoveCallback( const void* pAddress )
	{
		std::list < C_CallbackInfo >::iterator i = cCallbacksInfo.begin( );
		bool bRemoved = false;

		while ( i != cCallbacksInfo.end( ) )
		{
			if ( i->m_pAddress == pAddress )
			{
				i = cCallbacksInfo.erase( i );
				bRemoved = true;
			}
			else
				++i;
		}

		if ( !bRemoved )
			return;

		bool bUnGuard = true;

		for ( auto& cInfo : cCallbacksInfo )
		{
			if ( GetPage( cInfo.m_pAddress ) == GetPage( pAddress ) )
			{
				bUnGuard = false;
				break;
			}
		}

		if ( bUnGuard )
			UnGuardPage( pAddress );
	}
}

```

`PGHooker.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32505.173
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PGHooker", "PGHooker.vcxproj", "{77A8388A-D5DC-4912-A4AC-151FF40637F3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{77A8388A-D5DC-4912-A4AC-151FF40637F3}.Release|x64.ActiveCfg = Release|x64
		{77A8388A-D5DC-4912-A4AC-151FF40637F3}.Release|x64.Build.0 = Release|x64
		{77A8388A-D5DC-4912-A4AC-151FF40637F3}.Release|x86.ActiveCfg = Release|Win32
		{77A8388A-D5DC-4912-A4AC-151FF40637F3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9436AC01-2E73-4A9E-89C6-D176D33653C0}
	EndGlobalSection
EndGlobal

```

`PGHooker.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{77a8388a-d5dc-4912-a4ac-151ff40637f3}</ProjectGuid>
    <RootNamespace>PGHooker</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Examples.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="PGHooker.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PGHooker.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Examples.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="PGHooker.hpp">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# PGHooker
 
## Function hooking example

```cpp
#include <iostream>

#include "PGHooker.hpp"

int WINAPI hkMessageBoxA( HWND hWnd,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType )
{
    printf( "MessageBoxA hook called !!! \n" );

    PGHooker::DisableHookForOnce( MessageBoxA );
    return MessageBoxA( hWnd, lpText, lpCaption, uType );
}

int main( )
{
    PGHooker::Initialize( );
    PGHooker::CreateHook( MessageBoxA, hkMessageBoxA );

    printf( "Calling MessageBoxA \n" );

    MessageBoxA( NULL, "Text", "Caption", MB_ICONINFORMATION );
    
    printf( "End! \n" );

    return 0;
}
```
## Console output
```
Calling MessageBoxA
MessageBoxA hook called !!!
End!
```

```