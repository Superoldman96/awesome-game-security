Project Path: arc_gmh5225_hwid-checker-mg_s7qqs1vj

Source Tree:

```txt
arc_gmh5225_hwid-checker-mg_s7qqs1vj
├── LICENSE.txt
├── README.md
├── hwid-checker-mg.sln
├── hwid_checker
│   ├── hwid-checker-mg.vcxproj
│   ├── hwid-checker-mg.vcxproj.filters
│   ├── hwid-checker-mg.vcxproj.user
│   ├── hwid_checker.cpp
│   ├── hwid_checker.vcxproj
│   ├── hwid_checker.vcxproj.user
│   └── includes
│       ├── smbios.cpp
│       └── smbios.hpp
└── img
    ├── Capture_cmd.PNG
    └── unknown.png

```

`LICENSE.txt`:

```txt
The MIT License (MIT)

Copyright (c) 2020 medievalghoul

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
![Build status](https://ci.appveyor.com/api/projects/status/hjxm9hfjwljab2am?svg=true)
# hwid-checker-mg

Before I proceed, I would like to give a huge thanks to nealhow_ ([github](https://github.com/nealhow), [twitter](https://twitter.com/nealhow_)) for being a huge help, by 
contributing so much with his knowlegde and skills. Without him and his guidence, this project would've took longer to make. 
Fun fact, at the time of making this project I wasn't able to find a single C++ hwid checker

### INTRODUCTION 

hwid-checker-mg is simple, proof-of-concept, hardware id checker made in C++ that utilizes the SMBIOS/DMI standards to 
output information that's been described by the BIOS. The information ranges from 
system manufacturer, model name, serial number (Which is our main focus for this hwid checker)

C++ has been chosen as the language of this project for two reasons:
- I couldn't, at time of making this, find a straight forward answer documentation for creating extracting data from the smbios.
  Most if the answers I've encounter were a bit vague. So, I created this to have a basic foundation on understand how HWID spoofers work
- It was a challenge

This was a great learning experience and was much a challenge. Here are some of the concepts
I've encountered 
- what is smbios and why was it needed?
  - The SMBIOS stands for *System Management BIOS*. It provides a set of data structures or tables that describes a computer's BIOS configuration.
	The use of SMBIOS elimiated the use of having to directly get the hardware's information.

- what is DMI?
  - Sort for Desktop Management Interface, is a manager that generates a standard for managing and tracking components of a computer.
    By standard it's referring to it being applicable to other OSes.

Evidently, it'll be need to read [System Management BIOS (SMBIOS) Reference Specification Version 3.3.0](https://www.dmtf.org/standards/smbios) to further your understanding on this topic.

Also, allocating a ``RawSMBIOSData data struct`` in the heap at runtime gave undefine behavior. So I wouldn't recommended it.

### DOCUMENTATION

**Doc 1: Table 3 – Structure header format description**

```c

// windows struct

typedef struct _dmi_header
{
	BYTE		type;
	BYTE		length;
	WORD		handle;
} dmi_header;

// and for linux

struct dmi_header {
	u8 type;
	u8 length;
	u16 handle;
} __packed;
```

- First, The type data member of size ``BYTE`` or ``uint8_t`` holds the SMBIOS specification defines the DMI Types different types of elements a computer. For example, type 2, means that the record contains 
  "Base Board" Information. To have a better understand of the Types SMBIOS defines, here's a code representation in file [smbios.hpp](https://github.com/medievalghoul/hwid-checker-mg/tree/master/hwid_checker/includes/smbios.hpp):

```c++
  enum dmi_entry_type
    : BYTE /* 6.1.2 Structure header format */
  {
    DMI_ENTRY_BIOS = 0,
    DMI_ENTRY_SYSTEM,
    DMI_ENTRY_BASEBOARD,
    DMI_ENTRY_CHASSIS,
    DMI_ENTRY_PROCESSOR,
    DMI_ENTRY_MEM_CONTROLLER,
    DMI_ENTRY_MEM_MODULE,
    DMI_ENTRY_CACHE,
    DMI_ENTRY_PORT_CONNECTOR,
    DMI_ENTRY_SYSTEM_SLOT,
    DMI_ENTRY_ONBOARD_DEVICE,
    DMI_ENTRY_OEMSTRINGS,
    DMI_ENTRY_SYSCONF,
    DMI_ENTRY_BIOS_LANG,
    DMI_ENTRY_GROUP_ASSOC,
    DMI_ENTRY_SYSTEM_EVENT_LOG,
    DMI_ENTRY_PHYS_MEM_ARRAY,
    DMI_ENTRY_MEM_DEVICE,
    DMI_ENTRY_32_MEM_ERROR,
    DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR,
    DMI_ENTRY_MEM_DEV_MAPPED_ADDR,
    DMI_ENTRY_BUILTIN_POINTING_DEV,
    DMI_ENTRY_PORTABLE_BATTERY,
    DMI_ENTRY_SYSTEM_RESET,
    DMI_ENTRY_HW_SECURITY,
    DMI_ENTRY_SYSTEM_POWER_CONTROLS,
    DMI_ENTRY_VOLTAGE_PROBE,
    DMI_ENTRY_COOLING_DEV,
    DMI_ENTRY_TEMP_PROBE,
    DMI_ENTRY_ELECTRICAL_CURRENT_PROBE,
    DMI_ENTRY_OOB_REMOTE_ACCESS,
    DMI_ENTRY_BIS_ENTRY,
    DMI_ENTRY_SYSTEM_BOOT,
    DMI_ENTRY_MGMT_DEV,
    DMI_ENTRY_MGMT_DEV_COMPONENT,
    DMI_ENTRY_MGMT_DEV_THRES,
    DMI_ENTRY_MEM_CHANNEL,
    DMI_ENTRY_IPMI_DEV,
    DMI_ENTRY_SYS_POWER_SUPPLY,
    DMI_ENTRY_ADDITIONAL,
    DMI_ENTRY_ONBOARD_DEV_EXT,
    DMI_ENTRY_MGMT_CONTROLLER_HOST,
    DMI_ENTRY_INACTIVE = 126,
    DMI_ENTRY_END_OF_TABLE = 127,
  };
```
- Second, the length data member of size ``BYTE`` or ``uint8_t`` holds the size of the 
  formatted area starting at type field. Formated area can also be referred to as the area with recorded information.
  The length is also used as a relative offset as you'll be seeing in ([smbios.cpp](),[hwid_checker.cpp]()).

- Third, the handle data member of size ``WORD`` or ``uint16_t`` is a unique identifier, which allows certain records to reference to each other.
  An example would be memory device referencing to memory conttroller and vice versa.

**Doc 2: Raw SMBIOS firmware table provider**

```c++
#include <windows.h>

typedef struct RawSMBIOSData
{
	BYTE    Used20CallingMethod;
	BYTE    SMBIOSMajorVersion;
	BYTE    SMBIOSMinorVersion;
	BYTE    DmiRevision;
	DWORD   Length;
	BYTE    SMBIOSTableData[];
} RawSMBIOSData;

DWORD smbios_data_size	       {};
BYTE  *b_		       {nullptr};
dmi_header* header             {nullptr};
RawSMBIOSData* smbios_data     {nullptr};
BYTE smbios_data_buffer[0x10000] = { 0 };

GetSystemFirmwareTable('RSMB', 0, smbios_data_buffer, smbios_buffersize);
```

The **GetSystemFirmwareTable** function retrieves specified firmware tables from a firmware tables provider.
in our case the Raw SMBIOS Firmware provider tables.

Also, allocating a ``RawSMBIOSData data_structure`` in the heap at runtime, gave undefined behaviors. So I wouldn't recommended it.

### Resource that undeceive my research
    Most all of them are bit vague:	
    https://www.youtube.com/watch?v=yX6caxDOPu0
	https://stackoverflow.com/questions/43473262/getting-the-motherboards-serial-number
	https://www.experts-exchange.com/videos/7444/What-is-WMI-and-how-it-can-be-used-to-get-hardware-and-software-information-from-remote-computers.html
	https://www.codeproject.com/Questions/437379/Cplusplus-source-code-to-get-CPU-number-motherboar
	https://docs.microsoft.com/en-us/windows/win32/sysinfo/system-information-functions?redirectedfrom=MSDN
	https://stackoverflow.com/questions/56935213/how-to-get-adapter-driver-version-in-directx12/56960922
	https://stackoverflow.com/questions/1090261/get-the-graphics-card-model
	https://docs.microsoft.com/en-us/windows/win32/direct3d9/d3dadapter-identifier9
	https://docs.microsoft.com/en-us/windows/win32/api/guiddef/ns-guiddef-guid
	https://stackoverflow.com/questions/1672677/print-a-guid-variable
	https://www.windows-commandline.com/get-serial-number-for-ram-motherboard-hard-disk/
	https://stackoverflow.com/questions/43473262/getting-the-motherboards-serial-number
	https://www.dmtf.org/standards/smbios
	https://gist.github.com/daiakushi/98a004e7cd750803dfe1
	https://www.codeproject.com/Tips/5263343/How-to-Get-the-BIOS-UUID


	by reading source code of dmicode:
	- https://github.com/mirror/dmidecode/blob/master/dmidecode.c
	- https://elixir.bootlin.com/linux/latest/source/include/linux/dmi.h

	uuid vs guid: 
	- https://stackoverflow.com/questions/246930/is-there-any-difference-between-a-guid-and-a-uuid?rq=1

	dmicode:
	- https://linux.die.net/man/8/dmidecode  
  
  
Thanks for the read

```

`hwid-checker-mg.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30011.22
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "hwid_checker", "hwid_checker\hwid_checker.vcxproj", "{0915FF14-6ACB-41E0-8C32-5252FB32D182}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0915FF14-6ACB-41E0-8C32-5252FB32D182}.Debug|x64.ActiveCfg = Debug|x64
		{0915FF14-6ACB-41E0-8C32-5252FB32D182}.Debug|x64.Build.0 = Debug|x64
		{0915FF14-6ACB-41E0-8C32-5252FB32D182}.Debug|x86.ActiveCfg = Debug|Win32
		{0915FF14-6ACB-41E0-8C32-5252FB32D182}.Debug|x86.Build.0 = Debug|Win32
		{0915FF14-6ACB-41E0-8C32-5252FB32D182}.Release|x64.ActiveCfg = Release|x64
		{0915FF14-6ACB-41E0-8C32-5252FB32D182}.Release|x64.Build.0 = Release|x64
		{0915FF14-6ACB-41E0-8C32-5252FB32D182}.Release|x86.ActiveCfg = Release|Win32
		{0915FF14-6ACB-41E0-8C32-5252FB32D182}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D7E91943-4513-48F4-B620-C2638232A531}
	EndGlobalSection
EndGlobal

```

`hwid_checker/hwid-checker-mg.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{0915FF14-6ACB-41E0-8C32-5252FB32D182}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>hwidchecker</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>hwid-checker-mg</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin_left$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin_left$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin_left$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin_left$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="hwid-checker-mg.cpp" />
    <ClCompile Include="includes\smbios.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes\smbios.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`hwid_checker/hwid-checker-mg.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="includes\smbios.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hwid-checker-mg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes\smbios.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`hwid_checker/hwid-checker-mg.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`hwid_checker/hwid_checker.cpp`:

```cpp
// hwid_checker.cpp

#include "includes/smbios.hpp"

using std::cout, std::vector;
using namespace smbios;

//
// streaming the GUID to std::cout
// operatoroverloading will take place
//

auto operator<<(
	std::ostream& os, 
	GUID adapter
	) 
	-> std::ostream&
{
	os << std::uppercase;
	os.width(8); 
	
	//
	// first  set of 8 characters in the GUID
	// for example: F54F83C5
	//

	os << std::hex << adapter.Data1 << '-';
	
	os.width(4);

	//
	// second set of 4 characters in the GUID
	// for example: 9724
	//

	os << std::hex << adapter.Data2 << '-';

	os.width(4);

	//
	// third set of 4 characters in the GUID
	// for example: 6A1C
	//

	os << std::hex << adapter.Data3 << '-';
	
	os.width(2);
	os << std::hex
		<< static_cast<short> (adapter.Data4[0]) // fourth set of characters
		<< static_cast<short> (adapter.Data4[1]) //
		<< '-'
		<< static_cast<short> (adapter.Data4[2]) // fifth set of characters
		<< static_cast<short> (adapter.Data4[3]) //
		<< static_cast<short> (adapter.Data4[4])
		<< static_cast<short> (adapter.Data4[5])
		<< static_cast<short> (adapter.Data4[6])
		<< static_cast<short> (adapter.Data4[7]);
	os << std::nouppercase;
	return os;

}

extern "C" {
	IDirect3D9 *Direct3DCreate9(
		UINT SDKVersion
	);
}

auto main()
	-> int
{
	DWORD hdd_serial							 {};
	DWORD flag										 {1};
	DWORD gpu_serial							 {};
	DWORD smbios_data_size				 {};
	BYTE  *b_					             {nullptr};
	dmi_header* header             {nullptr};
	RawSMBIOSData* smbios_data     {nullptr};
  BYTE* smbios_data_buffer; //[0x10000] = { 0 }; //0.065536 megabytes
	smbios_data_buffer = new BYTE[0x10000]; //0.065536 megabytes fails

	// HW_PROFILE_INFO hw_prof_info won't be needed
	
	std::puts("\tGetting HWID\n");

	if (GetVolumeInformationA("C://", NULL, NULL,
		&hdd_serial, NULL, NULL, NULL, NULL) == 0) {
		cout << "Error encounters 'GetVolumeInformation: "
			<< GetLastError() << "\n";
		_getch();
	}

	//
	// SMBIOS (RSMB) firmware tables 
	//

	smbios_data_size = GetSystemFirmwareTable('RSMB', 0, 0, 0);

	if (!smbios_data_size) {
		std::puts("Error: ERROR_OUTOFMEMORY");
		_getch();
		ExitProcess(EXIT_FAILURE);
	}

	if (smbios_data_size == 0) {
		cout << "Error encounters 'GetSystemFirmwareTable': "
			<< GetLastError() << "\n";
		_getch();
		ExitProcess(EXIT_FAILURE);
	}
	int smbios_buffersize = smbios_data_size;

	smbios_data_size = GetSystemFirmwareTable('RSMB', 0, smbios_data_buffer, smbios_buffersize);
	
	if (!smbios_data_size) {
		std::puts("Error: ERROR_OUTOFMEMORY");
		_getch();
		ExitProcess(EXIT_FAILURE);
	}

	cout << "\tget buffer size is: " << smbios_buffersize << "\n";

	smbios_data =
		reinterpret_cast<RawSMBIOSData*> (
			smbios_data_buffer
			);


	if (smbios_data->Length != smbios_buffersize - 8)
	{
		printf("Smbios length error\n");
		_getch();
		ExitProcess(EXIT_FAILURE);
	}
	

	IDirect3D9 *d9object = Direct3DCreate9(D3D_SDK_VERSION);
	unsigned int adaptercount = d9object->GetAdapterCount();
	D3DADAPTER_IDENTIFIER9* adapters = new D3DADAPTER_IDENTIFIER9[sizeof(adaptercount)];

	for (unsigned int i = 0; i < adaptercount; i++) {
		d9object->GetAdapterIdentifier(i, 0, &(adapters[i]));
	}

	cout << "\tGPU desc:   " << adapters->Description << "\n";
	cout << "\tGPU vendor: " << adapters->VendorId << "\n";
	cout << "\tGPU guid:   " << adapters->DeviceIdentifier << "\n";
	cout << "\tHDD hwid:   " << hdd_serial << "\n";
	
	// eax, ebx, ecx, edx
	int cpuid[4] = { 0,0,0,0 };
	__cpuid(cpuid, 0);
	char16_t hold = 0;
	char16_t* pointer = reinterpret_cast<char16_t*> (cpuid);
	for (char32_t i = 0; i < 8; i++) {
		hold += pointer[i];
	}

	cout << "\tCPU   id:   " << std::uppercase << hold << "\n";

	// Go throught BIOS structures
	b_ = smbios_data->SMBIOSTableData;
	for (DWORD index{}; index < smbios_data->Length; index++) {
		
		dmi_header *header =
			reinterpret_cast<dmi_header*> (b_);

		if (header->type == dmi_entry_type::DMI_ENTRY_BIOS && flag) {
			std::printf("\n\tType  %02d - [Bios Device type]\n", header->type);
			cout << "\t\tBIOS Vendor:    " << dmi_string(header, b_[0x4]) << "\n";
			cout << "\t\tBIOS Version:   " << dmi_string(header, b_[0x5]) << "\n";
			cout << "\t\tRelease data:   " << dmi_string(header, b_[0x8]) << "\n";

			flag = 0;
		} 

		else if (header->type == dmi_entry_type::DMI_ENTRY_BASEBOARD) {
			std::printf("\n\tType  %02d - [Baseboard Device type]\n", header->type);
			cout << "\t\tManufacturer:   " << dmi_string(header, b_[0x4]) << "\n";
			cout << "\t\tProduct Number: " << dmi_string(header, b_[0x5]) << "\n";
			cout << "\t\tVersion:        " << dmi_string(header, b_[0x6]) << "\n";
			cout << "\t\tSerial Number:  " << dmi_string(header, b_[0x7]) << "\n";
			cout << "\t\tUUID:           "; 
			
			dmi_system_uuid(b_ + 0x8,
				smbios_data->SMBIOSMajorVersion * 0x100 + smbios_data->SMBIOSMinorVersion);


		} 
		

		else if (header->type == dmi_entry_type::DMI_ENTRY_MEM_DEVICE) {
			std::printf("\n\tType  %02d - [Memory Device type]\n", header->type);
			cout << "\t\tMemory Type:    " << dmi_memory_device_type(b_[0x12]) << "\n";
			cout << "\t\tSize of RAM:    " << dmi_string(header, b_[0xC]) << "\n";
			cout << "\t\tManufacturer:   " << dmi_string(header, b_[0x17]) << "\n";
			cout << "\t\tSerial Number:  " << dmi_string(header, b_[0x18]) << "\n";
		}

		
		b_ += header->length;
		while ((*(WORD*)b_) != 0) { b_++; }
		b_ += 2;
	}

	_getch();
	delete [] smbios_data_buffer;
	return {};
}

```

`hwid_checker/hwid_checker.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{0915FF14-6ACB-41E0-8C32-5252FB32D182}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>hwidchecker</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>hwid-checker-mg</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin_left$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin_left$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin_left$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin_left$(Platform)\$(Configuration)</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="hwid_checker.cpp" />
    <ClCompile Include="includes\smbios.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes\smbios.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`hwid_checker/hwid_checker.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`hwid_checker/includes/smbios.cpp`:

```cpp
#include "smbios.hpp"

using smbios::dmi_memory_device_type;

auto smbios::dmi_system_uuid(
	const BYTE* p, short version
		) -> void
{
	bool only0xff = true;
	bool only0x00 = true;
	int i{};

	//
	// 16 because of the byte uuid
	// this process also makes so that the uuid isn't all
	// 1's and 0's
	//


	for (i = 0; i < 16 && (only0x00 || only0xff); i++) {
		if (p[i] != 0x00) { only0x00 = false; }
		if (p[i] != 0xFF) { only0xff = false; }
	}

	if (only0x00) { std::puts("Not present : 0x00"); return; }
	if (only0xff) { std::puts("Not Settable: 0xff"); return; }

	if (version >= 0x0206) {
		std::printf("%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
			p[3], p[2], p[1], p[0], p[5], p[4], p[7], p[6],
			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
	} else {
			std::printf("-%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
				p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
				p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
	}
}

auto smbios::dmi_string(
	const smbios::dmi_header* dm, BYTE src
		) -> const char*
{
	std::size_t length{};
	std::size_t i{};

	char* bp = (char*)dm;
		//reinterpret_cast<char*> (dm);

	if (src == 0) { return "Not specified"; }
	bp += dm->length;

	while (src > 1 && *bp) {
		bp += std::strlen(bp);
		bp++;
		src--;
	}
	
	if (!*bp) { return "BAD_INDEXING"; }

	
	
	//
	// filtering ASCII
	// removal of junk data
	//

	length = std::strlen(bp);
	for (int i = 0; i < length; i++) {
		if (bp[i] < 32 || bp[i] == 127) { bp[i] = '.'; }
	}
	return bp;

}

auto dmi_memory_device_type(
	BYTE code
		) -> const char*
{
	std::map<int, const char*> memory_device_type;
	/* 7.18.2 */

	memory_device_type[dmi_memory_device_type::DMT_OTHER]				 = "Other"; /* 0x01 */
	memory_device_type[dmi_memory_device_type::DMT_UNKNOWN]			 = "Unknown";
	memory_device_type[dmi_memory_device_type::DMT_DRAM]				 = "DRAM";
	memory_device_type[dmi_memory_device_type::DMT_EDRAM]				 = "EDRAM";
	memory_device_type[dmi_memory_device_type::DMT_VRAM]				 = "VRAM";
	memory_device_type[dmi_memory_device_type::DMT_SRAM]				 = "SRAM";
	memory_device_type[dmi_memory_device_type::DMT_RAM]					 = "RAM";
	memory_device_type[dmi_memory_device_type::DMT_ROM]					 = "ROM";
	memory_device_type[dmi_memory_device_type::DMT_FLASH]				 = "Flash";
	memory_device_type[dmi_memory_device_type::DMT_EEPROM]			 = "EEPROM";
	memory_device_type[dmi_memory_device_type::DMT_FEPROM]			 = "FEPROM";
	memory_device_type[dmi_memory_device_type::DMT_EPROM]				 = "EPROM";
	memory_device_type[dmi_memory_device_type::DMT_CDRAM]				 = "CDRAM";
	memory_device_type[dmi_memory_device_type::DMT_3DRAM]				 = "3DRAM";
	memory_device_type[dmi_memory_device_type::DMT_SDRAM]				 = "SDRAM";
	memory_device_type[dmi_memory_device_type::DMT_SGRAM]			   = "SGRAM";
	memory_device_type[dmi_memory_device_type::DMT_RDRAM]				 = "RDRAM";
	memory_device_type[dmi_memory_device_type::DMT_DDR]					 = "DDR";
	memory_device_type[dmi_memory_device_type::DMT_DDR2]				 = "DDR2";
	memory_device_type[dmi_memory_device_type::DMT_DDR2_FB_DIMM] = "DDR2 FB-DIMM";
	memory_device_type[dmi_memory_device_type::DMT_RESERVED1]		 = "Reserved";
	memory_device_type[dmi_memory_device_type::DMT_RESERVED2]		 = "Reserved";
	memory_device_type[dmi_memory_device_type::DMT_RESERVED3]		 = "Reserved";
	memory_device_type[dmi_memory_device_type::DMT_DDR3]				 = "DDR3";
	memory_device_type[dmi_memory_device_type::DMT_FBD2]				 = "FBD2";
	memory_device_type[dmi_memory_device_type::DMT_DDR4]				 = "DDR4";
	memory_device_type[dmi_memory_device_type::DMT_LPDDR]				 = "LPDDR";
	memory_device_type[dmi_memory_device_type::DMT_LPDDR2]			 = "LPDDR2";
	memory_device_type[dmi_memory_device_type::DMT_LPDDR3]			 = "LPDDR3";
	memory_device_type[dmi_memory_device_type::DMT_LPDDR4]			 = "LPDDR4";
	memory_device_type[dmi_memory_device_type::DMT_LOGICAL_NONVOLATILE_DEVICE] = "Logical non-volatile device";
	memory_device_type[dmi_memory_device_type::DMT_HBM]					 = "HBM";
	memory_device_type[dmi_memory_device_type::DMT_HBM2]				 = "HBM2"; /* 0x21 */


	if (code >= smbios::dmi_memory_device_type::DMT_OTHER
	&& code <= smbios::dmi_memory_device_type::DMT_HBM2) {
		return memory_device_type[code - 0x01];
	}
		
	return out_of_spec;
}
```

`hwid_checker/includes/smbios.hpp`:

```hpp
#pragma once
#include <iostream>
#include <windows.h>
#include <conio.h>
#include <tchar.h>
#include <intrin.h>
#include <d3d9.h>
#include <iomanip>
#include <vector>
#include <map>

#pragma comment(lib, "d3d9.lib")
#pragma warning(disable : 4200)

#define out_of_spec "OUT OF SPEC"



namespace smbios 
{
  enum dmi_entry_type
    : BYTE
  {
    DMI_ENTRY_BIOS = 0,
    DMI_ENTRY_SYSTEM,
    DMI_ENTRY_BASEBOARD,
    DMI_ENTRY_CHASSIS,
    DMI_ENTRY_PROCESSOR,
    DMI_ENTRY_MEM_CONTROLLER,
    DMI_ENTRY_MEM_MODULE,
    DMI_ENTRY_CACHE,
    DMI_ENTRY_PORT_CONNECTOR,
    DMI_ENTRY_SYSTEM_SLOT,
    DMI_ENTRY_ONBOARD_DEVICE,
    DMI_ENTRY_OEMSTRINGS,
    DMI_ENTRY_SYSCONF,
    DMI_ENTRY_BIOS_LANG,
    DMI_ENTRY_GROUP_ASSOC,
    DMI_ENTRY_SYSTEM_EVENT_LOG,
    DMI_ENTRY_PHYS_MEM_ARRAY,
    DMI_ENTRY_MEM_DEVICE,
    DMI_ENTRY_32_MEM_ERROR,
    DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR,
    DMI_ENTRY_MEM_DEV_MAPPED_ADDR,
    DMI_ENTRY_BUILTIN_POINTING_DEV,
    DMI_ENTRY_PORTABLE_BATTERY,
    DMI_ENTRY_SYSTEM_RESET,
    DMI_ENTRY_HW_SECURITY,
    DMI_ENTRY_SYSTEM_POWER_CONTROLS,
    DMI_ENTRY_VOLTAGE_PROBE,
    DMI_ENTRY_COOLING_DEV,
    DMI_ENTRY_TEMP_PROBE,
    DMI_ENTRY_ELECTRICAL_CURRENT_PROBE,
    DMI_ENTRY_OOB_REMOTE_ACCESS,
    DMI_ENTRY_BIS_ENTRY,
    DMI_ENTRY_SYSTEM_BOOT,
    DMI_ENTRY_MGMT_DEV,
    DMI_ENTRY_MGMT_DEV_COMPONENT,
    DMI_ENTRY_MGMT_DEV_THRES,
    DMI_ENTRY_MEM_CHANNEL,
    DMI_ENTRY_IPMI_DEV,
    DMI_ENTRY_SYS_POWER_SUPPLY,
    DMI_ENTRY_ADDITIONAL,
    DMI_ENTRY_ONBOARD_DEV_EXT,
    DMI_ENTRY_MGMT_CONTROLLER_HOST,
    DMI_ENTRY_INACTIVE = 126,
    DMI_ENTRY_END_OF_TABLE = 127,
  };

	enum dmi_memory_device_type // 7.18.2
		: BYTE
	{
		DMT_OTHER = 0x01, /* 0x01 */
		DMT_UNKNOWN,
		DMT_DRAM,
		DMT_EDRAM,
		DMT_VRAM,
		DMT_SRAM,
		DMT_RAM,
		DMT_ROM,
		DMT_FLASH,
		DMT_EEPROM,
		DMT_FEPROM,
		DMT_EPROM,
		DMT_CDRAM,
		DMT_3DRAM,
		DMT_SDRAM,
		DMT_SGRAM,
		DMT_RDRAM,
		DMT_DDR,
		DMT_DDR2,
		DMT_DDR2_FB_DIMM,
		DMT_RESERVED1,
		DMT_RESERVED2,
		DMT_RESERVED3,
		DMT_DDR3,
		DMT_FBD2,
		DMT_DDR4,
		DMT_LPDDR,
		DMT_LPDDR2,
		DMT_LPDDR3,
		DMT_LPDDR4,
		DMT_LOGICAL_NONVOLATILE_DEVICE,
		DMT_HBM,
		DMT_HBM2 /* 0x21 */
	};

	//
	// Data structure the consults the hold of extracted data from the the raw
	// SMBIOS firmware table
	//

	typedef struct RawSMBIOSData
	{
		BYTE    Used20CallingMethod;
		BYTE    SMBIOSMajorVersion;
		BYTE    SMBIOSMinorVersion;
		BYTE    DmiRevision;
		DWORD   Length;
		BYTE    SMBIOSTableData[];
	} RawSMBIOSData;



	// definition:
	// Desktop Management Interface (DMI) generates a standard framework 
	// for managing and tracking components in a desktop, notebook or server 
	// computer, by abstracting these components from the software that manages them.
	//

	typedef struct _dmi_header
	{
		BYTE		type;
		BYTE		length;
		WORD		handle;
	} dmi_header;


	// function protoypes
	void dmi_system_uuid(const BYTE* p, short version);
	const char* dmi_string(const dmi_header* dm, BYTE src);
	const char* dmi_memory_device_type(BYTE code);
};
```