Project Path: arc_gmh5225_regenny_2saa996f

Source Tree:

```txt
arc_gmh5225_regenny_2saa996f
├── ATTRIBUTIONS.md
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake.toml
├── cmkr.cmake
├── examples
│   ├── test.lua
│   ├── test0.cpp
│   ├── test0.genny
│   └── types.genny
├── extras
│   └── dumpmapper
│       ├── main.py
│       └── requirements.txt
├── format.ps1
├── resources
│   ├── bottle.ico
│   ├── bottle.png
│   ├── potion.ico
│   ├── potion.png
│   └── readme_preview.png
├── src
│   ├── AboutUi.cpp
│   ├── AboutUi.hpp
│   ├── Config.cpp
│   ├── Config.hpp
│   ├── Helpers.hpp
│   ├── LoggerUi.cpp
│   ├── LoggerUi.hpp
│   ├── Main.cpp
│   ├── MemoryUi.cpp
│   ├── MemoryUi.hpp
│   ├── Process.cpp
│   ├── Process.hpp
│   ├── Project.cpp
│   ├── Project.hpp
│   ├── ReGenny.cpp
│   ├── ReGenny.hpp
│   ├── Utility.cpp
│   ├── Utility.hpp
│   ├── arch
│   │   ├── Arch.cpp
│   │   ├── Arch.hpp
│   │   ├── Windows.cpp
│   │   ├── Windows.hpp
│   │   └── Windows.rc
│   └── node
│       ├── Array.cpp
│       ├── Array.hpp
│       ├── Base.cpp
│       ├── Base.hpp
│       ├── Bitfield.cpp
│       ├── Bitfield.hpp
│       ├── Pointer.cpp
│       ├── Pointer.hpp
│       ├── Property.hpp
│       ├── Struct.cpp
│       ├── Struct.hpp
│       ├── Undefined.cpp
│       ├── Undefined.hpp
│       ├── UndefinedBitfield.cpp
│       ├── UndefinedBitfield.hpp
│       ├── Variable.cpp
│       └── Variable.hpp
├── thirdparty
│   ├── SDL_Trigger
│   │   ├── sdl_trigger.cpp
│   │   └── sdl_trigger.h
│   └── scope_gaurd
│       └── scope_guard.hpp
└── vcpkg.json

```

`ATTRIBUTIONS.md`:

```md
# Open Source License Attribution

This application uses Open Source components. You can find the source
code of their open source projects along with license information below.
We acknowledge and are grateful to these developers for their contributions
to open source.

### [Dear ImGui](https://github.com/ocornut/imgui)
- Copyright (c) 2014-2021 Omar Cornut
- [MIT License](https://github.com/ocornut/imgui/blob/master/LICENSE.txt)

### [FreeType](https://github.com/freetype/freetype)
-  Copyright 1996-2002, 2006 by David Turner, Robert Wilhelm, and Werner Lemberg
- [The FreeType Project License](https://github.com/freetype/freetype/blob/master/LICENSE.TXT)

### [Simple DirectMedia Layer](https://github.com/libsdl-org/SDL)
- Copyright (C) 1997-2021 Sam Lantinga
- [zlib License](https://github.com/libsdl-org/SDL/blob/main/LICENSE.txt)

### [glad](https://github.com/Dav1dde/glad)
- Copyright (c) 2013-2020 David Herberth
- [MIT License](https://github.com/Dav1dde/glad/blob/master/LICENSE)

### [{fmt}](https://github.com/fmtlib/fmt)
- Copyright (c) 2012 - present, Victor Zverovich
- [MIT License](https://github.com/fmtlib/fmt/blob/master/LICENSE.rst)

### [The Parsing Expression Grammar Template Library (PEGTL)](https://github.com/taocpp/PEGTL)
- Copyright (c) 2007-2021 Dr. Colin Hirsch and Daniel Frey
- [MIT License](https://github.com/taocpp/PEGTL/blob/master/LICENSE)

### [Native File Dialog](https://github.com/mlabbe/nativefiledialog)
- Copyright (c) 2014-2019 Frogtoss Games, Inc.
- [MIT License](https://github.com/mlabbe/nativefiledialog/blob/master/LICENSE)

### [spdlog](https://github.com/gabime/spdlog)
- Copyright (c) 2016 Gabi Melman
- [MIT License](https://github.com/gabime/spdlog/blob/v1.x/LICENSE)

### [UTF8-CPP](https://github.com/nemtrif/utfcpp)
- [Boost Software License 1.0](https://github.com/nemtrif/utfcpp/blob/master/LICENSE)

### [JSON for Modern C++](https://github.com/nlohmann/json)
- Copyright (c) 2013-2021 Niels Lohmann
- [MIT License](https://github.com/nlohmann/json/blob/develop/LICENSE.MIT)

### [Lua 5.4](https://www.lua.org/)
- Copyright (C) 1994-2021 Lua.org, PUC-Rio
- [MIT License](https://www.lua.org/license.html)

### [sol2](https://github.com/ThePhD/sol2)
- Copyright (c) 2013-2022 Rapptz, ThePhD, and contributors
- [MIT License](https://github.com/ThePhD/sol2/blob/develop/LICENSE)

### [bottle.png](https://www.flaticon.com/free-icon/bottle_867876)
- Icon made by [Freepik](https://www.freepik.com) from [www.flaticon.com](https://www.flaticon.com/)

### [potion.png](https://www.flaticon.com/free-icon/potion_1205587)
- Icon made by [Freepik](https://www.freepik.com) from [www.flaticon.com](https://www.flaticon.com/)

```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

# Regenerate CMakeLists.txt automatically in the root project
set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr
	include(cmkr.cmake OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
endif()

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

project(regenny)

if(CMKR_ROOT_PROJECT AND NOT CMKR_DISABLE_VCPKG)
	include(FetchContent)
	message(STATUS "Fetching vcpkg (2022.08.15)...")
	FetchContent_Declare(vcpkg URL "https://github.com/microsoft/vcpkg/archive/refs/tags/2022.08.15.tar.gz")
	FetchContent_GetProperties(vcpkg)
	if(NOT vcpkg_POPULATED)
		FetchContent_Populate(vcpkg)
		include("${vcpkg_SOURCE_DIR}/scripts/buildsystems/vcpkg.cmake")
	endif()
endif()

include(FetchContent)

message(STATUS "Fetching sdkgenny (cbf986af49c45afb2016c96202b66d66fa1cbd8e)...")
FetchContent_Declare(sdkgenny
	GIT_REPOSITORY
		"https://github.com/cursey/sdkgenny.git"
	GIT_TAG
		cbf986af49c45afb2016c96202b66d66fa1cbd8e
)
FetchContent_MakeAvailable(sdkgenny)

message(STATUS "Fetching luagenny (556c914a846ccf3f358b559e99d4610f71d71c29)...")
FetchContent_Declare(luagenny
	GIT_REPOSITORY
		"https://github.com/praydog/luagenny.git"
	GIT_TAG
		556c914a846ccf3f358b559e99d4610f71d71c29
)
FetchContent_MakeAvailable(luagenny)

# Packages
find_package(imgui REQUIRED)

find_package(fmt REQUIRED)

find_package(pegtl REQUIRED)

find_package(unofficial-nativefiledialog REQUIRED)

find_package(spdlog REQUIRED)

find_package(utf8cpp REQUIRED)

find_package(SDL2 REQUIRED)

find_package(nlohmann_json REQUIRED)

find_package(glad REQUIRED)

find_package(sol2 REQUIRED)

find_package(lua REQUIRED)

# Target regenny
set(CMKR_TARGET regenny)
set(regenny_SOURCES "")

list(APPEND regenny_SOURCES
	"src/AboutUi.cpp"
	"src/Config.cpp"
	"src/LoggerUi.cpp"
	"src/Main.cpp"
	"src/MemoryUi.cpp"
	"src/Process.cpp"
	"src/Project.cpp"
	"src/ReGenny.cpp"
	"src/Utility.cpp"
	"src/arch/Arch.cpp"
	"src/arch/Windows.cpp"
	"src/node/Array.cpp"
	"src/node/Base.cpp"
	"src/node/Bitfield.cpp"
	"src/node/Pointer.cpp"
	"src/node/Struct.cpp"
	"src/node/Undefined.cpp"
	"src/node/UndefinedBitfield.cpp"
	"src/node/Variable.cpp"
	"src/AboutUi.hpp"
	"src/Config.hpp"
	"src/Helpers.hpp"
	"src/LoggerUi.hpp"
	"src/MemoryUi.hpp"
	"src/Process.hpp"
	"src/Project.hpp"
	"src/ReGenny.hpp"
	"src/Utility.hpp"
	"src/arch/Arch.hpp"
	"src/arch/Windows.hpp"
	"src/node/Array.hpp"
	"src/node/Base.hpp"
	"src/node/Bitfield.hpp"
	"src/node/Pointer.hpp"
	"src/node/Property.hpp"
	"src/node/Struct.hpp"
	"src/node/Undefined.hpp"
	"src/node/UndefinedBitfield.hpp"
	"src/node/Variable.hpp"
	"thirdparty/SDL_Trigger/sdl_trigger.cpp"
	"thirdparty/scope_gaurd/scope_guard.hpp"
	"thirdparty/SDL_Trigger/sdl_trigger.h"
)

if(WIN32) # windows
	list(APPEND regenny_SOURCES
		"src/arch/Windows.rc"
	)
endif()

list(APPEND regenny_SOURCES
	cmake.toml
)

set(CMKR_SOURCES ${regenny_SOURCES})
add_executable(regenny)

if(regenny_SOURCES)
	target_sources(regenny PRIVATE ${regenny_SOURCES})
endif()

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT regenny)
endif()

source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${regenny_SOURCES})

target_compile_definitions(regenny PRIVATE
	UTF_CPP_CPLUSPLUS=201103L
)

target_compile_features(regenny PRIVATE
	cxx_std_17
)

target_include_directories(regenny PRIVATE
	"src/"
	"thirdparty/scope_gaurd/"
	"thirdparty/SDL_Trigger/"
)

target_link_libraries(regenny PRIVATE
	imgui::imgui
	fmt::fmt
	taocpp::pegtl
	unofficial::nativefiledialog::nfd
	spdlog::spdlog
	utf8cpp
	SDL2::SDL2
	SDL2::SDL2main
	nlohmann_json::nlohmann_json
	glad::glad
	sdkgenny::sdkgenny
	lua
	sol2
	luagenny::luagenny
)

add_custom_command(
    TARGET regenny POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different $<TARGET_FILE:luagenny_shared> $<TARGET_FILE_DIR:regenny>)

unset(CMKR_TARGET)
unset(CMKR_SOURCES)

# Target test0
set(CMKR_TARGET test0)
set(test0_SOURCES "")

list(APPEND test0_SOURCES
	"examples/test0.cpp"
)

list(APPEND test0_SOURCES
	cmake.toml
)

set(CMKR_SOURCES ${test0_SOURCES})
add_executable(test0)

if(test0_SOURCES)
	target_sources(test0 PRIVATE ${test0_SOURCES})
endif()

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT test0)
endif()

source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${test0_SOURCES})

target_compile_features(test0 PRIVATE
	cxx_std_17
)

unset(CMKR_TARGET)
unset(CMKR_SOURCES)


```

`LICENSE`:

```
MIT License

Copyright (c) 2021 cursey

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# ReGenny

[![GitHub Build Action](https://github.com/cursey/regenny/actions/workflows/build.yml/badge.svg)](https://github.com/cursey/regenny/actions/workflows/build.yml) 

[Usage & Scripting Documentation](https://praydog.github.io/regenny-book/)

ReGenny is a reverse engineering tool to interactively reconstruct structures and generate usable C++ header files. Header file generation is done by the sister project [SdkGenny](https://github.com/cursey/sdkgenny). 

![Early build preview](resources/readme_preview.png)

## Status

ReGenny is still early in development but is usable. Things may change unexpectedly. Existing projects may break and need to be updated. Many more features are planned. There will be bugs.

## Download

ReGenny is under active development. Any published builds (or lack thereof) may be out of date. It is advised that if you want to use ReGenny in its current form that you build ReGenny yourself. However, you may be able to grab the latest artifact from GitHub actions [here](https://github.com/cursey/regenny/actions).

## Building

ReGenny uses [CMake](https://cmake.org/) via the help of [cmkr](https://github.com/build-cpp/cmkr).

From the command line:
```
cmake -B build
cmake --build build
```

## Design decisions

* ReGenny uses plaintext project files instead of binary ones (`.genny` and `.json`). Plaintext formats are much better for inclusion in git repositories and makes collaborating with others on ReGenny projects easier since you can diff/merge project files.
* Tree based display (like [ReClass.NET](https://github.com/ReClassNET/ReClass.NET)) but you build the tree using `.genny` files.
* ReGenny uses [SdkGenny](https://github.com/cursey/sdkgenny) for output. One of [SdkGenny](https://github.com/cursey/sdkgenny)'s primary goals is to generate good output and ReGenny reaps all the benefits from that. Instead of a single monolithic header file, ReGenny uses [SdkGenny](https://github.com/cursey/sdkgenny) to generate a proper header file hierarchy for inclusion into your project. If your project is already using [SdkGenny](https://github.com/cursey/sdkgenny) then you don't even need to generate header files since you can just use the `.genny` file directly.
* Since ReGenny uses [SdkGenny](https://github.com/cursey/sdkgenny), it supports everything `.genny` files do:
	* Namespaces
	* Enums
	* Structs
	* Classes
	* Function prototypes
	* Static function prototypes
	* Bitfields
	* Arrays
	* Multi-dimensional arrays
	* Pointers
	* Namespaces can be nested within each other
	* Structs, enums and classes can be nested within other structs/classes
	* Bring your own external types
* The `.genny` format is flexible enough to parse simple C/C++ structures directly with zero (or minimal) modification making importing existing structures into ReGenny easy.

```

`cmake.toml`:

```toml
# Reference: https://build-cpp.github.io/cmkr/cmake-toml
[project]
name = "regenny"

[vcpkg]
version = "2022.08.15"
packages = [
    "imgui[docking-experimental,freetype,sdl2-binding,opengl3-binding]",
    "fmt",
    "pegtl",
    "nativefiledialog",
    "spdlog",
    "utfcpp",
    "nlohmann-json",
    "glad[gl-api-30]",
    "lua",
    "sol2"
]

[fetch-content]
sdkgenny = { git = "https://github.com/cursey/sdkgenny.git", tag = "cbf986af49c45afb2016c96202b66d66fa1cbd8e" }
luagenny = { git = "https://github.com/praydog/luagenny.git", tag = "556c914a846ccf3f358b559e99d4610f71d71c29" }

[find-package]
imgui = {}
fmt = {}
pegtl = {}
unofficial-nativefiledialog = {}
spdlog = {}
utf8cpp = {}
SDL2 = {}
nlohmann_json = {}
glad = {}
sol2 = {}
lua = {}

[target.regenny]
type = "executable"
sources = [
    "src/**.cpp",
    "src/**.hpp",
    "thirdparty/**.cpp",
    "thirdparty/**.hpp",
    "thirdparty/**.h",
]
windows.sources = ["src/**.rc"]
include-directories = [
    "src/",
    "thirdparty/scope_gaurd/",
    "thirdparty/SDL_Trigger/",
]
link-libraries = [
    "imgui::imgui",
    "fmt::fmt",
    "taocpp::pegtl",
    "unofficial::nativefiledialog::nfd",
    "spdlog::spdlog",
    "utf8cpp",
    "SDL2::SDL2",
    "SDL2::SDL2main",
    "nlohmann_json::nlohmann_json",
    "glad::glad",
    "sdkgenny::sdkgenny",
    "lua",
    "sol2",
    "luagenny::luagenny",
]
compile-definitions = ["UTF_CPP_CPLUSPLUS=201103L"]
compile-features = ["cxx_std_17"]
cmake-after="""
add_custom_command(
    TARGET regenny POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different $<TARGET_FILE:luagenny_shared> $<TARGET_FILE_DIR:regenny>)
"""

[target.test0]
type = "executable"
sources = ["examples/test0.cpp"]
compile-features = ["cxx_std_17"]

```

`cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.13" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE} AND EXISTS "$ENV{CMKR_CACHE}")
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    if(CMKR_EXECUTABLE MATCHES "^${CMAKE_CURRENT_BINARY_DIR}/_cmkr")
        if(DEFINED ENV{CMKR_CACHE} AND EXISTS "$ENV{CMKR_CACHE}")
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND EXISTS "$ENV{CMKR_CACHE}" AND CMKR_EXECUTABLE MATCHES "^${CMKR_DIRECTORY_PREFIX}")
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`examples/test.lua`:

```lua
local test_start = os.clock()

local baz = regenny:overlay()
if baz == nil then
    print("Cannot continue test, overlay does not exist.")
    return false
end

if baz:type():name() ~= "Baz" then
    print("Cannot continue test, selected type is not Baz")
    return false
end

print(baz)
print(baz:type())
print(string.format("%x", baz:address()))

local bazstruct = baz:type()
print(bazstruct:name())

local function testcompare(x, name)
    for k, v in pairs(
    {
        "typename",
        "type",
        "generic_type",
        "struct",
        "class",
        "enum",
        "enum_class",
        "namespace",
        "reference",
        "pointer",
        "variable",
        "function",
        "virtual_function",
        "static_function",
        "array",
        "parameter",
        "constant"
    }
    ) do
        print(tostring(name or x) .. " == " .. tostring(v) .. ": " .. tostring(x["is_"..v](x)))
        --print(tostring(name or x) .. " == " .. tostring(v) .. ": " .. tostring(x:is_a(v)))
    end
end

testcompare(bazstruct, "bazstruct")

local test_count = 0

local function value_expect(x, expected, metadata)
    test_count = test_count + 1

    if not metadata then
        metadata = "test " .. tostring(test_count)
    end

    if x ~= expected then
        print("test " .. tostring(test_count) .. " failed " .. "[ " .. metadata .. " ]" .. ", got " .. tostring(x) .. ", expected " .. tostring(expected))
        return false
    end

    print("test " .. tostring(test_count) .. " passed " .. "[ " .. metadata .. " ] == " .. tostring(expected))
    return true
end

function do_tests()
    print("testing...")

    local round = function(val, dec)
        dec = dec or 1
        return math.floor(val * 10 ^ dec + 0.5) / 10 ^ dec
    end

    local results = {
        value_expect(bazstruct:name(), "Baz", "bazstruct:name()"),
        value_expect(bazstruct:is_a("struct"), true, "bazstruct:is_a(\"struct\")"),
        value_expect(bazstruct:is_a("type"), true, "bazstruct:is_a(\"type\")"),
        value_expect(bazstruct:is_struct(), true, "bazstruct:is_struct()"),
        value_expect(bazstruct:is_type(), true, "bazstruct:is_type()"),
        value_expect(baz.d, 123, "baz.d"),
        value_expect(baz.foo.a, 42, "baz.foo.a"),
        value_expect(baz.foo.b, 1337, "baz.foo.b"),
        value_expect(round(baz.foo.c, 1), 77.7, "round(baz.foo.c)"),
        value_expect(baz.g.a, 43, "baz.g.a"),
        value_expect(baz.g.b, 1338, "baz.g.b"),
        value_expect(round(baz.g.c, 1), 78.7, "round(baz.g.c)"),
        value_expect(baz.hello, "Hello, world!", "baz.hello"),
        value_expect(baz.e, 666, "baz.e"),
        value_expect(baz.ta.age, 20, "baz.ta.age"),
        value_expect(round(baz.ta.gpa, 1), 3.9, "baz.ta.gpa"),
        value_expect(baz.ta.wage, 30000, "baz.ta.wage"),
        value_expect(baz.ta.hours, 40, "baz.ta.hours"),
        value_expect(bazstruct:find_variable_in_parents("foo") ~= nil, true, "bazstruct:find_variable(\"foo\") ~= nil"),
        value_expect(bazstruct:find_variable_in_parents("foo"):name(), "foo", "bazstruct:find_variable(\"foo\"):name()"),
        value_expect(bazstruct:find_variable_in_parents("foo"):type():is_pointer(), true, "bazstruct:find_variable(\"foo\"):type():is_pointer()"),
        value_expect(bazstruct:find("variable", "e") ~= nil, true, "bazstruct:find(\"variable\", \"e\") ~= nil"),
        value_expect(bazstruct:find_variable("e") == bazstruct:find("variable", "e"), true, "bazstruct:find_variable(\"e\") == bazstruct:find(\"variable\", \"e\")"),
        value_expect(bazstruct:find_variable("e"):is_a("variable"), true, "bazstruct:find(\"variable\", \"e\"):is_a(\"variable\")"),
        value_expect(bazstruct:find_variable("e"):is_variable(), true, "bazstruct:find(\"variable\", \"e\"):is_variable()"),
        value_expect(bazstruct:find_variable("e"):as("variable") ~= nil, true, "bazstruct:find(\"variable\", \"e\"):as(\"variable\") ~= nil"),
        value_expect(bazstruct:find_variable("e"):as_variable() ~= nil, true, "bazstruct:find(\"variable\", \"e\"):as_variable() ~= nil"),
        value_expect(bazstruct:find_variable("e"):is_a("class"), false, "bazstruct:find(\"variable\", \"e\"):is_a(\"class\")"),
        value_expect(bazstruct:find_variable("e"):is_class(), false, "bazstruct:find(\"variable\", \"e\"):is_class()"),
        value_expect(bazstruct:find_variable("e"):as("class") == nil, true, "bazstruct:find(\"variable\", \"e\"):as(\"class\") == nil"),
        value_expect(bazstruct:find_variable("e"):as_class() == nil, true, "bazstruct:find(\"variable\", \"e\"):as_class() == nil"),
        value_expect(bazstruct:find_variable("e"):is_a("struct"), false, "bazstruct:find(\"variable\", \"e\"):is_a(\"struct\")"),
        value_expect(bazstruct:find_variable("e"):is_struct(), false, "bazstruct:find(\"variable\", \"e\"):is_struct()"),
        value_expect(bazstruct:find_variable("e"):as("struct") == nil, true, "bazstruct:find(\"variable\", \"e\"):as(\"struct\") == nil"),
        value_expect(bazstruct:find_variable("e"):as_struct() == nil, true, "bazstruct:find(\"variable\", \"e\"):as_struct() == nil"),
        value_expect(bazstruct:find_variable("e"):is_a("type"), false, "bazstruct:find(\"variable\", \"e\"):is_a(\"type\")"),
        value_expect(bazstruct:find_variable("e"):is_type(), false, "bazstruct:find(\"variable\", \"e\"):is_type()"),
        value_expect(bazstruct:find_variable("e"):as("type") == nil, true, "bazstruct:find(\"variable\", \"e\"):as(\"type\") == nil"),
        value_expect(bazstruct:find_variable("e"):as_type() == nil, true, "bazstruct:find(\"variable\", \"e\"):as_type() == nil"),
        value_expect(bazstruct:find_variable("e"):type() ~= nil, true, "bazstruct:find(\"variable\", \"e\"):type() ~= nil"),
        value_expect(bazstruct:find_variable("e"):type():is_a("type"), true, "bazstruct:find(\"variable\", \"e\"):type():is_a(\"type\")"),
        value_expect(bazstruct:find_variable("e"):type():is_type(), true, "bazstruct:find(\"variable\", \"e\"):type():is_type()"),
        value_expect(bazstruct:find_variable("e"):type():name() == "int", true, "bazstruct:find(\"variable\", \"e\"):type():name() == \"int\""),
        value_expect(bazstruct:find_variable("e"):type():metadata()[1] == "i32", true, "bazstruct:find(\"variable\", \"e\"):type():metadata()[0] == \"i32\""),
        value_expect(bazstruct:find_variable("not_real_var") == nil, true, "bazstruct:find(\"variable\", \"not_real_var\") == nil"),

        value_expect(bazstruct:find_variable("ta"):type():name() == "TA", true, "bazstruct:find(\"variable\", \"ta\"):type():name() == \"TA\""),
        value_expect(bazstruct:find_variable("ta"):type():as_struct() ~= nil, true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct() ~= nil"),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[1]:name() == "Student", true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:name() == \"Student\""),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[2]:name() == "Faculty", true, "bazstruct:find(\"variable\", \"ta\"):type():parents()[2]:name() == \"Faculty\""),
        value_expect(#bazstruct:find_variable("ta"):type():as_struct():parents()[1]:parents() == 1, true, "#bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:parents() == 1"),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[1]:parents()[1]:name() == "Person", true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:parents()[1]:name() == \"Person\""),
        value_expect(#bazstruct:find_variable("ta"):type():as_struct():parents()[1]:parents()[1]:parents(), 0, "#bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:parents()[1]:parents() == 0"),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[1]:find_variable_in_parents("age") ~= nil, true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:find_variable_in_parents(\"age\") ~= nil"),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[1]:find_variable_in_parents("age"):name() == "age", true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:find_variable_in_parents(\"age\"):name() == \"age\""),
        
        value_expect(baz.things:type():is_a("pointer"), true, "baz.things:type():is_a(\"pointer\")"),
        value_expect(baz.things:type():to():is_a("struct"), true, "baz.things:type():to():is_a(\"struct\")"),
        value_expect(baz.things:type():to():is_struct(), true, "baz.things:type():to():is_struct()"),
        value_expect(baz.things:type():name(), "Thing*", "baz.things:type():name()"),
    }

    --[[for i=0, 10000 do
        bazstruct:find_variable("e"):type():is_type()
    end]]

    for i=0, 10-1 do
        table.insert(results, value_expect(baz.things[i].abc, i * 2, "baz.things[" .. tostring(i) .. "].abc"))
    end

    table.insert(results, value_expect(baz.f:type():name(), "int*", "baz.f:type():name()"))
    table.insert(results, value_expect(baz.f:type():to():name(), "int", "baz.f:type():to():name()"))

    for i=0, 10-1 do
        table.insert(results, value_expect(baz.f[i], i, "baz.f[" .. tostring(i) .. "]"))
    end

    table.insert(results, value_expect(baz.f:deref() == baz.f[0], true, "baz.f:deref() == baz.f[0]"))

    local known_variables = bazstruct:get_all("variable")
    local known_variables2 = bazstruct:get_all_variable()

    table.insert(results, value_expect(#known_variables == #known_variables2, true, "#known_variables == #known_variables2"))

    table.insert(results, value_expect(known_variables ~= nil, true, "known_variables ~= nil"))
    table.insert(results, value_expect(#known_variables, 10, "#known_variables"))

    for k, v in pairs(known_variables) do
        table.insert(results, value_expect(known_variables[k] == known_variables2[k], true, "known_variables[" .. tostring(k) .. "] == known_variables2[" .. tostring(k) .. "]"))

        local mt = getmetatable(baz)
        local ok, val = pcall(mt.__index, baz, v:name())
        table.insert(results, value_expect(ok, true, "pcall baz." .. v:name()))
    end


    ----------------------------
    ------- write tests --------
    ----------------------------
    -- baz.g.a modification
    local old_baz_g_a = baz.g.a
    baz.g.a = baz.g.a + 1

    table.insert(results, value_expect(baz.g.a, old_baz_g_a + 1, "baz.g.a = baz.g.a + 1"))

    baz.g.a = old_baz_g_a

    table.insert(results, value_expect(baz.g.a, old_baz_g_a, "baz.g.a = old_baz_g_a"))

    -- baz.g.c modification (float/number)
    local old_baz_g_c = baz.g.c

    baz.g.c = baz.g.c + 13.337

    table.insert(results, value_expect(round(baz.g.c, 3), round(old_baz_g_c + 13.337, 3), "baz.g.c = baz.g.c + 13.337"))

    baz.g.c = old_baz_g_c

    table.insert(results, value_expect(round(baz.g.c, 3), round(old_baz_g_c, 3), "baz.g.c = old_baz_g_c"))

    -- TA age modification
    local old_ta_age = baz.ta.age
    baz.ta.age = baz.ta.age + 1

    table.insert(results, value_expect(baz.ta.age, old_ta_age + 1, "baz.ta.age = baz.ta.age + 1"))

    baz.ta.age = old_ta_age

    table.insert(results, value_expect(baz.ta.age, old_ta_age, "baz.ta.age = old_ta_age"))

    -- Testing writing to baz.f[i] (pointer to int array)
    for i=0, 10-1 do
        local old_baz_f_i = baz.f[i]
        baz.f[i] = baz.f[i] * 1337

        table.insert(results, value_expect(baz.f[i], old_baz_f_i * 1337, "baz.f[" .. tostring(i) .. "] = baz.f[" .. tostring(i) .. "] * 1337"))

        baz.f[i] = old_baz_f_i

        table.insert(results, value_expect(baz.f[i], old_baz_f_i, "baz.f[" .. tostring(i) .. "] = old_baz_f_i"))
    end

    -- Testing writing to baz.foo (pointer to structure)
    local old_foo_addr = baz.foo:ptr()
    baz.foo = 123456789

    table.insert(results, value_expect(baz.foo:ptr(), 123456789, "baz.foo = 123456789"))

    baz.foo = nil

    table.insert(results, value_expect(baz.foo:ptr(), 0, "baz.foo = nil (0)"))

    baz.foo = old_foo_addr

    table.insert(results, value_expect(baz.foo:ptr(), old_foo_addr, "baz.foo = old_foo_addr"))

    local total_passed = 0

    for k, v in pairs(results) do
        if v == false then
            print("Detected failure at test " .. tostring(k))
        else
            total_passed = total_passed + 1
        end
    end

    print(tostring(total_passed) .. " / " .. tostring(#results) .. " tests passed")

    return #results == total_passed
end

local retval = do_tests()

local time_elapsed = os.clock() - test_start

print("Tests took " .. tostring(time_elapsed) .. " seconds (" .. tostring(time_elapsed * 1000) .. "ms)")

local gen_start = os.clock()

return retval
```

`examples/test0.cpp`:

```cpp
#include <iostream>
#include <iomanip>

#pragma pack(push,1)
enum Place { EARTH = 1, MOON = 2, MARS = 3 };

enum Color : uint8_t { RED = 1, GREEN = 2, BLUE = 3 };

struct Date {
    unsigned short nWeekDay : 3;
    unsigned short nMonthDay : 6;
    unsigned short nMonth : 5;
    unsigned short nYear : 8;
};

struct Foo {
    int a{};
    int b{};
    float c{};
    Place p{};
    int bf1 : 4;
    Place bf2 : 2;
    int rest : 26;
    Place places[3]{EARTH, MOON, MARS};
    Color colors[3]{RED, GREEN, BLUE};
};

struct Bar {
    int d{};
    Foo* foo{};
    int m[4][3];
    union {
        Date date;
        unsigned int date_int{};
    };
};

struct Thing {
    int abc{};
};

struct RTTITest {
    virtual ~RTTITest(){};
};

struct A {
    virtual ~A() {}
};

struct B : A {
    virtual ~B() {}
};

struct C : B {
    virtual ~C() {}
};

struct D {
    virtual ~D() {}
};

struct E : C, D {
    virtual ~E() {}
};

struct Person {
    int age{20};
};

struct Student : Person {
    float gpa{3.9};
};

struct Faculty : Person {
    int wage{30000};
};

struct TA : Student, Faculty {
    int hours{40};
};

struct Baz : Bar {
    TA ta{};
    int e{};
    int thing{};
    int* f{};
    Foo g{};
    Thing* things{};
    char* hello{};
    wchar_t* wide_hello{};
    char intrusive_hello[32]{"hello, intrusive world!"};
    bool im_true{true};
    bool im_false{false};
    char im_also_true{7};
    __declspec(align(sizeof(void*))) RTTITest* rtti{};
    E* e_ptr{};
};
#pragma pack(pop)

int main(int argc, char* argv[]) {
    auto foo = new Foo{};
    foo->a = 42;
    foo->b = 1337;
    foo->c = 77.7f;
    foo->p = Place::MARS;
    foo->bf1 = Place::MOON;
    foo->bf2 = Place::MARS;
    foo->rest = 12345678;

    auto baz = new Baz{};
    baz->d = 123;
    baz->foo = foo;
    for (auto i = 0; i < 4; ++i) {
        for (auto j = 0; j < 3; ++j) {
            baz->m[i][j] = i + j;
        }
    }
    baz->date.nWeekDay = 1;
    baz->date.nMonthDay = 2;
    baz->date.nMonth = 3;
    baz->date.nYear = 4;
    baz->e = 666;
    baz->f = new int[10];
    for (auto i = 0; i < 10; ++i) {
        baz->f[i] = i;
    }
    baz->g = *foo;
    ++baz->g.a;
    ++baz->g.b;
    ++baz->g.c;
    baz->g.p = Place::MOON;
    baz->things = new Thing[10];
    for (auto i = 0; i < 10; ++i) {
        baz->things[i].abc = i * 2;
    }
    baz->hello = (char*)"Hello, world!";
    baz->wide_hello = (wchar_t*)L"Hello, wide world!";

    auto rtti = new RTTITest{};
    baz->rtti = rtti;
    baz->e_ptr = new E{};

    std::cout << "0x" << std::hex << (uintptr_t)baz << std::endl;
    std::cout << "Press ENTER to exit.";
    std::cin.get();
    return 0;
}
```

`examples/test0.genny`:

```genny
import "types.genny"

struct RTTITest{}

enum Place {
    EARTH = 1,
    MOON = 2,
    MARS = 3,
}

enum Color : byte {
	RED = 1,
	GREEN = 2,
	BLUE = 3
}

struct Date {
    ushort nWeekDay : 3
    ushort nMonthDay : 6
    ushort nMonth : 5
    ushort nYear : 8
}

struct Foo {
    int a
    int b
    float c
    Place p
    Place bf1 : 4
    Place bf2 : 2
    Place places[3]
	Color colors[3]
	//Color red
	//Color blue
}

struct Bar {
    int d
    Foo* foo
    int[4][3] m
    Date date
}

struct Thing {
    int abc
}

struct Person {
    int age
}

struct Student : Person {
    float gpa
}

struct Faculty : Person {
    int wage
}

struct TA : Student, Faculty {
    int hours
}

struct Baz : Bar 0x100 {
	TA ta
    int e
    int thing
    int* f
    Foo g
    Thing* things
    char* hello [[utf8*]]
    //wchar_t* wide_hello [[utf16*]]
    //char[32] intrusive_hello [[utf8*]]
    bool im_true +40
    bool im_false
    bool im_also_true
	//RTTITest* test + 5
}

struct RTTITest 0x100 {
	uintptr_t** vtable
}


```

`examples/types.genny`:

```genny
// Basic types we use throughout the test proj.
type int 4 [[i32]]
type float 4 [[f32]]
type ushort 2 [[u16]]
type str 8 [[utf8*]]
type wstr 8 [[utf16*]]
type bool 1 [[bool]]
type uintptr_t 8 [[u64]]
type char 1
type wchar_t 2
type byte 1 [[u8]]

```

`extras/dumpmapper/main.py`:

```py
# Overview: This script will take
# Input: A dumped executable file
# and will manually map the file into memory using the PE sections
# so we can view it with runtime analysis tools

import pefile
import os
import fire
import ctypes

VirtualAlloc = ctypes.windll.kernel32.VirtualAlloc
VirtualAlloc.restype = ctypes.c_uint64
VirtualAlloc.argtypes = [
    ctypes.c_uint64, ctypes.c_uint64, ctypes.wintypes.DWORD, ctypes.wintypes.DWORD
]

VirtualAllocEx = ctypes.windll.kernel32.VirtualAllocEx
VirtualAllocEx.restype = ctypes.c_uint64
VirtualAllocEx.argtypes = [
    ctypes.wintypes.HANDLE,
    ctypes.c_uint64, ctypes.c_uint64, ctypes.wintypes.DWORD, ctypes.wintypes.DWORD
]

OpenProcess = ctypes.windll.kernel32.OpenProcess
OpenProcess.restype = ctypes.wintypes.HANDLE
OpenProcess.argtypes = [ctypes.wintypes.DWORD, ctypes.wintypes.BOOL, ctypes.c_int]

WriteProcessMemory = ctypes.windll.kernel32.WriteProcessMemory
WriteProcessMemory.restype = ctypes.wintypes.BOOL
WriteProcessMemory.argtypes = [
    ctypes.wintypes.HANDLE, ctypes.c_uint64, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64)
]

PROCESS_ALL_ACCESS = 0x101ffb

MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
MEM_COMMIT_RESERVE = MEM_COMMIT | MEM_RESERVE

PAGE_READWRITE = 0x04
PAGE_READWRITE_EXECUTE = 0x40
PAGE_READ_EXECUTE = 0x20

def main(input=None, pid=None):
    # Check if the file exists
    if input is None or not os.path.isfile(input):
        print("[-] File does not exist")
        return

    has_process = False

    if pid is not None:
        process = OpenProcess(PROCESS_ALL_ACCESS, False, int(pid))

        if process is None or process == 0 or process == -1:
            print("[-] Failed to open process")
            return
        else:
            print("[+] Opened process " + str(pid) + " with handle " + str(hex(process)))
            has_process = True


    print("[+] Parsing file")

    # Parse the file
    pe = pefile.PE(input)

    # Check if the file is a PE file
    if not pe.is_exe() and not pe.is_dll():
        print("[-] File is not a PE file")
        return

    # Check if the file is a 64 bit file
    if pe.OPTIONAL_HEADER.Magic != 0x20b:
        print("[-] File is not a 64 bit file, not supported. Magic: " + str(hex(pe.OPTIONAL_HEADER.Magic)))
        return

    print(pe.NT_HEADERS)
    print(pe.OPTIONAL_HEADER)
    print(pe.FILE_HEADER)

    imagebase = pe.OPTIONAL_HEADER.ImageBase

    total_virtual_size = pe.OPTIONAL_HEADER.SizeOfHeaders

    for section  in pe.sections:
        total_virtual_size += section.Misc_VirtualSize

    print("[+] Total virtual size: " + str(hex(total_virtual_size)))

    # Align the virtual size to the section alignment in pe.OPTIONAL_HEADER.SectionAlignment
    alignment = pe.OPTIONAL_HEADER.SectionAlignment
    total_virtual_size = (total_virtual_size + alignment - 1) & ~(alignment - 1)

    print("[+] Aligned virtual size: " + str(hex(total_virtual_size)))

    if (total_virtual_size < pe.OPTIONAL_HEADER.SizeOfImage):
        total_virtual_size = pe.OPTIONAL_HEADER.SizeOfImage
        print("[+] Fixed total virtual size to: " + str(hex(total_virtual_size)))

    if not has_process:
        addr = VirtualAlloc(imagebase, total_virtual_size, MEM_COMMIT_RESERVE, PAGE_READWRITE_EXECUTE)
    else:
        addr = VirtualAllocEx(process, imagebase, total_virtual_size, MEM_COMMIT_RESERVE, PAGE_READWRITE_EXECUTE)

    if addr == 0:
        print("[-] Failed to allocate memory for " + input)
        return

    print("[+] Allocated memory at: " + str(hex(addr)))

    # Write the headers to the start of the allocated space
    # TODO

    # Get the sections, and write them to memory
    for section in pe.sections:
        print("[+] Writing section: " + section.Name.decode("utf-8"))
        print("[+]  Section virtual address: " + str(hex(section.VirtualAddress)))
        print("[+]  Section virtual size: " + str(hex(section.Misc_VirtualSize)))
        print("[+]  Section raw size: " + str(hex(section.SizeOfRawData)))
        print("[+]  Buffer address: " + str(hex(addr + section.VirtualAddress)))

        size = section.SizeOfRawData

        # if the size is 0, then we continue
        # because it's uninitialized data
        if size == 0:
            continue

        section_data = pe.get_data(section.VirtualAddress, size)

        # Copy the section data into buf (aka the allocated space)
        print("[+]  Writing section " + section.Name.decode("utf-8") + " to: " + str(hex(addr + section.VirtualAddress)) + " to " + str(hex(addr + section.VirtualAddress + size)))

        if not has_process:
            ctypes.memmove(addr + section.VirtualAddress, section_data, size)
        else:
            written = ctypes.c_uint64(0)
            WriteProcessMemory(process, addr + section.VirtualAddress, section_data, size, ctypes.byref(written))


    print("[+] Memory is allocated at " + str(hex(addr)))
    os.system("pause")


if __name__ == '__main__':
    fire.Fire(main)
```

`extras/dumpmapper/requirements.txt`:

```txt
fire
pefile
```

`format.ps1`:

```ps1
Get-ChildItem -Path .\src -Include *.hpp, *.cpp -Recurse | 
ForEach-Object {
    Write-Output $_.FullName
    &clang-format -i -style=file $_.FullName
}

```

`src/AboutUi.cpp`:

```cpp
#include <imgui.h>

#include "AboutUi.hpp"

void about_ui() {
    ImGui::TextUnformatted(R"(Open Source License Attribution

This application uses Open Source components. You can find the source
code of their open source projects along with license information below.
We acknowledge and are grateful to these developers for their contributions
to open source.


)"
                           R"(### Dear ImGui

The MIT License (MIT)

Copyright (c) 2014-2021 Omar Cornut

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


)"
                           R"(### FreeType

                    The FreeType Project LICENSE
                    ----------------------------

                            2006-Jan-27

                    Copyright 1996-2002, 2006 by
          David Turner, Robert Wilhelm, and Werner Lemberg



Introduction
============

  The FreeType  Project is distributed in  several archive packages;
  some of them may contain, in addition to the FreeType font engine,
  various tools and  contributions which rely on, or  relate to, the
  FreeType Project.

  This  license applies  to all  files found  in such  packages, and
  which do not  fall under their own explicit  license.  The license
  affects  thus  the  FreeType   font  engine,  the  test  programs,
  documentation and makefiles, at the very least.

  This  license   was  inspired  by  the  BSD,   Artistic,  and  IJG
  (Independent JPEG  Group) licenses, which  all encourage inclusion
  and  use of  free  software in  commercial  and freeware  products
  alike.  As a consequence, its main points are that:

    o We don't promise that this software works. However, we will be
      interested in any kind of bug reports. (`as is' distribution)

    o You can  use this software for whatever you  want, in parts or
      full form, without having to pay us. (`royalty-free' usage)

    o You may not pretend that  you wrote this software.  If you use
      it, or  only parts of it,  in a program,  you must acknowledge
      somewhere  in  your  documentation  that  you  have  used  the
      FreeType code. (`credits')

  We  specifically  permit  and  encourage  the  inclusion  of  this
  software, with  or without modifications,  in commercial products.
  We  disclaim  all warranties  covering  The  FreeType Project  and
  assume no liability related to The FreeType Project.


  Finally,  many  people  asked  us  for  a  preferred  form  for  a
  credit/disclaimer to use in compliance with this license.  We thus
  encourage you to use the following text:

   """
    Portions of this software are copyright © <year> The FreeType
    Project (www.freetype.org).  All rights reserved.
   """

  Please replace <year> with the value from the FreeType version you
  actually use.


Legal Terms
===========

0. Definitions
--------------

  Throughout this license,  the terms `package', `FreeType Project',
  and  `FreeType  archive' refer  to  the  set  of files  originally
  distributed  by the  authors  (David Turner,  Robert Wilhelm,  and
  Werner Lemberg) as the `FreeType Project', be they named as alpha,
  beta or final release.

  `You' refers to  the licensee, or person using  the project, where
  `using' is a generic term including compiling the project's source
  code as  well as linking it  to form a  `program' or `executable'.
  This  program is  referred to  as  `a program  using the  FreeType
  engine'.

  This  license applies  to all  files distributed  in  the original
  FreeType  Project,   including  all  source   code,  binaries  and
  documentation,  unless  otherwise  stated   in  the  file  in  its
  original, unmodified form as  distributed in the original archive.
  If you are  unsure whether or not a particular  file is covered by
  this license, you must contact us to verify this.

  The FreeType  Project is copyright (C) 1996-2000  by David Turner,
  Robert Wilhelm, and Werner Lemberg.  All rights reserved except as
  specified below.

1. No Warranty
--------------

  THE FREETYPE PROJECT  IS PROVIDED `AS IS' WITHOUT  WARRANTY OF ANY
  KIND, EITHER  EXPRESS OR IMPLIED,  INCLUDING, BUT NOT  LIMITED TO,
  WARRANTIES  OF  MERCHANTABILITY   AND  FITNESS  FOR  A  PARTICULAR
  PURPOSE.  IN NO EVENT WILL ANY OF THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE  FOR ANY DAMAGES CAUSED  BY THE USE OR  THE INABILITY TO
  USE, OF THE FREETYPE PROJECT.

2. Redistribution
-----------------

  This  license  grants  a  worldwide, royalty-free,  perpetual  and
  irrevocable right  and license to use,  execute, perform, compile,
  display,  copy,   create  derivative  works   of,  distribute  and
  sublicense the  FreeType Project (in  both source and  object code
  forms)  and  derivative works  thereof  for  any  purpose; and  to
  authorize others  to exercise  some or all  of the  rights granted
  herein, subject to the following conditions:

    o Redistribution of  source code  must retain this  license file
      (`FTL.TXT') unaltered; any  additions, deletions or changes to
      the original  files must be clearly  indicated in accompanying
      documentation.   The  copyright   notices  of  the  unaltered,
      original  files must  be  preserved in  all  copies of  source
      files.

    o Redistribution in binary form must provide a  disclaimer  that
      states  that  the software is based in part of the work of the
      FreeType Team,  in  the  distribution  documentation.  We also
      encourage you to put an URL to the FreeType web page  in  your
      documentation, though this isn't mandatory.

  These conditions  apply to any  software derived from or  based on
  the FreeType Project,  not just the unmodified files.   If you use
  our work, you  must acknowledge us.  However, no  fee need be paid
  to us.

3. Advertising
--------------

  Neither the  FreeType authors and  contributors nor you  shall use
  the name of the  other for commercial, advertising, or promotional
  purposes without specific prior written permission.

  We suggest,  but do not require, that  you use one or  more of the
  following phrases to refer  to this software in your documentation
  or advertising  materials: `FreeType Project',  `FreeType Engine',
  `FreeType library', or `FreeType Distribution'.

  As  you have  not signed  this license,  you are  not  required to
  accept  it.   However,  as  the FreeType  Project  is  copyrighted
  material, only  this license, or  another one contracted  with the
  authors, grants you  the right to use, distribute,  and modify it.
  Therefore,  by  using,  distributing,  or modifying  the  FreeType
  Project, you indicate that you understand and accept all the terms
  of this license.

4. Contacts
-----------

  There are two mailing lists related to FreeType:

    o freetype@nongnu.org

      Discusses general use and applications of FreeType, as well as
      future and  wanted additions to the  library and distribution.
      If  you are looking  for support,  start in  this list  if you
      haven't found anything to help you in the documentation.

    o freetype-devel@nongnu.org

      Discusses bugs,  as well  as engine internals,  design issues,
      specific licenses, porting, etc.

  Our home page can be found at

    https://www.freetype.org


)"
                           R"(### Simple DirectMedia Layer

Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
  
This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:
  
1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.


)"
                           R"(### glad

The MIT License (MIT)

Copyright (c) 2013-2020 David Herberth

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


)"
                           R"(### {fmt}

Copyright (c) 2012 - present, Victor Zverovich

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


)"
                           R"(### The Parsing Expression Grammar Template LIbrary (PEGTL)

The MIT License (MIT)

Copyright (c) 2007-2021 Dr. Colin Hirsch and Daniel Frey

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


)"
                           R"(### Native File Dialog

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.


)"
                           R"(### spdlog

The MIT License (MIT)

Copyright (c) 2016 Gabi Melman.                                       

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


)"
                           R"(### UTF8 - CPP

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


)"
                           R"(### JSON for Modern C++

MIT License 

Copyright (c) 2013-2021 Niels Lohmann

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


)"
                           R"(### Lua

Copyright © 1994-2021 Lua.org, PUC-Rio.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


)"
                           R"(### sol2

The MIT License (MIT)

Copyright (c) 2013-2022 Rapptz, ThePhD, and contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


)"
                           R"(### bottle.png/potion.png (app icon)

Icon made by Freepik from www.flaticon.com
)");
}

```

`src/AboutUi.hpp`:

```hpp
#pragma once

void about_ui();

```

`src/Config.cpp`:

```cpp
#include "Config.hpp"

void to_json(nlohmann::json& j, const Config& c) {
    j["font"]["file"] = c.font_file;
    j["font"]["size"] = c.font_size;
    j["file"]["history"] = c.file_history;
    j["display"]["address"] = c.display_address;
    j["display"]["offset"] = c.display_offset;
    j["display"]["bytes"] = c.display_bytes;
    j["display"]["print"] = c.display_print;
    j["refresh_rate"] = c.refresh_rate;
    j["always_on_top"] = c.always_on_top;
}

void from_json(const nlohmann::json& j, Config& c) {
    if (j.find("font") != j.end()) {
        c.font_file = j.at("font").value("file", "");
        c.font_size = j.at("font").value("size", 16.0f);
    }

    if (j.find("file") != j.end()) {
        c.file_history = j.at("file").value<decltype(c.file_history)>("history", {});
    }

    if (j.find("display") != j.end()) {
        c.display_address = j.at("display").value("address", true);
        c.display_offset = j.at("display").value("offset", true);
        c.display_bytes = j.at("display").value("bytes", true);
        c.display_print = j.at("display").value("print", true);
    }

    c.refresh_rate = j.value("refresh_rate", 500);
    c.always_on_top = j.value("always_on_top", false);
}

```

`src/Config.hpp`:

```hpp
#pragma once

#include <deque>
#include <string>

#include <nlohmann/json.hpp>

struct Config {
    std::string font_file{};
    float font_size{16.0f};
    std::deque<std::string> file_history{};
    bool display_address{true};
    bool display_offset{true};
    bool display_bytes{true};
    bool display_print{true};
    int refresh_rate{500};
    bool always_on_top{false};
};

void to_json(nlohmann::json& j, const Config& c);
void from_json(const nlohmann::json& j, Config& c);

```

`src/Helpers.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <map>
#include <string>

class Helpers {
public:
    virtual std::map<uint32_t, std::string> processes() = 0;
};
```

`src/LoggerUi.cpp`:

```cpp
#include "LoggerUi.hpp"

void LoggerUi::ui() {
    ImGui::BeginChild("logger");
    ImGui::TextUnformatted(m_buf.begin());

    if (m_scroll_to_bottom) {
        ImGui::SetScrollHereY(1.0f);
        m_scroll_to_bottom = false;
    }

    ImGui::EndChild();
}

```

`src/LoggerUi.hpp`:

```hpp
#pragma once

#include <fmt/format.h>
#include <imgui.h>
#include <spdlog/sinks/base_sink.h>
#include <spdlog/spdlog.h>

template <typename Mutex> class LoggerUiSink : public spdlog::sinks::base_sink<Mutex> {
public:
    LoggerUiSink(ImGuiTextBuffer& buf, bool& scroll_to_bottom) : m_buf{buf}, m_scroll_to_bottom{scroll_to_bottom} {}

protected:
    void sink_it_(const spdlog::details::log_msg& msg) override {
        spdlog::memory_buf_t formatted{};
        spdlog::sinks::base_sink<Mutex>::formatter_->format(msg, formatted);
        m_buf.append(fmt::to_string(formatted).c_str());
        m_scroll_to_bottom = true;
    }

    void flush_() override {}

private:
    ImGuiTextBuffer& m_buf{};
    bool& m_scroll_to_bottom{};
};

class LoggerUi {
public:
    void ui();

    auto&& logger() const { return m_logger; }
    auto&& logger() { return m_logger; }

    void clear() { m_buf.clear(); }

private:
    ImGuiTextBuffer m_buf{};
    bool m_scroll_to_bottom{};
    std::shared_ptr<LoggerUiSink<std::mutex>> m_sink{
        std::make_shared<LoggerUiSink<std::mutex>>(m_buf, m_scroll_to_bottom)};
    std::shared_ptr<spdlog::logger> m_logger{std::make_shared<spdlog::logger>("LoggerUi", m_sink)};
};
```

`src/Main.cpp`:

```cpp
#include <cstdio>
#include <filesystem>

#include <SDL.h>
#include <glad/glad.h> // Initialize with gladLoadGL()
#include <imgui.h>
#include <imgui_impl_opengl3.h>
#include <imgui_impl_sdl.h>

#include "scope_guard.hpp"

#include "ReGenny.hpp"

// Main code
int main(int, char**) {
    // Setup SDL
    // (Some versions of SDL before <2.0.10 appears to have performance/stalling issues on a minority of Windows
    // systems, depending on whether SDL_INIT_GAMECONTROLLER is enabled or disabled.. updating to latest version of SDL
    // is recommended!)
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) != 0) {
        printf("Error: %s\n", SDL_GetError());
        return -1;
    }

    auto cleanup_sdl = sg::make_scope_guard([] { SDL_Quit(); });

    // GL 3.0 + GLSL 130
    const char* glsl_version = "#version 130";
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);

    // Create window with graphics context
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
    SDL_WindowFlags window_flags =
        (SDL_WindowFlags)(SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);
    SDL_Window* window =
        SDL_CreateWindow("ReGenny", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, window_flags);
    SDL_GLContext gl_context = SDL_GL_CreateContext(window);
    SDL_GL_SetSwapInterval(1); // Enable vsync
    SDL_SetWindowMinimumSize(window, 300, 150);

    auto cleanup_window = sg::make_scope_guard([window, gl_context] {
        SDL_GL_DeleteContext(gl_context);
        SDL_DestroyWindow(window);
    });

    // Initialize OpenGL loader
    if (gladLoadGL() == 0) {
        fprintf(stderr, "Failed to initialize OpenGL loader!\n");
        return 1;
    }

    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();

    auto app_path_str = SDL_GetPrefPath("cursey", "ReGenny");
    std::filesystem::path app_path{app_path_str};
    SDL_free(app_path_str);

    auto imgui_ini_filename = (app_path / "imgui.ini").string();
    auto& io = ImGui::GetIO();

    io.IniFilename = imgui_ini_filename.c_str();
    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    // ImGui::StyleColorsClassic();

    // Setup Platform/Renderer backends
    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);
    ImGui_ImplOpenGL3_Init(glsl_version);

    auto cleanup_imgui = sg::make_scope_guard([] {
        ImGui_ImplOpenGL3_Shutdown();
        ImGui_ImplSDL2_Shutdown();
        ImGui::DestroyContext();
    });

    // Our state
    ReGenny regenny{window};
    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

    // Main loop
    bool done = false;

    while (!done) {
        auto start_time = SDL_GetPerformanceCounter();

        // Poll and handle events (inputs, window resize, etc.)
        // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your
        // inputs.
        // - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
        // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
        // Generally you may always pass all inputs to dear imgui, and hide them from your application based on those
        // two flags.
        SDL_Event e{};

        while (SDL_PollEvent(&e)) {
            ImGui_ImplSDL2_ProcessEvent(&e);
            regenny.process_event(e);

            if (e.type == SDL_QUIT) {
                done = true;
            } else if (e.type == SDL_WINDOWEVENT && e.window.event == SDL_WINDOWEVENT_CLOSE &&
                       e.window.windowID == SDL_GetWindowID(window)) {
                done = true;
            }
        }

        regenny.update();

        // Start the Dear ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplSDL2_NewFrame(window);
        ImGui::NewFrame();

        regenny.ui();
        // ImGui::ShowDemoWindow();

        // Rendering
        ImGui::Render();
        glViewport(0, 0, (int)io.DisplaySize.x, (int)io.DisplaySize.y);
        glClearColor(
            clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        SDL_GL_SwapWindow(window);

        auto end_time = SDL_GetPerformanceCounter();
        auto elapsed_ms = (end_time - start_time) / (float)SDL_GetPerformanceFrequency() * 1000.0f;
        constexpr auto fps_cap = 1000.0f / 60.0f;

        SDL_Delay((Uint32)std::max(fps_cap - elapsed_ms, 0.0f));
    }

    return 0;
}

```

`src/MemoryUi.cpp`:

```cpp
#include <array>

#include <fmt/format.h>
#include <imgui.h>
#include <imgui_internal.h>

#include "node/Pointer.hpp"

#include "MemoryUi.hpp"

MemoryUi::MemoryUi(
    Config& cfg, sdkgenny::Sdk& sdk, sdkgenny::Struct* struct_, Process& process, node::Property& inherited_props)
    : m_cfg{cfg}, m_sdk{sdk}, m_struct{struct_}, m_process{process}, m_props{inherited_props} {
    if (m_struct == nullptr) {
        return;
    }

    m_proxy_variable = std::make_unique<sdkgenny::Variable>("root");
    m_proxy_variable->type(m_struct->ptr());

    auto root = std::make_unique<node::Pointer>(m_cfg, m_process, m_proxy_variable.get(), m_props);
    root->is_collapsed(false);

    m_root = std::move(root);
}

void MemoryUi::display(uintptr_t address) {
    m_header.clear();

    auto needs_space = false;

    if (m_cfg.display_address) {
        if constexpr (sizeof(void*) == 8) {
            fmt::format_to(std::back_inserter(m_header), "{:16}", "Address");
        } else {
            fmt::format_to(std::back_inserter(m_header), "{:8}", "Address");
        }

        needs_space = true;
    }

    if (m_cfg.display_offset) {
        if (needs_space) {
            m_header += ' ';
        }

        fmt::format_to(std::back_inserter(m_header), "{:8}", "Offset");
        needs_space = true;
    }

    if (m_cfg.display_bytes) {
        if (needs_space) {
            m_header += ' ';
        }

        fmt::format_to(std::back_inserter(m_header), "{:19}", "Bytes");
        needs_space = true;
    }

    if (m_cfg.display_print) {
        if (needs_space) {
            m_header += ' ';
        }

        fmt::format_to(std::back_inserter(m_header), "{:8}", "Print");
        needs_space = true;
    }

    ImGui::TextColored({0.6f, 0.6f, 0.6f, 1.0f}, "%s", m_header.c_str());

    if (m_root != nullptr) {
        ImGui::BeginChild("MemoryUiRoot", ImGui::GetContentRegionAvail());
        m_root->display(address, 0, (std::byte*)&address);
        ImGui::EndChild();
    }
}

```

`src/MemoryUi.hpp`:

```hpp
#pragma once

#include <map>
#include <memory>
#include <unordered_map>
#include <vector>

#include <sdkgenny.hpp>

#include "Config.hpp"
#include "Process.hpp"
#include "node/Base.hpp"
#include "node/Property.hpp"

class MemoryUi {
public:
    MemoryUi(
        Config& cfg, sdkgenny::Sdk& sdk, sdkgenny::Struct* struct_, Process& process, node::Property& inherited_props);

    void display(uintptr_t address);

    auto&& props() { return m_props; }

private:
    Config& m_cfg;
    sdkgenny::Sdk& m_sdk;
    sdkgenny::Struct* m_struct{};
    Process& m_process;

    std::unique_ptr<sdkgenny::Variable> m_proxy_variable{};
    std::unique_ptr<node::Base> m_root{};

    node::Property m_props;

    std::string m_header{};
};
```

`src/Process.cpp`:

```cpp
#include "Process.hpp"

bool Process::read(uintptr_t address, void* buffer, size_t size) {
    // If we're reading from read-only memory we can just use the cached version since it hasn't changed.
    for (auto&& ro_allocation : m_read_only_allocations) {
        if (ro_allocation.start <= address && address + size <= ro_allocation.end &&
            ro_allocation.mem.size() == ro_allocation.size) {
            auto offset = address - ro_allocation.start;

            // two incase the size causes overflow
            if (offset >= ro_allocation.mem.size() || offset + size >= ro_allocation.mem.size()) {
                return false;
            }

            memcpy(buffer, ro_allocation.mem.data() + offset, size);
            return true;
        }
    }

    return handle_read(address, buffer, size);
}

bool Process::write(uintptr_t address, const void* buffer, size_t size) {
    return handle_write(address, buffer, size);
}

std::optional<uint64_t> Process::protect(uintptr_t address, size_t size, uint64_t flags) {
    return handle_protect(address, size, flags);
}

std::optional<uintptr_t> Process::allocate(uintptr_t address, size_t size, uint64_t flags) {
    return handle_allocate(address, size, flags);
}

const Process::Module* Process::get_module_within(uintptr_t addr) const {
    for (auto& mod : modules()) {
        if (addr >= mod.start && addr <= mod.end) {
            return &mod;
        }
    }

    return nullptr;
}

const Process::Module* Process::get_module(std::string_view name) const {
    for (auto& mod : modules()) {
        if (mod.name == name) {
            return &mod;
        }
    }

    return nullptr;
}

```

`src/Process.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

class Process {
public:
    class Module {
    public:
        std::string name{};
        uintptr_t start{};
        uintptr_t end{};
        size_t size{};
    };

    struct Allocation {
        uintptr_t start{};
        uintptr_t end{};
        size_t size{};

        bool read{};
        bool write{};
        bool execute{};
    };

    struct ReadOnlyAllocation : public Allocation {
        // Read only allocations get cached.
        std::vector<std::byte> mem{};
    };

    bool read(uintptr_t address, void* buffer, size_t size);
    bool write(uintptr_t address, const void* buffer, size_t size);
    std::optional<uint64_t> protect(uintptr_t address, size_t size, uint64_t flags);
    std::optional<uintptr_t> allocate(uintptr_t address, size_t size, uint64_t flags);
    virtual uint32_t process_id() { return 0; }

    // NOTE: Return true by default so you can view structures without being attached.
    virtual bool ok() { return true; }

    // RTTI
    virtual std::optional<std::string> get_typename(uintptr_t ptr) { return std::nullopt; }

    auto&& modules() const { return m_modules; }
    auto&& allocations() const { return m_allocations; }

    const Process::Module* get_module_within(uintptr_t addr) const;
    const Process::Module* get_module(std::string_view name) const;

    template <typename T> std::optional<T> read(uintptr_t address) {
        T out{};

        if (!read(address, &out, sizeof(T))) {
            return std::nullopt;
        }

        return out;
    }

    template <typename T> bool write(uintptr_t address, const T& value) { return write(address, &value, sizeof(T)); }

protected:
    std::vector<Module> m_modules{};
    std::vector<Allocation> m_allocations{};
    std::vector<ReadOnlyAllocation> m_read_only_allocations{};

    virtual bool handle_write(uintptr_t address, const void* buffer, size_t size) { return true; }
    virtual bool handle_read(uintptr_t address, void* buffer, size_t size) { return true; }
    virtual std::optional<uint64_t> handle_protect(uintptr_t address, size_t size, uint64_t flags) {
        return std::nullopt;
    }
    virtual std::optional<uintptr_t> handle_allocate(uintptr_t address, size_t size, uint64_t flags) {
        return std::nullopt;
    }
};
```

`src/Project.cpp`:

```cpp
#include "Project.hpp"

void to_json(nlohmann::json& j, const Project& p) {
    std::function<void(nlohmann::json&, const std::string&, const node::Property&)> visit =
        [&visit](nlohmann::json& j, const std::string& name, const node::Property& prop) {
            if (prop.value.index() == 0 && prop.props.empty()) {
                return;
            }

            if (prop.value != prop.default_value) {
                std::visit(
                    [&](auto&& value) {
                        using T = std::decay_t<decltype(value)>;
                        if constexpr (std::is_same_v<T, int>) {
                            j[name] = value;
                        } else if constexpr (std::is_same_v<T, bool>) {
                            j[name] = value;
                        }
                    },
                    prop.value);
            }

            for (auto&& [child_name, child_prop] : prop.props) {
                visit(j[name], child_name, child_prop);
            }
        };

    std::function<void(nlohmann::json&)> erase_null = [&erase_null](nlohmann::json& j) {
        if (!j.is_object()) {
            return;
        }

        for (auto it = j.begin(); it != j.end();) {
            if (it->is_null()) {
                it = j.erase(it);
            } else {
                erase_null(it.value());
                ++it;
            }
        }
    };

    j["props"].clear();

    for (auto&& [type_name, props] : p.props) {
        visit(j["props"], type_name, props);
    }

    for (auto it = j["props"].begin(); it != j["props"].end(); ++it) {
        erase_null(it.value());
    }

    j["process"]["filter"] = p.process_filter;
    j["process"]["id"] = p.process_id;
    j["process"]["name"] = p.process_name;
    j["extension"]["header"] = p.extension_header;
    j["extension"]["source"] = p.extension_source;
    j["type"]["addresses"] = p.type_addresses;
    j["type"]["chosen"] = p.type_chosen;
}

void from_json(const nlohmann::json& j, Project& p) {
    p.process_filter = j.at("process").value("filter", "");
    p.process_id = j.at("process").value<uint32_t>("id", 0);
    p.process_name = j.at("process").value("name", "");
    p.extension_header = j.at("extension").value("header", ".hpp");
    p.extension_source = j.at("extension").value("source", ".cpp");
    p.type_addresses = j.at("type").value<decltype(p.type_addresses)>("addresses", {});
    p.type_chosen = j.at("type").value("chosen", "");
    p.props.clear();

    std::function<void(const nlohmann::json&, node::Property&)> visit = [&visit](const nlohmann::json& j,
                                                                            node::Property& prop) {
        if (j.empty()) {
            return;
        }

        for (auto it = j.begin(); it != j.end(); ++it) {
            auto& val = it.value();

            if (val.is_boolean()) {
                prop[it.key()].value = (bool)val;
            } else if (val.is_number()) {
                prop[it.key()].value = (int)val;
            } else if (val.is_object()) {
                visit(val, prop.props[it.key()]);
            }
        }
    };

    for (auto it = j.at("props").begin(); it != j.at("props").end(); ++it) {
        visit(it.value(), p.props[it.key()]);
    }
}

```

`src/Project.hpp`:

```hpp
#pragma once

#include <map>
#include <string>

#include <nlohmann/json.hpp>

#include "node/Property.hpp"

struct Project {
    std::string extension_header{".hpp"};
    std::string extension_source{".cpp"};
    std::string process_filter{};
    uint32_t process_id{};
    std::string process_name{};
    std::map<std::string, node::Property> props{};
    std::map<std::string, std::string> type_addresses{};
    std::string type_chosen{};
};

void to_json(nlohmann::json& j, const Project& p);
void from_json(const nlohmann::json& j, Project& p);

```

`src/ReGenny.cpp`:

```cpp
#include <algorithm>
#include <cassert>
#include <cstdlib>
#include <type_traits>

#include <LuaGenny.h>
#include <fmt/format.h>
#include <imgui.h>
#include <imgui_impl_opengl3.h>
#include <imgui_impl_sdl.h>
#include <imgui_internal.h>
#include <imgui_stdlib.h>
#include <nfd.h>
#include <sdkgenny_parser.hpp>
#include <spdlog/spdlog.h>

#include "AboutUi.hpp"
#include "Utility.hpp"
#include "arch/Arch.hpp"
#include "node/Undefined.hpp"

#ifdef _WIN32
#include "arch/Windows.hpp"
#endif

#include "ReGenny.hpp"

using namespace std::literals;

ReGenny::ReGenny(SDL_Window* window)
    : m_window{window}, m_helpers{arch::make_helpers()}, m_process{std::make_unique<Process>()} {
    spdlog::set_default_logger(m_logger.logger());
    spdlog::set_pattern("[%H:%M:%S] [%l] %v");
    spdlog::info("Start of log.");

    reset_lua_state();

    auto path_str = SDL_GetPrefPath("cursey", "ReGenny");
    m_app_path = path_str;
    SDL_free(path_str);

    load_cfg();

    m_triggers.on({SDLK_LCTRL, SDLK_n}, [this] { file_new(); });
    m_triggers.on({SDLK_LCTRL, SDLK_o}, [this] { file_open(); });
    m_triggers.on({SDLK_LCTRL, SDLK_s}, [this] { file_save(); });
    m_triggers.on({SDLK_LCTRL, SDLK_q}, [this] { file_quit(); });
    m_triggers.on({SDLK_LCTRL, SDLK_l}, [this] { file_run_lua_script(); });
    m_triggers.on({SDLK_LCTRL, SDLK_e}, [this] { file_open_in_editor(); });
}

ReGenny::~ReGenny() {
}

void ReGenny::process_event(SDL_Event& e) {
    m_triggers.processEvent(e);
}

void ReGenny::update() {
    if (m_load_font) {
        spdlog::info("Setting font {}...", m_cfg.font_file);

        auto& io = ImGui::GetIO();
        io.Fonts->Clear();
        io.Fonts->AddFontFromFileTTF(m_cfg.font_file.c_str(), m_cfg.font_size);
        ImGui_ImplOpenGL3_DestroyFontsTexture();
        ImGui_ImplOpenGL3_CreateFontsTexture();
        m_load_font = false;
    }

    auto now = std::chrono::system_clock::now();

    // Auto reload changed files.
    if (now > m_file_modified_check_time) {
        file_reload();
        m_file_modified_check_time = now + 1s;
    }

    // Auto detach from closed processes.
    if (m_process != nullptr) {
        if (!m_process->ok()) {
            action_detach();
        }
    }

    if (m_cfg_save_time && now > *m_cfg_save_time) {
        save_cfg();
        m_cfg_save_time = std::nullopt;
    }
}

void ReGenny::ui() {
    SDL_GetWindowSize(m_window, &m_window_w, &m_window_h);
    ImGui::SetNextWindowPos({0, 0}, ImGuiCond_Always);
    ImGui::SetNextWindowSize({(float)m_window_w, (float)m_window_h}, ImGuiCond_Always);
    ImGui::Begin("ReGenny", nullptr,
        ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking |
            ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoResize);
    auto dock = ImGui::GetID("MainDockSpace");

    if (ImGui::DockBuilderGetNode(dock) == nullptr) {
        ImGui::DockBuilderAddNode(dock, ImGuiDockNodeFlags_DockSpace);
        ImGui::DockBuilderSetNodeSize(dock, ImGui::GetContentRegionAvail());

        ImGuiID left{}, right{};
        ImGuiID top{}, bottom{};

        ImGuiID bottom_top{}, bottom_bottom{};

        ImGui::DockBuilderSplitNode(dock, ImGuiDir_Up, 1.61f * 0.5f, &top, &bottom);
        ImGui::DockBuilderSplitNode(top, ImGuiDir_Left, 0.66f, &left, &right);
        ImGui::DockBuilderSplitNode(bottom, ImGuiDir_Up, 1.61f * 0.5f, &bottom_top, &bottom_bottom);

        ImGui::DockBuilderDockWindow("Attach", left);
        ImGui::DockBuilderDockWindow("Memory View", left);
        ImGui::DockBuilderDockWindow("Editor", right);
        ImGui::DockBuilderDockWindow("Log", bottom_top);
        ImGui::DockBuilderDockWindow("LuaEval", bottom_bottom);

        ImGui::DockBuilderFinish(dock);
    }

    ImGui::DockSpace(dock, ImGui::GetContentRegionAvail(), ImGuiDockNodeFlags_AutoHideTabBar);

    menu_ui();

    ImGui::SetNextWindowPos(ImVec2{m_window_w / 2.0f, m_window_h / 2.0f}, ImGuiCond_Appearing, ImVec2{0.5f, 0.5f});
    ImGui::SetNextWindowSize(ImVec2{600.0f, 0.0f}, ImGuiCond_Appearing);
    m_ui.attach_popup = ImGui::GetID("Attach");
    if (ImGui::BeginPopupModal("Attach")) {
        attach_ui();

        ImGui::SameLine();

        if (ImGui::Button("Cancel")) {
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }

    m_ui.rtti_popup = ImGui::GetID("RTTI");

    if (ImGui::BeginPopupModal("RTTI")) {
        rtti_ui();

        ImGui::SameLine();

        if (ImGui::Button("Close")) {
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }

    ImGui::Begin("Memory View");
    memory_ui();
    ImGui::End();

    ImGui::Begin("Log");
    m_logger.ui();
    ImGui::End();

    ImGui::Begin("LuaEval");

    ImGui::BeginChild("luaeval");
    std::array<char, 256> eval{};
    ImGui::PushItemWidth(ImGui::GetWindowWidth());

    if (m_reapply_focus_eval) {
        ImGui::SetKeyboardFocusHere();
        m_reapply_focus_eval = false;
    }

    auto eval_cb = [](ImGuiInputTextCallbackData* data) -> int {
        auto rg = reinterpret_cast<ReGenny*>(data->UserData);

        if (data->EventFlag == ImGuiInputTextFlags_CallbackHistory) {
            if (data->EventKey == ImGuiKey_UpArrow) {
                if (rg->eval_history_index() > 0) {
                    rg->eval_history_index()--;
                }
            } else if (data->EventKey == ImGuiKey_DownArrow) {
                if (rg->eval_history_index() < rg->eval_history().size()) {
                    rg->eval_history_index()++;
                }
            }

            if (rg->eval_history_index() < rg->eval_history().size()) {
                data->DeleteChars(0, data->BufTextLen);
                data->InsertChars(0, rg->eval_history()[rg->eval_history_index()].c_str());
            }
        }

        return 0;
    };

    if (ImGui::InputText("eval", eval.data(), 256,
            ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_CallbackHistory, eval_cb, this)) {
        if (m_eval_history.size() >= 20) {
            m_eval_history.pop_front();
        }

        m_eval_history.push_back(eval.data());
        m_eval_history_index = m_eval_history.size();

        try {
            if (std::string_view{eval.data()} == "clear") {
                m_logger.clear();
            } else {
                auto result = m_lua->safe_script(std::string{"return "} + eval.data());

                if (!result.valid()) {
                    result = m_lua->safe_script(eval.data());

                    if (!result.valid()) {
                        sol::script_default_on_error(*m_lua, std::move(result));
                    }
                } else {
                    auto obj = result.get<sol::object>();

                    obj.push();
                    auto str = luaL_tolstring(*m_lua, -1, nullptr);

                    if (str != nullptr) {
                        spdlog::info("{}", str);
                    }

                    obj.pop();
                }
            }
        } catch (const std::exception& e) {
            if (std::string_view{e.what()}.find("<eof>") != std::string_view::npos) {
                // Try again without the return
                try {
                    auto result = m_lua->safe_script(eval.data());

                    if (!result.valid()) {
                        sol::script_default_on_error(*m_lua, std::move(result));
                    }
                } catch (const std::exception& e) {
                    spdlog::error("{}", e.what());
                } catch (...) {
                    spdlog::error("Unknown exception");
                }
            } else {
                spdlog::error("{}", e.what());
            }
        } catch (...) {
            spdlog::error("Unknown exception");
        }

        m_reapply_focus_eval = true;
    }
    ImGui::PopItemWidth();
    ImGui::EndChild();

    ImGui::End();

    ImGui::SetNextWindowPos(ImVec2{m_window_w / 2.0f, m_window_h / 2.0f}, ImGuiCond_Appearing, ImVec2{0.5f, 0.5f});
    m_ui.error_popup = ImGui::GetID("Error");
    if (ImGui::BeginPopupModal("Error")) {
        ImGui::TextUnformatted(m_ui.error_msg.c_str());

        if (ImGui::Button("Ok")) {
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }

    ImGui::SetNextWindowPos(ImVec2{m_window_w / 2.0f, m_window_h / 2.0f}, ImGuiCond_Appearing, ImVec2{0.5f, 0.5f});
    ImGui::SetNextWindowSize(ImVec2{600.0f, 0.0f}, ImGuiCond_Appearing);
    m_ui.font_popup = ImGui::GetID("Set Font");
    if (ImGui::BeginPopupModal("Set Font")) {
        if (ImGui::Button("Browse")) {
            nfdchar_t* out_path{};

            if (NFD_OpenDialog("ttf", nullptr, &out_path) == NFD_OKAY) {
                m_cfg.font_file = out_path;
            }
        }

        ImGui::SameLine();
        ImGui::TextUnformatted(m_cfg.font_file.c_str());
        ImGui::SliderFloat("Size", &m_cfg.font_size, 6.0f, 32.0f, "%.0f");

        if (ImGui::Button("OK")) {
            ImGui::CloseCurrentPopup();

            if (!m_cfg.font_file.empty()) {
                m_load_font = true;
            }

            save_cfg();
        }

        ImGui::SameLine();

        if (ImGui::Button("Cancel")) {
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }

    ImGui::SetNextWindowPos(ImVec2{m_window_w / 2.0f, m_window_h / 2.0f}, ImGuiCond_Appearing, ImVec2{0.5f, 0.5f});
    ImGui::SetNextWindowSize(ImVec2{600.0f, 350.0f}, ImGuiCond_Appearing);
    m_ui.about_popup = ImGui::GetID("About");
    if (ImGui::BeginPopup("About")) {
        about_ui();
        ImGui::EndPopup();
    }

    ImGui::SetNextWindowPos(ImVec2{m_window_w / 2.0f, m_window_h / 2.0f}, ImGuiCond_Appearing, ImVec2{0.5f, 0.5f});
    ImGui::SetNextWindowSize(ImVec2{600.0f, 0.0f}, ImGuiCond_Appearing);
    m_ui.extensions_popup = ImGui::GetID("Set SDK Extensions");
    if (ImGui::BeginPopupModal("Set SDK Extensions")) {
        ImGui::InputText("Header Extension", &m_project.extension_header);
        ImGui::InputText("Source Extension", &m_project.extension_source);

        if (ImGui::Button("OK")) {
            ImGui::CloseCurrentPopup();
            save_project();
        }

        ImGui::SameLine();

        if (ImGui::Button("Cancel")) {
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }
    ImGui::End();
}

void ReGenny::menu_ui() {
    if (ImGui::BeginMenuBar()) {
        if (ImGui::BeginMenu("File")) {
            if (ImGui::MenuItem("New", "Ctrl+N")) {
                file_new();
            }

            if (ImGui::MenuItem("Open", "Ctrl+O")) {
                file_open();
            }

            if (ImGui::BeginMenu("Open Recent...")) {
                if (m_cfg.file_history.empty()) {
                    ImGui::TextUnformatted("No files have been open recently");
                }

                for (auto&& path : m_cfg.file_history) {
                    if (ImGui::MenuItem(path.c_str())) {
                        file_open(path);
                    }
                }

                ImGui::EndMenu();
            }

            ImGui::BeginDisabled(m_sdk == nullptr);

            if (ImGui::MenuItem("Save", "Ctrl+S")) {
                file_save();
            }

            if (ImGui::MenuItem("Save As...")) {
                file_save_as();
            }

            if (ImGui::MenuItem("Open In Editor", "Ctrl+E")) {
                file_open_in_editor();
            }

            if (ImGui::MenuItem("Run Lua Script", "Ctrl+L")) {
                file_run_lua_script();
            }

            ImGui::EndDisabled();

            if (ImGui::MenuItem("Exit", "Ctrl+Q")) {
                file_quit();
            }

            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("View")) {
            ImGui::Checkbox("Hide Undefined Nodes", &node::Undefined::is_hidden);

            if (ImGui::Checkbox("Display Address", &m_cfg.display_address)) {
                save_cfg();
            }

            if (ImGui::Checkbox("Display Offset", &m_cfg.display_offset)) {
                save_cfg();
            }

            if (ImGui::Checkbox("Display Bytes", &m_cfg.display_bytes)) {
                save_cfg();
            }

            if (ImGui::Checkbox("Display Print", &m_cfg.display_print)) {
                save_cfg();
            }

            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Action")) {
            ImGui::BeginDisabled(m_sdk == nullptr);

            if (ImGui::MenuItem("Attach")) {
                ImGui::OpenPopup(m_ui.attach_popup);
            }

            if (ImGui::MenuItem("Detach")) {
                action_detach();
            }

            if (ImGui::MenuItem("Generate SDK")) {
                action_generate_sdk();
            }

            if (ImGui::MenuItem("Autogenerate RTTI Struct")) {
                m_ui.rtti_text.clear();
                ImGui::OpenPopup(m_ui.rtti_popup);
            }

            ImGui::EndDisabled();
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Options")) {
            if (ImGui::MenuItem("Set Font")) {
                // options_set_font();
                ImGui::OpenPopup(m_ui.font_popup);
            }

            if (ImGui::MenuItem("Set SDK Extensions")) {
                ImGui::OpenPopup(m_ui.extensions_popup);
            }

            if (ImGui::SliderInt("Refresh delay", &m_cfg.refresh_rate, 0, 1000)) {
                m_cfg_save_time = std::chrono::system_clock::now() + 1s;
            }

            if (ImGui::Checkbox("Always on top", &m_cfg.always_on_top)) {
                save_cfg();
                SDL_SetWindowAlwaysOnTop(m_window, m_cfg.always_on_top ? SDL_TRUE : SDL_FALSE);
            }

            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Help")) {
            if (ImGui::MenuItem("About")) {
                ImGui::OpenPopup(m_ui.about_popup);
            }

            ImGui::EndMenu();
        }

        ImGui::EndMenuBar();
    }
}

void ReGenny::file_reload() {
    // Check if a file was modified
    if (m_open_filepath.empty() || m_sdk == nullptr) {
        return;
    }

    for (auto&& filepath : m_sdk->imports()) {
        auto cwt = std::filesystem::last_write_time(filepath);

        try {
            if (cwt > m_file_lwt) {
                spdlog::info("Reopening {}...", filepath.string());
                parse_file();
                m_file_lwt = cwt;
                return;
            }
        } catch (const std::exception& e) {
            spdlog::error("Failed to get last write time for {}: {}", filepath.string(), e.what());
        } catch (...) {
            spdlog::error("Failed to get last write time for {} (Unknown reason)", filepath.string());
        }
    }
}

void ReGenny::file_new() {
    if (m_process && m_process->process_id() != 0) {
        action_detach();
    }

    nfdchar_t* out_path{};

    if (NFD_SaveDialog("genny", nullptr, &out_path) != NFD_OKAY) {
        return;
    }

    m_open_filepath = out_path;
    m_open_filepath.replace_extension("genny");

    free(out_path);

    spdlog::info("Creating new project {}...", m_open_filepath.string());

    std::ofstream genny_file{m_open_filepath};

    genny_file << "type int 4 [[i32]]\n\n"
               << "struct Foo {\n"
               << "    int bar @ 8\n"
               << "}\n";
    genny_file.close();

    save_project();
    parse_file();
}

void ReGenny::file_open(const std::filesystem::path& filepath) {
    if (m_process && m_process->process_id() != 0) {
        action_detach();
    }

    if (filepath.empty()) {
        nfdchar_t* out_path{};

        if (NFD_OpenDialog("genny", nullptr, &out_path) != NFD_OKAY) {
            return;
        }

        m_open_filepath = out_path;
        free(out_path);
    } else {
        m_open_filepath = filepath;
    }

    spdlog::info("Opening {}...", m_open_filepath.string());

    load_project();
    parse_file();
    remember_file();
    set_window_title();
}

void ReGenny::load_project() {
    auto project_filepath = m_open_filepath;
    project_filepath.replace_extension("json");

    if (!std::filesystem::exists(project_filepath)) {
        spdlog::warn("No project {} exists. Skipping...", project_filepath.string());
        return;
    }

    spdlog::info("Opening project {}...", project_filepath.string());

    try {
        std::ifstream f{project_filepath};
        nlohmann::json j{};

        f >> j;
        m_project = j.get<Project>();
    } catch (const nlohmann::json::exception& e) {
        spdlog::error(e.what());
    }

    if (m_process->process_id() == 0) { // Invalid PID (aka not attached).
        attach();
    }

    // Reset the memory UI here since a new project has been loaded.
    m_mem_ui.reset();
}

void ReGenny::file_save() {
    if (m_open_filepath.empty()) {
        file_save_as();
        return;
    }

    spdlog::info("Saving {}...", m_open_filepath.string());

    remember_file();
    save_project();
}

void ReGenny::save_project() {
    auto proj_filepath = m_open_filepath;

    proj_filepath.replace_extension("json");
    spdlog::info("Saving {}...", proj_filepath.string());

    try {
        std::ofstream f{proj_filepath, std::ofstream::out};
        nlohmann::json j = m_project;

        f << std::setw(4) << j;
    } catch (const nlohmann::json::exception& e) {
        spdlog::error(e.what());
    }
}

void ReGenny::file_save_as() {
    nfdchar_t* save_path{};

    if (NFD_SaveDialog("genny", m_open_filepath.string().c_str(), &save_path) != NFD_OKAY) {
        return;
    }

    m_open_filepath = save_path;
    m_open_filepath.replace_extension("genny");

    spdlog::info("Saving as {}...", m_open_filepath.string());

    file_save();
    free(save_path);
}

void ReGenny::file_open_in_editor() {
    if (m_open_filepath.empty()) {
        return;
    }

    spdlog::info("Opening {}...", m_open_filepath.string());

    SDL_OpenURL(("file://" + m_open_filepath.string()).c_str());
}

void ReGenny::file_quit() {
    SDL_QuitEvent event{};

    event.timestamp = SDL_GetTicks();
    event.type = SDL_QUIT;

    SDL_PushEvent((SDL_Event*)&event);
}

void ReGenny::file_run_lua_script() {
    std::scoped_lock _{m_lua_lock};

    nfdchar_t* lua_path{};

    if (NFD_OpenDialog("lua", nullptr, &lua_path) != NFD_OKAY) {
        return;
    }

    try {
        m_lua->do_file(lua_path);
    } catch (const std::exception& e) {
        spdlog::error(e.what());
        return;
    } catch (...) {
        spdlog::error("Unknown error!");
        return;
    }
}

void ReGenny::action_detach() {
    spdlog::info("Detaching...");
    m_process = std::make_unique<Process>();
    m_mem_ui = std::make_unique<MemoryUi>(
        m_cfg, *m_sdk, dynamic_cast<sdkgenny::Struct*>(m_type), *m_process, m_project.props[m_project.type_chosen]);
    m_ui.processes.clear();
    set_window_title();
}

void ReGenny::action_generate_sdk() {
    if (m_sdk == nullptr) {
        return;
    }

    nfdchar_t* sdk_path{};

    if (NFD_PickFolder(nullptr, &sdk_path) != NFD_OKAY) {
        return;
    }

    spdlog::info("Generating SDK at {}...", sdk_path);
    m_sdk->header_extension(m_project.extension_header)
        ->source_extension(m_project.extension_source)
        ->generate(sdk_path);
    free(sdk_path);
    spdlog::info("SDK generated!");
}

void ReGenny::attach_ui() {
    auto now = std::chrono::steady_clock::now();

    if (m_ui.processes.empty() || now >= m_ui.next_attach_refresh_time) {
        m_ui.processes = m_helpers->processes();
        m_ui.next_attach_refresh_time = now + 1s;
    }

    ImGui::InputText("Filter", &m_project.process_filter);

    if (ImGui::BeginListBox("Processes")) {
        for (auto&& [pid, name] : m_ui.processes) {
            if (!m_project.process_filter.empty()) {
                if (auto it = std::search(name.begin(), name.end(), m_project.process_filter.begin(),
                        m_project.process_filter.end(), [](auto a, auto b) { return tolower(a) == tolower(b); });
                    it == name.end()) {
                    continue;
                }
            }
            auto is_selected = pid == m_project.process_id;

            if (ImGui::Selectable(fmt::format("{} - {}", pid, name).c_str(), is_selected)) {
                m_project.process_name = name;
                m_project.process_id = pid;
            }

            if (is_selected) {
                ImGui::SetItemDefaultFocus();
            }
        }

        ImGui::EndListBox();
    }

    if (ImGui::Button("Attach")) {
        ImGui::CloseCurrentPopup();
        attach();
    }
}

void ReGenny::attach() {
    if (m_project.process_id == 0) {
        return;
    }

    // Make sure we have an up-to-date process list.
    m_ui.processes = m_helpers->processes();

    // Validate that the chosen process_id and process_name match.
    auto is_valid = false;

    for (auto&& [pid, name] : m_ui.processes) {
        if (pid == m_project.process_id && name == m_project.process_name) {
            is_valid = true;
        }
    }

    if (!is_valid) {
        return;
    }

    spdlog::info("Attaching to {} PID: {}...", m_project.process_name, m_project.process_id);

    m_process = arch::open_process(m_project.process_id);

    if (!m_process->ok()) {
        action_detach();
        m_ui.error_msg = "Couldn't open the process!";
        ImGui::OpenPopup(m_ui.error_popup);
        return;
    }

    parse_file();
    set_window_title();
}

void ReGenny::rtti_ui() {
    if (m_process == nullptr || !m_process->ok() || m_process->process_id() == 0) {
        ImGui::Text("Error: No Process");
        return;
    }

    if (!m_is_address_valid) {
        ImGui::Text("Error: Invalid Address");
        return;
    }

    if (m_type == nullptr) {
        ImGui::Text("Error: No Type");
        return;
    }

    if (m_type->size() == 0) {
        ImGui::Text("Error: Empty Type");
        return;
    }

    auto size = ImGui::GetContentRegionAvail();

    size.y -= 16;
    size.y = std::clamp(size.y, 0.0f, 128.0f);

    if (ImGui::InputTextMultiline("##source_rtti", &m_ui.rtti_text, size, ImGuiInputTextFlags_AllowTabInput)) {
    }

    if (ImGui::Button("Generate")) {
        m_ui.rtti_text.clear();
        std::vector<uint8_t> data(m_type->size());

        m_process->read(m_address, data.data(), data.size());

        std::unordered_map<std::string, uint32_t> counts{};

        for (size_t i = 0; i < data.size(); i++) {
            if (i + sizeof(void*) >= data.size()) {
                break;
            }

            const auto deref = *(uintptr_t*)(data.data() + i);

            if (deref == 0) {
                continue;
            }

            const auto tname = m_process->get_typename(deref);

            if (!tname || tname->length() < 5) {
                continue;
            }

            const auto demangled = tname->substr(4, tname->find_first_of("@@") - 4);

            counts[demangled] += 1;
            const auto count = counts[demangled];

            const auto variable_name = demangled + "_" + std::to_string(count);

            m_ui.rtti_text += fmt::format("struct {:s}* {:s} @ 0x{:x}\n", demangled, variable_name, (uintptr_t)i);
        }
    }
}

void ReGenny::update_address() {
    // If the parsed address has no offsets then it's not valid at all and there's nothing to update.
    if (m_parsed_address.offsets.empty()) {
        return;
    }

    // Make sure it's time to update.
    auto now = std::chrono::steady_clock::now();

    if (now < m_next_address_refresh_time) {
        return;
    }

    m_next_address_refresh_time = now + 250ms;
    m_is_address_valid = false;

    // Get the starting point.
    m_address = m_parsed_address.offsets.front();

    if (!m_parsed_address.name.empty()) {
        auto& modname = m_parsed_address.name;

        for (auto&& mod : m_process->modules()) {
            if (std::equal(modname.begin(), modname.end(), mod.name.begin(), mod.name.end(),
                    [](auto a, auto b) { return std::tolower(a) == std::tolower(b); })) {
                m_address += mod.start;
                break;
            }
        }
    }

    // Dereference and add the offsets.
    for (auto it = m_parsed_address.offsets.begin() + 1; it != m_parsed_address.offsets.end(); ++it) {
        m_address = m_process->read<uintptr_t>(m_address).value_or(0);

        if (m_address == 0) {
            return;
        }

        m_address += *it;
    }

    // Validate the final address.
    for (auto&& allocation : m_process->allocations()) {
        if (allocation.start <= m_address && m_address <= allocation.end) {
            m_is_address_valid = true;
            break;
        }
    }
}

void ReGenny::memory_ui() {
    // assert(m_process != nullptr);

    if (ImGui::BeginCombo("Typename", m_project.type_chosen.c_str())) {
        for (auto&& type_name : m_ui.type_names) {
            auto is_selected = type_name == m_project.type_chosen;

            if (ImGui::Selectable(type_name.c_str(), is_selected)) {
                // Save the previously selected type's props.
                if (m_mem_ui != nullptr) {
                    m_project.props[m_project.type_chosen] = m_mem_ui->props();
                }

                m_project.type_chosen = type_name;
                set_type();
            }

            if (is_selected) {
                ImGui::SetItemDefaultFocus();
            }
        }

        ImGui::EndCombo();
    }

    if (ImGui::InputText("Address", &m_ui.address)) {
        set_address();
    }

    ImGui::SameLine();

    if (!m_is_address_valid) {
        ImGui::TextColored({1.0f, 0.0f, 0.0f, 1.0f}, "Invalid address!");
        // return;
    } else {
        ImGui::TextColored({0.0f, 1.0f, 0.0f, 1.0f}, "%p", m_address);
    }

    update_address();

    if (m_mem_ui != nullptr) {
        m_mem_ui->display(m_is_address_valid ? m_address : 0);
    }
}

void ReGenny::set_address() {
    if (auto addr = parse_address(m_ui.address)) {
        m_parsed_address = *addr;
    }

    remember_type_and_address();
}

void ReGenny::set_type() {
    if (m_sdk == nullptr) {
        return;
    }

    sdkgenny::Object* parent = m_sdk->global_ns();
    std::string type_name = m_project.type_chosen;
    size_t pos{};

    while ((pos = type_name.find('.')) != std::string::npos) {
        parent = parent->find<sdkgenny::Object>(type_name.substr(0, pos));

        if (parent == nullptr) {
            return;
        }

        type_name.erase(0, pos + 1);
    }

    m_type = parent->find<sdkgenny::Struct>(type_name);

    if (m_type == nullptr) {
        return;
    }

    if (auto search = m_project.type_addresses.find(m_project.type_chosen); search != m_project.type_addresses.end()) {
        m_ui.address = search->second;
    } else {
        m_ui.address.clear();
    }

    set_address();

    m_mem_ui = std::make_unique<MemoryUi>(
        m_cfg, *m_sdk, dynamic_cast<sdkgenny::Struct*>(m_type), *m_process, m_project.props[m_project.type_chosen]);
}

void ReGenny::reset_lua_state() {
    std::scoped_lock _{m_lua_lock};

    m_lua = std::make_unique<sol::state>();
    auto& lua = *m_lua;

    m_lua->open_libraries(sol::lib::base, sol::lib::package, sol::lib::string, sol::lib::math, sol::lib::table,
        sol::lib::bit32, sol::lib::utf8, sol::lib::os, sol::lib::coroutine, sol::lib::io);
    luaopen_luagenny(lua);

    // clang-format off

    lua["sdkgenny"] = sol::stack::pop<sol::table>(*m_lua);
    lua["print"] = [](sol::this_state s, sol::object value) {
        if (value.is<const char*>()) {
            spdlog::info("{}", value.as<const char*>());
        } else {
            auto str = luaL_tolstring(s, lua_gettop(s), nullptr);

            spdlog::info("{}", str != nullptr ? str : "");

            lua_pop(s, 1);
        }
    };

    auto create_overlay = lua.safe_script("return function(addr, t) return sdkgenny.StructOverlay(addr, t) end").get<sol::function>();
    
    m_lua->new_usertype<ReGenny>("ReGennyClass",
        sol::no_constructor,
        "type", &ReGenny::type,
        "address", &ReGenny::address,
        "overlay", [create_overlay](sol::this_state s, ReGenny* rg) -> sol::object {
            if (rg->process() == nullptr) {
                return sol::make_object(s, sol::nil);
            }

            if (rg->type() == nullptr || !rg->type()->is_a<sdkgenny::Struct>()) {
                return sol::make_object(s, sol::nil);
            }

            return sol::make_object(s, create_overlay(rg->address(), dynamic_cast<sdkgenny::Struct*>(rg->type())));
        },
        "sdk", [](sol::this_state s, ReGenny* rg) { 
            if (rg->sdk() == nullptr) {
                sol::make_object(s, sol::nil);
            }

            return sol::make_object(s, rg->sdk().get());
        },
        "process", [](sol::this_state s, ReGenny* rg) -> sol::object { 
            if (rg->process() == nullptr) {
                sol::make_object(s, sol::nil);
            }

        #ifdef _WIN32
            if (auto wp = dynamic_cast<arch::WindowsProcess*>(rg->process().get())) {
                return sol::make_object(s, wp);
            }
        #endif
            
            return sol::make_object(s, rg->process().get());
        }
    );

    auto read_string = [](Process* p, uintptr_t addr, bool perform_strlen) -> std::string { 
        if (!perform_strlen) {
            std::vector<uint8_t> bytes(256);
            p->read(addr, bytes.data(), bytes.size());

            return std::string{(const char*)bytes.data()};
        }

        std::vector<uint8_t> bytes(16);

        for (size_t i = 0; ; i++) {
            const auto data = p->read<uint8_t>(addr + i);

            if (!data) {
                break;
            }

            if (i >= bytes.size()) {
                bytes.resize(bytes.size() * 2);
            }

            bytes[i] = *data;

            if (bytes[i] == 0) {
                break;
            }
        }

        if (bytes.empty()) {
            return std::string{};
        }

        return std::string{(const char*)bytes.data()};
    };

    m_lua->new_usertype<Process>("ReGennyProcess",
        sol::no_constructor,
        "read_uint8", [](Process* p, uintptr_t addr) { return p->read<uint8_t>(addr); },
        "read_uint16", [](Process* p, uintptr_t addr) { return p->read<uint16_t>(addr); },
        "read_uint32", [](Process* p, uintptr_t addr) { return p->read<uint32_t>(addr); },
        "read_uint64", [](Process* p, uintptr_t addr) { return p->read<uint64_t>(addr); },
        "read_int8", [](Process* p, uintptr_t addr) { return p->read<int8_t>(addr); },
        "read_int16", [](Process* p, uintptr_t addr) { return p->read<int16_t>(addr); },
        "read_int32", [](Process* p, uintptr_t addr) { return p->read<int32_t>(addr); },
        "read_int64", [](Process* p, uintptr_t addr) { return p->read<int64_t>(addr); },
        "read_float", [](Process* p, uintptr_t addr) { return p->read<float>(addr); },
        "read_double", [](Process* p, uintptr_t addr) { return p->read<double>(addr); },
        "write_uint8", [](Process* p, uintptr_t addr, uint8_t val) { p->write<uint8_t>(addr, val); },
        "write_uint16", [](Process* p, uintptr_t addr, uint16_t val) { p->write<uint16_t>(addr, val); },
        "write_uint32", [](Process* p, uintptr_t addr, uint32_t val) { p->write<uint32_t>(addr, val); },
        "write_uint64", [](Process* p, uintptr_t addr, uint64_t val) { p->write<uint64_t>(addr, val); },
        "write_int8", [](Process* p, uintptr_t addr, int8_t val) { p->write<int8_t>(addr, val); },
        "write_int16", [](Process* p, uintptr_t addr, int16_t val) { p->write<int16_t>(addr, val); },
        "write_int32", [](Process* p, uintptr_t addr, int32_t val) { p->write<int32_t>(addr, val); },
        "write_int64", [](Process* p, uintptr_t addr, int64_t val) { p->write<int64_t>(addr, val); },
        "write_float", [](Process* p, uintptr_t addr, float val) { p->write<float>(addr, val); },
        "write_double", [](Process* p, uintptr_t addr, double val) { p->write<double>(addr, val); },
        "read_string", read_string,
        "protect", &Process::protect,
        "allocate", [](Process* p, uintptr_t addr, size_t size, sol::object flags_obj) {
            uint64_t flags{};

            if (flags_obj.is<uint64_t>()) {
                flags = flags_obj.as<uint64_t>();
            }

            return p->allocate(addr, size, flags);
        },
        "get_module_within", &Process::get_module_within,
        "get_module", &Process::get_module,
        "modules", &Process::modules,
        "allocations", &Process::allocations
    );

#ifdef _WIN32
    m_lua->new_usertype<arch::WindowsProcess>("ReGennyWindowsProcess",
        sol::base_classes, sol::bases<Process>(),
        "get_typename", &arch::WindowsProcess::get_typename,
        "allocate_rwx", [](arch::WindowsProcess* p, uintptr_t addr, size_t size) {
            return p->allocate(addr, size, PAGE_EXECUTE_READWRITE);
        },
        "protect_rwx", [](arch::WindowsProcess* p, uintptr_t addr, size_t size) {
            return p->protect(addr, size, PAGE_EXECUTE_READWRITE);
        },
        "create_remote_thread", &arch::WindowsProcess::create_remote_thread
    );
#endif

    m_lua->new_usertype<Process::Module>("ReGennyProcessModule",
        "name", &Process::Module::name,
        "start", &Process::Module::start,
        "end", &Process::Module::end,
        "size", &Process::Module::size
    );

    m_lua->new_usertype<Process::Allocation>("ReGennyProcessAllocation",
        "start", &Process::Allocation::start,
        "end", &Process::Allocation::end,
        "size", &Process::Allocation::size,
        "read", &Process::Allocation::read,
        "write", &Process::Allocation::write,
        "execute", &Process::Allocation::execute
    );

    lua["regenny"] = this;

    lua["sdkgenny_reader"] = [](sol::this_state s, uintptr_t address, size_t size) -> sol::object {
        // Make this use ReGenny's process reading functions
        // instead of treating the address as if we're in the same context as the game.

        auto lua = sol::state_view{s};
        auto rg = lua["regenny"].get<ReGenny*>();

        if (rg == nullptr) {
            return sol::make_object(s, sol::nil);
        }

        auto& process = rg->process();

        if (process == nullptr) {
            return sol::make_object(s, sol::nil);
        }

        switch (size) {
        case 8: {
            auto value = process->read<uint64_t>(address);
            if (!value) {
                break;
            }

            return sol::make_object(s, value);
        }
        case 4: {
            auto value = process->read<uint32_t>(address);
            if (!value) {
                break;
            }

            return sol::make_object(s, value);
        }
        case 2: {
            auto value = process->read<uint16_t>(address);
            if (!value) {
                break;
            }

            return sol::make_object(s, value);
        }
        case 1: {
            auto value = process->read<uint8_t>(address);
            if (!value) {
                break;
            }

            return sol::make_object(s, value);
        }
        default:
            break;
        }

        return sol::make_object(s, sol::nil);
    };

    lua["sdkgenny_string_reader"] = [read_string](sol::this_state s, uintptr_t address) -> sol::object {
        auto lua = sol::state_view{s};
        auto rg = lua["regenny"].get<ReGenny*>();

        if (rg == nullptr) {
            return sol::make_object(s, sol::nil);
        }

        auto& process = rg->process();

        if (process == nullptr) {
            return sol::make_object(s, sol::nil);
        }

        return sol::make_object(s, read_string(process.get(), address, true));
    };

    lua["sdkgenny_writer"] = [](sol::this_state s, uintptr_t address, size_t size, sol::object value) {
        auto lua = sol::state_view{s};
        auto rg = lua["regenny"].get<ReGenny*>();

        if (rg == nullptr) {
            return;
        }

        auto& process = rg->process();

        if (process == nullptr) {
            return;
        }

        switch(size) {
        case 8:
            if (!value.is<sol::nil_t>()) {
                value.push();

                if (lua_isinteger(s, -1)) {
                    process->write<uint64_t>(address, (uint64_t)lua_tointeger(s, -1));
                } else if (lua_isnumber(s, -1)) {
                    process->write<double>(address, lua_tonumber(s, -1));
                }

                value.pop();
            } else {
                process->write<uint64_t>(address, 0);
            }

            break;
        case 4:
            if (!value.is<sol::nil_t>()) {
                value.push();

                if (lua_isinteger(s, -1)) {
                    process->write<uint32_t>(address, (uint32_t)lua_tointeger(s, -1));
                } else if (lua_isnumber(s, -1)) {
                    process->write<float>(address, (float)lua_tonumber(s, -1));
                }

                value.pop();
            } else {
                process->write<uint32_t>(address, 0);
            }

            break;
        case 2:
            process->write<uint16_t>(address, value.as<uint16_t>());
            break;
        case 1:
            value.push();

            if (lua_isboolean(s, -1)) {
                process->write<bool>(address, lua_toboolean(s, -1));
            } else if (lua_isinteger(s, -1)) {
                process->write<uint8_t>(address, (uint8_t)lua_tointeger(s, -1));
            }

            value.pop();

            break;
        }
    };

    // clang-format on
}

void ReGenny::parse_file() try {
    auto sdk = std::make_unique<sdkgenny::Sdk>();

    sdk->import(m_open_filepath);

    sdkgenny::parser::State s{};
    s.filepath = m_open_filepath;
    s.parents.push_back(sdk->global_ns());

    tao::pegtl::file_input in{m_open_filepath};

    if (tao::pegtl::parse<sdkgenny::parser::Grammar, sdkgenny::parser::Action>(in, s)) {
        // We just parsed, so record the max last write time for any of the imported files.
        // This prevents reloading on opening a file for the first time since launch.
        for (auto&& import : sdk->imports()) {
            m_file_lwt = std::max(m_file_lwt, std::filesystem::last_write_time(import));
        }

        m_sdk = std::move(sdk);

        if (m_mem_ui != nullptr) {
            m_project.props[m_project.type_chosen] = m_mem_ui->props();
            m_mem_ui.reset();
        }

        // Build the list of selectable types for the type selector.
        m_ui.type_names.clear();

        std::unordered_set<sdkgenny::Struct*> structs{};
        m_sdk->global_ns()->get_all_in_children<sdkgenny::Struct>(structs);

        for (auto&& struct_ : structs) {
            std::vector<std::string> parent_names{};

            for (auto p = struct_->owner<sdkgenny::Object>(); p != nullptr && !p->is_a<sdkgenny::Sdk>();
                 p = p->owner<sdkgenny::Object>()) {
                if (auto& name = p->name(); !name.empty()) {
                    parent_names.emplace_back(name);
                }
            }

            std::reverse(parent_names.begin(), parent_names.end());
            std::string name{};

            for (auto p : parent_names) {
                name += p + '.';
            }

            name += struct_->name();

            m_ui.type_names.emplace(std::move(name));
        }

        set_type();
    } else {
        throw std::runtime_error{"Failed to parse file."}; 
    }
} catch (const std::exception& e) {
    spdlog::error(e.what());
}

void ReGenny::load_cfg() try {
    auto cfg_path = (m_app_path / "cfg.json").string();

    if (!std::filesystem::exists(cfg_path)) {
        return;
    }

    spdlog::info("Loading config {}...", cfg_path);

    std::ifstream f{cfg_path};
    nlohmann::json j{};

    f >> j;
    m_cfg = j.get<Config>();

    if (!m_cfg.font_file.empty()) {
        m_load_font = true;
    }

    SDL_SetWindowAlwaysOnTop(m_window, m_cfg.always_on_top ? SDL_TRUE : SDL_FALSE);
} catch (const std::exception& e) {
    spdlog::error(e.what());
    m_cfg = {};
}

void ReGenny::save_cfg() {
    auto cfg_path = m_app_path / "cfg.json";

    spdlog::info("Saving config {}...", cfg_path.string());

    try {
        std::ofstream f{cfg_path};
        nlohmann::json j = m_cfg;

        f << std::setw(4) << j;
    } catch (const nlohmann::json::exception& e) {
        spdlog::error(e.what());
    }
}

void ReGenny::remember_file() {
    for (auto it = m_cfg.file_history.begin(); it != m_cfg.file_history.end();) {
        if (*it == m_open_filepath) {
            it = m_cfg.file_history.erase(it);
        } else {
            ++it;
        }
    }

    m_cfg.file_history.emplace_front(m_open_filepath.string());

    if (m_cfg.file_history.size() > 10) {
        m_cfg.file_history.resize(10);
    }

    save_cfg();
}

void ReGenny::remember_type_and_address() {
    if (m_type == nullptr) {
        return;
    }

    m_project.type_addresses[m_project.type_chosen] = m_ui.address;
}

void ReGenny::set_window_title() {
    std::string title = "ReGenny";

    if (!m_open_filepath.empty()) {
        title += fmt::format(" - {}", m_open_filepath.string());
    }

    if (m_process && m_process->process_id() != 0 && !m_project.process_name.empty()) {
        title += fmt::format(" - {} PID: {}", m_project.process_name, m_project.process_id);
    }

    SDL_SetWindowTitle(m_window, title.c_str());
}

```

`src/ReGenny.hpp`:

```hpp
#pragma once

#include <chrono>
#include <deque>
#include <filesystem>
#include <map>
#include <memory>
#include <string>
#include <unordered_map>

#include <SDL.h>
#include <sdkgenny.hpp>
#include <sol/sol.hpp>

#include "Config.hpp"
#include "Helpers.hpp"
#include "LoggerUi.hpp"
#include "MemoryUi.hpp"
#include "Process.hpp"
#include "Project.hpp"
#include "Utility.hpp"
#include "node/Property.hpp"
#include "sdl_trigger.h"

class ReGenny {
public:
    ReGenny(SDL_Window* window);
    virtual ~ReGenny();

    void process_event(SDL_Event& e);
    void update();
    void ui();

    auto&& window() const { return m_window; }
    auto& lua() const { return *m_lua; }
    auto& sdk() const { return m_sdk; }
    auto type() const { return m_type; }
    auto& process() const { return m_process; }
    auto address() const { return m_address; }

    auto& eval_history_index() { return m_eval_history_index; }
    auto& eval_history() const { return m_eval_history; }

private:
    int m_window_w{};
    int m_window_h{};
    SDL_Window* m_window{};

    std::unique_ptr<Helpers> m_helpers{};
    std::unique_ptr<Process> m_process{};
    std::unique_ptr<sdkgenny::Sdk> m_sdk{};
    sdkgenny::Type* m_type{};
    uintptr_t m_address{};
    bool m_is_address_valid{};
    ParsedAddress m_parsed_address{};
    std::chrono::steady_clock::time_point m_next_address_refresh_time{};

    struct {
        // Process ID -> process name.
        std::map<uint32_t, std::string> processes{};
        std::chrono::steady_clock::time_point next_attach_refresh_time{};

        std::string error_msg{};
        ImGuiID error_popup{};

        std::string address{};
        std::set<std::string> type_names{};

        std::string rtti_text{};

        ImGuiID attach_popup{};
        ImGuiID rtti_popup{};
        ImGuiID font_popup{};
        ImGuiID about_popup{};
        ImGuiID extensions_popup{};
    } m_ui{};

    std::unique_ptr<MemoryUi> m_mem_ui{};

    std::filesystem::path m_open_filepath{};
    std::filesystem::file_time_type m_file_lwt;
    std::chrono::system_clock::time_point m_file_modified_check_time{};

    LoggerUi m_logger{};

    bool m_load_font{};

    std::filesystem::path m_app_path{};
    Trigger::Group m_triggers{};

    Config m_cfg{};
    std::optional<std::chrono::system_clock::time_point> m_cfg_save_time{};

    std::recursive_mutex m_lua_lock{};
    std::unique_ptr<sol::state> m_lua{};
    std::deque<std::string> m_eval_history{};
    int32_t m_eval_history_index{};
    bool m_reapply_focus_eval{false};

    Project m_project{};

    void menu_ui();

    void file_new();
    void file_open(const std::filesystem::path& filepath = {});
    void file_reload();
    void load_project();
    void file_save();
    void save_project();
    void file_save_as();
    void file_open_in_editor();
    void file_quit();
    void file_run_lua_script();

    void action_detach();
    void action_generate_sdk();

    void attach_ui();
    void attach();

    void rtti_ui();

    void update_address();
    void memory_ui();
    void set_address();
    void set_type();

    void parse_file();
    void reset_lua_state();

    void load_cfg();
    void save_cfg();

    void remember_file();
    void remember_type_and_address();

    void set_window_title();
};

```

`src/Utility.cpp`:

```cpp
#include <tao/pegtl.hpp>

#include "Utility.hpp"

namespace address_parser {
using namespace tao::pegtl;

struct HexNum : seq<one<'0'>, one<'x'>, plus<xdigit>> {};
struct DecNum : plus<digit> {};
struct Num : sor<HexNum, DecNum> {};
struct NameChar : sor<alnum, one<' ', '(', ')', '_', '-', ',', '.'>> {};
struct Name : seq<plus<NameChar>> {};
struct Offset : seq<Num, opt<one<'-'>, one<'>'>, struct Offset>> {};
struct ModOffset : seq<one<'<'>, Name, one<'>'>, opt<one<'+'>, Offset>> {};
struct Grammar : sor<Offset, ModOffset> {};

template <typename Rule> struct Action : nothing<Rule> {};
template <> struct Action<Num> {
    template <typename Input> static void apply(const Input& in, ParsedAddress& s) {
        try {
            auto num = std::stoull(in.string(), nullptr, 0);
            s.offsets.push_back(num);
        } catch (...) {
            // Failed to convert.
        }
    }
};

template <> struct Action<Name> {
    template <typename Input> static void apply(const Input& in, ParsedAddress& s) { s.name = in.string_view(); }
};

} // namespace address_parser

std::optional<ParsedAddress> parse_address(const std::string& str) {
    try {
        ParsedAddress s{};
        tao::pegtl::memory_input in{str, ""};

        if (tao::pegtl::parse<address_parser::Grammar, address_parser::Action>(in, s)) {
            return s;
        }
    } catch (const tao::pegtl::parse_error& e) {
    }

    return std::nullopt;
}

```

`src/Utility.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

struct ParsedAddress {
    std::string name{};
    std::vector<uintptr_t> offsets{};
};

std::optional<ParsedAddress> parse_address(const std::string& str);
```

`src/arch/Arch.cpp`:

```cpp
#ifdef _WIN32
#include "Windows.hpp"
#endif

#include "Arch.hpp"

std::unique_ptr<Helpers> arch::make_helpers() {
#ifdef _WIN32
    return std::make_unique<arch::WindowsHelpers>();
#endif
}

std::unique_ptr<Process> arch::open_process(uint32_t process_id) {
#ifdef _WIN32
    return std::make_unique<arch::WindowsProcess>(process_id);
#endif
}

```

`src/arch/Arch.hpp`:

```hpp
#pragma once

#include <memory>

#include "Helpers.hpp"
#include "Process.hpp"

namespace arch {
std::unique_ptr<Helpers> make_helpers();
std::unique_ptr<Process> open_process(uint32_t process_id);
} // namespace arch
```

`src/arch/Windows.cpp`:

```cpp
#include <limits>

#include <sstream>

#include <Windows.h>

#include <TlHelp32.h>

#include "Windows.hpp"

namespace arch {
WindowsProcess::WindowsProcess(DWORD process_id) : Process{} {
    m_process = OpenProcess(
        PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, process_id);

    if (m_process == nullptr) {
        return;
    }

    // Iterate modules.
    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, process_id);

    if (snapshot != INVALID_HANDLE_VALUE) {
        MODULEENTRY32 entry{};

        entry.dwSize = sizeof(entry);

        if (Module32First(snapshot, &entry)) {
            do {
                Module m{};

                m.name = entry.szModule;
                m.start = (uintptr_t)entry.modBaseAddr;
                m.size = entry.modBaseSize;
                m.end = m.start + m.size;

                m_modules.emplace_back(std::move(m));

            } while (Module32Next(snapshot, &entry));
        }

        CloseHandle(snapshot);
    }

    // Iterate memory.
    uintptr_t address = 0;
    MEMORY_BASIC_INFORMATION mbi{};

    while (VirtualQueryEx(m_process, (LPCVOID)address, &mbi, sizeof(mbi)) != 0) {
        auto protect = mbi.Protect;
        Allocation a{};

        a.start = (uintptr_t)mbi.BaseAddress;
        a.size = mbi.RegionSize;
        a.end = a.start + a.size;
        a.read = protect & PAGE_READONLY || protect & PAGE_READWRITE || protect & PAGE_WRITECOPY ||
                 protect & PAGE_EXECUTE_READ || protect & PAGE_EXECUTE_READWRITE || protect & PAGE_EXECUTE_WRITECOPY;
        a.write = protect & PAGE_READWRITE || protect & PAGE_WRITECOPY || protect & PAGE_EXECUTE_READWRITE ||
                  protect & PAGE_EXECUTE_WRITECOPY;
        a.execute = protect & PAGE_EXECUTE_READ || protect & PAGE_EXECUTE_READWRITE || protect & PAGE_EXECUTE_WRITECOPY;

        if (a.read) {
            // We cache read-only memory allocations in their entirety because Process::read optimizes for read-only
            // reads.
            if (!a.write) {
                ReadOnlyAllocation ro{};
                ro.start = a.start;
                ro.size = a.size;
                ro.end = a.end;
                ro.read = a.read;
                ro.write = a.write;
                ro.execute = a.execute;
                ro.mem.resize(ro.size);

                if (read(ro.start, ro.mem.data(), ro.size)) {
                    m_read_only_allocations.emplace_back(std::move(ro));
                }
            }

            m_allocations.emplace_back(std::move(a));
        }

        address += mbi.RegionSize;
    }
}

uint32_t WindowsProcess::process_id() {
    return GetProcessId(m_process);
}

bool WindowsProcess::ok() {
    if (m_process == nullptr) {
        return false;
    }

    DWORD exitcode{};

    GetExitCodeProcess(m_process, &exitcode);

    return exitcode == STILL_ACTIVE;
}

bool WindowsProcess::handle_write(uintptr_t address, const void* buffer, size_t size) {
    SIZE_T bytes_written{};

    WriteProcessMemory(m_process, (LPVOID)address, buffer, size, &bytes_written);

    return bytes_written == size;
}

bool WindowsProcess::handle_read(uintptr_t address, void* buffer, size_t size) {
    SIZE_T bytes_read{};

    if (ReadProcessMemory(m_process, (LPCVOID)address, buffer, size, &bytes_read) == 0) {
        // Query the page to get the real size, and re-read.
        MEMORY_BASIC_INFORMATION mbi{};
        if (VirtualQueryEx(m_process, (LPCVOID)address, &mbi, sizeof(mbi)) == 0) {
            return false;
        }

        size = ((uintptr_t)mbi.BaseAddress + mbi.RegionSize) - address;

        if (ReadProcessMemory(m_process, (LPCVOID)address, buffer, size, &bytes_read) == 0) {
            return false;
        }
    }

    return bytes_read == size;
}

std::optional<uintptr_t> WindowsProcess::handle_allocate(uintptr_t address, size_t size, uint64_t flags) {
    if (auto ptr = VirtualAllocEx(m_process, (LPVOID)address, size, MEM_COMMIT, (DWORD)flags); ptr != nullptr) {
        return (uintptr_t)ptr;
    }

    return std::nullopt;
}

std::optional<uint64_t> WindowsProcess::handle_protect(uintptr_t address, size_t size, uint64_t flags) {
    DWORD old_protect{};

    if (VirtualProtectEx(m_process, (LPVOID)address, size, (DWORD)flags, &old_protect) != 0) {
        return (uint64_t)old_protect;
    }

    return std::nullopt;
}

std::optional<uintptr_t> WindowsProcess::get_complete_object_locator_ptr(uintptr_t ptr) {
    if (ptr == 0) {
        return std::nullopt;
    }

    auto vtable = Process::read<uintptr_t>(ptr);

    if (!vtable || *vtable == 0) {
        return std::nullopt;
    }

    return Process::read<uintptr_t>(*vtable - sizeof(void*));
}

std::optional<_s_RTTICompleteObjectLocator> WindowsProcess::get_complete_object_locator(uintptr_t ptr) {
    auto out_ptr = get_complete_object_locator_ptr(ptr);

    if (!out_ptr) {
        return std::nullopt;
    }

    return Process::read<_s_RTTICompleteObjectLocator>(*out_ptr);
}

std::optional<std::array<uint8_t, sizeof(std::type_info) + 256>> WindowsProcess::get_typeinfo(uintptr_t ptr) {
    if (ptr == 0) {
        return std::nullopt;
    }

    auto locator_ptr = get_complete_object_locator_ptr(ptr);

    if (!locator_ptr || *locator_ptr == 0) {
        return std::nullopt;
    }

    auto locator = Process::read<_s_RTTICompleteObjectLocator>(*locator_ptr);

    if (!locator) {
        return std::nullopt;
    }

    auto type_desc_pre = locator->pTypeDescriptor;

    // x64 usually
#if _RTTI_RELATIVE_TYPEINFO
    if (type_desc_pre == 0) {
        return std::nullopt;
    }

    uintptr_t image_base = 0;

    if (locator->signature == COL_SIG_REV0) {
        auto module_within = get_module_within(*locator_ptr);

        if (!module_within) {
            return std::nullopt;
        }

        image_base = module_within->start;
    } else {
        image_base = *locator_ptr - locator->pSelf;
    }

    auto ti = image_base + type_desc_pre;

    return Process::read<std::array<uint8_t, sizeof(std::type_info) + 256>>((uintptr_t)ti);
#else
    if (type_desc_pre == nullptr || get_module_within((uintptr_t)type_desc_pre) == nullptr) {
        return std::nullopt;
    }

    return Process::read<std::array<uint8_t, sizeof(std::type_info) + 256>>((uintptr_t)type_desc_pre);
#endif
}

HANDLE WindowsProcess::create_remote_thread(uintptr_t address, uintptr_t param) {
    return CreateRemoteThread(m_process, nullptr, 0, (LPTHREAD_START_ROUTINE)address, (LPVOID)param, 0, nullptr);
}

std::optional<std::string> WindowsProcess::get_typename(uintptr_t ptr) {
    if (ptr == 0) {
        return std::nullopt;
    }

    auto typeinfo = get_typeinfo(ptr);

    if (!typeinfo) {
        return std::nullopt;
    }

    auto ti = (std::type_info*)&*typeinfo;

    return ti->raw_name();
}

std::map<uint32_t, std::string> WindowsHelpers::processes() {
    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (snapshot == INVALID_HANDLE_VALUE) {
        return {};
    }

    std::map<uint32_t, std::string> pids{};
    PROCESSENTRY32 entry{};

    entry.dwSize = sizeof(entry);

    if (Process32First(snapshot, &entry)) {
        do {
            pids[entry.th32ProcessID] = entry.szExeFile;
        } while (Process32Next(snapshot, &entry));
    }

    CloseHandle(snapshot);

    return pids;
}
} // namespace arch

```

`src/arch/Windows.hpp`:

```hpp
#pragma once

#include <array>

#include <Windows.h>
#include <rttidata.h>
#include <vcruntime_typeinfo.h>

#include "Helpers.hpp"
#include "Process.hpp"

namespace arch {
class WindowsProcess : public Process {
public:
    WindowsProcess(DWORD process_id);

    uint32_t process_id() override;
    bool ok() override;

    std::optional<std::string> get_typename(uintptr_t ptr) override;

    // RTTI
    std::optional<uintptr_t> get_complete_object_locator_ptr(uintptr_t ptr);
    std::optional<_s_RTTICompleteObjectLocator> get_complete_object_locator(uintptr_t ptr);
    std::optional<std::array<uint8_t, sizeof(std::type_info) + 256>> get_typeinfo(uintptr_t ptr); // __RTtypeid

    HANDLE create_remote_thread(uintptr_t address, uintptr_t param);

protected:
    bool handle_write(uintptr_t address, const void* buffer, size_t size) override;
    bool handle_read(uintptr_t address, void* buffer, size_t size) override;
    std::optional<uint64_t> handle_protect(uintptr_t address, size_t size, uint64_t flags) override;
    std::optional<uintptr_t> handle_allocate(uintptr_t address, size_t size, uint64_t flags) override;

private:
    HANDLE m_process{};
};

class WindowsHelpers : public Helpers {
public:
    std::map<uint32_t, std::string> processes() override;
};
} // namespace arch

```

`src/arch/Windows.rc`:

```rc
#ifndef _DEBUG
101 ICON "..\\..\\resources\\bottle.ico"
#else
101 ICON "..\\..\\resources\\potion.ico"
#endif

```

`src/node/Array.cpp`:

```cpp
#include <fmt/format.h>
#include <imgui.h>
#include <utf8.h>

#include "Pointer.hpp"
#include "Struct.hpp"

#include "Array.hpp"

namespace node {
void Array::display_str(std::string& s, const std::string& str) {
    s += "\"";

    for (auto&& c : str) {
        if (c == 0) {
            break;
        }

        s += c;
    }

    s += "\" ";
}

Array::Array(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props)
    : Variable{cfg, process, var, props}, m_arr{dynamic_cast<sdkgenny::Array*>(var->type())} {
    assert(m_arr != nullptr);

    m_props["__collapsed"].set_default(true);
    m_props["__start"].set_default(0);
    m_props["__count"].set_default(std::min(10, (int)m_arr->count()));

    // Make sure inherited props are within acceptable ranges.
    start_element() = std::clamp(start_element(), 0, (int)m_arr->count());
    num_elements_displayed() = std::clamp(num_elements_displayed(), 0, (int)m_arr->count());

    // Create the initial nodes.
    create_nodes();
}

void Array::display(uintptr_t address, uintptr_t offset, std::byte* mem) {
    display_address_offset(address, offset);
    ImGui::SameLine();
    ImGui::BeginGroup();
    display_type();
    ImGui::SameLine();
    display_name();

    if (!m_value_str.empty()) {
        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Text, {181.0f / 255.0f, 206.0f / 255.0f, 168.0f / 255.0f, 1.0f});
        ImGui::TextUnformatted(m_value_str.c_str());
        ImGui::PopStyleColor();
    }

    ImGui::EndGroup();

    if (ImGui::IsItemClicked()) {
        is_collapsed() = !is_collapsed();
    }

    if (ImGui::BeginPopupContextItem("ArrayNode")) {
        if (ImGui::InputInt("Start element", &start_element())) {
            start_element() = std::clamp(start_element(), 0, (int)m_arr->count());
            create_nodes();
        }

        if (ImGui::InputInt("# Elements displayed", &num_elements_displayed())) {
            num_elements_displayed() = std::clamp(num_elements_displayed(), 0, (int)m_arr->count());
            create_nodes();
        }

        ImGui::EndPopup();
    }

    if (is_collapsed()) {
        return;
    }

    auto start = start_element();
    auto num_elements = num_elements_displayed();

    for (auto i = 0; i < num_elements; ++i) {
        auto cur_element = start + i;
        auto& cur_node = m_elements[i];
        auto cur_offset = cur_element * m_arr->of()->size();

        ++indentation_level;
        ImGui::PushID(cur_node.get());
        cur_node->display(address + cur_offset, offset + cur_offset, mem + cur_offset);
        ImGui::PopID();
        --indentation_level;
    }
}

void Array::update(uintptr_t address, uintptr_t offset, std::byte* mem) {
    Base::update(address, offset, mem);
    m_value_str.clear();

    auto num_elements = num_elements_displayed();
    auto start = start_element();

    for (auto i = 0; i < num_elements; ++i) {
        auto cur_element = start + i;
        auto& cur_node = m_elements[i];
        auto cur_offset = cur_element * m_arr->of()->size();

        cur_node->update(address + cur_offset, offset + cur_offset, mem + cur_offset);
    }

    for (auto&& md : m_var->metadata()) {
        if (md == "utf8*") {
            m_utf8.resize(m_arr->count());
            memcpy(m_utf8.data(), mem, m_arr->count() * sizeof(char));
            display_str(m_value_str, m_utf8);
        } else if (md == "utf16*") {
            m_utf16.resize(m_arr->count());
            memcpy(m_utf16.data(), mem, m_arr->count() * sizeof(char16_t));

            m_utf16.back() = L'\0';

            // if we don't do this then utf16to8 will throw an exception.
            // todo: do for utf32?
            const auto real_len = wcslen((wchar_t*)m_utf16.data());
            m_utf16.resize(real_len);

            std::string utf8conv{};

            try {
                utf8conv = utf8::utf16to8(m_utf16);
            } catch (utf8::invalid_utf16& e) {
                utf8conv = e.what();
            }

            display_str(m_value_str, utf8conv);
        } else if (md == "utf32*") {
            m_utf32.resize(m_arr->count());
            memcpy(m_utf32.data(), mem, m_arr->count() * sizeof(char32_t));

            std::string utf32conv{};

            try {
                utf32conv = utf8::utf32to8(m_utf32);
            } catch (utf8::invalid_utf16& e) {
                utf32conv = e.what();
            }

            display_str(m_value_str, utf32conv);
        }
    }
}

void Array::create_nodes() {
    m_proxy_variables.clear();
    m_elements.clear();

    auto num_elements = num_elements_displayed();
    auto start = start_element();
    auto end = start + num_elements;

    for (auto i = start; i < end; ++i) {
        auto proxy_variable = std::make_unique<sdkgenny::Variable>(fmt::format("{}[{}]", m_var->name(), i));
        auto&& proxy_props = m_props[proxy_variable->name()];

        proxy_variable->type(m_arr->of());
        proxy_variable->offset(m_var->offset() + i * m_arr->size());

        std::unique_ptr<Variable> node{};

        if (proxy_variable->type()->is_a<sdkgenny::Array>()) {
            node = std::make_unique<Array>(m_cfg, m_process, proxy_variable.get(), proxy_props);
        } else if (proxy_variable->type()->is_a<sdkgenny::Struct>()) {
            auto struct_ = std::make_unique<Struct>(m_cfg, m_process, proxy_variable.get(), proxy_props);
            struct_->is_collapsed(false);
            node = std::move(struct_);
        } else if (proxy_variable->type()->is_a<sdkgenny::Pointer>()) {
            node = std::make_unique<Pointer>(m_cfg, m_process, proxy_variable.get(), proxy_props);
        } else {
            node = std::make_unique<Variable>(m_cfg, m_process, proxy_variable.get(), proxy_props);
        }

        m_proxy_variables.emplace_back(std::move(proxy_variable));
        m_elements.emplace_back(std::move(node));
    }
}
} // namespace node
```

`src/node/Array.hpp`:

```hpp
#pragma once

#include "Variable.hpp"

namespace node {
class Array : public Variable {
public:
    Array(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props);

    void display(uintptr_t address, uintptr_t offset, std::byte* mem) override;
    void update(uintptr_t address, uintptr_t offset, std::byte* mem) override;

    auto is_collapsed(bool is_collapsed) {
        m_props["__collapsed"].set(is_collapsed);
        return this;
    }
    auto& is_collapsed() { return m_props["__collapsed"].as_bool(); }

    auto start_element(int start_element) {
        m_props["__start"].set(start_element);
        return this;
    }
    auto& start_element() { return m_props["__start"].as_int(); }

    auto num_elements_displayed(int num_elements) {
        m_props["__count"].set(num_elements);
        return this;
    }
    auto& num_elements_displayed() { return m_props["__count"].as_int(); }

protected:
    sdkgenny::Array* m_arr{};
    std::vector<std::unique_ptr<Variable>> m_elements{};
    std::vector<std::unique_ptr<sdkgenny::Variable>> m_proxy_variables{};

    std::string m_value_str{};

    void create_nodes();

    static void display_str(std::string& s, const std::string& str);
};
} // namespace node
```

`src/node/Base.cpp`:

```cpp
#include <SDL.h>
#include <fmt/format.h>
#include <imgui.h>
#include <imgui_internal.h>
// msvc 15 errors about min/max
#include <algorithm>

#include "Base.hpp"

namespace node {
int Base::indentation_level = -1;

Base::Base(Config& cfg, Process& process, Property& props) : m_cfg{cfg}, m_process{process}, m_props{props} {
}

void Base::update(uintptr_t address, uintptr_t offset, std::byte* mem) {
    m_preamble_str.clear();
    m_bytes_str.clear();
    m_print_str.clear();

    auto end = (int)std::min(size(), sizeof(uint64_t));

    for (auto i = end - 1; i >= 0; --i) {
        fmt::format_to(std::back_inserter(m_bytes_str), "{:02X}", *(uint8_t*)&mem[i]);
    }

    if (end < size()) {
        m_bytes_str += "...";
    }

    for (auto i = 0; i < end; ++i) {
        auto c = *(char*)(mem + i);

        if (c >= 0 && isprint(c)) {
            m_print_str += c;
        } else {
            m_print_str += '.';
        }
    }

    auto needs_space = false;

    if (m_cfg.display_address) {
        if constexpr (sizeof(void*) == 8) {
            fmt::format_to(std::back_inserter(m_preamble_str), "{:016X}", address);
        } else {
            fmt::format_to(std::back_inserter(m_preamble_str), "{:08X}", address);
        }

        needs_space = true;
    }

    if (m_cfg.display_offset) {
        if (needs_space) {
            m_preamble_str += ' ';
        }

        fmt::format_to(std::back_inserter(m_preamble_str), "{:08X}", offset);
        needs_space = true;
    }

    if (m_cfg.display_bytes) {
        if (needs_space) {
            m_preamble_str += ' ';
        }

        fmt::format_to(std::back_inserter(m_preamble_str), "{:19}", m_bytes_str.c_str());
        needs_space = true;
    }

    if (m_cfg.display_print) {
        if (needs_space) {
            m_preamble_str += ' ';
        }

        fmt::format_to(std::back_inserter(m_preamble_str), "{:8}", m_print_str.c_str());
        needs_space = true;
    }
}

void Base::display_address_offset(uintptr_t address, uintptr_t offset) {
    ImGui::PushStyleColor(ImGuiCol_Text, {0.6f, 0.6f, 0.6f, 1.0f});
    ImGui::TextUnformatted(m_preamble_str.c_str());
    ImGui::PopStyleColor();

    if (ImGui::BeginPopupContextItem("Preamble")) {
        if (ImGui::Button("Copy Address")) {
            SDL_SetClipboardText(fmt::format("0x{:X}", address).c_str());
            ImGui::CloseCurrentPopup();
        }

        if (ImGui::Button("Copy Offset")) {
            SDL_SetClipboardText(fmt::format("0x{:X}", offset).c_str());
            ImGui::CloseCurrentPopup();
        }

        if (ImGui::Button("Copy Bytes")) {
            SDL_SetClipboardText(m_bytes_str.c_str());
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }

    if (indentation_level > 0) {
        auto g = ImGui::GetCurrentContext();
        ImGui::SameLine(0.0f, 0.0f);
        ImGui::Dummy(ImVec2{g->Style.IndentSpacing * indentation_level, g->FontSize});
    }
}

} // namespace node

```

`src/node/Base.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <unordered_map>

#include "../Config.hpp"
#include "../Process.hpp"
#include "Property.hpp"

namespace node {
class Base {
public:
    Base(Config& cfg, Process& process, Property& props);

    virtual void display(uintptr_t address, uintptr_t offset, std::byte* mem) = 0;
    virtual size_t size() = 0;
    virtual void update(uintptr_t address, uintptr_t offset, std::byte* mem);

    auto& props() { return m_props; }

protected:
    static int indentation_level;
    Config& m_cfg;
    Process& m_process;
    Property& m_props;
    std::string m_preamble_str{};
    std::string m_bytes_str{};
    std::string m_print_str{};

    void display_address_offset(uintptr_t address, uintptr_t offset);
};

} // namespace node

```

`src/node/Bitfield.cpp`:

```cpp
#include <array>
#include <cassert>

#include <fmt/format.h>
#include <imgui.h>

#include "Bitfield.hpp"

namespace node {
template <typename T> void display_bits(std::string& s, size_t num_bits, uintptr_t offset, std::byte* mem) {
    s += "0b";

    auto data = *(T*)mem;
    auto start = (int)offset;
    auto end = (int)(offset + num_bits);

    for (auto i = end - 1; i >= start; --i) {
        if (data >> i & 1) {
            s += "1";
        } else {
            s += "0";
        }
    }
}

template <typename T> void display_as(std::string& s, size_t num_bits, uintptr_t offset, std::byte* mem) {
    T mask{};
    auto data = *(T*)mem;
    auto start = offset;
    auto end = offset + num_bits;

    for (auto i = start; i < end; ++i) {
        mask |= 1ull << i;
    }

    data &= mask;
    data >>= start;

    fmt::format_to(std::back_inserter(s), " {}", data);
}

template <typename T>
void display_enum(std::string& s, size_t num_bits, uintptr_t offset, std::byte* mem, sdkgenny::Enum* enum_) {
    T mask{};
    auto data = *(T*)mem;
    auto start = offset;
    auto end = offset + num_bits;

    for (auto i = start; i < end; ++i) {
        mask |= 1ull << i;
    }

    data &= mask;
    data >>= start;

    auto val_found = false;

    for (auto&& [val_name, val_val] : enum_->values()) {
        if (val_val == data) {
            s += ' ' + val_name;
            val_found = true;
            break;
        }
    }

    if (!val_found) {
        display_as<T>(s, num_bits, offset, mem);
    }
}

Bitfield::Bitfield(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props)
    : Variable{cfg, process, var, props} {
    assert(var->is_bitfield());
}

void Bitfield::display(uintptr_t address, uintptr_t offset, std::byte* mem) {
    display_address_offset(address, offset);
    ImGui::SameLine();
    ImGui::BeginGroup();
    ImGui::TextColored({0.6f, 0.6f, 1.0f, 1.0f}, "%s", m_var->type()->name().c_str());
    ImGui::SameLine();
    ImGui::Text("%s : %d", m_var->name().c_str(), m_var->bit_size());
    ImGui::SameLine();
    ImGui::TextUnformatted(m_display_str.c_str());
    ImGui::EndGroup();

    if (ImGui::BeginPopupContextItem("BitfieldNodes")) {
        write_display(address, mem);
        ImGui::EndPopup();
    }
}

void Bitfield::update(uintptr_t address, uintptr_t offset, std::byte* mem) {
    Base::update(address, offset, mem);
    m_display_str.clear();

    switch (m_var->type()->size()) {
    case 1:
        display_bits<uint8_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
        break;
    case 2:
        display_bits<uint16_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
        break;
    case 4:
        display_bits<uint32_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
        break;
    case 8:
        display_bits<uint64_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
        break;
    default:
        assert(0);
    }

    std::array<std::vector<std::string>*, 2> metadatas{&m_var->metadata(), &m_var->type()->metadata()};

    for (auto&& metadata : metadatas) {
        for (auto&& md : *metadata) {
            if (md == "u8") {
                display_as<uint8_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
            } else if (md == "u16") {
                display_as<uint16_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
            } else if (md == "u32") {
                display_as<uint32_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
            } else if (md == "u64") {
                display_as<uint64_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
            } else if (md == "i8") {
                display_as<int8_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
            } else if (md == "i16") {
                display_as<int16_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
            } else if (md == "i32") {
                display_as<int32_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
            } else if (md == "i64") {
                display_as<int64_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem);
            }
        }
    }

    if (auto enum_ = dynamic_cast<sdkgenny::Enum*>(m_var->type())) {
        switch (m_var->type()->size()) {
        case 1:
            display_enum<uint8_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem, enum_);
            break;
        case 2:
            display_enum<uint16_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem, enum_);
            break;
        case 4:
            display_enum<uint32_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem, enum_);
            break;
        case 8:
            display_enum<uint64_t>(m_display_str, m_var->bit_size(), m_var->bit_offset(), mem, enum_);
            break;
        }
    }
}

template <typename T>
void handle_write(Process& process, size_t num_bits, uintptr_t offset, uintptr_t address, std::byte* mem) {
    T mask{};
    auto data = *(T*)mem;
    auto start = offset;
    auto end = offset + num_bits;

    for (auto i = start; i < end; ++i) {
        mask |= 1ull << i;
    }

    data &= mask;
    data >>= start;
    auto value = *(T*)mem;
    ImGuiDataType datatype;

    if constexpr (std::is_same_v<T, uint8_t> || std::is_same_v<T, bool>) {
        datatype = ImGuiDataType_U8;
    } else if constexpr (std::is_same_v<T, uint16_t>) {
        datatype = ImGuiDataType_U16;
    } else if constexpr (std::is_same_v<T, uint32_t>) {
        datatype = ImGuiDataType_U32;
    } else if constexpr (std::is_same_v<T, uint64_t>) {
        datatype = ImGuiDataType_U64;
    } else if constexpr (std::is_same_v<T, int8_t>) {
        datatype = ImGuiDataType_S8;
    } else if constexpr (std::is_same_v<T, int16_t>) {
        datatype = ImGuiDataType_S16;
    } else if constexpr (std::is_same_v<T, int32_t>) {
        datatype = ImGuiDataType_S32;
    } else if constexpr (std::is_same_v<T, int64_t>) {
        datatype = ImGuiDataType_S64;
    }

    if (ImGui::InputScalar(
            "Value", datatype, (void*)&data, nullptr, nullptr, nullptr, ImGuiInputTextFlags_EnterReturnsTrue)) {
        value &= ~mask;
        value |= (data << start) & mask;
        process.write(address, (const void*)&value, sizeof(T));

        // Write it back to the mem so the next frame it displays the new value (if user hit enter).
        *(T*)mem = value;
    }
}

void Bitfield::write_display(uintptr_t address, std::byte* mem) {
    switch (m_var->type()->size()) {
    case 1:
        handle_write<uint8_t>(m_process, m_var->bit_size(), m_var->bit_offset(), address, mem);
        break;
    case 2:
        handle_write<uint16_t>(m_process, m_var->bit_size(), m_var->bit_offset(), address, mem);
        break;
    case 4:
        handle_write<uint32_t>(m_process, m_var->bit_size(), m_var->bit_offset(), address, mem);
        break;
    case 8:
        handle_write<uint64_t>(m_process, m_var->bit_size(), m_var->bit_offset(), address, mem);
        break;
    default:
        assert(0);
    }
}
} // namespace node
```

`src/node/Bitfield.hpp`:

```hpp
#pragma once

#include <map>

#include "Variable.hpp"

namespace node {
class Bitfield : public Variable {
public:
    Bitfield(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props);

    void display(uintptr_t address, uintptr_t offset, std::byte* mem) override;
    void update(uintptr_t address, uintptr_t offset, std::byte* mem) override;

private:
    std::string m_display_str{};

    void write_display(uintptr_t address, std::byte* mem);
};
} // namespace node
```

`src/node/Pointer.cpp`:

```cpp
#include <fmt/format.h>
#include <imgui.h>
#include <utf8.h>

#include "Array.hpp"
#include "Struct.hpp"

#include "Pointer.hpp"

using namespace std::literals;

namespace node {
void Pointer::display_str(std::string& s, const std::string& str) {
    s += "\"";

    for (auto&& c : str) {
        if (c == 0) {
            break;
        }

        s += c;
    }

    s += "\" ";
}

Pointer::Pointer(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props)
    : Variable{cfg, process, var, props} {
    m_ptr = dynamic_cast<sdkgenny::Pointer*>(m_var->type());
    assert(m_ptr != nullptr);

    m_props["__collapsed"].set_default(true);
    m_props["__array"].set_default(false);
    m_props["__count"].set_default(1);

    // Make sure the array count is never < 1 (can happen if the node was previously an array node or a user hand-edited
    // the props).
    if (array_count() < 1) {
        array_count() = 1;
    }
}

void Pointer::display(uintptr_t address, uintptr_t offset, std::byte* mem) {
    if (indentation_level >= 0) {
        display_address_offset(address, offset);
        ImGui::SameLine();
        ImGui::BeginGroup();
        display_type();
        ImGui::SameLine();
        display_name();
        ImGui::SameLine();
        // ImGui::Text("%p", *(uintptr_t*)mem);
        ImGui::PushStyleColor(ImGuiCol_Text, {0.6f, 0.6f, 0.6f, 1.0f});
        ImGui::TextUnformatted(m_address_str.c_str());
        ImGui::PopStyleColor();

        if (!m_value_str.empty()) {
            ImGui::SameLine();
            ImGui::PushStyleColor(ImGuiCol_Text, {181.0f / 255.0f, 206.0f / 255.0f, 168.0f / 255.0f, 1.0f});
            ImGui::TextUnformatted(m_value_str.c_str());
            ImGui::PopStyleColor();
        }

        ImGui::EndGroup();

        if (ImGui::IsItemClicked()) {
            is_collapsed() = !is_collapsed();
        }

        m_is_hovered = ImGui::IsItemHovered();

        if (ImGui::BeginPopupContextItem("PointerNode")) {
            if (ImGui::Checkbox("Is Array", &is_array())) {
                m_ptr_node = nullptr;
            }

            if (is_array()) {
                if (ImGui::InputInt("Array Count", &array_count())) {
                    if (array_count() < 1) {
                        array_count() = 1;
                    }

                    m_ptr_node = nullptr;
                }
            }

            ImGui::EndPopup();
        }

        if (is_collapsed() && !m_is_hovered) {
            return;
        }
    }

    auto pointed_to_address = *(uintptr_t*)mem;

    if (pointed_to_address != m_address) {
        m_address = pointed_to_address;
    }

    // We create the node here right before displaying it to avoid pointer loop crashes. Only nodes that are uncollapsed
    // get created.
    if (m_ptr_node == nullptr) {
        auto&& var_name = m_var->name();
        auto&& props = m_props[var_name];

        if (is_array()) {
            m_proxy_var = std::make_unique<sdkgenny::Variable>(var_name);
            m_proxy_var->type(m_ptr->to()->array_(array_count()));
            m_ptr_node = std::make_unique<Array>(m_cfg, m_process, m_proxy_var.get(), props);
        } else {
            m_proxy_var = std::make_unique<sdkgenny::Variable>(var_name);
            m_proxy_var->type(m_ptr->to());

            if (m_ptr->to()->is_a<sdkgenny::Struct>()) {
                auto struct_ = std::make_unique<Struct>(m_cfg, m_process, m_proxy_var.get(), props);
                struct_->display_self(false)->is_collapsed(false);
                m_ptr_node = std::move(struct_);
            } else if (m_ptr->to()->is_a<sdkgenny::Pointer>()) {
                m_ptr_node = std::make_unique<Pointer>(m_cfg, m_process, m_proxy_var.get(), props);
            } else {
                m_ptr_node = std::make_unique<Variable>(m_cfg, m_process, m_proxy_var.get(), props);
            }
        }
    }

    refresh_memory();

    // This can happen if the type pointed to is empty. For example if the user has just created the type in the editor
    // and the memory ui has been refreshed.
    if (m_mem.empty()) {
        return;
    }

    auto show_tooltip = is_collapsed() && m_is_hovered;
    auto backup_indentation_level = indentation_level;

    if (show_tooltip) {
        ImGui::BeginTooltip();
        indentation_level = 0;
    } else {
        ++indentation_level;
    }

    ImGui::PushID(m_ptr_node.get());
    m_ptr_node->display(m_address, 0, &m_mem[0]);
    ImGui::PopID();

    if (show_tooltip) {
        ImGui::EndTooltip();
    }

    indentation_level = backup_indentation_level;
}

void Pointer::update(uintptr_t address, uintptr_t offset, std::byte* mem) {
    Base::update(address, offset, mem);
    m_value_str.clear();
    m_address_str.clear();

    for (auto&& md : m_var->metadata()) {
        if (md == "utf8*") {
            m_utf8.resize(256);
            m_process.read(*(uintptr_t*)mem, m_utf8.data(), 255 * sizeof(char));
            display_str(m_value_str, m_utf8);
        } else if (md == "utf16*") {
            m_utf16.resize(256);
            m_process.read(*(uintptr_t*)mem, m_utf16.data(), 255 * sizeof(char16_t));

            m_utf16.back() = L'\0';

            // if we don't do this then utf16to8 will throw an exception.
            // todo: do for utf32?
            const auto real_len = wcslen((wchar_t*)m_utf16.data());
            m_utf16.resize(real_len);

            std::string utf8conv{};

            try {
                utf8conv = utf8::utf16to8(m_utf16);
            } catch (utf8::invalid_utf16& e) {
                utf8conv = e.what();
            }

            display_str(m_value_str, utf8conv);
        } else if (md == "utf32*") {
            m_utf32.resize(256);
            m_process.read(*(uintptr_t*)mem, m_utf32.data(), 255 * sizeof(char32_t));

            std::string utf32conv{};

            try {
                utf32conv = utf8::utf32to8(m_utf32);
            } catch (utf8::invalid_utf16& e) {
                utf32conv = e.what();
            }

            display_str(m_value_str, utf32conv);
        }
    }

    auto addr = *(uintptr_t*)mem;

    // RTTI
    if (auto tn = m_process.get_typename(addr); tn) {
        fmt::format_to(std::back_inserter(m_address_str), "obj*:{:s} ", *tn);
    }

    for (auto&& mod : m_process.modules()) {
        if (mod.start <= addr && addr <= mod.end) {
            fmt::format_to(std::back_inserter(m_address_str), "<{}>+0x{:X}", mod.name, addr - mod.start);
            // Bail here so we don't try previewing this pointer as something else.
            return;
        }
    }

    for (auto&& allocation : m_process.allocations()) {
        if (allocation.start <= addr && addr <= allocation.end) {
            fmt::format_to(std::back_inserter(m_address_str), "0x{:X}", addr);
            // Bail here so we don't try previewing this pointer as something else.
            return;
        }
    }
}

void Pointer::refresh_memory() {
    if ((is_collapsed() && !m_is_hovered) || m_ptr->to()->size() == 0) {
        return;
    }

    if (auto now = std::chrono::steady_clock::now(); now >= m_mem_refresh_time) {
        m_mem_refresh_time = now + std::chrono::milliseconds(m_cfg.refresh_rate);

        // Make sure our memory buffer is large enough (since the first refresh it wont be).
        m_mem.resize(m_ptr->to()->size() * array_count());
        m_process.read(m_address, m_mem.data(), m_mem.size());
        m_ptr_node->update(m_address, 0, &m_mem[0]);
    }
}
} // namespace node
```

`src/node/Pointer.hpp`:

```hpp
#pragma once

#include <chrono>

#include "../Process.hpp"
#include "Variable.hpp"

namespace node {
class Pointer : public Variable {
public:
    Pointer(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props);

    void display(uintptr_t address, uintptr_t offset, std::byte* mem) override;
    void update(uintptr_t address, uintptr_t offset, std::byte* mem) override;

    auto is_collapsed(bool is_collapsed) {
        m_props["__collapsed"].set(is_collapsed);
        return this;
    }
    auto& is_collapsed() { return m_props["__collapsed"].as_bool(); }

    auto is_array(bool is_array) {
        m_props["__array"].set(is_array);
        return this;
    }
    auto& is_array() { return m_props["__array"].as_bool(); }

    auto array_count(int count) {
        m_props["__count"].set(count);
        return this;
    }
    auto& array_count() { return m_props["__count"].as_int(); }

protected:
    sdkgenny::Pointer* m_ptr{};
    std::vector<std::byte> m_mem{};
    std::chrono::steady_clock::time_point m_mem_refresh_time{};
    uintptr_t m_address{};

    std::unique_ptr<Base> m_ptr_node{};
    std::unique_ptr<sdkgenny::Variable> m_proxy_var{};

    std::string m_value_str{};
    std::string m_address_str{};

    bool m_is_hovered{};

    void refresh_memory();

    static void display_str(std::string& s, const std::string& str);
};
} // namespace node
```

`src/node/Property.hpp`:

```hpp
#pragma once

#include <string>
#include <unordered_map>
#include <variant>

namespace node {
struct Property {
    std::variant<std::monostate, bool, int> value{};
    std::variant<std::monostate, bool, int> default_value{};
    std::unordered_map<std::string, Property> props{};

    Property* find(const std::string& s) {
        if (auto search = props.find(s); search != props.end()) {
            return &search->second;
        }

        return nullptr;
    }

    Property& operator[](const std::string& s) { return props[s]; }

    template <typename T> void set(T val) { value = val; }

    template <typename T> void set_default(T val) {
        if (value.index() == 0) {
            value = val;
        }

        default_value = val;
    }

    bool& as_bool() { return std::get<bool>(value); }
    int& as_int() { return std::get<int>(value); }
};
} // namespace node
```

`src/node/Struct.cpp`:

```cpp
#include <fmt/format.h>
#include <imgui.h>

#include "Array.hpp"
#include "Bitfield.hpp"
#include "Pointer.hpp"
#include "Undefined.hpp"
#include "UndefinedBitfield.hpp"

#include "Struct.hpp"

namespace node {
Struct::Struct(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props)
    : Variable{cfg, process, var, props}, m_struct{dynamic_cast<sdkgenny::Struct*>(var->type())} {
    assert(m_struct != nullptr);

    m_props["__collapsed"].set_default(true);

    std::set<uintptr_t> bitfield_offsets{};

    // Build the node map.
    auto make_node = [&](sdkgenny::Variable* var) -> std::unique_ptr<Base> {
        auto&& props = m_props[var->name()];

        if (var->type()->is_a<sdkgenny::Array>()) {
            return std::make_unique<Array>(m_cfg, m_process, var, props);
        } else if (var->type()->is_a<sdkgenny::Struct>()) {
            return std::make_unique<Struct>(m_cfg, m_process, var, props);
        } else if (var->type()->is_a<sdkgenny::Pointer>()) {
            return std::make_unique<Pointer>(m_cfg, m_process, var, props);
        } else if (var->is_bitfield()) {
            return std::make_unique<Bitfield>(m_cfg, m_process, var, props);
        } else {
            return std::make_unique<Variable>(m_cfg, m_process, var, props);
        }
    };
    std::function<void(uintptr_t, sdkgenny::Struct*)> add_vars = [&](uintptr_t offset, sdkgenny::Struct* s) {
        auto parent_offset = offset;

        for (auto&& parent : s->parents()) {
            add_vars(parent_offset, parent);
            parent_offset += parent->size();
        }

        for (auto&& var : s->get_all<sdkgenny::Variable>()) {
            if (var->is_bitfield()) {
                bitfield_offsets.emplace(offset + var->offset());
            } else {
                m_nodes.emplace(offset + var->offset(), make_node(var));
            }
        }
    };

    add_vars(0, m_struct);

    // Fill in all the bitfields (padding becomes UndefinedBitfield nodes).
    for (auto offset : bitfield_offsets) {
        auto last_bit = 0;
        sdkgenny::Type* bitfield_type = nullptr;

        for (auto&& [bit_offset, var] : m_struct->bitfield(offset)) {
            if (bit_offset - last_bit > 0) {
                auto& props = m_props[fmt::format("pad_bitfield__{:x}_{:x}", offset, last_bit)];
                m_nodes.emplace(offset, std::make_unique<UndefinedBitfield>(
                                            m_cfg, m_process, props, var->size(), bit_offset - last_bit, last_bit));
            }

            m_nodes.emplace(offset, make_node(var));

            last_bit = bit_offset + var->bit_size();
            bitfield_type = var->type();
        }

        auto num_bits = bitfield_type->size() * CHAR_BIT;

        if (last_bit != num_bits) {
            auto bit_offset = num_bits;
            auto& props = m_props[fmt::format("pad_bitfield__{:x}_{:x}", offset, last_bit)];
            m_nodes.emplace(offset, std::make_unique<UndefinedBitfield>(m_cfg, m_process, props, bitfield_type->size(),
                                        bit_offset - last_bit, last_bit));
        }
    }

    // Fill in the rest of the offsets with undefined nodes.
    if (!m_nodes.empty()) {
        for (auto i = m_nodes.begin(), j = std::next(m_nodes.begin()); j != m_nodes.end(); i = j++) {
            auto last_offset = i->first + i->second->size();
            auto delta = j->first - last_offset;

            fill_space(last_offset, delta);
        }

        // Fill in the end.
        auto last_node = m_nodes.rbegin();
        auto last_offset = last_node->first + last_node->second->size();
        auto delta = m_size - last_offset;

        fill_space(last_offset, delta);
    } else {
        fill_space(0, m_size);
    }
}

void Struct::display(uintptr_t address, uintptr_t offset, std::byte* mem) {
    if (m_display_self) {
        display_address_offset(address, offset);
        ImGui::SameLine();
        ImGui::BeginGroup();
        display_type();
        ImGui::SameLine();
        display_name();
        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Text, {0.6f, 0.6f, 0.6f, 1.0f});
        ImGui::TextUnformatted(m_display_str.c_str());
        ImGui::PopStyleColor();
        ImGui::EndGroup();

        if (ImGui::IsItemClicked()) {
            is_collapsed() = !is_collapsed();
        }

        m_is_hovered = ImGui::IsItemHovered();

        if (is_collapsed() && !m_is_hovered) {
            return;
        }
    }

    auto show_tooltip = is_collapsed() && m_is_hovered;

    if (show_tooltip) {
        ImGui::BeginTooltip();
    }

    auto it = m_nodes.begin();

    for (uintptr_t node_offset = 0; node_offset < m_size;) {
        // Advance the iterator until the next node >= the current node_offset.
        for (; it != m_nodes.end() && it->first < node_offset; ++it) {
        }

        if (it == m_nodes.end()) {
            fill_space(node_offset, m_size - node_offset);
            it = m_nodes.find(node_offset);
        }

        if (node_offset != it->first) {
            // Advance until the next non-undefined node.
            for (; it != m_nodes.end() && dynamic_cast<Undefined*>(it->second.get()); ++it) {
            }

            // Fill in the space.
            if (it != m_nodes.end()) {
                auto delta = it->first - node_offset;
                fill_space(node_offset, delta);
            } else {
                fill_space(node_offset, m_size - node_offset);
            }

            // There will now be a node where @ node_offset.
            it = m_nodes.find(node_offset);
        }

        // Display all nodes @ this offset (more than 1 indicates a bitfield).
        size_t node_size{};

        for (; it != m_nodes.end() && it->first == node_offset; ++it) {
            auto backup_indentation_level = indentation_level;

            if (show_tooltip) {
                indentation_level = 0;
            } else if (m_display_self) {
                ++indentation_level;
            }

            auto& node = it->second;

            ImGui::PushID(node.get());
            node->display(address + node_offset, offset + node_offset, &mem[node_offset]);
            ImGui::PopID();

            indentation_level = backup_indentation_level;
            node_size = node->size();
        }

        node_offset += node_size;
    }

    if (show_tooltip) {
        ImGui::EndTooltip();
    }
}

void Struct::update(uintptr_t address, uintptr_t offset, std::byte* mem) {
    Base::update(address, offset, mem);
    m_display_str.clear();

    // RTTI
    if (auto tn = m_process.get_typename(address); tn) {
        fmt::format_to(std::back_inserter(m_display_str), "obj:{:s} ", *tn);
    }

    if (is_collapsed() && !m_is_hovered) {
        return;
    }

    for (auto&& [node_offset, node] : m_nodes) {
        node->update(address + node_offset, offset + node_offset, &mem[node_offset]);
    }
}

void Struct::fill_space(uintptr_t last_offset, int delta) {
    auto add_undefined = [this](int offset, int size) {
        // Delete nodes that are will be overwritten by the undefined node we are going to add.
        for (auto i = offset; i < offset + size; ++i) {
            m_nodes.erase(i);
        }

        auto& props = m_props[fmt::format("undefined_{:x}", offset)];
        m_nodes.emplace(offset, std::make_unique<Undefined>(m_cfg, m_process, props, size));
    };

    auto start = last_offset;
    auto end = last_offset + delta;

    for (auto offset = start; offset <= end; ++offset) {
        if (offset % sizeof(uintptr_t) == 0 || offset == end) {
            switch (offset - last_offset) {
            case 8:
                add_undefined(last_offset, 8);
                break;

            case 7:
                add_undefined(last_offset, 4);
                add_undefined(last_offset + 4, 2);
                add_undefined(last_offset + 6, 1);
                break;

            case 6:
                add_undefined(last_offset, 4);
                add_undefined(last_offset + 4, 2);
                break;

            case 5:
                add_undefined(last_offset, 4);
                add_undefined(last_offset + 4, 1);
                break;

            case 4:
                add_undefined(last_offset, 4);
                break;

            case 3:
                add_undefined(last_offset, 2);
                add_undefined(last_offset + 2, 1);
                break;

            case 2:
                add_undefined(last_offset, 2);
                break;

            case 1:
                add_undefined(last_offset, 1);
                break;

            default:
                break;
            }

            last_offset = offset;
        }
    }
}
} // namespace node

```

`src/node/Struct.hpp`:

```hpp
#pragma once

#include <map>

#include "Variable.hpp"

namespace node {
class Struct : public Variable {
public:
    Struct(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props);

    void display(uintptr_t address, uintptr_t offset, std::byte* mem) override;
    void update(uintptr_t address, uintptr_t offset, std::byte* mem) override;

    auto is_collapsed(bool is_collapsed) {
        m_props["__collapsed"].set(is_collapsed);
        return this;
    }
    auto& is_collapsed() { return m_props["__collapsed"].as_bool(); }

    auto display_self(bool display_self) {
        m_display_self = display_self;
        return this;
    }
    auto display_self() const { return m_display_self; }

private:
    bool m_display_self{true};
    sdkgenny::Struct* m_struct{};
    std::multimap<uintptr_t, std::unique_ptr<Base>> m_nodes{};
    bool m_is_hovered{};
    std::string m_display_str{};

    void fill_space(uintptr_t last_offset, int delta);
};

} // namespace node
```

`src/node/Undefined.cpp`:

```cpp
#include <fmt/format.h>
#include <imgui.h>

#include "Pointer.hpp"

#include "Undefined.hpp"

namespace node {
static sdkgenny::Namespace g_preview_ns{""};
static sdkgenny::Variable g_preview_ptr{"preview_ptr"};
static Property g_preview_props{};
static std::unique_ptr<Pointer> g_preview_node{};
static Process* g_preview_node_process{};
bool Undefined::is_hidden{};

Undefined::Undefined(Config& cfg, Process& process, Property& props, size_t size)
    : Base{cfg, process, props}, m_size{size}, m_original_size{size} {
    m_props["__size"].set_default(0);

    // If our inherited size_override isn't 0 we apply the override now.
    if (size_override() != 0) {
        m_size = size_override();
    }

    if (g_preview_node == nullptr || g_preview_node_process != &process) {
        auto preview_struct = g_preview_ns.struct_("preview")->size(sizeof(uintptr_t) * 16);
        g_preview_ptr.type(preview_struct->ptr());
        g_preview_node = std::make_unique<Pointer>(m_cfg, process, &g_preview_ptr, g_preview_props);
        g_preview_node->is_collapsed() = false;
        g_preview_node_process = &process;
    }
}

void Undefined::display(uintptr_t address, uintptr_t offset, std::byte* mem) {
    if (is_hidden) {
        return;
    }

    // Normal unsplit display.
    display_address_offset(address, offset);
    ImGui::SameLine();
    ImGui::BeginGroup();
    ImGui::TextUnformatted(m_bytes_str.c_str());
    ImGui::SameLine();
    ImGui::TextColored({0.6f, 0.6f, 0.6f, 1.0f}, "%s", m_preview_str.c_str());
    ImGui::EndGroup();

    auto is_hovered = ImGui::IsItemHovered();

    if (ImGui::BeginPopupContextItem("UndefinedNodes")) {
        if (ImGui::InputInt("Size Override", &size_override())) {
            size_override() = std::clamp(size_override(), 0, 8);

            if (size_override() == 0) {
                m_size = m_original_size;
            } else {
                m_size = size_override();
            }
        }

        ImGui::EndPopup();
    }

    if (is_hovered && m_is_pointer) {
        auto backup_indentation_level = indentation_level;

        ImGui::BeginTooltip();
        indentation_level = -1;
        g_preview_node->display(*(uintptr_t*)mem, 0, &mem[0]);
        ImGui::EndTooltip();

        indentation_level = backup_indentation_level;
    }
}

size_t Undefined::size() {
    return m_size;
}

void Undefined::update(uintptr_t address, uintptr_t offset, std::byte* mem) {
    Base::update(address, offset, mem);

    m_is_pointer = false;

    // Normal unsplit refresh.
    m_bytes_str.clear();
    m_preview_str.clear();

    for (auto i = 0; i < m_size; ++i) {
        fmt::format_to(std::back_inserter(m_bytes_str), "{:02X}", *(uint8_t*)&mem[i]);
    }

    if (m_size == sizeof(uintptr_t)) {
        auto addr = *(uintptr_t*)mem;

        // RTTI
        if (auto tn = m_process.get_typename(address); tn) {
            fmt::format_to(std::back_inserter(m_preview_str), "obj:{:s} ", *tn);
        }

        if (auto tn = m_process.get_typename(addr); tn) {
            fmt::format_to(std::back_inserter(m_preview_str), "obj*:{:s} ", *tn);
        }

        for (auto&& mod : m_process.modules()) {
            if (mod.start <= addr && addr <= mod.end) {
                fmt::format_to(std::back_inserter(m_preview_str), "<{}>+0x{:X} ", mod.name, addr - mod.start);
                m_is_pointer = true;
            }
        }

        for (auto&& allocation : m_process.allocations()) {
            if (allocation.start <= addr && addr <= allocation.end) {
                fmt::format_to(std::back_inserter(m_preview_str), "heap:0x{:X} ", addr);
                m_is_pointer = true;
            }
        }

        if (m_is_pointer) {
            // See if it looks like its pointing to a string.
            static std::string str{};
            str.resize(256);
            m_process.read(addr, str.data(), 255 * sizeof(char));
            str.resize(std::min<size_t>(256, strlen(str.data())));

            auto is_str = true;

            for (auto&& c : str) {
                if (!isprint((uint8_t)c)) {
                    is_str = false;
                    break;
                }
            }

            if (is_str) {
                fmt::format_to(std::back_inserter(m_preview_str), "\"{}\" ", str);
            }

            // Bail here so we don't try previewing this pointer as something else.
            return;
        }
    }

    switch (m_size) {
    case 8:
        fmt::format_to(std::back_inserter(m_preview_str), "i64:{} f64:{}", *(int64_t*)mem, *(double*)mem);
        break;
    case 4:
        fmt::format_to(std::back_inserter(m_preview_str), "i32:{} f32:{}", *(int32_t*)mem, *(float*)mem);
        break;
    case 2:
        fmt::format_to(std::back_inserter(m_preview_str), "i16:{}", *(int16_t*)mem);
        break;
    case 1: {
        auto val = *(int8_t*)mem;
        fmt::format_to(std::back_inserter(m_preview_str), "i8:{}", val);

        if (0x20 <= val && val <= 0x7E) {
            fmt::format_to(std::back_inserter(m_preview_str), " '{}'", (char)val);
        }
    } break;
    }
}
} // namespace node
```

`src/node/Undefined.hpp`:

```hpp
#pragma once

#include "Base.hpp"

namespace node {
class Undefined : public Base {
public:
    static bool is_hidden;

    Undefined(Config& cfg, Process& process, Property& props, size_t size);

    void display(uintptr_t address, uintptr_t offset, std::byte* mem) override;
    size_t size() override;
    void update(uintptr_t address, uintptr_t offset, std::byte* mem) override;

    auto size_override(int size) {
        m_props["__size"].set(size);
        return this;
    }
    auto& size_override() { return m_props["__size"].as_int(); }

protected:
    size_t m_size{};
    size_t m_original_size{};
    std::string m_bytes_str{};
    std::string m_preview_str{};
    bool m_is_pointer{};
};
} // namespace node
```

`src/node/UndefinedBitfield.cpp`:

```cpp
#include <fmt/format.h>
#include <imgui.h>

#include "UndefinedBitfield.hpp"

namespace node {
template <typename T> void display_bits(std::string& s, size_t num_bits, uintptr_t offset, std::byte* mem) {
    s += "0b";

    auto data = *(T*)mem;
    auto start = (int)offset;
    auto end = (int)(offset + num_bits);

    for (auto i = end - 1; i >= start; --i) {
        if (data >> i & 1) {
            s += "1";
        } else {
            s += "0";
        }
    }
}

UndefinedBitfield::UndefinedBitfield(
    Config& cfg, Process& process, Property& props, size_t size, size_t bit_size, size_t bit_offset)
    : Base{cfg, process, props}, m_size{size}, m_bit_size{bit_size}, m_bit_offset{bit_offset} {
}

void UndefinedBitfield::display(uintptr_t address, uintptr_t offset, std::byte* mem) {
    display_address_offset(address, offset);
    ImGui::SameLine();
    ImGui::TextColored({0.6f, 0.6f, 0.6f, 1.0f}, "%s", m_display_str.c_str());
}

void UndefinedBitfield::update(uintptr_t address, uintptr_t offset, std::byte* mem) {
    Base::update(address, offset, mem);
    m_display_str.clear();

    switch (m_size) {
    case 1:
        display_bits<uint8_t>(m_display_str, m_bit_size, m_bit_offset, mem);
        break;
    case 2:
        display_bits<uint16_t>(m_display_str, m_bit_size, m_bit_offset, mem);
        break;
    case 4:
        display_bits<uint32_t>(m_display_str, m_bit_size, m_bit_offset, mem);
        break;
    case 8:
        display_bits<uint64_t>(m_display_str, m_bit_size, m_bit_offset, mem);
        break;
    default:
        assert(0);
    }
}

} // namespace node
```

`src/node/UndefinedBitfield.hpp`:

```hpp
#pragma once

#include "Base.hpp"

namespace node {
class UndefinedBitfield : public Base {
public:
    UndefinedBitfield(Config& cfg, Process& process, Property& props, size_t size, size_t bit_size, size_t bit_offset);

    void display(uintptr_t address, uintptr_t offset, std::byte* mem) override;
    size_t size() override { return m_size; }
    void update(uintptr_t address, uintptr_t offset, std::byte* mem) override;

protected:
    size_t m_size{};
    size_t m_bit_size{};
    size_t m_bit_offset{};
    std::string m_display_str{};
};
} // namespace node
```

`src/node/Variable.cpp`:

```cpp
#include <array>

#include <fmt/format.h>
#include <imgui.h>
#include <utf8.h>

#include "Variable.hpp"

namespace node {
template <typename T> void display_as(std::string& s, std::byte* mem) {
    fmt::format_to(std::back_inserter(s), "{} ", *(T*)mem);
}

static void display_str(std::string& s, const std::string& str) {
    s += "\"";

    for (auto&& c : str) {
        if (c == 0) {
            break;
        }

        s += c;
    }

    s += "\" ";
}

template <typename T> void display_enum(std::string& s, std::byte* mem, sdkgenny::Enum* enum_) {
    auto val = *(T*)mem;
    auto val_found = false;

    for (auto&& [val_name, val_val] : enum_->values()) {
        if (val_val == val) {
            s += ' ' + val_name;
            val_found = true;
            break;
        }
    }

    if (!val_found) {
        display_as<T>(s, mem);
    }
}

Variable::Variable(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props)
    : Base{cfg, process, props}, m_var{var}, m_size{var->size()} {
}

void Variable::display_type() {
    ImGui::TextColored({0.6f, 0.6f, 1.0f, 1.0f}, "%s", m_var->type()->name().c_str());
}

void Variable::display_name() {
    ImGui::TextUnformatted(m_var->name().c_str());
}

void Variable::display(uintptr_t address, uintptr_t offset, std::byte* mem) {
    display_address_offset(address, offset);
    ImGui::SameLine();
    ImGui::BeginGroup();
    display_type();
    ImGui::SameLine();
    display_name();
    ImGui::SameLine();
    ImGui::PushStyleColor(ImGuiCol_Text, {181.0f / 255.0f, 206.0f / 255.0f, 168.0f / 255.0f, 1.0f});
    ImGui::TextUnformatted(m_value_str.c_str());
    ImGui::PopStyleColor();
    ImGui::EndGroup();

    if (ImGui::BeginPopupContextItem("VariableNodes")) {
        write_display(address, mem);
        ImGui::EndPopup();
    }
}

size_t Variable::size() {
    return m_size;
}

void Variable::update(uintptr_t address, uintptr_t offset, std::byte* mem) {
    Base::update(address, offset, mem);

    m_value_str.clear();

    std::array<std::vector<std::string>*, 2> metadatas{&m_var->metadata(), &m_var->type()->metadata()};

    for (auto&& metadata : metadatas) {
        for (auto&& md : *metadata) {
            if (md == "u8") {
                display_as<uint8_t>(m_value_str, mem);
            } else if (md == "u16") {
                display_as<uint16_t>(m_value_str, mem);
            } else if (md == "u32") {
                display_as<uint32_t>(m_value_str, mem);
            } else if (md == "u64") {
                display_as<uint64_t>(m_value_str, mem);
            } else if (md == "i8") {
                display_as<int8_t>(m_value_str, mem);
            } else if (md == "i16") {
                display_as<int16_t>(m_value_str, mem);
            } else if (md == "i32") {
                display_as<int32_t>(m_value_str, mem);
            } else if (md == "i64") {
                display_as<int64_t>(m_value_str, mem);
            } else if (md == "f32") {
                display_as<float>(m_value_str, mem);
            } else if (md == "f64") {
                display_as<double>(m_value_str, mem);
            } else if (md == "utf8*") {
                m_utf8.resize(256);
                m_process.read(*(uintptr_t*)mem, m_utf8.data(), 255 * sizeof(char));
                display_str(m_value_str, m_utf8);
            } else if (md == "utf16*") {
                m_utf16.resize(256);
                m_process.read(*(uintptr_t*)mem, m_utf16.data(), 255 * sizeof(char16_t));

                m_utf16.back() = L'\0';

                // if we don't do this then utf16to8 will throw an exception.
                // todo: do for utf32?
                const auto real_len = wcslen((wchar_t*)m_utf16.data());
                m_utf16.resize(real_len);

                std::string utf8conv{};

                try {
                    utf8conv = utf8::utf16to8(m_utf16);
                } catch (utf8::invalid_utf16& e) {
                    utf8conv = e.what();
                }

                display_str(m_value_str, utf8conv);
            } else if (md == "utf32*") {
                m_utf32.resize(256);
                m_process.read(*(uintptr_t*)mem, m_utf32.data(), 255 * sizeof(char32_t));

                std::string utf32conv{};

                try {
                    utf32conv = utf8::utf32to8(m_utf32);
                } catch (utf8::invalid_utf16& e) {
                    utf32conv = e.what();
                }

                display_str(m_value_str, utf32conv);
            } else if (md == "bool") {
                if (*(bool*)mem) {
                    m_value_str += "true ";
                } else {
                    m_value_str += "false ";
                }
            }
        }
    }

    if (auto enum_ = dynamic_cast<sdkgenny::Enum*>(m_var->type())) {
        switch (m_size) {
        case 1:
            display_enum<uint8_t>(m_value_str, mem, enum_);
            break;
        case 2:
            display_enum<uint16_t>(m_value_str, mem, enum_);
            break;
        case 4:
            display_enum<uint32_t>(m_value_str, mem, enum_);
            break;
        case 8:
            display_enum<uint64_t>(m_value_str, mem, enum_);
            break;
        }
    }
}

template <typename T> void handle_write(Process& process, uintptr_t address, std::byte* mem) {
    auto value = *(T*)mem;
    ImGuiDataType datatype;

    if constexpr (std::is_same_v<T, uint8_t> || std::is_same_v<T, bool>) {
        datatype = ImGuiDataType_U8;
    } else if constexpr (std::is_same_v<T, uint16_t>) {
        datatype = ImGuiDataType_U16;
    } else if constexpr (std::is_same_v<T, uint32_t>) {
        datatype = ImGuiDataType_U32;
    } else if constexpr (std::is_same_v<T, uint64_t>) {
        datatype = ImGuiDataType_U64;
    } else if constexpr (std::is_same_v<T, int8_t>) {
        datatype = ImGuiDataType_S8;
    } else if constexpr (std::is_same_v<T, int16_t>) {
        datatype = ImGuiDataType_S16;
    } else if constexpr (std::is_same_v<T, int32_t>) {
        datatype = ImGuiDataType_S32;
    } else if constexpr (std::is_same_v<T, int64_t>) {
        datatype = ImGuiDataType_S64;
    } else if constexpr (std::is_same_v<T, float>) {
        datatype = ImGuiDataType_Float;
    } else if constexpr (std::is_same_v<T, double>) {
        datatype = ImGuiDataType_Double;
    }

    if (ImGui::InputScalar(
            "Value", datatype, (void*)&value, nullptr, nullptr, nullptr, ImGuiInputTextFlags_EnterReturnsTrue)) {
        process.write(address, (const void*)&value, sizeof(T));

        // Write it back to the mem so the next frame it displays the new value (if user hit enter).
        *(T*)mem = value;
    }
}

void Variable::write_display(uintptr_t address, std::byte* mem) {
    std::array<std::vector<std::string>*, 2> metadatas{&m_var->metadata(), &m_var->type()->metadata()};

    for (auto&& metadata : metadatas) {
        for (auto&& md : *metadata) {
            if (md == "u8") {
                handle_write<uint8_t>(m_process, address, mem);
            } else if (md == "u16") {
                handle_write<uint16_t>(m_process, address, mem);
            } else if (md == "u32") {
                handle_write<uint32_t>(m_process, address, mem);
            } else if (md == "u64") {
                handle_write<uint64_t>(m_process, address, mem);
            } else if (md == "i8") {
                handle_write<int8_t>(m_process, address, mem);
            } else if (md == "i16") {
                handle_write<int16_t>(m_process, address, mem);
            } else if (md == "i32") {
                handle_write<int32_t>(m_process, address, mem);
            } else if (md == "i64") {
                handle_write<int64_t>(m_process, address, mem);
            } else if (md == "f32") {
                handle_write<float>(m_process, address, mem);
            } else if (md == "f64") {
                handle_write<double>(m_process, address, mem);
            } else if (md == "bool") {
                handle_write<bool>(m_process, address, mem);
            } else {
                ImGui::Text("Unable to write to this data type");
            }
        }
    }
}
} // namespace node

```

`src/node/Variable.hpp`:

```hpp
#pragma once

#include <sdkgenny.hpp>

#include "Base.hpp"

namespace node {
class Variable : public Base {
public:
    Variable(Config& cfg, Process& process, sdkgenny::Variable* var, Property& props);

    virtual void display_type();
    virtual void display_name();
    void display(uintptr_t address, uintptr_t offset, std::byte* mem) override;
    size_t size() override;
    void update(uintptr_t address, uintptr_t offset, std::byte* mem) override;

protected:
    sdkgenny::Variable* m_var{};
    size_t m_size{};
    std::string m_value_str{};
    std::string m_utf8{};
    std::u16string m_utf16{};
    std::u32string m_utf32{};

    void write_display(uintptr_t address, std::byte* mem);
};
} // namespace node
```

`thirdparty/SDL_Trigger/sdl_trigger.cpp`:

```cpp
#include "sdl_trigger.h"
#include <iostream>
#include <algorithm>

namespace Trigger {

    std::vector<Group*> groups;
    Group globalGroup;

    bool KeyCombination::hasKey(SDL_Keycode key) const {
        for(size_t i = 0; i < keys.size(); i++) {
            if (keys[i].key == key) {
                return true;
            }
        }

        return false;
    }

    void KeyCombination::markKeyDown(SDL_Keycode key) {
        for(size_t i = 0; i < keys.size(); i++) {
            if (keys[i].key == key) {
                keys[i].isDown = true;
            }
        }
    }

    void KeyCombination::markKeyUp(SDL_Keycode key) {
        for(size_t i = 0; i < keys.size(); i++) {
            if (keys[i].key == key) {
                keys[i].isDown = false;
            }
        }
    }

    void KeyCombination::reset() {
        for(size_t i = 0; i < keys.size(); i++) {
            keys[i].isDown = false;
        }
    }

    bool KeyCombination::isFulfilled() const {
        for(size_t i = 0; i < keys.size(); i++) {
            if (!keys[i].isDown) {
                return false;
            }
        }

        return true;
    }

    Trigger::Trigger(Keycodes keys, Callback callback) : callback{callback} {
        for(const auto key : keys) {
            combination.keys.push_back({key, false});
        }
    }

    Group::Group() : triggers{}, isEnabled{true} {
        groups.push_back(this);
    }

    Group::~Group() {
        groups.erase(std::remove(groups.begin(), groups.end(), this));
    }

    void Group::enable() {
        isEnabled = true;
    }

    void Group::disable() {
        isEnabled = false;

        for (auto& trigger : triggers) {
            trigger.combination.reset();
        }
    }

    void Group::toggle() {
        if (isEnabled) {
            disable();
        } else {
            enable();
        }
    }

    void Group::on(SDL_Keycode key, Callback callback) {
        on(Keycodes{key}, callback);
    }

    void Group::on(Keycodes keys, Callback callback) {
        triggers.push_back(Trigger(keys, callback));
    }

    void Group::processEvent(SDL_Event& e) {
        SDL_Keycode key = e.key.keysym.sym;

        if (e.type == SDL_KEYDOWN && e.key.repeat == 0) {
            for (auto& trigger : triggers) {
                if (trigger.combination.hasKey(key)) {
                    trigger.combination.markKeyDown(key);
                } else {
                    trigger.combination.reset();
                }
            }

            for (auto& trigger : triggers) {
                if (trigger.combination.isFulfilled()) {
                    trigger.callback();
                }
            }
        } else if (e.type == SDL_KEYUP) {
            for (auto& trigger : triggers) {
                if (trigger.combination.hasKey(key)) {
                    trigger.combination.markKeyUp(key);
                }
            }
        }
    }

    void on(SDL_Keycode key, Callback callback) {
        on(Keycodes{key}, callback);
    }

    void on(Keycodes keys, Callback callback) {
        globalGroup.triggers.push_back(Trigger(keys, callback));
    }

    void processEvent(SDL_Event& e) {
        for (auto& group : groups) {
            if (group->isEnabled) {
                group->processEvent(e);
            }
        }
    }

} // namespace Trigger

```

`thirdparty/SDL_Trigger/sdl_trigger.h`:

```h
#ifndef SDL_TRIGGER_H
#define SDL_TRIGGER_H

#include "SDL2/SDL.h"
#include <functional>
#include <vector>

namespace Trigger {
    using Callback = std::function<void(void)>;
    using Keycodes = std::vector<SDL_Keycode>;

    struct KeyState {
        SDL_Keycode key;
        bool isDown;
    };

    struct KeyCombination {
        std::vector<KeyState> keys;

        bool hasKey(SDL_Keycode key) const;
        void markKeyDown(SDL_Keycode key);
        void markKeyUp(SDL_Keycode key);
        void reset();
        bool isFulfilled() const;
    };

    struct Trigger {
        KeyCombination combination;
        Callback callback;

        Trigger(Keycodes keys, Callback callback);
    };

    struct Group {
        std::vector<Trigger> triggers;
        bool isEnabled;

        Group();
        ~Group();

        void enable();
        void disable();
        void toggle();

        void on(SDL_Keycode key, Callback callback);
        void on(Keycodes keys, Callback callback);

        void processEvent(SDL_Event& e);
    };
    extern Group globalGroup;
    extern std::vector<Group*> groups;

    void on(SDL_Keycode key, Callback callback);
    void on(Keycodes keys, Callback callback);

    void processEvent(SDL_Event& e);
} // namespace Trigger

#endif /* SDL_TRIGGER_H */
```

`thirdparty/scope_gaurd/scope_guard.hpp`:

```hpp
/*
 *  Created on: 13/02/2018
 *      Author: ricab
 *
 * See README.md for documentation of this header's public interface.
 */

#ifndef SCOPE_GUARD_HPP_
#define SCOPE_GUARD_HPP_

#include <type_traits>
#include <utility>

#if __cplusplus >= 201703L && defined(SG_REQUIRE_NOEXCEPT_IN_CPP17)
#define SG_REQUIRE_NOEXCEPT
#endif

namespace sg
{
  namespace detail
  {
    /* --- Some custom type traits --- */

    // Type trait determining whether a type is callable with no arguments
    template<typename T, typename = void>
    struct is_noarg_callable_t
      : public std::false_type
    {}; // in general, false

    template<typename T>
    struct is_noarg_callable_t<T, decltype(std::declval<T&&>()())>
      : public std::true_type
    {}; // only true when call expression valid

    // Type trait determining whether a no-argument callable returns void
    template<typename T>
    struct returns_void_t
      : public std::is_same<void, decltype(std::declval<T&&>()())>
    {};

    /* Type trait determining whether a no-arg callable is nothrow invocable if
    required. This is where SG_REQUIRE_NOEXCEPT logic is encapsulated. */
    template<typename T>
    struct is_nothrow_invocable_if_required_t
      : public
#ifdef SG_REQUIRE_NOEXCEPT
          std::is_nothrow_invocable<T> /* Note: _r variants not enough to
                                          confirm void return: any return can be
                                          discarded so all returns are
                                          compatible with void */
#else
          std::true_type
#endif
    {};

    // logic AND of two or more type traits
    template<typename A, typename B, typename... C>
    struct and_t : public and_t<A, and_t<B, C...>>
    {}; // for more than two arguments

    template<typename A, typename B>
    struct and_t<A, B> : public std::conditional<A::value, B, A>::type
    {}; // for two arguments

    // Type trait determining whether a type is a proper scope_guard callback.
    template<typename T>
    struct is_proper_sg_callback_t
      : public and_t<is_noarg_callable_t<T>,
                     returns_void_t<T>,
                     is_nothrow_invocable_if_required_t<T>,
                     std::is_nothrow_destructible<T>>
    {};


    /* --- The actual scope_guard template --- */

    template<typename Callback,
             typename = typename std::enable_if<
               is_proper_sg_callback_t<Callback>::value>::type>
    class scope_guard;


    /* --- Now the friend maker --- */

    template<typename Callback>
    detail::scope_guard<Callback> make_scope_guard(Callback&& callback)
    noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value); /*
    we need this in the inner namespace due to MSVC bugs preventing
    sg::detail::scope_guard from befriending a sg::make_scope_guard
    template instance in the parent namespace (see https://is.gd/xFfFhE). */


    /* --- The template specialization that actually defines the class --- */

    template<typename Callback>
    class scope_guard<Callback> final
    {
    public:
      typedef Callback callback_type;

      scope_guard(scope_guard&& other)
      noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);

      ~scope_guard() noexcept; // highlight noexcept dtor

      void dismiss() noexcept;

    public:
      scope_guard() = delete;
      scope_guard(const scope_guard&) = delete;
      scope_guard& operator=(const scope_guard&) = delete;
      scope_guard& operator=(scope_guard&&) = delete;

    private:
      explicit scope_guard(Callback&& callback)
      noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value); /*
                                                      meant for friends only */

      friend scope_guard<Callback> make_scope_guard<Callback>(Callback&&)
      noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value); /*
      only make_scope_guard can create scope_guards from scratch (i.e. non-move)
      */

    private:
      Callback m_callback;
      bool m_active;

    };

  } // namespace detail


  /* --- Now the single public maker function --- */

  using detail::make_scope_guard; // see comment on declaration above

} // namespace sg

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
sg::detail::scope_guard<Callback>::scope_guard(Callback&& callback)
noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
  : m_callback(std::forward<Callback>(callback)) /* use () instead of {} because
    of DR 1467 (https://is.gd/WHmWuo), which still impacts older compilers
    (e.g. GCC 4.x and clang <=3.6, see https://godbolt.org/g/TE9tPJ and
    https://is.gd/Tsmh8G) */
  , m_active{true}
{}

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
sg::detail::scope_guard<Callback>::~scope_guard<Callback>() noexcept
{
  if(m_active)
    m_callback();
}

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
sg::detail::scope_guard<Callback>::scope_guard(scope_guard&& other)
noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
  : m_callback(std::forward<Callback>(other.m_callback)) // idem
  , m_active{std::move(other.m_active)}
{
  other.m_active = false;
}

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
inline void sg::detail::scope_guard<Callback>::dismiss() noexcept
{
  m_active = false;
}

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
inline auto sg::detail::make_scope_guard(Callback&& callback)
noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
-> detail::scope_guard<Callback>
{
  return detail::scope_guard<Callback>{std::forward<Callback>(callback)};
}

#endif /* SCOPE_GUARD_HPP_ */

```

`vcpkg.json`:

```json
{
  "$cmkr": "This file is automatically generated from cmake.toml - DO NOT EDIT",
  "$cmkr-url": "https://github.com/build-cpp/cmkr",
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "dependencies": [
    {
      "name": "imgui",
      "features": ["docking-experimental","freetype","sdl2-binding","opengl3-binding"]
    },
    "fmt",
    "pegtl",
    "nativefiledialog",
    "spdlog",
    "utfcpp",
    "nlohmann-json",
    {
      "name": "glad",
      "features": ["gl-api-30"]
    },
    "lua",
    "sol2"
  ],
  "description": "",
  "name": "regenny",
  "version-string": ""
}

```