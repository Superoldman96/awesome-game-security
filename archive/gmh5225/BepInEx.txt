Project Path: arc_gmh5225_BepInEx__2wttyxa

Source Tree:

```txt
arc_gmh5225_BepInEx__2wttyxa
├── BepInEx.Core
│   ├── BepInEx.Core.csproj
│   ├── Bootstrap
│   │   ├── BaseChainloader.cs
│   │   └── TypeLoader.cs
│   ├── Configuration
│   │   ├── AcceptableValueBase.cs
│   │   ├── AcceptableValueList.cs
│   │   ├── AcceptableValueRange.cs
│   │   ├── ConfigDefinition.cs
│   │   ├── ConfigDescription.cs
│   │   ├── ConfigEntryBase.cs
│   │   ├── ConfigFile.cs
│   │   ├── ConfigWrapper.cs
│   │   ├── SettingChangedEventArgs.cs
│   │   ├── TomlTypeConverter.cs
│   │   └── TypeConverter.cs
│   ├── Console
│   │   ├── ConsoleManager.cs
│   │   ├── IConsoleDriver.cs
│   │   ├── SafeConsole.cs
│   │   ├── Unix
│   │   │   ├── ConsoleWriter.cs
│   │   │   ├── LinuxConsoleDriver.cs
│   │   │   ├── TtyHandler.cs
│   │   │   ├── UnixStream.cs
│   │   │   └── UnixStreamHelper.cs
│   │   └── Windows
│   │       ├── ConsoleEncoding
│   │       │   ├── ConsoleEncoding.Buffers.cs
│   │       │   ├── ConsoleEncoding.PInvoke.cs
│   │       │   └── ConsoleEncoding.cs
│   │       ├── ConsoleWindow.cs
│   │       ├── Kon.cs
│   │       └── WindowsConsoleDriver.cs
│   ├── Contract
│   │   ├── Attributes.cs
│   │   ├── IPlugin.cs
│   │   └── PluginInfo.cs
│   ├── Logging
│   │   ├── BepInExLogInterpolatedStringHandler.cs
│   │   ├── ConsoleLogListener.cs
│   │   ├── DiskLogListener.cs
│   │   ├── HarmonyLogSource.cs
│   │   ├── ILogListener.cs
│   │   ├── ILogSource.cs
│   │   ├── InterpolatedStringHandlerAttribute.cs
│   │   ├── LogEventArgs.cs
│   │   ├── LogLevel.cs
│   │   ├── Logger.cs
│   │   ├── ManualLogSource.cs
│   │   └── TraceLogSource.cs
│   ├── Paths.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   └── Utility.cs
├── BepInEx.Preloader.Core
│   ├── AssemblyBuildInfo.cs
│   ├── BepInEx.Preloader.Core.csproj
│   ├── EnvVars.cs
│   ├── InternalPreloaderLogger.cs
│   ├── Logging
│   │   ├── ChainloaderLogHelper.cs
│   │   └── PreloaderConsoleListener.cs
│   ├── Patching
│   │   ├── AssemblyPatcher.cs
│   │   ├── Attributes.cs
│   │   ├── BasePatcher.cs
│   │   ├── PatcherContext.cs
│   │   └── PatcherPluginMetadata.cs
│   ├── PlatformUtils.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   └── RuntimeFixes
│       ├── ConsoleSetOutFix.cs
│       └── HarmonyBackendFix.cs
├── BepInEx.sln
├── Directory.Build.props
├── LICENSE
├── README.md
├── Runtimes
│   ├── NET
│   │   ├── BepInEx.NET.Common
│   │   │   ├── BasePlugin.cs
│   │   │   ├── BepInEx.NET.Common.csproj
│   │   │   └── NetChainloader.cs
│   │   ├── BepInEx.NET.CoreCLR
│   │   │   ├── BepInEx.NET.CoreCLR.csproj
│   │   │   ├── HookEntrypoint.cs
│   │   │   └── NetCorePreloader.cs
│   │   ├── BepInEx.NET.Framework.Launcher
│   │   │   ├── App.config
│   │   │   ├── BepInEx.NET.Framework.Launcher.csproj
│   │   │   ├── NetPreloader.cs
│   │   │   ├── Program.cs
│   │   │   └── RuntimeFixes
│   │   │       └── AssemblyFixes.cs
│   │   └── BepInEx.NET.Shared
│   │       ├── BepInEx.NET.Shared.projitems
│   │       ├── BepInEx.NET.Shared.shproj
│   │       └── SharedEntrypoint.cs
│   └── Unity
│       ├── BepInEx.Unity.Common
│       │   ├── BepInEx.Unity.Common.csproj
│       │   └── UnityInfo.cs
│       ├── BepInEx.Unity.IL2CPP
│       │   ├── BasePlugin.cs
│       │   ├── BepInEx.Unity.IL2CPP.csproj
│       │   ├── DoorstopEntrypoint.cs
│       │   ├── Hook
│       │   │   ├── BaseNativeDetour.cs
│       │   │   ├── Dobby
│       │   │   │   ├── DobbyDetour.cs
│       │   │   │   └── DobbyLib.cs
│       │   │   ├── Funchook
│       │   │   │   ├── FunchookDetour.cs
│       │   │   │   └── FunchookLib.cs
│       │   │   ├── INativeDetour.cs
│       │   │   └── Il2CppInteropDetourProvider.cs
│       │   ├── IL2CPPChainloader.cs
│       │   ├── Il2CppInteropManager.cs
│       │   ├── Logging
│       │   │   ├── BepInExLoggerProvider.cs
│       │   │   ├── IL2CPPLogSource.cs
│       │   │   └── IL2CPPUnityLogSource.cs
│       │   ├── Preloader.cs
│       │   ├── RuntimeFixes
│       │   │   └── RedirectStdErrFix.cs
│       │   ├── UnityEngine
│       │   │   └── Input.cs
│       │   ├── UnityPreloadRunner.cs
│       │   ├── Utils
│       │   │   ├── Collections
│       │   │   │   ├── CollectionExtensions.cs
│       │   │   │   ├── Il2CppManagedEnumerable.cs
│       │   │   │   ├── Il2CppManagedEnumerator.cs
│       │   │   │   ├── ManagedIl2CppEnumerable.cs
│       │   │   │   └── ManagedIl2CppEnumerator.cs
│       │   │   ├── Il2CppUtils.cs
│       │   │   ├── MessageBox.cs
│       │   │   ├── MonoBehaviourExtensions.cs
│       │   │   └── NotifySend.cs
│       │   └── app.config
│       ├── BepInEx.Unity.Mono
│       │   ├── BaseUnityPlugin.cs
│       │   ├── BepInEx.Unity.Mono.csproj
│       │   ├── BepInExInstance.cs
│       │   ├── Bootstrap
│       │   │   └── UnityChainloader.cs
│       │   ├── Configuration
│       │   │   └── KeyboardShortcut.cs
│       │   ├── Logging
│       │   │   ├── UnityLogListener.cs
│       │   │   └── UnityLogSource.cs
│       │   ├── ThreadingHelper.cs
│       │   └── UnityTomlTypeConverters.cs
│       ├── BepInEx.Unity.Mono.Preloader
│       │   ├── BepInEx.Unity.Mono.Preloader.csproj
│       │   ├── DoorstopEntrypoint.cs
│       │   ├── EntrypointPatcher.cs
│       │   ├── RuntimeFixes
│       │   │   ├── TraceFix.cs
│       │   │   ├── UnityPatches.cs
│       │   │   └── XTermFix.cs
│       │   ├── UnityPreloader.cs
│       │   ├── UnityPreloaderRunner.cs
│       │   └── Utils
│       │       └── MonoAssemblyHelper.cs
│       └── Doorstop
│           ├── doorstop_config_il2cpp.ini
│           ├── doorstop_config_mono.ini
│           ├── run_bepinex_il2cpp.sh
│           └── run_bepinex_mono.sh
├── assets
│   └── logos
│       ├── logo.png
│       └── logo.svg
├── build
│   ├── Build.csproj
│   ├── DependencyCache.cs
│   ├── DistributionTarget.cs
│   ├── DownloadTasks.cs
│   ├── GitTasks.cs
│   └── Program.cs
├── build.cmd
├── build.ps1
├── build.sh
├── docs
│   ├── BUILDING.md
│   ├── CODE_OF_CONDUCT.md
│   └── CONTRIBUTING.md
└── nuget.config

```

`BepInEx.Core/BepInEx.Core.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <Description>BepInEx Core library</Description>
        <TargetFrameworks>net35;netstandard2.0</TargetFrameworks>
        <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
        <!-- Force nuget assembly output on netstandard2.0 -->
        <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="All"/>
        <PackageReference Include="HarmonyX" Version="2.10.1"/>
        <PackageReference Include="SemanticVersioning" Version="2.0.2"/>
        <PackageReference Include="MonoMod.Utils" Version="22.5.1.1"/>
    </ItemGroup>
    <ItemGroup>
        <Compile Remove="Contract\IPlugin.cs"/>
    </ItemGroup>

    <!-- CopyLocalLockFileAssemblies causes to also output shared assemblies: https://github.com/NuGet/Home/issues/4837#issuecomment-354536302 -->
    <!-- Since all core assemblies usually follow naming of System.*, we just delete them for now -->
    <!-- Also delete deps.json as they are not used by mono -->
    <Target Name="DeleteSys" AfterTargets="Build">
        <ItemGroup>
            <FilesToDelete Include="$(OutputPath)System.*.dll"/>
            <FilesToDelete Include="$(OutputPath)*.deps.json"/>
        </ItemGroup>
        <Delete Files="@(FilesToDelete)"/>
    </Target>
</Project>

```

`BepInEx.Core/Bootstrap/BaseChainloader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using BepInEx.Configuration;
using BepInEx.Logging;
using Mono.Cecil;

namespace BepInEx.Bootstrap;

public abstract class BaseChainloader<TPlugin>
{
    protected static readonly string CurrentAssemblyName = Assembly.GetExecutingAssembly().GetName().Name;
    protected static readonly Version CurrentAssemblyVersion = Assembly.GetExecutingAssembly().GetName().Version;

    private static Regex allowedGuidRegex { get; } = new(@"^[a-zA-Z0-9\._\-]+$");

    /// <summary>
    ///     Analyzes the given type definition and attempts to convert it to a valid <see cref="PluginInfo" />
    /// </summary>
    /// <param name="type">Type definition to analyze.</param>
    /// <param name="assemblyLocation">The filepath of the assembly, to keep as metadata.</param>
    /// <returns>If the type represent a valid plugin, returns a <see cref="PluginInfo" /> instance. Otherwise, return null.</returns>
    public static PluginInfo ToPluginInfo(TypeDefinition type, string assemblyLocation)
    {
        if (type.IsInterface || type.IsAbstract)
            return null;

        try
        {
            if (!type.IsSubtypeOf(typeof(TPlugin)))
                return null;
        }
        catch (AssemblyResolutionException)
        {
            // Can happen if this type inherits a type from an assembly that can't be found. Safe to assume it's not a plugin.
            return null;
        }

        var metadata = BepInPlugin.FromCecilType(type);

        // Perform checks that will prevent the plugin from being loaded in ALL cases
        if (metadata == null)
        {
            Logger.Log(LogLevel.Warning, $"Skipping over type [{type.FullName}] as no metadata attribute is specified");
            return null;
        }

        if (string.IsNullOrEmpty(metadata.GUID) || !allowedGuidRegex.IsMatch(metadata.GUID))
        {
            Logger.Log(LogLevel.Warning,
                       $"Skipping type [{type.FullName}] because its GUID [{metadata.GUID}] is of an illegal format.");
            return null;
        }

        if (metadata.Version == null)
        {
            Logger.Log(LogLevel.Warning, $"Skipping type [{type.FullName}] because its version is invalid.");
            return null;
        }

        if (metadata.Name == null)
        {
            Logger.Log(LogLevel.Warning, $"Skipping type [{type.FullName}] because its name is null.");
            return null;
        }

        var filters = BepInProcess.FromCecilType(type);
        var dependencies = BepInDependency.FromCecilType(type);
        var incompatibilities = BepInIncompatibility.FromCecilType(type);

        var bepinVersion =
            type.Module.AssemblyReferences.FirstOrDefault(reference => reference.Name == "BepInEx.Core")?.Version ??
            new Version();

        return new PluginInfo
        {
            Metadata = metadata,
            Processes = filters,
            Dependencies = dependencies,
            Incompatibilities = incompatibilities,
            TypeName = type.FullName,
            TargettedBepInExVersion = bepinVersion,
            Location = assemblyLocation
        };
    }

    protected static bool HasBepinPlugins(AssemblyDefinition ass)
    {
        if (ass.MainModule.AssemblyReferences.All(r => r.Name != CurrentAssemblyName))
            return false;
        if (ass.MainModule.GetTypeReferences().All(r => r.FullName != typeof(BepInPlugin).FullName))
            return false;

        return true;
    }

    protected static bool PluginTargetsWrongBepin(PluginInfo pluginInfo)
    {
        var pluginTarget = pluginInfo.TargettedBepInExVersion;
        // X.X.X.x - compare normally. x.x.x.X - nightly build number, ignore
        if (pluginTarget.Major != CurrentAssemblyVersion.Major) return true;
        if (pluginTarget.Minor > CurrentAssemblyVersion.Minor) return true;
        if (pluginTarget.Minor < CurrentAssemblyVersion.Minor) return false;
        return pluginTarget.Build > CurrentAssemblyVersion.Build;
    }

    #region Contract

    protected virtual string ConsoleTitle => $"BepInEx {Paths.BepInExVersion} - {Paths.ProcessName}";

    private bool _initialized;

    /// <summary>
    ///     List of all <see cref="PluginInfo" /> instances loaded via the chainloader.
    /// </summary>
    public Dictionary<string, PluginInfo> Plugins { get; } = new();

    /// <summary>
    ///     Collection of error chainloader messages that occured during plugin loading.
    ///     Contains information about what certain plugins were not loaded.
    /// </summary>
    public List<string> DependencyErrors { get; } = new();

    /// <summary>
    ///     Occurs after a plugin is loaded.
    /// </summary>
    public event Action<PluginInfo> PluginLoaded;

    /// <summary>
    ///     Occurs after all plugins are loaded.
    /// </summary>
    public event Action Finished;

    public virtual void Initialize(string gameExePath = null)
    {
        if (_initialized)
            throw new InvalidOperationException("Chainloader cannot be initialized multiple times");

        // Set vitals
        if (gameExePath != null)
            // Checking for null allows a more advanced initialization workflow, where the Paths class has been initialized before calling Chainloader.Initialize
            // This is used by Preloader to use environment variables, for example
            Paths.SetExecutablePath(gameExePath);

        InitializeLoggers();

        if (!Directory.Exists(Paths.PluginPath))
            Directory.CreateDirectory(Paths.PluginPath);

        if (!Directory.Exists(Paths.PatcherPluginPath))
            Directory.CreateDirectory(Paths.PatcherPluginPath);

        _initialized = true;

        Logger.Log(LogLevel.Message, "Chainloader initialized");
    }

    protected virtual void InitializeLoggers()
    {
        if (ConsoleManager.ConsoleEnabled && !ConsoleManager.ConsoleActive)
            ConsoleManager.CreateConsole();

        if (ConsoleManager.ConsoleActive)
        {
            if (!Logger.Listeners.Any(x => x is ConsoleLogListener))
                Logger.Listeners.Add(new ConsoleLogListener());

            ConsoleManager.SetConsoleTitle(ConsoleTitle);
        }

        if (ConfigDiskLogging.Value)
            Logger.Listeners.Add(new DiskLogListener("LogOutput.log", ConfigDiskLoggingDisplayedLevel.Value,
                                                     ConfigDiskAppend.Value, ConfigDiskLoggingInstantFlushing.Value,
                                                     ConfigDiskLoggingFileLimit.Value));

        if (!TraceLogSource.IsListening)
            Logger.Sources.Add(TraceLogSource.CreateSource());

        if (!Logger.Sources.Any(x => x is HarmonyLogSource))
            Logger.Sources.Add(new HarmonyLogSource());
    }

    /// <summary>
    /// Discovers all plugins in the plugin directory without loading them.
    /// </summary>
    /// <remarks>
    /// This is useful for discovering BepInEx plugin metadata.
    /// </remarks>
    /// <param name="path">Path from which to search the plugins.</param>
    /// <param name="cacheName">Cache name to use. If null, results are not cached.</param>
    /// <returns>List of discovered plugins and their metadata.</returns>
    protected IList<PluginInfo> DiscoverPluginsFrom(string path, string cacheName = "chainloader")
    {
        var pluginsToLoad =
            TypeLoader.FindPluginTypes(path, ToPluginInfo, HasBepinPlugins, cacheName);
        return pluginsToLoad.SelectMany(p => p.Value).ToList();
    }

    /// <summary>
    /// Discovers plugins to load.
    /// </summary>
    /// <returns>List of plugins to be loaded.</returns>
    protected virtual IList<PluginInfo> DiscoverPlugins()
    {
        return DiscoverPluginsFrom(Paths.PluginPath);
    }

    /// <summary>
    /// Preprocess the plugins and modify the load order.
    /// </summary>
    /// <remarks>Some plugins may be skipped if they cannot be loaded (wrong metadata, etc).</remarks>
    /// <param name="plugins">Plugins to process.</param>
    /// <returns>List of plugins to load in the correct load order.</returns>
    protected virtual IList<PluginInfo> ModifyLoadOrder(IList<PluginInfo> plugins)
    {
        // We use a sorted dictionary to ensure consistent load order
        var dependencyDict =
            new SortedDictionary<string, IEnumerable<string>>(StringComparer.InvariantCultureIgnoreCase);
        var pluginsByGuid = new Dictionary<string, PluginInfo>();

        foreach (var pluginInfoGroup in plugins.GroupBy(info => info.Metadata.GUID))
        {
            if (Plugins.TryGetValue(pluginInfoGroup.Key, out var loadedPlugin))
            {
                Logger.Log(LogLevel.Warning,
                           $"Skipping [{pluginInfoGroup.Key}] because a plugin with a similar GUID ([{loadedPlugin}]) has been already loaded.");
                continue;
            }

            PluginInfo loadedVersion = null;
            foreach (var pluginInfo in pluginInfoGroup.OrderByDescending(x => x.Metadata.Version))
            {
                if (loadedVersion != null)
                {
                    Logger.Log(LogLevel.Warning,
                               $"Skipping [{pluginInfo}] because a newer version exists ({loadedVersion})");
                    continue;
                }

                // Perform checks that will prevent loading plugins in this run
                var filters = pluginInfo.Processes.ToList();
                var invalidProcessName = filters.Count != 0 &&
                                         filters.All(x => !string.Equals(x.ProcessName.Replace(".exe", ""),
                                                                         Paths.ProcessName,
                                                                         StringComparison
                                                                             .InvariantCultureIgnoreCase));

                if (invalidProcessName)
                {
                    Logger.Log(LogLevel.Warning,
                               $"Skipping [{pluginInfo}] because of process filters ({string.Join(", ", pluginInfo.Processes.Select(p => p.ProcessName).ToArray())})");
                    continue;
                }

                loadedVersion = pluginInfo;
                dependencyDict[pluginInfo.Metadata.GUID] = pluginInfo.Dependencies.Select(d => d.DependencyGUID);
                pluginsByGuid[pluginInfo.Metadata.GUID] = pluginInfo;
            }
        }

        foreach (var pluginInfo in pluginsByGuid.Values.ToList())
            if (pluginInfo.Incompatibilities.Any(incompatibility =>
                                                     pluginsByGuid.ContainsKey(incompatibility.IncompatibilityGUID)
                                                  || Plugins.ContainsKey(incompatibility.IncompatibilityGUID))
               )
            {
                pluginsByGuid.Remove(pluginInfo.Metadata.GUID);
                dependencyDict.Remove(pluginInfo.Metadata.GUID);

                var incompatiblePluginsNew = pluginInfo.Incompatibilities.Select(x => x.IncompatibilityGUID)
                                                       .Where(x => pluginsByGuid.ContainsKey(x));
                var incompatiblePluginsExisting = pluginInfo.Incompatibilities.Select(x => x.IncompatibilityGUID)
                                                            .Where(x => Plugins.ContainsKey(x));
                var incompatiblePlugins = incompatiblePluginsNew.Concat(incompatiblePluginsExisting).ToArray();
                var message =
                    $@"Could not load [{pluginInfo}] because it is incompatible with: {string.Join(", ", incompatiblePlugins)}";
                DependencyErrors.Add(message);
                Logger.Log(LogLevel.Error, message);
            }
            else if (PluginTargetsWrongBepin(pluginInfo))
            {
                var message =
                    $@"Plugin [{pluginInfo}] targets a wrong version of BepInEx ({pluginInfo.TargettedBepInExVersion}) and might not work until you update";
                DependencyErrors.Add(message);
                Logger.Log(LogLevel.Warning, message);
            }

        // We don't add already loaded plugins to the dependency graph as they are already loaded

        var emptyDependencies = new string[0];

        // Sort plugins by their dependencies.
        // Give missing dependencies no dependencies of its own, which will cause missing plugins to be first in the resulting list.
        var sortedPlugins = Utility.TopologicalSort(dependencyDict.Keys,
                                                    x =>
                                                        dependencyDict.TryGetValue(x, out var deps)
                                                            ? deps
                                                            : emptyDependencies).ToList();

        return sortedPlugins.Where(pluginsByGuid.ContainsKey).Select(x => pluginsByGuid[x]).ToList();
    }

    /// <summary>
    /// Run the chainloader and load all plugins from the plugins folder.
    /// </summary>
    public virtual void Execute()
    {
        try
        {
            var plugins = DiscoverPlugins();
            Logger.Log(LogLevel.Info, $"{plugins.Count} plugin{(plugins.Count == 1 ? "" : "s")} to load");
            LoadPlugins(plugins);
            Finished?.Invoke();
        }
        catch (Exception ex)
        {
            try
            {
                ConsoleManager.CreateConsole();
            }
            catch { }

            Logger.Log(LogLevel.Error, $"Error occurred loading plugins: {ex}");
        }

        Logger.Log(LogLevel.Message, "Chainloader startup complete");
    }

    private IList<PluginInfo> LoadPlugins(IList<PluginInfo> plugins)
    {
        var sortedPlugins = ModifyLoadOrder(plugins);

        var invalidPlugins = new HashSet<string>();
        var processedPlugins = new Dictionary<string, SemanticVersioning.Version>();
        var loadedAssemblies = new Dictionary<string, Assembly>();
        var loadedPlugins = new List<PluginInfo>();

        foreach (var plugin in sortedPlugins)
        {
            var dependsOnInvalidPlugin = false;
            var missingDependencies = new List<BepInDependency>();
            foreach (var dependency in plugin.Dependencies)
            {
                static bool IsHardDependency(BepInDependency dep) =>
                    (dep.Flags & BepInDependency.DependencyFlags.HardDependency) != 0;

                // If the dependency wasn't already processed, it's missing altogether
                var dependencyExists =
                    processedPlugins.TryGetValue(dependency.DependencyGUID, out var pluginVersion);
                // Alternatively, if the dependency hasn't been loaded before, it's missing too
                if (!dependencyExists)
                {
                    dependencyExists = Plugins.TryGetValue(dependency.DependencyGUID, out var pluginInfo);
                    pluginVersion = pluginInfo?.Metadata.Version;
                }

                if (!dependencyExists || dependency.VersionRange != null &&
                    !dependency.VersionRange.IsSatisfied(pluginVersion))
                {
                    // If the dependency is hard, collect it into a list to show
                    if (IsHardDependency(dependency))
                        missingDependencies.Add(dependency);
                    continue;
                }

                // If the dependency is a hard and is invalid (e.g. has missing dependencies), report that to the user
                if (invalidPlugins.Contains(dependency.DependencyGUID) && IsHardDependency(dependency))
                {
                    dependsOnInvalidPlugin = true;
                    break;
                }
            }

            processedPlugins.Add(plugin.Metadata.GUID, plugin.Metadata.Version);

            if (dependsOnInvalidPlugin)
            {
                var message =
                    $"Skipping [{plugin}] because it has a dependency that was not loaded. See previous errors for details.";
                DependencyErrors.Add(message);
                Logger.Log(LogLevel.Warning, message);
                continue;
            }

            if (missingDependencies.Count != 0)
            {
                var message = $@"Could not load [{plugin}] because it has missing dependencies: {
                    string.Join(", ", missingDependencies.Select(s => s.VersionRange == null ? s.DependencyGUID : $"{s.DependencyGUID} ({s.VersionRange})").ToArray())
                }";
                DependencyErrors.Add(message);
                Logger.Log(LogLevel.Error, message);

                invalidPlugins.Add(plugin.Metadata.GUID);
                continue;
            }

            try
            {
                Logger.Log(LogLevel.Info, $"Loading [{plugin}]");

                if (!loadedAssemblies.TryGetValue(plugin.Location, out var ass))
                    loadedAssemblies[plugin.Location] = ass = Assembly.LoadFrom(plugin.Location);

                Plugins[plugin.Metadata.GUID] = plugin;
                TryRunModuleCtor(plugin, ass);
                plugin.Instance = LoadPlugin(plugin, ass);
                loadedPlugins.Add(plugin);

                PluginLoaded?.Invoke(plugin);
            }
            catch (Exception ex)
            {
                invalidPlugins.Add(plugin.Metadata.GUID);
                Plugins.Remove(plugin.Metadata.GUID);

                Logger.Log(LogLevel.Error,
                           $"Error loading [{plugin}]: {(ex is ReflectionTypeLoadException re ? TypeLoader.TypeLoadExceptionToString(re) : ex.ToString())}");
            }
        }

        return loadedPlugins;
    }

    /// <summary>
    /// Detects and loads all plugins in the specified directories.
    /// </summary>
    /// <remarks>
    /// It is better to collect all paths at once and use a single call to LoadPlugins than multiple calls.
    /// This allows to run proper dependency resolving and to load all plugins in one go.
    /// </remarks>
    /// <param name="pluginsPaths">Directories to search the plugins from.</param>
    /// <returns>List of loaded plugin infos.</returns>
    public IList<PluginInfo> LoadPlugins(params string[] pluginsPaths)
    {
        // TODO: This is a temporary solution for 3rd party loaders. Instead, this should be done via metaplugins.
        var plugins = new List<PluginInfo>();
        foreach (var pluginsPath in pluginsPaths)
            plugins.AddRange(DiscoverPluginsFrom(pluginsPath));
        return LoadPlugins(plugins);
    }

    private static void TryRunModuleCtor(PluginInfo plugin, Assembly assembly)
    {
        try
        {
            RuntimeHelpers.RunModuleConstructor(assembly.GetType(plugin.TypeName).Module.ModuleHandle);
        }
        catch (Exception e)
        {
            Logger.Log(LogLevel.Warning,
                       $"Couldn't run Module constructor for {assembly.FullName}::{plugin.TypeName}: {e}");
        }
    }

    public abstract TPlugin LoadPlugin(PluginInfo pluginInfo, Assembly pluginAssembly);

    #endregion

    #region Config

    private static readonly ConfigEntry<bool> ConfigDiskAppend = ConfigFile.CoreConfig.Bind(
     "Logging.Disk", "AppendLog",
     false,
     "Appends to the log file instead of overwriting, on game startup.");

    private static readonly ConfigEntry<bool> ConfigDiskLogging = ConfigFile.CoreConfig.Bind(
     "Logging.Disk", "Enabled",
     true,
     "Enables writing log messages to disk.");

    private static readonly ConfigEntry<LogLevel> ConfigDiskLoggingDisplayedLevel = ConfigFile.CoreConfig.Bind(
     "Logging.Disk", "LogLevels",
     LogLevel.Fatal | LogLevel.Error | LogLevel.Warning | LogLevel.Message | LogLevel.Info,
     "Only displays the specified log levels in the disk log output.");

    private static readonly ConfigEntry<bool> ConfigDiskLoggingInstantFlushing = ConfigFile.CoreConfig.Bind(
     "Logging.Disk", "InstantFlushing",
     false,
     new StringBuilder()
         .AppendLine("If true, instantly writes any received log entries to disk.")
         .AppendLine("This incurs a major performance hit if a lot of log messages are being written, however it is really useful for debugging crashes.")
         .ToString());

    private static readonly ConfigEntry<int> ConfigDiskLoggingFileLimit = ConfigFile.CoreConfig.Bind(
     "Logging.Disk", "ConcurrentFileLimit",
     5,
     new StringBuilder()
         .AppendLine("The maximum amount of concurrent log files that will be written to disk.")
         .AppendLine("As one log file is used per open game instance, you may find it necessary to increase this limit when debugging multiple instances at the same time.")
         .ToString());

    #endregion
}

```

`BepInEx.Core/Bootstrap/TypeLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using BepInEx.Configuration;
using BepInEx.Logging;
using Mono.Cecil;

namespace BepInEx.Bootstrap;

/// <summary>
///     A cacheable metadata item. Can be used with <see cref="TypeLoader.LoadAssemblyCache{T}" /> and
///     <see cref="TypeLoader.SaveAssemblyCache{T}" /> to cache plugin metadata.
/// </summary>
public interface ICacheable
{
    /// <summary>
    ///     Serialize the object into a binary format.
    /// </summary>
    /// <param name="bw"></param>
    void Save(BinaryWriter bw);

    /// <summary>
    ///     Loads the object from binary format.
    /// </summary>
    /// <param name="br"></param>
    void Load(BinaryReader br);
}

/// <summary>
///     A cached assembly.
/// </summary>
/// <typeparam name="T"></typeparam>
public class CachedAssembly<T> where T : ICacheable
{
    /// <summary>
    ///     List of cached items inside the assembly.
    /// </summary>
    public List<T> CacheItems { get; set; }

    /// <summary>
    ///     Hash of the assembly. Used to verify that the assembly hasn't been changed.
    /// </summary>
    public string Hash { get; set; }
}

/// <summary>
///     Provides methods for loading specified types from an assembly.
/// </summary>
public static class TypeLoader
{
    /// <summary>
    ///     Default assembly resolved used by the <see cref="TypeLoader" />
    /// </summary>
    public static readonly DefaultAssemblyResolver CecilResolver;

    /// <summary>
    ///     Default reader parameters used by <see cref="TypeLoader" />
    /// </summary>
    public static readonly ReaderParameters ReaderParameters;

    public static HashSet<string> SearchDirectories = new();

    #region Config

    private static readonly ConfigEntry<bool> EnableAssemblyCache = ConfigFile.CoreConfig.Bind(
     "Caching", "EnableAssemblyCache",
     true,
     "Enable/disable assembly metadata cache\nEnabling this will speed up discovery of plugins and patchers by caching the metadata of all types BepInEx discovers.");

    #endregion

    static TypeLoader()
    {
        CecilResolver = new DefaultAssemblyResolver();
        ReaderParameters = new ReaderParameters { AssemblyResolver = CecilResolver };

        CecilResolver.ResolveFailure += CecilResolveOnFailure;
    }

    public static AssemblyDefinition CecilResolveOnFailure(object sender, AssemblyNameReference reference)
    {
        if (!Utility.TryParseAssemblyName(reference.FullName, out var name))
            return null;

        var resolveDirs = new[]
        {
            Paths.BepInExAssemblyDirectory,
            Paths.PluginPath,
            Paths.PatcherPluginPath,
            Paths.ManagedPath
        }.Concat(SearchDirectories);

        foreach (var dir in resolveDirs)
        {
            if (!Directory.Exists(dir))
            {
                Logger.Log(LogLevel.Debug, $"Unable to resolve cecil search directory '{dir}'");
                continue;
            }

            if (Utility.TryResolveDllAssembly(name, dir, ReaderParameters, out var assembly))
                return assembly;
        }

        return AssemblyResolve?.Invoke(sender, reference);
    }

    /// <summary>
    ///     Event fired when <see cref="TypeLoader" /> fails to resolve a type during type loading.
    /// </summary>
    public static event AssemblyResolveEventHandler AssemblyResolve;

    /// <summary>
    ///     Looks up assemblies in the given directory and locates all types that can be loaded and collects their metadata.
    /// </summary>
    /// <typeparam name="T">The specific base type to search for.</typeparam>
    /// <param name="directory">The directory to search for assemblies.</param>
    /// <param name="typeSelector">A function to check if a type should be selected and to build the type metadata.</param>
    /// <param name="assemblyFilter">A filter function to quickly determine if the assembly can be loaded.</param>
    /// <param name="cacheName">The name of the cache to get cached types from.</param>
    /// <returns>
    ///     A dictionary of all assemblies in the directory and the list of type metadatas of types that match the
    ///     selector.
    /// </returns>
    public static Dictionary<string, List<T>> FindPluginTypes<T>(string directory,
                                                                 Func<TypeDefinition, string, T> typeSelector,
                                                                 Func<AssemblyDefinition, bool> assemblyFilter =
                                                                     null,
                                                                 string cacheName = null)
        where T : ICacheable, new()
    {
        var result = new Dictionary<string, List<T>>();
        var hashes = new Dictionary<string, string>();
        Dictionary<string, CachedAssembly<T>> cache = null;

        if (cacheName != null)
            cache = LoadAssemblyCache<T>(cacheName);

        foreach (var dll in Directory.GetFiles(Path.GetFullPath(directory), "*.dll", SearchOption.AllDirectories))
            try
            {
                using var dllMs = new MemoryStream(File.ReadAllBytes(dll));
                var hash = Utility.HashStream(dllMs);
                hashes[dll] = hash;
                dllMs.Position = 0;
                if (cache != null && cache.TryGetValue(dll, out var cacheEntry))
                    if (hash == cacheEntry.Hash)
                    {
                        result[dll] = cacheEntry.CacheItems;
                        continue;
                    }

                using var ass = AssemblyDefinition.ReadAssembly(dllMs, ReaderParameters);
                Logger.Log(LogLevel.Debug, $"Examining '{dll}'");

                if (!assemblyFilter?.Invoke(ass) ?? false)
                {
                    result[dll] = new List<T>();
                    continue;
                }

                var matches = ass.MainModule.Types
                                 .Select(t => typeSelector(t, dll))
                                 .Where(t => t != null).ToList();
                result[dll] = matches;
            }
            catch (BadImageFormatException e)
            {
                Logger.Log(LogLevel.Debug,
                           $"Skipping loading {dll} because it's not a valid .NET assembly. Full error: {e.Message}");
            }
            catch (Exception e)
            {
                Logger.Log(LogLevel.Error, e);
            }

        if (cacheName != null)
            SaveAssemblyCache(cacheName, result, hashes);

        return result;
    }

    /// <summary>
    ///     Loads an index of type metadatas from a cache.
    /// </summary>
    /// <param name="cacheName">Name of the cache</param>
    /// <typeparam name="T">Cacheable item</typeparam>
    /// <returns>
    ///     Cached type metadatas indexed by the path of the assembly that defines the type. If no cache is defined,
    ///     return null.
    /// </returns>
    public static Dictionary<string, CachedAssembly<T>> LoadAssemblyCache<T>(string cacheName)
        where T : ICacheable, new()
    {
        if (!EnableAssemblyCache.Value)
            return null;

        var result = new Dictionary<string, CachedAssembly<T>>();
        try
        {
            var path = Path.Combine(Paths.CachePath, $"{cacheName}_typeloader.dat");
            if (!File.Exists(path))
                return null;

            using (var br = new BinaryReader(File.OpenRead(path)))
            {
                var entriesCount = br.ReadInt32();

                for (var i = 0; i < entriesCount; i++)
                {
                    var entryIdentifier = br.ReadString();
                    var hash = br.ReadString();
                    var itemsCount = br.ReadInt32();
                    var items = new List<T>();

                    for (var j = 0; j < itemsCount; j++)
                    {
                        var entry = new T();
                        entry.Load(br);
                        items.Add(entry);
                    }

                    result[entryIdentifier] = new CachedAssembly<T> { Hash = hash, CacheItems = items };
                }
            }
        }
        catch (Exception e)
        {
            Logger.Log(LogLevel.Warning,
                       $"Failed to load cache \"{cacheName}\"; skipping loading cache. Reason: {e.Message}.");
        }

        return result;
    }

    /// <summary>
    ///     Saves indexed type metadata into a cache.
    /// </summary>
    /// <param name="cacheName">Name of the cache</param>
    /// <param name="entries">List of plugin metadatas indexed by the path to the assembly that contains the types</param>
    /// <param name="hashes">Hash values that can be used for checking similarity between cached and live assembly</param>
    /// <typeparam name="T">Cacheable item</typeparam>
    public static void SaveAssemblyCache<T>(string cacheName,
                                            Dictionary<string, List<T>> entries,
                                            Dictionary<string, string> hashes)
        where T : ICacheable
    {
        if (!EnableAssemblyCache.Value)
            return;

        try
        {
            if (!Directory.Exists(Paths.CachePath))
                Directory.CreateDirectory(Paths.CachePath);

            var path = Path.Combine(Paths.CachePath, $"{cacheName}_typeloader.dat");

            using var bw = new BinaryWriter(File.OpenWrite(path));
            bw.Write(entries.Count);

            foreach (var kv in entries)
            {
                bw.Write(kv.Key);
                bw.Write(hashes.TryGetValue(kv.Key, out var hash) ? hash : "");
                bw.Write(kv.Value.Count);

                foreach (var item in kv.Value)
                    item.Save(bw);
            }
        }
        catch (Exception e)
        {
            Logger.Log(LogLevel.Warning,
                       $"Failed to save cache \"{cacheName}\"; skipping saving cache. Reason: {e.Message}.");
        }
    }

    /// <summary>
    ///     Converts TypeLoadException to a readable string.
    /// </summary>
    /// <param name="ex">TypeLoadException</param>
    /// <returns>Readable representation of the exception</returns>
    public static string TypeLoadExceptionToString(ReflectionTypeLoadException ex)
    {
        var sb = new StringBuilder();
        foreach (var exSub in ex.LoaderExceptions)
        {
            sb.AppendLine(exSub.Message);
            if (exSub is FileNotFoundException exFileNotFound)
            {
                if (!string.IsNullOrEmpty(exFileNotFound.FusionLog))
                {
                    sb.AppendLine("Fusion Log:");
                    sb.AppendLine(exFileNotFound.FusionLog);
                }
            }
            else if (exSub is FileLoadException exLoad)
            {
                if (!string.IsNullOrEmpty(exLoad.FusionLog))
                {
                    sb.AppendLine("Fusion Log:");
                    sb.AppendLine(exLoad.FusionLog);
                }
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }
}

```

`BepInEx.Core/Configuration/AcceptableValueBase.cs`:

```cs
using System;

namespace BepInEx.Configuration;

/// <summary>
///     Base type of all classes representing and enforcing acceptable values of config settings.
/// </summary>
public abstract class AcceptableValueBase
{
    /// <param name="valueType">Type of values that this class can Clamp.</param>
    protected AcceptableValueBase(Type valueType)
    {
        ValueType = valueType;
    }

    /// <summary>
    ///     Type of the supported values.
    /// </summary>
    public Type ValueType { get; }

    /// <summary>
    ///     Change the value to be acceptable, if it's not already.
    /// </summary>
    public abstract object Clamp(object value);

    /// <summary>
    ///     Check if the value is an acceptable value.
    /// </summary>
    public abstract bool IsValid(object value);

    /// <summary>
    ///     Get the string for use in config files.
    /// </summary>
    public abstract string ToDescriptionString();
}

```

`BepInEx.Core/Configuration/AcceptableValueList.cs`:

```cs
using System;
using System.Linq;

namespace BepInEx.Configuration;

/// <summary>
///     Specify the list of acceptable values for a setting.
/// </summary>
public class AcceptableValueList<T> : AcceptableValueBase where T : IEquatable<T>
{
    /// <summary>
    ///     Specify the list of acceptable values for a setting.
    ///     If the setting does not equal any of the values, it will be set to the first one.
    /// </summary>
    public AcceptableValueList(params T[] acceptableValues) : base(typeof(T))
    {
        if (acceptableValues == null) throw new ArgumentNullException(nameof(acceptableValues));
        if (acceptableValues.Length == 0)
            throw new ArgumentException("At least one acceptable value is needed", nameof(acceptableValues));

        AcceptableValues = acceptableValues;
    }

    /// <summary>
    ///     List of values that a setting can take.
    /// </summary>
    public virtual T[] AcceptableValues { get; }

    /// <inheritdoc />
    public override object Clamp(object value)
    {
        if (IsValid(value))
            return value;

        return AcceptableValues[0];
    }

    /// <inheritdoc />
    public override bool IsValid(object value) => value is T v && AcceptableValues.Any(x => x.Equals(v));

    /// <inheritdoc />
    public override string ToDescriptionString() =>
        "# Acceptable values: " + string.Join(", ", AcceptableValues.Select(x => x.ToString()).ToArray());
}

```

`BepInEx.Core/Configuration/AcceptableValueRange.cs`:

```cs
using System;

namespace BepInEx.Configuration;

/// <summary>
///     Specify the range of acceptable values for a setting.
/// </summary>
public class AcceptableValueRange<T> : AcceptableValueBase where T : IComparable
{
    /// <param name="minValue">Lowest acceptable value</param>
    /// <param name="maxValue">Highest acceptable value</param>
    public AcceptableValueRange(T minValue, T maxValue) : base(typeof(T))
    {
        if (maxValue == null)
            throw new ArgumentNullException(nameof(maxValue));
        if (minValue == null)
            throw new ArgumentNullException(nameof(minValue));
        if (minValue.CompareTo(maxValue) >= 0)
            throw new ArgumentException($"{nameof(minValue)} has to be lower than {nameof(maxValue)}");

        MinValue = minValue;
        MaxValue = maxValue;
    }

    /// <summary>
    ///     Lowest acceptable value
    /// </summary>
    public virtual T MinValue { get; }

    /// <summary>
    ///     Highest acceptable value
    /// </summary>
    public virtual T MaxValue { get; }

    /// <inheritdoc />
    public override object Clamp(object value)
    {
        if (MinValue.CompareTo(value) > 0)
            return MinValue;

        if (MaxValue.CompareTo(value) < 0)
            return MaxValue;

        return value;
    }

    /// <inheritdoc />
    public override bool IsValid(object value) => MinValue.CompareTo(value) <= 0 && MaxValue.CompareTo(value) >= 0;

    /// <inheritdoc />
    public override string ToDescriptionString() => $"# Acceptable value range: From {MinValue} to {MaxValue}";
}

```

`BepInEx.Core/Configuration/ConfigDefinition.cs`:

```cs
using System;
using System.Linq;

namespace BepInEx.Configuration;

/// <summary>
///     Section and key of a setting. Used as a unique key for identification within a
///     <see cref="T:BepInEx.Configuration.ConfigFile" />.
///     The same definition can be used in multiple config files, it will point to different settings then.
/// </summary>
/// <inheritdoc />
public class ConfigDefinition : IEquatable<ConfigDefinition>
{
    private static readonly char[] _invalidConfigChars = { '=', '\n', '\t', '\\', '"', '\'', '[', ']' };

    /// <summary>
    ///     Create a new definition. Definitions with same section and key are equal.
    /// </summary>
    /// <param name="section">Group of the setting, case sensitive.</param>
    /// <param name="key">Name of the setting, case sensitive.</param>
    public ConfigDefinition(string section, string key)
    {
        CheckInvalidConfigChars(section, nameof(section));
        CheckInvalidConfigChars(key, nameof(key));
        Key = key;
        Section = section;
    }

    /// <inheritdoc />
    [Obsolete("description argument is no longer used, put it in a ConfigDescription instead")]
    public ConfigDefinition(string section, string key, string description)
    {
        Key = key ?? "";
        Section = section ?? "";
    }

    /// <summary>
    ///     Group of the setting. All settings within a config file are grouped by this.
    /// </summary>
    public string Section { get; }

    /// <summary>
    ///     Name of the setting.
    /// </summary>
    public string Key { get; }

    /// <summary>
    ///     Check if the definitions are the same.
    /// </summary>
    /// <inheritdoc />
    public bool Equals(ConfigDefinition other)
    {
        if (other == null) return false;
        return string.Equals(Key, other.Key)
            && string.Equals(Section, other.Section);
    }

    private static void CheckInvalidConfigChars(string val, string name)
    {
        if (val == null) throw new ArgumentNullException(name);
        if (val != val.Trim())
            throw new ArgumentException("Cannot use whitespace characters at start or end of section and key names",
                                        name);
        if (val.Any(c => _invalidConfigChars.Contains(c)))
            throw new
                ArgumentException(@"Cannot use any of the following characters in section and key names: = \n \t \ "" ' [ ]",
                                  name);
    }

    /// <summary>
    ///     Check if the definitions are the same.
    /// </summary>
    public override bool Equals(object obj)
    {
        if (ReferenceEquals(null, obj))
            return false;
        if (ReferenceEquals(this, obj))
            return true;

        return Equals(obj as ConfigDefinition);
    }

    /// <inheritdoc />
    public override int GetHashCode()
    {
        unchecked
        {
            var hashCode = Key != null ? Key.GetHashCode() : 0;
            hashCode = (hashCode * 397) ^ (Section != null ? Section.GetHashCode() : 0);
            return hashCode;
        }
    }

    /// <summary>
    ///     Check if the definitions are the same.
    /// </summary>
    public static bool operator ==(ConfigDefinition left, ConfigDefinition right) => Equals(left, right);

    /// <summary>
    ///     Check if the definitions are the same.
    /// </summary>
    public static bool operator !=(ConfigDefinition left, ConfigDefinition right) => !Equals(left, right);

    /// <inheritdoc />
    public override string ToString() => Section + "." + Key;
}

```

`BepInEx.Core/Configuration/ConfigDescription.cs`:

```cs
using System;

namespace BepInEx.Configuration;

/// <summary>
///     Metadata of a <see cref="ConfigEntryBase" />.
/// </summary>
public class ConfigDescription
{
    /// <summary>
    ///     Create a new description.
    /// </summary>
    /// <param name="description">Text describing the function of the setting and any notes or warnings.</param>
    /// <param name="acceptableValues">
    ///     Range of values that this setting can take. The setting's value will be automatically
    ///     clamped.
    /// </param>
    /// <param name="tags">Objects that can be used by user-made classes to add functionality.</param>
    public ConfigDescription(string description, AcceptableValueBase acceptableValues = null, params object[] tags)
    {
        AcceptableValues = acceptableValues;
        Tags = tags;
        Description = description ?? throw new ArgumentNullException(nameof(description));
    }

    /// <summary>
    ///     Text describing the function of the setting and any notes or warnings.
    /// </summary>
    public string Description { get; }

    /// <summary>
    ///     Range of acceptable values for a setting.
    /// </summary>
    public AcceptableValueBase AcceptableValues { get; }

    /// <summary>
    ///     Objects that can be used by user-made classes to add functionality.
    /// </summary>
    public object[] Tags { get; }

    /// <summary>
    ///     An empty description.
    /// </summary>
    public static ConfigDescription Empty { get; } = new("");
}

```

`BepInEx.Core/Configuration/ConfigEntryBase.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using BepInEx.Logging;

namespace BepInEx.Configuration;

/// <summary>
///     Provides access to a single setting inside of a <see cref="Configuration.ConfigFile" />.
/// </summary>
/// <typeparam name="T">Type of the setting.</typeparam>
public sealed class ConfigEntry<T> : ConfigEntryBase
{
    private T _typedValue;

    internal ConfigEntry(ConfigFile configFile,
                         ConfigDefinition definition,
                         T defaultValue,
                         ConfigDescription configDescription) : base(configFile, definition, typeof(T),
                                                                     defaultValue, configDescription)
    {
        configFile.SettingChanged += (sender, args) =>
        {
            if (args.ChangedSetting == this) SettingChanged?.Invoke(sender, args);
        };
    }

    /// <summary>
    ///     Value of this setting.
    /// </summary>
    public T Value
    {
        get => _typedValue;
        set
        {
            value = ClampValue(value);
            if (Equals(_typedValue, value))
                return;

            _typedValue = value;
            OnSettingChanged(this);
        }
    }

    /// <inheritdoc />
    public override object BoxedValue
    {
        get => Value;
        set => Value = (T) value;
    }

    /// <summary>
    ///     Fired when the setting is changed. Does not detect changes made outside from this object.
    /// </summary>
    public event EventHandler SettingChanged;
}

/// <summary>
///     Container for a single setting of a <see cref="Configuration.ConfigFile" />.
///     Each config entry is linked to one config file.
/// </summary>
public abstract class ConfigEntryBase
{
    /// <summary>
    ///     Types of defaultValue and definition.AcceptableValues have to be the same as settingType.
    /// </summary>
    internal protected ConfigEntryBase(ConfigFile configFile,
                             ConfigDefinition definition,
                             Type settingType,
                             object defaultValue,
                             ConfigDescription configDescription)
    {
        ConfigFile = configFile ?? throw new ArgumentNullException(nameof(configFile));
        Definition = definition ?? throw new ArgumentNullException(nameof(definition));
        SettingType = settingType ?? throw new ArgumentNullException(nameof(settingType));

        Description = configDescription ?? ConfigDescription.Empty;
        if (Description.AcceptableValues != null &&
            !SettingType.IsAssignableFrom(Description.AcceptableValues.ValueType))
            throw new
                ArgumentException("configDescription.AcceptableValues is for a different type than the type of this setting");

        DefaultValue = defaultValue;

        // Free type check and automatically calls ClampValue in case AcceptableValues were provided
        BoxedValue = defaultValue;
    }

    /// <summary>
    ///     Config file this entry is a part of.
    /// </summary>
    public ConfigFile ConfigFile { get; }

    /// <summary>
    ///     Category and name of this setting. Used as a unique key for identification within a
    ///     <see cref="Configuration.ConfigFile" />.
    /// </summary>
    public ConfigDefinition Definition { get; }

    /// <summary>
    ///     Description / metadata of this setting.
    /// </summary>
    public ConfigDescription Description { get; }

    /// <summary>
    ///     Type of the <see cref="BoxedValue" /> that this setting holds.
    /// </summary>
    public Type SettingType { get; }

    /// <summary>
    ///     Default value of this setting (set only if the setting was not changed before).
    /// </summary>
    public object DefaultValue { get; }

    /// <summary>
    ///     Get or set the value of the setting.
    /// </summary>
    public abstract object BoxedValue { get; set; }

    /// <summary>
    ///     Get the serialized representation of the value.
    /// </summary>
    public string GetSerializedValue() => TomlTypeConverter.ConvertToString(BoxedValue, SettingType);

    /// <summary>
    ///     Set the value by using its serialized form.
    /// </summary>
    public void SetSerializedValue(string value)
    {
        try
        {
            var newValue = TomlTypeConverter.ConvertToValue(value, SettingType);
            BoxedValue = newValue;
        }
        catch (Exception e)
        {
            Logger.Log(LogLevel.Warning,
                       $"Config value of setting \"{Definition}\" could not be parsed and will be ignored. Reason: {e.Message}; Value: {value}");
        }
    }

    /// <summary>
    ///     If necessary, clamp the value to acceptable value range. T has to be equal to settingType.
    /// </summary>
    protected T ClampValue<T>(T value)
    {
        if (Description.AcceptableValues != null)
            return (T) Description.AcceptableValues.Clamp(value);
        return value;
    }

    /// <summary>
    ///     Trigger setting changed event.
    /// </summary>
    protected void OnSettingChanged(object sender) => ConfigFile.OnSettingChanged(sender, this);

    /// <summary>
    ///     Write a description of this setting using all available metadata.
    /// </summary>
    public void WriteDescription(StreamWriter writer)
    {
        if (!string.IsNullOrEmpty(Description.Description))
            writer.WriteLine($"## {Description.Description.Replace("\n", "\n## ")}");

        writer.WriteLine($"# Setting type: {SettingType.Name}");

        writer.WriteLine($"# Default value: {TomlTypeConverter.ConvertToString(DefaultValue, SettingType)}");

        if (Description.AcceptableValues != null)
        {
            writer.WriteLine(Description.AcceptableValues.ToDescriptionString());
        }
        else if (SettingType.IsEnum)
        {
            writer.WriteLine($"# Acceptable values: {string.Join(", ", Enum.GetNames(SettingType))}");

            if (SettingType.GetCustomAttributes(typeof(FlagsAttribute), true).Any())
                writer.WriteLine("# Multiple values can be set at the same time by separating them with , (e.g. Debug, Warning)");
        }
    }
}

```

`BepInEx.Core/Configuration/ConfigFile.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using BepInEx.Logging;

namespace BepInEx.Configuration;

/// <summary>
///     A helper class to handle persistent data. All public methods are thread-safe.
/// </summary>
public class ConfigFile : IDictionary<ConfigDefinition, ConfigEntryBase>
{
    private readonly BepInPlugin _ownerMetadata;

    /// <inheritdoc cref="ConfigFile(string, bool, BepInPlugin)" />
    public ConfigFile(string configPath, bool saveOnInit) : this(configPath, saveOnInit, null) { }

    /// <summary>
    ///     Create a new config file at the specified config path.
    /// </summary>
    /// <param name="configPath">Full path to a file that contains settings. The file will be created as needed.</param>
    /// <param name="saveOnInit">If the config file/directory doesn't exist, create it immediately.</param>
    /// <param name="ownerMetadata">Information about the plugin that owns this setting file.</param>
    public ConfigFile(string configPath, bool saveOnInit, BepInPlugin ownerMetadata)
    {
        _ownerMetadata = ownerMetadata;

        if (configPath == null) throw new ArgumentNullException(nameof(configPath));
        configPath = Path.GetFullPath(configPath);
        ConfigFilePath = configPath;

        if (File.Exists(ConfigFilePath))
            Reload();
        else if (saveOnInit) Save();
    }

    public static ConfigFile CoreConfig { get; } = new(Paths.BepInExConfigPath, true);

    /// <summary>
    ///     All config entries inside
    /// </summary>
    protected Dictionary<ConfigDefinition, ConfigEntryBase> Entries { get; } = new();

    private Dictionary<ConfigDefinition, string> OrphanedEntries { get; } = new();

    /// <summary>
    ///     Create a list with all config entries inside of this config file.
    /// </summary>
    [Obsolete("Use Keys instead")]
    public ReadOnlyCollection<ConfigDefinition> ConfigDefinitions
    {
        get
        {
            lock (_ioLock)
            {
                return Entries.Keys.ToList().AsReadOnly();
            }
        }
    }

    /// <summary>
    ///     Full path to the config file. The file might not exist until a setting is added and changed, or <see cref="Save" />
    ///     is called.
    /// </summary>
    public string ConfigFilePath { get; }

    /// <summary>
    ///     If enabled, writes the config to disk every time a value is set.
    ///     If disabled, you have to manually use <see cref="Save" /> or the changes will be lost!
    /// </summary>
    public bool SaveOnConfigSet { get; set; } = true;

    /// <inheritdoc />
    public ConfigEntryBase this[ConfigDefinition key]
    {
        get
        {
            lock (_ioLock)
            {
                return Entries[key];
            }
        }
    }

    /// <summary>
    /// </summary>
    /// <param name="section"></param>
    /// <param name="key"></param>
    public ConfigEntryBase this[string section, string key] => this[new ConfigDefinition(section, key)];

    /// <inheritdoc />
    public IEnumerator<KeyValuePair<ConfigDefinition, ConfigEntryBase>> GetEnumerator() =>
        // We can't really do a read lock for this
        Entries.GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    void ICollection<KeyValuePair<ConfigDefinition, ConfigEntryBase>>.Add(
        KeyValuePair<ConfigDefinition, ConfigEntryBase> item)
    {
        lock (_ioLock)
        {
            Entries.Add(item.Key, item.Value);
        }
    }

    /// <inheritdoc />
    public bool Contains(KeyValuePair<ConfigDefinition, ConfigEntryBase> item)
    {
        lock (_ioLock)
        {
            return ((ICollection<KeyValuePair<ConfigDefinition, ConfigEntryBase>>) Entries).Contains(item);
        }
    }

    void ICollection<KeyValuePair<ConfigDefinition, ConfigEntryBase>>.CopyTo(
        KeyValuePair<ConfigDefinition, ConfigEntryBase>[] array,
        int arrayIndex)
    {
        lock (_ioLock)
        {
            ((ICollection<KeyValuePair<ConfigDefinition, ConfigEntryBase>>) Entries).CopyTo(array, arrayIndex);
        }
    }

    bool ICollection<KeyValuePair<ConfigDefinition, ConfigEntryBase>>.Remove(
        KeyValuePair<ConfigDefinition, ConfigEntryBase> item)
    {
        lock (_ioLock)
        {
            return Entries.Remove(item.Key);
        }
    }

    /// <inheritdoc />
    public int Count
    {
        get
        {
            lock (_ioLock)
            {
                return Entries.Count;
            }
        }
    }

    /// <inheritdoc />
    public bool IsReadOnly => false;

    /// <inheritdoc />
    public bool ContainsKey(ConfigDefinition key)
    {
        lock (_ioLock)
        {
            return Entries.ContainsKey(key);
        }
    }

    /// <inheritdoc />
    public void Add(ConfigDefinition key, ConfigEntryBase value) =>
        throw new InvalidOperationException("Directly adding a config entry is not supported");

    /// <inheritdoc />
    public bool Remove(ConfigDefinition key)
    {
        lock (_ioLock)
        {
            return Entries.Remove(key);
        }
    }

    /// <inheritdoc />
    public void Clear()
    {
        lock (_ioLock)
        {
            Entries.Clear();
        }
    }

    bool IDictionary<ConfigDefinition, ConfigEntryBase>.TryGetValue(ConfigDefinition key, out ConfigEntryBase value)
    {
        lock (_ioLock)
        {
            return Entries.TryGetValue(key, out value);
        }
    }

    /// <inheritdoc />
    ConfigEntryBase IDictionary<ConfigDefinition, ConfigEntryBase>.this[ConfigDefinition key]
    {
        get
        {
            lock (_ioLock)
            {
                return Entries[key];
            }
        }
        set => throw new InvalidOperationException("Directly setting a config entry is not supported");
    }

    /// <summary>
    ///     Returns the ConfigDefinitions that the ConfigFile contains.
    ///     <para>Creates a new array when the property is accessed. Thread-safe.</para>
    /// </summary>
    public ICollection<ConfigDefinition> Keys
    {
        get
        {
            lock (_ioLock)
            {
                return Entries.Keys.ToArray();
            }
        }
    }

    /// <summary>
    ///     Returns the ConfigEntryBase values that the ConfigFile contains.
    ///     <para>Creates a new array when the property is accessed. Thread-safe.</para>
    /// </summary>
    public ICollection<ConfigEntryBase> Values
    {
        get
        {
            lock (_ioLock)
            {
                return Entries.Values.ToArray();
            }
        }
    }

    /// <summary>
    ///     Create an array with all config entries inside of this config file. Should be only used for metadata purposes.
    ///     If you want to access and modify an existing setting then use
    ///     <see cref="AddSetting{T}(ConfigDefinition,T,ConfigDescription)" />
    ///     instead with no description.
    /// </summary>
    [Obsolete("Use Values instead")]
    public ConfigEntryBase[] GetConfigEntries()
    {
        lock (_ioLock)
        {
            return Entries.Values.ToArray();
        }
    }

    #region Save/Load

    private readonly object _ioLock = new();

    /// <summary>
    ///     Generate user-readable comments for each of the settings in the saved .cfg file.
    /// </summary>
    public bool GenerateSettingDescriptions { get; set; } = true;

    /// <summary>
    ///     Reloads the config from disk. Unsaved changes are lost.
    /// </summary>
    public void Reload()
    {
        lock (_ioLock)
        {
            OrphanedEntries.Clear();

            var currentSection = string.Empty;

            foreach (var rawLine in File.ReadAllLines(ConfigFilePath))
            {
                var line = rawLine.Trim();

                if (line.StartsWith("#")) //comment
                    continue;

                if (line.StartsWith("[") && line.EndsWith("]")) //section
                {
                    currentSection = line.Substring(1, line.Length - 2);
                    continue;
                }

                var split = line.Split(new[] { '=' }, 2); //actual config line
                if (split.Length != 2)
                    continue; //empty/invalid line

                var currentKey = split[0].Trim();
                var currentValue = split[1].Trim();

                var definition = new ConfigDefinition(currentSection, currentKey);

                Entries.TryGetValue(definition, out var entry);

                if (entry != null)
                    entry.SetSerializedValue(currentValue);
                else
                    OrphanedEntries[definition] = currentValue;
            }
        }

        OnConfigReloaded();
    }

    /// <summary>
    ///     Writes the config to disk.
    /// </summary>
    public void Save()
    {
        lock (_ioLock)
        {
            var directoryName = Path.GetDirectoryName(ConfigFilePath);
            if (directoryName != null) Directory.CreateDirectory(directoryName);

            using (var writer = new StreamWriter(ConfigFilePath, false, Utility.UTF8NoBom))
            {
                if (_ownerMetadata != null)
                {
                    writer.WriteLine($"## Settings file was created by plugin {_ownerMetadata.Name} v{_ownerMetadata.Version}");
                    writer.WriteLine($"## Plugin GUID: {_ownerMetadata.GUID}");
                    writer.WriteLine();
                }

                var allConfigEntries = Entries
                                       .Select(x => new
                                       {
                                           x.Key, entry = x.Value, value = x.Value.GetSerializedValue()
                                       })
                                       .Concat(OrphanedEntries.Select(x => new
                                       {
                                           x.Key, entry = (ConfigEntryBase) null, value = x.Value
                                       }));

                foreach (var sectionKv in allConfigEntries.GroupBy(x => x.Key.Section).OrderBy(x => x.Key))
                {
                    // Section heading
                    writer.WriteLine($"[{sectionKv.Key}]");

                    foreach (var configEntry in sectionKv)
                    {
                        if (GenerateSettingDescriptions)
                        {
                            writer.WriteLine();
                            configEntry.entry?.WriteDescription(writer);
                        }

                        writer.WriteLine($"{configEntry.Key.Key} = {configEntry.value}");
                    }

                    writer.WriteLine();
                }
            }
        }
    }

    #endregion

    #region Wraps

    /// <summary>
    ///     Access one of the existing settings. If the setting has not been added yet, null is returned.
    ///     If the setting exists but has a different type than T, an exception is thrown.
    ///     New settings should be added with <see cref="AddSetting{T}(ConfigDefinition,T,ConfigDescription)" />.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="configDefinition">Section and Key of the setting.</param>
    [Obsolete("Use ConfigFile[key] or TryGetEntry instead")]
    public ConfigEntry<T> GetSetting<T>(ConfigDefinition configDefinition) =>
        TryGetEntry<T>(configDefinition, out var entry)
            ? entry
            : null;

    /// <summary>
    ///     Access one of the existing settings. If the setting has not been added yet, null is returned.
    ///     If the setting exists but has a different type than T, an exception is thrown.
    ///     New settings should be added with <see cref="AddSetting{T}(ConfigDefinition,T,ConfigDescription)" />.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="section">Section/category/group of the setting. Settings are grouped by this.</param>
    /// <param name="key">Name of the setting.</param>
    [Obsolete("Use ConfigFile[key] or TryGetEntry instead")]
    public ConfigEntry<T> GetSetting<T>(string section, string key) =>
        TryGetEntry<T>(section, key, out var entry)
            ? entry
            : null;

    /// <summary>
    ///     Access one of the existing settings. If the setting has not been added yet, false is returned. Otherwise, true.
    ///     If the setting exists but has a different type than T, an exception is thrown.
    ///     New settings should be added with
    ///     <see cref="Bind{T}(BepInEx.Configuration.ConfigDefinition,T,BepInEx.Configuration.ConfigDescription)" />.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="configDefinition">Section and Key of the setting.</param>
    /// <param name="entry">The ConfigEntry value to return.</param>
    public bool TryGetEntry<T>(ConfigDefinition configDefinition, out ConfigEntry<T> entry)
    {
        lock (_ioLock)
        {
            if (Entries.TryGetValue(configDefinition, out var rawEntry))
            {
                entry = (ConfigEntry<T>) rawEntry;
                return true;
            }

            entry = null;
            return false;
        }
    }

    /// <summary>
    ///     Access one of the existing settings. If the setting has not been added yet, null is returned.
    ///     If the setting exists but has a different type than T, an exception is thrown.
    ///     New settings should be added with
    ///     <see cref="Bind{T}(BepInEx.Configuration.ConfigDefinition,T,BepInEx.Configuration.ConfigDescription)" />.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="section">Section/category/group of the setting. Settings are grouped by this.</param>
    /// <param name="key">Name of the setting.</param>
    /// <param name="entry">The ConfigEntry value to return.</param>
    public bool TryGetEntry<T>(string section, string key, out ConfigEntry<T> entry) =>
        TryGetEntry(new ConfigDefinition(section, key), out entry);

    /// <summary>
    ///     Create a new setting. The setting is saved to drive and loaded automatically.
    ///     Each definition can be used to add only one setting, trying to add a second setting will throw an exception.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="configDefinition">Section and Key of the setting.</param>
    /// <param name="defaultValue">Value of the setting if the setting was not created yet.</param>
    /// <param name="configDescription">Description of the setting shown to the user and other metadata.</param>
    public ConfigEntry<T> Bind<T>(ConfigDefinition configDefinition,
                                  T defaultValue,
                                  ConfigDescription configDescription = null)
    {
        if (!TomlTypeConverter.CanConvert(typeof(T)))
            throw new
                ArgumentException($"Type {typeof(T)} is not supported by the config system. Supported types: {string.Join(", ", TomlTypeConverter.GetSupportedTypes().Select(x => x.Name).ToArray())}");

        lock (_ioLock)
        {
            if (Entries.TryGetValue(configDefinition, out var rawEntry))
                return (ConfigEntry<T>) rawEntry;

            var entry = new ConfigEntry<T>(this, configDefinition, defaultValue, configDescription);

            Entries[configDefinition] = entry;

            if (OrphanedEntries.TryGetValue(configDefinition, out var homelessValue))
            {
                entry.SetSerializedValue(homelessValue);
                OrphanedEntries.Remove(configDefinition);
            }

            if (SaveOnConfigSet)
                Save();

            return entry;
        }
    }

    /// <summary>
    ///     Create a new setting. The setting is saved to drive and loaded automatically.
    ///     Each section and key pair can be used to add only one setting, trying to add a second setting will throw an
    ///     exception.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="section">Section/category/group of the setting. Settings are grouped by this.</param>
    /// <param name="key">Name of the setting.</param>
    /// <param name="defaultValue">Value of the setting if the setting was not created yet.</param>
    /// <param name="configDescription">Description of the setting shown to the user and other metadata.</param>
    public ConfigEntry<T> Bind<T>(string section,
                                  string key,
                                  T defaultValue,
                                  ConfigDescription configDescription = null) =>
        Bind(new ConfigDefinition(section, key), defaultValue, configDescription);

    /// <summary>
    ///     Create a new setting. The setting is saved to drive and loaded automatically.
    ///     Each section and key pair can be used to add only one setting, trying to add a second setting will throw an
    ///     exception.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="section">Section/category/group of the setting. Settings are grouped by this.</param>
    /// <param name="key">Name of the setting.</param>
    /// <param name="defaultValue">Value of the setting if the setting was not created yet.</param>
    /// <param name="description">Simple description of the setting shown to the user.</param>
    public ConfigEntry<T> Bind<T>(string section, string key, T defaultValue, string description) =>
        Bind(new ConfigDefinition(section, key), defaultValue, new ConfigDescription(description));

    /// <summary>
    ///     Create a new setting. The setting is saved to drive and loaded automatically.
    ///     Each definition can be used to add only one setting, trying to add a second setting will throw an exception.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="configDefinition">Section and Key of the setting.</param>
    /// <param name="defaultValue">Value of the setting if the setting was not created yet.</param>
    /// <param name="configDescription">Description of the setting shown to the user and other metadata.</param>
    [Obsolete("Use Bind instead")]
    public ConfigEntry<T> AddSetting<T>(ConfigDefinition configDefinition,
                                        T defaultValue,
                                        ConfigDescription configDescription = null) =>
        Bind(configDefinition, defaultValue, configDescription);

    /// <summary>
    ///     Create a new setting. The setting is saved to drive and loaded automatically.
    ///     Each section and key pair can be used to add only one setting, trying to add a second setting will throw an
    ///     exception.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="section">Section/category/group of the setting. Settings are grouped by this.</param>
    /// <param name="key">Name of the setting.</param>
    /// <param name="defaultValue">Value of the setting if the setting was not created yet.</param>
    /// <param name="configDescription">Description of the setting shown to the user and other metadata.</param>
    [Obsolete("Use Bind instead")]
    public ConfigEntry<T> AddSetting<T>(string section,
                                        string key,
                                        T defaultValue,
                                        ConfigDescription configDescription = null) =>
        Bind(new ConfigDefinition(section, key), defaultValue, configDescription);

    /// <summary>
    ///     Create a new setting. The setting is saved to drive and loaded automatically.
    ///     Each section and key pair can be used to add only one setting, trying to add a second setting will throw an
    ///     exception.
    /// </summary>
    /// <typeparam name="T">Type of the value contained in this setting.</typeparam>
    /// <param name="section">Section/category/group of the setting. Settings are grouped by this.</param>
    /// <param name="key">Name of the setting.</param>
    /// <param name="defaultValue">Value of the setting if the setting was not created yet.</param>
    /// <param name="description">Simple description of the setting shown to the user.</param>
    [Obsolete("Use Bind instead")]
    public ConfigEntry<T> AddSetting<T>(string section, string key, T defaultValue, string description) =>
        Bind(new ConfigDefinition(section, key), defaultValue, new ConfigDescription(description));

    /// <summary>
    ///     Access a setting. Use Bind instead.
    /// </summary>
    [Obsolete("Use Bind instead")]
    public ConfigWrapper<T> Wrap<T>(string section, string key, string description = null, T defaultValue = default)
    {
        lock (_ioLock)
        {
            var definition = new ConfigDefinition(section, key, description);
            var setting = Bind(definition, defaultValue,
                               string.IsNullOrEmpty(description) ? null : new ConfigDescription(description));
            return new ConfigWrapper<T>(setting);
        }
    }

    /// <summary>
    ///     Access a setting. Use Bind instead.
    /// </summary>
    [Obsolete("Use Bind instead")]
    public ConfigWrapper<T> Wrap<T>(ConfigDefinition configDefinition, T defaultValue = default) =>
        Wrap(configDefinition.Section, configDefinition.Key, null, defaultValue);

    #endregion

    #region Events

    /// <summary>
    ///     An event that is fired every time the config is reloaded.
    /// </summary>
    public event EventHandler ConfigReloaded;

    /// <summary>
    ///     Fired when one of the settings is changed.
    /// </summary>
    public event EventHandler<SettingChangedEventArgs> SettingChanged;

    internal void OnSettingChanged(object sender, ConfigEntryBase changedEntryBase)
    {
        if (changedEntryBase == null) throw new ArgumentNullException(nameof(changedEntryBase));

        if (SaveOnConfigSet)
            Save();

        var settingChanged = SettingChanged;
        if (settingChanged == null) return;

        var args = new SettingChangedEventArgs(changedEntryBase);
        foreach (EventHandler<SettingChangedEventArgs> callback in settingChanged.GetInvocationList())
            try
            {
                callback(sender, args);
            }
            catch (Exception e)
            {
                Logger.Log(LogLevel.Error, e);
            }
    }

    private void OnConfigReloaded()
    {
        var configReloaded = ConfigReloaded;
        if (configReloaded == null) return;

        foreach (EventHandler callback in configReloaded.GetInvocationList())
            try
            {
                callback(this, EventArgs.Empty);
            }
            catch (Exception e)
            {
                Logger.Log(LogLevel.Error, e);
            }
    }

    #endregion
}

```

`BepInEx.Core/Configuration/ConfigWrapper.cs`:

```cs
using System;

namespace BepInEx.Configuration;

/// <summary>
///     Provides access to a single setting inside of a <see cref="Configuration.ConfigFile" />.
/// </summary>
/// <typeparam name="T">Type of the setting.</typeparam>
[Obsolete("Use ConfigFile from new Bind overloads instead")]
public sealed class ConfigWrapper<T>
{
    internal ConfigWrapper(ConfigEntry<T> configEntry)
    {
        ConfigEntry = configEntry ?? throw new ArgumentNullException(nameof(configEntry));

        configEntry.ConfigFile.SettingChanged += (sender, args) =>
        {
            if (args.ChangedSetting == configEntry) SettingChanged?.Invoke(sender, args);
        };
    }

    /// <summary>
    ///     Entry of this setting in the <see cref="Configuration.ConfigFile" />.
    /// </summary>
    public ConfigEntry<T> ConfigEntry { get; }

    /// <summary>
    ///     Unique definition of this setting.
    /// </summary>
    public ConfigDefinition Definition => ConfigEntry.Definition;

    /// <summary>
    ///     Config file this setting is inside of.
    /// </summary>
    public ConfigFile ConfigFile => ConfigEntry.ConfigFile;

    /// <summary>
    ///     Value of this setting.
    /// </summary>
    public T Value
    {
        get => ConfigEntry.Value;
        set => ConfigEntry.Value = value;
    }

    /// <summary>
    ///     Fired when the setting is changed. Does not detect changes made outside from this object.
    /// </summary>
    public event EventHandler SettingChanged;
}

```

`BepInEx.Core/Configuration/SettingChangedEventArgs.cs`:

```cs
using System;

namespace BepInEx.Configuration;

/// <summary>
///     Arguments for events concerning a change of a setting.
/// </summary>
/// <inheritdoc />
public sealed class SettingChangedEventArgs : EventArgs
{
    /// <inheritdoc />
    public SettingChangedEventArgs(ConfigEntryBase changedSetting)
    {
        ChangedSetting = changedSetting;
    }

    /// <summary>
    ///     Setting that was changed
    /// </summary>
    public ConfigEntryBase ChangedSetting { get; }
}

```

`BepInEx.Core/Configuration/TomlTypeConverter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using BepInEx.Logging;

namespace BepInEx.Configuration;

/// <summary>
///     Serializer/deserializer used by the config system.
/// </summary>
public static class TomlTypeConverter
{
    // Don't put anything from UnityEngine here or it will break preloader, use LazyTomlConverterLoader instead
    private static Dictionary<Type, TypeConverter> TypeConverters { get; } = new()
    {
        [typeof(string)] = new TypeConverter
        {
            ConvertToString = (obj, type) => Escape((string) obj),
            ConvertToObject = (str, type) =>
            {
                // Check if the string is a file path with unescaped \ path separators (e.g. D:\test and not D:\\test)
                if (Regex.IsMatch(str, @"^""?\w:\\(?!\\)(?!.+\\\\)"))
                    return str;
                return Unescape(str);
            }
        },
        [typeof(bool)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString().ToLowerInvariant(),
            ConvertToObject = (str, type) => bool.Parse(str)
        },
        [typeof(byte)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => byte.Parse(str)
        },

        //integral types

        [typeof(sbyte)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => sbyte.Parse(str)
        },
        [typeof(byte)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => byte.Parse(str)
        },
        [typeof(short)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => short.Parse(str)
        },
        [typeof(ushort)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => ushort.Parse(str)
        },
        [typeof(int)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => int.Parse(str)
        },
        [typeof(uint)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => uint.Parse(str)
        },
        [typeof(long)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => long.Parse(str)
        },
        [typeof(ulong)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => ulong.Parse(str)
        },

        //floating point types

        [typeof(float)] = new TypeConverter
        {
            ConvertToString = (obj, type) => ((float) obj).ToString(NumberFormatInfo.InvariantInfo),
            ConvertToObject = (str, type) => float.Parse(str, NumberFormatInfo.InvariantInfo)
        },
        [typeof(double)] = new TypeConverter
        {
            ConvertToString = (obj, type) => ((double) obj).ToString(NumberFormatInfo.InvariantInfo),
            ConvertToObject = (str, type) => double.Parse(str, NumberFormatInfo.InvariantInfo)
        },
        [typeof(decimal)] = new TypeConverter
        {
            ConvertToString = (obj, type) => ((decimal) obj).ToString(NumberFormatInfo.InvariantInfo),
            ConvertToObject = (str, type) => decimal.Parse(str, NumberFormatInfo.InvariantInfo)
        },

        //enums are special

        [typeof(Enum)] = new TypeConverter
        {
            ConvertToString = (obj, type) => obj.ToString(),
            ConvertToObject = (str, type) => Enum.Parse(type, str, true)
        }
    };

    /// <summary>
    ///     Convert object of a given type to a string using available converters.
    /// </summary>
    public static string ConvertToString(object value, Type valueType)
    {
        var conv = GetConverter(valueType);
        if (conv == null)
            throw new InvalidOperationException($"Cannot convert from type {valueType}");

        return conv.ConvertToString(value, valueType);
    }

    /// <summary>
    ///     Convert string to an object of a given type using available converters.
    /// </summary>
    public static T ConvertToValue<T>(string value) => (T) ConvertToValue(value, typeof(T));

    /// <summary>
    ///     Convert string to an object of a given type using available converters.
    /// </summary>
    public static object ConvertToValue(string value, Type valueType)
    {
        var conv = GetConverter(valueType);
        if (conv == null)
            throw new InvalidOperationException($"Cannot convert to type {valueType.Name}");

        return conv.ConvertToObject(value, valueType);
    }

    /// <summary>
    ///     Get a converter for a given type if there is any.
    /// </summary>
    public static TypeConverter GetConverter(Type valueType)
    {
        if (valueType == null)
            throw new ArgumentNullException(nameof(valueType));

        if (valueType.IsEnum)
            return TypeConverters[typeof(Enum)];

        TypeConverters.TryGetValue(valueType, out var result);

        return result;
    }

    /// <summary>
    ///     Add a new type converter for a given type.
    ///     If a different converter is already added, this call is ignored and false is returned.
    /// </summary>
    public static bool AddConverter(Type type, TypeConverter converter)
    {
        if (type == null) throw new ArgumentNullException(nameof(type));
        if (converter == null) throw new ArgumentNullException(nameof(converter));
        if (CanConvert(type))
        {
            Logger.Log(LogLevel.Warning,
                       "Tried to add a TomlConverter when one already exists for type " + type.FullName);
            return false;
        }

        TypeConverters.Add(type, converter);
        return true;
    }

    /// <summary>
    ///     Check if a given type can be converted to and from string.
    /// </summary>
    public static bool CanConvert(Type type) => GetConverter(type) != null;

    /// <summary>
    ///     Give a list of types with registered converters.
    /// </summary>
    public static IEnumerable<Type> GetSupportedTypes() => TypeConverters.Keys;

    private static string Escape(this string txt)
    {
        if (string.IsNullOrEmpty(txt)) return string.Empty;

        var stringBuilder = new StringBuilder(txt.Length + 2);
        foreach (var c in txt)
            switch (c)
            {
                case '\0':
                    stringBuilder.Append(@"\0");
                    break;
                case '\a':
                    stringBuilder.Append(@"\a");
                    break;
                case '\b':
                    stringBuilder.Append(@"\b");
                    break;
                case '\t':
                    stringBuilder.Append(@"\t");
                    break;
                case '\n':
                    stringBuilder.Append(@"\n");
                    break;
                case '\v':
                    stringBuilder.Append(@"\v");
                    break;
                case '\f':
                    stringBuilder.Append(@"\f");
                    break;
                case '\r':
                    stringBuilder.Append(@"\r");
                    break;
                case '\'':
                    stringBuilder.Append(@"\'");
                    break;
                case '\\':
                    stringBuilder.Append(@"\");
                    break;
                case '\"':
                    stringBuilder.Append(@"\""");
                    break;
                default:
                    stringBuilder.Append(c);
                    break;
            }

        return stringBuilder.ToString();
    }

    private static string Unescape(this string txt)
    {
        if (string.IsNullOrEmpty(txt))
            return txt;
        var stringBuilder = new StringBuilder(txt.Length);
        for (var i = 0; i < txt.Length;)
        {
            var num = txt.IndexOf('\\', i);
            if (num < 0 || num == txt.Length - 1)
                num = txt.Length;
            stringBuilder.Append(txt, i, num - i);
            if (num >= txt.Length)
                break;
            var c = txt[num + 1];
            switch (c)
            {
                case '0':
                    stringBuilder.Append('\0');
                    break;
                case 'a':
                    stringBuilder.Append('\a');
                    break;
                case 'b':
                    stringBuilder.Append('\b');
                    break;
                case 't':
                    stringBuilder.Append('\t');
                    break;
                case 'n':
                    stringBuilder.Append('\n');
                    break;
                case 'v':
                    stringBuilder.Append('\v');
                    break;
                case 'f':
                    stringBuilder.Append('\f');
                    break;
                case 'r':
                    stringBuilder.Append('\r');
                    break;
                case '\'':
                    stringBuilder.Append('\'');
                    break;
                case '\"':
                    stringBuilder.Append('\"');
                    break;
                case '\\':
                    stringBuilder.Append('\\');
                    break;
                default:
                    stringBuilder.Append('\\').Append(c);
                    break;
            }

            i = num + 2;
        }

        return stringBuilder.ToString();
    }
}

```

`BepInEx.Core/Configuration/TypeConverter.cs`:

```cs
using System;

namespace BepInEx.Configuration;

/// <summary>
///     A serializer/deserializer combo for some type(s). Used by the config system.
/// </summary>
public class TypeConverter
{
    /// <summary>
    ///     Used to serialize the type into a (hopefully) human-readable string.
    ///     Object is the instance to serialize, Type is the object's type.
    /// </summary>
    public Func<object, Type, string> ConvertToString { get; set; }

    /// <summary>
    ///     Used to deserialize the type from a string.
    ///     String is the data to deserialize, Type is the object's type, should return instance to an object of Type.
    /// </summary>
    public Func<string, Type, object> ConvertToObject { get; set; }
}

```

`BepInEx.Core/Console/ConsoleManager.cs`:

```cs
using System;
using System.ComponentModel;
using System.IO;
using System.Text;
using BepInEx.Configuration;
using BepInEx.Unix;
using MonoMod.Utils;

namespace BepInEx;

public static class ConsoleManager
{
    public enum ConsoleOutRedirectType
    {
        [Description("Auto")]
        Auto = 0,

        [Description("Console Out")]
        ConsoleOut,

        [Description("Standard Out")]
        StandardOut
    }

    private const uint SHIFT_JIS_CP = 932;

    private const string ENABLE_CONSOLE_ARG = "--enable-console";

    public static readonly ConfigEntry<bool> ConfigConsoleEnabled = ConfigFile.CoreConfig.Bind(
     "Logging.Console", "Enabled",
     true,
     "Enables showing a console for log output.");

    public static readonly ConfigEntry<bool> ConfigPreventClose = ConfigFile.CoreConfig.Bind(
     "Logging.Console", "PreventClose",
     false,
     "If enabled, will prevent closing the console (either by deleting the close button or in other platform-specific way).");

    public static readonly ConfigEntry<bool> ConfigConsoleShiftJis = ConfigFile.CoreConfig.Bind(
     "Logging.Console", "ShiftJisEncoding",
     false,
     "If true, console is set to the Shift-JIS encoding, otherwise UTF-8 encoding.");

    public static readonly ConfigEntry<ConsoleOutRedirectType> ConfigConsoleOutRedirectType =
        ConfigFile.CoreConfig.Bind(
                                   "Logging.Console", "StandardOutType",
                                   ConsoleOutRedirectType.Auto,
                                   new StringBuilder()
                                       .AppendLine("Hints console manager on what handle to assign as StandardOut. Possible values:")
                                       .AppendLine("Auto - lets BepInEx decide how to redirect console output")
                                       .AppendLine("ConsoleOut - prefer redirecting to console output; if possible, closes original standard output")
                                       .AppendLine("StandardOut - prefer redirecting to standard output; if possible, closes console out")
                                       .ToString()
                                  );

    private static readonly bool? EnableConsoleArgOverride;

    static ConsoleManager()
    {
        // Ensure GetCommandLineArgs failing (e.g. on unix) does not kill bepin
        try
        {
            var args = Environment.GetCommandLineArgs();
            for (var i = 0; i < args.Length; i++)
            {
                var res = args[i];
                if (res == ENABLE_CONSOLE_ARG && i + 1 < args.Length && bool.TryParse(args[i + 1], out var enable))
                    EnableConsoleArgOverride = enable;
            }
        }
        catch (Exception)
        {
            // Skip
        }
    }

    public static bool ConsoleEnabled => EnableConsoleArgOverride ?? ConfigConsoleEnabled.Value;

    internal static IConsoleDriver Driver { get; set; }

    /// <summary>
    ///     True if an external console has been started, false otherwise.
    /// </summary>
    public static bool ConsoleActive => Driver?.ConsoleActive ?? false;

    /// <summary>
    ///     The stream that writes to the standard out stream of the process. Should never be null.
    /// </summary>
    public static TextWriter StandardOutStream => Driver?.StandardOut;

    /// <summary>
    ///     The stream that writes to an external console. Null if no such console exists
    /// </summary>
    public static TextWriter ConsoleStream => Driver?.ConsoleOut;


    public static void Initialize(bool alreadyActive, bool useManagedEncoder)
    {
        if (PlatformHelper.Is(Platform.Unix))
            Driver = new LinuxConsoleDriver();
        else if (PlatformHelper.Is(Platform.Windows))
            Driver = new WindowsConsoleDriver();
        else
            throw new PlatformNotSupportedException("Was unable to determine console driver for platform " +
                                                    PlatformHelper.Current);

        Driver.Initialize(alreadyActive, useManagedEncoder);
    }

    private static void DriverCheck()
    {
        if (Driver == null)
            throw new InvalidOperationException("Driver has not been initialized");
    }

    public static void CreateConsole()
    {
        if (ConsoleActive)
            return;

        DriverCheck();

        // Apparently some versions of Mono throw a "Encoding name 'xxx' not supported"
        // if you use Encoding.GetEncoding
        // That's why we use of codepages directly and handle then in console drivers separately
        var codepage = ConfigConsoleShiftJis.Value ? SHIFT_JIS_CP : (uint) Encoding.UTF8.CodePage;

        Driver.CreateConsole(codepage);

        if (ConfigPreventClose.Value)
            Driver.PreventClose();
    }

    public static void DetachConsole()
    {
        if (!ConsoleActive)
            return;

        DriverCheck();

        Driver.DetachConsole();
    }

    public static void SetConsoleTitle(string title)
    {
        DriverCheck();

        Driver.SetConsoleTitle(title);
    }

    public static void SetConsoleColor(ConsoleColor color)
    {
        DriverCheck();

        Driver.SetConsoleColor(color);
    }
}

```

`BepInEx.Core/Console/IConsoleDriver.cs`:

```cs
using System;
using System.IO;

namespace BepInEx;

internal interface IConsoleDriver
{
    TextWriter StandardOut { get; }
    TextWriter ConsoleOut { get; }

    bool ConsoleActive { get; }
    bool ConsoleIsExternal { get; }

    void PreventClose();

    void Initialize(bool alreadyActive, bool useManagedEncoder);

    // Apparently Windows code-pages work in Mono.
    // https://stackoverflow.com/a/33456543
    void CreateConsole(uint codepage);
    void DetachConsole();

    void SetConsoleColor(ConsoleColor color);

    void SetConsoleTitle(string title);
}

```

`BepInEx.Core/Console/SafeConsole.cs`:

```cs
// --------------------------------------------------
// UnityInjector - SafeConsole.cs
// Copyright (c) Usagirei 2015 - 2015
// --------------------------------------------------

using System;
using System.Reflection;

namespace UnityInjector.ConsoleUtil;

/// <summary>
///     Console class with safe handlers for Unity 4.x, which does not have a proper Console implementation
/// </summary>
internal static class SafeConsole
{
    private static GetColorDelegate _getBackgroundColor;
    private static SetColorDelegate _setBackgroundColor;

    private static GetColorDelegate _getForegroundColor;
    private static SetColorDelegate _setForegroundColor;

    private static GetStringDelegate _getTitle;
    private static SetStringDelegate _setTitle;

    static SafeConsole()
    {
        var tConsole = typeof(Console);
        InitColors(tConsole);
    }

    public static bool BackgroundColorExists { get; private set; }

    public static ConsoleColor BackgroundColor
    {
        get => _getBackgroundColor();
        set => _setBackgroundColor(value);
    }

    public static bool ForegroundColorExists { get; private set; }

    public static ConsoleColor ForegroundColor
    {
        get => _getForegroundColor();
        set => _setForegroundColor(value);
    }

    public static bool TitleExists { get; private set; }

    public static string Title
    {
        get => _getTitle();
        set => _setTitle(value);
    }

    private static void InitColors(Type tConsole)
    {
        const BindingFlags BINDING_FLAGS = BindingFlags.Public | BindingFlags.Static;

        var gfc = tConsole.GetMethod("get_ForegroundColor", BINDING_FLAGS);
        var sfc = tConsole.GetMethod("set_ForegroundColor", BINDING_FLAGS);

        var gbc = tConsole.GetMethod("get_BackgroundColor", BINDING_FLAGS);
        var sbc = tConsole.GetMethod("set_BackgroundColor", BINDING_FLAGS);

        var gtt = tConsole.GetMethod("get_Title", BINDING_FLAGS);
        var stt = tConsole.GetMethod("set_Title", BINDING_FLAGS);

        _setForegroundColor = sfc != null
                                  ? (SetColorDelegate) Delegate.CreateDelegate(typeof(SetColorDelegate), sfc)
                                  : value => { };

        _setBackgroundColor = sbc != null
                                  ? (SetColorDelegate) Delegate.CreateDelegate(typeof(SetColorDelegate), sbc)
                                  : value => { };

        _getForegroundColor = gfc != null
                                  ? (GetColorDelegate) Delegate.CreateDelegate(typeof(GetColorDelegate), gfc)
                                  : () => ConsoleColor.Gray;

        _getBackgroundColor = gbc != null
                                  ? (GetColorDelegate) Delegate.CreateDelegate(typeof(GetColorDelegate), gbc)
                                  : () => ConsoleColor.Black;

        _getTitle = gtt != null
                        ? (GetStringDelegate) Delegate.CreateDelegate(typeof(GetStringDelegate), gtt)
                        : () => string.Empty;

        _setTitle = stt != null
                        ? (SetStringDelegate) Delegate.CreateDelegate(typeof(SetStringDelegate), stt)
                        : value => { };

        BackgroundColorExists = _setBackgroundColor != null && _getBackgroundColor != null;
        ForegroundColorExists = _setForegroundColor != null && _getForegroundColor != null;
        TitleExists = _setTitle != null && _getTitle != null;
    }

    private delegate ConsoleColor GetColorDelegate();

    private delegate void SetColorDelegate(ConsoleColor value);

    private delegate string GetStringDelegate();

    private delegate void SetStringDelegate(string value);
}

```

`BepInEx.Core/Console/Unix/ConsoleWriter.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using HarmonyLib;

namespace BepInEx.Unix;

internal static class ConsoleWriter
{
    private static Func<Stream, Encoding, bool, StreamWriter> cStreamWriterConstructor;

    private static Func<Stream, Encoding, bool, StreamWriter> CStreamWriterConstructor
    {
        get
        {
            if (cStreamWriterConstructor != null)
                return cStreamWriterConstructor;

            var cStreamWriter = AccessTools.TypeByName("System.IO.CStreamWriter");

            Func<Stream, Encoding, bool, StreamWriter> GetCtor(int[] perm)
            {
                var parameters = new[] { typeof(Stream), typeof(Encoding), typeof(bool) };
                var ctor = AccessTools.Constructor(cStreamWriter, perm.Select(i => parameters[i]).ToArray());
                if (ctor != null)
                    return (stream, encoding, l) =>
                    {
                        var vals = new object[] { stream, encoding, l };
                        return (StreamWriter) ctor.Invoke(perm.Select(i => vals[i]).ToArray());
                    };
                return null;
            }

            var ctorParams = new[]
            {
                new[] { 0, 1, 2 }, // Unity 5.x and up
                new[] { 0, 1 }     // Unity 4.7 and older
            };

            cStreamWriterConstructor = ctorParams.Select(GetCtor).FirstOrDefault(f => f != null);
            if (cStreamWriterConstructor == null)
                throw new AmbiguousMatchException("Failed to find suitable constructor for CStreamWriter");
            return cStreamWriterConstructor;
        }
    }

    public static TextWriter CreateConsoleStreamWriter(Stream stream, Encoding encoding, bool leaveOpen)
    {
        var writer = CStreamWriterConstructor(stream, encoding, leaveOpen);
        writer.AutoFlush = true;
        return writer;
    }
}

```

`BepInEx.Core/Console/Unix/LinuxConsoleDriver.cs`:

```cs
using System;
using System.IO;
using BepInEx.Configuration;
using BepInEx.Logging;
using HarmonyLib;
using UnityInjector.ConsoleUtil;

namespace BepInEx.Unix;

internal class LinuxConsoleDriver : IConsoleDriver
{
    private static readonly ConfigEntry<bool> ForceCustomTtyDriverConfig =
        ConfigFile.CoreConfig.Bind(
                                   "Logging.Console",
                                   "ForceBepInExTTYDriver",
                                   false,
                                   "If enabled, forces to use custom BepInEx TTY driver for handling terminal output on unix.");

    static LinuxConsoleDriver()
    {
        UseMonoTtyDriver = false;

        if (ForceCustomTtyDriverConfig.Value)
            return;

        var consoleDriverType = typeof(Console).Assembly.GetType("System.ConsoleDriver");

        if (consoleDriverType != null)
            UseMonoTtyDriver = typeof(Console).Assembly.GetType("System.ParameterizedStrings") != null;
    }

    public static bool UseMonoTtyDriver { get; }

    public bool StdoutRedirected { get; private set; }

    public TtyInfo TtyInfo { get; private set; }

    public TextWriter StandardOut { get; private set; }
    public TextWriter ConsoleOut { get; private set; }

    public bool ConsoleActive { get; private set; }
    public bool ConsoleIsExternal => false;

    public void PreventClose()
    {
        // Not supported by all distros
    }

    public void Initialize(bool alreadyActive, bool useManagedEncoder)
    {
        // Console is always considered active on Unix
        ConsoleActive = true;

        StdoutRedirected = UnixStreamHelper.isatty(1) != 1;

        var duplicateStream = UnixStreamHelper.CreateDuplicateStream(1);

        if (UseMonoTtyDriver && !StdoutRedirected)
        {
            // Mono implementation handles xterm for us

            var writer = ConsoleWriter.CreateConsoleStreamWriter(duplicateStream, Console.Out.Encoding, true);

            StandardOut = TextWriter.Synchronized(writer);

            var driver = AccessTools.Field(AccessTools.TypeByName("System.ConsoleDriver"), "driver").GetValue(null);
            AccessTools.Field(AccessTools.TypeByName("System.TermInfoDriver"), "stdout").SetValue(driver, writer);
        }
        else
        {
            // Handle TTY ourselves

            var writer = new StreamWriter(duplicateStream, Console.Out.Encoding);

            writer.AutoFlush = true;

            StandardOut = TextWriter.Synchronized(writer);

            TtyInfo = TtyHandler.GetTtyInfo();
        }

        ConsoleOut = StandardOut;
    }

    public void CreateConsole(uint codepage) =>
        Logger.Log(LogLevel.Warning, "An external console currently cannot be spawned on a Unix platform.");

    public void DetachConsole() =>
        throw new PlatformNotSupportedException("Cannot detach console on a Unix platform");

    public void SetConsoleColor(ConsoleColor color)
    {
        if (StdoutRedirected)
            return;

        if (UseMonoTtyDriver)
            // Use mono's inbuilt terminfo driver to set the foreground color for us
            SafeConsole.ForegroundColor = color;
        else
            ConsoleOut.Write(TtyInfo.GetAnsiCode(color));
    }

    public void SetConsoleTitle(string title)
    {
        if (StdoutRedirected)
            return;

        if (UseMonoTtyDriver && SafeConsole.TitleExists)
            SafeConsole.Title = title;
        else
            ConsoleOut.Write($"\u001B]2;{title.Replace("\\", "\\\\")}\u0007");
    }
}

```

`BepInEx.Core/Console/Unix/TtyHandler.cs`:

```cs
// Sections of this code have been abridged from https://github.com/mono/mono/blob/master/mcs/class/corlib/System/TermInfoReader.cs under the MIT license

using System;
using System.IO;
using System.Linq;
using System.Text;

namespace BepInEx.Unix;

internal class TtyInfo
{
    public string TerminalType { get; set; } = "default";

    public int MaxColors { get; set; }

    public string[] ForegroundColorStrings { get; set; }

    public static TtyInfo Default { get; } = new()
    {
        MaxColors = 0
    };

    public string GetAnsiCode(ConsoleColor color)
    {
        if (MaxColors <= 0 || ForegroundColorStrings == null)
            return string.Empty;

        var index = (int) color % MaxColors;
        return ForegroundColorStrings[index];
    }
}

internal static class TtyHandler
{
    private static readonly string[] ncursesLocations =
    {
        "/usr/share/terminfo",
        "/etc/terminfo",
        "/usr/lib/terminfo",
        "/lib/terminfo"
    };

    private static string TryTermInfoDir(string dir, string term)
    {
        var infoFilePath = $"{dir}/{(int) term[0]:x}/{term}";

        if (File.Exists(infoFilePath))
            return infoFilePath;

        infoFilePath = Utility.CombinePaths(dir, term.Substring(0, 1), term);

        if (File.Exists(infoFilePath))
            return infoFilePath;

        return null;
    }

    private static string FindTermInfoPath(string term)
    {
        if (string.IsNullOrEmpty(term))
            return null;

        var termInfoVar = Environment.GetEnvironmentVariable("TERMINFO");
        if (termInfoVar != null && Directory.Exists(termInfoVar))
        {
            var text = TryTermInfoDir(termInfoVar, term);
            if (text != null) return text;
        }

        foreach (var location in ncursesLocations)
            if (Directory.Exists(location))
            {
                var text = TryTermInfoDir(location, term);

                if (text != null)
                    return text;
            }

        return null;
    }

    public static TtyInfo GetTtyInfo(string terminal = null)
    {
        terminal = terminal ?? Environment.GetEnvironmentVariable("TERM");
        var path = FindTermInfoPath(terminal);

        if (path == null)
            return TtyInfo.Default;

        var buffer = File.ReadAllBytes(path);

        var info = TtyInfoParser.Parse(buffer);
        info.TerminalType = terminal;

        return info;
    }
}

internal static class TtyInfoParser
{
    private static readonly int[] ansiColorMapping =
    {
        0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15
    };

    public static TtyInfo Parse(byte[] buffer)
    {
        int intSize;


        int magic = GetInt16(buffer, 0);

        switch (magic)
        {
            case 0x11a:
                intSize = 2;
                break;

            case 0x21E:
                intSize = 4;
                break;

            default:
                // Unknown ttyinfo format
                return TtyInfo.Default;
        }

        int boolFieldLength = GetInt16(buffer, 4);
        int intFieldLength = GetInt16(buffer, 6);
        int strOffsetFieldLength = GetInt16(buffer, 8);

        // Normally i'd put a more complete implementation here, but I only need to parse this info to get the max color count
        // Feel free to implement the rest of this using these sources:
        // https://github.com/mono/mono/blob/master/mcs/class/corlib/System/TermInfoReader.cs
        // https://invisible-island.net/ncurses/man/term.5.html
        // https://invisible-island.net/ncurses/man/terminfo.5.html

        var baseOffset = 12 + GetString(buffer, 12).Length + 1; // Skip the terminal name
        baseOffset += boolFieldLength;                          // Length of bool field section
        baseOffset += baseOffset % 2;                           // Correct for boundary

        var colorOffset =
            baseOffset
          + intSize * (int) TermInfoNumbers.MaxColors; // Finally the offset for the max color integer

        //int stringOffset = baseOffset + (intSize * intFieldLength);

        //int foregoundColorOffset =
        //	stringOffset
        //	+ (2 * (int)TermInfoStrings.SetAForeground);

        //foregoundColorOffset = stringOffset
        //					   + (2 * strOffsetFieldLength)
        //					   + GetInt16(buffer, foregoundColorOffset);

        var info = new TtyInfo();

        info.MaxColors = GetInteger(intSize, buffer, colorOffset);

        //string setForegroundTemplate = GetString(buffer, foregoundColorOffset);

        //info.ForegroundColorStrings = ansiColorMapping.Select(x => setForegroundTemplate.Replace("%p1%", x.ToString())).ToArray();
        info.ForegroundColorStrings =
            ansiColorMapping.Select(x => $"\u001B[{(x > 7 ? 82 + x : 30 + x)}m").ToArray();

        return info;
    }

    private static int GetInt32(byte[] buffer, int offset) =>
        buffer[offset]
      | (buffer[offset + 1] << 8)
      | (buffer[offset + 2] << 16)
      | (buffer[offset + 3] << 24);

    private static short GetInt16(byte[] buffer, int offset) =>
        (short) (buffer[offset]
               | (buffer[offset + 1] << 8));

    private static int GetInteger(int intSize, byte[] buffer, int offset) =>
        intSize == 2
            ? GetInt16(buffer, offset)
            : GetInt32(buffer, offset);

    private static string GetString(byte[] buffer, int offset)
    {
        var length = 0;

        while (buffer[offset + length] != 0x00)
            length++;

        return Encoding.ASCII.GetString(buffer, offset, length);
    }

    internal enum TermInfoNumbers
    {
        MaxColors = 13
    }

    internal enum TermInfoStrings
    {
        SetAForeground = 359
    }
}

```

`BepInEx.Core/Console/Unix/UnixStream.cs`:

```cs
using System;
using System.IO;
using System.Runtime.InteropServices;

namespace BepInEx.Unix;

internal class UnixStream : Stream
{
    public UnixStream(int fileDescriptor, FileAccess access)
    {
        Access = access;

        var newFd = UnixStreamHelper.dup(fileDescriptor);
        FileHandle = UnixStreamHelper.fdopen(newFd, access == FileAccess.Write ? "w" : "r");
    }

    public override bool CanRead => Access == FileAccess.Read || Access == FileAccess.ReadWrite;
    public override bool CanSeek => false;
    public override bool CanWrite => Access == FileAccess.Write || Access == FileAccess.ReadWrite;
    public override long Length => throw new InvalidOperationException();

    public override long Position
    {
        get => throw new InvalidOperationException();
        set => throw new InvalidOperationException();
    }


    public FileAccess Access { get; }

    public IntPtr FileHandle { get; }


    public override void Flush() => UnixStreamHelper.fflush(FileHandle);

    public override long Seek(long offset, SeekOrigin origin) => throw new InvalidOperationException();

    public override void SetLength(long value) => throw new InvalidOperationException();

    public override int Read(byte[] buffer, int offset, int count)
    {
        var gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);

        var read = UnixStreamHelper.fread(new IntPtr(gcHandle.AddrOfPinnedObject().ToInt64() + offset),
                                          (IntPtr) count, (IntPtr) 1, FileHandle);

        gcHandle.Free();

        return read.ToInt32();
    }

    public override void Write(byte[] buffer, int offset, int count)
    {
        var gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);

        UnixStreamHelper.fwrite(new IntPtr(gcHandle.AddrOfPinnedObject().ToInt64() + offset), (IntPtr) count,
                                (IntPtr) 1, FileHandle);

        gcHandle.Free();
    }

    private void ReleaseUnmanagedResources() => UnixStreamHelper.fclose(FileHandle);

    protected override void Dispose(bool disposing)
    {
        ReleaseUnmanagedResources();
        base.Dispose(disposing);
    }

    ~UnixStream()
    {
        Dispose(false);
    }
}

```

`BepInEx.Core/Console/Unix/UnixStreamHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using MonoMod.Utils;

namespace BepInEx.Unix;

internal static class UnixStreamHelper
{
    public delegate int dupDelegate(int fd);

    public delegate int fcloseDelegate(IntPtr stream);

    public delegate IntPtr fdopenDelegate(int fd, string mode);

    public delegate int fflushDelegate(IntPtr stream);

    public delegate IntPtr freadDelegate(IntPtr ptr, IntPtr size, IntPtr nmemb, IntPtr stream);

    public delegate int fwriteDelegate(IntPtr ptr, IntPtr size, IntPtr nmemb, IntPtr stream);

    public delegate int isattyDelegate(int fd);

    [DynDllImport("libc")]
    public static dupDelegate dup;

    [DynDllImport("libc")]
    public static fdopenDelegate fdopen;

    [DynDllImport("libc")]
    public static freadDelegate fread;

    [DynDllImport("libc")]
    public static fwriteDelegate fwrite;

    [DynDllImport("libc")]
    public static fcloseDelegate fclose;

    [DynDllImport("libc")]
    public static fflushDelegate fflush;

    [DynDllImport("libc")]
    public static isattyDelegate isatty;

    static UnixStreamHelper()
    {
        var libcMapping = new Dictionary<string, List<DynDllMapping>>
        {
            ["libc"] = new()
            {
                "libc.so.6",               // Ubuntu glibc
                "libc",                    // Linux glibc
                "/usr/lib/libSystem.dylib" // OSX POSIX
            }
        };

        typeof(UnixStreamHelper).ResolveDynDllImports(libcMapping);
    }

    public static Stream CreateDuplicateStream(int fileDescriptor)
    {
        var newFd = dup(fileDescriptor);

        return new UnixStream(newFd, FileAccess.Write);
    }
}

```

`BepInEx.Core/Console/Windows/ConsoleEncoding/ConsoleEncoding.Buffers.cs`:

```cs
// --------------------------------------------------
// UnityInjector - ConsoleEncoding.Buffers.cs
// Copyright (c) Usagirei 2015 - 2015
// --------------------------------------------------

namespace UnityInjector.ConsoleUtil;
// --------------------------------------------------
// Code ported from
// https://gist.github.com/asm256/9bfb88336a1433e2328a
// Which in turn was seemingly ported from
// http://jonskeet.uk/csharp/ebcdic/
// using only safe (managed) code
// --------------------------------------------------

internal partial class ConsoleEncoding
{
    private readonly byte[] _zeroByte = new byte[0];
    private readonly char[] _zeroChar = new char[0];
    private byte[] _byteBuffer = new byte[256];
    private char[] _charBuffer = new char[256];

    private void ExpandByteBuffer(int count)
    {
        if (_byteBuffer.Length < count)
            _byteBuffer = new byte[count];
    }

    private void ExpandCharBuffer(int count)
    {
        if (_charBuffer.Length < count)
            _charBuffer = new char[count];
    }

    private void ReadByteBuffer(byte[] bytes, int index, int count)
    {
        for (var i = 0; i < count; i++)
            bytes[index + i] = _byteBuffer[i];
    }

    private void ReadCharBuffer(char[] chars, int index, int count)
    {
        for (var i = 0; i < count; i++)
            chars[index + i] = _charBuffer[i];
    }

    private void WriteByteBuffer(byte[] bytes, int index, int count)
    {
        ExpandByteBuffer(count);
        for (var i = 0; i < count; i++)
            _byteBuffer[i] = bytes[index + i];
    }

    private void WriteCharBuffer(char[] chars, int index, int count)
    {
        ExpandCharBuffer(count);
        for (var i = 0; i < count; i++)
            _charBuffer[i] = chars[index + i];
    }
}

```

`BepInEx.Core/Console/Windows/ConsoleEncoding/ConsoleEncoding.PInvoke.cs`:

```cs
// --------------------------------------------------
// UnityInjector - ConsoleEncoding.PInvoke.cs
// Copyright (c) Usagirei 2015 - 2015
// --------------------------------------------------

using System;
using System.Runtime.InteropServices;

namespace UnityInjector.ConsoleUtil;

// --------------------------------------------------
// Code ported from
// https://gist.github.com/asm256/9bfb88336a1433e2328a
// Which in turn was seemingly ported from
// http://jonskeet.uk/csharp/ebcdic/
// using only safe (managed) code
// --------------------------------------------------
internal partial class ConsoleEncoding
{
    [DllImport("kernel32.dll")]
    private static extern uint GetConsoleOutputCP();

    [DllImport("kernel32.dll")]
    private static extern uint GetACP();

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern int MultiByteToWideChar(uint codePage,
                                                  uint dwFlags,
                                                  [In] [MarshalAs(UnmanagedType.LPArray)]
                                                  byte[] lpMultiByteStr,
                                                  int cbMultiByte,
                                                  [Out] [MarshalAs(UnmanagedType.LPWStr)]
                                                  char[] lpWideCharStr,
                                                  int cchWideChar);

    [DllImport("kernel32.dll")]
    private static extern IntPtr SetConsoleOutputCP(uint codepage);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern int WideCharToMultiByte(uint codePage,
                                                  uint dwFlags,
                                                  [In] [MarshalAs(UnmanagedType.LPWStr)] char[] lpWideCharStr,
                                                  int cchWideChar,
                                                  [Out] [MarshalAs(UnmanagedType.LPArray)]
                                                  byte[] lpMultiByteStr,
                                                  int cbMultiByte,
                                                  IntPtr lpDefaultChar,
                                                  IntPtr lpUsedDefaultChar);
}

```

`BepInEx.Core/Console/Windows/ConsoleEncoding/ConsoleEncoding.cs`:

```cs
// --------------------------------------------------
// UnityInjector - ConsoleEncoding.cs
// Copyright (c) Usagirei 2015 - 2015
// --------------------------------------------------

using System;
using System.Text;

namespace UnityInjector.ConsoleUtil;

// --------------------------------------------------
// Code ported from
// https://gist.github.com/asm256/9bfb88336a1433e2328a
// Which in turn was seemingly ported from
// http://jonskeet.uk/csharp/ebcdic/
// using only safe (managed) code
// --------------------------------------------------
internal partial class ConsoleEncoding : Encoding
{
    private readonly uint _codePage;

    private ConsoleEncoding(uint codePage)
    {
        _codePage = codePage;
    }

    public override int CodePage => (int)_codePage;

    public static Encoding OutputEncoding => new ConsoleEncoding(ConsoleCodePage);

    public static uint ConsoleCodePage
    {
        get => GetConsoleOutputCP();
        set => SetConsoleOutputCP(value);
    }

    public static uint GetActiveCodePage() => GetACP();

    public static ConsoleEncoding GetEncoding(uint codePage) => new(codePage);

    public override int GetByteCount(char[] chars, int index, int count)
    {
        WriteCharBuffer(chars, index, count);
        var result = WideCharToMultiByte(_codePage, 0, chars, count, _zeroByte, 0, IntPtr.Zero, IntPtr.Zero);
        return result;
    }

    public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
    {
        var byteCount = GetByteCount(chars, charIndex, charCount);
        WriteCharBuffer(chars, charIndex, charCount);
        ExpandByteBuffer(byteCount);
        _ = WideCharToMultiByte(_codePage, 0, chars, charCount, _byteBuffer, byteCount, IntPtr.Zero,
                                IntPtr.Zero);
        var readCount = Math.Min(bytes.Length, byteCount);
        ReadByteBuffer(bytes, byteIndex, readCount);
        return readCount;
    }

    public override int GetCharCount(byte[] bytes, int index, int count)
    {
        WriteByteBuffer(bytes, index, count);
        var result = MultiByteToWideChar(_codePage, 0, bytes, count, _zeroChar, 0);
        return result;
    }

    public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
    {
        var charCount = GetCharCount(bytes, byteIndex, byteCount);
        WriteByteBuffer(bytes, byteIndex, byteCount);
        ExpandCharBuffer(charCount);
        _ = MultiByteToWideChar(_codePage, 0, bytes, byteCount, _charBuffer, charCount);
        var readCount = Math.Min(chars.Length, charCount);
        ReadCharBuffer(chars, charIndex, readCount);
        return readCount;
    }

    // Account for some exotic UTF-8 characters
    public override int GetMaxByteCount(int charCount) => charCount * 4;
    public override int GetMaxCharCount(int byteCount) => byteCount;
}

```

`BepInEx.Core/Console/Windows/ConsoleWindow.cs`:

```cs
// --------------------------------------------------
// UnityInjector - ConsoleWindow.cs
// Copyright (c) Usagirei 2015 - 2015
// --------------------------------------------------

using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using BepInEx;
using BepInEx.ConsoleUtil;
using MonoMod.Utils;

namespace UnityInjector.ConsoleUtil;

internal class ConsoleWindow
{
    private const int STD_OUTPUT_HANDLE = -11;
    private const uint SC_CLOSE = 0xF060;
    private const uint MF_BYCOMMAND = 0x00000000;

    private const uint LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800;
    public static IntPtr ConsoleOutHandle;
    public static IntPtr OriginalStdoutHandle;

    private static bool methodsInited;
    private static SetForegroundWindowDelegate setForeground;
    private static GetForegroundWindowDelegate getForeground;
    private static GetSystemMenuDelegate getSystemMenu;
    private static DeleteMenuDelegate deleteMenu;
    public static bool IsAttached { get; private set; }

    public static string Title
    {
        set
        {
            if (!IsAttached)
                return;

            if (value == null)
                throw new ArgumentNullException(nameof(value));

            if (value.Length > 24500)
                throw new InvalidOperationException("Console title too long");

            if (!SetConsoleTitle(value))
                throw new InvalidOperationException("Console title invalid");
        }
    }

    public static void Attach()
    {
        if (IsAttached)
            return;
        Initialize();

        if (OriginalStdoutHandle == IntPtr.Zero)
            OriginalStdoutHandle = GetStdHandle(STD_OUTPUT_HANDLE);

        var cur = GetConsoleWindow();

        if (cur == IntPtr.Zero)
        {
            // Store Current Window
            var currWnd = getForeground();

            if (!AllocConsole())
            {
                var error = Marshal.GetLastWin32Error();
                if (error != 5) throw new Win32Exception("AllocConsole() failed");
            }

            // Restore Foreground
            setForeground(currWnd);
        }

        ConsoleOutHandle = CreateFile("CONOUT$", 0x80000000 | 0x40000000, 2, IntPtr.Zero, 3, 0, IntPtr.Zero);
        Kon.conOut = ConsoleOutHandle;

        if (!SetStdHandle(STD_OUTPUT_HANDLE, ConsoleOutHandle))
            throw new Win32Exception("SetStdHandle() failed");

        if (OriginalStdoutHandle != IntPtr.Zero && ConsoleManager.ConfigConsoleOutRedirectType.Value ==
            ConsoleManager.ConsoleOutRedirectType.ConsoleOut)
            CloseHandle(OriginalStdoutHandle);

        IsAttached = true;
    }

    public static void PreventClose()
    {
        if (!IsAttached)
            return;
        Initialize();

        var hwnd = GetConsoleWindow();
        var hmenu = getSystemMenu(hwnd, false);
        if (hmenu != IntPtr.Zero)
            deleteMenu(hmenu, SC_CLOSE, MF_BYCOMMAND);
    }

    public static void Detach()
    {
        if (!IsAttached)
            return;

        if (!CloseHandle(ConsoleOutHandle))
            throw new Win32Exception("CloseHandle() failed");

        ConsoleOutHandle = IntPtr.Zero;

        if (!FreeConsole())
            throw new Win32Exception("FreeConsole() failed");

        if (!SetStdHandle(STD_OUTPUT_HANDLE, OriginalStdoutHandle))
            throw new Win32Exception("SetStdHandle() failed");

        IsAttached = false;
    }

    private static void Initialize()
    {
        if (methodsInited)
            return;
        methodsInited = true;

        // Some games may ship user32.dll with some methods missing. As such, we load the DLL explicitly from system folder
        var user32Dll = LoadLibraryEx("user32.dll", IntPtr.Zero, LOAD_LIBRARY_SEARCH_SYSTEM32);
        setForeground = GetProcAddress(user32Dll, "SetForegroundWindow").AsDelegate<SetForegroundWindowDelegate>();
        getForeground = GetProcAddress(user32Dll, "GetForegroundWindow").AsDelegate<GetForegroundWindowDelegate>();
        getSystemMenu = GetProcAddress(user32Dll, "GetSystemMenu").AsDelegate<GetSystemMenuDelegate>();
        deleteMenu = GetProcAddress(user32Dll, "DeleteMenu").AsDelegate<DeleteMenuDelegate>();
    }

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool AllocConsole();

    [DllImport("kernel32.dll")]
    private static extern IntPtr GetConsoleWindow();

    [DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
    private static extern bool CloseHandle(IntPtr handle);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr CreateFile(string fileName,
                                            uint desiredAccess,
                                            int shareMode,
                                            IntPtr securityAttributes,
                                            int creationDisposition,
                                            int flagsAndAttributes,
                                            IntPtr templateFile);

    [DllImport("kernel32.dll", SetLastError = false)]
    private static extern bool FreeConsole();

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetStdHandle(int nStdHandle);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool SetStdHandle(int nStdHandle, IntPtr hConsoleOutput);

    [DllImport("kernel32.dll", BestFitMapping = true, CharSet = CharSet.Auto, SetLastError = true)]
    private static extern bool SetConsoleTitle(string title);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr LoadLibraryEx(string lpLibFileName, IntPtr hFile, uint dwFlags);


    [UnmanagedFunctionPointer(CallingConvention.Winapi)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private delegate bool SetForegroundWindowDelegate(IntPtr hWnd);

    [UnmanagedFunctionPointer(CallingConvention.Winapi)]
    private delegate IntPtr GetForegroundWindowDelegate();

    [UnmanagedFunctionPointer(CallingConvention.Winapi)]
    private delegate IntPtr GetSystemMenuDelegate(IntPtr hwnd, bool bRevert);

    [UnmanagedFunctionPointer(CallingConvention.Winapi)]
    private delegate bool DeleteMenuDelegate(IntPtr hMenu, uint uPosition, uint uFlags);
}

```

`BepInEx.Core/Console/Windows/Kon.cs`:

```cs
using System;
using System.Runtime.InteropServices;
#if NET35
using System.Security.Permissions;

#endif

namespace BepInEx.ConsoleUtil
{
    internal class Kon
    {
        #region pinvoke

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool GetConsoleScreenBufferInfo(IntPtr hConsoleOutput,
                                                              out CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool SetConsoleTextAttribute(IntPtr hConsoleOutput, short attributes);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr GetStdHandle(int nStdHandle);

        #endregion

        #region Types

        private struct CONSOLE_SCREEN_BUFFER_INFO
        {
            internal COORD dwSize;
            internal COORD dwCursorPosition;
            internal short wAttributes;
            internal SMALL_RECT srWindow;
            internal COORD dwMaximumWindowSize;
        }

        private struct COORD
        {
            internal short X;
            internal short Y;
        }

        private struct SMALL_RECT
        {
            internal short Left;
            internal short Top;
            internal short Right;
            internal short Bottom;
        }

        private static readonly IntPtr INVALID_HANDLE_VALUE = new(-1);

        #endregion

        #region Private

        private static short ConsoleColorToColorAttribute(short color, bool isBackground)
        {
            if ((color & -16) != 0)
                throw new ArgumentException("Arg_InvalidConsoleColor");
            if (isBackground)
                color <<= 4;
            return color;
        }

        private static CONSOLE_SCREEN_BUFFER_INFO GetBufferInfo(bool throwOnNoConsole, out bool succeeded)
        {
            succeeded = false;
            if (!(conOut == INVALID_HANDLE_VALUE))
            {
                CONSOLE_SCREEN_BUFFER_INFO console_SCREEN_BUFFER_INFO;
                if (!GetConsoleScreenBufferInfo(conOut, out console_SCREEN_BUFFER_INFO))
                {
                    var consoleScreenBufferInfo =
                        GetConsoleScreenBufferInfo(GetStdHandle(-12), out console_SCREEN_BUFFER_INFO);
                    if (!consoleScreenBufferInfo)
                        consoleScreenBufferInfo =
                            GetConsoleScreenBufferInfo(GetStdHandle(-10), out console_SCREEN_BUFFER_INFO);

                    if (!consoleScreenBufferInfo)
                        if (Marshal.GetLastWin32Error() == 6 && !throwOnNoConsole)
                            return default;
                }

                succeeded = true;
                return console_SCREEN_BUFFER_INFO;
            }

            if (!throwOnNoConsole)
                return default;
            throw new Exception("IO.IO_NoConsole");
        }

        private static void SetConsoleColor(bool isBackground, ConsoleColor c)
        {
#if NET35
            new UIPermission(UIPermissionWindow.SafeTopLevelWindows).Demand();
#endif
            var color = ConsoleColorToColorAttribute((short) c, isBackground);
            bool flag;
            var bufferInfo = GetBufferInfo(false, out flag);
            if (!flag)
                return;
            var num = bufferInfo.wAttributes;
            num &= (short) (isBackground ? -241 : -16);
            num = (short) ((ushort) num | (ushort) color);
            SetConsoleTextAttribute(conOut, num);
        }

        private static ConsoleColor GetConsoleColor(bool isBackground)
        {
            bool flag;
            var bufferInfo = GetBufferInfo(false, out flag);
            if (!flag)
                return isBackground ? ConsoleColor.Black : ConsoleColor.Gray;
            return ColorAttributeToConsoleColor((short) (bufferInfo.wAttributes & 240));
        }

        private static ConsoleColor ColorAttributeToConsoleColor(short c)
        {
            if ((short) (c & 255) != 0)
                c >>= 4;
            return (ConsoleColor) c;
        }

        internal static IntPtr conOut = IntPtr.Zero;

        #endregion

        #region Public

        public static void ResetConsoleColor()
        {
            SetConsoleColor(true, ConsoleColor.Black);
            SetConsoleColor(false, ConsoleColor.Gray);
        }

        public static ConsoleColor ForegroundColor
        {
            get => GetConsoleColor(false);
            set => SetConsoleColor(false, value);
        }

        public static ConsoleColor BackgroundColor
        {
            get => GetConsoleColor(true);
            set => SetConsoleColor(true, value);
        }

        #endregion
    }
}

```

`BepInEx.Core/Console/Windows/WindowsConsoleDriver.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using BepInEx.ConsoleUtil;
using HarmonyLib;
using Microsoft.Win32.SafeHandles;
using MonoMod.Utils;
using UnityInjector.ConsoleUtil;

namespace BepInEx;

internal class WindowsConsoleDriver : IConsoleDriver
{
    // Apparently on some versions of Unity (e.g. 2018.4) using old mono causes crashes on game close if
    // IntPtr overload is used for file streams (check #139).
    // On the other hand, not all Unity games come with SafeFileHandle overload for FileStream
    // As such, we're trying to use SafeFileHandle when it's available and go back to IntPtr overload if not available
    private static readonly ConstructorInfo FileStreamCtor = new[]
    {
        AccessTools.Constructor(typeof(FileStream), new[] { typeof(SafeFileHandle), typeof(FileAccess) }),
        AccessTools.Constructor(typeof(FileStream), new[] { typeof(IntPtr), typeof(FileAccess) })
    }.FirstOrDefault(m => m != null);

    private readonly Func<int> getWindowHeight = AccessTools
                                                 .PropertyGetter(typeof(Console), nameof(Console.WindowHeight))
                                                 ?.CreateDelegate<Func<int>>();

    private readonly Func<int> getWindowWidth = AccessTools
                                                .PropertyGetter(typeof(Console), nameof(Console.WindowWidth))
                                                ?.CreateDelegate<Func<int>>();

    private bool useManagedEncoder;

    private int ConsoleWidth
    {
        get
        {
            try
            {
                return getWindowWidth?.Invoke() ?? 0;
            }
            catch (IOException)
            {
                return 0;
            }
        }
    }

    private int ConsoleHeight
    {
        get
        {
            try
            {
                return getWindowHeight?.Invoke() ?? 0;
            }
            catch (IOException)
            {
                return 0;
            }
        }
    }

    public TextWriter StandardOut { get; private set; }
    public TextWriter ConsoleOut { get; private set; }

    public bool ConsoleActive { get; private set; }
    public bool ConsoleIsExternal => true;

    public void Initialize(bool alreadyActive, bool useManagedEncoder)
    {
        ConsoleActive = alreadyActive;
        this.useManagedEncoder = useManagedEncoder;

        if (ConsoleActive)
        {
            // We're in a .NET framework / XNA environment; console *is* stdout
            ConsoleOut = Console.Out;
            StandardOut = new StreamWriter(Console.OpenStandardOutput());
        }
        else
        {
            StandardOut = Console.Out;
        }
    }

    public void CreateConsole(uint codepage)
    {
        ConsoleWindow.Attach();

        // Make sure of ConsoleEncoding helper class because on some Monos
        // Encoding.GetEncoding throws NotImplementedException on most codepages
        // NOTE: We don't set Console.OutputEncoding because it resets any existing Console.Out writers
        if (!useManagedEncoder)
            ConsoleEncoding.ConsoleCodePage = codepage;

        // If stdout exists, write to it, otherwise make it the same as console out
        // Not sure if this is needed? Does the original Console.Out still work?
        var stdout = GetOutHandle();
        if (stdout == IntPtr.Zero)
        {
            StandardOut = TextWriter.Null;
            ConsoleOut = TextWriter.Null;
            return;
        }

        var originalOutStream = OpenFileStream(stdout);
        StandardOut = new StreamWriter(originalOutStream, Utility.UTF8NoBom)
        {
            AutoFlush = true
        };

        var consoleOutStream = OpenFileStream(ConsoleWindow.ConsoleOutHandle);
        // Can't use Console.OutputEncoding because it can be null (i.e. not preference by user)
        ConsoleOut = new StreamWriter(consoleOutStream,
                                      useManagedEncoder ? Utility.UTF8NoBom : ConsoleEncoding.OutputEncoding)
        {
            AutoFlush = true
        };
        ConsoleActive = true;
    }

    public void PreventClose() => ConsoleWindow.PreventClose();

    public void DetachConsole()
    {
        ConsoleWindow.Detach();

        ConsoleOut.Close();
        ConsoleOut = null;

        ConsoleActive = false;
    }

    public void SetConsoleColor(ConsoleColor color)
    {
        SafeConsole.ForegroundColor = color;
        Kon.ForegroundColor = color;
    }

    public void SetConsoleTitle(string title) => ConsoleWindow.Title = title;

    private static Stream OpenFileStream(IntPtr handle)
    {
        if (ReflectionHelper.IsCore)
        {
            var windowsConsoleStreamType = Type.GetType("System.ConsolePal+WindowsConsoleStream, System.Console", true);
            var constructor = AccessTools.Constructor(windowsConsoleStreamType,
                                                      new[] { typeof(IntPtr), typeof(FileAccess), typeof(bool) });
            return (Stream)constructor.Invoke(new object[] { handle, FileAccess.Write, true });
        }

        var fileHandle = new SafeFileHandle(handle, false);
        var ctorParams = AccessTools.ActualParameters(FileStreamCtor,
                                                      new object[]
                                                      {
                                                          fileHandle, fileHandle.DangerousGetHandle(),
                                                          FileAccess.Write
                                                      });
        return (FileStream) Activator.CreateInstance(typeof(FileStream), ctorParams);
    }

    private IntPtr GetOutHandle()
    {
        switch (ConsoleManager.ConfigConsoleOutRedirectType.Value)
        {
            case ConsoleManager.ConsoleOutRedirectType.ConsoleOut:
                return ConsoleWindow.ConsoleOutHandle;
            case ConsoleManager.ConsoleOutRedirectType.StandardOut:
                return ConsoleWindow.OriginalStdoutHandle;
            case ConsoleManager.ConsoleOutRedirectType.Auto:
            default:
                return ConsoleWindow.OriginalStdoutHandle != IntPtr.Zero
                           ? ConsoleWindow.OriginalStdoutHandle
                           : ConsoleWindow.ConsoleOutHandle;
        }
    }
}

```

`BepInEx.Core/Contract/Attributes.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using BepInEx.Bootstrap;
using Mono.Cecil;
using Range = SemanticVersioning.Range;
using Version = SemanticVersioning.Version;

namespace BepInEx;

#region BaseUnityPlugin

/// <summary>
///     This attribute denotes that a class is a plugin, and specifies the required metadata.
/// </summary>
[AttributeUsage(AttributeTargets.Class)]
public class BepInPlugin : Attribute
{
    /// <param name="GUID">The unique identifier of the plugin. Should not change between plugin versions.</param>
    /// <param name="Name">The user friendly name of the plugin. Is able to be changed between versions.</param>
    /// <param name="Version">The specific version of the plugin.</param>
    public BepInPlugin(string GUID, string Name, string Version)
    {
        this.GUID = GUID;
        this.Name = Name;
        this.Version = TryParseLongVersion(Version);
    }

    /// <summary>
    ///     The unique identifier of the plugin. Should not change between plugin versions.
    /// </summary>
    public string GUID { get; protected set; }


    /// <summary>
    ///     The user friendly name of the plugin. Is able to be changed between versions.
    /// </summary>
    public string Name { get; protected set; }


    /// <summary>
    ///     The specific version of the plugin.
    /// </summary>
    public Version Version { get; protected set; }

    private static Version TryParseLongVersion(string version)
    {
        if (Version.TryParse(version, out var v))
            return v;

        // no System.Version.TryParse() on .NET 3.5
        try
        {
            var longVersion = new System.Version(version);

            return new Version(longVersion.Major, longVersion.Minor,
                               longVersion.Build != -1 ? longVersion.Build : 0);
        }
        catch { }

        return null;
    }

    internal static BepInPlugin FromCecilType(TypeDefinition td)
    {
        var attr = MetadataHelper.GetCustomAttributes<BepInPlugin>(td, false).FirstOrDefault();

        if (attr == null)
            return null;

        return new BepInPlugin((string) attr.ConstructorArguments[0].Value,
                               (string) attr.ConstructorArguments[1].Value,
                               (string) attr.ConstructorArguments[2].Value);
    }
}

/// <summary>
///     This attribute specifies any dependencies that this plugin has on other plugins.
/// </summary>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class BepInDependency : Attribute, ICacheable
{
    /// <summary>
    ///     Flags that are applied to a dependency
    /// </summary>
    [Flags]
    public enum DependencyFlags
    {
        /// <summary>
        ///     The plugin has a hard dependency on the referenced plugin, and will not run without it.
        /// </summary>
        HardDependency = 1,

        /// <summary>
        ///     This plugin has a soft dependency on the referenced plugin, and is able to run without it.
        /// </summary>
        SoftDependency = 2
    }

    /// <summary>
    ///     Marks this <see cref="BaseUnityPlugin" /> as dependent on another plugin. The other plugin will be loaded before
    ///     this one.
    ///     If the other plugin doesn't exist, what happens depends on the <see cref="Flags" /> parameter.
    /// </summary>
    /// <param name="DependencyGUID">The GUID of the referenced plugin.</param>
    /// <param name="Flags">The flags associated with this dependency definition.</param>
    public BepInDependency(string DependencyGUID, DependencyFlags Flags = DependencyFlags.HardDependency)
    {
        this.DependencyGUID = DependencyGUID;
        this.Flags = Flags;
        VersionRange = null;
    }

    /// <summary>
    ///     Marks this <see cref="BaseUnityPlugin" /> as dependent on another plugin. The other plugin will be loaded before
    ///     this one.
    ///     If the other plugin doesn't exist or is of a version not satisfying <see cref="VersionRange" />, this plugin will
    ///     not load and an error will be logged instead.
    /// </summary>
    /// <param name="guid">The GUID of the referenced plugin.</param>
    /// <param name="version">The version range of the referenced plugin.</param>
    /// <remarks>When version is supplied the dependency is always treated as HardDependency</remarks>
    public BepInDependency(string guid, string version) : this(guid)
    {
        VersionRange = Range.Parse(version);
    }

    /// <summary>
    ///     The GUID of the referenced plugin.
    /// </summary>
    public string DependencyGUID { get; protected set; }

    /// <summary>
    ///     The flags associated with this dependency definition.
    /// </summary>
    public DependencyFlags Flags { get; protected set; }

    /// <summary>
    ///     The version <see cref="SemVer.Range">range</see> of the referenced plugin.
    /// </summary>
    public Range VersionRange { get; protected set; }

    void ICacheable.Save(BinaryWriter bw)
    {
        bw.Write(DependencyGUID);
        bw.Write((int) Flags);
        bw.Write(VersionRange?.ToString() ?? string.Empty);
    }

    void ICacheable.Load(BinaryReader br)
    {
        DependencyGUID = br.ReadString();
        Flags = (DependencyFlags) br.ReadInt32();

        var versionRange = br.ReadString();
        VersionRange = versionRange == string.Empty ? null : Range.Parse(versionRange);
    }

    internal static IEnumerable<BepInDependency> FromCecilType(TypeDefinition td)
    {
        var attrs = MetadataHelper.GetCustomAttributes<BepInDependency>(td, true);
        return attrs.Select(customAttribute =>
        {
            var dependencyGuid = (string) customAttribute.ConstructorArguments[0].Value;
            var secondArg = customAttribute.ConstructorArguments[1].Value;
            if (secondArg is string minVersion) return new BepInDependency(dependencyGuid, minVersion);
            return new BepInDependency(dependencyGuid, (DependencyFlags) secondArg);
        }).ToList();
    }
}

/// <summary>
///     This attribute specifies other plugins that are incompatible with this plugin.
/// </summary>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class BepInIncompatibility : Attribute, ICacheable
{
    /// <summary>
    ///     Marks this <see cref="BaseUnityPlugin" /> as incompatible with another plugin.
    ///     If the other plugin exists, this plugin will not be loaded and a warning will be shown.
    /// </summary>
    /// <param name="IncompatibilityGUID">The GUID of the referenced plugin.</param>
    public BepInIncompatibility(string IncompatibilityGUID)
    {
        this.IncompatibilityGUID = IncompatibilityGUID;
    }

    /// <summary>
    ///     The GUID of the referenced plugin.
    /// </summary>
    public string IncompatibilityGUID { get; protected set; }

    void ICacheable.Save(BinaryWriter bw) => bw.Write(IncompatibilityGUID);

    void ICacheable.Load(BinaryReader br) => IncompatibilityGUID = br.ReadString();

    internal static IEnumerable<BepInIncompatibility> FromCecilType(TypeDefinition td)
    {
        var attrs = MetadataHelper.GetCustomAttributes<BepInIncompatibility>(td, true);
        return attrs.Select(customAttribute =>
        {
            var dependencyGuid = (string) customAttribute.ConstructorArguments[0].Value;
            return new BepInIncompatibility(dependencyGuid);
        }).ToList();
    }
}

/// <summary>
///     This attribute specifies which processes this plugin should be run for. Not specifying this attribute will load the
///     plugin under every process.
/// </summary>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class BepInProcess : Attribute
{
    /// <param name="ProcessName">The name of the process that this plugin will run under.</param>
    public BepInProcess(string ProcessName)
    {
        this.ProcessName = ProcessName;
    }

    /// <summary>
    ///     The name of the process that this plugin will run under.
    /// </summary>
    public string ProcessName { get; protected set; }

    internal static List<BepInProcess> FromCecilType(TypeDefinition td)
    {
        var attrs = MetadataHelper.GetCustomAttributes<BepInProcess>(td, true);
        return attrs.Select(customAttribute =>
                                new BepInProcess((string) customAttribute.ConstructorArguments[0].Value)).ToList();
    }
}

#endregion

#region MetadataHelper

/// <summary>
///     Helper class to use for retrieving metadata about a plugin, defined as attributes.
/// </summary>
public static class MetadataHelper
{
    internal static IEnumerable<CustomAttribute> GetCustomAttributes<T>(TypeDefinition td, bool inherit)
        where T : Attribute
    {
        var result = new List<CustomAttribute>();
        var type = typeof(T);
        var currentType = td;

        do
        {
            result.AddRange(currentType.CustomAttributes.Where(ca => ca.AttributeType.FullName == type.FullName));
            currentType = currentType.BaseType?.Resolve();
        } while (inherit && currentType?.FullName != "System.Object");


        return result;
    }

    /// <summary>
    ///     Retrieves the BepInPlugin metadata from a plugin type.
    /// </summary>
    /// <param name="pluginType">The plugin type.</param>
    /// <returns>The BepInPlugin metadata of the plugin type.</returns>
    public static BepInPlugin GetMetadata(Type pluginType)
    {
        var attributes = pluginType.GetCustomAttributes(typeof(BepInPlugin), false);

        if (attributes.Length == 0)
            return null;

        return (BepInPlugin) attributes[0];
    }

    /// <summary>
    ///     Retrieves the BepInPlugin metadata from a plugin instance.
    /// </summary>
    /// <param name="plugin">The plugin instance.</param>
    /// <returns>The BepInPlugin metadata of the plugin instance.</returns>
    public static BepInPlugin GetMetadata(object plugin) => GetMetadata(plugin.GetType());

    /// <summary>
    ///     Gets the specified attributes of a type, if they exist.
    /// </summary>
    /// <typeparam name="T">The attribute type to retrieve.</typeparam>
    /// <param name="pluginType">The plugin type.</param>
    /// <returns>The attributes of the type, if existing.</returns>
    public static T[] GetAttributes<T>(Type pluginType) where T : Attribute =>
        (T[]) pluginType.GetCustomAttributes(typeof(T), true);

    /// <summary>
    ///     Gets the specified attributes of an assembly, if they exist.
    /// </summary>
    /// <param name="assembly">The assembly.</param>
    /// <typeparam name="T">The attribute type to retrieve.</typeparam>
    /// <returns>The attributes of the type, if existing.</returns>
    public static T[] GetAttributes<T>(Assembly assembly) where T : Attribute =>
        (T[]) assembly.GetCustomAttributes(typeof(T), true);

    /// <summary>
    ///     Gets the specified attributes of an instance, if they exist.
    /// </summary>
    /// <typeparam name="T">The attribute type to retrieve.</typeparam>
    /// <param name="plugin">The plugin instance.</param>
    /// <returns>The attributes of the instance, if existing.</returns>
    public static IEnumerable<T> GetAttributes<T>(object plugin) where T : Attribute =>
        GetAttributes<T>(plugin.GetType());

    /// <summary>
    ///     Gets the specified attributes of a reflection metadata type, if they exist.
    /// </summary>
    /// <typeparam name="T">The attribute type to retrieve.</typeparam>
    /// <param name="member">The reflection metadata instance.</param>
    /// <returns>The attributes of the instance, if existing.</returns>
    public static T[] GetAttributes<T>(MemberInfo member) where T : Attribute =>
        (T[]) member.GetCustomAttributes(typeof(T), true);

    /// <summary>
    ///     Retrieves the dependencies of the specified plugin type.
    /// </summary>
    /// <param name="plugin">The plugin type.</param>
    /// <returns>A list of all plugin types that the specified plugin type depends upon.</returns>
    public static IEnumerable<BepInDependency> GetDependencies(Type plugin) =>
        plugin.GetCustomAttributes(typeof(BepInDependency), true).Cast<BepInDependency>();
}

#endregion

```

`BepInEx.Core/Contract/IPlugin.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using BepInEx.Configuration;
using BepInEx.Logging;

namespace BepInEx.Contract
{
  public interface IPlugin
  {
	  /// <summary>
	  /// Information about this plugin as it was loaded.
	  /// </summary>
	  PluginInfo Info { get; }

	  /// <summary>
	  /// Logger instance tied to this plugin.
	  /// </summary>
	  ManualLogSource Logger { get; }

	  /// <summary>
	  /// Default config file tied to this plugin. The config file will not be created until 
	  /// any settings are added and changed, or <see cref="ConfigFile.Save"/> is called.
	  /// </summary>
	  ConfigFile Config { get; }
  }
}

```

`BepInEx.Core/Contract/PluginInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using BepInEx.Bootstrap;

namespace BepInEx;

/// <summary>
///     Data class that represents information about a loadable BepInEx plugin.
///     Contains all metadata and additional info required for plugin loading by <see cref="Chainloader" />.
/// </summary>
public class PluginInfo : ICacheable
{
    /// <summary>
    ///     General metadata about a plugin.
    /// </summary>
    public BepInPlugin Metadata { get; internal set; }

    /// <summary>
    ///     Collection of <see cref="BepInProcess" /> attributes that describe what processes the plugin can run on.
    /// </summary>
    public IEnumerable<BepInProcess> Processes { get; internal set; }

    /// <summary>
    ///     Collection of <see cref="BepInDependency" /> attributes that describe what plugins this plugin depends on.
    /// </summary>
    public IEnumerable<BepInDependency> Dependencies { get; internal set; }

    /// <summary>
    ///     Collection of <see cref="BepInIncompatibility" /> attributes that describe what plugins this plugin
    ///     is incompatible with.
    /// </summary>
    public IEnumerable<BepInIncompatibility> Incompatibilities { get; internal set; }

    /// <summary>
    ///     File path to the plugin DLL
    /// </summary>
    public string Location { get; internal set; }

    /// <summary>
    ///     Instance of the plugin that represents this info. NULL if no plugin is instantiated from info (yet)
    /// </summary>
    public object Instance { get; internal set; }

    public string TypeName { get; internal set; }

    internal Version TargettedBepInExVersion { get; set; }

    void ICacheable.Save(BinaryWriter bw)
    {
        bw.Write(TypeName);
        bw.Write(Location);

        bw.Write(Metadata.GUID);
        bw.Write(Metadata.Name);
        bw.Write(Metadata.Version.ToString());

        var processList = Processes.ToList();
        bw.Write(processList.Count);
        foreach (var bepInProcess in processList)
            bw.Write(bepInProcess.ProcessName);

        var depList = Dependencies.ToList();
        bw.Write(depList.Count);
        foreach (var bepInDependency in depList)
            ((ICacheable) bepInDependency).Save(bw);

        var incList = Incompatibilities.ToList();
        bw.Write(incList.Count);
        foreach (var bepInIncompatibility in incList)
            ((ICacheable) bepInIncompatibility).Save(bw);

        bw.Write(TargettedBepInExVersion.ToString(4));
    }

    void ICacheable.Load(BinaryReader br)
    {
        TypeName = br.ReadString();
        Location = br.ReadString();

        Metadata = new BepInPlugin(br.ReadString(), br.ReadString(), br.ReadString());

        var processListCount = br.ReadInt32();
        var processList = new List<BepInProcess>(processListCount);
        for (var i = 0; i < processListCount; i++)
            processList.Add(new BepInProcess(br.ReadString()));
        Processes = processList;

        var depCount = br.ReadInt32();
        var depList = new List<BepInDependency>(depCount);
        for (var i = 0; i < depCount; i++)
        {
            var dep = new BepInDependency("");
            ((ICacheable) dep).Load(br);
            depList.Add(dep);
        }

        Dependencies = depList;

        var incCount = br.ReadInt32();
        var incList = new List<BepInIncompatibility>(incCount);
        for (var i = 0; i < incCount; i++)
        {
            var inc = new BepInIncompatibility("");
            ((ICacheable) inc).Load(br);
            incList.Add(inc);
        }

        Incompatibilities = incList;

        TargettedBepInExVersion = new Version(br.ReadString());
    }

    /// <inheritdoc />
    public override string ToString() => $"{Metadata?.Name} {Metadata?.Version}";
}

```

`BepInEx.Core/Logging/BepInExLogInterpolatedStringHandler.cs`:

```cs
using System;
using System.Runtime.CompilerServices;
using System.Text;
using BepInEx.Logging;

namespace BepInEx.Core.Logging.Interpolation;

/// <summary>
///     Interpolated string handler for BepInEx <see cref="Logger" />. This allows to conditionally skip logging certain
///     messages and speed up logging in certain places.
/// </summary>
/// <remarks>
///     The class isn't meant to be constructed manually.
///     Instead, use <see cref="ManualLogSource.Log(BepInEx.Logging.LogLevel,BepInExLogInterpolatedStringHandler)" /> with
///     string interpolation.
/// </remarks>
[InterpolatedStringHandler]
public class BepInExLogInterpolatedStringHandler
{
    // See https://source.dot.net/#System.Private.CoreLib/DefaultInterpolatedStringHandler.cs,29
    private const int GUESSED_LENGTH_PER_HOLE = 11;

    // We can't use an array pool to support net35 builds, so default to StringBuilder
    private readonly StringBuilder sb;

    /// <summary>
    ///     Constructs a log handler.
    /// </summary>
    /// <param name="literalLength">Length of the literal string.</param>
    /// <param name="formattedCount">Number for formatted items.</param>
    /// <param name="logLevel">Log level the message belongs to.</param>
    /// <param name="isEnabled">Whether this string should be logged.</param>
    public BepInExLogInterpolatedStringHandler(int literalLength,
                                               int formattedCount,
                                               LogLevel logLevel,
                                               out bool isEnabled)
    {
        Enabled = (logLevel & Logger.ListenedLogLevels) != LogLevel.None;
        isEnabled = Enabled;
        sb = Enabled ? new StringBuilder(literalLength + formattedCount * GUESSED_LENGTH_PER_HOLE) : null;
    }

    /// <summary>
    ///     Whether the interpolation is enabled and string will be logged.
    /// </summary>
    public bool Enabled { get; }

    /// <summary>
    ///     Appends a literal string to the interpolation.
    /// </summary>
    /// <param name="s">String to append.</param>
    public void AppendLiteral(string s)
    {
        if (!Enabled)
            return;
        sb.Append(s);
    }

    /// <summary>
    ///     Appends a value to the interpolation.
    /// </summary>
    /// <param name="t">Value to append.</param>
    /// <typeparam name="T">Type of the value to append.</typeparam>
    public void AppendFormatted<T>(T t)
    {
        if (!Enabled)
            return;

        sb.Append(t);
    }

    /// <summary>
    ///     Append a formattable item.
    /// </summary>
    /// <param name="t">Item to append.</param>
    /// <param name="format">Format to append with.</param>
    /// <typeparam name="T">Item type.</typeparam>
    public void AppendFormatted<T>(T t, string format) where T : IFormattable
    {
        if (!Enabled)
            return;

        sb.Append(t?.ToString(format, null));
    }

    /// <summary>
    ///     Append an IntPtr.
    /// </summary>
    /// <param name="t">Item to append.</param>
    /// <param name="format">Format to append with.</param>
    public void AppendFormatted(IntPtr t, string format)
    {
        if (!Enabled)
            return;

        sb.Append(t.ToString(format));
    }

    /// <inheritdoc />
    public override string ToString() => sb?.ToString() ?? string.Empty;
}

/// <inheritdoc />
[InterpolatedStringHandler]
public class BepInExFatalLogInterpolatedStringHandler : BepInExLogInterpolatedStringHandler
{
    /// <inheritdoc />
    public BepInExFatalLogInterpolatedStringHandler(int literalLength,
                                                    int formattedCount,
                                                    out bool isEnabled) : base(literalLength, formattedCount,
                                                                               LogLevel.Fatal, out isEnabled) { }
}

/// <inheritdoc />
[InterpolatedStringHandler]
public class BepInExErrorLogInterpolatedStringHandler : BepInExLogInterpolatedStringHandler
{
    /// <inheritdoc />
    public BepInExErrorLogInterpolatedStringHandler(int literalLength,
                                                    int formattedCount,
                                                    out bool isEnabled) : base(literalLength, formattedCount,
                                                                               LogLevel.Error, out isEnabled) { }
}

/// <inheritdoc />
[InterpolatedStringHandler]
public class BepInExWarningLogInterpolatedStringHandler : BepInExLogInterpolatedStringHandler
{
    /// <inheritdoc />
    public BepInExWarningLogInterpolatedStringHandler(int literalLength,
                                                      int formattedCount,
                                                      out bool isEnabled) : base(literalLength, formattedCount,
        LogLevel.Warning, out isEnabled) { }
}

/// <inheritdoc />
[InterpolatedStringHandler]
public class BepInExMessageLogInterpolatedStringHandler : BepInExLogInterpolatedStringHandler
{
    /// <inheritdoc />
    public BepInExMessageLogInterpolatedStringHandler(int literalLength,
                                                      int formattedCount,
                                                      out bool isEnabled) : base(literalLength, formattedCount,
        LogLevel.Message, out isEnabled) { }
}

/// <inheritdoc />
[InterpolatedStringHandler]
public class BepInExInfoLogInterpolatedStringHandler : BepInExLogInterpolatedStringHandler
{
    /// <inheritdoc />
    public BepInExInfoLogInterpolatedStringHandler(int literalLength,
                                                   int formattedCount,
                                                   out bool isEnabled) : base(literalLength, formattedCount,
                                                                              LogLevel.Info, out isEnabled) { }
}

/// <inheritdoc />
[InterpolatedStringHandler]
public class BepInExDebugLogInterpolatedStringHandler : BepInExLogInterpolatedStringHandler
{
    /// <inheritdoc />
    public BepInExDebugLogInterpolatedStringHandler(int literalLength,
                                                    int formattedCount,
                                                    out bool isEnabled) : base(literalLength, formattedCount,
                                                                               LogLevel.Debug, out isEnabled) { }
}

```

`BepInEx.Core/Logging/ConsoleLogListener.cs`:

```cs
using System;
using BepInEx.Configuration;

namespace BepInEx.Logging;

/// <summary>
///     Logs entries using a console spawned by BepInEx.
/// </summary>
public class ConsoleLogListener : ILogListener
{
    protected static readonly ConfigEntry<LogLevel> ConfigConsoleDisplayedLevel = ConfigFile.CoreConfig.Bind(
     "Logging.Console", "LogLevels",
     LogLevel.Fatal | LogLevel.Error | LogLevel.Warning | LogLevel.Message | LogLevel.Info,
     "Only displays the specified log levels in the console output.");

    /// <inheritdoc />
    public LogLevel LogLevelFilter => ConfigConsoleDisplayedLevel.Value;

    /// <inheritdoc />
    public void LogEvent(object sender, LogEventArgs eventArgs)
    {
        ConsoleManager.SetConsoleColor(eventArgs.Level.GetConsoleColor());
        ConsoleManager.ConsoleStream?.Write(eventArgs.ToStringLine());
        ConsoleManager.SetConsoleColor(ConsoleColor.Gray);
    }

    /// <inheritdoc />
    public void Dispose() { }
}

```

`BepInEx.Core/Logging/DiskLogListener.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;

namespace BepInEx.Logging;

/// <summary>
///     Logs entries using Unity specific outputs.
/// </summary>
public class DiskLogListener : ILogListener
{
    public static HashSet<string> BlacklistedSources = new();

    /// <summary>
    ///     Creates a new disk log listener.
    /// </summary>
    /// <param name="localPath">Path to the log.</param>
    /// <param name="displayedLogLevel">Log levels to display.</param>
    /// <param name="appendLog">Whether to append logs to an already existing log file.</param>
    /// <param name="delayedFlushing">
    ///     Whether to delay flushing to disk to improve performance. Useful to set this to false
    ///     when debugging crashes.
    /// </param>
    /// <param name="fileLimit">Maximum amount of concurrently opened log files. Can help with infinite game boot loops.</param>
    public DiskLogListener(string localPath,
                           LogLevel displayedLogLevel = LogLevel.Info,
                           bool appendLog = false,
                           bool delayedFlushing = true,
                           int fileLimit = 5)
    {
        DisplayedLogLevel = displayedLogLevel;

        var counter = 1;

        FileStream fileStream;

        while (!Utility.TryOpenFileStream(Path.Combine(Paths.BepInExRootPath, localPath),
                                          appendLog ? FileMode.Append : FileMode.Create, out fileStream,
                                          share: FileShare.Read, access: FileAccess.Write))
        {
            if (counter == fileLimit)
            {
                Logger.Log(LogLevel.Error, "Couldn't open a log file for writing. Skipping log file creation");

                return;
            }

            Logger.Log(LogLevel.Warning, $"Couldn't open log file '{localPath}' for writing, trying another...");

            localPath = $"LogOutput.{counter++}.log";
        }

        LogWriter = TextWriter.Synchronized(new StreamWriter(fileStream, Utility.UTF8NoBom));

        if (delayedFlushing) FlushTimer = new Timer(o => { LogWriter?.Flush(); }, null, 2000, 2000);

        InstantFlushing = !delayedFlushing;
    }

    /// <summary>
    ///     Log levels to display.
    /// </summary>
    public LogLevel DisplayedLogLevel { get; }

    /// <summary>
    ///     Writer for the disk log.
    /// </summary>
    public TextWriter LogWriter { get; protected set; }

    /// <summary>
    ///     Timer for flushing the logs to a file.
    /// </summary>
    private Timer FlushTimer { get; }

    private bool InstantFlushing { get; }

    /// <inheritdoc />
    public LogLevel LogLevelFilter => DisplayedLogLevel;

    /// <inheritdoc />
    public void LogEvent(object sender, LogEventArgs eventArgs)
    {
        if (LogWriter == null)
            return;

        if (BlacklistedSources.Contains(eventArgs.Source.SourceName))
            return;

        LogWriter.WriteLine(eventArgs.ToString());

        if (InstantFlushing)
            LogWriter.Flush();
    }

    /// <inheritdoc />
    public void Dispose()
    {
        FlushTimer?.Dispose();

        try
        {
            LogWriter?.Flush();
            LogWriter?.Dispose();
        }
        catch (ObjectDisposedException) { }
    }

    ~DiskLogListener()
    {
        Dispose();
    }
}

```

`BepInEx.Core/Logging/HarmonyLogSource.cs`:

```cs
using System;
using System.Collections.Generic;
using BepInEx.Configuration;
using HarmonyLogger = HarmonyLib.Tools.Logger;

namespace BepInEx.Logging;

public class HarmonyLogSource : ILogSource
{
    private static readonly ConfigEntry<HarmonyLogger.LogChannel> LogChannels = ConfigFile.CoreConfig.Bind(
     "Harmony.Logger",
     "LogChannels",
     HarmonyLogger.LogChannel.Warn | HarmonyLogger.LogChannel.Error,
     "Specifies which Harmony log channels to listen to.\nNOTE: IL channel dumps the whole patch methods, use only when needed!");

    private static readonly Dictionary<HarmonyLogger.LogChannel, LogLevel> LevelMap = new()
    {
        [HarmonyLogger.LogChannel.Info] = LogLevel.Info,
        [HarmonyLogger.LogChannel.Warn] = LogLevel.Warning,
        [HarmonyLogger.LogChannel.Error] = LogLevel.Error,
        [HarmonyLogger.LogChannel.IL] = LogLevel.Debug
    };

    public HarmonyLogSource()
    {
        HarmonyLogger.ChannelFilter = LogChannels.Value;
        HarmonyLogger.MessageReceived += HandleHarmonyMessage;
    }

    public void Dispose() => HarmonyLogger.MessageReceived -= HandleHarmonyMessage;

    public string SourceName { get; } = "HarmonyX";
    public event EventHandler<LogEventArgs> LogEvent;

    private void HandleHarmonyMessage(object sender, HarmonyLogger.LogEventArgs e)
    {
        if (!LevelMap.TryGetValue(e.LogChannel, out var level))
            return;

        LogEvent?.Invoke(this, new LogEventArgs(e.Message, level, this));
    }
}

```

`BepInEx.Core/Logging/ILogListener.cs`:

```cs
using System;

namespace BepInEx.Logging;

/// <summary>
///     A generic log listener that receives log events and can route them to some output (e.g. file, console, socket).
/// </summary>
public interface ILogListener : IDisposable
{
    /// <summary>
    ///     What log levels the listener preliminarily wants.
    /// </summary>
    /// <remarks>
    ///     The filter is used to more efficiently discard log messages that aren't being listened to.
    ///     As such, the filter should represent the log levels that the listener will always want to process.
    ///     It is up to the the implementation of <see cref="LogEvent" /> whether the messages are going to be processed or
    ///     discarded.
    /// </remarks>
    /// TODO: Right now the filter cannot be updated after the log listener has been attached to the logger.
    LogLevel LogLevelFilter { get; }

    /// <summary>
    ///     Handle an incoming log event.
    /// </summary>
    /// <param name="sender">Log source that sent the event. Don't use; instead use <see cref="LogEventArgs.Source" /></param>
    /// <param name="eventArgs">Information about the log message.</param>
    void LogEvent(object sender, LogEventArgs eventArgs);
}

```

`BepInEx.Core/Logging/ILogSource.cs`:

```cs
using System;

namespace BepInEx.Logging;

/// <summary>
///     Log source that can output log messages.
/// </summary>
public interface ILogSource : IDisposable
{
    /// <summary>
    ///     Name of the log source.
    /// </summary>
    string SourceName { get; }

    /// <summary>
    ///     Event that sends the log message. Call <see cref="EventHandler.Invoke" /> to send a log message.
    /// </summary>
    event EventHandler<LogEventArgs> LogEvent;
}

```

`BepInEx.Core/Logging/InterpolatedStringHandlerAttribute.cs`:

```cs
// ReSharper disable once CheckNamespace

namespace System.Runtime.CompilerServices;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false)]
internal sealed class InterpolatedStringHandlerAttribute : Attribute { }

[AttributeUsage(AttributeTargets.Parameter)]
internal sealed class InterpolatedStringHandlerArgumentAttribute : Attribute
{
    public InterpolatedStringHandlerArgumentAttribute(string argument)
    {
        Arguments = new[] { argument };
    }

    public InterpolatedStringHandlerArgumentAttribute(params string[] arguments)
    {
        Arguments = arguments;
    }

    public string[] Arguments { get; }
}

```

`BepInEx.Core/Logging/LogEventArgs.cs`:

```cs
using System;

namespace BepInEx.Logging;

/// <summary>
///     Log event arguments. Contains info about the log message.
/// </summary>
public class LogEventArgs : EventArgs
{
    /// <summary>
    ///     Creates the log event args-
    /// </summary>
    /// <param name="data">Logged data.</param>
    /// <param name="level">Log level of the data.</param>
    /// <param name="source">Log source that emits these args.</param>
    public LogEventArgs(object data, LogLevel level, ILogSource source)
    {
        Data = data;
        Level = level;
        Source = source;
    }

    /// <summary>
    ///     Logged data.
    /// </summary>
    public object Data { get; }

    /// <summary>
    ///     Log levels for the data.
    /// </summary>
    public LogLevel Level { get; }

    /// <summary>
    ///     Log source that emitted the log event.
    /// </summary>
    public ILogSource Source { get; }

    /// <inheritdoc />
    public override string ToString() => $"[{Level,-7}:{Source.SourceName,10}] {Data}";

    /// <summary>
    ///     Like <see cref="ToString" /> but appends newline at the end.
    /// </summary>
    /// <returns>Same output as <see cref="ToString" /> but with new line.</returns>
    public string ToStringLine() => $"[{Level,-7}:{Source.SourceName,10}] {Data}{Environment.NewLine}";
}

```

`BepInEx.Core/Logging/LogLevel.cs`:

```cs
using System;

namespace BepInEx.Logging;

/// <summary>
///     The level, or severity of a log entry.
/// </summary>
[Flags]
public enum LogLevel
{
    /// <summary>
    ///     No level selected.
    /// </summary>
    None = 0,

    /// <summary>
    ///     A fatal error has occurred, which cannot be recovered from.
    /// </summary>
    Fatal = 1,

    /// <summary>
    ///     An error has occured, but can be recovered from.
    /// </summary>
    Error = 2,

    /// <summary>
    ///     A warning has been produced, but does not necessarily mean that something wrong has happened.
    /// </summary>
    Warning = 4,

    /// <summary>
    ///     An important message that should be displayed to the user.
    /// </summary>
    Message = 8,

    /// <summary>
    ///     A message of low importance.
    /// </summary>
    Info = 16,

    /// <summary>
    ///     A message that would likely only interest a developer.
    /// </summary>
    Debug = 32,

    /// <summary>
    ///     All log levels.
    /// </summary>
    All = Fatal | Error | Warning | Message | Info | Debug
}

/// <summary>
///     Helper methods for log level handling.
/// </summary>
public static class LogLevelExtensions
{
    /// <summary>
    ///     Gets the highest log level when there could potentially be multiple levels provided.
    /// </summary>
    /// <param name="levels">The log level(s).</param>
    /// <returns>The highest log level supplied.</returns>
    public static LogLevel GetHighestLevel(this LogLevel levels)
    {
        var enums = Enum.GetValues(typeof(LogLevel));
        Array.Sort(enums);

        foreach (LogLevel e in enums)
            if ((levels & e) != LogLevel.None)
                return e;

        return LogLevel.None;
    }

    /// <summary>
    ///     Returns a translation of a log level to it's associated console colour.
    /// </summary>
    /// <param name="level">The log level(s).</param>
    /// <returns>A console color associated with the highest log level supplied.</returns>
    public static ConsoleColor GetConsoleColor(this LogLevel level)
    {
        level = GetHighestLevel(level);
        return level switch
        {
            LogLevel.Fatal   => ConsoleColor.Red,
            LogLevel.Error   => ConsoleColor.DarkRed,
            LogLevel.Warning => ConsoleColor.Yellow,
            LogLevel.Message => ConsoleColor.White,
            LogLevel.Info    => ConsoleColor.DarkGray,
            LogLevel.Debug   => ConsoleColor.DarkGray,
            _                => ConsoleColor.Gray
        };
    }
}

```

`BepInEx.Core/Logging/Logger.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using BepInEx.Core.Logging.Interpolation;

namespace BepInEx.Logging;

/// <summary>
///     Handles pub-sub event marshalling across all log listeners and sources.
/// </summary>
public static class Logger
{
    private static readonly ManualLogSource InternalLogSource;

    private static readonly LogListenerCollection listeners;

    static Logger()
    {
        Sources = new LogSourceCollection();
        listeners = new LogListenerCollection();

        InternalLogSource = CreateLogSource("BepInEx");
    }

    /// <summary>
    ///     Log levels that are currently listened to by at least one listener.
    /// </summary>
    public static LogLevel ListenedLogLevels => listeners.activeLogLevels;

    /// <summary>
    ///     Collection of all log listeners that receive log events.
    /// </summary>
    public static ICollection<ILogListener> Listeners => listeners;

    /// <summary>
    ///     Collection of all log source that output log events.
    /// </summary>
    public static ICollection<ILogSource> Sources { get; }

    internal static void InternalLogEvent(object sender, LogEventArgs eventArgs)
    {
        // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator Prevent extra allocations
        foreach (var listener in listeners)
            if ((eventArgs.Level & listener.LogLevelFilter) != LogLevel.None)
                listener?.LogEvent(sender, eventArgs);
    }

    /// <summary>
    ///     Logs an entry to the internal logger instance.
    /// </summary>
    /// <param name="level">The level of the entry.</param>
    /// <param name="data">The data of the entry.</param>
    internal static void Log(LogLevel level, object data) => InternalLogSource.Log(level, data);

    /// <summary>
    ///     Logs an entry to the internal logger instance if any log listener wants the message.
    /// </summary>
    /// <param name="level">The level of the entry.</param>
    /// <param name="logHandler">Log handler to resolve log from.</param>
    internal static void Log(LogLevel level,
                             [InterpolatedStringHandlerArgument("level")]
                             BepInExLogInterpolatedStringHandler logHandler) =>
        InternalLogSource.Log(level, logHandler);

    /// <summary>
    ///     Creates a new log source with a name and attaches it to <see cref="Sources" />.
    /// </summary>
    /// <param name="sourceName">Name of the log source to create.</param>
    /// <returns>An instance of <see cref="ManualLogSource" /> that allows to write logs.</returns>
    public static ManualLogSource CreateLogSource(string sourceName)
    {
        var source = new ManualLogSource(sourceName);
        Sources.Add(source);
        return source;
    }

    private class LogListenerCollection : List<ILogListener>, ICollection<ILogListener>
    {
        public LogLevel activeLogLevels = LogLevel.None;

        void ICollection<ILogListener>.Add(ILogListener item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));

            activeLogLevels |= item.LogLevelFilter;

            base.Add(item);
        }

        void ICollection<ILogListener>.Clear()
        {
            activeLogLevels = LogLevel.None;
            base.Clear();
        }

        bool ICollection<ILogListener>.Remove(ILogListener item)
        {
            if (item == null || !base.Remove(item))
                return false;

            activeLogLevels = LogLevel.None;

            foreach (var i in this)
                activeLogLevels |= i.LogLevelFilter;

            return true;
        }
    }


    private class LogSourceCollection : List<ILogSource>, ICollection<ILogSource>
    {
        void ICollection<ILogSource>.Add(ILogSource item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item),
                                                "Log sources cannot be null when added to the source list.");

            item.LogEvent += InternalLogEvent;

            base.Add(item);
        }

        void ICollection<ILogSource>.Clear()
        {
            foreach (var item in this)
                item.LogEvent -= InternalLogEvent;

            base.Clear();
        }

        bool ICollection<ILogSource>.Remove(ILogSource item)
        {
            if (item == null || !Remove(item))
                return false;

            item.LogEvent -= InternalLogEvent;
            return true;
        }
    }
}

```

`BepInEx.Core/Logging/ManualLogSource.cs`:

```cs
using System;
using System.Runtime.CompilerServices;
using BepInEx.Core.Logging.Interpolation;

namespace BepInEx.Logging;

/// <summary>
///     A generic, multi-purpose log source. Exposes simple API to manually emit logs.
/// </summary>
public class ManualLogSource : ILogSource
{
    /// <summary>
    ///     Creates a manual log source.
    /// </summary>
    /// <param name="sourceName">Name of the log source.</param>
    public ManualLogSource(string sourceName)
    {
        SourceName = sourceName;
    }

    /// <inheritdoc />
    public string SourceName { get; }

    /// <inheritdoc />
    public event EventHandler<LogEventArgs> LogEvent;

    /// <inheritdoc />
    public void Dispose() { }

    /// <summary>
    ///     Logs a message with the specified log level.
    /// </summary>
    /// <param name="level">Log levels to attach to the message. Multiple can be used with bitwise ORing.</param>
    /// <param name="data">Data to log.</param>
    public void Log(LogLevel level, object data) => LogEvent?.Invoke(this, new LogEventArgs(data, level, this));

    /// <summary>
    ///     Logs an interpolated string with the specified log level.
    /// </summary>
    /// <param name="level">Log levels to attach to the message. Multiple can be used with bitwise ORing.</param>
    /// <param name="logHandler">Handler for the interpolated string.</param>
    public void Log(LogLevel level,
                    [InterpolatedStringHandlerArgument("level")]
                    BepInExLogInterpolatedStringHandler logHandler)
    {
        if (logHandler.Enabled)
            LogEvent?.Invoke(this, new LogEventArgs(logHandler.ToString(), level, this));
    }

    /// <summary>
    ///     Logs a message with <see cref="LogLevel.Fatal" /> level.
    /// </summary>
    /// <param name="data">Data to log.</param>
    public void LogFatal(object data) => Log(LogLevel.Fatal, data);

    /// <summary>
    ///     Logs an interpolated string with <see cref="LogLevel.Fatal" /> level.
    /// </summary>
    /// <param name="logHandler">Handler for the interpolated string.</param>
    public void LogFatal(BepInExFatalLogInterpolatedStringHandler logHandler) => Log(LogLevel.Fatal, logHandler);

    /// <summary>
    ///     Logs a message with <see cref="LogLevel.Error" /> level.
    /// </summary>
    /// <param name="data">Data to log.</param>
    public void LogError(object data) => Log(LogLevel.Error, data);

    /// <summary>
    ///     Logs an interpolated string with <see cref="LogLevel.Error" /> level.
    /// </summary>
    /// <param name="logHandler">Handler for the interpolated string.</param>
    public void LogError(BepInExErrorLogInterpolatedStringHandler logHandler) => Log(LogLevel.Error, logHandler);

    /// <summary>
    ///     Logs a message with <see cref="LogLevel.Warning" /> level.
    /// </summary>
    /// <param name="data">Data to log.</param>
    public void LogWarning(object data) => Log(LogLevel.Warning, data);

    /// <summary>
    ///     Logs an interpolated string with <see cref="LogLevel.Warning" /> level.
    /// </summary>
    /// <param name="logHandler">Handler for the interpolated string.</param>
    public void LogWarning(BepInExWarningLogInterpolatedStringHandler logHandler) => Log(LogLevel.Warning, logHandler);

    /// <summary>
    ///     Logs a message with <see cref="LogLevel.Message" /> level.
    /// </summary>
    /// <param name="data">Data to log.</param>
    public void LogMessage(object data) => Log(LogLevel.Message, data);

    /// <summary>
    ///     Logs an interpolated string with <see cref="LogLevel.Message" /> level.
    /// </summary>
    /// <param name="logHandler">Handler for the interpolated string.</param>
    public void LogMessage(BepInExMessageLogInterpolatedStringHandler logHandler) => Log(LogLevel.Message, logHandler);

    /// <summary>
    ///     Logs a message with <see cref="LogLevel.Info" /> level.
    /// </summary>
    /// <param name="data">Data to log.</param>
    public void LogInfo(object data) => Log(LogLevel.Info, data);

    /// <summary>
    ///     Logs an interpolated string with <see cref="LogLevel.Info" /> level.
    /// </summary>
    /// <param name="logHandler">Handler for the interpolated string.</param>
    public void LogInfo(BepInExInfoLogInterpolatedStringHandler logHandler) => Log(LogLevel.Info, logHandler);

    /// <summary>
    ///     Logs a message with <see cref="LogLevel.Debug" /> level.
    /// </summary>
    /// <param name="data">Data to log.</param>
    public void LogDebug(object data) => Log(LogLevel.Debug, data);

    /// <summary>
    ///     Logs an interpolated string with <see cref="LogLevel.Debug" /> level.
    /// </summary>
    /// <param name="logHandler">Handler for the interpolated string.</param>
    public void LogDebug(BepInExDebugLogInterpolatedStringHandler logHandler) => Log(LogLevel.Debug, logHandler);
}

```

`BepInEx.Core/Logging/TraceLogSource.cs`:

```cs
using System.Diagnostics;

namespace BepInEx.Logging;

/// <summary>
///     A source that routes all logs from the inbuilt .NET <see cref="Trace" /> API to the BepInEx logging system.
/// </summary>
/// <inheritdoc cref="TraceListener" />
public class TraceLogSource : TraceListener
{
    private static TraceLogSource traceListener;

    /// <summary>
    ///     Creates a new trace log source.
    /// </summary>
    protected TraceLogSource()
    {
        LogSource = new ManualLogSource("Trace");
    }

    /// <summary>
    ///     Whether Trace logs are currently being rerouted.
    /// </summary>
    public static bool IsListening { get; private set; }

    /// <summary>
    ///     Internal log source.
    /// </summary>
    protected ManualLogSource LogSource { get; }

    /// <summary>
    ///     Creates a new trace log source.
    /// </summary>
    /// <returns>New log source (or already existing one).</returns>
    public static ILogSource CreateSource()
    {
        if (traceListener == null)
        {
            traceListener = new TraceLogSource();
            Trace.Listeners.Add(traceListener);
            IsListening = true;
        }

        return traceListener.LogSource;
    }

    /// <summary>
    ///     Writes a message to the underlying <see cref="ManualLogSource" /> instance.
    /// </summary>
    /// <param name="message">The message to write.</param>
    public override void Write(string message) => LogSource.Log(LogLevel.Info, message);

    /// <summary>
    ///     Writes a message and a newline to the underlying <see cref="ManualLogSource" /> instance.
    /// </summary>
    /// <param name="message">The message to write.</param>
    public override void WriteLine(string message) => LogSource.Log(LogLevel.Info, message);

    /// <inheritdoc />
    public override void TraceEvent(TraceEventCache eventCache,
                                    string source,
                                    TraceEventType eventType,
                                    int id,
                                    string format,
                                    params object[] args) =>
        TraceEvent(eventCache, source, eventType, id, string.Format(format, args));

    /// <inheritdoc />
    public override void TraceEvent(TraceEventCache eventCache,
                                    string source,
                                    TraceEventType eventType,
                                    int id,
                                    string message)
    {
        var level = eventType switch
        {
            TraceEventType.Critical    => LogLevel.Fatal,
            TraceEventType.Error       => LogLevel.Error,
            TraceEventType.Warning     => LogLevel.Warning,
            TraceEventType.Information => LogLevel.Info,
            _                          => LogLevel.Debug
        };
        LogSource.Log(level, $"{message}".Trim());
    }
}

```

`BepInEx.Core/Paths.cs`:

```cs
using System.IO;
using System.Linq;
using System.Reflection;
using MonoMod.Utils;
using SemanticVersioning;

namespace BepInEx;

/// <summary>
///     Paths used by BepInEx
/// </summary>
public static class Paths
{
    // TODO: Why is this in Paths?
    /// <summary>
    ///    BepInEx version.
    /// </summary>
    public static Version BepInExVersion { get; } =
        Version.Parse(MetadataHelper.GetAttributes<AssemblyInformationalVersionAttribute>(typeof(Paths).Assembly)[0]
                                    .InformationalVersion);

    /// <summary>
    ///     The path to the Managed folder that contains the main managed assemblies.
    /// </summary>
    public static string ManagedPath { get; private set; }

    /// <summary>
    ///     The path to the game data folder of the currently running Unity game.
    /// </summary>
    public static string GameDataPath { get; private set; }

    /// <summary>
    ///     The directory that the core BepInEx DLLs reside in.
    /// </summary>
    public static string BepInExAssemblyDirectory { get; private set; }

    /// <summary>
    ///     The path to the core BepInEx DLL.
    /// </summary>
    public static string BepInExAssemblyPath { get; private set; }

    /// <summary>
    ///     The path to the main BepInEx folder.
    /// </summary>
    public static string BepInExRootPath { get; private set; }

    /// <summary>
    ///     The path of the currently executing program BepInEx is encapsulated in.
    /// </summary>
    public static string ExecutablePath { get; private set; }

    /// <summary>
    ///     The directory that the currently executing process resides in.
    ///     <para>On OSX however, this is the parent directory of the game.app folder.</para>
    /// </summary>
    public static string GameRootPath { get; private set; }

    /// <summary>
    ///     The path to the config directory.
    /// </summary>
    public static string ConfigPath { get; private set; }

    /// <summary>
    ///     The path to the global BepInEx configuration file.
    /// </summary>
    public static string BepInExConfigPath { get; private set; }

    /// <summary>
    ///     The path to temporary cache files.
    /// </summary>
    public static string CachePath { get; private set; }

    /// <summary>
    ///     The path to the patcher plugin folder which resides in the BepInEx folder.
    /// </summary>
    public static string PatcherPluginPath { get; private set; }

    /// <summary>
    ///     The path to the plugin folder which resides in the BepInEx folder.
    ///     <para>
    ///         This is ONLY guaranteed to be set correctly when Chainloader has been initialized.
    ///     </para>
    /// </summary>
    public static string PluginPath { get; private set; }

    /// <summary>
    ///     The name of the currently executing process.
    /// </summary>
    public static string ProcessName { get; private set; }

    /// <summary>
    ///     List of directories from where Mono will search assemblies before assembly resolving is invoked.
    /// </summary>
    public static string[] DllSearchPaths { get; private set; }

    public static void SetExecutablePath(string executablePath,
                                         string bepinRootPath = null,
                                         string managedPath = null,
                                         bool gameDataRelativeToManaged = false,
                                         string[] dllSearchPath = null)
    {
        ExecutablePath = executablePath;
        ProcessName = Path.GetFileNameWithoutExtension(executablePath);

        GameRootPath = PlatformHelper.Is(Platform.MacOS)
                           ? Utility.ParentDirectory(executablePath, 4)
                           : Path.GetDirectoryName(executablePath);

        GameDataPath = managedPath != null && gameDataRelativeToManaged
                           ? Path.GetDirectoryName(managedPath)
                           : Path.Combine(GameRootPath, $"{ProcessName}_Data");
        ManagedPath = managedPath ?? Path.Combine(GameDataPath, "Managed");
        BepInExRootPath = bepinRootPath ?? Path.Combine(GameRootPath, "BepInEx");
        ConfigPath = Path.Combine(BepInExRootPath, "config");
        BepInExConfigPath = Path.Combine(ConfigPath, "BepInEx.cfg");
        PluginPath = Path.Combine(BepInExRootPath, "plugins");
        PatcherPluginPath = Path.Combine(BepInExRootPath, "patchers");
        BepInExAssemblyDirectory = Path.Combine(BepInExRootPath, "core");
        BepInExAssemblyPath = Path.Combine(BepInExAssemblyDirectory,
                                           $"{Assembly.GetExecutingAssembly().GetName().Name}.dll");
        CachePath = Path.Combine(BepInExRootPath, "cache");
        DllSearchPaths = (dllSearchPath ?? new string[0]).Concat(new[] { ManagedPath }).Distinct().ToArray();
    }

    internal static void SetPluginPath(string pluginPath) =>
        PluginPath = Utility.CombinePaths(BepInExRootPath, pluginPath);
}

```

`BepInEx.Core/Properties/AssemblyInfo.cs`:

```cs
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("BepInEx.Preloader.Core")]
[assembly: InternalsVisibleTo("BepInEx.Unity.Mono")]
[assembly: InternalsVisibleTo("BepInEx.NET.Framework.Launcher")]
[assembly: InternalsVisibleTo("BepInEx.NET.CoreCLR")]
[assembly: InternalsVisibleTo("BepInEx.Unity.IL2CPP")]
[assembly: InternalsVisibleTo("BepInExTests")]

```

`BepInEx.Core/Utility.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Security.Cryptography;
using System.Text;
using Mono.Cecil;

namespace BepInEx;

/// <summary>
///     Generic helper properties and methods.
/// </summary>
public static class Utility
{
    private const string TRUSTED_PLATFORM_ASSEMBLIES = "TRUSTED_PLATFORM_ASSEMBLIES";
    private static bool? sreEnabled;

    /// <summary>
    ///     Whether current Common Language Runtime supports dynamic method generation using
    ///     <see cref="System.Reflection.Emit" /> namespace.
    /// </summary>
    public static bool CLRSupportsDynamicAssemblies => CheckSRE();

    /// <summary>
    ///     An encoding for UTF-8 which does not emit a byte order mark (BOM).
    /// </summary>
    public static Encoding UTF8NoBom { get; } = new UTF8Encoding(false);

    private static bool CheckSRE()
    {
        try
        {
            if (sreEnabled.HasValue)
                return sreEnabled.Value;

            // ReSharper disable once AssignNullToNotNullAttribute
            _ = new CustomAttributeBuilder(null, new object[0]);
        }
        catch (PlatformNotSupportedException)
        {
            sreEnabled = false;
            return sreEnabled.Value;
        }
        catch (ArgumentNullException)
        {
            // Suppress ArgumentNullException
        }

        sreEnabled = true;
        return sreEnabled.Value;
    }

    /// <summary>
    ///     Try to perform an action.
    /// </summary>
    /// <param name="action">Action to perform.</param>
    /// <param name="exception">Possible exception that gets returned.</param>
    /// <returns>True, if action succeeded, false if an exception occured.</returns>
    public static bool TryDo(Action action, out Exception exception)
    {
        exception = null;
        try
        {
            action();
            return true;
        }
        catch (Exception e)
        {
            exception = e;
            return false;
        }
    }

    /// <summary>
    ///     Combines multiple paths together, as the specific method is not available in .NET 3.5.
    /// </summary>
    /// <param name="parts">The multiple paths to combine together.</param>
    /// <returns>A combined path.</returns>
    public static string CombinePaths(params string[] parts) => parts.Aggregate(Path.Combine);

    /// <summary>
    ///     Returns the parent directory of a path, optionally specifying the amount of levels.
    /// </summary>
    /// <param name="path">The path to get the parent directory of.</param>
    /// <param name="levels">The amount of levels to traverse. Defaults to 1</param>
    /// <returns>The parent directory.</returns>
    public static string ParentDirectory(string path, int levels = 1)
    {
        for (var i = 0; i < levels; i++)
            path = Path.GetDirectoryName(path);

        return path;
    }

    /// <summary>
    ///     Tries to parse a bool, with a default value if unable to parse.
    /// </summary>
    /// <param name="input">The string to parse</param>
    /// <param name="defaultValue">The value to return if parsing is unsuccessful.</param>
    /// <returns>Boolean value of input if able to be parsed, otherwise default value.</returns>
    public static bool SafeParseBool(string input, bool defaultValue = false) =>
        bool.TryParse(input, out var result) ? result : defaultValue;

    /// <summary>
    ///     Converts a file path into a UnityEngine.WWW format.
    /// </summary>
    /// <param name="path">The file path to convert.</param>
    /// <returns>A converted file path.</returns>
    public static string ConvertToWWWFormat(string path) => $"file://{path.Replace('\\', '/')}";

    /// <summary>
    ///     Indicates whether a specified string is null, empty, or consists only of white-space characters.
    /// </summary>
    /// <param name="self">The string to test.</param>
    /// <returns>True if the value parameter is null or empty, or if value consists exclusively of white-space characters.</returns>
    public static bool IsNullOrWhiteSpace(this string self) => self == null || self.All(char.IsWhiteSpace);

    /// <summary>
    ///     Sorts a given dependency graph using a direct toposort, reporting possible cyclic dependencies.
    /// </summary>
    /// <param name="nodes">Nodes to sort</param>
    /// <param name="dependencySelector">Function that maps a node to a collection of its dependencies.</param>
    /// <typeparam name="TNode">Type of the node in a dependency graph.</typeparam>
    /// <returns>Collection of nodes sorted in the order of least dependencies to the most.</returns>
    /// <exception cref="Exception">Thrown when a cyclic dependency occurs.</exception>
    public static IEnumerable<TNode> TopologicalSort<TNode>(IEnumerable<TNode> nodes,
                                                            Func<TNode, IEnumerable<TNode>> dependencySelector)
    {
        var sorted_list = new List<TNode>();

        var visited = new HashSet<TNode>();
        var sorted = new HashSet<TNode>();

        foreach (var input in nodes)
        {
            var currentStack = new Stack<TNode>();
            if (!Visit(input, currentStack))
                throw new Exception("Cyclic Dependency:\r\n" + currentStack.Select(x => $" - {x}") //append dashes
                                                                           .Aggregate((a, b) =>
                                                                               $"{a}\r\n{b}")); //add new lines inbetween
        }


        return sorted_list;

        bool Visit(TNode node, Stack<TNode> stack)
        {
            if (visited.Contains(node))
            {
                if (!sorted.Contains(node)) return false;
            }
            else
            {
                visited.Add(node);
                stack.Push(node);
                if (dependencySelector(node).Any(dep => !Visit(dep, stack)))
                    return false;

                sorted.Add(node);
                sorted_list.Add(node);

                stack.Pop();
            }

            return true;
        }
    }

    /// <summary>
    ///     Try to resolve and load the given assembly DLL.
    /// </summary>
    /// <param name="assemblyName">Name of the assembly, of the type <see cref="AssemblyName" />.</param>
    /// <param name="directory">Directory to search the assembly from.</param>
    /// <param name="assembly">The loaded assembly.</param>
    /// <returns>True, if the assembly was found and loaded. Otherwise, false.</returns>
    public static bool TryResolveDllAssembly<T>(AssemblyName assemblyName,
                                                string directory,
                                                Func<string, T> loader,
                                                out T assembly) where T : class
    {
        assembly = null;

        var potentialDirectories = new List<string> { directory };

        if (!Directory.Exists(directory))
            return false;

        potentialDirectories.AddRange(Directory.GetDirectories(directory, "*", SearchOption.AllDirectories));

        foreach (var subDirectory in potentialDirectories)
        {
            var potentialPaths = new[]
            {
                $"{assemblyName.Name}.dll",
                $"{assemblyName.Name}.exe"
            };

            foreach (var potentialPath in potentialPaths)
            {
                var path = Path.Combine(subDirectory, potentialPath);

                if (!File.Exists(path))
                    continue;

                try
                {
                    assembly = loader(path);
                }
                catch (Exception)
                {
                    continue;
                }

                return true;
            }
        }

        return false;
    }

    /// <summary>
    ///     Checks whether a given cecil type definition is a subtype of a provided type.
    /// </summary>
    /// <param name="self">Cecil type definition</param>
    /// <param name="td">Type to check against</param>
    /// <returns>Whether the given cecil type is a subtype of the type.</returns>
    public static bool IsSubtypeOf(this TypeDefinition self, Type td)
    {
        if (self.FullName == td.FullName)
            return true;
        return self.FullName != "System.Object" && (self.BaseType?.Resolve()?.IsSubtypeOf(td) ?? false);
    }

    /// <summary>
    ///     Try to resolve and load the given assembly DLL.
    /// </summary>
    /// <param name="assemblyName">Name of the assembly, of the type <see cref="AssemblyName" />.</param>
    /// <param name="directory">Directory to search the assembly from.</param>
    /// <param name="assembly">The loaded assembly.</param>
    /// <returns>True, if the assembly was found and loaded. Otherwise, false.</returns>
    public static bool TryResolveDllAssembly(AssemblyName assemblyName, string directory, out Assembly assembly) =>
        TryResolveDllAssembly(assemblyName, directory, Assembly.LoadFrom, out assembly);

    /// <summary>
    ///     Try to resolve and load the given assembly DLL.
    /// </summary>
    /// <param name="assemblyName">Name of the assembly, of the type <see cref="AssemblyName" />.</param>
    /// <param name="directory">Directory to search the assembly from.</param>
    /// <param name="readerParameters">Reader parameters that contain possible custom assembly resolver.</param>
    /// <param name="assembly">The loaded assembly.</param>
    /// <returns>True, if the assembly was found and loaded. Otherwise, false.</returns>
    public static bool TryResolveDllAssembly(AssemblyName assemblyName,
                                             string directory,
                                             ReaderParameters readerParameters,
                                             out AssemblyDefinition assembly) =>
        TryResolveDllAssembly(assemblyName, directory,
                              s => AssemblyDefinition.ReadAssembly(s, readerParameters), out assembly);

    /// <summary>
    ///     Tries to create a file with the given name
    /// </summary>
    /// <param name="path">Path of the file to create</param>
    /// <param name="mode">File open mode</param>
    /// <param name="fileStream">Resulting filestream</param>
    /// <param name="access">File access options</param>
    /// <param name="share">File share options</param>
    /// <returns></returns>
    public static bool TryOpenFileStream(string path,
                                         FileMode mode,
                                         out FileStream fileStream,
                                         FileAccess access = FileAccess.ReadWrite,
                                         FileShare share = FileShare.Read)
    {
        try
        {
            fileStream = new FileStream(path, mode, access, share);

            return true;
        }
        catch (IOException)
        {
            fileStream = null;

            return false;
        }
    }

    public static IEnumerable<MethodDefinition> EnumerateAllMethods(this TypeDefinition type)
    {
        var currentType = type;

        while (currentType != null)
        {
            foreach (var method in currentType.Methods)
                yield return method;

            currentType = currentType.BaseType?.Resolve();
        }
    }

    /// <summary>
    ///     Compute a MD5 hash of the given stream.
    /// </summary>
    /// <param name="stream">Stream to hash</param>
    /// <returns>MD5 hash as a hex string</returns>
    public static string HashStream(Stream stream)
    {
        using var md5 = MD5.Create();

        var buf = new byte[4096];
        int read;
        while ((read = stream.Read(buf, 0, buf.Length)) > 0)
            md5.TransformBlock(buf, 0, read, buf, 0);

        md5.TransformFinalBlock(new byte[0], 0, 0);

        return ByteArrayToString(md5.Hash);
    }

    /// <summary>
    /// Hash a list of strings using MD5
    /// </summary>
    /// <param name="strings">Strings to hash</param>
    /// <returns>MD5 of the strings</returns>
    public static string HashStrings(params string[] strings)
    {
        using var md5 = MD5.Create();

        foreach (var str in strings)
            md5.TransformBlock(Encoding.UTF8.GetBytes(str), 0, str.Length, null, 0);

        md5.TransformFinalBlock(new byte[0], 0, 0);

        return ByteArrayToString(md5.Hash);
    }

    /// <summary>
    ///     Convert the given array to a hex string.
    /// </summary>
    /// <param name="data">Bytes to convert.</param>
    /// <returns>Bytes reinterpreted as a hex number.</returns>
    public static string ByteArrayToString(byte[] data)
    {
        var builder = new StringBuilder(data.Length * 2);

        foreach (var b in data)
            builder.AppendFormat("{0:x2}", b);

        return builder.ToString();
    }

    /// <summary>
    /// Get a value of a command line argument
    /// </summary>
    /// <param name="arg">Argument name</param>
    /// <returns>Next argument after the given argument name. If not found, returns null.</returns>
    public static string GetCommandLineArgValue(string arg)
    {
        var args = Environment.GetCommandLineArgs();
        for (var i = 1; i < args.Length; i++)
            if (args[i] == arg && i + 1 < args.Length)
                return args[i + 1];
        return null;
    }

    /// <summary>
    ///     Try to parse given string as an assembly name
    /// </summary>
    /// <param name="fullName">Fully qualified assembly name</param>
    /// <param name="assemblyName">Resulting <see cref="AssemblyName" /> instance</param>
    /// <returns><c>true</c>, if parsing was successful, otherwise <c>false</c></returns>
    /// <remarks>
    ///     On some versions of mono, using <see cref="Assembly.GetName()" /> fails because it runs on unmanaged side
    ///     which has problems with encoding.
    ///     Using <see cref="AssemblyName" /> solves this by doing parsing on managed side instead.
    /// </remarks>
    public static bool TryParseAssemblyName(string fullName, out AssemblyName assemblyName)
    {
        try
        {
            assemblyName = new AssemblyName(fullName);
            return true;
        }
        catch (Exception)
        {
            assemblyName = null;
            return false;
        }
    }

    internal static void AddCecilPlatformAssemblies(this AppDomain appDomain, string assemblyDir)
    {
        if (!Directory.Exists(assemblyDir))
            return;
        // Cecil 0.11 requires one to manually set up list of trusted assemblies for assembly resolving
        var curTrusted = appDomain.GetData(TRUSTED_PLATFORM_ASSEMBLIES) as string;
        var addTrusted = string.Join(Path.PathSeparator.ToString(),
                                     Directory.GetFiles(assemblyDir, "*.dll",
                                                        SearchOption.TopDirectoryOnly));
        var newTrusted = curTrusted == null ? addTrusted : $"{curTrusted}{Path.PathSeparator}{addTrusted}";
        appDomain.SetData(TRUSTED_PLATFORM_ASSEMBLIES, newTrusted);
    }

    /// <summary>
    ///     Gets unique files in all given directories. If the file with the same name exists in multiple directories,
    ///     only the first occurrence is returned.
    /// </summary>
    /// <param name="directories">Directories to search from.</param>
    /// <param name="pattern">File pattern to search.</param>
    /// <returns>Collection of all files in the directories.</returns>
    public static IEnumerable<string> GetUniqueFilesInDirectories(IEnumerable<string> directories,
                                                                  string pattern = "*")
    {
        var result = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
        foreach (var directory in directories)
        foreach (var file in Directory.GetFiles(directory, pattern))
        {
            var fileName = Path.GetFileName(file);
            if (!result.ContainsKey(fileName))
                result[fileName] = file;
        }

        return result.Values;
    }
}

```

`BepInEx.Preloader.Core/AssemblyBuildInfo.cs`:

```cs
using System;
using System.Linq;
using Mono.Cecil;

namespace BepInEx.Preloader.Core
{
    public class AssemblyBuildInfo
    {
        public enum FrameworkType
        {
            Unknown,
            NetFramework,
            NetStandard,
            NetCore
        }

        public Version NetFrameworkVersion { get; private set; }

        public bool IsAnyCpu { get; set; }

        public bool Is64Bit { get; set; }

        public FrameworkType AssemblyFrameworkType { get; set; }

        private void SetNet4Version(AssemblyDefinition assemblyDefinition)
        {
            NetFrameworkVersion = new Version(0, 0);
            AssemblyFrameworkType = FrameworkType.Unknown;

            var targetFrameworkAttribute = assemblyDefinition.CustomAttributes.FirstOrDefault(x => 
                x.AttributeType.FullName == "System.Runtime.Versioning.TargetFrameworkAttribute");

            if (targetFrameworkAttribute == null)
                return;

            if (targetFrameworkAttribute.ConstructorArguments.Count < 1)
                return;

            if (targetFrameworkAttribute.ConstructorArguments[0].Type.Name != "String")
                return;

            string versionInfo = (string)targetFrameworkAttribute.ConstructorArguments[0].Value;

            var values = versionInfo.Split(',');

            

            foreach (var value in values)
            {
                if (value.StartsWith(".NET"))
                {
                    AssemblyFrameworkType = value switch
                    {
                        ".NETFramework" => FrameworkType.NetFramework,
                        ".NETCoreApp"   => FrameworkType.NetCore,
                        ".NETStandard"  => FrameworkType.NetStandard,
                        _               => FrameworkType.Unknown
                    };
                }
                else if (value.StartsWith("Version=v"))
                {
                    try
                    {
                        NetFrameworkVersion = new Version(value.Substring("Version=v".Length));
                    }
                    catch { }
                }
            }
        }

        public static AssemblyBuildInfo DetermineInfo(AssemblyDefinition assemblyDefinition)
        {
            var buildInfo = new AssemblyBuildInfo();

            // framework version

            var runtime = assemblyDefinition.MainModule.Runtime;

            if (runtime == TargetRuntime.Net_1_0)
            {
                buildInfo.NetFrameworkVersion = new Version(1, 0);
                buildInfo.AssemblyFrameworkType = FrameworkType.NetFramework;
            }
            else if (runtime == TargetRuntime.Net_1_1)
            {
                buildInfo.NetFrameworkVersion = new Version(1, 1);
                buildInfo.AssemblyFrameworkType = FrameworkType.NetFramework;
            }
            else if (runtime == TargetRuntime.Net_2_0)
            {
                // Assume 3.5 here. The code to determine versions between 2.0 and 3.5 is not worth the amount of non-unity games that use it, if any

                buildInfo.NetFrameworkVersion = new Version(3, 5);
                buildInfo.AssemblyFrameworkType = FrameworkType.NetFramework;
            }
            else
            {
                buildInfo.SetNet4Version(assemblyDefinition);
            }

            // bitness

            /*
                AnyCPU 64-bit preferred
                MainModule.Architecture: I386
                MainModule.Attributes: ILOnly

                AnyCPU 32-bit preferred
                MainModule.Architecture: I386
                MainModule.Attributes: ILOnly, Required32Bit, Preferred32Bit

                x86
                MainModule.Architecture: I386
                MainModule.Attributes: ILOnly, Required32Bit

                x64
                MainModule.Architecture: AMD64
                MainModule.Attributes: ILOnly
            */

            var architecture = assemblyDefinition.MainModule.Architecture;
            var attributes = assemblyDefinition.MainModule.Attributes;

            if (architecture == TargetArchitecture.AMD64)
            {
                buildInfo.Is64Bit = true;
                buildInfo.IsAnyCpu = false;
            }
            else if (architecture == TargetArchitecture.I386 && HasFlag(attributes, ModuleAttributes.Preferred32Bit | ModuleAttributes.Required32Bit))
            {
                buildInfo.Is64Bit = false;
                buildInfo.IsAnyCpu = true;
            }
            else if (architecture == TargetArchitecture.I386 && HasFlag(attributes, ModuleAttributes.Required32Bit))
            {
                buildInfo.Is64Bit = false;
                buildInfo.IsAnyCpu = false;
            }
            else if (architecture == TargetArchitecture.I386)
            {
                buildInfo.Is64Bit = true;
                buildInfo.IsAnyCpu = true;
            }
            else
            {
                throw new Exception("Unable to determine assembly architecture");
            }

            return buildInfo;
        }

        private static bool HasFlag(ModuleAttributes value, ModuleAttributes flag)
        {
            return (value & flag) == flag;
        }

        /// <inheritdoc />
        public override string ToString()
        {
            string frameworkType = AssemblyFrameworkType switch {
                FrameworkType.NetFramework => "Framework",
                FrameworkType.NetStandard  => "Standard",
                FrameworkType.NetCore      => "Core",
                FrameworkType.Unknown      => "Unknown",
                _                          => throw new ArgumentOutOfRangeException()
            };

            if (IsAnyCpu)
            {
                return $".NET {frameworkType} {NetFrameworkVersion}, AnyCPU ({(Is64Bit ? "64" : "32")}-bit preferred)";
            }

            return $".NET {frameworkType} {NetFrameworkVersion}, {(Is64Bit ? "x64" : "x86")}";
        }
    }
}

```

`BepInEx.Preloader.Core/BepInEx.Preloader.Core.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <Description>Core classes and utilities for BepInEx Preloader</Description>
        <TargetFrameworks>net35;netstandard2.0</TargetFrameworks>
    </PropertyGroup>
    <ItemGroup>
        <ProjectReference Include="..\BepInEx.Core\BepInEx.Core.csproj"/>
    </ItemGroup>
    <ItemGroup>
        <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="All"/>
        <PackageReference Include="HarmonyX" Version="2.10.1"/>
        <PackageReference Include="MonoMod.RuntimeDetour" Version="22.5.1.1"/>
        <PackageReference Include="MonoMod.Utils" Version="22.5.1.1"/>
    </ItemGroup>
</Project>

```

`BepInEx.Preloader.Core/EnvVars.cs`:

```cs
using System;
using System.IO;

namespace BepInEx.Preloader.Core;

/// <summary>
///     Doorstop environment variables, passed into the BepInEx preloader.
///     <para>https://github.com/NeighTools/UnityDoorstop/wiki#environment-variables</para>
/// </summary>
public static class EnvVars
{
    /// <summary>
    ///     Path to the assembly that was invoked via Doorstop. Contains the same value as in "targetAssembly" configuration
    ///     option in the config file.
    /// </summary>
    public static string DOORSTOP_INVOKE_DLL_PATH { get; private set; }

    /// <summary>
    ///     Full path to the game's "Managed" folder that contains all the game's managed assemblies
    /// </summary>
    public static string DOORSTOP_MANAGED_FOLDER_DIR { get; private set; }

    /// <summary>
    ///     Full path to the game executable currently running.
    /// </summary>
    public static string DOORSTOP_PROCESS_PATH { get; private set; }

    /// <summary>
    ///     Array of paths where Mono searches DLLs from before assembly resolvers are invoked.
    /// </summary>
    public static string[] DOORSTOP_DLL_SEARCH_DIRS { get; private set; }

    /// <summary>
    ///     Path of the DLL that contains mono imports.
    /// </summary>
    public static string DOORSTOP_MONO_LIB_PATH { get; private set; }

    internal static void LoadVars()
    {
        DOORSTOP_INVOKE_DLL_PATH = Environment.GetEnvironmentVariable("DOORSTOP_INVOKE_DLL_PATH");
        DOORSTOP_MANAGED_FOLDER_DIR = Environment.GetEnvironmentVariable("DOORSTOP_MANAGED_FOLDER_DIR");
        DOORSTOP_PROCESS_PATH = Environment.GetEnvironmentVariable("DOORSTOP_PROCESS_PATH");
        DOORSTOP_MONO_LIB_PATH = Environment.GetEnvironmentVariable("DOORSTOP_MONO_LIB_PATH");
        DOORSTOP_DLL_SEARCH_DIRS =
            Environment.GetEnvironmentVariable("DOORSTOP_DLL_SEARCH_DIRS")?.Split(Path.PathSeparator) ??
            new string[0];
    }
}

```

`BepInEx.Preloader.Core/InternalPreloaderLogger.cs`:

```cs
using BepInEx.Logging;

namespace BepInEx.Preloader.Core;

public static class PreloaderLogger
{
    public static ManualLogSource Log { get; } = Logger.CreateLogSource("Preloader");
}

```

`BepInEx.Preloader.Core/Logging/ChainloaderLogHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using BepInEx.Logging;
using MonoMod.Utils;

namespace BepInEx.Preloader.Core.Logging;

public static class ChainloaderLogHelper
{
    private static Dictionary<string, string> MacOSVersions { get; } = new()
    {
        // https://en.wikipedia.org/wiki/Darwin_%28operating_system%29#Release_history
        ["16.0.0"] = "10.12",
        ["16.5.0"] = "10.12.4",
        ["16.6.0"] = "10.12.6",
        ["17.5.0"] = "10.13.4",
        ["17.6.0"] = "10.13.5",
        ["17.7.0"] = "10.13.6",
        ["18.2.0"] = "10.14.1",
        ["19.2.0"] = "10.15.2",
        ["19.3.0"] = "10.15.3",
        ["19.5.0"] = "10.15.5.1",
        ["20.1.0"] = "11.0",
        ["20.2.0"] = "11.1",
        ["20.3.0"] = "11.2",
        ["20.4.0"] = "11.3",
        ["20.5.0"] = "11.4",
        ["21.0.1"] = "12.0",
        ["21.1.0"] = "12.0.1",
        ["21.2.0"] = "12.1",
    };

    public static void PrintLogInfo(ManualLogSource log)
    {
        var bepinVersion = Paths.BepInExVersion;
        var versionMini = new SemanticVersioning.Version(bepinVersion.Major, bepinVersion.Minor, bepinVersion.Patch,
                                                         bepinVersion.PreRelease);
        var consoleTitle = $"BepInEx {versionMini} - {Paths.ProcessName}";
        log.Log(LogLevel.Message, consoleTitle);

        if (ConsoleManager.ConsoleActive)
            ConsoleManager.SetConsoleTitle(consoleTitle);

        if (!string.IsNullOrEmpty(bepinVersion.Build))
            log.Log(LogLevel.Message, $"Built from commit {bepinVersion.Build}");

        Logger.Log(LogLevel.Info, $"System platform: {GetPlatformString()}");
        Logger.Log(LogLevel.Info,
                   $"Process bitness: {(PlatformUtils.ProcessIs64Bit ? "64-bit (x64)" : "32-bit (x86)")}");
    }

    private static string GetPlatformString()
    {
        var builder = new StringBuilder();

        var osVersion = Environment.OSVersion.Version;

        // NOTE: this logic needs to be different for .NET 5.
        // We don't use it and I don't think we will for a long time (possibly ever), but upgrading will break Environment.OSVersion
        // https://docs.microsoft.com/en-us/dotnet/core/compatibility/core-libraries/5.0/environment-osversion-returns-correct-version#change-description

        // Some additional notes
        // On .NET Framework and .NET Core platforms before 5, Environment.OSVersion does not work as you would expect.

        // On Windows, it returns at maximum 6.3 (Windows 8) if you don't specify that your application is specifically compatible with Windows 10, due to compatibility layer stuff.
        // So we have to call RtlGetVersion which bypasses that and gets the values for us. This is done in PlatformUtils

        // On macOS it returns the Darwin kernel version. I've included a mapping of most versions, but there's definitely some missing versions

        // Not sure what it does on Linux. I think it returns the kernel version there too, but we already get the utsname structure from SetPlatform() regardless

        if (PlatformHelper.Is(Platform.Windows))
        {
            osVersion = PlatformUtils.WindowsVersion;

            builder.Append("Windows ");

            // https://stackoverflow.com/a/2819962

            if (osVersion.Major >= 10 && osVersion.Build >= 22000)
                builder.Append("11");
            else if (osVersion.Major >= 10)
                builder.Append("10");
            else if (osVersion.Major == 6 && osVersion.Minor == 3)
                builder.Append("8.1");
            else if (osVersion.Major == 6 && osVersion.Minor == 2)
                builder.Append("8");
            else if (osVersion.Major == 6 && osVersion.Minor == 1)
                builder.Append("7");
            else if (osVersion.Major == 6 && osVersion.Minor == 0)
                builder.Append("Vista");
            else if (osVersion.Major <= 5)
                builder.Append("XP");

            if (PlatformHelper.Is(Platform.Wine))
                builder.AppendFormat(" (Wine {0})", PlatformUtils.WineVersion);
        }
        else if (PlatformHelper.Is(Platform.MacOS))
        {
            builder.Append("macOS ");


            var osxVersion = osVersion.ToString(3);

            if (MacOSVersions.TryGetValue(osxVersion, out var macOsVersion))
            {
                builder.Append(macOsVersion);
            }
            else
            {
                builder.AppendFormat("Unknown (kernel {0})", osVersion);
            }
        }
        else if (PlatformHelper.Is(Platform.Linux))
        {
            builder.Append("Linux");

            if (PlatformUtils.LinuxKernelVersion != null)
            {
                builder.AppendFormat(" (kernel {0})", PlatformUtils.LinuxKernelVersion);
            }
        }

        builder.Append(PlatformHelper.Is(Platform.Bits64) ? " 64-bit" : " 32-bit");

        if (PlatformHelper.Is(Platform.Android))
        {
            builder.Append(" Android");
        }

        if (PlatformHelper.Is(Platform.ARM))
        {
            builder.Append(" ARM");

            if (PlatformHelper.Is(Platform.Bits64))
                builder.Append("64");
        }

        return builder.ToString();
    }

    public static void RewritePreloaderLogs()
    {
        if (PreloaderConsoleListener.LogEvents == null || PreloaderConsoleListener.LogEvents.Count == 0)
            return;

        // Temporarily disable the console log listener (if there is one from preloader) as we replay the preloader logs
        var logListener = Logger.Listeners.FirstOrDefault(logger => logger is ConsoleLogListener);

        if (logListener != null)
            Logger.Listeners.Remove(logListener);

        foreach (var preloaderLogEvent in PreloaderConsoleListener.LogEvents)
            Logger.InternalLogEvent(PreloaderLogger.Log, preloaderLogEvent);

        if (logListener != null)
            Logger.Listeners.Add(logListener);
    }
}

```

`BepInEx.Preloader.Core/Logging/PreloaderConsoleListener.cs`:

```cs
using System.Collections.Generic;
using BepInEx.Configuration;
using BepInEx.Logging;

namespace BepInEx.Preloader.Core.Logging;

/// <summary>
///     Log listener that listens to logs during preloading time and buffers messages for output in Unity logs later.
/// </summary>
public class PreloaderConsoleListener : ILogListener
{
    private static readonly ConfigEntry<LogLevel> ConfigConsoleDisplayedLevel = ConfigFile.CoreConfig.Bind(
     "Logging.Console", "LogLevels",
     LogLevel.Fatal | LogLevel.Error | LogLevel.Warning | LogLevel.Message | LogLevel.Info,
     "Which log levels to show in the console output.");

    /// <summary>
    ///     A list of all <see cref="LogEventArgs" /> objects that this listener has received.
    /// </summary>
    public static List<LogEventArgs> LogEvents { get; } = new();

    /// <inheritdoc />
    public LogLevel LogLevelFilter => ConfigConsoleDisplayedLevel.Value;

    /// <inheritdoc />
    public void LogEvent(object sender, LogEventArgs eventArgs) => LogEvents.Add(eventArgs);

    /// <inheritdoc />
    public void Dispose() { }
}

```

`BepInEx.Preloader.Core/Patching/AssemblyPatcher.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using BepInEx.Bootstrap;
using BepInEx.Configuration;
using BepInEx.Logging;
using HarmonyLib;
using Mono.Cecil;

namespace BepInEx.Preloader.Core.Patching;

/// <summary>
///     Worker class which is used for loading and patching entire folders of assemblies, or alternatively patching and
///     loading assemblies one at a time.
/// </summary>
public class AssemblyPatcher : IDisposable
{
    private static readonly string CurrentAssemblyName = Assembly.GetExecutingAssembly().GetName().Name;

    private Func<byte[], string, Assembly> assemblyLoader;

    public AssemblyPatcher(Func<byte[], string, Assembly> assemblyLoader)
    {
        this.assemblyLoader = assemblyLoader;
    }

    /// <summary>
    ///     The context of this assembly patcher instance that is passed to all patcher plugins.
    /// </summary>
    public PatcherContext PatcherContext { get; } = new()
    {
        DumpedAssembliesPath = Utility.CombinePaths(Paths.BepInExRootPath, "DumpedAssemblies", Paths.ProcessName)
    };

    /// <summary>
    ///     A cloned version of <see cref="PatcherPlugins" /> to ensure that any foreach loops do not break when the collection
    ///     gets modified.
    /// </summary>
    private IEnumerable<BasePatcher> PatcherPluginsSafe => PatcherContext.PatcherPlugins.ToList();

    private ManualLogSource Logger { get; } = BepInEx.Logging.Logger.CreateLogSource("AssemblyPatcher");

    private static Regex allowedGuidRegex { get; } = new(@"^[a-zA-Z0-9\._\-]+$");

    /// <summary>
    ///     Performs work to dispose collection objects.
    /// </summary>
    public void Dispose()
    {
        foreach (var assembly in PatcherContext.AvailableAssemblies)
            assembly.Value.Dispose();

        PatcherContext.AvailableAssemblies.Clear();

        PatcherContext.AvailableAssembliesPaths.Clear();

        // Clear to allow GC collection.
        PatcherContext.PatcherPlugins.Clear();
    }

    private PatcherPluginMetadata ToPatcherPlugin(TypeDefinition type, string assemblyPath)
    {
        if (type.IsInterface || type.IsAbstract && !type.IsSealed)
            return null;

        try
        {
            if (!type.IsSubtypeOf(typeof(BasePatcher)))
                return null;
        }
        catch (AssemblyResolutionException)
        {
            // Can happen if this type inherits a type from an assembly that can't be found. Safe to assume it's not a plugin.
            return null;
        }

        var metadata = PatcherPluginInfoAttribute.FromCecilType(type);

        // Perform checks that will prevent the plugin from being loaded in ALL cases
        if (metadata == null)
        {
            Logger.Log(LogLevel.Warning, $"Skipping over type [{type.FullName}] as no metadata attribute is specified");
            return null;
        }

        if (string.IsNullOrEmpty(metadata.GUID) || !allowedGuidRegex.IsMatch(metadata.GUID))
        {
            Logger.Log(LogLevel.Warning,
                       $"Skipping type [{type.FullName}] because its GUID [{metadata.GUID}] is of an illegal format");
            return null;
        }

        if (metadata.Version == null)
        {
            Logger.Log(LogLevel.Warning, $"Skipping type [{type.FullName}] because its version is invalid");
            return null;
        }

        if (metadata.Name == null)
        {
            Logger.Log(LogLevel.Warning, $"Skipping type [{type.FullName}] because its name is null");
            return null;
        }

        return new PatcherPluginMetadata
        {
            TypeName = type.FullName
        };
    }

    private bool HasPatcherPlugins(AssemblyDefinition ass)
    {
        if (ass.MainModule.AssemblyReferences.All(r => r.Name != CurrentAssemblyName) &&
            ass.Name.Name != CurrentAssemblyName)
            return false;
        if (ass.MainModule.GetTypeReferences().All(r => r.FullName != typeof(BasePatcher).FullName))
            return false;

        return true;
    }

    /// <summary>
    ///     Adds all patchers from all managed assemblies specified in a directory.
    /// </summary>
    /// <param name="directory">Directory to search patcher DLLs from.</param>
    public void AddPatchersFromDirectory(string directory)
    {
        if (!Directory.Exists(directory))
            return;

        var sortedPatchers = new List<PatchDefinition>();

        var patchers = TypeLoader.FindPluginTypes(directory, ToPatcherPlugin, HasPatcherPlugins);

        // TODO: Add dependency ordering and process attribute filtering

        foreach (var keyValuePair in patchers)
        {
            var assemblyPath = keyValuePair.Key;
            var patcherCollection = keyValuePair.Value;

            if (patcherCollection.Count == 0)
                continue;

            var ass = Assembly.LoadFrom(assemblyPath);

            foreach (var patcherPlugin in patcherCollection)
                try
                {
                    var type = ass.GetType(patcherPlugin.TypeName);

                    var instance = (BasePatcher) Activator.CreateInstance(type);
                    instance.Context = PatcherContext;

                    PatcherContext.PatcherPlugins.Add(instance);

                    var methods =
                        type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

                    foreach (var method in methods)
                    {
                        var targetAssemblies = MetadataHelper.GetAttributes<TargetAssemblyAttribute>(method);
                        var targetTypes = MetadataHelper.GetAttributes<TargetTypeAttribute>(method);

                        if (targetAssemblies.Length == 0 && targetTypes.Length == 0)
                            continue;

                        var parameters = method.GetParameters();

                        if (parameters.Length < 1 || parameters.Length > 2
                                                     // Next few lines ensure that the first parameter is AssemblyDefinition and does not have any
                                                     // target type attributes, and vice versa
                                                  || !(
                                                          parameters[0].ParameterType == typeof(AssemblyDefinition)
                                                       || parameters[0].ParameterType ==
                                                          typeof(AssemblyDefinition).MakeByRefType()
                                                       && targetTypes.Length == 0
                                                       || parameters[0].ParameterType == typeof(TypeDefinition)
                                                       && targetAssemblies.Length == 0
                                                      )
                                                  || parameters.Length == 2 &&
                                                     parameters[1].ParameterType != typeof(string)
                                                  || method.ReturnType != typeof(void) &&
                                                     method.ReturnType != typeof(bool)
                           )
                        {
                            Logger
                                .Log(LogLevel.Warning,
                                     $"Skipping method [{method.FullDescription()}] as it is not a valid patcher method");
                            continue;
                        }

                        void AddDefinition(PatchDefinition definition)
                        {
                            Logger.Log(LogLevel.Debug, $"Discovered patch [{definition.FullName}]");
                            sortedPatchers.Add(definition);
                        }

                        foreach (var targetAssembly in targetAssemblies)
                            AddDefinition(new PatchDefinition(targetAssembly, instance, method));
                        foreach (var targetType in targetTypes)
                            AddDefinition(new PatchDefinition(targetType, instance, method));
                    }
                }
                catch (Exception e)
                {
                    Logger.Log(LogLevel.Error,
                               $"Failed to load patchers from type [{patcherPlugin.TypeName}]: {(e is ReflectionTypeLoadException re ? TypeLoader.TypeLoadExceptionToString(re) : e.ToString())}");
                }

            var assName = ass.GetName();
            Logger.Log(patcherCollection.Any() ? LogLevel.Info : LogLevel.Debug,
                       $"Loaded {patcherCollection.Count} patcher type{(patcherCollection.Count == 1 ? "" : "s")} from [{assName.Name} {assName.Version}]");
        }

        PatcherContext.PatchDefinitions.AddRange(sortedPatchers);
    }


    /// <summary>
    ///     Adds all .dll assemblies in given directories to be patched and loaded by this patcher instance. Non-managed
    ///     assemblies
    ///     are skipped.
    /// </summary>
    /// <param name="directories">The directories to search.</param>
    public void LoadAssemblyDirectories(params string[] directories) =>
        LoadAssemblyDirectories(directories, new[] { "dll" });

    /// <summary>
    ///     Adds all assemblies in given directories to be patched and loaded by this patcher instance. Non-managed assemblies
    ///     are
    ///     skipped.
    /// </summary>
    /// <param name="directories">The directory to search.</param>
    /// <param name="assemblyExtensions">The file extensions to attempt to load.</param>
    public void LoadAssemblyDirectories(IEnumerable<string> directories, IEnumerable<string> assemblyExtensions)
    {
        var filesToSearch = assemblyExtensions
            .SelectMany(ext => Utility.GetUniqueFilesInDirectories(directories, $"*.{ext}"));

        foreach (var assemblyPath in filesToSearch)
        {
            if (!TryLoadAssembly(assemblyPath, out var assembly))
                continue;

            // NOTE: this is special cased here because the dependency handling for System.dll is a bit wonky
            // System has an assembly reference to itself, and it also has a reference to Mono.Security causing a circular dependency
            // It's also generally dangerous to change system.dll since so many things rely on it, 
            // and it's already loaded into the appdomain since this loader references it, so we might as well skip it
            if (assembly.Name.Name == "System"
             || assembly.Name.Name ==
                "mscorlib") //mscorlib is already loaded into the appdomain so it can't be patched
            {
                assembly.Dispose();
                continue;
            }

            var fileName = Path.GetFileName(assemblyPath);
            PatcherContext.AvailableAssemblies.Add(fileName, assembly);
            PatcherContext.AvailableAssembliesPaths.Add(fileName, assemblyPath);

            Logger.LogDebug($"Assembly loaded: {Path.GetFileName(assemblyPath)}");

            //if (UnityPatches.AssemblyLocations.ContainsKey(assembly.FullName))
            //{
            //	Logger.LogWarning($"Tried to load duplicate assembly {Path.GetFileName(assemblyPath)} from Managed folder! Skipping...");
            //	continue;
            //}

            //assemblies.Add(Path.GetFileName(assemblyPath), assembly);
            //UnityPatches.AssemblyLocations.Add(assembly.FullName, Path.GetFullPath(assemblyPath));
        }
    }

    /// <summary>
    ///     Attempts to load a managed assembly as an <see cref="AssemblyDefinition" />. Returns true if successful.
    /// </summary>
    /// <param name="path">The path of the assembly.</param>
    /// <param name="assembly">The loaded assembly. Null if not successful in loading.</param>
    public static bool TryLoadAssembly(string path, out AssemblyDefinition assembly)
    {
        try
        {
            assembly = AssemblyDefinition.ReadAssembly(path, TypeLoader.ReaderParameters);
            return true;
        }
        catch (BadImageFormatException)
        {
            // Not a managed assembly
            assembly = null;
            return false;
        }
    }

    /// <summary>
    ///     Applies patchers to all assemblies loaded into this assembly patcher and then loads patched assemblies into memory.
    /// </summary>
    public void PatchAndLoad()
    {
        // First, create a copy of the assembly dictionary as the initializer can change them
        var assemblies =
            new Dictionary<string, AssemblyDefinition>(PatcherContext.AvailableAssemblies,
                                                       StringComparer.InvariantCultureIgnoreCase);

        // Next, initialize all the patchers
        foreach (var assemblyPatcher in PatcherPluginsSafe)
            try
            {
                assemblyPatcher.Initialize();
            }
            catch (Exception ex)
            {
                Logger.Log(LogLevel.Error, $"Failed to run initializer of {assemblyPatcher.Info.GUID}: {ex}");
            }

        // Then, perform the actual patching

        var patchedAssemblies = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);
        var resolvedAssemblies = new Dictionary<string, string>();

        // TODO: Maybe instead reload the assembly and repatch with other valid patchers?
        var invalidAssemblies = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);

        Logger.Log(LogLevel.Message, $"Executing {PatcherContext.PatchDefinitions.Count} patch(es)");

        foreach (var patchDefinition in PatcherContext.PatchDefinitions.ToList())
        {
            var targetDll = patchDefinition.TargetAssembly?.TargetAssembly ??
                            patchDefinition.TargetType.TargetAssembly;

            var isAssemblyPatch = patchDefinition.TargetAssembly != null;

            if (targetDll == TargetAssemblyAttribute.AllAssemblies)
            {
                foreach (var kv in PatcherContext.AvailableAssemblies.ToList())
                {
                    if (invalidAssemblies.Contains(kv.Key))
                        continue;

                    RunPatcher(kv.Value, kv.Key);
                }
            }
            else
            {
                if (!PatcherContext.AvailableAssemblies.TryGetValue(targetDll, out var assembly)
                 || invalidAssemblies.Contains(targetDll))
                    continue;

                RunPatcher(assembly, targetDll);
            }


            bool RunPatcher(AssemblyDefinition assembly, string targetDll)
            {
                try
                {
                    var arguments = new object[patchDefinition.MethodInfo.GetParameters().Length];

                    if (!isAssemblyPatch)
                    {
                        var targetType =
                            assembly.MainModule.Types.FirstOrDefault(x => x.FullName ==
                                                                          patchDefinition.TargetType.TargetType);

                        if (targetType == null)
                        {
                            Logger
                                .LogWarning($"Unable to find type [{patchDefinition.TargetType.TargetType}] defined in {patchDefinition.MethodInfo.Name}. Skipping patcher"); //TODO: Proper name
                            return false;
                        }

                        arguments[0] = targetType;
                    }
                    else
                    {
                        arguments[0] = assembly;
                    }

                    if (arguments.Length > 1)
                        arguments[1] = targetDll;

                    var result = patchDefinition.MethodInfo.Invoke(patchDefinition.Instance, arguments);

                    if (patchDefinition.MethodInfo.ReturnType == typeof(void)
                     || patchDefinition.MethodInfo.ReturnType == typeof(bool) && (bool) result)
                    {
                        if (isAssemblyPatch)
                        {
                            assembly = (AssemblyDefinition) arguments[0];
                            PatcherContext.AvailableAssemblies[targetDll] = assembly;
                        }

                        patchedAssemblies.Add(targetDll);
                    }

                    return true;
                }
                catch (Exception e)
                {
                    Logger.Log(LogLevel.Error,
                               $"Failed to run [{patchDefinition.FullName}] when patching [{assembly.Name.Name}]. This assembly will not be patched. Error: {e}");
                    patchedAssemblies.Remove(targetDll);
                    invalidAssemblies.Add(targetDll);
                    return false;
                }
            }


            foreach (var resolvedAss in AppDomain.CurrentDomain.GetAssemblies())
            {
                var name = Utility.TryParseAssemblyName(resolvedAss.FullName, out var assName)
                               ? assName.Name
                               : resolvedAss.FullName;

                // Report only the first type that caused the assembly to load, because any subsequent ones can be false positives
                if (!resolvedAssemblies.ContainsKey(name))
                    resolvedAssemblies[name] = patchDefinition.MethodInfo.DeclaringType.ToString();
            }
        }

        // Check if any patched assemblies have been already resolved by the CLR
        // If there are any, they cannot be loaded by the preloader
        var patchedAssemblyNames =
            new
                HashSet<string>(assemblies.Where(kv => patchedAssemblies.Contains(kv.Key)).Select(kv => kv.Value.Name.Name),
                                StringComparer.InvariantCultureIgnoreCase);
        var earlyLoadAssemblies = resolvedAssemblies.Where(kv => patchedAssemblyNames.Contains(kv.Key)).ToList();

        if (earlyLoadAssemblies.Count != 0)
            Logger.Log(LogLevel.Warning, new StringBuilder()
                                         .AppendLine("The following assemblies have been loaded too early and will not be patched by preloader:")
                                         .AppendLine(string.Join(Environment.NewLine,
                                                                 earlyLoadAssemblies
                                                                     .Select(kv =>
                                                                                 $"* [{kv.Key}] (first loaded by [{kv.Value}])")
                                                                     .ToArray()))
                                         .AppendLine("Expect unexpected behavior and issues with plugins and patchers not being loaded.")
                                         .ToString());

        var dumpedAssemblyPaths = new Dictionary<string, string>();
        // Finally, load patched assemblies into memory
        if (ConfigDumpAssemblies.Value || ConfigLoadDumpedAssemblies.Value)
        {
            if (!Directory.Exists(PatcherContext.DumpedAssembliesPath))
                Directory.CreateDirectory(PatcherContext.DumpedAssembliesPath);

            foreach (var kv in assemblies)
            {
                var filename = kv.Key;
                var name = Path.GetFileNameWithoutExtension(filename);
                var ext = Path.GetExtension(filename);
                var assembly = kv.Value;

                if (!patchedAssemblies.Contains(filename))
                    continue;
                for (var i = 0;; i++)
                {
                    var postfix = i > 0 ? $"_{i}" : "";
                    var path = Path.Combine(PatcherContext.DumpedAssembliesPath, $"{name}{postfix}{ext}");
                    if (!Utility.TryOpenFileStream(path, FileMode.Create, out var fs))
                        continue;
                    assembly.Write(fs);
                    fs.Dispose();
                    dumpedAssemblyPaths[filename] = path;
                    break;
                }
            }
        }

        if (ConfigBreakBeforeLoadAssemblies.Value)
        {
            Logger.Log(LogLevel.Info,
                       $"BepInEx is about load the following assemblies:\n{string.Join("\n", patchedAssemblies.ToArray())}");
            Logger.Log(LogLevel.Info, $"The assemblies were dumped into {PatcherContext.DumpedAssembliesPath}");
            Logger.Log(LogLevel.Info, "Load any assemblies into the debugger, set breakpoints and continue execution.");
            Debugger.Break();
        }

        foreach (var kv in assemblies)
        {
            var filename = kv.Key;
            var assembly = kv.Value;

            // Note that since we only *load* assemblies, they shouldn't trigger dependency loading
            // Not loading all assemblies is very important not only because of memory reasons,
            // but because some games *rely* on that because of messed up internal dependencies.
            if (patchedAssemblies.Contains(filename))
            {
                Assembly loadedAssembly;

                if (ConfigLoadDumpedAssemblies.Value &&
                    dumpedAssemblyPaths.TryGetValue(filename, out var dumpedAssemblyPath))
                {
                    loadedAssembly = Assembly.LoadFrom(dumpedAssemblyPath);
                }
                else
                {
                    using var assemblyStream = new MemoryStream();
                    assembly.Write(assemblyStream);
                    loadedAssembly = assemblyLoader(assemblyStream.ToArray(),
                                                    PatcherContext.AvailableAssembliesPaths[filename]);
                }

                PatcherContext.LoadedAssemblies.Add(filename, loadedAssembly);

                Logger.Log(LogLevel.Debug, $"Loaded '{assembly.FullName}' into memory");
            }

            // Though we have to dispose of all assemblies regardless of them being patched or not
            assembly.Dispose();
        }

        // Finally, run all finalizers
        foreach (var assemblyPatcher in PatcherPluginsSafe)
            try
            {
                assemblyPatcher.Finalizer();
            }
            catch (Exception ex)
            {
                Logger.Log(LogLevel.Error, $"Failed to run finalizer of {assemblyPatcher.Info.GUID}: {ex}");
            }
    }

    #region Config

    private static readonly ConfigEntry<bool> ConfigDumpAssemblies = ConfigFile.CoreConfig.Bind(
     "Preloader", "DumpAssemblies",
     false,
     "If enabled, BepInEx will save patched assemblies into BepInEx/DumpedAssemblies.\nThis can be used by developers to inspect and debug preloader patchers.");

    private static readonly ConfigEntry<bool> ConfigLoadDumpedAssemblies = ConfigFile.CoreConfig.Bind(
     "Preloader", "LoadDumpedAssemblies",
     false,
     "If enabled, BepInEx will load patched assemblies from BepInEx/DumpedAssemblies instead of memory.\nThis can be used to be able to load patched assemblies into debuggers like dnSpy.\nIf set to true, will override DumpAssemblies.");

    private static readonly ConfigEntry<bool> ConfigBreakBeforeLoadAssemblies = ConfigFile.CoreConfig.Bind(
     "Preloader", "BreakBeforeLoadAssemblies",
     false,
     "If enabled, BepInEx will call Debugger.Break() once before loading patched assemblies.\nThis can be used with debuggers like dnSpy to install breakpoints into patched assemblies before they are loaded.");

    #endregion
}

```

`BepInEx.Preloader.Core/Patching/Attributes.cs`:

```cs
using System;
using System.Linq;
using Mono.Cecil;
using Version = SemanticVersioning.Version;

namespace BepInEx.Preloader.Core.Patching;

/// <summary>
///     This attribute denotes that a class is a patcher plugin, and specifies the required metadata.
/// </summary>
[AttributeUsage(AttributeTargets.Class)]
public class PatcherPluginInfoAttribute : Attribute
{
    /// <param name="GUID">The unique identifier of the plugin. Should not change between plugin versions.</param>
    /// <param name="Name">The user friendly name of the plugin. Is able to be changed between versions.</param>
    /// <param name="Version">The specific version of the plugin.</param>
    public PatcherPluginInfoAttribute(string GUID, string Name, string Version)
    {
        this.GUID = GUID;
        this.Name = Name;
        this.Version = TryParseLongVersion(Version);
    }

    /// <summary>
    ///     The unique identifier of the plugin. Should not change between plugin versions.
    /// </summary>
    public string GUID { get; protected set; }


    /// <summary>
    ///     The user friendly name of the plugin. Is able to be changed between versions.
    /// </summary>
    public string Name { get; protected set; }


    /// <summary>
    ///     The specific version of the plugin.
    /// </summary>
    public Version Version { get; protected set; }

    private static Version TryParseLongVersion(string version)
    {
        if (Version.TryParse(version, out var v))
            return v;

        // no System.Version.TryParse() on .NET 3.5
        try
        {
            var longVersion = new System.Version(version);

            return new Version(longVersion.Major, longVersion.Minor,
                               longVersion.Build != -1 ? longVersion.Build : 0);
        }
        catch { }

        return null;
    }

    internal static PatcherPluginInfoAttribute FromCecilType(TypeDefinition td)
    {
        var attr = MetadataHelper.GetCustomAttributes<PatcherPluginInfoAttribute>(td, false).FirstOrDefault();

        if (attr == null)
            return null;

        return new PatcherPluginInfoAttribute((string) attr.ConstructorArguments[0].Value,
                                              (string) attr.ConstructorArguments[1].Value,
                                              (string) attr.ConstructorArguments[2].Value);
    }

    internal static PatcherPluginInfoAttribute FromType(Type type)
    {
        var attributes = type.GetCustomAttributes(typeof(PatcherPluginInfoAttribute), false);

        if (attributes.Length == 0)
            return null;

        return (PatcherPluginInfoAttribute) attributes[0];
    }
}

/// <summary>
///     Defines an assembly that a patch method will target.
/// </summary>
[AttributeUsage(AttributeTargets.Method)]
public class TargetAssemblyAttribute : Attribute
{
    /// <summary>
    ///     Marker used to indicate all possible assemblies to be targeted by a patch method.
    /// </summary>
    public const string AllAssemblies = "_all";

    /// <param name="targetAssembly">
    ///     The short filename of the assembly. Use <see cref="AllAssemblies" /> to mark all possible
    ///     assemblies as targets.
    /// </param>
    public TargetAssemblyAttribute(string targetAssembly)
    {
        TargetAssembly = targetAssembly;
    }

    /// <summary>
    ///     The short filename of the assembly to target.
    /// </summary>
    public string TargetAssembly { get; }
}

/// <summary>
///     Defines a type that a patch method will target.
/// </summary>
[AttributeUsage(AttributeTargets.Method)]
public class TargetTypeAttribute : Attribute
{
    /// <param name="targetAssembly">The short filename of the assembly of which <paramref name="targetType" /> belongs to.</param>
    /// <param name="targetType">The full name of the type to target for patching.</param>
    public TargetTypeAttribute(string targetAssembly, string targetType)
    {
        TargetAssembly = targetAssembly;
        TargetType = targetType;
    }

    /// <summary>
    ///     The short filename of the assembly to target.
    /// </summary>
    public string TargetAssembly { get; }

    /// <summary>
    ///     The full name of the type to target for patching.
    /// </summary>
    public string TargetType { get; }
}

```

`BepInEx.Preloader.Core/Patching/BasePatcher.cs`:

```cs
using BepInEx.Configuration;
using BepInEx.Logging;

namespace BepInEx.Preloader.Core.Patching;

/// <summary>
///     A patcher that can contain multiple methods for patching assemblies.
/// </summary>
public abstract class BasePatcher
{
    protected BasePatcher()
    {
        Info = PatcherPluginInfoAttribute.FromType(GetType());

        Log = Logger.CreateLogSource(Info.Name);

        Config = new ConfigFile(Utility.CombinePaths(Paths.ConfigPath, Info.GUID + ".cfg"), false,
                                new BepInPlugin(Info.GUID, Info.Name, Info.Version.ToString()));
    }

    /// <summary>
    ///     A <see cref="ILogSource" /> instance created for use by this patcher plugin.
    /// </summary>
    public ManualLogSource Log { get; }

    /// <summary>
    ///     A configuration file binding created with the <see cref="PatcherPluginInfoAttribute.GUID" /> of this plugin as the
    ///     filename.
    /// </summary>
    public ConfigFile Config { get; }

    /// <summary>
    ///     Metadata associated with this patcher plugin.
    /// </summary>
    public PatcherPluginInfoAttribute Info { get; }

    /// <summary>
    ///     The context of the <see cref="AssemblyPatcher" /> this BasePatcher is associated with.
    /// </summary>
    public PatcherContext Context { get; set; }

    /// <summary>
    ///     Executed before any patches from any plugin are applied.
    /// </summary>
    public virtual void Initialize() { }

    /// <summary>
    ///     Executed after all patches from all plugins have been applied.
    /// </summary>
    public virtual void Finalizer() { }
}

```

`BepInEx.Preloader.Core/Patching/PatcherContext.cs`:

```cs
using System.Collections.Generic;
using System.Reflection;
using Mono.Cecil;

namespace BepInEx.Preloader.Core.Patching;

/// <summary>
///     A definition of an individual patch for use by <see cref="AssemblyPatcher" />.
/// </summary>
public class PatchDefinition
{
    public PatchDefinition(TargetAssemblyAttribute targetAssembly, BasePatcher instance, MethodInfo methodInfo)
    {
        TargetAssembly = targetAssembly;
        Instance = instance;
        MethodInfo = methodInfo;

        FullName = $"{MethodInfo.DeclaringType.FullName}/{MethodInfo.Name} -> {TargetAssembly.TargetAssembly}";
    }

    public PatchDefinition(TargetTypeAttribute targetType, BasePatcher instance, MethodInfo methodInfo)
    {
        TargetType = targetType;
        Instance = instance;
        MethodInfo = methodInfo;

        FullName =
            $"{MethodInfo.DeclaringType.FullName}/{MethodInfo.Name} -> {TargetType.TargetAssembly}/{TargetType.TargetType}";
    }

    /// <summary>
    ///     The assembly / assemblies this patch will target, if there any.
    /// </summary>
    public TargetAssemblyAttribute TargetAssembly { get; }

    /// <summary>
    ///     The type / types this patch will target, if there are any.
    /// </summary>
    public TargetTypeAttribute TargetType { get; }

    /// <summary>
    ///     The instance of the <see cref="BasePatcher" /> this <see cref="PatchDefinition" /> originates from.
    /// </summary>
    public BasePatcher Instance { get; }

    /// <summary>
    ///     The method that will perform the patching logic defined by this <see cref="PatchDefinition" /> instance.
    /// </summary>
    public MethodInfo MethodInfo { get; }

    /// <summary>
    ///     A friendly name for this patch definition, for use in logging and error tracking.
    /// </summary>
    public string FullName { get; }
}

/// <summary>
///     Context provided to patcher plugins from the associated patcher engine.
/// </summary>
public class PatcherContext
{
    /// <summary>
    ///     <para>Contains a list of assemblies that will be patched and loaded into the runtime.</para>
    ///     <para>
    ///         The dictionary has the name of the file, without any directories. These are used by the dumping
    ///         functionality, and as such, these are also required to be unique. They do not have to be exactly the same as
    ///         the real filename, however they have to be mapped deterministically.
    ///     </para>
    ///     <para>Order is not respected, as it will be sorted by dependencies.</para>
    /// </summary>
    public Dictionary<string, AssemblyDefinition> AvailableAssemblies { get; } = new();

    /// <summary>
    ///     <para>Contains a mapping of available assembly name to their original filenames.</para>
    /// </summary>
    public Dictionary<string, string> AvailableAssembliesPaths { get; } = new();

    /// <summary>
    ///     <para>Contains a dictionary of assemblies that have been loaded as part of executing this assembly patcher.</para>
    ///     <para>
    ///         The key is the same key as used in <see cref="LoadedAssemblies" />, while the value is the actual assembly
    ///         itself.
    ///     </para>
    /// </summary>
    public Dictionary<string, Assembly> LoadedAssemblies { get; } = new();

    /// <summary>
    ///     A list of plugins that will be initialized and executed, in the order of the list.
    /// </summary>
    public List<BasePatcher> PatcherPlugins { get; } = new();

    /// <summary>
    ///     A list of individual patches that <see cref="AssemblyPatcher" /> will execute, generated by parsing
    ///     <see cref="PatcherPlugins" />.
    /// </summary>
    public List<PatchDefinition> PatchDefinitions { get; } = new();

    /// <summary>
    ///     The directory location as to where patched assemblies will be saved to and loaded from disk, for debugging
    ///     purposes. Defaults to BepInEx/DumpedAssemblies/<ProcessName>
    /// </summary>
    public string DumpedAssembliesPath { get; internal set; }
}

```

`BepInEx.Preloader.Core/Patching/PatcherPluginMetadata.cs`:

```cs
using System.IO;
using BepInEx.Bootstrap;

namespace BepInEx.Preloader.Core.Patching;

/// <summary>
///     A single cached assembly patcher.
/// </summary>
internal class PatcherPluginMetadata : ICacheable
{
    /// <summary>
    ///     Type name of the patcher.
    /// </summary>
    public string TypeName { get; set; } = string.Empty;

    /// <inheritdoc />
    public void Save(BinaryWriter bw) => bw.Write(TypeName);

    /// <inheritdoc />
    public void Load(BinaryReader br) => TypeName = br.ReadString();
}

```

`BepInEx.Preloader.Core/PlatformUtils.cs`:

```cs
using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using MonoMod.Utils;

namespace BepInEx.Preloader.Core;

internal static class PlatformUtils
{
    public static readonly bool ProcessIs64Bit = IntPtr.Size >= 8;
    public static Version WindowsVersion { get; set; }
    public static Version WineVersion { get; set; }

    public static string LinuxArchitecture { get; set; }
    public static string LinuxKernelVersion { get; set; }

    [DllImport("libc.so.6", EntryPoint = "uname", CallingConvention = CallingConvention.Cdecl,
               CharSet = CharSet.Ansi)]
    private static extern IntPtr uname_linux(ref utsname_linux utsname);

    [DllImport("/usr/lib/libSystem.dylib", EntryPoint = "uname", CallingConvention = CallingConvention.Cdecl,
               CharSet = CharSet.Ansi)]
    private static extern IntPtr uname_osx(ref utsname_osx utsname);

    [DllImport("ntdll.dll", SetLastError = true)]
    private static extern bool RtlGetVersion(ref WindowsOSVersionInfoExW versionInfo);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr LoadLibrary(string libraryName);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    private static bool Is(this Platform current, Platform expected) => (current & expected) == expected;

    /// <summary>
    ///     Recreation of MonoMod's PlatformHelper.DeterminePlatform method, but with libc calls instead of creating processes.
    /// </summary>
    public static void SetPlatform()
    {
        var current = Platform.Unknown;

        // For old Mono, get from a private property to accurately get the platform.
        // static extern PlatformID Platform
        var p_Platform = typeof(Environment).GetProperty("Platform", BindingFlags.NonPublic | BindingFlags.Static);
        string platID;
        if (p_Platform != null)
            platID = p_Platform.GetValue(null, new object[0]).ToString();
        else
            // For .NET and newer Mono, use the usual value.
            platID = Environment.OSVersion.Platform.ToString();
        platID = platID.ToLowerInvariant();

        if (platID.Contains("win"))
            current = Platform.Windows;
        else if (platID.Contains("mac") || platID.Contains("osx"))
            current = Platform.MacOS;
        else if (platID.Contains("lin") || platID.Contains("unix"))
            current = Platform.Linux;

        if (current.Is(Platform.Linux) && Directory.Exists("/data") && File.Exists("/system/build.prop"))
            current = Platform.Android;
        else if (current.Is(Platform.Unix) && Directory.Exists("/System/Library/AccessibilityBundles"))
            current = Platform.iOS;

        if (current.Is(Platform.Windows))
        {
            var windowsVersionInfo = new WindowsOSVersionInfoExW();
            RtlGetVersion(ref windowsVersionInfo);

            WindowsVersion = new Version((int) windowsVersionInfo.dwMajorVersion,
                                         (int) windowsVersionInfo.dwMinorVersion, 0,
                                         (int) windowsVersionInfo.dwBuildNumber);

            var ntDll = LoadLibrary("ntdll.dll");
            if (ntDll != IntPtr.Zero)
            {
                var wineGetVersion = GetProcAddress(ntDll, "wine_get_version");
                if (wineGetVersion != IntPtr.Zero)
                {
                    current |= Platform.Wine;
                    var getVersion = wineGetVersion.AsDelegate<GetWineVersionDelegate>();
                    WineVersion = new Version(getVersion());
                }
            }
        }

        // Is64BitOperatingSystem has been added in .NET Framework 4.0
        var m_get_Is64BitOperatingSystem =
            typeof(Environment).GetProperty("Is64BitOperatingSystem")?.GetGetMethod();
        if (m_get_Is64BitOperatingSystem != null)
            current |= (bool) m_get_Is64BitOperatingSystem.Invoke(null, new object[0]) ? Platform.Bits64 : 0;
        else
            current |= IntPtr.Size >= 8 ? Platform.Bits64 : 0;

        if ((current.Is(Platform.MacOS) || current.Is(Platform.Linux)) && Type.GetType("Mono.Runtime") != null)
        {
            string arch;
            IntPtr result;

            if (current.Is(Platform.MacOS))
            {
                var utsname_osx = new utsname_osx();
                result = uname_osx(ref utsname_osx);
                arch = utsname_osx.machine;
            }
            else
            {
                // Linux
                var utsname_linux = new utsname_linux();
                result = uname_linux(ref utsname_linux);
                arch = utsname_linux.machine;

                LinuxArchitecture = utsname_linux.machine;
                LinuxKernelVersion = utsname_linux.version;
            }

            if (result == IntPtr.Zero && (arch.StartsWith("aarch") || arch.StartsWith("arm")))
                current |= Platform.ARM;
        }
        else
        {
            // Detect ARM based on PE info or uname.
            typeof(object).Module.GetPEKind(out var peKind, out var machine);
            if (machine == (ImageFileMachine) 0x01C4 /* ARM, .NET Framework 4.5 */)
                current |= Platform.ARM;
        }

        PlatformHelper.Current = current;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.LPStr)]
    private delegate string GetWineVersionDelegate();

    [StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Unicode)]
    public struct WindowsOSVersionInfoExW
    {
        public uint dwOSVersionInfoSize;
        public uint dwMajorVersion;
        public uint dwMinorVersion;
        public uint dwBuildNumber;
        public uint dwPlatformId;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
        public string szCSDVersion;

        public ushort wServicePackMajor;
        public ushort wServicePackMinor;
        public ushort wSuiteMask;
        public byte wProductType;
        public byte wReserved;

        public WindowsOSVersionInfoExW()
        {
            dwOSVersionInfoSize = (uint) Marshal.SizeOf(typeof(WindowsOSVersionInfoExW));
            dwMajorVersion = 0;
            dwMinorVersion = 0;
            dwBuildNumber = 0;
            dwPlatformId = 0;
            szCSDVersion = null;
            wServicePackMajor = 0;
            wServicePackMinor = 0;
            wSuiteMask = 0;
            wProductType = 0;
            wReserved = 0;
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct utsname_osx
    {
        private const int osx_utslen = 256;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = osx_utslen)]
        public string sysname;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = osx_utslen)]
        public string nodename;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = osx_utslen)]
        public string release;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = osx_utslen)]
        public string version;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = osx_utslen)]
        public string machine;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct utsname_linux
    {
        private const int linux_utslen = 65;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = linux_utslen)]
        public string sysname;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = linux_utslen)]
        public string nodename;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = linux_utslen)]
        public string release;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = linux_utslen)]
        public string version;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = linux_utslen)]
        public string machine;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = linux_utslen)]
        public string domainname;
    }
}

```

`BepInEx.Preloader.Core/Properties/AssemblyInfo.cs`:

```cs
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("BepInEx.Unity.Mono.Preloader")]
[assembly: InternalsVisibleTo("BepInEx.NET.Framework.Launcher")]
[assembly: InternalsVisibleTo("BepInEx.NET.CoreCLR")]
[assembly: InternalsVisibleTo("BepInEx.Unity.IL2CPP")]

```

`BepInEx.Preloader.Core/RuntimeFixes/ConsoleSetOutFix.cs`:

```cs
using System;
using System.IO;
using System.Text;
using BepInEx.Logging;
using HarmonyLib;

namespace BepInEx.Preloader.RuntimeFixes;

public static class ConsoleSetOutFix
{
    private static LoggedTextWriter loggedTextWriter;
    internal static ManualLogSource ConsoleLogSource = Logger.CreateLogSource("Console");

    public static void Apply()
    {
        loggedTextWriter = new LoggedTextWriter { Parent = Console.Out };
        Console.SetOut(loggedTextWriter);
        Harmony.CreateAndPatchAll(typeof(ConsoleSetOutFix));
    }

    [HarmonyPatch(typeof(Console), nameof(Console.SetOut))]
    [HarmonyPrefix]
    private static bool OnSetOut(TextWriter newOut)
    {
        loggedTextWriter.Parent = newOut;
        return false;
    }
}

internal class LoggedTextWriter : TextWriter
{
    public override Encoding Encoding { get; } = Encoding.UTF8;

    public TextWriter Parent { get; set; }

    public override void Flush() => Parent.Flush();

    public override void Write(string value)
    {
        ConsoleSetOutFix.ConsoleLogSource.Log(LogLevel.Info, value);
        Parent.Write(value);
    }

    public override void WriteLine(string value)
    {
        ConsoleSetOutFix.ConsoleLogSource.Log(LogLevel.Info, value);
        Parent.WriteLine(value);
    }
}

```

`BepInEx.Preloader.Core/RuntimeFixes/HarmonyBackendFix.cs`:

```cs
using System;
using System.ComponentModel;
using BepInEx.Configuration;

namespace BepInEx.Preloader.RuntimeFixes;

public static class HarmonyBackendFix
{
    private static readonly ConfigEntry<MonoModBackend> ConfigHarmonyBackend = ConfigFile.CoreConfig.Bind(
     "Preloader",
     "HarmonyBackend",
     MonoModBackend.auto,
     "Specifies which MonoMod backend to use for Harmony patches. Auto uses the best available backend.\nThis setting should only be used for development purposes (e.g. debugging in dnSpy). Other code might override this setting.");

    public static void Initialize()
    {
        switch (ConfigHarmonyBackend.Value)
        {
            case MonoModBackend.auto:
                break;
            case MonoModBackend.dynamicmethod:
            case MonoModBackend.methodbuilder:
            case MonoModBackend.cecil:
                Environment.SetEnvironmentVariable("MONOMOD_DMD_TYPE", ConfigHarmonyBackend.Value.ToString());
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(ConfigHarmonyBackend), ConfigHarmonyBackend.Value,
                                                      "Unknown backend");
        }
    }

    private enum MonoModBackend
    {
        // Enum names are important!
        [Description("Auto")]
        auto = 0,

        [Description("DynamicMethod")]
        dynamicmethod,

        [Description("MethodBuilder")]
        methodbuilder,

        [Description("Cecil")]
        cecil
    }
}

```

`BepInEx.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32112.339
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BepInEx.Preloader.Core", "BepInEx.Preloader.Core\BepInEx.Preloader.Core.csproj", "{15F8BC38-A761-4F93-8903-1B531AC5D9F9}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BepInEx.Unity.Mono", "Runtimes\Unity\BepInEx.Unity.Mono\BepInEx.Unity.Mono.csproj", "{EAE9FAE6-8011-45A3-8B6E-0C7F14210533}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BepInEx.Unity.Mono.Preloader", "Runtimes\Unity\BepInEx.Unity.Mono.Preloader\BepInEx.Unity.Mono.Preloader.csproj", "{D404C973-441D-48ED-B266-C21320BA0D87}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BepInEx.Core", "BepInEx.Core\BepInEx.Core.csproj", "{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Mono", "Mono", "{6E2DD21E-0854-4F4A-B925-D90E0016D03D}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BepInEx.NET.Framework.Launcher", "Runtimes\NET\BepInEx.NET.Framework.Launcher\BepInEx.NET.Framework.Launcher.csproj", "{490B052B-7F23-4052-AD04-613856618901}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "NET", "NET", "{6EC98884-A3DC-4828-85EF-5F10F7519429}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BepInEx.Unity.IL2CPP", "Runtimes\Unity\BepInEx.Unity.IL2CPP\BepInEx.Unity.IL2CPP.csproj", "{429D5F83-7FEC-4D09-AB82-E868EB61AF59}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Markdown", "Markdown", "{68C57430-3E92-4B50-A9A5-208FE9CCD914}"
	ProjectSection(SolutionItems) = preProject
		README.md = README.md
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BepInEx.NET.Common", "Runtimes\NET\BepInEx.NET.Common\BepInEx.NET.Common.csproj", "{76EB1952-7826-471C-9CF3-815D094DA077}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BepInEx.NET.CoreCLR", "Runtimes\NET\BepInEx.NET.CoreCLR\BepInEx.NET.CoreCLR.csproj", "{08083F40-98AA-4176-BA01-817C18C35C7F}"
EndProject
Project("{D954291E-2A0B-460D-934E-DC6B0785DB48}") = "BepInEx.NET.Shared", "Runtimes\NET\BepInEx.NET.Shared\BepInEx.NET.Shared.shproj", "{067BCC8C-FC25-4929-B4F4-C6A5A7496994}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Shared", "Shared", "{12081C35-76DF-450C-AC83-1E1CB84516AA}"
	ProjectSection(SolutionItems) = preProject
		Directory.Build.props = Directory.Build.props
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Unity", "Unity", "{BF8F4E07-3B89-4152-89F4-9EF9D4AAA1E0}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BepInEx.Unity.Common", "Runtimes\Unity\BepInEx.Unity.Common\BepInEx.Unity.Common.csproj", "{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "IL2CPP", "IL2CPP", "{E4E75C18-4156-4213-A20C-8677EF6B5312}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Doorstop", "Doorstop", "{CE06453E-44E7-4D50-9A68-AA15F4C1C8D1}"
	ProjectSection(SolutionItems) = preProject
		Runtimes\Unity\Doorstop\doorstop_config_il2cpp.ini = Runtimes\Unity\Doorstop\doorstop_config_il2cpp.ini
		Runtimes\Unity\Doorstop\doorstop_config_mono.ini = Runtimes\Unity\Doorstop\doorstop_config_mono.ini
		Runtimes\Unity\Doorstop\run_bepinex_il2cpp.sh = Runtimes\Unity\Doorstop\run_bepinex_il2cpp.sh
		Runtimes\Unity\Doorstop\run_bepinex_mono.sh = Runtimes\Unity\Doorstop\run_bepinex_mono.sh
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Build", "build\Build.csproj", "{0C38DDF2-EAAA-43FA-BA0A-985636AC6040}"
EndProject
Global
	GlobalSection(SharedMSBuildProjectFiles) = preSolution
		BepInEx.NetLauncher.Shared\BepInEx.NetLauncher.Shared.projitems*{067bcc8c-fc25-4929-b4f4-c6a5a7496994}*SharedItemsImports = 13
		BepInEx.NetLauncher.Shared\BepInEx.NetLauncher.Shared.projitems*{08083f40-98aa-4176-ba01-817c18c35c7f}*SharedItemsImports = 5
		BepInEx.Shared\BepInEx.Shared.projitems*{08083f40-98aa-4176-ba01-817c18c35c7f}*SharedItemsImports = 5
		BepInEx.Shared\BepInEx.Shared.projitems*{15f8bc38-a761-4f93-8903-1b531ac5d9f9}*SharedItemsImports = 5
		BepInEx.Shared\BepInEx.Shared.projitems*{429d5f83-7fec-4d09-ab82-e868eb61af59}*SharedItemsImports = 5
		BepInEx.NetLauncher.Shared\BepInEx.NetLauncher.Shared.projitems*{490b052b-7f23-4052-ad04-613856618901}*SharedItemsImports = 5
		BepInEx.Shared\BepInEx.Shared.projitems*{490b052b-7f23-4052-ad04-613856618901}*SharedItemsImports = 5
		BepInEx.Shared\BepInEx.Shared.projitems*{4ffba620-f5ed-47f9-b90c-dad1316fd9b9}*SharedItemsImports = 5
		BepInEx.Shared\BepInEx.Shared.projitems*{5c7847fb-c16d-47bd-bb17-1045669f9aa7}*SharedItemsImports = 13
		BepInEx.Shared\BepInEx.Shared.projitems*{d404c973-441d-48ed-b266-c21320ba0d87}*SharedItemsImports = 5
		BepInEx.Shared\BepInEx.Shared.projitems*{eae9fae6-8011-45a3-8b6e-0c7f14210533}*SharedItemsImports = 5
	EndGlobalSection
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release_NetFramework|Any CPU = Release_NetFramework|Any CPU
		Release_Unity|Any CPU = Release_Unity|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{15F8BC38-A761-4F93-8903-1B531AC5D9F9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{15F8BC38-A761-4F93-8903-1B531AC5D9F9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{15F8BC38-A761-4F93-8903-1B531AC5D9F9}.Release_NetFramework|Any CPU.ActiveCfg = Release|Any CPU
		{15F8BC38-A761-4F93-8903-1B531AC5D9F9}.Release_NetFramework|Any CPU.Build.0 = Release|Any CPU
		{15F8BC38-A761-4F93-8903-1B531AC5D9F9}.Release_Unity|Any CPU.ActiveCfg = Release|Any CPU
		{15F8BC38-A761-4F93-8903-1B531AC5D9F9}.Release_Unity|Any CPU.Build.0 = Release|Any CPU
		{15F8BC38-A761-4F93-8903-1B531AC5D9F9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{15F8BC38-A761-4F93-8903-1B531AC5D9F9}.Release|Any CPU.Build.0 = Release|Any CPU
		{EAE9FAE6-8011-45A3-8B6E-0C7F14210533}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EAE9FAE6-8011-45A3-8B6E-0C7F14210533}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EAE9FAE6-8011-45A3-8B6E-0C7F14210533}.Release_NetFramework|Any CPU.ActiveCfg = Release|Any CPU
		{EAE9FAE6-8011-45A3-8B6E-0C7F14210533}.Release_Unity|Any CPU.ActiveCfg = Release|Any CPU
		{EAE9FAE6-8011-45A3-8B6E-0C7F14210533}.Release_Unity|Any CPU.Build.0 = Release|Any CPU
		{EAE9FAE6-8011-45A3-8B6E-0C7F14210533}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EAE9FAE6-8011-45A3-8B6E-0C7F14210533}.Release|Any CPU.Build.0 = Release|Any CPU
		{D404C973-441D-48ED-B266-C21320BA0D87}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D404C973-441D-48ED-B266-C21320BA0D87}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D404C973-441D-48ED-B266-C21320BA0D87}.Release_NetFramework|Any CPU.ActiveCfg = Release|Any CPU
		{D404C973-441D-48ED-B266-C21320BA0D87}.Release_Unity|Any CPU.ActiveCfg = Release|Any CPU
		{D404C973-441D-48ED-B266-C21320BA0D87}.Release_Unity|Any CPU.Build.0 = Release|Any CPU
		{D404C973-441D-48ED-B266-C21320BA0D87}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D404C973-441D-48ED-B266-C21320BA0D87}.Release|Any CPU.Build.0 = Release|Any CPU
		{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}.Release_NetFramework|Any CPU.ActiveCfg = Release|Any CPU
		{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}.Release_NetFramework|Any CPU.Build.0 = Release|Any CPU
		{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}.Release_Unity|Any CPU.ActiveCfg = Release|Any CPU
		{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}.Release_Unity|Any CPU.Build.0 = Release|Any CPU
		{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4FFBA620-F5ED-47F9-B90C-DAD1316FD9B9}.Release|Any CPU.Build.0 = Release|Any CPU
		{490B052B-7F23-4052-AD04-613856618901}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{490B052B-7F23-4052-AD04-613856618901}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{490B052B-7F23-4052-AD04-613856618901}.Release_NetFramework|Any CPU.ActiveCfg = Release|Any CPU
		{490B052B-7F23-4052-AD04-613856618901}.Release_NetFramework|Any CPU.Build.0 = Release|Any CPU
		{490B052B-7F23-4052-AD04-613856618901}.Release_Unity|Any CPU.ActiveCfg = Release|Any CPU
		{490B052B-7F23-4052-AD04-613856618901}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{490B052B-7F23-4052-AD04-613856618901}.Release|Any CPU.Build.0 = Release|Any CPU
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59}.Release_NetFramework|Any CPU.ActiveCfg = Release|Any CPU
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59}.Release_NetFramework|Any CPU.Build.0 = Release|Any CPU
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59}.Release_Unity|Any CPU.ActiveCfg = Release|Any CPU
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59}.Release_Unity|Any CPU.Build.0 = Release|Any CPU
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59}.Release|Any CPU.Build.0 = Release|Any CPU
		{76EB1952-7826-471C-9CF3-815D094DA077}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{76EB1952-7826-471C-9CF3-815D094DA077}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{76EB1952-7826-471C-9CF3-815D094DA077}.Release_NetFramework|Any CPU.ActiveCfg = Release|Any CPU
		{76EB1952-7826-471C-9CF3-815D094DA077}.Release_NetFramework|Any CPU.Build.0 = Release|Any CPU
		{76EB1952-7826-471C-9CF3-815D094DA077}.Release_Unity|Any CPU.ActiveCfg = Release|Any CPU
		{76EB1952-7826-471C-9CF3-815D094DA077}.Release_Unity|Any CPU.Build.0 = Release|Any CPU
		{76EB1952-7826-471C-9CF3-815D094DA077}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{76EB1952-7826-471C-9CF3-815D094DA077}.Release|Any CPU.Build.0 = Release|Any CPU
		{08083F40-98AA-4176-BA01-817C18C35C7F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{08083F40-98AA-4176-BA01-817C18C35C7F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{08083F40-98AA-4176-BA01-817C18C35C7F}.Release_NetFramework|Any CPU.ActiveCfg = Release|Any CPU
		{08083F40-98AA-4176-BA01-817C18C35C7F}.Release_NetFramework|Any CPU.Build.0 = Release|Any CPU
		{08083F40-98AA-4176-BA01-817C18C35C7F}.Release_Unity|Any CPU.ActiveCfg = Release|Any CPU
		{08083F40-98AA-4176-BA01-817C18C35C7F}.Release_Unity|Any CPU.Build.0 = Release|Any CPU
		{08083F40-98AA-4176-BA01-817C18C35C7F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{08083F40-98AA-4176-BA01-817C18C35C7F}.Release|Any CPU.Build.0 = Release|Any CPU
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}.Release_NetFramework|Any CPU.ActiveCfg = Debug|Any CPU
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}.Release_NetFramework|Any CPU.Build.0 = Debug|Any CPU
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}.Release_Unity|Any CPU.ActiveCfg = Debug|Any CPU
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}.Release_Unity|Any CPU.Build.0 = Debug|Any CPU
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9}.Release|Any CPU.Build.0 = Release|Any CPU
		{0C38DDF2-EAAA-43FA-BA0A-985636AC6040}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0C38DDF2-EAAA-43FA-BA0A-985636AC6040}.Release_NetFramework|Any CPU.ActiveCfg = Debug|Any CPU
		{0C38DDF2-EAAA-43FA-BA0A-985636AC6040}.Release_NetFramework|Any CPU.Build.0 = Debug|Any CPU
		{0C38DDF2-EAAA-43FA-BA0A-985636AC6040}.Release_Unity|Any CPU.ActiveCfg = Debug|Any CPU
		{0C38DDF2-EAAA-43FA-BA0A-985636AC6040}.Release_Unity|Any CPU.Build.0 = Debug|Any CPU
		{0C38DDF2-EAAA-43FA-BA0A-985636AC6040}.Release|Any CPU.ActiveCfg = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{EAE9FAE6-8011-45A3-8B6E-0C7F14210533} = {6E2DD21E-0854-4F4A-B925-D90E0016D03D}
		{D404C973-441D-48ED-B266-C21320BA0D87} = {6E2DD21E-0854-4F4A-B925-D90E0016D03D}
		{490B052B-7F23-4052-AD04-613856618901} = {6EC98884-A3DC-4828-85EF-5F10F7519429}
		{76EB1952-7826-471C-9CF3-815D094DA077} = {6EC98884-A3DC-4828-85EF-5F10F7519429}
		{08083F40-98AA-4176-BA01-817C18C35C7F} = {6EC98884-A3DC-4828-85EF-5F10F7519429}
		{067BCC8C-FC25-4929-B4F4-C6A5A7496994} = {6EC98884-A3DC-4828-85EF-5F10F7519429}
		{68C57430-3E92-4B50-A9A5-208FE9CCD914} = {12081C35-76DF-450C-AC83-1E1CB84516AA}
		{6E2DD21E-0854-4F4A-B925-D90E0016D03D} = {BF8F4E07-3B89-4152-89F4-9EF9D4AAA1E0}
		{C32E74A3-C0BD-42DE-9E2F-D033D496ACB9} = {BF8F4E07-3B89-4152-89F4-9EF9D4AAA1E0}
		{E4E75C18-4156-4213-A20C-8677EF6B5312} = {BF8F4E07-3B89-4152-89F4-9EF9D4AAA1E0}
		{429D5F83-7FEC-4D09-AB82-E868EB61AF59} = {E4E75C18-4156-4213-A20C-8677EF6B5312}
		{CE06453E-44E7-4D50-9A68-AA15F4C1C8D1} = {BF8F4E07-3B89-4152-89F4-9EF9D4AAA1E0}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {55AC11EF-F568-4C79-A356-7ED9510145B1}
	EndGlobalSection
EndGlobal

```

`Directory.Build.props`:

```props
<Project>
    <PropertyGroup>
        <VersionPrefix>6.0.0</VersionPrefix>
        <Authors>BepInEx</Authors>
        <LangVersion>latest</LangVersion>
        <Nullable>disable</Nullable>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <PackageLicenseExpression>LGPL-2.1-only</PackageLicenseExpression>
        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <DebugType>embedded</DebugType>
        <Configurations>Debug;Release</Configurations>
        <PackageProjectUrl>https://github.com/BepInEx/BepInEx</PackageProjectUrl>
        <RepositoryUrl>https://github.com/BepInEx/BepInEx</RepositoryUrl>
        <RepositoryType>git</RepositoryType>
        <Copyright>Copyright © 2022 BepInEx Team</Copyright>
        <BuildDir>$(SolutionDir)bin</BuildDir>
        <PackageOutputPath>$(BuildDir)/NuGet</PackageOutputPath>
        <PackageIcon>logo.png</PackageIcon>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    </PropertyGroup>
    <ItemGroup>
        <None Include="$(SolutionDir)\assets\logos\logo.png" Pack="true" Visible="false" PackagePath=""/>
    </ItemGroup>
</Project>

```

`LICENSE`:

```
                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS


                                NOTICE

BepInEx - Unity 
Copyright (C) 2020 BepInEx Team

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
USA


Exemptions / alternate licenses are available for negotiation.

```

`README.md`:

```md
<p align="center">
    <img src="https://avatars2.githubusercontent.com/u/39589027?s=256">
</p>

# BepInEx

![Github All Releases](https://img.shields.io/github/downloads/bepinex/bepinex/total.svg)
![GitHub release](https://img.shields.io/github/release/bepinex/bepinex.svg)
[![BepInEx Discord](https://user-images.githubusercontent.com/7288322/34429117-c74dbd12-ecb8-11e7-896d-46369cd0de5b.png)](https://discord.gg/MpFEDAg)

Bepis Injector Extensible

---

BepInEx is a plugin / modding framework for Unity Mono, IL2CPP and .NET framework games (XNA, FNA, MonoGame, etc.)

(Currently only Unity Mono has stable releases)

#### Platform compatibility chart

|              | Windows | OSX  | Linux | ARM |
|--------------|---------|------|-------|-----|
| Unity Mono   | ✔️      | ✔️  | ✔️    | N/A |
| Unity IL2CPP | ✔️      | ❌   | ✔     | ❌  |
| .NET / XNA   | ✔️      | Mono | Mono  | N/A |

A more comprehensive comparison list of features and compatibility is available at https://bepis.io/unity.html

## Resources

**[Latest releases](https://github.com/BepInEx/BepInEx/releases)**

**[Bleeding Edge builds](https://builds.bepinex.dev/projects/bepinex_be)**

**[How to install (latest releases)](https://docs.bepinex.dev/articles/user_guide/installation/index.html)**

**[How to install (Bleeding Edge, BepInEx 6)](https://docs.bepinex.dev/master/articles/user_guide/installation/index.html)**

**[User and developer guides](https://docs.bepinex.dev/master/)**

**[Discord server](https://discord.gg/MpFEDAg)**

### Available plugin loaders

| Name              | Link to project                                                                           |
|-------------------|-------------------------------------------------------------------------------------------|
| BSIPA             | [BepInEx.BSIPA.Loader](https://github.com/BepInEx/BepInEx.BSIPA.Loader)                   |
| IPA               | [IPALoaderX](https://github.com/BepInEx/IPALoaderX)                                       |
| MelonLoader       | [BepInEx.MelonLoader.Loader](https://github.com/BepInEx/BepInEx.MelonLoader.Loader)       |
| MonoMod           | [BepInEx.MonoMod.Loader](https://github.com/BepInEx/BepInEx.MonoMod.Loader)               |
| MuseDashModLoader | [BepInEx.MDML.Loader](https://github.com/BepInEx/BepInEx.MDML.Loader)                     |
| Partiality        | [BepInEx-Partiality-Wrapper](https://github.com/sinai-dev/BepInEx-Partiality-Wrapper)     |
| Sybaris           | [BepInEx.SybarisLoader.Patcher](https://github.com/BepInEx/BepInEx.SybarisLoader.Patcher) |
| UnityInjector     | [BepInEx.UnityInjector.Loader](https://github.com/BepInEx/BepInEx.UnityInjectorLoader)    |
| Unity Mod Manager | [Yan.UMMLoader](https://github.com/hacknet-bar/Yan.UMMLoader)                             |
| uMod              | [BepInEx.uMod.Loader](https://github.com/BepInEx/BepInEx.uMod.Loader)                     |

## Used libraries

- [NeighTools/UnityDoorstop](https://github.com/NeighTools/UnityDoorstop) - v4.0.0
- [BepInEx/HarmonyX](https://github.com/BepInEx/HarmonyX) - v2.10.1
- [0x0ade/MonoMod](https://github.com/0x0ade/MonoMod) - v22.5.1.1
- [jbevain/cecil](https://github.com/jbevain/cecil) - v0.10.4

#### IL2CPP libraries

- [SamboyCoding/Cpp2IL](https://github.com/SamboyCoding/Cpp2IL) - v2022.0.7.2
- [BepInEx/Il2CppInterop](https://github.com/BepInEx/Il2CppInterop) - v1.4.1
- [BepInEx/dotnet-runtime](https://github.com/BepInEx/dotnet-runtime) - v6.0.7

## License

The BepInEx project is licensed under the LGPL-2.1 license.

```

`Runtimes/NET/BepInEx.NET.Common/BasePlugin.cs`:

```cs
using BepInEx.Configuration;
using BepInEx.Logging;
using HarmonyLib;

namespace BepInEx.NET.Common
{
    public abstract class BasePlugin
    {
        protected BasePlugin()
        {
            var metadata = MetadataHelper.GetMetadata(this);

            HarmonyInstance = new Harmony("BepInEx.Plugin." + metadata.GUID);

            Log = Logger.CreateLogSource(metadata.Name);

            Config = new ConfigFile(Utility.CombinePaths(Paths.ConfigPath, metadata.GUID + ".cfg"), false, metadata);
        }

        public ManualLogSource Log { get; }

        public ConfigFile Config { get; }

        public Harmony HarmonyInstance { get; set; }

        public abstract void Load();

        public virtual bool Unload() => false;
    }
}

```

`Runtimes/NET/BepInEx.NET.Common/BepInEx.NET.Common.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <Description>BepInEx common code for .NET-based games</Description>
        <TargetFrameworks>netstandard2.1;net40</TargetFrameworks>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="HarmonyX" Version="2.10.1"/>
        <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="All"/>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\..\BepInEx.Core\BepInEx.Core.csproj"/>
        <ProjectReference Include="..\..\..\BepInEx.Preloader.Core\BepInEx.Preloader.Core.csproj"/>
    </ItemGroup>

</Project>

```

`Runtimes/NET/BepInEx.NET.Common/NetChainloader.cs`:

```cs
using System;
using System.Reflection;
using BepInEx.Bootstrap;
using BepInEx.Preloader.Core.Logging;

namespace BepInEx.NET.Common
{
    public class NetChainloader : BaseChainloader<BasePlugin>
    {
        // TODO: Remove once proper instance handling exists
        public static NetChainloader Instance { get; set; }

        public override void Initialize(string gameExePath = null)
        {
            Instance = this;
            base.Initialize(gameExePath);
        }

        public override BasePlugin LoadPlugin(PluginInfo pluginInfo, Assembly pluginAssembly)
        {
            var type = pluginAssembly.GetType(pluginInfo.TypeName);

            var pluginInstance = (BasePlugin) Activator.CreateInstance(type);

            pluginInstance.Load();

            return pluginInstance;
        }

        protected override void InitializeLoggers()
        {
            base.InitializeLoggers();

            ChainloaderLogHelper.RewritePreloaderLogs();
        }
    }
}

```

`Runtimes/NET/BepInEx.NET.CoreCLR/BepInEx.NET.CoreCLR.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <Description>BepInEx support library for CoreCLR games</Description>
        <TargetFramework>netcoreapp3.1</TargetFramework>
        <OutputPath>$(BuildDir)/NET.CoreCLR</OutputPath>
        <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
        <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\BepInEx.NET.Common\BepInEx.NET.Common.csproj"/>
        <ProjectReference Include="..\..\..\BepInEx.Preloader.Core\BepInEx.Preloader.Core.csproj"/>
    </ItemGroup>

    <Import Project="..\BepInEx.NET.Shared\BepInEx.NET.Shared.projitems" Label="Shared"/>
</Project>

```

`Runtimes/NET/BepInEx.NET.CoreCLR/HookEntrypoint.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using BepInEx.Logging;
using BepInEx.NET.CoreCLR;
using BepInEx.NET.Shared;
using BepInEx.Preloader.Core;

internal class StartupHook
{
    public static List<string> ResolveDirectories = new();

    public static string DoesNotExistPath = "_doesnotexist_.exe";

    public static void Initialize()
    {
        var silentExceptionLog = $"bepinex_preloader_{DateTime.Now:yyyyMMdd_HHmmss_fff}.log";

        try
        {
//#if DEBUG
//          filename =
//              Path.Combine(Directory.GetCurrentDirectory(),
//                           Path.GetFileName(Process.GetCurrentProcess().MainModule.FileName));
//          ResolveDirectories.Add(Path.GetDirectoryName(filename));

//          // for debugging within VS
//          ResolveDirectories.Add(Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName));
//#else
            
            var executableFilename = Process.GetCurrentProcess().MainModule.FileName;
            
            var assemblyFilename = TryDetermineAssemblyNameFromDotnet(executableFilename)
                                ?? TryDetermineAssemblyNameFromStubExecutable(executableFilename)
                                ?? TryDetermineAssemblyNameFromCurrentAssembly(executableFilename);

            string gameDirectory = null;

            if (assemblyFilename != null)
                gameDirectory = Path.GetDirectoryName(assemblyFilename);

            string bepinexCoreDirectory = null;

            if (gameDirectory != null)
                bepinexCoreDirectory = Path.Combine(gameDirectory, "BepInEx", "core");

            if (assemblyFilename == null || gameDirectory == null || !Directory.Exists(bepinexCoreDirectory))
            {
                throw new Exception("Could not determine game location, or BepInEx install location");
            }
            
            silentExceptionLog = Path.Combine(gameDirectory, silentExceptionLog);
            
            ResolveDirectories.Add(bepinexCoreDirectory);
//#endif

            AppDomain.CurrentDomain.AssemblyResolve += SharedEntrypoint.RemoteResolve(ResolveDirectories);

            NetCorePreloaderRunner.OuterMain(assemblyFilename);
        }
        catch (Exception ex)
        {
            string executableLocation = null;
            string arguments = null;

            try
            {
                executableLocation = Process.GetCurrentProcess().MainModule?.FileName;
                arguments = string.Join(' ', Environment.GetCommandLineArgs());
            }
            catch { }

            string exceptionString = $"Unhandled fatal exception\r\n" +
                                     $"Executable location: {executableLocation ?? "<null>"}\r\n" +
                                     $"Arguments: {arguments ?? "<null>"}\r\n" +
                                     $"{ex}";

            File.WriteAllText(silentExceptionLog, exceptionString);

            Console.WriteLine("Unhandled exception");
            Console.WriteLine($"Executable location: {executableLocation ?? "<null>"}");
            Console.WriteLine($"Arguments: {arguments ?? "<null>"}");
            Console.WriteLine(ex);
        }
    }

    private static string TryDetermineAssemblyNameFromDotnet(string executableFilename)
    {
        if (Path.GetFileNameWithoutExtension(executableFilename) == "dotnet")
        {
            // We're in a special setup that uses dotnet directly to start a .dll, instead of a .exe that launches dotnet implicitly

            var args = Environment.GetCommandLineArgs();

            foreach (var arg in args)
            {
                if (!arg.EndsWith(".dll", StringComparison.OrdinalIgnoreCase)
                 && !arg.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                if (File.Exists(arg))
                {
                    return Path.GetFullPath(arg);
                }
            }
        }

        return null;
    }

    private static string TryDetermineAssemblyNameFromStubExecutable(string executableFilename)
    {
        string dllFilename = Path.ChangeExtension(executableFilename, ".dll");

        if (File.Exists(dllFilename))
            return dllFilename;

        return null;
    }

    private static string TryDetermineAssemblyNameFromCurrentAssembly(string executableFilename)
    {
        string assemblyLocation = typeof(StartupHook).Assembly.Location.Replace('/', Path.DirectorySeparatorChar);

        string coreFolderPath = Path.GetDirectoryName(assemblyLocation);

        if (coreFolderPath == null)
            return null; // throw new Exception("Could not find a valid path to the BepInEx directory");

        string gameDirectory = Path.GetDirectoryName(Path.GetDirectoryName(coreFolderPath));

        if (gameDirectory == null)
            return null; // throw new Exception("Could not find a valid path to the game directory");

        return Path.Combine(gameDirectory, DoesNotExistPath);
    }
}

namespace BepInEx.NET.CoreCLR
{
    internal static class NetCorePreloaderRunner
    {
        internal static void PreloaderMain()
        {
            ConsoleManager.Initialize(false, true);

            ConsoleManager.CreateConsole();

            Logger.Listeners.Add(new ConsoleLogListener());

            try
            {
                NetCorePreloader.Start();
            }
            catch (Exception ex)
            {
                PreloaderLogger.Log.Log(LogLevel.Fatal, "Unhandled exception");
                PreloaderLogger.Log.Log(LogLevel.Fatal, ex);
            }
        }

        internal static void OuterMain(string filename)
        {
            PlatformUtils.SetPlatform();

            Paths.SetExecutablePath(filename);

            AppDomain.CurrentDomain.AssemblyResolve += SharedEntrypoint.LocalResolve;

            PreloaderMain();
        }
    }
}

```

`Runtimes/NET/BepInEx.NET.CoreCLR/NetCorePreloader.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using BepInEx.Bootstrap;
using BepInEx.Logging;
using BepInEx.NET.Common;
using BepInEx.Preloader.Core;
using BepInEx.Preloader.Core.Logging;
using BepInEx.Preloader.Core.Patching;
using Mono.Cecil;

namespace BepInEx.NET.CoreCLR
{
    internal class NetCorePreloader
    {
        private static readonly ManualLogSource Log = PreloaderLogger.Log;

        public static void Start()
        {
            var preloaderListener = new PreloaderConsoleListener();
            Logger.Listeners.Add(preloaderListener);

            string entrypointAssemblyPath = !Paths.ExecutablePath.EndsWith(StartupHook.DoesNotExistPath) ? Paths.ExecutablePath : null;

            TypeLoader.SearchDirectories.Add(Paths.GameRootPath);
            
            Logger.Sources.Add(TraceLogSource.CreateSource());

            ChainloaderLogHelper.PrintLogInfo(Log);

            Log.LogInfo($"CLR runtime version: {Environment.Version}");

            Log.LogInfo($"Current executable: {Process.GetCurrentProcess().MainModule.FileName}");
            Log.LogInfo($"Entrypoint assembly: {entrypointAssemblyPath ?? "<does not exist>"}");
            Log.LogInfo($"Launch arguments: {string.Join(' ', Environment.GetCommandLineArgs())}");


            AssemblyBuildInfo executableInfo;

            if (entrypointAssemblyPath != null)
            {
                using (var entrypointAssembly = AssemblyDefinition.ReadAssembly(entrypointAssemblyPath))
                    executableInfo = AssemblyBuildInfo.DetermineInfo(entrypointAssembly);

                Log.LogInfo($"Game executable build architecture: {executableInfo}");
            }
            else
            {
                Log.LogWarning("Game assembly is unknown, can't determine build architecture");
            }

            Log.LogMessage("Preloader started");

            using (var assemblyPatcher = new AssemblyPatcher((data, _) => Assembly.Load(data)))
            {
                assemblyPatcher.AddPatchersFromDirectory(Paths.PatcherPluginPath);

                Log.LogInfo($"{assemblyPatcher.PatcherContext.PatchDefinitions.Count} patcher definition(s) loaded");

                assemblyPatcher.LoadAssemblyDirectories(new[] { Paths.GameRootPath }, new[] { "dll", "exe" });

                Log.LogInfo($"{assemblyPatcher.PatcherContext.AvailableAssemblies.Count} assemblies discovered");

                assemblyPatcher.PatchAndLoad();
            }

            Log.LogMessage("Preloader finished");

            Logger.Listeners.Remove(preloaderListener);

            var chainloader = new NetChainloader();
            chainloader.Initialize();
            chainloader.Execute();
        }
    }
}

```

`Runtimes/NET/BepInEx.NET.Framework.Launcher/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup>
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2"/>
    </startup>
</configuration>

```

`Runtimes/NET/BepInEx.NET.Framework.Launcher/BepInEx.NET.Framework.Launcher.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <Description>BepInEx support library for .NET Framework games</Description>
        <OutputType>Exe</OutputType>
        <TargetFramework>net452</TargetFramework>
        <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
        <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
        <PlatformTarget>x86</PlatformTarget>
        <OutputPath>$(BuildDir)/NET.Framework</OutputPath>
    </PropertyGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\..\BepInEx.Core\BepInEx.Core.csproj"/>
        <ProjectReference Include="..\BepInEx.NET.Common\BepInEx.NET.Common.csproj"/>
        <ProjectReference Include="..\..\..\BepInEx.Preloader.Core\BepInEx.Preloader.Core.csproj" PrivateAssets="All"/>
    </ItemGroup>
    <ItemGroup>
        <PackageReference Include="HarmonyX" Version="2.10.1"/>
        <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="All"/>
    </ItemGroup>
    <Import Project="..\BepInEx.NET.Shared\BepInEx.NET.Shared.projitems" Label="Shared"/>
</Project>

```

`Runtimes/NET/BepInEx.NET.Framework.Launcher/NetPreloader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using BepInEx.Bootstrap;
using BepInEx.Configuration;
using BepInEx.Logging;
using BepInEx.NET.Common;
using BepInEx.NET.Framework.Launcher.RuntimeFixes;
using BepInEx.Preloader.Core;
using BepInEx.Preloader.Core.Logging;
using BepInEx.Preloader.Core.Patching;
using HarmonyLib;
using Mono.Cecil;
using MonoMod.Utils;

namespace BepInEx.NET.Framework.Launcher;

public static class NetPreloader
{
    private static readonly ManualLogSource Log = PreloaderLogger.Log;

    #region Config

    private static readonly ConfigEntry<string> ConfigEntrypointExecutable = ConfigFile.CoreConfig.Bind<string>(
     "Preloader.Entrypoint", "Assembly",
     null,
     "The local filename of the .NET executable to target.");

    #endregion

    [DllImport("Kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern bool SetDllDirectory(string lpPathName);

    [DllImport("Kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern bool AddDllDirectory(string lpPathName);


    public static void Start(string[] args)
    {
        var preloaderListener = new PreloaderConsoleListener();
        Logger.Listeners.Add(preloaderListener);

        if (string.IsNullOrEmpty(ConfigEntrypointExecutable.Value))
        {
            Log.Log(LogLevel.Fatal,
                    $"Entry executable was not set. Please set this in your config before launching the application");
            Program.ReadExit();
            return;
        }

        var executablePath = Path.GetFullPath(ConfigEntrypointExecutable.Value);

        if (!File.Exists(executablePath))
        {
            Log.Log(LogLevel.Fatal, $"Unable to locate executable: {ConfigEntrypointExecutable.Value}");
            Program.ReadExit();
            return;
        }


        Paths.SetExecutablePath(executablePath);
        Program.ResolveDirectories.Add(Paths.GameRootPath);

        foreach (var searchDir in Program.ResolveDirectories)
            TypeLoader.SearchDirectories.Add(searchDir);

        if (PlatformHelper.Is(Platform.Windows))
        {
            AddDllDirectory(Paths.GameRootPath);
            SetDllDirectory(Paths.GameRootPath);
        }


        Logger.Sources.Add(TraceLogSource.CreateSource());

        ChainloaderLogHelper.PrintLogInfo(Log);

        Log.Log(LogLevel.Info, $"CLR runtime version: {Environment.Version}");


        AssemblyBuildInfo executableInfo, launcherInfo;

        using (var executableAssembly = AssemblyDefinition.ReadAssembly(executablePath))
            executableInfo = AssemblyBuildInfo.DetermineInfo(executableAssembly);

        using (var launcherAssembly = AssemblyDefinition.ReadAssembly(typeof(NetPreloader).Assembly.Location))
            launcherInfo = AssemblyBuildInfo.DetermineInfo(launcherAssembly);

        // we don't particularly care about AnyCPU here since the fallback bitness is almost never the case
        if (executableInfo.Is64Bit != launcherInfo.Is64Bit)
        {
            Log.LogError($"Game executable is {(executableInfo.Is64Bit ? "64" : "32")}-bit while BepInEx has been compiled as {(launcherInfo.Is64Bit ? "64" : "32")}-bit. Expect crashes");
        }

        if (executableInfo.NetFrameworkVersion != launcherInfo.NetFrameworkVersion ||
            executableInfo.AssemblyFrameworkType != launcherInfo.AssemblyFrameworkType)
        {
            Log.LogWarning($"Game executable has been compiled as {executableInfo}, while BepInEx has been compiled as {launcherInfo}. There may be issues within the game caused by this");
        }

        Log.LogInfo($"Game executable build architecture: {executableInfo}");
        Log.LogInfo($"BepInEx launcher build architecture: {launcherInfo}");

        Log.Log(LogLevel.Message, "Preloader started");

        Assembly entrypointAssembly;

        using (var assemblyPatcher = new AssemblyPatcher((data, _) => Assembly.Load(data)))
        {
            assemblyPatcher.AddPatchersFromDirectory(Paths.PatcherPluginPath);

            Log.Log(LogLevel.Info,
                    $"{assemblyPatcher.PatcherContext.PatchDefinitions.Count} patcher definition(s) loaded");

            assemblyPatcher.LoadAssemblyDirectories(new[] { Paths.GameRootPath }, new[] { "dll", "exe" });

            Log.Log(LogLevel.Info, $"{assemblyPatcher.PatcherContext.AvailableAssemblies.Count} assemblies discovered");

            assemblyPatcher.PatchAndLoad();


            var assemblyName = AssemblyName.GetAssemblyName(executablePath);

            entrypointAssembly =
                assemblyPatcher.PatcherContext.LoadedAssemblies.Values.FirstOrDefault(x => x.FullName ==
                    assemblyName.FullName);

            foreach (var loadedAssembly in assemblyPatcher.PatcherContext.LoadedAssemblies)
            {
                // TODO: Need full paths for loaded assemblies
                var assemblyPath = Path.Combine(Paths.GameRootPath, loadedAssembly.Key);

                Log.LogDebug($"Registering '{assemblyPath}' as a loaded assembly");
                AssemblyFixes.AssemblyLocations[loadedAssembly.Value.FullName] = assemblyPath;
            }

            if (entrypointAssembly != null)
            {
                Log.LogDebug("Found patched entrypoint assembly! Using it");
            }
            else
            {
                Log.LogDebug("Using entrypoint assembly from disk");
                entrypointAssembly = Assembly.LoadFrom(executablePath);
            }
        }

        Log.LogMessage("Preloader finished");

        Logger.Listeners.Remove(preloaderListener);

        var chainloader = new NetChainloader();
        chainloader.Initialize();
        chainloader.Execute();


        AssemblyFixes.Execute(entrypointAssembly);

        try
        {
            var argList = new List<object>();

            var paramTypes = entrypointAssembly.EntryPoint.GetParameters();

            if (paramTypes.Length == 1 && paramTypes[0].ParameterType == typeof(string[]))
            {
                argList.Add(args);
            }
            else if (paramTypes.Length == 1 && paramTypes[0].ParameterType == typeof(string))
            {
                argList.Add(string.Join(" ", args));
            }
            else if (paramTypes.Length != 0)
            {
                // Only other entrypoint signatures I can think of that .NET supports is Task / Task<int>
                //   async entrypoints. That's a can of worms for another time though

                Log.LogFatal($"Could not figure out how to handle entrypoint method with this signature: {entrypointAssembly.EntryPoint.FullDescription()}");
                return;
            }

            entrypointAssembly.EntryPoint.Invoke(null, argList.ToArray());
        }
        catch (Exception ex)
        {
            Log.LogFatal($"Unhandled exception: {ex}");
        }
    }
}

```

`Runtimes/NET/BepInEx.NET.Framework.Launcher/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using BepInEx.Logging;
using BepInEx.NET.Shared;
using BepInEx.Preloader.Core;

namespace BepInEx.NET.Framework.Launcher;

internal class Program
{
    public static List<string> ResolveDirectories { get; set; } = new()
    {
        "C:\\Windows\\Microsoft.NET\\assembly\\GAC_32\\Microsoft.Xna.Framework.Game\\v4.0_4.0.0.0__842cf8be1de50553\\"
    };

    internal static void ReadExit()
    {
        Console.WriteLine("Press enter to exit...");
        Console.ReadLine();
        Environment.Exit(-1);
    }

    private static void Main(string[] args)
    {
        var silentExceptionLog = $"preloader_{DateTime.Now:yyyyMMdd_HHmmss_fff}.log";

        try
        {
            string filename;

#if DEBUG
            filename =
                Path.Combine(Directory.GetCurrentDirectory(),
                             Path.GetFileName(Process.GetCurrentProcess().MainModule.FileName));
            ResolveDirectories.Add(Path.GetDirectoryName(filename));

            // for debugging within VS
            ResolveDirectories.Add(Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName));
#else
            filename = Process.GetCurrentProcess().MainModule.FileName;
            ResolveDirectories.Add(Path.Combine(Path.GetDirectoryName(filename), "BepInEx", "core"));
#endif

            AppDomain.CurrentDomain.AssemblyResolve += SharedEntrypoint.RemoteResolve(ResolveDirectories);

            NetPreloaderRunner.OuterMain(args, filename);
        }
        catch (Exception ex)
        {
            File.WriteAllText(silentExceptionLog, ex.ToString());

            Console.WriteLine("Unhandled exception");
            Console.WriteLine(ex);
            ReadExit();
        }
    }
}

internal static class NetPreloaderRunner
{
    internal static void PreloaderMain(string[] args)
    {
        Logger.Listeners.Add(new ConsoleLogListener());

        ConsoleManager.Initialize(true, true);

        try
        {
            NetPreloader.Start(args);
        }
        catch (Exception ex)
        {
            PreloaderLogger.Log.Log(LogLevel.Fatal, "Unhandled exception");
            PreloaderLogger.Log.Log(LogLevel.Fatal, ex);
            Program.ReadExit();
        }
    }

    internal static void OuterMain(string[] args, string filename)
    {
        PlatformUtils.SetPlatform();

        Paths.SetExecutablePath(filename);

        AppDomain.CurrentDomain.AssemblyResolve += SharedEntrypoint.LocalResolve;

        PreloaderMain(args);
    }
}

```

`Runtimes/NET/BepInEx.NET.Framework.Launcher/RuntimeFixes/AssemblyFixes.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using BepInEx.Logging;
using HarmonyLib;

namespace BepInEx.NET.Framework.Launcher.RuntimeFixes;

internal class AssemblyFixes
{
    private static Assembly EntryAssembly { get; set; }

    public static Dictionary<string, string> AssemblyLocations { get; } =
        new(StringComparer.InvariantCultureIgnoreCase);

    public static void Execute(Assembly entryAssembly)
    {
        EntryAssembly = entryAssembly;
        Harmony.CreateAndPatchAll(typeof(AssemblyFixes), "io.bepinex.assemblyfix");
    }

    [HarmonyPrefix]
    [HarmonyPatch(typeof(Assembly), nameof(Assembly.GetEntryAssembly))]
    public static bool GetEntryAssemblyPrefix(ref Assembly __result)
    {
        Logger.Log(LogLevel.Debug, "Ran GetEntryAssembly");

        __result = EntryAssembly;
        return false;
    }

    [HarmonyPrefix]
    [HarmonyPatch(typeof(Assembly), nameof(Assembly.Load), typeof(string))]
    public static bool LoadByName(ref Assembly __result, string assemblyString)
    {
        __result = AppDomain.CurrentDomain.GetAssemblies()
                            .FirstOrDefault(x => x.GetName().FullName == assemblyString);


        Logger.Log(LogLevel.Debug, $"LoadByName: {assemblyString} : {__result != null}");

        return __result != null;
    }

    [HarmonyPrefix]
    [HarmonyPatch("System.Reflection.RuntimeAssembly", nameof(Assembly.Location), MethodType.Getter)]
    public static bool GetLocation(ref string __result, Assembly __instance)
    {
        Logger.Log(LogLevel.Debug, $"GetLocation: {__instance.FullName}");

        if (AssemblyLocations.TryGetValue(__instance.FullName, out var location))
        {
            __result = location;
            return false;
        }

        return true;
    }

    // This is commented out because it should be implemented alongside GetLocation, but seems to crash the runtime
    // Might be because the target type should be System.Reflection.RuntimeAssembly

    //[HarmonyPrefix]
    //[HarmonyPatch(typeof(Assembly), nameof(Assembly.CodeBase), MethodType.Getter)]
    //public static bool GetCodeBase(ref string __result, Assembly __instance)
    //{
    //    if (AssemblyLocations.TryGetValue(__instance.FullName, out var location))
    //    {
    //        __result = $"file://{location.Replace('\\', '/')}";
    //        return false;
    //    }

    //    return true;
    //}
}

```

`Runtimes/NET/BepInEx.NET.Shared/BepInEx.NET.Shared.projitems`:

```projitems
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <SharedGUID>067bcc8c-fc25-4929-b4f4-c6a5a7496994</SharedGUID>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <Import_RootNamespace>BepInEx.NetLauncher.Shared</Import_RootNamespace>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="$(MSBuildThisFileDirectory)SharedEntrypoint.cs" />
  </ItemGroup>
</Project>
```

`Runtimes/NET/BepInEx.NET.Shared/BepInEx.NET.Shared.shproj`:

```shproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Label="Globals">
        <ProjectGuid>067bcc8c-fc25-4929-b4f4-c6a5a7496994</ProjectGuid>
        <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>
    </PropertyGroup>
    <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')"/>
    <Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeSharing\Microsoft.CodeSharing.Common.Default.props"/>
    <Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeSharing\Microsoft.CodeSharing.Common.props"/>
    <PropertyGroup/>
    <Import Project="BepInEx.NetLauncher.Shared.projitems" Label="Shared"/>
    <Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeSharing\Microsoft.CodeSharing.CSharp.targets"/>
</Project>

```

`Runtimes/NET/BepInEx.NET.Shared/SharedEntrypoint.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

// This code is shared between the .NET Framework launcher and the .NET Core entrypoint projects.
// However, it cannot be placed in the NetLauncher.Common project because this has to do with assembly resolution,
//   and placing this logic inside of an external assembly will cause a crash.
// A shared project is the only way to deduplicate code here

namespace BepInEx.NET.Shared
{
    internal static class SharedEntrypoint
    {
        public static ResolveEventHandler RemoteResolve(List<string> resolveDirectories)
        {
            return (sender, args) => RemoteResolveInternal(sender, args, resolveDirectories);
        }

        private static Assembly RemoteResolveInternal(object sender,
                                                      ResolveEventArgs reference,
                                                      List<string> resolveDirectories)
        {
            var assemblyName = new AssemblyName(reference.Name);

            foreach (var directory in resolveDirectories)
            {
                if (!Directory.Exists(directory))
                    continue;

                var potentialDirectories = new List<string> { directory };

                potentialDirectories.AddRange(Directory.GetDirectories(directory, "*", SearchOption.AllDirectories));

                var potentialFiles = potentialDirectories.Select(x => Path.Combine(x, $"{assemblyName.Name}.dll"))
                                                         .Concat(potentialDirectories.Select(x =>
                                                                     Path
                                                                         .Combine(x,
                                                                             $"{assemblyName.Name}.exe")));

                foreach (var path in potentialFiles)
                {
                    if (!File.Exists(path))
                        continue;

                    Assembly assembly;

                    try
                    {
                        assembly = Assembly.LoadFrom(path);
                    }
                    catch (Exception ex)
                    {
                        continue;
                    }

                    if (assembly.GetName().Name == assemblyName.Name)
                        return assembly;
                }
            }

            return null;
        }

        public static Assembly LocalResolve(object sender, ResolveEventArgs args)
        {
            var assemblyName = new AssemblyName(args.Name);

            var foundAssembly = AppDomain.CurrentDomain.GetAssemblies()
                                         .FirstOrDefault(x => x.GetName().Name == assemblyName.Name);

            if (foundAssembly != null)
                return foundAssembly;

            if (LocalUtility.TryResolveDllAssembly(assemblyName, Paths.BepInExAssemblyDirectory, out foundAssembly)
             || LocalUtility.TryResolveDllAssembly(assemblyName, Paths.PatcherPluginPath, out foundAssembly)
             || LocalUtility.TryResolveDllAssembly(assemblyName, Paths.PluginPath, out foundAssembly))
                return foundAssembly;

            return null;
        }
    }


    /// <summary>
    ///     Generic helper properties and methods.
    /// </summary>
    internal static class LocalUtility
    {
        /// <summary>
        ///     Try to resolve and load the given assembly DLL.
        /// </summary>
        /// <param name="assemblyName">Name of the assembly, of the type <see cref="AssemblyName" />.</param>
        /// <param name="directory">Directory to search the assembly from.</param>
        /// <param name="assembly">The loaded assembly.</param>
        /// <returns>True, if the assembly was found and loaded. Otherwise, false.</returns>
        private static bool TryResolveDllAssembly<T>(AssemblyName assemblyName,
                                                     string directory,
                                                     Func<string, T> loader,
                                                     out T assembly) where T : class
        {
            assembly = null;

            if (!Directory.Exists(directory))
                return false;

            var potentialDirectories = new List<string> { directory };

            potentialDirectories.AddRange(Directory.GetDirectories(directory, "*", SearchOption.AllDirectories));

            foreach (var subDirectory in potentialDirectories)
            {
                var path = Path.Combine(subDirectory, $"{assemblyName.Name}.dll");

                if (!File.Exists(path))
                    continue;

                try
                {
                    assembly = loader(path);
                }
                catch (Exception)
                {
                    continue;
                }

                return true;
            }

            return false;
        }

        /// <summary>
        ///     Try to resolve and load the given assembly DLL.
        /// </summary>
        /// <param name="assemblyName">Name of the assembly, of the type <see cref="AssemblyName" />.</param>
        /// <param name="directory">Directory to search the assembly from.</param>
        /// <param name="assembly">The loaded assembly.</param>
        /// <returns>True, if the assembly was found and loaded. Otherwise, false.</returns>
        public static bool TryResolveDllAssembly(AssemblyName assemblyName, string directory, out Assembly assembly) =>
            TryResolveDllAssembly(assemblyName, directory, Assembly.LoadFrom, out assembly);
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Common/BepInEx.Unity.Common.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <Description>BepInEx common code for Unity games</Description>
        <TargetFrameworks>net35;netstandard2.0</TargetFrameworks>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="AssetRipper.VersionUtilities" Version="1.2.1"/>
        <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="all"/>
        <PackageReference Include="MonoMod.Utils" Version="22.5.1.1"/>
    </ItemGroup>

</Project>

```

`Runtimes/Unity/BepInEx.Unity.Common/UnityInfo.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using AssetRipper.VersionUtilities;
using MonoMod.Utils;

[assembly: InternalsVisibleTo("BepInEx.Unity.Mono.Preloader")]
[assembly: InternalsVisibleTo("BepInEx.Unity.Mono")]
[assembly: InternalsVisibleTo("BepInEx.Unity.IL2CPP")]

namespace BepInEx.Unity.Common;

/// <summary>
///     Various information about the currently executing Unity player.
/// </summary>
public static class UnityInfo
{
    // Adapted from https://github.com/SamboyCoding/Cpp2IL/blob/development/LibCpp2IL/LibCpp2IlMain.cs
    private static readonly ManagerLookup[] ManagerVersionLookup =
    {
        new("globalgamemanagers", 0x14, 0x30),
        new("data.unity3d", 0x12),
        new("mainData", 0x14)
    };

    private static bool initialized;

    /// <summary>
    ///     Path to the player executable.
    /// </summary>
    public static string PlayerPath { get; private set; }

    /// <summary>
    ///     Path to the game data directory (directory that contains the game assets).
    /// </summary>
    public static string GameDataPath { get; private set; }

    /// <summary>
    ///     Version of the Unity player
    /// </summary>
    /// <remarks>
    ///     Because BepInEx can execute very early, the exact Unity version might not be available in early
    ///     bootstrapping phases. The version should be treated as an estimation of the actual version of the Unity player.
    /// </remarks>
    public static UnityVersion Version { get; private set; }

    internal static void Initialize(string unityPlayerPath, string gameDataPath)
    {
        if (initialized)
            return;
        PlayerPath = Path.GetFullPath(unityPlayerPath ?? throw new ArgumentNullException(nameof(unityPlayerPath)));
        GameDataPath = Path.GetFullPath(gameDataPath ?? throw new ArgumentNullException(nameof(gameDataPath)));

        DetermineVersion();
        initialized = true;
    }

    internal static void SetRuntimeUnityVersion(string version) => Version = UnityVersion.Parse(version);

    private static void DetermineVersion()
    {
        // Try looking up first since it's more reliable
        foreach (var lookup in ManagerVersionLookup)
            if (lookup.TryLookup(out var version))
            {
                Version = version;
                return;
            }

        // On Windows, we can try to parse executable name, but some games can mess up the file version as well 
        if (PlatformHelper.Is(Platform.Windows))
            try
            {
                var version = FileVersionInfo.GetVersionInfo(PlayerPath);
                // Parse manually because some games can also wipe the file version (so it's an empty string)
                var simpleVersion = new Version(version.FileVersion);
                Version = new UnityVersion((ushort) simpleVersion.Major, (ushort) simpleVersion.Minor,
                                           (ushort) simpleVersion.Build);
                return;
            }
            catch (Exception)
            {
                // Some games have version stripped or intentionally wrong
                // In that case pass through
            }

        // We can't determine the version fully, so we'll try to guess
        // On UnityMono, UnityEngine.CoreModule.dll is present for post-2017
        // We'll also mark it as "experimental" so that we can detect this via logs
        var managed = Path.Combine(GameDataPath, "Managed");
        if (File.Exists(Path.Combine(managed, "UnityEngine.CoreModule.dll")))
            Version = new UnityVersion(2017, 0, 0, UnityVersionType.Experimental);

        Version = default;
    }

    private class ManagerLookup
    {
        private readonly string filePath;
        private readonly int[] lookupOffsets;

        public ManagerLookup(string filePath, params int[] lookupOffsets)
        {
            this.filePath = filePath;
            this.lookupOffsets = lookupOffsets;
        }

        public bool TryLookup(out UnityVersion version)
        {
            var path = Path.Combine(GameDataPath, filePath);
            if (!File.Exists(path))
            {
                version = default;
                return false;
            }

            using var fs = File.OpenRead(path);
            foreach (var offset in lookupOffsets)
            {
                var sb = new StringBuilder();
                fs.Position = offset;

                byte b;
                while ((b = (byte) fs.ReadByte()) != 0)
                    sb.Append((char) b);

                try
                {
                    version = UnityVersion.Parse(sb.ToString());
                    return true;
                }
                catch (Exception e)
                {
                    // Ignore
                }
            }

            version = default;
            return false;
        }
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/BasePlugin.cs`:

```cs
using BepInEx.Configuration;
using BepInEx.Logging;
using Il2CppInterop.Runtime.InteropTypes;

namespace BepInEx.Unity.IL2CPP;

public abstract class BasePlugin
{
    protected BasePlugin()
    {
        var metadata = MetadataHelper.GetMetadata(this);

        Log = Logger.CreateLogSource(metadata.Name);

        Config = new ConfigFile(Utility.CombinePaths(Paths.ConfigPath, metadata.GUID + ".cfg"), false, metadata);
    }

    public ManualLogSource Log { get; }

    public ConfigFile Config { get; }

    public abstract void Load();

    public virtual bool Unload() => false;

    /// <summary>
    ///     Add a Component (e.g. MonoBehaviour) into Unity scene.
    ///     Automatically registers the type with Il2Cpp Type system if it isn't already.
    /// </summary>
    /// <typeparam name="T">Type of the component to add.</typeparam>
    public T AddComponent<T>() where T : Il2CppObjectBase => IL2CPPChainloader.AddUnityComponent<T>();
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/BepInEx.Unity.IL2CPP.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <Description>BepInEx support library for Il2Cpp games</Description>
        <TargetFramework>net6.0</TargetFramework>
        <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <OutputPath>$(BuildDir)/Unity.IL2CPP</OutputPath>
        <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
    </PropertyGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\..\BepInEx.Core\BepInEx.Core.csproj"/>
        <ProjectReference Include="..\..\..\BepInEx.Preloader.Core\BepInEx.Preloader.Core.csproj" PrivateAssets="All"/>
        <ProjectReference Include="..\BepInEx.Unity.Common\BepInEx.Unity.Common.csproj"/>
    </ItemGroup>
    <ItemGroup>
        <PackageReference Include="HarmonyX" Version="2.10.1"/>
        <PackageReference Include="Iced" Version="1.17.0"/>
        <PackageReference Include="Il2CppInterop.Generator" Version="1.4.1"/>
        <PackageReference Include="Il2CppInterop.HarmonySupport" Version="1.4.1"/>
        <PackageReference Include="Il2CppInterop.ReferenceLibs" Version="1.0.0" IncludeAssets="compile" PrivateAssets="all"/>
        <PackageReference Include="Il2CppInterop.Runtime" Version="1.4.1"/>
        <PackageReference Include="Microsoft.Extensions.Logging" Version="6.0.0" IncludeAssets="compile" PrivateAssets="all"/>
        <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.1" IncludeAssets="compile" PrivateAssets="all"/>
        <PackageReference Include="MonoMod.RuntimeDetour" Version="22.5.1.1"/>
        <PackageReference Include="Samboy063.Cpp2IL.Core" Version="2022.0.7.2"/>
    </ItemGroup>

    <!-- CopyLocalLockFileAssemblies causes to also output shared assemblies: https://github.com/NuGet/Home/issues/4837#issuecomment-354536302 -->
    <!-- Since all core assemblies usually follow naming of System.*, we just delete them for now -->
    <!-- Also delete deps.json as they are not used by embedded CLR -->
    <Target Name="DeleteSys" AfterTargets="Build">
        <ItemGroup>
            <FilesToDelete Include="$(OutputPath)System.*.dll"/>
            <FilesToDelete Include="$(OutputPath)*.deps.json"/>
        </ItemGroup>
        <Delete Files="@(FilesToDelete)"/>
    </Target>

</Project>

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/DoorstopEntrypoint.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using BepInEx;
using BepInEx.Preloader.Core;
using BepInEx.Unity.IL2CPP;
using BepInEx.Unity.IL2CPP.Utils;
using MonoMod.Utils;

// ReSharper disable once CheckNamespace
namespace Doorstop;

internal static class Entrypoint
{
    /// <summary>
    ///     The main entrypoint of BepInEx, called from Doorstop.
    /// </summary>
    public static void Start()
    {
        // We set it to the current directory first as a fallback, but try to use the same location as the .exe file.
        var silentExceptionLog = Environment.GetEnvironmentVariable("BEPINEX_PRELOADER_LOG") ??
                                 $"preloader_{DateTime.Now:yyyyMMdd_HHmmss_fff}.log";
        Mutex mutex = null;

        try
        {
            EnvVars.LoadVars();

            silentExceptionLog =
                Path.Combine(Path.GetDirectoryName(EnvVars.DOORSTOP_PROCESS_PATH), silentExceptionLog);

            var mutexId = Utility.HashStrings(Process.GetCurrentProcess().ProcessName, EnvVars.DOORSTOP_PROCESS_PATH,
                                              typeof(Entrypoint).FullName);

            mutex = new Mutex(false, $"Global\\{mutexId}");
            mutex.WaitOne();

            UnityPreloaderRunner.PreloaderMain();
        }
        catch (Exception ex)
        {
            File.WriteAllText(silentExceptionLog, ex.ToString());

            try
            {
                if (PlatformHelper.Is(Platform.Windows))
                {
                    MessageBox.Show("Failed to start BepInEx", "BepInEx");
                }
                else if (NotifySend.IsSupported)
                {
                    NotifySend.Send("Failed to start BepInEx", "Check logs for details");
                }
                else if (string.IsNullOrEmpty(Environment.GetEnvironmentVariable("BEPINEX_FAIL_FAST")))
                {
                    // Don't exit the game if we have no way of signaling to the user that a crash happened
                    return;
                }
            }
            catch (Exception)
            {
                // ignored
            }

            Environment.Exit(1);
        }
        finally
        {
            mutex?.ReleaseMutex();
        }
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Hook/BaseNativeDetour.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;
using BepInEx.Logging;
using MonoMod.RuntimeDetour;

namespace BepInEx.Unity.IL2CPP.Hook;

internal abstract class BaseNativeDetour<T> : INativeDetour where T : BaseNativeDetour<T>
{
    protected static readonly ManualLogSource Logger = BepInEx.Logging.Logger.CreateLogSource(typeof(T).Name);

    protected BaseNativeDetour(nint originalMethodPtr, Delegate detourMethod)
    {
        OriginalMethodPtr = originalMethodPtr;
        DetourMethod = detourMethod;
        DetourMethodPtr = Marshal.GetFunctionPointerForDelegate(detourMethod);
    }

    public bool IsPrepared { get; protected set; }
    protected MethodInfo TrampolineMethod { get; set; }
    protected Delegate DetourMethod { get; set; }

    public nint OriginalMethodPtr { get; }
    public nint DetourMethodPtr { get; }
    public nint TrampolinePtr { get; protected set; }
    public bool IsValid { get; private set; } = true;
    public bool IsApplied { get; private set; }

    public void Dispose()
    {
        if (!IsValid) return;
        Undo();
        Free();
    }

    public void Apply()
    {
        if (IsApplied) return;

        Prepare();
        ApplyImpl();

        Logger.Log(LogLevel.Debug,
                   $"Original: {OriginalMethodPtr:X}, Trampoline: {TrampolinePtr:X}, diff: {Math.Abs(OriginalMethodPtr - TrampolinePtr):X}");

        IsApplied = true;
    }

    public void Undo()
    {
        if (IsApplied && IsPrepared) UndoImpl();
    }

    public void Free()
    {
        FreeImpl();
        IsValid = false;
    }

    public MethodBase GenerateTrampoline(MethodBase signature = null)
    {
        if (TrampolineMethod == null)
        {
            Prepare();
            TrampolineMethod = DetourHelper.GenerateNativeProxy(TrampolinePtr, signature);
        }

        return TrampolineMethod;
    }

    public TDelegate GenerateTrampoline<TDelegate>() where TDelegate : Delegate
    {
        if (!typeof(Delegate).IsAssignableFrom(typeof(TDelegate)))
            throw new InvalidOperationException($"Type {typeof(TDelegate)} not a delegate type.");

        _ = GenerateTrampoline(typeof(TDelegate).GetMethod("Invoke"));

        return Marshal.GetDelegateForFunctionPointer<TDelegate>(TrampolinePtr);
    }

    protected abstract void ApplyImpl();

    private void Prepare()
    {
        if (IsPrepared) return;
        Logger.LogDebug($"Preparing detour from 0x{OriginalMethodPtr:X2} to 0x{DetourMethodPtr:X2}");
        PrepareImpl();
        Logger.LogDebug($"Prepared detour; Trampoline: 0x{TrampolinePtr:X2}");
        IsPrepared = true;
    }

    protected abstract void PrepareImpl();

    protected abstract void UndoImpl();

    protected abstract void FreeImpl();
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Hook/Dobby/DobbyDetour.cs`:

```cs
using System;

namespace BepInEx.Unity.IL2CPP.Hook.Dobby;

internal class DobbyDetour : BaseNativeDetour<DobbyDetour>
{
    public DobbyDetour(nint originalMethodPtr, Delegate detourMethod) : base(originalMethodPtr, detourMethod) { }

    protected override void ApplyImpl() => DobbyLib.Commit(OriginalMethodPtr);

    protected override unsafe void PrepareImpl()
    {
        nint trampolinePtr = 0;
        DobbyLib.Prepare(OriginalMethodPtr, DetourMethodPtr, &trampolinePtr);
        TrampolinePtr = trampolinePtr;
    }

    protected override void UndoImpl() => DobbyLib.Destroy(OriginalMethodPtr);

    protected override void FreeImpl() { }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Hook/Dobby/DobbyLib.cs`:

```cs
using System.Runtime.InteropServices;

namespace BepInEx.Unity.IL2CPP.Hook.Dobby;

internal static unsafe class DobbyLib
{
    [DllImport("dobby", EntryPoint = "DobbyHook", CallingConvention = CallingConvention.Cdecl)]
    public static extern int Hook(nint target, nint replacement, nint* originalCall);

    [DllImport("dobby", EntryPoint = "DobbyPrepare", CallingConvention = CallingConvention.Cdecl)]
    public static extern int Prepare(nint target, nint replacement, nint* originalCall);

    [DllImport("dobby", EntryPoint = "DobbyCommit", CallingConvention = CallingConvention.Cdecl)]
    public static extern int Commit(nint target);

    [DllImport("dobby", EntryPoint = "DobbyDestroy", CallingConvention = CallingConvention.Cdecl)]
    public static extern int Destroy(nint target);
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Hook/Funchook/FunchookDetour.cs`:

```cs
using System;
using System.Runtime.CompilerServices;

namespace BepInEx.Unity.IL2CPP.Hook.Funchook;

internal class FunchookDetour : BaseNativeDetour<FunchookDetour>
{
    private readonly nint funchookInstance;

    public FunchookDetour(nint originalMethodPtr, Delegate detourMethod) : base(originalMethodPtr, detourMethod)
    {
        funchookInstance = FunchookLib.Create();
    }

    protected override void ApplyImpl() => EnsureSuccess(FunchookLib.Install(funchookInstance, 0));

    protected override unsafe void PrepareImpl()
    {
        var trampolinePtr = OriginalMethodPtr;
        EnsureSuccess(FunchookLib.Prepare(funchookInstance, &trampolinePtr, DetourMethodPtr));
        TrampolinePtr = trampolinePtr;
    }

    protected override void UndoImpl() => EnsureSuccess(FunchookLib.Uninstall(funchookInstance, 0));

    protected override void FreeImpl() => EnsureSuccess(FunchookLib.Destroy(funchookInstance));

    private string GetErrorMessage()
        => FunchookLib.ErrorMessage(funchookInstance);

    private void EnsureSuccess(FunchookResult result, [CallerArgumentExpression("result")] string methodName = null)
    {
        if (result == FunchookResult.Success) return;
        var errorMsg = GetErrorMessage();
        if (result == FunchookResult.OutOfMemory) throw new OutOfMemoryException($"{methodName} failed: {errorMsg}");
        throw new Exception($"{methodName} failed with result {result}: {errorMsg}");
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Hook/Funchook/FunchookLib.cs`:

```cs
using System.Runtime.InteropServices;

namespace BepInEx.Unity.IL2CPP.Hook.Funchook;

internal enum FunchookResult
{
    InternalError = -1,
    Success = 0,
    OutOfMemory = 1,
    AlreadyInstalled = 2,
    Disassembly = 3,
    IPRelativeOffset = 4,
    CannotFixIPRelative = 5,
    FoundBackJump = 6,
    TooShortInstructions = 7,
    MemoryAllocation = 8,
    MemoryFunction = 9,
    NotInstalled = 10,
    NoAvailableRegisters = 11
}

internal static unsafe class FunchookLib
{
    [DllImport("funchook", EntryPoint = "funchook_create", CallingConvention = CallingConvention.Cdecl)]
    public static extern nint Create();

    [DllImport("funchook", EntryPoint = "funchook_destroy", CallingConvention = CallingConvention.Cdecl)]
    public static extern FunchookResult Destroy(nint handle);

    [DllImport("funchook", EntryPoint = "funchook_prepare", CallingConvention = CallingConvention.Cdecl)]
    public static extern FunchookResult Prepare(nint handle, nint* target, nint hook);

    [DllImport("funchook", EntryPoint = "funchook_install", CallingConvention = CallingConvention.Cdecl)]
    public static extern FunchookResult Install(nint handle, int flags);

    [DllImport("funchook", EntryPoint = "funchook_uninstall", CallingConvention = CallingConvention.Cdecl)]
    public static extern FunchookResult Uninstall(nint handle, int flags);

    [DllImport("funchook", EntryPoint = "funchook_error_message", CallingConvention = CallingConvention.Cdecl)]
    public static extern string ErrorMessage(nint handle);

    [DllImport("funchook", EntryPoint = "funchook_set_debug_file", CallingConvention = CallingConvention.Cdecl)]
    public static extern FunchookResult SetDebugFile([MarshalAs(UnmanagedType.LPStr)] string name);
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Hook/INativeDetour.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using BepInEx.Configuration;
using BepInEx.Unity.IL2CPP.Hook.Dobby;
using BepInEx.Unity.IL2CPP.Hook.Funchook;
using MonoMod.RuntimeDetour;
using MonoMod.Utils;

namespace BepInEx.Unity.IL2CPP.Hook;

public interface INativeDetour : IDetour
{
    private static readonly ConfigEntry<DetourProvider> DetourProviderType = ConfigFile.CoreConfig.Bind(
         "Detours", "DetourProviderType",
         DetourProvider.Default,
         "The native provider to use for managed detours"
        );

    public nint OriginalMethodPtr { get; }
    public nint DetourMethodPtr { get; }
    public nint TrampolinePtr { get; }

    private static INativeDetour CreateDefault<T>(nint original, T target) where T : Delegate =>
        // TODO: check and provide an OS accurate provider
        new DobbyDetour(original, target);

    public static INativeDetour Create<T>(nint original, T target) where T : Delegate
    {
        var detour = DetourProviderType.Value switch
        {
            DetourProvider.Dobby    => new DobbyDetour(original, target),
            DetourProvider.Funchook => new FunchookDetour(original, target),
            _                       => CreateDefault(original, target)
        };
        if (!ReflectionHelper.IsMono)
        {
            return new CacheDetourWrapper(detour, target);
        }

        return detour;
    }

    public static INativeDetour CreateAndApply<T>(nint from, T to, out T original)
        where T : Delegate
    {
        var detour = Create(from, to);
        original = detour.GenerateTrampoline<T>();
        detour.Apply();

        return detour;
    }

    // Workaround for CoreCLR collecting all delegates
    private class CacheDetourWrapper : INativeDetour
    {
        private readonly INativeDetour _wrapped;

        private List<object> _cache = new();

        public CacheDetourWrapper(INativeDetour wrapped, Delegate target)
        {
            _wrapped = wrapped;
            _cache.Add(target);
        }

        public void Dispose()
        {
            _wrapped.Dispose();
            _cache.Clear();
        }

        public void Apply() => _wrapped.Apply();

        public void Undo() => _wrapped.Undo();

        public void Free() => _wrapped.Free();

        public MethodBase GenerateTrampoline(MethodBase signature = null) => _wrapped.GenerateTrampoline(signature);

        public T GenerateTrampoline<T>() where T : Delegate
        {
            var trampoline = _wrapped.GenerateTrampoline<T>();
            _cache.Add(trampoline);
            return trampoline;
        }

        public bool IsValid => _wrapped.IsValid;

        public bool IsApplied => _wrapped.IsApplied;

        public nint OriginalMethodPtr => _wrapped.OriginalMethodPtr;

        public nint DetourMethodPtr => _wrapped.DetourMethodPtr;

        public nint TrampolinePtr => _wrapped.TrampolinePtr;
    }

    internal enum DetourProvider
    {
        Default,
        Dobby,
        Funchook
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Hook/Il2CppInteropDetourProvider.cs`:

```cs
using System;
using Il2CppInterop.Runtime.Injection;

namespace BepInEx.Unity.IL2CPP.Hook;

internal class Il2CppInteropDetourProvider : IDetourProvider
{
    public IDetour Create<TDelegate>(nint original, TDelegate target) where TDelegate : Delegate =>
        new Il2CppInteropDetour(INativeDetour.Create(original, target));
}

internal class Il2CppInteropDetour : IDetour
{
    private readonly INativeDetour detour;

    public Il2CppInteropDetour(INativeDetour detour)
    {
        this.detour = detour;
    }

    public void Dispose() => detour.Dispose();

    public void Apply() => detour.Apply();

    public T GenerateTrampoline<T>() where T : Delegate => detour.GenerateTrampoline<T>();

    public nint Target => detour.OriginalMethodPtr;
    public nint Detour => detour.DetourMethodPtr;
    public nint OriginalTrampoline => detour.TrampolinePtr;
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/IL2CPPChainloader.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;
using BepInEx.Bootstrap;
using BepInEx.Configuration;
using BepInEx.Logging;
using BepInEx.Preloader.Core;
using BepInEx.Preloader.Core.Logging;
using BepInEx.Unity.IL2CPP.Hook;
using BepInEx.Unity.IL2CPP.Logging;
using BepInEx.Unity.IL2CPP.Utils;
using Il2CppInterop.Runtime.InteropTypes;
using UnityEngine;
using Logger = BepInEx.Logging.Logger;

namespace BepInEx.Unity.IL2CPP;

public class IL2CPPChainloader : BaseChainloader<BasePlugin>
{
    private static RuntimeInvokeDetourDelegate originalInvoke;

    private static readonly ConfigEntry<bool> ConfigUnityLogging = ConfigFile.CoreConfig.Bind(
     "Logging", "UnityLogListening",
     true,
     "Enables showing unity log messages in the BepInEx logging system.");

    private static readonly ConfigEntry<bool> ConfigDiskWriteUnityLog = ConfigFile.CoreConfig.Bind(
     "Logging.Disk", "WriteUnityLog",
     false,
     "Include unity log messages in log file output.");


    private static INativeDetour RuntimeInvokeDetour { get; set; }

    public static IL2CPPChainloader Instance { get; set; }

    /// <summary>
    ///     Register and add a Unity Component (for example MonoBehaviour) into BepInEx global manager.
    ///     Automatically registers the type with Il2Cpp type system if it isn't initialised already.
    /// </summary>
    /// <typeparam name="T">Type of the component to add.</typeparam>
    public static T AddUnityComponent<T>() where T : Il2CppObjectBase => AddUnityComponent(typeof(T)).Cast<T>();

    /// <summary>
    ///     Register and add a Unity Component (for example MonoBehaviour) into BepInEx global manager.
    ///     Automatically registers the type with Il2Cpp type system if it isn't initialised already.
    /// </summary>
    /// <param name="t">Type of the component to add</param>
    public static Il2CppObjectBase AddUnityComponent(Type t) => Il2CppUtils.AddComponent(t);

    /// <summary>
    ///     Occurs after a plugin is instantiated and just before <see cref="BasePlugin.Load"/> is called.
    /// </summary>
    public event Action<PluginInfo, Assembly, BasePlugin> PluginLoad;

    public override void Initialize(string gameExePath = null)
    {
        base.Initialize(gameExePath);
        Instance = this;

        if (!NativeLibrary.TryLoad("GameAssembly", typeof(IL2CPPChainloader).Assembly, null, out var il2CppHandle))
        {
            Logger.Log(LogLevel.Fatal,
                       "Could not locate Il2Cpp game assembly (GameAssembly.dll, UserAssembly.dll or libil2cpp.so). The game might be obfuscated or use a yet unsupported build of Unity.");
            return;
        }

        var runtimeInvokePtr = NativeLibrary.GetExport(il2CppHandle, "il2cpp_runtime_invoke");
        PreloaderLogger.Log.Log(LogLevel.Debug, $"Runtime invoke pointer: 0x{runtimeInvokePtr.ToInt64():X}");
        RuntimeInvokeDetourDelegate invokeMethodDetour = OnInvokeMethod;

        RuntimeInvokeDetour =
            INativeDetour.CreateAndApply(runtimeInvokePtr, invokeMethodDetour, out originalInvoke);
        PreloaderLogger.Log.Log(LogLevel.Debug, "Runtime invoke patched");
    }

    private static IntPtr OnInvokeMethod(IntPtr method, IntPtr obj, IntPtr parameters, IntPtr exc)
    {
        var methodName = Marshal.PtrToStringAnsi(Il2CppInterop.Runtime.IL2CPP.il2cpp_method_get_name(method));

        var unhook = false;

        if (methodName == "Internal_ActiveSceneChanged")
            try
            {
                if (ConfigUnityLogging.Value)
                {
                    Logger.Sources.Add(new IL2CPPUnityLogSource());

                    Application.CallLogCallback("Test call after applying unity logging hook", "", LogType.Assert,
                                                true);
                }

                unhook = true;

                Instance.Execute();
            }
            catch (Exception ex)
            {
                Logger.Log(LogLevel.Fatal, "Unable to execute IL2CPP chainloader");
                Logger.Log(LogLevel.Error, ex);
            }

        var result = originalInvoke(method, obj, parameters, exc);

        if (unhook)
        {
            RuntimeInvokeDetour.Dispose();

            PreloaderLogger.Log.Log(LogLevel.Debug, "Runtime invoke unpatched");
        }

        return result;
    }

    protected override void InitializeLoggers()
    {
        base.InitializeLoggers();

        if (!ConfigDiskWriteUnityLog.Value) DiskLogListener.BlacklistedSources.Add("Unity");

        ChainloaderLogHelper.RewritePreloaderLogs();

        Logger.Sources.Add(new IL2CPPLogSource());
    }

    public override BasePlugin LoadPlugin(PluginInfo pluginInfo, Assembly pluginAssembly)
    {
        var type = pluginAssembly.GetType(pluginInfo.TypeName);

        var pluginInstance = (BasePlugin) Activator.CreateInstance(type);

        PluginLoad?.Invoke(pluginInfo, pluginAssembly, pluginInstance);
        pluginInstance.Load();

        return pluginInstance;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr RuntimeInvokeDetourDelegate(IntPtr method, IntPtr obj, IntPtr parameters, IntPtr exc);
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Il2CppInteropManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Net.Http;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using BepInEx.Configuration;
using BepInEx.Logging;
using BepInEx.Unity.Common;
using BepInEx.Unity.IL2CPP.Hook;
using BepInEx.Unity.IL2CPP.Logging;
using Cpp2IL.Core;
using HarmonyLib;
using Il2CppInterop.Common;
using Il2CppInterop.Generator;
using Il2CppInterop.Generator.Runners;
using Il2CppInterop.HarmonySupport;
using Il2CppInterop.Runtime.Startup;
using LibCpp2IL;
using Microsoft.Extensions.Logging;
using Mono.Cecil;
using MonoMod.Utils;
using LogLevel = Microsoft.Extensions.Logging.LogLevel;
using MSLoggerFactory = Microsoft.Extensions.Logging.LoggerFactory;

namespace BepInEx.Unity.IL2CPP;

internal static class Il2CppInteropManager
{
    private static readonly ConfigEntry<bool> UpdateInteropAssemblies =
        ConfigFile.CoreConfig.Bind("IL2CPP",
                                   "UpdateInteropAssemblies",
                                   true,
                                   new StringBuilder()
                                       .AppendLine("Whether to run Il2CppInterop automatically to generate Il2Cpp support assemblies when they are outdated.")
                                       .AppendLine("If disabled assemblies in `BepInEx/interop` won't be updated between game or BepInEx updates!")
                                       .ToString());

    private static readonly ConfigEntry<string> UnityBaseLibrariesSource = ConfigFile.CoreConfig.Bind(
     "IL2CPP", "UnityBaseLibrariesSource",
     "https://unity.bepinex.dev/libraries/{VERSION}.zip",
     new StringBuilder()
         .AppendLine("URL to the ZIP of managed Unity base libraries.")
         .AppendLine("The base libraries are used by Il2CppInterop to generate interop assemblies.")
         .AppendLine("The URL can include {VERSION} template which will be replaced with the game's Unity engine version.")
         .ToString());

    private static readonly ConfigEntry<string> ConfigUnhollowerDeobfuscationRegex = ConfigFile.CoreConfig.Bind(
     "IL2CPP", "UnhollowerDeobfuscationRegex",
     string.Empty,
     new StringBuilder()
         .AppendLine("The RegEx string to pass to Il2CppAssemblyUnhollower for renaming obfuscated names.")
         .AppendLine("All types and members matching this RegEx will get a name based on their signature,")
         .AppendLine("resulting in names that persist after game updates.")
         .ToString());

    private static readonly ConfigEntry<bool> ScanMethodRefs = ConfigFile.CoreConfig.Bind(
     "IL2CPP", "ScanMethodRefs",
     Environment.Is64BitProcess,
     "If enabled, Il2CppInterop will use xref to find dead methods and generate CallerCount attributes.");

    private static readonly ConfigEntry<bool> DumpDummyAssemblies = ConfigFile.CoreConfig.Bind(
     "IL2CPP", "DumpDummyAssemblies",
     false,
     "If enabled, BepInEx will save dummy assemblies generated by an Cpp2IL dumper into BepInEx/dummy.");

    private static readonly ManualLogSource Logger = BepInEx.Logging.Logger.CreateLogSource("InteropManager");

    private static bool initialized;

    public static string GameAssemblyPath => Environment.GetEnvironmentVariable("BEPINEX_GAME_ASSEMBLY_PATH") ??
                                             Path.Combine(Paths.GameRootPath,
                                                          "GameAssembly." + PlatformHelper.LibrarySuffix);

    private static string HashPath => Path.Combine(IL2CPPInteropAssemblyPath, "assembly-hash.txt");

    private static string UnityBaseLibsDirectory => Path.Combine(Paths.BepInExRootPath, "unity-libs");

    internal static string IL2CPPInteropAssemblyPath => Path.Combine(Paths.BepInExRootPath, "interop");

    private static ILoggerFactory LoggerFactory { get; } = MSLoggerFactory.Create(b =>
    {
        b.AddProvider(new BepInExLoggerProvider())
         .SetMinimumLevel(LogLevel.Trace); // Each BepInEx log listener has its own filtering
    });

    private static string ComputeHash()
    {
        using var md5 = MD5.Create();

        static void HashFile(ICryptoTransform hash, string file)
        {
            const int defaultCopyBufferSize = 81920;
            using var fs = File.OpenRead(file);
            var buffer = new byte[defaultCopyBufferSize];
            int read;
            while ((read = fs.Read(buffer)) > 0)
                hash.TransformBlock(buffer, 0, read, buffer, 0);
        }

        static void HashString(ICryptoTransform hash, string str)
        {
            var buffer = Encoding.UTF8.GetBytes(str);
            hash.TransformBlock(buffer, 0, buffer.Length, buffer, 0);
        }

        HashFile(md5, GameAssemblyPath);

        if (Directory.Exists(UnityBaseLibsDirectory))
            foreach (var file in Directory.EnumerateFiles(UnityBaseLibsDirectory, "*.dll",
                                                          SearchOption.TopDirectoryOnly))
            {
                HashString(md5, Path.GetFileName(file));
                HashFile(md5, file);
            }

        // Hash some common dependencies as they can affect output
        HashString(md5, typeof(InteropAssemblyGenerator).Assembly.GetName().Version.ToString());
        HashString(md5, typeof(Cpp2IlApi).Assembly.GetName().Version.ToString());

        md5.TransformFinalBlock(new byte[0], 0, 0);

        return Utility.ByteArrayToString(md5.Hash);
    }

    private static bool CheckIfGenerationRequired()
    {
        static bool NeedGenerationOrSkip()
        {
            if (!UpdateInteropAssemblies.Value)
            {
                var hash = ComputeHash();
                Logger.LogWarning($"Interop assemblies are possibly out of date. To disable this message, create file {HashPath} with the following contents: {hash}");
                return false;
            }

            return true;
        }

        if (!Directory.Exists(IL2CPPInteropAssemblyPath))
            return true;

        if (!File.Exists(HashPath))
            return NeedGenerationOrSkip();

        if (ComputeHash() != File.ReadAllText(HashPath) && NeedGenerationOrSkip())
        {
            Logger.LogInfo("Detected outdated interop assemblies, will regenerate them now");
            return true;
        }

        return false;
    }

    private static Assembly ResolveInteropAssemblies(object sender, ResolveEventArgs args)
    {
        var assemblyName = new AssemblyName(args.Name);
        return Utility.TryResolveDllAssembly(assemblyName, IL2CPPInteropAssemblyPath, out var foundAssembly)
                   ? foundAssembly
                   : null;
    }

    public static void Initialize()
    {
        if (initialized)
            throw new InvalidOperationException("Already initialized");
        initialized = true;

        Environment.SetEnvironmentVariable("IL2CPP_INTEROP_DATABASES_LOCATION", IL2CPPInteropAssemblyPath);
        AppDomain.CurrentDomain.AssemblyResolve += ResolveInteropAssemblies;

        GenerateInteropAssemblies();
        var interopLogger = LoggerFactory.CreateLogger("Il2CppInterop");

        var unityVersion = UnityInfo.Version;
        Il2CppInteropRuntime.Create(new RuntimeConfiguration
                            {
                                UnityVersion = new Version(unityVersion.Major, unityVersion.Minor, unityVersion.Build),
                                DetourProvider = new Il2CppInteropDetourProvider()
                            })
                            .AddLogger(interopLogger)
                            .AddHarmonySupport()
                            .Start();
    }

    private static void GenerateInteropAssemblies()
    {
        if (!CheckIfGenerationRequired())
            return;

        try
        {
            Directory.CreateDirectory(IL2CPPInteropAssemblyPath);
            Directory.EnumerateFiles(IL2CPPInteropAssemblyPath, "*.dll").Do(File.Delete);

            AppDomain.CurrentDomain.AddCecilPlatformAssemblies(UnityBaseLibsDirectory);
            DownloadUnityAssemblies();
            var dummyAssemblies = RunCpp2Il();

            if (DumpDummyAssemblies.Value)
            {
                var dummyPath = Path.Combine(Paths.BepInExRootPath, "dummy");
                Directory.CreateDirectory(dummyPath);
                foreach (var assemblyDefinition in dummyAssemblies)
                    assemblyDefinition.Write(Path.Combine(dummyPath, $"{assemblyDefinition.Name.Name}.dll"));
            }

            RunIl2CppInteropGenerator(dummyAssemblies);

            File.WriteAllText(HashPath, ComputeHash());
        }
        catch (Exception e)
        {
            Logger.LogError($"Failed to generate Il2Cpp interop assemblies: {e}");
        }
    }

    private static void DownloadUnityAssemblies()
    {
        var unityVersion = UnityInfo.Version;
        var source =
            UnityBaseLibrariesSource.Value.Replace("{VERSION}",
                                                   $"{unityVersion.Major}.{unityVersion.Minor}.{unityVersion.Build}");

        if (!string.IsNullOrEmpty(source))
        {
            Logger.LogMessage("Downloading unity base libraries");

            Directory.CreateDirectory(UnityBaseLibsDirectory);
            Directory.EnumerateFiles(UnityBaseLibsDirectory, "*.dll").Do(File.Delete);

            using var httpClient = new HttpClient();
            using var zipStream = httpClient.GetStreamAsync(source).GetAwaiter().GetResult();
            using var zipArchive = new ZipArchive(zipStream, ZipArchiveMode.Read);

            Logger.LogMessage("Extracting downloaded unity base libraries");
            zipArchive.ExtractToDirectory(UnityBaseLibsDirectory);
        }
    }

    private static List<AssemblyDefinition> RunCpp2Il()
    {
        Logger.LogMessage("Running Cpp2IL to generate dummy assemblies");

        var metadataPath = Path.Combine(Paths.GameRootPath,
                                        $"{Paths.ProcessName}_Data",
                                        "il2cpp_data",
                                        "Metadata",
                                        "global-metadata.dat");

        List<AssemblyDefinition> sourceAssemblies;

        var stopwatch = new Stopwatch();
        stopwatch.Start();

        var cpp2IlLogger = BepInEx.Logging.Logger.CreateLogSource("Cpp2IL");

        Cpp2IL.Core.Logger.VerboseLog += (message, s) =>
            cpp2IlLogger.LogDebug($"[{s}] {message.Trim()}");
        Cpp2IL.Core.Logger.InfoLog += (message, s) =>
            cpp2IlLogger.LogInfo($"[{s}] {message.Trim()}");
        Cpp2IL.Core.Logger.WarningLog += (message, s) =>
            cpp2IlLogger.LogWarning($"[{s}] {message.Trim()}");
        Cpp2IL.Core.Logger.ErrorLog += (message, s) =>
            cpp2IlLogger.LogError($"[{s}] {message.Trim()}");

        var unityVersion = UnityInfo.Version;
        Cpp2IlApi.InitializeLibCpp2Il(GameAssemblyPath, metadataPath, new int[]
        {
            unityVersion.Major,
            unityVersion.Minor,
            unityVersion.Build,
        }, false);
        sourceAssemblies = Cpp2IlApi.MakeDummyDLLs();
        Cpp2IlApi.RunAttributeRestorationForAllAssemblies(null,
                                                          LibCpp2IlMain.MetadataVersion >= 29 ||
                                                          LibCpp2IlMain.Binary!.InstructionSet is InstructionSet.X86_32
                                                              or InstructionSet.X86_64);
        Cpp2IlApi.DisposeAndCleanupAll();

        stopwatch.Stop();
        Logger.LogInfo($"Cpp2IL finished in {stopwatch.Elapsed}");

        return sourceAssemblies;
    }

    private static void RunIl2CppInteropGenerator(List<AssemblyDefinition> sourceAssemblies)
    {
        var opts = new GeneratorOptions
        {
            GameAssemblyPath = ScanMethodRefs.Value ? GameAssemblyPath : null,
            Source = sourceAssemblies,
            OutputDir = IL2CPPInteropAssemblyPath,
            UnityBaseLibsDir = Directory.Exists(UnityBaseLibsDirectory) ? UnityBaseLibsDirectory : null,
            ObfuscatedNamesRegex = !string.IsNullOrEmpty(ConfigUnhollowerDeobfuscationRegex.Value)
                                       ? new Regex(ConfigUnhollowerDeobfuscationRegex.Value)
                                       : null,
        };

        var renameMapLocation = Path.Combine(Paths.BepInExRootPath, "DeobfuscationMap.csv.gz");
        if (File.Exists(renameMapLocation))
        {
            Logger.LogInfo("Parsing deobfuscation rename mappings");
            opts.ReadRenameMap(renameMapLocation);
        }

        Logger.LogInfo("Generating interop assemblies");

        var logger = LoggerFactory.CreateLogger("Il2CppInteropGen");

        Il2CppInteropGenerator.Create(opts)
                              .AddLogger(logger)
                              .AddInteropAssemblyGenerator()
                              .Run();

        sourceAssemblies.Do(x => x.Dispose());
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Logging/BepInExLoggerProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using BepInEx.Logging;
using Microsoft.Extensions.Logging;
using BepInExLogLevel = BepInEx.Logging.LogLevel;
using LogLevel = Microsoft.Extensions.Logging.LogLevel;

namespace BepInEx.Unity.IL2CPP.Logging;

internal class BepInExLoggerProvider : ILoggerProvider
{
    private readonly List<BepInExLogger> loggers = new();

    public void Dispose()
    {
        foreach (var bepInExLogger in loggers)
            bepInExLogger.Dispose();
        loggers.Clear();
    }

    public ILogger CreateLogger(string categoryName)
    {
        var logger = new BepInExLogger { SourceName = categoryName };
        Logger.Sources.Add(logger);
        loggers.Add(logger);
        return logger;
    }

    private class EmptyScope : IDisposable
    {
        public void Dispose() { }
    }

    private class BepInExLogger : ILogSource, ILogger
    {
        public void Log<TState>(LogLevel logLevel,
                                EventId eventId,
                                TState state,
                                Exception exception,
                                Func<TState, Exception, string> formatter)
        {
            var logLine = state.ToString() ?? string.Empty;

            if (exception != null)
                logLine += $"\nException: {exception}";

            LogEvent?.Invoke(this,
                             new LogEventArgs(logLine, MSLogLevelToBepInExLogLevel(logLevel),
                                              this));
        }


        public bool IsEnabled(LogLevel logLevel) =>
            (MSLogLevelToBepInExLogLevel(logLevel) & Logger.ListenedLogLevels) != BepInExLogLevel.None;

        public IDisposable BeginScope<TState>(TState state) => new EmptyScope();

        public void Dispose() => Logger.Sources.Remove(this);

        public string SourceName { get; init; }

        public event EventHandler<LogEventArgs> LogEvent;

        private static BepInExLogLevel MSLogLevelToBepInExLogLevel(LogLevel logLevel) => logLevel switch
        {
            LogLevel.Trace       => BepInExLogLevel.Debug,
            LogLevel.Debug       => BepInExLogLevel.Debug,
            LogLevel.Information => BepInExLogLevel.Info,
            LogLevel.Warning     => BepInExLogLevel.Warning,
            LogLevel.Error       => BepInExLogLevel.Error,
            LogLevel.Critical    => BepInExLogLevel.Fatal,
            LogLevel.None        => BepInExLogLevel.None,
            var _                => throw new ArgumentOutOfRangeException(nameof(logLevel), logLevel, null)
        };
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Logging/IL2CPPLogSource.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using BepInEx.Logging;

namespace BepInEx.Unity.IL2CPP.Logging;

public class IL2CPPLogSource : ILogSource
{
    public IL2CPPLogSource()
    {
        var loggerPointer = Marshal.GetFunctionPointerForDelegate(new IL2CPPLogCallbackDelegate(IL2CPPLogCallback));
        Il2CppInterop.Runtime.IL2CPP.il2cpp_register_log_callback(loggerPointer);
    }

    public string SourceName { get; } = "IL2CPP";
    public event EventHandler<LogEventArgs> LogEvent;

    public void Dispose() { }

    private void IL2CPPLogCallback(string message) =>
        LogEvent?.Invoke(this, new LogEventArgs(message.Trim(), LogLevel.Message, this));

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void IL2CPPLogCallbackDelegate([In] [MarshalAs(UnmanagedType.LPStr)] string message);
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Logging/IL2CPPUnityLogSource.cs`:

```cs
using System;
using BepInEx.Logging;
using UnityEngine;

namespace BepInEx.Unity.IL2CPP.Logging;

public class IL2CPPUnityLogSource : ILogSource
{
    public IL2CPPUnityLogSource()
    {
        Application.s_LogCallbackHandler = new Action<string, string, LogType>(UnityLogCallback);

        Il2CppInterop.Runtime.IL2CPP
                     .ResolveICall<
                         SetLogCallbackDefinedDelegate>("UnityEngine.Application::SetLogCallbackDefined")(true);
    }

    public string SourceName { get; } = "Unity";

    public event EventHandler<LogEventArgs> LogEvent;

    public void Dispose() { }

    public void UnityLogCallback(string logLine, string exception, LogType type)
    {
        var level = type switch
        {
            LogType.Error     => LogLevel.Error,
            LogType.Assert    => LogLevel.Debug,
            LogType.Warning   => LogLevel.Warning,
            LogType.Log       => LogLevel.Message,
            LogType.Exception => LogLevel.Error,
            _                 => LogLevel.Message
        };
        LogEvent?.Invoke(this, new LogEventArgs(logLine, level, this));
    }

    private delegate IntPtr SetLogCallbackDefinedDelegate(bool defined);
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Preloader.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;
using BepInEx.IL2CPP.RuntimeFixes;
using BepInEx.Logging;
using BepInEx.Preloader.Core;
using BepInEx.Preloader.Core.Logging;
using BepInEx.Preloader.Core.Patching;
using BepInEx.Preloader.RuntimeFixes;
using BepInEx.Unity.Common;
using MonoMod.Utils;

namespace BepInEx.Unity.IL2CPP;

public static class Preloader
{
    private static PreloaderConsoleListener PreloaderLog { get; set; }

    internal static ManualLogSource Log => PreloaderLogger.Log;

    // TODO: This is not needed, maybe remove? (Instance is saved in IL2CPPChainloader itself)
    private static IL2CPPChainloader Chainloader { get; set; }

    public static void Run()
    {
        try
        {
            HarmonyBackendFix.Initialize();
            ConsoleSetOutFix.Apply();
            UnityInfo.Initialize(Paths.ExecutablePath, Paths.GameDataPath);

            ConsoleManager.Initialize(false, true);

            PreloaderLog = new PreloaderConsoleListener();
            Logger.Listeners.Add(PreloaderLog);

            if (ConsoleManager.ConsoleEnabled)
            {
                ConsoleManager.CreateConsole();
                Logger.Listeners.Add(new ConsoleLogListener());
            }

            RedirectStdErrFix.Apply();

            ChainloaderLogHelper.PrintLogInfo(Log);

            Logger.Log(LogLevel.Info, $"Running under Unity {UnityInfo.Version}");
            Logger.Log(LogLevel.Info, $"Runtime version: {Environment.Version}");
            Logger.Log(LogLevel.Info, $"Runtime information: {RuntimeInformation.FrameworkDescription}");

            Logger.Log(LogLevel.Debug, $"Game executable path: {Paths.ExecutablePath}");
            Logger.Log(LogLevel.Debug, $"Interop assembly directory: {Il2CppInteropManager.IL2CPPInteropAssemblyPath}");
            Logger.Log(LogLevel.Debug, $"BepInEx root path: {Paths.BepInExRootPath}");

            if (PlatformHelper.Is(Platform.Wine) && !Environment.Is64BitProcess)
            {
                if (!NativeLibrary.TryGetExport(NativeLibrary.Load("ntdll"), "RtlRestoreContext", out var _))
                {
                    Logger.Log(LogLevel.Warning,
                               "Your wine version doesn't support CoreCLR properly, expect crashes! Upgrade to wine 7.16 or higher.");
                }
            }

            NativeLibrary.SetDllImportResolver(typeof(Il2CppInterop.Runtime.IL2CPP).Assembly, DllImportResolver);

            Il2CppInteropManager.Initialize();

            using (var assemblyPatcher = new AssemblyPatcher((data, _) => Assembly.Load(data)))
            {
                assemblyPatcher.AddPatchersFromDirectory(Paths.PatcherPluginPath);

                Log.LogInfo($"{assemblyPatcher.PatcherContext.PatcherPlugins.Count} patcher plugin{(assemblyPatcher.PatcherContext.PatcherPlugins.Count == 1 ? "" : "s")} loaded");

                assemblyPatcher.LoadAssemblyDirectories(Il2CppInteropManager.IL2CPPInteropAssemblyPath);

                Log.LogInfo($"{assemblyPatcher.PatcherContext.PatcherPlugins.Count} assemblies discovered");

                assemblyPatcher.PatchAndLoad();
            }


            Logger.Listeners.Remove(PreloaderLog);


            Chainloader = new IL2CPPChainloader();

            Chainloader.Initialize();
        }
        catch (Exception ex)
        {
            Log.Log(LogLevel.Fatal, ex);

            throw;
        }
    }

    private static IntPtr DllImportResolver(string libraryName, Assembly assembly, DllImportSearchPath? searchPath)
    {
        if (libraryName == "GameAssembly")
        {
            return NativeLibrary.Load(Il2CppInteropManager.GameAssemblyPath, assembly, searchPath);
        }

        return IntPtr.Zero;
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/RuntimeFixes/RedirectStdErrFix.cs`:

```cs
using System.IO;
using System.Runtime.InteropServices;
using BepInEx.Logging;
using MonoMod.Utils;

namespace BepInEx.IL2CPP.RuntimeFixes;

internal static class RedirectStdErrFix
{
    private const int STD_ERROR_HANDLE = -12;
    private const int INVALID_HANDLE_VALUE = -1;
    private const int FILE_SHARE_READ = 1;
    private const int GENERIC_WRITE = 0x40000000;
    private const int CREATE_ALWAYS = 2;
    private const int FILE_ATTRIBUTE_NORMAL = 0x00000080;

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern nint CreateFile(string fileName,
                                          uint desiredAccess,
                                          int shareMode,
                                          nint securityAttributes,
                                          int creationDisposition,
                                          int flagsAndAttributes,
                                          nint templateFile);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool SetStdHandle(int nStdHandle, nint hConsoleOutput);


    public static void Apply()
    {
        if (PlatformHelper.Is(Platform.Windows))
        {
            var errorFile = CreateFile(Path.Combine(Paths.BepInExRootPath, "ErrorLog.log"), GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
            if (errorFile == INVALID_HANDLE_VALUE)
            {
                Logger.Log(LogLevel.Warning, "Failed to open error log file; skipping error redirection");
                return;
            }

            if (!SetStdHandle(STD_ERROR_HANDLE, errorFile))
                Logger.Log(LogLevel.Warning, "Failed to redirect stderr; skipping error redirection");
        }
        // On unix, we can generally redirect stderr to a file "normally" via piping
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/UnityEngine/Input.cs`:

```cs
namespace BepInEx.Unity.IL2CPP.UnityEngine;

public enum KeyCode
{
    None,
    Backspace = 8,
    Delete = 127,
    Tab = 9,
    Clear = 12,
    Return,
    Pause = 19,
    Escape = 27,
    Space = 32,
    Keypad0 = 256,
    Keypad1,
    Keypad2,
    Keypad3,
    Keypad4,
    Keypad5,
    Keypad6,
    Keypad7,
    Keypad8,
    Keypad9,
    KeypadPeriod,
    KeypadDivide,
    KeypadMultiply,
    KeypadMinus,
    KeypadPlus,
    KeypadEnter,
    KeypadEquals,
    UpArrow,
    DownArrow,
    RightArrow,
    LeftArrow,
    Insert,
    Home,
    End,
    PageUp,
    PageDown,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    Alpha0 = 48,
    Alpha1,
    Alpha2,
    Alpha3,
    Alpha4,
    Alpha5,
    Alpha6,
    Alpha7,
    Alpha8,
    Alpha9,
    Exclaim = 33,
    DoubleQuote,
    Hash,
    Dollar,
    Percent,
    Ampersand,
    Quote,
    LeftParen,
    RightParen,
    Asterisk,
    Plus,
    Comma,
    Minus,
    Period,
    Slash,
    Colon = 58,
    Semicolon,
    Less,
    Equals,
    Greater,
    Question,
    At,
    LeftBracket = 91,
    Backslash,
    RightBracket,
    Caret,
    Underscore,
    BackQuote,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    LeftCurlyBracket,
    Pipe,
    RightCurlyBracket,
    Tilde,
    Numlock = 300,
    CapsLock,
    ScrollLock,
    RightShift,
    LeftShift,
    RightControl,
    LeftControl,
    RightAlt,
    LeftAlt,
    LeftCommand = 310,
    LeftApple = 310,
    LeftWindows,
    RightCommand = 309,
    RightApple = 309,
    RightWindows = 312,
    AltGr,
    Help = 315,
    Print,
    SysReq,
    Break,
    Menu,
    Mouse0 = 323,
    Mouse1,
    Mouse2,
    Mouse3,
    Mouse4,
    Mouse5,
    Mouse6,
    JoystickButton0,
    JoystickButton1,
    JoystickButton2,
    JoystickButton3,
    JoystickButton4,
    JoystickButton5,
    JoystickButton6,
    JoystickButton7,
    JoystickButton8,
    JoystickButton9,
    JoystickButton10,
    JoystickButton11,
    JoystickButton12,
    JoystickButton13,
    JoystickButton14,
    JoystickButton15,
    JoystickButton16,
    JoystickButton17,
    JoystickButton18,
    JoystickButton19,
    Joystick1Button0,
    Joystick1Button1,
    Joystick1Button2,
    Joystick1Button3,
    Joystick1Button4,
    Joystick1Button5,
    Joystick1Button6,
    Joystick1Button7,
    Joystick1Button8,
    Joystick1Button9,
    Joystick1Button10,
    Joystick1Button11,
    Joystick1Button12,
    Joystick1Button13,
    Joystick1Button14,
    Joystick1Button15,
    Joystick1Button16,
    Joystick1Button17,
    Joystick1Button18,
    Joystick1Button19,
    Joystick2Button0,
    Joystick2Button1,
    Joystick2Button2,
    Joystick2Button3,
    Joystick2Button4,
    Joystick2Button5,
    Joystick2Button6,
    Joystick2Button7,
    Joystick2Button8,
    Joystick2Button9,
    Joystick2Button10,
    Joystick2Button11,
    Joystick2Button12,
    Joystick2Button13,
    Joystick2Button14,
    Joystick2Button15,
    Joystick2Button16,
    Joystick2Button17,
    Joystick2Button18,
    Joystick2Button19,
    Joystick3Button0,
    Joystick3Button1,
    Joystick3Button2,
    Joystick3Button3,
    Joystick3Button4,
    Joystick3Button5,
    Joystick3Button6,
    Joystick3Button7,
    Joystick3Button8,
    Joystick3Button9,
    Joystick3Button10,
    Joystick3Button11,
    Joystick3Button12,
    Joystick3Button13,
    Joystick3Button14,
    Joystick3Button15,
    Joystick3Button16,
    Joystick3Button17,
    Joystick3Button18,
    Joystick3Button19,
    Joystick4Button0,
    Joystick4Button1,
    Joystick4Button2,
    Joystick4Button3,
    Joystick4Button4,
    Joystick4Button5,
    Joystick4Button6,
    Joystick4Button7,
    Joystick4Button8,
    Joystick4Button9,
    Joystick4Button10,
    Joystick4Button11,
    Joystick4Button12,
    Joystick4Button13,
    Joystick4Button14,
    Joystick4Button15,
    Joystick4Button16,
    Joystick4Button17,
    Joystick4Button18,
    Joystick4Button19,
    Joystick5Button0,
    Joystick5Button1,
    Joystick5Button2,
    Joystick5Button3,
    Joystick5Button4,
    Joystick5Button5,
    Joystick5Button6,
    Joystick5Button7,
    Joystick5Button8,
    Joystick5Button9,
    Joystick5Button10,
    Joystick5Button11,
    Joystick5Button12,
    Joystick5Button13,
    Joystick5Button14,
    Joystick5Button15,
    Joystick5Button16,
    Joystick5Button17,
    Joystick5Button18,
    Joystick5Button19,
    Joystick6Button0,
    Joystick6Button1,
    Joystick6Button2,
    Joystick6Button3,
    Joystick6Button4,
    Joystick6Button5,
    Joystick6Button6,
    Joystick6Button7,
    Joystick6Button8,
    Joystick6Button9,
    Joystick6Button10,
    Joystick6Button11,
    Joystick6Button12,
    Joystick6Button13,
    Joystick6Button14,
    Joystick6Button15,
    Joystick6Button16,
    Joystick6Button17,
    Joystick6Button18,
    Joystick6Button19,
    Joystick7Button0,
    Joystick7Button1,
    Joystick7Button2,
    Joystick7Button3,
    Joystick7Button4,
    Joystick7Button5,
    Joystick7Button6,
    Joystick7Button7,
    Joystick7Button8,
    Joystick7Button9,
    Joystick7Button10,
    Joystick7Button11,
    Joystick7Button12,
    Joystick7Button13,
    Joystick7Button14,
    Joystick7Button15,
    Joystick7Button16,
    Joystick7Button17,
    Joystick7Button18,
    Joystick7Button19,
    Joystick8Button0,
    Joystick8Button1,
    Joystick8Button2,
    Joystick8Button3,
    Joystick8Button4,
    Joystick8Button5,
    Joystick8Button6,
    Joystick8Button7,
    Joystick8Button8,
    Joystick8Button9,
    Joystick8Button10,
    Joystick8Button11,
    Joystick8Button12,
    Joystick8Button13,
    Joystick8Button14,
    Joystick8Button15,
    Joystick8Button16,
    Joystick8Button17,
    Joystick8Button18,
    Joystick8Button19
}

public static class Input
{
    private static readonly GetKeyIntDelegate GetKeyInt_Value
        = Il2CppInterop.Runtime.IL2CPP
                       .ResolveICall<GetKeyIntDelegate>("UnityEngine.Input::GetKeyInt(UnityEngine.KeyCode)");

    public static bool GetKeyInt(KeyCode key) => GetKeyInt_Value(key);

    private delegate bool GetKeyIntDelegate(KeyCode key);
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/UnityPreloadRunner.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using BepInEx.Preloader.Core;

namespace BepInEx.Unity.IL2CPP;

internal static class UnityPreloaderRunner
{
    public static void PreloaderMain()
    {
        var bepinPath =
            Path.GetDirectoryName(Path.GetDirectoryName(Path.GetFullPath(EnvVars.DOORSTOP_INVOKE_DLL_PATH)));

        PlatformUtils.SetPlatform();

        Paths.SetExecutablePath(EnvVars.DOORSTOP_PROCESS_PATH, bepinPath, EnvVars.DOORSTOP_MANAGED_FOLDER_DIR, false,
                                EnvVars.DOORSTOP_DLL_SEARCH_DIRS);

        // Cecil 0.11 requires one to manually set up list of trusted assemblies for assembly resolving
        // The main BCL path
        AppDomain.CurrentDomain.AddCecilPlatformAssemblies(Paths.ManagedPath);
        // The parent path -> .NET has some extra managed DLLs in there
        AppDomain.CurrentDomain.AddCecilPlatformAssemblies(Path.GetDirectoryName(Paths.ManagedPath));

        AppDomain.CurrentDomain.AssemblyResolve += LocalResolve;

        Preloader.Run();
    }

    internal static Assembly LocalResolve(object sender, ResolveEventArgs args)
    {
        var assemblyName = new AssemblyName(args.Name);

        var foundAssembly = AppDomain.CurrentDomain.GetAssemblies()
                                     .FirstOrDefault(x => x.GetName().Name == assemblyName.Name);

        if (foundAssembly != null)
            return foundAssembly;

        if (Utility.TryResolveDllAssembly(assemblyName, Paths.BepInExAssemblyDirectory, out foundAssembly)
         || Utility.TryResolveDllAssembly(assemblyName, Paths.PatcherPluginPath, out foundAssembly)
         || Utility.TryResolveDllAssembly(assemblyName, Paths.PluginPath, out foundAssembly))
            return foundAssembly;

        return null;
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/Collections/CollectionExtensions.cs`:

```cs
using Il2CppSystem.Collections;

namespace BepInEx.Unity.IL2CPP.Utils.Collections;

public static class CollectionExtensions
{
    public static IEnumerator WrapToIl2Cpp(this System.Collections.IEnumerator self) =>
        new Il2CppManagedEnumerator(self).Cast<IEnumerator>();

    public static System.Collections.IEnumerator WrapToManaged(this IEnumerator self) =>
        new ManagedIl2CppEnumerator(self);

    public static IEnumerable WrapToIl2Cpp(this System.Collections.IEnumerable self) =>
        new Il2CppManagedEnumerable(self).Cast<IEnumerable>();

    public static System.Collections.IEnumerable WrapToManaged(this IEnumerable self) =>
        new ManagedIl2CppEnumerable(self);
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/Collections/Il2CppManagedEnumerable.cs`:

```cs
using System.Collections;
using Il2CppInterop.Runtime.Injection;
using Il2CppSystem;
using ArgumentNullException = System.ArgumentNullException;
using IEnumerator = Il2CppSystem.Collections.IEnumerator;
using IntPtr = System.IntPtr;

namespace BepInEx.Unity.IL2CPP.Utils.Collections;

public class Il2CppManagedEnumerable : Object
{
    private readonly IEnumerable enumerable;

    static Il2CppManagedEnumerable()
    {
        ClassInjector.RegisterTypeInIl2Cpp<Il2CppManagedEnumerable>(new RegisterTypeOptions
        {
            Interfaces = new[] { typeof(Il2CppSystem.Collections.IEnumerable) }
        });
    }

    public Il2CppManagedEnumerable(IntPtr ptr) : base(ptr) { }

    public Il2CppManagedEnumerable(IEnumerable enumerable)
        : base(ClassInjector.DerivedConstructorPointer<Il2CppManagedEnumerable>())
    {
        this.enumerable = enumerable ?? throw new ArgumentNullException(nameof(enumerable));
        ClassInjector.DerivedConstructorBody(this);
    }

    public IEnumerator GetEnumerator() =>
        new Il2CppManagedEnumerator(enumerable.GetEnumerator()).Cast<IEnumerator>();
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/Collections/Il2CppManagedEnumerator.cs`:

```cs
using System.Collections;
using System.Collections.Generic;
using System.Reflection.Emit;
using HarmonyLib;
using Il2CppInterop.Runtime;
using Il2CppInterop.Runtime.Injection;
using Il2CppSystem;
using ArgumentNullException = System.ArgumentNullException;
using Il2CppIEnumerator = Il2CppSystem.Collections.IEnumerator;
using IntPtr = System.IntPtr;
using NotSupportedException = System.NotSupportedException;
using Type = System.Type;

namespace BepInEx.Unity.IL2CPP.Utils.Collections;

public class Il2CppManagedEnumerator : Object
{
    private static readonly Dictionary<Type, System.Func<object, Object>> boxers = new();

    private readonly IEnumerator enumerator;

    static Il2CppManagedEnumerator()
    {
        ClassInjector.RegisterTypeInIl2Cpp<Il2CppManagedEnumerator>(new RegisterTypeOptions
        {
            Interfaces = new[] { typeof(Il2CppIEnumerator) }
        });
    }

    public Il2CppManagedEnumerator(IntPtr ptr) : base(ptr) { }

    public Il2CppManagedEnumerator(IEnumerator enumerator)
        : base(ClassInjector.DerivedConstructorPointer<Il2CppManagedEnumerator>())
    {
        this.enumerator = enumerator ?? throw new ArgumentNullException(nameof(enumerator));
        ClassInjector.DerivedConstructorBody(this);
    }

    public Object Current => enumerator.Current switch
    {
        Il2CppIEnumerator i => i.Cast<Object>(),
        IEnumerator e       => new Il2CppManagedEnumerator(e),
        Object oo           => oo,
        { } obj             => ManagedToIl2CppObject(obj),
        null                => null
    };

    public bool MoveNext() => enumerator.MoveNext();

    public void Reset() => enumerator.Reset();

    private static System.Func<object, Object> GetValueBoxer(Type t)
    {
        if (boxers.TryGetValue(t, out var conv))
            return conv;

        var dm = new DynamicMethod($"Il2CppUnbox_{t.FullDescription()}", typeof(Object),
                                   new[] { typeof(object) });
        var il = dm.GetILGenerator();
        var loc = il.DeclareLocal(t);
        var classField = typeof(Il2CppClassPointerStore<>).MakeGenericType(t)
                                                          .GetField(nameof(Il2CppClassPointerStore<int>
                                                                               .NativeClassPtr));
        il.Emit(OpCodes.Ldsfld, classField);
        il.Emit(OpCodes.Ldarg_0);
        il.Emit(OpCodes.Unbox_Any, t);
        il.Emit(OpCodes.Stloc, loc);
        il.Emit(OpCodes.Ldloca, loc);
        il.Emit(OpCodes.Call,
                typeof(Il2CppInterop.Runtime.IL2CPP).GetMethod(nameof(Il2CppInterop.Runtime.IL2CPP.il2cpp_value_box)));
        il.Emit(OpCodes.Newobj, typeof(Object).GetConstructor(new[] { typeof(IntPtr) }));
        il.Emit(OpCodes.Ret);

        var converter = dm.CreateDelegate(typeof(System.Func<object, Object>)) as System.Func<object, Object>;
        boxers[t] = converter;
        return converter;
    }

    private static Object ManagedToIl2CppObject(object obj)
    {
        var t = obj.GetType();
        if (obj is string s)
            return new Object(Il2CppInterop.Runtime.IL2CPP.ManagedStringToIl2Cpp(s));
        if (t.IsPrimitive)
            return GetValueBoxer(t)(obj);
        throw new NotSupportedException($"Type {t} cannot be converted directly to an Il2Cpp object");
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/Collections/ManagedIl2CppEnumerable.cs`:

```cs
using System;
using System.Collections;

namespace BepInEx.Unity.IL2CPP.Utils.Collections;

public class ManagedIl2CppEnumerable : IEnumerable
{
    private readonly Il2CppSystem.Collections.IEnumerable enumerable;

    public ManagedIl2CppEnumerable(Il2CppSystem.Collections.IEnumerable enumerable)
    {
        this.enumerable = enumerable ?? throw new ArgumentNullException(nameof(enumerable));
    }

    public IEnumerator GetEnumerator() => new ManagedIl2CppEnumerator(enumerable.GetEnumerator());
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/Collections/ManagedIl2CppEnumerator.cs`:

```cs
using System;
using System.Collections;
using HarmonyLib;

namespace BepInEx.Unity.IL2CPP.Utils.Collections;

public class ManagedIl2CppEnumerator : IEnumerator
{
    private static readonly Func<Il2CppSystem.Collections.IEnumerator, bool> moveNext = AccessTools
        .Method(typeof(Il2CppSystem.Collections.IEnumerator), "MoveNext")
        ?.CreateDelegate<Func<Il2CppSystem.Collections.IEnumerator, bool>>();

    private static readonly Action<Il2CppSystem.Collections.IEnumerator> reset = AccessTools
        .Method(typeof(Il2CppSystem.Collections.IEnumerator), "Reset")
        ?.CreateDelegate<Action<Il2CppSystem.Collections.IEnumerator>>();

    private readonly Il2CppSystem.Collections.IEnumerator enumerator;

    public ManagedIl2CppEnumerator(Il2CppSystem.Collections.IEnumerator enumerator)
    {
        this.enumerator = enumerator ?? throw new ArgumentNullException(nameof(enumerator));
    }

    public bool MoveNext() => moveNext?.Invoke(enumerator) ?? false;

    public void Reset() => reset?.Invoke(enumerator);

    public object Current => enumerator.Current;
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/Il2CppUtils.cs`:

```cs
using System;
using Il2CppInterop.Runtime;
using Il2CppInterop.Runtime.Injection;
using Il2CppInterop.Runtime.InteropTypes;
using UnityEngine;

namespace BepInEx.Unity.IL2CPP.Utils;

internal static class Il2CppUtils
{
    // TODO: Check if we can safely initialize this in Chainloader instead
    private static GameObject managerGo;

    public static Il2CppObjectBase AddComponent(Type t)
    {
        if (managerGo == null)
            managerGo = new GameObject { hideFlags = HideFlags.HideAndDontSave };

        if (!ClassInjector.IsTypeRegisteredInIl2Cpp(t))
            ClassInjector.RegisterTypeInIl2Cpp(t);

        return managerGo.AddComponent(Il2CppType.From(t));
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/MessageBox.cs`:

```cs
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using MonoMod.Utils;

namespace BepInEx.Unity.IL2CPP.Utils;

internal static class MessageBox
{
    [DllImport("user32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int MessageBoxA(IntPtr hWnd, string lpText, string lpCaption, uint uType);

    public static void Show(string text, string caption)
    {
        if (!PlatformHelper.Is(Platform.Windows)) throw new PlatformNotSupportedException();
        if (MessageBoxA(IntPtr.Zero, text, caption, 0) == 0)
            throw new Win32Exception();
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/MonoBehaviourExtensions.cs`:

```cs
using System.Collections;
using BepInEx.Unity.IL2CPP.Utils.Collections;
using UnityEngine;

namespace BepInEx.Unity.IL2CPP.Utils;

public static class MonoBehaviourExtensions
{
    public static Coroutine StartCoroutine(this MonoBehaviour self, IEnumerator coroutine) =>
        self.StartCoroutine(coroutine.WrapToIl2Cpp());
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/Utils/NotifySend.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;

namespace BepInEx.Unity.IL2CPP.Utils;

internal static class NotifySend
{
    private const string EXECUTABLE_NAME = "notify-send";

    public static bool IsSupported => Find(EXECUTABLE_NAME) != null;

    private static string Find(string fileName)
    {
        if (File.Exists(fileName))
            return Path.GetFullPath(fileName);

        var paths = Environment.GetEnvironmentVariable("PATH");
        if (paths == null)
            return null;

        foreach (var path in paths.Split(Path.PathSeparator))
        {
            var fullPath = Path.Combine(path, fileName);
            if (File.Exists(fullPath))
                return fullPath;
        }

        return null;
    }

    public static void Send(string summary, string body)
    {
        if (!IsSupported) throw new NotSupportedException();

        var processStartInfo = new ProcessStartInfo(Find(EXECUTABLE_NAME))
        {
            ArgumentList =
            {
                summary,
                body,
                "--app-name=BepInEx",
            },
        };

        Process.Start(processStartInfo);
    }
}

```

`Runtimes/Unity/BepInEx.Unity.IL2CPP/app.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <runtime>
        <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
            <dependentAssembly>
                <assemblyIdentity name="Mono.Cecil" publicKeyToken="50cebf1cceb9d05e" culture="neutral"/>
                <bindingRedirect oldVersion="0.0.0.0-0.11.2.0" newVersion="0.11.2.0"/>
            </dependentAssembly>
        </assemblyBinding>
    </runtime>
</configuration>

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/BepInEx.Unity.Mono.Preloader.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <TargetFrameworks>net35;netstandard2.0</TargetFrameworks>
        <AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>
        <Description>BepInEx preloader module for UnityMono games</Description>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFramework)' == 'net35'">
        <!-- Output only net35 version to distribution; netstadnard is only used for generating NuGet package -->
        <OutputPath>$(BuildDir)/Unity.Mono</OutputPath>
        <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
    </PropertyGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\..\BepInEx.Core\BepInEx.Core.csproj"/>
        <ProjectReference Include="..\..\..\BepInEx.Preloader.Core\BepInEx.Preloader.Core.csproj"/>
        <ProjectReference Include="..\BepInEx.Unity.Common\BepInEx.Unity.Common.csproj"/>
    </ItemGroup>
    <ItemGroup>
        <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="All"/>
        <PackageReference Include="HarmonyX" Version="2.10.1"/>
    </ItemGroup>
</Project>

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/DoorstopEntrypoint.cs`:

```cs
using System;
using System.IO;
using BepInEx.Preloader.Core;
using BepInEx.Unity.Mono.Preloader;

// ReSharper disable once CheckNamespace
namespace Doorstop;

internal static class Entrypoint
{
    /// <summary>
    ///     The main entrypoint of BepInEx, called from Doorstop.
    /// </summary>
    public static void Start()
    {
        // We set it to the current directory first as a fallback, but try to use the same location as the .exe file.
        var silentExceptionLog = $"preloader_{DateTime.Now:yyyyMMdd_HHmmss_fff}.log";

        try
        {
            EnvVars.LoadVars();

            var gamePath = Path.GetDirectoryName(EnvVars.DOORSTOP_PROCESS_PATH) ?? ".";
            silentExceptionLog = Path.Combine(gamePath, silentExceptionLog);

            // In some versions of Unity 4, Mono tries to resolve BepInEx.dll prematurely because of the call to Paths.SetExecutablePath
            // To prevent that, we have to use reflection and a separate startup class so that we can install required assembly resolvers before the main code
            typeof(Entrypoint).Assembly.GetType($"BepInEx.Unity.Mono.Preloader.{nameof(UnityPreloaderRunner)}")
                              ?.GetMethod(nameof(UnityPreloaderRunner.PreloaderPreMain))
                              ?.Invoke(null, null);
        }
        catch (Exception ex)
        {
            File.WriteAllText(silentExceptionLog, ex.ToString());
        }
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/EntrypointPatcher.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using BepInEx.Bootstrap;
using BepInEx.Configuration;
using BepInEx.Logging;
using BepInEx.Preloader.Core.Patching;
using BepInEx.Unity.Common;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace BepInEx.Unity.Mono.Preloader;

[PatcherPluginInfo("io.bepinex.entrypointpatcher", "BepInEx Entrypoint", "1.0")]
internal class EntrypointPatcher : BasePatcher
{
    private static readonly ConfigEntry<string> ConfigEntrypointAssembly = ConfigFile.CoreConfig.Bind(
     "Preloader.Entrypoint", "Assembly",
     DefaultEntrypointAssembly,
     "The local filename of the assembly to target.");

    private static readonly ConfigEntry<string> ConfigEntrypointType = ConfigFile.CoreConfig.Bind(
     "Preloader.Entrypoint", "Type",
     DefaultEntrypointType,
     "The name of the type in the entrypoint assembly to search for the entrypoint method.");

    private static readonly ConfigEntry<string> ConfigEntrypointMethod = ConfigFile.CoreConfig.Bind(
     "Preloader.Entrypoint", "Method",
     ".cctor",
     "The name of the method in the specified entrypoint assembly and type to hook and load Chainloader from.");

    private static string DefaultEntrypointAssembly =>
        UnityInfo.Version.IsLess(2017) ? "UnityEngine.dll" : "UnityEngine.CoreModule.dll";

    private static string DefaultEntrypointType => UnityInfo.Version.IsLess(5) ? "MonoBehaviour" : "Application";

    private bool HasLoaded { get; set; }

    [TargetAssembly(TargetAssemblyAttribute.AllAssemblies)]
    public bool PatchEntrypoint(ref AssemblyDefinition assembly, string filename)
    {
        if (HasLoaded || filename != ConfigEntrypointAssembly.Value)
            return false;

        if (assembly.MainModule.AssemblyReferences.Any(x => x.Name.Contains("BepInEx")))
            throw new
                Exception("BepInEx has been detected to be patched! Please unpatch before using a patchless variant!");

        var entrypointType = ConfigEntrypointType.Value;
        var entrypointMethod = ConfigEntrypointMethod.Value;

        Log.Log(LogLevel.Debug, $"Hooking chainloader into {entrypointType}::{entrypointMethod}");

        var isCctor = entrypointMethod.IsNullOrWhiteSpace() || entrypointMethod == ".cctor";


        var entryType = assembly.MainModule.Types.FirstOrDefault(x => x.Name == entrypointType);

        if (entryType == null)
            throw new Exception("The entrypoint type is invalid! Please check your config/BepInEx.cfg file");

        var chainloaderAssemblyPath = Path.Combine(Paths.BepInExAssemblyDirectory, "BepInEx.Unity.Mono.dll");

        var readerParameters = new ReaderParameters
        {
            AssemblyResolver = TypeLoader.CecilResolver
        };

        using (var chainloaderAssemblyDefinition =
               AssemblyDefinition.ReadAssembly(chainloaderAssemblyPath, readerParameters))
        {
            var chainloaderType =
                chainloaderAssemblyDefinition.MainModule.Types.First(x => x.Name == "UnityChainloader");

            var originalStartMethod = chainloaderType.EnumerateAllMethods().First(x => x.Name == "StaticStart");

            var startMethod = assembly.MainModule.ImportReference(originalStartMethod);

            var methods = new List<MethodDefinition>();

            if (isCctor)
            {
                var cctor = entryType.Methods.FirstOrDefault(m => m.IsConstructor && m.IsStatic);

                if (cctor == null)
                {
                    cctor = new MethodDefinition(".cctor",
                                                 MethodAttributes.Static | MethodAttributes.Private
                                                                         | MethodAttributes.HideBySig |
                                                                           MethodAttributes.SpecialName
                                                                         | MethodAttributes.RTSpecialName,
                                                 assembly.MainModule.ImportReference(typeof(void)));

                    entryType.Methods.Add(cctor);
                    var il = cctor.Body.GetILProcessor();
                    il.Append(il.Create(OpCodes.Ret));
                }

                methods.Add(cctor);
            }
            else
            {
                methods.AddRange(entryType.Methods.Where(x => x.Name == entrypointMethod));
            }

            if (!methods.Any())
                throw new Exception("The entrypoint method is invalid! Please check your config.ini");

            foreach (var method in methods)
            {
                var il = method.Body.GetILProcessor();

                var ins = il.Body.Instructions.First();

                il.InsertBefore(ins,
                                il.Create(OpCodes.Ldnull)); // gameExePath (always null, we initialize the Paths class in Entrypoint)

                il.InsertBefore(ins,
                                il.Create(OpCodes.Call,
                                          startMethod)); // UnityChainloader.StaticStart(string gameExePath)
            }
        }

        HasLoaded = true;

        return true;
    }

    public override void Finalizer()
    {
        if (!HasLoaded)
            Log.Log(LogLevel.Fatal,
                    $"Failed to patch BepInEx chainloader into assembly '{ConfigEntrypointAssembly.Value}', either due to error or not being able to find it. Is it spelled correctly?");
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/RuntimeFixes/TraceFix.cs`:

```cs
using System;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using HarmonyLib;

namespace BepInEx.Unity.Mono.Preloader.RuntimeFixes;

/// <summary>
///     This exists because the Mono implementation of <see cref="Trace" /> is/was broken, and would call Write directly
///     instead of calling TraceEvent.
/// </summary>
internal static class TraceFix
{
    private static Type TraceImplType;

    private static object ListenersSyncRoot;
    private static TraceListenerCollection Listeners;
    private static PropertyInfo prop_AutoFlush;

    private static bool AutoFlush => (bool) prop_AutoFlush.GetValue(null, null);


    public static void ApplyFix()
    {
        TraceImplType = AppDomain.CurrentDomain.GetAssemblies()
                                 .First(x => x.GetName().Name == "System")
                                 .GetTypes()
                                 .FirstOrDefault(x => x.Name == "TraceImpl");
        // assembly that has already fixed this
        if (TraceImplType == null) return;

        ListenersSyncRoot = AccessTools.Property(TraceImplType, "ListenersSyncRoot").GetValue(null, null);

        Listeners = (TraceListenerCollection) AccessTools.Property(TraceImplType, "Listeners").GetValue(null, null);

        prop_AutoFlush = AccessTools.Property(TraceImplType, "AutoFlush");


        var instance = new Harmony("com.bepis.bepinex.tracefix");

        instance.Patch(
                       typeof(Trace).GetMethod("DoTrace", BindingFlags.Static | BindingFlags.NonPublic),
                       new HarmonyMethod(typeof(TraceFix).GetMethod(nameof(DoTraceReplacement),
                                                                    BindingFlags.Static | BindingFlags.NonPublic)));
    }


    private static bool DoTraceReplacement(string kind, Assembly report, string message)
    {
        var arg = string.Empty;
        try
        {
            arg = report.GetName().Name;
        }
        catch (MethodAccessException) { }

        var type = (TraceEventType) Enum.Parse(typeof(TraceEventType), kind);

        lock (ListenersSyncRoot)
        {
            foreach (var obj in Listeners)
            {
                var traceListener = (TraceListener) obj;
                traceListener.TraceEvent(new TraceEventCache(), arg, type, 0, message);

                if (AutoFlush) traceListener.Flush();
            }
        }

        return false;
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/RuntimeFixes/UnityPatches.cs`:

```cs
using System.IO;
using System.Reflection;
using BepInEx.Unity.Mono.Preloader.Utils;
using HarmonyLib;

namespace BepInEx.Unity.Mono.Preloader.RuntimeFixes;

internal static class UnityPatches
{
    private static Harmony HarmonyInstance { get; set; }

    public static void Apply()
    {
        HarmonyInstance = Harmony.CreateAndPatchAll(typeof(UnityPatches));

        try
        {
            TraceFix.ApplyFix();
        }
        catch { } //ignore everything, if it's thrown an exception, we're using an assembly that has already fixed this
    }

    [HarmonyPrefix]
    [HarmonyPatch(typeof(Assembly), nameof(Assembly.LoadFile), typeof(string))]
    [HarmonyPatch(typeof(Assembly), nameof(Assembly.LoadFrom), typeof(string))]
    public static bool LoadFilePrefix(string __0, ref Assembly __result)
    {
        if (!File.Exists(__0))
            throw new FileNotFoundException(__0);
        __result = MonoAssemblyHelper.Load(__0);
        return false;
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/RuntimeFixes/XTermFix.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Emit;
using HarmonyLib;
using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.Platforms;
using MonoMod.Utils;

namespace BepInEx.Unity.Mono.Preloader.RuntimeFixes;

internal static class XTermFix
{
    public static int intOffset;

    public static void Apply()
    {
        if (PlatformHelper.Is(Platform.Windows))
            return;

        if (typeof(Console).Assembly.GetType("System.ConsoleDriver") == null)
            // Mono version is too old, use our own TTY implementation instead
            return;

        if (AccessTools.Method("System.TermInfoReader:DetermineVersion") != null)
            // Fix has been applied officially
            return;

        // Apparently on older Unity versions (4.x), using Process.Start can run Console..cctor
        // And since MonoMod's PlatformHelper (used by DetourHelper.Native) runs Process.Start to determine ARM/x86 platform,
        // this causes a crash owing to TermInfoReader running before it can be patched and fixed
        // Because Doorstop does not support ARM at the moment, we can get away with just forcing x86 detour platform.
        // TODO: Figure out a way to detect ARM on Unix without running Process.Start
        DetourHelper.Native = new DetourNativeX86Platform();

        var harmony = new Harmony("com.bepinex.xtermfix");

        harmony.Patch(AccessTools.Method("System.TermInfoReader:ReadHeader"),
                      new HarmonyMethod(typeof(XTermFix), nameof(ReadHeaderPrefix)));

        harmony.Patch(AccessTools.Method("System.TermInfoReader:Get", new[] { AccessTools.TypeByName("System.TermInfoNumbers") }),
                      transpiler: new HarmonyMethod(typeof(XTermFix), nameof(GetTermInfoNumbersTranspiler)));

        harmony.Patch(AccessTools.Method("System.TermInfoReader:Get", new[] { AccessTools.TypeByName("System.TermInfoStrings") }),
                      transpiler: new HarmonyMethod(typeof(XTermFix), nameof(GetTermInfoStringsTranspiler)));

        harmony.Patch(AccessTools.Method("System.TermInfoReader:GetStringBytes", new[] { AccessTools.TypeByName("System.TermInfoStrings") }),
                      transpiler: new HarmonyMethod(typeof(XTermFix), nameof(GetTermInfoStringsTranspiler)));

        DetourHelper.Native = null;
    }

    public static int GetInt32(byte[] buffer, int offset)
    {
        int b1 = buffer[offset];
        int b2 = buffer[offset + 1];
        int b3 = buffer[offset + 2];
        int b4 = buffer[offset + 3];

        return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);
    }

    public static short GetInt16(byte[] buffer, int offset)
    {
        int b1 = buffer[offset];
        int b2 = buffer[offset + 1];

        return (short) (b1 | (b2 << 8));
    }

    public static int GetInteger(byte[] buffer, int offset) =>
        intOffset == 2
            ? GetInt16(buffer, offset)
            : GetInt32(buffer, offset);

    public static void DetermineVersion(short magic)
    {
        if (magic == 0x11a)
            intOffset = 2;
        else if (magic == 0x21e)
            intOffset = 4;
        else
            throw new Exception($"Unknown xterm header format: {magic}");
    }

    public static bool ReadHeaderPrefix(byte[] buffer,
                                        ref int position,
                                        ref short ___boolSize,
                                        ref short ___numSize,
                                        ref short ___strOffsets)
    {
        var magic = GetInt16(buffer, position);
        position += 2;
        DetermineVersion(magic);

        // nameSize = GetInt16(buffer, position);
        position += 2;
        ___boolSize = GetInt16(buffer, position);
        position += 2;
        ___numSize = GetInt16(buffer, position);
        position += 2;
        ___strOffsets = GetInt16(buffer, position);
        position += 2;
        // strSize = GetInt16(buffer, position);
        position += 2;

        return false;
    }

    public static IEnumerable<CodeInstruction> GetTermInfoNumbersTranspiler(IEnumerable<CodeInstruction> instructions)
    {
        // This implementation does not seem to have changed so I will be using indexes like the lazy fuck I am

        var list = instructions.ToList();

        list[31] = new CodeInstruction(OpCodes.Ldsfld, AccessTools.Field(typeof(XTermFix), nameof(intOffset)));
        list[36] = new CodeInstruction(OpCodes.Nop);
        list[39] = new CodeInstruction(OpCodes.Call, AccessTools.Method(typeof(XTermFix), nameof(GetInteger)));

        return list;
    }

    public static IEnumerable<CodeInstruction> GetTermInfoStringsTranspiler(IEnumerable<CodeInstruction> instructions)
    {
        // This implementation does not seem to have changed so I will be using indexes like the lazy fuck I am

        var list = instructions.ToList();

        list[32] = new CodeInstruction(OpCodes.Ldsfld, AccessTools.Field(typeof(XTermFix), nameof(intOffset)));

        return list;
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/UnityPreloader.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using BepInEx.Bootstrap;
using BepInEx.Configuration;
using BepInEx.Logging;
using BepInEx.Preloader.Core;
using BepInEx.Preloader.Core.Logging;
using BepInEx.Preloader.Core.Patching;
using BepInEx.Preloader.RuntimeFixes;
using BepInEx.Unity.Common;
using BepInEx.Unity.Mono.Preloader.RuntimeFixes;
using BepInEx.Unity.Mono.Preloader.Utils;

namespace BepInEx.Unity.Mono.Preloader;

/// <summary>
///     The main entrypoint of BepInEx, and initializes all patchers and the chainloader.
/// </summary>
internal static class UnityPreloader
{
    #region Config

    internal static readonly ConfigEntry<bool> ConfigApplyRuntimePatches = ConfigFile.CoreConfig.Bind(
     "Preloader", "ApplyRuntimePatches",
     true,
     "Enables or disables runtime patches.\nThis should always be true, unless you cannot start the game due to a Harmony related issue (such as running .NET Standard runtime) or you know what you're doing.");

    #endregion

    /// <summary>
    ///     The log writer that is specific to the preloader.
    /// </summary>
    private static PreloaderConsoleListener PreloaderLog { get; set; }

    private static ManualLogSource Log => PreloaderLogger.Log;

    public static void Run()
    {
        try
        {
            HarmonyBackendFix.Initialize();
            UnityInfo.Initialize(Paths.ExecutablePath, Paths.GameDataPath);

            ConsoleManager.Initialize(false, false);
            AllocateConsole();

            Utility.TryDo(() =>
            {
                if (ConfigApplyRuntimePatches.Value)
                    UnityPatches.Apply();
            }, out var runtimePatchException);

            Logger.Sources.Add(new HarmonyLogSource());
            Logger.Sources.Add(TraceLogSource.CreateSource());

            PreloaderLog = new PreloaderConsoleListener();
            Logger.Listeners.Add(PreloaderLog);

            ChainloaderLogHelper.PrintLogInfo(Log);
            Log.Log(LogLevel.Info, $"Running under Unity {UnityInfo.Version}");
            Log.Log(LogLevel.Info, $"CLR runtime version: {Environment.Version}");
            Log.Log(LogLevel.Info, $"Supports SRE: {Utility.CLRSupportsDynamicAssemblies}");

            Log.Log(LogLevel.Debug, $"Game executable path: {Paths.ExecutablePath}");
            Log.Log(LogLevel.Debug, $"Unity Managed directory: {Paths.ManagedPath}");
            Log.Log(LogLevel.Debug, $"BepInEx root path: {Paths.BepInExRootPath}");

            if (runtimePatchException != null)
                Log.Log(LogLevel.Warning,
                        $"Failed to apply runtime patches for Mono. See more info in the output log. Error message: {runtimePatchException.Message}");

            Log.Log(LogLevel.Message, "Preloader started");

            TypeLoader.SearchDirectories.UnionWith(Paths.DllSearchPaths);

            using (var assemblyPatcher = new AssemblyPatcher(MonoAssemblyHelper.LoadFromMemory))
            {
                assemblyPatcher.AddPatchersFromDirectory(Paths.BepInExAssemblyDirectory);
                assemblyPatcher.AddPatchersFromDirectory(Paths.PatcherPluginPath);

                Log.Log(LogLevel.Info,
                        $"{assemblyPatcher.PatcherContext.PatcherPlugins.Count} patcher plugin{(assemblyPatcher.PatcherContext.PatcherPlugins.Count == 1 ? "" : "s")} loaded");

                assemblyPatcher.LoadAssemblyDirectories(Paths.DllSearchPaths);

                Log.Log(LogLevel.Info,
                        $"{assemblyPatcher.PatcherContext.AvailableAssemblies.Count} assemblies discovered");

                assemblyPatcher.PatchAndLoad();
            }

            Log.Log(LogLevel.Message, "Preloader finished");
            Logger.Listeners.Remove(PreloaderLog);
            PreloaderLog.Dispose();
        }
        catch (Exception ex)
        {
            try
            {
                Log.Log(LogLevel.Fatal, "Could not run preloader!");
                Log.Log(LogLevel.Fatal, ex);

                if (!ConsoleManager.ConsoleActive)
                {
                    //if we've already attached the console, then the log will already be written to the console
                    AllocateConsole();
                    Console.Write(PreloaderLog);
                }
            }
            catch { }

            var log = string.Empty;

            try
            {
                // We could use platform-dependent newlines, however the developers use Windows so this will be easier to read :)

                log = string.Join("\r\n", PreloaderConsoleListener.LogEvents.Select(x => x.ToString()).ToArray());
                log += "\r\n";

                PreloaderLog?.Dispose();
                PreloaderLog = null;
            }
            catch { }

            File.WriteAllText(
                              Path.Combine(Paths.GameRootPath, $"preloader_{DateTime.Now:yyyyMMdd_HHmmss_fff}.log"),
                              log + ex);
        }
    }

    /// <summary>
    ///     Allocates a console window for use by BepInEx safely.
    /// </summary>
    public static void AllocateConsole()
    {
        if (!ConsoleManager.ConsoleEnabled)
            return;

        try
        {
            ConsoleManager.CreateConsole();
            Logger.Listeners.Add(new ConsoleLogListener());
        }
        catch (Exception ex)
        {
            Log.LogError("Failed to allocate console!");
            Log.LogError(ex);
        }
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/UnityPreloaderRunner.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using BepInEx.Preloader.Core;
using BepInEx.Preloader.RuntimeFixes;
using BepInEx.Unity.Mono.Preloader.RuntimeFixes;
using BepInEx.Unity.Mono.Preloader.Utils;

namespace BepInEx.Unity.Mono.Preloader;

internal static class UnityPreloaderRunner
{
    // This is a list of important assemblies in BepInEx core folder that should be force-loaded
    // Some games can ship these assemblies in Managed folder, in which case assembly resolving bypasses our LocalResolve
    // On the other hand, renaming these assemblies is not viable because 3rd party assemblies
    // that we don't build (e.g. MonoMod, Harmony, many plugins) depend on them
    // As such, we load them early so that the game uses our version instead
    // These assemblies should be known to be rarely edited and are known to be shipped as-is with Unity assets
    private static readonly string[] CriticalAssemblies =
    {
        "Mono.Cecil.dll",
        "Mono.Cecil.Mdb.dll",
        "Mono.Cecil.Pdb.dll",
        "Mono.Cecil.Rocks.dll"
    };

    private static void LoadCriticalAssemblies()
    {
        foreach (var criticalAssembly in CriticalAssemblies)
            try
            {
                MonoAssemblyHelper.Load(Path.Combine(Paths.BepInExAssemblyDirectory, criticalAssembly));
            }
            catch (Exception)
            {
                // Suppress error for now
                // TODO: Should we crash here if load fails? Can't use logging at this point
            }
    }

    public static void PreloaderPreMain()
    {
        PlatformUtils.SetPlatform();

        var bepinPath = Utility.ParentDirectory(Path.GetFullPath(EnvVars.DOORSTOP_INVOKE_DLL_PATH), 2);

        Paths.SetExecutablePath(EnvVars.DOORSTOP_PROCESS_PATH,
                                bepinPath,
                                EnvVars.DOORSTOP_MANAGED_FOLDER_DIR,
                                true,
                                EnvVars.DOORSTOP_DLL_SEARCH_DIRS);

        LoadCriticalAssemblies();
        AppDomain.CurrentDomain.AssemblyResolve += LocalResolve;
        PreloaderMain();
    }

    private static void PreloaderMain()
    {
        if (UnityPreloader.ConfigApplyRuntimePatches.Value)
        {
            XTermFix.Apply();
            ConsoleSetOutFix.Apply();
        }

        UnityPreloader.Run();
    }

    private static Assembly LocalResolve(object sender, ResolveEventArgs args)
    {
        if (!Utility.TryParseAssemblyName(args.Name, out var assemblyName))
            return null;

        // Use parse assembly name on managed side because native GetName() can fail on some locales
        // if the game path has "exotic" characters

        var validAssemblies = AppDomain.CurrentDomain
                                       .GetAssemblies()
                                       .Select(a => new
                                       {
                                           assembly = a,
                                           name = Utility.TryParseAssemblyName(a.FullName, out var name)
                                                      ? name
                                                      : null
                                       })
                                       .Where(a => a.name != null && a.name.Name == assemblyName.Name)
                                       .OrderByDescending(a => a.name.Version)
                                       .ToList();

        // First try to match by version, then just pick the best match (generally highest)
        // This should mainly affect cases where the game itself loads some assembly (like Mono.Cecil) 
        var foundMatch = validAssemblies.FirstOrDefault(a => a.name.Version == assemblyName.Version) ??
                         validAssemblies.FirstOrDefault();
        var foundAssembly = foundMatch?.assembly;

        if (foundAssembly != null)
            return foundAssembly;

        if (MonoAssemblyHelper.TryResolveDllAssembly(assemblyName, Paths.BepInExAssemblyDirectory, out foundAssembly)
         || MonoAssemblyHelper.TryResolveDllAssembly(assemblyName, Paths.PatcherPluginPath, out foundAssembly)
         || MonoAssemblyHelper.TryResolveDllAssembly(assemblyName, Paths.PluginPath, out foundAssembly))
            return foundAssembly;

        return null;
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono.Preloader/Utils/MonoAssemblyHelper.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using BepInEx.Preloader.Core;
using Mono.Cecil;
using MonoMod.Utils;

namespace BepInEx.Unity.Mono.Preloader.Utils;

internal static class MonoAssemblyHelper
{
    static MonoAssemblyHelper()
    {
        // We can't use mono's __Internal because on Windows it will use GetModuleHandleW(NULL) that will
        // in turn return the module to the EXE and not mono.dll (at least on Unity versions < 5).
        typeof(MonoAssemblyHelper).ResolveDynDllImports(new()
        {
            ["mono"] = new()
            {
                EnvVars.DOORSTOP_MONO_LIB_PATH
            }
        });
    }

    private static ReadAssemblyResult ReadAssemblyData(string filePath)
    {
        return ReadAssemblyData(File.ReadAllBytes(filePath));
    }

    private static ReadAssemblyResult ReadAssemblyData(byte[] assemblyData)
    {
        using var ms = new MemoryStream(assemblyData);
        using var ad = AssemblyDefinition.ReadAssembly(ms);

        return new ReadAssemblyResult
        {
            AssemblyName = ad.Name.Name,
            AssemblyData = assemblyData
        };
    }

    private static Assembly GetAssemblyByName(string assemblyName)
    {
        return AppDomain.CurrentDomain.GetAssemblies()
                        .FirstOrDefault(a => Utility.TryParseAssemblyName(a.FullName, out var name) &&
                                             name.Name == assemblyName);
    }

    public static bool TryResolveDllAssembly(AssemblyName assemblyName, string directory, out Assembly assembly) =>
        Utility.TryResolveDllAssembly(assemblyName, directory, Load, out assembly);

    public static Assembly LoadFromMemory(byte[] data, string filePath)
    {
        var fullPath = Path.GetFullPath(filePath);
        return ReadAssemblyData(data).Load(fullPath);
    }

    public static Assembly Load(string filePath)
    {
        var fullPath = Path.GetFullPath(filePath);
        return ReadAssemblyData(fullPath).Load(fullPath);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate nint ImageOpenDelegate(nint data,
                                            uint dataLength,
                                            bool needCopy,
                                            out MonoImageOpenStatus status,
                                            bool refOnly,
                                            [MarshalAs(UnmanagedType.LPStr)] string name);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate nint AssemblyLoadDelegate(nint image,
                                               [MarshalAs(UnmanagedType.LPStr)] string fileName,
                                               out MonoImageOpenStatus status,
                                               bool refOnly);

    private enum MonoImageOpenStatus
    {
        MONO_IMAGE_OK,
        MONO_IMAGE_ERROR_ERRNO,
        MONO_IMAGE_MISSING_ASSEMBLYREF,
        MONO_IMAGE_IMAGE_INVALID
    }

    private class ReadAssemblyResult
    {
        public byte[] AssemblyData;
        public string AssemblyName;

        public unsafe Assembly Load(string fullPath)
        {
            var assembly = GetAssemblyByName(AssemblyName);
            if (assembly != null)
                return assembly;

            fixed (byte* data = &AssemblyData[0])
            {
                var image = imageOpen((nint) data, (uint) AssemblyData.Length, true,
                                      out var status, false, fullPath);
                if (status != MonoImageOpenStatus.MONO_IMAGE_OK)
                    throw new BadImageFormatException($"Failed to load image {fullPath}: {status}");
                assemblyLoad(image, fullPath, out status, false);
                if (status != MonoImageOpenStatus.MONO_IMAGE_OK)
                    throw new BadImageFormatException($"Failed to load assembly {fullPath}: {status}");
                return GetAssemblyByName(AssemblyName);
            }
        }
    }
#pragma warning disable CS0649
    [DynDllImport("mono", "mono_image_open_from_data_with_name")]
    private static ImageOpenDelegate imageOpen;

    [DynDllImport("mono", "mono_assembly_load_from_full")]
    private static AssemblyLoadDelegate assemblyLoad;
#pragma warning restore CS0649
}

```

`Runtimes/Unity/BepInEx.Unity.Mono/BaseUnityPlugin.cs`:

```cs
using System;
using BepInEx.Configuration;
using BepInEx.Logging;
using UnityEngine;

namespace BepInEx.Unity.Mono;

/// <summary>
///     The base plugin type that is used by the BepInEx plugin loader.
/// </summary>
public abstract class BaseUnityPlugin : MonoBehaviour
{
    /// <summary>
    ///     Create a new instance of a plugin and all of its tied in objects.
    /// </summary>
    /// <exception cref="InvalidOperationException">BepInPlugin attribute is missing.</exception>
    protected BaseUnityPlugin()
    {
        var metadata = MetadataHelper.GetMetadata(this);
        if (metadata == null)
            throw new InvalidOperationException("Can't create an instance of " + GetType().FullName +
                                                " because it inherits from BaseUnityPlugin and the BepInPlugin attribute is missing.");

        Info = new PluginInfo
        {
            Metadata = metadata,
            Instance = this,
            Dependencies = MetadataHelper.GetDependencies(GetType()),
            Processes = MetadataHelper.GetAttributes<BepInProcess>(GetType()),
            Location = GetType().Assembly.Location
        };

        Logger = BepInEx.Logging.Logger.CreateLogSource(metadata.Name);

        Config = new ConfigFile(Utility.CombinePaths(Paths.ConfigPath, metadata.GUID + ".cfg"), false, metadata);
    }

    /// <summary>
    ///     Information about this plugin as it was loaded.
    /// </summary>
    public PluginInfo Info { get; }

    /// <summary>
    ///     Logger instance tied to this plugin.
    /// </summary>
    protected ManualLogSource Logger { get; }

    /// <summary>
    ///     Default config file tied to this plugin. The config file will not be created until
    ///     any settings are added and changed, or <see cref="ConfigFile.Save" /> is called.
    /// </summary>
    public ConfigFile Config { get; }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono/BepInEx.Unity.Mono.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <Description>BepInEx support library for Mono Unity games</Description>
        <TargetFrameworks>net35;netstandard2.0</TargetFrameworks>
        <AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFramework)' == 'net35'">
        <!-- Output only net35 version to distribution; netstadnard is only used for generating NuGet package -->
        <OutputPath>$(BuildDir)/Unity.Mono</OutputPath>
        <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
    </PropertyGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\..\BepInEx.Core\BepInEx.Core.csproj"/>
        <ProjectReference Include="..\..\..\BepInEx.Preloader.Core\BepInEx.Preloader.Core.csproj" PrivateAssets="All"/>
        <ProjectReference Include="..\BepInEx.Unity.Mono.Preloader\BepInEx.Unity.Mono.Preloader.csproj" PrivateAssets="All"/>
    </ItemGroup>
    <ItemGroup>
        <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="All"/>
        <PackageReference Include="HarmonyX" Version="2.10.1"/>
        <PackageReference Include="UnityEngine" Version="5.6.1" IncludeAssets="compile"/>
    </ItemGroup>
</Project>

```

`Runtimes/Unity/BepInEx.Unity.Mono/BepInExInstance.cs`:

```cs
using BepInEx.Unity.Mono.Bootstrap;

namespace BepInEx.Unity.Mono;

public static class BepInExInstance
{
    public static UnityChainloader Chainloader { get; }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono/Bootstrap/UnityChainloader.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using BepInEx.Bootstrap;
using BepInEx.Configuration;
using BepInEx.Logging;
using BepInEx.Preloader.Core.Logging;
using BepInEx.Unity.Common;
using BepInEx.Unity.Mono.Logging;
using UnityEngine;
using Logger = BepInEx.Logging.Logger;
using Object = UnityEngine.Object;

[assembly: InternalsVisibleTo("UnityEngine")]
[assembly: InternalsVisibleTo("UnityEngine.Core")]

namespace BepInEx.Unity.Mono.Bootstrap;

/// <summary>
///     The manager and loader for all plugins, and the entry point for BepInEx plugin system.
/// </summary>
public class UnityChainloader : BaseChainloader<BaseUnityPlugin>
{
    private static readonly ConfigEntry<bool> ConfigUnityLogging = ConfigFile.CoreConfig.Bind(
     "Logging", "UnityLogListening",
     true,
     "Enables showing unity log messages in the BepInEx logging system.");

    private static readonly ConfigEntry<bool> ConfigDiskWriteUnityLog = ConfigFile.CoreConfig.Bind(
     "Logging.Disk", "WriteUnityLog",
     false,
     "Include unity log messages in log file output.");

    private static readonly bool staticStartHasBeenCalled = false;

    private string _consoleTitle;

    // TODO: Remove once proper instance handling exists
    public static UnityChainloader Instance { get; set; }

    /// <summary>
    ///     The GameObject that all plugins are attached to as components.
    /// </summary>
    public static GameObject ManagerObject { get; private set; }

    protected override string ConsoleTitle => _consoleTitle;


    // In some rare cases calling Application.unityVersion seems to cause MissingMethodException
    // if a preloader patch applies Harmony patch to Chainloader.Initialize.
    // The issue could be related to BepInEx being compiled against Unity 5.6 version of UnityEngine.dll,
    // but the issue is apparently present with both official Harmony and HarmonyX
    // We specifically prevent inlining to prevent early resolving
    // TODO: Figure out better version obtaining mechanism (e.g. from globalmanagers)
    private static string UnityVersion
    {
        [MethodImpl(MethodImplOptions.NoInlining)]
        get => Application.unityVersion;
    }

    [Obsolete("This method is public due to a limitation with Unity 4.x. DO NOT CALL", true)]
    public static void StaticStart(string gameExePath = null)
    {
        try
        {
            if (staticStartHasBeenCalled)
                throw new InvalidOperationException("Cannot call StaticStart again");

            Logger.Log(LogLevel.Debug, "Entering chainloader StaticStart");

            var instance = new UnityChainloader();
            instance.Initialize(gameExePath);
            instance.Execute();

            Logger.Log(LogLevel.Debug, "Exiting chainloader StaticStart");
        }
        catch (Exception ex)
        {
            Logger.Log(LogLevel.Fatal, $"Unable to complete chainloader StaticStart: {ex.Message}");
            Logger.Log(LogLevel.Fatal, ex.StackTrace);
        }
    }

    public override void Initialize(string gameExePath = null)
    {
        try
        {
            Logger.Log(LogLevel.Debug, "Entering chainloader initialize");

            Instance = this;

            UnityTomlTypeConverters.AddUnityEngineConverters();

            Logger.Log(LogLevel.Debug, "Initializing ThreadingHelper");
            ThreadingHelper.Initialize();

            Logger.Log(LogLevel.Debug, "Creating Manager object");
            ManagerObject = new GameObject("BepInEx_Manager") { hideFlags = HideFlags.HideAndDontSave };
            Object.DontDestroyOnLoad(ManagerObject);

            Logger.Log(LogLevel.Debug, "Getting game product name");
            var productNameProp =
                typeof(Application).GetProperty("productName", BindingFlags.Public | BindingFlags.Static);
            _consoleTitle =
                $"{CurrentAssemblyName} {CurrentAssemblyVersion} - {productNameProp?.GetValue(null, null) ?? Path.GetFileNameWithoutExtension(Process.GetCurrentProcess().ProcessName)}";

            Logger.Log(LogLevel.Debug, "Falling back to BaseChainloader initializer");

            base.Initialize(gameExePath);

            Logger.Log(LogLevel.Debug, "Exiting chainloader initialize");
        }
        catch (Exception ex)
        {
            Logger.Log(LogLevel.Fatal, $"Unable to complete chainloader init: {ex.Message}");
            Logger.Log(LogLevel.Fatal, ex.StackTrace);
        }
    }

    protected override void InitializeLoggers()
    {
        base.InitializeLoggers();

        Logger.Listeners.Add(new UnityLogListener());

        // Update version info from runtime in case it wasn't set yet
        var prevVersion = UnityInfo.Version;
        UnityInfo.SetRuntimeUnityVersion(UnityVersion);
        if (UnityInfo.Version != prevVersion)
            Logger.Log(LogLevel.Info, $"UnityPlayer version: {UnityInfo.Version}");

        if (!ConfigDiskWriteUnityLog.Value) DiskLogListener.BlacklistedSources.Add("Unity Log");

        ChainloaderLogHelper.RewritePreloaderLogs();

        if (ConfigUnityLogging.Value)
            Logger.Sources.Add(new UnityLogSource());
    }

    public override BaseUnityPlugin LoadPlugin(PluginInfo pluginInfo, Assembly pluginAssembly) =>
        (BaseUnityPlugin) ManagerObject.AddComponent(pluginAssembly.GetType(pluginInfo.TypeName));
}

```

`Runtimes/Unity/BepInEx.Unity.Mono/Configuration/KeyboardShortcut.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using BepInEx.Configuration;
using BepInEx.Logging;
using UnityEngine;
using Logger = BepInEx.Logging.Logger;

namespace BepInEx.Unity.Mono.Configuration;

/// <summary>
///     A keyboard shortcut that can be used in Update method to check if user presses a key combo. The shortcut is only
///     triggered when the user presses the exact combination. For example, <c>F + LeftCtrl</c> will trigger only if user
///     presses and holds only LeftCtrl, and then presses F. If any other keys are pressed, the shortcut will not trigger.
///     Can be used as a value of a setting in <see cref="ConfigFile.Bind{T}(ConfigDefinition,T,ConfigDescription)" />
///     to allow user to change this shortcut and have the changes saved.
///     How to use: Use <see cref="IsDown" /> in this class instead of <see cref="Input.GetKeyDown(KeyCode)" /> in the
///     Update loop.
/// </summary>
public struct KeyboardShortcut
{
    static KeyboardShortcut()
    {
        TomlTypeConverter.AddConverter(
                                       typeof(KeyboardShortcut),
                                       new TypeConverter
                                       {
                                           ConvertToString = (o, type) => ((KeyboardShortcut) o).Serialize(),
                                           ConvertToObject = (s, type) => Deserialize(s)
                                       });
    }

    /// <summary>
    ///     Shortcut that never triggers.
    /// </summary>
    public static readonly KeyboardShortcut Empty = new();

    /// <summary>
    ///     All KeyCode values that can be used in a keyboard shortcut.
    /// </summary>
    public static readonly IEnumerable<KeyCode> AllKeyCodes = (KeyCode[]) Enum.GetValues(typeof(KeyCode));

    // Don't block hotkeys if mouse is being pressed, e.g. when shooting and trying to strafe
    private static readonly KeyCode[] _modifierBlockKeyCodes = AllKeyCodes.Except(new[]
    {
        KeyCode.Mouse0, KeyCode.Mouse1, KeyCode.Mouse2, KeyCode.Mouse3, KeyCode.Mouse4, KeyCode.Mouse5,
        KeyCode.Mouse6, KeyCode.None
    }).ToArray();

    private readonly KeyCode[] _allKeys;

    /// <summary>
    ///     Create a new keyboard shortcut.
    /// </summary>
    /// <param name="mainKey">Main key to press</param>
    /// <param name="modifiers">Keys that should be held down before main key is registered</param>
    public KeyboardShortcut(KeyCode mainKey, params KeyCode[] modifiers) : this(new[] { mainKey }.Concat(modifiers)
                                                                                    .ToArray())
    {
        if (mainKey == KeyCode.None && modifiers.Any())
            throw new
                ArgumentException($"Can't set {nameof(mainKey)} to KeyCode.None if there are any {nameof(modifiers)}");
    }

    private KeyboardShortcut(KeyCode[] keys)
    {
        _allKeys = SanitizeKeys(keys);
    }

    private static KeyCode[] SanitizeKeys(params KeyCode[] keys)
    {
        if (keys.Length == 0 || keys[0] == KeyCode.None)
            return new[] { KeyCode.None };

        return new[] { keys[0] }.Concat(keys.Skip(1).Distinct().Where(x => x != keys[0]).OrderBy(x => (int) x))
                                .ToArray();
    }

    /// <summary>
    ///     Main key of the key combination. It has to be pressed / let go last for the combination to be triggered.
    ///     If the combination is empty, <see cref="KeyCode.None" /> is returned.
    /// </summary>
    public KeyCode MainKey => _allKeys != null && _allKeys.Length > 0 ? _allKeys[0] : KeyCode.None;

    /// <summary>
    ///     Modifiers of the key combination, if any.
    /// </summary>
    public IEnumerable<KeyCode> Modifiers => _allKeys?.Skip(1) ?? Enumerable.Empty<KeyCode>();

    /// <summary>
    ///     Attempt to deserialize key combination from the string.
    /// </summary>
    public static KeyboardShortcut Deserialize(string str)
    {
        try
        {
            var parts = str.Split(new[] { ' ', '+', ',', ';', '|' }, StringSplitOptions.RemoveEmptyEntries)
                           .Select(x => (KeyCode) Enum.Parse(typeof(KeyCode), x)).ToArray();
            return new KeyboardShortcut(parts);
        }
        catch (SystemException ex)
        {
            Logger.Log(LogLevel.Error, "Failed to read keybind from settings: " + ex.Message);
            return Empty;
        }
    }

    /// <summary>
    ///     Serialize the key combination into a user readable string.
    /// </summary>
    public string Serialize()
    {
        if (_allKeys == null) return string.Empty;
        return string.Join(" + ", _allKeys.Select(x => x.ToString()).ToArray());
    }

    /// <summary>
    ///     Check if the main key was just pressed (Input.GetKeyDown), and specified modifier keys are all pressed
    /// </summary>
    public bool IsDown()
    {
        var mainKey = MainKey;
        if (mainKey == KeyCode.None) return false;

        return Input.GetKeyDown(mainKey) && ModifierKeyTest();
    }

    /// <summary>
    ///     Check if the main key is currently held down (Input.GetKey), and specified modifier keys are all pressed
    /// </summary>
    public bool IsPressed()
    {
        var mainKey = MainKey;
        if (mainKey == KeyCode.None) return false;

        return Input.GetKey(mainKey) && ModifierKeyTest();
    }

    /// <summary>
    ///     Check if the main key was just lifted (Input.GetKeyUp), and specified modifier keys are all pressed.
    /// </summary>
    public bool IsUp()
    {
        var mainKey = MainKey;
        if (mainKey == KeyCode.None) return false;

        return Input.GetKeyUp(mainKey) && ModifierKeyTest();
    }

    private bool ModifierKeyTest()
    {
        var allKeys = _allKeys;
        var mainKey = MainKey;

        var allModifiersPressed = allKeys.All(c => c == mainKey || Input.GetKey(c));
        if (!allModifiersPressed) return false;

        var noOtherModifiersPressed = _modifierBlockKeyCodes.All(c => !Input.GetKey(c) || allKeys.Contains(c));
        return noOtherModifiersPressed;
    }

    /// <inheritdoc />
    public override string ToString()
    {
        if (MainKey == KeyCode.None) return "Not set";

        return string.Join(" + ", _allKeys.Select(c => c.ToString()).ToArray());
    }

    /// <inheritdoc />
    public override bool Equals(object obj) =>
        obj is KeyboardShortcut shortcut && MainKey == shortcut.MainKey &&
        Modifiers.SequenceEqual(shortcut.Modifiers);

    /// <inheritdoc />
    public override int GetHashCode()
    {
        if (MainKey == KeyCode.None) return 0;

        return _allKeys.Aggregate(_allKeys.Length, (current, item) => unchecked(current * 31 + (int) item));
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono/Logging/UnityLogListener.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using BepInEx.Configuration;
using BepInEx.Logging;
using UnityEngine;
using Logger = BepInEx.Logging.Logger;

namespace BepInEx.Unity.Mono.Logging
{
    /// <summary>
    ///     Logs entries using Unity specific outputs.
    /// </summary>
    public class UnityLogListener : ILogListener
    {
        internal static readonly Action<string> WriteStringToUnityLog;

        protected static readonly ConfigEntry<LogLevel> ConfigUnityLogLevel = ConfigFile.CoreConfig.Bind(
         "Logging.Unity", "LogLevels",
         LogLevel.Fatal | LogLevel.Error | LogLevel.Warning | LogLevel.Message | LogLevel.Info,
         "What log levels to log to Unity's output log.");

        private readonly ConfigEntry<bool> LogConsoleToUnity = ConfigFile.CoreConfig.Bind("Logging",
            "LogConsoleToUnityLog", false,
            new StringBuilder()
                .AppendLine("If enabled, writes Standard Output messages to Unity log")
                .AppendLine("NOTE: By default, Unity does so automatically. Only use this option if no console messages are visible in Unity log")
                .ToString());

        static UnityLogListener()
        {
            foreach (var methodInfo in typeof(UnityLogWriter).GetMethods(BindingFlags.Static | BindingFlags.Public))
            {
                try
                {
                    methodInfo.Invoke(null, new object[] { "" });
                }
                catch
                {
                    continue;
                }

                WriteStringToUnityLog = (Action<string>) Delegate.CreateDelegate(typeof(Action<string>), methodInfo);
                break;
            }

            if (WriteStringToUnityLog == null)
                Logger.Log(LogLevel.Error, "Unable to start Unity log writer");
        }

        /// <inheritdoc />
        public LogLevel LogLevelFilter => ConfigUnityLogLevel.Value;

        /// <inheritdoc />
        public void LogEvent(object sender, LogEventArgs eventArgs)
        {
            if (eventArgs.Source is UnityLogSource)
                return;

            // Special case: don't write console twice since Unity can already do that
            if (LogConsoleToUnity.Value || eventArgs.Source.SourceName != "Console")
                WriteStringToUnityLog?.Invoke(eventArgs.ToStringLine());
        }

        /// <inheritdoc />
        public void Dispose() { }
    }
}

namespace UnityEngine
{
    internal sealed class UnityLogWriter
    {
        [MethodImpl(MethodImplOptions.InternalCall)]
        public static extern void WriteStringToUnityLogImpl(string s);

        [MethodImpl(MethodImplOptions.InternalCall)]
        public static extern void WriteStringToUnityLog(string s);
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono/Logging/UnityLogSource.cs`:

```cs
using System;
using System.Reflection;
using BepInEx.Logging;
using UnityEngine;

namespace BepInEx.Unity.Mono.Logging;

/// <summary>
///     Logs entries using Unity specific outputs.
/// </summary>
public class UnityLogSource : ILogSource
{
    private bool disposed;

    /// <summary>
    ///     Creates a new Unity log source.
    /// </summary>
    public UnityLogSource()
    {
        InternalUnityLogMessage += UnityLogMessageHandler;
    }

    /// <inheritdoc />
    public string SourceName { get; } = "Unity Log";

    /// <inheritdoc />
    public event EventHandler<LogEventArgs> LogEvent;

    /// <inheritdoc />
    public void Dispose()
    {
        if (!disposed)
        {
            InternalUnityLogMessage -= UnityLogMessageHandler;
            disposed = true;
        }
    }

    private void UnityLogMessageHandler(object sender, LogEventArgs eventArgs)
    {
        var newEventArgs = new LogEventArgs(eventArgs.Data, eventArgs.Level, this);
        LogEvent?.Invoke(this, newEventArgs);
    }

    #region Static Unity handler

    private static event EventHandler<LogEventArgs> InternalUnityLogMessage;

    static UnityLogSource()
    {
        var callback = new Application.LogCallback(OnUnityLogMessageReceived);

        var logEvent =
            typeof(Application).GetEvent("logMessageReceived", BindingFlags.Public | BindingFlags.Static);
        if (logEvent != null)
        {
            logEvent.AddEventHandler(null, callback);
            //UnsubscribeAction = () => logEvent.RemoveEventHandler(null, callback);
        }
        else
        {
            var registerLogCallback =
                typeof(Application).GetMethod("RegisterLogCallback", BindingFlags.Public | BindingFlags.Static);
            registerLogCallback.Invoke(null, new object[] { callback });
            //UnsubscribeAction = () => registerLogCallback.Invoke(null, new object[] { null });
        }
    }

    private static void OnUnityLogMessageReceived(string message, string stackTrace, LogType type)
    {
        LogLevel logLevel;

        switch (type)
        {
            case LogType.Error:
            case LogType.Assert:
            case LogType.Exception:
                logLevel = LogLevel.Error;
                break;
            case LogType.Warning:
                logLevel = LogLevel.Warning;
                break;
            case LogType.Log:
            default:
                logLevel = LogLevel.Info;
                break;
        }

        if (type == LogType.Exception)
            message += $"\nStack trace:\n{stackTrace}";

        InternalUnityLogMessage?.Invoke(null, new LogEventArgs(message, logLevel, null));
    }

    #endregion
}

```

`Runtimes/Unity/BepInEx.Unity.Mono/ThreadingHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Threading;
using BepInEx.Logging;
using UnityEngine;
using Logger = BepInEx.Logging.Logger;

namespace BepInEx.Unity.Mono;

/// <summary>
///     Provides methods for running code on other threads and synchronizing with the main thread.
/// </summary>
public sealed class ThreadingHelper : MonoBehaviour, ISynchronizeInvoke
{
    private readonly object _invokeLock = new();
    private Action _invokeList;
    private Thread _mainThread;

    /// <summary>
    ///     Current instance of the helper.
    /// </summary>
    public static ThreadingHelper Instance { get; private set; }

    /// <summary>
    ///     Gives methods for invoking delegates on the main unity thread, both synchronously and asynchronously.
    ///     Can be used in many built-in framework types, for example
    ///     <see cref="System.IO.FileSystemWatcher.SynchronizingObject" />
    ///     and <see cref="System.Timers.Timer.SynchronizingObject" /> to make their events fire on the main unity thread.
    /// </summary>
    public static ISynchronizeInvoke SynchronizingObject => Instance;

    private void Update()
    {
        // The CurrentThread can change between Awake and later methods, it's safest to get it here.
        if (_mainThread == null)
            _mainThread = Thread.CurrentThread;

        // Safe to do outside of lock because nothing can remove callbacks, at worst we execute with 1 frame delay
        if (_invokeList == null) return;

        Action toRun;
        lock (_invokeLock)
        {
            toRun = _invokeList;
            _invokeList = null;
        }

        // Need to execute outside of the lock in case the callback itself calls Invoke we could deadlock
        // The invocation would also block any threads that call Invoke
        foreach (var action in toRun.GetInvocationList().Cast<Action>())
            try
            {
                action();
            }
            catch (Exception ex)
            {
                LogInvocationException(ex);
            }
    }

    internal static void Initialize()
    {
        var go = new GameObject("BepInEx_ThreadingHelper") { hideFlags = HideFlags.HideAndDontSave };
        DontDestroyOnLoad(go);
        Instance = go.AddComponent<ThreadingHelper>();
    }

    /// <summary>
    ///     Queue the delegate to be invoked on the main unity thread. Use to synchronize your threads.
    /// </summary>
    public void StartSyncInvoke(Action action)
    {
        if (action == null) throw new ArgumentNullException(nameof(action));

        lock (_invokeLock)
        {
            _invokeList += action;
        }
    }

    /// <summary>
    ///     Queue the delegate to be invoked on a background thread. Use this to run slow tasks without affecting the game.
    ///     NOTE: Most of Unity API can not be accessed while running on another thread!
    /// </summary>
    /// <param name="action">
    ///     Task to be executed on another thread. Can optionally return an Action that will be executed on the main thread.
    ///     You can use this action to return results of your work safely. Return null if this is not needed.
    /// </param>
    public void StartAsyncInvoke(Func<Action> action)
    {
        void DoWork(object _)
        {
            try
            {
                var result = action();

                if (result != null)
                    StartSyncInvoke(result);
            }
            catch (Exception ex)
            {
                LogInvocationException(ex);
            }
        }

        if (!ThreadPool.QueueUserWorkItem(DoWork))
            throw new NotSupportedException("Failed to queue the action on ThreadPool");
    }

    private static void LogInvocationException(Exception ex)
    {
        Logger.Log(LogLevel.Error, ex);
        if (ex.InnerException != null) Logger.Log(LogLevel.Error, $"INNER: {ex.InnerException}");
    }

    #region ISynchronizeInvoke

    IAsyncResult ISynchronizeInvoke.BeginInvoke(Delegate method, object[] args)
    {
        var result = new InvokeResult();

        object Invoke()
        {
            try
            {
                return method.DynamicInvoke(args);
            }
            catch (Exception ex)
            {
                result.ExceptionThrown = true;
                return ex;
            }
        }

        if (!InvokeRequired)
            result.Finish(Invoke(), true);
        else
            StartSyncInvoke(() => result.Finish(Invoke(), false));

        return result;
    }

    object ISynchronizeInvoke.EndInvoke(IAsyncResult result)
    {
        var invokeResult = (InvokeResult) result;
        invokeResult.AsyncWaitHandle.WaitOne();

        if (invokeResult.ExceptionThrown)
            throw (Exception) invokeResult.AsyncState;
        return invokeResult.AsyncState;
    }

    object ISynchronizeInvoke.Invoke(Delegate method, object[] args)
    {
        var invokeResult = ((ISynchronizeInvoke) this).BeginInvoke(method, args);
        return ((ISynchronizeInvoke) this).EndInvoke(invokeResult);
    }

    /// <summary>
    ///     False if current code is executing on the main unity thread, otherwise True.
    ///     Warning: Will return true before the first frame finishes (i.e. inside plugin Awake and Start methods).
    /// </summary>
    /// <inheritdoc />
    public bool InvokeRequired => _mainThread == null || _mainThread != Thread.CurrentThread;

    private sealed class InvokeResult : IAsyncResult
    {
        internal bool ExceptionThrown;

        public InvokeResult()
        {
            AsyncWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        }

        public bool IsCompleted { get; private set; }
        public WaitHandle AsyncWaitHandle { get; }
        public object AsyncState { get; private set; }
        public bool CompletedSynchronously { get; private set; }

        public void Finish(object result, bool completedSynchronously)
        {
            AsyncState = result;
            CompletedSynchronously = completedSynchronously;
            IsCompleted = true;
            ((EventWaitHandle) AsyncWaitHandle).Set();
        }
    }

    #endregion
}

/// <summary>
///     Convenience extensions for utilizing multiple threads and using the <see cref="ThreadingHelper" />.
/// </summary>
public static class ThreadingExtensions
{
    /// <inheritdoc cref="RunParallel{TIn,TOut}(IList{TIn},Func{TIn,TOut},int)" />
    public static IEnumerable<TOut> RunParallel<TIn, TOut>(this IEnumerable<TIn> data,
                                                           Func<TIn, TOut> work,
                                                           int workerCount = -1)
    {
        foreach (var result in RunParallel(data.ToList(), work))
            yield return result;
    }

    /// <summary>
    ///     Apply a function to a collection of data by spreading the work on multiple threads.
    ///     Outputs of the functions are returned to the current thread and yielded one by one.
    /// </summary>
    /// <typeparam name="TIn">Type of the input values.</typeparam>
    /// <typeparam name="TOut">Type of the output values.</typeparam>
    /// <param name="data">Input values for the work function.</param>
    /// <param name="work">Function to apply to the data on multiple threads at once.</param>
    /// <param name="workerCount">Number of worker threads. By default Environment.ProcessorCount is used.</param>
    /// <exception cref="TargetInvocationException">
    ///     An exception was thrown inside one of the threads, and the operation was
    ///     aborted.
    /// </exception>
    /// <exception cref="ArgumentException">Need at least 1 workerCount.</exception>
    public static IEnumerable<TOut> RunParallel<TIn, TOut>(this IList<TIn> data,
                                                           Func<TIn, TOut> work,
                                                           int workerCount = -1)
    {
        if (workerCount < 0)
            workerCount = Mathf.Max(2, Environment.ProcessorCount);
        else if (workerCount == 0)
            throw new ArgumentException("Need at least 1 worker", nameof(workerCount));

        var perThreadCount = Mathf.CeilToInt(data.Count / (float) workerCount);
        var doneCount = 0;

        var lockObj = new object();
        var are = new ManualResetEvent(false);
        IEnumerable<TOut> doneItems = null;
        Exception exceptionThrown = null;

        // Start threads to process the data
        for (var i = 0; i < workerCount; i++)
        {
            var first = i * perThreadCount;
            var last = Mathf.Min(first + perThreadCount, data.Count);
            ThreadPool.QueueUserWorkItem(
                                         _ =>
                                         {
                                             var results = new List<TOut>(perThreadCount);

                                             try
                                             {
                                                 for (var dataIndex = first; dataIndex < last; dataIndex++)
                                                 {
                                                     if (exceptionThrown != null) break;
                                                     results.Add(work(data[dataIndex]));
                                                 }
                                             }
                                             catch (Exception ex)
                                             {
                                                 exceptionThrown = ex;
                                             }

                                             lock (lockObj)
                                             {
                                                 doneItems = doneItems == null
                                                                 ? results
                                                                 : results.Concat(doneItems);
                                                 doneCount++;
                                                 are.Set();
                                             }
                                         });
        }

        // Main thread waits for results and returns them until all threads finish
        while (true)
        {
            are.WaitOne();

            IEnumerable<TOut> toOutput;
            bool isDone;
            lock (lockObj)
            {
                toOutput = doneItems;
                doneItems = null;
                isDone = doneCount == workerCount;
            }

            if (toOutput != null)
                foreach (var doneItem in toOutput)
                    yield return doneItem;

            if (isDone)
                break;
        }

        if (exceptionThrown != null)
            throw new TargetInvocationException("An exception was thrown inside one of the threads",
                                                exceptionThrown);
    }

    /// <summary>
    /// Apply a function to a collection of data by spreading the work on multiple threads.
    /// Lower overhead than RunParallel but it blocks the main thread until all work is completed or an exception has been thrown.
    /// </summary>
    /// <typeparam name="T">Type of the input values.</typeparam>
    /// <param name="data">Input values for the work function.</param>
    /// <param name="work">Function to apply to the data on multiple threads at once.</param>
    /// <param name="workerCount">Number of worker threads. By default Environment.ProcessorCount is used.</param>
    /// <exception cref="TargetInvocationException">An exception was thrown inside one of the threads, and the operation was aborted.</exception>
    /// <exception cref="ArgumentException">Need at least 1 workerCount.</exception>
    public static void ForEachParallel<T>(this IList<T> data, Action<T> work, int workerCount = -1)
    {
        if (workerCount < 0)
            workerCount = Mathf.Max(2, Environment.ProcessorCount);
        else if (workerCount == 0)
            throw new ArgumentException("Need at least 1 worker", nameof(workerCount));

        var currentIndex = data.Count;

        var are = new ManualResetEvent(false);
        var runningCount = workerCount;
        Exception exceptionThrown = null;

        void DoWork(object _)
        {
            try
            {
                while (true)
                {
                    if (exceptionThrown != null)
                        return;

                    var decrementedIndex = Interlocked.Decrement(ref currentIndex);
                    if (decrementedIndex < 0)
                        return;

                    work(data[decrementedIndex]);
                }
            }
            catch (Exception ex)
            {
                exceptionThrown = ex;
            }
            finally
            {
                var decCount = Interlocked.Decrement(ref runningCount);
                if (decCount <= 0)
                    are.Set();
            }
        }

        // Start threads to process the data
        for (var i = 0; i < workerCount - 1; i++)
            ThreadPool.QueueUserWorkItem(DoWork);

        DoWork(null);

        are.WaitOne();

        if (exceptionThrown != null)
            throw new TargetInvocationException("An exception was thrown inside one of the threads", exceptionThrown);
    }
}

```

`Runtimes/Unity/BepInEx.Unity.Mono/UnityTomlTypeConverters.cs`:

```cs
using System;
using System.Runtime.CompilerServices;
using BepInEx.Configuration;
using UnityEngine;

namespace BepInEx.Unity.Mono;

/// <summary>
///     Config types that are unity specific
/// </summary>
internal static class UnityTomlTypeConverters
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void AddUnityEngineConverters()
    {
        var colorConverter = new TypeConverter
        {
            ConvertToString = (obj, type) => ColorUtility.ToHtmlStringRGBA((Color) obj),
            ConvertToObject = (str, type) =>
            {
                if (!ColorUtility.TryParseHtmlString("#" + str.Trim('#', ' '), out var c))
                    throw new FormatException("Invalid color string, expected hex #RRGGBBAA");
                return c;
            }
        };

        TomlTypeConverter.AddConverter(typeof(Color), colorConverter);

        var jsonConverter = new TypeConverter
        {
            ConvertToString = (obj, type) => JsonUtility.ToJson(obj),
            ConvertToObject = (str, type) => JsonUtility.FromJson(type: type, json: str)
        };

        TomlTypeConverter.AddConverter(typeof(Vector2), jsonConverter);
        TomlTypeConverter.AddConverter(typeof(Vector3), jsonConverter);
        TomlTypeConverter.AddConverter(typeof(Vector4), jsonConverter);
        TomlTypeConverter.AddConverter(typeof(Quaternion), jsonConverter);
    }
}

```

`Runtimes/Unity/Doorstop/doorstop_config_il2cpp.ini`:

```ini
# General options for Unity Doorstop
[General]

# Enable Doorstop?
enabled = true

# Path to the assembly to load and execute
# NOTE: The entrypoint must be of format `static void Doorstop.Entrypoint.Start()`
target_assembly = BepInEx\core\BepInEx.Unity.IL2CPP.dll

# If true, Unity's output log is redirected to <current folder>\output_log.txt
redirect_output_log = false

# If enabled, DOORSTOP_DISABLE env var value is ignored
# USE THIS ONLY WHEN ASKED TO OR YOU KNOW WHAT THIS MEANS
ignore_disable_switch = false

# Options specific to running under Unity Mono runtime
[UnityMono]

# Overrides default Mono DLL search path
# Sometimes it is needed to instruct Mono to seek its assemblies from a different path
# (e.g. mscorlib is stripped in original game)
# This option causes Mono to seek mscorlib and core libraries from a different folder before Managed
# Original Managed folder is added as a secondary folder in the search path
dll_search_path_override =

# If true, Mono debugger server will be enabled
debug_enabled = false

# When debug_enabled is true, this option specifies whether Doorstop should initialize the debugger server
# If you experience crashes when starting the debugger on debug UnityPlayer builds, try setting this to false
debug_start_server = true

# When debug_enabled is true, specifies the address to use for the debugger server
debug_address = 127.0.0.1:10000

# If true and debug_enabled is true, Mono debugger server will suspend the game execution until a debugger is attached
debug_suspend = false

# Options sepcific to running under Il2Cpp runtime
[Il2Cpp]

# Path to coreclr.dll that contains the CoreCLR runtime
coreclr_path = dotnet\coreclr.dll

# Path to the directory containing the managed core libraries for CoreCLR (mscorlib, System, etc.)
corlib_dir = dotnet

```

`Runtimes/Unity/Doorstop/doorstop_config_mono.ini`:

```ini
# General options for Unity Doorstop
[General]

# Enable Doorstop?
enabled = true

# Path to the assembly to load and execute
# NOTE: The entrypoint must be of format `static void Doorstop.Entrypoint.Start()`
target_assembly = BepInEx\core\BepInEx.Unity.Mono.Preloader.dll

# If true, Unity's output log is redirected to <current folder>\output_log.txt
redirect_output_log = false

# If enabled, DOORSTOP_DISABLE env var value is ignored
# USE THIS ONLY WHEN ASKED TO OR YOU KNOW WHAT THIS MEANS
ignore_disable_switch = false

# Options specific to running under Unity Mono runtime
[UnityMono]

# Overrides default Mono DLL search path
# Sometimes it is needed to instruct Mono to seek its assemblies from a different path
# (e.g. mscorlib is stripped in original game)
# This option causes Mono to seek mscorlib and core libraries from a different folder before Managed
# Original Managed folder is added as a secondary folder in the search path
dll_search_path_override =

# If true, Mono debugger server will be enabled
debug_enabled = false

# When debug_enabled is true, this option specifies whether Doorstop should initialize the debugger server
# If you experience crashes when starting the debugger on debug UnityPlayer builds, try setting this to false
debug_start_server = true

# When debug_enabled is true, specifies the address to use for the debugger server
debug_address = 127.0.0.1:10000

# If true and debug_enabled is true, Mono debugger server will suspend the game execution until a debugger is attached
debug_suspend = false

```

`Runtimes/Unity/Doorstop/run_bepinex_il2cpp.sh`:

```sh
#!/bin/sh
# BepInEx start script
# 
# Run the script to start the game with BepInEx enabled
#
# There are two ways to use this script
#
# 1. Via CLI: Run ./run_bepinex.sh <path to game> [doorstop arguments] [game arguments]
# 2. Via config: edit the options below and run ./run.sh without any arguments

# 0 is false, 1 is true

# LINUX: name of Unity executable
# MACOS: name of the .app directory
executable_name=""

# All of the below can be overriden with command line args

# General Config Options

# Enable Doorstop?
enabled="1"

# Path to the assembly to load and execute
# NOTE: The entrypoint must be of format `static void Doorstop.Entrypoint.Start()`
target_assembly="BepInEx/core/BepInEx.Unity.IL2CPP.dll"

# If enabled, DOORSTOP_DISABLE env var value is ignored
# USE THIS ONLY WHEN ASKED TO OR YOU KNOW WHAT THIS MEANS
ignore_disable_switch="0"

# Mono Options

# Overrides default Mono DLL search path
# Sometimes it is needed to instruct Mono to seek its assemblies from a different path
# (e.g. mscorlib is stripped in original game)
# This option causes Mono to seek mscorlib and core libraries from a different folder before Managed
# Original Managed folder is added as a secondary folder in the search path
dll_search_path_override=""

# If 1, Mono debugger server will be enabled
debug_enable="0"

# When debug_enabled is 1, this option specifies whether Doorstop should initialize the debugger server
# If you experience crashes when starting the debugger on debug UnityPlayer builds, try setting this to 0
debug_start_server="0"

# When debug_enabled is 1, specifies the address to use for the debugger server
debug_address="127.0.0.1:10000"

# If 1 and debug_enabled is 1, Mono debugger server will suspend the game execution until a debugger is attached
debug_suspend="0"

# CoreCLR options (IL2CPP)

# Path to coreclr shared library WITHOUT THE EXTENSION that contains the CoreCLR runtime
coreclr_path="dotnet/libcoreclr"

# Path to the directory containing the managed core libraries for CoreCLR (mscorlib, System, etc.)
corlib_dir="dotnet"

################################################################################
# Everything past this point is the actual script

# Special case: program is launched via Steam
# In that case rerun the script via their bootstrapper to ensure Steam overlay works
if [ "$2" = "SteamLaunch" ]; then
    steam="$1 $2 $3 $4 $0 $5"
    shift 5
    $steam "$@"
    exit
fi

# Handle first param being executable name
if [ -x "$1" ] ; then
    executable_name="$1"
    echo "Target executable: $1"
    shift
fi

if [ -z "${executable_name}" ] || [ ! -x "${executable_name}" ]; then
    echo "Please set executable_name to a valid name in a text editor or as the first command line parameter"
    exit 1
fi

# Use POSIX-compatible way to get the directory of the executable
a="/$0"; a=${a%/*}; a=${a#/}; a=${a:-.}; BASEDIR=$(cd "$a" || exit; pwd -P)

arch=""
executable_path=""
lib_extension=""

# Set executable path and the extension to use for the libdoorstop shared object
os_type="$(uname -s)"
case ${os_type} in
    Linux*)
        executable_path="${executable_name}"
        # Handle relative paths
        if ! echo "$executable_path" | grep "^/.*$"; then
            executable_path="${BASEDIR}/${executable_path}"
        fi
        lib_extension="so"
    ;;
    Darwin*)
        real_executable_name="${executable_name}"

        # Handle relative directories
        if ! echo "$real_executable_name" | grep "^/.*$"; then
            real_executable_name="${BASEDIR}/${real_executable_name}"
        fi

        # If we're not even an actual executable, check .app Info for actual executable
        if ! echo "$real_executable_name" | grep "^.*\.app/Contents/MacOS/.*"; then
            # Add .app to the end if not given
            if ! echo "$real_executable_name" | grep "^.*\.app$"; then
                real_executable_name="${real_executable_name}.app"
            fi
            inner_executable_name=$(defaults read "${real_executable_name}/Contents/Info" CFBundleExecutable)
            executable_path="${real_executable_name}/Contents/MacOS/${inner_executable_name}"
        else
            executable_path="${executable_name}"
        fi
        lib_extension="dylib"
    ;;
    *)
        # alright whos running games on freebsd
        echo "Unknown operating system ($(uname -s))"
        echo "Make an issue at https://github.com/NeighTools/UnityDoorstop"
        exit 1
    ;;
esac

abs_path() {
    echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
}

_readlink() {
    # relative links with readlink (without -f) do not preserve the path info 
    ab_path="$(abs_path "$1")"
    link="$(readlink "${ab_path}")"
    case $link in
        /*);;
        *) link="$(dirname "$ab_path")/$link";;
    esac
    echo "$link"
}


resolve_executable_path () {
    e_path="$(abs_path "$1")"
    
    while [ -L "${e_path}" ]; do 
        e_path=$(_readlink "${e_path}");
    done
    echo "${e_path}"
}

# Get absolute path of executable and show to user
executable_path=$(resolve_executable_path "${executable_path}")
echo "${executable_path}"

# Figure out the arch of the executable with file
file_out="$(LD_PRELOAD="" file -b "${executable_path}")"
case "${file_out}" in
    *64-bit*)
        arch="x64"
    ;;
    *32-bit*)
        arch="x86"
    ;;
    *)
        echo "The executable \"${executable_path}\" is not compiled for x86 or x64 (might be ARM?)"
        echo "If you think this is a mistake (or would like to encourage support for other architectures)"
        echo "Please make an issue at https://github.com/NeighTools/UnityDoorstop"
        echo "Got: ${file_out}"
        exit 1
    ;;
esac

# Helper to convert common boolean strings into just 0 and 1
doorstop_bool() {
    case "$1" in
        TRUE|true|t|T|1|Y|y|yes)
            echo "1"
        ;;
        FALSE|false|f|F|0|N|n|no)
            echo "0"
        ;;
    esac
}

# Read from command line
while :; do
    case "$1" in
        --doorstop_enabled)
            enabled="$(doorstop_bool "$2")"
            shift
        ;;
        --doorstop_target_assembly)
            target_assembly="$2"
            shift
        ;;
        --doorstop-mono-dll-search-path-override)
            dll_search_path_override="$2"
            shift
        ;;
        --doorstop-mono-debug-enabled)
            debug_enable="$(doorstop_bool "$2")"
            shift
        ;;
        --doorstop-mono-debug-start-server)
            debug_start_server="$(doorstop_bool "$2")"
            shift
        ;;
        --doorstop-mono-debug-suspend)
            debug_suspend="$(doorstop_bool "$2")"
            shift
        ;;
        --doorstop-mono-debug-address)
            debug_address="$2"
            shift
        ;;
        --doorstop-clr-runtime-coreclr-path)
            coreclr_path="$2"
            shift
        ;;
        --doorstop-clr-corlib-dir)
            corlib_dir="$2"
            shift
        ;;
        *)
            if [ -z "$1" ]; then
                break
            fi
            rest_args="$rest_args $1"
        ;;
    esac
    shift
done

# Move variables to environment
export DOORSTOP_ENABLED="$enabled"
export DOORSTOP_TARGET_ASSEMBLY="$target_assembly"
export DOORSTOP_IGNORE_DISABLED_ENV="$ignore_disable_switch"
export DOORSTOP_MONO_DLL_SEARCH_PATH_OVERRIDE="$dll_search_path_override"
export DOORSTOP_MONO_DEBUG_ENABLED="$debug_enable"
export DOORSTOP_MONO_DEBUG_START_SERVER="$debug_start_server"
export DOORSTOP_MONO_DEBUG_ADDRESS="$debug_address"
export DOORSTOP_MONO_DEBUG_SUSPEND="$debug_suspend"
export DOORSTOP_CLR_RUNTIME_CORECLR_PATH="$coreclr_path.$lib_extension"
export DOORSTOP_CLR_CORLIB_DIR="$corlib_dir"

# Final setup
doorstop_directory="${BASEDIR}/"
doorstop_name="libdoorstop.${lib_extension}"

export LD_LIBRARY_PATH="${doorstop_directory}:${corlib_dir}:${LD_LIBRARY_PATH}"
if [ -z "$LD_PRELOAD" ]; then
    export LD_PRELOAD="${doorstop_name}"
else
    export LD_PRELOAD="${doorstop_name}:${LD_PRELOAD}"
fi

export DYLD_LIBRARY_PATH="${doorstop_directory}:${DYLD_LIBRARY_PATH}"
if [ -z "$DYLD_INSERT_LIBRARIES" ]; then
    export DYLD_INSERT_LIBRARIES="${doorstop_name}"
else
    export DYLD_INSERT_LIBRARIES="${doorstop_name}:${DYLD_INSERT_LIBRARIES}"
fi

# shellcheck disable=SC2086
exec "$executable_path" $rest_args

```

`Runtimes/Unity/Doorstop/run_bepinex_mono.sh`:

```sh
#!/bin/sh
# BepInEx start script
# 
# Run the script to start the game with BepInEx enabled
#
# There are two ways to use this script
#
# 1. Via CLI: Run ./run_bepinex.sh <path to game> [doorstop arguments] [game arguments]
# 2. Via config: edit the options below and run ./run.sh without any arguments

# 0 is false, 1 is true

# LINUX: name of Unity executable
# MACOS: name of the .app directory
executable_name=""

# All of the below can be overriden with command line args

# General Config Options

# Enable Doorstop?
enabled="1"

# Path to the assembly to load and execute
# NOTE: The entrypoint must be of format `static void Doorstop.Entrypoint.Start()`
target_assembly="BepInEx/core/BepInEx.Unity.Mono.Preloader.dll"

# If enabled, DOORSTOP_DISABLE env var value is ignored
# USE THIS ONLY WHEN ASKED TO OR YOU KNOW WHAT THIS MEANS
ignore_disable_switch="0"

# Mono Options

# Overrides default Mono DLL search path
# Sometimes it is needed to instruct Mono to seek its assemblies from a different path
# (e.g. mscorlib is stripped in original game)
# This option causes Mono to seek mscorlib and core libraries from a different folder before Managed
# Original Managed folder is added as a secondary folder in the search path
dll_search_path_override=""

# If 1, Mono debugger server will be enabled
debug_enable="0"

# When debug_enabled is 1, this option specifies whether Doorstop should initialize the debugger server
# If you experience crashes when starting the debugger on debug UnityPlayer builds, try setting this to 0
debug_start_server="0"

# When debug_enabled is 1, specifies the address to use for the debugger server
debug_address="127.0.0.1:10000"

# If 1 and debug_enabled is 1, Mono debugger server will suspend the game execution until a debugger is attached
debug_suspend="0"

# CoreCLR options (IL2CPP)

# Path to coreclr shared library WITHOUT THE EXTENSION that contains the CoreCLR runtime
coreclr_path=""

# Path to the directory containing the managed core libraries for CoreCLR (mscorlib, System, etc.)
corlib_dir=""

################################################################################
# Everything past this point is the actual script

# Special case: program is launched via Steam
# In that case rerun the script via their bootstrapper to ensure Steam overlay works
if [ "$2" = "SteamLaunch" ]; then
    steam="$1 $2 $3 $4 $0 $5"
    shift 5
    $steam "$@"
    exit
fi

# Handle first param being executable name
if [ -x "$1" ] ; then
    executable_name="$1"
    echo "Target executable: $1"
    shift
fi

if [ -z "${executable_name}" ] || [ ! -x "${executable_name}" ]; then
    echo "Please set executable_name to a valid name in a text editor or as the first command line parameter"
    exit 1
fi

# Use POSIX-compatible way to get the directory of the executable
a="/$0"; a=${a%/*}; a=${a#/}; a=${a:-.}; BASEDIR=$(cd "$a" || exit; pwd -P)

arch=""
executable_path=""
lib_extension=""

# Set executable path and the extension to use for the libdoorstop shared object
os_type="$(uname -s)"
case ${os_type} in
    Linux*)
        executable_path="${executable_name}"
        # Handle relative paths
        if ! echo "$executable_path" | grep "^/.*$"; then
            executable_path="${BASEDIR}/${executable_path}"
        fi
        lib_extension="so"
    ;;
    Darwin*)
        real_executable_name="${executable_name}"

        # Handle relative directories
        if ! echo "$real_executable_name" | grep "^/.*$"; then
            real_executable_name="${BASEDIR}/${real_executable_name}"
        fi

        # If we're not even an actual executable, check .app Info for actual executable
        if ! echo "$real_executable_name" | grep "^.*\.app/Contents/MacOS/.*"; then
            # Add .app to the end if not given
            if ! echo "$real_executable_name" | grep "^.*\.app$"; then
                real_executable_name="${real_executable_name}.app"
            fi
            inner_executable_name=$(defaults read "${real_executable_name}/Contents/Info" CFBundleExecutable)
            executable_path="${real_executable_name}/Contents/MacOS/${inner_executable_name}"
        else
            executable_path="${executable_name}"
        fi
        lib_extension="dylib"
    ;;
    *)
        # alright whos running games on freebsd
        echo "Unknown operating system ($(uname -s))"
        echo "Make an issue at https://github.com/NeighTools/UnityDoorstop"
        exit 1
    ;;
esac

abs_path() {
    echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
}

_readlink() {
    # relative links with readlink (without -f) do not preserve the path info 
    ab_path="$(abs_path "$1")"
    link="$(readlink "${ab_path}")"
    case $link in
        /*);;
        *) link="$(dirname "$ab_path")/$link";;
    esac
    echo "$link"
}


resolve_executable_path () {
    e_path="$(abs_path "$1")"
    
    while [ -L "${e_path}" ]; do 
        e_path=$(_readlink "${e_path}");
    done
    echo "${e_path}"
}

# Get absolute path of executable and show to user
executable_path=$(resolve_executable_path "${executable_path}")
echo "${executable_path}"

# Figure out the arch of the executable with file
file_out="$(LD_PRELOAD="" file -b "${executable_path}")"
case "${file_out}" in
    *64-bit*)
        arch="x64"
    ;;
    *32-bit*)
        arch="x86"
    ;;
    *)
        echo "The executable \"${executable_path}\" is not compiled for x86 or x64 (might be ARM?)"
        echo "If you think this is a mistake (or would like to encourage support for other architectures)"
        echo "Please make an issue at https://github.com/NeighTools/UnityDoorstop"
        echo "Got: ${file_out}"
        exit 1
    ;;
esac

# Helper to convert common boolean strings into just 0 and 1
doorstop_bool() {
    case "$1" in
        TRUE|true|t|T|1|Y|y|yes)
            echo "1"
        ;;
        FALSE|false|f|F|0|N|n|no)
            echo "0"
        ;;
    esac
}

# Read from command line
while :; do
    case "$1" in
        --doorstop_enabled)
            enabled="$(doorstop_bool "$2")"
            shift
        ;;
        --doorstop_target_assembly)
            target_assembly="$2"
            shift
        ;;
        --doorstop-mono-dll-search-path-override)
            dll_search_path_override="$2"
            shift
        ;;
        --doorstop-mono-debug-enabled)
            debug_enable="$(doorstop_bool "$2")"
            shift
        ;;
        --doorstop-mono-debug-start-server)
            debug_start_server="$(doorstop_bool "$2")"
            shift
        ;;
        --doorstop-mono-debug-suspend)
            debug_suspend="$(doorstop_bool "$2")"
            shift
        ;;
        --doorstop-mono-debug-address)
            debug_address="$2"
            shift
        ;;
        --doorstop-clr-runtime-coreclr-path)
            coreclr_path="$2"
            shift
        ;;
        --doorstop-clr-corlib-dir)
            corlib_dir="$2"
            shift
        ;;
        *)
            if [ -z "$1" ]; then
                break
            fi
            rest_args="$rest_args $1"
        ;;
    esac
    shift
done

# Move variables to environment
export DOORSTOP_ENABLED="$enabled"
export DOORSTOP_TARGET_ASSEMBLY="$target_assembly"
export DOORSTOP_IGNORE_DISABLED_ENV="$ignore_disable_switch"
export DOORSTOP_MONO_DLL_SEARCH_PATH_OVERRIDE="$dll_search_path_override"
export DOORSTOP_MONO_DEBUG_ENABLED="$debug_enable"
export DOORSTOP_MONO_DEBUG_START_SERVER="$debug_start_server"
export DOORSTOP_MONO_DEBUG_ADDRESS="$debug_address"
export DOORSTOP_MONO_DEBUG_SUSPEND="$debug_suspend"
export DOORSTOP_CLR_RUNTIME_CORECLR_PATH="$coreclr_path.$lib_extension"
export DOORSTOP_CLR_CORLIB_DIR="$corlib_dir"

# Final setup
doorstop_directory="${BASEDIR}/"
doorstop_name="libdoorstop.${lib_extension}"

export LD_LIBRARY_PATH="${doorstop_directory}:${corlib_dir}:${LD_LIBRARY_PATH}"
if [ -z "$LD_PRELOAD" ]; then
    export LD_PRELOAD="${doorstop_name}"
else
    export LD_PRELOAD="${doorstop_name}:${LD_PRELOAD}"
fi

export DYLD_LIBRARY_PATH="${doorstop_directory}:${DYLD_LIBRARY_PATH}"
if [ -z "$DYLD_INSERT_LIBRARIES" ]; then
    export DYLD_INSERT_LIBRARIES="${doorstop_name}"
else
    export DYLD_INSERT_LIBRARIES="${doorstop_name}:${DYLD_INSERT_LIBRARIES}"
fi

# shellcheck disable=SC2086
exec "$executable_path" $rest_args

```

`assets/logos/logo.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   version="1.1"
   id="svg2"
   xml:space="preserve"
   width="341.33334"
   height="341.33334"
   viewBox="0 0 341.33334 341.33334"
   sodipodi:docname="Untitled-1.ai"><metadata
     id="metadata8"><rdf:RDF><cc:Work
         rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" /></cc:Work></rdf:RDF></metadata><defs
     id="defs6"><clipPath
       clipPathUnits="userSpaceOnUse"
       id="clipPath18"><path
         d="M 0,256 H 256 V 0 H 0 Z"
         id="path16" /></clipPath><clipPath
       clipPathUnits="userSpaceOnUse"
       id="clipPath26"><path
         d="M 20,224 H 244 V 64 H 20 Z"
         id="path24" /></clipPath><linearGradient
       x1="0"
       y1="0"
       x2="1"
       y2="0"
       gradientUnits="userSpaceOnUse"
       gradientTransform="matrix(0,-160,-160,0,132,224)"
       spreadMethod="pad"
       id="linearGradient36"><stop
         style="stop-opacity:1;stop-color:#000000"
         offset="0"
         id="stop32" /><stop
         style="stop-opacity:1;stop-color:#513c35"
         offset="1"
         id="stop34" /></linearGradient><linearGradient
       x1="0"
       y1="0"
       x2="1"
       y2="0"
       gradientUnits="userSpaceOnUse"
       gradientTransform="matrix(0,-160,-160,0,128,228)"
       spreadMethod="pad"
       id="linearGradient68"><stop
         style="stop-opacity:1;stop-color:#914d36"
         offset="0"
         id="stop64" /><stop
         style="stop-opacity:1;stop-color:#513c35"
         offset="1"
         id="stop66" /></linearGradient><linearGradient
       x1="0"
       y1="0"
       x2="1"
       y2="0"
       gradientUnits="userSpaceOnUse"
       gradientTransform="matrix(0,-160,-160,0,128,228)"
       spreadMethod="pad"
       id="linearGradient88"><stop
         style="stop-opacity:1;stop-color:#914d36"
         offset="0"
         id="stop84" /><stop
         style="stop-opacity:1;stop-color:#513c35"
         offset="1"
         id="stop86" /></linearGradient><clipPath
       clipPathUnits="userSpaceOnUse"
       id="clipPath98"><path
         d="M 0,256 H 256 V 0 H 0 Z"
         id="path96" /></clipPath><linearGradient
       x1="0"
       y1="0"
       x2="1"
       y2="0"
       gradientUnits="userSpaceOnUse"
       gradientTransform="matrix(0,-40,-40,0,210,56)"
       spreadMethod="pad"
       id="linearGradient144"><stop
         style="stop-opacity:1;stop-color:#ffe690"
         offset="0"
         id="stop136" /><stop
         style="stop-opacity:1;stop-color:#ffe690"
         offset="0.1"
         id="stop138" /><stop
         style="stop-opacity:1;stop-color:#ff9e9e"
         offset="0.9"
         id="stop140" /><stop
         style="stop-opacity:1;stop-color:#ff9e9e"
         offset="1"
         id="stop142" /></linearGradient><linearGradient
       x1="0"
       y1="0"
       x2="1"
       y2="0"
       gradientUnits="userSpaceOnUse"
       gradientTransform="matrix(0,-48,-48,0,94,56)"
       spreadMethod="pad"
       id="linearGradient164"><stop
         style="stop-opacity:1;stop-color:#914d36"
         offset="0"
         id="stop160" /><stop
         style="stop-opacity:1;stop-color:#513c35"
         offset="1"
         id="stop162" /></linearGradient></defs><sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="640"
     inkscape:window-height="480"
     id="namedview4" /><g
     id="g10"
     inkscape:groupmode="layer"
     inkscape:label="Untitled-1"
     transform="matrix(1.3333333,0,0,-1.3333333,0,341.33333)"><g
       id="g12"><g
         id="g14"
         clip-path="url(#clipPath18)"><g
           id="g20"><g
             id="g22" /><g
             id="g50"><g
               clip-path="url(#clipPath26)"
               opacity="0.300003"
               id="g48"><g
                 id="g46"><g
                   id="g44"><g
                     id="g42"><g
                       id="g40"><path
                         d="M 100,180.564 V 80 H 36 v 32 h 32 c 8.836,0 16,7.163 16,16 v 32 c 0,8.836 -7.164,16 -16,16 H 36 v 32 h 40 c 0,0 8.5,-0.5 8,8 0.5,7.5 -8,8 -8,8 H 36 c -8.836,0 -16,-7.164 -16,-16 v -32 c 0,-8.836 7.164,-16 16,-16 H 68 V 128 H 36 c -1.899,0 -3.721,-0.331 -5.412,-0.938 C 24.415,124.844 20,118.938 20,112 V 80 c 0,-8.837 7.164,-16 16,-16 h 64 c 8.836,0 16,7.163 16,16 v 64 c 0,8.836 7.164,16 16,16 8.837,0 16,-7.164 16,-16 V 80 c 0,-8.837 7.163,-16 16,-16 h 64 c 8.837,0 16,7.163 16,16 v 32 c 0,8.837 -7.163,16 -16,16 h -32 v 32 h 32 c 8.837,0 16,7.164 16,16 v 32 c 0,8.836 -7.163,16 -16,16 h -40 c 0,0 -8.5,-0.5 -8,-8 -0.5,-8.5 8,-8 8,-8 h 40 v -32 h -32 c -8.837,0 -16,-7.164 -16,-16 v -32 c 0,-8.837 7.163,-16 16,-16 h 32 V 80 h -64 v 111.334 c 0,17.437 -13.671,32.176 -31.101,32.654 C 114.815,224.483 100,209.972 100,192 Z"
                         style="fill:url(#linearGradient36);stroke:none"
                         id="path38" /></g></g></g></g></g></g></g></g></g><g
       id="g52"><g
         id="g54"><g
           id="g60"><g
             id="g62"><path
               d="M 96,196 V 184.565 84 H 32 v 32 h 32 c 8.836,0 16,7.163 16,16 v 0 32 c 0,8.836 -7.164,16 -16,16 v 0 H 32 v 32 h 40 c 0,0 8.5,-0.5 8,8 v 0 c 0.5,7.5 -8,8 -8,8 v 0 H 32 c -8.837,0 -16,-7.163 -16,-16 v 0 -32 c 0,-8.836 7.163,-16 16,-16 v 0 H 64 V 132 H 32 c -1.9,0 -3.721,-0.331 -5.411,-0.938 v 0 C 20.415,128.843 16,122.937 16,116 v 0 -32 c 0,-8.837 7.163,-16 16,-16 v 0 h 64 c 8.837,0 16,7.163 16,16 v 0 64 c 0,8.837 7.164,16 16,16 v 0 c 8.837,0 16,-7.163 16,-16 v 0 -64 c 0,-8.837 7.163,-16 16,-16 v 0 h 64 c 8.837,0 16,7.163 16,16 v 0 32 c 0,8.837 -7.163,16 -16,16 v 0 h -32 v 32 h 32 c 8.837,0 16,7.164 16,16 v 0 32 c 0,8.837 -7.163,16 -16,16 v 0 h -40 c 0,0 -8.5,-0.5 -8,-8 v 0 c -0.5,-8.5 8,-8 8,-8 v 0 h 40 v -32 h -32 c -8.837,0 -16,-7.164 -16,-16 v 0 -32 c 0,-8.837 7.163,-16 16,-16 v 0 h 32 V 84 h -64 v 111.334 c 0,17.437 -13.671,32.176 -31.1,32.654 v 0 c -0.299,0.008 -0.601,0.012 -0.898,0.012 v 0 C 110.326,228.002 96,213.675 96,196"
               style="fill:url(#linearGradient68);stroke:none"
               id="path70" /></g></g></g></g><g
       id="g72"><g
         id="g74"><g
           id="g80"><g
             id="g82"><path
               d="m 184,228 c 0,0 -8.5,-0.5 -8,-8 v 0 c -0.5,-8.5 8,-8 8,-8 v 0 h 40 v -32 h -32 c -8.837,0 -16,-7.164 -16,-16 v 0 -32 c 0,-8.837 7.163,-16 16,-16 v 0 h 32 V 84 h -64 v 111.334 c 0,17.437 -13.671,32.176 -31.1,32.654 v 0 c -0.222,0.006 -0.445,0.01 -0.667,0.012 v 0 h -0.472 C 110.196,227.873 96,213.595 96,196 V 196 184.565 84 H 32 v 32 h 32 c 8.836,0 16,7.163 16,16 v 0 32 c 0,8.836 -7.164,16 -16,16 v 0 H 32 v 32 h 40 c 0,0 8.5,-0.5 8,8 v 0 c 0.5,7.5 -8,8 -8,8 v 0 H 32 c -8.837,0 -16,-7.163 -16,-16 v 0 -32 c 0,-8.836 7.163,-16 16,-16 v 0 H 64 V 132 H 32 c -1.9,0 -3.721,-0.331 -5.411,-0.938 v 0 C 20.415,128.843 16,122.937 16,116 v 0 -32 c 0,-8.837 7.163,-16 16,-16 v 0 h 64 c 8.837,0 16,7.163 16,16 v 0 64 c 0,8.837 7.164,16 16,16 v 0 c 8.837,0 16,-7.163 16,-16 v 0 -64 c 0,-8.837 7.163,-16 16,-16 v 0 h 64 c 8.837,0 16,7.163 16,16 v 0 32 c 0,8.837 -7.163,16 -16,16 v 0 h -32 v 32 h 32 c 8.837,0 16,7.164 16,16 v 0 32 c 0,8.837 -7.163,16 -16,16 v 0 z"
               style="fill:url(#linearGradient88);stroke:none"
               id="path90" /></g></g></g></g><g
       id="g92"><g
         id="g94"
         clip-path="url(#clipPath98)"><g
           id="g100"
           transform="translate(128,184)"><path
             d="m 0,0 -12,-12 c 7.79,-2.597 16.211,-2.597 24,0 z"
             style="fill:#ff9e9e;fill-opacity:1;fill-rule:nonzero;stroke:none"
             id="path102" /></g><g
           id="g104"
           transform="translate(125.1064,183.106)"><path
             d="m 0,0 c -1.446,1.447 -2.893,2.893 -2.893,2.893 0,0 -8.735,-5.707 -11.574,-7.715 -1.888,-1.336 -2.629,-4.587 -2.639,-7.417 -0.01,-2.697 2.169,-4.876 4.866,-4.866 2.831,0.01 6.082,0.75 7.418,2.638 2.009,2.839 7.716,11.573 7.716,11.573 z"
             style="fill:#ffe690;fill-opacity:1;fill-rule:nonzero;stroke:none"
             id="path106" /></g><g
           id="g108"
           transform="translate(130.8936,183.106)"><path
             d="m 0,0 c 1.446,1.447 2.894,2.893 2.894,2.893 0,0 8.734,-5.707 11.573,-7.715 1.888,-1.336 2.629,-4.587 2.639,-7.417 0.01,-2.697 -2.169,-4.876 -4.866,-4.866 -2.832,0.01 -6.082,0.75 -7.418,2.638 -2.009,2.839 -7.716,11.573 -7.716,11.573 0,0 1.447,1.447 2.894,2.894"
             style="fill:#ffe690;fill-opacity:1;fill-rule:nonzero;stroke:none"
             id="path110" /></g><g
           id="g112"
           transform="translate(120,200)"><path
             d="m 0,0 c 0,-4.418 -3.582,-8 -8,-8 -4.418,0 -8,3.582 -8,8 0,4.418 3.582,8 8,8 4.418,0 8,-3.582 8,-8"
             style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none"
             id="path114" /></g><g
           id="g116"
           transform="translate(152,200)"><path
             d="m 0,0 c 0,-4.418 -3.582,-8 -8,-8 -4.418,0 -8,3.582 -8,8 0,4.418 3.582,8 8,8 4.418,0 8,-3.582 8,-8"
             style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none"
             id="path118" /></g><g
           id="g120"
           transform="translate(134,186)"><path
             d="m 0,0 c 0,-3.313 -2.687,-6 -6,-6 -3.313,0 -6,2.687 -6,6 0,3.313 2.687,6 6,6 3.313,0 6,-2.687 6,-6"
             style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none"
             id="path122" /></g></g></g><g
       id="g124"><g
         id="g126"><g
           id="g132"><g
             id="g134"><path
               d="m 185.98,54.949 c -3.388,0 -5.082,-1.726 -5.082,-5.174 v 0 -26.652 c 0,-3.45 1.694,-5.173 5.082,-5.173 v 0 h 20.295 c 5.039,0 5.039,8.045 0,8.045 v 0 h -17.233 v 6.909 h 14.881 c 2.447,0 3.695,2.009 3.695,4.068 v 0 c 0,1.966 -1.248,3.976 -3.743,3.976 v 0 h -14.833 v 5.954 h 17.089 c 2.497,0 3.792,2.011 3.792,4.022 v 0 c 0,2.012 -1.295,4.025 -3.84,4.025 v 0 z m 45.428,-9.728 -4.224,-6.098 -4.321,6.192 c -0.767,1.155 -1.968,1.634 -3.12,1.634 v 0 c -2.208,0 -4.464,-1.634 -4.464,-3.745 v 0 c 0,-0.672 0.239,-1.391 0.815,-2.16 v 0 l 6.193,-8.496 -6.67,-9.073 c -0.578,-0.767 -0.818,-1.536 -0.818,-2.304 v 0 c 0,-2.208 2.016,-4.081 4.177,-4.081 v 0 c 1.15,0 2.351,0.528 3.265,1.873 v 0 l 4.943,7.105 4.944,-7.154 c 0.817,-1.248 1.97,-1.728 3.122,-1.728 v 0 c 2.159,0 4.367,1.872 4.367,4.081 v 0 c 0,0.672 -0.24,1.441 -0.769,2.16 v 0 l -6.768,9.121 6.099,8.496 c 0.575,0.769 0.814,1.536 0.814,2.257 v 0 c 0,2.064 -2.16,3.648 -4.319,3.648 v 0 c -1.201,0 -2.45,-0.527 -3.266,-1.728"
               style="fill:url(#linearGradient144);stroke:none"
               id="path146" /></g></g></g></g><g
       id="g148"><g
         id="g150"><g
           id="g156"><g
             id="g158"><path
               d="M 129.504,52.685 V 20.472 c 0,-2.086 2.011,-3.13 4.024,-3.13 v 0 c 2.012,0 4.024,1.044 4.024,3.13 v 0 32.213 c 0,2.18 -2.012,3.27 -4.024,3.27 v 0 c -2.012,0 -4.024,-1.09 -4.024,-3.27 M 24.081,54.949 c -3.387,0 -5.083,-1.726 -5.083,-5.174 v 0 -26.652 c 0,-3.45 1.696,-5.173 5.083,-5.173 v 0 H 37.7 c 9.828,0 14.299,3.782 14.299,12.095 v 0 c 0,3.613 -1.836,7.156 -4.659,8.605 v 0 c 2.072,1.299 2.966,3.591 2.966,6.131 v 0 c 0,6.575 -4.189,10.168 -13.455,10.168 v 0 z m 3.069,-8.041 h 9.951 c 3.648,0 4.999,-0.624 4.999,-2.334 v 0 c 0,-1.666 -1.048,-2.625 -4.25,-2.625 v 0 h -10.7 z m 0,-12.858 h 10.6 c 4.2,0 6.049,-1.308 6.049,-4.005 v 0 c 0,-2.795 -1.849,-4.048 -6.049,-4.048 v 0 h -10.6 z m 126.734,10.354 c 0,2.155 -1.789,3.209 -3.577,3.209 v 0 c -1.834,0 -3.669,-1.101 -3.669,-3.209 v 0 -23.177 c 0,-2.207 2.023,-3.36 3.999,-3.36 v 0 c 1.929,0 3.812,1.056 3.812,3.216 v 0 12.194 c 0,4.367 2.198,6.912 6.071,6.912 v 0 c 2.794,0 4.305,-1.969 4.305,-4.991 v 0 -14.162 c 0,-2.113 1.976,-3.169 3.907,-3.169 v 0 c 1.975,0 3.905,1.056 3.905,3.169 v 0 14.303 c 0,8.73 -4.001,12.61 -11.774,12.61 v 0 c -2.549,0 -5.884,-1.342 -6.979,-3.545 m -52.704,0.814 c 0,3.259 -7.801,3.259 -7.801,0 v 0 -32.494 c 0,-2.04 2.058,-3.06 4.117,-3.06 v 0 c 2.058,0 4.118,1.02 4.118,3.06 v 0 6.237 c 1.412,-1.438 4.329,-2.012 6.212,-2.012 v 0 c 7.812,0 13.553,5.605 13.553,15.526 v 0 c 0,9.917 -5.741,15.474 -13.553,15.474 v 0 c -2.495,0 -5.693,-1.15 -6.646,-2.731 m 0.199,-12.743 c 0,4.916 2.541,7.667 5.647,7.667 v 0 c 3.905,0 6.446,-2.651 6.446,-7.667 v 0 c 0,-5.018 -2.541,-7.718 -6.446,-7.718 v 0 c -3.152,0 -5.647,2.801 -5.647,7.718 M 58.308,31.878 c 0,-8.539 5.506,-14.929 14.145,-14.929 v 0 c 7.154,0 11.329,2.537 12.866,6.11 v 0 c 0.143,0.374 0.24,0.749 0.24,1.128 v 0 c 0,2.047 -2.448,3.524 -4.513,3.524 v 0 c -1.007,0 -1.919,-0.382 -2.353,-1.191 v 0 c -0.623,-1.189 -2.88,-2.427 -6.095,-2.427 v 0 c -3.025,0 -6.145,2.38 -6.241,4.954 v 0 h 15.314 c 3.408,0 4.895,1.64 4.895,4.519 v 0 0.398 c -0.335,7.583 -6.383,12.985 -14.017,12.985 v 0 c -8.215,0 -14.241,-5.59 -14.241,-15.071 m 14.29,8.071 c 3.215,0 5.375,-1.798 6.001,-4.002 v 0 H 66.406 c 0.672,2.158 2.639,4.002 6.192,4.002"
               style="fill:url(#linearGradient164);stroke:none"
               id="path166" /></g></g></g></g></g></svg>

```

`build.cmd`:

```cmd
:; set -eo pipefail
:; SCRIPT_DIR=$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)
:; ${SCRIPT_DIR}/build.sh "$@"
:; exit $?

@ECHO OFF
powershell -ExecutionPolicy ByPass -NoProfile -File "%~dp0build.ps1" %*

```

`build.ps1`:

```ps1
dotnet run --project build/Build.csproj -- $args
exit $LASTEXITCODE;
```

`build.sh`:

```sh
dotnet run --project ./build/Build.csproj -- "$@"

```

`build/Build.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6</TargetFramework>
        <RunWorkingDirectory>$(MSBuildProjectDirectory)</RunWorkingDirectory>
        <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="Cake.Frosting" Version="2.2.0"/>
        <PackageReference Include="Cake.Git" Version="2.0.0"/>
        <PackageReference Include="Cake.Incubator" Version="7.0.0"/>
        <PackageReference Include="Cake.Json" Version="7.0.1"/>
        <PackageReference Include="Microsoft.Build" Version="17.2.0"/>
    </ItemGroup>
    <ItemGroup>
        <Content Include="$(SolutionDir)/.github/workflows/*.yml" LinkBase="ci"/>
    </ItemGroup>
</Project>

```

`build/DependencyCache.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using Cake.Core.IO;
using Cake.Json;

readonly record struct DependencyCache(BuildContext Ctx, FilePath CacheFile)
{
    readonly IDictionary<string, string> cache =
        File.Exists(CacheFile.FullPath)
            ? Ctx.DeserializeJsonFromFile<Dictionary<string, string>>(CacheFile.FullPath)
            : new Dictionary<string, string>();

    public void Refresh(string name, string key, Action process)
    {
        if (cache.TryGetValue(name, out var curKey) && curKey == key) return;
        process();
        cache[name] = key;
    }

    public void Save() => Ctx.SerializeJsonToPrettyFile(CacheFile.FullPath, cache);
}

```

`build/DistributionTarget.cs`:

```cs
using System;

readonly record struct DistributionTarget(string DistributionIdentifier, string RuntimeIndentifier)
{
    public readonly string Arch = RuntimeIndentifier.Split('-')[1];
    public readonly string Engine = DistributionIdentifier.Split('.')[0];
    public readonly string Os = RuntimeIndentifier.Split('-')[0];
    public readonly string Runtime = DistributionIdentifier.Split('.')[1];
    public readonly string Target = $"{DistributionIdentifier}-{RuntimeIndentifier}";

    public string ClearOsName => Os switch
    {
        "win"   => "Windows",
        "linux" => "Linux",
        "macos" => "macOS",
        var _   => throw new NotSupportedException($"OS {Os} is not supported")
    };

    public string DllExtension => Os switch
    {
        "win"   => "dll",
        "linux" => "so",
        "macos" => "dylib",
        var _   => throw new NotSupportedException($"Unsupported OS: {Os}")
    };

    public string DllPrefix => Os switch
    {
        "win"   => "",
        "linux" => "lib",
        "macos" => "lib",
        _       => throw new NotSupportedException($"Unsupported OS: {Os}")
    };
}

```

`build/DownloadTasks.cs`:

```cs
using System;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Cake.Core;
using Cake.Core.IO;
using Spectre.Console;
using Path = System.IO.Path;

static class DownloadTasks
{
    public static void DownloadFiles(this ICakeContext ctx,
                                     string name,
                                     params (string Name, string Url, FilePath Destination)[] files)
    {
        AnsiConsole.Progress().Start(pCtx =>
        {
            Task.WaitAll(files
                         .Select(t => DownloadFile(pCtx, t.Name, t.Url, t.Destination))
                         .ToArray());
        });
    }

    public static void DownloadZipFiles(this ICakeContext ctx,
                                        string name,
                                        params (string Name, string Url, DirectoryPath Destination)[] files)
    {
        AnsiConsole.Progress().Start(pCtx =>
        {
            Task.WaitAll(files.Select(async t =>
            {
                var zipFilePath = $"{t.Destination}_tmp.zip";
                await DownloadFile(pCtx, t.Name, t.Url, zipFilePath);
                await UnzipFile(pCtx, t.Name, zipFilePath, t.Destination);
                File.Delete(zipFilePath!);
            }).ToArray());
        });
    }

    static async Task DownloadFile(ProgressContext pCtx, string name, string url, FilePath destination)
    {
        using var client = new HttpClient();
        await using var fs = File.Create(destination.FullPath);
        var response = await client.GetAsync(url, HttpCompletionOption.ResponseHeadersRead);
        if (!response.IsSuccessStatusCode)
            throw new Exception($"Failed to download {name}");
        await using var stream = await response.Content.ReadAsStreamAsync();
        var bar = pCtx.AddTask($"Downloading {name}", maxValue: (int) (response.Content.Headers.ContentLength ?? 1));

        var buffer = new byte[4096];
        int read;
        while ((read = await stream.ReadAsync(buffer)) > 0)
        {
            await fs.WriteAsync(buffer.AsMemory(0, read));
            bar.Increment(read);
        }
    }

    static async Task UnzipFile(ProgressContext pCtx, string name, FilePath zipFile, DirectoryPath destination)
    {
        using var zip = ZipFile.OpenRead(zipFile.FullPath);
        var bar = pCtx.AddTask($"Extracting {name}", maxValue: (int) zip.Entries.Select(e => e.Length).Sum());

        foreach (var entry in zip.Entries)
        {
            // Use Path.Combine to ensure the trailing slash is preserved.
            var fullPath = Path.Combine(destination.FullPath, entry.FullName);
            var fileName = Path.GetFileName(fullPath);
            if (string.IsNullOrEmpty(fileName))
            {
                Directory.CreateDirectory(fullPath);
                continue;
            }

            Directory.CreateDirectory(Path.GetDirectoryName(fullPath) ?? throw new InvalidOperationException());
            await using var fs = File.Create(fullPath);
            await using var stream = entry.Open();
            var buffer = new byte[4096];
            int read;
            while ((read = await stream.ReadAsync(buffer)) > 0)
            {
                await fs.WriteAsync(buffer.AsMemory(0, read));
                bar.Increment(read);
            }
        }
    }
}

```

`build/GitTasks.cs`:

```cs
using Cake.Common;
using Cake.Core;

static class GitTasks
{
    public static string Git(this ICakeContext ctx, string args, string separator = "")
    {
        using var process = ctx.StartAndReturnProcess("git", new() { Arguments = args, RedirectStandardOutput = true });
        process.WaitForExit();
        return string.Join(separator, process.GetStandardOutput());
    }
}

```

`build/Program.cs`:

```cs
#pragma warning disable CS1591
// ReSharper disable ClassNeverInstantiated.Global
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Cake.Common;
using Cake.Common.IO;
using Cake.Common.Tools.DotNet;
using Cake.Common.Tools.DotNet.Build;
using Cake.Common.Tools.DotNet.NuGet.Push;
using Cake.Core;
using Cake.Core.Diagnostics;
using Cake.Core.IO;
using Cake.Frosting;
using Cake.Git;
using Cake.Json;
using Microsoft.Build.Definition;
using Microsoft.Build.Evaluation;

return new CakeHost()
       .UseContext<BuildContext>()
       .Run(args);

public class BuildContext : FrostingContext
{
    public enum ProjectBuildType
    {
        Release,
        Development,
        BleedingEdge
    }

    public const string DoorstopVersion = "4.0.0";
    public const string DotnetRuntimeVersion = "6.0.7";
    public const string DobbyVersion = "1.0.2";

    public const string DotnetRuntimeZipUrl =
        $"https://github.com/BepInEx/dotnet-runtime/releases/download/{DotnetRuntimeVersion}/mini-coreclr-Release.zip";

    internal readonly DistributionTarget[] Distributions =
    {
        new("Unity.Mono", "win-x86"),
        new("Unity.Mono", "win-x64"),
        new("Unity.Mono", "linux-x86"),
        new("Unity.Mono", "linux-x64"),
        new("Unity.Mono", "macos-x64"),
        new("Unity.IL2CPP", "win-x86"),
        new("Unity.IL2CPP", "win-x64"),
        new("Unity.IL2CPP", "linux-x64"),
        new("Unity.IL2CPP", "macos-x64"),
        new("NET.Framework", "win-x64"),
        new("NET.CoreCLR", "win-x64")
    };


    public BuildContext(ICakeContext ctx)
        : base(ctx)
    {
        RootDirectory = ctx.Environment.WorkingDirectory.GetParent();
        OutputDirectory = RootDirectory.Combine("bin");
        CacheDirectory = OutputDirectory.Combine(".dep_cache");
        DistributionDirectory = OutputDirectory.Combine("dist");
        var props = Project.FromFile(RootDirectory.CombineWithFilePath("Directory.Build.props").FullPath,
                                     new ProjectOptions());
        VersionPrefix = props.GetPropertyValue("VersionPrefix");
        CurrentCommit = ctx.GitLogTip(RootDirectory);

        BuildType = ctx.Argument("build-type", ProjectBuildType.Development);
        BuildId = ctx.Argument("build-id", -1);
        LastBuildCommit = ctx.Argument("last-build-commit", "");
        NugetApiKey = ctx.Argument("nuget-api-key", "");
        NugetSource = ctx.Argument("nuget-source", "https://nuget.bepinex.dev/v3/index.json");
    }

    public ProjectBuildType BuildType { get; }
    public int BuildId { get; }
    public string LastBuildCommit { get; }
    public string NugetApiKey { get; }
    public string NugetSource { get; }

    public DirectoryPath RootDirectory { get; }
    public DirectoryPath OutputDirectory { get; }
    public DirectoryPath CacheDirectory { get; }
    public DirectoryPath DistributionDirectory { get; }

    public string VersionPrefix { get; }
    public GitCommit CurrentCommit { get; }

    public string VersionSuffix => BuildType switch
    {
        ProjectBuildType.Release      => "",
        ProjectBuildType.Development  => "dev",
        ProjectBuildType.BleedingEdge => $"be.{BuildId}",
        var _                         => throw new ArgumentOutOfRangeException()
    };

    public string BuildPackageVersion =>
        VersionPrefix + BuildType switch
        {
            ProjectBuildType.Release => "",
            var _                    => $"-{VersionSuffix}+{this.GitShortenSha(RootDirectory, CurrentCommit)}",
        };

    public static string DoorstopZipUrl(string arch) =>
        $"https://github.com/NeighTools/UnityDoorstop/releases/download/v{DoorstopVersion}/doorstop_{arch}_release_{DoorstopVersion}.zip";

    public static string DobbyZipUrl(string arch) =>
        $"https://github.com/BepInEx/Dobby/releases/download/v{DobbyVersion}/dobby-{arch}.zip";
}

[TaskName("Clean")]
public sealed class CleanTask : FrostingTask<BuildContext>
{
    public override void Run(BuildContext ctx)
    {
        ctx.CreateDirectory(ctx.OutputDirectory);
        ctx.CleanDirectory(ctx.OutputDirectory,
                           f => !f.Path.FullPath.Contains(".dep_cache"));

        ctx.Log.Information("Cleaning up old build objects");
        ctx.CleanDirectories(ctx.RootDirectory.Combine("**/BepInEx.*/**/bin").FullPath);
        ctx.CleanDirectories(ctx.RootDirectory.Combine("**/BepInEx.*/**/obj").FullPath);
    }
}

[TaskName("Compile")]
[IsDependentOn(typeof(CleanTask))]
public sealed class CompileTask : FrostingTask<BuildContext>
{
    public override void Run(BuildContext ctx)
    {
        var buildSettings = new DotNetBuildSettings
        {
            Configuration = "Release"
        };
        if (ctx.BuildType != BuildContext.ProjectBuildType.Release)
        {
            buildSettings.MSBuildSettings = new()
            {
                VersionSuffix = ctx.VersionSuffix,
                Properties =
                {
                    ["SourceRevisionId"] = new[] { ctx.CurrentCommit.Sha },
                    ["RepositoryBranch"] = new[] { ctx.GitBranchCurrent(ctx.RootDirectory).FriendlyName }
                }
            };
        }

        ctx.DotNetBuild(ctx.RootDirectory.FullPath, buildSettings);
    }
}

[TaskName("DownloadDependencies")]
public sealed class DownloadDependenciesTask : FrostingTask<BuildContext>
{
    public override void Run(BuildContext ctx)
    {
        ctx.Log.Information("Downloading dependencies");
        ctx.CreateDirectory(ctx.CacheDirectory);

        var cache = new DependencyCache(ctx, ctx.CacheDirectory.CombineWithFilePath("cache.json"));

        cache.Refresh("NeighTools/UnityDoorstop", BuildContext.DoorstopVersion, () =>
        {
            ctx.Log.Information($"Downloading Doorstop {BuildContext.DoorstopVersion}");
            var doorstopDir = ctx.CacheDirectory.Combine("doorstop");
            ctx.CreateDirectory(doorstopDir);
            ctx.CleanDirectory(doorstopDir);
            var archs = new[] { "win", "linux", "macos" };
            var versions = archs
                           .Select(a => ($"Doorstop ({a})",
                                         BuildContext.DoorstopZipUrl(a),
                                         doorstopDir.Combine($"doorstop_{a}")))
                           .ToArray();
            ctx.DownloadZipFiles($"Doorstop {BuildContext.DoorstopVersion}", versions);
        });

        cache.Refresh("BepInEx/Dobby", BuildContext.DobbyVersion, () =>
        {
            ctx.Log.Information($"Downloading Dobby {BuildContext.DobbyVersion}");
            var dobbyDir = ctx.CacheDirectory.Combine("dobby");
            ctx.CreateDirectory(dobbyDir);
            ctx.CleanDirectory(dobbyDir);
            var archs = new[] { "win", "linux", "macos" };
            var versions = archs
                           .Select(a => ($"Dobby ({a})", BuildContext.DobbyZipUrl(a), dobbyDir.Combine($"dobby_{a}")))
                           .ToArray();
            ctx.DownloadZipFiles($"Dobby {BuildContext.DobbyVersion}", versions);
        });

        cache.Refresh("BepInEx/dotnet_runtime", BuildContext.DotnetRuntimeVersion, () =>
        {
            ctx.Log.Information($"Downloading dotnet runtime {BuildContext.DotnetRuntimeVersion}");
            var dotnetDir = ctx.CacheDirectory.Combine("dotnet");
            ctx.CreateDirectory(dotnetDir);
            ctx.CleanDirectory(dotnetDir);
            ctx.DownloadZipFiles($"dotnet-runtime {BuildContext.DotnetRuntimeVersion}",
                                 ("dotnet runtime", BuildContext.DotnetRuntimeZipUrl, dotnetDir));
        });

        cache.Save();
    }
}

[TaskName("MakeDist")]
[IsDependentOn(typeof(CompileTask))]
[IsDependentOn(typeof(DownloadDependenciesTask))]
public sealed class MakeDistTask : FrostingTask<BuildContext>
{
    public override void Run(BuildContext ctx)
    {
        ctx.CreateDirectory(ctx.DistributionDirectory);
        ctx.CleanDirectory(ctx.DistributionDirectory);

        var latestTag = ctx.Git("describe --tags --abbrev=0");
        var changelog = new StringBuilder()
                        .AppendLine(
                                    $"{ctx.Git($"rev-list --count {latestTag}..HEAD")} changes since {latestTag}")
                        .AppendLine()
                        .AppendLine("Changelog (excluding merge commits):")
                        .AppendLine(ctx.Git(
                                            $"--no-pager log --no-merges --pretty=\"format:* (%h) [%an] %s\" {latestTag}..HEAD",
                                            Environment.NewLine))
                        .ToString();


        foreach (var dist in ctx.Distributions)
        {
            ctx.Log.Information($"Creating distribution {dist.Target}");
            var targetDir = ctx.DistributionDirectory.Combine(dist.Target);
            ctx.CreateDirectory(targetDir);
            ctx.CleanDirectory(targetDir);

            var bepInExDir = targetDir.Combine("BepInEx");
            var bepInExCoreDir = bepInExDir.Combine("core");
            ctx.CreateDirectory(bepInExDir);
            ctx.CreateDirectory(bepInExCoreDir);
            ctx.CreateDirectory(bepInExDir.Combine("plugins"));
            ctx.CreateDirectory(bepInExDir.Combine("patchers"));

            File.WriteAllText(targetDir.CombineWithFilePath("changelog.txt").FullPath, changelog);
            foreach (var filePath in ctx.GetFiles(ctx.OutputDirectory.Combine(dist.DistributionIdentifier)
                                                     .Combine("*.*").FullPath))
                ctx.CopyFileToDirectory(filePath, bepInExCoreDir);

            if (dist.Engine == "Unity")
            {
                var doorstopPath =
                    ctx.CacheDirectory.Combine("doorstop").Combine($"doorstop_{dist.Os}").Combine(dist.Arch);
                foreach (var filePath in ctx.GetFiles(doorstopPath.Combine($"*.{dist.DllExtension}").FullPath))
                    ctx.CopyFileToDirectory(filePath, targetDir);
                ctx.CopyFileToDirectory(doorstopPath.CombineWithFilePath(".doorstop_version"), targetDir);
                var (doorstopConfigFile, doorstopConfigDistName) = dist.Os switch
                {
                    "win" => ($"doorstop_config_{dist.Runtime.ToLower()}.ini",
                              "doorstop_config.ini"),
                    "linux" or "macos" => ($"run_bepinex_{dist.Runtime.ToLower()}.sh",
                                           "run_bepinex.sh"),
                    var _ => throw new
                                 NotSupportedException(
                                                       $"Doorstop is not supported on {dist.Os}")
                };
                ctx.CopyFile(ctx.RootDirectory.Combine("Runtimes").Combine("Unity").Combine("Doorstop").CombineWithFilePath(doorstopConfigFile),
                             targetDir.CombineWithFilePath(doorstopConfigDistName));

                if (dist.Runtime == "IL2CPP")
                {
                    ctx.CopyFile(ctx.CacheDirectory.Combine("dobby").Combine($"dobby_{dist.Os}").CombineWithFilePath($"{dist.DllPrefix}dobby_{dist.Arch}.{dist.DllExtension}"),
                                 bepInExCoreDir.CombineWithFilePath($"{dist.DllPrefix}dobby.{dist.DllExtension}"));
                    ctx.CopyDirectory(ctx.CacheDirectory.Combine("dotnet").Combine(dist.RuntimeIndentifier),
                                      targetDir.Combine("dotnet"));
                }
            }

            if (dist.DistributionIdentifier == "NET.Framework")
            {
                ctx.DeleteFile(bepInExCoreDir.CombineWithFilePath("BepInEx.NET.Framework.Launcher.exe.config"));
                foreach (var filePath in ctx.GetFiles(bepInExCoreDir.Combine("BepInEx.NET.*").FullPath))
                    ctx.MoveFileToDirectory(filePath, targetDir);
            }

            if (dist.DistributionIdentifier == "NET.CoreCLR")
                foreach (var filePath in ctx.GetFiles(bepInExCoreDir.Combine("BepInEx.NET.CoreCLR.*").FullPath))
                    ctx.MoveFileToDirectory(filePath, targetDir);
        }
    }
}

[TaskName("PushNuGet")]
public sealed class PushNuGetTask : FrostingTask<BuildContext>
{
    public override bool ShouldRun(BuildContext ctx) => !string.IsNullOrWhiteSpace(ctx.NugetApiKey) &&
                                                        ctx.BuildType != BuildContext.ProjectBuildType.Development;

    public override void Run(BuildContext ctx)
    {
        var nugetPath = ctx.OutputDirectory.Combine("NuGet");
        var settings = new DotNetNuGetPushSettings
        {
            Source = ctx.NugetSource,
            ApiKey = ctx.NugetApiKey
        };
        foreach (var pkg in ctx.GetFiles(nugetPath.Combine("*.nupkg").FullPath))
            ctx.DotNetNuGetPush(pkg, settings);
    }
}

[TaskName("Publish")]
[IsDependentOn(typeof(MakeDistTask))]
[IsDependentOn(typeof(PushNuGetTask))]
public sealed class PublishTask : FrostingTask<BuildContext>
{
    public override void Run(BuildContext ctx)
    {
        ctx.Log.Information("Packing BepInEx");

        foreach (var dist in ctx.Distributions)
        {
            var targetZipName = $"BepInEx-{dist.Target}-{ctx.BuildPackageVersion}.zip";
            ctx.Log.Information($"Packing {targetZipName}");
            ctx.Zip(ctx.DistributionDirectory.Combine(dist.Target),
                    ctx.DistributionDirectory
                       .CombineWithFilePath(targetZipName));
        }


        var changeLog = "";
        if (!string.IsNullOrWhiteSpace(ctx.LastBuildCommit))
        {
            var changeLogContents =
                ctx.Git($"--no-pager log --no-merges --pretty=\"format:<li>(<code>%h</code>) [%an] %s</li>\" {ctx.LastBuildCommit}..HEAD",
                        "\n");
            changeLog = $"<ul>{changeLogContents}</ul>";
        }

        ctx.SerializeJsonToPrettyFile(ctx.DistributionDirectory.CombineWithFilePath("info.json"),
                                      new Dictionary<string, object>
                                      {
                                          ["id"] = ctx.BuildId.ToString(),
                                          ["date"] = DateTime.Now.ToString("o"),
                                          ["changelog"] = changeLog,
                                          ["hash"] = ctx.CurrentCommit.Sha,
                                          ["short_hash"] = ctx.GitShortenSha(ctx.RootDirectory, ctx.CurrentCommit),
                                          ["artifacts"] = ctx.Distributions.Select(d => new Dictionary<string, string>
                                          {
                                              ["file"] = $"BepInEx-{d.Target}-{ctx.BuildPackageVersion}.zip",
                                              ["description"] =
                                                  $"BepInEx {d.Engine} ({d.Runtime}) for {d.ClearOsName} ({d.Arch}) games"
                                          }).ToArray()
                                      });
    }
}

[TaskName("Default")]
[IsDependentOn(typeof(CompileTask))]
public class DefaultTask : FrostingTask { }

```

`docs/BUILDING.md`:

```md
# Building BepInEx

You can build BepInEx two ways: by using `dotnet` or by using the automated build project.

## CakeBuild script

You can use the included `build` projected based on [cakebuild](https://cakebuild.net/) that allows you to automatically get dependencies, build and package everything.

**CakeBuild requires [.NET 6.0](https://dotnet.microsoft.com/download) or newer to be installed**

### Windows (Command Line)

Clone this repository via `git clone https://github.com/BepInEx/BepInEx.git`.  
After that, run in the repository directory

```bat
build.cmd --target Compile
```

### Windows (PowerShell)

Clone this repository via `git clone https://github.com/BepInEx/BepInEx.git`.  
After that, run in the repository directory

```ps
./build.ps1 --target Compile
```

Make sure you have the execution policy set to enable running scripts.

### Linux (Bash)

Clone this repository via `git clone https://github.com/BepInEx/BepInEx.git`.  
After that, run in the repository directory

```sh
./build.sh --target Compile
```

### Additional build targets

The build script provides the following build targets (that you can pass via the `target` parameter)

| Target     | Description                                                                                        |
|------------|----------------------------------------------------------------------------------------------------|
| `Compile`  | Pulls dependencies and builds BepInEx binaries                                                     |
| `MakeDist` | Runs `Compile` and creates distributable package for each distribution target to `bin/dist` folder |
| `Publish`  | Runs `MakeDist` and zips everything into archives into `bin/dist` folder                           |

```

`docs/CODE_OF_CONDUCT.md`:

```md
Don't be a jackass.
Being a horse is fine, though.
```

`docs/CONTRIBUTING.md`:

```md
# Contributing to this project

Please take a moment to review this document in order to make the contribution
process easy and effective for everyone involved.

Following these guidelines helps to communicate that you respect the time of
the developers managing and developing this open source project. In return,
they should reciprocate that respect in addressing your issue or assessing
patches and features.


## Using the issue tracker

The issue tracker is the preferred channel for [bug reports](#bugs),
[features requests](#features) and [submitting pull
requests](#pull-requests), but please respect the following restrictions:


* Please **do not** report issues that are not related to BepInEx. For issues 
  not related to BepInEx itself, consider using the following outlets:
  - **The game's own community for quick tech support.** (This is the quickest way to get help!)
  - [BepisPlugins repository](https://github.com/bbepis/BepisPlugins) to report issues with
    plugins, like IPALoader.

* Please **do not** derail or troll issues. Keep the discussion on topic and
  respect the opinions of others.


<a name="bugs"></a>
## Bug reports

A bug is a _demonstrable problem_ that is caused by the code **in this repository**.
Good bug reports are extremely helpful - thank you!

Guidelines for bug reports:

1. **Use the GitHub issue search** &mdash; check if the issue has already been
   reported.

2. **Check if the issue has been fixed** &mdash; try to reproduce it using the
   latest release of BepInEx.

3. **Isolate the problem** &mdash; Make screenshots of the errors, save the logs that clearly display the problem

A good bug report shouldn't leave others needing to chase you up for more
information. Please try to be as detailed as possible in your report. 

Most importantly, we want to know the following:

* What version of BepInEx do you use?
* What game do you use it on?
* What plug-ins do you have installed (as seen in the log)?

<a name="features"></a>
## Feature requests

Feature requests are welcome. But take a moment to find out whether your idea
fits with the scope and aims of the project. It's up to *you* to make a strong
case to convince the project's developers of the merits of this feature. Please
provide as much detail and context as possible.


<a name="pull-requests"></a>
## Pull requests

Good pull requests - patches, improvements, new features - are a fantastic
help. They should remain focused in scope and avoid containing unrelated
commits.

**Please ask first** before embarking on any significant pull request (e.g.
implementing features, refactoring code, porting to a different language),
otherwise you risk spending a lot of time working on something that the
project's developers might not want to merge into the project.

Please adhere to the coding conventions used throughout a project (indentation,
accurate comments, etc.) and any other requirements (such as test coverage).

Follow this process if you'd like your work considered for inclusion in the
project:

1. [Fork](http://help.github.com/fork-a-repo/) the project, clone your fork,
   and configure the remotes:

   ```bash
   # Clone your fork of the repo into the current directory
   git clone https://github.com/<your-username>/<repo-name>
   # Navigate to the newly cloned directory
   cd <repo-name>
   # Assign the original repo to a remote called "upstream"
   git remote add upstream https://github.com/<upstream-owner>/<repo-name>
   ```

2. If you cloned a while ago, get the latest changes from upstream:

   ```bash
   git checkout <dev-branch>
   git pull upstream <dev-branch>
   ```

3. Create a new topic branch (off the main project development branch) to
   contain your feature, change, or fix:

   ```bash
   git checkout -b <topic-branch-name>
   ```

4. Commit your changes in logical chunks. Please adhere to these [git commit
   message guidelines](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)
   or your code is unlikely be merged into the main project. Use Git's
   [interactive rebase](https://help.github.com/articles/interactive-rebase)
   feature to tidy up your commits before making them public.

5. Locally merge (or rebase) the upstream development branch into your topic branch:

   ```bash
   git pull [--rebase] upstream <dev-branch>
   ```

6. Push your topic branch up to your fork:

   ```bash
   git push origin <topic-branch-name>
   ```

7. [Open a Pull Request](https://help.github.com/articles/using-pull-requests/)
    with a clear title and description.

**IMPORTANT**: By submitting a patch, you agree to allow the project owner to
license your work under the same license as that used by the project.
```

`nuget.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="BepInEx" value="https://nuget.bepinex.dev/v3/index.json" />
  </packageSources>
</configuration>
```