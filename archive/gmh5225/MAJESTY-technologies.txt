Project Path: arc_gmh5225_MAJESTY-technologies_1uxcegdw

Source Tree:

```txt
arc_gmh5225_MAJESTY-technologies_1uxcegdw
├── Dead DbgkpProcessDebugPortMutex.png
├── Dead ValidAccessMask.png
├── Detect instrumentation callbacks.png
├── MAJESTY technologies
│   ├── AntiDebug.hpp
│   ├── AntiHypervisor.hpp
│   ├── ApiWrapper.hpp
│   ├── DriverEntry.cpp
│   ├── GetPID.h
│   ├── MAJESTY technologies.vcxproj
│   ├── MAJESTY technologies.vcxproj.filters
│   ├── MAJESTY technologies.vcxproj.user
│   ├── MAJESTYtechnologies.inf
│   ├── MurmurHash2A.h
│   ├── NoCRT.h
│   ├── NtApiDef.h
│   ├── Offset.hpp
│   ├── PplibEx.hpp
│   ├── Struct.h
│   ├── Util.hpp
│   └── xorstr.h
├── MAJESTY technologies.sln
├── Open handle to protected process.png
├── Protect Process.png
├── README.md
├── SexyTest
│   ├── SexyTest.cpp
│   ├── SexyTest.vcxproj
│   ├── SexyTest.vcxproj.filters
│   └── SexyTest.vcxproj.user
└── Under HyperHide.png

```

`MAJESTY technologies.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MAJESTY technologies", "MAJESTY technologies\MAJESTY technologies.vcxproj", "{2053487A-DF6D-4376-8073-5D8D719FCD58}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SexyTest", "SexyTest\SexyTest.vcxproj", "{A45AD110-CBE7-4A47-8C04-B11BDF99C585}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|ARM.ActiveCfg = Debug|ARM
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|ARM.Build.0 = Debug|ARM
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|ARM.Deploy.0 = Debug|ARM
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|ARM64.Build.0 = Debug|ARM64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|x64.ActiveCfg = Debug|x64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|x64.Build.0 = Debug|x64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|x64.Deploy.0 = Debug|x64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|x86.ActiveCfg = Debug|Win32
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|x86.Build.0 = Debug|Win32
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Debug|x86.Deploy.0 = Debug|Win32
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|ARM.ActiveCfg = Release|ARM
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|ARM.Build.0 = Release|ARM
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|ARM.Deploy.0 = Release|ARM
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|ARM64.ActiveCfg = Release|ARM64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|ARM64.Build.0 = Release|ARM64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|ARM64.Deploy.0 = Release|ARM64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|x64.ActiveCfg = Release|x64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|x64.Build.0 = Release|x64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|x64.Deploy.0 = Release|x64
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|x86.ActiveCfg = Release|Win32
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|x86.Build.0 = Release|Win32
		{2053487A-DF6D-4376-8073-5D8D719FCD58}.Release|x86.Deploy.0 = Release|Win32
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Debug|ARM.ActiveCfg = Debug|Win32
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Debug|ARM64.ActiveCfg = Debug|Win32
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Debug|x64.ActiveCfg = Debug|x64
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Debug|x64.Build.0 = Debug|x64
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Debug|x86.ActiveCfg = Debug|Win32
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Debug|x86.Build.0 = Debug|Win32
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Release|ARM.ActiveCfg = Release|Win32
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Release|ARM64.ActiveCfg = Release|Win32
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Release|x64.ActiveCfg = Release|x64
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Release|x64.Build.0 = Release|x64
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Release|x86.ActiveCfg = Release|Win32
		{A45AD110-CBE7-4A47-8C04-B11BDF99C585}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5CABFDAA-AB36-452E-9EF2-4F1CDEA3D31C}
	EndGlobalSection
EndGlobal

```

`MAJESTY technologies/AntiDebug.hpp`:

```hpp
#pragma once

#include "GetPID.h"
#include "Offset.hpp"

namespace AntiDebug
{

	namespace AntiUserModeAntiDebug
	{
		//Just check DebugPort in PEPROCESS
		__forceinline	bool PsIsProcessBeingDebugged(HANDLE procId)
		{


			uint64_t IsdebugPort = 0;
			if (procId)
			{
				PEPROCESS proc;



				if (NT_SUCCESS(PIDHelp::GetEProcessByProcId(procId, &proc)))
				{

					IsdebugPort = *(uint32_t*)((uint64_t)proc + Offset::debugOffset.DebugPort);



				}
			}
			return IsdebugPort;

		}







		//Just check NoDebugInherit  in PEPROCESS
		__forceinline	bool IsProcessDebugFlag(HANDLE procId)
		{
			/*
			NoDebugInherit safe  if  debugger detaches?
			*/


			processFlag2 IsDebugFlag{ 0 };
			if (procId)
			{
				PEPROCESS proc;


				if (NT_SUCCESS(PIDHelp::GetEProcessByProcId(procId, &proc)))
				{
					IsDebugFlag = (*(processFlag2*)((uint64_t)proc + Offset::debugOffset.NoDebugInherit));


				}
			}
			return IsDebugFlag.NoDebugInherit;

		}


		 
		  
		//Brute force find thread and check procId by thread
		__forceinline bool  HideManualThread(HANDLE procId)
		{

			bool IsSetHide = false;

			PETHREAD Thread;


			auto PsLookupThreadByThreadId = (t_PsLookupThreadByThreadId)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("PsLookupThreadByThreadId"));

			auto ObfDereferenceObject= (t_ObfDereferenceObject)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("ObfDereferenceObject"));

			for (size_t i = 0; i < 35000; i++)
			{


				if (NT_SUCCESS(PsLookupThreadByThreadId((HANDLE)i, &Thread)))
				{

					auto proc = *(PEPROCESS*)((uint64_t)Thread + Offset::debugOffset.Process);

					if (proc)
					{
						auto procIdProcess = *(HANDLE*)((uint64_t)proc + PIDHelp::OffsetHelp::OffsetUniqueProcessId);

						if (procId == procIdProcess)
						{
							if ((*(uint32_t*)((uint64_t)Thread + Offset::debugOffset.HideFromDebugger) & 0x4) == 0)
							{
								*(uint32_t*)((uint64_t)Thread + Offset::debugOffset.HideFromDebugger) ^= 4;
								IsSetHide =  true;


							}
						}
					}
					ObfDereferenceObject(Thread);
				}

			}

			return IsSetHide;

		}

		//Brute force find thread and check procId by thread
		__forceinline bool  IsHardwareBreakpoint(HANDLE procId)
		{

			bool IsHardwareBreakpoint  = false;

			PETHREAD Thread;

			auto PsLookupThreadByThreadId = (t_PsLookupThreadByThreadId)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("PsLookupThreadByThreadId"));

			auto PsGetContextThread = (t_PsGetContextThread)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("PsGetContextThread"));
			auto ObfDereferenceObject = (t_ObfDereferenceObject )Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("ObfDereferenceObject"));

			for (size_t i = 0; i < 35000; i++)
			{


				if (NT_SUCCESS(PsLookupThreadByThreadId((HANDLE)i, &Thread)))
				{

					auto proc = *(PEPROCESS*)((uint64_t)Thread + Offset::debugOffset.Process);

					if (proc)
					{
						auto procIdProcess = *(HANDLE*)((uint64_t)proc + PIDHelp::OffsetHelp::OffsetUniqueProcessId);

						if (procId == procIdProcess)
						{
							CONTEXT ctx;
							ctx.ContextFlags = CONTEXT_ALL; 
							if (NT_SUCCESS(PsGetContextThread(Thread,&ctx, KernelMode)))
							{
								if (ctx.Dr7 && ctx.Dr6)
								{
									IsHardwareBreakpoint = true;
								}
							
							} 
						}
					}
					ObfDereferenceObject(Thread);
				}

			}

			return IsHardwareBreakpoint;

		}

		

		__forceinline	bool IsUnderExplorer(HANDLE procId)
		{



			bool underExplorer = false;

			auto procIDExploler = PIDHelp::GetID(xorstr_("explorer.exe"));

			if (procId && procIDExploler)
			{
				PEPROCESS proc;

				if (NT_SUCCESS(PIDHelp::GetEProcessByProcId(procId, &proc)))
				{
					auto uniqIdProc = *(uint64_t*)((uint64_t)proc + Offset::debugOffset.InheritedFromUniqueProcessId);


					underExplorer = (uint64_t)procIDExploler != uniqIdProc;



				}
			}
			return underExplorer;

		}




		__forceinline bool IsInstrCallbacks(HANDLE procId)
		{
			uint64_t IsInstEnable = 0;
			if (procId)
			{
				PEPROCESS proc;


				if (NT_SUCCESS(PIDHelp::GetEProcessByProcId(procId, &proc)))
				{
					IsInstEnable = *(uint64_t*)((uint64_t)proc + Offset::debugOffset.InstrumentationCallback);


				}
			}
			return IsInstEnable != 0;
		}
		
		__forceinline bool BreakDebugPortMutex ()
		{

			/*
			
			BF 53 03 00 C0  0F 84  

			 
			\xBF\x53\x03\x00\xC0\x0F\x84 xxx?xxx

			48 8D 0D
			*/

			auto ProcessDebugPortMutexSig = (uint64_t)Util::FindPatternImage((PVOID)gl_baseNtoskrnl, xorstr_("PAGE"), xorstr_("\xBF\x53\x03\x00\xC0\x0F\x84"), xorstr_("xxx?xxx"));

			if (!ProcessDebugPortMutexSig)
			{
				Log("Can't find pattern \n");
				return false;
			}
			for (size_t i = 0; *(BYTE*)(ProcessDebugPortMutexSig + i) != 0xc3; i++) //wallking while not ret 
			{
				if (
					*(BYTE*)(ProcessDebugPortMutexSig + i) == 0x48 &&
					*(BYTE*)(ProcessDebugPortMutexSig + i + 1) == 0x8D &&
					*(BYTE*)(ProcessDebugPortMutexSig + i + 2) == 0x0D
					)
				{
					ProcessDebugPortMutexSig += i;
					auto ProcessDebugPortMutexFix = (uint64_t)Util::ResolveRelativeAddress((PVOID)ProcessDebugPortMutexSig, 3, 7);
 
					*( bool* )ProcessDebugPortMutexFix = 0;
					return true;
				}
			}

			return false;



		}

		__forceinline bool DisableValidAccessMask()
		{
			/*
			 Very thank's https://www.codenong.com/cs106696582/
				
				40 8A C5 4C 89 ? 24 ?

				\x40\x8A\xC5\xC4\x89\x00\x24\x00 xxxxx?x? 

			48 8B 05

			48 8B 05 A1 1F D9 FF                            mov     rax, cs:DbgkDebugObjectType // 7 

			48 8B 05 C6 9C 47 00                            mov     rax, cs:DbgkDebugObjectType // 10 
			
			*/
			auto DbgObjectPattern = (uint64_t)Util::FindPatternImage((PVOID)gl_baseNtoskrnl, xorstr_("PAGE"), xorstr_("\x40\x8A\xC5\x4C\x89\x00\x24\x00"), xorstr_("xxxxx?x?"));
		
			if (!DbgObjectPattern)
			{
				Log("Can't find pattern \n");
				return false;
			}

			for (size_t i = 0;*(BYTE*)(DbgObjectPattern + i) != 0xc3; i++) //wallking while not ret 
			{
				if (
					*(BYTE*)(DbgObjectPattern + i) ==  0x48 &&
					*(BYTE*)(DbgObjectPattern + i + 1 ) == 0x8b &&
					*(BYTE*)(DbgObjectPattern + i + 2) == 0x05
					)
				{
					DbgObjectPattern += i;
					auto DbgObjectPatternFixValue = (uint64_t)Util::ResolveRelativeAddress((PVOID)DbgObjectPattern, 3, 7);

					auto ObjectTypePointer = *(uint64_t*)(DbgObjectPatternFixValue);

					*(ULONG*)(ObjectTypePointer + 0x40 + 0x1c) = 0; // _OBJECT_TYPE -> TypeInfo - 0x40   ValidAccessMask - 0x1c 
					return true;
				}
			}
			
			return false;

			
		}
	}


	namespace AntiKernelDebug
	{


		//Just call DisableKernelDebug like mhyprot(AC genshin impact) https://www.godeye.club/2021/06/03/002-mhyprot-insider-callbacks.html
		__forceinline	bool DisableKernelDebug()
		{

			auto KdDisableDebugger = (t_KdDisableDebugger)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("KdDisableDebugger"));
			auto status = KdDisableDebugger();
			return	MurmurHash2A(status,7,7) != MurmurHash2A( STATUS_DEBUGGER_INACTIVE,7,7);

			// https://www.godeye.club/2021/06/03/002-mhyprot-insider-callbacks.html

		}

		//Call ZwSystemDebugControl with SysDbgBreakPoint
		__forceinline bool DebugTrigger()
		{

			//	https://pastebin.com/6kbt1Vka



			auto ZwSystemDebugControl = (t_ZwSystemDebugControl)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("ZwSystemDebugControl"));
			auto status = ZwSystemDebugControl(
				SysDbgBreakPoint,
				0,
				0,
				0,
				0,
				0
				);

		return MurmurHash2A(status, 10, 10) != MurmurHash2A(STATUS_DEBUGGER_INACTIVE, 10, 10);
		}

		//Call KdChangeOption like Vanguard  -> https://www.unknowncheats.me/forum/2798056-post2.html
		__forceinline	bool IsChangeOpthion()
		{

			auto KdChangeOption = (t_KdChangeOption)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("KdChangeOption"));
			auto status = KdChangeOption(KD_OPTION_SET_BLOCK_ENABLE, NULL, NULL, NULL, NULL, NULL);
			return MurmurHash2A(status, 6, 6) != MurmurHash2A(STATUS_DEBUGGER_INACTIVE, 6, 6);

		}



		//Check Some value ( more info -> https://shhoya.github.io/antikernel_kerneldebugging4.html	)
		__forceinline	bool CheckGlobalValue()
		{
			 

			auto kernelDebuggerPres = *(BYTE*)(0xFFFFF78000000000 + 0x02D4);

			 

			//	check value in KUSER_SHARED_DATA 

			if ((kernelDebuggerPres & 1) || (kernelDebuggerPres & 2))
			{
				return true;
			}
			auto  patternKdpBootedNodebug = (uint64_t)Util::FindPatternImage((PVOID)gl_baseNtoskrnl, xorstr_("PAGE"), xorstr_("\x4C\x8B\xD2\x83\x64\x24\x00\x00\x48\x83"), xorstr_("xxxxxx??xx"));

			if (patternKdpBootedNodebug)
			{

				/*
				4C 8B D2 83 64 24  ? ? 48 83

				\x4C\x8B\xD2\x83\x64\x24\x00\x00\x48\x83  xxxxxx??xx

				80 3D ? ? ? ?  00 // KdpBootedNodebug
				*/
				for (size_t i = 0; *(BYTE*)(patternKdpBootedNodebug + i) != 0xc3; i++) //wallking while not 1  ret 
				{
					if (
						*(BYTE*)(patternKdpBootedNodebug + i) == 0x80 &&
						*(BYTE*)(patternKdpBootedNodebug + i + 1) == 0x3D
						)
					{
						patternKdpBootedNodebug += i;
						auto KdpBootedNodebugFix = (uint64_t)Util::ResolveRelativeAddress((PVOID)patternKdpBootedNodebug, 2, 7);


						if (!*(bool*)KdpBootedNodebugFix)
						{
							return true;
						}

						break;

					}
				}


			}

			/*
			48 89 ? ? ?      45 33 C9    45 8B C2
			\x48\x89\x00\x00\x00\x45\x33\xC9\x45\x8B\xC2  xx???xxxxxx
			*/
			auto KdpReadVirtualMemoryPattern = (uint64_t)Util::FindPatternImage((PVOID)gl_baseNtoskrnl, xorstr_("PAGEKD"), xorstr_("\x48\x89\x00\x00\x00\x45\x33\xC9\x45\x8B\xC2"), xorstr_("xx???xxxxxx"));
			if (KdpReadVirtualMemoryPattern)
			{
				for (size_t i = 0; *(BYTE*)(KdpReadVirtualMemoryPattern + i) != 0xc3; i++) //wallking while not 1  ret 
				{

					if (
						*(BYTE*)(KdpReadVirtualMemoryPattern + i) == 0x4c &&
						*(BYTE*)(KdpReadVirtualMemoryPattern + i + 1) == 0x8D &&
						*(BYTE*)(KdpReadVirtualMemoryPattern + i + 2) == 0X0D
						)
					{
						KdpReadVirtualMemoryPattern += i;
						auto KdpContextFix = (uint64_t)Util::ResolveRelativeAddress((PVOID)KdpReadVirtualMemoryPattern, 3, 7);


						if (*(uint64_t*)KdpContextFix)
						{
							return true;
						}

						break;

					}
				}
			}
			
				/*
			F6 C1 02  74 ? 83   E1 FD         
			\xF6\xC1\x02\x74\x00\x83\xE1\xFD  xxxx?xxx
			
			2 pattern  48 8D 0D   

			40 53    48 83 EC 20   firs't byte
			*/
			auto KdpLowWriteContentpattern = (uint64_t)Util::FindPatternImage((PVOID)gl_baseNtoskrnl, xorstr_("PAGEKD"), xorstr_("\xF6\xC1\x02\x74\x00\x83\xE1\xFD"), xorstr_("xxxx?xxx"));
			if (KdpLowWriteContentpattern)
			{
				for (size_t i = 0; i < 90 || !((*(BYTE*)(KdpLowWriteContentpattern - i) == 0x40 && (*(BYTE*)(KdpLowWriteContentpattern - i + 1) == 0x53))); i++)
				{

					if (
						*(BYTE*)(KdpLowWriteContentpattern - i) == 0x48 &&
						*(BYTE*)(KdpLowWriteContentpattern - i + 1) == 0x8D &&
						*(BYTE*)(KdpLowWriteContentpattern - i + 2) == 0x0D
						)
					{
						KdpLowWriteContentpattern -= i;
						auto KdpBreakpointTableFix = (uint64_t)Util::ResolveRelativeAddress((PVOID)KdpLowWriteContentpattern, 3, 7);
					
						for (size_t j = 0; j <= 3 * 0x28; j++) // size struct 0x28 and we check 3 breakpoint 
						{
							if (*(BYTE*)(KdpBreakpointTableFix + j) !=0)
							{
								return true;
							}
						}
						break;
					}
				}
			}
			 

			/*
			7E 11  BA 01 00 00 00  48 8D 0D ? ? ? ? E8 ? ? ? FF


			\x7E\x11\xBA\x01\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\xFF

			xxxxxxxxxx????x???x
			*/
			auto KdpTimeSlipDpcRoutinePattern = (uint64_t)Util::FindPatternImage((PVOID)gl_baseNtoskrnl, xorstr_("PAGEKD"), xorstr_("\x7E\x11\xBA\x01\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\xFF"), xorstr_("xxxxxxxxxx????x???x"));
			if (KdpTimeSlipDpcRoutinePattern)
			{
				for (size_t i = 0; *(BYTE*)(KdpTimeSlipDpcRoutinePattern + i) != 0xc3; i++) //wallking while not 1  ret 
				{

					if (
						*(BYTE*)(KdpTimeSlipDpcRoutinePattern + i) == 0x48 &&
						*(BYTE*)(KdpTimeSlipDpcRoutinePattern + i + 1) == 0x8D &&
						*(BYTE*)(KdpTimeSlipDpcRoutinePattern + i + 2) == 0x0D
						)
					{
						KdpTimeSlipDpcRoutinePattern += i;
						auto KdpTimeSlipWorkItemFix = (uint64_t)Util::ResolveRelativeAddress((PVOID)KdpTimeSlipDpcRoutinePattern, 3, 7);

						for (size_t j = 0; j <= 0x20; j++) //size(WORK_QUEUE_ITEM) = 0x20 
						{
							if (*(BYTE*)(KdpTimeSlipWorkItemFix+ j))
							{
								return true;
							}

						}
						break;

					}
				}

			}

			/*
			? 38 ? ? ? ? ? 75 ? 45 ? ? ? 88 ? ? ? ? ? 48 8D
			\x00\x38\x00\x00\x00\x00\x00\x75\x00\x45\x00\x00\x00\x88\x00\x00\x00\x00\x00\x48\x8D
			?x?????x?x???x?????xx
			*/

			auto KdpDebuggerStructuresInitializedPattern = (uint64_t)Util::FindPatternImage((PVOID)gl_baseNtoskrnl, xorstr_("PAGEKD"), xorstr_("\x00\x38\x00\x00\x00\x00\x00\x75\x00\x45\x00\x00\x00\x88\x00\x00\x00\x00\x00\x48\x8D"), xorstr_("?x?????x?x???x?????xx"));
			if (KdpDebuggerStructuresInitializedPattern)
			{
				auto KdpDebuggerStructuresInitializedFix = (uint64_t)Util::ResolveRelativeAddress((PVOID)KdpDebuggerStructuresInitializedPattern, 3, 7);
				if (*(bool*)KdpDebuggerStructuresInitializedFix)
				{
					return true;
				}
			}
			return false;
		}
			
			

	}

}

```

`MAJESTY technologies/AntiHypervisor.hpp`:

```hpp
#pragma once

#include "Util.hpp"
#include "MurmurHash2A.h" 
//	https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html




namespace DetectHyp
{
		__forceinline	bool ProcIsIntel()
		{
			int cpuid[4]{ -1 }; 
			__cpuid(cpuid, 0);
				if (MurmurHash2A(cpuid[2],4,4) == MurmurHash2A('letn',4,4))
				{	
					return true;		
				}
			return false;
		}	

	__forceinline	bool compare_list_cpuid()
	{
		//compare cpuid  list
		int  invalid_cpuid_list[4] = { -1 };
		int valid_cpuid_list[4] = { -1 }; 

		__cpuid(invalid_cpuid_list, 0x13371337);
		__cpuid(valid_cpuid_list, 0x40000000);

		if ((invalid_cpuid_list[0] != valid_cpuid_list[0]) ||
			(invalid_cpuid_list[1] != valid_cpuid_list[1]) ||
			(invalid_cpuid_list[2] != valid_cpuid_list[2]) ||
			(invalid_cpuid_list[3] != valid_cpuid_list[3]))
			return true;

		return false;



	}

	__forceinline bool cpuid_is_hypervisor()
	{
		int cpuid[4] = { 0 };
		__cpuid(cpuid, 1);
		return ((cpuid[2] >> 31) & 1);
	}



		bool   time_attack_rdtsc()
		{ 
		uint64_t avg = 0;
		int cpuInfo[4] = {}; 
		for (int i = 0; i < 2500; i++)
		{
			auto tick1 = __readmsr(IA32_TIME_STAMP_COUNTER);
			__cpuid(cpuInfo, 0);// vm-exit
			auto tick2 = __readmsr(IA32_TIME_STAMP_COUNTER);
			avg += (tick2 - tick1);
		} 
		avg /= 2500;
		return (avg < 500 && avg > 25) ? false : true;
		}




	// Some hypervisor just  0(like:VMware)
	bool time_attack_MPERF()
	{


		int cpuid[4]{ -1 };
		uint64_t  avg{ 0 }; 
		for (int i = 0; i < 30; i++)
		{
			auto tick1 = __readmsr(IA32_MPERF_MSR);
			__cpuid(cpuid, 0);//call vm-exit
			auto tick2 = __readmsr(IA32_MPERF_MSR);

			if (!tick1 && !tick2)
			{
				return true;
			}

			avg += (tick2 - tick1);
		} 
		avg /= 30;
		return  (0x2ff < avg) || (0xc > avg );

	}

	// Some hypervisor just return 0(like:VMware)
	bool time_attack_APERF()
	{

		uint64_t avg{ 0 };
		int data[4]{ -1 }; 
		for (size_t i = 0; i < 30; i++)
		{
			auto  tick1 = __readmsr(IA32_APERF_MSR);
			__cpuid(data, 0); //call vm-exit
			auto tick2 = __readmsr(IA32_APERF_MSR);
			if (!tick1 && !tick2)
			{ 
				return true;
			} 
			avg += (tick2 - tick1);
		}
		avg /= 30;
		return  (0x2ff < avg) || (0x33 > avg);
	}

	__forceinline bool lbr_is_virtulazed()
	{
		if(ProcIsIntel())
		{
			auto current_value = __readmsr(MSR_DEBUGCTL);//safe current value
			__writemsr(MSR_DEBUGCTL, DEBUGCTL_LBR | DEBUGCTL_BTF);
			auto whatch_write = __readmsr(MSR_DEBUGCTL);
			__writemsr(MSR_DEBUGCTL, current_value);
			return (!(whatch_write & DEBUGCTL_LBR));
		}
		return false;
	}

	__forceinline bool lbr_stask_is_virtulazed()
	{
		if(ProcIsIntel())
		{
			int cpuid[4]{ -1 };
			auto currentLBR = __readmsr(MSR_P6M_LBSTK_TOS);
			__cpuid(cpuid, 0);//call vm-exit
			auto exitLBR = __readmsr(MSR_P6M_LBSTK_TOS);
			return currentLBR != exitLBR;
		}
		return false;

	}




}

```

`MAJESTY technologies/ApiWrapper.hpp`:

```hpp
#pragma once
#include "NoCrt.h"





namespace ApiWrapper
{
    __forceinline    UNICODE_STRING InitUnicodeString(static const wchar_t* string_to_init)
    {

        UNICODE_STRING stringInit{ 0 };
        if (string_to_init)
        {
            stringInit.Length = NoCRT::string::wstrlen(string_to_init) * sizeof(wchar_t);
            stringInit.MaximumLength = stringInit.Length + 2;
            stringInit.Buffer = (wchar_t*)string_to_init;
        }
        return stringInit;

    }





    __forceinline  int CompareUnicodeString(UNICODE_STRING str_1, UNICODE_STRING str_2, bool case_int_sensitive = false)
    {

        //return 0 if equal
        if (case_int_sensitive)
        {
            return NoCRT::string::wstrcmp(str_1.Buffer, str_2.Buffer);
        }
        else
        {
            return NoCRT::string::wstricmp(str_1.Buffer, str_2.Buffer);
        }

    }


    __forceinline  bool  EqualUnicodeString(UNICODE_STRING str_1, UNICODE_STRING str_2, bool case_in_sensitive = false)
    {
        //return 1 if equal
        if (case_in_sensitive)
        {
            return !NoCRT::string::wstrcmp(str_1.Buffer, str_2.Buffer);
        }
        else
        {
            return !NoCRT::string::wstricmp(str_1.Buffer, str_2.Buffer);
        }
    }






    __forceinline  void FreeUnicodeString(UNICODE_STRING& str)
    {
        //just set buffer/Length

        /*
        in disassembly  RtlFreeUnicodeString use ExFreePoolWithTag wrf?
        */
        str.Buffer = 0;
        str.Length = 0;
        str.MaximumLength = 0;
    }


    


    void NTAPI MoveMemory(
        PVOID Destination,
        CONST VOID* Source,
        SIZE_T Length
    )
    {
        NoCRT::mem::memmove(Destination, Source, Length);
    }


    __forceinline  SIZE_T NTAPI  RtlCompareMemory(
        IN const VOID* Source1,
        IN const VOID* Source2,
        IN SIZE_T Length)
    {
        return NoCRT::mem::memicmp(Source1, Source2, Length);
    }

    __forceinline   VOID  NTAPI   ZeroMemory
    (
        PVOID Destination,
        SIZE_T Length)
    {
        NoCRT::mem::memset(Destination, Length, 0);
    }

    __forceinline  VOID NTAPI FillMemoryUlonglong
    (
        PVOID Destination,
        SIZE_T Length,
        ULONGLONG Fill)
    {
        PULONGLONG Dest = (PULONGLONG)Destination;
        SIZE_T Count = Length / sizeof(ULONGLONG);

        while (Count > 0)
        {
            *Dest = Fill;
            Dest++;
            Count--;
        }
    }

}

```

`MAJESTY technologies/DriverEntry.cpp`:

```cpp

#include "AntiDebug.hpp" 
#include "AntiHypervisor.hpp"
#include "PplibEx.hpp"

//combine sections for  decrease size 

#pragma comment(linker, "/MERGE:.data=.text")

#pragma comment(linker, "/MERGE:.rdata=.text")

#pragma comment(linker, "/MERGE:.pdata=.text")

#pragma comment(linker, "/MERGE:INIT=.text")


//set ERW for present problem
#pragma comment(linker, "/SECTION:.text,EWR")



#define bEnableAntiUmDebugger 1
#define bEnableAntiHypervisor 1
#define bEnableAntiKMDebugger 1
#define bEnableAntiKMDebuggerGlobalValue 1
#define bEnableProtectProcess 1
#define bEnableBreakDebugger 1

/*
For manual map driver just  give base address ntoskrnl in parameters  (like kdmapper)	https://github.com/TheCruZ/kdmapper/blob/c3b404298bf90b8fb2e74c2be783569dd0eaa06e/kdmapper/main.cpp#L105


For not manual map driver just use DriverObject (more info:  https://www.unknowncheats.me/forum/general-programming-and-reversing/427419-getkernelbase.html	)


*/

NTSTATUS DriverEntry( uint64_t baseNtoskrnl, IN PUNICODE_STRING pRegistryPath)
{


	gl_baseNtoskrnl = baseNtoskrnl;	//just set global value,because i lazy 

	PIDHelp::OffsetHelp::InitOffset(); // init value for get pid and other staff

	 

	static HANDLE procId = PIDHelp::GetID(xorstr_("SexyTest.exe"));



	if (Offset::GetOffset() )
	{
		/*

			⣿⣿⣷⡁⢆⠈⠕⢕⢂⢕⢂⢕⢂⢔⢂⢕⢄⠂⣂⠂⠆⢂⢕⢂⢕⢂⢕⢂⢕⢂
			⣿⣿⣿⡷⠊⡢⡹⣦⡑⢂⢕⢂⢕⢂⢕⢂⠕⠔⠌⠝⠛⠶⠶⢶⣦⣄⢂⢕⢂⢕
			⣿⣿⠏⣠⣾⣦⡐⢌⢿⣷⣦⣅⡑⠕⠡⠐⢿⠿⣛⠟⠛⠛⠛⠛⠡⢷⡈⢂⢕⢂
			⠟⣡⣾⣿⣿⣿⣿⣦⣑⠝⢿⣿⣿⣿⣿⣿⡵⢁⣤⣶⣶⣿⢿⢿⢿⡟⢻⣤⢑⢂
			⣾⣿⣿⡿⢟⣛⣻⣿⣿⣿⣦⣬⣙⣻⣿⣿⣷⣿⣿⢟⢝⢕⢕⢕⢕⢽⣿⣿⣷⣔
			⣿⣿⠵⠚⠉⢀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣗⢕⢕⢕⢕⢕⢕⣽⣿⣿⣿⣿
			⢷⣂⣠⣴⣾⡿⡿⡻⡻⣿⣿⣴⣿⣿⣿⣿⣿⣿⣷⣵⣵⣵⣷⣿⣿⣿⣿⣿⣿⡿
			⢌⠻⣿⡿⡫⡪⡪⡪⡪⣺⣿⣿⣿⣿⣿⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃
			⠣⡁⠹⡪⡪⡪⡪⣪⣾⣿⣿⣿⣿⠋⠐⢉⢍⢄⢌⠻⣿⣿⣿⣿⣿⣿⣿⣿⠏⠈
			⡣⡘⢄⠙⣾⣾⣾⣿⣿⣿⣿⣿⣿⡀⢐⢕⢕⢕⢕⢕⡘⣿⣿⣿⣿⣿⣿⠏⠠⠈
			⠌⢊⢂⢣⠹⣿⣿⣿⣿⣿⣿⣿⣿⣧⢐⢕⢕⢕⢕⢕⢅⣿⣿⣿⣿⡿⢋⢜⠠⠈
			⠄⠁⠕⢝⡢⠈⠻⣿⣿⣿⣿⣿⣿⣿⣷⣕⣑⣑⣑⣵⣿⣿⣿⡿⢋⢔⢕⣿⠠⠈
			⠨⡂⡀⢑⢕⡅⠂⠄⠉⠛⠻⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢋⢔⢕⢕⣿⣿⠠⠈
			⠄⠪⣂⠁⢕⠆⠄⠂⠄⠁⡀⠂⡀⠄⢈⠉⢍⢛⢛⢛⢋⢔⢕⢕⢕⣽⣿⣿⠠⠈
		*/
		
#if bEnableAntiUmDebugger


		Log("Is debug port ->\t %x\n", AntiDebug::AntiUserModeAntiDebug::PsIsProcessBeingDebugged(procId));

		Log("Is debug flag ->\t %x\n", AntiDebug::AntiUserModeAntiDebug::IsProcessDebugFlag(procId));

		Log("Isn't under Explorer ->\t %x\n", AntiDebug::AntiUserModeAntiDebug::IsUnderExplorer(procId));

		Log("Is HardwareBreakpoint ->\t %x\n", AntiDebug::AntiUserModeAntiDebug::IsHardwareBreakpoint(procId));

		Log("Is find  thread and set HideFromDebugger ->\t %x\n", AntiDebug::AntiUserModeAntiDebug::HideManualThread(procId));

		Log("Is instumenthion callbakc ->\t %x\n", AntiDebug::AntiUserModeAntiDebug::IsInstrCallbacks(procId));

#endif


#if bEnableBreakDebugger


		Log("Is find  ValidAccessMask ->\t %x\n",AntiDebug::AntiUserModeAntiDebug::DisableValidAccessMask());
		Log("Is find   DebugMutex ->\t %x\n", AntiDebug::AntiUserModeAntiDebug::BreakDebugPortMutex());


#endif		

#if  bEnableProtectProcess

		PplibEx::ProtectProcessByPID(procId);
#endif 

		
		
	}

	else
	{
		Log("Can't find offset!\n");
	}
	
#if bEnableAntiKMDebugger


	Log("KdChangeOpthion ->\t %x\n", AntiDebug::AntiKernelDebug::IsChangeOpthion());
	Log("Disable kernel debugger ->\t %x\n", AntiDebug::AntiKernelDebug::DisableKernelDebug());
	Log("ZwSystemDebugControl ->\t %x\n", AntiDebug::AntiKernelDebug::DebugTrigger());

#endif	

#if bEnableAntiKMDebuggerGlobalValue

	Log("Global value antidebug ->\t %x\n", AntiDebug::AntiKernelDebug::CheckGlobalValue());

#endif


#if bEnableAntiHypervisor

 

	Log("Compare cpuid list ->\t %x\n", DetectHyp::compare_list_cpuid());
	Log("Cpuid is hypervisor ->\t %x\n", DetectHyp::cpuid_is_hypervisor());
	Log("Check virtualizathion lbr ->\t %x\n", DetectHyp::lbr_is_virtulazed());
	Log("Check stack lbr ->\t %x\n", DetectHyp::lbr_stask_is_virtulazed());


	Log("Time attack rdtsc ->\t %x\n", DetectHyp::time_attack_rdtsc());
	Log("Time attack with APERF ->\t %x\n", DetectHyp::time_attack_APERF());
	Log("Time attack with MPERF ->\t %x\n", DetectHyp::time_attack_MPERF());

#endif
	
	return STATUS_SUCCESS;



	
}
```

`MAJESTY technologies/GetPID.h`:

```h
#pragma once
#include "Util.hpp"
#include "MurmurHash2A.h"

//	https://www.unknowncheats.me/forum/c-and-c-/467342-kernel-getting-pid-xp-vista-7-8-8-1-10-11-a.html
namespace PIDHelp
{

	namespace OffsetHelp
	{

		static UINT OffsetUniqueProcessId = 0x0;
		static UINT OffsetActiveProcessLinks = 0x0;
		static UINT OffsetImageFileName = 0x0;
		static UINT OffsetActiveThreads = 0x0;
		static uint64_t*  myPsInitialSystemProcess = 0x0;

		__forceinline bool InitOffset()
		{


			myPsInitialSystemProcess = (uint64_t*)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("PsInitialSystemProcess"));


			PEPROCESS SystemProcess = (PEPROCESS)*myPsInitialSystemProcess;

			for (int i = 0; i < 0xFFF; i++) // 0xFFF larger than the size of full struct
			{
				if (!OffsetUniqueProcessId && !OffsetActiveProcessLinks)
				{
					if (
						MurmurHash2A (*(UINT64*)((UINT64)SystemProcess + i),4,4) == MurmurHash2A(4,4,4)							&& // 4 always, pid of system process
						*(UINT64*)((UINT64)SystemProcess + i + 0x8) > 0xFFFF000000000000)  // > 0xFFFF000000000000 always
					{
						OffsetUniqueProcessId = i;
						OffsetActiveProcessLinks = i + 0x8;
					}
				}
				if (!OffsetImageFileName && !OffsetActiveThreads)
				{
					if (*(UINT64*)((UINT64)SystemProcess + i) > 0x0000400000000000 && *(UINT64*)((UINT64)SystemProcess + i) < 0x0000800000000000 && // 0x00006D6574737953 always, but better to make range
						*(UINT64*)((UINT64)SystemProcess + i + 0x48) > 0 && *(UINT64*)((UINT64)SystemProcess + i + 0x48) < 0xFFF) // 80 ~ 300 in general
					{
						OffsetImageFileName = i;
						OffsetActiveThreads = i + 0x48;
					}
				}

				if (OffsetUniqueProcessId && OffsetActiveProcessLinks && OffsetImageFileName && OffsetActiveThreads)
				{
					return true;
				}
			}

			return false;
		}
	}

	__forceinline NTSTATUS  GetPEprocessByProcName(IN const CHAR* szProcessName, OUT PEPROCESS* pProcessInfo)
		{


			PEPROCESS SystemProcess = (PEPROCESS)*OffsetHelp::myPsInitialSystemProcess;


			PEPROCESS CurrentProcess = SystemProcess;

			do
			{
				if (NoCRT::string::strstr((CHAR*)((UINT64)CurrentProcess + OffsetHelp::OffsetImageFileName), szProcessName))
				{
					if (*(UINT*)((UINT64)CurrentProcess + OffsetHelp::OffsetActiveThreads))
					{
						*pProcessInfo = CurrentProcess;
						return STATUS_SUCCESS;
					}
				}

				PLIST_ENTRY List = (PLIST_ENTRY)((UINT64)(CurrentProcess)+OffsetHelp::OffsetActiveProcessLinks);
				CurrentProcess = (PEPROCESS)((UINT64)List->Flink - OffsetHelp::OffsetActiveProcessLinks);

			} while (CurrentProcess != SystemProcess);

			return STATUS_NOT_FOUND;


	}
	


	__forceinline  HANDLE GetID(IN const CHAR* szProcessName)
		{

		 

		PEPROCESS SystemProcess = (PEPROCESS)*OffsetHelp::myPsInitialSystemProcess;

		PEPROCESS CurrentProcess = SystemProcess;

		 

				do
				{
						if (NoCRT::string::strstr((CHAR*)((UINT64)CurrentProcess + OffsetHelp::OffsetImageFileName), szProcessName))
						{
							if (*(ULONG*)((UINT64)CurrentProcess + OffsetHelp::OffsetActiveThreads))
							{


								return *(HANDLE*)((UINT64)CurrentProcess + OffsetHelp::OffsetUniqueProcessId);
							}
						}

					PLIST_ENTRY List = (PLIST_ENTRY)((UINT64)(CurrentProcess)+OffsetHelp::OffsetActiveProcessLinks);
					CurrentProcess = (PEPROCESS)((UINT64)List->Flink - OffsetHelp::OffsetActiveProcessLinks);

				} while (CurrentProcess != SystemProcess);

				return 0;


	}
		
		
	 
	__forceinline  NTSTATUS GetEProcessByProcId(HANDLE procId, OUT PEPROCESS* pProcessInfo)
	{
		  
		PEPROCESS SystemProcess = (PEPROCESS)*OffsetHelp::myPsInitialSystemProcess;

		PEPROCESS CurrentProcess = SystemProcess;
		 

		 
			do
			{
				if (MurmurHash2A (*(uint64_t*)((UINT64)CurrentProcess + OffsetHelp::OffsetUniqueProcessId),9,9) == MurmurHash2A((uint64_t)procId,9,9))
				{
					if (*(UINT*)((UINT64)CurrentProcess + OffsetHelp::OffsetActiveThreads))
					{
						*pProcessInfo = CurrentProcess;
						return STATUS_SUCCESS;
					}
				}

				PLIST_ENTRY List = (PLIST_ENTRY)((UINT64)(CurrentProcess)+OffsetHelp::OffsetActiveProcessLinks);
				CurrentProcess = (PEPROCESS)((UINT64)List->Flink - OffsetHelp::OffsetActiveProcessLinks);

			} while (CurrentProcess != SystemProcess);

			return STATUS_NOT_FOUND;

		
		

	}
	

	__forceinline  PEPROCESS GetEProcessByProcIdEx(HANDLE procId)
	{




		PEPROCESS SystemProcess = (PEPROCESS)*OffsetHelp::myPsInitialSystemProcess;

		PEPROCESS CurrentProcess = SystemProcess;


		

				do
				{
					if (MurmurHash2A  (*(uint64_t*)((UINT64)CurrentProcess + OffsetHelp::OffsetUniqueProcessId),10,10) == MurmurHash2A((uint64_t) procId,10,10))
					{
						if (*(UINT*)((UINT64)CurrentProcess + OffsetHelp::OffsetActiveThreads))
						{
							return  CurrentProcess;
						 
						}
					}

					PLIST_ENTRY List = (PLIST_ENTRY)((UINT64)(CurrentProcess)+OffsetHelp::OffsetActiveProcessLinks);
					CurrentProcess = (PEPROCESS)((UINT64)List->Flink - OffsetHelp::OffsetActiveProcessLinks);

				} while (CurrentProcess != SystemProcess);

				return 0;



		return 0;
	}

}
```

`MAJESTY technologies/MAJESTY technologies.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{2053487A-DF6D-4376-8073-5D8D719FCD58}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>MAJESTY_technologies</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <Optimization>MinSpace</Optimization>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="MAJESTYtechnologies.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AntiDebug.hpp" />
    <ClInclude Include="AntiHypervisor.hpp" />
    <ClInclude Include="ApiWrapper.hpp" />
    <ClInclude Include="GetPID.h" />
    <ClInclude Include="MurmurHash2A.h" />
    <ClInclude Include="NoCRT.h" />
    <ClInclude Include="NtApiDef.h" />
    <ClInclude Include="Offset.hpp" />
    <ClInclude Include="PplibEx.hpp" />
    <ClInclude Include="Struct.h" />
    <ClInclude Include="Util.hpp" />
    <ClInclude Include="xorstr.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`MAJESTY technologies/MAJESTY technologies.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="ApiWrapper">
      <UniqueIdentifier>{6dcabf7f-b670-4db3-8628-752a8a658631}</UniqueIdentifier>
    </Filter>
    <Filter Include="Obfuscathion">
      <UniqueIdentifier>{cb6075d4-17df-4280-8fb7-103222b1c9e1}</UniqueIdentifier>
    </Filter>
    <Filter Include="AntiReverse">
      <UniqueIdentifier>{78b18822-0940-453a-97a3-e3733b35acfd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Asm">
      <UniqueIdentifier>{8e8481b3-a740-4a86-ad82-63ebaaa99a9b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Util">
      <UniqueIdentifier>{8dcc469a-1985-430a-9075-1f7ea06a9b37}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="MAJESTYtechnologies.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Util.hpp">
      <Filter>Util</Filter>
    </ClInclude>
    <ClInclude Include="GetPID.h">
      <Filter>Util</Filter>
    </ClInclude>
    <ClInclude Include="ApiWrapper.hpp">
      <Filter>ApiWrapper</Filter>
    </ClInclude>
    <ClInclude Include="NoCRT.h">
      <Filter>ApiWrapper</Filter>
    </ClInclude>
    <ClInclude Include="NtApiDef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiHypervisor.hpp">
      <Filter>AntiReverse</Filter>
    </ClInclude>
    <ClInclude Include="Offset.hpp">
      <Filter>AntiReverse</Filter>
    </ClInclude>
    <ClInclude Include="PplibEx.hpp">
      <Filter>AntiReverse</Filter>
    </ClInclude>
    <ClInclude Include="xorstr.h">
      <Filter>Obfuscathion</Filter>
    </ClInclude>
    <ClInclude Include="MurmurHash2A.h">
      <Filter>Obfuscathion</Filter>
    </ClInclude>
    <ClInclude Include="Struct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiDebug.hpp">
      <Filter>AntiReverse</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp">
      <Filter>Driver Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`MAJESTY technologies/MAJESTY technologies.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`MAJESTY technologies/MAJESTYtechnologies.inf`:

```inf
;
; MAJESTYtechnologies.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=MAJESTYtechnologies.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
MAJESTYtechnologies_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
MAJESTYtechnologies.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%MAJESTYtechnologies.DeviceDesc%=MAJESTYtechnologies_Device, Root\MAJESTYtechnologies ; TODO: edit hw-id

[MAJESTYtechnologies_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
MAJESTYtechnologies.sys

;-------------- Service installation
[MAJESTYtechnologies_Device.NT.Services]
AddService = MAJESTYtechnologies,%SPSVCINST_ASSOCSERVICE%, MAJESTYtechnologies_Service_Inst

; -------------- MAJESTYtechnologies driver install sections
[MAJESTYtechnologies_Service_Inst]
DisplayName    = %MAJESTYtechnologies.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\MAJESTYtechnologies.sys

;
;--- MAJESTYtechnologies_Device Coinstaller installation ------
;

[MAJESTYtechnologies_Device.NT.CoInstallers]
AddReg=MAJESTYtechnologies_Device_CoInstaller_AddReg
CopyFiles=MAJESTYtechnologies_Device_CoInstaller_CopyFiles

[MAJESTYtechnologies_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[MAJESTYtechnologies_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[MAJESTYtechnologies_Device.NT.Wdf]
KmdfService =  MAJESTYtechnologies, MAJESTYtechnologies_wdfsect
[MAJESTYtechnologies_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "MAJESTYtechnologies Installation Disk"
MAJESTYtechnologies.DeviceDesc = "MAJESTYtechnologies Device"
MAJESTYtechnologies.SVCDESC = "MAJESTYtechnologies Service"

```

`MAJESTY technologies/MurmurHash2A.h`:

```h
#pragma once
#include "NoCRT.h"
#define mmix(h,k) { k *= m; k ^= k >> r; k *= m; h *= m; h ^= k; }
#define MurmurHashStr(str) MurmurHash2A(str,NoCRT::string::strlen(str),  NoCRT::string::strlen(str) )


__forceinline constexpr uint64_t  MurmurHash2A(uint64_t key, int len, uint64_t  seed)
{
	const unsigned int m = 0x5bd1e995;
	const auto r = 24;
	unsigned int l = len;
	auto data = static_cast<uint64_t >(key);

	

	  uint64_t   h = seed * __TIME__[4];
	uint64_t  k = 0;

	while (len >= 4)
	{
		k = data;

		mmix(h, k);

		data += 4;
		len -= 4;
	}

	uint64_t  t = 0;

	switch (len)
	{
	case 3: t ^= data << 16;
	case 2: t ^= data << 8;
	case 1: t ^= data;
	};

	mmix(h, t);
	mmix(h, l);

	h ^= h >> 13;
	h *= m;
	h ^= h >> 15;

	return h;
}
```

`MAJESTY technologies/NoCRT.h`:

```h
#pragma once
#include "Struct.h"


namespace NoCRT {
	namespace mem {

		__forceinline  int  memicmp(const void* s1, const void* s2, unsigned __int64 n)
		{
			if (n != 0)
			{
				const unsigned char* p1 = (unsigned char*)s1, * p2 = (unsigned char*)s2;
				do
				{
					if (toupper(*p1) != toupper(*p2)) return (*p1 - *p2);
					p1++;
					p2++;
				} while (--n != 0);
			}
			return 0;
		}



		__forceinline  void* memcpy(void* dest, const void* src, unsigned __int64 count)
		{
			char* char_dest = (char*)dest;
			char* char_src = (char*)src;
			if ((char_dest <= char_src) || (char_dest >= (char_src + count)))
			{
				while (count > 0)
				{
					*char_dest = *char_src;
					char_dest++;
					char_src++;
					count--;

				}
			}
			else
			{
				char_dest = (char*)dest + count - 1;
				char_src = (char*)src + count - 1;
				while (count > 0)
				{
					*char_dest = *char_src;
					char_dest--;
					char_src--;
					count--;
				}
			}
			return dest;
		}

		__forceinline  void* memccpy(void* to, const void* from, int c, unsigned __int64 count)
		{
			char t;
			unsigned __int64 i;
			char* dst = (char*)to;
			const char* src = (const char*)from;
			for (i = 0; i < count; i++)
			{
				dst[i] = t = src[i];
				if (t == 0) break;
				if (t == c) return &dst[i + 1];
			}
			return 0;
		}
		__forceinline  void* memchr(const void* s, int c, unsigned __int64 n)
		{
			if (n)
			{
				const char* p = (const char*)s;
				do
				{
					if (*p++ == c) return (void*)(p - 1);
				} while (--n != 0);
			}
			return 0;
		}
		__forceinline  int  memcmp(const void* s1, const void* s2, unsigned __int64 n)
		{
			if (n != 0)
			{
				const unsigned char* p1 = (unsigned char*)s1, * p2 = (unsigned char*)s2;
				do
				{
					if (*p1++ != *p2++) return (*--p1 - *--p2);
				} while (--n != 0);
			}
			return 0;
		}

		__forceinline  void* memmove(void* dest, const void* src, unsigned __int64 count)
		{
			char* char_dest = (char*)dest;
			char* char_src = (char*)src;
			if ((char_dest <= char_src) || (char_dest >= (char_src + count)))
			{
				while (count > 0)
				{
					*char_dest = *char_src;
					char_dest++;
					char_src++;
					count--;
				}
			}
			else
			{
				char_dest = (char*)dest + count - 1;
				char_src = (char*)src + count - 1;
				while (count > 0)
				{
					*char_dest = *char_src;
					char_dest--;
					char_src--;
					count--;
				}
			}
			return dest;

		}
		__forceinline  void* memset(void* dest, char c, unsigned int len)
		{
			unsigned int i;
			unsigned int fill;
			unsigned int chunks = len / sizeof(fill);
			char* char_dest = (char*)dest;
			unsigned int* uint_dest = (unsigned int*)dest;
			fill = (c << 24) + (c << 16) + (c << 8) + c;

			for (i = len; i > chunks * sizeof(fill); i--) {
				char_dest[i - 1] = c;
			}

			for (i = chunks; i > 0; i--) {
				uint_dest[i - 1] = fill;
			}

			return dest;
		}


	}
	namespace string
	{


		__forceinline  int tolower(int c)
		{
			if (c >= 'A' && c <= 'Z') return c - 'A' + 'a';
			return c;
		}

		__forceinline  int wtolower(int c)
		{
			if (c >= L'A' && c <= L'Z') return c - L'A' + L'a';
			if (c >= L'À' && c <= L'ß') return c - L'À' + L'à';
			if (c == L'¨') return L'¸';
			return c;
		}

		__forceinline   int strlen(const char* string)
		{
			int cnt = 0;
			if (string)
			{
				for (; *string != 0; ++string) ++cnt;
			}
			return cnt;
		}

		__forceinline  int strcmp(const char* cs, const char* ct)
		{
			if (cs && ct)
			{
				while (*cs == *ct)
				{
					if (*cs == 0 && *ct == 0) return 0;
					if (*cs == 0 || *ct == 0) break;
					cs++;
					ct++;
				}
				return *cs - *ct;
			}
			return -1;
		}


		__forceinline  int stricmp(const char* cs, const char* ct)
		{
			if (cs && ct)
			{
				while (tolower(*cs) == tolower(*ct))
				{
					if (*cs == 0 && *ct == 0) return 0;
					if (*cs == 0 || *ct == 0) break;
					cs++;
					ct++;
				}
				return tolower(*cs) - tolower(*ct);
			}
			return -1;
		}





		__forceinline  int wstrlen(const wchar_t* string)
		{
			int cnt = 0;
			if (string)
			{
				for (; *string != 0; ++string) ++cnt;
			}
			return cnt;
		}


		__forceinline  const char* strstr(char const* _Str, char const* _SubStr)
		{
			const char* bp = _SubStr;
			const char* back_pos;
			while (*_Str != 0 && _Str != 0 && _SubStr != 0)
			{
				back_pos = _Str;
				while (tolower(*back_pos++) == tolower(*_SubStr++))
				{
					if (*_SubStr == 0)
					{
						return (char*)(back_pos - strlen(bp));
					}
				}
				++_Str;
				_SubStr = bp;
			}
			return 0;
		}

		__forceinline  int wstrcmp(const wchar_t* cs, const wchar_t* ct)
		{
			if (cs && ct)
			{
				while (*cs == *ct)
				{
					if (*cs == 0 && *ct == 0) return 0;
					if (*cs == 0 || *ct == 0) break;
					cs++;
					ct++;
				}
				return *cs - *ct;
			}
			return -1;
		}

		__forceinline  int wstricmp(const wchar_t* cs, const wchar_t* ct)
		{
			if (cs && ct)
			{
				while (wtolower(*cs) == wtolower(*ct))
				{
					if (*cs == 0 && *ct == 0) return 0;
					if (*cs == 0 || *ct == 0) break;
					cs++;
					ct++;
				}
				return wtolower(*cs) - wtolower(*ct);
			}
			return -1;
		}


		__forceinline  wchar_t* wstrstr(const wchar_t* s, const wchar_t* find)
		{
			wchar_t c, sc;
			if ((c = *find++) != 0)
			{
				do
				{
					do
					{
						if ((sc = *s++) == 0)
							return 0;
					} while (sc != c);
				} while (wstricmp(s, find) != 0);
				s--;
			}
			return (wchar_t*)s;
		}
		__forceinline  wchar_t* wstrset(wchar_t* szToFill, int szFill)
		{
			wchar_t* t = szToFill;
			while (*szToFill != 0)
			{
				*szToFill = szFill;
				szToFill++;
			}
			return t;
		}
		__forceinline  wchar_t* wstrnset(wchar_t* szToFill, int szFill, unsigned __int64 sizeMaxFill)
		{
			wchar_t* t = szToFill;
			int i = 0;
			while (*szToFill != 0 && i < (int)sizeMaxFill)
			{
				*szToFill = szFill;
				szToFill++;
				i++;
			}
			return t;
		}
		__forceinline  wchar_t* wstrrev(wchar_t* s)
		{
			wchar_t a, * b, * e;
			b = e = s;
			while (*e) e++;
			e--;
			while (b < e)
			{
				a = *b;
				*b = *e;
				*e = a;
				b++;
				e--;
			}
			return s;
		}

		__forceinline  bool iswdigit(wchar_t c) { return c >= L'0' && c <= L'9'; }
		constexpr 	__forceinline  __int64 wtoi64(const wchar_t* nptr)
		{
			wchar_t* s = (wchar_t*)nptr;
			__int64 acc = 0;
			int neg = 0;
			if (nptr == 0) return 0;
			while (*s = L' ') s++;
			if (*s == L'-')
			{
				neg = 1;
				s++;
			}
			else if (*s == L'+') s++;
			while (iswdigit(*s))
			{
				acc = 10 * acc + (*s - L'0');
				s++;
			}
			if (neg) acc *= -1;
			return acc;
		}
		__forceinline  int wtoi(const wchar_t* nptr)
		{
			wchar_t* s = (wchar_t*)nptr;
			int acc = 0;
			int neg = 0;
			if (nptr == 0) return 0;
			while (*s = L' ') s++;
			if (*s == L'-')
			{
				neg = 1;
				s++;
			}
			else if (*s == L'+') s++;
			while (iswdigit(*s))
			{
				acc = 10 * acc + (*s - L'0');
				s++;
			}
			if (neg) acc *= -1;
			return acc;
		}
		__forceinline  wchar_t* itow(int number, wchar_t* destination, int base)
		{
			int count = 0;
			do
			{
				int digit = number % base;
				destination[count++] = (digit > 9) ? digit - 10 + L'A' : digit + L'0';
			} while ((number /= base) != 0);
			destination[count] = 0;
			int i;
			for (i = 0; i < count / 2; ++i)
			{
				wchar_t symbol = destination[i];
				destination[i] = destination[count - i - 1];
				destination[count - i - 1] = symbol;
			}
			return destination;
		}

		__forceinline char* strcat_a(char* dest, const char* src)
		{
			if ((dest == 0) || (src == 0))
				return dest;

			while (*dest != 0)
				dest++;

			while (*src != 0) {
				*dest = *src;
				dest++;
				src++;
			}

			*dest = 0;
			return dest;
		}

		__forceinline wchar_t* strcat_w(wchar_t* dest, const wchar_t* src)
		{
			if ((dest == 0) || (src == 0))
				return dest;

			while (*dest != 0)
				dest++;

			while (*src != 0) {
				*dest = *src;
				dest++;
				src++;
			}

			*dest = 0;
			return dest;
		}
	}
}
```

`MAJESTY technologies/NtApiDef.h`:

```h
#pragma once
#include "Struct.h"



 

typedef NTSTATUS (NTAPI* t_PsGetContextThread)
(
     PETHREAD Thread,
     PCONTEXT ThreadContext,
     KPROCESSOR_MODE Mode
);


typedef NTSTATUS(NTAPI* t_ZwSystemDebugControl)
(
    unsigned long ControlCode,
    void* InputBuffer,
    unsigned long InputBufferLength,
    void* OutputBuffer,
    unsigned long OutputBufferLength,
    unsigned long* pResultLength
    );

 
 



typedef NTSTATUS(NTAPI* t_KdDisableDebugger)();

typedef NTSTATUS(NTAPI* t_KdChangeOption)
(
    KD_OPTION Option,
    ULONG     InBufferBytes,
    PVOID     InBuffer,
    ULONG     OutBufferBytes,
    PVOID     OutBuffer,
    PULONG    OutBufferNeeded
    );


typedef ULONG(NTAPI* t_vDbgPrintExWithPrefix)(
    PCCH    Prefix,
    ULONG   ComponentId,
    ULONG   Level,
    PCCH    Format,
    va_list arglist
    );

typedef  NTSTATUS(NTAPI* t_RtlGetVersion)
(
    PRTL_OSVERSIONINFOW lpVersionInformation
    );


 

typedef  NTSTATUS(NTAPI* t_PsLookupThreadByThreadId)
(
    HANDLE   ThreadId,
    PETHREAD* Thread
    );


 
typedef LONG_PTR(NTAPI* t_ObfDereferenceObject )
(
    PVOID Object
    );


```

`MAJESTY technologies/Offset.hpp`:

```hpp
#pragma once
#include "Util.hpp"

namespace Offset
{
	DebugOffset  debugOffset;


	PprocOffset ppOffset;


	__forceinline uint64_t GetWindowsNumber()
	{

		RTL_OSVERSIONINFOW  lpVersionInformation{ 0 };

		lpVersionInformation.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);



		auto   RtlGetVersion = (t_RtlGetVersion)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("RtlGetVersion"));

		if (RtlGetVersion)
		{
			RtlGetVersion(&lpVersionInformation);
		}
		else
		{
			auto buildNumber = (PDWORD64)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("NtBuildNumber"));

			lpVersionInformation.dwBuildNumber = *buildNumber;
			lpVersionInformation.dwMajorVersion = *(ULONG*)0xFFFFF7800000026C;
			lpVersionInformation.dwMinorVersion = *(ULONG*)0xFFFFF78000000270;

		}

		if (lpVersionInformation.dwBuildNumber >= WINDOWS_11)
		{
			return WINDOWS_NUMBER_11;
		}


		else if (lpVersionInformation.dwBuildNumber >= WINDOWS_10_VERSION_THRESHOLD1 && lpVersionInformation.dwBuildNumber <= WINDOWS_10_VERSION_21H2)
		{
			return WINDOWS_NUMBER_10;

		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_8_1)
		{

			return WINDOWS_NUMBER_8_1;

		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_8)
		{

			return WINDOWS_NUMBER_8;


		}
		else if (lpVersionInformation.dwBuildNumber == WINDOWS_7_SP1 || lpVersionInformation.dwBuildNumber == WINDOWS_7)
		{

			return WINDOWS_NUMBER_7;

		}

	}



	__forceinline bool GetOffset()
	{


		RTL_OSVERSIONINFOW  lpVersionInformation{ 0 };




		lpVersionInformation.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);



		auto   RtlGetVersion = (t_RtlGetVersion)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("RtlGetVersion"));

		if (RtlGetVersion)
		{
			RtlGetVersion(&lpVersionInformation);
		}
		else
		{
			auto buildNumber = (PDWORD64)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("NtBuildNumber"));

			lpVersionInformation.dwBuildNumber = *buildNumber;
			lpVersionInformation.dwMajorVersion = *(ULONG*)0xFFFFF7800000026C;
			lpVersionInformation.dwMinorVersion = *(ULONG*)0xFFFFF78000000270;

		}


		if (lpVersionInformation.dwBuildNumber == WINDOWS_11)
		{

			debugOffset.HideFromDebugger = 0x560;
			debugOffset.NoDebugInherit = 0x464;
			debugOffset.DebugPort = 0x578;
			debugOffset.InstrumentationCallback = 0x3d8;
			debugOffset.InheritedFromUniqueProcessId = 0x540; 
			debugOffset.Process = 0x220;



			ppOffset.protection = 0x87a;




		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_21H1 || lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_21H2 ||
			lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_20H2 || lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_20H1)
			{

				debugOffset.HideFromDebugger = 0x510;
				debugOffset.DebugPort = 0x578;
				debugOffset.NoDebugInherit = 0x464;
				debugOffset.InstrumentationCallback = 0x3d8;
				debugOffset.InheritedFromUniqueProcessId = 0x540;  
				debugOffset.Process = 0x220;

				ppOffset.protection = 0x87a;

			}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_19H2 || lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_19H1)
		{
			debugOffset.HideFromDebugger = 0x6e0;
			debugOffset.DebugPort = 0x420;
			debugOffset.NoDebugInherit = 0x30c;
			debugOffset.InstrumentationCallback = 0x2d0;
			debugOffset.InheritedFromUniqueProcessId = 0x3e8;  
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x6fa;


		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_REDSTONE5)
		{

			debugOffset.HideFromDebugger = 0x6d0;
			debugOffset.DebugPort = 0x420;
			debugOffset.NoDebugInherit = 0x304;
			debugOffset.InstrumentationCallback = 0x2c8;
			debugOffset.InheritedFromUniqueProcessId = 0x3e0; 
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x6ca;



		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_REDSTONE4)
		{
			debugOffset.HideFromDebugger = 0x6d0;
			debugOffset.DebugPort = 0x420;
			debugOffset.NoDebugInherit = 0x304;
			debugOffset.InstrumentationCallback = 0x2c8;
			debugOffset.InheritedFromUniqueProcessId = 0x3e0; 
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x6ca;



		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_REDSTONE3)
		{
			debugOffset.HideFromDebugger = 0x6d0;
			debugOffset.NoDebugInherit = 0x304;
			debugOffset.DebugPort = 0x420;
			debugOffset.InstrumentationCallback = 0x2c8;
			debugOffset.InheritedFromUniqueProcessId = 0x3e0; 
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x6ca;


		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_REDSTONE2)
		{
			debugOffset.DebugPort = 0x420;
			debugOffset.NoDebugInherit = 0x304;
			debugOffset.InstrumentationCallback = 0x2c8;
			debugOffset.HideFromDebugger = 0x6c8;
			debugOffset.InheritedFromUniqueProcessId = 0x3e0; 
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x6ca;



		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_REDSTONE1)
		{

			debugOffset.HideFromDebugger = 0x6c0;
			debugOffset.DebugPort = 0x420;
			debugOffset.NoDebugInherit = 0x304;
			debugOffset.InstrumentationCallback = 0x2c8;
			debugOffset.InheritedFromUniqueProcessId = 0x3e0; 
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x6c2;




		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_THRESHOLD2)
		{
			debugOffset.HideFromDebugger = 0x6bc;
			debugOffset.DebugPort = 0x420;
			debugOffset.NoDebugInherit = 0x304;
			debugOffset.InstrumentationCallback = 0x2c8;
			debugOffset.InheritedFromUniqueProcessId = 0x3e0; 
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x6b2;


		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_10_VERSION_THRESHOLD1)
		{
			debugOffset.HideFromDebugger = 0x6bc;
			debugOffset.DebugPort = 0x420;
			debugOffset.NoDebugInherit = 0x304;
			debugOffset.InstrumentationCallback = 0x2c8;
			debugOffset.InheritedFromUniqueProcessId = 0x3e0; 
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x6aa;


		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_8_1)
		{

			debugOffset.HideFromDebugger = 0x6b4;
			debugOffset.DebugPort = 0x410;
			debugOffset.NoDebugInherit = 0x2fc;
			debugOffset.InstrumentationCallback = 0x2c0;
			debugOffset.InheritedFromUniqueProcessId = 0x3d0; 
			debugOffset.Process = 0x220;


			ppOffset.protection = 0x67A;


		}

		else if (lpVersionInformation.dwBuildNumber == WINDOWS_8)
		{

			

			debugOffset.DebugPort = 0x410;
			debugOffset.NoDebugInherit = 0x2fc;
			debugOffset.InstrumentationCallback = 0x2c0;
			debugOffset.HideFromDebugger = 0x42c;
			debugOffset.InheritedFromUniqueProcessId = 0x3d0; 
			debugOffset.Process = 0x220;

			ppOffset.protection = 0x648;



		}
		else if (lpVersionInformation.dwBuildNumber == WINDOWS_7_SP1 || lpVersionInformation.dwBuildNumber == WINDOWS_7)
		{

			debugOffset.HideFromDebugger = 0x448;
			debugOffset.DebugPort = 0x1f0;
			debugOffset.NoDebugInherit = 0x440;
			debugOffset.InstrumentationCallback = 0x100;
			debugOffset.InheritedFromUniqueProcessId = 0x290; 
			debugOffset.Process = 0x210;

			ppOffset.protection = 0x43C;

		}


		else
		{
			return false;
		}

		return true;

	}

}

```

`MAJESTY technologies/PplibEx.hpp`:

```hpp
#pragma once
#include  "Offset.hpp"
#include "GetPID.h"



/*
	original https://github.com/notscimmy/pplib

	more info https://guidedhacking.com/threads/protected-processes-light-protected-processes.14968/

*/
namespace PplibEx
{

	__forceinline	void ProtectProcessByPID(HANDLE procId)
	{
		PEPROCESS proc; 
		 
		if (procId &&  NT_SUCCESS(PIDHelp::GetEProcessByProcId(procId, &proc)))
		{
			BYTE* pEProcess = (BYTE*)proc;
			uint8_t* pPPL = pEProcess + Offset::ppOffset.protection;

			uint64_t  version = Offset::GetWindowsNumber();
			if (MurmurHash2A(	version,7,7) == MurmurHash2A(WINDOWS_NUMBER_7,7,7))
				*(DWORD*)pPPL |= 1 << 0xB;
			else if (MurmurHash2A(version,8,8) == MurmurHash2A(WINDOWS_NUMBER_8,8,8))
				*pPPL = true;
			else if (MurmurHash2A(version,9,9) == MurmurHash2A(WINDOWS_NUMBER_8_1,9,9))
			{ 
				PS_PROTECTION protection;
				protection.Flags.Signer = PsProtectedSignerWinSystem;// = PsProtectedSignerMax for Windows 8.1
				protection.Flags.Type = PsProtectedTypeMax;
				*pPPL = protection.Level;
			}

			// process hacker can't sea PsProtectedTypeMax  and write Unknown	? WTF?!
			else if (MurmurHash2A(version,10,10) == MurmurHash2A(WINDOWS_NUMBER_10,10,10) || MurmurHash2A(version,11, 11) == MurmurHash2A(WINDOWS_NUMBER_11, 11, 11))
			{
				PS_PROTECTION protection; 
				protection.Flags.Signer = PsProtectedSignerMax;
				protection.Flags.Type = PsProtectedTypeMax;
				*pPPL = protection.Level;
			}
			 
		}


	}

}
```

`MAJESTY technologies/Struct.h`:

```h
#pragma once 
#include <ntifs.h> 
#include <minwindef.h> 
#include <ntstrsafe.h>
#include <ntimage.h>
#include <cstdint>
 
#include "xorstr.h"


EXTERN_C __int64 __readmsr(
	int register
);
EXTERN_C void __cpuid(
	int cpuInfo[4],
	int function_id
);
EXTERN_C void __writemsr(
	unsigned long Register,
	unsigned __int64 Value
); 


 

#define WINDOWS_7 7600
#define WINDOWS_7_SP1 7601
#define WINDOWS_8 9200
#define WINDOWS_8_1 9600
#define WINDOWS_10_VERSION_THRESHOLD1 10240
#define WINDOWS_10_VERSION_THRESHOLD2 10586
#define WINDOWS_10_VERSION_REDSTONE1 14393
#define WINDOWS_10_VERSION_REDSTONE2 15063
#define WINDOWS_10_VERSION_REDSTONE3 16299
#define WINDOWS_10_VERSION_REDSTONE4 17134
#define WINDOWS_10_VERSION_REDSTONE5 17763
#define WINDOWS_10_VERSION_19H1 18362
#define WINDOWS_10_VERSION_19H2 18363
#define WINDOWS_10_VERSION_20H1 19041
#define WINDOWS_10_VERSION_20H2 19042
#define WINDOWS_10_VERSION_21H1 19043
#define WINDOWS_10_VERSION_21H2 19044
#define WINDOWS_11 22000


#define WINDOWS_NUMBER_7 7
#define WINDOWS_NUMBER_8 8
#define WINDOWS_NUMBER_8_1 9
#define WINDOWS_NUMBER_10 10
#define WINDOWS_NUMBER_11 11

#define IA32_P5_MC_ADDR_MSR		0x00000000
#define DEBUGCTL_LBR            0x01
#define DEBUGCTL_BTF            0x02
#define	IA32_TIME_STAMP_COUNTER 0x00000010
#define SMI_COUNT_MSR 0x00000034
#define IA32_MPERF_MSR 0x000000E7
#define IA32_APERF_MSR 0x000000E8
#define	MSR_P6M_LBSTK_TOS	0x1c9
#define	MSR_DEBUGCTL		0x1d9

static const uint64_t PMASK = (~0xfull << 8) & 0xfffffffffull;

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK   0x00000001

#define 	LDR_IS_DATAFILE(handle)   (((ULONG_PTR)(handle)) & (ULONG_PTR)1)

#define 	LDR_DATAFILE_TO_VIEW(x)   ((PVOID)(((ULONG_PTR)(x)) & ~(ULONG_PTR)1))

#define OBJ_KERNEL_EXCLUSIVE           0x00010000L
#define OBJ_VALID_PRIVATE_ATTRIBUTES   0x00010000L
#define OBJ_ALL_VALID_ATTRIBUTES (OBJ_VALID_PRIVATE_ATTRIBUTES | OBJ_VALID_ATTRIBUTES)



DWORD64 gl_baseNtoskrnl = 0;

EXTERN_C POBJECT_TYPE* IoDriverObjectType;

#define PAGE_OFFSET_SIZE 12

#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64
#define TLS_EXPANSION_SLOTS 1024

#define RTL_MAX_DRIVE_LETTERS 32


#define GDI_HANDLE_BUFFER_SIZE32    34
#define GDI_HANDLE_BUFFER_SIZE64    60

#ifndef _WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

 

typedef enum _LDR_DDAG_STATE
{
	LdrModulesMerged = -5,
	LdrModulesInitError = -4,
	LdrModulesSnapError = -3,
	LdrModulesUnloaded = -2,
	LdrModulesUnloading = -1,
	LdrModulesPlaceHolder = 0,
	LdrModulesMapping = 1,
	LdrModulesMapped = 2,
	LdrModulesWaitingForDependencies = 3,
	LdrModulesSnapping = 4,
	LdrModulesSnapped = 5,
	LdrModulesCondensed = 6,
	LdrModulesReadyToInit = 7,
	LdrModulesInitializing = 8,
	LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;


typedef enum _SYSDBG_COMMAND {
	SysDbgQueryModuleInformation,
	SysDbgQueryTraceInformation,
	SysDbgSetTracepoint,
	SysDbgSetSpecialCall,
	SysDbgClearSpecialCalls,
	SysDbgQuerySpecialCalls,
	SysDbgBreakPoint,
	SysDbgQueryVersion,
	SysDbgReadVirtual,
	SysDbgWriteVirtual,
	SysDbgReadPhysical,
	SysDbgWritePhysical,
	SysDbgReadControlSpace,
	SysDbgWriteControlSpace,
	SysDbgReadIoSpace,
	SysDbgWriteIoSpace,
	SysDbgReadMsr,
	SysDbgWriteMsr,
	SysDbgReadBusData,
	SysDbgWriteBusData,
	SysDbgCheckLowMemory,
	SysDbgEnableKernelDebugger,
	SysDbgDisableKernelDebugger,
	SysDbgGetAutoKdEnable,
	SysDbgSetAutoKdEnable,
	SysDbgGetPrintBufferSize,
	SysDbgSetPrintBufferSize,
	SysDbgGetKdUmExceptionEnable,
	SysDbgSetKdUmExceptionEnable,
	SysDbgGetTriageDump,
	SysDbgGetKdBlockEnable,
	SysDbgSetKdBlockEnable,
} SYSDBG_COMMAND, * PSYSDBG_COMMAND;

 
typedef union _PS_PROTECTION
{
	UCHAR Level;
	struct
	{
		int Type : 3;
		int Audit : 1;
		int Signer : 4;
	} Flags;
} PS_PROTECTION, * PPS_PROTECTION;

typedef enum _PS_PROTECTED_SIGNER
{
	PsProtectedSignerNone = 0,
	PsProtectedSignerAuthenticode = 1,
	PsProtectedSignerCodeGen = 2,
	PsProtectedSignerAntimalware = 3,
	PsProtectedSignerLsa = 4,
	PsProtectedSignerWindows = 5,
	PsProtectedSignerWinTcb = 6,
	PsProtectedSignerWinSystem = 7,
	PsProtectedSignerApp = 8,
	PsProtectedSignerMax = 9
} PS_PROTECTED_SIGNER;

typedef enum _PS_PROTECTED_TYPE
{
	PsProtectedTypeNone = 0,
	PsProtectedTypeProtectedLight = 1,
	PsProtectedTypeProtected = 2,
	PsProtectedTypeMax = 3

} PS_PROTECTED_TYPE;


struct DebugOffset
{
	uint32_t NoDebugInherit;
	uint32_t DebugPort;
	uint32_t HideFromDebugger;
	uint32_t InstrumentationCallback;
	uint32_t InheritedFromUniqueProcessId;
	uint32_t Process;

};


struct PprocOffset
{
	uint64_t protection;

};

struct processFlag2
{
	ULONG CreateReported : 1;                                         
	ULONG NoDebugInherit : 1;                                         
	ULONG ProcessExiting : 1;                                         
	ULONG ProcessDelete : 1;                                          
	ULONG ManageExecutableMemoryWrites : 1;                           
	ULONG VmDeleted : 1;                                              
	ULONG OutswapEnabled : 1;                                         
	ULONG Outswapped : 1;                                             
	ULONG FailFastOnCommitFail : 1;                                   
	ULONG Wow64VaSpace4Gb : 1;                                        
	ULONG AddressSpaceInitialized : 2;                                
	ULONG SetTimerResolution : 1;                                     
	ULONG BreakOnTermination : 1;                                     
	ULONG DeprioritizeViews : 1;                                      
	ULONG WriteWatch : 1;                                             
	ULONG ProcessInSession : 1;                                       
	ULONG OverrideAddressSpace : 1;                                   
	ULONG HasAddressSpace : 1;                                        
	ULONG LaunchPrefetched : 1;                                       
	ULONG Background : 1;                                             
	ULONG VmTopDown : 1;                                              
	ULONG ImageNotifyDone : 1;                                        
	ULONG PdeUpdateNeeded : 1;                                        
	ULONG VdmAllowed : 1;                                             
	ULONG ProcessRundown : 1;                                         
	ULONG ProcessInserted : 1;                                        
	ULONG DefaultIoPriority : 3;                                      
	ULONG ProcessSelfDelete : 1;                                      
	ULONG SetTimerResolutionLink : 1;                                 
};

 



struct CrossThreadFlags
{
	ULONG Terminated : 1;                                             
	ULONG ThreadInserted : 1;                                         
	ULONG HideFromDebugger : 1;                                       
	ULONG ActiveImpersonationInfo : 1;                                
	ULONG HardErrorsAreDisabled : 1;                                  
	ULONG BreakOnTermination : 1;                                     
	ULONG SkipCreationMsg : 1;                                        
	ULONG SkipTerminationMsg : 1;                                     
	ULONG CopyTokenOnOpen : 1;                                        
	ULONG ThreadIoPriority : 3;                                       
	ULONG ThreadPagePriority : 3;                                     
	ULONG RundownFail : 1;                                            
	ULONG UmsForceQueueTermination : 1;                               
	ULONG IndirectCpuSets : 1;                                        
	ULONG DisableDynamicCodeOptOut : 1;                               
	ULONG ExplicitCaseSensitivity : 1;                                
	ULONG PicoNotifyExit : 1;                                         
	ULONG DbgWerUserReportActive : 1;                                 
	ULONG ForcedSelfTrimActive : 1;                                   
	ULONG SamplingCoverage : 1;                                       
	ULONG ReservedCrossThreadFlags : 8;                               
};
 
```

`MAJESTY technologies/Util.hpp`:

```hpp
#pragma once
#include "NtApiDef.h"
#include "ApiWrapper.hpp"
#include "MurmurHash2A.h"

#define Log(x,...)  Util::Print(xorstr_(x), __VA_ARGS__)




namespace Util
{

	 


	
	
	__forceinline  uint64_t	GetProcAddress(const uintptr_t imageBase, const char* exportName) {

		if (!imageBase)
			return 0;

		if ( MurmurHash2A( reinterpret_cast<PIMAGE_DOS_HEADER>(imageBase)->e_magic,10,10) != MurmurHash2A(0x5A4D,10,10))
			return 0;

		const auto ntHeader = reinterpret_cast<PIMAGE_NT_HEADERS64>(imageBase + reinterpret_cast<PIMAGE_DOS_HEADER>(imageBase)->e_lfanew);
		const auto exportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(imageBase + ntHeader->OptionalHeader.DataDirectory[0].VirtualAddress);
		if (!exportDirectory)
			0;

		const auto exportedFunctions = reinterpret_cast<DWORD*>(imageBase + exportDirectory->AddressOfFunctions);
		const auto exportedNames = reinterpret_cast<DWORD*>(imageBase + exportDirectory->AddressOfNames);
		const auto exportedNameOrdinals = reinterpret_cast<UINT16*>(imageBase + exportDirectory->AddressOfNameOrdinals);

		for (size_t i{}; i < exportDirectory->NumberOfNames; ++i) {
			const auto functionName = reinterpret_cast<const char*>(imageBase + exportedNames[i]);
			if (NoCRT::string::stricmp(exportName, functionName) == 0) {
				return imageBase + exportedFunctions[exportedNameOrdinals[i]];

			}
		}

		return 0;
	}

	
	__forceinline  ULONG Print(const char* text, ...)
	{

		va_list(args);
		va_start(args, text);


		auto myvDbgPrintExWithPrefix = (t_vDbgPrintExWithPrefix)Util::GetProcAddress(gl_baseNtoskrnl, xorstr_("vDbgPrintExWithPrefix"));
		auto result = myvDbgPrintExWithPrefix(xorstr_("[sex technology] "), 0, 0, text, args);

		va_end(args);
		return result;

	}
	 

	__forceinline bool  CheckMask(const char* base, const char* pattern, const char* mask)
	{
		for (; *mask; ++base, ++pattern, ++mask)
		{
			if ('x' == *mask && *base != *pattern)
			{
				return false;
			}
		}

		return true;
	}


	__forceinline PVOID FindPattern(PVOID base, int length, const char* pattern, const char* mask)
	{
		length -= static_cast<int>(NoCRT::string::strlen(mask));
		for (auto i = 0; i <= length; ++i)
		{
			const auto* data = static_cast<char*>(base);
			const auto* address = &data[i];
			if (CheckMask(address, pattern, mask))
				return PVOID(address);
		}

		return nullptr;
	}

	__forceinline PVOID FindPatternImage(PVOID base, const char* secthionName, const char* pattern, const char* mask)
	{
		PVOID match = nullptr;

		auto* headers = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<char*>(base) + static_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
		auto* sections = IMAGE_FIRST_SECTION(headers);

		for (auto i = 0; i < headers->FileHeader.NumberOfSections; ++i)
		{
			auto* section = &sections[i];
			if ( NoCRT::mem::memcmp(section->Name, secthionName, NoCRT::string::strlen(secthionName)) == 0)
			{
				match = FindPattern(static_cast<char*>(base) + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
				if (match)
					break;
			}
		}

		return match;
	}

	__forceinline PVOID ResolveRelativeAddress(PVOID pvAddress, UINT64 qwOffset, UINT64 qwRelative)
	{
		ULONG ulRelativeAddress;
		NoCRT::mem::memmove(&ulRelativeAddress, (PVOID)((UINT64)pvAddress + qwOffset), sizeof(ULONG));
		return (PVOID)(ulRelativeAddress + (UINT64)pvAddress + qwRelative);
	}
}
```

`MAJESTY technologies/xorstr.h`:

```h
#pragma once



#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define xorstr_(str) skCrypt_key(str, __TIME__[4], __TIME__[7] * __TIME__[3])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()


```

`README.md`:

```md
# MAJESTY-technologies
Little driver for protecthion.  
The driver is still under development, so you can submit your ideas!  
I write it's for manual map driver,because i havn't sertivicate for driver.  

Version 1.3

Support windows 10-11!!  
You can remove/fix some detect with signature for work on windows 7,7sp1,8,8.1!  

I try do this driver use max DKOM   
 
Anti-UM debug:  
1)PEPROCESS -> DebugPort  
2)PEPROCESS -> NoDebugInherit  
3)PETHREAD -> HideFromDebugger(set manual like:EAC)  
4)PEPROCESS -> InheritedFromUniqueProcessId and compare with explorer.exe  
5)Check hardware breakpoint  
6) Set ProcessDebugPortMutex and ValidAccessMask to 0  

Anti-analysis:  
1)Check InstrumentationCallback( PEPROCESS -> Pcb -> InstrumentationCallback)  
2)Do process proteced  
  
Anti-KM debug:  
1)Check offset(like:KdEnteredDebugger)  
2)Check KdFuncthion on return STATUS_DEBUGGER_INACTIVE  
  
Anti-Hypervisor:  
1)Time attack  
2)check anomalies  
  
To-do list:  
1)write communicathion(UM <-> KM)  
2)Use hash for get address NtApi  
3)Check some hook?  

Check instrumentation callbacks(under VMware) ->  
![alt text](https://github.com/LazyAhora/MAJESTY-technologies/blob/main/Detect%20instrumentation%20callbacks.png)  
Set protect process ->  
![alt text](https://github.com/LazyAhora/MAJESTY-technologies/blob/main/Protect%20Process.png)  
Running under HyperHide  ->  
![alt text](https://github.com/LazyAhora/MAJESTY-technologies/blob/main/Under%20HyperHide.png)  
Set ValidAccessMask to 0  ->  
![alt text](https://github.com/LazyAhora/MAJESTY-technologies/blob/main/Dead%20ValidAccessMask.png)  
Set DbgkpProcessDebugPortMutex to 0 ->  
![alt text](https://github.com/LazyAhora/MAJESTY-technologies/blob/main/Dead%20DbgkpProcessDebugPortMutex.png)  
Try open R/W handle to protected process ->  
![alt text](https://github.com/LazyAhora/MAJESTY-technologies/blob/main/Open%20handle%20to%20protected%20process.png)  

```

`SexyTest/SexyTest.cpp`:

```cpp
#include <Windows.h>
#include <iostream>

 
int main()
{ 
	while (true)
	{
		if (GetAsyncKeyState(VK_SPACE))
		{
			std::cout << "Meh!\n";
			Sleep(500);
		}
		if (GetAsyncKeyState(VK_INSERT))
		{
			ExitProcess((UINT)"Sexy");
		}
	};
}


```

`SexyTest/SexyTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a45ad110-cbe7-4a47-8c04-b11bdf99c585}</ProjectGuid>
    <RootNamespace>SexyTest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="SexyTest.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SexyTest/SexyTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="SexyTest.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`SexyTest/SexyTest.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```