Project Path: arc_gmh5225_ANTfs_y1f0i4ok

Source Tree:

```txt
arc_gmh5225_ANTfs_y1f0i4ok
├── ANTfs
│   ├── ANTfs.cpp
│   ├── ANTfs.vcxproj
│   ├── ANTfs.vcxproj.filters
│   ├── antiforensics.cpp
│   ├── antiforensics.h
│   ├── privileges.cpp
│   ├── privileges.h
│   └── typesndefs.h
├── ANTfs Driver
│   ├── ANTfs Driver.vcxproj
│   ├── ANTfs Driver.vcxproj.filters
│   ├── ANTfsDriver.inf
│   ├── Source.cpp
│   ├── dispatchroutines.cpp
│   ├── dispatchroutines.h
│   └── typesndefs.h
├── ANTfs.sln
├── Images
│   └── helpmenu.png
└── README.md

```

`ANTfs Driver/ANTfs Driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ANTfs_Driver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="ANTfsDriver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dispatchroutines.cpp" />
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dispatchroutines.h" />
    <ClInclude Include="typesndefs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ANTfs Driver/ANTfs Driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Header Files\types">
      <UniqueIdentifier>{cf3f8914-c6a8-4d8a-a195-b53d69c0a839}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\dispatch">
      <UniqueIdentifier>{98130faf-90b9-44b9-85b4-342ebeb8b8f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\dispatch">
      <UniqueIdentifier>{de90aac4-8b60-4726-a5b2-f17ab968c095}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="ANTfsDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dispatchroutines.cpp">
      <Filter>Source Files\dispatch</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="typesndefs.h">
      <Filter>Header Files\types</Filter>
    </ClInclude>
    <ClInclude Include="dispatchroutines.h">
      <Filter>Header Files\dispatch</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ANTfs Driver/ANTfsDriver.inf`:

```inf
;
; ANTfsDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=ANTfsDriver.cat
PnpLockdown=1

;This template is supported for OS version 17763 (Windows 10 version 1809) and after.
;For Windows OS prior to Windows 10 1809 set DefaultDestDir = 12
[DestinationDirs]
DefaultDestDir = 13


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[DefaultInstall.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName="ANTfsDriver Source Disk"

```

`ANTfs Driver/Source.cpp`:

```cpp
#include <ntifs.h>
#include <ntddk.h>

#include "typesndefs.h"
#include "dispatchroutines.h"

UNICODE_STRING g_usDeviceName = RTL_CONSTANT_STRING(L"\\Device\\ANTfs");
UNICODE_STRING g_usSymbolicName = RTL_CONSTANT_STRING(L"\\??\\ANTfs");

_Function_class_(DRIVER_DISPATCH)
_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS 
DriverDispatchRoutine(
	_In_ PDEVICE_OBJECT,
	_In_ PIRP Irp
)
{
	NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

	PWIPE_INPUT_BUFFER UsermodeBuffer = nullptr;

	UINT32 Information = NULL;
	UINT32 IoControlCode = NULL;

	PIO_STACK_LOCATION IoStackLocation = IoGetCurrentIrpStackLocation(Irp);

	IoControlCode = IoStackLocation->Parameters.DeviceIoControl.IoControlCode;

	switch (IoControlCode)
	{
	case IoctlOverwrite:
		__try
		{
			UsermodeBuffer = static_cast<PWIPE_INPUT_BUFFER>(
				Irp->AssociatedIrp.SystemBuffer
				);
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			KdPrint(("[%ws::%d] Access violation occured.\n", 
				__FUNCTIONW__, __LINE__));

			return STATUS_ACCESS_VIOLATION;
		}
		Status = OverwriteFileRecord(UsermodeBuffer);
		break;
	default:
		KdPrint(("[%ws::%d] %04x not supported.\n", 
			__FUNCTIONW__, __LINE__, IoControlCode));
		break;
	}

	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = Information;

	IofCompleteRequest(Irp, IO_NO_INCREMENT);

	return Status;
}

_Function_class_(DRIVER_DISPATCH)
_Dispatch_type_(IRP_MJ_CREATE)
_Dispatch_type_(IRP_MJ_CLOSE)
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
DriverCreateClose(
	_In_ PDEVICE_OBJECT,
	_In_ PIRP Irp
)
{
	Irp->IoStatus.Information = NULL;
	Irp->IoStatus.Status = STATUS_SUCCESS;

	IofCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

_Function_class_(DRIVER_UNLOAD)
_IRQL_requires_(PASSIVE_LEVEL)
VOID
DriverUnload(
	_In_ PDRIVER_OBJECT DriverObject
)
{
	IoDeleteSymbolicLink(&g_usSymbolicName);
	IoDeleteDevice(DriverObject->DeviceObject);

	KdPrint(("[%ws::%d] Completed successfully.\n", __FUNCTIONW__, __LINE__));
}

EXTERN_C
_Function_class_(DRIVER_INITIALIZE)
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING
)
{
	PDEVICE_OBJECT DeviceObject = NULL;

	NTSTATUS Status = IoCreateDevice(
		DriverObject,
		NULL,
		&g_usDeviceName,
		FILE_DEVICE_UNKNOWN,
		FILE_DEVICE_SECURE_OPEN,
		TRUE,
		&DeviceObject
	);
	if (!NT_SUCCESS(Status))
	{
		KdPrint(("[%ws::%d] Failed with status: 0x%08x\n", __FUNCTIONW__, __LINE__, Status));

		if (DeviceObject)
		{
			IoDeleteDevice(DeviceObject);
		}
		return Status;
	}

	Status = IoCreateSymbolicLink(&g_usSymbolicName, &g_usDeviceName);
	if (!NT_SUCCESS(Status))
	{
		KdPrint(("[%ws::%d] Failed with status: 0x%08x\n", __FUNCTIONW__, __LINE__, Status));

		IoDeleteDevice(DeviceObject);
		return Status;
	}

	DeviceObject->Flags |= DO_BUFFERED_IO;

	DriverObject->DriverUnload = DriverUnload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] =
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = DriverCreateClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDispatchRoutine;

	KdPrint(("[%ws::%d] Completed successfully.\n", __FUNCTIONW__, __LINE__));

	return Status;
}


/// EOF
```

`ANTfs Driver/dispatchroutines.cpp`:

```cpp
#include "dispatchroutines.h"

_Use_decl_annotations_
NTSTATUS 
OverwriteFileRecord(
	PWIPE_INPUT_BUFFER WipeInputBuffer
)
{
	NTSTATUS Status = STATUS_MEMORY_NOT_ALLOCATED;
	KEVENT EventObj;

	UNICODE_STRING usDriveDirectory = RTL_CONSTANT_STRING(L"\\??");
	UNICODE_STRING usDriveLetter = { 0 };
	UNICODE_STRING SymbolicLinkName = { 0 };

	HANDLE hDirectoryHandle = NULL;
	HANDLE hFileHandle = NULL;

	PFILE_OBJECT FileObject = nullptr;
	PDEVICE_OBJECT DiskDeviceObject = nullptr;
	PIRP Irp = nullptr;
	PIO_STACK_LOCATION IoStackLocation = nullptr;

	OBJECT_ATTRIBUTES oa = { 0 };
	IO_STATUS_BLOCK io = { 0 };
	LARGE_INTEGER StartingOffset = { 0 };

	KeInitializeEvent(&EventObj, NotificationEvent, FALSE);

	RtlInitUnicodeString(&usDriveLetter, WipeInputBuffer->DriveLetter);

	PUINT8 ZeroBuffer = static_cast<PUINT8>(
		ExAllocatePoolWithTag(
			NonPagedPoolNx,
			WipeInputBuffer->ClusterSize, 
			POOLTAG
		)
		);

	SymbolicLinkName.Buffer = static_cast<PWCH>(
		ExAllocatePoolWithTag(NonPagedPoolNx, MAX_LEN, POOLTAG)
		);
	if (ZeroBuffer == NULL || SymbolicLinkName.Buffer == NULL)
	{
		KdPrint(("[%ws::%d] Failed with status: %08x.\n", 
			__FUNCTIONW__, __LINE__, Status));
		return Status;
	}
	else
	{
		RtlSecureZeroMemory(ZeroBuffer, WipeInputBuffer->ClusterSize);
		RtlSecureZeroMemory(SymbolicLinkName.Buffer, MAX_LEN);

		SymbolicLinkName.MaximumLength = MAX_LEN;
	}

	InitializeObjectAttributes(
		&oa, 
		&usDriveDirectory, 
		OBJ_CASE_INSENSITIVE, 
		NULL, NULL
	);

	Status = ZwOpenDirectoryObject(&hDirectoryHandle, DIRECTORY_QUERY, &oa);
	if (!NT_SUCCESS(Status))
	{
		KdPrint(("[%ws::%d] Failed with status: %08x.\n", 
			__FUNCTIONW__, __LINE__, Status));
		goto CleanupAndExit;
	}
	else
	{
		KdPrint(("[%ws::%d] Opened a handle to %wZ.\n", 
			__FUNCTIONW__, __LINE__, usDriveDirectory));
	}

	InitializeObjectAttributes(
		&oa, 
		&usDriveLetter, 
		OBJ_CASE_INSENSITIVE, 
		hDirectoryHandle, 
		NULL
	);

	Status = ZwOpenSymbolicLinkObject(&hDirectoryHandle, SYMBOLIC_LINK_QUERY, &oa);
	if (!NT_SUCCESS(Status))
	{
		KdPrint(("[%ws::%d] Failed with status: %08x.\n", 
			__FUNCTIONW__, __LINE__, Status));
		goto CleanupAndExit;
	}

	Status = ZwQuerySymbolicLinkObject(hDirectoryHandle, &SymbolicLinkName, NULL);
	if (!NT_SUCCESS(Status))
	{
		KdPrint(("[%ws::%d] Failed with status: %08x.\n",
			__FUNCTIONW__, __LINE__, Status));
		goto CleanupAndExit;
	}
	else
	{
		KdPrint(("[%ws::%d] Opened symbolic link to %wZ.\n", 
			__FUNCTIONW__, __LINE__, SymbolicLinkName));
	}

	Status = ZwOpenFile(
		&hFileHandle,
		GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
		&oa,
		&io,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		FILE_SYNCHRONOUS_IO_NONALERT
	);
	if (!NT_SUCCESS(Status) || hFileHandle == NULL)
	{
		KdPrint(("[%ws::%d] Failed with status: %08x.\n", 
			__FUNCTIONW__, __LINE__, Status));
		goto CleanupAndExit;
	}

	Status = ObReferenceObjectByHandle(
		hFileHandle, 
		FILE_READ_DATA | FILE_WRITE_DATA, 
		NULL, 
		KernelMode, 
		reinterpret_cast<PVOID*>(&FileObject), 
		NULL
	);
	if (NT_SUCCESS(Status))
	{
		DiskDeviceObject = FileObject->DeviceObject;
		if (DiskDeviceObject->Vpb != NULL)
		{
			if (DiskDeviceObject->Vpb->RealDevice != NULL)
			{
				DiskDeviceObject = DiskDeviceObject->Vpb->RealDevice;
			}
		}
		ObDereferenceObject(FileObject);
	}
	else
	{
		KdPrint(("[%ws::%d] Unable to reference handle.\n", 
			__FUNCTIONW__, __LINE__));
		goto CleanupAndExit;
	}

	StartingOffset.QuadPart = WipeInputBuffer->FileOffset;

	Irp = IoBuildSynchronousFsdRequest(
		IRP_MJ_WRITE,
		DiskDeviceObject,
		ZeroBuffer,
		WipeInputBuffer->ClusterSize,
		&StartingOffset,
		&EventObj,
		&io
	);
	if (Irp == NULL)
	{
		Status = STATUS_INSUFFICIENT_RESOURCES;

		KdPrint(("[%ws::%d] Failed with status: %08x.\n", 
			__FUNCTIONW__, __LINE__, Status));
		goto CleanupAndExit;
	}

	IoStackLocation = IoGetNextIrpStackLocation(Irp);
	IoStackLocation->Flags |= SL_OVERRIDE_VERIFY_VOLUME;
	IoStackLocation->Flags |= SL_FORCE_DIRECT_WRITE;

	Status = IoCallDriver(DiskDeviceObject, Irp);
	if (!NT_SUCCESS(Status))
	{
		KdPrint(("[%ws::%d] Failed with status: %08x.\n", 
			__FUNCTIONW__, __LINE__, Status));
		goto CleanupAndExit;
	}

	if (Status == STATUS_PENDING)
	{
		KeWaitForSingleObject(&EventObj, Executive, KernelMode, FALSE, NULL);
		Status = io.Status;
	}

CleanupAndExit:
	if (ZeroBuffer != NULL)
	{
		RtlSecureZeroMemory(ZeroBuffer, WipeInputBuffer->ClusterSize);
		ExFreePoolWithTag(ZeroBuffer, POOLTAG);
	}

	if (SymbolicLinkName.Buffer != NULL)
	{
		RtlSecureZeroMemory(SymbolicLinkName.Buffer, MAX_LEN);
		ExFreePoolWithTag(SymbolicLinkName.Buffer, POOLTAG);
	}

	if (DiskDeviceObject != NULL)
	{
		ObDereferenceObject(DiskDeviceObject);
	}

	if (hFileHandle != NULL)
	{
		ZwClose(hFileHandle);
		hFileHandle = NULL;
	}

	if (hDirectoryHandle != NULL)
	{
		ZwClose(hDirectoryHandle);
		hDirectoryHandle = NULL;
	}

	return Status;
}


/// EOF
```

`ANTfs Driver/dispatchroutines.h`:

```h
#pragma once
#include <ntifs.h>
#include "typesndefs.h"

/// <summary>
/// This locates the lower device of NTFS and directly
/// overwrites the contents of a file with zeroes, as 
/// well as the file record of that file. This is done
/// live, on disk.
/// </summary>
/// <param name="WipeInputBuffer"></param>
/// <returns>Returns STATUS_SUCCESS or the 
/// appropriate status code.</returns>
_Success_(return >= 0)
NTSTATUS 
OverwriteFileRecord(
	_In_ PWIPE_INPUT_BUFFER WipeInputBuffer
);


/// EOF
```

`ANTfs Driver/typesndefs.h`:

```h
#pragma once
#include <ntddk.h>

///---------------------------------------------------------------
/// Macro(s)
///---------------------------------------------------------------
#define ENCODE_IOCTL(DeviceType, Function)( \
	((DeviceType) << 16 |					\
	((FILE_WRITE_DATA) << 14) |				\
	((Function) << 2) |						\
	(METHOD_BUFFERED))						\
)

///---------------------------------------------------------------
/// Definitions
///---------------------------------------------------------------
constexpr auto POOLTAG = 'nRhC';
constexpr auto MAX_LEN = 260 * 2;

///---------------------------------------------------------------
/// Enum types
///---------------------------------------------------------------
typedef enum
{
	IoctlOverwrite = ENCODE_IOCTL(FILE_DEVICE_UNKNOWN, 0x900)
} IOCTLS;

///---------------------------------------------------------------
/// Struct Types
///---------------------------------------------------------------
#include <pshpack1.h>
typedef struct _WIPE_INPUT_BUFFER
{
	const wchar_t* DriveLetter;
	SIZE_T NameLength;
	const wchar_t* FileName;
	UINT64 FileOffset;
	UINT32 ClusterSize;
} WIPE_INPUT_BUFFER, * PWIPE_INPUT_BUFFER;
#include <poppack.h>


/// EOF
```

`ANTfs.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ANTfs", "ANTfs\ANTfs.vcxproj", "{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ANTfs Driver", "ANTfs Driver\ANTfs Driver.vcxproj", "{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Debug|ARM.ActiveCfg = Debug|Win32
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Debug|ARM64.ActiveCfg = Debug|Win32
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Debug|x64.ActiveCfg = Debug|x64
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Debug|x64.Build.0 = Debug|x64
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Debug|x86.ActiveCfg = Debug|Win32
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Debug|x86.Build.0 = Debug|Win32
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Release|ARM.ActiveCfg = Release|Win32
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Release|ARM64.ActiveCfg = Release|Win32
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Release|x64.ActiveCfg = Release|x64
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Release|x64.Build.0 = Release|x64
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Release|x86.ActiveCfg = Release|Win32
		{ADB7578B-189E-4FF0-AAF4-728F1BEEE462}.Release|x86.Build.0 = Release|Win32
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|ARM.ActiveCfg = Debug|ARM
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|ARM.Build.0 = Debug|ARM
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|ARM.Deploy.0 = Debug|ARM
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|ARM64.Build.0 = Debug|ARM64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|x64.ActiveCfg = Debug|x64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|x64.Build.0 = Debug|x64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|x64.Deploy.0 = Debug|x64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|x86.ActiveCfg = Debug|Win32
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|x86.Build.0 = Debug|Win32
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Debug|x86.Deploy.0 = Debug|Win32
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|ARM.ActiveCfg = Release|ARM
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|ARM.Build.0 = Release|ARM
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|ARM.Deploy.0 = Release|ARM
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|ARM64.ActiveCfg = Release|ARM64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|ARM64.Build.0 = Release|ARM64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|ARM64.Deploy.0 = Release|ARM64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|x64.ActiveCfg = Release|x64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|x64.Build.0 = Release|x64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|x64.Deploy.0 = Release|x64
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|x86.ActiveCfg = Release|Win32
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|x86.Build.0 = Release|Win32
		{CD7A5FBE-CAA6-474C-B967-04FF3477AA70}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5B5C254B-5322-4B0A-B38D-BF6A3C1C0776}
	EndGlobalSection
EndGlobal

```

`ANTfs/ANTfs.cpp`:

```cpp
/// ANTfs.cpp : This file contains the 'main' function. Program execution begins and ends there.
///

#include <Windows.h>
#include <algorithm>
#include <iostream>
#include <ctime>

#include "privileges.h"
#include "antiforensics.h"

bool 
GenerateOutputPath(
    _Inout_ std::wstring& Output
)
{
    std::wstringstream ss;
    Output.resize(MAX_PATH * 2, '\0');

    DWORD DirLength = GetCurrentDirectory(MAX_PATH, &Output[0]);
    if (DirLength == NULL)
    {
        std::wcerr << "[!] Failed to get current directory: ";
        std::wcerr << GetLastError() << std::endl;

        return false;
    }

    Output.resize(wcslen(Output.c_str()));

    ss << Output.c_str();
    ss << L"\\";
    ss << time(0);
    ss << L"_recovered\\";

    Output = ss.str();

    return true;
}

void Usage(
    _In_ wchar_t* argv
)
{
    std::wcout << "Usage: " << argv << " [-d/--drive drive letter]";
    std::wcout << " [-r/--recover -o/--outfile] || [-w/--wipe-record file name]" << std::endl;
    std::wcout << "\nAn application to recover deleted data or to wipe the record of a file";
    std::wcout << " that has been introduced to the system. The goal is to stay undetected if";
    std::wcout << " the drive is being analyzed by a forensic analyst or to recover data for ";
    std::wcout << "recovering potential sensitive data." << std::endl;
    std::wcout << "\nRequired arguments:" << std::endl;
    std::wcout << "-d, --drive\tThe letter of the drive to search through." << std::endl;
    std::wcout << "\nOptional arguments:" << std::endl;
    std::wcout << "-r, --recover\tAttempts to recover deleted files on the drive." << std::endl;
    std::wcout << "-o, --outfile\tOutputs the file(s) into a directory." << std::endl;
    std::wcout << "-w, --wipe\tAttempts to wipe the record clean of the file." << std::endl;
    std::wcout << "-h, --help\tShow this help message and exit." << std::endl;
    std::wcout << "\nAtleast one of the optional arguments is required. If the recover option "; 
    std::wcout << "is selected, the outfile parameter is required. There is a default output ";
    std::wcout << "file that is a time-stamped folder created in the same directory that ";
    std::wcout << argv << " is being run in." << std::endl;
}

int wmain(
    int argc, 
    wchar_t* argv[]
)
{
    bool bRecover = false;
    bool bWipe = false;

    std::wstring DriveLetter;
    std::wstring FileRecord;
    std::wstring Storage;

    UINT32 NumberOfRecords = 0;

    std::unique_ptr<antiforensics> Antiforensics;

    std::wcout << "       _     ___      _____________   __       " << std::endl;
    std::wcout << "      dM.    `MM\\     `M'MMMMMMMMMM  69MM      " << std::endl;
    std::wcout << "     ,MMb     MMM\\     M /   MM   \\ 6M' `      " << std::endl;
    std::wcout << "     d'YM.    M\\MM\\    M     MM    _MM______   " << std::endl;
    std::wcout << "    ,P `Mb    M \\MM\\   M     MM    MMMM6MMMMb\\ " << std::endl;
    std::wcout << "    d'  YM.   M  \\MM\\  M     MM     MMMM'    ` " << std::endl;
    std::wcout << "   ,P   `Mb   M   \\MM\\ M     MM     MMYM.      " << std::endl;
    std::wcout << "   d'    YM.  M    \\MM\\M     MM     MM YMMMMb  " << std::endl;
    std::wcout << "  ,MMMMMMMMb  M     \\MMM     MM     MM     `Mb " << std::endl;
    std::wcout << "  d'      YM. M      \\MM     MM     MML    ,MM " << std::endl;
    std::wcout << "_dM_     _dMM_M_      \\M    _MM_   _MMMYMMMM9  \n" << std::endl;

    if (!privileges::checkAdminPrivileges())
    {
        std::wcerr << "[!] Must run with administrator privileges!" << std::endl;
        return EXIT_FAILURE;
    }

    if (argc < 2)
    {
        Usage(argv[0]);
        return EXIT_FAILURE;
    }

    for (int i = 0; i < argc; i++)
    {
        if (wcscmp(argv[i], L"-d") == 0 || wcscmp(argv[i], L"--drive") == 0)
        {
            DriveLetter = argv[i + 1];

            ///
            /// Check to see if theres a colon for the drive. If not, add it.
            /// 
            if (DriveLetter.find(L":") == std::string::npos)
            {
                DriveLetter.insert(DriveLetter.size(), L":");
            }

            ///
            /// Now convert it to the format needed for CreateFile.
            /// 
            DriveLetter.insert(0, L"\\\\.\\");
        }
        else if (wcscmp(argv[i], L"-r") == 0 || wcscmp(argv[i], L"--recover") == 0)
        {
            if (argv[i + 1])
            {
                if (wcscmp(argv[i + 1], L"-o") == 0 || wcscmp(argv[i + 1], L"--outfile") == 0)
                {
                    bRecover = true;
                    if (argv[i + 2])
                    {
                        Storage = argv[i + 2];

                        ///
                        /// Check to see if the path ends with a back slash. If not,
                        /// add it.
                        /// 
                        if (reinterpret_cast<const wchar_t*>(Storage.back()) != L"\\")
                        {
                            Storage.insert(Storage.size(), L"\\");
                        }
                    }
                }
            }
        }
        else if (wcscmp(argv[i], L"-w") == 0 || wcscmp(argv[i], L"--wipe") == 0)
        {
            if (argv[i + 1] && argv[i + 1][0] != '-')
            {
                bWipe = true;

                FileRecord = argv[i + 1];
            }
        }
        else if (wcscmp(argv[i], L"-h") == 0 || wcscmp(argv[i], L"--help") == 0)
        {
            Usage(argv[0]);
            return EXIT_SUCCESS;
        }
    }

    if (!bRecover && !bWipe)
    {
        std::wcerr << "[!] Provide an option to either recover or wipe a file record" << std::endl;
        return EXIT_FAILURE;
    }

    Antiforensics = std::make_unique<antiforensics>();

    std::wcout << "[+] Initializing " << DriveLetter << "...";
    if (!Antiforensics->init(DriveLetter.c_str()))
    {
        std::wcerr << "uh-oh!" << std::endl;
        std::wcerr << Antiforensics->what() << std::endl;
        return EXIT_FAILURE;
    }
    else
    {
        std::wcout << "done." << std::endl;
    }

    if (bRecover)
    {
        if (Storage.empty())
        {
            if (!GenerateOutputPath(Storage))
            {
                std::wcerr << "[!] Unable to create string: " << GetLastError() << std::endl;
                return EXIT_FAILURE;
            }
        }

        if (!CreateDirectory(Storage.c_str(), NULL))
        {
            std::wcerr << "[!] Unable to create " << Storage;
            std::wcerr << ": " << GetLastError() << std::endl;
            return EXIT_FAILURE;
        }

        std::wcout << "[+] Scanning to recover files from: ";
        std::wcout << DriveLetter.c_str() << "." << std::endl;

        if (!Antiforensics->RecoverFiles(Storage, &NumberOfRecords))
        {
            std::wcerr << Antiforensics->what();
            return EXIT_FAILURE;
        }

        std::wcout << "[+] Finished recovering " << NumberOfRecords << " records." << std::endl;
    }


    if (bWipe && !FileRecord.empty())
    {
        ///
        /// Strip the formatting of the drive so it can get processed within the kernel.
        /// 
        size_t pos = DriveLetter.find(L"\\\\.\\");
        if (pos != std::wstring::npos)
        {
            DriveLetter.erase(pos, wcslen(L"\\\\.\\"));
        }
        
        std::wcout << "[+] Going to try and wipe record for ";
        std::wcout << FileRecord.c_str() << "...";

        if (!Antiforensics->WipeRecord(DriveLetter.c_str(), FileRecord.c_str()))
        {
            std::wcerr << "uh-oh!" << std::endl;
            std::wcerr << Antiforensics->what();
        }
        else
        {
            std::wcout << "done." << std::endl;
        }

        std::wcout << "[+] Finished." << std::endl;
    }

    return EXIT_SUCCESS;
}


/// EOF
```

`ANTfs/ANTfs.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{adb7578b-189e-4ff0-aaf4-728f1beee462}</ProjectGuid>
    <RootNamespace>ANTfs</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ANTfs.cpp" />
    <ClCompile Include="antiforensics.cpp" />
    <ClCompile Include="privileges.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="antiforensics.h" />
    <ClInclude Include="privileges.h" />
    <ClInclude Include="typesndefs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ANTfs/ANTfs.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\classes">
      <UniqueIdentifier>{459ff526-adf6-42ff-a020-806a05fb54f1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\namespaces">
      <UniqueIdentifier>{b79e7fe5-72e1-4280-89c1-5ebde958948a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\types">
      <UniqueIdentifier>{be1afe1f-dd4a-4c22-a343-22e4684d4c2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\classes">
      <UniqueIdentifier>{1410e274-ca8f-401e-91f0-a01c16742fa7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\namespaces">
      <UniqueIdentifier>{a2be1ccd-3d55-458a-99bf-9d9b7426e109}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ANTfs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="antiforensics.cpp">
      <Filter>Source Files\classes</Filter>
    </ClCompile>
    <ClCompile Include="privileges.cpp">
      <Filter>Source Files\namespaces</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="antiforensics.h">
      <Filter>Header Files\classes</Filter>
    </ClInclude>
    <ClInclude Include="privileges.h">
      <Filter>Header Files\namespaces</Filter>
    </ClInclude>
    <ClInclude Include="typesndefs.h">
      <Filter>Header Files\types</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ANTfs/antiforensics.cpp`:

```cpp
#include "antiforensics.h"

_Use_decl_annotations_
bool 
antiforensics::WriteToFile(
    std::wstring OutputFile,
    PUINT8 lpBuffer, 
    UINT32 dwNumberOfBytesToWrite
)
{
    std::wstringstream ss;

    bool bStatus = false;

    int duplicate = 1;

    HANDLE hFile = INVALID_HANDLE_VALUE;

    ss << OutputFile.c_str();

    do
    {
        hFile = CreateFile(
            ss.str().c_str(),
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );
        if (GetLastError() == ERROR_FILE_EXISTS)
        {
            ss.str(std::wstring());

            ss << OutputFile.c_str();
            ss << L"_";
            ss << duplicate++;
        }
    } while (GetLastError() != ERROR_SUCCESS);

    bStatus = WriteFile(
        hFile,
        lpBuffer,
        dwNumberOfBytesToWrite,
        NULL,
        NULL
    );
    if (!bStatus)
    {
        return bStatus;
    }

    CloseHandle(hFile);
    return bStatus;
}

_Use_decl_annotations_
wchar_t* 
antiforensics::LastError()
{
    wchar_t* error[MAXERRORLENGTH] = { 0 };

    FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        reinterpret_cast<LPWSTR>(&error),
        MAXERRORLENGTH,
        NULL
    );

    return *error;
}

_Use_decl_annotations_
void 
antiforensics::ParseRunList(
    PUINT8& RunListData,
    PUINT32 TotalClusterSize,
    PUINT32 RelativeOffset
)
{
    UINT32 NumberOfClusters = 0;
    UINT32 TempLcn = 0;

    PRUNLIST_HEADER RunListHeader = reinterpret_cast<PRUNLIST_HEADER>(
        RunListData
        );

    ///
    /// Skip over the header. Doesn't need to get parsed.
    /// 
    RunListData++;

    ///
    /// Parse the length of the attribute. 
    /// 
    switch (RunListHeader->ByteLength)
    {
    case 1:
        NumberOfClusters = *reinterpret_cast<PINT8>(RunListData);
        break;
    case 2:
        NumberOfClusters = *reinterpret_cast<PINT16>(RunListData);
        break;
    case 3:
    case 4:
        NumberOfClusters = *reinterpret_cast<PINT32>(RunListData);
        if (RunListHeader->ByteLength == 3)
        {
            NumberOfClusters &= 0xffffff;
        }
        break;
    default:
        ///
        /// We shouldn't be in here but just in case there's anything 
        /// over 4, let's just break to see what value it is and 
        /// implement it. 
        /// 
        std::printf("[!] Got %d and is not implemented. Breaking at %d...\n",
            RunListHeader->ByteLength, __LINE__);
        DebugBreak();
        break;
    }

    *TotalClusterSize = NumberOfClusters;

    ///
    /// Move on to the next entry to parse the number of clusters
    /// this data is on.
    /// 
    RunListData += RunListHeader->ByteLength;

    if (RunListHeader->ByteOffset)
    {
        switch (RunListHeader->ByteOffset)
        {
        case 1:
            TempLcn = *reinterpret_cast<PINT8>(RunListData);
            break;
        case 2:
            TempLcn = *reinterpret_cast<PINT16>(RunListData);
            break;
        case 3:
            TempLcn = *reinterpret_cast<PINT32>(RunListData);
            TempLcn &= 0xffffff;

            ///
            /// Check to see if this value is negative. If it is a negative number,
            /// pad the most significant byte with an 0xff.
            /// 
            if ((TempLcn & 0x800000) >> 17)
            {
                TempLcn |= 0xff000000;
            }
            break;
        case 4:
            TempLcn = *reinterpret_cast<PINT32>(RunListData);
            break;
        default:
            ///
            /// Same as above. We shouldn't be in here but just in case there's
            /// anything over 4, let's just break to see what value it is and then
            /// implement it. 
            ///
            std::printf("[!] Got %d and is not implemented. Breaking at %d...\n",
                RunListHeader->ByteLength, __LINE__);
            DebugBreak();
            break;
        }
    }
    else
    {
        TempLcn = 0;
    }

    *RelativeOffset = TempLcn;
    RunListData += RunListHeader->ByteOffset;
}

_Use_decl_annotations_
PATTRIBUTE 
antiforensics::GetAttributeFor(
    ATTRIBUTE_TYPE AttributeType,
    PFILE_RECORD FileRecord
)
{
    PATTRIBUTE Attribute = nullptr;

    PATTRIBUTE temp = reinterpret_cast<PATTRIBUTE>(
        NextEntry(FileRecord, FileRecord->AttributeOffset)
        );

    if (temp->AttributeType == AttributeEnd)
    {
        return nullptr;
    }

    do
    {
        if (temp->AttributeType == AttributeType)
        {
            switch (temp->AttributeType)
            {
            case AttributeFileName:
                ///
                /// If the attribute's ID is 2, you will get the long filename. If the
                /// attribute's ID is 3, you will get the short filename. I want the 
                /// long filename.
                /// 
                if (temp->AttributeIdentifier == NamespaceDos)
                {
                    Attribute = reinterpret_cast<PATTRIBUTE>(
                        new UINT8[temp->Length]()
                        );
                    RtlCopyMemory(Attribute, temp, temp->Length);
                    return Attribute;
                }
                break;
            case AttributeData:
                /// 
                /// If the attribute is resident and the attribute is not nameless, this means 
                /// that there is an alternative data stream present (at least in my testing).
                /// I am only interested in data, not named attributes.
                /// 
                if (temp->IsNonResident)
                {
                    Attribute = reinterpret_cast<PATTRIBUTE>(
                        new UINT8[temp->Length]()
                        );
                    RtlCopyMemory(Attribute, temp, temp->Length);
                    return Attribute;
                }
                else if (!temp->IsNonResident && temp->NameLength == NULL)
                {
                    Attribute = reinterpret_cast<PATTRIBUTE>(
                        new UINT8[temp->Length]()
                        );
                    RtlCopyMemory(Attribute, temp, temp->Length);

                    return Attribute;
                }
                break;
            default:
                break;
            }
        }

        temp = NextEntry(temp, temp->Length);
    } while (temp->AttributeType != AttributeEnd);

    return Attribute;
}

_Use_decl_annotations_
bool 
antiforensics::VerifySector(
    PFILE_RECORD& FileRecord
)
{
    PUINT16 Usn = reinterpret_cast<PUINT16>(
        NextEntry(FileRecord, BootSector->BytesPerSector - 2)
        );
    if (*Usn != FileRecord->Usn)
    {
        wsprintf(e, L"[%ws::%d] Expected %04x, but got %04x.\n", 
            __FUNCTIONW__, __LINE__, FileRecord->Usn, *Usn);

        return false;
    }

    RtlCopyMemory(
        reinterpret_cast<PUINT8>(FileRecord) + BootSector->BytesPerSector - 2,
        FileRecord->UpdateSequenceArray,
        FileRecord->UsaCount - 1
    );

    return true;
}

_Use_decl_annotations_
bool 
antiforensics::ReadNtfsFrom(
    LONGLONG Offset,
    ULONG Length,
    PVOID Buffer
)
{
    OVERLAPPED ol = { 0 };

    ol.Offset = Offset & 0xffffffff;
    ol.OffsetHigh = Offset >> 32;

    bool bStatus = ReadFile(
        hFileHandle,
        Buffer,
        Length,
        NULL,
        &ol
    );
    if (!bStatus)
    {
        wsprintf(e, L"[%ws::%d] %ws\n", __FUNCTIONW__, __LINE__, LastError());
    }
    return bStatus;
}

antiforensics::antiforensics()
{
}

antiforensics::~antiforensics()
{
    if (!MftRunList.empty())
    {
        for (PRUNLIST temp : MftRunList)
        {
            RtlSecureZeroMemory(temp, sizeof(RUNLIST));
            delete temp; temp = nullptr;
        }
    }

    if (hFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFileHandle);
        hFileHandle = NULL;
    }

    if (MftFileRecord != nullptr)
    {
        RtlSecureZeroMemory(MftFileRecord, BytesPerFileRecord);
        delete[] MftFileRecord; MftFileRecord = nullptr;
    }

    if (BootSector != nullptr)
    {
        RtlSecureZeroMemory(BootSector, sizeof(BOOT_SECTOR));
        delete BootSector; BootSector = nullptr;
    }
}

_Use_decl_annotations_
bool 
antiforensics::init(
    const wchar_t* DriveName
)
{
    UINT32 StartingLcn = 0;

    hFileHandle = CreateFile(
        DriveName,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (hFileHandle == INVALID_HANDLE_VALUE)
    {
        wsprintf(e, L"[%ws::%d] %ws", __FUNCTIONW__, __LINE__, LastError());
        return false;
    }

    BootSector = new BOOT_SECTOR();

    bool bStatus = ReadNtfsFrom(NULL, sizeof(BOOT_SECTOR), BootSector);
    if (!bStatus)
    {
        wsprintf(e, L"[%ws::%d] %ws", __FUNCTIONW__, __LINE__, LastError());
        return false;
    }

    if (BootSector->Signature != NTFS_BOOT_SECTOR_SIGNATURE)
    {
        wsprintf(e, L"[%ws::%d] Boot signature mismatch! Expected %04x, but got %04x.\n", 
            __FUNCTIONW__, __LINE__, NTFS_BOOT_SECTOR_SIGNATURE, BootSector->Signature);
        return false;
    }

    ///
    /// The MFT can be calculated by multiplying the starting cluster of the MFT by
    /// BootSector->SectorsPerCluster and then shifting it left by 9. This is done
    /// for the MFT Mirror as well. 
    /// 
    MftOffset = BootSector->StartingClusterOfMft * BootSector->SectorsPerCluster;
    MftOffset *= BootSector->BytesPerSector;

    MftFileRecord = reinterpret_cast<PFILE_RECORD>(
        new UINT8[BytesPerFileRecord]()
        );

    bStatus = ReadNtfsFrom(MftOffset, BytesPerFileRecord, MftFileRecord);
    if (!bStatus)
    {
        wsprintf(e, L"[%ws::%d] %ws", __FUNCTIONW__, __LINE__, LastError());
        return false;
    }

    if (MftFileRecord->Signature != FILE_SIGNATURE)
    {
        wsprintf(e, L"[%ws::%d] $MFT signature mismatch! Expected %04x, but got %04x.\n",
            __FUNCTIONW__, __LINE__, NTFS_BOOT_SECTOR_SIGNATURE, BootSector->Signature);
        return false;
    }

    if (!VerifySector(MftFileRecord))
    {
        return false;
    }

    ///
    /// There can be multiple MFT's in the drive. We need to pull all the 
    /// data run entries to enumerate all of the files on the system.
    /// 
    PATTRIBUTE Attribute = GetAttributeFor(AttributeData, MftFileRecord);
    if (Attribute == NULL)
    {
        wsprintf(e, L"[%ws::%d] Unable to find attribute for %02x.\n", 
            __FUNCTIONW__, __LINE__, AttributeData);
        return false;
    }

    ///
    /// Iterate through the data runs and save them in a vector to be used 
    /// later.
    /// 
    PUINT8 MftRunListData = reinterpret_cast<PUINT8>(
        NextEntry(Attribute, Attribute->NonResident.RunArrayOffset)
        );

    do
    {
        PRUNLIST RunListData = new RUNLIST();

        ParseRunList(MftRunListData, &RunListData->ClusterSize, &RunListData->LcnOffset);

        ///
        /// Calculate the size (in bytes) of the clusters.
        /// 
        RunListData->ClusterSize *= BootSector->SectorsPerCluster;
        RunListData->ClusterSize *= BootSector->BytesPerSector;

        StartingLcn += RunListData->LcnOffset;

        RunListData->AbsoluteOffset = StartingLcn * BootSector->SectorsPerCluster;
        RunListData->AbsoluteOffset *= BootSector->BytesPerSector;

        MftRunList.push_back(RunListData);
    } while (*MftRunListData != NULL);

    if (MftRunList.empty())
    {
        ///
        /// We shouldn't be in here, but just in case.
        /// 
        wsprintf(e, L"[%ws::%d] There were no entries allocated.\n", 
            __FUNCTIONW__, __LINE__);
        return false;
    }
    
    return true;
}

_Use_decl_annotations_
bool 
antiforensics::RecoverFiles(
    std::wstring OutputDirectory,
    PUINT32 NumberOfRecords
)
{
    std::wstringstream ss;

    UINT32 RecordCount = 0;

    bool bStatus = false;

    PATTRIBUTE FilenameAttribHeader = nullptr;
    PATTRIBUTE DataAttributeHeader = nullptr;
    PFILENAME_ATTRIB FileNameAttribute = nullptr;

    PFILE_RECORD FileRecord = reinterpret_cast<PFILE_RECORD>(
        new UINT8[BytesPerFileRecord]()
        );

    wchar_t* FileName = new wchar_t[MAX_PATH * 2]();

    for (PRUNLIST DataRun : MftRunList)
    {
        UINT64 Offset = DataRun->AbsoluteOffset;

        ///
        /// Adjust the size to take into account the file records. We don't want to count down
        /// from 2048 if there's only two file records.
        /// 
        UINT32 NumberOfRecords = DataRun->ClusterSize / BytesPerFileRecord;
        do
        {
            bStatus = ReadNtfsFrom(Offset, BytesPerFileRecord, FileRecord);
            if (bStatus)
            {
                ///
                /// Ran into a weird issue where the logic for signature was picking up junk, 
                /// like FILE_UPLOAD_LIMITE_PREMIUM_TIER_1. The offset to the update sequence isn't
                /// a good check because it could probably change; instead, I AND it to check if it contains
                /// an underscore. It's a little hacky, but it works.
                /// 
                if (FileRecord->Signature == FILE_SIGNATURE && (FileRecord->UsaOffset & 0xff) != '_')
                {
                    ///
                    /// Check to make sure the USN matches the last two bytes of the record. 
                    /// 
                    if (!VerifySector(FileRecord))
                    {
                        std::wcerr << LastError() << std::endl;
                        std::wcerr << "[!] Warning: Usn does not match for record: " << std::hex << Offset << std::endl;
                    }

                    ///
                    /// Check the records allocation status. If it's unallocatd, I want it.
                    /// 
                    if (FileRecord->Flags.value == NULL)
                    {
                        FilenameAttribHeader = GetAttributeFor(AttributeFileName, FileRecord);
                        if (FilenameAttribHeader)
                        {
                            FileNameAttribute = reinterpret_cast<PFILENAME_ATTRIB>(
                                NextEntry(FilenameAttribHeader, FilenameAttribHeader->Resident.ValueOffset)
                                );

                            RtlCopyMemory(FileName, FileNameAttribute->Filename, FileNameAttribute->FilenameLength * 2);

                            ///
                            /// Hit some cases where we would receive multibtye characters and would throw off
                            /// the program and offset the structures. This sanity checks by getting rid of the multibyte
                            /// and replacing it with an underscore.
                            /// 
                            for (int i = 0; i < FileNameAttribute->FilenameLength; i++)
                            {
                                if (FileName[i] & 0xff00)
                                {
                                    FileName[i] = 0x005f;
                                }
                            }

                            ss << OutputDirectory.c_str();
                            ss << FileName;

                            std::wcout << "[+] Writing to " << ss.str().c_str() << "." << std::endl;

                            DataAttributeHeader = GetAttributeFor(AttributeData, FileRecord);
                            if (DataAttributeHeader)
                            {
                                if (!DataAttributeHeader->IsNonResident)
                                {
                                    if (DataAttributeHeader->Resident.ValueLength != NULL)
                                    {
                                        PUINT8 DataLocation = reinterpret_cast<PUINT8>(
                                            NextEntry(DataAttributeHeader, DataAttributeHeader->Resident.ValueOffset)
                                            );

                                        if (!WriteToFile(ss.str(), DataLocation, DataAttributeHeader->Resident.ValueLength))
                                        {
                                            std::wcerr << "Dammit: " << LastError() << std::endl;
                                        }

                                        RecordCount++;
                                    }
                                }
                                else
                                {
                                    if (DataAttributeHeader->NonResident.AllocatedSize != NULL)
                                    {
                                        PUINT8 RunListData = reinterpret_cast<PUINT8>(
                                            NextEntry(DataAttributeHeader, DataAttributeHeader->NonResident.RunArrayOffset)
                                            );

                                        UINT64 StartingLcn = 0;
                                        UINT64 DataOffset = 0;

                                        PUINT8 AllocatedData = new UINT8[DataAttributeHeader->NonResident.AllocatedSize]();

                                        do
                                        {
                                            UINT64 AbsoluteOffset = 0;
                                            UINT32 ClusterSize = 0;
                                            UINT32 TempLcn = 0;

                                            ParseRunList(RunListData, &ClusterSize, &TempLcn);

                                            ///
                                            /// If TempLcn is zero, that means we hit a sparse file. Move on.
                                            /// 
                                            if (TempLcn == NULL)
                                            {
                                                continue;
                                            }

                                            ///
                                            /// Calculate the size (in bytes) of the clusters.
                                            /// 
                                            ClusterSize *= BootSector->SectorsPerCluster;
                                            ClusterSize *= BootSector->BytesPerSector;

                                            StartingLcn += TempLcn;

                                            AbsoluteOffset = StartingLcn * BootSector->SectorsPerCluster;
                                            AbsoluteOffset *= BootSector->BytesPerSector;

                                            ///
                                            /// Throughout my entire testing on tons and tons of files on various 
                                            /// drives, it seems the absolute address goes up to only five bytes
                                            /// so mask off the extra byte since UINT64 is eight.
                                            /// 
                                            AbsoluteOffset &= 0xffffffffff;

                                            if (!ReadNtfsFrom(AbsoluteOffset, ClusterSize, AllocatedData + DataOffset))
                                            {
                                                std::wcerr << "Failed: " << GetLastError() << std::endl;
                                            }

                                            DataOffset += ClusterSize;

                                        } while (*RunListData != NULL);

#ifdef _DEBUG
                                        if (DataAttributeHeader->NonResident.AllocatedSize > 0xffffffff)
                                        {
                                            std::wcerr << "[!] We have a size bigger than a UINT32. File record: ";
                                            std::wcerr << std::hex << Offset << std::endl;
                                        }
#endif // DEBUG

                                        ///
                                        /// Now output the data into a file and then clear up and release
                                        /// the allocated memory.
                                        ///
                                        if (!WriteToFile(ss.str(), AllocatedData, DataAttributeHeader->NonResident.AllocatedSize))
                                        {
                                            std::wcerr << "Dammit: " << LastError() << std::endl;
                                        }

                                        RecordCount++;

                                        RtlSecureZeroMemory(AllocatedData, DataAttributeHeader->NonResident.AllocatedSize);
                                        delete[] AllocatedData;
                                        AllocatedData = nullptr;
                                    }
                                }
                            }

                            ///
                            /// Clear the filename to get reused again.
                            /// 
                            ss.str(std::wstring());

                            if (DataAttributeHeader)
                            {
                                RtlSecureZeroMemory(DataAttributeHeader, DataAttributeHeader->Length);
                                delete[] DataAttributeHeader;
                                DataAttributeHeader = nullptr;
                            }
                        }

                        if (FilenameAttribHeader)
                        {
                            RtlSecureZeroMemory(FilenameAttribHeader, FilenameAttribHeader->Length);
                            delete[] FilenameAttribHeader;
                            FilenameAttribHeader = nullptr;
                        }
                    }
                }
            }

            RtlSecureZeroMemory(FileName, MAX_PATH * 2);

            Offset += BytesPerFileRecord;
        } while (NumberOfRecords--);
    }

    *NumberOfRecords = RecordCount;

    if (FileName != nullptr)
    {
        RtlSecureZeroMemory(FileName, MAX_PATH * 2);
        delete[] FileName;
        FileName = nullptr;
    }

    RtlSecureZeroMemory(FileRecord, BytesPerFileRecord);
    delete[] FileRecord;
    FileRecord = nullptr;

    return bStatus;
}

_Use_decl_annotations_
bool 
antiforensics::WipeRecord(
    const wchar_t* DriveLetter,
    const wchar_t* NameOfFileRecord
)
{
    bool bStatus = false;
    bool bWipedAlready = false;

    PATTRIBUTE FilenameAttribHeader = nullptr;
    PATTRIBUTE DataAttributeHeader = nullptr;
    PFILENAME_ATTRIB FileNameAttribute = nullptr;
    PWIPE_INPUT_BUFFER OverwriteBuffer = nullptr;

    PFILE_RECORD FileRecord = reinterpret_cast<PFILE_RECORD>(
        new UINT8[BytesPerFileRecord]()
        );

    wchar_t* FileName = new wchar_t[MAX_PATH * 2]();

    HANDLE hFile = CreateFile(
        ANTFS_DRIVER_NAME,
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        wsprintf(e, L"[%ws::%d] %ws\n",
            __FUNCTIONW__, __LINE__, LastError());

        return false;
    }

    for (PRUNLIST DataRun : MftRunList)
    {
        UINT64 Offset = DataRun->AbsoluteOffset;

        ///
        /// Adjust the size to take into account the file records. We don't want to count down
        /// from 2048 if there's only two file records.
        /// 
        UINT32 NumberOfRecords = DataRun->ClusterSize / BytesPerFileRecord;
        do
        {
            bStatus = ReadNtfsFrom(Offset, BytesPerFileRecord, FileRecord);
            if (bStatus)
            {
                ///
                /// Ran into a weird issue where the logic for signature was picking up junk, 
                /// like FILE_UPLOAD_LIMITE_PREMIUM_TIER_1. The offset to the update sequence isn't
                /// a good check because it could probably change; instead, I AND it to check if it contains
                /// an underscore. It's a little hacky, but it works.
                /// 
                if (FileRecord->Signature == FILE_SIGNATURE && (FileRecord->UsaOffset & 0xff) != '_' && FileRecord->Flags.value == NULL)
                {
                    bStatus = false;

                    ///
                    /// Check to make sure the USN matches the last two bytes of the record. Then
                    /// NULL them.
                    /// 
                    if (!VerifySector(FileRecord))
                    {
                        std::wcerr << LastError() << std::endl;
                        std::wcerr << "[!] Warning: Usn does not match for record: " << std::hex << Offset << std::endl;
                    }

                    FilenameAttribHeader = GetAttributeFor(AttributeFileName, FileRecord);
                    if (FilenameAttribHeader)
                    {
                        FileNameAttribute = reinterpret_cast<PFILENAME_ATTRIB>(
                            NextEntry(FilenameAttribHeader, FilenameAttribHeader->Resident.ValueOffset)
                            );

                        ///
                        /// Hit some cases where we would receive multibtye characters and would throw off
                        /// the program and offset the structures. This sanity checks by getting rid of the multibyte
                        /// and replacing it with an underscore.
                        /// 
                        for (int i = 0; i < FileNameAttribute->FilenameLength; i++)
                        {
                            if (FileName[i] & 0xff00)
                            {
                                FileName[i] = 0x005f;
                            }
                        }

                        RtlCopyMemory(FileName, FileNameAttribute->Filename, FileNameAttribute->FilenameLength * 2);

                        if (wcscmp(FileName, NameOfFileRecord) == 0)
                        {
                            OverwriteBuffer = new WIPE_INPUT_BUFFER();

                            OverwriteBuffer->DriveLetter = DriveLetter;
                            OverwriteBuffer->FileName = NameOfFileRecord;
                            OverwriteBuffer->NameLength = wcslen(NameOfFileRecord);

                            ///
                            /// Wipe the record of that data. This section will go through and iterate through 
                            /// each data location.
                            /// 
                            DataAttributeHeader = GetAttributeFor(AttributeData, FileRecord);
                            if (DataAttributeHeader)
                            {
                                SIZE_T InputBufferSize = sizeof(WIPE_INPUT_BUFFER);
                                InputBufferSize += wcslen(OverwriteBuffer->DriveLetter);
                                InputBufferSize += OverwriteBuffer->NameLength;

                                if (!DataAttributeHeader->IsNonResident)
                                {
                                    if (DataAttributeHeader->Resident.ValueLength != NULL)
                                    {
                                        OverwriteBuffer->FileOffset = Offset;
                                        OverwriteBuffer->ClusterSize = BytesPerFileRecord;

                                        DeviceIoControl(
                                            hFile, 
                                            IoctlOverwrite, 
                                            OverwriteBuffer, 
                                            InputBufferSize,
                                            NULL, NULL, NULL, NULL
                                        );
                                    }
                                }
                                else
                                {
                                    if (DataAttributeHeader->NonResident.AllocatedSize != NULL)
                                    {
                                        PUINT8 RunListData = reinterpret_cast<PUINT8>(
                                            NextEntry(DataAttributeHeader, DataAttributeHeader->NonResident.RunArrayOffset)
                                            );

                                        UINT64 StartingLcn = 0;
                                        UINT64 DataOffset = 0;

                                        PUINT8 AllocatedData = new UINT8[DataAttributeHeader->NonResident.AllocatedSize]();

                                        do
                                        {
                                            UINT64 AbsoluteOffset = 0;
                                            UINT32 ClusterSize = 0;
                                            UINT32 TempLcn = 0;

                                            ParseRunList(RunListData, &ClusterSize, &TempLcn);

                                            ///
                                            /// If TempLcn is zero, that means we hit a sparse file. Move on.
                                            /// 
                                            if (TempLcn == NULL)
                                            {
                                                continue;
                                            }

                                            ///
                                            /// Calculate the size (in bytes) of the clusters.
                                            /// 
                                            ClusterSize *= BootSector->SectorsPerCluster;
                                            ClusterSize *= BootSector->BytesPerSector;

                                            StartingLcn += TempLcn;

                                            AbsoluteOffset = StartingLcn * BootSector->SectorsPerCluster;
                                            AbsoluteOffset *= BootSector->BytesPerSector;

                                            ///
                                            /// Throughout my entire testing on tons and tons of files on various 
                                            /// drives, it seems the absolute address goes up to only five bytes
                                            /// so mask off the extra byte since UINT64 is eight.
                                            /// 
                                            AbsoluteOffset &= 0xffffffffff;

                                            OverwriteBuffer->FileOffset = AbsoluteOffset;
                                            OverwriteBuffer->ClusterSize = ClusterSize;

                                            DeviceIoControl(
                                                hFile, 
                                                IoctlOverwrite, 
                                                OverwriteBuffer, 
                                                InputBufferSize,
                                                NULL, NULL, NULL, NULL
                                            );

                                            DataOffset += ClusterSize;

                                        } while (*RunListData != NULL);

                                        ///
                                        /// Now that all the locations have been wiped, wipe the record itself.
                                        /// 
                                        OverwriteBuffer->FileOffset = Offset;
                                        OverwriteBuffer->ClusterSize = BytesPerFileRecord;

                                        DeviceIoControl(
                                            hFile,
                                            IoctlOverwrite,
                                            OverwriteBuffer,
                                            InputBufferSize,
                                            NULL, NULL, NULL, NULL
                                        );

                                        RtlSecureZeroMemory(AllocatedData, DataAttributeHeader->NonResident.AllocatedSize);
                                        delete[] AllocatedData;
                                        AllocatedData = nullptr;
                                    }
                                }
                            }


                            if (DataAttributeHeader)
                            {
                                RtlSecureZeroMemory(DataAttributeHeader, DataAttributeHeader->Length);
                                delete[] DataAttributeHeader;
                                DataAttributeHeader = nullptr;
                            }
                        }
                    }
                }
            }

            Offset += BytesPerFileRecord;
        } while (NumberOfRecords--);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    if (OverwriteBuffer != nullptr)
    {
        RtlSecureZeroMemory(OverwriteBuffer, sizeof(WIPE_INPUT_BUFFER));
        delete OverwriteBuffer;
        OverwriteBuffer = nullptr;
    }
    else
    {
        bStatus = false;

        wsprintf(e, L"[%ws::%d] Unable to find %ws.\n",
            __FUNCTIONW__, __LINE__, NameOfFileRecord);
    }

    if (FileName != nullptr)
    {
        RtlSecureZeroMemory(FileName, MAX_PATH * 2);
        delete[] FileName;
        FileName = nullptr;
    }

    RtlSecureZeroMemory(FileRecord, BytesPerFileRecord);
    delete[] FileRecord;
    FileRecord = nullptr;

    return bStatus;
}

_Use_decl_annotations_
wchar_t* 
antiforensics::what()
{
    return e;
}


/// EOF
```

`ANTfs/antiforensics.h`:

```h
#pragma once

#include <Windows.h>
#include <iostream>
#include <sstream>
#include <vector>

#include "typesndefs.h"

class antiforensics
{
private:
	HANDLE hFileHandle = INVALID_HANDLE_VALUE;

	PBOOT_SECTOR BootSector = nullptr;
	PFILE_RECORD MftFileRecord = nullptr;

	UINT32 BytesPerFileRecord = 1024;

	UINT64 MftOffset = 0;

	std::vector<PRUNLIST> MftRunList;

	wchar_t e[MAXERRORLENGTH * sizeof(wchar_t)] = { 0 };

protected:
	/// <summary>
	/// This method is a protected method. NextEntry will calculate 
	/// the offset and return the new address to parse. 
	/// </summary>
	/// <typeparam name="T1"></typeparam>
	/// <typeparam name="T2"></typeparam>
	/// <param name="p"></param>
	/// <param name="Offset"></param>
	/// <returns>Returns the next entry of a datatype.</returns>
	template <typename T1, typename T2>
	T1* 
	NextEntry(
		_In_reads_to_ptr_(Offset) T1* p,
		_In_ T2 Offset
	)
	{
		T1* Entry = reinterpret_cast<T1*>(
			reinterpret_cast<PUINT8>(p) + Offset
			);

		return Entry;
	}

	/// <summary>
	/// This method is a protected method. WriteToFile is a wrapper
	/// to WriteFile. This function will create a file for a deleted 
	/// file's contents to be written to. If there are any duplicates, 
	/// the filename will get renamed with a _2, _3, etc. 
	/// </summary>
	/// <param name="OutputFile"></param>
	/// <param name="lpBuffer"></param>
	/// <param name="dwNumberOfBytesToWrite"></param>
	/// <returns>Returns true if successful.</returns>
	_Success_(return != 0)
	bool 
	WriteToFile(
		_In_ std::wstring OutputFile,
		_In_ PUINT8 lpBuffer,
		_In_ UINT32 dwNumberOfBytesToWrite
	);

	/// <summary>
	/// This method is a protected method. LastError will convert the 
	/// GetLastError into a human-readable format to know exactly
	/// what happened.
	/// </summary>
	/// <returns>Returns a null-terminated error message.</returns>
	_Ret_maybenull_z_
	wchar_t* 
	LastError();

	/// <summary>
	/// This method is a protected method. ParseRunList will process the
	/// data runs of a file record. This will take care of unfragmented, 
	/// fragmented, sparsed, compressed, or any combination.
	/// </summary>
	/// <param name="RunListData"></param>
	/// <param name="TotalClusterSize"></param>
	/// <param name="RelativeOffset"></param>
	void 
	ParseRunList(
		_Outref_result_maybenull_ PUINT8& RunListData,
		_Inout_ PUINT32 TotalClusterSize,
		_Inout_ PUINT32 RelativeOffset
	);

	/// <summary>
	/// This method is a protected method. GetAttributeFor will iterate 
	/// through a given file record for an attribute. If the attribute 
	/// matches, space will be allocated for this attribute and copied. 
	/// This allocation will need to get zeroed and freed after use.
	/// </summary>
	/// <param name="AttributeType"></param>
	/// <param name="FileRecord"></param>
	/// <returns>Returns a PATTRIBUTE structure if successful; otherwise, 
	/// will return nullptr</returns>
	_Ret_maybenull_
	PATTRIBUTE 
	GetAttributeFor(
		_In_ ATTRIBUTE_TYPE AttributeType,
		_In_reads_bytes_(BytesPerFileRecord) PFILE_RECORD FileRecord
	);

	/// <summary>
	/// This method is a protected method. VerifySector will verify the
	/// USN matches at offset 510 and 1,024. If this doesn't match, chances
	/// are the data is corrupted. It will then apply the original bytes
	/// before being overwritten after successful verification.
	/// </summary>
	/// <param name="FileRecord"></param>
	/// <returns>Returns true if successful.</returns>
	_Success_(return != 0)
	bool 
	VerifySector(
		_In_reads_bytes_(BytesPerFileRecord) PFILE_RECORD& FileRecord
	);

	/// <summary>
	/// This method is a protected method. ReadNtfsFrom is a wrapper for
	/// ZwReadFile and is used for reading the MFT.
	/// </summary>
	/// <param name="Offset"></param>
	/// <param name="Length"></param>
	/// <param name="Buffer"></param>
	/// <returns>Returns true if successful.</returns>
	_Success_(return != 0)
	bool 
	ReadNtfsFrom(
		_In_ LONGLONG Offset,
		_In_ ULONG Length,
		_Inout_bytecount_(Length) PVOID Buffer
	);

public:
	antiforensics();
	~antiforensics();

	/// <summary>
	/// This method will intialize all the variables needed to 
	/// parse the MFT. It will calculate the offset to the MFT and 
	/// then use that to locate all of the MFTs, if there are 
	/// multiple. 
	/// </summary>
	/// <param name="DriveName"></param>
	/// <returns>Returns true if successful.</returns>
	_Success_(return != 0)
	bool 
	init(
		_In_ const wchar_t* DriveName
	);

	/// <summary>
	/// This method will iterate through all of the deleted files 
	/// in the MFT. It will locate the contents of the data and then 
	/// output the data into a directory for later analysis.
	/// </summary>
	/// <param name="OutputDirectory"></param>
	/// <param name="NumberOfRecords"></param>
	/// <returns>Returns true if successful.</returns>
	_Success_(return != 0)
	bool 
	RecoverFiles(
		_In_ std::wstring OutputDirectory,
		_Out_ PUINT32 NumberOfRecords
	);

	/// <summary>
	/// This method will iterate through the deleted files in
	/// the MFT looking for a specific file record. If it finds
	/// the file record, it will locate the contents of the data
	/// and sends an IOCTL to the driver to overwrite the record
	/// with zeroes. It will then overwrite the file record, itself.
	/// </summary>
	/// <param name="DriveLetter"></param>
	/// <param name="NameOfFileRecord"></param>
	/// <returns>Returns true if successful.</returns>
	_Success_(return != 0)
	bool 
	WipeRecord(
		_In_ const wchar_t* DriveLetter,
		_In_ const wchar_t* NameOfFileRecord
	);

	/// <summary>
	/// Returns what happened if something goes wrong. 
	/// </summary>
	/// <returns>Returns an error message.</returns>
	_Ret_z_
	wchar_t* 
	what();
};


/// EOF 
```

`ANTfs/privileges.cpp`:

```cpp
#include "privileges.h"

bool privileges::checkAdminPrivileges()
{
	SID_IDENTIFIER_AUTHORITY NtAuthortiy = SECURITY_NT_AUTHORITY;
	PSID AdministratorsGroup = nullptr;

	BOOL bRetVal = AllocateAndInitializeSid(
		&NtAuthortiy,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&AdministratorsGroup
	);
	if (bRetVal)
	{
		if (!CheckTokenMembership(
			NULL, 
			AdministratorsGroup, 
			reinterpret_cast<PBOOL>(&bRetVal)
		))
		{
			bRetVal = false;
		}
		FreeSid(AdministratorsGroup);
		AdministratorsGroup = nullptr;
	}

	return bRetVal;
}


/// EOF
```

`ANTfs/privileges.h`:

```h
#pragma once
#include <Windows.h>

namespace privileges
{
	/// <summary>
	/// Checks to see if the callee is running with 
	/// Administrator privileges. 
	/// </summary>
	/// <returns>Returns true if successful.</returns>
	bool checkAdminPrivileges();
}


/// EOF
```

`ANTfs/typesndefs.h`:

```h
#pragma once
#include <winnt.h>

///---------------------------------------------------------------
/// Macro(s)
///---------------------------------------------------------------
#define ENCODE_IOCTL(DeviceType, Function)( \
	((DeviceType) << 16 |					\
	((FILE_WRITE_DATA) << 14) |				\
	((Function) << 2) |						\
	(METHOD_BUFFERED))						\
)

///---------------------------------------------------------------
/// Definitions
///---------------------------------------------------------------
constexpr auto ANTFS_DRIVER_NAME = L"\\\\.\\ANTfs";
constexpr auto FILE_SIGNATURE = 'ELIF';
constexpr auto NTFS_BOOT_SECTOR_SIGNATURE = 0xaa55;

///---------------------------------------------------------------
/// Enum types
///---------------------------------------------------------------
typedef enum
{
	IoctlOverwrite = ENCODE_IOCTL(FILE_DEVICE_UNKNOWN, 0x900)
} IOCTLS; 

typedef enum
{
	NamespacePosix,
	NamespaceWin32,
	NamespaceDos,
	NamespaceWin32andDos
} FILENAME_NAMESPACE;

typedef enum
{
	AttributeStandardInformation = 0x10,
	AttributeAttributeList = 0x20,
	AttributeFileName = 0x30,
	AttributeObjectId = 0x40,
	AttributeSecurityDescriptor = 0x50,
	AttributeVolumeName = 0x60,
	AttributeVolumeInformation = 0x70,
	AttributeData = 0x80,
	AttributeIndexRoot = 0x90,
	AttributeIndexAllocation = 0xa0,
	AttributeBitmap = 0xb0,
	AttributeReparsePoint = 0xc0,
	AttributeEAInformation = 0xd0,
	AttributeEA = 0xe0,
	AttributePropertySet = 0xf0,
	AttributeLoggedUtilityStream = 0x100,
	AttributeEnd = 0xffffffff
} ATTRIBUTE_TYPE, * PATTRIBUTE_TYPE;

typedef enum
{
	$Mft,
	$MftMirror,
	$LogFile,
	$Volume,
	$AttrDef,
	$RootIndex,
	$Bitmap,
	$Boot,
	$BadClus,
	$Secure,
	$UpCase,
	$Extend
} SPECIAL_FILE_TYPE, * PSPECIAL_FILE_TYPE;

///---------------------------------------------------------------
/// Struct Types
///---------------------------------------------------------------
#include <pshpack1.h>
typedef struct _BOOT_SECTOR
{
	UINT8 JmpToBootCode[3];
	char OemName[8];
	UINT16 BytesPerSector;
	UINT8 SectorsPerCluster;
	UINT16 ReservedSectors;
	UINT8 Unused0[5];
	UINT8 MediaDescriptor;
	UINT16 Unused1;
	UINT16 SectorsPerTrack;
	UINT16 NumberOfHeads;
	UINT32 HiddenSectors;
	UINT32 Unused2;
	UINT32 Unused3;
	UINT64 TotalSectorsInSystem;
	UINT64 StartingClusterOfMft;
	UINT64 StartingClusterOfMftMirror;
	UINT32 ClustersPerFileRecord;
	UINT32 ClustersPerIndexBlock;
	UINT64 VolumeSerialNumber;
	UINT32 Checksum;
	UINT8 BootstrapCode[426];
	UINT16 Signature;
} BOOT_SECTOR, * PBOOT_SECTOR;

///
/// Using nameless structs so disabling the warnings that prevent the driver from 
/// being compiled. 
/// 
#pragma warning(disable : 4201)
typedef struct _FILE_RECORD
{
	UINT32 Signature;						/// The type of NTFS record (FILE, INDX, BAAD, etc.)
	UINT16 UsaOffset;						/// Offset in bytes to the Update Sequence Array
	UINT16 UsaCount;						/// The number of values in the Update Sequence Array
	UINT64 Lsn;								/// $Logfile Sequence Number 

	UINT16 SequenceNumber;					/// Number of times that the MFT entry has been used
	UINT16 LinkCount;						/// The number of hard links to the MFT entry
	UINT16 AttributeOffset;					/// Offset to the first attribute

	union
	{
		struct
		{
			UINT16 NotInUseNotDirectory : 1;/// bit 0
			UINT16 InUseNotDirectory : 1;	/// bit 1
			UINT16 NotInUseIsDirectory : 1; /// bit 2
			UINT16 InUseIsDirectory : 1;	/// bit 3
		};
		UINT16 value;
	} Flags;

	UINT32 BytesInUse;						/// Number of bytes used by the FILE record
	UINT32 BytesAllocated;					/// Number of bytes allocated for the FILE record
	UINT64 BaseFileRecord;					/// Reference to the base FILE record
	UINT32 NextAttributeNumber;				/// Next attribute id
	UINT32 IdOfThisRecord;					/// Id of this record
	UINT16 Usn;								/// Update Sequence Number
	UINT8 UpdateSequenceArray[3];			/// Update Sequence Array is 4 bytes with 2 bytes padding
} FILE_RECORD, * PFILE_RECORD;

typedef struct _ATTRIBUTE
{
	INT32 AttributeType;
	UINT32 Length;					/// Length of the attribute. If this is the last, it will be 0xffffffff
	UINT8 IsNonResident;			/// If true, this is a nonresident entry (deleted)
	UINT8 NameLength;
	UINT16 NameOffset;

	union
	{
		struct
		{
			UINT16 Compressed : 8;	/// bits 0 - 7
			UINT16 Placeholder : 6; /// bits 8 - 13
			UINT16 Encrypted : 1;	/// bit 14
			UINT16 Sparse : 1;		/// bit 15
		};
		UINT16 value;
	} Flags;

	UINT16 AttributeIdentifier;		/// The number that is unique to this MFT entry

	union
	{
		struct
		{
			UINT32 ValueLength;		/// The size, in bytes, of the attribute value
			UINT16 ValueOffset;		/// The offset, in bytes, to the attribute value
			UINT8 IndexedFlag;		/// The attribute properties. 1 if indexed. 
			UINT8 Padding;
		} Resident;

		struct
		{
			UINT64 LowVcn;			/// The lowest valid Virtual Cluster Number
			UINT64 HighVcn;			/// The highest valid Virtual Cluster Number
			UINT16 RunArrayOffset;	/// The offset, in bytes, to the run array that contains mappings between VCNs and LCNs
			UINT16 CompressionUnit; /// The compression unit for this attribute. If this is 0, it is not compressed
			UINT32 Unused;
			UINT64 AllocatedSize;	/// The size, in bytes, of disk space allocated to hold the attribute value
			UINT64 DataSize;		/// The size, in bytes, of the attribute value. This value may be larger than the AllocatedSize if the attribute value is compressed or sparse
			UINT64 InitializedSize; /// The size, in bytes, of the initialized portion of the attribute value
			UINT64 CompressedSize;	/// This will exist if it's compressed
		} NonResident;
	};
} ATTRIBUTE, * PATTRIBUTE;

typedef struct _FILENAME_ATTRIB
{
	union
	{
		struct
		{
			UINT64 FileRecordNumber : 48;
			UINT64 SequenceNumber : 16;
		};
	} ParentDirectory;

	UINT64 FileCreationTime;
	UINT64 FileModifiedTime;
	UINT64 RecordChanged;
	UINT64 LastAccessedTime;
	UINT64 AllocatedSizeOfData;
	UINT64 RealSizeOfData;
	UINT32 FileAttributes;
	UINT32 Reserved;
	UINT8 FilenameLength;
	UINT8 FilenameNamespace;
	WCHAR Filename[ANYSIZE_ARRAY];
} FILENAME_ATTRIB, * PFILENAME_ATTRIB;

typedef struct _STANDARD_INFORMATION_ATTRIB
{
	UINT64 CreationTime;
	UINT64 ChangeTime;
	UINT64 LastWriteTime;
	UINT64 LastAccessTime;

	union
	{
		struct
		{
			UINT32 ReadOnly : 1;		/// bit 1
			UINT32 Hidden : 1;			/// bit 2
			UINT32 System : 1;			/// bit 3
			UINT32 Padding : 2;			/// bits 4 - 5
			UINT32 Archive : 1;			/// bit 6
			UINT32 Device : 1;			/// bit 7
			UINT32 Normal : 1;			/// bit 8
			UINT32 Temporary : 1;		/// bit 9
			UINT32 SparseFile : 1;		/// bit 10
			UINT32 ReparsePoint : 1;	/// bit 11
			UINT32 Compressed : 1;		/// bit 12
			UINT32 Offline : 1;			/// bit 13
			UINT32 IsContentIndexed : 1;/// bit 14
			UINT32 Encrypted : 1;		/// bit 15
		};
		UINT32 value;
	} FileAttributes;

	UINT32 MaxNumOfVersions;
	UINT32 VersionNumber;
	UINT32 ClassId;
	UINT32 OwnerId;
	UINT32 SecurityId;
	UINT32 QuotaCharged;
	UINT64 UpdateSequenceNumber;
} STANDARD_INFORMATION_ATTRIB, * PSTANDARD_INFORMATION_ATTRIB;

typedef union _RUNLIST_HEADER
{
	struct
	{
		UINT8 ByteLength : 4;
		UINT8 ByteOffset : 4;
	};
	UINT8 value;
} RUNLIST_HEADER, * PRUNLIST_HEADER;

typedef struct _RUNLIST
{
	UINT32 ClusterSize;
	UINT32 LcnOffset;
	UINT64 AbsoluteOffset;
} RUNLIST, * PRUNLIST;

typedef struct _WIPE_INPUT_BUFFER
{
	const wchar_t* DriveLetter;
	SIZE_T NameLength;
	const wchar_t* FileName;
	UINT64 FileOffset;
	UINT32 ClusterSize;
} WIPE_INPUT_BUFFER, * PWIPE_INPUT_BUFFER;
#include <poppack.h>


/// EOF
```

`README.md`:

```md
# ANTfs
ANTfs is an antiforensics project that came about after taking a Digital Forensics class this semester. The name stems from anti and NTFS since I am manipulating the filesystem. This project consists of a usermode application that will recover files that have been deleted and outputs them into a directory of your choice for later analysis. The driver is the kernel mode application that takes care of overwriting the file record and file's contents to wipe it into the abyss -- not hide it. 

The use case of this application is when you have shell access on a computer you ~~don't~~ own and you introduce a file to the system and you need to delete it to hide your traces. For science. 

Also, this is just a PoC. A blogpost will follow when finished.

### Requirements:
1. Windows SDK
2. Windows WDK

The SDK and the WDK are needed to be able to compile this on your own if you choose to modify this. This was compiled using Visual Studio 2019. 

### How to use?
![alt text](https://github.com/ch3rn0byl/ANTfs/blob/master/Images/helpmenu.png)

If you are wanting to recover deleted files from the system: 
```
ANTfs.exe --drive c --recover --outfile
```
A timestamped directory will be created in the same directory ANTfs is being run from if no path is given. Add an output path if needed (highly recommended):
```
ANTfs.exe --drive c --recover --outfile Y:\loot
```
If you are wiping a record from the system, the driver needs to be installed:
```
sc create antfs binPath= <path/to/driver>/antfs driver.sys type= kernel
sc start antfs
```
Then on the application:
```
ANTfs.exe --drive c --wipe some_file_name.file_extension
```
Once the file record is found, the usermode application will make a call to the driver and wipe the record from within the kernel.

### How does this work?
#### Usermode Application: ANTfs.exe
ANTfs is the usermode application that will create a handle to C: (or whatever volume you give it), and begin reading from the MFT. ANTfs will iterate through each file record in the MFT(s) and check its allocation bit. If it's unallocated, I process that record. This does not get files that have been thrown into the recycle bin. ANTfs will either recover the data or wipe the data, depending on what you choose. If you want to wipe the record, that is when the driver comes to play.

#### Kernel Driver: ANTfs Driver.sys
ANTfs Driver is the kernel mode application that will bypass direct write blocking by setting the SL_FORCE_OVERWRITE inside the IRP's flags and sending a Write request to the lower driver. 

### TODOs:
1. Look into the structure of RCRD inside $LOGFILE and then go in and delete the name of the file from there. 
2. See if it's possible to write directly to the record through usermode (if possible). This will eliminate the need for the driver.
3. Look into $USNJRNL to see if there are any artifacts.

```