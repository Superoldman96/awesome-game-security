Project Path: arc_gmh5225_EFTLeecher_a4zl_dya

Source Tree:

```txt
arc_gmh5225_EFTLeecher_a4zl_dya
├── DMADevice.cpp
├── DMADevice.h
├── Dialog Callbacks.cpp
├── Dialog Callbacks.h
├── EFT Leecher.aps
├── EFT Leecher.rc
├── EFT Leecher.vcxproj
├── EFT Leecher.vcxproj.filters
├── EFT Leecher.vcxproj.user
├── Entry Point.cpp
├── MainThread.cpp
├── MainThread.h
├── MonoClasses.cpp
├── MonoClasses.h
├── README.md
├── Settings.ini
├── globals.h
├── leechcore.h
├── leechcore.lib
├── resource.h
├── vmm.lib
└── vmmdll.h

```

`DMADevice.cpp`:

```cpp
#include "globals.h"

//we set the variable inside the namespace X to what ever we want so that the compiler CAN set the value before executed
bool DMADevice::bConnected = false;
DWORD DMADevice::dwAttachedProcessId = NULL;
ULONG64 DMADevice::dwUnityPlayerBaseAddress = NULL;


bool DMADevice::Connect(bool bMMapFile, bool bStealth, bool bRemoveOtherDMAConnections)
{
	//check if we already connected to the dma device?
	if (bConnected)
		return true;

	//we declare the return value here so we can return any status we want if something fail's!
	bool bReturnStatus = true;

	//the default argument count is 3 which is ["", "-device", "fpga"]
	unsigned int iArgumentCount = 3;

	//set the arguments!
	LPSTR args[7] = { "", "-device", "fpga", "-max", 0, "-memmap", "mmap.txt" };

	//lets remove ALL other connections first?
	if(bRemoveOtherDMAConnections)
	{
		//check the status and see if we DID close DMA connection's
		if (DisconnectOtherConnections() == false)
		{
			MessageBoxA(0, "Could not close other DMA connection's are you sure there is one open?", 0, 0);

			//now i dont know if we should return false to say NOT to connect because what if they HAVNT got a connection open?
			return false;
		}
	}

	//see if we want to use the map file
	if (bMMapFile)
	{
		//we set to false because we will set to true if ALL checks passed so its much easyer to keep track!
		bReturnStatus = false;

		//create a buffer for the memory size from map
		char szMapMemory[64] = { 0 };

		//CreateFile ether creates a file or opens an existing file that depends on the flags given with dwCreationDisposition
		HANDLE hFile = CreateFileA("mmap.txt", FILE_GENERIC_READ, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		
		//we check if we have a handle for this file
		if (hFile != INVALID_HANDLE_VALUE)
		{
			//we grab the file size
			DWORD dwFileSize = GetFileSize(hFile, NULL);

			//check if the file size is BIGGER then 0
			if (dwFileSize > 0)
			{
				//create a file buffer to store the file into memory so we can read the file or copy the file into the buffer this can be BYTE or char but byte is better because BYTE allows -256 to 256 char only allow 0 to 255
				//we do plus 1 because we want file buffer + a null terminated char (WE DONT NEED IT because we know the file size but meh memory can be a dangerous thing if fucked up!)
				BYTE* lpFileBuffer = new BYTE[dwFileSize + 1];

				//we check if the system has the memory for this file size i mean ALL systems should have atleast 10mb memory but we ALWAYS check when dealing with memory!
				if (lpFileBuffer != NULL)
				{
					//create a variable to store how many bytes / char's we have read from the file
					DWORD dwNumberBytesRead = 0;
					if (ReadFile(hFile, lpFileBuffer, dwFileSize, &dwNumberBytesRead, NULL))
					{
						//strrchr reads the whole buffer AKA file buffer and finds the LAST "needle AKA -" in the file and returns the string + - in the file!
						char *szLastMemoryLine = strrchr((char*)lpFileBuffer, '-');
						if (szLastMemoryLine != NULL)
						{
							//szLastMemoryLine should now contain - "- MEMORY_ADDRESS"

							//so we change the minus and the space to 0 and x so it should now be 0xMEMORY_ADDRESS which we can now use? or should be able to!
							szLastMemoryLine[0] = '0';
							szLastMemoryLine[1] = 'x';

							//now copy the LAST memory map so we can use it
							strcpy_s(szMapMemory, szLastMemoryLine);

							//we set our return status to true because we set the first argument to true meaning we want to use the map file and we can use it because we have everything we need?
							bReturnStatus = true;

							//we now change the argument count because we are using ALOT more!
							iArgumentCount = 7;
						}
					}
					//right ill take a min to explain this part because SOME are ALWAYS confused about delete [] and delete and free
					//delete [] DELETES an ARRAY that was allocated so any memory made with NEW [SIZE] you are ALWAYS required to delete it as an ARRAY!
					//delete DELETES a memory that is created with just NEW you should never delete NEW memory with delete [] because that memory is not an array its just MEMORY pointer
					//so any time you create memory or create memory AKA "new VARIABLE_TYPE[]" you should do "delete []" but if you do "new VARABLE_TYPE" you should just delete
					delete[] lpFileBuffer;
				}
			}

			//we have to close a handle to the file we have opened so the system can take control of it!
			CloseHandle(hFile);
		}
		else
		{
			//we couldnt get a handle to the file so we check if the file is found!
			if (GetLastError() == ERROR_FILE_NOT_FOUND)
			{
				//the file is NOT found!
				MessageBoxA(0, "mmap.txt is not found please make sure mmap.txt is valid and has valid memory map", 0, 0);

				//return false so we DONT connect to the dma device with the wrong arguments and give the wrong idea!
				return false;
			}
		}
		//we now set the argument to the memory map file found?
		args[4] = { szMapMemory };
	}

	//we check if the results are in and they are false because if false then we cant connect because something is wrong?
	if (bReturnStatus == false)
	{
		//i dont know what to say? maybe tell them run as admin make sure the file is valid? idk? LOL!
		MessageBoxA(0, "mmap.txt is not found please make sure mmap.txt is valid and has valid memory map", 0, 0);

		//do i need to explain this?
		return false;
	}

	//now make a connection <3
	if (!VMMDLL_Initialize(iArgumentCount, args))
	{
		//give them a message i mean we have to tell them about the cable length i mean whos stupid to have a cable length of like 4meters?(LOL!)
		MessageBoxA(0, "Failed to connect to the DMA Device make sure your cable is NOT to long and is able to connect to the DMA Device", 0, 0);

		//do i need to explain this?
		return false;
	}

	//do we want to force clear the "master abort flags?" meaning stealth? so there NO CHANCE for the flags to be set?
	if (bStealth)
	{
		//we need variables to save the values
		ULONG64 qwID = 0, qwVersionMajor = 0, qwVersionMinor = 0;

		//we ask nicely for the results of EACH request AKA ID, Major version, Minor version
		if (!VMMDLL_ConfigGet(LC_OPT_FPGA_FPGA_ID, &qwID) ||
			!VMMDLL_ConfigGet(LC_OPT_FPGA_VERSION_MAJOR, &qwVersionMajor) ||
			!VMMDLL_ConfigGet(LC_OPT_FPGA_VERSION_MINOR, &qwVersionMinor))
		{
			//display an error?
			MessageBoxA(0, "Failed to get your FPGA Version are you connected?", 0, 0);

			//because a connection was made we need to now close it :(
			VMMDLL_Close();

			//do i need to explain this?
			return false;
		}
		if (!((qwVersionMajor >= 4) && ((qwVersionMajor >= 5) || (qwVersionMinor >= 7))))
		{
			//display an error?
			MessageBoxA(0, "Your version of the FPGA can not use the stealth function please disable or update your FPGA board to the lastest version", 0, 0);

			//because a connection was made we need to now close it :(
			VMMDLL_Close();

			//do i need to explain this?
			return false;
		}
		//create a variable to store data
		LC_CONFIG LcConfig = {};

		//set our leech core config version
		LcConfig.dwVersion = LC_CONFIG_VERSION;

		//and the device name the device name is existing because we have already set up a connection but if you want to be anal just use FPGA or there device
		strcpy_s(LcConfig.szDevice, "existing");

		//now create a standalone version of leech core ourself
		HANDLE hLeechCore = LcCreate(&LcConfig);

		//check the return value LcCreate will return NULL if failed to "create" and a handle or "memory" to the created leech core
		if (hLeechCore == NULL)
		{
			//display an error?
			MessageBoxA(0, "Could not create or open an existing device to leech core please retry if this problem keeps happening disable stealth option", 0, 0);

			//because a connection was made we need to now close it :(
			VMMDLL_Close();

			//do i need to explain this?
			return false;
		}
		//please dont ask me why or what this shit is because its what ufrisk wants you to send to the config to reset the "pci config space flags"
		BYTE bBytes[4] = { 0x10, 0x00, 0x10, 0x00 };

		//now we send a command to the device to tell it todo a command which is cleaning the PCI config space flags remember i dont know how all this shit works all i know is this works and he shown it in his code want more info on how this works ask ufrisk lol
		//https://github.com/ufrisk/MemProcFS/blob/master/vmm_example/vmmdll_example.c#L184 link to how he is doing it!
		LcCommand(hLeechCore, LC_CMD_FPGA_CFGREGPCIE_MARKWR | 0x002, 4, bBytes, NULL, NULL);

		//close the handle to the leech core we have opened this will NOT close the connection as they have a counter on how many times a connection has been made so we have made 2 but only closing 1? so meaning they will keep it open for us!
		LcClose(hLeechCore);
	}

	//copy the return status to tell us if connection was complete!
	bConnected = bReturnStatus;

	//everything is complete we have a connection and we have set up everything we need :)
	return bReturnStatus;
}
bool DMADevice::AttachToProcessId(LPSTR szProcessName)
{
	//wait we trying to look for a process without a connection this is not a good thing this is bad! but shouldnt ever happen but always good to check?
	if (bConnected == false)
		return false;

	//we grab a process id from the name some games use 2 process id's or processes like pubg it runs 2 of the same exe names so you have to filter them
	if (VMMDLL_PidGetFromName(szProcessName, &dwAttachedProcessId) == FALSE)
		return false;

	//grab unityplayer.dll it should ALWAYS be found if the process is unity player game!
	dwUnityPlayerBaseAddress = VMMDLL_ProcessGetModuleBase(dwAttachedProcessId, L"UnityPlayer.dll");

	//check if found!
	if (dwUnityPlayerBaseAddress == 0)
	{
		//set it to null because we no longer want to be attached lol!
		dwAttachedProcessId = NULL;
		return false;
	}
	//we return true if dwAttachedProcessId is ANYTHING but NULL and false if its NULL same with unityplayer.dll address
	return (dwAttachedProcessId != NULL && dwUnityPlayerBaseAddress != NULL);
}
void DMADevice::Disconnect()
{
	//we have no connection!
	bConnected = false;

	//reset the attached process id
	dwAttachedProcessId = NULL;

	//tell the DMA to close the device
	VMMDLL_Close();
}
bool DMADevice::CheckForModuleInsideProcessId(DWORD dwProcessId, LPCWSTR wszModuleName)
{
	//create a snapshot list of the modules inside the process from process id
	HANDLE hProcessList = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId);

	//we couldnt get the list?
	if (hProcessList == INVALID_HANDLE_VALUE)
		return false;

	//make a variable for storing the results
	MODULEENTRY32 me32 = {};

	//tell windows the size
	me32.dwSize = sizeof(MODULEENTRY32);

	//grab the first module inside the list!
	if (!Module32First(hProcessList, &me32))
	{
		//ALWAYS clean up system handles
		CloseHandle(hProcessList);
		return false;
	}


	do{
		//compare the module name to the module we want
		if (_wcsicmp(me32.szModule, wszModuleName) == 0)
		{
			//ALWAYS clean up system handles
			CloseHandle(hProcessList);

			//success!
			return true;
		}

		//grab the next module in the list! if there is one!
	} while (Module32Next(hProcessList, &me32));

	//ALWAYS clean up system handles
	CloseHandle(hProcessList);
	return false;
}
using fnFreeCall = DWORD_PTR(__fastcall*)(...);
template<typename ...Params>NTSTATUS NtRoutine(const char* szName, Params &&... params)
{
	HMODULE hNtDll = GetModuleHandleA("ntdll.dll");
	if (hNtDll == 0)
		return STATUS_NOT_FOUND;

	auto fn = (fnFreeCall)GetProcAddress(hNtDll, szName);
	if (fn == 0)
		return STATUS_NOT_FOUND;

	return (NTSTATUS)fn(std::forward<Params>(params) ...);
}
//simple API calls to ntdll for some reason ntdll is different on MOST version of windows so we use a simple API to just grab the "function" and forward the arguments to it really simple nothing much to explain
#define NtQuerySystemInformation(...) NtRoutine("NtQuerySystemInformation", __VA_ARGS__)
#define NtDuplicateObject(...) NtRoutine("NtDuplicateObject", __VA_ARGS__)
#define NtQueryObject(...) NtRoutine("NtQueryObject", __VA_ARGS__)

bool DMADevice::CloseHandleInProcess(DWORD dwProcessId, HANDLE hHandle)
{
	//we open the process that we require access to we want all access creating threads,memory read/write query process etc etc
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);

	//for some reason we couldnt open this process? is it system did they run as admin? wtf going on?
	if (hProcess == NULL)
		return false;

	//now grab the close handle address thanks to windows for the shared address space of system modules we dont need to worry about this being wrong when found locally(this process)
	LPTHREAD_START_ROUTINE Address_CloseHandle = (LPTHREAD_START_ROUTINE)GetProcAddress(LoadLibrary(L"Kernel32.dll"), "CloseHandle");

	//WAIT A SEC? closehandle is not found WTF we running on shitty mac?
	if (Address_CloseHandle == NULL)
	{
		//ALWAYS clean up system handles
		CloseHandle(hProcess);
		return false;
	}

	//we create a remote thread on the process when executing code you are ALWAYS required to have it in a thread ether main thread or a newly created thread but since they dont have anticheat protection we just use normal create thread <3
	HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, Address_CloseHandle, hHandle, 0, 0);

	//ermm? couldnt create a thread on there process? wtf?
	if (hRemoteThread == NULL)
	{
		//ALWAYS clean up system handles
		CloseHandle(hProcess);
		return false;
	}
	//WAIT for the thread to finish executing or running and we wait for infinite you can wait for X ammount of time but its best to wait for it to finish fully before we give the status!
	WaitForSingleObject(hRemoteThread, INFINITE);

	//ALWAYS clean up system handles
	CloseHandle(hRemoteThread);
	CloseHandle(hProcess);

	//success!
	return true;
}
bool DMADevice::CloseDMAConnections(DWORD dwProcessId)
{
	//use 2mb for default size we can use more if required!
	DWORD dwSize = 0x2000;

	//variable for the size if we need more! (everyone always need's more!)
	DWORD dwRequired = 0;

	//make some memory because we cant use a variable well we can but it could be like 50mb in size which would then require the exe to be 50mb lol but make memory its simple easy and quick!
	SYSTEM_HANDLE_INFORMATION2* lpSysHandleInformation = (SYSTEM_HANDLE_INFORMATION2*)malloc(dwSize);

	//wait we cant get enough memory? FML fail then?
	if (lpSysHandleInformation == NULL)
		return false;

	//grab all handle objects on the system
	NTSTATUS ntStatus = NtQuerySystemInformation(16/*SystemHandleInformation*/, lpSysHandleInformation, dwSize, &dwRequired);

	//we failed? todo this?
	if (!NT_SUCCESS(ntStatus))
	{
		//oh we dont have enough buffer size thats not an issue lets make more room! we also check to make sure the API returned the required size
		if (ntStatus != STATUS_INFO_LENGTH_MISMATCH || !dwRequired)
		{
			//ALWAYS clean up memory!
			free(lpSysHandleInformation);
			return false;
		}
		// The size was not enough so clean up the old stuff!
		free(lpSysHandleInformation);

		//lets change the size now much bigger plus added room!
		dwSize = dwRequired + 1024;

		//make more memory more room!
		lpSysHandleInformation = (SYSTEM_HANDLE_INFORMATION2*)malloc(dwSize);

		//always check to make sure they have made the memory before accessing it :)
		if (lpSysHandleInformation == 0)
		{
			return false;
		}

		//now lets call it again with a bigger size! this should not fail anymore!
		ntStatus = NtQuerySystemInformation(16/*SystemHandleInformation*/, lpSysHandleInformation, dwSize, &dwRequired);

		//am i seeing bullshit again?! just fail this time!
		if (!NT_SUCCESS(ntStatus))
		{
			//ALWAYS clean up memory!
			free(lpSysHandleInformation);

			return false;
		}
	}

	//we memory enough to get the type info so make it here so we dont have to keep making it per object and we can just reuse the buffer
	POBJECT_TYPE_INFORMATION lpObjectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x5000);
	if (lpObjectTypeInfo == 0)
	{
		//ALWAYS clean up memory!
		free(lpSysHandleInformation);

		//we dont have enough memory? so tell them its not working :(
		return false;
	}

	//now create a loop for all the system handles and do some checks!
	for (int i = 0; i < lpSysHandleInformation->HandleCount; i++)
	{
		//get the handle from the index i
		SYSTEM_HANDLE handle = lpSysHandleInformation->Handles[i];

		//check the object type the process id and the process id!
		if (handle.ObjectTypeNumber != 10 && handle.ProcessId > 4 && handle.ProcessId == dwProcessId)
		{
			//we open the process that has the handle so we can duplate it
			HANDLE hProcessHandle = OpenProcess(PROCESS_DUP_HANDLE, FALSE, handle.ProcessId);

			//we could not do this SHIT then continue and hope that we find what we look for!
			if (hProcessHandle == 0)
				continue;

			//make a variable to hold the handle data
			HANDLE hDupHandle = INVALID_HANDLE_VALUE;

			//duplicate the object aka copy the handle, handles are process based so you CANT use another processes handles UNLESS you ask for it and duplicate it!
			if (!NT_SUCCESS(NtDuplicateObject(hProcessHandle, handle.Handle, GetCurrentProcess(), &hDupHandle, 0, 0, DUPLICATE_SAME_ACCESS)))
			{
				//always close and clean up handles!
				CloseHandle(hProcessHandle);
				continue;
			}

			//clear the buffer we reuse so it has nothing from the old!
			ZeroMemory(lpObjectTypeInfo, 0x5000);

			//just set this to null we dont need it or want to use it but some arguments are required!
			dwRequired = 0;

			//now query the handle object
			if (!NT_SUCCESS(NtQueryObject(hDupHandle, ObjectTypeInformation, lpObjectTypeInfo, 0x5000, &dwRequired)))
			{
				//always close and clean up handles!
				CloseHandle(hProcessHandle);
				CloseHandle(hDupHandle);
				continue;
			}

			//we check to see if this object type is a FILE because when opening a device or a folder or anything todo with file system its ALWAYS a file type!
			if (wcscmp(lpObjectTypeInfo->TypeName.Buffer, L"File") != 0)
			{
				//always close and clean up handles!
				CloseHandle(hProcessHandle);
				CloseHandle(hDupHandle);
				continue;
			}

			//clear the buffer we reuse so it has nothing from the old!
			ZeroMemory(lpObjectTypeInfo, 0x5000);

			//convert the object type info to name information
			POBJECT_NAME_INFORMATION lpObjectNameInfo = (POBJECT_NAME_INFORMATION)lpObjectTypeInfo;

			//again query the object info but this time we are after the NAME now the type name
			if (!NT_SUCCESS(NtQueryObject(hDupHandle, ObjectNameInformation, lpObjectTypeInfo, 0x5000, &dwRequired)))
			{
				//always close and clean up handles!
				CloseHandle(hProcessHandle);
				CloseHandle(hDupHandle);
				continue;
			}

			//now we compare the object name info to device DMA device connects with Device\\000X X = an id of the device and sometimes WDeviceW000 as well no idea why but windows converts \\ to W? confused maybe api bug?
			if (wcsncmp(lpObjectNameInfo->Name.Buffer, L"\\Device\\000", wcslen(L"\\Device\\000")) == 0 || 
				wcsncmp(lpObjectNameInfo->Name.Buffer, L"WDeviceW000", wcslen(L"WDeviceW000")) == 0)
			{
				//keep a backup of what we found
				DWORD dwDMAProcessId = (DWORD)handle.ProcessId;
				HANDLE hDeviceHandle = (HANDLE)handle.Handle;

				//clean up everything because surely they should not be any other connections but one.....?

				//ALWAYS clean up memory!
				free(lpSysHandleInformation);
				free(lpObjectTypeInfo);

				//always close and clean up handles!
				CloseHandle(hProcessHandle);
				CloseHandle(hDupHandle);

				//now process the "disconnection request or force disconnection"
				return CloseHandleInProcess(dwDMAProcessId, hDeviceHandle);
			}

			//always close and clean up handles!
			CloseHandle(hProcessHandle);
			CloseHandle(hDupHandle);
		}
	}
	//ALWAYS clean up memory!
	free(lpObjectTypeInfo);
	free(lpSysHandleInformation);
	return false;
}
bool DMADevice::DisconnectOtherConnections()
{
	//we create a list handle to grab ALL current processes on the current system
	HANDLE hProcessList = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hProcessList == INVALID_HANDLE_VALUE)
		return false;

	//we have a variable to hold the current "process"
	PROCESSENTRY32 pe32 = {};

	//we set the size
	pe32.dwSize = sizeof(PROCESSENTRY32);

	//we grab the FIRST process in the list!
	if (!Process32First(hProcessList, &pe32))
	{
		CloseHandle(hProcessList);
		return false;
	}

	//save our current process id
	DWORD dwCurrentProcessId = GetCurrentProcessId();

	do {
		//we first check to make sure the process id is bigger then 5 any process lower then 5 is a system process and we shouldnt mess with system processes!
		//then we compare to make sure the process is NOT ours!
		//then we check for the required module inside the process which is vmm.dll
		if (pe32.th32ProcessID > 5 && pe32.th32ProcessID != dwCurrentProcessId && CheckForModuleInsideProcessId(pe32.th32ProcessID))
		{
			//always close handles when done with it allows the system to be clean!
			CloseHandle(hProcessList);

			//close the dma connection and return the status
			return CloseDMAConnections(pe32.th32ProcessID);
		}
		//grab the next process in the list
	} while (Process32Next(hProcessList, &pe32));

	//always close handles when done with it allows the system to be clean!
	CloseHandle(hProcessList);

	//no process found with a DMA connection (well one we can find) so lets just say we closed them DMA will fail to connect if there is one open!
	return true;
}

bool DMADevice::MemReadUnityString(CUnityString *lpStringPtr, CUnityString* us)
{
	if (!dwAttachedProcessId || !bConnected || !lpStringPtr)
		return false;

	//because unity strings can be REALLY long or REALLY short we use mem read scatter ufrisk says its faster?
	DWORD dwNumPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES((QWORD)lpStringPtr, sizeof(CUnityString));

	//get the page address PAGE ADDRESS is inline with 0x1000 normally all systems are set like this but some change it which they shouldnt
	QWORD qwPageAddress = PAGE_ALIGN((QWORD)lpStringPtr);

	//now get the offset, the offset is the last 3 char numbers hex on the address so 0x1337 offset will be 0x0337
	DWORD dwPageOffset = PAGE_OFFSET((QWORD)lpStringPtr);

	//make 3 scatter memory requests
	PPMEM_SCATTER ppMEMs;

	//create memory and init the scatters
	if (!LcAllocScatter1(3, &ppMEMs))
		return false;

	//EACH scatter address needs to be inline with 0x1000 + (i * 0x1000)
	for (int i = 0; i < dwNumPages; i++)
		ppMEMs[i]->qwA = (qwPageAddress + (i << PAGE_SHIFT));

	//send the request to the device
	DWORD dwProcessedCount = VMMDLL_MemReadScatter(dwAttachedProcessId, ppMEMs, dwNumPages, VMMDLL_FLAG_NOCACHE | VMMDLL_FLAG_NOPAGING | VMMDLL_FLAG_NOCACHEPUT | VMMDLL_FLAG_ZEROPAD_ON_FAIL);

	//check how many pages we have processed
	if (dwProcessedCount > 0)
	{
		//get the current buffer size
		DWORD cb = min(sizeof(CUnityString), PAGE_SIZE - dwPageOffset);

		//convert the buffer to BYTES because bytes is 1 and pointer is 8
		LPBYTE lpBuffer = (LPBYTE)us;

		//loop the processed requests the pages we have got
		for (int i = 0; i < dwProcessedCount; i++)
		{
			//is this request finished or valid?
			if (!ppMEMs[i]->f)
				continue;

			//copy the buffer to our output buffer
			memcpy(lpBuffer, (ppMEMs[i]->pb + dwPageOffset), cb);

			//move the buffer up!
			lpBuffer += cb;

			//change the current buffer size to PAGE SIZE
			cb = PAGE_SIZE;

			//check IF we are below PAGE SIZE
			if (((dwPageOffset + sizeof(CUnityString)) & 0xfff))
			{
				//set the current buffer size to the len size left
				cb = ((dwPageOffset + sizeof(CUnityString)) & 0xfff);
			}
			//reset the page offset because we reading now from the start of a page..
			dwPageOffset = 0;
		}
		//clean up the memory and scatter required
		LcMemFree(ppMEMs);

		//set to null we dont need to but lets!
		ppMEMs = 0;

		//check the buffer for validation so the string size should be extactly the same as whats in the buffer no more no less!
		return (wcslen(us->szString) == us->dwStringSize);
	}
	//clean up the memory and scatter required
	LcMemFree(ppMEMs);

	//set to null we dont need to but lets!
	ppMEMs = 0;

	//didnt do as what we needed?
	return false;
}
```

`DMADevice.h`:

```h
#pragma once


#define PAGE_SIZE 0x1000
#define BELOW_PAGE_SIZE (PAGE_SIZE - 1)
#define PAGE_ADDRESS(x) (x & 0xfffffffffffff000)
#define PAGE_OFFSET(x) (x & BELOW_PAGE_SIZE)

#define PAGE_SHIFT 12
#define PAGE_ALIGN(Va) ((QWORD)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))
#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))

typedef struct _SYSTEM_HANDLE
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION2
{
	ULONG HandleCount;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION2, *PSYSTEM_HANDLE_INFORMATION2;


//name spaces are like a container so its like saying ANYTHING inside a namespace belongs to the name X
//so to use anything in the namespace you just use the namespace name and then the variable or function!
namespace DMADevice
{
	//extern is just declaring that we have a variable by this name but its else where!
	//when declaring extern MAKE sure you declare it else where
	extern bool bConnected;
	extern DWORD dwAttachedProcessId;
	extern ULONG64 dwUnityPlayerBaseAddress;

	//declare the functions so we can use it all over!
	//i have added arguments so i dont need to worry about reading the status of the "check boxes" inside the function
	//and the equals just means this is the default value IF you dont use the arguments! so if you call Connect(); the 2 arguements will just be Connect(false,false);
	extern bool Connect(bool bMMapFile = false, bool bStealth = false, bool bRemoveOtherDMAConnections = false);

	extern void Disconnect();

	//make a function to just attach to a process so we can return an error if the process is not found or if you want to change process for another project? idk? dont need this but meh!
	extern bool AttachToProcessId(LPSTR szProcessName = REMOTE_PROCESS);

	extern bool CheckForModuleInsideProcessId(DWORD dwProcessId, LPCWSTR wszModuleName = L"vmm.dll");
	extern bool CloseHandleInProcess(DWORD dwProcessId, HANDLE hHandle);
	extern bool CloseDMAConnections(DWORD dwProcessId);
	extern bool DisconnectOtherConnections();

	template<typename U, typename P>DWORD MemRead(U lpAddress, P lpOutput, size_t uiSize, bool bFullReadRequired = true)
	{
		if (!dwAttachedProcessId || !bConnected || !lpAddress)
			return 0;

		DWORD dwBytesRead = 0;
		BOOL bRetn = (VMMDLL_MemReadEx(dwAttachedProcessId, (ULONG64)lpAddress, (PBYTE)lpOutput, uiSize, &dwBytesRead, VMMDLL_FLAG_NOCACHE | VMMDLL_FLAG_NOPAGING | VMMDLL_FLAG_NOCACHEPUT | VMMDLL_FLAG_ZEROPAD_ON_FAIL | VMMDLL_FLAG_NOPAGING_IO) && dwBytesRead != 0);
		if (!bRetn || (bFullReadRequired && dwBytesRead != uiSize))
			return dwBytesRead;

		return dwBytesRead;
	}
	template<typename Var, typename U>Var MemReadPtr(U lpAddress)
	{
		Var lpPtr = 0;
		if (MemRead(lpAddress, &lpPtr, sizeof(Var)))
			return lpPtr;
		return 0;
	}
	template<typename U, typename P>BOOL MemWrite(U lpAddress, P lpInput, size_t uiSize)
	{
		if (!dwAttachedProcessId || !bConnected || !lpAddress)
			return FALSE;

		return VMMDLL_MemWrite(dwAttachedProcessId, (ULONG64)lpAddress, (PBYTE)lpInput, uiSize);
	}
	template<typename U, typename P>BOOL MemWritePtr(U lpAddress, P lpInput)
	{
		if (!dwAttachedProcessId || !bConnected || !lpAddress)
			return FALSE;

		return VMMDLL_MemWrite(dwAttachedProcessId, (ULONG64)lpAddress, (PBYTE)&lpInput, sizeof(P));
	}

	bool MemReadUnityString(CUnityString *lpStringPtr, CUnityString* us);
}
```

`Dialog Callbacks.cpp`:

```cpp
#include "globals.h"
#include <Wininet.h>
#include <time.h>
#pragma comment(lib, "Crypt32.lib")
#pragma comment(lib, "wininet.lib")

//this is a dialog call back what a callback is, is a function that gets called when and if something happens in the dialog
//the iMsg argument allows you to filter which one you want to ACT on or what todo when something happens


//keep a record of skill setting's we dont need to keep reading and writing memory from EFT it takes LONGER!
DWORD iLastPressed = 0;
CSkillData sSkillData[Skills_Max] = {};

//i made a function just so its quicker and easy then defining loads of thingss inside the switch cases below!
VOID SetDialogItemsStatus(HWND hDlg, bool bDisabled)
{
	//we dont want to disable the connect button if we are enabled the others we want to do the opposite so we use ! which is the opposite of true!
	EnableWindow(GetDlgItem(hDlg, ID_BTN_DMA_CONNECT), !bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_AUTO_DISCONNECT), !bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_USE_MMAP_FILE), !bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_USE_STEALTH_CONNECTION), !bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_REMOVE_CONNECTIONS), !bDisabled);	

	//now do normal shit? enable if we want to or disable!
	EnableWindow(GetDlgItem(hDlg, ID_BTN_DMA_SHUTDOWN), bDisabled);
	//EnableWindow(GetDlgItem(hDlg, IDC_NOWEIGHT), bDisabled);
	//EnableWindow(GetDlgItem(hDlg, IDC_DOORS), bDisabled);
	//EnableWindow(GetDlgItem(hDlg, IDC_DOORS_KEYCARD), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_NORECOIL), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_ENDURANCE), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_SKILLS_MAX), bDisabled);
	EnableWindow(GetDlgItem(hDlg, ID_BTN_VISOR_EFFECT), bDisabled);
	EnableWindow(GetDlgItem(hDlg, ID_BTN_NIGHTVISION), bDisabled);
	EnableWindow(GetDlgItem(hDlg, ID_BTN_THERMAL), bDisabled);
#ifdef ENABLE_AIMBOT
	EnableWindow(GetDlgItem(hDlg, IDC_AIMBOT_ENABLE), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_AIMBOT_HEAD), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_AIMBOT_CHEST), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_AIMBOT_PELVIS), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_AIMBOT_LFOOT), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_AIMBOT_RFOOT), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_AIMBOT_RANDOM), bDisabled);
	EnableWindow(GetDlgItem(hDlg, IDC_AIMBOT_HOTKEY), bDisabled);
#endif
}

//from https://docs.microsoft.com/en-us/windows/win32/controls/create-a-tooltip-for-a-control

// Description:
//   Creates a tooltip for an item in a dialog box. 

// Parameters:
//   idTool - identifier of an dialog box item.
//   nDlg - window handle of the dialog box.
//   pszText - string to use as the tooltip text.

// Returns:
//   The handle to the tooltip.
//
HWND CreateToolTip(int toolID, HWND hDlg, PTSTR pszText)
{
	if (!toolID || !hDlg || !pszText)
		return NULL;

	// Get the window of the tool.
	HWND hwndTool = GetDlgItem(hDlg, toolID);

	// Create the tooltip. g_hInst is the global instance handle.
	HWND hwndTip = CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_ALWAYSTIP | TTS_BALLOON, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hDlg, NULL, GetModuleHandle(0), NULL);
	if (!hwndTool || !hwndTip)
		return NULL;

	// Associate the tooltip with the tool.
	TOOLINFO toolInfo = { 0 };
	toolInfo.cbSize = sizeof(toolInfo);
	toolInfo.hwnd = hDlg;
	toolInfo.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
	toolInfo.uId = (UINT_PTR)hwndTool;
	toolInfo.lpszText = pszText;
	SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&toolInfo);
	return hwndTip;
}
//write our own version i mean microsoft thanks so much!
BOOL WINAPI WritePrivateProfileIntA(LPCSTR szKey, int iValue)
{
	char szValue[64] = {};
	sprintf_s(szValue, "%d", iValue);
	return WritePrivateProfileStringA("ToolBox", szKey, szValue, szSettingsFile);
}

//this is for the serial dialog box
INT_PTR CALLBACK Serial_Dialog_Callback(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	//switch is just a simple load of if's statment's
	switch (iMsg)
	{
		//init dialog is the first thing that is called put your start up code here
		case WM_INITDIALOG:
		{


			//declare a buffer for the HWID
			char szHWID[512] = { 0 };
			//the ifdef will check ALL included header files for the #define X and if #define X is found the compiler will auto add the code

			strcpy_s(szHWID, "DEV_HWID");

			//SetWindowText just does what it says on the tin lol it sets text inside a dialog item
			//GetDlgItem is a simple function it grabs ANY dialog item within or declared on or in a dialog
			SetWindowTextA(GetDlgItem(hWnd, IDC_HWID), szHWID);

			//the ifdef will check ALL included header files for the #define X and if #define X is found the compiler will auto add the code


			//to save the user time we call a simple windows api called postmessage which basically is saying SEND this message to the dialog telling them we have clicked OK
			PostMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDOK, NULL), NULL);

			//the ifdef will check ALL included header files for the #define X and if #define X is found the compiler will auto add the code

			
		}break;

		//command is passed when you click or you do a command
		case WM_COMMAND:
		{
			//grab which dialog item passed the command AKA button's etc
			switch (LOWORD(wParam))
			{
				//IDOK is a normal OK dialog button (just to explain i renamed the OK button to verity)
				case IDOK:
				{
//the ifdef will check ALL included header files for the #define X and if #define X is found the compiler will auto add the code


					//keep a buffer for the serial
					char szSerial[512] = { 0 };
//read above about this.....^^

					


			
					//grab the dialog entered text or text that we have set
					UINT iLen = GetDlgItemTextA(hWnd, IDC_SERIAL, szSerial, 512);

					strcpy_s(szSerial, "DEV_HWID");
	

					//WritePrivateProfileStringA writes a string to a file with the key given!
					//we write it here because the HWID has been checked and has passed so CAN write and it will be valid next time!
					for (int s = 0; s < iLen; s++)
					{
						if (szSerial[s] == '\r' && szSerial[s + 1] == '\n')
						{
							memmove(&szSerial[s], &szSerial[s + 2], iLen - s);
						}
					}

					WritePrivateProfileStringA("ToolBox", "HWID", szSerial, szSettingsFile);

					//we can pass ANYTHING to quit message so we can check if its valid!
					PostQuitMessage(1337);
					
				
					return S_OK;
				
				}break;

				//IDCANCEL is a normal Cancel dialog button
				case IDCANCEL:
				{
					//post quit message forces the WM_QUIT message which in the main app loop you should be looking for then to break and after that message is processed the app will then fetch the destory etc message's
					PostQuitMessage(0);
				}break;
			}

		}break;

		//destroy is called when the dialog is DESTORYED put your clean up code here
		case WM_DESTROY:
		{
			
		}break;
	}
	return S_OK;
}

//this is for the main dialog box
INT_PTR CALLBACK Main_Dialog_Callback(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	//switch is just a simple load of if's statment's
	switch (iMsg)
	{
		//init dialog is the first thing that is called put your start up code here
		case WM_INITDIALOG:
		{
			//load setting's here
			if(GetPrivateProfileIntA("ToolBox", "UseMapFile", 0, szSettingsFile))
				CheckDlgButton(hWnd, IDC_USE_MMAP_FILE, BST_CHECKED);

			if (GetPrivateProfileIntA("ToolBox", "StealthInjection", 0, szSettingsFile))
				CheckDlgButton(hWnd, IDC_USE_STEALTH_CONNECTION, BST_CHECKED);

			if (GetPrivateProfileIntA("ToolBox", "RemoveConnections", 0, szSettingsFile))
				CheckDlgButton(hWnd, IDC_REMOVE_CONNECTIONS, BST_CHECKED);

			if (GetPrivateProfileIntA("ToolBox", "AutoDisconnect", 0, szSettingsFile))
			{
				bAutoDisconnectAfterRaidEnds = true;
				CheckDlgButton(hWnd, IDC_AUTO_DISCONNECT, BST_CHECKED);
			}
			else
			{
				bAutoDisconnectAfterRaidEnds = false;
			}

			if (GetPrivateProfileIntA("ToolBox", "RemoveVisorEffects", 0, szSettingsFile))
			{
				SendMessageA(hWnd, WM_COMMAND, MAKEWPARAM(ID_BTN_VISOR_EFFECT, 0), 0);
			}

			if (GetPrivateProfileIntA("ToolBox", "NightVisionEffect", 0, szSettingsFile))
			{
				SendMessageA(hWnd, WM_COMMAND, MAKEWPARAM(ID_BTN_NIGHTVISION, 0), 0);
			}

			if (GetPrivateProfileIntA("ToolBox", "ThermalVisionEffect", 0, szSettingsFile))
			{
				SendMessageA(hWnd, WM_COMMAND, MAKEWPARAM(ID_BTN_THERMAL, 0), 0);
			}
			bNoWeight = (GetPrivateProfileIntA("ToolBox", "NoWeight", 0, szSettingsFile));
			bUnlockEverything = (GetPrivateProfileIntA("ToolBox", "UnlockEverything", 0, szSettingsFile));
			bNoStamina = (GetPrivateProfileIntA("ToolBox", "NoStamina", 0, szSettingsFile));
			bNoRecoil = (GetPrivateProfileIntA("ToolBox", "NoRecoil", 0, szSettingsFile));
			bRemoveVisorEffects = (GetPrivateProfileIntA("ToolBox", "RemoveVisorEffects", 0, szSettingsFile));
			bNightVisionEffect = (GetPrivateProfileIntA("ToolBox", "NightVisionEffect", 0, szSettingsFile));
			bThermalVisionEffect = (GetPrivateProfileIntA("ToolBox", "ThermalVisionEffect", 0, szSettingsFile));
			CheckDlgButton(hWnd, IDC_NORECOIL, bNoRecoil ? BST_CHECKED : BST_UNCHECKED);
			CheckDlgButton(hWnd, IDC_ENDURANCE, bNoStamina ? BST_CHECKED : BST_UNCHECKED);


			SetDlgItemTextA(hWnd, ID_BTN_VISOR_EFFECT, !bRemoveVisorEffects ? "Enable Visor Effects" : "Remove Visor Effects");
			SetDlgItemTextA(hWnd, ID_BTN_THERMAL, (!bThermalVisionEffect) ? "Enable Thermal Vision" : "Disable Thermal Vision");
			SetDlgItemTextA(hWnd, ID_BTN_NIGHTVISION, !bNightVisionEffect ? "Enable Night Vision" : "Disable Night Vision");

			iJumpMultiplier = (GetPrivateProfileIntA("ToolBox", "JumpMultiplier", 1, szSettingsFile));
			iThrowMultiplier = (GetPrivateProfileIntA("ToolBox", "ThrowMultiplier", 1, szSettingsFile));
			iHearingMultiplier = (GetPrivateProfileIntA("ToolBox", "HearingMultiplier", 1, szSettingsFile));

			SendDlgItemMessageW(hWnd, IDC_JUMP_SLIDER, TBM_SETRANGE, TRUE, MAKELPARAM(1, 6));
			SendDlgItemMessageW(hWnd, IDC_THROW_SLIDER, TBM_SETRANGE, TRUE, MAKELPARAM(1, 6));
			SendDlgItemMessageW(hWnd, IDC_HEARING_SLIDER, TBM_SETRANGE, TRUE, MAKELPARAM(1, 10));

			SendDlgItemMessageW(hWnd, IDC_JUMP_SLIDER, TBM_SETPOS, TRUE, iJumpMultiplier);
			SendDlgItemMessageW(hWnd, IDC_THROW_SLIDER, TBM_SETPOS, TRUE, iThrowMultiplier);
			SendDlgItemMessageW(hWnd, IDC_HEARING_SLIDER, TBM_SETPOS, TRUE, iHearingMultiplier);

			wchar_t szTextBuffer[32] = {};
			swprintf_s(szTextBuffer, L"%dx", iJumpMultiplier);
			SetWindowTextW(GetDlgItem(hWnd, IDC_JUMP_TEXT), szTextBuffer);
			swprintf_s(szTextBuffer, L"%dx", iThrowMultiplier);
			SetWindowTextW(GetDlgItem(hWnd, IDC_THROW_TEXT), szTextBuffer);
			swprintf_s(szTextBuffer, L"%dx", iHearingMultiplier);
			SetWindowTextW(GetDlgItem(hWnd, IDC_HEARING_TEXT), szTextBuffer);

#ifdef ENABLE_AIMBOT
		
			iAimbotBone = GetPrivateProfileIntA("ToolBox", "Aimbot_Bone", EHumanBones::HumanHead, szSettingsFile);
			if (iAimbotBone == EHumanBones::HumanHead)
				CheckDlgButton(hWnd, IDC_AIMBOT_HEAD, BST_CHECKED);
			if (iAimbotBone == EHumanBones::HumanSpine1)
				CheckDlgButton(hWnd, IDC_AIMBOT_CHEST, BST_CHECKED);
			if (iAimbotBone == EHumanBones::HumanPelvis)
				CheckDlgButton(hWnd, IDC_AIMBOT_PELVIS, BST_CHECKED);
			if (iAimbotBone == EHumanBones::HumanLFoot)
				CheckDlgButton(hWnd, IDC_AIMBOT_LFOOT, BST_CHECKED);
			if (iAimbotBone == EHumanBones::HumanRFoot)
				CheckDlgButton(hWnd, IDC_AIMBOT_RFOOT, BST_CHECKED);
			if (iAimbotBone == EHumanBones::BONE_MAX)
				CheckDlgButton(hWnd, IDC_AIMBOT_RANDOM, BST_CHECKED);

			bAimbotEnabled = (GetPrivateProfileIntA("ToolBox", "Aimbot_Enable", 0, szSettingsFile) == 1);
			CheckDlgButton(hWnd, IDC_AIMBOT_ENABLE, bAimbotEnabled);

			iAimbotHotkey = (GetPrivateProfileIntA("ToolBox", "Aimbot_Hotkey", KC_Mouse0, szSettingsFile));
			for (int i = 1; i < 0xA6; i++)
			{
				if (iAimbotHotkey == unityKC[i].kc && unityKC[i].kc != KC_None)
					SetDlgItemTextW(hWnd, IDC_AIMBOT_HOTKEY, unityKC[i].KeyName);
			}
#endif
		}break;

		//command is passed when you click or you do a command
		case WM_COMMAND:
		{
			//grab which dialog item passed the command AKA button's etc
			switch (LOWORD(wParam))
			{
				//lets check which button we have clicked or dialog item we have clicked
				case ID_BTN_DMA_CONNECT:
				{
					//now lets call the function to see if we can connect

					//we dont have to use variables BUT easyer for you to understand
					bool bUseMapFile = (IsDlgButtonChecked(hWnd, IDC_USE_MMAP_FILE) == BST_CHECKED);
					bool bUseStealth = (IsDlgButtonChecked(hWnd, IDC_USE_STEALTH_CONNECTION) == BST_CHECKED);
					bool bRemoveDMA = (IsDlgButtonChecked(hWnd, IDC_REMOVE_CONNECTIONS) == BST_CHECKED);

					//call our function to connect to the dma device!
					if (DMADevice::Connect(bUseMapFile, bUseStealth, bRemoveDMA) == false)
					{
						//DO NOT continue! return so the code dont continue!
						return S_OK;
					}

					//we want a new color so lets make it green? i like green its nice!
					dwConnectionStatusColor = RGB(0, 255, 0);

					//change the connection status to connected aka green(lime)!
					SetDlgItemTextA(hWnd, IDC_CONNECTION_STATUS, "Connected!");

					//now we attach to the process id we want
					if (DMADevice::AttachToProcessId() == false)
					{
						//display an error
						MessageBoxA(0, "Remote process " REMOTE_PROCESS " was not found please make sure the process is running! and click connect again.", 0, 0);
						
						//we dont disconnect there no point? its just easier to find the process again
						return S_OK;
					}
					//create a buffer to store the results of sprintf
					char szProcessIdBufferText[32] = { 0 };

					//sprintf converts a format to string
					sprintf_s(szProcessIdBufferText, "%d[0x%X]", DMADevice::dwAttachedProcessId, DMADevice::dwAttachedProcessId);

					//set the dlgitem text
					SetDlgItemTextA(hWnd, IDC_PROCESS_ID, szProcessIdBufferText);

					//set all the dlgitems to enabled
					SetDialogItemsStatus(hWnd, true);
				}break;

				case ID_BTN_DMA_SHUTDOWN:
				{
					//disconnect the device
					DMADevice::Disconnect();

					//change the connection status to disconnected AKA red!
					dwConnectionStatusColor = RGB(255, 0, 0);

					//set the connection status text to disconnected
					SetDlgItemTextA(hWnd, IDC_CONNECTION_STATUS, "Disconnected!");

					//set the dlgitem text
					SetDlgItemTextA(hWnd, IDC_PROCESS_ID, "N/A");
					
					//set all the dlgitems to disabled
					SetDialogItemsStatus(hWnd, false);
				}break;

				case IDC_AUTO_DISCONNECT:
				{
					//set the global variable to what ever the user has set it to
					bAutoDisconnectAfterRaidEnds = (IsDlgButtonChecked(hWnd, IDC_AUTO_DISCONNECT) == BST_CHECKED);
				}break;


				case ID_BTN_VISOR_EFFECT:
				{
					//let me explain this this is just making the variable equal the opposite of the current value so its as simple as writing this!
					//if(bRemoveVisorEffects) bRemoveVisorEffects = false;
					//if(!bRemoveVisorEffects) bRemoveVisorEffects = true;
					bRemoveVisorEffects = !bRemoveVisorEffects;

					//right let me explain the ? : the ? means if that value is TRUE so bRemoveVisorEffects == true the FIRST or after the ? will be the value or text and : will be the opposite of what value!
					SetDlgItemTextA(hWnd, ID_BTN_VISOR_EFFECT, !bRemoveVisorEffects ? "Enable Visor Effects" : "Remove Visor Effects");
				}break;

				case ID_BTN_NIGHTVISION:
				{
					//read above for information about this!
					bNightVisionEffect = !bNightVisionEffect;

					//set some lovly text(read above for this information)
					SetDlgItemTextA(hWnd, ID_BTN_NIGHTVISION, !bNightVisionEffect ? "Enable Night Vision" : "Disable Night Vision");
				}break;

				case ID_BTN_THERMAL:
				{
					//read above for information about this!
					bThermalVisionEffect = !bThermalVisionEffect;

					//set some lovly text(read above for this information)
					SetDlgItemTextA(hWnd, ID_BTN_THERMAL, !bThermalVisionEffect ? "Enable Thermal Vision" : "Disable Thermal Vision");
				}break;

				case IDC_NORECOIL:
				{
					//just check the status of the checkbox and set a "global variable" of the status
					bNoRecoil = (IsDlgButtonChecked(hWnd, IDC_NORECOIL) == BST_CHECKED);
				}break;

				case IDC_ENDURANCE:
				{
					//just check the status of the checkbox and set a "global variable" of the status
					bNoStamina = (IsDlgButtonChecked(hWnd, IDC_ENDURANCE) == BST_CHECKED);
				}break;

				case IDC_DOORS:
				{
					//just check the status of the checkbox and set a "global variable" of the status
					bUnlockEverything = (IsDlgButtonChecked(hWnd, IDC_DOORS) == BST_CHECKED);
				}break;

				//case IDC_SKILLSMAX:
				//{
				//	//create a new dialog box for the skills
				//	bSkillsUpdate = (IsDlgButtonChecked(hWnd, IDC_SKILLSMAX) == BST_CHECKED);;

				case IDC_BTN_SKILLS:
				{
					//create a new dialog box for the skills
					DialogBoxW(GetModuleHandle(0), MAKEINTRESOURCE(IDD_SKILL_BUF_DIALOG), NULL, Skills_Dialog_Callback);
				}break;

#ifdef ENABLE_AIMBOT
				case IDC_AIMBOT_ENABLE:
				{
					bAimbotEnabled = (IsDlgButtonChecked(hWnd, IDC_AIMBOT_ENABLE) == BST_CHECKED);
				}break;

				case IDC_AIMBOT_HEAD:
				case IDC_AIMBOT_CHEST:
				case IDC_AIMBOT_PELVIS:
				case IDC_AIMBOT_LFOOT:
				case IDC_AIMBOT_RFOOT:
				case IDC_AIMBOT_RANDOM:
				{
					if (IsDlgButtonChecked(hWnd, IDC_AIMBOT_HEAD))
						iAimbotBone = EHumanBones::HumanHead;
					if (IsDlgButtonChecked(hWnd, IDC_AIMBOT_PELVIS))
						iAimbotBone = EHumanBones::HumanPelvis;
					if (IsDlgButtonChecked(hWnd, IDC_AIMBOT_CHEST))
						iAimbotBone = EHumanBones::HumanSpine1;//no idea if this is correct but try different values
					if (IsDlgButtonChecked(hWnd, IDC_AIMBOT_LFOOT))
						iAimbotBone = EHumanBones::HumanLFoot;
					if (IsDlgButtonChecked(hWnd, IDC_AIMBOT_RFOOT))
						iAimbotBone = EHumanBones::HumanRFoot;
					if (IsDlgButtonChecked(hWnd, IDC_AIMBOT_RANDOM))
						iAimbotBone = EHumanBones::BONE_MAX;

				}break;

				//shit part :@
				case IDC_AIMBOT_HOTKEY:
				{
					//need this because when you click on the button and try set LButton the dlg wants to past the button press AGAIN! so you in an endless loop!
					if (iLastPressed > 0)
					{
						int dwTmp = (int)(iLastPressed - GetTickCount());
						if (dwTmp > 0 && !(dwTmp < 0))
							return 0;
					}

					SetFocus(NULL);

					int iKey = -1;
					SetDlgItemTextW(hWnd, IDC_AIMBOT_HOTKEY, L"Press Any Key");
					while (iKey == -1)
					{
						for (int i = 0; i < 0xE0; i++)
						{
							if (GetAsyncKeyState(i) < 0 && unityKC[i].kc != KC_None)
							{
								iKey = i;
								break;
							}
						}
					}
					iAimbotHotkey = unityKC[iKey].kc;
					SetDlgItemTextW(hWnd, IDC_AIMBOT_HOTKEY, unityKC[iKey].KeyName);
					if(iKey == VK_LBUTTON)
						iLastPressed = (GetTickCount() + 200);

				}break;
#endif
			
				
				case ID_EXIT:
				{
					//save settings why not?
					WritePrivateProfileIntA("RemoveVisorEffects", bRemoveVisorEffects);
					WritePrivateProfileIntA("NightVisionEffect", bNightVisionEffect);
					WritePrivateProfileIntA("ThermalVisionEffect", bThermalVisionEffect);
					WritePrivateProfileIntA("NoRecoil", bNoRecoil);
					WritePrivateProfileIntA("NoStamina", bNoStamina);
					WritePrivateProfileIntA("UnlockEverything", bUnlockEverything);
					WritePrivateProfileIntA("NoWeight", bNoWeight);
					WritePrivateProfileIntA("UseMapFile", (IsDlgButtonChecked(hWnd, IDC_USE_MMAP_FILE) == BST_CHECKED));
					WritePrivateProfileIntA("StealthInjection", (IsDlgButtonChecked(hWnd, IDC_USE_STEALTH_CONNECTION) == BST_CHECKED));
					WritePrivateProfileIntA("RemoveConnections", (IsDlgButtonChecked(hWnd, IDC_REMOVE_CONNECTIONS) == BST_CHECKED));
					WritePrivateProfileIntA("AutoDisconnect", (IsDlgButtonChecked(hWnd, IDC_AUTO_DISCONNECT) == BST_CHECKED));
					WritePrivateProfileIntA("JumpMultiplier", iJumpMultiplier);
					WritePrivateProfileIntA("ThrowMultiplier", iThrowMultiplier);
					WritePrivateProfileIntA("HearingMultiplier", iHearingMultiplier);
#ifdef ENABLE_AIMBOT
					WritePrivateProfileIntA("Aimbot_Bone", iAimbotBone);
					WritePrivateProfileIntA("Aimbot_Hotkey", iAimbotHotkey);
					WritePrivateProfileIntA("Aimbot_Enable", bAimbotEnabled);
#endif
					PostQuitMessage(0);
				}break;
			}
		}break;

		//this is sent as a message WHEN you move the slider etc
		case WM_HSCROLL:
		{
			if ((HWND)lParam == GetDlgItem(hWnd, IDC_JUMP_SLIDER))
			{
				//grab the slider value
				int iPos = SendDlgItemMessageW(hWnd, IDC_JUMP_SLIDER, TBM_GETPOS, 0, 0);

				//set the "text" for the value of the level
				wchar_t szTextBuffer[32] = {};
				swprintf_s(szTextBuffer, L"%dx", iPos);
				SetWindowTextW(GetDlgItem(hWnd, IDC_JUMP_TEXT), szTextBuffer);

				//set the data
				iJumpMultiplier = iPos;
			}
			if ((HWND)lParam == GetDlgItem(hWnd, IDC_THROW_SLIDER))
			{
				//grab the slider value
				int iPos = SendDlgItemMessageW(hWnd, IDC_THROW_SLIDER, TBM_GETPOS, 0, 0);

				//set the "text" for the value of the level
				wchar_t szTextBuffer[32] = {};
				swprintf_s(szTextBuffer, L"%dx", iPos);
				SetWindowTextW(GetDlgItem(hWnd, IDC_THROW_TEXT), szTextBuffer);

				//set the data
				iThrowMultiplier = iPos;
			}
			if ((HWND)lParam == GetDlgItem(hWnd, IDC_HEARING_SLIDER))
			{
				//grab the slider value
				int iPos = SendDlgItemMessageW(hWnd, IDC_HEARING_SLIDER, TBM_GETPOS, 0, 0);

				//set the "text" for the value of the level
				wchar_t szTextBuffer[32] = {};
				swprintf_s(szTextBuffer, L"%dx", iPos);
				SetWindowTextW(GetDlgItem(hWnd, IDC_HEARING_TEXT), szTextBuffer);

				//set the data
				iHearingMultiplier = iPos;
			}

		}break;

		//this is sent or called BEFORE the static text is drawn so we can make it really fancy if we want only did this so it can show you you can do many things!
		case WM_CTLCOLORSTATIC:
		{
			if (((HWND)lParam) == GetDlgItem(hWnd, IDC_CONNECTION_STATUS))
			{
				//set the background mode so we want it transparent
				SetBkMode((HDC)wParam, TRANSPARENT);

				//set the text color
				SetTextColor((HDC)wParam, dwConnectionStatusColor);

				//WM_CTLCOLORSTATIC REQUIRES YOU TO RETURN A SYSCOLORBRUSH!!!
				//Return value
				//If an application processes this message, the return value is a handle to a brush that the system uses to paint the background of the static control.
				//so we return the color menu which is default menu color of any dialog
				return (BOOL)GetSysColorBrush(COLOR_MENU);
			}
			if (((HWND)lParam) == GetDlgItem(hWnd, IDC_PLAYER_STATUS))
			{
				//set the background mode so we want it transparent
				SetBkMode((HDC)wParam, TRANSPARENT);

				//set the text color
				SetTextColor((HDC)wParam, bLocalPlayerFound ? RGB(0,255,0) : RGB(255,0,0));

				//WM_CTLCOLORSTATIC REQUIRES YOU TO RETURN A SYSCOLORBRUSH!!!
				//Return value
				//If an application processes this message, the return value is a handle to a brush that the system uses to paint the background of the static control.
				//so we return the color menu which is default menu color of any dialog
				return (BOOL)GetSysColorBrush(COLOR_MENU);
			}
			if (((HWND)lParam) == GetDlgItem(hWnd, IDC_WORLD_STATUS))
			{
				//set the background mode so we want it transparent
				SetBkMode((HDC)wParam, TRANSPARENT);

				//set the text color
				SetTextColor((HDC)wParam, bWorldPointerFound ? RGB(0, 255, 0) : RGB(255, 0, 0));

				//WM_CTLCOLORSTATIC REQUIRES YOU TO RETURN A SYSCOLORBRUSH!!!
				//Return value
				//If an application processes this message, the return value is a handle to a brush that the system uses to paint the background of the static control.
				//so we return the color menu which is default menu color of any dialog
				return (BOOL)GetSysColorBrush(COLOR_MENU);
			}

			
		}break;

		//did we click the nice BIG recross at the top right? then process it?
		case WM_CLOSE:
		{
			//save settings why not?
			WritePrivateProfileIntA("RemoveVisorEffects", bRemoveVisorEffects);
			WritePrivateProfileIntA("NightVisionEffect", bNightVisionEffect);
			WritePrivateProfileIntA("ThermalVisionEffect", bThermalVisionEffect);
			WritePrivateProfileIntA("NoRecoil", bNoRecoil);
			WritePrivateProfileIntA("NoStamina", bNoStamina);
			WritePrivateProfileIntA("UnlockEverything", bUnlockEverything);
			WritePrivateProfileIntA("NoWeight", bNoWeight);
			WritePrivateProfileIntA("UseMapFile", (IsDlgButtonChecked(hWnd, IDC_USE_MMAP_FILE) == BST_CHECKED));
			WritePrivateProfileIntA("StealthInjection", (IsDlgButtonChecked(hWnd, IDC_USE_STEALTH_CONNECTION) == BST_CHECKED));
			WritePrivateProfileIntA("RemoveConnections", (IsDlgButtonChecked(hWnd, IDC_REMOVE_CONNECTIONS) == BST_CHECKED));
			WritePrivateProfileIntA("AutoDisconnect", (IsDlgButtonChecked(hWnd, IDC_AUTO_DISCONNECT) == BST_CHECKED));
			WritePrivateProfileIntA("JumpMultiplier", iJumpMultiplier);
			WritePrivateProfileIntA("ThrowMultiplier", iThrowMultiplier);
			WritePrivateProfileIntA("HearingMultiplier", iHearingMultiplier);
#ifdef ENABLE_AIMBOT
			WritePrivateProfileIntA("Aimbot_Bone", iAimbotBone);
			WritePrivateProfileIntA("Aimbot_Hotkey", iAimbotHotkey);
			WritePrivateProfileIntA("Aimbot_Enable", bAimbotEnabled);
#endif
			//disconnect the device
			DMADevice::Disconnect();

			//lets just quit!
			PostQuitMessage(0);
		}break;

		//destroy is called when the dialog is DESTORYED put your clean up code here
		case WM_DESTROY:
		{
			//disconnect the device
			DMADevice::Disconnect();

			//save settings why not?
			WritePrivateProfileIntA("RemoveVisorEffects", bRemoveVisorEffects);
			WritePrivateProfileIntA("NightVisionEffect", bNightVisionEffect);
			WritePrivateProfileIntA("ThermalVisionEffect", bThermalVisionEffect);
			WritePrivateProfileIntA("NoRecoil", bNoRecoil);
			WritePrivateProfileIntA("NoStamina", bNoStamina);
			WritePrivateProfileIntA("UnlockEverything", bUnlockEverything);
			WritePrivateProfileIntA("NoWeight", bNoWeight);
			WritePrivateProfileIntA("UseMapFile", (IsDlgButtonChecked(hWnd, IDC_USE_MMAP_FILE) == BST_CHECKED));
			WritePrivateProfileIntA("StealthInjection", (IsDlgButtonChecked(hWnd, IDC_USE_STEALTH_CONNECTION) == BST_CHECKED));
			WritePrivateProfileIntA("RemoveConnections", (IsDlgButtonChecked(hWnd, IDC_REMOVE_CONNECTIONS) == BST_CHECKED));
			WritePrivateProfileIntA("AutoDisconnect", (IsDlgButtonChecked(hWnd, IDC_AUTO_DISCONNECT) == BST_CHECKED));
			WritePrivateProfileIntA("JumpMultiplier", iJumpMultiplier);
			WritePrivateProfileIntA("ThrowMultiplier", iThrowMultiplier);
			WritePrivateProfileIntA("HearingMultiplier", iHearingMultiplier);
			#ifdef ENABLE_AIMBOT
			WritePrivateProfileIntA("Aimbot_Bone", iAimbotBone);
			WritePrivateProfileIntA("Aimbot_Hotkey", iAimbotHotkey);
			WritePrivateProfileIntA("Aimbot_Enable", bAimbotEnabled);
			#endif

		}break;
	}
	return S_OK;
}

//this is for the skills dialog box
INT_PTR CALLBACK Skills_Dialog_Callback(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	//switch is just a simple load of if's statment's
	switch (iMsg)
	{
		//init dialog is the first thing that is called put your start up code here
		case WM_INITDIALOG:
		{
			//load setting's here
			for (int i = 0; i < Skills_Max; i++)
			{
				//add the skill name to the list
				SendDlgItemMessageW(hWnd, IDC_SKILLS_LIST, LB_ADDSTRING, NULL, (LPARAM)szSkillNames[i]);

				//declare a buffer for the key
				char szKey[64] = {};

				//now make a string with the buffer and add a unique key
				sprintf_s(szKey, "Level_Enabled_%d", i);

				//set the data from the settings file
				sSkillData[i].m_bLvlEnabled = GetPrivateProfileIntA("ToolBox", szKey, 0, szSettingsFile);

				//clear the buffer for new data
				ZeroMemory(szKey, 64);

				//now make a string with the buffer and add a unique key
				sprintf_s(szKey, "Level_%d", i);

				//set the data from the settings file
				sSkillData[i].m_iLevel = GetPrivateProfileIntA("ToolBox", szKey, 0, szSettingsFile);
			}

			//set the values for the slider min and max!
			SendDlgItemMessageW(hWnd, IDC_LEVEL_SLIDER, TBM_SETRANGE, TRUE, MAKELPARAM(0, 51));
		}break;

		//this is sent as a message WHEN you move the slider etc
		case WM_HSCROLL:
		{
			if ((HWND)lParam == GetDlgItem(hWnd, IDC_LEVEL_SLIDER))
			{
				//we have changed selection so lets grab the new selected one!
				INT iSelected = SendDlgItemMessageA(hWnd, IDC_SKILLS_LIST, LB_GETCURSEL, NULL, NULL);

				//check if we have selected something make sure we are not going over board!
				if (iSelected == LB_ERR || iSelected >= Skills_Max)
					return S_OK;

				//grab the slider value
				int iPos = SendDlgItemMessageW(hWnd, IDC_LEVEL_SLIDER, TBM_GETPOS, 0, 0);

				//set the "text" for the value of the level
				wchar_t szTextBuffer[32] = {};
				swprintf_s(szTextBuffer, L"%d", iPos);

				//after 50 its MAX level!
				if (iPos > 50)
					wcscpy(szTextBuffer, L"MAX");

				//set the dlg item text
				SetWindowTextW(GetDlgItem(hWnd, IDC_LEVEL_TEXT), szTextBuffer);

				//set the data
				sSkillData[iSelected].m_iLevel = iPos;
			}
		}break;

		//command is passed when you click or you do a command
		case WM_COMMAND:
		{
			//grab which dialog item passed the command AKA button's etc
			switch (LOWORD(wParam))
			{
				//did we click enable?
				case IDC_ENABLE_LEVEL:
				{
					//we have changed selection so lets grab the new selected one!
					INT iSelected = SendDlgItemMessageA(hWnd, IDC_SKILLS_LIST, LB_GETCURSEL, NULL, NULL);

					//check if we have selected something make sure we are not going over board!
					if (iSelected == LB_ERR || iSelected >= Skills_Max)
						return S_OK;

					//save the results
					sSkillData[iSelected].m_bLvlEnabled = IsDlgButtonChecked(hWnd, IDC_ENABLE_LEVEL);

					//enable or disbale the skill slider
					EnableWindow(GetDlgItem(hWnd, IDC_LEVEL_SLIDER), sSkillData[iSelected].m_bLvlEnabled); 
					EnableWindow(GetDlgItem(hWnd, IDC_LEVEL_TEXT), sSkillData[iSelected].m_bLvlEnabled);
				}break;

				////did we click enable?
				//case IDC_SKILL_BUFFER:
				//{
				//	//we have changed selection so lets grab the new selected one!
				//	INT iSelected = SendDlgItemMessageA(hWnd, IDC_SKILLS_LIST, LB_GETCURSEL, NULL, NULL);

				//	//check if we have selected something make sure we are not going over board!
				//	if (iSelected == LB_ERR || iSelected >= Skills_Max)
				//		return S_OK;

				//	//save the results
				//	sSkillData[iSelected].m_bBuffsEnabled = IsDlgButtonChecked(hWnd, IDC_ENABLE_LEVEL);

				//	//we tell the main thread we have updated skills
				//	bSkillsUpdate = true;
				//}break;


				//check if its a list we have clicked!
				case IDC_SKILLS_LIST:
				{
					//check why we clicked or what we have done?
					if (HIWORD(wParam) == LBN_SELCHANGE)
					{
						//we have changed selection so lets grab the new selected one!
						INT iSelected = SendDlgItemMessageA(hWnd, IDC_SKILLS_LIST, LB_GETCURSEL, NULL, NULL);
						
						//check if we have selected something make sure we are not going over board!
						if (iSelected == LB_ERR || iSelected >= Skills_Max)
							return S_OK;

						//grab the selected from the array we dont require it as a pointer (pointer allows changes done to it but keep it as an array so we can READ only)
						CSkillData lpSkillData = sSkillData[iSelected];

						//check the dlg button on the status of the saved results
						CheckDlgButton(hWnd, IDC_ENABLE_LEVEL, lpSkillData.m_bLvlEnabled ? BST_CHECKED : BST_UNCHECKED);

						//enable the window IF skill check box is enabled or disable if not ticked etc
						EnableWindow(GetDlgItem(hWnd, IDC_LEVEL_SLIDER), lpSkillData.m_bLvlEnabled);
						EnableWindow(GetDlgItem(hWnd, IDC_LEVEL_TEXT), lpSkillData.m_bLvlEnabled);

						//set the dlg item text 
						wchar_t szTextBuffer[64] = {};
						swprintf_s(szTextBuffer, L"%d", lpSkillData.m_iLevel);

						//after 50 its MAX level!
						if (lpSkillData.m_iLevel > 50)
							wcscpy(szTextBuffer, L"MAX");
						SetDlgItemTextW(hWnd, IDC_LEVEL_TEXT, szTextBuffer);

						//set the track bar / slider position
						SendDlgItemMessageW(hWnd, IDC_LEVEL_SLIDER, TBM_SETPOS, TRUE, lpSkillData.m_iLevel);
						////check the dlg button on the status of the saved results
						//CheckDlgButton(hWnd, IDC_SKILL_BUFFER, lpSkillData.m_bBuffsEnabled);
					}
				}break;
			}
		}
		break;
		
		//destroy is called when the dialog is DESTORYED put your clean up code here
		case WM_DESTROY:
		{
			//save setting's here
			for (int i = 0; i < Skills_Max; i++)
			{
				//declare a buffer for the key
				char szKey[64] = {};

				//now make a string with the buffer and add a unique key
				sprintf_s(szKey, "Level_Enabled_%d", i);

				//write the data from the global array
				WritePrivateProfileIntA(szKey, sSkillData[i].m_bLvlEnabled);

				//clear the buffer for new data
				ZeroMemory(szKey, 64);

				//now make a string with the buffer and add a unique key
				sprintf_s(szKey, "Level_%d", i);
				
				//write the data from the global array
				WritePrivateProfileIntA(szKey, sSkillData[i].m_iLevel);
			}
		}break;

		case WM_CLOSE:
		{
			EndDialog(hWnd, 0);
		}break;
	}
	return S_OK;
}
```

`Dialog Callbacks.h`:

```h
#pragma once

//a struct data of what we want to save!
struct CSkillData
{
	bool m_bLvlEnabled;
	int m_iLevel;
};

extern CSkillData sSkillData[];

extern wchar_t* GetConfigSettingsFile();

//we use a header file to tell C++ that we have declared function callbacks in a CPP file but you cant include a CPP file without errors
extern INT_PTR CALLBACK Serial_Dialog_Callback(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR CALLBACK Main_Dialog_Callback(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR CALLBACK Skills_Dialog_Callback(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
```

`EFT Leecher.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_NEUTRAL
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_MAIN_DIALOG DIALOGEX 0, 0, 172, 555
STYLE DS_SETFONT | DS_SETFOREGROUND | DS_3DLOOK | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_STATICEDGE
CAPTION "da tool box"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "Disconnect DMA",ID_BTN_DMA_SHUTDOWN,84,96,66,14,WS_DISABLED
    PUSHBUTTON      "Exit",ID_EXIT,7,529,155,14
    DEFPUSHBUTTON   "Connect DMA",ID_BTN_DMA_CONNECT,18,96,60,14
    DEFPUSHBUTTON   "Remove Visor Effect",ID_BTN_VISOR_EFFECT,12,315,150,14,WS_DISABLED
    DEFPUSHBUTTON   "Enable Night Vision",ID_BTN_NIGHTVISION,12,347,150,14,WS_DISABLED
    DEFPUSHBUTTON   "Enable Thermal Vision",ID_BTN_THERMAL,12,331,150,14,WS_DISABLED
    CONTROL         "No Recoil && No Sway",IDC_NORECOIL,"Button",BS_AUTOCHECKBOX | WS_DISABLED | WS_TABSTOP,27,289,138,10
    CONTROL         "Unlimited Endurance / Stamina",IDC_ENDURANCE,"Button",BS_AUTOCHECKBOX | WS_DISABLED | WS_TABSTOP,27,300,138,10
    CONTROL         "Close All Other DMA Connections",IDC_REMOVE_CONNECTIONS,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,27,150,138,10
    GROUPBOX        "DMA Connection",IDC_STATIC,6,84,162,84
    CONTROL         "Use MMap.txt",IDC_USE_MMAP_FILE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,27,126,138,10
    CONTROL         "Stealth Connection (FW 4.7+ req)",IDC_USE_STEALTH_CONNECTION,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,27,138,138,10
    LTEXT           "Connection Status:",IDC_STATIC,18,18,62,8
    LTEXT           "Disconnected!",IDC_CONNECTION_STATUS,93,18,72,8
    GROUPBOX        "Hack Functions",IDC_STATIC,6,276,162,93
    LTEXT           "Remote Process Id:",IDC_STATIC,18,30,64,8
    LTEXT           "N/A",IDC_PROCESS_ID,93,30,72,8
    CONTROL         "Auto Disconnect After Raid End's",IDC_AUTO_DISCONNECT,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,27,114,138,10
    GROUPBOX        "Skills",IDC_STATIC,6,174,162,96
    PUSHBUTTON      "Set Skills Level",IDC_BTN_SKILLS,12,246,150,18,NOT WS_VISIBLE | WS_DISABLED
    LTEXT           "Local Player:",IDC_STATIC,18,66,60,8
    LTEXT           "Dead / Not Found",IDC_PLAYER_STATUS,93,66,72,8
    GROUPBOX        "Status",IDC_STATIC,6,6,162,75
    LTEXT           "World:",IDC_STATIC,18,42,60,8
    LTEXT           "Not Found",IDC_WORLD_STATUS,93,42,72,8
    LTEXT           "Location:",IDC_STATIC,18,54,60,8
    LTEXT           "Not In A Location",IDC_STATUS_LOCATION,93,54,72,8
    GROUPBOX        "Buffs",IDC_STATIC,12,186,150,54
    CONTROL         "",IDC_JUMP_SLIDER,"msctls_trackbar32",TBS_BOTH | TBS_NOTICKS | WS_TABSTOP,18,210,42,12
    CONTROL         "",IDC_THROW_SLIDER,"msctls_trackbar32",TBS_BOTH | TBS_NOTICKS | WS_TABSTOP,66,210,42,12
    CONTROL         "",IDC_HEARING_SLIDER,"msctls_trackbar32",TBS_BOTH | TBS_NOTICKS | WS_TABSTOP,123,210,42,12
    CTEXT           "Jump",IDC_STATIC,18,198,42,8
    CTEXT           "Throw",IDC_STATIC,66,198,42,8
    CTEXT           "Hearing",IDC_STATIC,123,198,42,8
    CTEXT           "1x",IDC_JUMP_TEXT,18,222,42,8
    CTEXT           "1x",IDC_THROW_TEXT,66,222,42,8
    CTEXT           "1x",IDC_HEARING_TEXT,123,222,42,8
    GROUPBOX        "Aimbot",IDC_STATIC,6,370,156,117
    CONTROL         "Enable",IDC_AIMBOT_ENABLE,"Button",BS_AUTOCHECKBOX | WS_DISABLED | WS_TABSTOP,18,383,36,10
    GROUPBOX        "Single Bones",IDC_STATIC,21,396,144,87
    PUSHBUTTON      "L Button",IDC_AIMBOT_HOTKEY,13,502,144,18,WS_DISABLED
    CTEXT           "Hotkey",IDC_STATIC,13,492,144,8
    CONTROL         "Foot Left",IDC_AIMBOT_LFOOT,"Button",BS_AUTORADIOBUTTON | WS_DISABLED,18,449,45,10
    CONTROL         "Foot Right",IDC_AIMBOT_RFOOT,"Button",BS_AUTORADIOBUTTON | WS_DISABLED,18,462,49,10
    CONTROL         "Randomize Bones",IDC_AIMBOT_RANDOM,"Button",BS_AUTORADIOBUTTON | BS_LEFTTEXT | WS_DISABLED,82,382,72,10
    CONTROL         "Head",IDC_AIMBOT_HEAD,"Button",BS_AUTORADIOBUTTON | WS_DISABLED,18,411,33,10
    CONTROL         "Chest",IDC_AIMBOT_CHEST,"Button",BS_AUTORADIOBUTTON | WS_DISABLED,18,424,35,10
    CONTROL         "Hip",IDC_AIMBOT_PELVIS,"Button",BS_AUTORADIOBUTTON | WS_DISABLED,18,436,26,10
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_MAIN_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 165
        TOPMARGIN, 7
        BOTTOMMARGIN, 547
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_MAIN_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

#endif    // English resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// German (Germany) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // German (Germany) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United Kingdom) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENG)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_UK
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_SERIAL_DIALOG DIALOGEX 0, 0, 309, 128
STYLE DS_SETFONT | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "Verify",IDOK,12,108,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,246,108,50,14
    EDITTEXT        IDC_HWID,12,18,282,14,ES_AUTOHSCROLL | ES_READONLY
    GROUPBOX        "HWID",IDC_STATIC,6,6,294,30
    CTEXT           "Serial/HWID is invalid!",IDC_STATUS_TEXT,66,108,174,8,NOT WS_VISIBLE
    EDITTEXT        IDC_SERIAL,12,54,282,43,ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL
    GROUPBOX        "Serial",IDC_STATIC,6,42,294,60
END

IDD_SKILL_BUF_DIALOG DIALOGEX 0, 0, 303, 170
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Skill Buff's"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    LISTBOX         IDC_SKILLS_LIST,12,18,138,138,LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP
    GROUPBOX        "Skill(s) List",IDC_STATIC,6,6,150,156
    GROUPBOX        "Skill Data",IDC_STATIC,162,6,132,156
    CONTROL         "",IDC_LEVEL_SLIDER,"msctls_trackbar32",TBS_BOTH | TBS_NOTICKS | WS_DISABLED | WS_TABSTOP,174,42,114,12
    RTEXT           "0",IDC_LEVEL_TEXT,234,54,48,8,WS_DISABLED
    GROUPBOX        "Level",IDC_STATIC,168,18,120,54
    CONTROL         "Enable",IDC_ENABLE_LEVEL,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,180,30,102,10
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_SERIAL_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 302
        TOPMARGIN, 7
        BOTTOMMARGIN, 121
    END

    IDD_SKILL_BUF_DIALOG, DIALOG
    BEGIN
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_SERIAL_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_SKILL_BUF_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

#endif    // English (United Kingdom) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`EFT Leecher.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1df3e898-0740-475e-adee-856f6f1fd93c}</ProjectGuid>
    <RootNamespace>EFTLeecher</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;C:\pcileechsource;C:\Program Files\VMProtect Ultimate\Lib\Windows;C:\Users\ASMFreak\Downloads\PCILeech_files_and_binaries_v4.7-20201206;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x64;C:\pcileechsource;C:\Program Files\VMProtect Ultimate\Lib\Windows;C:\Users\ASMFreak\Downloads\PCILeech_files_and_binaries_v4.7-20201206;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>
      </ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <UseFullPaths>false</UseFullPaths>
      <SupportJustMyCode />
    </ClCompile>
    <Link>
      <SubSystem>NotSet</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>NotSet</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Dialog Callbacks.cpp" />
    <ClCompile Include="DMADevice.cpp" />
    <ClCompile Include="Entry Point.cpp" />
    <ClCompile Include="MainThread.cpp" />
    <ClCompile Include="MonoClasses.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Dialog Callbacks.h" />
    <ClInclude Include="DMADevice.h" />
    <ClInclude Include="globals.h" />
    <ClInclude Include="MainThread.h" />
    <ClInclude Include="MonoClasses.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="EFT Leecher.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EFT Leecher.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Resource">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Entry Point.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Dialog Callbacks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DMADevice.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MainThread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MonoClasses.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="globals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dialog Callbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DMADevice.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MainThread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MonoClasses.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Resource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="EFT Leecher.rc">
      <Filter>Resource</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EFT Leecher.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <RESOURCE_FILE>EFT Leecher.rc</RESOURCE_FILE>
  </PropertyGroup>
</Project>
```

`Entry Point.cpp`:

```cpp
//we include header files you dont have to use any OTHER Files but its cleaner
#include "globals.h"

//the location of the settings file
char szSettingsFile[MAX_PATH] = {};

//the console call back it will fire when an event happens AKA closing the console
#ifdef DEBUG_CONSOLE
BOOL WINAPI ConsoleHandle(DWORD CtrlType)
{
	if (CtrlType == CTRL_CLOSE_EVENT)
	{
		return TRUE;
	}
	return FALSE;
}
#endif

//
// This is the MAIN entry point this is what your application will run before anything else
//
INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
	//
	// hInstance - the current application address space
	// hPrevInstance - the prev application address space
	// lpCmdLine - the command line that is passed IF passed
	// nShowCmd - the show command this is normally SW_SHOWNORMAL meaning user clicked on the EXE
	//
	//UNREFERENCED_PARAMETER - allows you to tell C++ you WILL NOT USE this parameter you dont need to use it, but if you use it it causes your app NOT to compile unneeded code
	//
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

#ifdef DEBUG_CONSOLE
	//creates a new console for this app
	AllocConsole();

	//this tells the app to redirect ANY writes AKA printf to the console
	freopen("CONOUT$", "w", stdout);

	//set a console callback
	SetConsoleCtrlHandler(ConsoleHandle, TRUE);

	//print some debug data
	printf("DMA toolbox loaded\n\n");
#endif
	//get the settings file
	GetCurrentDirectoryA(MAX_PATH, szSettingsFile);
	strcat(szSettingsFile, "//Settings.ini");

	//this "CreateDialogParamA" will create a dialog from a resource file AKA IDD_MAIN_DIALOG and sets a callback function to the dialog
	HWND hDlgBox = CreateDialogParamA(hInstance, MAKEINTRESOURCEA(IDD_SERIAL_DIALOG), NULL, Serial_Dialog_Callback, NULL);
	if (hDlgBox == 0)
	{
		MessageBox(0, L"Failed to create dialog box\n", 0, 0);
		return 0;
	}
	//we tell the dialog that we want to show it
	ShowWindow(hDlgBox, SW_SHOWNORMAL);

	//we tell "windows" to update the dialog
	UpdateWindow(hDlgBox);

#ifdef DEBUG_CONSOLE
	//more debug data
	printf("Toolbox loaded!\n");
#endif

	//declare a variable
	MSG msg = { 0 };

	//make a loop till you get the quit message
	while (msg.message != WM_QUIT)
	{
		//peek message checks if there are any message AKA things that have happen on the dialog
		while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE) > 0)
		{
			//check if this message is a dialog message if this is NOT a dialog message then translate it and send it to the callback function
			if (!IsDialogMessage(hDlgBox, &msg))
			{
				//translate message before sending it to the dialog
				TranslateMessage(&msg);

				//send it to the dialog callback function
				DispatchMessage(&msg);
			}

			//check if the message is quitting
			if (msg.message == WM_QUIT)
			{
				//break the loop when you get the quit message then it will do an if statement and break the endless loop!
				break;
			}
		}
	}

	//destroy the window FULLY! you dont need to because the quit message will do it but LETS make sure destory is called for clean up?
	DestroyWindow(hDlgBox);

	//set it to NULL so we dont get wrong value when making a new dialog box!
	hDlgBox = NULL;

	//the ifdef will check ALL included header files for the #define X and if #define X is found the compiler will auto add the code

	//check the value if its valid return from the HWID check dialog box!
	if (msg.wParam == 1337)
	{
		//create a new dialog box because we have checked the HWID!
		hDlgBox = CreateDialogParamA(hInstance, MAKEINTRESOURCEA(IDD_MAIN_DIALOG), NULL, Main_Dialog_Callback, NULL);

		//clear the WHOLE message buffer so that way we dont get wrong data
		ZeroMemory(&msg, sizeof(MSG));

		//we tell the dialog that we want to show it
		ShowWindow(hDlgBox, SW_SHOWNORMAL);

		//we tell "windows" to update the dialog
		UpdateWindow(hDlgBox);

		CThreadData hThreadData = {};
		hThreadData.m_hDlg = hDlgBox;
		hThreadData.m_bGameRunnning = TRUE;
		hThreadData.m_lpMainWorldPointer = 0;
		hThreadData.m_lpLocalPlayerPointer = 0;
		hThreadData.m_dwInputManager = 0;
		hThreadData.m_lpMainCameraGameObject = 0;
		hThreadData.m_iPlayerObjectCount = 0;
		hThreadData.m_iBone = 0;
		hThreadData.m_lpPlayerObjects = (CPlayerData**)calloc(200, sizeof(DWORD64));
		for (int i = 0; i < 200; i++)
			hThreadData.m_lpPlayerObjects[i] = (CPlayerData*)calloc(1, sizeof(CPlayerData));

		//create a thread for the main processing or main shit or hack function what ever you please just so we can do shit in the background with no issues of crap!
		HANDLE hMainThread = CreateThread(NULL, NULL, MainThread, &hThreadData, NULL, NULL);
#ifdef ENABLE_AIMBOT
		HANDLE hPlayerThread = CreateThread(NULL, NULL, PlayerThread, &hThreadData, NULL, NULL);
		HANDLE hAimbotThread = CreateThread(NULL, NULL, AimbotThread, &hThreadData, NULL, NULL);
#endif
		//wait we couldnt create a thread? WTF is this guy running win95?
		if (hMainThread == INVALID_HANDLE_VALUE)
		{
			MessageBoxA(0, "Error Creating MainThread Try Again?", 0, 0);

			//destroy the window FULLY! you dont need to because the quit message will do it but LETS make sure destory is called for clean up?
			DestroyWindow(hDlgBox);

			//set it to NULL so we dont get wrong value when making a new dialog box!
			hDlgBox = NULL;

			return nShowCmd;
		}
#ifdef ENABLE_AIMBOT
		if (hPlayerThread == INVALID_HANDLE_VALUE)
		{
			MessageBoxA(0, "Error Creating MainThread Try Again?", 0, 0);

			//destroy the window FULLY! you dont need to because the quit message will do it but LETS make sure destory is called for clean up?
			DestroyWindow(hDlgBox);

			//set it to NULL so we dont get wrong value when making a new dialog box!
			hDlgBox = NULL;

			return nShowCmd;
		}
		if (hAimbotThread == INVALID_HANDLE_VALUE)
		{
			MessageBoxA(0, "Error Creating MainThread Try Again?", 0, 0);

			//destroy the window FULLY! you dont need to because the quit message will do it but LETS make sure destory is called for clean up?
			DestroyWindow(hDlgBox);

			//set it to NULL so we dont get wrong value when making a new dialog box!
			hDlgBox = NULL;

			return nShowCmd;
		}
#endif
		//make a loop till you get the quit message
		while (msg.message != WM_QUIT)
		{
			//peek message checks if there are any message AKA things that have happen on the dialog
			while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE) > 0)
			{
				//check if this message is a dialog message if this is NOT a dialog message then translate it and send it to the callback function
				if (!IsDialogMessage(hDlgBox, &msg))
				{
					//translate message before sending it to the dialog
					TranslateMessage(&msg);

					//send it to the dialog callback function
					DispatchMessage(&msg);
				}

				//check if the message is quitting
				if (msg.message == WM_QUIT)
				{
					//break the loop when you get the quit message then it will do an if statement and break the endless loop!
					break;
				}
			}
		}

		//destroy the window FULLY! you dont need to because the quit message will do it but LETS make sure destory is called for clean up?
		DestroyWindow(hDlgBox);

		//set it to NULL so we dont get wrong value when making a new dialog box!
		hDlgBox = NULL;

		//tell thread to piss off!
		hThreadData.m_bGameRunnning = FALSE;

		////close the main thread it should close but we need to FORCE it to close because we no longer need it but meh lets just force it 
		//TerminateThread(hMainThread, TRUE);
		//TerminateThread(hAimbotThread, TRUE);

		//wait for the thread to exit!
		WaitForSingleObject(hMainThread, INFINITE);
#ifdef ENABLE_AIMBOT
		WaitForSingleObject(hPlayerThread, INFINITE);
		WaitForSingleObject(hAimbotThread, INFINITE);
		CloseHandle(hPlayerThread);
#endif		
		CloseHandle(hMainThread);
		//exit the handle! always clean up :)

#ifdef ENABLE_AIMBOT
		CloseHandle(hAimbotThread);
#endif
	}

//the ifdef will check ALL included header files for the #define X and if #define X is found the compiler will auto add the code



	//now we just return because everything has been cleaned up etc via the callbacks!
	return nShowCmd;
}
```

`MainThread.cpp`:

```cpp
#include "globals.h"
#include "MonoClasses.h"

DWORD dwConnectionStatusColor = RGB(255, 0, 0);
float fMaxStamina = 0.0f;
bool bWorldPointerFound = false;
bool bLocalPlayerFound = false;
bool bLocalPlayerTextSet = false;
bool bAutoDisconnectAfterRaidEnds = false;
bool bRemoveVisorEffects = false;
bool bNightVisionEffect = false;
bool bThermalVisionEffect = false;
bool bNoWeight = false;
bool bNoRecoil = false;
bool bNoStamina = false;
bool bUnlockEverything = false;
#ifdef ENABLE_AIMBOT
bool bAimbotEnabled = false;
int iAimbotBone = 0;
int iAimbotHotkey = 0;
#endif
int iJumpMultiplier = 1;
int iThrowMultiplier = 1;
int iHearingMultiplier = 1;

//normal map names
wchar_t *szMapNames[] =
{
	L"Factory",
	L"Factory",
	L"Woods",
	L"Customs",
	L"Shoreline",
	L"Interchange",
	L"Reserve",
	L"Labs"
};
wchar_t *szEFTMapNames[] =
{
	L"factory4_day",
	L"factory4_night",
	L"Woods",
	L"bigmap",
	L"Shoreline",
	L"Interchange",
	L"RezervBase",
	L"laboratory"
};

CGameWorld *GetGameWorld(CGameWorld *lpWorldData)
{
	CUnityGameObjectManager* objManagerPtr = DMADevice::MemReadPtr<CUnityGameObjectManager*>(DMADevice::dwUnityPlayerBaseAddress + UNITY_OBJECT_LIST);
	if (objManagerPtr == 0)
		return 0;

	CUnityGameObjectManager objManager = {};
	if (!DMADevice::MemRead(objManagerPtr, &objManager, sizeof(CUnityGameObjectManager)))
		return 0;

	int iCount = 0;
	CUnityListElement<CUnityListNode<CUnityGameObject>> *lpObject = objManager.m_Active.m_lpNext;
	while (lpObject != objManager.m_Active.m_lpPrev)
	{
		iCount++;
		if (iCount > 5000)
			return 0;

		CUnityListNode<CUnityGameObject> lpObjectDataLoop = {};
		if (!lpObject || !DMADevice::MemRead(lpObject, &lpObjectDataLoop, sizeof(CUnityListNode<CUnityGameObject>)))
			break;

		CUnityGameObject lpGameObject = {};
		if (DMADevice::MemRead(lpObjectDataLoop.m_lpData, &lpGameObject, sizeof(CUnityGameObject)))
		{
			char szObjectName[64] = {};
			if (DMADevice::MemRead(lpGameObject.m_szObjectName, szObjectName, 32, false) && strcmp(szObjectName, "GameWorld") == 0)
			{
				CGameWorld* lpGameWorld = (CGameWorld*)lpGameObject.m_aComponents.GetByName("ClientNetworkGameWorld,ClientLocalGameWorld");
				if (lpGameWorld && DMADevice::MemRead(lpGameWorld, lpWorldData, sizeof(CGameWorld)) && lpWorldData->m_lpComponent)
				{
					CUnityTList<CPlayer*> lpPlayerList = {};
					if (DMADevice::MemRead(lpWorldData->RegisteredPlayers, &lpPlayerList, sizeof(CUnityTList<CPlayer*>)) && lpPlayerList.dwSize > 0)
						return lpGameWorld;
				}
			}
		}
		lpObject = (CUnityListElement<CUnityListNode<CUnityGameObject>>*)lpObjectDataLoop.m_lpNext;
	}
	return 0;
}

CUnityGameObject *GetMainCamera()
{
	CamerasArray *lpCameras = DMADevice::MemReadPtr<CamerasArray*>(DMADevice::dwUnityPlayerBaseAddress + UNITY_CAMERA_LIST);
	if (lpCameras)
	{
		CamerasArray lpCameraArray = {};
		if (DMADevice::MemRead(lpCameras, &lpCameraArray, sizeof(CamerasArray)) && lpCameraArray.Cameras && lpCameraArray.SizeCur > 0)
		{
			CCamera **lpCameraList = (CCamera**)calloc(lpCameraArray.SizeCur, sizeof(void*));
			if (lpCameraList == 0)
				return 0;

			if (DMADevice::MemRead(lpCameraArray.Cameras, lpCameraList, sizeof(void*) * lpCameraArray.SizeCur))
			{
				for (int i = 0; i < lpCameraArray.SizeCur; i++)
				{
					CCamera* pCamera = lpCameraList[i];
					if (pCamera)
					{
						CUnityGameObject *lpGameObject = DMADevice::MemReadPtr<CUnityGameObject*>((DWORD_PTR)pCamera + 0x30);
						if (lpGameObject)
						{
							CUnityGameObject pGameObject = {};
							if (DMADevice::MemRead(lpGameObject, &pGameObject, sizeof(CUnityGameObject)))
							{
								char szObjectName[64] = {};
								if (DMADevice::MemRead(pGameObject.m_szObjectName, szObjectName, 64))
								{
									if (strcmp(szObjectName, "FPS Camera") == 0)
									{
										free(lpCameraList);
										return lpGameObject;
									}
								}
							}
						}
					}
				}
			}
			free(lpCameraList);
			lpCameraList = 0;
		}
	}
	return 0;
}

CPlayer* GetLocalPlayer(CGameWorld *lpWorldData, CUnityString* lpLocalProfileId)
{
	CPlayer lpPlayerData = {};
	CProfile lpPlayerProfileData = {};
	CUnityString lpUnityStringData = {};
	CUnityTList<CPlayer*> lpPlayerList = {};
	CUnityTListCounter<CPlayer*, 100> lpPlayerListArray = {};
	if (DMADevice::MemRead(lpWorldData->RegisteredPlayers, &lpPlayerList, sizeof(CUnityTList<CPlayer*>)) && lpPlayerList.dwSize > 0)
	{
		if (DMADevice::MemRead(lpPlayerList.lpList, &lpPlayerListArray, TLIST_SIZE(CPlayer*, lpPlayerList.dwSize)))
		{
			for (int i = 0; i < lpPlayerList.dwSize; i++)
			{
				CPlayer* lpPlayerPtr = lpPlayerListArray.lpListArray[i];
				if (!lpPlayerPtr || 
					!DMADevice::MemRead(lpPlayerPtr, &lpPlayerData, sizeof(CPlayer)) || 
					!DMADevice::MemRead(lpPlayerData.m_lpProfile, &lpPlayerProfileData, sizeof(CProfile)))
					continue;

				DMADevice::MemReadUnityString(lpPlayerProfileData.Id, &lpUnityStringData);

				if (lpPlayerData.m_bIsLocalPlayer || (lpUnityStringData == (*lpLocalProfileId)))
					return lpPlayerPtr;
			}
		}
	}
	return 0;
}

void Camera_Hack_Effects(CUnityGameObject* lpMainCameraGameObject)
{
	float fSet = 0.0f;

	if (lpMainCameraGameObject)
	{
		CUnityGameObject pGameObject = {};
		if (DMADevice::MemRead(lpMainCameraGameObject, &pGameObject, sizeof(CUnityGameObject)))
		{
			CVisorEffect* lpCamGameVisorEffect = (CVisorEffect*)pGameObject.m_aComponents.GetByName("VisorEffect");
			if (lpCamGameVisorEffect)
			{
				fSet = bRemoveVisorEffects ? 0.0f : 1.0f;

				DMADevice::MemWrite((DWORD_PTR)lpCamGameVisorEffect + offsetof(CVisorEffect, Intensity), &fSet, sizeof(float));
			}

			CNightvision* lpCamGameNightVisionEffect = (CNightvision*)pGameObject.m_aComponents.GetByName("NightVision");
			if (lpCamGameNightVisionEffect)
			{
				fSet = bNightVisionEffect ? 0.0f : 1.0f;

				DMADevice::MemWrite((DWORD_PTR)lpCamGameNightVisionEffect + offsetof(CNightvision, Intensity), &fSet, sizeof(float));
				DMADevice::MemWrite((DWORD_PTR)lpCamGameNightVisionEffect + offsetof(CNightvision, _on), &bNightVisionEffect, sizeof(bool));
			}

			CThermalVision* lpCamGameThermalEffect = (CThermalVision*)pGameObject.m_aComponents.GetByName("ThermalVision");
			if (lpCamGameThermalEffect)
			{
				DMADevice::MemWrite((DWORD_PTR)lpCamGameThermalEffect + offsetof(CThermalVision, _on), &bThermalVisionEffect, sizeof(bool));

				DWORD64 dwThermial1 = DMADevice::MemReadPtr<DWORD64>((DWORD_PTR)lpCamGameThermalEffect + 0x90);
				if (dwThermial1)
				{
					DWORD64 dwThermial2 = DMADevice::MemReadPtr<DWORD64>((DWORD_PTR)dwThermial1 + 0x10);
					if (dwThermial2)
					{
						/*BYTE bValue = 224;
						DMADevice::MemWrite(dwThermial2 + 0x38, &bValue, sizeof(BYTE));*/
					}

				}
			}
		}
	}	
}

void LocalPlayerHacks(CPlayer* lpLocalPlayerPointer, bool bIsThisMapInterchange)
{
	CPlayer lpLocalPlayer = {};
	if (!DMADevice::MemRead(lpLocalPlayerPointer, &lpLocalPlayer, sizeof(lpLocalPlayer)))
		return;

	//physical stuff
	float fSet = 100.0f;

	//check variable and pointer
	if (bNoStamina)
	{
		//keep a variable for data
		CGClass440 bPhyData = {};

		//read the whole class
		if (DMADevice::MemRead(lpLocalPlayer.m_lpPhyiscal, &bPhyData, sizeof(CGClass440)))
		{
			//again read the whole class so we can grab current stamina
			CGClass439 gStamina = {};
			if (DMADevice::MemRead(bPhyData.Stamina, &gStamina, sizeof(CGClass439)))
			{
				//check our variable if its been set if its not then lets set stamina to the "default value"
				if (fMaxStamina == 0.0f)
					fMaxStamina = gStamina.Current;
				else
					//we have the default value so just keep setting it ;)
					DMADevice::MemWrite(((QWORD)bPhyData.Stamina) + offsetof(CGClass439, Current), &fMaxStamina, sizeof(float));
			}
			if (DMADevice::MemRead(bPhyData.HandsStamina, &gStamina, sizeof(CGClass439)))
			{
				DMADevice::MemWrite(((QWORD)bPhyData.HandsStamina) + offsetof(CGClass439, Current), &fSet, sizeof(float));
			}
			if (DMADevice::MemRead(bPhyData.Oxygen, &gStamina, sizeof(CGClass439)))
			{
				DMADevice::MemWrite(((QWORD)bPhyData.Oxygen) + offsetof(CGClass439, Current), &fSet, sizeof(float));
			}
		}
	}

	//weapon stuff
	//check the variable
	if (bNoRecoil)
	{
		//value we want to set
		fSet = 0.0f;

		//Grab all the class data
		CProceduralWeaponAnimation bProWeaponAnimation = {};
		if (DMADevice::MemRead(lpLocalPlayer.m_lpWeaponAni, &bProWeaponAnimation, sizeof(CProceduralWeaponAnimation)))
		{
			//&=~ means REMOVE bit's from a DWORD or BYTE &=| means set bits yeah alot of learning if you want to understand bits google it :) lol
			//please read online about bit mask there VERY VERY hard to explain and take awhile to understand bit mask and flags is what you want to look for!
			bProWeaponAnimation.Mask &= ~CEProceduralAnimationMask::Walking;

			//set the breath intensity to 0.0f
			if (bProWeaponAnimation.m_lpBreath)
				DMADevice::MemWrite(((QWORD)bProWeaponAnimation.m_lpBreath) + offsetof(CBreath, m_fIntensity), &fSet, sizeof(float));

			//set the walk intensity to 0.0f
			if (bProWeaponAnimation.m_lpWalk)
				DMADevice::MemWrite(((QWORD)bProWeaponAnimation.m_lpWalk) + offsetof(CWalk, m_fIntensity), &fSet, sizeof(float));

			//set the motion react to 0.0f
			if (bProWeaponAnimation.m_MotionReact)
				DMADevice::MemWrite(((QWORD)bProWeaponAnimation.m_MotionReact) + offsetof(CMotionEffector, m_fIntensity), &fSet, sizeof(float));

			//set the force react to 0.0f
			if (bProWeaponAnimation.m_ForceReact)
				DMADevice::MemWrite(((QWORD)bProWeaponAnimation.m_ForceReact) + offsetof(CForceEffector, m_fIntensity), &fSet, sizeof(float));

			//this is no recoil ONLY everything else is no sway :')
			if (bProWeaponAnimation.m_lpShooting)
				DMADevice::MemWrite(((QWORD)bProWeaponAnimation.m_lpShooting) + offsetof(CShotEffector, m_fIntensity), &fSet, sizeof(float));

			//set the new mask on the weapon
			DMADevice::MemWrite(((QWORD)lpLocalPlayer.m_lpWeaponAni) + offsetof(CProceduralWeaponAnimation, Mask), &bProWeaponAnimation.Mask, sizeof(DWORD));
		}
		
	}

	////unlock all doors etc
	//if (bUnlockEverything)
	//{
	//	//variable to store the saved results
	//	CDoor bInteractableData = {};
	//
	//	//grab the whole struct data its QUICKER and easyer
	//	if (DMADevice::MemRead(lpLocalPlayer.interactableObject_0, &bInteractableData, sizeof(CDoor)))
	//	{
	//		//first we declare what we want to find which is EVERYTHING
	//		char *szToFind = "KeycardDoor,Door,LootableContainer,Trunk";
	//
	//		//now we check if this map is interchange if so then we declare that we want everything BUT keycard doors 
	//		if(bIsThisMapInterchange)
	//			szToFind = "Door,LootableContainer,Trunk";
	//
	//		//now look for this 
	//		if(bInteractableData.GetComonent(szToFind))
	//		{
	//			//we check the status of the door is it locked?
	//			if (bInteractableData._doorState == CEDoorState::DS_Locked)
	//			{
	//				//we have to declare a variable to set memory (well we dont but easyer)
	//				CEDoorState ioDoorState = CEDoorState::DS_Shut;
	//
	//				//now write memory there no need to check if written as if a door dont open its not gonna kill us? well i hope not!
	//				DMADevice::MemWrite(((QWORD)lpLocalPlayer.interactableObject_0) + offsetof(CWorldInteractiveObject, _doorState), &ioDoorState, sizeof(CEDoorState));
	//			}
	//		}
	//	}
	//}

	//variable to store the saved results
	CProfile lpProfile = {};

	//grab the whole struct data its QUICKER and easyer
	if (DMADevice::MemRead(lpLocalPlayer.m_lpProfile, &lpProfile, sizeof(CProfile)))
	{
		//variable to store the saved results
		CGClass1205 lpSkills = {};

		//grab the whole struct data its QUICKER and easyer
		if (DMADevice::MemRead(lpProfile.Skills, &lpSkills, sizeof(CGClass1205)))
		{
			//keep an array a variable
			CUnityTArrayCounter<CGClass1097*, 100> lpSkillArray = {};

			//grab the first part which is the start "size and first data" then we grab it ALL!
			if (DMADevice::MemRead(lpSkills.Skills, &lpSkillArray, sizeof(CUnityTArray<CGClass1097*>)))
			{
				//we grab ALL the tarray which is unity lovly arrays!
				if (DMADevice::MemRead(lpSkills.Skills, &lpSkillArray, TARRAY_SIZE(CGClass1097*, lpSkillArray.dwSize)))
				{
					//loop ALL the skills!
					for (int i = 0; i < lpSkillArray.dwSize; i++)
					{
						//grab the pointer to the skill
						CGClass1097 *lpSkill = lpSkillArray.lpListArray[i];
						if (!lpSkill)
							continue;
							
						//keep a copy of the data
						CGClass1097 SkillData = {};

						//we need to read the skill data BECAUSE EFT dont sort the skill's meaning str could be 10 index etc etc
						if (DMADevice::MemRead(lpSkill, &SkillData, sizeof(CGClass1097)))
						{
							//loop all the skills to find ours
							for (int s = 0; s < Skills_Max; s++)
							{
								//check this index
								if (SkillData.Id == s)
								{
									//do we want to change this skill level?
									if (sSkillData[s].m_bLvlEnabled)
									{
										//100 exp * level 51 max level is 50 but EFT checks if level is > 50 which would need to be 51
										float fSkillExp = (100.0f * sSkillData[s].m_iLevel);

										//set the memory for the EXP
										DMADevice::MemWrite(((QWORD)lpSkill) + offsetof(CGClass1097, Current), &fSkillExp, sizeof(float));
									}
								}
							}
						}
					}
				}
			}
#define SKILL_SET_BUFF(t,x,v) if(lpSkills.##x) { t val = v; DMADevice::MemWrite((((DWORD64)lpSkills.##x) + offsetof(CGClass1103<t>, Value)), &val, sizeof(t)); }

			//Endurance
			SKILL_SET_BUFF(float, EnduranceBuffEnduranceInc, 1.5f);
			SKILL_SET_BUFF(float, EnduranceHands, 1.0f);
			SKILL_SET_BUFF(float, EnduranceBuffJumpCostRed, 1.0f);
			SKILL_SET_BUFF(float, EnduranceBuffBreathTimeInc, 1.0f);
			SKILL_SET_BUFF(float, EnduranceBuffRestoration, 1.5f);
			SKILL_SET_BUFF(float, EnduranceBreathElite, 1.5f);

			//Strength
			//SKILL_SET_BUFF(float, StrengthBuffLiftWeightInc, 10.0f);
			SKILL_SET_BUFF(float, StrengthBuffSprintSpeedInc, 0.3f);
			SKILL_SET_BUFF(float, StrengthBuffJumpHeightInc, (0.1f * iJumpMultiplier));//oi michael cunt? leave the values alone?
			SKILL_SET_BUFF(float, StrengthBuffAimFatigue, 0.2f);
			SKILL_SET_BUFF(float, StrengthBuffThrowDistanceInc, (0.1f * iThrowMultiplier));//oi michael cunt? leave the values alone?
			SKILL_SET_BUFF(float, StrengthBuffMeleePowerInc, 0.3f);
			//SKILL_SET_BUFF(bool, StrengthBuffElite, true);
			SKILL_SET_BUFF(float, StrengthBuffMeleeCrits, 0.5f);

			//Vitality
			SKILL_SET_BUFF(float, VitalityBuffBleedChanceRed, 1.0f);
			SKILL_SET_BUFF(float, VitalityBuffSurviobilityInc, 1.0f);
			SKILL_SET_BUFF(bool, VitalityBuffRegeneration, true);
			SKILL_SET_BUFF(bool, VitalityBuffBleedStop, true);

			//Health
			SKILL_SET_BUFF(float, HealthBreakChanceRed, 1.0f);
			SKILL_SET_BUFF(float, HealthOfflineRegenerationInc, 999.0f);
			SKILL_SET_BUFF(float, HealthEnergy, 1.0f);
			SKILL_SET_BUFF(float, HealthHydration, 1.0f);
			SKILL_SET_BUFF(bool, HealthEliteAbsorbDamage, true);
			//SKILL_SET_BUFF(float, HealthElitePosion, 999.0f);

			//Stress
			SKILL_SET_BUFF(float, StressPain, 1.0f);
			//SKILL_SET_BUFF(float, StressTremor, 999.0f);
			SKILL_SET_BUFF(bool, StressBerserk, true);

			//Metabolism
			SKILL_SET_BUFF(float, MetabolismRatioPlus, 1.0f);
			SKILL_SET_BUFF(bool, MetabolismEliteBuffNoDyhydration, true);

			//Perception
			SKILL_SET_BUFF(float, PerceptionHearing, (1.2f * iHearingMultiplier));//oi michael cunt? leave the values alone?
			SKILL_SET_BUFF(float, PerceptionLootDot, 1.0f);
			SKILL_SET_BUFF(bool, PerceptionEliteNoIdea, true);

			//Intellect
			SKILL_SET_BUFF(float, IntellectLearningSpeed, 1.0f);
			SKILL_SET_BUFF(float, IntellectWeaponMaintance, 1.0f);
			SKILL_SET_BUFF(bool, IntellectEliteNaturalLearner, true);
			SKILL_SET_BUFF(bool, IntellectEliteAmmoCounter, true);
			SKILL_SET_BUFF(bool, IntellectEliteContainerScope, true);

			//Attention
			SKILL_SET_BUFF(float, AttentionLootSpeed, 1.0f);
			SKILL_SET_BUFF(float, AttentionExamine, 10.0f);
			SKILL_SET_BUFF(float, AttentionEliteLuckySearch, 100.0f);
			SKILL_SET_BUFF(bool, AttentionEliteExtraLootExp, true);

			//Magdrills
			//SKILL_SET_BUFF(float, MagDrillsLoadSpeed, 180.0f);
			//SKILL_SET_BUFF(float, MagDrillsUnloadSpeed, 100.0f);
			//SKILL_SET_BUFF(float, MagDrillsInventoryCheckSpeed, 100.0f);
			//SKILL_SET_BUFF(float, MagDrillsInventoryCheckAccuracy, 100.0f);
			//SKILL_SET_BUFF(bool, MagDrillsInstantCheck, true);
			//SKILL_SET_BUFF(bool, MagDrillsLoadProgression, true);

			//Charisma
			/*
			SKILL_SET_BUFF(float, CharismaBuff1, 999.0f);
			SKILL_SET_BUFF(float, CharismaBuff2, 999.0f);
			SKILL_SET_BUFF(bool, CharismaEliteBuff1, true);
			SKILL_SET_BUFF(float, CharismaEliteBuff2, 999.0f);
			SKILL_SET_BUFF(float, MemoryMentalForget1, 999.0f);
			SKILL_SET_BUFF(float, MemoryMentalForget2, 999.0f);
			SKILL_SET_BUFF(bool, MemoryEliteMentalRecoil, true);
			SKILL_SET_BUFF(float, AimMasterSpeed, 999.0f);
			SKILL_SET_BUFF(float, AimMasterWiggle, 999.0f);
			SKILL_SET_BUFF(bool, AimMasterElite, true);
			SKILL_SET_BUFF(float, RecoilControlImprove, 999.0f);
			SKILL_SET_BUFF(float, RecoilControlElite, 999.0f);
			SKILL_SET_BUFF(float, TroubleFixing, 999.0f);
			SKILL_SET_BUFF(float, TroubleFixingElite, 999.0f);
			SKILL_SET_BUFF(float, ThrowingStrengthBuff, 999.0f);
			SKILL_SET_BUFF(float, ThrowingEnergyExpenses, 999.0f);
			SKILL_SET_BUFF(bool, ThrowingEliteBuff, true);
			SKILL_SET_BUFF(float, DrawSpeed, 999.0f);
			SKILL_SET_BUFF(float, DrawSound, 999.0f);
			SKILL_SET_BUFF(bool, DrawElite, true);
			SKILL_SET_BUFF(bool, DrawTremor, true);
			SKILL_SET_BUFF(float, CovertMovementSoundVolume, 999.0f);
			SKILL_SET_BUFF(float, CovertMovementEquipment, 999.0f);
			SKILL_SET_BUFF(float, CovertMovementSpeed, 999.0f);
			SKILL_SET_BUFF(bool, CovertMovementElite, true);
			SKILL_SET_BUFF(float, CovertMovementLoud, 999.0f);
			SKILL_SET_BUFF(float, ProneMovementSpeed, 999.0f);
			SKILL_SET_BUFF(float, ProneMovementVolume, 999.0f);
			SKILL_SET_BUFF(bool, ProneMovementEliteSprint, true);
			*/

			//Search
			SKILL_SET_BUFF(float, SearchBuffSpeed, 10.0f);
			SKILL_SET_BUFF(bool, SearchDouble, true);

			//Surgery
			//SKILL_SET_BUFF(float, SurgeryReducePenalty, 999.0f);
			//SKILL_SET_BUFF(float, SurgerySpeed, 999.0f);



		}
	}

	//check variable
	//if (bNoWeight)
	//{
	//	//keep a variable for data
	//	CGClass1797 bInvData = {};

	//	//read the whole class
	//	if (DMADevice::MemRead(lpLocalPlayer._inventoryController, &bInvData, sizeof(CGClass1797)))
	//	{
	//		//keep a variable for data
	//		CGClass1781 bClass1752Data = {};

	//		//read the whole class
	//		if (DMADevice::MemRead(bInvData.gclass1781_0, &bClass1752Data, sizeof(CGClass1781)))
	//		{
	//			float fMax = 1.0f;

	//			//set both total weight and total weight elite skill to 1.0f some reason they didnt put these together but if you enable max skill it uses total weight elite skill not total weight
	//			DMADevice::MemWrite(((QWORD)bClass1752Data.TotalWeight) + offsetof(CGClass503<float>, gparam_0), &fMax, sizeof(float));
	//			DMADevice::MemWrite(((QWORD)bClass1752Data.TotalWeightEliteSkill) + offsetof(CGClass503<float>, gparam_0), &fMax, sizeof(float));
	//		}
	//	}

	//	//keep a variable for data
	//	CGClass440 bPhyData = {};

	//	//read the whole class
	//	if (DMADevice::MemRead(lpLocalPlayer.m_lpPhyiscal, &bPhyData, sizeof(CGClass440)))
	//	{
	//		float fMax = 5.0f;
	//		DMADevice::MemWrite(((QWORD)lpLocalPlayer.m_lpPhyiscal) + offsetof(CGClass440, PreviousWeight), &fMax, sizeof(float));

	//		fMax = 0.0f;
	//		DMADevice::MemWrite(((QWORD)lpLocalPlayer.m_lpPhyiscal) + offsetof(CGClass440, float_4), &fMax, sizeof(float));
	//		DMADevice::MemWrite(((QWORD)lpLocalPlayer.m_lpPhyiscal) + offsetof(CGClass440, Overweight), &fMax, sizeof(float));
	//		DMADevice::MemWrite(((QWORD)lpLocalPlayer.m_lpPhyiscal) + offsetof(CGClass440, WalkOverweight), &fMax, sizeof(float));

	//		fMax = 1.0f;
	//		DMADevice::MemWrite(((QWORD)lpLocalPlayer.m_lpPhyiscal) + offsetof(CGClass440, WalkSpeedLimit), &fMax, sizeof(float));

	//		bool bUpdated = true;
	//		DMADevice::MemWrite(((QWORD)lpLocalPlayer.m_lpPhyiscal) + offsetof(CGClass440, bool_1), &bUpdated, sizeof(bool));
	//	}
	//}
}

#ifdef ENABLE_AIMBOT
bool GetPlayerBonePosition(CPlayer* lpPlayerPtr, int iBone, FVec3 *vOutput)
{
	CPlayerBody lpPlayerBody = {};
	if (!lpPlayerPtr || !DMADevice::MemRead(lpPlayerPtr->m_lpPlayerBody, &lpPlayerBody, sizeof(CPlayerBody), false))
		return false;

	CSkeleton lpSkeleton = {};
	if (!DMADevice::MemRead(lpPlayerBody.SkeletonRootJoint, &lpSkeleton, sizeof(CSkeleton), false))
		return false;

	CUnityTList<CMonoTransform*> lpBoneData = {};
	if (!DMADevice::MemRead(lpSkeleton._values, &lpBoneData, sizeof(CUnityTList<CMonoTransform*>), false))
		return false;

	if (lpBoneData.dwSize == 0 || iBone > lpBoneData.dwSize || lpBoneData.lpList == 0)
		return false;

	CMonoTransform *lpPointer = 0;
	if (!DMADevice::MemRead(((DWORD64)lpBoneData.lpList) + 0x20 + (iBone * sizeof(CMonoTransform*)), &lpPointer, sizeof(CMonoTransform*)))
		return false;

	return lpPointer->GetPosition(vOutput);
}
bool IsKeyDown(CThreadData *lpData, int iKeyCode)
{
	BYTE bKeyManager[PAGE_SIZE] = {};
	if (!DMADevice::MemRead(lpData->m_dwInputManager, &bKeyManager, PAGE_SIZE, false))
		return false;

	DWORD64 dwKeyStatePtr1 = *(DWORD64*)(bKeyManager + 0x58);
	DWORD64 dwKeyStatePtr2 = *(DWORD64*)(bKeyManager + 0x78);

	DWORD dwKeyState1 = 0;
	if (dwKeyStatePtr1 && DMADevice::MemRead(dwKeyStatePtr1, &bKeyManager, PAGE_SIZE, false))
		dwKeyState1 = *(DWORD*)(bKeyManager + 4 * (iKeyCode >> 5));

	DWORD dwKeyState2 = 0;
	if (dwKeyStatePtr2 && DMADevice::MemRead(dwKeyStatePtr2, &bKeyManager, PAGE_SIZE, false))
		dwKeyState2 = *(DWORD*)(bKeyManager + 4 * (iKeyCode >> 5));

	return ((1 << (iKeyCode & 31)) & dwKeyState1) != 0 || ((1 << (iKeyCode & 31)) & dwKeyState2) != 0;
}

FVec4 FromEulerRad(FVec3 euler)
{
	float yaw = euler.x;
	float pitch = euler.y;
	float roll = euler.z;
	float rollOver2 = roll * 0.5f;
	float sinRollOver2 = sinf(rollOver2);
	float cosRollOver2 = cosf(rollOver2);
	float pitchOver2 = pitch * 0.5f;
	float sinPitchOver2 = sinf(pitchOver2);
	float cosPitchOver2 = cosf(pitchOver2);
	float yawOver2 = yaw * 0.5f;
	float sinYawOver2 = sinf(yawOver2);
	float cosYawOver2 = cosf(yawOver2);

	FVec4 result;
	result.x = cosYawOver2 * cosPitchOver2 * cosRollOver2 + sinYawOver2 * sinPitchOver2 * sinRollOver2;
	result.y = cosYawOver2 * cosPitchOver2 * sinRollOver2 - sinYawOver2 * sinPitchOver2 * cosRollOver2;
	result.z = cosYawOver2 * sinPitchOver2 * cosRollOver2 + sinYawOver2 * cosPitchOver2 * sinRollOver2;
	result.w = sinYawOver2 * cosPitchOver2 * cosRollOver2 - cosYawOver2 * sinPitchOver2 * sinRollOver2;
	return result;

}

FVec2 ClampRotation(CGClass1134 *lpMovementContextPtr, FVec2 rotation)
{
	CGClass1134 lpMovementContext = {};
	if (!DMADevice::MemRead(lpMovementContextPtr, &lpMovementContext, sizeof(CGClass1134)))
		return FVec2();

	return FVec2(ClampAngle360Sensitive(rotation.x, lpMovementContext.vector2_3.x, lpMovementContext.vector2_3.y), ClampAngle(rotation.y, lpMovementContext.vector2_4.x + lpMovementContext.float_28, lpMovementContext.vector2_4.y + lpMovementContext.float_28));
}
VOID SetLocalAngles(CProceduralWeaponAnimation* lpWeaponAni, CGClass1134 *lpMovementContext, FVec2 vNewRotation, FVec2 vOldRotation)
{
	FVec2 vNew = ClampRotation(lpMovementContext, vNewRotation);
	DMADevice::MemWrite(((DWORD64)lpMovementContext) + offsetof(CGClass1134, vector2_2), &vOldRotation, sizeof(FVec2));
	DMADevice::MemWrite(((DWORD64)lpMovementContext) + offsetof(CGClass1134, vector2_1), &vNew, sizeof(FVec2));


	FVec3 vOld = FromEulerRad(FVec3(vNew.y, vNew.x, 0.0f) * 0.017453292f) * FVec3(0.0f, 0.0f, 1.0f);
	vOld.z = -vOld.z;
	DMADevice::MemWrite(((DWORD64)lpMovementContext) + offsetof(CGClass1134, vector3_3), &vOld, sizeof(FVec2));

	vOld = FromEulerRad(FVec3(0.0f, vNew.x, 0.0f) * 0.017453292f) * FVec3(0.0f, 0.0f, 1.0f);
	vOld.z = -vOld.z;
	DMADevice::MemWrite(((DWORD64)lpMovementContext) + offsetof(CGClass1134, vector3_4), &vOld, sizeof(FVec2));
	
	DMADevice::MemWrite(((DWORD64)lpWeaponAni) + offsetof(CProceduralWeaponAnimation, Pitch), &vNew.y, sizeof(float));
}
float GetFOV(FVec2& ViewAngles, FVec2& vAimAngles)
{
	FVec2 vDelta = (vAimAngles - ViewAngles).NormalizeAngles();
	return sqrt(pow(vDelta.x, 2.0f) + pow(vDelta.y, 2.0f));
}
bool GetLocalFirepoint(CPlayer* lpLocalData, FVec3* vOutput)
{
	CPlayerBones lpLocalPlayerBones = {};
	if (!DMADevice::MemRead(lpLocalData->PlayerBones, &lpLocalPlayerBones, sizeof(CPlayerBones), false))
		return false;

	CBifacialTransform lpFireportBiTransform = {};
	if (!DMADevice::MemRead(lpLocalPlayerBones.Fireport, &lpFireportBiTransform, sizeof(CBifacialTransform), false))
		return false;

	return lpFireportBiTransform.GetPosition(vOutput);
}
bool IsSameGroup(CPlayer* lpLocalData, CGClass1194* lpProfileData)
{
	CProfile lpLocalProfileData = {};
	if (!DMADevice::MemRead(lpLocalData->m_lpProfile, &lpLocalProfileData, sizeof(CProfile)))
		return false;

	CGClass1194 lpLocalProfileInfo = {};
	if (!DMADevice::MemRead(lpLocalProfileData.Info, &lpLocalProfileInfo, sizeof(CGClass1194)))
		return false;

	CUnityString szLocalGroupId = {};
	CUnityString szPlayerGroupId = {};
	if (!DMADevice::MemRead(lpLocalProfileInfo.GroupId, &szLocalGroupId, sizeof(CUnityString)) || !DMADevice::MemRead(lpProfileData->GroupId, &szPlayerGroupId, sizeof(CUnityString)))
		return false;

	return (szLocalGroupId == szPlayerGroupId);
}
bool GetMainCameraPosition(CUnityGameObject* lpMainCameraGameObject, FVec3* vOutput)
{
	CUnityGameObject pGameObject = {};
	if (!DMADevice::MemRead(lpMainCameraGameObject, &pGameObject, sizeof(CUnityGameObject)))
		return false;

	CMonoTransform* lpTransform = (CMonoTransform*)pGameObject.m_aComponents.GetById(CLASS_MonoTransform);
	if (lpTransform == 0)
		return false;

	return lpTransform->GetPosition(vOutput);
}
int RandomInt(int a, int b)
{
	return a + (rand() % (int)(b - a + 1));
}
DWORD WINAPI AimbotThread(LPVOID lpParam)
{
	CThreadData *lpThreadData = (CThreadData*)lpParam;

	//keep a variable to copy the world data into this process
	CGameWorld lpWorldData = {};

	constexpr int iNextSwitchTimer = 200;//this is in MS 1000 = 1 second

	DWORD dwSwitchTimer = 0;

	CPlayerData* lpBestTarget = 0;

	int iRandomBoneArray[] = { EHumanBones::HumanPelvis, EHumanBones::HumanSpine1, EHumanBones::HumanNeck, EHumanBones::HumanHead, EHumanBones::HumanHead /*, EHumanBones::HumanLFoot, EHumanBones::HumanRFoot  ADD MORE HERE IF YOU WANT */ };

	srand(GetTickCount());

	//check if we are running and waiting!
	while (lpThreadData->m_bGameRunnning)
	{
		//random bone
		if (iAimbotBone == EHumanBones::BONE_MAX)
		{
			if ((GetTickCount() - dwSwitchTimer) > iNextSwitchTimer)
			{
				
				lpThreadData->m_iBone = iRandomBoneArray[RandomInt(0, ARRAYSIZE(iRandomBoneArray))];
				
				dwSwitchTimer = GetTickCount();
			}
		}
		else
		{
			//we want this bone :)
			lpThreadData->m_iBone = iAimbotBone;
		}

		if (!lpThreadData->m_lpLocalPlayerPointer && !lpThreadData->m_lpMainCameraGameObject)
			Sleep(2000);
		else
		{
			//i made the aimbot as i made mine IF the aimbot finds a target IT WILL KEEP THE LOCK ONTO THE TARGET TILL ITS DEAD OR YOU STOP PRESSING THE AIM KEY TO REMOVE THIS FUNCTION UNCOMMENT BELOW!
			//lpBestTarget = 0;

			CPlayer lpLocalData = { };
			CGClass1134 lpAimData = { };
			FVec3 vCameraPosition = FVec3();
			FVec3 vFireport = FVec3();
			if ( GetMainCameraPosition(lpThreadData->m_lpMainCameraGameObject, &vCameraPosition) && 
				DMADevice::MemRead(lpThreadData->m_lpLocalPlayerPointer, &lpLocalData, sizeof(CPlayer)) && 
				GetLocalFirepoint(&lpLocalData, &vFireport) &&
				DMADevice::MemRead(lpLocalData.m_lpMovementContext, &lpAimData, sizeof(CGClass1134)))
			{
				if (lpBestTarget == 0)
				{
					float fMaxDistance = (float)0xffffffff;
					for (int i = 0; i < lpThreadData->m_iPlayerObjectCount; i++)
					{
						CPlayerData* lpPlayerData = lpThreadData->m_lpPlayerObjects[i];
						if (lpPlayerData == 0 || lpPlayerData->m_lpPointer == 0 || lpPlayerData->m_bSameGroup || !lpPlayerData->m_bBasePositionVaild || !lpPlayerData->m_bBoneIsVaild)
							continue;

						FVec3 vForward = (FromEulerRad(FVec3(lpAimData.vector2_1.y, lpAimData.vector2_1.x, 0.0f) * 0.017453292f)) * FVec3(0.0f, 0.0f, 1.0f);
						vForward.z = -vForward.z;

						FVec3 vTDelta = (lpPlayerData->m_vBonePosition - vCameraPosition);
						FVec3 vDeltaNor = vTDelta.Normalize();
						float fFOV = vForward.GetFOV(vDeltaNor);
						if (fFOV >= 15.0f)
							continue;

						fFOV *= vTDelta.Length();
						if (fFOV < fMaxDistance)
						{
							fMaxDistance = fFOV;
							lpBestTarget = lpPlayerData;
						}
					}
				}
				bool bKeyPressed = IsKeyDown(lpThreadData, iAimbotHotkey);
				if (!bKeyPressed)
					lpBestTarget = 0;

				CPlayer bPlayer = {};
				FVec3 vBonePos = FVec3();
				if (lpBestTarget && lpBestTarget->m_lpPointer && DMADevice::MemRead(lpBestTarget->m_lpPointer,&bPlayer, sizeof(CPlayer)) && GetPlayerBonePosition(&bPlayer, lpThreadData->m_iBone, &vBonePos))
				{
					if (bKeyPressed)
					{
						FVec2 vAimbot = (vBonePos - vFireport).Normalize().ToRotator();

						SetLocalAngles(lpLocalData.m_lpWeaponAni, lpLocalData.m_lpMovementContext, vAimbot, lpAimData.vector2_1);
					}
				}


			}
		}
		Sleep(1);
	}

	return TRUE;
}
#endif
#ifdef ENABLE_AIMBOT
DWORD WINAPI PlayerThread(LPVOID lpParam)
{
	CThreadData *lpThreadData = (CThreadData*)lpParam;

	//keep a variable to copy the world data into this process
	CGameWorld lpWorldData = {};

	//before we begin! create player list so we can save pointers here
	CUnityTList<CPlayer*>* g_lpPlayers = (CUnityTList<CPlayer*>*)LocalAlloc(LMEM_ZEROINIT, (100 * sizeof(CPlayer*)) + sizeof(CUnityTList<CPlayer*>));
	if (g_lpPlayers == NULL)
		return FALSE;

	//check if we are running and waiting!
	while (lpThreadData->m_bGameRunnning)
	{
		//check if we have a pointer from the other thread!
		while (lpThreadData->m_lpMainWorldPointer)
		{
			//copy world data we dont need all we only need 1 variable but dma device reads in PAGE size so if trying to read 8 bytes your still reading 4096 bytes
			if (DMADevice::MemRead(lpThreadData->m_lpMainWorldPointer, &lpWorldData, sizeof(CGameWorld), false))
			{
				if (lpThreadData->m_lpLocalPlayerPointer)
				{
					CPlayer lpLocalPlayerData = {};
					if (DMADevice::MemRead(lpThreadData->m_lpLocalPlayerPointer, &lpLocalPlayerData, sizeof(CPlayer), false))
					{
						//and here we go!
						CUnityTList<CPlayer*> lpPlayerList = {};
						if (lpWorldData.RegisteredPlayers && DMADevice::MemRead(lpWorldData.RegisteredPlayers, &lpPlayerList, sizeof(CUnityTList<CPlayer*>), false))
						{
							if (lpPlayerList.dwSize > 0 && DMADevice::MemRead(lpPlayerList.lpList, g_lpPlayers, TLIST_SIZE(CPlayer*, lpPlayerList.dwSize), false))
							{
								CPlayer* lpBestTarget = 0;
								float fMaxDistance = 999999.0f;
								for (int i = 0; i < lpPlayerList.dwSize; i++)
								{
									CPlayer lpPlayerData = {};
									CPlayer* lpPlayerPtr = g_lpPlayers->lpListArray[i];

									lpThreadData->m_lpPlayerObjects[i]->m_lpPointer = lpPlayerPtr;
									if (!lpPlayerPtr || lpPlayerPtr == lpThreadData->m_lpLocalPlayerPointer || !DMADevice::MemRead(lpPlayerPtr, &lpPlayerData, sizeof(CPlayer), false) || !lpPlayerData.m_lpComponent)
										continue;

									CGClass1194 lpPlayerProfileInfo = {};
									CProfile lpPlayerProfileData = {};
									if (!DMADevice::MemRead(lpPlayerData.m_lpProfile, &lpPlayerProfileData, sizeof(CProfile)) ||
										!DMADevice::MemRead(lpPlayerProfileData.Info, &lpPlayerProfileInfo, sizeof(CGClass1194)))
										continue;

									lpThreadData->m_lpPlayerObjects[i]->m_bBasePositionVaild = lpPlayerData.GetPosition(&lpThreadData->m_lpPlayerObjects[i]->m_vBasePosition);
									lpThreadData->m_lpPlayerObjects[i]->m_bSameGroup = IsSameGroup(&lpLocalPlayerData, &lpPlayerProfileInfo);
									lpThreadData->m_lpPlayerObjects[i]->m_bBoneIsVaild = GetPlayerBonePosition(&lpPlayerData, lpThreadData->m_iBone, &lpThreadData->m_lpPlayerObjects[i]->m_vBonePosition);
								}
							}
							lpThreadData->m_iPlayerObjectCount = lpPlayerList.dwSize;
						}
					}
				}
			}
		}
		Sleep(100);
	}

	//free me!
	SAFE_FREE_ALLOC(g_lpPlayers);

	return TRUE;
}
#endif
DWORD WINAPI MainThread(LPVOID lpParam)
{
	CThreadData *lpThreadData = (CThreadData*)lpParam;

	//grab the hwnd from the argument!
	HWND hMainWindow = (HWND)lpThreadData->m_hDlg;

	//keep a variable to copy the world data into this process
	CGameWorld lpWorldData = {};

	//a buffer for the script data!
	CUnityMonoBehaviourScript lpWorldScriptData = {};

	//local profile id
	CUnityString lpLocalProfileId = {};

	//keep a variable for the location?
	CUnityString lpMapLocation = {};

	//a variable to know if this is interchange YOU can set this as a global variable meaning at the top of the file BUT why? its quicker and easyer this way
	bool bIsThisMapInterchange = false;

	//
	//create an endless loop
	while (lpThreadData->m_bGameRunnning)
	{
		//check to see if we have connected we have attached to process and we have a unityplayer base address else we have not fully set up and we shouldnt be reading / writing memory till its done!
		if (DMADevice::bConnected && DMADevice::dwAttachedProcessId && DMADevice::dwUnityPlayerBaseAddress)
		{
			//clear the buffer for new world data
			ZeroMemory(&lpWorldData, sizeof(CGameWorld));

			lpThreadData->m_lpMainWorldPointer = 0;

			if (lpThreadData->m_dwInputManager == 0)
				lpThreadData->m_dwInputManager = DMADevice::MemReadPtr<DWORD64>(DMADevice::dwUnityPlayerBaseAddress + INPUT_MANAGER);

			//first things first! get a game world pointer before anything else!
			CGameWorld *lpMainWorldPointer = NULL;
			while (lpMainWorldPointer == NULL)
			{
				//grab the world pointer and the data from the struct so we dont need to process more reads then required
				lpMainWorldPointer = GetGameWorld(&lpWorldData);

				//check if we have a pointer
				if (lpMainWorldPointer != NULL)
				{
					//break out of the (lpMainWorldPointer == NULL) loop and continue on the MAIN loop!
					lpThreadData->m_lpMainWorldPointer = lpMainWorldPointer;

					//let the world know we found the world ;) lol!
					bWorldPointerFound = true;
					
					//set the dlg item text
					SetDlgItemTextA(hMainWindow, IDC_WORLD_STATUS, "Found");
					break;
				}
				//refresh ALL data meaning all memory cache etc we dont need to but meh i like to
				VMMDLL_ConfigSet(VMMDLL_OPT_REFRESH_ALL, TRUE);

				//sleep for 2 seconds we dont need to see if we are in game every 100ms 2 seconds is enough?
				Sleep(2000);
			}

			//Clean out buffer from these variables so we can use them
			ZeroMemory(&lpWorldScriptData,sizeof(CUnityMonoBehaviourScript));
			ZeroMemory(&lpLocalProfileId, sizeof(CUnityString));
			ZeroMemory(&lpMapLocation, sizeof(CUnityString));

			//set to false because why not?
			bIsThisMapInterchange = false;

			//string_0 is the location id if this is NULL then it means your offline or in hideout :)
			if (lpWorldData.string_0 && DMADevice::MemReadUnityString(lpWorldData.string_0, &lpMapLocation))
			{
				//loop the ammount of map names we have
				for (int i = 0; i < ARRAYSIZE(szEFTMapNames); i++)
				{
					//compare the map names
					if (lpMapLocation == szEFTMapNames[i])
					{
						//now set the REAL map name
						SetDlgItemTextW(hMainWindow, IDC_STATUS_LOCATION, szMapNames[i]);

						//interchange map id is 5
						bIsThisMapInterchange = (i == 5);

						//break the loop so we dont need to continue as waste of cpu :)
						break;
					}
				}
			}
			else
			{
				//we cant grab the god damn name because offline raid eft dont like to save the location but hey! just use offline raid we dont need it
				SetDlgItemTextW(hMainWindow, IDC_STATUS_LOCATION, L"Offline Raid");
			}

			//we make ANOTHER endless loop as we now have a world pointer and we can now read memory
			while (1)
			{
				//it dont have to read this but update always needed!
				DMADevice::MemRead(lpMainWorldPointer, &lpWorldScriptData, sizeof(CUnityMonoBehaviourScript));

				//every world needs a component
				//no component so break the while loop?
				if (!lpWorldScriptData.m_lpComponent)
				{
					lpThreadData->m_lpMainWorldPointer = 0;

					lpMainWorldPointer = NULL;

					//let the world know we found the world ;) lol!
					bWorldPointerFound = false;

					//set the dlg item text
					SetDlgItemTextA(hMainWindow, IDC_WORLD_STATUS, "Not Found");
					break;
				}
				//grab our local player id(this should only be done ONCE! profile id dont change?)
				if (lpLocalProfileId.dwStringSize == 0 && !DMADevice::MemReadUnityString(lpWorldData.CurrentProfileId, &lpLocalProfileId))
					continue;

				//grab main camera
				if (lpThreadData->m_lpMainCameraGameObject == 0)
					lpThreadData->m_lpMainCameraGameObject = GetMainCamera();

				//we have everything now!

				//first lets do the camera shit
				Camera_Hack_Effects(lpThreadData->m_lpMainCameraGameObject);

				//get the local player from the world data
				CPlayer *lpLocalPlayer = GetLocalPlayer(&lpWorldData, &lpLocalProfileId);

				//update local player ALWAYS!
				lpThreadData->m_lpLocalPlayerPointer = lpLocalPlayer;

				//check it
				if (lpLocalPlayer)
				{
					//we should be false? just saves keep setting it!
					if (!bLocalPlayerTextSet)
					{
						//set the flags or bool!
						bLocalPlayerFound = true;

						//set the dlg item text
						SetDlgItemTextA(hMainWindow, IDC_PLAYER_STATUS, "Alive / Found");

						//set it to true so we dont keep setting the text or the flags!
						bLocalPlayerTextSet = true;
					}

					//now do all other hacks
					LocalPlayerHacks(lpLocalPlayer, bIsThisMapInterchange);
				}

				//we always need to sleep inside a thread when doing a while loop AKA endless loop because if you leave a thread running none stop at 99% or 100% load time you will have a high CPU usage :(
				Sleep(30);
			}

			//set the local pointer to null now!
			lpThreadData->m_lpLocalPlayerPointer = 0;

			//main camera should be null?
			lpThreadData->m_lpMainCameraGameObject = 0;

			//reset this so we can set the text!
			bLocalPlayerTextSet = false;

			//set the flags
			bLocalPlayerFound = false;

			//set the dlg item text
			SetDlgItemTextA(hMainWindow, IDC_PLAYER_STATUS, "Dead / Not Found");

			//we have broken the loop due to no world has been found OR the world has been deleted so we post a message to the dlg to say disconnect IF auto disconnect is enabled!
			if (bAutoDisconnectAfterRaidEnds)
			{
				//now post a message to tell the device to disconnect!
				PostMessageA(hMainWindow, WM_COMMAND, MAKEWPARAM(ID_BTN_DMA_SHUTDOWN, 0) , NULL);
			}

		}

		//we always need to sleep inside a thread when doing a while loop AKA endless loop because if you leave a thread running none stop at 99% or 100% load time you will have a high CPU usage :(
		Sleep(10);
	}

	//it dont matter what you return on your own threads there is a winapi function GetThreadExitCode which is what you use if thread has issues creating etc but we dont need to worry do we?
	return TRUE;
}
```

`MainThread.h`:

```h
#pragma once
#include <atomic>

struct CPlayerData
{
	bool m_bSameGroup : 1;
	bool m_bBasePositionVaild : 1;
	bool m_bBoneIsVaild : 1;

	CPlayer* m_lpPointer;

	FVec3 m_vBonePosition;
	FVec3 m_vBasePosition;
};

struct CThreadData
{
	BOOL m_bGameRunnning;

	HWND m_hDlg;

	std::atomic<int> m_iBone;

	CPlayer* m_lpLocalPlayerPointer;
	CGameWorld *m_lpMainWorldPointer;
	CUnityGameObject* m_lpMainCameraGameObject;

	int m_iPlayerObjectCount;
	CPlayerData** m_lpPlayerObjects;

	DWORD64 m_dwInputManager;
};

extern DWORD WINAPI MainThread(LPVOID lpParam);
extern DWORD WINAPI PlayerThread(LPVOID lpParam);
extern DWORD WINAPI AimbotThread(LPVOID lpParam);
```

`MonoClasses.cpp`:

```cpp
#include "globals.h"



CUnityKeyCodes unityKC[] =
{
	{ KC_None,L"" },
	{ KC_Mouse0,L"L.M.Button" },
	{ KC_Mouse1,L"R.M.Button" },
	{ KC_Break,L"Break" },
	{ KC_Mouse2,L"M.M.Button" },
	{ KC_Mouse3,L"X1.Button" },
	{ KC_Mouse4,L"X2.Button" },
	{ KC_None,L"" },
	{ KC_Backspace,L"Backspace" },
	{ KC_Tab,L"Tab" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_Clear,L"Clear" },
	{ KC_Return,L"Enter" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_Shift,L"Shift" },//0x10
	{ KC_Control,L"Control" },
	{ KC_Menu,L"Menu" },
	{ KC_Pause,L"Pause" },
	{ KC_CapsLock,L"Caps Lock" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_Escape,L"Escape" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_Space,L"Space" },//0x20
	{ KC_PageUp,L"Page Up" },
	{ KC_PageDown,L"Page Down" },
	{ KC_End,L"End" },
	{ KC_Home,L"Home" },
	{ KC_LeftArrow,L"Left" },
	{ KC_UpArrow,L"Up" },
	{ KC_RightArrow,L"Right" },
	{ KC_DownArrow,L"Down" },
	{ KC_None,L"" },//Select
	{ KC_Print,L"Print" },
	{ KC_None,L"" },//Execute
	{ KC_None,L"" },//Print screen -- cant use unity dont support it
	{ KC_Insert,L"Insert" },
	{ KC_Delete,L"Delete" },
	{ KC_Help,L"Help" },
	{ KC_Alpha0,L"0" },//0x30
	{ KC_Alpha1,L"1" },
	{ KC_Alpha2,L"2" },
	{ KC_Alpha3,L"3" },
	{ KC_Alpha4,L"4" },
	{ KC_Alpha5,L"5" },
	{ KC_Alpha6,L"6" },
	{ KC_Alpha7,L"7" },
	{ KC_Alpha8,L"8" },
	{ KC_Alpha9,L"9" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },//0x40
	{ KC_A,L"A" },
	{ KC_B,L"B" },
	{ KC_C,L"C" },
	{ KC_D,L"D" },
	{ KC_E,L"E" },
	{ KC_F,L"F" },
	{ KC_G,L"G" },
	{ KC_H,L"H" },
	{ KC_I,L"I" },
	{ KC_J,L"J" },
	{ KC_K,L"K" },
	{ KC_L,L"L" },
	{ KC_M,L"M" },
	{ KC_N,L"N" },
	{ KC_O,L"O" },
	{ KC_P,L"P" },//0x50
	{ KC_Q,L"Q" },
	{ KC_R,L"R" },
	{ KC_S,L"S" },
	{ KC_T,L"T" },
	{ KC_U,L"U" },
	{ KC_V,L"V" },
	{ KC_W,L"W" },
	{ KC_X,L"X" },
	{ KC_Y,L"Y" },
	{ KC_Z,L"Z" },
	{ KC_LeftWindows,L"L.Windows" },
	{ KC_RightWindows,L"R.Windows" },
	{ KC_None,L"" },//Applications 
	{ KC_None,L"" },
	{ KC_None,L"" },//Sleep
	{ KC_Keypad0,L"Numpad 0" },//0x60
	{ KC_Keypad1,L"Numpad 1" },
	{ KC_Keypad2,L"Numpad 2" },
	{ KC_Keypad3,L"Numpad 3" },
	{ KC_Keypad4,L"Numpad 4" },
	{ KC_Keypad5,L"Numpad 5" },
	{ KC_Keypad6,L"Numpad 6" },
	{ KC_Keypad7,L"Numpad 7" },
	{ KC_Keypad8,L"Numpad 8" },
	{ KC_Keypad9,L"Numpad 9" },
	{ KC_KeypadMultiply,L"*" },
	{ KC_KeypadPlus,L"+" },
	{ KC_None,L"" },//Separator
	{ KC_KeypadMinus,L"-" },
	{ KC_KeypadPeriod,L"." },
	{ KC_KeypadDivide,L"/" },
	{ KC_F1,L"F1" },//0x70
	{ KC_F2,L"F2" },
	{ KC_F3,L"F3" },
	{ KC_F4,L"F4" },
	{ KC_F5,L"F5" },
	{ KC_F6,L"F6" },
	{ KC_F7,L"F7" },
	{ KC_F8,L"F8" },
	{ KC_F9,L"F9" },
	{ KC_F10,L"F10" },
	{ KC_F11,L"F11" },
	{ KC_F12,L"F12" },
	{ KC_None,L"" },//F13
	{ KC_None,L"" },//F14
	{ KC_None,L"" },//F15
	{ KC_None,L"" },//F16
	{ KC_None,L"" },//0x80
	{ KC_None,L"" },//F18
	{ KC_None,L"" },//F19
	{ KC_None,L"" },//F20
	{ KC_None,L"" },//F21
	{ KC_None,L"" },//F22
	{ KC_None,L"" },//F23
	{ KC_None,L"" },//F24
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_Numlock,L"Num Lock" },//0x90
	{ KC_ScrollLock,L"Scroll Lock" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_LeftShift,L"L.Shift" },//0xA0
	{ KC_RightShift,L"R.Shift" },
	{ KC_LeftControl,L"L.Control" },
	{ KC_RightControl,L"R.Control" },
	{ KC_LeftAlt,L"L.Alt" },
	{ KC_RightAlt,L"R.Alt" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_Semicolon,L";" },
	{ KC_Equals,L"=" },
	{ KC_Comma,L"," },
	{ KC_Minus,L"-" },
	{ KC_Period,L"." },
	{ KC_Slash,L"/" },
	{ KC_Quote,L"'" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_None,L"" },
	{ KC_LeftBracket,L"[" },
	{ KC_Pipe,L"|" },
	{ KC_RightBracket,L"]" },
	{ KC_Hash,L"#" },
	{ KC_BackQuote,L"`" },
};

//list of skill names
wchar_t *szSkillNames[Skills_Max] =
{
	L"Endurance",
	L"Strength",
	L"Vitality",
	L"Health",
	L"Stress Resistance",
	L"Metabolism",
	L"Immunity",
	L"Perception",
	L"Intellect",
	L"Attention",
	L"Charisma",
	L"Memory",
	L"Mag Drills",
	L"Pistol",
	L"Revolver",
	L"SMG",
	L"Assault",
	L"Shotgun",
	L"Sniper",
	L"LMG",
	L"HMG",
	L"Launcher",
	L"Attached Launcher",
	L"Throwing",
	L"Misc",
	L"Melee",
	L"DMR",
	L"Draw Master",
	L"Aim Master",
	L"Recoil Control",
	L"Trouble Shooting",
	L"Sniping",
	L"Covert Movement",
	L"Prone Movement",
	L"First Aid",
	L"Field Medicine",
	L"Surgery",
	L"Light Vests",
	L"Heavy Vests",
	L"Weapon Modding",
	L"Advanced Modding",
	L"NightOps",
	L"SilentOps",
	L"Lock Picking",
	L"Search",
	L"Weapon Treatment",
	L"Free Trading",
	L"Auctions",
	L"Clean Operations",
	L"Barter",
	L"Shadow Connections",
	L"Task Performance",
	L"Bear Assault Operations",
	L"Bear Authority",
	L"Bear AK Systems",
	L"Bear Heavy Caliber",
	L"Bear Raw Power",
	L"USEC AR Systems",
	L"USEC Deep Weapon Modding",
	L"USEC Long Range Optics",
	L"USEC Negotiations",
	L"USEC Tactics",
	L"Bot Reload",
	L"Bot Sound",
	L"Aim Drills",
	L"Hideout Management",
	L"Crafting"
};
class Matrix34
{
public:
	FVec4 vec0;
	FVec4 vec1;
	FVec4 vec2;

	Matrix34()
	{
	}
};
struct TransformAccessReadOnly
{
	ULONGLONG	pTransformData;
	int			index;
};
struct TransformData
{
	char _0x0000[0x18];			//0x0000
	ULONGLONG pTransformArray;	//0x0018
	ULONGLONG pTransformIndices;//0x0020
};//0x0028
const char *CUnityGameObject::GetObjectName(char *szOutput, size_t nSize)
{
	return (DMADevice::MemRead((DWORD64)((DWORD64)this + 0x60), szOutput, nSize)) ? szOutput : 0;
}
bool CUnityGameObject::IsObject(char *szObjectName)
{
	char szOutput[65] = { 0 };
	return (GetObjectName(szOutput) && strcmp(szOutput, szObjectName) == 0);
}
CUnityGameObject *CCamera::GetGameObject()
{
	return DMADevice::MemReadPtr<CUnityGameObject*>((DWORD_PTR)this + 0x30);
}
void *CUnityMonoBehaviourScript::GetComonent(char* szName)
{
	if (!this->m_lpComponent)
		return 0;

	CUnityMonoBehaviour lpMonoBehaviour = {};
	if (!DMADevice::MemRead(this->m_lpComponent, &lpMonoBehaviour, sizeof(CUnityMonoBehaviour)) || !lpMonoBehaviour.m_lpKlass)
		return 0;

	CUnityGameObject lpUnityGameObject = {};
	if (!DMADevice::MemRead(lpMonoBehaviour.m_lpKlass, &lpUnityGameObject, sizeof(CUnityGameObject)))
		return 0;

	return lpUnityGameObject.m_aComponents.GetByName(szName);
}
bool CMonoTransform::GetPosition(FVec3* vOutput)
{
	TransformData tfd = {};
	TransformAccessReadOnly tro = {};
	CMonoTransform lpTransformData = {};
	if (!DMADevice::MemRead(this, &lpTransformData, sizeof(CMonoTransform)) || !DMADevice::MemRead(lpTransformData.dwKlass + offsetof(CMonoTransform, dwMain), &tro, sizeof(TransformAccessReadOnly)) || !DMADevice::MemRead(tro.pTransformData, &tfd, sizeof(TransformData)))
		return false;

	int iIndex = tro.index;
	int* dwIndex = new int[iIndex + 1];
	Matrix34* matrix34 = new Matrix34[iIndex + 1];
	if (!dwIndex || !matrix34 || !DMADevice::MemRead(tfd.pTransformArray, matrix34, sizeof(Matrix34) * (iIndex + 1)) || !DMADevice::MemRead(tfd.pTransformIndices, dwIndex, sizeof(int) * (iIndex + 1)))
	{
		SAFE_DELETE_ARRAY(dwIndex);
		SAFE_DELETE_ARRAY(matrix34);
		return false;
	}

	const __m128 mulVec1 = { -2.000, -2.000, 2.000, 0.000 };
	const __m128 mulVec2 = { -2.000, 2.000, -2.000, 0.000 };
	const __m128 mulVec3 = { 2.000, -2.000, -2.000, 0.000 };
	int iCurrentIndex = dwIndex[iIndex];
	__m128 result = *(__m128*) & matrix34[iIndex].vec0;
	while (iCurrentIndex >= 0)
	{
		__m128 v10 = _mm_mul_ps(*(__m128*) & matrix34[iCurrentIndex].vec2, result);
		__m128 v11 = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34[iCurrentIndex].vec1), 0x00));
		__m128 v12 = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34[iCurrentIndex].vec1), 0x71));
		__m128 v13 = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34[iCurrentIndex].vec1), 0x8E));
		__m128 v14 = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34[iCurrentIndex].vec1), 0x55));
		__m128 v15 = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34[iCurrentIndex].vec1), 0xAA));
		__m128 v16 = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34[iCurrentIndex].vec1), 0xDB));
		__m128 var1 = _mm_mul_ps(_mm_sub_ps(_mm_mul_ps(_mm_mul_ps(v11, (__m128)mulVec3), v13), _mm_mul_ps(_mm_mul_ps(v14, (__m128)mulVec1), v16)), _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), -86)));
		__m128 var2 = _mm_mul_ps(_mm_sub_ps(_mm_mul_ps(_mm_mul_ps(v15, (__m128)mulVec1), v16), _mm_mul_ps(_mm_mul_ps(v11, (__m128)mulVec2), v12)), _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 85)));
		__m128 var3 = _mm_mul_ps(_mm_sub_ps(_mm_mul_ps(_mm_mul_ps(v14, (__m128)mulVec2), v12), _mm_mul_ps(_mm_mul_ps(v15, (__m128)mulVec3), v13)), _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 0)));
		result = _mm_add_ps(_mm_add_ps(_mm_add_ps(var1, var2), _mm_add_ps(var3, v10)), *(__m128*)(&matrix34[iCurrentIndex].vec0));
		iCurrentIndex = dwIndex[iCurrentIndex];
	}
	SAFE_DELETE_ARRAY(dwIndex);
	SAFE_DELETE_ARRAY(matrix34);
	*vOutput = FVec3(result.m128_f32[0], result.m128_f32[1], result.m128_f32[2]);
	return true;
}
bool CBifacialTransform::GetPosition(FVec3 *vOutput)
{
	if (_accumulatePositionAndRotation)
	{
		if (vOutput)
			*vOutput = _accumulatedPosition;
		return true;
	}
	if (__useImitation && uFunc__positionImitator)
	{
		//we cant use this :(
		return false;
	}

	if (_Transform)
	{
		CMonoTransform lpTransform = {};
		if (DMADevice::MemRead(this->_Transform, &lpTransform, sizeof(CMonoTransform), false))
			return this->_Transform->GetPosition(vOutput);
		return false;
	}
	return false;
}
CMonoTransform* CUnityMonoBehaviourScript::GetTransform()
{
	CUnityMonoBehaviour lpMonoBehaviour = {};
	CUnityGameObject lpUnityGameObject = {};
	if (!DMADevice::MemRead(this->m_lpComponent, &lpMonoBehaviour, sizeof(CUnityMonoBehaviour)) || !DMADevice::MemRead(lpMonoBehaviour.m_lpKlass, &lpUnityGameObject, sizeof(CUnityGameObject)))
		return 0;

	return lpUnityGameObject.m_aComponents.GetTransform();
}
bool CUnityMonoBehaviourScript::GetPosition(FVec3* vOutput)
{
	CMonoTransform* lpTransform = (CMonoTransform*)this->GetTransform();
	if (lpTransform == 0)
		return false;

	return lpTransform->GetPosition(vOutput);
}
```

`MonoClasses.h`:

```h
#pragma once
#include <math.h>

#define CLASS_MonoBehaviour 68	//0x44
#define CLASS_MonoTransform 120	//0x80

extern wchar_t *szSkillNames[];

enum KeyCode
{
	KC_None,
	KC_Backspace = 8,
	KC_Delete = 127,
	KC_Tab = 9,
	KC_Clear = 12,
	KC_Return,
	KC_Pause = 19,
	KC_Escape = 27,
	KC_Space = 32,
	KC_Keypad0 = 256,
	KC_Keypad1,
	KC_Keypad2,
	KC_Keypad3,
	KC_Keypad4,
	KC_Keypad5,
	KC_Keypad6,
	KC_Keypad7,
	KC_Keypad8,
	KC_Keypad9,
	KC_KeypadPeriod,
	KC_KeypadDivide,
	KC_KeypadMultiply,
	KC_KeypadMinus,
	KC_KeypadPlus,
	KC_KeypadEnter,
	KC_KeypadEquals,
	KC_UpArrow,
	KC_DownArrow,
	KC_RightArrow,
	KC_LeftArrow,
	KC_Insert,
	KC_Home,
	KC_End,
	KC_PageUp,
	KC_PageDown,
	KC_F1,
	KC_F2,
	KC_F3,
	KC_F4,
	KC_F5,
	KC_F6,
	KC_F7,
	KC_F8,
	KC_F9,
	KC_F10,
	KC_F11,
	KC_F12,
	KC_F13,
	KC_F14,
	KC_F15,
	KC_Alpha0 = 48,
	KC_Alpha1,
	KC_Alpha2,
	KC_Alpha3,
	KC_Alpha4,
	KC_Alpha5,
	KC_Alpha6,
	KC_Alpha7,
	KC_Alpha8,
	KC_Alpha9,
	KC_Exclaim = 33,
	KC_DoubleQuote,
	KC_Hash,
	KC_Dollar,
	KC_Percent,
	KC_Ampersand,
	KC_Quote,
	KC_LeftParen,
	KC_RightParen,
	KC_Asterisk,
	KC_Plus,
	KC_Comma,
	KC_Minus,
	KC_Period,
	KC_Slash,
	KC_Colon = 58,
	KC_Semicolon,
	KC_Less,
	KC_Equals,
	KC_Greater,
	KC_Question,
	KC_At,
	KC_LeftBracket = 91,
	KC_Backslash,
	KC_RightBracket,
	KC_Caret,
	KC_Underscore,
	KC_BackQuote,
	KC_A,
	KC_B,
	KC_C,
	KC_D,
	KC_E,
	KC_F,
	KC_G,
	KC_H,
	KC_I,
	KC_J,
	KC_K,
	KC_L,
	KC_M,
	KC_N,
	KC_O,
	KC_P,
	KC_Q,
	KC_R,
	KC_S,
	KC_T,
	KC_U,
	KC_V,
	KC_W,
	KC_X,
	KC_Y,
	KC_Z,
	KC_LeftCurlyBracket,
	KC_Pipe,
	KC_RightCurlyBracket,
	KC_Tilde,
	KC_Numlock = 300,
	KC_CapsLock,
	KC_ScrollLock,
	KC_RightShift,
	KC_LeftShift,
	KC_RightControl,
	KC_LeftControl,
	KC_RightAlt,
	KC_LeftAlt,
	KC_LeftCommand = 310,
	KC_LeftApple = 310,
	KC_LeftWindows,
	KC_RightCommand = 309,
	KC_RightApple = 309,
	KC_RightWindows = 312,
	KC_AltGr,
	KC_Help = 315,
	KC_Print,
	KC_SysReq,
	KC_Break,
	KC_Menu,
	KC_Mouse0 = 323,
	KC_Mouse1,
	KC_Mouse2,
	KC_Mouse3,
	KC_Mouse4,
	KC_Mouse5,
	KC_Mouse6,
	KC_Shift = (KC_RightShift | KC_LeftShift),
	KC_Control = (KC_RightControl | KC_LeftControl)
};

struct CUnityKeyCodes
{
	KeyCode kc;
	wchar_t *KeyName;
};

extern CUnityKeyCodes unityKC[];

enum EHumanBones
{
	Empty = 0,
	IKController,
	Mesh,
	Vest_0,
	Vest_1,
	backpack,
	backpack_0,
	backpack_1,
	backpack_2,
	razgruz,
	razgruz_0,
	razgruz_1,
	razgruz_2,
	Root_Joint,
	HumanPelvis,
	HumanLThigh1,
	HumanLThigh2,
	HumanLCalf,
	HumanLFoot,
	HumanLToe,
	HumanRThigh1,
	HumanRThigh2,
	HumanRCalf,
	HumanRFoot,
	HumanRToe,
	Bear_Feet,
	USEC_Feet,
	BEAR_feet_1,
	weapon_holster_pistol,
	HumanSpine1,
	HumanGear1,
	HumanGear2,
	HumanGear3,
	HumanGear4,
	HumanGear4_1,
	HumanGear5,
	HumanSpine2,
	HumanSpine3,
	IK_S_LForearm1,
	IK_S_LForearm2,
	IK_S_LForearm3,
	IK_S_LPalm,
	IK_S_LDigit11,
	IK_S_LDigit12,
	IK_S_LDigit13,
	IK_S_LDigit21,
	IK_S_LDigit22,
	IK_S_LDigit23,
	IK_S_LDigit31,
	IK_S_LDigit32,
	IK_S_LDigit33,
	IK_S_LDigit41,
	IK_S_LDigit42,
	IK_S_LDigit43,
	IK_S_LDigit51,
	IK_S_LDigit52,
	IK_S_LDigit53,
	XYZ,
	LCollarbone_anim,
	RCollarbone_anim,
	RCollarbone_anim_XYZ,
	Weapon_root_3rd_anim,
	Weapon_root_3rd_anim_XYZ_1,
	Bend_Goal_Left,
	Bend_Goal_Right,
	Bend_Goal_Right_XYZ_1,
	HumanRibcage,
	IK_LForearm1,
	IK_LForearm2,
	IK_LForearm3,
	IK_LPalm,
	IK_LDigit11,
	IK_LDigit12,
	IK_LDigit13,
	IK_LDigit21,
	IK_LDigit22,
	IK_LDigit23,
	IK_LDigit31,
	IK_LDigit32,
	IK_LDigit33,
	IK_LDigit41,
	IK_LDigit42,
	IK_LDigit43,
	IK_LDigit51,
	IK_LDigit52,
	IK_LDigit53,
	Camera_animated,
	CameraContainer,
	Cam,
	HumanLCollarbone,
	HumanLUpperarm,
	HumanLForearm1,
	HumanLForearm2,
	HumanLForearm3,
	HumanLPalm,
	HumanLDigit11,
	HumanLDigit12,
	HumanLDigit13,
	HumanLDigit21,
	HumanLDigit22,
	HumanLDigit23,
	HumanLDigit31,
	HumanLDigit32,
	HumanLDigit33,
	HumanLDigit41,
	HumanLDigit42,
	HumanLDigit43,
	HumanLDigit51,
	HumanLDigit52,
	HumanLDigit53,
	HumanRCollarbone,
	HumanRUpperarm,
	HumanRForearm1,
	HumanRForearm2,
	HumanRForearm3,
	HumanRPalm,
	HumanRDigit11,
	HumanRDigit12,
	HumanRDigit13,
	HumanRDigit21,
	HumanRDigit22,
	HumanRDigit23,
	HumanRDigit31,
	HumanRDigit32,
	HumanRDigit33,
	HumanRDigit41,
	HumanRDigit42,
	HumanRDigit43,
	HumanRDigit51,
	HumanRDigit52,
	HumanRDigit53,
	Weapon_root,
	HumanNeck,
	HumanHead,
	HumanBackpack,
	weapon_holster,
	weapon_holster1,
	Camera_animated_3rd,
	BONE_MAX
};

enum CEProceduralAnimationMask
{
	Breathing = 1,//0x000000[0x000004]
	Walking = 2,//0x000000[0x000004]
	MotionReaction = 4,//0x000000[0x000004]
	ForceReaction = 8,//0x000000[0x000004]
	Shooting = 16,//0x000000[0x000004]
	DrawDown = 32,//0x000000[0x000004]
	Aiming = 64,//0x000000[0x000004]
};
enum CEDoorState : BYTE
{
	DS_Locked = 1,//0x000000[0x000001]
	DS_Shut = 2,//0x000000[0x000001]
	DS_Open = 4,//0x000000[0x000001]
	DS_Interacting = 8,//0x000000[0x000001]
	DS_Breaching = 16,//0x000000[0x000001]
};
enum CESkillId : BYTE
{
	Endurance = 0,//0x000000[0x000001]
	Strength = 1,//0x000000[0x000001]
	Vitality = 2,//0x000000[0x000001]
	Health = 3,//0x000000[0x000001]
	StressResistance = 4,//0x000000[0x000001]
	Metabolism = 5,//0x000000[0x000001]
	Immunity = 6,//0x000000[0x000001]
	Perception = 7,//0x000000[0x000001]
	Intellect = 8,//0x000000[0x000001]
	Attention = 9,//0x000000[0x000001]
	Charisma = 10,//0x000000[0x000001]
	Memory = 11,//0x000000[0x000001]
	MagDrills = 12,//0x000000[0x000001]
	Pistol = 13,//0x000000[0x000001]
	Revolver = 14,//0x000000[0x000001]
	SMG = 15,//0x000000[0x000001]
	Assault = 16,//0x000000[0x000001]
	Shotgun = 17,//0x000000[0x000001]
	Sniper = 18,//0x000000[0x000001]
	LMG = 19,//0x000000[0x000001]
	HMG = 20,//0x000000[0x000001]
	Launcher = 21,//0x000000[0x000001]
	AttachedLauncher = 22,//0x000000[0x000001]
	Throwing = 23,//0x000000[0x000001]
	Misc = 24,//0x000000[0x000001]
	Melee = 25,//0x000000[0x000001]
	DMR = 26,//0x000000[0x000001]
	DrawMaster = 27,//0x000000[0x000001]
	AimMaster = 28,//0x000000[0x000001]
	RecoilControl = 29,//0x000000[0x000001]
	TroubleShooting = 30,//0x000000[0x000001]
	Sniping = 31,//0x000000[0x000001]
	CovertMovement = 32,//0x000000[0x000001]
	ProneMovement = 33,//0x000000[0x000001]
	FirstAid = 34,//0x000000[0x000001]
	FieldMedicine = 35,//0x000000[0x000001]
	Surgery = 36,//0x000000[0x000001]
	LightVests = 37,//0x000000[0x000001]
	HeavyVests = 38,//0x000000[0x000001]
	WeaponModding = 39,//0x000000[0x000001]
	AdvancedModding = 40,//0x000000[0x000001]
	NightOps = 41,//0x000000[0x000001]
	SilentOps = 42,//0x000000[0x000001]
	Lockpicking = 43,//0x000000[0x000001]
	Search = 44,//0x000000[0x000001]
	WeaponTreatment = 45,//0x000000[0x000001]
	Freetrading = 46,//0x000000[0x000001]
	Auctions = 47,//0x000000[0x000001]
	Cleanoperations = 48,//0x000000[0x000001]
	Barter = 49,//0x000000[0x000001]
	Shadowconnections = 50,//0x000000[0x000001]
	Taskperformance = 51,//0x000000[0x000001]
	BearAssaultoperations = 52,//0x000000[0x000001]
	BearAuthority = 53,//0x000000[0x000001]
	BearAksystems = 54,//0x000000[0x000001]
	BearHeavycaliber = 55,//0x000000[0x000001]
	BearRawpower = 56,//0x000000[0x000001]
	UsecArsystems = 57,//0x000000[0x000001]
	UsecDeepweaponmodding = 58,//0x000000[0x000001]
	UsecLongrangeoptics = 59,//0x000000[0x000001]
	UsecNegotiations = 60,//0x000000[0x000001]
	UsecTactics = 61,//0x000000[0x000001]
	BotReload = 62,//0x000000[0x000001]
	BotSound = 63,//0x000000[0x000001]
	AimDrills = 64,//0x000000[0x000001]
	HideoutManagement = 65,//0x000000[0x000001]
	Crafting = 66,//0x000000[0x000001]
	Skills_Max = 67
};
enum CESkillClass
{
	Physical = 0,//0x000000[0x000004]
	Combat = 1,//0x000000[0x000004]
	Special = 2,//0x000000[0x000004]
	Practical = 3,//0x000000[0x000004]
	Mental = 4,//0x000000[0x000004]
};


static bool FindInCharArray(char *szClassNames, const char *szToFind)
{
	char *szFoundClass = strchr(szClassNames, ',');
	if (szFoundClass == 0)
		return _stricmp(szClassNames, (char*)szToFind) == 0;

	char *szHaystack = szClassNames;
	while (1)
	{
		char *szNeedle = strchr(szHaystack, ',');
		if (szNeedle == 0)
			return (_stricmp(szHaystack, (char*)szToFind) == 0);

		if (strncmp(szHaystack, (char*)szToFind, (size_t)(szNeedle - szHaystack)) == 0)
			return true;

		szHaystack = szNeedle + 1;
	}
	return false;
}

inline float Clamp(float value, float min, float max)
{
	if (value < min)
		value = min;
	else if (value > max)
		value = max;
	return value;
}
inline float ClampAngle(float angle, float min, float max)
{
	if (angle < -360.0f)
	{
		angle += 360.0f;
	}
	if (angle > 360.0f)
	{
		angle -= 360.0f;
	}
	return Clamp(angle, min, max);
}
inline float ClampAngle360Sensitive(float angle, float min, float max)
{
	if (angle < -360.0f)
	{
		angle += 360.0f;
	}
	if (angle > 360.0f)
	{
		angle -= 360.0f;
	}
	float num = (angle > 0.0f) ? (angle - 360.0f) : (angle + 360.0f);
	if (num > min && num < max)
	{
		return angle;
	}
	return Clamp(angle, min, max);
}


class FVec3;

class FVec2
{
public:
	float x, y;

	FVec2()
	{
		x = y = 0.0f;
	}
	FVec2(float xx, float yy)
	{
		x = xx;
		y = yy;
	}
	FVec2 operator / (float v)
	{
		return FVec2(x / v, y / v);
	}
	inline FVec2 operator-(const FVec2& v)
	{
		FVec2 res;
		res.x = x - v.x;
		res.y = y - v.y;
		return res;
	}
	inline FVec2 operator / (const FVec2& v)
	{
		FVec2 res;
		res.x = x / v.x;
		res.y = y / v.y;
		return res;
	}
	inline FVec3 ForwardVector();

	FVec2 NormalizeAngles()
	{
		while (x > 89.0f)
			x -= 180.0f;
		while (x < -89.0f)
			x += 180.0f;

		while (y > 180.0f)
			y -= 360.0f;
		while (y < -180.0f)
			y += 360.0f;
		return (*this);
	}
};

class FVec3
{
public:
	float x, y, z;

	FVec3()
	{
		x = y = z = 0.0f;
	}
	FVec3(float xx, float yy, float zz)
	{
		x = xx;
		y = yy;
		z = zz;
	}

	FVec3 operator * (float v)
	{
		return FVec3(x * v, y * v, z * v);
	}

	inline float Dot(const float v)
	{
		return (x * v + y * v + z * v);
	}
	inline float Dot(const FVec3& v)
	{
		return (x * v.x + y * v.y + z * v.z); //4 1547 ‭
	}
	inline FVec3 operator-(const FVec3& v)
	{
		FVec3 res;
		res.x = x - v.x;
		res.y = y - v.y;
		res.z = z - v.z;
		return res;
	}
	
	//static float Angle(FVec3 from, FVec3 to)
	//{
	//	float denominator = (float)sqrt(from.LengthSqt() * to.LengthSqt());
	//	if (denominator < kEpsilonNormalSqrt)
	//		return 0.0f;

	//	float dot = Clamp(from.Dot(to) / denominator, -1.0f, 1.0f);
	//	return ((float)acosf(dot)) * 57.295779513082320876798154814105f;
	//}
	inline float GetFOV(FVec3 &vDelta)
	{
		return D3DXToDegree(acosf((*this).Dot(vDelta)));
	}
	inline FVec3 Normalize()
	{
		float fMag_Inv = 1.0f / Length();
		return FVec3(x * fMag_Inv, y * fMag_Inv, z *fMag_Inv);
	}
	inline FVec2 ToRotator()
	{
		FVec2 rot;
		rot.y = (float)-D3DXToDegree(atan2f(y, (float)sqrtf(x * x + z * z)));
		rot.x = (float)D3DXToDegree(atan2f(x, z));
		if (rot.x > 180.0f)
			rot.x -= 360.0f;
		return rot;
	}
	inline float LengthSqt()
	{
		return (x * x + y * y + z * z);
	}
	float Length()
	{
		return sqrtf(LengthSqt());
	}
};
	
inline FVec3 FVec2::ForwardVector()
{
	float fCY = cosf(D3DXToRadian(x));
	float fSY = sinf(D3DXToRadian(x));
	float fCP = cosf(D3DXToRadian(y));
	float fSP = sinf(D3DXToRadian(y));

	FVec3 res;
	res.x = fSP * fCY;
	res.y = -fSY;
	res.z = fCY * fCP;
	return res;
};

class FVec4
{
public:
	float x, y, z, w;

	FVec4()
	{
		x = y = z = w = 0.0f;
	}

	FVec4(float xx, float yy, float zz, float ww)
	{
		x = xx;
		y = yy;
		z = zz;
		w = ww;
	}

	FVec3 operator *(FVec3 point)
	{
		float num = x * 2.0f;
		float num2 = y * 2.0f;
		float num3 = z * 2.0f;
		float num4 = x * num;
		float num5 = y * num2;
		float num6 = z * num3;
		float num7 = x * num2;
		float num8 = x * num3;
		float num9 = y * num3;
		float num10 = w * num;
		float num11 = w * num2;
		float num12 = w * num3;

		FVec3 result;
		result.x = (1.0f - (num5 + num6)) * point.x + (num7 - num12) * point.y + (num8 + num11) * point.z;
		result.y = (num7 + num12) * point.x + (1.0f - (num4 + num6)) * point.y + (num9 - num10) * point.z;
		result.z = (num8 - num11) * point.x + (num9 + num10) * point.y + (1.0f - (num4 + num5)) * point.z;
		return result;
	}
};

class CObject
{
public:
	char _0x0000[0x10];
};

class CMonoTransform
{
public:
	char _0x0000[0x010];				//0x0000
	DWORD_PTR dwKlass;					//0x0010
	char _0x0018[0x20];					//0x0018
	DWORD_PTR dwMain;					//0x0038

public:
	bool GetPosition(FVec3* vOutput);
};

template<typename T>class CUnityTArray
{
public:
	char _0x0000[0x18];		//0x0000
	DWORD dwSize;			//0x0018
	DWORD dwMaxSize;		//0x001C
	T lpListArray[1];		//0x0020
};
#define TARRAY_SIZE(T,xCount) sizeof(CUnityTArray<T>) + (sizeof(T) * xCount)

template<typename T, int iCounter>class CUnityTArrayCounter
{
public:
	char _0x0000[0x18];		//0x0000
	DWORD dwSize;			//0x0018
	DWORD dwMaxSize;		//0x001C
	T lpListArray[iCounter];//0x0020
};

template<typename T>class CUnityTList
{
public:
	char _0x0000[0x10];		//0x0000
	CUnityTList *lpList;	//0x0010
	DWORD dwSize;			//0x0018
	DWORD dwMaxSize;		//0x001C
	T lpListArray[1];		//0x0020
};
#define TLIST_SIZE(T,xCount) sizeof(CUnityTList<T>) + (sizeof(T) * xCount)

template<typename T, int iCounter>class CUnityTListCounter
{
public:
	char _0x0000[0x10];		//0x0000
	CUnityTList<T> *lpList;	//0x0010
	DWORD dwSize;			//0x0018
	DWORD dwMaxSize;		//0x001C
	T lpListArray[iCounter];		//0x0020
};

template<typename TKeys, typename TValues>class CUnityDictionaryValues
{
public:
	DWORD64 m_dwArrayHash;								//0x0000
	TKeys m_lpKey;										//0x0008
	TValues m_lpValue;									//0x0010
};
template<typename TKeys, typename TValues>class CUnityDictionaryList
{
public:
	char _0x0000[0x20];									//0x0000
	CUnityDictionaryValues<TKeys, TValues> m_Data[1];	//0x0020
};

template<typename TKeys, typename TValues>class CUnityDictionary
{
public:
	char _0x0000[0x18];									//0x0000
	CUnityDictionaryList<TKeys, TValues>* m_lpKeys;		//0x0018
	//CUnityDictionaryValues<TValues>* m_lpValues;		//0x0020
	char _0x0030[0x20];									//0x0028
	DWORD dwSize;										//0x0040
	DWORD dwMax;										//0x0044
	char _0x0048[0x08];									//0x0048
};

struct CUnityString
{
	DWORD64 dwVTable;													//0x0000
	DWORD64 Unknown;													//0x0008
	DWORD dwStringSize;													//0x0010
	wchar_t szString[512];												//0x0014
};
static bool operator == (CUnityString& a, CUnityString& b)
{
	return (a.dwStringSize == b.dwStringSize && wcscmp(a.szString, b.szString) == 0);
}
static bool operator == (CUnityString& a, const wchar_t* b)
{
	return (a.dwStringSize == wcslen(b) && wcscmp(a.szString, b) == 0);
}

class CUnityMonoType
{
public:
	class CMonoClass *m_lpKlass;										//0x0000
	char _0x0008[0x10];													//0x0008
	DWORD64 m_dwType;													//0x0018
};

class CUnityBaseMonoBehaviour
{
public:
	CUnityMonoType *m_lpType;											//0x0000
	char _0x0008[0x08];													//0x0008
};

template<typename T>class CUnityListElement
{
public:
	CUnityListElement<T> *m_lpPrev;
	CUnityListElement<T> *m_lpNext;
};
template<typename T>class CUnityListNode : public CUnityListElement<T>
{
public:
	T *m_lpData;
};

class CUnityObject : public CUnityListNode<class CUnityObject>
{
public:
	char _0x0018[0x10];										//0x0018
	void *m_lpScriptingObjectPointer;						//0x0028
};//Size = 0x0030

class CUnityComponent : public CUnityObject
{
public:
	class CUnityGameObject *m_lpGameObject;					//0x0030
};//Size = 0x0038

class CMonoClass
{
public:
	char _0x0000[0x30];													//0x0000
	CMonoClass *m_lpParent;												//0x0030
	char _0x0038[0x10];													//0x0038
	const char *m_szName;												//0x0048
	const char *m_szNamespace;											//0x0050
	char _0x0058[0x48];													//0x0058
	class CMethod **lpMethod;											//0x00A0
	char _0x00A8[0x54];													//0x00A8
	DWORD m_dwNumOfMethods;												//0x00FC
};

template<typename T>class CUnityPair
{
public:
	int first;
	char _0x0004[4];
	T* second;
};
template<typename T>class CUnityDynamicArray
{
public:
	CUnityPair<T> *m_lpData;			//0x0000
	int m_iLabel;						//0x0008
	char _0x000C[4];					//0x000C
	DWORD m_dwSize;						//0x0010
	char _0x0014[4];					//0x0014
	DWORD m_dwCapacity;					//0x0018
	char _0x001C[4];					//0x001C

	FORCEINLINE BOOL ReadListData(CUnityPair<T>* lpOutput)
	{
		return DMADevice::MemRead(this->m_lpData, lpOutput, sizeof(CUnityPair<T>) * m_dwSize, "List");
	}

	CMonoTransform* GetTransform()
	{
		if (m_dwSize == 0 || m_dwSize >= 100 || m_lpData == 0)
			return 0;

		CUnityPair<CMonoTransform*> lpBuffer = {};
		if (!DMADevice::MemRead(this->m_lpData, &lpBuffer, sizeof(CUnityPair<CMonoTransform*>)))
			return 0;

		CUnityMonoBehaviour monoBehaviour = {};
		if (!DMADevice::MemRead(lpBuffer.second, &monoBehaviour, sizeof(CUnityMonoBehaviour)))
			return 0;

		return (CMonoTransform*)monoBehaviour.m_lpScript;
	}

	T* operator[](int i)
	{
		if (i > m_dwSize)
			return 0;

		CUnityPair<T> lpBuffer[64] = {};
		if (!ReadListData(lpBuffer))
			return 0;

		return lpBuffer[i].second;
	}

	T* GetById(int iId)
	{
		if (m_dwSize == 0 || m_dwSize >= 1000 || m_lpData == 0)
			return 0;

		CUnityPair<T>* lpBuffer = (CUnityPair<T>*)calloc(m_dwSize, sizeof(CUnityPair<T>));
		if (!lpBuffer)
			return 0;

		if (!ReadListData(lpBuffer))
		{
			free(lpBuffer);
			return 0;
		}

		for (int i = 0; i < m_dwSize; i++)
		{
			if (lpBuffer[i].first == iId)
			{
				CUnityMonoBehaviour monoBehaviour = {};
				if (!DMADevice::MemRead(lpBuffer[i].second, &monoBehaviour, sizeof(CUnityMonoBehaviour), "List"))
					continue;

				free(lpBuffer);
				return (T*)monoBehaviour.m_lpScript;
			}
		}
		free(lpBuffer);
		return 0;
	}

	T* GetByName(char *szScriptName)
	{
		if (m_dwSize == 0 || m_dwSize >= 1000 || m_lpData == 0)
			return 0;

		CUnityPair<T>* lpBuffer = (CUnityPair<T>*)calloc(m_dwSize, sizeof(CUnityPair<T>));
		if (!lpBuffer)
			return 0;

		if (!ReadListData(lpBuffer))
		{
			free(lpBuffer);
			return 0;
		}

		for (int i = 0; i < m_dwSize; i++)
		{
			CUnityMonoBehaviour monoBehaviour = {};
			if (lpBuffer[i].first != CLASS_MonoBehaviour || !lpBuffer[i].second || !DMADevice::MemRead(lpBuffer[i].second, &monoBehaviour, sizeof(CUnityMonoBehaviour)))
				continue;

			if (!monoBehaviour.m_lpScript || !monoBehaviour.m_lpScriptCache)
				continue;

			CUnityScriptCache monoScriptCache = {};
			if (!DMADevice::MemRead(monoBehaviour.m_lpScriptCache, &monoScriptCache, sizeof(CUnityScriptCache)) || !monoScriptCache.klass)
				continue;

			char szClassName[64] = {};
			CMonoClass monoKlass = {};
			if (!DMADevice::MemRead(monoScriptCache.klass, &monoKlass, sizeof(CMonoClass)) || !monoKlass.m_szName || !DMADevice::MemRead(monoKlass.m_szName, szClassName, 64, false))
				continue;

			//printf("Name:%s\n", szClassName);
			if (FindInCharArray(szScriptName, szClassName))
			{
				free(lpBuffer);
				return (T*)monoBehaviour.m_lpScript;
			}
		}
		free(lpBuffer);
		return 0;
	}
};

class CUnityScriptCache
{
public:
	int refCount;														//0x0000
	char _0x0004[4];													//0x0004
	class CMonoClass *klass;											//0x0008
	CUnityDynamicArray<class CUnityScriptingMethodMono> methods;		//0x0010
	int scriptType;														//0x0030
};

class CUnityGameObject : public CUnityObject
{
public:
	CUnityDynamicArray<CUnityComponent> m_aComponents;		//0x0030
	char _0x0050[0x10];										//0x0050
	const char *m_szObjectName;								//0x0060
	//char _0x0068[0x10];									//0x0068

	const char *GetObjectName(char *szOutput, size_t nSize = 64);
	bool IsObject(char *szObjectName);
};

class CUnityMonoBehaviour
{
public:
	LPCVOID lpVTable;													//0x0000
	char _0x0008[0x20];													//0x0008
	CUnityMonoBehaviour *m_lpScript;									//0x0028
	CUnityGameObject *m_lpKlass;										//0x0030
	char _0x0038[0xB8];													//0x0038
	CUnityScriptCache *m_lpScriptCache;									//0x00F0
};
class CUnityMonoBehaviourScript : public CUnityBaseMonoBehaviour
{
public:
	class CUnityMonoBehaviour *m_lpComponent;			//0x0010

	void *GetComonent(char* szName);
	void *GetComonent(DWORD dwId, int *iErrorCode = 0);
	CMonoTransform* GetTransform();

	bool GetPosition(FVec3* lpOutput);
	bool GetRotation(FVec4* lpOutput);
};





class CUnityGameObjectManager
{
public:
	CUnityListElement<CUnityListNode<CUnityGameObject>> m_Tagged;
	CUnityListElement<CUnityListNode<CUnityGameObject>> m_Active;
};


template<typename T>class CGClass1103 : public CUnityBaseMonoBehaviour
{
public:
	char _0x0010[0x10];//0x0010
	DWORD Id;//0x0020
	DWORD BuffType;//0x0024
	T Value;//0x0028
};
class CGClass1097 : public CUnityBaseMonoBehaviour
{
public:
	char _0x0010[0x18];							//0x0010
	CESkillId Id;								//000028
	float Current;								//0x002C
};
class CGameWorld : public CUnityMonoBehaviourScript
{
public:
	class CGClass687* gclass687_0;//0x000018[0x000008]
	CUnityString* string_0;//0x000020[0x000008]
	class CGClass916* GameDateTime;//0x000028[0x000008]
	class CConfig* SpeedLimits;//0x000030[0x000008]
	CUnityString* CurrentProfileId;//0x000038[0x000008]
	class CGClass446* gclass446_0;//0x000040[0x000008]
	class CAudioSourceCulling* AudioSourceCulling;//0x000048[0x000008]
	class CGInterface215* ginterface215_0;//0x000050[0x000008]
	class CBallisticsCalculator* _sharedBallisticsCalculator;//0x000058[0x000008]
	CUnityTList<class CGInterface7*>* LootList;//0x000060[0x000008]
	CUnityDictionary<class CIItemOwner*, class CGStruct77>* ItemOwners;//0x000068[0x000008]
	void* LootItems;//0x000070[0x000008]
	CUnityTList<class CGClass747*>* AllLoot;//0x000078[0x000008]
	CUnityTList<class CPlayer*>* RegisteredPlayers;//0x000080[0x000008]
};

class CItem : public CObject
{
public:
	CUnityString* Id;//0x000010[0x000008]
	void* OriginalAddress;//0x000018[0x000008]
	void* Components;//0x000020[0x000008]
	CUnityString* _toStringCache;//0x000028[0x000008]
	void* CurrentAddress;//0x000030[0x000008]
	void* _template;//0x000038[0x000008]
	void* Attributes;//0x000040[0x000008]
	void* ChildrenChanged;//0x000048[0x000008]
	bool UnlimitedCount;//0x000050[0x000001]
	unsigned char _0x00000051[0x3];//0x00000051 (0x3) MISSED OFFSET
	__int32 BuyRestrictionMax;//0x000054[0x000004]
	__int32 BuyRestrictionCurrent;//0x000058[0x000004]
	__int32 StackObjectsCount;//0x00005C[0x000004]
	__int32 Version;//0x000060[0x000004]
	bool SpawnedInSession;//0x000064[0x000001]
	unsigned char _0x00000065[0x3];//0x00000065 (0x3) MISSED OFFSET
};
class CGClass1765 : public CItem
{
public:
	void* SideEffect;//0x000068[0x000008]
	void* Repairable;//0x000070[0x000008]
	void* KnifeComponent;//0x000078[0x000008]
};
class CGClass1766 : public CGClass1765
{
public:
	int Side;//0x0000D0[0x000004]
	unsigned char _0x000000D4[0x4];//0x000000D4 (0x4) MISSED OFFSET
};
template<typename T>class CGClass502 : public CObject
{
public:
	void* func_0;//0x000010[0x000008]
};
template<typename T>class CGClass503 : public CGClass502<T>
{
public:
	T gparam_0;//0x000018[0x000008]
	bool bool_0;//0x000020[0x000001]
	unsigned char _0x00000021[0x7];//0x00000021 (0x7) MISSED OFFSET
};
class CGClass1781 : public CObject
{
public:
	void* Equipment;//0x000010[0x000008]
	void* ArmorSlots;//0x000010[0x000008]
	void* Stash;//0x000018[0x000008]
	void* FastAccessSlots;//0x000018[0x000008]
	void* QuestRaidItems;//0x000020[0x000008]
	void* QuestStashItems;//0x000028[0x000008]
	void* SortingTable;//0x000030[0x000008]
	void* FastAccess;//0x000038[0x000008]
	void* TotalWeight;//0x000040[0x000008]
	void* TotalWeightEliteSkill;//0x000048[0x000008]
	void* DeserializationErrors;//0x000050[0x000008]
	void* list_0;//0x000058[0x000008]
	void* OnWeightUpdated;//0x000060[0x000008]
};



class CGClass1794 : public CObject
{
public:
	void* action_0;//0x000010[0x000008]
	void* Logger;//0x000018[0x000008]
	void* action_1;//0x000020[0x000008]
	void* action_2;//0x000028[0x000008]
	void* action_3;//0x000030[0x000008]
	void* action_4;//0x000038[0x000008]
	void* action_5;//0x000040[0x000008]
	void* action_6;//0x000048[0x000008]
	void* action_7;//0x000050[0x000008]
	void* action_8;//0x000058[0x000008]
	void* action_9;//0x000060[0x000008]
	void* action_10;//0x000068[0x000008]
	void* action_11;//0x000070[0x000008]
	void* action_12;//0x000078[0x000008]
	void* hashSet_0;//0x000080[0x000008]
	CUnityString* string_0;//0x000088[0x000008]
	void* itemFilter_0;//0x000090[0x000008]
	void* item_0;//0x000098[0x000008]
	void* item_1;//0x0000A0[0x000008]
	void* item_2;//0x0000A8[0x000008]
	CUnityString* string_1;//0x0000B0[0x000008]
	void* list_0;//0x0000B8[0x000008]
	void* coroutine_0;//0x0000C0[0x000008]
	unsigned __int16 ushort_0;//0x0000C8[0x000002]
	unsigned char _0x000000CA[0x2];//0x000000CA (0x2) MISSED OFFSET
	__int32 int_0;//0x0000CC[0x000004]
	bool bool_0;//0x0000D0[0x000001]
	bool bool_1;//0x0000D1[0x000001]
	unsigned char _0x000000D2[0x2];//0x000000D2 (0x2) MISSED OFFSET
	int eownerType_0;//0x0000D4[0x000004]
};
class CGClass1143 : public CUnityBaseMonoBehaviour
{
public:
	void* action_0;//0x000010[0x000008]
	float FactorValue;//0x000018[0x000004]
	bool SimpleCalculation;//0x00001C[0x000001]
	char _0x0001D[0x03];//0x00001D[0x000003]
	float float_0;//0x000020[0x000003]
};
class CGClass1795 : public CGClass1794
{
public:
	int Side;//0x0000D8[0x000004]
	unsigned char _0x000000DC[0x4];//0x000000DC (0x4) MISSED OFFSET
};
class CGClass1205 : public CObject
{
public:
	void* WeaponBuffs;//0x000010[0x000008]
	CGClass1103<float>* EnduranceBuffEnduranceInc;//0x000018[0x000008]
	CGClass1103<float>* EnduranceHands;//0x000020[0x000008]
	CGClass1103<float>* EnduranceBuffJumpCostRed;//0x000028[0x000008]
	CGClass1103<float>* EnduranceBuffBreathTimeInc;//0x000030[0x000008]
	CGClass1103<float>* EnduranceBuffRestoration;//0x000038[0x000008]
	CGClass1103<float>* EnduranceBreathElite;//0x000040[0x000008]
	CGClass1103<float>* StrengthBuffLiftWeightInc;//0x000048[0x000008]
	CGClass1103<float>* StrengthBuffSprintSpeedInc;//0x000050[0x000008]
	CGClass1103<float>* StrengthBuffJumpHeightInc;//0x000058[0x000008]
	CGClass1103<float>* StrengthBuffAimFatigue;//0x000060[0x000008]
	CGClass1103<float>* StrengthBuffThrowDistanceInc;//0x000068[0x000008]
	CGClass1103<float>* StrengthBuffMeleePowerInc;//0x000070[0x000008]
	CGClass1103<bool>* StrengthBuffElite;//0x000078[0x000008]
	CGClass1103<float>* StrengthBuffMeleeCrits;//0x000080[0x000008]
	CGClass1103<float>* VitalityBuffBleedChanceRed;//0x000088[0x000008]
	CGClass1103<float>* VitalityBuffSurviobilityInc;//0x000090[0x000008]
	CGClass1103<bool>* VitalityBuffRegeneration;//0x000098[0x000008]
	CGClass1103<bool>* VitalityBuffBleedStop;//0x0000A0[0x000008]
	CGClass1103<float>* HealthBreakChanceRed;//0x0000A8[0x000008]
	CGClass1103<float>* HealthOfflineRegenerationInc;//0x0000B0[0x000008]
	CGClass1103<float>* HealthEnergy;//0x0000B8[0x000008]
	CGClass1103<float>* HealthHydration;//0x0000C0[0x000008]
	CGClass1103<bool>* HealthEliteAbsorbDamage;//0x0000C8[0x000008]
	CGClass1103<float>* HealthElitePosion;//0x0000D0[0x000008]
	CGClass1103<float>* StressPain;//0x0000D8[0x000008]
	CGClass1103<float>* StressTremor;//0x0000E0[0x000008]
	CGClass1103<bool>* StressBerserk;//0x0000E8[0x000008]
	CGClass1103<float>* MetabolismRatioPlus;//0x0000F0[0x000008]
	CGClass1103<float>* MetabolismPoisonTime;//0x0000F8[0x000008]
	CGClass1103<float>* MetabolismMiscDebuffTime;//0x000100[0x000008]
	CGClass1103<bool>* MetabolismEliteBuffNoDyhydration;//0x000108[0x000008]
	CGClass1103<float>* PerceptionHearing;//0x000110[0x000008]
	CGClass1103<float>* PerceptionLootDot;//0x000118[0x000008]
	CGClass1103<bool>* PerceptionEliteNoIdea;//0x000120[0x000008]
	CGClass1103<float>* IntellectLearningSpeed;//0x000128[0x000008]
	CGClass1103<float>* IntellectWeaponMaintance;//0x000130[0x000008]
	CGClass1103<bool>* IntellectEliteNaturalLearner;//0x000138[0x000008]
	CGClass1103<bool>* IntellectEliteAmmoCounter;//0x000140[0x000008]
	CGClass1103<bool>* IntellectEliteContainerScope;//0x000148[0x000008]
	CGClass1103<float>* AttentionLootSpeed;//0x000150[0x000008]
	CGClass1103<float>* AttentionExamine;//0x000158[0x000008]
	CGClass1103<float>* AttentionEliteLuckySearch;//0x000160[0x000008]
	CGClass1103<bool>* AttentionEliteExtraLootExp;//0x000168[0x000008]
	CGClass1103<float>* MagDrillsLoadSpeed;//0x000170[0x000008]
	CGClass1103<float>* MagDrillsUnloadSpeed;//0x000178[0x000008]
	CGClass1103<float>* MagDrillsInventoryCheckSpeed;//0x000180[0x000008]
	CGClass1103<float>* MagDrillsInventoryCheckAccuracy;//0x000188[0x000008]
	CGClass1103<bool>* MagDrillsInstantCheck;//0x000190[0x000008]
	CGClass1103<bool>* MagDrillsLoadProgression;//0x000198[0x000008]
	CGClass1103<float>* CharismaBuff1;//0x0001A0[0x000008]
	CGClass1103<float>* CharismaBuff2;//0x0001A8[0x000008]
	CGClass1103<bool>* CharismaEliteBuff1;//0x0001B0[0x000008]
	CGClass1103<float>* CharismaEliteBuff2;//0x0001B8[0x000008]
	CGClass1103<float>* MemoryMentalForget1;//0x0001C0[0x000008]
	CGClass1103<float>* MemoryMentalForget2;//0x0001C8[0x000008]
	CGClass1103<bool>* MemoryEliteMentalRecoil;//0x0001D0[0x000008]
	CGClass1103<float>* ImmunityMiscEffects;//0x0001D8[0x000008]
	CGClass1103<float>* ImmunityPoisonBuff;//0x0001E0[0x000008]
	CGClass1103<float>* ImmunityPainKiller;//0x0001E8[0x000008]
	CGClass1103<float>* ImmunityAvoidPoisonChance;//0x0001F0[0x000008]
	CGClass1103<float>* ImmunityAvoidMiscEffectsChance;//0x0001F8[0x000008]
	void* Pistol;//0x000200[0x000008]
	void* Revolver;//0x000208[0x000008]
	void* SMG;//0x000210[0x000008]
	void* Assault;//0x000218[0x000008]
	void* Shotgun;//0x000220[0x000008]
	void* Sniper;//0x000228[0x000008]
	void* LMG;//0x000230[0x000008]
	void* HMG;//0x000238[0x000008]
	void* Launcher;//0x000240[0x000008]
	void* AttachedLauncher;//0x000248[0x000008]
	void* Misc;//0x000250[0x000008]
	void* Melee;//0x000258[0x000008]
	void* DMR;//0x000260[0x000008]
	void* Throwing;//0x000268[0x000008]
	void* AimDrills;//0x000270[0x000008]
	void* RecoilControl;//0x000278[0x000008]
	void* TroubleShooting;//0x000280[0x000008]
	CGClass1103<float>* AimMasterSpeed;//0x000288[0x000008]
	CGClass1103<float>* AimMasterWiggle;//0x000290[0x000008]
	CGClass1103<bool>* AimMasterElite;//0x000298[0x000008]
	CGClass1103<float>* RecoilControlImprove;//0x0002A0[0x000008]
	CGClass1103<float>* RecoilControlElite;//0x0002A8[0x000008]
	CGClass1103<float>* TroubleFixing;//0x0002B0[0x000008]
	CGClass1103<bool>* TroubleFixingDurElite;//0x0002B8[0x000008]
	CGClass1103<bool>* TroubleFixingMagElite;//0x0002C0[0x000008]
	CGClass1103<bool>* TroubleFixingAmmoElite;//0x0002C8[0x000008]
	CGClass1103<float>* ThrowingStrengthBuff;//0x0002D0[0x000008]
	CGClass1103<float>* ThrowingEnergyExpenses;//0x0002D8[0x000008]
	CGClass1103<bool>* ThrowingEliteBuff;//0x0002E0[0x000008]
	CGClass1103<float>* DrawSpeed;//0x0002E8[0x000008]
	CGClass1103<float>* DrawSound;//0x0002F0[0x000008]
	CGClass1103<bool>* DrawElite;//0x0002F8[0x000008]
	CGClass1103<bool>* DrawTremor;//0x000300[0x000008]
	void* action_0;//0x000308[0x000008]
	CUnityTArray<CGClass1097*>* Skills;//0x000310[0x000008]
	CUnityTArray<CGClass1097*>* DisplayList;//0x000318[0x000008]
	void* list_0;//0x000320[0x000008]
	void* Mastering;//0x000328[0x000008]
	void* action_1;//0x000330[0x000008]
	void* action_2;//0x000338[0x000008]
	void* action_3;//0x000340[0x000008]
	void* action_4;//0x000348[0x000008]
	void* action_5;//0x000350[0x000008]
	void* NoExpenseAimSkillTimer;//0x000358[0x000008]
	void* FastAimTimer;//0x000360[0x000008]
	void* SprintAction;//0x000368[0x000008]
	void* PushUp;//0x000370[0x000008]
	CGClass1143* ProneAction;//0x000378[0x000008]
	void* MovementAction;//0x000380[0x000008]
	void* JumpAction;//0x000388[0x000008]
	void* WeaponReloadAction;//0x000390[0x000008]
	void* WeaponShotAction;//0x000398[0x000008]
	void* WeaponChamberAction;//0x0003A0[0x000008]
	CGClass1143* WeaponFixAction;//0x0003A8[0x000008]
	CGClass1143* WeaponDrawAction;//0x0003B0[0x000008]
	CGClass1143* WeaponAimAction;//0x0003B8[0x000008]
	void* ShotAfterAim;//0x0003C0[0x000008]
	CGClass1143* RecoilAction;//0x0003C8[0x000008]
	CGClass1143* FistfightAction;//0x0003D0[0x000008]
	CGClass1143* ThrowAction;//0x0003D8[0x000008]
	CGClass1143* HoldBreathAction;//0x0003E0[0x000008]
	CGClass1143* DamageTakenAction;//0x0003E8[0x000008]
	void* HealthNegativeEffect;//0x0003F0[0x000008]
	CGClass1143* LowHPDuration;//0x0003F8[0x000008]
	CGClass1143* OnlineAction;//0x000400[0x000008]
	CGClass1143* UniqueLoot;//0x000408[0x000008]
	CGClass1143* ExamineAction;//0x000410[0x000008]
	CGClass1143* ExamineWithInstruction;//0x000418[0x000008]
	void* LockpickAction;//0x000420[0x000008]
	CGClass1143* RepairAction;//0x000428[0x000008]
	void* FindAction;//0x000430[0x000008]
	void* TradeAction;//0x000438[0x000008]
	CGClass1143* SearchAction;//0x000440[0x000008]
	CGClass1143* RaidLoadedAmmoAction;//0x000448[0x000008]
	CGClass1143* RaidUnloadedAmmoAction;//0x000450[0x000008]
	CGClass1143* MagazineCheckAction;//0x000458[0x000008]
	void* AnySkillUp;//0x000460[0x000008]
	void* SkillProgress;//0x000468[0x000008]
	void* HydrationChanged;//0x000470[0x000008]
	void* EnergyChanged;//0x000478[0x000008]
	void* KillAction;//0x000480[0x000008]
	CGClass1143* SurgeryAction;//0x000488[0x000008]
	void* HideoutCraftTimerAction;//0x000490[0x000008]
	CGClass1143* HideoutCompleteCraftAction;//0x000498[0x000008]
	CGClass1143* HideoutZoneUpgradeAction;//0x0004A0[0x000008]
	CGClass1143* UniqueCrafting;//0x0004A8[0x000008]
	CGClass1143* StimulatorNegativeBuff;//0x0004B0[0x000008]
	CGClass1143* Exhaustion;//0x0004B8[0x000008]
	CGClass1143* Dehydration;//0x0004C0[0x000008]
	CGClass1143* WeaponRepairedAction;//0x0004C8[0x000008]
	void* ConsumptionActions;//0x0004D0[0x000008]
	void* bonusController_0;//0x0004D8[0x000008]
	void* Perception;//0x0004E0[0x000008]
	void* Intellect;//0x0004E8[0x000008]
	void* Attention;//0x0004F0[0x000008]
	void* Immunity;//0x0004F8[0x000008]
	void* Charisma;//0x000500[0x000008]
	void* Memory;//0x000508[0x000008]
	void* Endurance;//0x000510[0x000008]
	void* Strength;//0x000518[0x000008]
	void* Vitality;//0x000520[0x000008]
	void* Health;//0x000528[0x000008]
	void* Metabolism;//0x000530[0x000008]
	void* StressResistance;//0x000538[0x000008]
	void* Sniping;//0x000540[0x000008]
	void* CovertMovement;//0x000548[0x000008]
	void* ProneMovement;//0x000550[0x000008]
	void* FirstAid;//0x000558[0x000008]
	void* FieldMedicine;//0x000560[0x000008]
	void* LightVests;//0x000568[0x000008]
	void* HeavyVests;//0x000570[0x000008]
	void* WeaponModding;//0x000578[0x000008]
	void* AdvancedModding;//0x000580[0x000008]
	void* NightOps;//0x000588[0x000008]
	void* SilentOps;//0x000590[0x000008]
	void* Lockpicking;//0x000598[0x000008]
	void* Surgery;//0x0005A0[0x000008]
	void* Search;//0x0005A8[0x000008]
	void* WeaponTreatment;//0x0005B0[0x000008]
	void* MagDrills;//0x0005B8[0x000008]
	void* Freetrading;//0x0005C0[0x000008]
	void* Auctions;//0x0005C8[0x000008]
	void* Cleanoperations;//0x0005D0[0x000008]
	void* Barter;//0x0005D8[0x000008]
	void* Shadowconnections;//0x0005E0[0x000008]
	void* Taskperformance;//0x0005E8[0x000008]
	void* Crafting;//0x0005F0[0x000008]
	void* HideoutManagement;//0x0005F8[0x000008]
	CGClass1103<float>* CovertMovementSoundVolume;//0x000600[0x000008]
	CGClass1103<float>* CovertMovementEquipment;//0x000608[0x000008]
	CGClass1103<float>* CovertMovementSpeed;//0x000610[0x000008]
	CGClass1103<bool>* CovertMovementElite;//0x000618[0x000008]
	CGClass1103<float>* CovertMovementLoud;//0x000620[0x000008]
	CGClass1103<float>* ProneMovementSpeed;//0x000628[0x000008]
	CGClass1103<float>* ProneMovementVolume;//0x000630[0x000008]
	CGClass1103<bool>* ProneMovementEliteSprint;//0x000638[0x000008]
	CGClass1103<float>* SearchBuffSpeed;//0x000640[0x000008]
	CGClass1103<bool>* SearchDouble;//0x000648[0x000008]
	CGClass1103<float>* SurgeryReducePenalty;//0x000650[0x000008]
	CGClass1103<float>* SurgerySpeed;//0x000658[0x000008]
	CGClass1103<float>* HideoutResourceConsumption;//0x000660[0x000008]
	CGClass1103<float>* ZoneBonusBoost;//0x000668[0x000008]
	CGClass1103<bool>* HideoutExtraSlots;//0x000670[0x000008]
	CGClass1103<float>* SingleCraftTimeReduce;//0x000678[0x000008]
	CGClass1103<float>* ContinueCraftTimeReduce;//0x000680[0x000008]
	CGClass1103<bool>* EliteCrafting;//0x000688[0x000008]
	CGClass1103<float>* WeaponDurabilityLosOnShotReduce;//0x000690[0x000008]
	CGClass1103<float>* WeaponDeteriorationChanceOnRepairReduce;//0x000698[0x000008]
	CGClass1103<bool>* ZeroWeaponDeteriorationOnRepair;//0x0006A0[0x000008]
	void* BearAssaultoperations;//0x0006A8[0x000008]
	void* BearAuthority;//0x0006B0[0x000008]
	void* BearAksystems;//0x0006B8[0x000008]
	void* BearHeavycaliber;//0x0006C0[0x000008]
	void* BearRawpower;//0x0006C8[0x000008]
	void* UsecArsystems;//0x0006D0[0x000008]
	void* UsecDeepweaponmodding;//0x0006D8[0x000008]
	void* UsecLongrangeoptics;//0x0006E0[0x000008]
	void* UsecNegotiations;//0x0006E8[0x000008]
	void* UsecTactics;//0x0006F0[0x000008]
	void* BotReload;//0x0006F8[0x000008]
	void* BotSoundGoef;//0x000700[0x000008]
	CGClass1103<float>* BotReloadSpeed;//0x000708[0x000008]
	CGClass1103<float>* BotSoundCoef;//0x000710[0x000008]
	__int32 ExtraSkillsPoints;//0x000718[0x000004]
	unsigned char _0x0000071C[0x4];//0x0000071C (0x4) MISSED OFFSET
};
class CGClass1180 : public CObject
{
public:
	__int32 Role;//0x000010[0x000004]
	__int32 BotDifficulty;//0x000014[0x000004]
	__int32 Experience;//0x000018[0x000004]
	float StandingForKill;//0x00001C[0x000004]
	float AggressorBonus;//0x000020[0x000004]
};
class CGClass1194 : public CObject
{
public:
	CUnityString* Nickname;//0x000010[0x000008]
	CUnityString* GroupId;//0x000018[0x000008]
	CUnityString* EntryPoint;//0x000020[0x000008]
	CUnityString* Voice;//0x000028[0x000008]
	void* Bans;//0x000030[0x000008]
	CGClass1180* Settings;//0x000038[0x000008]
	void* action_0;//0x000040[0x000008]
	void* action_1;//0x000048[0x000008]
	__int32 Side;//0x000050[0x000004]
	__int32 RegistrationDate;//0x000054[0x000004]
	double SavageLockTime;//0x000058[0x000008]
	__int32 NicknameChangeDate;//0x000060[0x000004]
	bool IsStreamerModeAvailable;//0x000064[0x000001]
	unsigned char _0x00000065[0x3];//0x00000065 (0x3) MISSED OFFSET
	__int32 MemberCategory;//0x000068[0x000004]
	__int32 int_0;//0x00006C[0x000004]
};
class CProfile : public CObject
{
public:
	CUnityString* Id;//0x000010[0x000008]
	CUnityString* AccountId;//0x000018[0x000008]
	CUnityString* PetId;//0x000020[0x000008]
	CGClass1194* Info;//0x000028[0x000008]
	void* Customization;//0x000030[0x000008]
	void* Encyclopedia;//0x000038[0x000008]
	void* Health;//0x000040[0x000008]
	CGClass1781* Inventory;//0x000048[0x000008]
	void* QuestItems;//0x000050[0x000008]
	void* InsuredItems;//0x000058[0x000008]
	CGClass1205* Skills;//0x000060[0x000008]
	void* Notes;//0x000068[0x000008]
	void* Quests;//0x000070[0x000008]
	void* ConditionCounters;//0x000078[0x000008]
	void* BackendCounters;//0x000080[0x000008]
	void* TradersInfo;//0x000088[0x000008]
	void* Bonuses;//0x000090[0x000008]
	void* Hideout;//0x000098[0x000008]
	void* RagfairInfo;//0x0000A0[0x000008]
	void* bonusController_0;//0x0000A8[0x000008]
	void* IdGenerator;//0x0000B0[0x000008]
	void* WishList;//0x0000B8[0x000008]
	void* _emptyResourceCollection;//0x0000C0[0x000008]
	void* fenceTraderInfo_0;//0x0000C8[0x000008]
	void* OnItemZoneDropped;//0x0000D0[0x000008]
	void* OnTraderStandingChanged;//0x0000D8[0x000008]
	void* OnTraderLoyaltyChanged;//0x0000E0[0x000008]
	void* Stats;//0x0000E8[0x000008]
	void* CheckedMagazines;//0x0000F0[0x000008]
	void* CheckedChambers;//0x0000F8[0x000008]
};
class CGClass1797 : public CGClass1795
{
public:
	void* action_13;//0x0000E0[0x000008]
	void* action_14;//0x0000E8[0x000008]
	void* action_15;//0x0000F0[0x000008]
	void* action_16;//0x0000F8[0x000008]
	void* action_17;//0x000100[0x000008]
	void* action_18;//0x000108[0x000008]
	void* dictionary_0;//0x000110[0x000008]
	void* SearchOperations;//0x000118[0x000008]
	CGClass1781* gclass1781_0;//0x000120[0x000008]
	CProfile* profile_0;//0x000128[0x000008]
	bool bool_2;//0x000130[0x000001]
	bool bool_3;//0x000131[0x000001]
	unsigned char _0x00000132[0x6];//0x00000132 (0x6) MISSED OFFSET
};
class CGClass1134 : public CObject
{
public:
	char _0x000010[0x01C0];
	float float_0;//0x0001D0[0x000004]
	bool bool_0;//0x0001D4[0x000001]
	unsigned char _0x000001D5[0x3];//0x000001D5 (0x3) MISSED OFFSET
	__int32 BlindFire;//0x0001D8[0x000004]
	bool IgnoreDeltaMovement;//0x0001DC[0x000001]
	unsigned char _0x000001DD[0x3];//0x000001DD (0x3) MISSED OFFSET
	float float_1;//0x0001E0[0x000004]
	float float_2;//0x0001E4[0x000004]
	bool CanSlope;//0x0001E8[0x000001]
	unsigned char _0x000001E9[0x3];//0x000001E9 (0x3) MISSED OFFSET
	float float_3;//0x0001EC[0x000004]
	float float_4;//0x0001F0[0x000004]
	float float_5;//0x0001F4[0x000004]
	float float_6;//0x0001F8[0x000004]
	float float_7;//0x0001FC[0x000004]
	__int32 int_0;//0x000200[0x000004]
	FVec2 vector2_0;//0x000204[0x000008]
	FVec2 vector2_1;//0x00020C[0x000008]
	FVec2 vector2_2;//0x000214[0x000008]
	BYTE raycastHit_0[0x00002C];//0x00021C[0x00002C]
	float CheckGroundedRayDistance;//0x000248[0x000004]
	float float_8;//0x00024C[0x000004]
	float float_9;//0x000250[0x000004]
	float float_10;//0x000254[0x000004]
	__int32 layerMask_0;//0x000258[0x000004]
	__int32 layerMask_1;//0x00025C[0x000004]
	__int32 layerMask_2;//0x000260[0x000004]
	__int32 int_1;//0x000264[0x000004]
	FVec2 vector2_3;//0x000268[0x000008]
	FVec2 vector2_4;//0x000270[0x000008]
	FVec2 vector2_5;//0x000278[0x000008]
	FVec3 vector3_0;//0x000280[0x00000C]
	float float_11;//0x00028C[0x000004]
	float CovertEfficiency;//0x000290[0x000004]
	bool SoftSurface;//0x000294[0x000001]
	bool bool_1;//0x000295[0x000001]
	unsigned char _0x00000296[0x2];//0x00000296 (0x2) MISSED OFFSET
	__int32 ephysicalCondition_0;//0x000298[0x000004]
	bool NextBreachResult;//0x00029C[0x000001]
	unsigned char _0x0000029D[0x3];//0x0000029D (0x3) MISSED OFFSET
	float float_16;//0x0002A0[0x000004]
	float LevelOnApproachStart;//0x0002A4[0x000004]
	bool bool_2;//0x0002A8[0x000001]
	unsigned char _0x000002A9[0x3];//0x000002A9 (0x3) MISSED OFFSET
	__int32 int_2;//0x0002AC[0x000004]
	float float_17;//0x0002B0[0x000004]
	bool bool_3;//0x0002B4[0x000001]
	unsigned char _0x000002B5[0x3];//0x000002B5 (0x3) MISSED OFFSET
	float float_18;//0x0002B8[0x000004]
	float float_19;//0x0002BC[0x000004]
	float float_20;//0x0002C0[0x000004]
	BYTE raycastHit_1[0x00002C];//0x0002C4[0x00002C]
	float FreefallTime;//0x0002F0[0x000004]
	FVec3 vector3_1;//0x0002F4[0x00000C]
	FVec4 PlatformRotation;//0x000300[0x000010]
	bool bool_4;//0x000310[0x000001]
	unsigned char _0x00000311[0x3];//0x00000311 (0x3) MISSED OFFSET
	float float_21;//0x000314[0x000004]
	FVec3 InputMotion;//0x000318[0x00000C]
	FVec3 InputMotionBeforeLimit;//0x000324[0x00000C]
	__int32 int_3;//0x000330[0x000004]
	bool bool_5;//0x000334[0x000001]
	unsigned char _0x00000335[0x3];//0x00000335 (0x3) MISSED OFFSET
	FVec3 vector3_2;//0x000338[0x00000C]
	float float_23;//0x000344[0x000004]
	FVec3 PreviousPosition;//0x000348[0x00000C]
	float float_24;//0x000354[0x000004]
	FVec3 vector3_3;//0x000358[0x00000C]
	FVec3 vector3_4;//0x000364[0x00000C]
	bool bool_6;//0x000370[0x000001]
	bool bool_7;//0x000371[0x000001]
	unsigned char _0x00000372[0x2];//0x00000372 (0x2) MISSED OFFSET
	float float_25;//0x000374[0x000004]
	FVec3 vector3_5;//0x000378[0x00000C]
	float float_26;//0x000384[0x000004]
	FVec3 vector3_6;//0x000388[0x00000C]
	float float_27;//0x000394[0x000004]
	float float_28;//0x000398[0x000004]
	FVec3 vector3_7;//0x00039C[0x00000C]
	FVec3 vector3_8;//0x0003A8[0x00000C]
	__int32 int_4;//0x0003B4[0x000004]
	float float_29;//0x0003B8[0x000004]
	bool bool_8;//0x0003BC[0x000001]
	bool bool_9;//0x0003BD[0x000001]
	bool bool_10;//0x0003BE[0x000001]
	unsigned char _0x000003BF[0x1];//0x000003BF (0x1) MISSED OFFSET
};
class CGClass439 : public CObject
{
public:
	void* TotalCapacity;//0x000010[0x000008]
	void* SelfRestoration;//0x000018[0x000008]
	void* Consumptions;//0x000020[0x000008]
	void* action_0;//0x000028[0x000008]
	void* action_1;//0x000030[0x000008]
	void* action_2;//0x000038[0x000008]
	void* action_3;//0x000040[0x000008]
	float Current;//0x000048[0x000004]
	float DisableRestoration;//0x00004C[0x000004]
	float float_0;//0x000050[0x000004]
	bool bool_0;//0x000054[0x000001]
	unsigned char _0x00000055[0x3];//0x00000055 (0x3) MISSED OFFSET
	__int32 int_0;//0x000058[0x000004]
	unsigned char _0x0000005C[0x4];//0x0000005C (0x4) MISSED OFFSET
};
class CGClass440 : public CObject
{
public:
	CPlayer* player_0;//0x000010[0x000008]
	void* MinStepSound;//0x000018[0x000008]
	void* TransitionSpeed;//0x000020[0x000008]
	CGClass439* Stamina;//0x000028[0x000008]
	CGClass439* HandsStamina;//0x000030[0x000008]
	CGClass439* Oxygen;//0x000038[0x000008]
	void* action_0;//0x000040[0x000008]
	void* action_1;//0x000048[0x000008]
	void* action_2;//0x000050[0x000008]
	void* action_3;//0x000058[0x000008]
	void* action_4;//0x000060[0x000008]
	void* action_5;//0x000068[0x000008]
	void* action_6;//0x000070[0x000008]
	float MaxPoseLevel;//0x000078[0x000004]
	float Overweight;//0x00007C[0x000004]
	float WalkOverweight;//0x000080[0x000004]
	float WalkSpeedLimit;//0x000084[0x000004]
	float SoundRadius;//0x000088[0x000004]
	bool bool_0;//0x00008C[0x000001]
	unsigned char _0x0000008D[0x3];//0x0000008D (0x3) MISSED OFFSET
	float float_2;//0x000090[0x000004]
	float Fatigue;//0x000094[0x000004]
	float CapacityBuff;//0x000098[0x000004]
	float float_3;//0x00009C[0x000004]
	float FallDamageMultiplier;//0x0000A0[0x000004]
	float StaminaCapacity;//0x0000A4[0x000004]
	float StaminaRestoreRate;//0x0000A8[0x000004]
	float HandsCapacity;//0x0000AC[0x000004]
	float HandsRestoreRate;//0x0000B0[0x000004]
	float OxygenCapacity;//0x0000B4[0x000004]
	float OxygenRestoreRate;//0x0000B8[0x000004]
	FVec2 WalkOverweightLimits;//0x0000BC[0x000008]
	FVec2 BaseOverweightLimits;//0x0000C4[0x000008]
	FVec2 SprintOverweightLimits;//0x0000CC[0x000008]
	FVec2 WalkSpeedOverweightLimits;//0x0000D4[0x000008]
	float float_4;//0x0000DC[0x000004]
	float PreviousWeight;//0x0000E0[0x000004]
	bool bool_1;//0x0000E4[0x000001]
	bool bool_2;//0x0000E5[0x000001]
	char gstruct22_0[0x000003];//0x0000E6[0x000003]
	bool bool_3;//0x0000E9[0x000001]
	bool bool_4;//0x0000EA[0x000001]
	bool bool_5;//0x0000EB[0x000001]
	bool bool_6;//0x0000EC[0x000001]
	unsigned char _0x000000ED[0x3];//0x000000ED (0x3) MISSED OFFSET
};
class CBreath//
{
public:
	char _0x0000[0xA4];							//0x0000
	float m_fIntensity;							//0x00A4
};
class CWalk//
{
public:
	char _0x0000[0x44];							//0x0000
	float m_fIntensity;							//0x0044
};
class CMotionEffector//
{
public:
	char _0x0000[0xD0];							//0x0000
	float m_fIntensity;							//0x00D0
};
class CForceEffector//
{
public:
	char _0x0000[0x30];							//0x0000
	float m_fIntensity;							//0x0030
};
class CShotEffector//
{
public:
	char _0x0000[0x68];							//0x0000
	float m_fIntensity;							//0x0068
};

class CProceduralWeaponAnimation : public CUnityMonoBehaviourScript
{
public:
	char _0x0018[0x10];							//0x0018
	class CBreath *m_lpBreath;					//0x0028
	class CWalk *m_lpWalk;						//0x0030
	class CMotionEffector *m_MotionReact;		//0x0038
	class CForceEffector *m_ForceReact;			//0x0040
	class CShotEffector *m_lpShooting;			//0x0048
	char _0x0050[0x00B0];						//0x0050
	DWORD Mask;									//0x0100
	char _0x0104[0x01EC];						//0x0050
	float Pitch;								//0x02F0
};
class CSkeleton : public CUnityMonoBehaviourScript
{
public:
	CUnityDictionary<CUnityString*, CMonoTransform*>* Bones;//0x000018[0x000008]
	void* _keys;//0x000020[0x000008]
	CUnityTList<CMonoTransform*>* _values;//0x000028[0x000008]
};
class CPlayerBody : public CUnityMonoBehaviourScript
{
public:
	void* _meshTransform;//0x000018[0x000008]
	class CPlayerBones* PlayerBones;//0x000020[0x000008]
	CSkeleton* SkeletonRootJoint;//0x000028[0x000008]
	CSkeleton* SkeletonHands;//0x000030[0x000008]
	void* BodySkins;//0x000038[0x000008]
	void* _watches;//0x000040[0x000008]
	void* _bodyRenderers;//0x000048[0x000008]
	void* SlotViews;//0x000050[0x000008]
	void* _itemInHands;//0x000058[0x000008]
	void* BodyCustomizationId;//0x000060[0x000008]
	void* PlayerSide;//0x000068[0x000008]
	void* PointOfView;//0x000070[0x000008]
	__int32 _layer;//0x000078[0x000004]
	__int32 _side;//0x00007C[0x000004]
	bool _active;//0x000080[0x000001]
	bool bool_0;//0x000081[0x000001]
	unsigned char _0x00000082[0x6];//0x00000082 (0x6) MISSED OFFSET
};

class CUnityTransform : public CUnityComponent
{
public:
	FVec3 GetPosition();
	FVec3 GetForward();
};
struct CBifacialTransform
{
	char _0x0000[0x10];                                        //0x0000
	CMonoTransform *_Transform;                            //0x0010
	void* uFunc__positionImitator;        //0x0018
	char _0x0020[0x88];                                        //0x0020
	bool __useImitation;                                    //0x00A8
	bool _accumulatePositionAndRotation;                    //0x00A9
	char _0x00AA[0x02];                                        //0x00AA
	FVec3 _accumulatedPosition;                                //0x00AC

	bool GetPosition(FVec3 *vOutput);
};
class CPlayerBones : public CUnityMonoBehaviourScript
{
public:
	char _0x00018[0xB8];
	CBifacialTransform* WeaponRoot;//0x0000D0[0x000008]
	CBifacialTransform* Ribcage;//0x0000D8[0x000008]
	CBifacialTransform* Head;//0x0000E0[0x000008]
	CBifacialTransform* LeftShoulder;//0x0000E8[0x000008]
	CBifacialTransform* RightShoulder;//0x0000F0[0x000008]
	CBifacialTransform* LeftThigh2;//0x0000F8[0x000008]
	CBifacialTransform* RightThigh2;//0x000100[0x000008]
	CBifacialTransform* BodyTransform;//0x000108[0x000008]
	CBifacialTransform* AnimatedTransform;//0x000110[0x000008]
	CBifacialTransform* Pelvis;//0x000118[0x000008]
	CBifacialTransform* LeftThigh1;//0x000120[0x000008]
	CBifacialTransform* RightThigh1;//0x000128[0x000008]
	CBifacialTransform* Spine3;//0x000130[0x000008]
	void* LeftHandCollider;//0x000138[0x000008]
	CBifacialTransform* Fireport;//0x000140[0x000008]
};
class CPlayer : public CUnityMonoBehaviourScript
{
public:
	char _0x0018[0x28];                                        //0x0018
	CGClass1134* m_lpMovementContext;                    //0x0040
	char _0x0040[0x60];                                        //0x0048
	CPlayerBody* m_lpPlayerBody;                            //0x00A8
	char _0x00A8[0xE0];                                        //0x00B0
	CProceduralWeaponAnimation* m_lpWeaponAni;                //0x0190
	char _0x0198[0x288];                                    //0x0198
	CUnityString* m_szLocation;                                //0x0420
	char _0x0428[0x8];                                        //0x0428
	void* m_lpDoor;                                    //0x0430
	char _0x0438[0x20];                                        //0x0438
	CProfile* m_lpProfile;                                    //0x0458
	char _0x0460[0x08];                                        //0x0460
	CGClass440* m_lpPhyiscal;                                //0x0468
	char _0x0470[0x8];                                        //0x0470
	void* m_lpBotData;                                //0x0478
	char _0x0480[0x10];                                        //0x0480
	void* m_lpHealth;                                    //0x0490
	char _0x0498[0x8];                                        //0x0498
	void* m_lpInventoryController;                    //0x04A0
	void* m_lpHandsController;                            //0x04A8
	char _0x04B0[0x40];                                        //0x04B0
	CPlayerBones* PlayerBones;                                //0x04F0
	char _0x04F8[0x2AB];                                    //0x04F8
	bool m_bIsLocalPlayer;                                    //0x07A3
};
//class CPlayer : public CUnityMonoBehaviourScript
//{
//public:
//	void* action_0;//0x000018[0x000008]
//	void* action_1;//0x000020[0x000008]
//	void* _characterController;//0x000028[0x000008]
//	void* _triggerColliderSearcher;//0x000030[0x000008]
//	void* worldInteractiveObject_0;//0x000038[0x000008]
//	CGClass1134* gclass1134_0;//0x000040[0x000008]
//	void* Pedometer;//0x000048[0x000008]
//	void* _mouseSensitivityModifiers;//0x000050[0x000008]
//	void* gdelegate25_0;//0x000058[0x000008]
//	void* LeftHandInteractionTarget;//0x000060[0x000008]
//	void* Grounder;//0x000068[0x000008]
//	void* HitReaction;//0x000070[0x000008]
//	void* _elbowBends;//0x000078[0x000008]
//	void* HandPosers;//0x000080[0x000008]
//	void* LMarkerRawBlender;//0x000088[0x000008]
//	void* LayerWeight;//0x000090[0x000008]
//	void* ThirdIkWeight;//0x000098[0x000008]
//	void* _fbbik;//0x0000A0[0x000008]
//	CPlayerBody* _playerBody;//0x0000A8[0x000008]
//	CUnityTArray<FVec3>* vector3_0;//0x0000B0[0x000008]
//	CUnityTArray<FVec4>* quaternion_3;//0x0000B8[0x000008]
//	CUnityTArray<void*>* transform_0;//0x0000C0[0x000008]
//	CUnityTArray<void*>* transform_1;//0x0000C8[0x000008]
//	CUnityTArray<void*>* transform_2;//0x0000D0[0x000008]
//	void* transform_3;//0x0000D8[0x000008]
//	void* transform_4;//0x0000E0[0x000008]
//	void* transform_5;//0x0000E8[0x000008]
//	CUnityTArray<void*>* twistRelax_0;//0x0000F0[0x000008]
//	CUnityTArray<void*>* limbIK_0;//0x0000F8[0x000008]
//	void* gameObject_0;//0x000100[0x000008]
//	void* action_2;//0x000108[0x000008]
//	void* previewMaterialSetter_0;//0x000110[0x000008]
//	void* beaconPlacer_0;//0x000118[0x000008]
//	void* firearmsEffects_0;//0x000120[0x000008]
//	void* firearmsEffects_1;//0x000128[0x000008]
//	void* compassArrow_0;//0x000130[0x000008]
//	CUnityTArray<void*>* transform_6;//0x000138[0x000008]
//	CUnityTArray<void*>* transform_7;//0x000140[0x000008]
//	void* list_0;//0x000148[0x000008]
//	void* PointOfViewChanged;//0x000150[0x000008]
//	void* AuthorityBlender;//0x000158[0x000008]
//	void* GrounderBlender;//0x000160[0x000008]
//	void* objectInHandsAnimator_0;//0x000168[0x000008]
//	void* gameObject_1;//0x000170[0x000008]
//	void* action_3;//0x000178[0x000008]
//	void* action_4;//0x000180[0x000008]
//	void* gameObject_2;//0x000188[0x000008]
//	CProceduralWeaponAnimation* proceduralWeaponAnimation_0;//0x000190[0x000008]
//	void* class726_0;//0x000198[0x000008]
//	void* DebugText;//0x0001A0[0x000008]
//	void* NestedStepSoundSource;//0x0001A8[0x000008]
//	void* _speechSource;//0x0001B0[0x000008]
//	void* FractureSound;//0x0001B8[0x000008]
//	void* PropIn;//0x0001C0[0x000008]
//	void* PropOut;//0x0001C8[0x000008]
//	void* FaceshieldOn;//0x0001D0[0x000008]
//	void* FaceshieldOff;//0x0001D8[0x000008]
//	void* audioClip_0;//0x0001E0[0x000008]
//	void* dictionary_0;//0x0001E8[0x000008]
//	void* surfaceSet_0;//0x0001F0[0x000008]
//	void* soundBank_0;//0x0001F8[0x000008]
//	void* soundBank_1;//0x000200[0x000008]
//	void* coroutine_0;//0x000208[0x000008]
//	void* coroutine_1;//0x000210[0x000008]
//	void* coroutine_2;//0x000218[0x000008]
//	void* coroutine_3;//0x000220[0x000008]
//	void* coroutine_4;//0x000228[0x000008]
//	void* coroutine_5;//0x000230[0x000008]
//	void* betterSource_0;//0x000238[0x000008]
//	void* audioClip_1;//0x000240[0x000008]
//	void* list_1;//0x000248[0x000008]
//	void* list_2;//0x000250[0x000008]
//	void* betterPropagationVolume_0;//0x000258[0x000008]
//	void* action_5;//0x000260[0x000008]
//	void* POM;//0x000268[0x000008]
//	void* TriggerZones;//0x000270[0x000008]
//	void* OnExitTriggerVisited;//0x000278[0x000008]
//	void* InteractingWithExfiltrationPoint;//0x000280[0x000008]
//	void* _animators;//0x000288[0x000008]
//	void* Speaker;//0x000290[0x000008]
//	void* gdelegate32_0;//0x000298[0x000008]
//	void* gdelegate33_0;//0x0002A0[0x000008]
//	void* Spirit;//0x0002A8[0x000008]
//	void* Logger;//0x0002B0[0x000008]
//	void* Corpse;//0x0002B8[0x000008]
//	CPlayer* LastAggressor;//0x0002C0[0x000008]
//	char LastDamageInfo[0x0000B0];//0x0002C8[0x0000B0]
//	void* GetSensitivity;//0x000378[0x000008]
//	void* GetAimingSensitivity;//0x000380[0x000008]
//	void* _openAction;//0x000388[0x000008]
//	void* ginterface136_0;//0x000390[0x000008]
//	void* renderer_0;//0x000398[0x000008]
//	void* camera_0;//0x0003A0[0x000008]
//	void* coroutine_6;//0x0003A8[0x000008]
//	void* coroutine_7;//0x0003B0[0x000008]
//	void* list_3;//0x0003B8[0x000008]
//	void* gclass2251_0;//0x0003C0[0x000008]
//	void* animator_0;//0x0003C8[0x000008]
//	void* runtimeAnimatorController_0;//0x0003D0[0x000008]
//	void* action_6;//0x0003D8[0x000008]
//	void* action_7;//0x0003E0[0x000008]
//	void* action_8;//0x0003E8[0x000008]
//	void* action_9;//0x0003F0[0x000008]
//	void* genericEventTranslator_0;//0x0003F8[0x000008]
//	void* gclass1107_0;//0x000400[0x000008]
//	void* gclass1107_1;//0x000408[0x000008]
//	void* gclass1107_2;//0x000410[0x000008]
//	void* gclass1107_3;//0x000418[0x000008]
//	CUnityString* string_0;//0x000420[0x000008]
//	void* ispawnPoint_0;//0x000428[0x000008]
//	void* interactableObject_0;//0x000430[0x000008]
//	CPlayer* player_0;//0x000438[0x000008]
//	void* placeItemTrigger_0;//0x000440[0x000008]
//	void* exfiltrationPoint_0;//0x000448[0x000008]
//	void* gclass1932_0;//0x000450[0x000008]
//	CProfile* profile_0;//0x000458[0x000008]
//	void* ginterface104_0;//0x000460[0x000008]
//	CGClass440* Physical;//0x000468[0x000008]
//	void* action_10;//0x000470[0x000008]
//	void* gclass285_0;//0x000478[0x000008]
//	void* dictionary_1;//0x000480[0x000008]
//	void* _healthController;//0x000488[0x000008]
//	void* _hitColliders;//0x000490[0x000008]
//	CGClass1797* _inventoryController;//0x000498[0x000008]
//	void* _handsController;//0x0004A0[0x000008]
//	void* _questController;//0x0004A8[0x000008]
//	void* playerToGrassConnector_0;//0x0004B0[0x000008]
//	void* action_11;//0x0004B8[0x000008]
//	CUnityString* string_1;//0x0004C0[0x000008]
//	void* Tracking;//0x0004C8[0x000008]
//	void* gdelegate26_1;//0x0004D0[0x000008]
//	void* waitForFixedUpdate_0;//0x0004D8[0x000008]
//	void* _playerLookRaycastTransform;//0x0004E0[0x000008]
//	CPlayerBones* PlayerBones;//0x0004E8[0x000008]
//	void* _preAllocatedArmorComponents;//0x0004F0[0x000008]
//	void* action_12;//0x0004F8[0x000008]
//	void* gclass270_0;//0x000500[0x000008]
//	void* ExfilUnsubscribe;//0x000508[0x000008]
//	void* SessionEndUnsubscribe;//0x000510[0x000008]
//	void* abstractProcess_0;//0x000518[0x000008]
//	void* slot_0;//0x000520[0x000008]
//	void* action_13;//0x000528[0x000008]
//	void* action_14;//0x000530[0x000008]
//	CUnityTArray<__int32>* equipmentSlot_0;//0x000538[0x000008]
//	void* _removeFromHandsCallback;//0x000540[0x000008]
//	void* callback_0;//0x000548[0x000008]
//	bool bool_0;//0x000550[0x000001]
//	unsigned char _0x00000551[0x3];//0x00000551 (0x3) MISSED OFFSET
//	float float_0;//0x000554[0x000004]
//	float float_1;//0x000558[0x000004]
//	bool bool_1;//0x00055C[0x000001]
//	bool bool_2;//0x00055D[0x000001]
//	unsigned char _0x0000055E[0x2];//0x0000055E (0x2) MISSED OFFSET
//	FVec3 HeadRotation;//0x000560[0x00000C]
//	float _mouseSensitivityModifier;//0x00056C[0x000004]
//	FVec2 vector2_0;//0x000570[0x000008]
//	FVec2 vector2_1;//0x000578[0x000008]
//	float TrunkRotationLimit;//0x000580[0x000004]
//	float PoseMemo;//0x000584[0x000004]
//	float float_2;//0x000588[0x000004]
//	float float_3;//0x00058C[0x000004]
//	float float_4;//0x000590[0x000004]
//	float _prevHeight;//0x000594[0x000004]
//	float HeightSmoothTime;//0x000598[0x000004]
//	float float_5;//0x00059C[0x000004]
//	float float_6;//0x0005A0[0x000004]
//	float float_7;//0x0005A4[0x000004]
//	float RibcageScaleCurrent;//0x0005A8[0x000004]
//	float RibcageScaleCurrentTarget;//0x0005AC[0x000004]
//	FVec2 UtilityLayerRange;//0x0005B0[0x000008]
//	float UtilityLayerLerpSpeed;//0x0005B8[0x000004]
//	bool GripAutoAdjust;//0x0005BC[0x000001]
//	unsigned char _0x000005BD[0x3];//0x000005BD (0x3) MISSED OFFSET
//	float ThirdPersonWeaponRootAuthority;//0x0005C0[0x000004]
//	float float_9;//0x0005C4[0x000004]
//	float float_10;//0x0005C8[0x000004]
//	float float_11;//0x0005CC[0x000004]
//	float float_12;//0x0005D0[0x000004]
//	float float_13;//0x0005D4[0x000004]
//	float float_14;//0x0005D8[0x000004]
//	float float_15;//0x0005DC[0x000004]
//	float float_16;//0x0005E0[0x000004]
//	float float_17;//0x0005E4[0x000004]
//	float float_18;//0x0005E8[0x000004]
//	float float_19;//0x0005EC[0x000004]
//	bool bool_3;//0x0005F0[0x000001]
//	bool bool_4;//0x0005F1[0x000001]
//	bool bool_5;//0x0005F2[0x000001]
//	bool bool_6;//0x0005F3[0x000001]
//	bool bool_7;//0x0005F4[0x000001]
//	bool bool_8;//0x0005F5[0x000001]
//	unsigned char _0x000005F6[0x2];//0x000005F6 (0x2) MISSED OFFSET
//	FVec3 vector3_1;//0x0005F8[0x00000C]
//	FVec3 vector3_2;//0x000604[0x00000C]
//	FVec3 vector3_3;//0x000610[0x00000C]
//	FVec3 vector3_4;//0x00061C[0x00000C]
//	FVec3 vector3_5;//0x000628[0x00000C]
//	FVec4 quaternion_0;//0x000634[0x000010]
//	FVec4 quaternion_1;//0x000644[0x000010]
//	FVec4 quaternion_2;//0x000654[0x000010]
//	float float_20;//0x000664[0x000004]
//	float float_21;//0x000668[0x000004]
//	bool _isDeadAlready;//0x00066C[0x000001]
//	bool bool_9;//0x00066D[0x000001]
//	unsigned char _0x0000066E[0x2];//0x0000066E (0x2) MISSED OFFSET
//	FVec3 vector3_6;//0x000670[0x00000C]
//	FVec4 quaternion_4;//0x00067C[0x000010]
//	bool bool_10;//0x00068C[0x000001]
//	unsigned char _0x0000068D[0x3];//0x0000068D (0x3) MISSED OFFSET
//	int CurrentSurface;//0x000690[0x000004]
//	int environmentType_0;//0x000694[0x000004]
//	bool HeavyBreath;//0x000698[0x000001]
//	unsigned char _0x00000699[0x3];//0x00000699 (0x3) MISSED OFFSET
//	float VerticalSoundFactor;//0x00069C[0x000004]
//	bool Muffled;//0x0006A0[0x000001]
//	unsigned char _0x000006A1[0x3];//0x000006A1 (0x3) MISSED OFFSET
//	char raycastHit_0[0x00002C];//0x0006A4[0x00002C]
//	bool bool_11;//0x0006D0[0x000001]
//	bool OcclusionDirty;//0x0006D1[0x000001]
//	bool DistanceDirty;//0x0006D2[0x000001]
//	bool PreviousFaceShield;//0x0006D3[0x000001]
//	FVec3 SpeechLocalPosition;//0x0006D4[0x00000C]
//	int layerMask_0;//0x0006E0[0x000004]
//	bool bool_12;//0x0006E4[0x000001]
//	unsigned char _0x000006E5[0x3];//0x000006E5 (0x3) MISSED OFFSET
//	float float_25;//0x0006E8[0x000004]
//	float float_26;//0x0006EC[0x000004]
//	float float_28;//0x0006F0[0x000004]
//	float float_29;//0x0006F4[0x000004]
//	bool bool_13;//0x0006F8[0x000001]
//	unsigned char _0x000006F9[0x3];//0x000006F9 (0x3) MISSED OFFSET
//	float float_30;//0x0006FC[0x000004]
//	float float_31;//0x000700[0x000004]
//	float float_32;//0x000704[0x000004]
//	float float_33;//0x000708[0x000004]
//	float float_34;//0x00070C[0x000004]
//	float float_35;//0x000710[0x000004]
//	float float_36;//0x000714[0x000004]
//	float float_37;//0x000718[0x000004]
//	float float_38;//0x00071C[0x000004]
//	float float_39;//0x000720[0x000004]
//	float float_40;//0x000724[0x000004]
//	bool bool_14;//0x000728[0x000001]
//	unsigned char _0x00000729[0x3];//0x00000729 (0x3) MISSED OFFSET
//	int LastDamageType;//0x00072C[0x000004]
//	int LastDamagedBodyPart;//0x000730[0x000004]
//	bool PlacingBeacon;//0x000734[0x000001]
//	bool Destroyed;//0x000735[0x000001]
//	unsigned char _0x00000736[0x2];//0x00000736 (0x2) MISSED OFFSET
//	int EnabledAnimators;//0x000738[0x000004]
//	int LastBodyPart;//0x00073C[0x000004]
//	float _corpseAppliedForce;//0x000740[0x000004]
//	float float_41;//0x000744[0x000004]
//	float float_42;//0x000748[0x000004]
//	__int32 int_3;//0x00074C[0x000004]
//	bool bool_15;//0x000750[0x000001]
//	bool bool_16;//0x000751[0x000001]
//	bool bool_17;//0x000752[0x000001]
//	bool bool_18;//0x000753[0x000001]
//	bool bool_19;//0x000754[0x000001]
//	unsigned char _0x00000755[0x3];//0x00000755 (0x3) MISSED OFFSET
//	float float_43;//0x000758[0x000004]
//	bool bool_20;//0x00075C[0x000001]
//	bool bool_21;//0x00075D[0x000001]
//	unsigned char _0x0000075E[0x2];//0x0000075E (0x2) MISSED OFFSET
//	__int32 int_4;//0x000760[0x000004]
//	int _updateQueue;//0x000764[0x000004]
//	int _armsUpdateQueue;//0x000768[0x000004]
//	int _armsUpdateMode;//0x00076C[0x000004]
//	int _bodyUpdateMode;//0x000770[0x000004]
//	float float_44;//0x000774[0x000004]
//	bool _armsupdated;//0x000778[0x000001]
//	unsigned char _0x00000779[0x3];//0x00000779 (0x3) MISSED OFFSET
//	float _armsTime;//0x00077C[0x000004]
//	bool _bodyupdated;//0x000780[0x000001]
//	unsigned char _0x00000781[0x3];//0x00000781 (0x3) MISSED OFFSET
//	float _bodyTime;//0x000784[0x000004]
//	__int32 _nFixedFrames;//0x000788[0x000004]
//	float _fixedTime;//0x00078C[0x000004]
//	float LastDeltaTime;//0x000790[0x000004]
//	bool _manuallyUpdated;//0x000794[0x000001]
//	CEDoorState edoorState_0;//0x000795[0x000001]
//	bool bool_22;//0x000796[0x000001]
//	bool bool_23;//0x000797[0x000001]
//	bool bool_24;//0x000798[0x000001]
//	bool bool_25;//0x000799[0x000001]
//	bool AggressorFound;//0x00079A[0x000001]
//	bool bool_26;//0x00079B[0x000001]
//	int eprocessStatus_0;//0x00079C[0x000004]
//	float float_45;//0x0007A0[0x000004]
//	__int32 int_5;//0x0007A4[0x000004]
//
//};
class CPoolSafeMonoBehaviour : public CUnityMonoBehaviourScript
{
public:
	char _0x0018[0x08];									//0x0018
};
class CCamera : public CUnityMonoBehaviourScript
{
public:
	CUnityGameObject *GetGameObject();
};
struct CamerasArray
{
	CCamera**	Cameras;			//0x0000
	INT64		SizeMin;			//0x0008
	INT64		SizeCur;			//0x0010
	INT64		SizeMax;			//0x0018
};
class CVisorEffect
{
public:
	char _0x0000[0x00B8];
	float Intensity;//0x0000B8[0x000004]
};
class CNightvision
{
public:
	char _0x0000[0x00A8];
	float Intensity;//0x0000A8[0x000004]
	char _0x00AC[0x0020];
	bool _on;//0x0000CC[0x000001]
};
class CThermalVision
{
public:
	char _0x0000[0x00D0];
	bool _on;//0x0000D0[0x000001]
};
//class CInteractableObject : public CPoolSafeMonoBehaviour
//{
//public:
//	char _0x0020[0x20];
//};
//
//class CWorldInteractiveObject : public CInteractableObject
//{
//public:
//	CUnityString* KeyId;//0x000040[0x000008]
//	CUnityString* Id;//0x000048[0x000008]
//	class CDoorHandle* LockHandle;//0x000050[0x000008]
//	CUnityTArray<class CAudioClip*>* ShutSound;//0x000058[0x000008]
//	CUnityTArray<class CAudioClip*>* SqueakSound;//0x000060[0x000008]
//	CUnityTArray<class CAudioClip*>* OpenSound;//0x000068[0x000008]
//	class CNavMeshObstacle* Obstacle;//0x000070[0x000008]
//	class CCollider* collider_0;//0x000078[0x000008]
//	class CGDelegate45* gdelegate45_0;//0x000080[0x000008]
//	class CInteractionState* _interaction;//0x000088[0x000008]
//	class CInteractionState* _previousInteraction;//0x000090[0x000008]
//	class CDoorHandle* _handle;//0x000098[0x000008]
//	class CUnityTArray<class CGripPose*>* Grips;//0x0000A0[0x000008]
//	CEDoorState Snap;//0x0000A8[0x000001]
//	unsigned char _0x000000A9[0x3];//0x000000A9 (0x3) MISSED OFFSET
//	__int32 int_2;//0x0000AC[0x000004]
//	float _currentAngle;//0x0000B0[0x000004]
//	FVec3 interactPosition1;//0x0000B4[0x00000C]
//	FVec3 interactPosition2;//0x0000C0[0x00000C]
//	FVec3 viewTarget1;//0x0000CC[0x00000C]
//	float OpenAngle;//0x0000D8[0x000004]
//	float CloseAngle;//0x0000DC[0x000004]
//	int DoorAxis;//0x0000E0[0x000004]
//	int DoorForward;//0x0000E4[0x000004]
//	__int32 PushID;//0x0000E8[0x000004]
//	__int32 CloseID;//0x0000EC[0x000004]
//	float ShutShift;//0x0000F0[0x000004]
//	float _ignoreSyncUntil;//0x0000F4[0x000004]
//	CEDoorState edoorState_0;//0x0000F8[0x000001]
//	CEDoorState _doorState;//0x0000F9[0x000001]
//	CEDoorState edoorState_1;//0x0000FA[0x000001]
//	bool Operatable;//0x0000FB[0x000001]
//	bool _shutPlayed;//0x0000FC[0x000001]
//	bool bool_0;//0x0000FD[0x000001]
//	CEDoorState edoorState_2;//0x0000FE[0x000001]
//	unsigned char _0x000000FF[0x1];//0x000000FF (0x1) MISSED OFFSET
//	float float_4;//0x000100[0x000004]
//	unsigned char _0x00000104[0x4];//0x00000104 (0x4) MISSED OFFSET
//};
//class CDoor : public CWorldInteractiveObject
//{
//public:
//};
```

`README.md`:

```md
# EFTLeecher
DMA Toolbox for Escape From Tarkov

```

`Settings.ini`:

```ini
[ToolBox]
HWID=DEV_HWID
RemoveVisorEffects=0
NightVisionEffect=0
ThermalVisionEffect=0
NoRecoil=1
NoStamina=1
UnlockEverything=1
NoWeight=0
UseMapFile=0
StealthInjection=1
RemoveConnections=1
AutoDisconnect=0
Level_Enabled_0=0
Level_0=51
Level_Buffer_0=0
Level_Enabled_1=0
Level_1=50
Level_Buffer_1=0
Level_Enabled_2=0
Level_2=0
Level_Buffer_2=0
Level_Enabled_3=0
Level_3=0
Level_Buffer_3=0
Level_Enabled_4=0
Level_4=0
Level_Buffer_4=0
Level_Enabled_5=0
Level_5=0
Level_Buffer_5=0
Level_Enabled_6=0
Level_6=0
Level_Buffer_6=0
Level_Enabled_7=1
Level_7=20
Level_Buffer_7=0
Level_Enabled_8=0
Level_8=0
Level_Buffer_8=0
Level_Enabled_9=0
Level_9=0
Level_Buffer_9=0
Level_Enabled_10=0
Level_10=0
Level_Buffer_10=0
Level_Enabled_11=0
Level_11=0
Level_Buffer_11=0
Level_Enabled_12=0
Level_12=0
Level_Buffer_12=0
Level_Enabled_13=0
Level_13=0
Level_Buffer_13=0
Level_Enabled_14=0
Level_14=0
Level_Buffer_14=0
Level_Enabled_15=0
Level_15=0
Level_Buffer_15=0
Level_Enabled_16=0
Level_16=0
Level_Buffer_16=0
Level_Enabled_17=0
Level_17=0
Level_Buffer_17=0
Level_Enabled_18=0
Level_18=0
Level_Buffer_18=0
Level_Enabled_19=0
Level_19=0
Level_Buffer_19=0
Level_Enabled_20=0
Level_20=0
Level_Buffer_20=0
Level_Enabled_21=0
Level_21=0
Level_Buffer_21=0
Level_Enabled_22=0
Level_22=0
Level_Buffer_22=0
Level_Enabled_23=0
Level_23=0
Level_Buffer_23=0
Level_Enabled_24=0
Level_24=0
Level_Buffer_24=0
Level_Enabled_25=0
Level_25=0
Level_Buffer_25=0
Level_Enabled_26=0
Level_26=0
Level_Buffer_26=0
Level_Enabled_27=0
Level_27=0
Level_Buffer_27=0
Level_Enabled_28=0
Level_28=0
Level_Buffer_28=0
Level_Enabled_29=0
Level_29=0
Level_Buffer_29=0
Level_Enabled_30=0
Level_30=0
Level_Buffer_30=0
Level_Enabled_31=0
Level_31=0
Level_Buffer_31=0
Level_Enabled_32=0
Level_32=0
Level_Buffer_32=0
Level_Enabled_33=0
Level_33=0
Level_Buffer_33=0
Level_Enabled_34=0
Level_34=0
Level_Buffer_34=0
Level_Enabled_35=0
Level_35=0
Level_Buffer_35=0
Level_Enabled_36=0
Level_36=0
Level_Buffer_36=0
Level_Enabled_37=0
Level_37=0
Level_Buffer_37=0
Level_Enabled_38=0
Level_38=0
Level_Buffer_38=0
Level_Enabled_39=0
Level_39=0
Level_Buffer_39=0
Level_Enabled_40=0
Level_40=0
Level_Buffer_40=0
Level_Enabled_41=0
Level_41=0
Level_Buffer_41=0
Level_Enabled_42=0
Level_42=0
Level_Buffer_42=0
Level_Enabled_43=0
Level_43=0
Level_Buffer_43=0
Level_Enabled_44=0
Level_44=0
Level_Buffer_44=0
Level_Enabled_45=0
Level_45=0
Level_Buffer_45=0
Level_Enabled_46=0
Level_46=0
Level_Buffer_46=0
Level_Enabled_47=0
Level_47=0
Level_Buffer_47=0
Level_Enabled_48=0
Level_48=0
Level_Buffer_48=0
Level_Enabled_49=0
Level_49=0
Level_Buffer_49=0
Level_Enabled_50=0
Level_50=0
Level_Buffer_50=0
Level_Enabled_51=0
Level_51=0
Level_Buffer_51=0
Level_Enabled_52=0
Level_52=0
Level_Buffer_52=0
Level_Enabled_53=0
Level_53=0
Level_Buffer_53=0
Level_Enabled_54=0
Level_54=0
Level_Buffer_54=0
Level_Enabled_55=0
Level_55=0
Level_Buffer_55=0
Level_Enabled_56=0
Level_56=0
Level_Buffer_56=0
Level_Enabled_57=0
Level_57=0
Level_Buffer_57=0
Level_Enabled_58=0
Level_58=0
Level_Buffer_58=0
Level_Enabled_59=0
Level_59=0
Level_Buffer_59=0
Level_Enabled_60=0
Level_60=0
Level_Buffer_60=0
Level_Enabled_61=0
Level_61=0
Level_Buffer_61=0
Level_Enabled_62=0
Level_62=0
Level_Buffer_62=0
Level_Enabled_63=0
Level_63=0
Level_Buffer_63=0
Level_Enabled_64=0
Level_64=0
Level_Buffer_64=0
Level_Enabled_65=0
Level_65=0
Level_Buffer_65=0
Level_Enabled_66=0
Level_66=0
Level_Buffer_66=0
JumpMultiplier=1
ThrowMultiplier=1
HearingMultiplier=1
Aimbot_Bone=133
Aimbot_Hotkey=324
Aimbot_Enabled=0
Aimbot_Enable=1

```

`globals.h`:

```h
//pragma once tells C++ compiler if you include this file more then once it will only ever be included more then once so you dont get include errors
#pragma once
//this is a C++ trick / hack that tells dialogs to use the better looking dialogs :)
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#define _CRT_SECURE_NO_WARNINGS
//include any EXTRA files
#include <windows.h>
#include <stdio.h>
#include "leechcore.h"
#include "vmmdll.h"
#include <utility>
#include <TlHelp32.h>
#include <CommCtrl.h>
#include <emmintrin.h>
#include <xmmintrin.h>
#pragma comment(lib,"leechcore.lib")
#pragma comment(lib,"vmm.lib")
#include "resource.h"
#include "Dialog Callbacks.h"

//defines this is where you define anything defines are just basically "static globals/variables" but with #define its telling the compiler you are defining it for compiling

#define REMOTE_PROCESS "EscapeFromTarkov.exe"

#define DEBUG_CONSOLE
//#define ENABLE_AIMBOT

#define INPUT_MANAGER		0x0156C448
#define UNITY_OBJECT_LIST	0x0156C698
#define UNITY_CAMERA_LIST	0x0150EA00

#define SAFE_DELETE_ARRAY(x) if(x) { delete [] x; x = 0; }
#define SAFE_FREE_ALLOC(x) if(x) { LocalFree(x); x = 0; }





typedef enum _OBJECT_INFORMATION_CLASS
{
	ObjectBasicInformation, // OBJECT_BASIC_INFORMATION
	ObjectNameInformation, // OBJECT_NAME_INFORMATION
	ObjectTypeInformation, // OBJECT_TYPE_INFORMATION
	ObjectTypesInformation, // OBJECT_TYPES_INFORMATION
	ObjectHandleFlagInformation, // OBJECT_HANDLE_FLAG_INFORMATION
	ObjectSessionInformation,
	ObjectSessionObjectInformation,
	MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

typedef struct _OBJECT_NAME_INFORMATION
{
	UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	UCHAR TypeIndex; // since WINBLUE
	CHAR ReservedByte;
	ULONG PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

#ifndef NT_SUCCESS
#define NT_SUCCESS(x) ((x) >= 0)
#endif //!NT_SUCCESS

#ifndef STATUS_NOT_FOUND
#define STATUS_NOT_FOUND               ((NTSTATUS)0xC0000225L)
#endif //!STATUS_NOT_FOUND

#ifndef STATUS_INFO_LENGTH_MISMATCH
#define STATUS_INFO_LENGTH_MISMATCH    ((NTSTATUS)0xC0000004L)
#endif //!STATUS_INFO_LENGTH_MISMATCH

//extern is just declaring that we have a variable by this name but its else where!
//when declaring extern MAKE sure you declare it else where
extern char szSettingsFile[];
extern DWORD dwConnectionStatusColor;
extern float fMaxStamina;
extern bool bLocalPlayerFound;
extern bool bWorldPointerFound;
extern bool bAutoDisconnectAfterRaidEnds;
extern bool bRemoveVisorEffects;
extern bool bNightVisionEffect;
extern bool bThermalVisionEffect;
extern bool bNoWeight;
extern bool bNoRecoil;
extern bool bNoStamina;
extern bool bUnlockEverything;
extern int iJumpMultiplier;
extern int iThrowMultiplier;
extern int iHearingMultiplier;

#ifdef ENABLE_AIMBOT
extern bool bAimbotEnabled;
extern int iAimbotBone;
extern int iAimbotHotkey;
#endif
#define D3DX_PI                        ((FLOAT)  3.141592654f)
#define D3DXToRadian(degree)        ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree(radian)        ((radian) * (180.0f / D3DX_PI))

//we include OTHER files here due to the fact we have defines and static globals above that the header files MIGHT use so just incase lets include files here so the files CAN access what they require!
#include "MonoClasses.h"
#include "DMADevice.h"
#include "MainThread.h"
```

`leechcore.h`:

```h
// leechcore.h : external header of the LeechCore library.
//
// LeechCore is a library which abstracts away reading and writing to various
// software and hardware acquisition sources. Sources ranges from memory dump
// files to driver backed live memory to hardware (FPGA) DMA backed memory.
//
// LeechCore built-in device support may be extended with external plugin
// device drivers placed as .dll or .so files in the same folder as LeechCore.
//
// For more information please consult the LeechCore information on Github:
// - README: https://github.com/ufrisk/LeechCore
// - GUIDE:  https://github.com/ufrisk/LeechCore/wiki
//
// (c) Ulf Frisk, 2020-2021
// Author: Ulf Frisk, pcileech@frizk.net
//
// Header Version: 2.6
//

#ifndef __LEECHCORE_H__
#define __LEECHCORE_H__
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

//-----------------------------------------------------------------------------
// OS COMPATIBILITY BELOW:
//-----------------------------------------------------------------------------

#ifdef _WIN32

#include <Windows.h>
#define EXPORTED_FUNCTION                   __declspec(dllexport)
typedef unsigned __int64                    QWORD, *PQWORD;

#endif /* _WIN32 */
#ifdef LINUX

#include <inttypes.h>
#include <stdlib.h>
#define EXPORTED_FUNCTION                   __attribute__((visibility("default")))
typedef void                                VOID, *PVOID, *HANDLE, **PHANDLE, *HMODULE;
typedef long long unsigned int              QWORD, *PQWORD, ULONG64, *PULONG64;
typedef uint64_t                            SIZE_T, *PSIZE_T, FILETIME, *PFILETIME;
typedef uint32_t                            DWORD, *PDWORD, *LPDWORD, BOOL, *PBOOL, NTSTATUS;
typedef uint16_t                            WORD, *PWORD;
typedef uint8_t                             BYTE, *PBYTE, *LPBYTE, UCHAR;
typedef char                                CHAR, *PCHAR, *LPSTR, *LPCSTR;
typedef uint16_t                            WCHAR, *PWCHAR, *LPWSTR, *LPCWSTR;
#define MAX_PATH                            260
#define _In_
#define _In_z_
#define _In_opt_
#define _In_reads_(x)
#define _In_reads_opt_(x)
#define _Inout_
#define _Inout_bytecount_(x)
#define _Inout_opt_
#define _Inout_updates_opt_(x)
#define _Out_
#define _Out_opt_
#define _Out_writes_(x)
#define _Out_writes_bytes_opt_(x)
#define _Out_writes_opt_(x)
#define _Out_writes_to_(x,y)
#define _When_(x,y)
#define _Frees_ptr_opt_
#define _Post_ptr_invalid_
#define _Check_return_opt_
#define _Printf_format_string_
#define _Success_(x)

#endif /* LINUX */



//-----------------------------------------------------------------------------
// Create and Close LeechCore devices:
// It's possible to create multiple LeechCore devices in parallel and also of
// different types if the underlying device will allow this. LeechCore will
// automatically take care of and abstract away any hardware/software issues
// with regards to the underlying devices.
//
// For more information about supported devices please check out the LeechCore
// guide at: https://github.com/ufrisk/LeechCore/wiki
//-----------------------------------------------------------------------------

#define LC_CONFIG_VERSION                       0xc0fd0002
#define LC_CONFIG_ERRORINFO_VERSION             0xc0fe0002

#define LC_CONFIG_PRINTF_ENABLED                0x01
#define LC_CONFIG_PRINTF_V                      0x02
#define LC_CONFIG_PRINTF_VV                     0x04
#define LC_CONFIG_PRINTF_VVV                    0x08

typedef struct LC_CONFIG {
    // below are set by caller
    DWORD dwVersion;                        // must equal LC_CREATE_VERSION
    DWORD dwPrintfVerbosity;                // printf verbosity according to LC_PRINTF_*
    CHAR szDevice[MAX_PATH];                // device connection string - see wiki for additional info.
    CHAR szRemote[MAX_PATH];                // remote connection striLC_CONFIG_VERSIONng - see wiki for additional info.
    _Check_return_opt_ int(*pfn_printf_opt)(_In_z_ _Printf_format_string_ char const *const _Format, ...);
    // below are set by caller, updated by LeecCore
    QWORD paMax;                            // max physical address (disables any max address auto-detect).
    // below are set by LeechCore
    BOOL fVolatile;
    BOOL fWritable;
    BOOL fRemote;
    BOOL fRemoteDisableCompress;
    CHAR szDeviceName[MAX_PATH];            // device name - such as 'fpga' or 'file'.
} LC_CONFIG, *PLC_CONFIG;

typedef struct tdLC_CONFIG_ERRORINFO {
    DWORD dwVersion;                        // must equal LC_CONFIG_ERRORINFO_VERSION
    DWORD cbStruct;
    DWORD _FutureUse[16];
    BOOL fUserInputRequest;
    DWORD cwszUserText;
    WCHAR wszUserText[];
} LC_CONFIG_ERRORINFO, *PLC_CONFIG_ERRORINFO, **PPLC_CONFIG_ERRORINFO;

/*
* Create a new LeechCore device according to the supplied configuration.
* CALLER LcMemFree: ppLcCreateErrorInfo
* -- pLcCreateConfig
* -- ppLcCreateErrorInfo = ptr to receive function allocated struct with error
*       information upon function failure. This info may contain a user message
*       requesting user action as an example. Any returned struct should be
*       free'd by a call to LcMemFree().
* -- return
*/
_Success_(return != NULL)
EXPORTED_FUNCTION HANDLE LcCreate(
    _Inout_ PLC_CONFIG pLcCreateConfig
);

_Success_(return != NULL)
EXPORTED_FUNCTION HANDLE LcCreateEx(
    _Inout_ PLC_CONFIG pLcCreateConfig,
    _Out_opt_ PPLC_CONFIG_ERRORINFO ppLcCreateErrorInfo
);

/*
* Close a LeechCore handle and free any resources no longer needed.
*/
EXPORTED_FUNCTION VOID LcClose(
    _In_opt_ _Post_ptr_invalid_ HANDLE hLC
);



//-----------------------------------------------------------------------------
// Read and Write memory from underlying device either using contiguous method
// or more recommended scatter method.
//
// The MEM_SCATTER struct allows reading and writing of discontiguous memory
// chunks which must adhere to the following rules:
// - maximum size = 0x1000 (4096) bytes = recommended size.
// - minimum size = 2 DWORDs (8 bytes).
// - must be DWORD (4 byte) aligned.
// - must never cross 0x1000 page boundary.
// - max value of iStack = MEM_SCATTER_STACK_SIZE - 2.
//-----------------------------------------------------------------------------

#define MEM_SCATTER_VERSION                 0xc0fe0002
#define MEM_SCATTER_STACK_SIZE              12

typedef struct tdMEM_SCATTER {
    DWORD version;                          // MEM_SCATTER_VERSION
    BOOL f;                                 // TRUE = success data in pb, FALSE = fail or not yet read.
    QWORD qwA;                              // address of memory to read
    PBYTE pb;                               // buffer to hold memory contents
    DWORD cb;                               // size of buffer to hold memory contents.
    DWORD iStack;                           // internal stack pointer
    QWORD vStack[MEM_SCATTER_STACK_SIZE];   // internal stack
} MEM_SCATTER, *PMEM_SCATTER, **PPMEM_SCATTER;

#define MEM_SCATTER_ADDR_INVALID            ((QWORD)-1)
#define MEM_SCATTER_ADDR_ISINVALID(pMEM)    (pMEM->qwA == (QWORD)-1)
#define MEM_SCATTER_ADDR_ISVALID(pMEM)      (pMEM->qwA != (QWORD)-1)
#define MEM_SCATTER_STACK_PUSH(pMEM, v)     (pMEM->vStack[pMEM->iStack++] = (QWORD)v)
#define MEM_SCATTER_STACK_PEEK(pMEM, i)     (pMEM->vStack[pMEM->iStack - i])
#define MEM_SCATTER_STACK_SET(pMEM, i, v)   (pMEM->vStack[pMEM->iStack - i] = (QWORD)v)
#define MEM_SCATTER_STACK_ADD(pMEM, i, v)   (pMEM->vStack[pMEM->iStack - i] += (QWORD)v)
#define MEM_SCATTER_STACK_POP(pMEM)         (pMEM->vStack[--pMEM->iStack])

/*
* Free LeechCore allocated memory such as memory allocated by the
* LcAllocScatter / LcCommand functions.
* -- pv
*/
EXPORTED_FUNCTION VOID LcMemFree(
    _Frees_ptr_opt_ PVOID pv
);

/*
* Allocate and pre-initialize empty MEMs including a 0x1000 buffer for each
* pMEM. The result should be freed by LcFree when its no longer needed.
* -- cMEMs
* -- pppMEMs = pointer to receive ppMEMs
* -- return
*/
_Success_(return)
EXPORTED_FUNCTION BOOL LcAllocScatter1(
    _In_ DWORD cMEMs,
    _Out_ PPMEM_SCATTER *pppMEMs
);

/*
* Allocate and pre-initialize empty MEMs excluding the 0x1000 buffer which
* will be accounted towards the pbData buffer in a contiguous way.
* The result should be freed by LcFree when its no longer needed.
* -- cbData = size of pbData (must be cMEMs * 0x1000)
* -- pbData = buffer used for MEM.pb
* -- cMEMs
* -- pppMEMs = pointer to receive ppMEMs
* -- return
*/
_Success_(return)
EXPORTED_FUNCTION BOOL LcAllocScatter2(
    _In_ DWORD cbData,
    _Inout_updates_opt_(cbData) PBYTE pbData,
    _In_ DWORD cMEMs,
    _Out_ PPMEM_SCATTER *pppMEMs
);

/*
* Allocate and pre-initialize empty MEMs excluding the 0x1000 buffer which
* will be accounted towards the pbData buffer in a contiguous way.
* -- pbDataFirstPage = optional buffer of first page
* -- pbDataLastPage = optional buffer of last page
* -- cbData = size of pbData
* -- pbData = buffer used for MEM.pb except first/last if exists
* -- cMEMs
* -- pppMEMs = pointer to receive ppMEMs
* -- return
*/
_Success_(return)
EXPORTED_FUNCTION BOOL LcAllocScatter3(
    _Inout_updates_opt_(0x1000) PBYTE pbDataFirstPage,
    _Inout_updates_opt_(0x1000) PBYTE pbDataLastPage,
    _In_ DWORD cbData,
    _Inout_updates_opt_(cbData) PBYTE pbData,
    _In_ DWORD cMEMs,
    _Out_ PPMEM_SCATTER *pppMEMs
);

/*
* Read memory in a scattered non-contiguous way. This is recommended for reads.
* -- hLC
* -- cMEMs
* -- ppMEMs
*/
EXPORTED_FUNCTION VOID LcReadScatter(
    _In_ HANDLE hLC,
    _In_ DWORD cMEMs,
    _Inout_ PPMEM_SCATTER ppMEMs
);

/*
* Read memory in a contiguous way. Note that if multiple memory segments are
* to be read LcReadScatter() may be more efficient.
* -- hLC,
* -- pa
* -- cb
* -- pb
* -- return
*/
_Success_(return)
EXPORTED_FUNCTION BOOL LcRead(
    _In_ HANDLE hLC,
    _In_ QWORD pa,
    _In_ DWORD cb,
    _Out_writes_(cb) PBYTE pb
);

/*
* Write memory in a scattered non-contiguous way.
* -- hLC
* -- cMEMs
* -- ppMEMs
*/
EXPORTED_FUNCTION VOID LcWriteScatter(
    _In_ HANDLE hLC,
    _In_ DWORD cMEMs,
    _Inout_ PPMEM_SCATTER ppMEMs
);

/*
* Write memory in a contiguous way.
* -- hLC
* -- pa
* -- cb
* -- pb
* -- return
*/
_Success_(return)
EXPORTED_FUNCTION BOOL LcWrite(
    _In_ HANDLE hLC,
    _In_ QWORD pa,
    _In_ DWORD cb,
    _In_reads_(cb) PBYTE pb
);



//-----------------------------------------------------------------------------
// Get/Set/Command functionality may be used to query and/or update LeechCore
// or its devices in various ways.
//-----------------------------------------------------------------------------

/*
* Set an option as defined by LC_OPT_*. (R option).
* -- hLC
* -- fOption = LC_OPT_*
* -- cbData
* -- pbData
* -- pcbData
*/
_Success_(return)
EXPORTED_FUNCTION BOOL LcGetOption(
    _In_ HANDLE hLC,
    _In_ QWORD fOption,
    _Out_ PQWORD pqwValue
);

/*
* Get an option as defined by LC_OPT_*. (W option).
* -- hLC
* -- fOption = LC_OPT_*
* -- cbData
* -- pbData
*/
_Success_(return)
EXPORTED_FUNCTION BOOL LcSetOption(
    _In_ HANDLE hLC,
    _In_ QWORD fOption,
    _In_ QWORD qwValue
);

/*
* Execute a command and retrieve a result (if any) at the same time.
* NB! If *ppbDataOut contains a memory allocation on exit this should be free'd
*     by calling LcMemFree().
* CALLER LcFreeMem: *ppbDataOut
* -- hLC
* -- fCommand = LC_CMD_*
* -- cbDataIn
* -- pbDataIn
* -- ppbDataOut
* -- pcbDataOut
*/
_Success_(return)
EXPORTED_FUNCTION BOOL LcCommand(
    _In_ HANDLE hLC,
    _In_ QWORD fCommand,
    _In_ DWORD cbDataIn,
    _In_reads_opt_(cbDataIn) PBYTE pbDataIn,
    _Out_opt_ PBYTE *ppbDataOut,
    _Out_opt_ PDWORD pcbDataOut
);

#define LC_OPT_CORE_PRINTF_ENABLE                   0x4000000100000000  // RW
#define LC_OPT_CORE_VERBOSE                         0x4000000200000000  // RW
#define LC_OPT_CORE_VERBOSE_EXTRA                   0x4000000300000000  // RW
#define LC_OPT_CORE_VERBOSE_EXTRA_TLP               0x4000000400000000  // RW
#define LC_OPT_CORE_VERSION_MAJOR                   0x4000000500000000  // R
#define LC_OPT_CORE_VERSION_MINOR                   0x4000000600000000  // R
#define LC_OPT_CORE_VERSION_REVISION                0x4000000700000000  // R
#define LC_OPT_CORE_ADDR_MAX                        0x1000000800000000  // R
#define LC_OPT_CORE_STATISTICS_CALL_COUNT           0x4000000900000000  // R [lo-dword: LC_STATISTICS_ID_*]
#define LC_OPT_CORE_STATISTICS_CALL_TIME            0x4000000a00000000  // R [lo-dword: LC_STATISTICS_ID_*]

#define LC_OPT_MEMORYINFO_VALID                     0x0200000100000000  // R
#define LC_OPT_MEMORYINFO_FLAG_32BIT                0x0200000300000000  // R
#define LC_OPT_MEMORYINFO_FLAG_PAE                  0x0200000400000000  // R
#define LC_OPT_MEMORYINFO_OS_VERSION_MINOR          0x0200000500000000  // R
#define LC_OPT_MEMORYINFO_OS_VERSION_MAJOR          0x0200000600000000  // R
#define LC_OPT_MEMORYINFO_OS_DTB                    0x0200000700000000  // R
#define LC_OPT_MEMORYINFO_OS_PFN                    0x0200000800000000  // R
#define LC_OPT_MEMORYINFO_OS_PsLoadedModuleList     0x0200000900000000  // R
#define LC_OPT_MEMORYINFO_OS_PsActiveProcessHead    0x0200000a00000000  // R
#define LC_OPT_MEMORYINFO_OS_MACHINE_IMAGE_TP       0x0200000b00000000  // R
#define LC_OPT_MEMORYINFO_OS_NUM_PROCESSORS         0x0200000c00000000  // R
#define LC_OPT_MEMORYINFO_OS_SYSTEMTIME             0x0200000d00000000  // R
#define LC_OPT_MEMORYINFO_OS_UPTIME                 0x0200000e00000000  // R
#define LC_OPT_MEMORYINFO_OS_KERNELBASE             0x0200000f00000000  // R
#define LC_OPT_MEMORYINFO_OS_KERNELHINT             0x0200001000000000  // R
#define LC_OPT_MEMORYINFO_OS_KdDebuggerDataBlock    0x0200001100000000  // R

#define LC_OPT_FPGA_PROBE_MAXPAGES                  0x0300000100000000  // RW
#define LC_OPT_FPGA_MAX_SIZE_RX                     0x0300000300000000  // RW
#define LC_OPT_FPGA_MAX_SIZE_TX                     0x0300000400000000  // RW
#define LC_OPT_FPGA_DELAY_PROBE_READ                0x0300000500000000  // RW - uS
#define LC_OPT_FPGA_DELAY_PROBE_WRITE               0x0300000600000000  // RW - uS
#define LC_OPT_FPGA_DELAY_WRITE                     0x0300000700000000  // RW - uS
#define LC_OPT_FPGA_DELAY_READ                      0x0300000800000000  // RW - uS
#define LC_OPT_FPGA_RETRY_ON_ERROR                  0x0300000900000000  // RW
#define LC_OPT_FPGA_DEVICE_ID                       0x0300008000000000  // R
#define LC_OPT_FPGA_FPGA_ID                         0x0300008100000000  // R
#define LC_OPT_FPGA_VERSION_MAJOR                   0x0300008200000000  // R
#define LC_OPT_FPGA_VERSION_MINOR                   0x0300008300000000  // R
#define LC_OPT_FPGA_ALGO_TINY                       0x0300008400000000  // RW - 1/0 use tiny 128-byte/tlp read algorithm.
#define LC_OPT_FPGA_ALGO_SYNCHRONOUS                0x0300008500000000  // RW - 1/0 use synchronous (old) read algorithm.
#define LC_OPT_FPGA_CFGSPACE_XILINX                 0x0300008600000000  // RW - [lo-dword: register address in bytes] [bytes: 0-3: data, 4-7: byte_enable(if wr/set); top bit = cfg_mgmt_wr_rw1c_as_rw]
#define LC_OPT_FPGA_TLP_READ_CB_WITHINFO            0x0300009000000000  // RW - 1/0 call TLP read callback with additional string info in szInfo
#define LC_OPT_FPGA_TLP_READ_CB_FILTERCPL           0x0300009100000000  // RW - 1/0 call TLP read callback with memory read completions from read calls filtered
#define LC_OPT_FPGA_TLP_READ_CB_BACKGROUND_THREAD   0x0300009200000000  // RW - 1/0 call TLP read callback auto-read with background thread [requires active callback function]

#define LC_CMD_FPGA_WRITE_TLP                       0x0000010100000000  // R  - !!! DEPRECATED DO NOT USE !!! - USE LC_CMD_FPGA_TLP_WRITE_SINGLE!
#define LC_CMD_FPGA_LISTEN_TLP                      0x0000010200000000  // R  - !!! DEPRECATED DO NOT USE !!!
#define LC_CMD_FPGA_PCIECFGSPACE                    0x0000010300000000  // R
#define LC_CMD_FPGA_CFGREGPCIE                      0x0000010400000000  // RW - [lo-dword: register address]
#define LC_CMD_FPGA_CFGREGCFG                       0x0000010500000000  // RW - [lo-dword: register address]
#define LC_CMD_FPGA_CFGREGDRP                       0x0000010600000000  // RW - [lo-dword: register address]
#define LC_CMD_FPGA_CFGREGCFG_MARKWR                0x0000010700000000  // W  - write with mask [lo-dword: register address] [bytes: 0-1: data, 2-3: mask]
#define LC_CMD_FPGA_CFGREGPCIE_MARKWR               0x0000010800000000  // W  - write with mask [lo-dword: register address] [bytes: 0-1: data, 2-3: mask]
#define LC_CMD_FPGA_CFGREG_DEBUGPRINT               0x0000010a00000000  // N/A
#define LC_CMD_FPGA_PROBE                           0x0000010b00000000  // RW
#define LC_CMD_FPGA_CFGSPACE_SHADOW_RD              0x0000010c00000000  // R
#define LC_CMD_FPGA_CFGSPACE_SHADOW_WR              0x0000010d00000000  // W  - [lo-dword: config space write base address]
#define LC_CMD_FPGA_TLP_WRITE_SINGLE                0x0000011000000000  // R  - write single tlp BYTE:s
#define LC_CMD_FPGA_TLP_WRITE_MULTIPLE              0x0000011100000000  // R  - write multiple LC_TLP:s
#define LC_CMD_FPGA_TLP_TOSTRING                    0x0000011200000000  // RW - convert single TLP to LPSTR; *pcbDataOut includes NULL terminator.
#define LC_CMD_FPGA_TLP_READ_FUNCTION_CALLBACK      0x0000011300000000  // W  - set/unset custom TLP read callback function and fetch TLPs (pbDataIn == PLC_TLP_CALLBACK).

#define LC_CMD_FILE_DUMPHEADER_GET                  0x0000020100000000  // R

#define LC_CMD_STATISTICS_GET                       0x4000010000000000  // R
#define LC_CMD_MEMMAP_GET                           0x4000020000000000  // R  - MEMMAP as LPSTR
#define LC_CMD_MEMMAP_SET                           0x4000030000000000  // W  - MEMMAP as LPSTR
#define LC_CMD_MEMMAP_GET_STRUCT                    0x4000040000000000  // R  - MEMMAP as LC_MEMMAP_ENTRY[]

#define LC_CMD_AGENT_EXEC_PYTHON                    0x8000000100000000  // RW - [lo-dword: optional timeout in ms]
#define LC_CMD_AGENT_EXIT_PROCESS                   0x8000000200000000  //    - [lo-dword: process exit code]

#define LC_STATISTICS_VERSION                       0xe1a10002
#define LC_STATISTICS_ID_OPEN                       0x00
#define LC_STATISTICS_ID_READ                       0x01
#define LC_STATISTICS_ID_READSCATTER                0x02
#define LC_STATISTICS_ID_WRITE                      0x03
#define LC_STATISTICS_ID_WRITESCATTER               0x04
#define LC_STATISTICS_ID_GETOPTION                  0x05
#define LC_STATISTICS_ID_SETOPTION                  0x06
#define LC_STATISTICS_ID_COMMAND                    0x07
#define LC_STATISTICS_ID_MAX                        0x07

static LPCSTR LC_STATISTICS_NAME[] = {
    "LcOpen",
    "LcRead",
    "LcReadScatter",
    "LcWrite",
    "LcWriteScatter",
    "LcGetOption",
    "LcSetOption",
    "LcCommand",
};

typedef struct tdLC_STATISTICS {
    DWORD dwVersion;
    DWORD _Reserved;
    QWORD qwFreq;
    struct {
        QWORD c;
        QWORD tm;   // total time in qwFreq ticks
    } Call[LC_STATISTICS_ID_MAX + 1];
} LC_STATISTICS, *PLC_STATISTICS;

typedef struct tdLC_MEMMAP_ENTRY {
    QWORD pa;
    QWORD cb;
    QWORD paRemap;
} LC_MEMMAP_ENTRY, *PLC_MEMMAP_ENTRY;

typedef struct tdLC_TLP {
    DWORD cb;
    DWORD _Reserved1;
    PBYTE pb;
} LC_TLP, *PLC_TLP;

/*
* Custom FPGA-only callback function to be called whenever a TLP is received if
* set by command LC_CMD_FPGA_TLP_READ_FUNCTION_CALLBACK.
* NOTE! CALLBACK FUNCTION MUST NEVER CALL LEECHCORE DUE TO RISK OF DEADLOCK!
*/
typedef VOID(*PLC_TLP_READ_FUNCTION_CALLBACK)(
    _In_opt_ PVOID ctx,
    _In_ DWORD cbTlp,
    _In_ PBYTE pbTlp,
    _In_opt_ DWORD cbInfo,
    _In_opt_ LPSTR szInfo
);

typedef struct tdLC_TLP_CALLBACK {
    PVOID ctx;
    PLC_TLP_READ_FUNCTION_CALLBACK pfn;
} LC_TLP_CALLBACK, *PLC_TLP_CALLBACK;

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* __LEECHCORE_H__ */

```

`resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by EFT Leecher.rc
//
#define IDD_MAIN_DIALOG                 101
#define IDD_SERIAL_DIALOG               103
#define IDD_SKILL_BUF_DIALOG            105
#define ID_BTN_DMA_SHUTDOWN             1001
#define ID_BTN_DMA_CONNECT              1002
#define ID_BTN_VISOR_EFFECT             1003
#define ID_BTN_NIGHTVISION_ON           1004
#define ID_BTN_NIGHTVISION              1004
#define ID_BTN_NIGHTVISION_OFF          1005
#define IDC_NOWEIGHT                    1006
#define ID_BTN_THERMAL_ON               1007
#define ID_BTN_THERMAL_OFF              1008
#define ID_BTN_THERMAL                  1008
#define IDC_DOORS                       1009
#define ID_EXIT                         1010
#define IDC_HWID                        1011
#define IDC_DOORS_KEYCARD               1012
#define IDC_NORECOIL                    1013
#define IDC_STATUS_TEXT                 1013
#define IDC_ENDURANCE                   1014
#define IDC_SKILLSMAX                   1015
#define IDC_EDIT1                       1015
#define IDC_SERIAL                      1015
#define IDC_SKILLS_MAX                  1015
#define IDC_REMOVE_CONNECTIONS          1016
#define IDC_USE_MMAP_FILE               1017
#define IDC_USE_STEALTH_CONNECTION      1018
#define IDC_CONNECTION_STATUS           1019
#define IDC_PROCESS_ID                  1020
#define IDC_CHECK1                      1021
#define IDC_SKILL_BUFFER                1021
#define IDC_AIMBOT_ENABLE               1021
#define IDC_AUTO_DISCONNECT             1022
#define IDC_BTN_SKILLS                  1023
#define IDC_PLAYER_STATUS               1024
#define IDC_WORLD_STATUS                1025
#define IDC_STATUS_LOCATION             1026
#define IDC_SKILLS_LIST                 1027
#define IDC_SLIDER1                     1028
#define IDC_LEVEL_SLIDER                1028
#define IDC_JUMP_SLIDER                 1028
#define IDC_THROW_SLIDER                1029
#define IDC_ENABLE_LEVEL                1030
#define IDC_HEARING_SLIDER              1030
#define IDC_LEVEL_TEXT                  1031
#define IDC_JUMP_TEXT                   1036
#define IDC_THROW_TEXT                  1037
#define IDC_HEARING_TEXT                1038
#define IDC_AIMBOT_HEAD                 1039
#define IDC_AIMBOT_CHEST                1040
#define IDC_AIMBOT_PELVIS               1041
#define IDC_AIMBOT_KEY                  1042
#define IDC_AIMBOT_HOTKEY               1042
#define IDC_AIMBOT_LFOOT                1043
#define IDC_AIMBOT_RFOOT                1044
#define IDC_AIMBOT_RANDOM               1045
#define IDC_RADIO3                      1048

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1049
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`vmmdll.h`:

```h
// vmmdll.h : header file to include in projects that use vmm.dll / vmm.so
// 
// Windows may access both UTF-8 *U and Wide-Char *W versions of functions
// while Linux may only access UTF-8 versions. Some functionality may also
// be degraded or unavailable on Linux.
//
// (c) Ulf Frisk, 2018-2021
// Author: Ulf Frisk, pcileech@frizk.net
//
// Header Version: 4.0
//

#include "leechcore.h"

#ifndef __VMMDLL_H__
#define __VMMDLL_H__
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifdef _WIN32

#include <Windows.h>
#undef EXPORTED_FUNCTION
#define EXPORTED_FUNCTION
typedef unsigned __int64                    QWORD, *PQWORD;

#endif /* _WIN32 */
#ifdef LINUX

#include <inttypes.h>
#include <stdlib.h>
#undef EXPORTED_FUNCTION
#define EXPORTED_FUNCTION                   __attribute__((visibility("default")))
typedef void                                VOID, *PVOID, *HANDLE, **PHANDLE, *HMODULE;
typedef long long unsigned int              QWORD, *PQWORD, ULONG64, *PULONG64;
typedef uint64_t                            SIZE_T, *PSIZE_T, FILETIME, *PFILETIME;
typedef uint32_t                            DWORD, *PDWORD, *LPDWORD, BOOL, *PBOOL, NTSTATUS;
typedef uint16_t                            WORD, *PWORD;
typedef uint8_t                             BYTE, *PBYTE, *LPBYTE, UCHAR;
typedef char                                CHAR, *PCHAR, *LPSTR, *LPCSTR;
typedef uint16_t                            WCHAR, *PWCHAR, *LPWSTR, *LPCWSTR;
#define MAX_PATH                            260
#define _In_
#define _In_z_
#define _In_opt_
#define _In_reads_(x)
#define _In_reads_opt_(x)
#define _Inout_
#define _Inout_bytecount_(x)
#define _Inout_opt_
#define _Inout_updates_opt_(x)
#define _Out_
#define _Out_opt_
#define _Out_writes_(x)
#define _Out_writes_bytes_opt_(x)
#define _Out_writes_opt_(x)
#define _Out_writes_to_(x,y)
#define _When_(x,y)
#define _Frees_ptr_opt_
#define _Post_ptr_invalid_
#define _Check_return_opt_
#define _Printf_format_string_
#define _Success_(x)

#endif /* LINUX */



//-----------------------------------------------------------------------------
// INITIALIZATION FUNCTIONALITY BELOW:
// Choose one way of initializing the VMM / MemProcFS.
//-----------------------------------------------------------------------------

/*
* Initialize VMM.DLL with command line parameters. For a more detailed info
* about the parameters please see github wiki for MemProcFS and LeechCore.
* NB! LeechCore initialization parameters are _also_ valid to this function.
* Important parameters are:
*    -printf = show printf style outputs.
*    -v -vv -vvv = extra verbosity levels.
*    -device = device as on format for LeechCore - please see leechcore.h or
*              Github documentation for additional information. Some values
*              are: <file>, fpga, usb3380, hvsavedstate, totalmeltdown, pmem
*    -remote = remote LeechCore instance - please see leechcore.h or Github
*              documentation for additional information.
*    -norefresh = disable background refreshes (even if backing memory is
*              volatile memory).
*    -memmap = specify a physical memory map given by file or specify 'auto'.
*              example: -memmap c:\\temp\\my_custom_memory_map.txt
*              example: -memmap auto
*    -pagefile[0-9] = page file(s) to use in addition to physical memory.
*              Normally pagefile.sys have index 0 and swapfile.sys index 1.
*              Page files are in constant flux - do not use if time diff
*              between memory dump and page files are more than few minutes.
*              Example: 'pagefile0 swapfile.sys'
*    -symbolserverdisable = disable symbol server until user change.
*              This parameter will take precedence over registry settings.
*    -waitinitialize = Wait for initialization to complete before returning.
*              Normal use is that some initialization is done asynchronously
*              and may not be completed when initialization call is completed.
*              This includes virtual memory compression, registry and more.
*              Example: '-waitinitialize'
*    -userinteract = allow vmm.dll to, on the console, query the user for
*              information such as, but not limited to, leechcore device options.
*              Default: user interaction = disabled.
*    -forensic = start a forensic scan of the physical memory immediately after
*              startup if possible. Allowed parameter values range from 0-4.
*              Note! forensic mode is not available for live memory.
*              1 = forensic mode with in-memory sqlite database.
*              2 = forensic mode with temp sqlite database deleted upon exit.
*              3 = forensic mode with temp sqlite database remaining upon exit.
*              4 = forensic mode with static named sqlite database (vmm.sqlite3).
*              Example -forensic 4
*
* -- argc
* -- argv
* -- ppLcErrorInfo = optional pointer to receive a function allocated memory of
*              struct LC_CONFIG_ERRORINFO with extended error information upon
*              failure. Any memory received should be free'd by caller by
*              calling LcMemFree().
* -- return = success/fail
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Initialize(_In_ DWORD argc, _In_ LPSTR argv[]);

EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_InitializeEx(_In_ DWORD argc, _In_ LPSTR argv[], _Out_opt_ PPLC_CONFIG_ERRORINFO ppLcErrorInfo);

/*
* Close an initialized instance of VMM.DLL and clean up all allocated resources
* including plugins, linked PCILeech.DLL and other memory resources.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Close();

/*
* Free memory allocated by the VMMDLL.
* -- pvMem
*/
EXPORTED_FUNCTION
VOID VMMDLL_MemFree(_Frees_ptr_opt_ PVOID pvMem);



//-----------------------------------------------------------------------------
// CONFIGURATION SETTINGS BELOW:
// Configure MemProcFS or the underlying memory
// acquisition devices.
//-----------------------------------------------------------------------------

/*
* Options used together with the functions: VMMDLL_ConfigGet & VMMDLL_ConfigSet
* Options are defined with either: VMMDLL_OPT_* in this header file or as
* LC_OPT_* in leechcore.h
* For more detailed information check the sources for individual device types.
*/
#define VMMDLL_OPT_CORE_PRINTF_ENABLE                   0x4000000100000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE                         0x4000000200000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE_EXTRA                   0x4000000300000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE_EXTRA_TLP               0x4000000400000000  // RW
#define VMMDLL_OPT_CORE_MAX_NATIVE_ADDRESS              0x4000000800000000  // R

#define VMMDLL_OPT_CORE_SYSTEM                          0x2000000100000000  // R
#define VMMDLL_OPT_CORE_MEMORYMODEL                     0x2000000200000000  // R

#define VMMDLL_OPT_CONFIG_IS_REFRESH_ENABLED            0x2000000300000000  // R - 1/0
#define VMMDLL_OPT_CONFIG_TICK_PERIOD                   0x2000000400000000  // RW - base tick period in ms
#define VMMDLL_OPT_CONFIG_READCACHE_TICKS               0x2000000500000000  // RW - memory cache validity period (in ticks)
#define VMMDLL_OPT_CONFIG_TLBCACHE_TICKS                0x2000000600000000  // RW - page table (tlb) cache validity period (in ticks)
#define VMMDLL_OPT_CONFIG_PROCCACHE_TICKS_PARTIAL       0x2000000700000000  // RW - process refresh (partial) period (in ticks)
#define VMMDLL_OPT_CONFIG_PROCCACHE_TICKS_TOTAL         0x2000000800000000  // RW - process refresh (full) period (in ticks)
#define VMMDLL_OPT_CONFIG_VMM_VERSION_MAJOR             0x2000000900000000  // R
#define VMMDLL_OPT_CONFIG_VMM_VERSION_MINOR             0x2000000A00000000  // R
#define VMMDLL_OPT_CONFIG_VMM_VERSION_REVISION          0x2000000B00000000  // R
#define VMMDLL_OPT_CONFIG_STATISTICS_FUNCTIONCALL       0x2000000C00000000  // RW - enable function call statistics (.status/statistics_fncall file)
#define VMMDLL_OPT_CONFIG_IS_PAGING_ENABLED             0x2000000D00000000  // RW - 1/0

#define VMMDLL_OPT_WIN_VERSION_MAJOR                    0x2000010100000000  // R
#define VMMDLL_OPT_WIN_VERSION_MINOR                    0x2000010200000000  // R
#define VMMDLL_OPT_WIN_VERSION_BUILD                    0x2000010300000000  // R
#define VMMDLL_OPT_WIN_SYSTEM_UNIQUE_ID                 0x2000010400000000  // R

#define VMMDLL_OPT_FORENSIC_MODE                        0x2000020100000000  // RW - enable/retrieve forensic mode type [0-4].

#define VMMDLL_OPT_REFRESH_ALL                          0x2001ffff00000000  // W - refresh all caches
#define VMMDLL_OPT_REFRESH_FREQ_MEM                     0x2001000200000000  // W - refresh memory cache (excl. TLB) [partial 33%/call]
#define VMMDLL_OPT_REFRESH_FREQ_TLB                     0x2001000400000000  // W - refresh page table (TLB) cache [partial 33%/call]
#define VMMDLL_OPT_REFRESH_FREQ_FAST                    0x2001040000000000  // W - refresh fast frequency - incl. partial process refresh
#define VMMDLL_OPT_REFRESH_FREQ_MEDIUM                  0x2001000100000000  // W - refresh medium frequency - incl. full process refresh
#define VMMDLL_OPT_REFRESH_FREQ_SLOW                    0x2001001000000000  // W - refresh slow frequency.
#define VMMDLL_OPT_REFRESH_PROCESS                      0x2001000100000000  // W - DEPRECATED: refresh process listings
#define VMMDLL_OPT_REFRESH_READ                         0x2001000200000000  // W - DEPRECATED: refresh physical read cache
#define VMMDLL_OPT_REFRESH_TLB                          0x2001000400000000  // W - DEPRECATED: refresh page table (TLB) cache
#define VMMDLL_OPT_REFRESH_PAGING                       0x2001000800000000  // W - DEPRECATED: refresh virtual memory 'paging' cache
#define VMMDLL_OPT_REFRESH_REGISTRY                     0x2001001000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_USER                         0x2001002000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_PHYSMEMMAP                   0x2001004000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_PFN                          0x2001008000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_OBJ                          0x2001010000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_NET                          0x2001020000000000  // W - DEPRECATED:

static LPCSTR VMMDLL_MEMORYMODEL_TOSTRING[4] = { "N/A", "X86", "X86PAE", "X64" };

typedef enum tdVMMDLL_MEMORYMODEL_TP {
    VMMDLL_MEMORYMODEL_NA       = 0,
    VMMDLL_MEMORYMODEL_X86      = 1,
    VMMDLL_MEMORYMODEL_X86PAE   = 2,
    VMMDLL_MEMORYMODEL_X64      = 3
} VMMDLL_MEMORYMODEL_TP;

typedef enum tdVMMDLL_SYSTEM_TP {
    VMMDLL_SYSTEM_UNKNOWN_X64   = 1,
    VMMDLL_SYSTEM_WINDOWS_X64   = 2,
    VMMDLL_SYSTEM_UNKNOWN_X86   = 3,
    VMMDLL_SYSTEM_WINDOWS_X86   = 4
} VMMDLL_SYSTEM_TP;

/*
* Set a device specific option value. Please see defines VMMDLL_OPT_* for infor-
* mation about valid option values. Please note that option values may overlap
* between different device types with different meanings.
* -- fOption
* -- pqwValue = pointer to ULONG64 to receive option value.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ConfigGet(_In_ ULONG64 fOption, _Out_ PULONG64 pqwValue);

/*
* Set a device specific option value. Please see defines VMMDLL_OPT_* for infor-
* mation about valid option values. Please note that option values may overlap
* between different device types with different meanings.
* -- fOption
* -- qwValue
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ConfigSet(_In_ ULONG64 fOption, _In_ ULONG64 qwValue);



//-----------------------------------------------------------------------------
// FORWARD DECLARATIONS:
//-----------------------------------------------------------------------------

typedef struct tdVMMDLL_MAP_PFN *PVMMDLL_MAP_PFN;



//-----------------------------------------------------------------------------
// LINUX SPECIFIC DEFINES:
//-----------------------------------------------------------------------------
#ifdef LINUX

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;
#endif /* LINUX */



//-----------------------------------------------------------------------------
// VFS - VIRTUAL FILE SYSTEM FUNCTIONALITY BELOW:
// NB! VFS FUNCTIONALITY REQUIRES PLUGINS TO BE INITIALIZED
//     WITH CALL TO VMMDLL_InitializePlugins().
// This is the core of MemProcFS. All implementation and analysis towards
// the virtual file system (vfs) is possible by using functionality below. 
//-----------------------------------------------------------------------------

#define VMMDLL_STATUS_SUCCESS                       ((NTSTATUS)0x00000000L)
#define VMMDLL_STATUS_UNSUCCESSFUL                  ((NTSTATUS)0xC0000001L)
#define VMMDLL_STATUS_END_OF_FILE                   ((NTSTATUS)0xC0000011L)
#define VMMDLL_STATUS_FILE_INVALID                  ((NTSTATUS)0xC0000098L)
#define VMMDLL_STATUS_FILE_SYSTEM_LIMITATION        ((NTSTATUS)0xC0000427L)

#define VMMDLL_VFS_FILELIST_EXINFO_VERSION          1
#define VMMDLL_VFS_FILELIST_VERSION                 2

typedef struct tdVMMDLL_VFS_FILELIST_EXINFO {
    DWORD dwVersion;
    BOOL fCompressed;                   // set flag FILE_ATTRIBUTE_COMPRESSED - (no meaning but shows gui artifact in explorer.exe)
    union {
        FILETIME ftCreationTime;        // 0 = default time
        QWORD qwCreationTime;
    };
    union {
        FILETIME ftLastAccessTime;      // 0 = default time
        QWORD qwLastAccessTime;
    };
    union {
        FILETIME ftLastWriteTime;       // 0 = default time
        QWORD qwLastWriteTime;
    };
} VMMDLL_VFS_FILELIST_EXINFO, *PVMMDLL_VFS_FILELIST_EXINFO;

typedef struct tdVMMDLL_VFS_FILELIST2 {
    DWORD dwVersion;
    VOID(*pfnAddFile)     (_Inout_ HANDLE h, _In_ LPSTR uszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
    VOID(*pfnAddDirectory)(_Inout_ HANDLE h, _In_ LPSTR uszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
    HANDLE h;
} VMMDLL_VFS_FILELIST2, *PVMMDLL_VFS_FILELIST2;

/*
* Helper functions for callbacks into the VMM_VFS_FILELIST structure.
*/
EXPORTED_FUNCTION
VOID VMMDLL_VfsList_AddFile(_In_ HANDLE pFileList, _In_ LPSTR uszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
VOID VMMDLL_VfsList_AddFileW(_In_ HANDLE pFileList, _In_ LPWSTR wszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
EXPORTED_FUNCTION
VOID VMMDLL_VfsList_AddDirectory(_In_ HANDLE pFileList, _In_ LPSTR uszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
VOID VMMDLL_VfsList_AddDirectoryW(_In_ HANDLE pFileList, _In_ LPWSTR wszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
EXPORTED_FUNCTION BOOL VMMDLL_VfsList_IsHandleValid(_In_ HANDLE pFileList);

/*
* List a directory of files in MemProcFS. Directories and files will be listed
* by callbacks into functions supplied in the pFileList parameter.
* If information of an individual file is needed it's neccessary to list all
* files in its directory.
* -- [uw]szPath
* -- pFileList
* -- return
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_VfsListU(_In_ LPSTR  uszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList);
_Success_(return) BOOL VMMDLL_VfsListW(_In_ LPWSTR wszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList);

/*
* Read select parts of a file in MemProcFS.
* -- [uw]szFileName
* -- pb
* -- cb
* -- pcbRead
* -- cbOffset
* -- return
*
*/
EXPORTED_FUNCTION
NTSTATUS VMMDLL_VfsReadU(_In_ LPSTR  uszFileName, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
NTSTATUS VMMDLL_VfsReadW(_In_ LPWSTR wszFileName, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);

/*
* Write select parts to a file in MemProcFS.
* -- [uw]szFileName
* -- pb
* -- cb
* -- pcbWrite
* -- cbOffset
* -- return
*/
EXPORTED_FUNCTION
NTSTATUS VMMDLL_VfsWriteU(_In_ LPSTR  uszFileName, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
NTSTATUS VMMDLL_VfsWriteW(_In_ LPWSTR wszFileName, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);

/*
* Utility functions for MemProcFS read/write towards different underlying data
* representations.
*/
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromPBYTE(_In_ PBYTE pbFile, _In_ ULONG64 cbFile, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromQWORD(_In_ ULONG64 qwValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset, _In_ BOOL fPrefix);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromDWORD(_In_ DWORD dwValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset, _In_ BOOL fPrefix);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromBOOL(_In_ BOOL fValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsWriteFile_BOOL(_Inout_ PBOOL pfTarget, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsWriteFile_DWORD(_Inout_ PDWORD pdwTarget, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset, _In_ DWORD dwMinAllow);



//-----------------------------------------------------------------------------
// PLUGIN MANAGER FUNCTIONALITY BELOW:
// Function and structures to initialize and use MemProcFS plugin functionality.
// The plugin manager is started by a call to function:
// VMM_VfsInitializePlugins. Each built-in plugin and external plugin of which
// the DLL name matches m_*.dll will receive a call to its InitializeVmmPlugin
// function. The plugin/module may decide to call pfnPluginManager_Register to
// register plugins in the form of different names one or more times.
// Example of registration function in a plugin DLL below: 
// 'VOID InitializeVmmPlugin(_In_ PVMM_PLUGIN_REGINFO pRegInfo)'
//-----------------------------------------------------------------------------

/*
* Initialize all potential plugins, both built-in and external, that maps into
* MemProcFS. Please note that plugins are not loaded by default - they have to
* be explicitly loaded by calling this function. They will be unloaded on a
* general close of the vmm dll.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_InitializePlugins();

#define VMMDLL_PLUGIN_CONTEXT_MAGIC                 0xc0ffee663df9301c
#define VMMDLL_PLUGIN_CONTEXT_VERSION               4
#define VMMDLL_PLUGIN_REGINFO_MAGIC                 0xc0ffee663df9301d
#define VMMDLL_PLUGIN_REGINFO_VERSION               13
#define VMMDLL_PLUGIN_FORENSIC_JSONDATA_VERSION     0xc0ee0001

#define VMMDLL_PLUGIN_NOTIFY_VERBOSITYCHANGE        0x01
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_FAST           0x05    // refresh fast event   - at partial process refresh.
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_MEDIUM         0x02    // refresh medium event - at full process refresh.
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_SLOW           0x04    // refresh slow event   - at registry refresh.

#define VMMDLL_PLUGIN_NOTIFY_FORENSIC_INIT          0x01000100
#define VMMDLL_PLUGIN_NOTIFY_FORENSIC_INIT_COMPLETE 0x01000200

typedef HANDLE                                      *PVMMDLL_PLUGIN_INTERNAL_CONTEXT;

typedef struct tdVMMDLL_PLUGIN_CONTEXT {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    DWORD dwPID;
    PVOID pProcess;
    LPSTR uszModule;
    LPSTR uszPath;
    PVOID pvReserved1;
    PVMMDLL_PLUGIN_INTERNAL_CONTEXT ctxM;       // optional internal module context.
} VMMDLL_PLUGIN_CONTEXT, *PVMMDLL_PLUGIN_CONTEXT;

typedef struct tdVMMDLL_PLUGIN_FORENSIC_JSONDATA {
    DWORD dwVersion;        // must equal VMMDLL_PLUGIN_FORENSIC_JSONDATA_VERSION
    BOOL fVerbose;
    LPSTR szjType;          // log type/name (json encoded)
    DWORD i;
    DWORD dwPID;
    QWORD vaObj;
    BOOL fva[2];            // log va even if zero
    QWORD va[2];
    BOOL fNum[2];           // log num even if zero
    QWORD qwNum[2];
    BOOL fHex[2];           // log hex even if zero
    QWORD qwHex[2];
    // str: will be prioritized in order: szu > wsz.
    LPCSTR usz[2];          // str: utf-8 encoded
    LPCWSTR wsz[2];         // str: wide
    BYTE _Reserved[0x4000+256];
} VMMDLL_PLUGIN_FORENSIC_JSONDATA, *PVMMDLL_PLUGIN_FORENSIC_JSONDATA;

typedef struct tdVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM {
    DWORD cMEMs;
    BOOL fValid;
    QWORD paBase;
    PPMEM_SCATTER ppMEMs;
    PVMMDLL_MAP_PFN pPfnMap;
} VMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM, *PVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM;

typedef struct tdVMMDLL_PLUGIN_REGINFO {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    VMMDLL_MEMORYMODEL_TP tpMemoryModel;
    VMMDLL_SYSTEM_TP tpSystem;
    HMODULE hDLL;
    BOOL(*pfnPluginManager_Register)(struct tdVMMDLL_PLUGIN_REGINFO *pPluginRegInfo);
    DWORD _Reserved[32];
    // python plugin information - not for general use
    struct {
        BOOL fPythonStandalone;
        DWORD _Reserved;
        HMODULE hReservedDllPython3;
        HMODULE hReservedDllPython3X;
    } python;
    // general plugin registration info to be filled out by the plugin below:
    struct {
        PVMMDLL_PLUGIN_INTERNAL_CONTEXT ctxM;   // optional internal module context [must be cleaned by pfnClose() call].
        CHAR uszPathName[128];
        BOOL fRootModule;
        BOOL fProcessModule;
        BOOL fRootModuleHidden;
        BOOL fProcessModuleHidden;
        CHAR sTimelineNameShort[6];
        CHAR _Reserved[2];
        CHAR uszTimelineFile[32];
        CHAR _Reserved2[32];
    } reg_info;
    // function plugin registration info to be filled out by the plugin below:
    struct {
        BOOL(*pfnList)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _Inout_ PHANDLE pFileList);
        NTSTATUS(*pfnRead)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead,  _In_ ULONG64 cbOffset);
        NTSTATUS(*pfnWrite)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
        VOID(*pfnNotify)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_ DWORD fEvent, _In_opt_ PVOID pvEvent, _In_opt_ DWORD cbEvent);
        VOID(*pfnClose)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        BOOL(*pfnVisibleModule)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        PVOID pvReserved[10];
    } reg_fn;
    // Optional forensic plugin functionality for forensic (more comprehensive)
    // analysis of various data. Functions are optional. Functions are called
    // in single-threaded mode regards to the plugin itself - but 'ingest'
    // functions are called in-parallel multi-threaded between plugins.
    // Functions are called in the order of:
    // pfnInitialize(), pfnIngest*(), pfnTimeline(), pfnLogJSON(), pfnFinalize()
    struct {
        PVOID(*pfnInitialize)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        VOID(*pfnFinalize)(_In_opt_ PVOID ctxfc);
        VOID(*pfnTimeline)(
            _In_opt_ PVOID ctxfc,
            _In_ HANDLE hTimeline,
            _In_ VOID(*pfnAddEntry)(_In_ HANDLE hTimeline, _In_ QWORD ft, _In_ DWORD dwAction, _In_ DWORD dwPID, _In_ DWORD dwData32, _In_ QWORD qwData64, _In_ LPSTR uszText),
            _In_ VOID(*pfnEntryAddBySql)(_In_ HANDLE hTimeline, _In_ DWORD cEntrySql, _In_ LPSTR *pszEntrySql));
        VOID(*pfnIngestPhysmem)(_In_opt_ PVOID ctxfc, _In_ PVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM pIngestPhysmem);
        VOID(*pfnIngestFinalize)(_In_opt_ PVOID ctxfc);
        PVOID pvReserved[10];
        VOID(*pfnLogJSON)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_ VOID(*pfnLogJSON)(_In_ PVMMDLL_PLUGIN_FORENSIC_JSONDATA pData));
    } reg_fnfc;
    // Additional system information - read/only by the plugins.
    struct {
        BOOL f32;
        DWORD dwVersionMajor;
        DWORD dwVersionMinor;
        DWORD dwVersionBuild;
        DWORD _Reserved[32];
    } sysinfo;
} VMMDLL_PLUGIN_REGINFO, *PVMMDLL_PLUGIN_REGINFO;



//-----------------------------------------------------------------------------
// VMM CORE FUNCTIONALITY BELOW:
// Vmm core functaionlity such as read (and write) to both virtual and physical
// memory. NB! writing will only work if the target is supported - i.e. not a
// memory dump file...
// To read physical memory specify dwPID as (DWORD)-1
//-----------------------------------------------------------------------------

#define VMMDLL_PID_PROCESS_WITH_KERNELMEMORY        0x80000000      // Combine with dwPID to enable process kernel memory (NB! use with extreme care).

// FLAG used to supress the default read cache in calls to VMM_MemReadEx()
// which will lead to the read being fetched from the target system always.
// Cached page tables (used for translating virtual2physical) are still used.
#define VMMDLL_FLAG_NOCACHE                         0x0001  // do not use the data cache (force reading from memory acquisition device)
#define VMMDLL_FLAG_ZEROPAD_ON_FAIL                 0x0002  // zero pad failed physical memory reads and report success if read within range of physical memory.
#define VMMDLL_FLAG_FORCECACHE_READ                 0x0008  // force use of cache - fail non-cached pages - only valid for reads, invalid with VMM_FLAG_NOCACHE/VMM_FLAG_ZEROPAD_ON_FAIL.
#define VMMDLL_FLAG_NOPAGING                        0x0010  // do not try to retrieve memory from paged out memory from pagefile/compressed (even if possible)
#define VMMDLL_FLAG_NOPAGING_IO                     0x0020  // do not try to retrieve memory from paged out memory if read would incur additional I/O (even if possible).
#define VMMDLL_FLAG_NOCACHEPUT                      0x0100  // do not write back to the data cache upon successful read from memory acquisition device.
#define VMMDLL_FLAG_CACHE_RECENT_ONLY               0x0200  // only fetch from the most recent active cache region when reading.
#define VMMDLL_FLAG_NO_PREDICTIVE_READ              0x0400  // do not perform additional predictive page reads (default on smaller requests).

/*
* Read memory in various non-contigious locations specified by the pointers to
* the items in the ppMEMs array. Result for each unit of work will be given
* individually. No upper limit of number of items to read, but no performance
* boost will be given if above hardware limit. Max size of each unit of work is
* one 4k page (4096 bytes). Reads must not cross 4k page boundaries. Reads must
* start at even DWORDs (4-bytes).
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- ppMEMs = array of scatter read headers.
* -- cpMEMs = count of ppMEMs.
* -- flags = optional flags as given by VMMDLL_FLAG_*
* -- return = the number of successfully read items.
*/
EXPORTED_FUNCTION
DWORD VMMDLL_MemReadScatter(_In_ DWORD dwPID, _Inout_ PPMEM_SCATTER ppMEMs, _In_ DWORD cpMEMs, _In_ DWORD flags);

/*
* Read a single 4096-byte page of memory.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pbPage
* -- return = success/fail (depending if all requested bytes are read or not).
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemReadPage(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Inout_bytecount_(4096) PBYTE pbPage);

/*
* Read a contigious arbitrary amount of memory.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- return = success/fail (depending if all requested bytes are read or not).
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemRead(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Out_writes_(cb) PBYTE pb, _In_ DWORD cb);

/*
* Read a contigious amount of memory and report the number of bytes read in pcbRead.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- pcbRead
* -- flags = flags as in VMMDLL_FLAG_*
* -- return = success/fail. NB! reads may report as success even if 0 bytes are
*        read - it's recommended to verify pcbReadOpt parameter.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemReadEx(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Out_writes_(cb) PBYTE pb, _In_ DWORD cb, _Out_opt_ PDWORD pcbReadOpt, _In_ ULONG64 flags);

/*
* Prefetch a number of addresses (specified in the pA array) into the memory
* cache. This function is to be used to batch larger known reads into local
* cache before making multiple smaller reads - which will then happen from
* the cache. Function exists for performance reasons.
* -- dwPID = PID of target process, (DWORD)-1 for physical memory.
* -- pPrefetchAddresses = array of addresses to read into cache.
* -- cPrefetchAddresses
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemPrefetchPages(_In_ DWORD dwPID, _In_reads_(cPrefetchAddresses) PULONG64 pPrefetchAddresses, _In_ DWORD cPrefetchAddresses);

/*
* Write a contigious arbitrary amount of memory. Please note some virtual memory
* such as pages of executables (such as DLLs) may be shared between different
* virtual memory over different processes. As an example a write to kernel32.dll
* in one process is likely to affect kernel32 in the whole system - in all
* processes. Heaps and Stacks and other memory are usually safe to write to.
* Please take care when writing to memory!
* -- dwPID = PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- return = TRUE on success, FALSE on partial or zero write.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemWrite(_In_ DWORD dwPID, _In_ ULONG64 qwA, _In_reads_(cb) PBYTE pb, _In_ DWORD cb);

/*
* Translate a virtual address to a physical address by walking the page tables
* of the specified process.
* -- dwPID
* -- qwVA
* -- pqwPA
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemVirt2Phys(_In_ DWORD dwPID, _In_ ULONG64 qwVA, _Out_ PULONG64 pqwPA);



//-----------------------------------------------------------------------------
// VMM PROCESS MAP FUNCTIONALITY BELOW:
// Functionality for retrieving process related collections of items such as
// page table map (PTE), virtual address descriptor map (VAD), loaded modules,
// heaps and threads.
//-----------------------------------------------------------------------------

#define VMMDLL_MAP_PTE_VERSION              2
#define VMMDLL_MAP_VAD_VERSION              6
#define VMMDLL_MAP_VADEX_VERSION            3
#define VMMDLL_MAP_MODULE_VERSION           5
#define VMMDLL_MAP_UNLOADEDMODULE_VERSION   2
#define VMMDLL_MAP_EAT_VERSION              2
#define VMMDLL_MAP_IAT_VERSION              2
#define VMMDLL_MAP_HEAP_VERSION             2
#define VMMDLL_MAP_THREAD_VERSION           3
#define VMMDLL_MAP_HANDLE_VERSION           2
#define VMMDLL_MAP_NET_VERSION              3
#define VMMDLL_MAP_PHYSMEM_VERSION          2
#define VMMDLL_MAP_USER_VERSION             2
#define VMMDLL_MAP_SERVICE_VERSION          3

// flags to check for existence in the fPage field of VMMDLL_MAP_PTEENTRY
#define VMMDLL_MEMMAP_FLAG_PAGE_W          0x0000000000000002
#define VMMDLL_MEMMAP_FLAG_PAGE_NS         0x0000000000000004
#define VMMDLL_MEMMAP_FLAG_PAGE_NX         0x8000000000000000
#define VMMDLL_MEMMAP_FLAG_PAGE_MASK       0x8000000000000006

typedef enum tdVMMDLL_PTE_TP {
    VMMDLL_PTE_TP_NA = 0,
    VMMDLL_PTE_TP_HARDWARE = 1,
    VMMDLL_PTE_TP_TRANSITION = 2,
    VMMDLL_PTE_TP_PROTOTYPE = 3,
    VMMDLL_PTE_TP_DEMANDZERO = 4,
    VMMDLL_PTE_TP_COMPRESSED = 5,
    VMMDLL_PTE_TP_PAGEFILE = 6,
} VMMDLL_PTE_TP, *PVMMDLL_PTE_TP;

typedef struct tdVMMDLL_MAP_PTEENTRY {
    QWORD vaBase;
    QWORD cPages;
    QWORD fPage;
    BOOL  fWoW64;
    DWORD _FutureUse1;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _Reserved1;
    DWORD cSoftware;    // # software (non active) PTEs in region
} VMMDLL_MAP_PTEENTRY, *PVMMDLL_MAP_PTEENTRY;

typedef struct tdVMMDLL_MAP_VADENTRY {
    QWORD vaStart;
    QWORD vaEnd;
    QWORD vaVad;
    // DWORD 0
    DWORD VadType           : 3;   // Pos 0
    DWORD Protection        : 5;   // Pos 3
    DWORD fImage            : 1;   // Pos 8
    DWORD fFile             : 1;   // Pos 9
    DWORD fPageFile         : 1;   // Pos 10
    DWORD fPrivateMemory    : 1;   // Pos 11
    DWORD fTeb              : 1;   // Pos 12
    DWORD fStack            : 1;   // Pos 13
    DWORD fSpare            : 2;   // Pos 14
    DWORD HeapNum           : 7;   // Pos 16
    DWORD fHeap             : 1;   // Pos 23
    DWORD cwszDescription   : 8;   // Pos 24
    // DWORD 1
    DWORD CommitCharge      : 31;   // Pos 0
    DWORD MemCommit         : 1;    // Pos 31
    DWORD u2;
    DWORD cbPrototypePte;
    QWORD vaPrototypePte;
    QWORD vaSubsection;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse1;
    DWORD _Reserved1;
    QWORD vaFileObject;             // only valid if fFile/fImage _and_ after wszText is initialized
    DWORD cVadExPages;              // number of "valid" VadEx pages in this VAD.
    DWORD cVadExPagesBase;          // number of "valid" VadEx pages in "previous" VADs
    QWORD _Reserved2;
} VMMDLL_MAP_VADENTRY, *PVMMDLL_MAP_VADENTRY;

typedef struct tdVMMDLL_MAP_VADEXENTRY {
    VMMDLL_PTE_TP tp;
    DWORD iPML;
    QWORD va;
    QWORD pa;
    QWORD pte;
    struct {
        DWORD _Reserved1;
        VMMDLL_PTE_TP tp;
        QWORD pa;
        QWORD pte;
    } proto;
    QWORD vaVadBase;
} VMMDLL_MAP_VADEXENTRY, *PVMMDLL_MAP_VADEXENTRY;

typedef enum tdVMMDLL_MODULE_TP {
    VMMDLL_MODULE_TP_NORMAL = 0,
    VMMDLL_MODULE_TP_DATA = 1,
    VMMDLL_MODULE_TP_NOTLINKED = 2,
    VMMDLL_MODULE_TP_INJECTED = 3,
} VMMDLL_MODULE_TP;

typedef struct tdVMMDLL_MAP_MODULEENTRY {
    QWORD vaBase;
    QWORD vaEntry;
    DWORD cbImageSize;
    BOOL  fWoW64;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _Reserved3;
    DWORD _Reserved4;
    union { LPSTR  uszFullName; LPWSTR wszFullName; };      // U/W dependant
    VMMDLL_MODULE_TP tp;
    DWORD cbFileSizeRaw;
    DWORD cSection;
    DWORD cEAT;
    DWORD cIAT;
    DWORD _Reserved2;
    QWORD _Reserved1[2];
} VMMDLL_MAP_MODULEENTRY, *PVMMDLL_MAP_MODULEENTRY;

typedef struct tdVMMDLL_MAP_UNLOADEDMODULEENTRY {
    QWORD vaBase;
    DWORD cbImageSize;
    BOOL  fWoW64;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse1;
    DWORD dwCheckSum;               // user-mode only
    DWORD dwTimeDateStamp;          // user-mode only
    DWORD _Reserved1;
    QWORD ftUnload;                 // kernel-mode only
} VMMDLL_MAP_UNLOADEDMODULEENTRY, *PVMMDLL_MAP_UNLOADEDMODULEENTRY;

typedef struct tdVMMDLL_MAP_EATENTRY {
    QWORD vaFunction;
    DWORD dwOrdinal;
    DWORD oFunctionsArray;          // PIMAGE_EXPORT_DIRECTORY->AddressOfFunctions[oFunctionsArray]
    DWORD oNamesArray;              // PIMAGE_EXPORT_DIRECTORY->AddressOfNames[oNamesArray]
    DWORD _FutureUse1;
    union { LPSTR  uszFunction; LPWSTR wszFunction; };      // U/W dependant
} VMMDLL_MAP_EATENTRY, *PVMMDLL_MAP_EATENTRY;

typedef struct tdVMMDLL_MAP_IATENTRY {
    QWORD vaFunction;
    union { LPSTR  uszFunction; LPWSTR wszFunction; };      // U/W dependant
    DWORD _FutureUse1;
    DWORD _FutureUse2;
    union { LPSTR  uszModule; LPWSTR wszModule; };          // U/W dependant
    struct {
        BOOL f32;
        WORD wHint;
        WORD _Reserved1;
        DWORD rvaFirstThunk;
        DWORD rvaOriginalFirstThunk;
        DWORD rvaNameModule;
        DWORD rvaNameFunction;
    } Thunk;
} VMMDLL_MAP_IATENTRY, *PVMMDLL_MAP_IATENTRY;

typedef struct tdVMMDLL_MAP_HEAPENTRY {
    QWORD vaHeapSegment;
    DWORD cPages;
    DWORD cPagesUnCommitted : 24;
    DWORD HeapId : 7;
    DWORD fPrimary : 1;
} VMMDLL_MAP_HEAPENTRY, *PVMMDLL_MAP_HEAPENTRY;

typedef struct tdVMMDLL_MAP_THREADENTRY {
    DWORD dwTID;
    DWORD dwPID;
    DWORD dwExitStatus;
    UCHAR bState;
    UCHAR bRunning;
    UCHAR bPriority;
    UCHAR bBasePriority;
    QWORD vaETHREAD;
    QWORD vaTeb;
    QWORD ftCreateTime;
    QWORD ftExitTime;
    QWORD vaStartAddress;
    QWORD vaStackBaseUser;          // value from _NT_TIB / _TEB
    QWORD vaStackLimitUser;         // value from _NT_TIB / _TEB
    QWORD vaStackBaseKernel;
    QWORD vaStackLimitKernel;
    QWORD vaTrapFrame;
    QWORD vaRIP;                    // RIP register (if user mode)
    QWORD vaRSP;                    // RSP register (if user mode)
    QWORD qwAffinity;
    DWORD dwUserTime;
    DWORD dwKernelTime;
    UCHAR bSuspendCount;
    UCHAR _FutureUse1[3];
    DWORD _FutureUse2[15];
} VMMDLL_MAP_THREADENTRY, *PVMMDLL_MAP_THREADENTRY;

typedef struct tdVMMDLL_MAP_HANDLEENTRY {
    QWORD vaObject;
    DWORD dwHandle;
    DWORD dwGrantedAccess : 24;
    DWORD iType : 8;
    QWORD qwHandleCount;
    QWORD qwPointerCount;
    QWORD vaObjectCreateInfo;
    QWORD vaSecurityDescriptor;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse2;
    DWORD dwPID;
    DWORD dwPoolTag;
    DWORD _FutureUse[5];
    union { LPSTR  uszType; LPWSTR wszType; };              // U/W dependant
} VMMDLL_MAP_HANDLEENTRY, *PVMMDLL_MAP_HANDLEENTRY;

typedef struct tdVMMDLL_MAP_NETENTRY {
    DWORD dwPID;
    DWORD dwState;
    WORD _FutureUse3[3];
    WORD AF;                        // address family (IPv4/IPv6)
    struct {
        BOOL fValid;
        WORD _Reserved;
        WORD port;
        BYTE pbAddr[16];            // ipv4 = 1st 4 bytes, ipv6 = all bytes
        union { LPSTR  uszText; LPWSTR wszText; };          // U/W dependant
    } Src;
    struct {
        BOOL fValid;
        WORD _Reserved;
        WORD port;
        BYTE pbAddr[16];            // ipv4 = 1st 4 bytes, ipv6 = all bytes
        union { LPSTR  uszText; LPWSTR wszText; };          // U/W dependant
    } Dst;
    QWORD vaObj;
    QWORD ftTime;
    DWORD dwPoolTag;
    DWORD _FutureUse4;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse2[4];
} VMMDLL_MAP_NETENTRY, *PVMMDLL_MAP_NETENTRY;

typedef struct tdVMMDLL_MAP_PHYSMEMENTRY {
    QWORD pa;
    QWORD cb;
} VMMDLL_MAP_PHYSMEMENTRY, *PVMMDLL_MAP_PHYSMEMENTRY;

typedef struct tdVMMDLL_MAP_USERENTRY {
    DWORD _FutureUse1[2];
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    ULONG64 vaRegHive;
    union { LPSTR  uszSID; LPWSTR wszSID; };                // U/W dependant
    DWORD _FutureUse2[2];
} VMMDLL_MAP_USERENTRY, *PVMMDLL_MAP_USERENTRY;

typedef struct tdVMMDLL_MAP_SERVICEENTRY {
    QWORD vaObj;
    DWORD dwOrdinal;
    DWORD dwStartType;
    SERVICE_STATUS ServiceStatus;
    union { LPSTR  uszServiceName; LPWSTR wszServiceName; };// U/W dependant
    union { LPSTR  uszDisplayName; LPWSTR wszDisplayName; };// U/W dependant
    union { LPSTR  uszPath; LPWSTR wszPath; };              // U/W dependant
    union { LPSTR  uszUserTp; LPWSTR wszUserTp; };          // U/W dependant
    union { LPSTR  uszUserAcct; LPWSTR wszUserAcct; };      // U/W dependant
    union { LPSTR  uszImagePath; LPWSTR wszImagePath; };    // U/W dependant
    DWORD dwPID;
    DWORD _FutureUse1;
    QWORD _FutureUse2;
} VMMDLL_MAP_SERVICEENTRY, *PVMMDLL_MAP_SERVICEENTRY;

typedef struct tdVMMDLL_MAP_PTE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // NULL or multi-wstr pointed into by VMMDLL_MAP_VADENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_PTEENTRY pMap[];     // map entries.
} VMMDLL_MAP_PTE, *PVMMDLL_MAP_PTE;

typedef struct tdVMMDLL_MAP_VAD {
    DWORD dwVersion;
    DWORD _Reserved1[4];
    DWORD cPage;                    // # pages in vad map.
    PBYTE pbMultiText;              // NULL or multi-wstr pointed into by VMMDLL_MAP_VADENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_VADENTRY pMap[];     // map entries.
} VMMDLL_MAP_VAD, *PVMMDLL_MAP_VAD;

typedef struct tdVMMDLL_MAP_VADEX {
    DWORD dwVersion;
    DWORD _Reserved1[4];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_VADEXENTRY pMap[];   // map entries.
} VMMDLL_MAP_VADEX, *PVMMDLL_MAP_VADEX;

typedef struct tdVMMDLL_MAP_MODULE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_MODULEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_MODULEENTRY pMap[];  // map entries.
} VMMDLL_MAP_MODULE, *PVMMDLL_MAP_MODULE;

typedef struct tdVMMDLL_MAP_UNLOADEDMODULE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_MODULEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_UNLOADEDMODULEENTRY pMap[];  // map entries.
} VMMDLL_MAP_UNLOADEDMODULE, *PVMMDLL_MAP_UNLOADEDMODULE;

typedef struct tdVMMDLL_MAP_EAT {
    DWORD dwVersion;
    DWORD dwOrdinalBase;
    DWORD cNumberOfNames;
    DWORD cNumberOfFunctions;
    DWORD _Reserved1[4];
    QWORD vaModuleBase;
    QWORD vaAddressOfFunctions;
    QWORD vaAddressOfNames;
    PBYTE pbMultiText;              // multi-str pointed into by VMM_MAP_EATENTRY.wszFunction
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_EATENTRY pMap[];     // map entries.
} VMMDLL_MAP_EAT, *PVMMDLL_MAP_EAT;

typedef struct tdVMMDLL_MAP_IAT {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    QWORD vaModuleBase;
    PBYTE pbMultiText;              // multi-str pointed into by VMM_MAP_EATENTRY.[wszFunction|wszModule]
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_IATENTRY pMap[];     // map entries.
} VMMDLL_MAP_IAT, *PVMMDLL_MAP_IAT;

typedef struct tdVMMDLL_MAP_HEAP {
    DWORD dwVersion;
    DWORD _Reserved1[8];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_HEAPENTRY pMap[];    // map entries.
} VMMDLL_MAP_HEAP, *PVMMDLL_MAP_HEAP;

typedef struct tdVMMDLL_MAP_THREAD {
    DWORD dwVersion;
    DWORD _Reserved[8];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_THREADENTRY pMap[];  // map entries.
} VMMDLL_MAP_THREAD, *PVMMDLL_MAP_THREAD;

typedef struct tdVMMDLL_MAP_HANDLE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_HANDLEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_HANDLEENTRY pMap[];  // map entries.
} VMMDLL_MAP_HANDLE, *PVMMDLL_MAP_HANDLE;

typedef struct tdVMMDLL_MAP_NET {
    DWORD dwVersion;
    DWORD _Reserved1;
    PBYTE pbMultiText;              // multi-wstr pointed into by VMM_MAP_NETENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_NETENTRY pMap[];     // map entries.
} VMMDLL_MAP_NET, *PVMMDLL_MAP_NET;

typedef struct tdVMMDLL_MAP_PHYSMEM {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    DWORD cMap;                     // # map entries.
    DWORD _Reserved2;
    VMMDLL_MAP_PHYSMEMENTRY pMap[]; // map entries.
} VMMDLL_MAP_PHYSMEM, *PVMMDLL_MAP_PHYSMEM;

typedef struct tdVMMDLL_MAP_USER {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_USERENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_USERENTRY pMap[];    // map entries.
} VMMDLL_MAP_USER, *PVMMDLL_MAP_USER;

typedef struct tdVMMDLL_MAP_SERVICE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_SERVICEENTRY.wsz*
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_SERVICEENTRY pMap[]; // map entries.
} VMMDLL_MAP_SERVICE, *PVMMDLL_MAP_SERVICE;

/*
* Retrieve the memory map entries based on hardware page tables (PTE) for the
* process. If pPteMap is set to NULL the number of bytes required will be
* returned in parameter pcbPteMap.
* Entries returned are sorted on VMMDLL_MAP_PTEENTRY.vaBase
* -- dwPID
* -- pPteMap = buffer of minimum byte length *pcbPteMap or NULL.
* -- pcbPteMap = pointer to byte count of pPteMap buffer.
* -- fIdentifyModules = try identify modules as well (= slower)
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPteU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbPteMap) PVMMDLL_MAP_PTE pPteMap, _Inout_ PDWORD pcbPteMap, _In_ BOOL fIdentifyModules);
_Success_(return) BOOL VMMDLL_Map_GetPteW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbPteMap) PVMMDLL_MAP_PTE pPteMap, _Inout_ PDWORD pcbPteMap, _In_ BOOL fIdentifyModules);

/*
* Retrieve memory map entries based on virtual address descriptor (VAD) for
* the process. If pVadMap is set to NULL the number of bytes required
* will be returned in parameter pcbVadMap.
* Entries returned are sorted on VMMDLL_MAP_VADENTRY.vaStart
* -- dwPID
* -- pVadMap = buffer of minimum byte length *pcbVadMap or NULL.
* -- pcbVadMap = pointer to byte count of pVadMap buffer.
* -- fIdentifyModules = try identify modules as well (= slower)
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetVadU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadMap) PVMMDLL_MAP_VAD pVadMap, _Inout_ PDWORD pcbVadMap, _In_ BOOL fIdentifyModules);
_Success_(return) BOOL VMMDLL_Map_GetVadW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadMap) PVMMDLL_MAP_VAD pVadMap, _Inout_ PDWORD pcbVadMap, _In_ BOOL fIdentifyModules);

/*
* Retrieve extended memory map information about a select sub-set of the memory
* map. If pVadExMap is set to NULL the number of bytes required will be
* returned in the parameter pcbVadExMap.
* -- dwPID
* -- pVadExMap = buffer of minimum byte length *pcbVadExMap or NULL.
* -- pcbVadExMap = pointer to byte count of pVadExMap buffer.
* -- oPage = offset in number of pages from process start.
* -- cPage = number of pages to process from oPages base.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Map_GetVadEx(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadExMap) PVMMDLL_MAP_VADEX pVadExMap, _Inout_ PDWORD pcbVadExMap, _In_ DWORD oPage, _In_ DWORD cPage);

/*
* Retrieve the modules (.dlls) for the specified process. If pModuleMap is set
* to NULL the number of bytes required will be returned in parameter pcbModuleMap.
* -- dwPID
* -- pModuleMap = buffer of minimum byte length *pcbModuleMap or NULL.
* -- pcbModuleMap = pointer to byte count of pModuleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetModuleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbModuleMap) PVMMDLL_MAP_MODULE pModuleMap, _Inout_ PDWORD pcbModuleMap);
_Success_(return) BOOL VMMDLL_Map_GetModuleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbModuleMap) PVMMDLL_MAP_MODULE pModuleMap, _Inout_ PDWORD pcbModuleMap);

/*
* Retrieve a module (.dll) entry given a process and module name.
* If pModuleMapEntry is set to NULL the number of bytes required
* will be returned in parameter pcbModuleMapEntry.
* If pcbModuleMapEntry is set to NULL the pModuleMapEntry is assumed to be of
* size sizeof(VMMDLL_MAP_MODULEENTRY) and data without names will be copied.
* -- dwPID
* -- [uw]szModuleName
* -- pModuleMapEntry = buffer of minimum byte length *pcbModuleMapEntry or NULL.
* -- pcbModuleMapEntry = pointer to byte count of pModuleMapEntry buffer or NULL.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetModuleFromNameU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbModuleMapEntry) PVMMDLL_MAP_MODULEENTRY pModuleMapEntry, _Inout_opt_ PDWORD pcbModuleMapEntry);
_Success_(return) BOOL VMMDLL_Map_GetModuleFromNameW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbModuleMapEntry) PVMMDLL_MAP_MODULEENTRY pModuleMapEntry, _Inout_opt_ PDWORD pcbModuleMapEntry);

/*
* Retrieve the unloaded modules (.dll/.sys) for the specified process. If
* pUnloadedModuleMap is set to NULL the number of bytes required will be
* returned in parameter pcbUnloadedModuleMap.
* -- dwPID
* -- pUnloadedModuleMap = buffer of minimum byte length *pcbUnloadedModuleMap or NULL.
* -- pcbUnloadedModuleMap = pointer to byte count of pUnloadedModuleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetUnloadedModuleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbUnloadedModuleMap) PVMMDLL_MAP_UNLOADEDMODULE pUnloadedModuleMap, _Inout_ PDWORD pcbUnloadedModuleMap);
_Success_(return) BOOL VMMDLL_Map_GetUnloadedModuleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbUnloadedModuleMap) PVMMDLL_MAP_UNLOADEDMODULE pUnloadedModuleMap, _Inout_ PDWORD pcbUnloadedModuleMap);

/*
* Retrieve the module exported functions from the export address table (EAT).
* If pEatMap is set to NULL the number of bytes required will be returned in
* parameter pcbEatMap.
* -- dwPID
* -- [uw]szModuleName
* -- pEatMap = buffer of minimum byte length *pcbEatMap or NULL.
* -- pcbEatMap = pointer to byte count of pEatMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetEATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbEatMap) PVMMDLL_MAP_EAT pEatMap, _Inout_ PDWORD pcbEatMap);
_Success_(return) BOOL VMMDLL_Map_GetEATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbEatMap) PVMMDLL_MAP_EAT pEatMap, _Inout_ PDWORD pcbEatMap);

/*
* Retrieve the module imported functions from the import address table (IAT).
* If pIatMap is set to NULL the number of bytes required will be returned in
* parameter pcbIatMap.
* -- dwPID
* -- [uw]szModuleName
* -- pIatMap = buffer of minimum byte length *pcbIatMap or NULL.
* -- pcbIatMap = pointer to byte count of pIatMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetIATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbIatMap) PVMMDLL_MAP_IAT pIatMap, _Inout_ PDWORD pcbIatMap);
_Success_(return) BOOL VMMDLL_Map_GetIATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbIatMap) PVMMDLL_MAP_IAT pIatMap, _Inout_ PDWORD pcbIatMap);

/*
* Retrieve the heaps for the specified process. If pHeapMap is set to NULL
* the number of bytes required will be returned in parameter pcbHeapMap.
* -- dwPID
* -- pHeapMap = buffer of minimum byte length *pcbHeapMap or NULL.
* -- pcbHeapMap = pointer to byte count of pHeapMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetHeap(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHeapMap) PVMMDLL_MAP_HEAP pHeapMap, _Inout_ PDWORD pcbHeapMap);

/*
* Retrieve the threads for the specified process. If pThreadMap is set to NULL
* the number of bytes required will be returned in parameter pcbThreadMap.
* Entries returned are sorted on VMMDLL_MAP_THREADENTRY.dwTID
* -- dwPID
* -- pThreadMap = buffer of minimum byte length *pcbThreadMap or NULL.
* -- pcbThreadMap = pointer to byte count of pThreadMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetThread(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbThreadMap) PVMMDLL_MAP_THREAD pThreadMap, _Inout_ PDWORD pcbThreadMap);

/*
* Retrieve the handles for the specified process. If pHandleMap is set to NULL
* the number of bytes required will be returned in parameter pcbHandleMap.
* Entries returned are sorted on VMMDLL_MAP_HANDLEENTRY.dwHandle
* -- dwPID
* -- pHandleMap = buffer of minimum byte length *pcbHandleMap or NULL.
* -- pcbHandleMap = pointer to byte count of pHandleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetHandleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHandleMap) PVMMDLL_MAP_HANDLE pHandleMap, _Inout_ PDWORD pcbHandleMap);
_Success_(return) BOOL VMMDLL_Map_GetHandleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHandleMap) PVMMDLL_MAP_HANDLE pHandleMap, _Inout_ PDWORD pcbHandleMap);

/*
* Retrieve the physical memory ranges from the physical memory map that Windows
* have enumerated.
* -- pPhysMemMap = buffer of minimum byte length *pcbPhysMemMap or NULL.
* -- pcbPhysMemMap = pointer to byte count of pPhysMemMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPhysMem(_Out_writes_bytes_opt_(*pcbPhysMemMap) PVMMDLL_MAP_PHYSMEM pPhysMemMap, _Inout_ PDWORD pcbPhysMemMap);

/*
* Retrieve the network connection map - consisting of active network connections,
* listening sockets and other networking functionality.
* -- pNetMap = buffer of minimum byte length *pcbNetMap or NULL.
* -- pcbNetMap = pointer to byte count of pNetrMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetNetU(_Out_writes_bytes_opt_(*pcbNetMap) PVMMDLL_MAP_NET pNetMap, _Inout_ PDWORD pcbNetMap);
_Success_(return) BOOL VMMDLL_Map_GetNetW(_Out_writes_bytes_opt_(*pcbNetMap) PVMMDLL_MAP_NET pNetMap, _Inout_ PDWORD pcbNetMap);

/*
* Retrieve the non well known users that are detected in the target system.
* NB! There may be more users in the system than the ones that are detected,
* only users with mounted registry hives may currently be detected - this is
* the normal behaviour for users with active processes.
* -- pUserMap = buffer of minimum byte length *pcbUserMap or NULL.
* -- pcbUserMap = pointer to byte count of pUserMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetUsersU(_Out_writes_bytes_opt_(*pcbUserMap) PVMMDLL_MAP_USER pUserMap, _Inout_ PDWORD pcbUserMap);
_Success_(return) BOOL VMMDLL_Map_GetUsersW(_Out_writes_bytes_opt_(*pcbUserMap) PVMMDLL_MAP_USER pUserMap, _Inout_ PDWORD pcbUserMap);

/*
* Retrieve the services currently known by the service control manager (SCM).
* -- pServiceMap = buffer of minimum byte length *pcbServiceMap or NULL.
* -- pcbServiceMap = pointer to byte count of pServiceMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetServicesU(_Out_writes_bytes_opt_(*pcbServiceMap) PVMMDLL_MAP_SERVICE pServiceMap, _Inout_ PDWORD pcbServiceMap);
_Success_(return) BOOL VMMDLL_Map_GetServicesW(_Out_writes_bytes_opt_(*pcbServiceMap) PVMMDLL_MAP_SERVICE pServiceMap, _Inout_ PDWORD pcbServiceMap);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC PAGE FRAME NUMBER (PFN) FUNCTIONALITY BELOW
//-----------------------------------------------------------------------------

#define VMMDLL_MAP_PFN_VERSION              1

static LPCSTR VMMDLL_PFN_TYPE_TEXT[] = { "Zero", "Free", "Standby", "Modifiy", "ModNoWr", "Bad", "Active", "Transit" };
static LPCSTR VMMDLL_PFN_TYPEEXTENDED_TEXT[] = { "-", "Unused", "ProcPriv", "PageTable", "LargePage", "DriverLock", "Shareable", "File" };

typedef enum tdVMMDLL_MAP_PFN_TYPE {
    VmmDll_PfnTypeZero = 0,
    VmmDll_PfnTypeFree = 1,
    VmmDll_PfnTypeStandby = 2,
    VmmDll_PfnTypeModified = 3,
    VmmDll_PfnTypeModifiedNoWrite = 4,
    VmmDll_PfnTypeBad = 5,
    VmmDll_PfnTypeActive = 6,
    VmmDll_PfnTypeTransition = 7
} VMMDLL_MAP_PFN_TYPE;

typedef enum tdVMMDLL_MAP_PFN_TYPEEXTENDED {
    VmmDll_PfnExType_Unknown = 0,
    VmmDll_PfnExType_Unused = 1,
    VmmDll_PfnExType_ProcessPrivate = 2,
    VmmDll_PfnExType_PageTable = 3,
    VmmDll_PfnExType_LargePage = 4,
    VmmDll_PfnExType_DriverLocked = 5,
    VmmDll_PfnExType_Shareable = 6,
    VmmDll_PfnExType_File = 7,
} VMMDLL_MAP_PFN_TYPEEXTENDED;

typedef struct tdVMMDLL_MAP_PFNENTRY {
    DWORD dwPfn;
    VMMDLL_MAP_PFN_TYPEEXTENDED tpExtended;
    struct {        // Only valid if active non-prototype PFN
        union {
            DWORD dwPid;
            DWORD dwPfnPte[5];  // PFN of paging levels 1-4 (x64)
        };
        QWORD va;               // valid if non-zero
    } AddressInfo;
    QWORD vaPte;
    QWORD OriginalPte;
    union {
        DWORD _u3;
        struct {
            WORD ReferenceCount;
            // MMPFNENTRY
            BYTE PageLocation       : 3;    // Pos 0  - VMMDLL_MAP_PFN_TYPE
            BYTE WriteInProgress    : 1;    // Pos 3
            BYTE Modified           : 1;    // Pos 4
            BYTE ReadInProgress     : 1;    // Pos 5
            BYTE CacheAttribute     : 2;    // Pos 6
            BYTE Priority           : 3;    // Pos 0
            BYTE Rom_OnProtectedStandby : 1;// Pos 3
            BYTE InPageError        : 1;    // Pos 4
            BYTE KernelStack_SystemChargedPage : 1; // Pos 5
            BYTE RemovalRequested   : 1;    // Pos 6
            BYTE ParityError        : 1;    // Pos 7
        };
    };
    union {
        QWORD _u4;
        struct {
            DWORD PteFrame;
            DWORD PteFrameHigh      : 4;    // Pos 32
            DWORD _Reserved         : 21;   // Pos 36
            DWORD PrototypePte      : 1;    // Pos 57
            DWORD PageColor         : 6;    // Pos 58
        };
    };
    DWORD _FutureUse[6];
} VMMDLL_MAP_PFNENTRY, *PVMMDLL_MAP_PFNENTRY;

typedef struct tdVMMDLL_MAP_PFN {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_PFNENTRY pMap[];     // map entries.
} VMMDLL_MAP_PFN, *PVMMDLL_MAP_PFN;

/*
* Retrieve information about scattered PFNs. The PFNs are returned in order of
* in which they are stored in the pPfns set.
* -- pPfns
* -- cPfns
* -- pPfnMap = buffer of minimum byte length *pcbPfnMap or NULL.
* -- pcbPfnMap = pointer to byte count of pPhysMemMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Map_GetPfn(_In_ DWORD pPfns[], _In_ DWORD cPfns, _Out_writes_bytes_opt_(*pcbPfnMap) PVMMDLL_MAP_PFN pPfnMap, _Inout_ PDWORD pcbPfnMap);



//-----------------------------------------------------------------------------
// VMM PROCESS FUNCTIONALITY BELOW:
// Functionality below is mostly relating to Windows processes.
//-----------------------------------------------------------------------------

/*
* Retrieve an active process given it's name. Please note that if multiple
* processes with the same name exists only one will be returned. If required to
* parse all processes with the same name please iterate over the PID list by
* calling VMMDLL_PidList together with VMMDLL_ProcessGetInformation.
* -- szProcName = process name case insensitive.
* -- pdwPID = pointer that will receive PID on success.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PidGetFromName(_In_ LPSTR szProcName, _Out_ PDWORD pdwPID);

/*
* List the PIDs in the system.
* -- pPIDs = DWORD array of at least number of PIDs in system, or NULL.
* -- pcPIDs = size of (in number of DWORDs) pPIDs array on entry, number of PIDs in system on exit.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PidList(_Out_writes_opt_(*pcPIDs) PDWORD pPIDs, _Inout_ PULONG64 pcPIDs); 

#define VMMDLL_PROCESS_INFORMATION_MAGIC        0xc0ffee663df9301e
#define VMMDLL_PROCESS_INFORMATION_VERSION      6

typedef struct tdVMMDLL_PROCESS_INFORMATION {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    VMMDLL_MEMORYMODEL_TP tpMemoryModel;    // as given by VMMDLL_MEMORYMODEL_* enum
    VMMDLL_SYSTEM_TP tpSystem;              // as given by VMMDLL_SYSTEM_* enum
    BOOL fUserOnly;                         // only user mode pages listed
    DWORD dwPID;
    DWORD dwPPID;
    DWORD dwState;
    CHAR szName[16];
    CHAR szNameLong[64];
    ULONG64 paDTB;
    ULONG64 paDTB_UserOpt;                  // may not exist
    struct {
        ULONG64 vaEPROCESS;
        ULONG64 vaPEB;
        ULONG64 _Reserved1;
        BOOL fWow64;
        DWORD vaPEB32;                  // WoW64 only
        DWORD dwSessionId;
        ULONG64 qwLUID;
        CHAR szSID[MAX_PATH];
    } win;
} VMMDLL_PROCESS_INFORMATION, *PVMMDLL_PROCESS_INFORMATION;

/*
* Retrieve various process information from a PID. Process information such as
* name, page directory bases and the process state may be retrieved.
* -- dwPID
* -- pProcessInformation = if null, size is given in *pcbProcessInfo
* -- pcbProcessInformation = size of pProcessInfo (in bytes) on entry and exit
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ProcessGetInformation(_In_ DWORD dwPID, _Inout_opt_ PVMMDLL_PROCESS_INFORMATION pProcessInformation, _In_ PSIZE_T pcbProcessInformation);

#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_PATH_KERNEL           1
#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_PATH_USER_IMAGE       2
#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_CMDLINE               3

/*
* Retrieve a string value belonging to a process. The function allocates a new
* string buffer and returns the requested string in it. The string is always
* NULL terminated. On failure NULL is returned.
* NB! CALLER IS RESPONSIBLE FOR VMMDLL_MemFree return value!
* CALLER FREE: VMMDLL_MemFree(return)
* -- dwPID
* -- fOptionString = string value to retrieve as given by VMMDLL_PROCESS_INFORMATION_OPT_STRING_*
* -- return - fail: NULL, success: the string - NB! must be VMMDLL_MemFree'd by caller!
*/
EXPORTED_FUNCTION
LPSTR VMMDLL_ProcessGetInformationString(_In_ DWORD dwPID, _In_ DWORD fOptionString);

/*
* Retrieve information about: Data Directories, Sections, Export Address Table
* and Import Address Table (IAT).
* If the pData == NULL upon entry the number of entries of the pData array must
* have in order to be able to hold the data is returned.
* -- dwPID
* -- [uw]szModule
* -- pData
* -- cData
* -- pcData
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_ProcessGetDirectoriesU(_In_ DWORD dwPID, _In_ LPSTR  uszModule, _Out_writes_(16) PIMAGE_DATA_DIRECTORY pData, _In_ DWORD cData, _Out_ PDWORD pcData);
_Success_(return) BOOL VMMDLL_ProcessGetDirectoriesW(_In_ DWORD dwPID, _In_ LPWSTR wszModule, _Out_writes_(16) PIMAGE_DATA_DIRECTORY pData, _In_ DWORD cData, _Out_ PDWORD pcData);
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_ProcessGetSectionsU(_In_ DWORD dwPID, _In_ LPSTR  uszModule, _Out_opt_ PIMAGE_SECTION_HEADER pData, _In_ DWORD cData, _Out_ PDWORD pcData);
_Success_(return) BOOL VMMDLL_ProcessGetSectionsW(_In_ DWORD dwPID, _In_ LPWSTR wszModule, _Out_opt_ PIMAGE_SECTION_HEADER pData, _In_ DWORD cData, _Out_ PDWORD pcData);

/*
* Retrieve the virtual address of a given function inside a process/module.
* -- dwPID
* -- [uw]szModuleName
* -- szFunctionName
* -- return = virtual address of function, zero on fail.
*/
EXPORTED_FUNCTION
ULONG64 VMMDLL_ProcessGetProcAddressU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _In_ LPSTR szFunctionName);
ULONG64 VMMDLL_ProcessGetProcAddressW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _In_ LPSTR szFunctionName);

/*
* Retrieve the base address of a given module.
* -- dwPID
* -- [uw]szModuleName
* -- return = virtual address of module base, zero on fail.
*/
EXPORTED_FUNCTION
ULONG64 VMMDLL_ProcessGetModuleBaseU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName);
ULONG64 VMMDLL_ProcessGetModuleBaseW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC DEBUGGING / SYMBOL FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

/*
* Load a .pdb symbol file and return its associated module name upon success.
* -- dwPID
* -- vaModuleBase
* -- szModuleName = buffer to receive module name upon success.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbLoad(_In_ DWORD dwPID, _In_ ULONG64 vaModuleBase, _Out_writes_(MAX_PATH) LPSTR szModuleName);

/*
* Retrieve a symbol virtual address given a module name and a symbol name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- cbSymbolAddressOrOffset = symbol virtual address or symbol offset.
* -- szSymbolName = buffer to receive symbol name upon success.
* -- pdwSymbolDisplacement = displacement from the beginning of the symbol.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbSymbolName(_In_ LPSTR szModule, _In_ QWORD cbSymbolAddressOrOffset, _Out_writes_(MAX_PATH) LPSTR szSymbolName, _Out_opt_ PDWORD pdwSymbolDisplacement);

/*
* Retrieve a symbol virtual address given a module name and a symbol name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- szSymbolName
* -- pvaSymbolAddress
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbSymbolAddress(_In_ LPSTR szModule, _In_ LPSTR szSymbolName, _Out_ PULONG64 pvaSymbolAddress);

/*
* Retrieve a type size given a module name and a type name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- szTypeName
* -- pcbTypeSize
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbTypeSize(_In_ LPSTR szModule, _In_ LPSTR szTypeName, _Out_ PDWORD pcbTypeSize);

/*
* Locate the offset of a type child - typically a sub-item inside a struct.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- uszTypeName
* -- uszTypeChildName
* -- pcbTypeChildOffset
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbTypeChildOffset(_In_ LPSTR szModule, _In_ LPSTR uszTypeName, _In_ LPSTR uszTypeChildName, _Out_ PDWORD pcbTypeChildOffset);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC REGISTRY FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

#define VMMDLL_REGISTRY_HIVE_INFORMATION_MAGIC      0xc0ffee653df8d01e
#define VMMDLL_REGISTRY_HIVE_INFORMATION_VERSION    3

typedef struct td_VMMDLL_REGISTRY_HIVE_INFORMATION {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    BYTE _FutureReserved1[0x14];
    ULONG64 vaCMHIVE;
    ULONG64 vaHBASE_BLOCK;
    DWORD cbLength;
    CHAR uszName[128];
    CHAR uszNameShort[32 + 1];
    CHAR uszHiveRootPath[MAX_PATH];
    QWORD _FutureReserved[0x10];
} VMMDLL_REGISTRY_HIVE_INFORMATION, *PVMMDLL_REGISTRY_HIVE_INFORMATION;

/*
* Retrieve information about the registry hives in the target system.
* -- pHives = buffer of cHives * sizeof(VMMDLL_REGISTRY_HIVE_INFORMATION) to receive information about all hives. NULL to receive # hives in pcHives.
* -- cHives
* -- pcHives = if pHives == NULL: # total hives. if pHives: # read hives.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveList(_Out_writes_(cHives) PVMMDLL_REGISTRY_HIVE_INFORMATION pHives, _In_ DWORD cHives, _Out_ PDWORD pcHives);

/*
* Read a contigious arbitrary amount of registry hive memory and report the
* number of bytes read in pcbRead.
* NB! Address space does not include regf registry hive file header!
* -- vaCMHive
* -- ra
* -- pb
* -- cb
* -- pcbReadOpt
* -- flags = flags as in VMMDLL_FLAG_*
* -- return = success/fail. NB! reads may report as success even if 0 bytes are
*        read - it's recommended to verify pcbReadOpt parameter.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveReadEx(_In_ ULONG64 vaCMHive, _In_ DWORD ra, _Out_ PBYTE pb, _In_ DWORD cb, _Out_opt_ PDWORD pcbReadOpt, _In_ ULONG64 flags);

/*
* Write a virtually contigious arbitrary amount of memory to a registry hive.
* NB! Address space does not include regf registry hive file header!
* -- vaCMHive
* -- ra
* -- pb
* -- cb
* -- return = TRUE on success, FALSE on partial or zero write.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveWrite(_In_ ULONG64 vaCMHive, _In_ DWORD ra, _In_ PBYTE pb, _In_ DWORD cb);

/*
* Enumerate registry sub keys - similar to WINAPI function 'RegEnumKeyExW.'
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- uszFullPathKey
* -- dwIndex = sub-key index 0..N (-1 for key).
* -- lpName
* -- lpcchName
* -- lpftLastWriteTime
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_EnumKeyExU(
    _In_ LPSTR uszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchName) LPSTR lpName,
    _Inout_ LPDWORD lpcchName,
    _Out_opt_ PFILETIME lpftLastWriteTime
);

/*
* Enumerate registry values given a registry key - similar to WINAPI function
* 'EnumValueW'. Please consult WINAPI function documentation for information.
* May be called in two ways:
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- uszFullPathKey
* -- dwIndex
* -- lpValueName
* -- lpcchValueName
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_EnumValueU(
    _In_ LPSTR uszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchValueName) LPSTR lpValueName,
    _Inout_ LPDWORD lpcchValueName,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _Inout_opt_ LPDWORD lpcbData
);

/*
* Query a registry value given a registry key/value path - similar to WINAPI
* function 'RegQueryValueEx'.
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey\Value'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey\'             (orphan key and default value)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey\Value'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey\Value'    (orphan key value)
* -- uszFullPathKeyValue
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_QueryValueExU(
    _In_ LPSTR uszFullPathKeyValue,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _When_(lpData == NULL, _Out_opt_) _When_(lpData != NULL, _Inout_opt_) LPDWORD lpcbData
);

/*
* Enumerate registry sub keys - similar to WINAPI function 'RegEnumKeyExW.'
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- wszFullPathKey
* -- dwIndex = sub-key index 0..N (-1 for key).
* -- lpName
* -- lpcchName
* -- lpftLastWriteTime
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_EnumKeyExW(
    _In_ LPWSTR wszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchName) LPWSTR lpName,
    _Inout_ LPDWORD lpcchName,
    _Out_opt_ PFILETIME lpftLastWriteTime
);

/*
* Enumerate registry values given a registry key - similar to WINAPI function
* 'EnumValueW'. Please consult WINAPI function documentation for information.
* May be called in two ways:
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- wszFullPathKey
* -- dwIndex
* -- lpValueName
* -- lpcchValueName
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_EnumValueW(
    _In_ LPWSTR wszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchValueName) LPWSTR lpValueName,
    _Inout_ LPDWORD lpcchValueName,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _Inout_opt_ LPDWORD lpcbData
);

/*
* Query a registry value given a registry key/value path - similar to WINAPI
* function 'RegQueryValueEx'.
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey\Value'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey\'             (orphan key and default value)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey\Value'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey\Value'    (orphan key value)
* -- wszFullPathKeyValue
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_QueryValueExW(
    _In_ LPWSTR wszFullPathKeyValue,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _When_(lpData == NULL, _Out_opt_) _When_(lpData != NULL, _Inout_opt_) LPDWORD lpcbData
);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC UTILITY FUNCTIONS BELOW:
//-----------------------------------------------------------------------------

typedef struct tdVMMDLL_WIN_THUNKINFO_IAT {
    BOOL fValid;
    BOOL f32;               // if TRUE fn is a 32-bit/4-byte entry, otherwise 64-bit/8-byte entry.
    ULONG64 vaThunk;        // address of import address table 'thunk'.
    ULONG64 vaFunction;     // value if import address table 'thunk' == address of imported function.
    ULONG64 vaNameModule;   // address of name string for imported module.
    ULONG64 vaNameFunction; // address of name string for imported function.
} VMMDLL_WIN_THUNKINFO_IAT, *PVMMDLL_WIN_THUNKINFO_IAT;

/*
* Retrieve information about the import address table IAT thunk for an imported
* function. This includes the virtual address of the IAT thunk which is useful
* for hooking.
* -- dwPID
* -- [uw]szModuleName
* -- szImportModuleName
* -- szImportFunctionName
* -- pThunkIAT
* -- return
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_WinGetThunkInfoIATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _In_ LPSTR szImportModuleName, _In_ LPSTR szImportFunctionName, _Out_ PVMMDLL_WIN_THUNKINFO_IAT pThunkInfoIAT);
_Success_(return) BOOL VMMDLL_WinGetThunkInfoIATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _In_ LPSTR szImportModuleName, _In_ LPSTR szImportFunctionName, _Out_ PVMMDLL_WIN_THUNKINFO_IAT pThunkInfoIAT);



//-----------------------------------------------------------------------------
// VMM UTIL FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

/*
* Fill a human readable hex ascii memory dump into the caller supplied sz buffer.
* -- pb
* -- cb
* -- cbInitialOffset = offset, must be max 0x1000 and multiple of 0x10.
* -- sz = buffer to fill, NULL to retrieve buffer size in pcsz parameter.
* -- pcsz = IF sz==NULL :: size of buffer (including space for terminating NULL) on exit
*           IF sz!=NULL :: size of buffer on entry, size of characters (excluding terminating NULL) on exit.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_UtilFillHexAscii(
    _In_reads_opt_(cb) PBYTE pb,
    _In_ DWORD cb,
    _In_ DWORD cbInitialOffset,
    _Out_writes_opt_(*pcsz) LPSTR sz,
    _Inout_ PDWORD pcsz
);



//-----------------------------------------------------------------------------
// DEFAULT (WINDOWS ONLY) COMPATIBILITY FUNCTION DEFINITIONS BELOW:
//-----------------------------------------------------------------------------

#ifdef _WIN32
#define VMMDLL_VfsList                  VMMDLL_VfsListW
#define VMMDLL_VfsRead                  VMMDLL_VfsReadW
#define VMMDLL_VfsWrite                 VMMDLL_VfsWriteW
#define VMMDLL_ProcessGetDirectories    VMMDLL_ProcessGetDirectoriesW
#define VMMDLL_ProcessGetSections       VMMDLL_ProcessGetSectionsW
#define VMMDLL_ProcessGetProcAddress    VMMDLL_ProcessGetProcAddressW
#define VMMDLL_ProcessGetModuleBase     VMMDLL_ProcessGetModuleBaseW
#define VMMDLL_Map_GetPte               VMMDLL_Map_GetPteW
#define VMMDLL_Map_GetVad               VMMDLL_Map_GetVadW
#define VMMDLL_Map_GetModule            VMMDLL_Map_GetModuleW
#define VMMDLL_Map_GetModuleFromName    VMMDLL_Map_GetModuleFromNameW
#define VMMDLL_Map_GetUnloadedModule    VMMDLL_Map_GetUnloadedModuleW
#define VMMDLL_Map_GetEAT               VMMDLL_Map_GetEATW
#define VMMDLL_Map_GetIAT               VMMDLL_Map_GetIATW
#define VMMDLL_Map_GetHandle            VMMDLL_Map_GetHandleW
#define VMMDLL_Map_GetNet               VMMDLL_Map_GetNetW
#define VMMDLL_Map_GetUsers             VMMDLL_Map_GetUsersW
#define VMMDLL_Map_GetServices          VMMDLL_Map_GetServicesW
#define VMMDLL_WinGetThunkInfoIAT       VMMDLL_WinGetThunkInfoIATW
#endif /* _WIN32 */

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* __VMMDLL_H__ */

```