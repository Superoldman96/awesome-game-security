Project Path: arc_gmh5225_nstool_g5tmyxkk

Source Tree:

```txt
arc_gmh5225_nstool_g5tmyxkk
├── BUILDING.md
├── LICENSE
├── README.md
├── SWITCH_KEYS.md
├── build
│   └── visualstudio
│       ├── nstool
│       │   ├── nstool.vcxproj
│       │   └── nstool.vcxproj.filters
│       └── nstool.sln
├── deps
│   ├── libfmt
│   ├── liblz4
│   ├── libmbedtls
│   ├── libpietendo
│   └── libtoolchain
├── makefile
└── src
    ├── AssetProcess.cpp
    ├── AssetProcess.h
    ├── CnmtProcess.cpp
    ├── CnmtProcess.h
    ├── ElfSymbolParser.cpp
    ├── ElfSymbolParser.h
    ├── EsCertProcess.cpp
    ├── EsCertProcess.h
    ├── EsTikProcess.cpp
    ├── EsTikProcess.h
    ├── FsProcess.cpp
    ├── FsProcess.h
    ├── GameCardProcess.cpp
    ├── GameCardProcess.h
    ├── IniProcess.cpp
    ├── IniProcess.h
    ├── KeyBag.cpp
    ├── KeyBag.h
    ├── KipProcess.cpp
    ├── KipProcess.h
    ├── MetaProcess.cpp
    ├── MetaProcess.h
    ├── NacpProcess.cpp
    ├── NacpProcess.h
    ├── NcaProcess.cpp
    ├── NcaProcess.h
    ├── NroProcess.cpp
    ├── NroProcess.h
    ├── NsoProcess.cpp
    ├── NsoProcess.h
    ├── PfsProcess.cpp
    ├── PfsProcess.h
    ├── PkiValidator.cpp
    ├── PkiValidator.h
    ├── RoMetadataProcess.cpp
    ├── RoMetadataProcess.h
    ├── RomfsProcess.cpp
    ├── RomfsProcess.h
    ├── SdkApiString.cpp
    ├── SdkApiString.h
    ├── Settings.cpp
    ├── Settings.h
    ├── elf.h
    ├── main.cpp
    ├── types.h
    ├── util.cpp
    ├── util.h
    └── version.h

```

`BUILDING.md`:

```md
# Building
## Linux (incl. Windows Subsystem for Linux) & MacOS - Makefile
### Requirements
* `make`
* Terminal access
* Typical GNU compatible development tools (e.g. `clang`, `g++`, `c++`, `ar` etc) with __C++11__ support

### Using Makefile
* `make` (default) - Compile program
	* Compiling the program requires local dependencies to be compiled via `make deps` beforehand
* `make clean` - Remove executable and object files
* `make deps` - Compile locally included dependency libraries
* `make clean_deps` - Remove compiled library binaries and object files

## Native Windows - Visual Studio
### Requirements
* [Visual Studio Community](https://visualstudio.microsoft.com/vs/community/) 2015 / 2017 / 2019

### Compiling NSTool
* Open `build/visualstudio/nstool.sln` in Visual Studio
* Select Target (e.g `Debug`|`Release` & `x86`|`x64`)
* Navigate to `Build`->`Build Solution`
```

`LICENSE`:

```
MIT License

Copyright (c) 2019 Jack

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Nintendo Switch Tool (NSTool) ![DeviceTag](https://img.shields.io/badge/Device-SWITCH-e60012.svg)
General purpose reading/extraction tool for Nintendo Switch file formats.

## Supported File Formats
* PartitionFs (`PFS0`) (.pfs0)
* Sha256PartitionFs (`HFS0`) (.hfs0)
* RomFs (.romfs)
* Nintendo Content Archive (.nca)
* Nintendo Submission Package (.nsp)
* NX GameCard Image (.xci)
* Meta (`META`) (.npdm)
* Nintendo Application Control Property (.nacp)
* Content Metadata (.cnmt) 
* ES Certificate (.cert)
* ES Ticket (v2 only) (.tik)
* Nintendo Shared Object (`NSO0`) (.nso) 
* Nintendo Relocatable Object (`NRO0`) (.nro)
* Initial Program Bundle (`INI1`) (.ini)
* Initial Program (`KIP1`) (.kip)

# Usage
## General usage
The default mode of NSTool is to show general information about a file.

To display general information the usage is as follows:
```
nstool some_file.bin
```

However not all information is shown in this mode; file-layout, key data and properties set to default values are omitted.

## Alternative output modes
To output file-layout information, use the `--showlayout` option:
```
nstool --showlayout some_file.bin
```

To output key data generation and selection, use the `--showkeys` option:
```
nstool --showkeys some_file.bin
```

To output all information, enable the verbose output mode with the `-v` or `--verbose` option:
```
nstool -v some_file.bin
```

## Specify File Type
NSTool will in most cases correctly identify the file type. However you can override this and manually specify the file type with the `-t` or `--type` option:
```
nstool -t cnmt some_file.bin
```
In that example `cnmt` was selected, NSTool would process the file as `Content Metadata`. See below for a list of supported file type codes:
| Code        | Description |
| ----------- | --------------- |
| gc, xci     | NX GameCard Image |
| nsp         | Nintendo Submission Package |
| pfs         | PartitionFs |
| hfs         | Sha256PartitionFs |
| romfs       | RomFs |
| nca         | Nintendo Content Archive |
| meta, npdm  | Meta (.npdm) |
| cnmt        | Content Metadata |
| nso         | Nintendo Shared Object |
| nro         | Nintendo Relocatable Object |
| ini         | Initial Program Bundle |
| kip         | Initial Program |
| nacp        | Nintendo Application Control Property |
| cert        | ES Certificate |
| tik         | ES Ticket |
| aset, asset | Homebrew NRO Asset Binary |

## Validate Input File
Some file types have signatures/hashes/fields that can be validated by NSTool, but this mode isn't enabled by default.

To validate files with NSTool, enable the verify mode with the `-y` or `--verify` option:
```
nstool -y some_file.bin
```

See the below table for file types that support optional validation:
| File Type | Validation | Comments |
| --------- | ---------- | -------- |
| ES Certificate | Signature | If certificate is part of a certificate chain it will validate it as part of that chain. `Root` signed certificates are verified with user supplied `Root` public key. |
| ES Ticket | Signature | If the user specifies a certificate chain with `--cert` option, the ticket will be verified against that certificate chain. |
| NX GameCard Image | XCI Header Signature, HFS0 Hashes | XCI header signature is verified with user supplied `XCI Header` public key. |
| META | AccessControlInfo fields, AccessControlInfoDesc signature | AccessControlInfo fields are validated against the AccessControlInfoDesc. AccessControlInfoDesc signature is verfied with the appropriate user supplied `ACID` public key. |
| NCA | Header Signature[0], Header Signature[1] | Header Signature[0] is verified with the appropriate user supplied `NCA Header` public key. Header Signature[1] is verified only in Program titles, by retrieving the with public key from the AccessControlInfoDesc stored in the `code` partition. |

* As of Nintendo Switch Firmware 9.0.0, Nintendo retroactively added key generations for some public keys, including `NCA Header` and `ACID` public keys, so the various generations for these public keys will have to be supplied by the user.
* As of NSTool v1.6.0 the public key(s) for `Root Certificate`, `XCI Header`, `ACID` and `NCA Header` are built-in, and will be used if the user does not supply the public key in a key file.

## DevKit Mode
Files generated for `Production` use different (for the most part) encryption/signing keys than files generated for `Development`. NSTool will select `Production` encryption/signing keys by default.
When handling files intended for developer consoles (e.g. systemupdaters, devtools, test builds, etc), you should enable developer mode with the `-d`, `--dev` option:
```
nstool -d some_file.bin
```

## Extract Files
Some file types have an internal file system. This can be displayed and extracted.

To display the file system tree, use the file tree option `--fstree`:
```
nstool --fstree some_file.bin
```

To extract the file system, use the extract option `-x`, `--extract`. Which has four modes.

1) Extract the entire file system.

This extracts the contents of the entire file system to `./extract_dir/`. `extract_dir` will be created if it doesn't exist.
```
nstool -x ./extract_dir/ some_file.bin
```

2) Extract a sub directory.

This extracts the contents of `/a/sub/directory/` to `./extract_dir/`. `extract_dir` will be created if it doesn't exist.
```
nstool -x /a/sub/directory/ ./extract_dir/ some_file.bin
```

3) Extract a specific file, preserving the original name.

This extracts `/path/to/a/file.bin` to `./extract_dir/file.bin`.
```
nstool -x /path/to/a/file.bin ./extract_dir/ some_file.bin
```

4) Extract a specific file with a custom name.

This extracts `/path/to/a/file.bin` to `./extract_dir/different_name.bin`.
```
nstool -x /path/to/a/file.bin ./extract_dir/different_name.bin some_file.bin
```

### Supported File Types
* PartitionFs
* Sha256PartitionFs
* RomFs (including RomFs embedded in Homebrew NRO)
* NCA
* NSP
* XCI

## NCA Patches
Nintendo distributes game patches/updates in the style of a diff to keep file sizes down. This means extracting game patches requires the base version of the game to be able to process patch data. Typically this is only done for the Program NCA.

If `basegame_v0.nca` is the base Program NCA, and `gamepatch_v13219.nca` is the patch Program NCA, simply specify the base NCA using the base NCA option `--basenca` when processing the patch NCA.

```
nstool --basenca ./basegame_v0.nca -x ./patchdata gamepatch_v13219.nca
```
In the above example the patch NCA is being extracted to `./patchdata`

## Encrypted Files
Some Nintendo Switch files are partially or completely encrypted. These require the user to supply the encryption keys to NSTool so that it can process them. 

See [SWITCH_KEYS.md](/SWITCH_KEYS.md) for more info.

# External Keys
NSTool doesn't embed any keys that are copyright protected. However keys can be imported via various keyset files. 

See [SWITCH_KEYS.md](/SWITCH_KEYS.md) for more info.

# Building
See [BUILDING.md](/BUILDING.md).
```

`SWITCH_KEYS.md`:

```md

# About
Keyset files are ASCII text files containing one key per line, in the form "__key_name = HEXADECIMALKEY__". Case and whitespace do not matter, ';' character can be used to insert comments.

# Loading keyset files automatically
If a keyset file is located in ___$HOME/.switch/___ it will be loaded automatically.

# General Keys (prod.keys and dev.keys)
Some switch files formats feature encryption and or cryptographic signatures. In order to process these file formats, some keys are required. These keys can be supplied via a keyfile: ___prod.keys___ (or ___dev.keys___ for devkit variants).

This keyset file can be provided via the command line, use the `-k` or `--keyset` option:
```
nstool -k prod.keys some_file.bin
```

## Format
The following keys are recognised (## represents the key revision, a hexadecimal number between 00 and FF):

```
; Key Sources
master_key_##                         : Master key, used to derive other keys. (0x10 bytes)
aes_kek_generation_source             : Used to derive other aes-keks. (0x10 bytes)
aes_key_generation_source             : Used to derive other aes-keys. (0x10 bytes)
package2_key_source                   : Used with master_key_## to derive package2_key_##. (0x10 bytes)
ticket_commonkey_source               : Used with master_key_## to derive ticket_commonkey_##. (0x10 bytes)
nca_header_kek_source                 : Used with master_key_00, aes_kek_generation_source and aes_key_generation_source to generate nca_header_kek.  (0x10 bytes)
nca_header_key_source                 : Used with nca_header_kek to generate nca_header_key.  (0x20 bytes)
nca_key_area_key_application_source   : Used with master_key_##, aes_kek_generation_source and aes_key_generation_source to generate nca_key_area_key_application_##. (0x10 bytes)
nca_key_area_key_ocean_source         : Used with master_key_##, aes_kek_generation_source and aes_key_generation_source to generate nca_key_area_key_ocean_##. (0x10 bytes)
nca_key_area_key_system_source        : Used with master_key_##, aes_kek_generation_source and aes_key_generation_source to generate nca_key_area_key_system_##. (0x10 bytes)

; Package1 keys
package1_key_##                       : AES128 Key (0x10 bytes)

; Package2 Keys 
package2_key_##                       : AES128 Key (0x10 bytes)
package2_sign_key_modulus             : RSA2048 Modulus (0x100 bytes)
package2_sign_key_private             : RSA2048 Private Exponent (0x100 bytes)

; Ticket Keys
ticket_commonkey_##                   : AES128 Key (0x10 bytes)

; PKI Root Signing Key
pki_root_sign_key_modulus             : RSA4096 Modulus (0x200 bytes)
pki_root_sign_key_private             : RSA4096 Private Exponent (0x200 bytes)

; NCA Keys
nca_header_key                        : AES128-XTS Key (0x20 bytes)
nca_header_sign_key_##_modulus        : RSA2048 Modulus (0x100 bytes)
nca_header_sign_key_##_private        : RSA2048 Private Exponent (0x100 bytes)
nca_key_area_key_application_##       : AES128 Key (0x10 bytes)
nca_key_area_key_ocean_##             : AES128 Key (0x10 bytes)
nca_key_area_key_system_##            : AES128 Key (0x10 bytes)
nca_key_area_key_hw_application_##    : AES128 Key (0x10 bytes)
nca_key_area_key_hw_ocean_##          : AES128 Key (0x10 bytes)
nca_key_area_key_hw_system_##         : AES128 Key (0x10 bytes)

; NRR Keys
nrr_certificate_sign_key_##_modulus   : RSA2048 Modulus (0x100 bytes)
nrr_certificate_sign_key_##_private   : RSA2048 Private Exponent (0x100 bytes)

; XCI Keys
xci_header_key_##                     : AES128 Key (0x10 bytes)
xci_header_sign_key_modulus           : RSA2048 Modulus (0x100 bytes)
xci_header_sign_key_private           : RSA2048 Private Exponent (0x100 bytes)
xci_initial_data_kek_##               : AES128 Key (0x10 bytes)
xci_cert_sign_key_modulus             : RSA2048 Modulus (0x100 bytes)
xci_cert_sign_key_private             : RSA2048 Private Exponent (0x100 bytes)

; ACID Keys
acid_sign_key_##_modulus              : RSA2048 Modulus (0x100 bytes)
acid_sign_key_##_private              : RSA2048 Private Exponent (0x100 bytes)
```

## Legacy Keynames
Since firmware `9.0.0+` support for signature key generations was retroactively added for RSA-PSS signatures in NRR, ACID and NCA. The old names for these keys are still valid:
```
nca_header_sign_key_modulus      : alias for nca_header_sign_key_00_modulus
nca_header_sign_key_private      : alias for nca_header_sign_key_00_private
acid_sign_key_modulus            : alias for acid_sign_key_00_modulus
acid_sign_key_private            : alias for acid_sign_key_00_private
```

## Compatibility with hactool keyset files
`prod.keys` (and `dev.keys`) keyset files share the same keyset file format as [hactool](https://github.com/SciresM/hactool/blob/master/KEYS.md), but names of keys may differ. For compatibility, hactool names for equivalent keys are accepted.
```
titlekek_source                  : hactool alias for ticket_commonkey_source
header_key_source                : hactool alias for nca_header_key_source
header_kek_source                : hactool alias for nca_header_kek_source
key_area_key_application_source  : hactool alias for nca_key_area_key_application_source
key_area_key_ocean_source        : hactool alias for nca_key_area_key_ocean_source
key_area_key_system_source       : hactool alias for nca_key_area_key_system_source 
titlekek_##                      : hactool alias for ticket_commonkey_##
header_key                       : hactool alias for nca_header_key
key_area_key_application_##      : hactool alias for nca_key_area_key_application_##
key_area_key_ocean_##            : hactool alias for nca_key_area_key_ocean_##
key_area_key_system_##           : hactool alias for nca_key_area_key_system_##
```

## Encrypted File Types
See below for advice on what keys are required to decrypt certain file types.

### NX GameCard Image
The `GameCard ExtendedHeader` is encrypted with one of 8 keys, specified by the `KekIndex` in the `GameCard Header`.
It isn't required to extract game data, it just contains metadata.

Only two keys are currently defined:
| KeyIndex    | Name            | Description |
| ----------- | --------------- | ----------- |
| 00          | Production      | Usually selected for prod images. Some dev images use this key index. |
| 01          | Development     | Usually selected for dev images. This was changed from key index 00 at some point. |

Define the header key(s) in `prod.keys`/`dev.keys` (Prod and dev share the same keydata):
```
xci_header_key_00 = <32 char AES128 key here>
xci_header_key_01 = <32 char AES128 key here>
```

### Nintendo Content Archive
Nintendo Content Archive (NCA) files have both an encrypted header and content. The encrypted header determines the layout/format/encryption method of the content, which contains the game data.

Define the header key in `prod.keys`/`dev.keys`.
```
nca_header_key = <64 char AES128-XTS key-data here>
```
Or allow NSTool to derive it from key sources:
```
master_key_00             = <32 char AES128 key-data here>
aes_kek_generation_source = <32 char AES128 key-data here>
aes_key_generation_source = <32 char AES128 key-data here>
nca_header_kek_source     = <32 char AES128 key-data here>
nca_header_key_source     = <64 char AES128 key-data here>
```

In order to read the NCA content, the content key must be determined. Unlike the header key which is fixed, each NCA will have a unique content key.

Content keys are either:
1) "Internal", where they are encrypted the NCA Header KeyArea
2) "External", where they are encrypted in an external Ticket file (.tik) (external content keys are sometimes called title keys)

#### Internal Content Key
Decrypting the content key from the NCA Header Key Area requires the appropriate `nca_key_area_key` to be defined in `prod.keys`/`dev.keys`.
However for security reasons Nintendo revises this key periodically, and within each key revision there are 3 separate keys for different categories of applications.

It's best to define as many of these as possible, to reduce the number of times you need to edit the keyfiles.

So for a given key revision these key area keys can be defined explicitly (`##` represents the key revision in hexadecimal):
```
nca_key_area_key_application_## = <32 char AES128 key-data here>
nca_key_area_key_ocean_##       = <32 char AES128 key-data here>
nca_key_area_key_system_##      = <32 char AES128 key-data here>
```
Or allow NSTool to derive them from key sources: (`##` represents the key revision in hexadecimal):
```
master_key_##                       = <32 char AES128 key-data here>
aes_kek_generation_source           = <32 char AES128 key-data here>
aes_key_generation_source           = <32 char AES128 key-data here>
nca_key_area_key_application_source = <32 char AES128 key-data here>
nca_key_area_key_ocean_source       = <32 char AES128 key-data here>
nca_key_area_key_system_source      = <32 char AES128 key-data here>
```

#### External Content Key
For NCAs that use an external content key, the user must supplied the key to NSTool.

Most NCAs that use an external content key will be bundled with a ticket file (*.tik) that contains the content key in an encrypted form.

The ticket can be supplied by the user using the `--tik` option:
```
nstool --tik <32 char rightsid>.tik <32 char contentid>.nca
```
This however requires the the appropriate commonkey to be defined in `prod.keys`/`dev.keys` to decrypt the content key in the ticket. However for security reasons Nintendo revises this key periodically. 

It's best to define as many of these as possible, to reduce the number of times you need to edit the keyfiles.

So for a given key revision the common key can be defined explicitly (`##` represents the key revision in hexadecimal):
```
ticket_commonkey_## = <32 char AES128 key-data here>
```
Or allow NSTool to derive them from key sources: (`##` represents the key revision in hexadecimal):
```
master_key_##           = <32 char AES128 key-data here>
ticket_commonkey_source = <32 char AES128 key-data here>
```

##### Supply the external content key directly to NSTool
Alternatively you can supply the raw encrypted content key (also called a title key) directly with the `--titlekey` option:
```
nstool --titlekey <32 char AES128 key-data here> <32 char contentid>.nca
```

It is also possible to supply the decrypted content key directly with the `--contentkey` option:
```
nstool --contentkey <32 char AES128 key-data here> <32 char contentid>.nca
```

##### Scene Tickets
Please note that "Scene" tickets have been known to have errors. If you have issues using the `--tik` option, try passing the raw encrypted titlekey directly with the `--titlekey` option. The titlekey can be found by reading the ticket with NSTool:
```
nstool <32 char rightsid>.tik
```

##### Personalised Tickets
If the ticket is personalised (encrypted with console unique RSA key), NSTool will not support it. You will need to use extract the title key with another tool and pass the encrypted title key directly with the `--titlekey` option.

# Title
```

`build/visualstudio/nstool.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32616.157
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nstool", "nstool\nstool.vcxproj", "{775EF5EB-CA49-4994-8AC4-47B4A5385266}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "deps", "deps", "{05929EAE-4471-4E8E-A6F3-793A81623D7F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "liblz4", "..\..\deps\liblz4\build\visualstudio\liblz4\liblz4.vcxproj", "{E741ADED-7900-4E07-8DB0-D008C336C3FB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libmbedtls", "..\..\deps\libmbedtls\build\visualstudio\libmbedtls\libmbedtls.vcxproj", "{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libtoolchain", "..\..\deps\libtoolchain\build\visualstudio\libtoolchain\libtoolchain.vcxproj", "{E194E4B8-1482-40A2-901B-75D4387822E9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libfmt", "..\..\deps\libfmt\build\visualstudio\libfmt\libfmt.vcxproj", "{F4B0540E-0AAE-4006-944B-356944EF61FA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libpietendo", "..\..\deps\libpietendo\build\visualstudio\libpietendo\libpietendo.vcxproj", "{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{775EF5EB-CA49-4994-8AC4-47B4A5385266}.Debug|x64.ActiveCfg = Debug|x64
		{775EF5EB-CA49-4994-8AC4-47B4A5385266}.Debug|x64.Build.0 = Debug|x64
		{775EF5EB-CA49-4994-8AC4-47B4A5385266}.Debug|x86.ActiveCfg = Debug|Win32
		{775EF5EB-CA49-4994-8AC4-47B4A5385266}.Debug|x86.Build.0 = Debug|Win32
		{775EF5EB-CA49-4994-8AC4-47B4A5385266}.Release|x64.ActiveCfg = Release|x64
		{775EF5EB-CA49-4994-8AC4-47B4A5385266}.Release|x64.Build.0 = Release|x64
		{775EF5EB-CA49-4994-8AC4-47B4A5385266}.Release|x86.ActiveCfg = Release|Win32
		{775EF5EB-CA49-4994-8AC4-47B4A5385266}.Release|x86.Build.0 = Release|Win32
		{E741ADED-7900-4E07-8DB0-D008C336C3FB}.Debug|x64.ActiveCfg = Debug|x64
		{E741ADED-7900-4E07-8DB0-D008C336C3FB}.Debug|x64.Build.0 = Debug|x64
		{E741ADED-7900-4E07-8DB0-D008C336C3FB}.Debug|x86.ActiveCfg = Debug|Win32
		{E741ADED-7900-4E07-8DB0-D008C336C3FB}.Debug|x86.Build.0 = Debug|Win32
		{E741ADED-7900-4E07-8DB0-D008C336C3FB}.Release|x64.ActiveCfg = Release|x64
		{E741ADED-7900-4E07-8DB0-D008C336C3FB}.Release|x64.Build.0 = Release|x64
		{E741ADED-7900-4E07-8DB0-D008C336C3FB}.Release|x86.ActiveCfg = Release|Win32
		{E741ADED-7900-4E07-8DB0-D008C336C3FB}.Release|x86.Build.0 = Release|Win32
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}.Debug|x64.ActiveCfg = Debug|x64
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}.Debug|x64.Build.0 = Debug|x64
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}.Debug|x86.ActiveCfg = Debug|Win32
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}.Debug|x86.Build.0 = Debug|Win32
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}.Release|x64.ActiveCfg = Release|x64
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}.Release|x64.Build.0 = Release|x64
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}.Release|x86.ActiveCfg = Release|Win32
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C}.Release|x86.Build.0 = Release|Win32
		{E194E4B8-1482-40A2-901B-75D4387822E9}.Debug|x64.ActiveCfg = Debug|x64
		{E194E4B8-1482-40A2-901B-75D4387822E9}.Debug|x64.Build.0 = Debug|x64
		{E194E4B8-1482-40A2-901B-75D4387822E9}.Debug|x86.ActiveCfg = Debug|Win32
		{E194E4B8-1482-40A2-901B-75D4387822E9}.Debug|x86.Build.0 = Debug|Win32
		{E194E4B8-1482-40A2-901B-75D4387822E9}.Release|x64.ActiveCfg = Release|x64
		{E194E4B8-1482-40A2-901B-75D4387822E9}.Release|x64.Build.0 = Release|x64
		{E194E4B8-1482-40A2-901B-75D4387822E9}.Release|x86.ActiveCfg = Release|Win32
		{E194E4B8-1482-40A2-901B-75D4387822E9}.Release|x86.Build.0 = Release|Win32
		{F4B0540E-0AAE-4006-944B-356944EF61FA}.Debug|x64.ActiveCfg = Debug|x64
		{F4B0540E-0AAE-4006-944B-356944EF61FA}.Debug|x64.Build.0 = Debug|x64
		{F4B0540E-0AAE-4006-944B-356944EF61FA}.Debug|x86.ActiveCfg = Debug|Win32
		{F4B0540E-0AAE-4006-944B-356944EF61FA}.Debug|x86.Build.0 = Debug|Win32
		{F4B0540E-0AAE-4006-944B-356944EF61FA}.Release|x64.ActiveCfg = Release|x64
		{F4B0540E-0AAE-4006-944B-356944EF61FA}.Release|x64.Build.0 = Release|x64
		{F4B0540E-0AAE-4006-944B-356944EF61FA}.Release|x86.ActiveCfg = Release|Win32
		{F4B0540E-0AAE-4006-944B-356944EF61FA}.Release|x86.Build.0 = Release|Win32
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}.Debug|x64.ActiveCfg = Debug|x64
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}.Debug|x64.Build.0 = Debug|x64
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}.Debug|x86.ActiveCfg = Debug|Win32
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}.Debug|x86.Build.0 = Debug|Win32
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}.Release|x64.ActiveCfg = Release|x64
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}.Release|x64.Build.0 = Release|x64
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}.Release|x86.ActiveCfg = Release|Win32
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{E741ADED-7900-4E07-8DB0-D008C336C3FB} = {05929EAE-4471-4E8E-A6F3-793A81623D7F}
		{7A7C66F3-2B5B-4E23-85D8-2A74FEDAD92C} = {05929EAE-4471-4E8E-A6F3-793A81623D7F}
		{E194E4B8-1482-40A2-901B-75D4387822E9} = {05929EAE-4471-4E8E-A6F3-793A81623D7F}
		{F4B0540E-0AAE-4006-944B-356944EF61FA} = {05929EAE-4471-4E8E-A6F3-793A81623D7F}
		{5ADDD009-9D25-40BE-B2A6-2F3AB4DCBBD2} = {05929EAE-4471-4E8E-A6F3-793A81623D7F}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {ABDCFB40-D6B3-44A9-92B5-0D7AB38D9FB8}
	EndGlobalSection
EndGlobal

```

`build/visualstudio/nstool/nstool.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{775EF5EB-CA49-4994-8AC4-47B4A5385266}</ProjectGuid>
    <RootNamespace>nstool</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)..\..\..\include;$(SolutionDir)..\..\deps\liblz4\include;$(SolutionDir)..\..\deps\libtoolchain\include;$(SolutionDir)..\..\deps\libfmt\include;$(SolutionDir)..\..\deps\libpietendo\include</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)..\..\..\include;$(SolutionDir)..\..\deps\liblz4\include;$(SolutionDir)..\..\deps\libtoolchain\include;$(SolutionDir)..\..\deps\libfmt\include;$(SolutionDir)..\..\deps\libpietendo\include</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)..\..\..\include;$(SolutionDir)..\..\deps\liblz4\include;$(SolutionDir)..\..\deps\libtoolchain\include;$(SolutionDir)..\..\deps\libfmt\include;$(SolutionDir)..\..\deps\libpietendo\include</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)..\..\..\include;$(SolutionDir)..\..\deps\liblz4\include;$(SolutionDir)..\..\deps\libtoolchain\include;$(SolutionDir)..\..\deps\libfmt\include;$(SolutionDir)..\..\deps\libpietendo\include</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectReference Include="$(SolutionDir)..\..\deps\libfmt\build\visualstudio\libfmt\libfmt.vcxproj">
      <Project>{f4b0540e-0aae-4006-944b-356944ef61fa}</Project>
    </ProjectReference>
    <ProjectReference Include="$(SolutionDir)..\..\deps\liblz4\build\visualstudio\liblz4\liblz4.vcxproj">
      <Project>{e741aded-7900-4e07-8db0-d008c336c3fb}</Project>
    </ProjectReference>
    <ProjectReference Include="$(SolutionDir)..\..\deps\libmbedtls\build\visualstudio\libmbedtls\libmbedtls.vcxproj">
      <Project>{7a7c66f3-2b5b-4e23-85d8-2a74fedad92c}</Project>
    </ProjectReference>
    <ProjectReference Include="$(SolutionDir)..\..\deps\libtoolchain\build\visualstudio\libtoolchain\libtoolchain.vcxproj">
      <Project>{e194e4b8-1482-40a2-901b-75d4387822e9}</Project>
    </ProjectReference>
    <ProjectReference Include="$(SolutionDir)..\..\deps\libpietendo\build\visualstudio\libpietendo\libpietendo.vcxproj">
      <Project>{5addd009-9d25-40be-b2a6-2f3ab4dcbbd2}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\src\AssetProcess.h" />
    <ClInclude Include="..\..\..\src\CnmtProcess.h" />
    <ClInclude Include="..\..\..\src\elf.h" />
    <ClInclude Include="..\..\..\src\ElfSymbolParser.h" />
    <ClInclude Include="..\..\..\src\EsCertProcess.h" />
    <ClInclude Include="..\..\..\src\EsTikProcess.h" />
    <ClInclude Include="..\..\..\src\FsProcess.h" />
    <ClInclude Include="..\..\..\src\GameCardProcess.h" />
    <ClInclude Include="..\..\..\src\IniProcess.h" />
    <ClInclude Include="..\..\..\src\KeyBag.h" />
    <ClInclude Include="..\..\..\src\KipProcess.h" />
    <ClInclude Include="..\..\..\src\MetaProcess.h" />
    <ClInclude Include="..\..\..\src\NacpProcess.h" />
    <ClInclude Include="..\..\..\src\NcaProcess.h" />
    <ClInclude Include="..\..\..\src\NroProcess.h" />
    <ClInclude Include="..\..\..\src\NsoProcess.h" />
    <ClInclude Include="..\..\..\src\PfsProcess.h" />
    <ClInclude Include="..\..\..\src\PkiValidator.h" />
    <ClInclude Include="..\..\..\src\RoMetadataProcess.h" />
    <ClInclude Include="..\..\..\src\RomfsProcess.h" />
    <ClInclude Include="..\..\..\src\SdkApiString.h" />
    <ClInclude Include="..\..\..\src\Settings.h" />
    <ClInclude Include="..\..\..\src\types.h" />
    <ClInclude Include="..\..\..\src\util.h" />
    <ClInclude Include="..\..\..\src\version.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\src\AssetProcess.cpp" />
    <ClCompile Include="..\..\..\src\CnmtProcess.cpp" />
    <ClCompile Include="..\..\..\src\ElfSymbolParser.cpp" />
    <ClCompile Include="..\..\..\src\EsCertProcess.cpp" />
    <ClCompile Include="..\..\..\src\EsTikProcess.cpp" />
    <ClCompile Include="..\..\..\src\FsProcess.cpp" />
    <ClCompile Include="..\..\..\src\GameCardProcess.cpp" />
    <ClCompile Include="..\..\..\src\IniProcess.cpp" />
    <ClCompile Include="..\..\..\src\KeyBag.cpp" />
    <ClCompile Include="..\..\..\src\KipProcess.cpp" />
    <ClCompile Include="..\..\..\src\main.cpp" />
    <ClCompile Include="..\..\..\src\MetaProcess.cpp" />
    <ClCompile Include="..\..\..\src\NacpProcess.cpp" />
    <ClCompile Include="..\..\..\src\NcaProcess.cpp" />
    <ClCompile Include="..\..\..\src\NroProcess.cpp" />
    <ClCompile Include="..\..\..\src\NsoProcess.cpp" />
    <ClCompile Include="..\..\..\src\PfsProcess.cpp" />
    <ClCompile Include="..\..\..\src\PkiValidator.cpp" />
    <ClCompile Include="..\..\..\src\RoMetadataProcess.cpp" />
    <ClCompile Include="..\..\..\src\RomfsProcess.cpp" />
    <ClCompile Include="..\..\..\src\SdkApiString.cpp" />
    <ClCompile Include="..\..\..\src\Settings.cpp" />
    <ClCompile Include="..\..\..\src\util.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`build/visualstudio/nstool/nstool.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\src\AssetProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\CnmtProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\elf.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\ElfSymbolParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\EsCertProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\EsTikProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\FsProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\GameCardProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\IniProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\KeyBag.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\KipProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\MetaProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\NacpProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\NcaProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\NroProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\NsoProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\PfsProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\PkiValidator.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\RoMetadataProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\RomfsProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\SdkApiString.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\Settings.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\version.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\src\AssetProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\CnmtProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\ElfSymbolParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\EsCertProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\EsTikProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\FsProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\GameCardProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\IniProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\KeyBag.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\KipProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\MetaProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\NacpProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\NcaProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\NsoProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\NroProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\PfsProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\PkiValidator.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\RoMetadataProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\RomfsProcess.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\SdkApiString.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\Settings.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`makefile`:

```
# C++/C Recursive Project Makefile 
# (c) Jack
# Version 8 (20220420)

# Project Name
PROJECT_NAME = nstool

# Project Relative Paths
PROJECT_PATH = $(CURDIR)
PROJECT_SRC_PATH = src
PROJECT_SRC_SUBDIRS = $(PROJECT_SRC_PATH)
#PROJECT_INCLUDE_PATH = include
#PROJECT_TESTSRC_PATH = test
#PROJECT_TESTSRC_SUBDIRS = $(PROJECT_TESTSRC_PATH)
PROJECT_BIN_PATH = bin
#PROJECT_DOCS_PATH = docs
#PROJECT_DOXYFILE_PATH = Doxyfile

# Determine if the root makefile has been established, and if not establish this makefile as the root makefile
ifeq ($(ROOT_PROJECT_NAME),)
	export ROOT_PROJECT_NAME = $(PROJECT_NAME)
	export ROOT_PROJECT_PATH = $(PROJECT_PATH)
	export ROOT_PROJECT_DEPENDENCY_PATH = $(ROOT_PROJECT_PATH)/deps
endif

# Project Dependencies
PROJECT_DEPEND = pietendo toolchain fmt lz4 mbedtls
PROJECT_DEPEND_LOCAL_DIR = libpietendo libtoolchain libfmt liblz4 libmbedtls

# Generate compiler flags for including project include path
ifneq ($(PROJECT_INCLUDE_PATH),)
	INC += -I"$(PROJECT_INCLUDE_PATH)"
endif

# Generate compiler flags for local included dependencies
ifneq ($(PROJECT_DEPEND_LOCAL_DIR),)
	LIB += $(foreach dep,$(PROJECT_DEPEND_LOCAL_DIR), -L"$(ROOT_PROJECT_DEPENDENCY_PATH)/$(dep)/bin")
	INC += $(foreach dep,$(PROJECT_DEPEND_LOCAL_DIR), -I"$(ROOT_PROJECT_DEPENDENCY_PATH)/$(dep)/include")
endif

# Generate compiler flags for external dependencies
ifneq ($(PROJECT_DEPEND),)
	LIB += $(foreach dep,$(PROJECT_DEPEND), -l$(dep))
endif

# Detect Platform
ifeq ($(PROJECT_PLATFORM),)
	ifeq ($(OS), Windows_NT)
		export PROJECT_PLATFORM = WIN32
	else
		UNAME = $(shell uname -s)
		ifeq ($(UNAME), Darwin)
			export PROJECT_PLATFORM = MACOS
		else
			export PROJECT_PLATFORM = GNU
		endif
	endif
endif

# Detect Architecture
ifeq ($(PROJECT_PLATFORM_ARCH),)
	ifeq ($(PROJECT_PLATFORM), WIN32)
		export PROJECT_PLATFORM_ARCH = x86_64
	else ifeq ($(PROJECT_PLATFORM), GNU)
		export PROJECT_PLATFORM_ARCH = $(shell uname -m)
	else ifeq ($(PROJECT_PLATFORM), MACOS)
		export PROJECT_PLATFORM_ARCH = $(shell uname -m)
	else
		export PROJECT_PLATFORM_ARCH = x86_64
	endif
endif

# Generate platform specific compiler flags
ifeq ($(PROJECT_PLATFORM), WIN32)
	# Windows Flags/Libs
	CC = x86_64-w64-mingw32-gcc
	CXX = x86_64-w64-mingw32-g++
	DEFINEFLAGS =
	WARNFLAGS = -Wall -Wno-unused-value -Wno-unused-but-set-variable
	ARCHFLAGS =
	INC +=
	LIB += -static
	ARFLAGS = cr -o
else ifeq ($(PROJECT_PLATFORM), GNU)
	# GNU/Linux Flags/Libs
	#CC = 
	#CXX =
	DEFINEFLAGS =
	WARNFLAGS = -Wall -Wno-unused-value -Wno-unused-but-set-variable
	ARCHFLAGS =
	INC +=
	LIB +=
	ARFLAGS = cr -o
else ifeq ($(PROJECT_PLATFORM), MACOS)
	# MacOS Flags/Libs
	#CC = 
	#CXX =
	DEFINEFLAGS =
	WARNFLAGS = -Wall -Wno-unused-value -Wno-unused-private-field
	ARCHFLAGS = -arch $(PROJECT_PLATFORM_ARCH)
	INC +=
	LIB +=
	ARFLAGS = rc
endif

# Compiler Flags
CXXFLAGS = -std=c++11 $(INC) $(DEFINEFLAGS) $(WARNFLAGS) $(ARCHFLAGS) -fPIC
CFLAGS = -std=c11 $(INC) $(DEFINEFLAGS) $(WARNFLAGS) $(ARCHFLAGS) -fPIC

# Object Files
SRC_OBJ = $(foreach dir,$(PROJECT_SRC_SUBDIRS),$(subst .cpp,.o,$(wildcard $(dir)/*.cpp))) $(foreach dir,$(PROJECT_SRC_SUBDIRS),$(subst .cc,.o,$(wildcard $(dir)/*.cc))) $(foreach dir,$(PROJECT_SRC_SUBDIRS),$(subst .c,.o,$(wildcard $(dir)/*.c)))
TESTSRC_OBJ = $(foreach dir,$(PROJECT_TESTSRC_SUBDIRS),$(subst .cpp,.o,$(wildcard $(dir)/*.cpp))) $(foreach dir,$(PROJECT_TESTSRC_SUBDIRS),$(subst .cc,.o,$(wildcard $(dir)/*.cc))) $(foreach dir,$(PROJECT_TESTSRC_SUBDIRS),$(subst .c,.o,$(wildcard $(dir)/*.c)))

# all is the default, user should specify what the default should do
#	- 'static_lib' for building source as a static library
#	- 'program' for building source as executable program
#	- 'test_program' for building the test program
# test_program can be used with program or static_lib, but program and static_lib cannot be used together
all: program
	
clean: clean_object_files remove_binary_dir

# Object Compile Rules
%.o: %.c
	@echo CC $<
	@$(CC) $(CFLAGS) -c $< -o $@ 

%.o: %.cpp
	@echo CXX $<
	@$(CXX) $(CXXFLAGS) -c $< -o $@ 

%.o: %.cc
	@echo CXX $<
	@$(CXX) $(CXXFLAGS) -c $< -o $@ 

# Binary Directory
.PHONY: create_binary_dir
create_binary_dir:
	@mkdir -p "$(PROJECT_BIN_PATH)"

.PHONY: remove_binary_dir
remove_binary_dir:
ifneq ($(PROJECT_BIN_PATH),)
	@rm -rf "$(PROJECT_BIN_PATH)"
endif

.PHONY: clean_object_files
clean_object_files:
	@rm -f $(SRC_OBJ) $(TESTSRC_OBJ)

# Build Library
static_lib: $(SRC_OBJ) create_binary_dir
	@echo LINK $(PROJECT_BIN_PATH)/$(PROJECT_NAME).a
	@ar $(ARFLAGS) "$(PROJECT_BIN_PATH)/$(PROJECT_NAME).a" $(SRC_OBJ)

# Build Program
program: $(SRC_OBJ) create_binary_dir
	@echo LINK $(PROJECT_BIN_PATH)/$(PROJECT_NAME)
	@$(CXX) $(ARCHFLAGS) $(SRC_OBJ) $(LIB) -o "$(PROJECT_BIN_PATH)/$(PROJECT_NAME)"

# Build Test Program
test_program: $(TESTSRC_OBJ) $(SRC_OBJ) create_binary_dir
ifneq ($(PROJECT_TESTSRC_PATH),)
	@echo LINK $(PROJECT_BIN_PATH)/$(PROJECT_NAME)_test
	@$(CXX) $(ARCHFLAGS) $(TESTSRC_OBJ) $(SRC_OBJ) $(LIB) -o "$(PROJECT_BIN_PATH)/$(PROJECT_NAME)_test"
endif

# Documentation
.PHONY: docs
docs:
ifneq ($(PROJECT_DOCS_PATH),)
	doxygen "$(PROJECT_DOXYFILE_PATH)"
endif

.PHONY: clean_docs
clean_docs:
ifneq ($(PROJECT_DOCS_PATH),)
	@rm -rf "$(PROJECT_DOCS_PATH)"
endif

# Dependencies
.PHONY: deps
deps:
	@$(foreach lib,$(PROJECT_DEPEND_LOCAL_DIR), cd "$(ROOT_PROJECT_DEPENDENCY_PATH)/$(lib)" && $(MAKE) static_lib && cd "$(PROJECT_PATH)";)

.PHONY: clean_deps
clean_deps:
	@$(foreach lib,$(PROJECT_DEPEND_LOCAL_DIR), cd "$(ROOT_PROJECT_DEPENDENCY_PATH)/$(lib)" && $(MAKE) clean && cd "$(PROJECT_PATH)";)
```

`src/AssetProcess.cpp`:

```cpp
#include "AssetProcess.h"

#include "util.h"

nstool::AssetProcess::AssetProcess() :
	mModuleName("nstool::AssetProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false)
{
}    

void nstool::AssetProcess::process()
{
	importHeader();
	if (mCliOutputMode.show_basic_info)
		displayHeader();
	processSections();
}     

void nstool::AssetProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::AssetProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::AssetProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::AssetProcess::setIconExtractPath(const tc::io::Path& path)
{
	mIconExtractPath = path;
}

void nstool::AssetProcess::setNacpExtractPath(const tc::io::Path& path)
{
	mNacpExtractPath = path;
}

void nstool::AssetProcess::setRomfsShowFsTree(bool show_fs_tree)
{
	mRomfs.setShowFsTree(show_fs_tree);
}

void nstool::AssetProcess::setRomfsExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs)
{
	mRomfs.setExtractJobs(extract_jobs);
}

void nstool::AssetProcess::importHeader()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	if (mFile->length() < tc::io::IOUtil::castSizeToInt64(sizeof(pie::hac::sAssetHeader)))
	{
		throw tc::Exception(mModuleName, "Corrupt ASET: file too small");
	}

	tc::ByteData scratch = tc::ByteData(sizeof(pie::hac::sAssetHeader));
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	mHdr.fromBytes(scratch.data(), scratch.size());
}

void nstool::AssetProcess::processSections()
{
	int64_t file_size = mFile->length();

	if (mHdr.getIconInfo().size > 0 && mIconExtractPath.isSet())
	{
		if ((mHdr.getIconInfo().size + mHdr.getIconInfo().offset) > file_size) 
			throw tc::Exception(mModuleName, "ASET geometry for icon beyond file size");

		fmt::print("Saving {:s}...", mIconExtractPath.get().to_string());
		writeSubStreamToFile(mFile, mHdr.getIconInfo().offset, mHdr.getIconInfo().size, mIconExtractPath.get());
	}

	if (mHdr.getNacpInfo().size > 0)
	{
		if ((mHdr.getNacpInfo().size + mHdr.getNacpInfo().offset) > file_size) 
			throw tc::Exception(mModuleName, "ASET geometry for nacp beyond file size");

		if (mNacpExtractPath.isSet())
		{
			fmt::print("Saving {:s}...", mNacpExtractPath.get().to_string());
			writeSubStreamToFile(mFile, mHdr.getNacpInfo().offset, mHdr.getNacpInfo().size, mNacpExtractPath.get());
		}
		
		mNacp.setInputFile(std::make_shared<tc::io::SubStream>(mFile, mHdr.getNacpInfo().offset, mHdr.getNacpInfo().size));
		mNacp.setCliOutputMode(mCliOutputMode);
		mNacp.setVerifyMode(mVerify);

		mNacp.process();
	}

	if (mHdr.getRomfsInfo().size > 0)
	{
		if ((mHdr.getRomfsInfo().size + mHdr.getRomfsInfo().offset) > file_size) 
			throw tc::Exception(mModuleName, "ASET geometry for romfs beyond file size");

		mRomfs.setInputFile(std::make_shared<tc::io::SubStream>(mFile, mHdr.getRomfsInfo().offset, mHdr.getRomfsInfo().size));
		mRomfs.setCliOutputMode(mCliOutputMode);
		mRomfs.setVerifyMode(mVerify);

		mRomfs.process();
	}
}

void nstool::AssetProcess::displayHeader()
{
	if (mCliOutputMode.show_layout)
	{
		fmt::print("[ASET Header]\n");
		fmt::print("  Icon:\n");
		fmt::print("    Offset:       0x{:x}\n", mHdr.getIconInfo().offset);
		fmt::print("    Size:         0x{:x}\n", mHdr.getIconInfo().size);
		fmt::print("  NACP:\n");
		fmt::print("    Offset:       0x{:x}\n", mHdr.getNacpInfo().offset);
		fmt::print("    Size:         0x{:x}\n", mHdr.getNacpInfo().size);
		fmt::print("  RomFs:\n");
		fmt::print("    Offset:       0x{:x}\n", mHdr.getRomfsInfo().offset);
		fmt::print("    Size:         0x{:x}\n", mHdr.getRomfsInfo().size);
	}	
}
		

```

`src/AssetProcess.h`:

```h
#pragma once
#include "types.h"
#include "NacpProcess.h"
#include "RomfsProcess.h"

#include <pietendo/hac/AssetHeader.h>

namespace nstool {

class AssetProcess
{
public:
	AssetProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	void setIconExtractPath(const tc::io::Path& path);
	void setNacpExtractPath(const tc::io::Path& path);
	
	void setRomfsShowFsTree(bool show_fs_tree);
	void setRomfsExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs);
private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	tc::Optional<tc::io::Path> mIconExtractPath;
	tc::Optional<tc::io::Path> mNacpExtractPath;

	pie::hac::AssetHeader mHdr;
	NacpProcess mNacp;
	RomfsProcess mRomfs;

	void importHeader();
	void processSections();
	void displayHeader();
};

}
```

`src/CnmtProcess.cpp`:

```cpp
#include "CnmtProcess.h"

#include <pietendo/hac/ContentMetaUtil.h>

nstool::CnmtProcess::CnmtProcess() :
	mModuleName("nstool::CnmtProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false)
{
}

void nstool::CnmtProcess::process()
{
	importCnmt();

	if (mCliOutputMode.show_basic_info)
		displayCnmt();
}

void nstool::CnmtProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::CnmtProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::CnmtProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

const pie::hac::ContentMeta& nstool::CnmtProcess::getContentMeta() const
{
	return mCnmt;
}

void nstool::CnmtProcess::importCnmt()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}
	
	// check if file_size is greater than 20MB, don't import.
	size_t cnmt_file_size = tc::io::IOUtil::castInt64ToSize(mFile->length());
	if (cnmt_file_size > (0x100000 * 20))
	{
		throw tc::Exception(mModuleName, "File too large.");
	}

	// read cnmt
	tc::ByteData scratch = tc::ByteData(cnmt_file_size);
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	// parse cnmt
	mCnmt.fromBytes(scratch.data(), scratch.size());
}

void nstool::CnmtProcess::displayCnmt()
{
	const pie::hac::sContentMetaHeader* cnmt_hdr = (const pie::hac::sContentMetaHeader*)mCnmt.getBytes().data();
	fmt::print("[ContentMeta]\n");
	fmt::print("  TitleId:               0x{:016x}\n", mCnmt.getTitleId());
	fmt::print("  Version:               {:s} (v{:d})\n", pie::hac::ContentMetaUtil::getVersionAsString(mCnmt.getTitleVersion()), mCnmt.getTitleVersion());
	fmt::print("  Type:                  {:s} ({:d})\n", pie::hac::ContentMetaUtil::getContentMetaTypeAsString(mCnmt.getContentMetaType()), (uint32_t)mCnmt.getContentMetaType());
	fmt::print("  Attributes:            0x{:x}", *((byte_t*)&cnmt_hdr->attributes));
	if (mCnmt.getAttribute().size())
	{
		std::vector<std::string> attribute_list;

		for (auto itr = mCnmt.getAttribute().begin(); itr != mCnmt.getAttribute().end(); itr++)
		{
			attribute_list.push_back(pie::hac::ContentMetaUtil::getContentMetaAttributeFlagAsString(pie::hac::cnmt::ContentMetaAttributeFlag(*itr)));
		}

		fmt::print(" [");
		for (auto itr = attribute_list.begin(); itr != attribute_list.end(); itr++)
		{
			fmt::print("{:s}",*itr);
			if ((itr + 1) != attribute_list.end())
			{
				fmt::print(", ");
			}
		}
		fmt::print("]");
	}
	fmt::print("\n");

	fmt::print("  StorageId:             {:s} ({:d})\n", pie::hac::ContentMetaUtil::getStorageIdAsString(mCnmt.getStorageId()), (uint32_t)mCnmt.getStorageId());
	fmt::print("  ContentInstallType:    {:s} ({:d})\n", pie::hac::ContentMetaUtil::getContentInstallTypeAsString(mCnmt.getContentInstallType()),(uint32_t)mCnmt.getContentInstallType());
	fmt::print("  RequiredDownloadSystemVersion: {:s} (v{:d})\n", pie::hac::ContentMetaUtil::getVersionAsString(mCnmt.getRequiredDownloadSystemVersion()), mCnmt.getRequiredDownloadSystemVersion());
	switch(mCnmt.getContentMetaType())
	{
		case (pie::hac::cnmt::ContentMetaType_Application):
			fmt::print("  ApplicationExtendedHeader:\n");
			fmt::print("    RequiredApplicationVersion: {:s} (v{:d})\n", pie::hac::ContentMetaUtil::getVersionAsString(mCnmt.getApplicationMetaExtendedHeader().getRequiredApplicationVersion()), mCnmt.getApplicationMetaExtendedHeader().getRequiredApplicationVersion());
			fmt::print("    RequiredSystemVersion:      {:s} (v{:d})\n", pie::hac::ContentMetaUtil::getVersionAsString(mCnmt.getApplicationMetaExtendedHeader().getRequiredSystemVersion()), mCnmt.getApplicationMetaExtendedHeader().getRequiredSystemVersion());
			fmt::print("    PatchId:                    0x{:016x}\n", mCnmt.getApplicationMetaExtendedHeader().getPatchId());
			break;
		case (pie::hac::cnmt::ContentMetaType_Patch):
			fmt::print("  PatchMetaExtendedHeader:\n");
			fmt::print("    RequiredSystemVersion: {:s} (v{:d})\n", pie::hac::ContentMetaUtil::getVersionAsString(mCnmt.getPatchMetaExtendedHeader().getRequiredSystemVersion()), mCnmt.getPatchMetaExtendedHeader().getRequiredSystemVersion());
			fmt::print("    ApplicationId:         0x{:016x}\n", mCnmt.getPatchMetaExtendedHeader().getApplicationId());
			break;
		case (pie::hac::cnmt::ContentMetaType_AddOnContent):
			fmt::print("  AddOnContentMetaExtendedHeader:\n");
			fmt::print("    RequiredApplicationVersion: {:s} (v{:d})\n", pie::hac::ContentMetaUtil::getVersionAsString(mCnmt.getAddOnContentMetaExtendedHeader().getRequiredApplicationVersion()), mCnmt.getAddOnContentMetaExtendedHeader().getRequiredApplicationVersion());
			fmt::print("    ApplicationId:         0x{:016x}\n", mCnmt.getAddOnContentMetaExtendedHeader().getApplicationId());
			break;
		case (pie::hac::cnmt::ContentMetaType_Delta):
			fmt::print("  DeltaMetaExtendedHeader:\n");
			fmt::print("    ApplicationId:         0x{:016x}\n", mCnmt.getDeltaMetaExtendedHeader().getApplicationId());
			break;
		default:
			break;
	}
	if (mCnmt.getContentInfo().size() > 0)
	{
		fmt::print("  ContentInfo:\n");
		for (size_t i = 0; i < mCnmt.getContentInfo().size(); i++)
		{
			const pie::hac::ContentInfo& info = mCnmt.getContentInfo()[i];
			fmt::print("    {:d}\n", i);
			fmt::print("      Type:         {:s} ({:d})\n", pie::hac::ContentMetaUtil::getContentTypeAsString(info.getContentType()), (uint32_t)info.getContentType());
			fmt::print("      Id:           {:s}\n", tc::cli::FormatUtil::formatBytesAsString(info.getContentId().data(), info.getContentId().size(), false, ""));
			fmt::print("      Size:         0x{:x}\n", info.getContentSize());
			fmt::print("      Hash:         {:s}\n", tc::cli::FormatUtil::formatBytesAsString(info.getContentHash().data(), info.getContentHash().size(), false, ""));
		}
	}
	if (mCnmt.getContentMetaInfo().size() > 0)
	{
		fmt::print("  ContentMetaInfo:\n");
		displayContentMetaInfoList(mCnmt.getContentMetaInfo(), "    ");
	}

	// print extended data
	if (mCnmt.getContentMetaType() == pie::hac::cnmt::ContentMetaType_Patch && mCnmt.getPatchMetaExtendedHeader().getExtendedDataSize() != 0)
	{
		// this is stubbed as the raw output is for development purposes
		//fmt::print("  PatchMetaExtendedData:\n");
		//tc::cli::FormatUtil::formatBytesAsHxdHexString(mCnmt.getPatchMetaExtendedData().data(), mCnmt.getPatchMetaExtendedData().size());
	}
	else if (mCnmt.getContentMetaType() == pie::hac::cnmt::ContentMetaType_Delta && mCnmt.getDeltaMetaExtendedHeader().getExtendedDataSize() != 0)
	{
		// this is stubbed as the raw output is for development purposes
		//fmt::print("  DeltaMetaExtendedData:\n");
		//tc::cli::FormatUtil::formatBytesAsHxdHexString(mCnmt.getDeltaMetaExtendedData().data(), mCnmt.getDeltaMetaExtendedData().size());
	}
	else if (mCnmt.getContentMetaType() == pie::hac::cnmt::ContentMetaType_SystemUpdate && mCnmt.getSystemUpdateMetaExtendedHeader().getExtendedDataSize() != 0)
	{
		fmt::print("  SystemUpdateMetaExtendedData:\n");
		fmt::print("    FormatVersion:         {:d}\n", mCnmt.getSystemUpdateMetaExtendedData().getFormatVersion());
		fmt::print("    FirmwareVariation:\n");
		auto variation_info = mCnmt.getSystemUpdateMetaExtendedData().getFirmwareVariationInfo();
		for (size_t i = 0; i < mCnmt.getSystemUpdateMetaExtendedData().getFirmwareVariationInfo().size(); i++)
		{
			fmt::print("      {:d}\n", i);
			fmt::print("        FirmwareVariationId:  0x{:x}\n", variation_info[i].variation_id);
			if (mCnmt.getSystemUpdateMetaExtendedData().getFormatVersion() == 2)
			{
				fmt::print("        ReferToBase:          {}\n", variation_info[i].meta.empty());
				if (variation_info[i].meta.empty() == false)
				{
					fmt::print("        ContentMeta:\n");
					displayContentMetaInfoList(variation_info[i].meta, "          ");
				}
			}
		}
	}

	fmt::print("  Digest:   {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mCnmt.getDigest().data(), mCnmt.getDigest().size(), false, ""));
}

void nstool::CnmtProcess::displayContentMetaInfo(const pie::hac::ContentMetaInfo& content_meta_info, const std::string& prefix)
{
	const pie::hac::sContentMetaInfo* content_meta_info_raw = (const pie::hac::sContentMetaInfo*)content_meta_info.getBytes().data();
	fmt::print("{:s}Id:           0x{:016x}\n", prefix, content_meta_info.getTitleId());
	fmt::print("{:s}Version:      {:s} (v{:d})\n", prefix, pie::hac::ContentMetaUtil::getVersionAsString(content_meta_info.getTitleVersion()), content_meta_info.getTitleVersion());
	fmt::print("{:s}Type:         {:s} ({:d})\n", prefix, pie::hac::ContentMetaUtil::getContentMetaTypeAsString(content_meta_info.getContentMetaType()), (uint32_t)content_meta_info.getContentMetaType());
	fmt::print("{:s}Attributes:   0x{:x}", prefix, *((byte_t*)&content_meta_info_raw->attributes) );
	if (content_meta_info.getAttribute().size())
	{
		std::vector<std::string> attribute_list;

		for (auto itr = content_meta_info.getAttribute().begin(); itr != content_meta_info.getAttribute().end(); itr++)
		{
			attribute_list.push_back(pie::hac::ContentMetaUtil::getContentMetaAttributeFlagAsString(pie::hac::cnmt::ContentMetaAttributeFlag(*itr)));
		}

		fmt::print(" [");
		for (auto itr = attribute_list.begin(); itr != attribute_list.end(); itr++)
		{
			fmt::print("{:s}",*itr);
			if ((itr + 1) != attribute_list.end())
			{
				fmt::print(", ");
			}
		}
		fmt::print("]");
	}
	fmt::print("\n");
}

void nstool::CnmtProcess::displayContentMetaInfoList(const std::vector<pie::hac::ContentMetaInfo>& content_meta_info_list, const std::string& prefix)
{
	for (size_t i = 0; i < content_meta_info_list.size(); i++)
	{
		const pie::hac::ContentMetaInfo& info = mCnmt.getContentMetaInfo()[i];
		fmt::print("{:s}{:d}\n", i);
		displayContentMetaInfo(info, prefix + "  ");
	}
}
```

`src/CnmtProcess.h`:

```h
#pragma once
#include "types.h"

#include <pietendo/hac/ContentMeta.h>

namespace nstool {

class CnmtProcess
{
public:
	CnmtProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	const pie::hac::ContentMeta& getContentMeta() const;
private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	pie::hac::ContentMeta mCnmt;

	void importCnmt();
	void displayCnmt();

	void displayContentMetaInfo(const pie::hac::ContentMetaInfo& content_meta_info, const std::string& prefix);
	void displayContentMetaInfoList(const std::vector<pie::hac::ContentMetaInfo>& content_meta_info_list, const std::string& prefix);
};

}
```

`src/ElfSymbolParser.cpp`:

```cpp
#include "ElfSymbolParser.h"

nstool::ElfSymbolParser::ElfSymbolParser() :
	mModuleName("nstool::ElfSymbolParser"),
	mSymbolList()
{
}

void nstool::ElfSymbolParser::operator=(const ElfSymbolParser& other)
{
	mSymbolList = other.mSymbolList;
}

bool nstool::ElfSymbolParser::operator==(const ElfSymbolParser& other) const
{
	return mSymbolList == other.mSymbolList;
}

bool nstool::ElfSymbolParser::operator!=(const ElfSymbolParser& other) const
{
	return !(*this == other);
}

void nstool::ElfSymbolParser::parseData(const byte_t *dyn_sym, size_t dyn_sym_size, const byte_t *dyn_str, size_t dyn_str_size, bool is64Bit)
{
	size_t dynSymSize = is64Bit ? sizeof(Elf64_Sym) : sizeof(Elf32_Sym);

	sElfSymbol symbol;
	for (size_t i = 0; i < dyn_sym_size; i += dynSymSize)
	{
		uint32_t name_pos;

		if (is64Bit)
		{
			name_pos = tc::bn::detail::__le_uint32(((Elf64_Sym*)(dyn_sym + i))->st_name);
			symbol.shn_index = tc::bn::detail::__le_uint16(((Elf64_Sym*)(dyn_sym + i))->st_shndx);
			symbol.symbol_type = elf::get_elf_st_type(((Elf64_Sym*)(dyn_sym + i))->st_info);
			symbol.symbol_binding = elf::get_elf_st_bind(((Elf64_Sym*)(dyn_sym + i))->st_info);
		}
		else
		{
			name_pos = tc::bn::detail::__le_uint32(((Elf32_Sym*)(dyn_sym + i))->st_name);
			symbol.shn_index = tc::bn::detail::__le_uint16(((Elf32_Sym*)(dyn_sym + i))->st_shndx);
			symbol.symbol_type = elf::get_elf_st_type(((Elf32_Sym*)(dyn_sym + i))->st_info);
			symbol.symbol_binding = elf::get_elf_st_bind(((Elf32_Sym*)(dyn_sym + i))->st_info);
		}

		if (name_pos >= dyn_str_size)
		{
			throw tc::Exception(mModuleName, "Out of bounds symbol name offset");
		}

		//for (; dyn_str[name_pos] == 0x00 && name_pos < dyn_str_size; name_pos++);
		
		symbol.name = std::string((char*)&dyn_str[name_pos]);
		mSymbolList.push_back(symbol);
	}
}

const std::vector<nstool::ElfSymbolParser::sElfSymbol>& nstool::ElfSymbolParser::getSymbolList() const
{
	return mSymbolList;
}
```

`src/ElfSymbolParser.h`:

```h
#pragma once
#include "types.h"
#include "elf.h"

namespace nstool {

class ElfSymbolParser
{
public:
	struct sElfSymbol
	{
		uint16_t shn_index;
		byte_t symbol_type;
		byte_t symbol_binding;
		std::string name;

		void operator=(const sElfSymbol& other)
		{
			shn_index = other.shn_index;
			symbol_type = other.symbol_type;
			symbol_binding = other.symbol_binding;
			name = other.name;
		}

		bool operator==(const sElfSymbol& other) const
		{
			return (shn_index == other.shn_index && symbol_type == other.symbol_type && symbol_binding == other.symbol_binding && name == other.name);
		}

		bool operator!=(const sElfSymbol& other) const
		{
			return !(*this == other);
		}
	};

	ElfSymbolParser();

	void operator=(const ElfSymbolParser& other);
	bool operator==(const ElfSymbolParser& other) const;
	bool operator!=(const ElfSymbolParser& other) const;

	void parseData(const byte_t *dyn_sym, size_t dyn_sym_size, const byte_t *dyn_str, size_t dyn_str_size, bool is64Bit);

	const std::vector<sElfSymbol>& getSymbolList() const;
private:
	std::string mModuleName;

	// data
	std::vector<sElfSymbol> mSymbolList;
};

}
```

`src/EsCertProcess.cpp`:

```cpp
#include "EsCertProcess.h"
#include "PkiValidator.h"
#include "util.h"

#include <pietendo/hac/es/SignUtils.h>

nstool::EsCertProcess::EsCertProcess() :
	mModuleName("nstool::EsCertProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false)
{
}

void nstool::EsCertProcess::process()
{
	importCerts();

	if (mVerify)
		validateCerts();

	if (mCliOutputMode.show_basic_info)
		displayCerts();
}

void nstool::EsCertProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::EsCertProcess::setKeyCfg(const KeyBag& keycfg)
{
	mKeyCfg = keycfg;
}

void nstool::EsCertProcess::setCliOutputMode(CliOutputMode mode)
{
	mCliOutputMode = mode;
}

void nstool::EsCertProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::EsCertProcess::importCerts()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// check if file_size is greater than 20MB, don't import.
	size_t file_size = tc::io::IOUtil::castInt64ToSize(mFile->length());
	if (file_size > (0x100000 * 20))
	{
		throw tc::Exception(mModuleName, "File too large.");
	}

	// import certs
	tc::ByteData scratch = tc::ByteData(file_size);
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	pie::hac::es::SignedData<pie::hac::es::CertificateBody> cert;
	for (size_t f_pos = 0; f_pos < scratch.size(); f_pos += cert.getBytes().size())
	{
		cert.fromBytes(scratch.data() + f_pos, scratch.size() - f_pos);
		mCert.push_back(cert);
	}
}

void nstool::EsCertProcess::validateCerts()
{
	PkiValidator pki;
	
	try
	{
		pki.setKeyCfg(mKeyCfg);
		pki.addCertificates(mCert);
	}
	catch (const tc::Exception& e)
	{
		fmt::print("[WARNING] {}\n", e.error());
		return;
	}
}

void nstool::EsCertProcess::displayCerts()
{
	for (size_t i = 0; i < mCert.size(); i++)
	{
		displayCert(mCert[i]);
	}
}

void nstool::EsCertProcess::displayCert(const pie::hac::es::SignedData<pie::hac::es::CertificateBody>& cert)
{
	fmt::print("[ES Certificate]\n");

	fmt::print("  SignType       {:s}", getSignTypeStr(cert.getSignature().getSignType()));
	if (mCliOutputMode.show_extended_info)
		fmt::print(" (0x{:x}) ({:s})", (uint32_t)cert.getSignature().getSignType(), getEndiannessStr(cert.getSignature().isLittleEndian()));
	fmt::print("\n");

	fmt::print("  Issuer:        {:s}\n", cert.getBody().getIssuer());
	fmt::print("  Subject:       {:s}\n", cert.getBody().getSubject());
	fmt::print("  PublicKeyType: {:s}", getPublicKeyTypeStr(cert.getBody().getPublicKeyType()));
	if (mCliOutputMode.show_extended_info)
		fmt::print(" ({:d})", (uint32_t)cert.getBody().getPublicKeyType());
	fmt::print("\n");
	fmt::print("  CertID:        0x{:x}\n", cert.getBody().getCertId());
	
	if (cert.getBody().getPublicKeyType() == pie::hac::es::cert::RSA4096)
	{
		fmt::print("  PublicKey:\n");
		if (mCliOutputMode.show_extended_info)
		{
			fmt::print("    Modulus:\n");
			fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(cert.getBody().getRsa4096PublicKey().n.data(), cert.getBody().getRsa4096PublicKey().n.size(), true, "", 0x10, 6, false));
			fmt::print("    Public Exponent:\n");
			fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(cert.getBody().getRsa4096PublicKey().e.data(), cert.getBody().getRsa4096PublicKey().e.size(), true, "", 0x10, 6, false));
		}
		else
		{
			fmt::print("    Modulus:\n");
			fmt::print("      {:s}\n", getTruncatedBytesString(cert.getBody().getRsa4096PublicKey().n.data(), cert.getBody().getRsa4096PublicKey().n.size()));
			fmt::print("    Public Exponent:\n");
			fmt::print("      {:s}\n", getTruncatedBytesString(cert.getBody().getRsa4096PublicKey().e.data(), cert.getBody().getRsa4096PublicKey().e.size()));
		}
	}
	else if (cert.getBody().getPublicKeyType() == pie::hac::es::cert::RSA2048)
	{
		fmt::print("  PublicKey:\n");
		if (mCliOutputMode.show_extended_info)
		{
			fmt::print("    Modulus:\n");
			fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(cert.getBody().getRsa2048PublicKey().n.data(), cert.getBody().getRsa2048PublicKey().n.size(), true, "", 0x10, 6, false));
			fmt::print("    Public Exponent:\n");
			fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(cert.getBody().getRsa2048PublicKey().e.data(), cert.getBody().getRsa2048PublicKey().e.size(), true, "", 0x10, 6, false));
		}
		else
		{
			fmt::print("    Modulus:\n");
			fmt::print("      {:s}\n", getTruncatedBytesString(cert.getBody().getRsa2048PublicKey().n.data(), cert.getBody().getRsa2048PublicKey().n.size()));
			fmt::print("    Public Exponent:\n");
			fmt::print("      {:s}\n", getTruncatedBytesString(cert.getBody().getRsa2048PublicKey().e.data(), cert.getBody().getRsa2048PublicKey().e.size()));
		}
	}
	else if (cert.getBody().getPublicKeyType() == pie::hac::es::cert::ECDSA240)
	{
		fmt::print("  PublicKey:\n");
		if (mCliOutputMode.show_extended_info)
		{
			fmt::print("    Modulus:\n");
			fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(cert.getBody().getEcdsa240PublicKey().r.data(), cert.getBody().getEcdsa240PublicKey().r.size(), true, "", 0x10, 6, false));
			fmt::print("    Public Exponent:\n");
			fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(cert.getBody().getEcdsa240PublicKey().s.data(), cert.getBody().getEcdsa240PublicKey().s.size(), true, "", 0x10, 6, false));
		}
		else
		{
			fmt::print("    Modulus:\n");
			fmt::print("      {:s}\n", getTruncatedBytesString(cert.getBody().getEcdsa240PublicKey().r.data(), cert.getBody().getEcdsa240PublicKey().r.size()));
			fmt::print("    Public Exponent:\n");
			fmt::print("      {:s}\n", getTruncatedBytesString(cert.getBody().getEcdsa240PublicKey().s.data(), cert.getBody().getEcdsa240PublicKey().s.size()));
		}
	}
}

std::string nstool::EsCertProcess::getSignTypeStr(pie::hac::es::sign::SignatureId type) const
{
	std::string str;
	switch (type)
	{
	case (pie::hac::es::sign::SIGN_ID_RSA4096_SHA1):
		str = "RSA4096-SHA1";
		break;
	case (pie::hac::es::sign::SIGN_ID_RSA2048_SHA1):
		str = "RSA2048-SHA1";
		break;
	case (pie::hac::es::sign::SIGN_ID_ECDSA240_SHA1):
		str = "ECDSA240-SHA1";
		break;
	case (pie::hac::es::sign::SIGN_ID_RSA4096_SHA256):
		str = "RSA4096-SHA256";
		break;
	case (pie::hac::es::sign::SIGN_ID_RSA2048_SHA256):
		str = "RSA2048-SHA256";
		break;
	case (pie::hac::es::sign::SIGN_ID_ECDSA240_SHA256):
		str = "ECDSA240-SHA256";
		break;
	default:
		str = "Unknown";
		break;
	}
	return str;
}

std::string nstool::EsCertProcess::getEndiannessStr(bool isLittleEndian) const
{
	return isLittleEndian ? "LittleEndian" : "BigEndian";
}

std::string nstool::EsCertProcess::getPublicKeyTypeStr(pie::hac::es::cert::PublicKeyType type) const
{
	std::string str;
	switch (type)
	{
	case (pie::hac::es::cert::RSA4096):
		str = "RSA4096";
		break;
	case (pie::hac::es::cert::RSA2048):
		str = "RSA2048";
		break;
	case (pie::hac::es::cert::ECDSA240):
		str = "ECDSA240";
		break;
	default:
		str = "Unknown";
		break;
	}
	return str;
}
```

`src/EsCertProcess.h`:

```h
#pragma once
#include "types.h"
#include "KeyBag.h"

#include <pietendo/hac/es/SignedData.h>
#include <pietendo/hac/es/CertificateBody.h>

namespace nstool {

class EsCertProcess
{
public:
	EsCertProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setKeyCfg(const KeyBag& keycfg);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	KeyBag mKeyCfg;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	std::vector<pie::hac::es::SignedData<pie::hac::es::CertificateBody>> mCert;

	void importCerts();
	void validateCerts();
	void displayCerts();
	void displayCert(const pie::hac::es::SignedData<pie::hac::es::CertificateBody>& cert);

	std::string getSignTypeStr(pie::hac::es::sign::SignatureId type) const;
	std::string getEndiannessStr(bool isLittleEndian) const;
	std::string getPublicKeyTypeStr(pie::hac::es::cert::PublicKeyType type) const;
};

}
```

`src/EsTikProcess.cpp`:

```cpp
#include "EsTikProcess.h"
#include "PkiValidator.h"

#include <pietendo/hac/es/SignUtils.h>

nstool::EsTikProcess::EsTikProcess() :
	mModuleName("nstool::EsTikProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false)
{
}

void nstool::EsTikProcess::process()
{
	importTicket();

	if (mVerify)
		verifyTicket();

	if (mCliOutputMode.show_basic_info)
		displayTicket();
}

void nstool::EsTikProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::EsTikProcess::setKeyCfg(const KeyBag& keycfg)
{
	mKeyCfg = keycfg;
}

void nstool::EsTikProcess::setCertificateChain(const std::vector<pie::hac::es::SignedData<pie::hac::es::CertificateBody>>& certs)
{
	mCerts = certs;
}

void nstool::EsTikProcess::setCliOutputMode(CliOutputMode mode)
{
	mCliOutputMode = mode;
}

void nstool::EsTikProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::EsTikProcess::importTicket()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// check if file_size is greater than 20MB, don't import.
	size_t file_size = tc::io::IOUtil::castInt64ToSize(mFile->length());
	if (file_size > (0x100000 * 20))
	{
		throw tc::Exception(mModuleName, "File too large.");
	}

	// read ticket
	tc::ByteData scratch = tc::ByteData(file_size);
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	mTik.fromBytes(scratch.data(), scratch.size());
}

void nstool::EsTikProcess::verifyTicket()
{
	PkiValidator pki_validator;
	tc::ByteData tik_hash;

	switch (pie::hac::es::sign::getHashAlgo(mTik.getSignature().getSignType()))
	{
	case (pie::hac::es::sign::HASH_ALGO_SHA1):
		tik_hash = tc::ByteData(tc::crypto::Sha1Generator::kHashSize);
		tc::crypto::GenerateSha1Hash(tik_hash.data(), mTik.getBody().getBytes().data(), mTik.getBody().getBytes().size());
		break;
	case (pie::hac::es::sign::HASH_ALGO_SHA256):
		tik_hash = tc::ByteData(tc::crypto::Sha2256Generator::kHashSize);
		tc::crypto::GenerateSha2256Hash(tik_hash.data(), mTik.getBody().getBytes().data(), mTik.getBody().getBytes().size());
		break;
	}

	try 
	{
		pki_validator.setKeyCfg(mKeyCfg);
		pki_validator.addCertificates(mCerts);
		pki_validator.validateSignature(mTik.getBody().getIssuer(), mTik.getSignature().getSignType(), mTik.getSignature().getSignature(), tik_hash);
	}
	catch (const tc::Exception& e)
	{
		fmt::print("[WARNING] Ticket signature could not be validated ({:s})\n", e.error());
	}
}

void nstool::EsTikProcess::displayTicket()
{
	const pie::hac::es::TicketBody_V2& body = mTik.getBody();	

	fmt::print("[ES Ticket]\n");
	fmt::print("  SignType:         {:s}", getSignTypeStr(mTik.getSignature().getSignType()));
	if (mCliOutputMode.show_extended_info)
		fmt::print(" (0x{:x})", (uint32_t)mTik.getSignature().getSignType());
	fmt::print("\n");

	fmt::print("  Issuer:           {:s}\n", body.getIssuer());
	fmt::print("  Title Key:\n");
	fmt::print("    EncMode:        {:s}\n", getTitleKeyPersonalisationStr(body.getTitleKeyEncType()));
	fmt::print("    KeyGeneration:  {:d}\n", (uint32_t)body.getCommonKeyId());
	if (body.getTitleKeyEncType() == pie::hac::es::ticket::RSA2048)
	{
		fmt::print("    Data:\n");
		fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(body.getEncTitleKey(), 0x100, true, "", 0x10, 6, false));
	}
	else if (body.getTitleKeyEncType() == pie::hac::es::ticket::AES128_CBC)
	{
		fmt::print("    Data:\n");
		fmt::print("      {:s}\n", tc::cli::FormatUtil::formatBytesAsString(body.getEncTitleKey(), 0x10, true, ""));
	}
	else
	{
		fmt::print("    Data:           <cannot display>\n");
	}
	fmt::print("  Version:          {:s} (v{:d})\n", getTitleVersionStr(body.getTicketVersion()), body.getTicketVersion());
	fmt::print("  License Type:     {:s}\n", getLicenseTypeStr(body.getLicenseType())); 
	if (body.getPropertyFlags().size() > 0 || mCliOutputMode.show_extended_info)
	{
		pie::hac::es::sTicketBody_v2* raw_body = (pie::hac::es::sTicketBody_v2*)body.getBytes().data();
		fmt::print("  PropertyMask:     0x{:04x}\n", ((tc::bn::le16<uint16_t>*)&raw_body->property_mask)->unwrap());
		for (size_t i = 0; i < body.getPropertyFlags().size(); i++)
		{
			fmt::print("    {:s}\n", getPropertyFlagStr(body.getPropertyFlags()[i]));
		}
	}
	if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  Reserved Region:\n");
		fmt::print("    {:s}\n", tc::cli::FormatUtil::formatBytesAsString(body.getReservedRegion(), 8, true, ""));
	}
	
	if (body.getTicketId() != 0 || mCliOutputMode.show_extended_info)
		fmt::print("  TicketId:         0x{:016x}\n", body.getTicketId());
	
	if (body.getDeviceId() != 0 || mCliOutputMode.show_extended_info)
		fmt::print("  DeviceId:         0x{:016x}\n", body.getDeviceId());
	
	fmt::print("  RightsId:         \n");
	fmt::print("    {:s}\n", tc::cli::FormatUtil::formatBytesAsString(body.getRightsId(), 16, true, ""));

	fmt::print("  SectionTotalSize:       0x{:x}\n", body.getSectionTotalSize());
	fmt::print("  SectionHeaderOffset:    0x{:x}\n", body.getSectionHeaderOffset());
	fmt::print("  SectionNum:             0x{:x}\n", body.getSectionNum());
	fmt::print("  SectionEntrySize:       0x{:x}\n", body.getSectionEntrySize());
}

std::string nstool::EsTikProcess::getSignTypeStr(uint32_t type) const
{
	std::string str;
	switch(type)
	{
	case (pie::hac::es::sign::SIGN_ID_RSA4096_SHA1):
		str = "RSA4096-SHA1";
		break;
	case (pie::hac::es::sign::SIGN_ID_RSA2048_SHA1):
		str = "RSA2048-SHA1";
		break;
	case (pie::hac::es::sign::SIGN_ID_ECDSA240_SHA1):
		str = "ECDSA240-SHA1";
		break;
	case (pie::hac::es::sign::SIGN_ID_RSA4096_SHA256):
		str = "RSA4096-SHA256";
		break;
	case (pie::hac::es::sign::SIGN_ID_RSA2048_SHA256):
		str = "RSA2048-SHA256";
		break;
	case (pie::hac::es::sign::SIGN_ID_ECDSA240_SHA256):
		str = "ECDSA240-SHA256";
		break;
	default:
		str = "Unknown";
		break;
	}
	return str;
}

std::string nstool::EsTikProcess::getTitleKeyPersonalisationStr(byte_t flag) const
{
	std::string str;
	switch(flag)
	{
	case (pie::hac::es::ticket::AES128_CBC):
		str = "Generic (AESCBC)";
		break;
	case (pie::hac::es::ticket::RSA2048):
		str = "Personalised (RSA2048)";
		break;
	default:
		str = fmt::format("Unknown ({:d})", flag);
		break;
	}
	return str;
}

std::string nstool::EsTikProcess::getLicenseTypeStr(byte_t flag) const
{
	std::string str;
	switch(flag)
	{
	case (pie::hac::es::ticket::LICENSE_PERMANENT):
		str = "Permanent";
		break;
	case (pie::hac::es::ticket::LICENSE_DEMO):
		str = "Demo";
		break;
	case (pie::hac::es::ticket::LICENSE_TRIAL):
		str = "Trial";
		break;
	case (pie::hac::es::ticket::LICENSE_RENTAL):
		str = "Rental";
		break;
	case (pie::hac::es::ticket::LICENSE_SUBSCRIPTION):
		str = "Subscription";
		break;
	case (pie::hac::es::ticket::LICENSE_SERVICE):
		str = "Service";
		break;
	default:
		str = fmt::format("Unknown ({:d})", flag);
		break;
	}
	return str;
}

std::string nstool::EsTikProcess::getPropertyFlagStr(byte_t flag) const
{
	std::string str;
	switch(flag)
	{
	case (pie::hac::es::ticket::FLAG_PRE_INSTALL):
		str = "PreInstall";
		break;
	case (pie::hac::es::ticket::FLAG_SHARED_TITLE):
		str = "SharedTitle";
		break;
	case (pie::hac::es::ticket::FLAG_ALLOW_ALL_CONTENT):
		str = "AllContent";
		break;
	case (pie::hac::es::ticket::FLAG_DEVICE_LINK_INDEPENDENT):
		str = "DeviceLinkIndependent";
		break;
	case (pie::hac::es::ticket::FLAG_VOLATILE):
		str = "Volatile";
		break;
	case (pie::hac::es::ticket::FLAG_ELICENSE_REQUIRED):
		str = "ELicenseRequired";
		break;
	default:
		str = fmt::format("Unknown ({:d})", flag);
		break;
	}
	return str;
}

std::string nstool::EsTikProcess::getTitleVersionStr(uint16_t version) const
{
	return fmt::format("{:d}.{:d}.{:d}", ((version>>10) & 0x3f), ((version>>4) & 0x3f), ((version>>0) & 0xf));
}
```

`src/EsTikProcess.h`:

```h
#pragma once
#include "types.h"
#include "KeyBag.h"

#include <pietendo/hac/es/SignedData.h>
#include <pietendo/hac/es/CertificateBody.h>
#include <pietendo/hac/es/TicketBody_V2.h>

namespace nstool {

class EsTikProcess
{
public:
	EsTikProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setKeyCfg(const KeyBag& keycfg);
	void setCertificateChain(const std::vector<pie::hac::es::SignedData<pie::hac::es::CertificateBody>>& certs);
	void setCliOutputMode(CliOutputMode mode);
	void setVerifyMode(bool verify);
private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	KeyBag mKeyCfg;
	CliOutputMode mCliOutputMode;
	bool mVerify;
	
	std::vector<pie::hac::es::SignedData<pie::hac::es::CertificateBody>> mCerts;

	pie::hac::es::SignedData<pie::hac::es::TicketBody_V2> mTik;

	void importTicket();
	void verifyTicket();
	void displayTicket();
	std::string getSignTypeStr(uint32_t type) const;
	std::string getTitleKeyPersonalisationStr(byte_t flag) const;
	std::string getLicenseTypeStr(byte_t flag) const;
	std::string getPropertyFlagStr(byte_t flag) const;
	std::string getTitleVersionStr(uint16_t version) const;
};

}
```

`src/FsProcess.cpp`:

```cpp
#include "FsProcess.h"
#include "util.h"

#include <memory>
#include <tc/io/FileNotFoundException.h>
#include <tc/io/DirectoryNotFoundException.h>

nstool::FsProcess::FsProcess() :
	mModuleLabel("nstool::FsProcess"),
	mInputFs(),
	mFsFormatName(),
	mShowFsInfo(false),
	mProperties(),
	mShowFsTree(false),
	mFsRootLabel(),
	mExtractJobs(),
	mDataCache(0x10000)
{

}

void nstool::FsProcess::process()
{
	if (mInputFs == nullptr)
	{
		throw tc::InvalidOperationException(mModuleLabel, "No input filesystem");
	}

	if (mShowFsInfo)
	{
		fmt::print("[{:s}]\n", mFsFormatName.isSet() ? mFsFormatName.get() : "FileSystem/Info");
		for (auto itr = mProperties.begin(); itr != mProperties.end(); itr++)
		{
			fmt::print("  {:s}\n", *itr);
		}
	}

	if (mShowFsTree)
	{
		printFs();
	}
	
	if (mExtractJobs.empty() == false)
	{
		extractFs();
	}
}

void nstool::FsProcess::setInputFileSystem(const std::shared_ptr<tc::io::IFileSystem>& input_fs)
{
	mInputFs = input_fs;
}

void nstool::FsProcess::setFsFormatName(const std::string& fs_format_name)
{
	mFsFormatName = fs_format_name;
}

void nstool::FsProcess::setShowFsInfo(bool show_fs_info)
{
	mShowFsInfo = show_fs_info;
}

void nstool::FsProcess::setFsProperties(const std::vector<std::string>& properties)
{
	mProperties = properties;
}

void nstool::FsProcess::setShowFsTree(bool show_fs_tree)
{
	mShowFsTree = show_fs_tree;
}

void nstool::FsProcess::setFsRootLabel(const std::string& root_label)
{
	mFsRootLabel = root_label;
}

void nstool::FsProcess::setExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs)
{
	mExtractJobs = extract_jobs;
}

void nstool::FsProcess::printFs()
{
	fmt::print("[{:s}/Tree]\n", (mFsFormatName.isSet() ? mFsFormatName.get() : "FileSystem"));
	visitDir(tc::io::Path("/"), tc::io::Path("/"), false, true);
}

void nstool::FsProcess::extractFs()
{
	fmt::print("[{:s}/Extract]\n", (mFsFormatName.isSet() ? mFsFormatName.get() : "FileSystem"));

	for (auto itr = mExtractJobs.begin(); itr != mExtractJobs.end(); itr++)
	{
		// check if root path (legacy case)
		if (itr->virtual_path == tc::io::Path("/"))
		{
			visitDir(tc::io::Path("/"), itr->extract_path, true, false);

			//fmt::print("Root Dir Virtual Path: \"{:s}\"\n", itr->virtual_path.to_string());

			// root directory extract successful, continue to next job
			continue;
		}

		// otherwise determine if this is a file or subdirectory
		try {
			std::shared_ptr<tc::io::IStream> file_stream;
			mInputFs->openFile(itr->virtual_path, tc::io::FileMode::Open, tc::io::FileAccess::Read, file_stream);

			//fmt::print("Valid File Path: \"{:s}\"\n", itr->virtual_path.to_string());

			// the output path for this file will depend on the user specified extract path
			std::shared_ptr<tc::io::IFileSystem> local_fs = std::make_shared<tc::io::LocalFileSystem>(tc::io::LocalFileSystem());

			// case: the extract_path is a valid path to an existing directory
			// behaviour: extract the file, preserving the original filename, to the specified directory
			// method: try getDirectoryListing(itr->extract_path), if this is does not throw, then we can be sure this is a valid path to a directory, file_extract_path = itr->extract_path + itr->virtual_path.back()

			try {
				tc::io::sDirectoryListing dir_listing;
				local_fs->getDirectoryListing(itr->extract_path, dir_listing);

				tc::io::Path file_extract_path = itr->extract_path + itr->virtual_path.back();

				fmt::print("Saving {:s}...\n", file_extract_path.to_string());

				writeStreamToFile(file_stream, itr->extract_path + itr->virtual_path.back(), mDataCache);

				continue;

			} catch (tc::io::DirectoryNotFoundException&) {
				// acceptable exception, just means directory didn't exist
			}

			// case: the extract_path up until the last element is a valid path to an existing directory, but the full path specifies neither a directory or a file
			// behaviour: treat extract_path as the intended location to write the extracted file (the original filename is not preserved, instead specified by the user in the final element of the extract path)
			// method: since this checks n-1 elements, it implies a path with more than one element, so that must be accounted for, as relative paths are valid and single element paths aren't always root

			try {
				// get path to parent directory
				tc::io::Path parent_dir_path = itr->extract_path;

				// replace final path element with the current directory alias 
				parent_dir_path.pop_back(); // remove filename
				parent_dir_path.push_back("."); // replace with the current dir name alias

				// test parent directory exists
				tc::io::sDirectoryListing dir_listing;
				local_fs->getDirectoryListing(parent_dir_path, dir_listing);

				fmt::print("Saving {:s} as {:s}...\n", itr->virtual_path.to_string(), itr->extract_path.to_string());

				writeStreamToFile(file_stream, itr->extract_path, mDataCache);

				continue;
			} catch (tc::io::DirectoryNotFoundException&) {
				// acceptable exception, just means the parent directory didn't exist
			}


			// extract path could not be determined, inform the user and skip this job
			fmt::print("[WARNING] Extract path was invalid, and was skipped: {:s}\n", itr->extract_path.to_string());
			continue;
		} catch (tc::io::FileNotFoundException&) {
			// acceptable exception, just means file didn't exist
		}

		// not a file, attempt to process this as a directory
		try {
			tc::io::sDirectoryListing dir_listing;
			mInputFs->getDirectoryListing(itr->virtual_path, dir_listing);

			visitDir(itr->virtual_path, itr->extract_path, true, false);

			//fmt::print("Valid Directory Path: \"{:s}\"\n", itr->virtual_path.to_string());

			// directory extract successful, continue to next job
			continue;

		} catch (tc::io::DirectoryNotFoundException&) {
			// acceptable exception, just means directory didn't exist
		}

		fmt::print("[WARNING] Failed to extract virtual path: \"{:s}\"\n", itr->virtual_path.to_string());
	}
	
}

void nstool::FsProcess::visitDir(const tc::io::Path& v_path, const tc::io::Path& l_path, bool extract_fs, bool print_fs)
{
	tc::io::LocalFileSystem local_fs;

	// get listing for directory
	tc::io::sDirectoryListing info;
	mInputFs->getDirectoryListing(v_path, info);

	if (print_fs)
	{
		for (size_t i = 0; i < v_path.size(); i++)
			fmt::print(" ");

		fmt::print("{:s}/\n", ((v_path.size() == 1) ? (mFsRootLabel.isSet() ? (mFsRootLabel.get() + ":")  : "Root:") : v_path.back()));
	}
	if (extract_fs)
	{
		// create local dir
		local_fs.createDirectory(l_path);
	}

	// iterate thru child files
	size_t cache_read_len;
	tc::io::Path out_path;
	std::shared_ptr<tc::io::IStream> in_stream;
	std::shared_ptr<tc::io::IStream> out_stream;
	for (auto itr = info.file_list.begin(); itr != info.file_list.end(); itr++)
	{
		if (print_fs)
		{
			for (size_t i = 0; i < v_path.size(); i++)
				fmt::print(" ");
			fmt::print(" {:s}\n", *itr);
		}
		if (extract_fs)
		{
			// build out path
			out_path = l_path + *itr;

			fmt::print("Saving {:s}...\n", out_path.to_string());

			// begin export
			mInputFs->openFile(v_path + *itr, tc::io::FileMode::Open, tc::io::FileAccess::Read, in_stream);
			local_fs.openFile(out_path, tc::io::FileMode::OpenOrCreate, tc::io::FileAccess::Write, out_stream);

			in_stream->seek(0, tc::io::SeekOrigin::Begin);
			out_stream->seek(0, tc::io::SeekOrigin::Begin);
			for (int64_t remaining_data = in_stream->length(); remaining_data > 0;)
			{
				cache_read_len = in_stream->read(mDataCache.data(), mDataCache.size());
				if (cache_read_len == 0)
				{
					throw tc::io::IOException(mModuleLabel, fmt::format("Failed to read from {:s}file.", (mFsFormatName.isSet() ? (mFsFormatName.get() + " ") : "")));
				}

				out_stream->write(mDataCache.data(), cache_read_len);

				remaining_data -= int64_t(cache_read_len);
			}
		}
	}

	// iterate thru child dirs
	for (auto itr = info.dir_list.begin(); itr != info.dir_list.end(); itr++)
	{
		visitDir(v_path + *itr, l_path + *itr, extract_fs, print_fs);
	}
}
```

`src/FsProcess.h`:

```h
#pragma once
#include <tc/Optional.h>
#include <tc/io.h>

#include "types.h"

namespace nstool
{

class FsProcess
{
public:
	FsProcess();

	void process();

	void setInputFileSystem(const std::shared_ptr<tc::io::IFileSystem>& input_fs);
	void setFsFormatName(const std::string& fs_format_name);
	void setFsProperties(const std::vector<std::string>& properties);
	void setShowFsInfo(bool show_fs_info);
	void setShowFsTree(bool show_fs_tree);
	void setFsRootLabel(const std::string& root_label);
	void setExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs);
private:
	std::string mModuleLabel;

	std::shared_ptr<tc::io::IFileSystem> mInputFs;

	// fs info
	tc::Optional<std::string> mFsFormatName;
	bool mShowFsInfo;
	std::vector<std::string> mProperties;

	// fs tree
	bool mShowFsTree;
	tc::Optional<std::string> mFsRootLabel;

	// extract jobs
	std::vector<nstool::ExtractJob> mExtractJobs;

	// cache for file extract
	tc::ByteData mDataCache;
	
	void printFs();
	void extractFs();

	void visitDir(const tc::io::Path& v_path, const tc::io::Path& l_path, bool extract_fs, bool print_fs);
};

}
```

`src/GameCardProcess.cpp`:

```cpp
#include "GameCardProcess.h"

#include <tc/crypto.h>
#include <tc/io/IOUtil.h>

#include <pietendo/hac/GameCardUtil.h>
#include <pietendo/hac/ContentMetaUtil.h>
#include <pietendo/hac/ContentArchiveUtil.h>

#include <pietendo/hac/GameCardFsSnapshotGenerator.h>
#include "FsProcess.h"


nstool::GameCardProcess::GameCardProcess() :
	mModuleName("nstool::GameCardProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false),
	mIsTrueSdkXci(false),
	mIsSdkXciEncrypted(false),
	mGcHeaderOffset(0),
	mProccessExtendedHeader(false),
	mFileSystem(),
	mFsProcess()
{
}

void nstool::GameCardProcess::process()
{
	importHeader();

	// validate header signature
	if (mVerify)
		validateXciSignature();

	// display header
	if (mCliOutputMode.show_basic_info)
		displayHeader();

	// process nested HFS0
	processRootPfs();
}

void nstool::GameCardProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::GameCardProcess::setKeyCfg(const KeyBag& keycfg)
{
	mKeyCfg = keycfg;
}

void nstool::GameCardProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::GameCardProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::GameCardProcess::setShowFsTree(bool show_fs_tree)
{
	mFsProcess.setShowFsTree(show_fs_tree);
}

void nstool::GameCardProcess::setExtractJobs(const std::vector<nstool::ExtractJob> extract_jobs)
{
	mFsProcess.setExtractJobs(extract_jobs);
}

void nstool::GameCardProcess::importHeader()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}
	
	// check stream is large enough for header
	if (mFile->length() < tc::io::IOUtil::castSizeToInt64(sizeof(pie::hac::sSdkGcHeader)))
	{
		throw tc::Exception(mModuleName, "Corrupt GameCard Image: File too small.");
	}

	// allocate memory for header
	tc::ByteData scratch = tc::ByteData(sizeof(pie::hac::sSdkGcHeader));

	// read header region
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	// determine if this is a SDK XCI or a "Community" XCI
	if (((pie::hac::sSdkGcHeader*)scratch.data())->signed_header.header.st_magic.unwrap() == pie::hac::gc::kGcHeaderStructMagic)
	{
		mIsTrueSdkXci = true;
		mGcHeaderOffset = sizeof(pie::hac::sGcKeyDataRegion);
	}
	else if (((pie::hac::sGcHeader_Rsa2048Signed*)scratch.data())->header.st_magic.unwrap() == pie::hac::gc::kGcHeaderStructMagic)
	{
		mIsTrueSdkXci = false;
		mGcHeaderOffset = 0;
	}
	else 
	{
		throw tc::Exception(mModuleName, "Corrupt GameCard Image: Unexpected magic bytes.");
	}

	pie::hac::sGcHeader_Rsa2048Signed* hdr_ptr = (pie::hac::sGcHeader_Rsa2048Signed*)(scratch.data() + mGcHeaderOffset);

	// generate hash of raw header
	tc::crypto::GenerateSha2256Hash(mHdrHash.data(), (byte_t*)&hdr_ptr->header, sizeof(pie::hac::sGcHeader));
	
	// save the signature
	memcpy(mHdrSignature.data(), hdr_ptr->signature.data(), mHdrSignature.size());
	
	// decrypt extended header
	byte_t xci_header_key_index = hdr_ptr->header.key_flag & 0xf;
	if (mKeyCfg.xci_header_key.find(xci_header_key_index) != mKeyCfg.xci_header_key.end())
	{
		pie::hac::GameCardUtil::decryptXciHeader(&hdr_ptr->header, mKeyCfg.xci_header_key[xci_header_key_index].data());
		mProccessExtendedHeader = true;
	}
	
	// deserialise header
	mHdr.fromBytes((byte_t*)&hdr_ptr->header, sizeof(pie::hac::sGcHeader));
}

void nstool::GameCardProcess::displayHeader()
{
	const pie::hac::sGcHeader* raw_hdr = (const pie::hac::sGcHeader*)mHdr.getBytes().data();

	fmt::print("[GameCard/Header]\n");
	fmt::print("  CardHeaderVersion:      {:d}\n", mHdr.getCardHeaderVersion());
	fmt::print("  RomSize:                {:s}", pie::hac::GameCardUtil::getRomSizeAsString((pie::hac::gc::RomSize)mHdr.getRomSizeType()));
	if (mCliOutputMode.show_extended_info)
		fmt::print(" (0x{:x})", mHdr.getRomSizeType());
	fmt::print("\n");
	fmt::print("  PackageId:              0x{:016x}\n", mHdr.getPackageId());
	fmt::print("  Flags:                  0x{:02x}\n", *((byte_t*)&raw_hdr->flags));
	for (auto itr = mHdr.getFlags().begin(); itr != mHdr.getFlags().end(); itr++)
	{
		fmt::print("    {:s}\n", pie::hac::GameCardUtil::getHeaderFlagsAsString((pie::hac::gc::HeaderFlags)*itr));
	}
	
	
	if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  KekIndex:               {:s} ({:d})\n", pie::hac::GameCardUtil::getKekIndexAsString((pie::hac::gc::KekIndex)mHdr.getKekIndex()), mHdr.getKekIndex());
		fmt::print("  TitleKeyDecIndex:       {:d}\n", mHdr.getTitleKeyDecIndex());
		fmt::print("  InitialData:\n");
		fmt::print("    Hash:\n");
		fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(mHdr.getInitialDataHash().data(), mHdr.getInitialDataHash().size(), true, "", 0x10, 6, false));
	}
	if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  Extended Header AesCbc IV:\n");
		fmt::print("    {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mHdr.getAesCbcIv().data(), mHdr.getAesCbcIv().size(), true, ""));
	}
	fmt::print("  SelSec:                 0x{:x}\n", mHdr.getSelSec());
	fmt::print("  SelT1Key:               0x{:x}\n", mHdr.getSelT1Key());
	fmt::print("  SelKey:                 0x{:x}\n", mHdr.getSelKey());
	if (mCliOutputMode.show_layout)
	{
		fmt::print("  RomAreaStartPage:       0x{:x}", mHdr.getRomAreaStartPage());
		if (mHdr.getRomAreaStartPage() != (uint32_t)(-1))
			fmt::print(" (0x{:x})", pie::hac::GameCardUtil::blockToAddr(mHdr.getRomAreaStartPage()));
		fmt::print("\n");

		fmt::print("  BackupAreaStartPage:    0x{:x}", mHdr.getBackupAreaStartPage());
		if (mHdr.getBackupAreaStartPage() != (uint32_t)(-1))
			fmt::print(" (0x{:x})", pie::hac::GameCardUtil::blockToAddr(mHdr.getBackupAreaStartPage()));
		fmt::print("\n");

		fmt::print("  ValidDataEndPage:       0x{:x}", mHdr.getValidDataEndPage());
		if (mHdr.getValidDataEndPage() != (uint32_t)(-1))
			fmt::print(" (0x{:x})", pie::hac::GameCardUtil::blockToAddr(mHdr.getValidDataEndPage()));
		fmt::print("\n");

		fmt::print("  LimArea:                0x{:x}", mHdr.getLimAreaPage());
		if (mHdr.getLimAreaPage() != (uint32_t)(-1))
			fmt::print(" (0x{:x})", pie::hac::GameCardUtil::blockToAddr(mHdr.getLimAreaPage()));
		fmt::print("\n");

		fmt::print("  PartitionFs Header:\n");
		fmt::print("    Offset:               0x{:x}\n", mHdr.getPartitionFsAddress());
		fmt::print("    Size:                 0x{:x}\n", mHdr.getPartitionFsSize());
		if (mCliOutputMode.show_extended_info)
		{
			fmt::print("    Hash:\n");
			fmt::print("      {:s}", tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(mHdr.getPartitionFsHash().data(), mHdr.getPartitionFsHash().size(), true, "", 0x10, 6, false));
		}
	}

	
	if (mProccessExtendedHeader)
	{
		fmt::print("[GameCard/ExtendedHeader]\n");
		fmt::print("  FwVersion:              v{:d} ({:s})\n", mHdr.getFwVersion(), pie::hac::GameCardUtil::getCardFwVersionDescriptionAsString((pie::hac::gc::FwVersion)mHdr.getFwVersion()));
		fmt::print("  AccCtrl1:               0x{:x}\n", mHdr.getAccCtrl1());
		fmt::print("    CardClockRate:        {:s}\n", pie::hac::GameCardUtil::getCardClockRateAsString((pie::hac::gc::CardClockRate)mHdr.getAccCtrl1()));
		fmt::print("  Wait1TimeRead:          0x{:x}\n", mHdr.getWait1TimeRead());
		fmt::print("  Wait2TimeRead:          0x{:x}\n", mHdr.getWait2TimeRead());
		fmt::print("  Wait1TimeWrite:         0x{:x}\n", mHdr.getWait1TimeWrite());
		fmt::print("  Wait2TimeWrite:         0x{:x}\n", mHdr.getWait2TimeWrite());
		fmt::print("  SdkAddon Version:       {:s} (v{:d})\n", pie::hac::ContentArchiveUtil::getSdkAddonVersionAsString(mHdr.getFwMode()), mHdr.getFwMode());
		fmt::print("  CompatibilityType:      {:s} ({:d})\n", pie::hac::GameCardUtil::getCompatibilityTypeAsString((pie::hac::gc::CompatibilityType)mHdr.getCompatibilityType()), mHdr.getCompatibilityType());
		fmt::print("  Update Partition Info:\n");
		fmt::print("    CUP Version:          {:s} (v{:d})\n", pie::hac::ContentMetaUtil::getVersionAsString(mHdr.getUppVersion()), mHdr.getUppVersion());
		fmt::print("    CUP TitleId:          0x{:016x}\n", mHdr.getUppId());
		fmt::print("    CUP Digest:           {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mHdr.getUppHash().data(), mHdr.getUppHash().size(), true, ""));
	}
}

bool nstool::GameCardProcess::validateRegionOfFile(int64_t offset, int64_t len, const byte_t* test_hash, bool use_salt, byte_t salt)
{
	// read region into memory
	tc::ByteData scratch = tc::ByteData(tc::io::IOUtil::castInt64ToSize(len));
	mFile->seek(offset, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	// update hash
	tc::crypto::Sha2256Generator sha256_gen;
	sha256_gen.initialize();
	sha256_gen.update(scratch.data(), scratch.size());
	if (use_salt)
		sha256_gen.update(&salt, sizeof(salt));

	// calculate hash
	pie::hac::detail::sha256_hash_t calc_hash;
	sha256_gen.getHash(calc_hash.data());

	return memcmp(calc_hash.data(), test_hash, calc_hash.size()) == 0;
}

bool nstool::GameCardProcess::validateRegionOfFile(int64_t offset, int64_t len, const byte_t* test_hash)
{
	return validateRegionOfFile(offset, len, test_hash, false, 0);
}

void nstool::GameCardProcess::validateXciSignature()
{
	if (mKeyCfg.xci_header_sign_key.isSet())
	{
		if (tc::crypto::VerifyRsa2048Pkcs1Sha2256(mHdrSignature.data(), mHdrHash.data(), mKeyCfg.xci_header_sign_key.get()) == false)
		{
			fmt::print("[WARNING] GameCard Header Signature: FAIL\n");
		}
	}
	else 
	{
		fmt::print("[WARNING] GameCard Header Signature: FAIL (Failed to load rsa public key.)\n");
	}
}

void nstool::GameCardProcess::processRootPfs()
{
	if (mVerify && validateRegionOfFile(mHdr.getPartitionFsAddress(), mHdr.getPartitionFsSize(), mHdr.getPartitionFsHash().data(), mHdr.getCompatibilityType() != pie::hac::gc::CompatibilityType_Global, mHdr.getCompatibilityType()) == false)
	{
		fmt::print("[WARNING] GameCard Root HFS0: FAIL (bad hash)\n");
	}

	std::shared_ptr<tc::io::IStream> gc_fs_raw = std::make_shared<tc::io::SubStream>(tc::io::SubStream(mFile, mHdr.getPartitionFsAddress(), pie::hac::GameCardUtil::blockToAddr(mHdr.getValidDataEndPage()+1) - mHdr.getPartitionFsAddress()));

	auto gc_vfs_snapshot = pie::hac::GameCardFsSnapshotGenerator(gc_fs_raw, mHdr.getPartitionFsSize(), mVerify ? pie::hac::GameCardFsSnapshotGenerator::ValidationMode_Warn : pie::hac::GameCardFsSnapshotGenerator::ValidationMode_None);
	mFileSystem = std::make_shared<tc::io::VirtualFileSystem>(tc::io::VirtualFileSystem(gc_vfs_snapshot) );

	mFsProcess.setInputFileSystem(mFileSystem);
	mFsProcess.setFsFormatName("PartitionFs");
	mFsProcess.setFsProperties({
		fmt::format("Type:      Nested HFS0"),
		fmt::format("DirNum:    {:d}", gc_vfs_snapshot.dir_entries.empty() ? 0 : gc_vfs_snapshot.dir_entries.size() - 1), // -1 to not include root directory
		fmt::format("FileNum:   {:d}", gc_vfs_snapshot.file_entries.size())
	});
	mFsProcess.setShowFsInfo(mCliOutputMode.show_basic_info);
	mFsProcess.setFsRootLabel(kXciMountPointName);
	mFsProcess.process();
}
```

`src/GameCardProcess.h`:

```h
#pragma once
#include "types.h"
#include "KeyBag.h"
#include "PfsProcess.h"

#include <pietendo/hac/GameCardHeader.h>

namespace nstool {

class GameCardProcess
{
public:
	GameCardProcess();

	void process();

	// generic
	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setKeyCfg(const KeyBag& keycfg);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	// fs specific
	void setShowFsTree(bool show_fs_tree);
	void setExtractJobs(const std::vector<nstool::ExtractJob> extract_jobs);
private:
	const std::string kXciMountPointName = "gamecard";

	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	KeyBag mKeyCfg;
	CliOutputMode mCliOutputMode;
	bool mVerify;
	
	bool mIsTrueSdkXci;
	bool mIsSdkXciEncrypted;
	size_t mGcHeaderOffset;
	bool mProccessExtendedHeader;
	pie::hac::detail::rsa2048_signature_t mHdrSignature;
	pie::hac::detail::sha256_hash_t mHdrHash;
	pie::hac::GameCardHeader mHdr;
	
	// fs processing
	std::shared_ptr<tc::io::IFileSystem> mFileSystem;
	FsProcess mFsProcess;

	void importHeader();
	void displayHeader();
	bool validateRegionOfFile(int64_t offset, int64_t len, const byte_t* test_hash, bool use_salt, byte_t salt);
	bool validateRegionOfFile(int64_t offset, int64_t len, const byte_t* test_hash);
	void validateXciSignature();
	void processRootPfs();
};

}
```

`src/IniProcess.cpp`:

```cpp
#include "IniProcess.h"

#include "util.h"
#include "KipProcess.h"

nstool::IniProcess::IniProcess() :
	mModuleName("nstool::IniProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false),
	mKipExtractPath()
{
}

void nstool::IniProcess::process()
{
	importHeader();
	importKipList();
	if (mCliOutputMode.show_basic_info)
	{
		displayHeader();
		displayKipList();
	}
	if (mKipExtractPath.isSet())
	{
		extractKipList();
	}
}

void nstool::IniProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::IniProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::IniProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::IniProcess::setKipExtractPath(const tc::io::Path& path)
{
	mKipExtractPath = path;
}

void nstool::IniProcess::importHeader()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// check if file_size is smaller than INI header size
	if (tc::io::IOUtil::castInt64ToSize(mFile->length()) < sizeof(pie::hac::sIniHeader))
	{
		throw tc::Exception(mModuleName, "Corrupt INI: file too small.");
	}

	// read ini
	tc::ByteData scratch = tc::ByteData(sizeof(pie::hac::sIniHeader));
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	// parse ini header
	mHdr.fromBytes(scratch.data(), scratch.size());
}

void nstool::IniProcess::importKipList()
{
	// kip pos info
	int64_t kip_pos = tc::io::IOUtil::castSizeToInt64(sizeof(pie::hac::sIniHeader));
	int64_t kip_size = 0;

	// tmp data to determine size
	pie::hac::sKipHeader hdr_raw;
	pie::hac::KernelInitialProcessHeader hdr;

	for (size_t i = 0; i < mHdr.getKipNum(); i++)
	{
		mFile->seek(kip_pos, tc::io::SeekOrigin::Begin);
		mFile->read((byte_t*)&hdr_raw, sizeof(hdr_raw));
		hdr.fromBytes((byte_t*)&hdr_raw, sizeof(hdr_raw));		
		kip_size = getKipSizeFromHeader(hdr);
		mKipList.push_back({hdr, std::make_shared<tc::io::SubStream>(tc::io::SubStream(mFile, kip_pos, kip_size))});
		kip_pos += kip_size;
	}
}

void nstool::IniProcess::displayHeader()
{
	fmt::print("[INI Header]\n");
	fmt::print("  Size:         0x{:x}\n", mHdr.getSize());
	fmt::print("  KIP Num:      {:d}\n", mHdr.getKipNum());
}

void nstool::IniProcess::displayKipList()
{
	for (auto itr = mKipList.begin(); itr != mKipList.end(); itr++)
	{
		KipProcess obj;

		obj.setInputFile(itr->stream);
		obj.setCliOutputMode(mCliOutputMode);
		obj.setVerifyMode(mVerify);

		obj.process();
	}
}

void nstool::IniProcess::extractKipList()
{
	// allocate cache memory
	tc::ByteData cache = tc::ByteData(kCacheSize);

	// make extract dir
	tc::io::LocalFileSystem local_fs;
	local_fs.createDirectory(mKipExtractPath.get());
	
	// out path for extracted KIP
	tc::io::Path out_path;

	// extract KIPs
	for (auto itr = mKipList.begin(); itr != mKipList.end(); itr++)
	{
		out_path = mKipExtractPath.get();
		out_path += fmt::format("{:s}.kip", itr->hdr.getName());

		if (mCliOutputMode.show_basic_info)
			fmt::print("Saving {:s}...\n", out_path.to_string());

		writeStreamToFile(itr->stream, out_path, cache);
	}
}

int64_t nstool::IniProcess::getKipSizeFromHeader(const pie::hac::KernelInitialProcessHeader& hdr) const
{	
	// the order of elements in a KIP are sequential, there are no file offsets
	return int64_t(sizeof(pie::hac::sKipHeader)) + int64_t(hdr.getTextSegmentInfo().file_layout.size + hdr.getRoSegmentInfo().file_layout.size + hdr.getDataSegmentInfo().file_layout.size);
}
```

`src/IniProcess.h`:

```h
#pragma once
#include "types.h"

#include <pietendo/hac/IniHeader.h>
#include <pietendo/hac/KernelInitialProcessHeader.h>

namespace nstool {

class IniProcess
{
public:
	IniProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	void setKipExtractPath(const tc::io::Path& path);
private:
	const size_t kCacheSize = 0x10000;

	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;
	
	tc::Optional<tc::io::Path> mKipExtractPath;

	pie::hac::IniHeader mHdr;
	struct InnerKipInfo
	{
		pie::hac::KernelInitialProcessHeader hdr;
		std::shared_ptr<tc::io::IStream> stream;
	};
	std::vector<InnerKipInfo> mKipList;

	void importHeader();
	void importKipList();
	void displayHeader();
	void displayKipList();
	void extractKipList();

	int64_t getKipSizeFromHeader(const pie::hac::KernelInitialProcessHeader& hdr) const;
};

}
```

`src/KeyBag.cpp`:

```cpp
#include "KeyBag.h"

#include "util.h"
#include <tc/cli/FormatUtil.h>

#include <pietendo/hac/define/types.h>
#include <pietendo/hac/define/gc.h>
#include <pietendo/hac/AesKeygen.h>

#include <pietendo/hac/es/SignUtils.h>
#include <pietendo/hac/es/SignedData.h>
#include <pietendo/hac/es/CertificateBody.h>
#include <pietendo/hac/es/TicketBody_V2.h>

nstool::KeyBagInitializer::KeyBagInitializer(bool isDev, const tc::Optional<tc::io::Path>& keyfile_path, const tc::Optional<tc::io::Path>& tik_path, const tc::Optional<tc::io::Path>& cert_path)
{
	if (keyfile_path.isSet())
	{
		importBaseKeyFile(keyfile_path.get(), isDev);
	}
	if (cert_path.isSet())
	{
		importCertificateChain(cert_path.get());
	}
	if (tik_path.isSet())
	{
		importTicket(tik_path.get());
	}

	// this will populate known keys if they aren't supplied by the user provided keyfiles.
	importKnownKeys(isDev);
}

void nstool::KeyBagInitializer::importBaseKeyFile(const tc::io::Path& keyfile_path, bool isDev)
{
	std::shared_ptr<tc::io::FileStream> keyfile_stream = std::make_shared<tc::io::FileStream>(tc::io::FileStream(keyfile_path, tc::io::FileMode::Open, tc::io::FileAccess::Read));

	// import keyfile into a dictionary
	std::map<std::string, std::string> keyfile_dict;
	processResFile(keyfile_stream, keyfile_dict);

	// sources for key derivation
	std::map<byte_t, aes128_key_t> master_key;
	tc::Optional<aes128_key_t> package2_key_source;
	tc::Optional<aes128_key_t> ticket_titlekek_source;
	std::array<tc::Optional<aes128_key_t>, 3> key_area_key_source;
	tc::Optional<aes128_key_t> aes_kek_generation_source;
	tc::Optional<aes128_key_t> aes_key_generation_source;
	tc::Optional<aes128_key_t> nca_header_kek_source;
	tc::Optional<aes128_xtskey_t> nca_header_key_source;
	tc::Optional<rsa_key_t> pki_root_sign_key;

	// macros for importing
	
#define _SAVE_AES128KEY(key_name, dst) \
	{ \
	std::string key,val; \
	tc::ByteData dec_val; \
	aes128_key_t tmp_aes128_key; \
	key = (key_name); \
	val = keyfile_dict[key]; \
	if (val.empty() == false) { \
		dec_val = tc::cli::FormatUtil::hexStringToBytes(val); \
		if (dec_val.size() != tmp_aes128_key.size()) \
			throw tc::ArgumentException("nstool::KeyBagInitializer", "Key: \"" + key_name + "\" has incorrect length"); \
		memcpy(tmp_aes128_key.data(), dec_val.data(), tmp_aes128_key.size()); \
		(dst) = tmp_aes128_key; \
	} \
	}

#define _SAVE_AES128XTSKEY(key_name, dst) \
	{ \
	std::string key,val; \
	tc::ByteData dec_val; \
	aes128_xtskey_t tmp_aes128_xtskey; \
	key = (key_name); \
	val = keyfile_dict[key]; \
	if (val.empty() == false) { \
		dec_val = tc::cli::FormatUtil::hexStringToBytes(val); \
		if (dec_val.size() != sizeof(tmp_aes128_xtskey)) \
			throw tc::ArgumentException("nstool::KeyBagInitializer", "Key: \"" + key_name + "\" has incorrect length"); \
		memcpy(tmp_aes128_xtskey[0].data(), dec_val.data(), tmp_aes128_xtskey[0].size()); \
		memcpy(tmp_aes128_xtskey[1].data(), dec_val.data()+tmp_aes128_xtskey[0].size(), tmp_aes128_xtskey[1].size()); \
		(dst) = tmp_aes128_xtskey; \
	} \
	}

#define _SAVE_RSAKEY(key_name, dst, bitsize) \
	{ \
	std::string key_mod,key_prv,val_mod,val_prv; \
	tc::ByteData dec_val; \
	rsa_key_t tmp_rsa_key; \
	key_mod = fmt::format("{:s}_modulus", (key_name)); \
	key_prv = fmt::format("{:s}_private", (key_name)); \
	val_mod = keyfile_dict[key_mod]; \
	val_prv = keyfile_dict[key_prv]; \
	if (val_mod.empty() == false) { \
		dec_val = tc::cli::FormatUtil::hexStringToBytes(val_mod); \
		if (dec_val.size() == (bitsize) >> 3) { \
			tmp_rsa_key.n = dec_val; \
			if (val_prv.empty() == false) { \
				dec_val = tc::cli::FormatUtil::hexStringToBytes(val_prv); \
				if (dec_val.size() == (bitsize) >> 3) { \
					tmp_rsa_key.d = dec_val; \
					(dst) = tc::crypto::RsaPrivateKey(tmp_rsa_key.n.data(), tmp_rsa_key.n.size(), tmp_rsa_key.d.data(), tmp_rsa_key.d.size()); \
				} \
				else { \
					fmt::print("[WARNING] Key: \"{:s}\" has incorrect length (was: {:d}, expected {:d})\n", key_prv, val_prv.size(), ((bitsize) >> 3)*2); \
				} \
			} \
			else { \
				(dst) = tc::crypto::RsaPublicKey(tmp_rsa_key.n.data(), tmp_rsa_key.n.size()); \
			} \
		} \
		else {\
			fmt::print("[WARNING] Key: \"{:s}\" has incorrect length (was: {:d}, expected {:d})\n", key_mod, val_mod.size(), ((bitsize) >> 3)*2); \
		} \
	} \
	}
	
	// keynames
	enum NameVariantIndex
	{
		NNTOOLS,
		LEGACY_HACTOOL,
		LEGACY_0
	};
	
	static const size_t kNameVariantNum = 3;
	
	std::vector<std::string> kMasterBase = { "master" };
	std::vector<std::string> kPkg1Base = { "package1" };
	std::vector<std::string> kPkg2Base = { "package2" };
	std::vector<std::string> kXciHeaderBase = { "xci_header" };
	std::vector<std::string> kXciInitialDataBase = { "xci_initial_data" };
	std::vector<std::string> kXciCertBase = { "xci_cert" };
	std::vector<std::string> kContentArchiveHeaderBase = { "nca_header", "header" };
	std::vector<std::string> kAcidBase = { "acid" };
	std::vector<std::string> kNrrCertBase = { "nrr_certificate" };
	std::vector<std::string> kPkiRootBase = { "pki_root" };
	std::vector<std::string> kTicketCommonKeyBase = { "ticket_commonkey", "titlekek" };
	std::vector<std::string> kNcaKeyAreaEncKeyBase = { "nca_key_area_key", "key_area_key", "nca_body_keak" };
	std::vector<std::string> kNcaKeyAreaEncKeyHwBase = { "nca_key_area_key_hw", "key_area_hw_key" };
	std::vector<std::string> kKekGenBase = { "aes_kek_generation" };
	std::vector<std::string> kKeyGenBase = { "aes_key_generation" };
	
	// misc str
	const std::string kKeyStr = "key";
	const std::string kKekStr = "kek";
	const std::string kSourceStr = "source";
	const std::string kSignKey = "sign_key";
	const std::string kModulusStr = "modulus";
	const std::string kPrivateStr = "private";
	std::vector<std::string> kNcaKeyAreaKeyIndexStr = { "application", "ocean", "system" };

	static const size_t kKeyGenerationNum = 0x100;
	/**/

	// import key data
	for (size_t name_idx = 0; name_idx < kNameVariantNum; name_idx++)
	{
		/* internal key sources */
		if (name_idx < kMasterBase.size())
		{
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				// std::map<byte_t, aes128_key_t> master_key;
				//fmt::print("{:s}_key_{:02x}\n", kMasterBase[name_idx], keygen_rev);
				_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:02x}", kMasterBase[name_idx], kKeyStr, keygen_rev), master_key[(byte_t)keygen_rev]);
			}
		}

		if (name_idx < kPkg2Base.size())
		{
			// tc::Optional<aes128_key_t> package2_key_source;
			//fmt::print("{:s}_key_source\n", kPkg2Base[name_idx]);
			_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:s}", kPkg2Base[name_idx], kKeyStr, kSourceStr), package2_key_source);
		}

		if (name_idx < kTicketCommonKeyBase.size())
		{
			// tc::Optional<aes128_key_t> ticket_titlekek_source;
			//fmt::print("{:s}_source\n", kTicketCommonKeyBase[name_idx]);
			_SAVE_AES128KEY(fmt::format("{:s}_{:s}", kTicketCommonKeyBase[name_idx], kSourceStr), ticket_titlekek_source);
		}

		if (name_idx < kNcaKeyAreaEncKeyBase.size())
		{
			// std::array<tc::Optional<aes128_key_t>, 3> key_area_key_source;

			for (size_t keak_idx = 0; keak_idx < kNcaKeyAreaKeyIndexStr.size(); keak_idx++)
			{
				//fmt::print("{:s}_{:s}_source\n", kNcaKeyAreaEncKeyBase[name_idx], kNcaKeyAreaKeyIndexStr[keak_idx]);
				_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:s}", kNcaKeyAreaEncKeyBase[name_idx], kNcaKeyAreaKeyIndexStr[keak_idx], kSourceStr), key_area_key_source[keak_idx]);
			}
		}
		
		if (name_idx < kKekGenBase.size())
		{
			// tc::Optional<aes128_key_t> aes_kek_generation_source;
			//fmt::print("{:s}_source\n", kKekGenBase[name_idx]);
			_SAVE_AES128KEY(fmt::format("{:s}_{:s}", kKekGenBase[name_idx], kSourceStr), aes_kek_generation_source);
		}

		if (name_idx < kKeyGenBase.size())
		{
			// tc::Optional<aes128_key_t> aes_key_generation_source;
			//fmt::print("{:s}_source\n", kKeyGenBase[name_idx]);
			_SAVE_AES128KEY(fmt::format("{:s}_{:s}", kKeyGenBase[name_idx], kSourceStr), aes_key_generation_source);
		}

		if (name_idx < kContentArchiveHeaderBase.size())
		{
			// tc::Optional<aes128_key_t> nca_header_kek_source;
			//fmt::print("{:s}_kek_source\n", kContentArchiveHeaderBase[name_idx]);
			_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:s}", kContentArchiveHeaderBase[name_idx], kKekStr, kSourceStr), nca_header_kek_source);
		}

		if (name_idx < kContentArchiveHeaderBase.size())
		{
			// tc::Optional<aes128_xtskey_t> nca_header_key_source;
			//fmt::print("{:s}_key_source\n", kContentArchiveHeaderBase[name_idx]);
			_SAVE_AES128XTSKEY(fmt::format("{:s}_{:s}_{:s}", kContentArchiveHeaderBase[name_idx], kKeyStr, kSourceStr), nca_header_key_source);
		}

		/* package1 */ 
		// package1_key_xx
		if (name_idx < kPkg1Base.size())
		{
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				//fmt::print("{:s}_key_{:02x}\n", kPkg1Base[name_idx], keygen_rev);
				_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:02x}", kPkg1Base[name_idx], kKeyStr, keygen_rev), pkg1_key[(byte_t)keygen_rev]);
			}
		}

		/* package2 */
		if (name_idx < kPkg2Base.size())
		{
			// package2_key_xx
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				//fmt::print("{:s}_key_{:02x}\n", kPkg2Base[name_idx], keygen_rev);
				_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:02x}", kPkg2Base[name_idx], kKeyStr, keygen_rev), pkg2_key[(byte_t)keygen_rev]);
			}

			// package2_sign_key
			//fmt::print("{:s}_{:s}_{:s}\n", kPkg2Base[name_idx], kSignKey, kPrivateStr);
			//fmt::print("{:s}_{:s}_{:s}\n", kPkg2Base[name_idx], kSignKey, kModulusStr);
			_SAVE_RSAKEY(fmt::format("{:s}_{:s}", kPkg2Base[name_idx], kSignKey), pkg2_sign_key, 2048);
		}

		/* eticket */
		// ticket common key
		if (name_idx < kTicketCommonKeyBase.size())
		{
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				//fmt::print("{:s}_{:02x}\n", kTicketCommonKeyBase[name_idx], keygen_rev);
				_SAVE_AES128KEY(fmt::format("{:s}_{:02x}", kTicketCommonKeyBase[name_idx], keygen_rev), etik_common_key[(byte_t)keygen_rev]);
			}
		}

		/* NCA keys */
		if (name_idx < kContentArchiveHeaderBase.size())
		{
			// nca header key
			//fmt::print("{:s}_{:s}\n", kContentArchiveHeaderBase[name_idx], kKeyStr);
			_SAVE_AES128XTSKEY(fmt::format("{:s}_{:s}", kContentArchiveHeaderBase[name_idx], kKeyStr), nca_header_key);
			
			// nca header sign0 key (generations)
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				//fmt::print("{:s}_{:s}_{:02x}_{:s}\n", kContentArchiveHeaderBase[name_idx], kSignKey, keygen_rev, kPrivateStr);
				//fmt::print("{:s}_{:s}_{:02x}_{:s}\n", kContentArchiveHeaderBase[name_idx], kSignKey, keygen_rev, kModulusStr);
				_SAVE_RSAKEY(fmt::format("{:s}_{:s}_{:02x}", kContentArchiveHeaderBase[name_idx], kSignKey, keygen_rev), nca_header_sign0_key[(byte_t)keygen_rev], 2048);
			}
			// nca header sign0 key (generation 0)
			//fmt::print("{:s}_{:s}_{:s}\n", kContentArchiveHeaderBase[name_idx], kSignKey, kPrivateStr);
			//fmt::print("{:s}_{:s}_{:s}\n", kContentArchiveHeaderBase[name_idx], kSignKey, kModulusStr);
			_SAVE_RSAKEY(fmt::format("{:s}_{:s}", kContentArchiveHeaderBase[name_idx], kSignKey), nca_header_sign0_key[0], 2048);
			
		}

		// nca body key (unused since prototype format)

		// nca key area encryption keys
		if (name_idx < kNcaKeyAreaEncKeyBase.size())
		{
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				for (size_t keak_idx = 0; keak_idx < kNcaKeyAreaKeyIndexStr.size(); keak_idx++)
				{
					//fmt::print("{:s}_{:s}_{:02x}\n", kNcaKeyAreaEncKeyBase[name_idx], kNcaKeyAreaKeyIndexStr[keak_idx], keygen_rev);
					_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:02x}", kNcaKeyAreaEncKeyBase[name_idx], kNcaKeyAreaKeyIndexStr[keak_idx], keygen_rev), nca_key_area_encryption_key[keak_idx][(byte_t)keygen_rev]);
				}
			}
		}
		// nca key area "hw" encryption keys
		if (name_idx < kNcaKeyAreaEncKeyHwBase.size())
		{
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				for (size_t keak_idx = 0; keak_idx < kNcaKeyAreaKeyIndexStr.size(); keak_idx++)
				{
					//fmt::print("{:s}_{:s}_{:02x}\n", kNcaKeyAreaEncKeyHwBase[name_idx], kNcaKeyAreaKeyIndexStr[keak_idx], keygen_rev);
					_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:02x}", kNcaKeyAreaEncKeyHwBase[name_idx], kNcaKeyAreaKeyIndexStr[keak_idx], keygen_rev), nca_key_area_encryption_key_hw[keak_idx][(byte_t)keygen_rev]);
				}
			}
		}

		/* ACID */
		if (name_idx < kAcidBase.size())
		{
			// acid sign key (generations)
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				//fmt::print("{:s}_{:s}_{:02x}_{:s}\n", kAcidBase[name_idx], kSignKey, keygen_rev, kPrivateStr);
				//fmt::print("{:s}_{:s}_{:02x}_{:s}\n", kAcidBase[name_idx], kSignKey, keygen_rev, kModulusStr);
				_SAVE_RSAKEY(fmt::format("{:s}_{:s}_{:02x}", kAcidBase[name_idx], kSignKey, keygen_rev), acid_sign_key[(byte_t)keygen_rev], 2048);
			}
			// acid sign key (generation 0)
			//fmt::print("{:s}_{:s}_{:s}\n", kAcidBase[name_idx], kSignKey, kPrivateStr);
			//fmt::print("{:s}_{:s}_{:s}\n", kAcidBase[name_idx], kSignKey, kModulusStr);
			_SAVE_RSAKEY(fmt::format("{:s}_{:s}", kAcidBase[name_idx], kSignKey), acid_sign_key[0], 2048);
		}

		/* NRR certificate */
		if (name_idx < kNrrCertBase.size())
		{
			// nrr certificate sign key (generations)
			for (size_t keygen_rev = 0; keygen_rev < kKeyGenerationNum; keygen_rev++)
			{
				//fmt::print("{:s}_{:s}_{:02x}_{:s}\n", kNrrCertBase[name_idx], kSignKey, keygen_rev, kPrivateStr);
				//fmt::print("{:s}_{:s}_{:02x}_{:s}\n", kNrrCertBase[name_idx], kSignKey, keygen_rev, kModulusStr);
				_SAVE_RSAKEY(fmt::format("{:s}_{:s}_{:02x}", kNrrCertBase[name_idx], kSignKey, keygen_rev), nrr_certificate_sign_key[(byte_t)keygen_rev], 2048);
			}
			// nrr certificate sign key (generation 0)
			//fmt::print("{:s}_{:s}_{:s}\n", kNrrCertBase[name_idx], kSignKey, kPrivateStr);
			//fmt::print("{:s}_{:s}_{:s}\n", kNrrCertBase[name_idx], kSignKey, kModulusStr);
			_SAVE_RSAKEY(fmt::format("{:s}_{:s}", kNrrCertBase[name_idx], kSignKey), nrr_certificate_sign_key[0], 2048);
		}

		/* XCI header */
		if (name_idx < kXciHeaderBase.size())
		{
			// xci header key (based on index)
			for (byte_t kek_index = 0; kek_index < 8; kek_index++)
			{
				//fmt::print("{:s}_{:s}_{:02x}\n", kXciHeaderBase[name_idx], kKeyStr, kek_index);
				_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:02x}", kXciHeaderBase[name_idx], kKeyStr, kek_index), xci_header_key[kek_index]);
			}
			// xci header key (old label, prod/dev keys are actually a fake distinction, the are different key indexes available to both?, so select correct index when importing)
			//fmt::print("{:s}_{:s}\n", kXciHeaderBase[name_idx], kKeyStr);
			_SAVE_AES128KEY(fmt::format("{:s}_{:s}", kXciHeaderBase[name_idx], kKeyStr), xci_header_key[isDev ? pie::hac::gc::KekIndex_Dev : pie::hac::gc::KekIndex_Prod]);

			// xci header sign key
			//fmt::print("{:s}_{:s}_{:s}\n", kXciHeaderBase[name_idx], kSignKey, kPrivateStr);
			//fmt::print("{:s}_{:s}_{:s}\n", kXciHeaderBase[name_idx], kSignKey, kModulusStr);
			_SAVE_RSAKEY(fmt::format("{:s}_{:s}", kXciHeaderBase[name_idx], kSignKey), xci_header_sign_key, 2048);
		}

		/* XCI InitialData */
		if (name_idx < kXciInitialDataBase.size())
		{
			// xci initial data key (based on index)
			for (byte_t kek_index = 0; kek_index < 8; kek_index++)
			{
				//fmt::print("{:s}_{:s}_{:02x}\n", kXciInitialDataBase[name_idx], kKekStr, kek_index);
				_SAVE_AES128KEY(fmt::format("{:s}_{:s}_{:02x}", kXciInitialDataBase[name_idx], kKekStr, kek_index), xci_initial_data_kek[kek_index]);
			}
		}

		/* XCI cert */
		if (name_idx < kXciCertBase.size())
		{
			// xci cert sign key
			_SAVE_RSAKEY(fmt::format("{:s}_{:s}", kXciCertBase[name_idx], kSignKey), xci_cert_sign_key, 2048);
		}

		/* PKI */
		if (name_idx < kPkiRootBase.size())
		{
			// tc::Optional<rsa_key_t> pki_root_sign_key;
			//fmt::print("{:s}_{:s}_{:s}\n", kPkiRootBase[name_idx], kSignKey, kPrivateStr);
			//fmt::print("{:s}_{:s}_{:s}\n", kPkiRootBase[name_idx], kSignKey, kModulusStr);
			_SAVE_RSAKEY(fmt::format("{:s}_{:s}", kPkiRootBase[name_idx], kSignKey), pki_root_sign_key, 4096);
		}

		
	}

#undef _SAVE_RSAKEY
#undef _SAVE_AES128XTSKEY
#undef _SAVE_AES128KEY

	// Derive Keys
	for (auto itr = master_key.begin(); itr != master_key.end(); itr++)
	{
		if (aes_kek_generation_source.isSet() && aes_key_generation_source.isSet())
		{
			if (itr->first == 0 && nca_header_kek_source.isSet() && nca_header_key_source.isSet())
			{
				if (nca_header_key.isNull())
				{
					aes128_key_t nca_header_kek_tmp;
					pie::hac::AesKeygen::generateKey(nca_header_kek_tmp.data(), aes_kek_generation_source.get().data(), nca_header_kek_source.get().data(), aes_key_generation_source.get().data(), itr->second.data());
					
					aes128_xtskey_t nca_header_key_tmp;
					pie::hac::AesKeygen::generateKey(nca_header_key_tmp[0].data(), nca_header_key_source.get()[0].data(), nca_header_kek_tmp.data());
					pie::hac::AesKeygen::generateKey(nca_header_key_tmp[1].data(), nca_header_key_source.get()[1].data(), nca_header_kek_tmp.data());

					nca_header_key = nca_header_key_tmp;
				}
			}

			for (size_t keak_idx = 0; keak_idx < pie::hac::nca::kKeyAreaEncryptionKeyNum; keak_idx++)
			{
				if (key_area_key_source[keak_idx].isSet() && nca_key_area_encryption_key[keak_idx].find(itr->first) != nca_key_area_encryption_key[keak_idx].end())
				{
					aes128_key_t nca_key_area_encryption_key_tmp;
					pie::hac::AesKeygen::generateKey(nca_key_area_encryption_key_tmp.data(), aes_kek_generation_source.get().data(), key_area_key_source[keak_idx].get().data(), aes_key_generation_source.get().data(), itr->second.data());
					nca_key_area_encryption_key[keak_idx][itr->first] = nca_key_area_encryption_key_tmp;
				}
			}
		}
		if (ticket_titlekek_source.isSet() && etik_common_key.find(itr->first) == etik_common_key.end())
		{
			aes128_key_t etik_common_key_tmp;
			pie::hac::AesKeygen::generateKey(etik_common_key_tmp.data(), ticket_titlekek_source.get().data(), itr->second.data());
			etik_common_key[itr->first] = etik_common_key_tmp;
		}
		if (package2_key_source.isSet() && pkg2_key.find(itr->first) == pkg2_key.end())
		{
			aes128_key_t pkg2_key_tmp;
			pie::hac::AesKeygen::generateKey(pkg2_key_tmp.data(), package2_key_source.get().data(), itr->second.data());
			pkg2_key[itr->first] = pkg2_key_tmp;
		}
	}

	// Save PKI Root Key
	if (pki_root_sign_key.isSet())
	{
		broadon_signer["Root"] = { tc::ByteData(), pie::hac::es::sign::SIGN_ALGO_RSA4096, pki_root_sign_key.get() };
	}
}

void nstool::KeyBagInitializer::importTitleKeyFile(const tc::io::Path& keyfile_path)
{

}

void nstool::KeyBagInitializer::importCertificateChain(const tc::io::Path& cert_path)
{
	// open cert file
	std::shared_ptr<tc::io::FileStream> certfile_stream;
	try {
		certfile_stream = std::make_shared<tc::io::FileStream>(tc::io::FileStream(cert_path, tc::io::FileMode::Open, tc::io::FileAccess::Read));
	}
	catch (tc::io::FileNotFoundException& e) {
		fmt::print("[WARNING] Failed to open certificate file \"{:s}\" ({:s}).\n", cert_path.to_string(), e.error());
		return;
	}
	
	// check size
	size_t cert_raw_size = tc::io::IOUtil::castInt64ToSize(certfile_stream->length());
	if (cert_raw_size > 0x10000)
	{
		fmt::print("[WARNING] Certificate file \"{:s}\" was too large.\n", cert_path.to_string());
		return;
	}

	// import cert data
	tc::ByteData cert_raw = tc::ByteData(cert_raw_size);
	certfile_stream->seek(0, tc::io::SeekOrigin::Begin);
	certfile_stream->read(cert_raw.data(), cert_raw.size());

	pie::hac::es::SignedData<pie::hac::es::CertificateBody> cert;
	try {
		for (size_t f_pos = 0; f_pos < cert_raw.size(); f_pos += cert.getBytes().size())
		{
			cert.fromBytes(cert_raw.data() + f_pos, cert_raw.size() - f_pos);

			std::string cert_identity = fmt::format("{:s}-{:s}", cert.getBody().getIssuer(), cert.getBody().getSubject());

			switch (cert.getBody().getPublicKeyType()) {
				case pie::hac::es::cert::PublicKeyType::RSA2048:
					broadon_signer[cert_identity] = { cert.getBytes(), pie::hac::es::sign::SIGN_ALGO_RSA2048, cert.getBody().getRsa2048PublicKey() };
					break;
				case pie::hac::es::cert::PublicKeyType::RSA4096:
					broadon_signer[cert_identity] = { cert.getBytes(), pie::hac::es::sign::SIGN_ALGO_RSA4096, cert.getBody().getRsa4096PublicKey() };
					break;
				case pie::hac::es::cert::PublicKeyType::ECDSA240:
					// broadon_signer[cert_identity] = { cert.getBytes(), pie::hac::es::sign::SIGN_ALGO_ECDSA240, cert.getBody().getRsa4096PublicKey() };
					fmt::print("[WARNING] Certificate {:s} will not be imported. ecc233 public keys are not supported yet.\n", cert_identity);
					break;
				default:
					fmt::print("[WARNING] Certificate {:s} will not be imported. Unknown public key type.\n", cert_identity);
			}
		}
	}
	catch (tc::Exception& e) {
		fmt::print("[WARNING] Certificate file \"{:s}\" is corrupted ({:s}).\n", cert_path.to_string(), e.error());
		return;
	}
}

void nstool::KeyBagInitializer::importTicket(const tc::io::Path& tik_path)
{
	// open cert file
	std::shared_ptr<tc::io::FileStream> tik_stream;
	try {
		tik_stream = std::make_shared<tc::io::FileStream>(tc::io::FileStream(tik_path, tc::io::FileMode::Open, tc::io::FileAccess::Read));
	}
	catch (tc::io::FileNotFoundException& e) {
		fmt::print("[WARNING] Failed to open ticket \"{:s}\" ({:s}).\n", tik_path.to_string(), e.error());
		return;
	}

	// check size
	size_t tik_raw_size = tc::io::IOUtil::castInt64ToSize(tik_stream->length());
	if (tik_raw_size > 0x10000)
	{
		fmt::print("[WARNING] Ticket \"{:s}\" was too large.\n", tik_path.to_string());
		return;
	}

	// import cert data
	tc::ByteData tik_raw = tc::ByteData(tik_raw_size);
	tik_stream->seek(0, tc::io::SeekOrigin::Begin);
	tik_stream->read(tik_raw.data(), tik_raw.size());

	pie::hac::es::SignedData<pie::hac::es::TicketBody_V2> tik;
	try {
		// de serialise ticket
		tik.fromBytes(tik_raw.data(), tik_raw.size());
		
		// save rights id
		rights_id_t rights_id;
		memcpy(rights_id.data(), tik.getBody().getRightsId(), rights_id.size());
		
		// check ticket is not personalised
		if (tik.getBody().getTitleKeyEncType() != pie::hac::es::ticket::AES128_CBC)
		{
			fmt::print("[WARNING] Ticket \"{:s}\" will not be imported. Personalised tickets are not supported.\n", tc::cli::FormatUtil::formatBytesAsString(rights_id.data(), rights_id.size(), true, ""));
			return;
		}

		// save enc title key
		aes128_key_t enc_title_key;
		memcpy(enc_title_key.data(), tik.getBody().getEncTitleKey(), enc_title_key.size());

		// save the encrypted title key as the fallback enc content key incase the ticket was malformed and workarounds to decrypt it in isolation fail
		if (fallback_enc_content_key.isNull())
		{
			fallback_enc_content_key = enc_title_key;
		}

		// determine key to decrypt title key
		byte_t common_key_index = tik.getBody().getCommonKeyId();

		// work around for bad scene tickets where they don't set the commonkey id field (detect scene ticket with ffff.... signature)
		if (common_key_index == 0 && *((uint64_t*)tik.getSignature().getSignature().data()) == (uint64_t)0xffffffffffffffff)
		{
			fmt::print("[WARNING] Ticket \"{:s}\" is fake-signed, and NCA decryption may fail if ticket was incorrectly generated.\n", tc::cli::FormatUtil::formatBytesAsString(rights_id.data(), rights_id.size(), true, ""));
			// the keygeneration was included in the rights_id from keygeneration 0x03 and onwards, so in those cases we can copy from there
			if (rights_id[15] >= 0x03)
				common_key_index = rights_id[15];
		}

		// convert key_generation
		common_key_index = pie::hac::AesKeygen::getMasterKeyRevisionFromKeyGeneration(common_key_index);

		if (etik_common_key.find(common_key_index) == etik_common_key.end())
		{
			fmt::print("[WARNING] Ticket \"{:s}\" will not be imported. Could not decrypt title key.\n", tc::cli::FormatUtil::formatBytesAsString(rights_id.data(), rights_id.size(), true, ""));
			return;
		}

		// decrypt title key
		aes128_key_t dec_title_key;
		tc::crypto::DecryptAes128Ecb(dec_title_key.data(), enc_title_key.data(), sizeof(aes128_key_t), etik_common_key[common_key_index].data(), sizeof(aes128_key_t));

		// add to key dict
		external_content_keys[rights_id] = dec_title_key;
		
	}
	catch (tc::Exception& e) {
		fmt::print("[WARNING] Ticket \"{:s}\" is corrupted ({:s}).\n", tik_path.to_string(), e.error());
		return;
	}
}

void nstool::KeyBagInitializer::importKnownKeys(bool isDev)
{
	static const pie::hac::detail::rsa2048_block_t kXciHeaderSignModulus = {
		0x98, 0xC7, 0x26, 0xB6, 0x0D, 0x0A, 0x50, 0xA7, 0x39, 0x21, 0x0A, 0xE3, 0x2F, 0xE4, 0x3E, 0x2E,
		0x5B, 0xA2, 0x86, 0x75, 0xAA, 0x5C, 0xEE, 0x34, 0xF1, 0xA3, 0x3A, 0x7E, 0xBD, 0x90, 0x4E, 0xF7,
		0x8D, 0xFA, 0x17, 0xAA, 0x6B, 0xC6, 0x36, 0x6D, 0x4C, 0x9A, 0x6D, 0x57, 0x2F, 0x80, 0xA2, 0xBC,
		0x38, 0x4D, 0xDA, 0x99, 0xA1, 0xD8, 0xC3, 0xE2, 0x99, 0x79, 0x36, 0x71, 0x90, 0x20, 0x25, 0x9D,
		0x4D, 0x11, 0xB8, 0x2E, 0x63, 0x6B, 0x5A, 0xFA, 0x1E, 0x9C, 0x04, 0xD1, 0xC5, 0xF0, 0x9C, 0xB1,
		0x0F, 0xB8, 0xC1, 0x7B, 0xBF, 0xE8, 0xB0, 0xD2, 0x2B, 0x47, 0x01, 0x22, 0x6B, 0x23, 0xC9, 0xD0,
		0xBC, 0xEB, 0x75, 0x6E, 0x41, 0x7D, 0x4C, 0x26, 0xA4, 0x73, 0x21, 0xB4, 0xF0, 0x14, 0xE5, 0xD9,
		0x8D, 0xB3, 0x64, 0xEE, 0xA8, 0xFA, 0x84, 0x1B, 0xB8, 0xB8, 0x7C, 0x88, 0x6B, 0xEF, 0xCC, 0x97,
		0x04, 0x04, 0x9A, 0x67, 0x2F, 0xDF, 0xEC, 0x0D, 0xB2, 0x5F, 0xB5, 0xB2, 0xBD, 0xB5, 0x4B, 0xDE,
		0x0E, 0x88, 0xA3, 0xBA, 0xD1, 0xB4, 0xE0, 0x91, 0x81, 0xA7, 0x84, 0xEB, 0x77, 0x85, 0x8B, 0xEF,
		0xA5, 0xE3, 0x27, 0xB2, 0xF2, 0x82, 0x2B, 0x29, 0xF1, 0x75, 0x2D, 0xCE, 0xCC, 0xAE, 0x9B, 0x8D,
		0xED, 0x5C, 0xF1, 0x8E, 0xDB, 0x9A, 0xD7, 0xAF, 0x42, 0x14, 0x52, 0xCD, 0xE3, 0xC5, 0xDD, 0xCE,
		0x08, 0x12, 0x17, 0xD0, 0x7F, 0x1A, 0xAA, 0x1F, 0x7D, 0xE0, 0x93, 0x54, 0xC8, 0xBC, 0x73, 0x8A,
		0xCB, 0xAD, 0x6E, 0x93, 0xE2, 0x19, 0x72, 0x6B, 0xD3, 0x45, 0xF8, 0x73, 0x3D, 0x2B, 0x6A, 0x55,
		0xD2, 0x3A, 0x8B, 0xB0, 0x8A, 0x42, 0xE3, 0x3D, 0xF1, 0x92, 0x23, 0x42, 0x2E, 0xBA, 0xCC, 0x9C,
		0x9A, 0xC1, 0xDD, 0x62, 0x86, 0x9C, 0x2E, 0xE1, 0x2D, 0x6F, 0x62, 0x67, 0x51, 0x08, 0x0E, 0xCF
	};

	static const pie::hac::detail::rsa2048_block_t kXciCertSignModulus = {
		0xCD, 0xF3, 0x2C, 0xB0, 0xF5, 0x14, 0x78, 0x34, 0xE5, 0x02, 0xD0, 0x29, 0x6A, 0xA5, 0xFD, 0x97,
		0x6A, 0xE0, 0xB0, 0xBB, 0xB0, 0x3B, 0x1A, 0x80, 0xB7, 0xD7, 0x58, 0x92, 0x79, 0x84, 0xC0, 0x36,
		0xB1, 0x55, 0x23, 0xD8, 0xA5, 0x60, 0x91, 0x26, 0x48, 0x1A, 0x80, 0x4A, 0xEA, 0x00, 0x98, 0x2A,
		0xEC, 0x52, 0x17, 0x72, 0x92, 0x4D, 0xF5, 0x42, 0xA7, 0x8A, 0x6F, 0x7F, 0xD2, 0x48, 0x51, 0x8E,
		0xDF, 0xCB, 0xBF, 0x77, 0xF6, 0x18, 0xBD, 0xE5, 0x00, 0xD9, 0x70, 0x8C, 0xEF, 0x57, 0xB2, 0x96,
		0xD0, 0x36, 0x83, 0x88, 0x9C, 0xC5, 0xFB, 0xA0, 0x33, 0x81, 0xA2, 0x12, 0x23, 0xC6, 0xC7, 0x86,
		0x0A, 0x98, 0x57, 0x4D, 0x2E, 0xB5, 0xAE, 0x64, 0xE4, 0x6F, 0xC2, 0xC5, 0xAC, 0x6A, 0x1D, 0xDB,
		0xA5, 0xAF, 0x12, 0x22, 0xAB, 0x1F, 0x51, 0xC8, 0x0E, 0x0D, 0xC9, 0xF5, 0x03, 0xE8, 0xD2, 0xFC,
		0x84, 0x62, 0x26, 0x55, 0xA4, 0xC3, 0xE2, 0xA8, 0x98, 0x05, 0x67, 0x23, 0xFD, 0xA5, 0x46, 0x40,
		0x78, 0x51, 0x09, 0x3D, 0x91, 0x74, 0xD6, 0xD0, 0x54, 0x23, 0x0D, 0xA0, 0xFB, 0x07, 0xD0, 0xAA,
		0x9D, 0x50, 0x4E, 0x2B, 0x26, 0x9A, 0x14, 0xE5, 0x6C, 0x73, 0x66, 0x24, 0x18, 0xA1, 0x93, 0x9C,
		0x2A, 0x40, 0x40, 0x05, 0x6B, 0xF1, 0x45, 0xDF, 0x22, 0x8B, 0x40, 0x61, 0xA4, 0x11, 0x06, 0x03,
		0xA5, 0x53, 0x84, 0xC0, 0x12, 0xE1, 0x88, 0x9D, 0x55, 0x55, 0x07, 0x40, 0x88, 0x01, 0x8C, 0xAB,
		0xA2, 0xFD, 0xFD, 0x19, 0x48, 0x25, 0xAB, 0x59, 0x59, 0x28, 0x63, 0x68, 0x69, 0x1B, 0x99, 0x73,
		0x8D, 0xAB, 0x5A, 0xFA, 0x71, 0x60, 0x1B, 0x12, 0xE7, 0x99, 0x70, 0xF1, 0x99, 0x2A, 0x50, 0x18,
		0x8B, 0x6B, 0x61, 0x90, 0xE2, 0x7E, 0x8B, 0x90, 0xD4, 0xD5, 0xC0, 0xCB, 0x7C, 0x08, 0x06, 0xD9
	};
	
	/* Keydata for very early beta NCA0 archives' RSA-OAEP. */
	/*
	static const pie::hac::detail::rsa2048_block_t beta_nca0_modulus = {
		0xAD, 0x58, 0xEE, 0x97, 0xF9, 0x47, 0x90, 0x7D, 0xF9, 0x29, 0x5F, 0x1F, 0x39, 0x68, 0xEE, 0x49,
		0x4C, 0x1E, 0x8D, 0x84, 0x91, 0x31, 0x5D, 0xE5, 0x96, 0x27, 0xB2, 0xB3, 0x59, 0x7B, 0xDE, 0xFD,
		0xB7, 0xEB, 0x40, 0xA1, 0xE7, 0xEB, 0xDC, 0x60, 0xD0, 0x3D, 0xC5, 0x50, 0x92, 0xAD, 0x3D, 0xC4,
		0x8C, 0x17, 0xD2, 0x37, 0x66, 0xE3, 0xF7, 0x14, 0x34, 0x38, 0x6B, 0xA7, 0x2B, 0x21, 0x10, 0x9B,
		0x73, 0x49, 0x15, 0xD9, 0x2A, 0x90, 0x86, 0x76, 0x81, 0x6A, 0x10, 0xBD, 0x74, 0xC4, 0x20, 0x55,
		0x25, 0xA8, 0x02, 0xC5, 0xA0, 0x34, 0x36, 0x7B, 0x66, 0x47, 0x2C, 0x7E, 0x47, 0x82, 0xA5, 0xD4,
		0xA3, 0x42, 0x45, 0xE8, 0xFD, 0x65, 0x72, 0x48, 0xA1, 0xB0, 0x44, 0x10, 0xEF, 0xAC, 0x1D, 0x0F,
		0xB5, 0x12, 0x19, 0xA8, 0x41, 0x0B, 0x76, 0x3B, 0xBC, 0xF1, 0x4A, 0x10, 0x46, 0x22, 0xB8, 0xF1,
		0xBC, 0x21, 0x81, 0x69, 0x9B, 0x63, 0x6F, 0xD7, 0xB9, 0x60, 0x2A, 0x9A, 0xE5, 0x2C, 0x47, 0x72,
		0x59, 0x65, 0xA2, 0x21, 0x60, 0xC4, 0xFC, 0xB0, 0xD7, 0x6F, 0x42, 0xC9, 0x0C, 0xF5, 0x76, 0x7D,
		0xF2, 0x5C, 0xE0, 0x80, 0x0F, 0xEE, 0x45, 0x7E, 0x4E, 0x3A, 0x8D, 0x9C, 0x5B, 0x5B, 0xD9, 0xD1,
		0x43, 0x94, 0x2C, 0xC7, 0x2E, 0xB9, 0x4A, 0xE5, 0x3E, 0x15, 0xDD, 0x43, 0x00, 0xF7, 0x78, 0xE7,
		0x7C, 0x39, 0xB0, 0x4D, 0xC5, 0xD1, 0x1C, 0xF2, 0xB4, 0x7A, 0x2A, 0xEA, 0x0A, 0x8E, 0xB9, 0x13,
		0xB4, 0x4F, 0xD7, 0x5B, 0x4D, 0x7B, 0x43, 0xB0, 0x3A, 0x9A, 0x60, 0x22, 0x47, 0x91, 0x78, 0xC7,
		0x10, 0x64, 0xE0, 0x2C, 0x69, 0xD1, 0x66, 0x3C, 0x42, 0x2E, 0xEF, 0x19, 0x21, 0x89, 0x8E, 0xE1,
		0xB0, 0xB4, 0xD0, 0x17, 0xA1, 0x0F, 0x73, 0x98, 0x5A, 0xF6, 0xEE, 0xC0, 0x2F, 0x9E, 0xCE, 0xC5
	};

	static const pie::hac::detail::sha256_hash_t beta_nca0_label_hash = {
		0xE3, 0xB0, 0xC4, 0x42, 0x98, 0xFC, 0x1C, 0x14, 0x9A, 0xFB, 0xF4, 0xC8, 0x99, 0x6F, 0xB9, 0x24,
		0x27, 0xAE, 0x41, 0xE4, 0x64, 0x9B, 0x93, 0x4C, 0xA4, 0x95, 0x99, 0x1B, 0x78, 0x52, 0xB8, 0x55
	};
	*/

	struct sRsaKeyForGeneration {
		byte_t generation;
		pie::hac::detail::rsa2048_block_t modulus;
	};

	static const pie::hac::detail::rsa2048_block_t kProdPackage2HeaderModulus = {
		0x8D, 0x13, 0xA7, 0x77, 0x6A, 0xE5, 0xDC, 0xC0, 0x3B, 0x25, 0xD0, 0x58, 0xE4, 0x20, 0x69, 0x59,
		0x55, 0x4B, 0xAB, 0x70, 0x40, 0x08, 0x28, 0x07, 0xA8, 0xA7, 0xFD, 0x0F, 0x31, 0x2E, 0x11, 0xFE,
		0x47, 0xA0, 0xF9, 0x9D, 0xDF, 0x80, 0xDB, 0x86, 0x5A, 0x27, 0x89, 0xCD, 0x97, 0x6C, 0x85, 0xC5,
		0x6C, 0x39, 0x7F, 0x41, 0xF2, 0xFF, 0x24, 0x20, 0xC3, 0x95, 0xA6, 0xF7, 0x9D, 0x4A, 0x45, 0x74,
		0x8B, 0x5D, 0x28, 0x8A, 0xC6, 0x99, 0x35, 0x68, 0x85, 0xA5, 0x64, 0x32, 0x80, 0x9F, 0xD3, 0x48,
		0x39, 0xA2, 0x1D, 0x24, 0x67, 0x69, 0xDF, 0x75, 0xAC, 0x12, 0xB5, 0xBD, 0xC3, 0x29, 0x90, 0xBE,
		0x37, 0xE4, 0xA0, 0x80, 0x9A, 0xBE, 0x36, 0xBF, 0x1F, 0x2C, 0xAB, 0x2B, 0xAD, 0xF5, 0x97, 0x32,
		0x9A, 0x42, 0x9D, 0x09, 0x8B, 0x08, 0xF0, 0x63, 0x47, 0xA3, 0xE9, 0x1B, 0x36, 0xD8, 0x2D, 0x8A,
		0xD7, 0xE1, 0x54, 0x11, 0x95, 0xE4, 0x45, 0x88, 0x69, 0x8A, 0x2B, 0x35, 0xCE, 0xD0, 0xA5, 0x0B,
		0xD5, 0x5D, 0xAC, 0xDB, 0xAF, 0x11, 0x4D, 0xCA, 0xB8, 0x1E, 0xE7, 0x01, 0x9E, 0xF4, 0x46, 0xA3,
		0x8A, 0x94, 0x6D, 0x76, 0xBD, 0x8A, 0xC8, 0x3B, 0xD2, 0x31, 0x58, 0x0C, 0x79, 0xA8, 0x26, 0xE9,
		0xD1, 0x79, 0x9C, 0xCB, 0xD4, 0x2B, 0x6A, 0x4F, 0xC6, 0xCC, 0xCF, 0x90, 0xA7, 0xB9, 0x98, 0x47,
		0xFD, 0xFA, 0x4C, 0x6C, 0x6F, 0x81, 0x87, 0x3B, 0xCA, 0xB8, 0x50, 0xF6, 0x3E, 0x39, 0x5D, 0x4D,
		0x97, 0x3F, 0x0F, 0x35, 0x39, 0x53, 0xFB, 0xFA, 0xCD, 0xAB, 0xA8, 0x7A, 0x62, 0x9A, 0x3F, 0xF2,
		0x09, 0x27, 0x96, 0x3F, 0x07, 0x9A, 0x91, 0xF7, 0x16, 0xBF, 0xC6, 0x3A, 0x82, 0x5A, 0x4B, 0xCF,
		0x49, 0x50, 0x95, 0x8C, 0x55, 0x80, 0x7E, 0x39, 0xB1, 0x48, 0x05, 0x1E, 0x21, 0xC7, 0x24, 0x4F
	};

	static const std::vector<sRsaKeyForGeneration> kProdNcaHeaderSign0Modulus = 
	{
		{
			0x00, 
			{0xBF, 0xBE, 0x40, 0x6C, 0xF4, 0xA7, 0x80, 0xE9, 0xF0, 0x7D, 0x0C, 0x99, 0x61, 0x1D, 0x77, 0x2F,
			0x96, 0xBC, 0x4B, 0x9E, 0x58, 0x38, 0x1B, 0x03, 0xAB, 0xB1, 0x75, 0x49, 0x9F, 0x2B, 0x4D, 0x58,
			0x34, 0xB0, 0x05, 0xA3, 0x75, 0x22, 0xBE, 0x1A, 0x3F, 0x03, 0x73, 0xAC, 0x70, 0x68, 0xD1, 0x16,
			0xB9, 0x04, 0x46, 0x5E, 0xB7, 0x07, 0x91, 0x2F, 0x07, 0x8B, 0x26, 0xDE, 0xF6, 0x00, 0x07, 0xB2,
			0xB4, 0x51, 0xF8, 0x0D, 0x0A, 0x5E, 0x58, 0xAD, 0xEB, 0xBC, 0x9A, 0xD6, 0x49, 0xB9, 0x64, 0xEF,
			0xA7, 0x82, 0xB5, 0xCF, 0x6D, 0x70, 0x13, 0xB0, 0x0F, 0x85, 0xF6, 0xA9, 0x08, 0xAA, 0x4D, 0x67,
			0x66, 0x87, 0xFA, 0x89, 0xFF, 0x75, 0x90, 0x18, 0x1E, 0x6B, 0x3D, 0xE9, 0x8A, 0x68, 0xC9, 0x26,
			0x04, 0xD9, 0x80, 0xCE, 0x3F, 0x5E, 0x92, 0xCE, 0x01, 0xFF, 0x06, 0x3B, 0xF2, 0xC1, 0xA9, 0x0C,
			0xCE, 0x02, 0x6F, 0x16, 0xBC, 0x92, 0x42, 0x0A, 0x41, 0x64, 0xCD, 0x52, 0xB6, 0x34, 0x4D, 0xAE,
			0xC0, 0x2E, 0xDE, 0xA4, 0xDF, 0x27, 0x68, 0x3C, 0xC1, 0xA0, 0x60, 0xAD, 0x43, 0xF3, 0xFC, 0x86,
			0xC1, 0x3E, 0x6C, 0x46, 0xF7, 0x7C, 0x29, 0x9F, 0xFA, 0xFD, 0xF0, 0xE3, 0xCE, 0x64, 0xE7, 0x35,
			0xF2, 0xF6, 0x56, 0x56, 0x6F, 0x6D, 0xF1, 0xE2, 0x42, 0xB0, 0x83, 0x40, 0xA5, 0xC3, 0x20, 0x2B,
			0xCC, 0x9A, 0xAE, 0xCA, 0xED, 0x4D, 0x70, 0x30, 0xA8, 0x70, 0x1C, 0x70, 0xFD, 0x13, 0x63, 0x29,
			0x02, 0x79, 0xEA, 0xD2, 0xA7, 0xAF, 0x35, 0x28, 0x32, 0x1C, 0x7B, 0xE6, 0x2F, 0x1A, 0xAA, 0x40,
			0x7E, 0x32, 0x8C, 0x27, 0x42, 0xFE, 0x82, 0x78, 0xEC, 0x0D, 0xEB, 0xE6, 0x83, 0x4B, 0x6D, 0x81,
			0x04, 0x40, 0x1A, 0x9E, 0x9A, 0x67, 0xF6, 0x72, 0x29, 0xFA, 0x04, 0xF0, 0x9D, 0xE4, 0xF4, 0x03,}
		},
		{
			0x01, 
			{0xAD, 0xE3, 0xE1, 0xFA, 0x04, 0x35, 0xE5, 0xB6, 0xDD, 0x49, 0xEA, 0x89, 0x29, 0xB1, 0xFF, 0xB6,
			0x43, 0xDF, 0xCA, 0x96, 0xA0, 0x4A, 0x13, 0xDF, 0x43, 0xD9, 0x94, 0x97, 0x96, 0x43, 0x65, 0x48,
			0x70, 0x58, 0x33, 0xA2, 0x7D, 0x35, 0x7B, 0x96, 0x74, 0x5E, 0x0B, 0x5C, 0x32, 0x18, 0x14, 0x24,
			0xC2, 0x58, 0xB3, 0x6C, 0x22, 0x7A, 0xA1, 0xB7, 0xCB, 0x90, 0xA7, 0xA3, 0xF9, 0x7D, 0x45, 0x16,
			0xA5, 0xC8, 0xED, 0x8F, 0xAD, 0x39, 0x5E, 0x9E, 0x4B, 0x51, 0x68, 0x7D, 0xF8, 0x0C, 0x35, 0xC6,
			0x3F, 0x91, 0xAE, 0x44, 0xA5, 0x92, 0x30, 0x0D, 0x46, 0xF8, 0x40, 0xFF, 0xD0, 0xFF, 0x06, 0xD2,
			0x1C, 0x7F, 0x96, 0x18, 0xDC, 0xB7, 0x1D, 0x66, 0x3E, 0xD1, 0x73, 0xBC, 0x15, 0x8A, 0x2F, 0x94,
			0xF3, 0x00, 0xC1, 0x83, 0xF1, 0xCD, 0xD7, 0x81, 0x88, 0xAB, 0xDF, 0x8C, 0xEF, 0x97, 0xDD, 0x1B,
			0x17, 0x5F, 0x58, 0xF6, 0x9A, 0xE9, 0xE8, 0xC2, 0x2F, 0x38, 0x15, 0xF5, 0x21, 0x07, 0xF8, 0x37,
			0x90, 0x5D, 0x2E, 0x02, 0x40, 0x24, 0x15, 0x0D, 0x25, 0xB7, 0x26, 0x5D, 0x09, 0xCC, 0x4C, 0xF4,
			0xF2, 0x1B, 0x94, 0x70, 0x5A, 0x9E, 0xEE, 0xED, 0x77, 0x77, 0xD4, 0x51, 0x99, 0xF5, 0xDC, 0x76,
			0x1E, 0xE3, 0x6C, 0x8C, 0xD1, 0x12, 0xD4, 0x57, 0xD1, 0xB6, 0x83, 0xE4, 0xE4, 0xFE, 0xDA, 0xE9,
			0xB4, 0x3B, 0x33, 0xE5, 0x37, 0x8A, 0xDF, 0xB5, 0x7F, 0x89, 0xF1, 0x9B, 0x9E, 0xB0, 0x15, 0xB2,
			0x3A, 0xFE, 0xEA, 0x61, 0x84, 0x5B, 0x7D, 0x4B, 0x23, 0x12, 0x0B, 0x83, 0x12, 0xF2, 0x22, 0x6B,
			0xB9, 0x22, 0x96, 0x4B, 0x26, 0x0B, 0x63, 0x5E, 0x96, 0x57, 0x52, 0xA3, 0x67, 0x64, 0x22, 0xCA,
			0xD0, 0x56, 0x3E, 0x74, 0xB5, 0x98, 0x1F, 0x0D, 0xF8, 0xB3, 0x34, 0xE6, 0x98, 0x68, 0x5A, 0xAD,}
		},
	};

	static const std::vector<sRsaKeyForGeneration> kProdAcidSignModulus = 
	{
		{
			0x00, 
			{0xDD, 0xC8, 0xDD, 0xF2, 0x4E, 0x6D, 0xF0, 0xCA, 0x9E, 0xC7, 0x5D, 0xC7, 0x7B, 0xAD, 0xFE, 0x7D,
			0x23, 0x89, 0x69, 0xB6, 0xF2, 0x06, 0xA2, 0x02, 0x88, 0xE1, 0x55, 0x91, 0xAB, 0xCB, 0x4D, 0x50,
			0x2E, 0xFC, 0x9D, 0x94, 0x76, 0xD6, 0x4C, 0xD8, 0xFF, 0x10, 0xFA, 0x5E, 0x93, 0x0A, 0xB4, 0x57,
			0xAC, 0x51, 0xC7, 0x16, 0x66, 0xF4, 0x1A, 0x54, 0xC2, 0xC5, 0x04, 0x3D, 0x1B, 0xFE, 0x30, 0x20,
			0x8A, 0xAC, 0x6F, 0x6F, 0xF5, 0xC7, 0xB6, 0x68, 0xB8, 0xC9, 0x40, 0x6B, 0x42, 0xAD, 0x11, 0x21,
			0xE7, 0x8B, 0xE9, 0x75, 0x01, 0x86, 0xE4, 0x48, 0x9B, 0x0A, 0x0A, 0xF8, 0x7F, 0xE8, 0x87, 0xF2,
			0x82, 0x01, 0xE6, 0xA3, 0x0F, 0xE4, 0x66, 0xAE, 0x83, 0x3F, 0x4E, 0x9F, 0x5E, 0x01, 0x30, 0xA4,
			0x00, 0xB9, 0x9A, 0xAE, 0x5F, 0x03, 0xCC, 0x18, 0x60, 0xE5, 0xEF, 0x3B, 0x5E, 0x15, 0x16, 0xFE,
			0x1C, 0x82, 0x78, 0xB5, 0x2F, 0x47, 0x7C, 0x06, 0x66, 0x88, 0x5D, 0x35, 0xA2, 0x67, 0x20, 0x10,
			0xE7, 0x6C, 0x43, 0x68, 0xD3, 0xE4, 0x5A, 0x68, 0x2A, 0x5A, 0xE2, 0x6D, 0x73, 0xB0, 0x31, 0x53,
			0x1C, 0x20, 0x09, 0x44, 0xF5, 0x1A, 0x9D, 0x22, 0xBE, 0x12, 0xA1, 0x77, 0x11, 0xE2, 0xA1, 0xCD,
			0x40, 0x9A, 0xA2, 0x8B, 0x60, 0x9B, 0xEF, 0xA0, 0xD3, 0x48, 0x63, 0xA2, 0xF8, 0xA3, 0x2C, 0x08,
			0x56, 0x52, 0x2E, 0x60, 0x19, 0x67, 0x5A, 0xA7, 0x9F, 0xDC, 0x3F, 0x3F, 0x69, 0x2B, 0x31, 0x6A,
			0xB7, 0x88, 0x4A, 0x14, 0x84, 0x80, 0x33, 0x3C, 0x9D, 0x44, 0xB7, 0x3F, 0x4C, 0xE1, 0x75, 0xEA,
			0x37, 0xEA, 0xE8, 0x1E, 0x7C, 0x77, 0xB7, 0xC6, 0x1A, 0xA2, 0xF0, 0x9F, 0x10, 0x61, 0xCD, 0x7B,
			0x5B, 0x32, 0x4C, 0x37, 0xEF, 0xB1, 0x71, 0x68, 0x53, 0x0A, 0xED, 0x51, 0x7D, 0x35, 0x22, 0xFD,}
		},
		{
			0x01, 
			{0xE7, 0xAA, 0x25, 0xC8, 0x01, 0xA5, 0x14, 0x6B, 0x01, 0x60, 0x3E, 0xD9, 0x96, 0x5A, 0xBF, 0x90,
			0xAC, 0xA7, 0xFD, 0x9B, 0x5B, 0xBD, 0x8A, 0x26, 0xB0, 0xCB, 0x20, 0x28, 0x9A, 0x72, 0x12, 0xF5,
			0x20, 0x65, 0xB3, 0xB9, 0x84, 0x58, 0x1F, 0x27, 0xBC, 0x7C, 0xA2, 0xC9, 0x9E, 0x18, 0x95, 0xCF,
			0xC2, 0x73, 0x2E, 0x74, 0x8C, 0x66, 0xE5, 0x9E, 0x79, 0x2B, 0xB8, 0x07, 0x0C, 0xB0, 0x4E, 0x8E,
			0xAB, 0x85, 0x21, 0x42, 0xC4, 0xC5, 0x6D, 0x88, 0x9C, 0xDB, 0x15, 0x95, 0x3F, 0x80, 0xDB, 0x7A,
			0x9A, 0x7D, 0x41, 0x56, 0x25, 0x17, 0x18, 0x42, 0x4D, 0x8C, 0xAC, 0xA5, 0x7B, 0xDB, 0x42, 0x5D,
			0x59, 0x35, 0x45, 0x5D, 0x8A, 0x02, 0xB5, 0x70, 0xC0, 0x72, 0x35, 0x46, 0xD0, 0x1D, 0x60, 0x01,
			0x4A, 0xCC, 0x1C, 0x46, 0xD3, 0xD6, 0x35, 0x52, 0xD6, 0xE1, 0xF8, 0x3B, 0x5D, 0xEA, 0xDD, 0xB8,
			0xFE, 0x7D, 0x50, 0xCB, 0x35, 0x23, 0x67, 0x8B, 0xB6, 0xE4, 0x74, 0xD2, 0x60, 0xFC, 0xFD, 0x43,
			0xBF, 0x91, 0x08, 0x81, 0xC5, 0x4F, 0x5D, 0x16, 0x9A, 0xC4, 0x9A, 0xC6, 0xF6, 0xF3, 0xE1, 0xF6,
			0x5C, 0x07, 0xAA, 0x71, 0x6C, 0x13, 0xA4, 0xB1, 0xB3, 0x66, 0xBF, 0x90, 0x4C, 0x3D, 0xA2, 0xC4,
			0x0B, 0xB8, 0x3D, 0x7A, 0x8C, 0x19, 0xFA, 0xFF, 0x6B, 0xB9, 0x1F, 0x02, 0xCC, 0xB6, 0xD3, 0x0C,
			0x7D, 0x19, 0x1F, 0x47, 0xF9, 0xC7, 0x40, 0x01, 0xFA, 0x46, 0xEA, 0x0B, 0xD4, 0x02, 0xE0, 0x3D,
			0x30, 0x9A, 0x1A, 0x0F, 0xEA, 0xA7, 0x66, 0x55, 0xF7, 0xCB, 0x28, 0xE2, 0xBB, 0x99, 0xE4, 0x83,
			0xC3, 0x43, 0x03, 0xEE, 0xDC, 0x1F, 0x02, 0x23, 0xDD, 0xD1, 0x2D, 0x39, 0xA4, 0x65, 0x75, 0x03,
			0xEF, 0x37, 0x9C, 0x06, 0xD6, 0xFA, 0xA1, 0x15, 0xF0, 0xDB, 0x17, 0x47, 0x26, 0x4F, 0x49, 0x03}
		},
	};

	static const pie::hac::detail::rsa2048_block_t kDevPackage2HeaderModulus = {
		0xB3, 0x65, 0x54, 0xFB, 0x0A, 0xB0, 0x1E, 0x85, 0xA7, 0xF6, 0xCF, 0x91, 0x8E, 0xBA, 0x96, 0x99,
		0x0D, 0x8B, 0x91, 0x69, 0x2A, 0xEE, 0x01, 0x20, 0x4F, 0x34, 0x5C, 0x2C, 0x4F, 0x4E, 0x37, 0xC7,
		0xF1, 0x0B, 0xD4, 0xCD, 0xA1, 0x7F, 0x93, 0xF1, 0x33, 0x59, 0xCE, 0xB1, 0xE9, 0xDD, 0x26, 0xE6,
		0xF3, 0xBB, 0x77, 0x87, 0x46, 0x7A, 0xD6, 0x4E, 0x47, 0x4A, 0xD1, 0x41, 0xB7, 0x79, 0x4A, 0x38,
		0x06, 0x6E, 0xCF, 0x61, 0x8F, 0xCD, 0xC1, 0x40, 0x0B, 0xFA, 0x26, 0xDC, 0xC0, 0x34, 0x51, 0x83,
		0xD9, 0x3B, 0x11, 0x54, 0x3B, 0x96, 0x27, 0x32, 0x9A, 0x95, 0xBE, 0x1E, 0x68, 0x11, 0x50, 0xA0,
		0x6B, 0x10, 0xA8, 0x83, 0x8B, 0xF5, 0xFC, 0xBC, 0x90, 0x84, 0x7A, 0x5A, 0x5C, 0x43, 0x52, 0xE6,
		0xC8, 0x26, 0xE9, 0xFE, 0x06, 0xA0, 0x8B, 0x53, 0x0F, 0xAF, 0x1E, 0xC4, 0x1C, 0x0B, 0xCF, 0x50,
		0x1A, 0xA4, 0xF3, 0x5C, 0xFB, 0xF0, 0x97, 0xE4, 0xDE, 0x32, 0x0A, 0x9F, 0xE3, 0x5A, 0xAA, 0xB7,
		0x44, 0x7F, 0x5C, 0x33, 0x60, 0xB9, 0x0F, 0x22, 0x2D, 0x33, 0x2A, 0xE9, 0x69, 0x79, 0x31, 0x42,
		0x8F, 0xE4, 0x3A, 0x13, 0x8B, 0xE7, 0x26, 0xBD, 0x08, 0x87, 0x6C, 0xA6, 0xF2, 0x73, 0xF6, 0x8E,
		0xA7, 0xF2, 0xFE, 0xFB, 0x6C, 0x28, 0x66, 0x0D, 0xBD, 0xD7, 0xEB, 0x42, 0xA8, 0x78, 0xE6, 0xB8,
		0x6B, 0xAE, 0xC7, 0xA9, 0xE2, 0x40, 0x6E, 0x89, 0x20, 0x82, 0x25, 0x8E, 0x3C, 0x6A, 0x60, 0xD7,
		0xF3, 0x56, 0x8E, 0xEC, 0x8D, 0x51, 0x8A, 0x63, 0x3C, 0x04, 0x78, 0x23, 0x0E, 0x90, 0x0C, 0xB4,
		0xE7, 0x86, 0x3B, 0x4F, 0x8E, 0x13, 0x09, 0x47, 0x32, 0x0E, 0x04, 0xB8, 0x4D, 0x5B, 0xB0, 0x46,
		0x71, 0xB0, 0x5C, 0xF4, 0xAD, 0x63, 0x4F, 0xC5, 0xE2, 0xAC, 0x1E, 0xC4, 0x33, 0x96, 0x09, 0x7B
	};

	static const std::vector<sRsaKeyForGeneration> kDevNcaHeaderSign0Modulus = 
	{
		{
			0x00, 
			{0xD8, 0xF1, 0x18, 0xEF, 0x32, 0x72, 0x4C, 0xA7, 0x47, 0x4C, 0xB9, 0xEA, 0xB3, 0x04, 0xA8, 0xA4,
			0xAC, 0x99, 0x08, 0x08, 0x04, 0xBF, 0x68, 0x57, 0xB8, 0x43, 0x94, 0x2B, 0xC7, 0xB9, 0x66, 0x49,
			0x85, 0xE5, 0x8A, 0x9B, 0xC1, 0x00, 0x9A, 0x6A, 0x8D, 0xD0, 0xEF, 0xCE, 0xFF, 0x86, 0xC8, 0x5C,
			0x5D, 0xE9, 0x53, 0x7B, 0x19, 0x2A, 0xA8, 0xC0, 0x22, 0xD1, 0xF3, 0x22, 0x0A, 0x50, 0xF2, 0x2B,
			0x65, 0x05, 0x1B, 0x9E, 0xEC, 0x61, 0xB5, 0x63, 0xA3, 0x6F, 0x3B, 0xBA, 0x63, 0x3A, 0x53, 0xF4,
			0x49, 0x2F, 0xCF, 0x03, 0xCC, 0xD7, 0x50, 0x82, 0x1B, 0x29, 0x4F, 0x08, 0xDE, 0x1B, 0x6D, 0x47,
			0x4F, 0xA8, 0xB6, 0x6A, 0x26, 0xA0, 0x83, 0x3F, 0x1A, 0xAF, 0x83, 0x8F, 0x0E, 0x17, 0x3F, 0xFE,
			0x44, 0x1C, 0x56, 0x94, 0x2E, 0x49, 0x83, 0x83, 0x03, 0xE9, 0xB6, 0xAD, 0xD5, 0xDE, 0xE3, 0x2D,
			0xA1, 0xD9, 0x66, 0x20, 0x5D, 0x1F, 0x5E, 0x96, 0x5D, 0x5B, 0x55, 0x0D, 0xD4, 0xB4, 0x77, 0x6E,
			0xAE, 0x1B, 0x69, 0xF3, 0xA6, 0x61, 0x0E, 0x51, 0x62, 0x39, 0x28, 0x63, 0x75, 0x76, 0xBF, 0xB0,
			0xD2, 0x22, 0xEF, 0x98, 0x25, 0x02, 0x05, 0xC0, 0xD7, 0x6A, 0x06, 0x2C, 0xA5, 0xD8, 0x5A, 0x9D,
			0x7A, 0xA4, 0x21, 0x55, 0x9F, 0xF9, 0x3E, 0xBF, 0x16, 0xF6, 0x07, 0xC2, 0xB9, 0x6E, 0x87, 0x9E,
			0xB5, 0x1C, 0xBE, 0x97, 0xFA, 0x82, 0x7E, 0xED, 0x30, 0xD4, 0x66, 0x3F, 0xDE, 0xD8, 0x1B, 0x4B,
			0x15, 0xD9, 0xFB, 0x2F, 0x50, 0xF0, 0x9D, 0x1D, 0x52, 0x4C, 0x1C, 0x4D, 0x8D, 0xAE, 0x85, 0x1E,
			0xEA, 0x7F, 0x86, 0xF3, 0x0B, 0x7B, 0x87, 0x81, 0x98, 0x23, 0x80, 0x63, 0x4F, 0x2F, 0xB0, 0x62,
			0xCC, 0x6E, 0xD2, 0x46, 0x13, 0x65, 0x2B, 0xD6, 0x44, 0x33, 0x59, 0xB5, 0x8F, 0xB9, 0x4A, 0xA9,}
		},
		{
			0x01, 
			{0x9A, 0xBC, 0x88, 0xBD, 0x0A, 0xBE, 0xD7, 0x0C, 0x9B, 0x42, 0x75, 0x65, 0x38, 0x5E, 0xD1, 0x01,
			0xCD, 0x12, 0xAE, 0xEA, 0xE9, 0x4B, 0xDB, 0xB4, 0x5E, 0x36, 0x10, 0x96, 0xDA, 0x3D, 0x2E, 0x66,
			0xD3, 0x99, 0x13, 0x8A, 0xBE, 0x67, 0x41, 0xC8, 0x93, 0xD9, 0x3E, 0x42, 0xCE, 0x34, 0xCE, 0x96,
			0xFA, 0x0B, 0x23, 0xCC, 0x2C, 0xDF, 0x07, 0x3F, 0x3B, 0x24, 0x4B, 0x12, 0x67, 0x3A, 0x29, 0x36,
			0xA3, 0xAA, 0x06, 0xF0, 0x65, 0xA5, 0x85, 0xBA, 0xFD, 0x12, 0xEC, 0xF1, 0x60, 0x67, 0xF0, 0x8F,
			0xD3, 0x5B, 0x01, 0x1B, 0x1E, 0x84, 0xA3, 0x5C, 0x65, 0x36, 0xF9, 0x23, 0x7E, 0xF3, 0x26, 0x38,
			0x64, 0x98, 0xBA, 0xE4, 0x19, 0x91, 0x4C, 0x02, 0xCF, 0xC9, 0x6D, 0x86, 0xEC, 0x1D, 0x41, 0x69,
			0xDD, 0x56, 0xEA, 0x5C, 0xA3, 0x2A, 0x58, 0xB4, 0x39, 0xCC, 0x40, 0x31, 0xFD, 0xFB, 0x42, 0x74,
			0xF8, 0xEC, 0xEA, 0x00, 0xF0, 0xD9, 0x28, 0xEA, 0xFA, 0x2D, 0x00, 0xE1, 0x43, 0x53, 0xC6, 0x32,
			0xF4, 0xA2, 0x07, 0xD4, 0x5F, 0xD4, 0xCB, 0xAC, 0xCA, 0xFF, 0xDF, 0x84, 0xD2, 0x86, 0x14, 0x3C,
			0xDE, 0x22, 0x75, 0xA5, 0x73, 0xFF, 0x68, 0x07, 0x4A, 0xF9, 0x7C, 0x2C, 0xCC, 0xDE, 0x45, 0xB6,
			0x54, 0x82, 0x90, 0x36, 0x1F, 0x2C, 0x51, 0x96, 0xC5, 0x0A, 0x53, 0x5B, 0xF0, 0x8B, 0x4A, 0xAA,
			0x3B, 0x68, 0x97, 0x19, 0x17, 0x1F, 0x01, 0xB8, 0xED, 0xB9, 0x9A, 0x5E, 0x08, 0xC5, 0x20, 0x1E,
			0x6A, 0x09, 0xF0, 0xE9, 0x73, 0xA3, 0xBE, 0x10, 0x06, 0x02, 0xE9, 0xFB, 0x85, 0xFA, 0x5F, 0x01,
			0xAC, 0x60, 0xE0, 0xED, 0x7D, 0xB9, 0x49, 0xA8, 0x9E, 0x98, 0x7D, 0x91, 0x40, 0x05, 0xCF, 0xF9,
			0x1A, 0xFC, 0x40, 0x22, 0xA8, 0x96, 0x5B, 0xB0, 0xDC, 0x7A, 0xF5, 0xB7, 0xE9, 0x91, 0x4C, 0x49,}
		},
	};

	static const std::vector<sRsaKeyForGeneration> kDevAcidSignModulus = 
	{
		{
			0x00, 
			{0xD6, 0x34, 0xA5, 0x78, 0x6C, 0x68, 0xCE, 0x5A, 0xC2, 0x37, 0x17, 0xF3, 0x82, 0x45, 0xC6, 0x89,
			0xE1, 0x2D, 0x06, 0x67, 0xBF, 0xB4, 0x06, 0x19, 0x55, 0x6B, 0x27, 0x66, 0x0C, 0xA4, 0xB5, 0x87,
			0x81, 0x25, 0xF4, 0x30, 0xBC, 0x53, 0x08, 0x68, 0xA2, 0x48, 0x49, 0x8C, 0x3F, 0x38, 0x40, 0x9C,
			0xC4, 0x26, 0xF4, 0x79, 0xE2, 0xA1, 0x85, 0xF5, 0x5C, 0x7F, 0x58, 0xBA, 0xA6, 0x1C, 0xA0, 0x8B,
			0x84, 0x16, 0x14, 0x6F, 0x85, 0xD9, 0x7C, 0xE1, 0x3C, 0x67, 0x22, 0x1E, 0xFB, 0xD8, 0xA7, 0xA5,
			0x9A, 0xBF, 0xEC, 0x0E, 0xCF, 0x96, 0x7E, 0x85, 0xC2, 0x1D, 0x49, 0x5D, 0x54, 0x26, 0xCB, 0x32,
			0x7C, 0xF6, 0xBB, 0x58, 0x03, 0x80, 0x2B, 0x5D, 0xF7, 0xFB, 0xD1, 0x9D, 0xC7, 0xC6, 0x2E, 0x53,
			0xC0, 0x6F, 0x39, 0x2C, 0x1F, 0xA9, 0x92, 0xF2, 0x4D, 0x7D, 0x4E, 0x74, 0xFF, 0xE4, 0xEF, 0xE4,
			0x7C, 0x3D, 0x34, 0x2A, 0x71, 0xA4, 0x97, 0x59, 0xFF, 0x4F, 0xA2, 0xF4, 0x66, 0x78, 0xD8, 0xBA,
			0x99, 0xE3, 0xE6, 0xDB, 0x54, 0xB9, 0xE9, 0x54, 0xA1, 0x70, 0xFC, 0x05, 0x1F, 0x11, 0x67, 0x4B,
			0x26, 0x8C, 0x0C, 0x3E, 0x03, 0xD2, 0xA3, 0x55, 0x5C, 0x7D, 0xC0, 0x5D, 0x9D, 0xFF, 0x13, 0x2F,
			0xFD, 0x19, 0xBF, 0xED, 0x44, 0xC3, 0x8C, 0xA7, 0x28, 0xCB, 0xE5, 0xE0, 0xB1, 0xA7, 0x9C, 0x33,
			0x8D, 0xB8, 0x6E, 0xDE, 0x87, 0x18, 0x22, 0x60, 0xC4, 0xAE, 0xF2, 0x87, 0x9F, 0xCE, 0x09, 0x5C,
			0xB5, 0x99, 0xA5, 0x9F, 0x49, 0xF2, 0xD7, 0x58, 0xFA, 0xF9, 0xC0, 0x25, 0x7D, 0xD6, 0xCB, 0xF3,
			0xD8, 0x6C, 0xA2, 0x69, 0x91, 0x68, 0x73, 0xB1, 0x94, 0x6F, 0xA3, 0xF3, 0xB9, 0x7D, 0xF8, 0xE0,
			0x72, 0x9E, 0x93, 0x7B, 0x7A, 0xA2, 0x57, 0x60, 0xB7, 0x5B, 0xA9, 0x84, 0xAE, 0x64, 0x88, 0x69}
		},
		{
			0x01, 
			{0xBC, 0xA5, 0x6A, 0x7E, 0xEA, 0x38, 0x34, 0x62, 0xA6, 0x10, 0x18, 0x3C, 0xE1, 0x63, 0x7B, 0xF0,
			0xD3, 0x08, 0x8C, 0xF5, 0xC5, 0xC4, 0xC7, 0x93, 0xE9, 0xD9, 0xE6, 0x32, 0xF3, 0xA0, 0xF6, 0x6E,
			0x8A, 0x98, 0x76, 0x47, 0x33, 0x47, 0x65, 0x02, 0x70, 0xDC, 0x86, 0x5F, 0x3D, 0x61, 0x5A, 0x70,
			0xBC, 0x5A, 0xCA, 0xCA, 0x50, 0xAD, 0x61, 0x7E, 0xC9, 0xEC, 0x27, 0xFF, 0xE8, 0x64, 0x42, 0x9A,
			0xEE, 0xBE, 0xC3, 0xD1, 0x0B, 0xC0, 0xE9, 0xBF, 0x83, 0x8D, 0xC0, 0x0C, 0xD8, 0x00, 0x5B, 0x76,
			0x90, 0xD2, 0x4B, 0x30, 0x84, 0x35, 0x8B, 0x1E, 0x20, 0xB7, 0xE4, 0xDC, 0x63, 0xE5, 0xDF, 0xCD,
			0x00, 0x5F, 0x81, 0x5F, 0x67, 0xC5, 0x8B, 0xDF, 0xFC, 0xE1, 0x37, 0x5F, 0x07, 0xD9, 0xDE, 0x4F,
			0xE6, 0x7B, 0xF1, 0xFB, 0xA1, 0x5A, 0x71, 0x40, 0xFE, 0xBA, 0x1E, 0xAE, 0x13, 0x22, 0xD2, 0xFE,
			0x37, 0xA2, 0xB6, 0x8B, 0xAB, 0xEB, 0x84, 0x81, 0x4E, 0x7C, 0x1E, 0x02, 0xD1, 0xFB, 0xD7, 0x5D,
			0x11, 0x84, 0x64, 0xD2, 0x4D, 0xBB, 0x50, 0x00, 0x67, 0x54, 0xE2, 0x77, 0x89, 0xBA, 0x0B, 0xE7,
			0x05, 0x57, 0x9A, 0x22, 0x5A, 0xEC, 0x76, 0x1C, 0xFD, 0xE8, 0xA8, 0x18, 0x16, 0x41, 0x65, 0x03,
			0xFA, 0xC4, 0xA6, 0x31, 0x5C, 0x1A, 0x7F, 0xAB, 0x11, 0xC8, 0x4A, 0x99, 0xB9, 0xE6, 0xCF, 0x62,
			0x21, 0xA6, 0x72, 0x47, 0xDB, 0xBA, 0x96, 0x26, 0x4E, 0x2E, 0xD4, 0x8C, 0x46, 0xD6, 0xA7, 0x1A,
			0x6C, 0x32, 0xA7, 0xDF, 0x85, 0x1C, 0x03, 0xC3, 0x6D, 0xA9, 0xE9, 0x68, 0xF4, 0x17, 0x1E, 0xB2,
			0x70, 0x2A, 0xA1, 0xE5, 0xE1, 0xF3, 0x8F, 0x6F, 0x63, 0xAC, 0xEB, 0x72, 0x0B, 0x4C, 0x4A, 0x36,
			0x3C, 0x60, 0x91, 0x9F, 0x6E, 0x1C, 0x71, 0xEA, 0xD0, 0x78, 0x78, 0xA0, 0x2E, 0xC6, 0x32, 0x6B}
		},
	};

	struct sBroadOnRsaKeyAndCert
	{
		std::string issuer;
		pie::hac::es::sign::SignatureAlgo key_type;
		tc::ByteData modulus;
		tc::ByteData certificate;
	};

	static const std::vector<sBroadOnRsaKeyAndCert> kProdBroadOnRsaKeyAndCert = 
	{
		{
			"Root",
			pie::hac::es::sign::SIGN_ALGO_RSA4096,
			tc::cli::FormatUtil::hexStringToBytes("F8246C58BAE7500301FBB7C2EBE0010571DA922378F0514EC0031DD0D21ED3D07EFC852069B5DE9BB951A8BC90A244926D379295AE9436AAA6A302510C7B1DEDD5FB20869D7F3016F6BE65D383A16DB3321B95351890B17002937EE193F57E99A2474E9D3824C7AEE38541F567E7518C7A0E38E7EBAF41191BCFF17B42A6B4EDE6CE8DE7318F7F5204B3990E226745AFD485B24493008B08C7F6B7E56B02B3E8FE0C9D859CB8B68223B8AB27EE5F6538078B2DB91E2A153E85818072A23B6DD93281054F6FB0F6F5AD283ECA0B7AF35455E03DA7B68326F3EC834AF314048AC6DF20D28508673CAB62A2C7BC131A533E0B66806B1C30664B372331BDC4B0CAD8D11EE7BBD9285548AAEC1F66E821B3C8A0476900C5E688E80CCE3C61D69CBBA137C6604F7A72DD8C7B3E3D51290DAA6A597B081F9D3633A3467A356109ACA7DD7D2E2FB2C1AEB8E20F4892D8B9F8B46F4E3C11F4F47D8B757DFEFEA3899C33595C5EFDEBCBABE8413E3A9A803C69356EB2B2AD5CC4C858455EF5F7B30644B47C64068CDF809F76025A2DB446E03D7CF62F34E702457B02A4CF5D9DD53CA53A7CA629788C67CA08BFECCA43A957AD16C94E1CD875CA107DCE7E0118F0DF6BFEE51DDBD991C26E60CD4858AA592C820075F29F526C917C6FE5403EA7D4A50CEC3B7384DE886E82D2EB4D4E42B5F2B149A81EA7CE7144DC2994CFC44E1F91CBD495"),
			tc::ByteData()
		},
		{
			"Root-CA00000003",
			pie::hac::es::sign::SIGN_ALGO_RSA2048,
			tc::cli::FormatUtil::hexStringToBytes("B279C9E2EEE121C6EAF44FF639F88F078B4B77ED9F9560B0358281B50E55AB721115A177703C7A30FE3AE9EF1C60BC1D974676B23A68CC04B198525BC968F11DE2DB50E4D9E7F071E562DAE2092233E9D363F61DD7C19FF3A4A91E8F6553D471DD7B84B9F1B8CE7335F0F5540563A1EAB83963E09BE901011F99546361287020E9CC0DAB487F140D6626A1836D27111F2068DE4772149151CF69C61BA60EF9D949A0F71F5499F2D39AD28C7005348293C431FFBD33F6BCA60DC7195EA2BCC56D200BAF6D06D09C41DB8DE9C720154CA4832B69C08C69CD3B073A0063602F462D338061A5EA6C915CD5623579C3EB64CE44EF586D14BAAA8834019B3EEBEED379"),
			tc::cli::FormatUtil::hexStringToBytes("00010003704138EFBBBDA16A987DD901326D1C9459484C88A2861B91A312587AE70EF6237EC50E1032DC39DDE89A96A8E859D76A98A6E7E36A0CFE352CA893058234FF833FCB3B03811E9F0DC0D9A52F8045B4B2F9411B67A51C44B5EF8CE77BD6D56BA75734A1856DE6D4BED6D3A242C7C8791B3422375E5C779ABF072F7695EFA0F75BCB83789FC30E3FE4CC8392207840638949C7F688565F649B74D63D8D58FFADDA571E9554426B1318FC468983D4C8A5628B06B6FC5D507C13E7A18AC1511EB6D62EA5448F83501447A9AFB3ECC2903C9DD52F922AC9ACDBEF58C6021848D96E208732D3D1D9D9EA440D91621C7A99DB8843C59C1F2E2C7D9B577D512C166D6F7E1AAD4A774A37447E78FE2021E14A95D112A068ADA019F463C7A55685AABB6888B9246483D18B9C806F474918331782344A4B8531334B26303263D9D2EB4F4BB99602B352F6AE4046C69A5E7E8E4A18EF9BC0A2DED61310417012FD824CC116CFB7C4C1F7EC7177A17446CBDE96F3EDD88FCD052F0B888A45FDAF2B631354F40D16E5FA9C2C4EDA98E798D15E6046DC5363F3096B2C607A9D8DD55B1502A6AC7D3CC8D8C575998E7D796910C804C495235057E91ECD2637C9C1845151AC6B9A0490AE3EC6F47740A0DB0BA36D075956CEE7354EA3E9A4F2720B26550C7D394324BC0CB7E9317D8A8661F42191FF10B08256CE3FD25B745E5194906B4D61CB4C2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526F6F7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001434130303030303030330000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007BE8EF6CB279C9E2EEE121C6EAF44FF639F88F078B4B77ED9F9560B0358281B50E55AB721115A177703C7A30FE3AE9EF1C60BC1D974676B23A68CC04B198525BC968F11DE2DB50E4D9E7F071E562DAE2092233E9D363F61DD7C19FF3A4A91E8F6553D471DD7B84B9F1B8CE7335F0F5540563A1EAB83963E09BE901011F99546361287020E9CC0DAB487F140D6626A1836D27111F2068DE4772149151CF69C61BA60EF9D949A0F71F5499F2D39AD28C7005348293C431FFBD33F6BCA60DC7195EA2BCC56D200BAF6D06D09C41DB8DE9C720154CA4832B69C08C69CD3B073A0063602F462D338061A5EA6C915CD5623579C3EB64CE44EF586D14BAAA8834019B3EEBEED3790001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			"Root-CA00000003-XS00000020",
			pie::hac::es::sign::SIGN_ALGO_RSA2048,
			tc::cli::FormatUtil::hexStringToBytes("D21D3CE67C1069DA049D5E5310E76B907E18EEC80B337C4723E339573F4C664907DB2F0832D03DF5EA5F160A4AF24100D71AFAC2E3AE75AFA1228012A9A21616597DF71EAFCB65941470D1B40F5EF83A597E179FCB5B57C2EE17DA3BC3769864CB47856767229D67328141FC9AB1DF149E0C5C15AEB80BC58FC71BE18966642D68308B506934B8EF779F78E4DDF30A0DCF93FCAFBFA131A8839FD641949F47EE25CEECF814D55B0BE6E5677C1EFFEC6F29871EF29AA3ED9197B0D83852E050908031EF1ABBB5AFC8B3DD937A076FF6761AB362405C3F7D86A3B17A6170A659C16008950F7F5E06A5DE3E5998895EFA7DEEA060BE9575668F78AB1907B3BA1B7D"),
			tc::cli::FormatUtil::hexStringToBytes("00010004969FE8288DA6B9DD52C7BD63642A4A9AE5F053ECCB93613FDA37992087BD9199DA5E6797618D77098133FD5B05CD8288139E2E975CD2608003878CDAF020F51A0E5B7692780845561B31C61808E8A47C3462224D94F736E9A14E56ACBF71B7F11BBDEE38DDB846D6BD8F0AB4E4948C5434EAF9BF26529B7EB83671D3CE60A6D7A850DBE6801EC52A7B7A3E5A27BC675BA3C53377CFC372EBCE02062F59F37003AA23AE35D4880E0E4B69F982FB1BAC806C2F75BA29587F2815FD7783998C354D52B19E3FAD9FBEF444C48579288DB0978116AFC82CE54DACB9ED7E1BFD50938F22F85EECF3A4F426AE5FEB15B72F022FB36ECCE9314DAD131429BFC9675F58EE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526F6F742D4341303030303030303300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015853303030303030323000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D21D3CE67C1069DA049D5E5310E76B907E18EEC80B337C4723E339573F4C664907DB2F0832D03DF5EA5F160A4AF24100D71AFAC2E3AE75AFA1228012A9A21616597DF71EAFCB65941470D1B40F5EF83A597E179FCB5B57C2EE17DA3BC3769864CB47856767229D67328141FC9AB1DF149E0C5C15AEB80BC58FC71BE18966642D68308B506934B8EF779F78E4DDF30A0DCF93FCAFBFA131A8839FD641949F47EE25CEECF814D55B0BE6E5677C1EFFEC6F29871EF29AA3ED9197B0D83852E050908031EF1ABBB5AFC8B3DD937A076FF6761AB362405C3F7D86A3B17A6170A659C16008950F7F5E06A5DE3E5998895EFA7DEEA060BE9575668F78AB1907B3BA1B7D0001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			"Root-CA00000003-XS00000022",
			pie::hac::es::sign::SIGN_ALGO_RSA2048,
			tc::cli::FormatUtil::hexStringToBytes("E29775264ADC30C0FDE2DEFCFBBAC406A3B1C2ADDC2644C4C3E46DAD11E4F1ED7BC8B6E8CDBBE87E01020DF807520CE8A8F88BB53BE82CAFF4A1AF7FC5CD69EB34E24BEA74781203B611D09EBF56F82E3F21A494549F407FABA948545B34B64F487E1F27B031A83D337CE40496A3034AC6A2DB9E9353A1967EC7A07A4B3672B5B3F7934FF166D90EC131D8A75DC925ED629F8381A586589A82790489D4BF170F29F8E4BE50811ECBA9564D5517362D8DE777B01FC0A0AD8DED692CEAFD028A468CD6A6BF18A2767801AF8BB954EDB4DA3CED78337F3E9B6A1602B94752C85A53993678FDFA0300A4200CA752FA0D94E5A4B74B726FB61876146E49EC148508F5"),
			tc::cli::FormatUtil::hexStringToBytes("0001000458C7FFCDB0A1758925286C3C5029942683A8ED614A4E5C24EECE90548F99A0E59429C3D7D9CA37910CC1F5974E3AA2D7438627FBE456C9C830E5BF5B4440013CD41AA6F0AE02307E3EDEF3EDE0E6404A87234786FED37878F4BF4D964C2290C66AF167AC94869DC2F8378FA3FE0B764F776F9CE479B9E7A4EAE77FCA924B84035C9C06075F5F23BBF3A202AC1AF6A640C62BEEE4603925534783642663238A803D5FC87C5BEA58E09B0669CE9273509A87FACEDA94333FC6264D095708C18F9A50963F0E02A0771AEBC7174D4A89BE158C6CF407BD11658363E924F2808B15C7FE00267565CBD386E576540C906F9B2FFB3AFC64BA1198FA711A48F107E6A9AD000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526F6F742D4341303030303030303300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015853303030303030323200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000E29775264ADC30C0FDE2DEFCFBBAC406A3B1C2ADDC2644C4C3E46DAD11E4F1ED7BC8B6E8CDBBE87E01020DF807520CE8A8F88BB53BE82CAFF4A1AF7FC5CD69EB34E24BEA74781203B611D09EBF56F82E3F21A494549F407FABA948545B34B64F487E1F27B031A83D337CE40496A3034AC6A2DB9E9353A1967EC7A07A4B3672B5B3F7934FF166D90EC131D8A75DC925ED629F8381A586589A82790489D4BF170F29F8E4BE50811ECBA9564D5517362D8DE777B01FC0A0AD8DED692CEAFD028A468CD6A6BF18A2767801AF8BB954EDB4DA3CED78337F3E9B6A1602B94752C85A53993678FDFA0300A4200CA752FA0D94E5A4B74B726FB61876146E49EC148508F50001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			"Root-CA00000003-XS00000024",
			pie::hac::es::sign::SIGN_ALGO_RSA2048,
			tc::cli::FormatUtil::hexStringToBytes("C694562BBDC74E83069876608EAD1EE7B1BC715036E9A6BDF58A6D22FD660ABD9CF360AA893D7746C92C5B9D20E480EAD1387786739956E060EBA79BD6ED7C06B2FCC6DBC1734ED12999AFEE5396FEE722FE3B96846D903F00A32671AC0CEDAAAB0C933C950304650A76152ED1B69547031793755599939B42F075CDF137F8C16D35870DE90D1BACBDB4B746F814AED0D3CB7F7C1B789A1FDF9947717B641BA972A6460D3258F5561CAA1D8E20085E8E3B9EBC92C9B6DCBB872A2AE02D74577F65EFA5AAFF29FD52EAA400D1408B2815C5C96CD2B54DF0F6708A755FB1DFA694A7794C4A0422F1BF8FAFE9E6870578133D50FD3D5356506CFCEC94EF79D6B639"),
			tc::cli::FormatUtil::hexStringToBytes("000100046EEED0424FF97D659DA43F85DF01E0997BA1FD1593997145BDE95703AABBDB7EFDE315F8CFE8AEC0F710FFF002938AEF8CEF7EBF90F725B6AC4EDA66DCF85132435E974DDBBE8F8C725CD114CE38C83404DFC0123BB4137C676C5C86EB4E211B7C35A03AB0C7E7637F1BF2486FDF0A5CCE5B047483841B5EA6BDC09AE770951ACA79EFB5497C46750585CF6C3FE4159ACE1CDFAB1BA8C00AB2446B57383F2F063344052E48E1557BD60BF973B252AC5AB4F5A12323AFCC1B06718775F3EDA4DD580A47A04D8063844235DC35D21A4FDED5A44EA401519920B73D15C66FDDF9F8286CF9122795EB9D5EA95C6E51603F6E62AA1631549EBE9E272B4BC3AEBC0D89000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526F6F742D4341303030303030303300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015853303030303030323400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C694562BBDC74E83069876608EAD1EE7B1BC715036E9A6BDF58A6D22FD660ABD9CF360AA893D7746C92C5B9D20E480EAD1387786739956E060EBA79BD6ED7C06B2FCC6DBC1734ED12999AFEE5396FEE722FE3B96846D903F00A32671AC0CEDAAAB0C933C950304650A76152ED1B69547031793755599939B42F075CDF137F8C16D35870DE90D1BACBDB4B746F814AED0D3CB7F7C1B789A1FDF9947717B641BA972A6460D3258F5561CAA1D8E20085E8E3B9EBC92C9B6DCBB872A2AE02D74577F65EFA5AAFF29FD52EAA400D1408B2815C5C96CD2B54DF0F6708A755FB1DFA694A7794C4A0422F1BF8FAFE9E6870578133D50FD3D5356506CFCEC94EF79D6B6390001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		}
	};

	static const std::vector<sBroadOnRsaKeyAndCert> kDevBroadOnRsaKeyAndCert = 
	{
		{
			"Root",
			pie::hac::es::sign::SIGN_ALGO_RSA4096,
			tc::cli::FormatUtil::hexStringToBytes("D01FE100D43556B24B56DAE971B5A5D384B93003BE1BBF28A2305B060645467D5B0251D2561A274F9E9F9CEC646150AB3D2AE3366866ACA4BAE81AE3D79AA6B04A8BCBA7E6FB648945EBDFDB85BA091FD7D114B5A3A780E3A22E6ECD87B5A4C6F910E4032208814B0CEEA1A17DF739695F617EF63528DB949637A056037F7B32413895C0A8F1982E1565E38EEDC22E590EE2677B8609F48C2E303FBC405CAC18042F822084E4936803DA7F41349248562B8EE12F78F803246330BC7BE7EE724AF458A472E7AB46A1A7C10C2F18FA07C3DDD89806A11C9CC130B247A33C8D47DE67F29E5577B11C43493D5BBA7634A7E4E71531B7DF5981FE24A114554CBD8F005CE1DB35085CCFC77806B6DE254068A26CB5492D4580438FE1E5A9ED75C5ED451DCE789439CCC3BA28A2312A1B8719EF0F73B713950C02591A7462A607F37C0AA7A18FA943A36D752A5F4192F0136100AA9CB41BBE14BEB1F9FC692FDFA09446DE5A9DDE2CA5F68C1C0C21429287CB2DAAA3D263752F73E09FAF4479D2817429F69800AFDE6B592DC19882BDF581CCABF2CB91029EF35C4CFDBBFF49C1FA1B2FE31DE7A560ECB47EBCFE32425B956F81B69917487E3B789151DB2E78B1FD2EBE7E626B3EA165B4FB00CCB751AF507329C4A3939EA6DD9C50A0E7386B0145796B41AF61F78555944F3BC22DC3BD0D00F8798A42B1AAA08320659AC7395AB4F329"),
			tc::ByteData()
		},
		{
			"Root-CA00000004",
			pie::hac::es::sign::SIGN_ALGO_RSA2048,
			tc::cli::FormatUtil::hexStringToBytes("C9CC2DC4DF2930E4DF3F8C70A078948775AD5E9AA604C5B4D8EAFF2AA1D214676564EFCA28CC00154554A1A3EA1379E9E6CAACED1593FE88D89AC6B8ACCCAB6E207CEB7CCA29809E2980440662B7D4382A15DA43085745A9AAE59AA05BDB32F66869A2DD4295386C87ECDD3508A2CF60D01E23EC2FE698F470D6001549A2F06759131E534C7006057DEF1D18A83F0AC79CFE80FF5A91F2BED4A0837061190A0329902165403C9A908FB615739F3CE33BF1BAEA16C25BCED7963FACC9D24D9C0AD76FC020B2C4B84C10A741A2CC7D9BAC3AACCCA3529BAC316A9AA75D2A26C7D7D288CBA466C5FE5F454AE679744A90A15772DB3B0E47A49AF031D16DBEAB332B"),
			tc::cli::FormatUtil::hexStringToBytes("000100031949429D1E58A62E7E8B56D1B76AE302FD8B97491F778745F75388C4DD0BEB1DF122FB9642151497764A53CF78151845E42CA8FDE486FD2A4F53F8A1BA008A7485FF73B3BF7E3C980729D0656B693219ADE835EB5FFFFCCB7CBB5E307FE0688B888EF2D2053FB7E791E985FD15EF10D79CCA88D6BB15E8E4714A98EE09BF7B8AF053232B6450E6D5FDFFC20A6D1EA6A23812E1014525D56D4082703B86986959A73CD1A14364D2C2DAEA96B095F76C46E4FF4155465E70EF1ED31053D97011E010CC93E7914013687FA3A802996D1E557B1CCC7A7E8F5865C1742E28E26DEF38A93AB5D82D43ECCCBF0BEF22E1FD57E2864333582FEDEABC012F986DDFC3E9447973470308455BDC57AA170B84427F73A29B48F6DA135F66C745C142A84AFB0E6A5EED85D7B9719936F8CE2B621F395F40DC03BEF8854C1117FF0C128641CC7843B97B4346DB226F6026ACB56C278B8E0EA79A2D65EF798E1078AD80ED4B9604D2F08B2CD64A23A3DB270833B402F80851F35BED3EE4577C6660FBF16D9413E09C917A49D42C6DA375BC27F0230DB98F8973AB027B522CD57EC03D25E8B3FC3494C97FB108FE18C68A4336E46C26B6F280D27E34BE287C3E4687BC9D776B76D928D1B6352EC0347D7294AA9360268D26F5F652064AF240D7D00C7C5EA3C32DE62D9B5C4B4CAB6FD7BD371D57C2166095910E4AD8E9ED181EF761936153892D77000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526F6F74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014341303030303030303400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000081122A46C9CC2DC4DF2930E4DF3F8C70A078948775AD5E9AA604C5B4D8EAFF2AA1D214676564EFCA28CC00154554A1A3EA1379E9E6CAACED1593FE88D89AC6B8ACCCAB6E207CEB7CCA29809E2980440662B7D4382A15DA43085745A9AAE59AA05BDB32F66869A2DD4295386C87ECDD3508A2CF60D01E23EC2FE698F470D6001549A2F06759131E534C7006057DEF1D18A83F0AC79CFE80FF5A91F2BED4A0837061190A0329902165403C9A908FB615739F3CE33BF1BAEA16C25BCED7963FACC9D24D9C0AD76FC020B2C4B84C10A741A2CC7D9BAC3AACCCA3529BAC316A9AA75D2A26C7D7D288CBA466C5FE5F454AE679744A90A15772DB3B0E47A49AF031D16DBEAB332B0001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			"Root-CA00000004-XS00000020",
			pie::hac::es::sign::SIGN_ALGO_RSA2048,
			tc::cli::FormatUtil::hexStringToBytes("BA278428765D879A7F215404C6EE4E0A0D3F66C33BC7F8A32FD898E52CB7B63443CED8B00527D89DEDC6BBF60AD1C5C9923021DD555F9BAD4BE0C0C406D3702915E5B34AC2D2ABE503C32A3A23B43834C9157B9A0AF2E4E9C03BEDE2B4C115F5353DFC66BD04A6C079970E38CBDD5A50A2B98FF2D765FCF83381E9E0E849C3573578378FF65951613E95F75EE8EF26183A40AAE4A76D7384EA478D2CDCE80FBA0321A6BF8D69983C3AA7AE5443B72BFE410BF1323CBD88C3560EA13D17D38A2E34041DE7AAF389DE4375225CA87EE349C760C7D99BE7E737C6261CC74E25AE46527AC9619F939057088D7435A6DE7B25AB82DD5410F2579CAEF1491A909D302B"),
			tc::cli::FormatUtil::hexStringToBytes("00010004603483F7F4EF3C863FF7B46821E9D83983EFB0BA29C45B10DFB2E8A268AE06084DFEB0B9680B6D40D6DF82CAE7D651E28F31364F5AB567DD9DCCFCBB5EFF8F1CEA92489C046E8BED2AF0D7F9CA0BD50F683633D681B08D1AF417D7B7F8762AD88E3AF0D1C45DAC5407B9D8F24F167AEDC7C5DBCF4E0E176EC341D4F9BA8ADFE749CF37F45688653886566A9045ED89AD353DD289E32631867BDFD7FC67738BDF0E1E858F3BF9DEE25B02206F0B7FFB61F866DA4D862D77DDBDA9668BB61CBDEFACB2583CE5C9FAB22FC90EF8EB06954743E5A32A37A3513C6C795BC8E0C65E2F170B435A8C447765381C4050427F88E9828E6E94144D28441C7F9C7F6D92FE5B000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526F6F742D4341303030303030303400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015853303030303030323000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BA278428765D879A7F215404C6EE4E0A0D3F66C33BC7F8A32FD898E52CB7B63443CED8B00527D89DEDC6BBF60AD1C5C9923021DD555F9BAD4BE0C0C406D3702915E5B34AC2D2ABE503C32A3A23B43834C9157B9A0AF2E4E9C03BEDE2B4C115F5353DFC66BD04A6C079970E38CBDD5A50A2B98FF2D765FCF83381E9E0E849C3573578378FF65951613E95F75EE8EF26183A40AAE4A76D7384EA478D2CDCE80FBA0321A6BF8D69983C3AA7AE5443B72BFE410BF1323CBD88C3560EA13D17D38A2E34041DE7AAF389DE4375225CA87EE349C760C7D99BE7E737C6261CC74E25AE46527AC9619F939057088D7435A6DE7B25AB82DD5410F2579CAEF1491A909D302B0001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			"Root-CA00000004-XS00000021",
			pie::hac::es::sign::SIGN_ALGO_RSA2048,
			tc::cli::FormatUtil::hexStringToBytes("CA303087732E88FB2736A4644B6A84DF02393786EBE3DBE914F92224126AB3C38D7CA67322B7D3107B9AC0E00AED9AF13DEDDC62BCB8AC889A47B07196B45BC97AC5DD333CC63E872E30CDB52BD35E055FBA56C2521AFC8BBFC8B06390522E99699750B457C8647A42D6318BE5EAA192ADA35DA7023FC348215613141919821FD5599B93497893CA58E7A88C8D6E6E9EB0A57567BF8C12EB25241BB6082BED7A696658A58DDB66E7CC2562F2EA061E5373E6A5397BF6299F7EA9065B0047AA408F24A5D6F6E4050B99DA86831F663792E08D96F182400182D9BECB917AE315A238CA89741B6AEAF52E238590CDA60FC5B74DC638F9D6FCAF95D2CA7AE005A7B1"),
			tc::cli::FormatUtil::hexStringToBytes("000100041282394569ED63B5C4E54747B31E3B32C68B0EB90712E3C04662101CA77A551A0394CC36CB28E369DFBBB9FD78C9C503C3B1F184729C2B05B4D1691581A877AF82F8EC3D70E95B27F459039B65D8221D4864CCB282FF721EBDD6C46863F8C95591C1BF36D0AC118C0027FA3E2D434821A5FEF123C65F17885321F9A520C22B9EE6FC533EEF582706A95DD0CEABACE87B0169E136336E2E9CC0399637CE4CC77B6DA418671A277614F80A0A909569018F624DE0C5E1A67DB134C63F1FFE30BB64C201FDD8DAD42F4C88B247C1C6133CC554DE6B15684320D6AA1E09CB59EAD15F37140C9DD4BE69D87CC90DD8F733C946FBA6C576C70533601AF4E8294A3B5DD4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526F6F742D4341303030303030303400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015853303030303030323100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CA303087732E88FB2736A4644B6A84DF02393786EBE3DBE914F92224126AB3C38D7CA67322B7D3107B9AC0E00AED9AF13DEDDC62BCB8AC889A47B07196B45BC97AC5DD333CC63E872E30CDB52BD35E055FBA56C2521AFC8BBFC8B06390522E99699750B457C8647A42D6318BE5EAA192ADA35DA7023FC348215613141919821FD5599B93497893CA58E7A88C8D6E6E9EB0A57567BF8C12EB25241BB6082BED7A696658A58DDB66E7CC2562F2EA061E5373E6A5397BF6299F7EA9065B0047AA408F24A5D6F6E4050B99DA86831F663792E08D96F182400182D9BECB917AE315A238CA89741B6AEAF52E238590CDA60FC5B74DC638F9D6FCAF95D2CA7AE005A7B10001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			"Root-CA00000004-XS00000024",
			pie::hac::es::sign::SIGN_ALGO_RSA2048,
			tc::cli::FormatUtil::hexStringToBytes("E5E262EA591EEB885DE5A3CA451CE9E4FEA0E89DAA9BBCD9EC6C23E3FEFCE31BE7C7217DAC3E1F5A8331EF3F0C738E9310E765E71AAAB92C6E18D36071E7F93446E06E2581A28483AE9EB9C8217C1D68A21FD098E186C71B6A1E1E2626C80B69FFD562EAD515C77D616554F6B74B34DEEB0DE905F44631F56A6FF12B47AC0190578267559592FAB173146071ECFBB014951512E45299A21C0B8B3377E55DCD95625130E533877BF11157585D43DB00F61DFE77CFA44F5F29F44945DBF4214F37214921C16ED7D74455B2AE7C8CA15DFBD20A4D5E6501965B78C2C542727D7A91C071C56403738F07E858239CD150DB304BA5ACD8751145A9A91D3E97085AD217"),
			tc::cli::FormatUtil::hexStringToBytes("000100049EA82934BD64EDCED4D506BB68BF1F217BAD912BEF134B687C8E590F2A9355D8EDD9BE00D85735A83820F69978B3E2876FE07BBB7F356B25CDCC98EEEA17BFA9EF649769E921BFDA7867D0570D2F0A7A223E7ACD8D9AE1F304F8EEC6C96B11805436CF686FBD05969E4C0D19A63EF89DA00899222D2CF006776FF027118E96CB027114AABBA268CB1775022B25EAF045C9E4A328A55FF85CFFFFFEAEFB78F1CD184ED9042D23A06F0161E5FBADE92638A483A1A3680DC9994A03D02F1D76EB0EE793843D31CCC172A3993C7344B2C5E634F2B89C47F85FD8B74D21745AEBCFD55E32FC03F6BCD40421499261F8AB93AC8A07E6EF5436036283A3B86192890A78000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526F6F742D4341303030303030303400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015853303030303030323400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000E5E262EA591EEB885DE5A3CA451CE9E4FEA0E89DAA9BBCD9EC6C23E3FEFCE31BE7C7217DAC3E1F5A8331EF3F0C738E9310E765E71AAAB92C6E18D36071E7F93446E06E2581A28483AE9EB9C8217C1D68A21FD098E186C71B6A1E1E2626C80B69FFD562EAD515C77D616554F6B74B34DEEB0DE905F44631F56A6FF12B47AC0190578267559592FAB173146071ECFBB014951512E45299A21C0B8B3377E55DCD95625130E533877BF11157585D43DB00F61DFE77CFA44F5F29F44945DBF4214F37214921C16ED7D74455B2AE7C8CA15DFBD20A4D5E6501965B78C2C542727D7A91C071C56403738F07E858239CD150DB304BA5ACD8751145A9A91D3E97085AD2170001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		}
	};

	if (isDev)
	{
		if (xci_header_sign_key.isNull())
			xci_header_sign_key = tc::crypto::RsaPublicKey(kXciHeaderSignModulus.data(), kXciHeaderSignModulus.size());

		if (xci_cert_sign_key.isNull())
			xci_cert_sign_key = tc::crypto::RsaPublicKey(kXciCertSignModulus.data(), kXciCertSignModulus.size());

		if (pkg2_sign_key.isNull())
			pkg2_sign_key = tc::crypto::RsaPublicKey(kDevPackage2HeaderModulus.data(), kDevPackage2HeaderModulus.size());

		for (auto itr = kDevNcaHeaderSign0Modulus.begin(); itr != kDevNcaHeaderSign0Modulus.end(); itr++)
		{
			if (nca_header_sign0_key.find(itr->generation) == nca_header_sign0_key.end())
				nca_header_sign0_key[itr->generation] = tc::crypto::RsaPublicKey(itr->modulus.data(), itr->modulus.size());
		}

		for (auto itr = kDevAcidSignModulus.begin(); itr != kDevAcidSignModulus.end(); itr++)
		{
			if (acid_sign_key.find(itr->generation) == acid_sign_key.end())
				acid_sign_key[itr->generation] = tc::crypto::RsaPublicKey(itr->modulus.data(), itr->modulus.size());
		}

		for (auto itr = kDevBroadOnRsaKeyAndCert.begin(); itr != kDevBroadOnRsaKeyAndCert.end(); itr++)
		{
			if (broadon_signer.find(itr->issuer) == broadon_signer.end())
				broadon_signer[itr->issuer] = {itr->certificate, itr->key_type, tc::crypto::RsaPublicKey(itr->modulus.data(), itr->modulus.size())};
		}
	}
	else
	{
		if (xci_header_sign_key.isNull())
			xci_header_sign_key = tc::crypto::RsaPublicKey(kXciHeaderSignModulus.data(), kXciHeaderSignModulus.size());

		if (xci_cert_sign_key.isNull())
			xci_cert_sign_key = tc::crypto::RsaPublicKey(kXciCertSignModulus.data(), kXciCertSignModulus.size());

		if (pkg2_sign_key.isNull())
			pkg2_sign_key = tc::crypto::RsaPublicKey(kProdPackage2HeaderModulus.data(), kProdPackage2HeaderModulus.size());

		for (auto itr = kProdNcaHeaderSign0Modulus.begin(); itr != kProdNcaHeaderSign0Modulus.end(); itr++)
		{
			if (nca_header_sign0_key.find(itr->generation) == nca_header_sign0_key.end())
				nca_header_sign0_key[itr->generation] = tc::crypto::RsaPublicKey(itr->modulus.data(), itr->modulus.size());
		}

		for (auto itr = kProdAcidSignModulus.begin(); itr != kProdAcidSignModulus.end(); itr++)
		{
			if (acid_sign_key.find(itr->generation) == acid_sign_key.end())
				acid_sign_key[itr->generation] = tc::crypto::RsaPublicKey(itr->modulus.data(), itr->modulus.size());
		}

		for (auto itr = kProdBroadOnRsaKeyAndCert.begin(); itr != kProdBroadOnRsaKeyAndCert.end(); itr++)
		{
			if (broadon_signer.find(itr->issuer) == broadon_signer.end())
				broadon_signer[itr->issuer] = {itr->certificate, itr->key_type, tc::crypto::RsaPublicKey(itr->modulus.data(), itr->modulus.size())};
		}
	}
}
```

`src/KeyBag.h`:

```h
#pragma once
#include <string>
#include <vector>
#include <array>
#include <map>
#include <tc/Optional.h>
#include <tc/io.h>
#include <pietendo/hac/es/SignUtils.h>
#include <pietendo/hac/define/types.h>
#include <pietendo/hac/define/nca.h>

namespace nstool {

struct KeyBag
{
	using aes128_key_t = pie::hac::detail::aes128_key_t;
	using aes128_xtskey_t = pie::hac::detail::aes128_xtskey_t;
	using rsa_key_t = tc::crypto::RsaKey;
	//using ecc_key_t = tc::crypto::EccKey;
	using rights_id_t = pie::hac::detail::rights_id_t;
	using key_generation_t = byte_t;
	using broadon_issuer_t = std::string;
	static const size_t kNcaKeakNum = pie::hac::nca::kKeyAreaEncryptionKeyNum;


	// acid
	std::map<key_generation_t, rsa_key_t> acid_sign_key;

	// pkg1 and pkg2
	std::map<key_generation_t, aes128_key_t> pkg1_key;
	std::map<key_generation_t, aes128_key_t> pkg2_key;
	tc::Optional<rsa_key_t> pkg2_sign_key;

	// nca
	tc::Optional<aes128_xtskey_t> nca_header_key;
	std::map<key_generation_t, rsa_key_t> nca_header_sign0_key;
	std::array<std::map<key_generation_t, aes128_key_t>, kNcaKeakNum> nca_key_area_encryption_key;
	std::array<std::map<key_generation_t, aes128_key_t>, kNcaKeakNum> nca_key_area_encryption_key_hw;

	// external content keys (nca<->ticket)
	std::map<rights_id_t, aes128_key_t> external_content_keys;
	tc::Optional<aes128_key_t> fallback_enc_content_key; // encrypted content key to be used when external_content_keys does not have the required content key (usually taken raw from ticket)
	tc::Optional<aes128_key_t> fallback_content_key; // content key to be used when external_content_keys does not have the required content key (usually already decrypted from ticket)

	// nrr
	std::map<key_generation_t, rsa_key_t> nrr_certificate_sign_key;

	// xci
	tc::Optional<rsa_key_t> xci_header_sign_key;
	std::map<byte_t, aes128_key_t> xci_header_key;
	std::map<byte_t, aes128_key_t> xci_initial_data_kek;
	tc::Optional<rsa_key_t> xci_cert_sign_key;

	// ticket
	std::map<key_generation_t, aes128_key_t> etik_common_key;

	// BroadOn signer profiles (for es cert and es tik)
	// BroadOn Keys
	struct BroadOnSignerProfile
	{
		tc::ByteData certificate;

		pie::hac::es::sign::SignatureAlgo key_type;
		rsa_key_t rsa_key;
		// ecc_key_t ecc_key;
	};
	std::map<broadon_issuer_t, BroadOnSignerProfile> broadon_signer;
};

class KeyBagInitializer : public KeyBag
{
public:
	KeyBagInitializer(bool isDev, const tc::Optional<tc::io::Path>& keyfile_path, const tc::Optional<tc::io::Path>& tik_path, const tc::Optional<tc::io::Path>& cert_path);
private:
	KeyBagInitializer();

	void importBaseKeyFile(const tc::io::Path& keyfile_path, bool isDev);
	void importTitleKeyFile(const tc::io::Path& keyfile_path);
	void importCertificateChain(const tc::io::Path& cert_path);
	void importTicket(const tc::io::Path& tik_path);

	void importKnownKeys(bool isDev);
};

}
```

`src/KipProcess.cpp`:

```cpp
#include "KipProcess.h"

#include <pietendo/hac/KernelCapabilityUtil.h>

#include <tc/NotImplementedException.h>

nstool::KipProcess::KipProcess() :
	mModuleName("nstool::KipProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false)
{
}

void nstool::KipProcess::process()
{
	importHeader();
	//importCodeSegments(); // code segments not imported because compression not supported yet
	if (mCliOutputMode.show_basic_info)
	{
		displayHeader();
		displayKernelCap(mHdr.getKernelCapabilities());
	}
}

void nstool::KipProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::KipProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::KipProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::KipProcess::importHeader()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// check if file_size is smaller than KIP header size
	if (tc::io::IOUtil::castInt64ToSize(mFile->length()) < sizeof(pie::hac::sKipHeader))
	{
		throw tc::Exception(mModuleName, "Corrupt KIP: file too small.");
	}

	// read kip
	tc::ByteData scratch = tc::ByteData(sizeof(pie::hac::sKipHeader));
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	// parse kip header
	mHdr.fromBytes(scratch.data(), scratch.size());
}

void nstool::KipProcess::importCodeSegments()
{
	tc::ByteData scratch;

	// process text segment
	if (mHdr.getTextSegmentInfo().is_compressed)
	{
		// allocate/read compressed text
		scratch = tc::ByteData(mHdr.getTextSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getTextSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(scratch.data(), scratch.size());

		// allocate for decompressed text segment
		mTextBlob = tc::ByteData(mHdr.getTextSegmentInfo().memory_layout.size);

		// decompress text segment
		if (decompressData(scratch.data(), scratch.size(), mTextBlob.data(), mTextBlob.size()) != mTextBlob.size())
		{
			throw tc::Exception(mModuleName, "KIP text segment failed to decompress");
		}
	}
	else
	{
		// read text segment directly (not compressed)
		mTextBlob = tc::ByteData(mHdr.getTextSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getTextSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(mTextBlob.data(), mTextBlob.size());
	}

	// process ro segment
	if (mHdr.getRoSegmentInfo().is_compressed)
	{
		// allocate/read compressed ro segment
		scratch = tc::ByteData(mHdr.getRoSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getRoSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(scratch.data(), scratch.size());

		// allocate for decompressed ro segment
		mRoBlob = tc::ByteData(mHdr.getRoSegmentInfo().memory_layout.size);

		// decompress ro segment
		if (decompressData(scratch.data(), scratch.size(), mRoBlob.data(), mRoBlob.size()) != mRoBlob.size())
		{
			throw tc::Exception(mModuleName, "KIP ro segment failed to decompress");
		}
	}
	else
	{
		// read ro segment directly (not compressed)
		mRoBlob = tc::ByteData(mHdr.getRoSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getRoSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(mRoBlob.data(), mRoBlob.size());
	}

	// process ro segment
	if (mHdr.getDataSegmentInfo().is_compressed)
	{
		// allocate/read compressed ro segment
		scratch = tc::ByteData(mHdr.getDataSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getDataSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(scratch.data(), scratch.size());

		// allocate for decompressed ro segment
		mDataBlob = tc::ByteData(mHdr.getDataSegmentInfo().memory_layout.size);

		// decompress ro segment
		if (decompressData(scratch.data(), scratch.size(), mDataBlob.data(), mDataBlob.size()) != mDataBlob.size())
		{
			throw tc::Exception(mModuleName, "KIP data segment failed to decompress");
		}
	}
	else
	{
		// read ro segment directly (not compressed)
		mDataBlob = tc::ByteData(mHdr.getDataSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getDataSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(mDataBlob.data(), mDataBlob.size());
	}
}

size_t nstool::KipProcess::decompressData(const byte_t* src, size_t src_len, byte_t* dst, size_t dst_capacity)
{
	throw tc::NotImplementedException(mModuleName, "KIP decompression not implemented yet.");
}

void nstool::KipProcess::displayHeader()
{
	fmt::print("[KIP Header]\n");
	fmt::print("  Meta:\n");
	fmt::print("    Name:                {:s}\n", mHdr.getName());
	fmt::print("    TitleId:             0x{:016x}\n", mHdr.getTitleId());
	fmt::print("    Version:             v{:d}\n", mHdr.getVersion());
	fmt::print("    Is64BitInstruction:  {}\n", mHdr.getIs64BitInstructionFlag());
	fmt::print("    Is64BitAddressSpace: {}\n", mHdr.getIs64BitAddressSpaceFlag());
	fmt::print("    UseSecureMemory:     {}\n", mHdr.getUseSecureMemoryFlag());
	fmt::print("  Program Sections:\n");
	fmt::print("     .text:\n");
	if (mCliOutputMode.show_layout)
	{
		fmt::print("      FileOffset:     0x{:x}\n", mHdr.getTextSegmentInfo().file_layout.offset);
		fmt::print("      FileSize:       0x{:x}{:s}\n", mHdr.getTextSegmentInfo().file_layout.size, (mHdr.getTextSegmentInfo().is_compressed? " (COMPRESSED)" : ""));
	}
	fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getTextSegmentInfo().memory_layout.offset);
	fmt::print("      MemorySize:     0x{:x}\n", mHdr.getTextSegmentInfo().memory_layout.size);
	fmt::print("    .ro:\n");
	if (mCliOutputMode.show_layout)
	{
		fmt::print("      FileOffset:     0x{:x}\n", mHdr.getRoSegmentInfo().file_layout.offset);
		fmt::print("      FileSize:       0x{:x}{:s}\n", mHdr.getRoSegmentInfo().file_layout.size, (mHdr.getRoSegmentInfo().is_compressed? " (COMPRESSED)" : ""));
	}
	fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getRoSegmentInfo().memory_layout.offset);
	fmt::print("      MemorySize:     0x{:x}\n", mHdr.getRoSegmentInfo().memory_layout.size);
	fmt::print("    .data:\n");
	if (mCliOutputMode.show_layout)
	{
		fmt::print("      FileOffset:     0x{:x}\n", mHdr.getDataSegmentInfo().file_layout.offset);
		fmt::print("      FileSize:       0x{:x}{:s}\n", mHdr.getDataSegmentInfo().file_layout.size, (mHdr.getDataSegmentInfo().is_compressed? " (COMPRESSED)" : ""));
	}
	fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getDataSegmentInfo().memory_layout.offset);
	fmt::print("      MemorySize:     0x{:x}\n", mHdr.getDataSegmentInfo().memory_layout.size);
	fmt::print("    .bss:\n");
	fmt::print("      MemorySize:     0x{:x}\n", mHdr.getBssSize());

}

void nstool::KipProcess::displayKernelCap(const pie::hac::KernelCapabilityControl& kern)
{
	fmt::print("[Kernel Capabilities]\n");
	if (kern.getThreadInfo().isSet())
	{
		pie::hac::ThreadInfoHandler threadInfo = kern.getThreadInfo();
		fmt::print("  Thread Priority:\n");
		fmt::print("    Min:     {:d}\n", threadInfo.getMinPriority());
		fmt::print("    Max:     {:d}\n", threadInfo.getMaxPriority());
		fmt::print("  CpuId:\n");
		fmt::print("    Min:     {:d}\n", threadInfo.getMinCpuId());
		fmt::print("    Max:     {:d}\n", threadInfo.getMaxCpuId());
	}

	if (kern.getSystemCalls().isSet())
	{
		auto syscall_ids = kern.getSystemCalls().getSystemCallIds();
		fmt::print("  SystemCalls:\n");
		std::vector<std::string> syscall_names;
		for (size_t syscall_id = 0; syscall_id < syscall_ids.size(); syscall_id++)
		{
			if (syscall_ids.test(syscall_id))
				syscall_names.push_back(pie::hac::KernelCapabilityUtil::getSystemCallIdAsString(pie::hac::kc::SystemCallId(syscall_id)));
		}
		fmt::print("{:s}", tc::cli::FormatUtil::formatListWithLineLimit(syscall_names, 60, 4));
	}
	if (kern.getMemoryMaps().isSet())
	{
		auto maps = kern.getMemoryMaps().getMemoryMaps();
		auto ioMaps = kern.getMemoryMaps().getIoMemoryMaps();

		fmt::print("  MemoryMaps:\n");
		for (size_t i = 0; i < maps.size(); i++)
		{
			fmt::print("    {:s}\n", formatMappingAsString(maps[i]));	
		}
		//fmt::print("  IoMaps:\n");
		for (size_t i = 0; i < ioMaps.size(); i++)
		{
			fmt::print("    {:s}\n", formatMappingAsString(ioMaps[i]));
		}
	}
	if (kern.getInterupts().isSet())
	{
		std::vector<std::string> interupts;
		for (auto itr = kern.getInterupts().getInteruptList().begin(); itr != kern.getInterupts().getInteruptList().end(); itr++)
		{
			interupts.push_back(fmt::format("0x{:x}", *itr));
		}
		fmt::print("  Interupts Flags:\n");
		fmt::print("{:s}", tc::cli::FormatUtil::formatListWithLineLimit(interupts, 60, 4));
	}
	if (kern.getMiscParams().isSet())
	{
		fmt::print("  ProgramType:        {:s} ({:d})\n", pie::hac::KernelCapabilityUtil::getProgramTypeAsString(kern.getMiscParams().getProgramType()), (uint32_t)kern.getMiscParams().getProgramType());
	}
	if (kern.getKernelVersion().isSet())
	{
		fmt::print("  Kernel Version:     {:d}.{:d}\n", kern.getKernelVersion().getVerMajor(), kern.getKernelVersion().getVerMinor());
	}
	if (kern.getHandleTableSize().isSet())
	{
		fmt::print("  Handle Table Size:  0x{:x}\n", kern.getHandleTableSize().getHandleTableSize());
	}
	if (kern.getMiscFlags().isSet())
	{
		auto misc_flags = kern.getMiscFlags().getMiscFlags();
		fmt::print("  Misc Flags:\n");
		std::vector<std::string> misc_flags_names;
		for (size_t misc_flags_bit = 0; misc_flags_bit < misc_flags.size(); misc_flags_bit++)
		{
			if (misc_flags.test(misc_flags_bit))
				misc_flags_names.push_back(pie::hac::KernelCapabilityUtil::getMiscFlagsBitAsString(pie::hac::kc::MiscFlagsBit(misc_flags_bit)));
		}
		fmt::print("{:s}", tc::cli::FormatUtil::formatListWithLineLimit(misc_flags_names, 60, 4));
	}
}

std::string nstool::KipProcess::formatMappingAsString(const pie::hac::MemoryMappingHandler::sMemoryMapping& map) const
{
	return fmt::format("0x{:016x} - 0x{:016x} (perm={:s}) (type={:s})", ((uint64_t)map.addr << 12), (((uint64_t)(map.addr + map.size) << 12) - 1), pie::hac::KernelCapabilityUtil::getMemoryPermissionAsString(map.perm), pie::hac::KernelCapabilityUtil::getMappingTypeAsString(map.type));
}
```

`src/KipProcess.h`:

```h
#pragma once
#include "types.h"

#include <pietendo/hac/KernelInitialProcessHeader.h>

namespace nstool {

class KipProcess
{
public:
	KipProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);
private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	pie::hac::KernelInitialProcessHeader mHdr;
	tc::ByteData mTextBlob, mRoBlob, mDataBlob;

	void importHeader();
	void importCodeSegments();
	size_t decompressData(const byte_t* src, size_t src_len, byte_t* dst, size_t dst_capacity);
	void displayHeader();
	void displayKernelCap(const pie::hac::KernelCapabilityControl& kern);

	std::string formatMappingAsString(const pie::hac::MemoryMappingHandler::sMemoryMapping& map) const;
};

}
```

`src/MetaProcess.cpp`:

```cpp
#include "MetaProcess.h"

#include <pietendo/hac/AccessControlInfoUtil.h>
#include <pietendo/hac/FileSystemAccessUtil.h>
#include <pietendo/hac/KernelCapabilityUtil.h>
#include <pietendo/hac/MetaUtil.h>

nstool::MetaProcess::MetaProcess() :
	mModuleName("nstool::MetaProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false)
{
}

void nstool::MetaProcess::process()
{
	importMeta();

	if (mVerify)
	{
		validateAcidSignature(mMeta.getAccessControlInfoDesc(), mMeta.getAccessControlInfoDescKeyGeneration());
		validateAciFromAcid(mMeta.getAccessControlInfo(), mMeta.getAccessControlInfoDesc());
	}

	if (mCliOutputMode.show_basic_info)
	{
		// npdm binary
		displayMetaHeader(mMeta);

		// aci binary
		displayAciHdr(mMeta.getAccessControlInfo());
		displayFac(mMeta.getAccessControlInfo().getFileSystemAccessControl());
		displaySac(mMeta.getAccessControlInfo().getServiceAccessControl());
		displayKernelCap(mMeta.getAccessControlInfo().getKernelCapabilities());

		// acid binary
		if (mCliOutputMode.show_extended_info)
		{
			displayAciDescHdr(mMeta.getAccessControlInfoDesc());
			displayFac(mMeta.getAccessControlInfoDesc().getFileSystemAccessControl());
			displaySac(mMeta.getAccessControlInfoDesc().getServiceAccessControl());
			displayKernelCap(mMeta.getAccessControlInfoDesc().getKernelCapabilities());
		}
	}
}

void nstool::MetaProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::MetaProcess::setKeyCfg(const KeyBag& keycfg)
{
	mKeyCfg = keycfg;
}

void nstool::MetaProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::MetaProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

const pie::hac::Meta& nstool::MetaProcess::getMeta() const
{
	return mMeta;
}

void nstool::MetaProcess::importMeta()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// check if file_size is greater than 20MB, don't import.
	size_t file_size = tc::io::IOUtil::castInt64ToSize(mFile->length());
	if (file_size > (0x100000 * 20))
	{
		throw tc::Exception(mModuleName, "File too large.");
	}

	// read meta
	tc::ByteData scratch = tc::ByteData(file_size);
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	mMeta.fromBytes(scratch.data(), scratch.size());
}

void nstool::MetaProcess::validateAcidSignature(const pie::hac::AccessControlInfoDesc& acid, byte_t key_generation)
{
	try {
		if (mKeyCfg.acid_sign_key.find(key_generation) == mKeyCfg.acid_sign_key.end())
		{
			throw tc::Exception("Failed to load rsa public key");
		}

		acid.validateSignature(mKeyCfg.acid_sign_key.at(key_generation));
	}
	catch (tc::Exception& e) {
		fmt::print("[WARNING] ACID Signature: FAIL ({:s})\n", e.error());
	}
	
}

void nstool::MetaProcess::validateAciFromAcid(const pie::hac::AccessControlInfo& aci, const pie::hac::AccessControlInfoDesc& acid)
{
	// check Program ID
	if (acid.getProgramIdRestrict().min > 0 && aci.getProgramId() < acid.getProgramIdRestrict().min)
	{
		fmt::print("[WARNING] ACI ProgramId: FAIL (Outside Legal Range)\n");
	}
	else if (acid.getProgramIdRestrict().max > 0 && aci.getProgramId() > acid.getProgramIdRestrict().max)
	{
		fmt::print("[WARNING] ACI ProgramId: FAIL (Outside Legal Range)\n");
	}

	auto fs_access = aci.getFileSystemAccessControl().getFsAccess();
	auto desc_fs_access = acid.getFileSystemAccessControl().getFsAccess();
	for (size_t i = 0; i < fs_access.size(); i++)
	{
		bool rightFound = false;
		for (size_t j = 0; j < desc_fs_access.size() && rightFound == false; j++)
		{
			if (fs_access[i] == desc_fs_access[j])
				rightFound = true;
		}

		if (rightFound == false)
		{
			fmt::print("[WARNING] ACI/FAC FsaRights: FAIL ({:s} not permitted)\n", pie::hac::FileSystemAccessUtil::getFsAccessFlagAsString(fs_access[i]));
		}
	}

	for (size_t i = 0; i < aci.getFileSystemAccessControl().getContentOwnerIdList().size(); i++)
	{
		bool rightFound = false;
		for (size_t j = 0; j < acid.getFileSystemAccessControl().getContentOwnerIdList().size() && rightFound == false; j++)
		{
			if (aci.getFileSystemAccessControl().getContentOwnerIdList()[i] == acid.getFileSystemAccessControl().getContentOwnerIdList()[j])
				rightFound = true;
		}

		if (rightFound == false)
		{

			fmt::print("[WARNING] ACI/FAC ContentOwnerId: FAIL (0x{:016x} not permitted)\n", aci.getFileSystemAccessControl().getContentOwnerIdList()[i]);
		}
	}

	for (size_t i = 0; i < aci.getFileSystemAccessControl().getSaveDataOwnerIdList().size(); i++)
	{
		bool rightFound = false;
		for (size_t j = 0; j < acid.getFileSystemAccessControl().getSaveDataOwnerIdList().size() && rightFound == false; j++)
		{
			if (aci.getFileSystemAccessControl().getSaveDataOwnerIdList()[i] == acid.getFileSystemAccessControl().getSaveDataOwnerIdList()[j])
				rightFound = true;
		}

		if (rightFound == false)
		{

			fmt::print("[WARNING] ACI/FAC SaveDataOwnerId: FAIL (0x{:016x} ({:d}) not permitted)\n", aci.getFileSystemAccessControl().getSaveDataOwnerIdList()[i].id, (uint32_t)aci.getFileSystemAccessControl().getSaveDataOwnerIdList()[i].access_type);
		}
	}

	// check SAC
	for (size_t i = 0; i < aci.getServiceAccessControl().getServiceList().size(); i++)
	{
		bool rightFound = false;
		for (size_t j = 0; j < acid.getServiceAccessControl().getServiceList().size() && rightFound == false; j++)
		{
			if (aci.getServiceAccessControl().getServiceList()[i] == acid.getServiceAccessControl().getServiceList()[j])
				rightFound = true;
		}

		if (rightFound == false)
		{
			fmt::print("[WARNING] ACI/SAC ServiceList: FAIL ({:s}{:s} not permitted)\n", aci.getServiceAccessControl().getServiceList()[i].getName(), (aci.getServiceAccessControl().getServiceList()[i].isServer()? " (Server)" : ""));
		}
	}

	// check KC
	// check thread info
	if (aci.getKernelCapabilities().getThreadInfo().getMaxCpuId() != acid.getKernelCapabilities().getThreadInfo().getMaxCpuId())
	{
		fmt::print("[WARNING] ACI/KC ThreadInfo/MaxCpuId: FAIL ({:d} not permitted)\n", aci.getKernelCapabilities().getThreadInfo().getMaxCpuId());
	}
	if (aci.getKernelCapabilities().getThreadInfo().getMinCpuId() != acid.getKernelCapabilities().getThreadInfo().getMinCpuId())
	{
		fmt::print("[WARNING] ACI/KC ThreadInfo/MinCpuId: FAIL ({:d} not permitted)\n", aci.getKernelCapabilities().getThreadInfo().getMinCpuId());
	}
	if (aci.getKernelCapabilities().getThreadInfo().getMaxPriority() != acid.getKernelCapabilities().getThreadInfo().getMaxPriority())
	{
		fmt::print("[WARNING] ACI/KC ThreadInfo/MaxPriority: FAIL ({:d} not permitted)\n", aci.getKernelCapabilities().getThreadInfo().getMaxPriority());
	}
	if (aci.getKernelCapabilities().getThreadInfo().getMinPriority() != acid.getKernelCapabilities().getThreadInfo().getMinPriority())
	{
		fmt::print("[WARNING] ACI/KC ThreadInfo/MinPriority: FAIL ({:d} not permitted)\n", aci.getKernelCapabilities().getThreadInfo().getMinPriority());
	}
	// check system calls
	auto syscall_ids = aci.getKernelCapabilities().getSystemCalls().getSystemCallIds();
	auto desc_syscall_ids = acid.getKernelCapabilities().getSystemCalls().getSystemCallIds();
	for (size_t i = 0; i < syscall_ids.size(); i++)
	{
		if (syscall_ids.test(i) && desc_syscall_ids.test(i) == false)
		{
			fmt::print("[WARNING] ACI/KC SystemCallList: FAIL ({:s} not permitted)\n", pie::hac::KernelCapabilityUtil::getSystemCallIdAsString(pie::hac::kc::SystemCallId(i)));
		}
	}
	// check memory maps
	for (size_t i = 0; i < aci.getKernelCapabilities().getMemoryMaps().getMemoryMaps().size(); i++)
	{
		bool rightFound = false;
		for (size_t j = 0; j < acid.getKernelCapabilities().getMemoryMaps().getMemoryMaps().size() && rightFound == false; j++)
		{
			if (aci.getKernelCapabilities().getMemoryMaps().getMemoryMaps()[i] == acid.getKernelCapabilities().getMemoryMaps().getMemoryMaps()[j])
				rightFound = true;
		}

		if (rightFound == false)
		{
			auto map = aci.getKernelCapabilities().getMemoryMaps().getMemoryMaps()[i];

			fmt::print("[WARNING] ACI/KC MemoryMap: FAIL ({:s} not permitted)\n", formatMappingAsString(map));
		}
	}
	for (size_t i = 0; i < aci.getKernelCapabilities().getMemoryMaps().getIoMemoryMaps().size(); i++)
	{
		bool rightFound = false;
		for (size_t j = 0; j < acid.getKernelCapabilities().getMemoryMaps().getIoMemoryMaps().size() && rightFound == false; j++)
		{
			if (aci.getKernelCapabilities().getMemoryMaps().getIoMemoryMaps()[i] == acid.getKernelCapabilities().getMemoryMaps().getIoMemoryMaps()[j])
				rightFound = true;
		}

		if (rightFound == false)
		{
			auto map = aci.getKernelCapabilities().getMemoryMaps().getIoMemoryMaps()[i];

			fmt::print("[WARNING] ACI/KC IoMemoryMap: FAIL ({:s} not permitted)\n", formatMappingAsString(map));
		}
	}
	// check interupts
	for (size_t i = 0; i < aci.getKernelCapabilities().getInterupts().getInteruptList().size(); i++)
	{
		bool rightFound = false;
		for (size_t j = 0; j < acid.getKernelCapabilities().getInterupts().getInteruptList().size() && rightFound == false; j++)
		{
			if (aci.getKernelCapabilities().getInterupts().getInteruptList()[i] == acid.getKernelCapabilities().getInterupts().getInteruptList()[j])
				rightFound = true;
		}

		if (rightFound == false)
		{
			fmt::print("[WARNING] ACI/KC InteruptsList: FAIL (0x{:x} not permitted)\n", aci.getKernelCapabilities().getInterupts().getInteruptList()[i]);
		}
	}
	// check misc params
	if (aci.getKernelCapabilities().getMiscParams().getProgramType() != acid.getKernelCapabilities().getMiscParams().getProgramType())
	{
		fmt::print("[WARNING] ACI/KC ProgramType: FAIL ({:d} not permitted)\n", (uint32_t)aci.getKernelCapabilities().getMiscParams().getProgramType());
	}
	// check kernel version
	uint32_t aciKernelVersion = (uint32_t)aci.getKernelCapabilities().getKernelVersion().getVerMajor() << 16 |  (uint32_t)aci.getKernelCapabilities().getKernelVersion().getVerMinor();
	uint32_t acidKernelVersion =  (uint32_t)acid.getKernelCapabilities().getKernelVersion().getVerMajor() << 16 |  (uint32_t)acid.getKernelCapabilities().getKernelVersion().getVerMinor();
	if (aciKernelVersion < acidKernelVersion)
	{
		fmt::print("[WARNING] ACI/KC RequiredKernelVersion: FAIL ({:d}.{:d} not permitted)\n", aci.getKernelCapabilities().getKernelVersion().getVerMajor(), aci.getKernelCapabilities().getKernelVersion().getVerMinor());
	}
	// check handle table size
	if (aci.getKernelCapabilities().getHandleTableSize().getHandleTableSize() > acid.getKernelCapabilities().getHandleTableSize().getHandleTableSize())
	{
		fmt::print("[WARNING] ACI/KC HandleTableSize: FAIL (0x{:x} too large)\n", aci.getKernelCapabilities().getHandleTableSize().getHandleTableSize());
	}
	// check misc flags
	auto misc_flags = aci.getKernelCapabilities().getMiscFlags().getMiscFlags();
	auto desc_misc_flags = acid.getKernelCapabilities().getMiscFlags().getMiscFlags();
	for (size_t i = 0; i < misc_flags.size(); i++)
	{
		if (misc_flags.test(i) && desc_misc_flags.test(i) == false)
		{
			fmt::print("[WARNING] ACI/KC MiscFlag: FAIL ({:s} not permitted)\n", pie::hac::KernelCapabilityUtil::getMiscFlagsBitAsString(pie::hac::kc::MiscFlagsBit(i)));
		}		
	}
}

void nstool::MetaProcess::displayMetaHeader(const pie::hac::Meta& hdr)
{
	fmt::print("[Meta Header]\n");
	fmt::print("  ACID KeyGeneration: {:d}\n", hdr.getAccessControlInfoDescKeyGeneration());
	fmt::print("  Flags:\n");
	fmt::print("    Is64BitInstruction:       {}\n", hdr.getIs64BitInstructionFlag());
	fmt::print("    ProcessAddressSpace:      {:s}\n", pie::hac::MetaUtil::getProcessAddressSpaceAsString(hdr.getProcessAddressSpace()));
	fmt::print("    OptimizeMemoryAllocation: {}\n", hdr.getOptimizeMemoryAllocationFlag());
	fmt::print("  SystemResourceSize: 0x{:x}\n", hdr.getSystemResourceSize());
	fmt::print("  Main Thread Params:\n");
	fmt::print("    Priority:      {:d}\n", hdr.getMainThreadPriority());
	fmt::print("    CpuId:         {:d}\n", hdr.getMainThreadCpuId());
	fmt::print("    StackSize:     0x{:x}\n", hdr.getMainThreadStackSize());
	fmt::print("  TitleInfo:\n");
	fmt::print("    Version:       v{:d}\n", hdr.getVersion());
	fmt::print("    Name:          {:s}\n", hdr.getName());
	if (hdr.getProductCode().length())
	{
		fmt::print("    ProductCode:   {:s}\n", hdr.getProductCode());
	}
}

void nstool::MetaProcess::displayAciHdr(const pie::hac::AccessControlInfo& aci)
{
	fmt::print("[Access Control Info]\n");
	fmt::print("  ProgramID:       0x{:016x}\n", aci.getProgramId());
}

void nstool::MetaProcess::displayAciDescHdr(const pie::hac::AccessControlInfoDesc& acid)
{
	fmt::print("[Access Control Info Desc]\n");
	fmt::print("  Flags:           \n");
	fmt::print("    Production:            {}\n", acid.getProductionFlag());
	fmt::print("    Unqualified Approval:  {}\n", acid.getUnqualifiedApprovalFlag());
	fmt::print("    Memory Region:         {:s} ({:d})\n", pie::hac::AccessControlInfoUtil::getMemoryRegionAsString(acid.getMemoryRegion()), (uint32_t)acid.getMemoryRegion());
	fmt::print("  ProgramID Restriction\n");
	fmt::print("    Min:           0x{:016x}\n", acid.getProgramIdRestrict().min);
	fmt::print("    Max:           0x{:016x}\n", acid.getProgramIdRestrict().max);
}

void nstool::MetaProcess::displayFac(const pie::hac::FileSystemAccessControl& fac)
{
	fmt::print("[FS Access Control]\n");
	fmt::print("  Format Version:  {:d}\n", fac.getFormatVersion());

	if (fac.getFsAccess().size())
	{
		std::vector<std::string> fs_access_str_list;
		for (auto itr = fac.getFsAccess().begin(); itr != fac.getFsAccess().end(); itr++)
		{
			std::string flag_string = pie::hac::FileSystemAccessUtil::getFsAccessFlagAsString(pie::hac::fac::FsAccessFlag(*itr));
			if (mCliOutputMode.show_extended_info)
			{
				fs_access_str_list.push_back(fmt::format("{:s} (bit {:d})", flag_string, (uint32_t)*itr));
			}
			else
			{
				fs_access_str_list.push_back(flag_string);
			}
			
		}

		fmt::print("  FsAccess:\n");
		fmt::print("{:s}", tc::cli::FormatUtil::formatListWithLineLimit(fs_access_str_list, 60, 4));
	}
	
	if (fac.getContentOwnerIdList().size())
	{
		fmt::print("  Content Owner IDs:\n");
		for (size_t i = 0; i < fac.getContentOwnerIdList().size(); i++)
		{
			fmt::print("    0x{:016x}\n", fac.getContentOwnerIdList()[i]);
		}
	}

	if (fac.getSaveDataOwnerIdList().size())
	{
		fmt::print("  Save Data Owner IDs:\n");
		for (size_t i = 0; i < fac.getSaveDataOwnerIdList().size(); i++)
		{
			fmt::print("    0x{:016x} ({:s})\n", fac.getSaveDataOwnerIdList()[i].id, pie::hac::FileSystemAccessUtil::getSaveDataOwnerAccessModeAsString(fac.getSaveDataOwnerIdList()[i].access_type));
		}
	}
}

void nstool::MetaProcess::displaySac(const pie::hac::ServiceAccessControl& sac)
{
	fmt::print("[Service Access Control]\n");
	fmt::print("  Service List:\n");
	std::vector<std::string> service_name_list;
	for (size_t i = 0; i < sac.getServiceList().size(); i++)
	{
		service_name_list.push_back(sac.getServiceList()[i].getName() + (sac.getServiceList()[i].isServer() ? "(isSrv)" : ""));
	}
	fmt::print("{:s}", tc::cli::FormatUtil::formatListWithLineLimit(service_name_list, 60, 4));
}

void nstool::MetaProcess::displayKernelCap(const pie::hac::KernelCapabilityControl& kern)
{
	fmt::print("[Kernel Capabilities]\n");
	if (kern.getThreadInfo().isSet())
	{
		pie::hac::ThreadInfoHandler threadInfo = kern.getThreadInfo();
		fmt::print("  Thread Priority:\n");
		fmt::print("    Min:     {:d}\n", threadInfo.getMinPriority());
		fmt::print("    Max:     {:d}\n", threadInfo.getMaxPriority());
		fmt::print("  CpuId:\n");
		fmt::print("    Min:     {:d}\n", threadInfo.getMinCpuId());
		fmt::print("    Max:     {:d}\n", threadInfo.getMaxCpuId());
	}

	if (kern.getSystemCalls().isSet())
	{
		auto syscall_ids = kern.getSystemCalls().getSystemCallIds();
		fmt::print("  SystemCalls:\n");
		std::vector<std::string> syscall_names;
		for (size_t syscall_id = 0; syscall_id < syscall_ids.size(); syscall_id++)
		{
			if (syscall_ids.test(syscall_id))
				syscall_names.push_back(pie::hac::KernelCapabilityUtil::getSystemCallIdAsString(pie::hac::kc::SystemCallId(syscall_id)));
		}
		fmt::print("{:s}", tc::cli::FormatUtil::formatListWithLineLimit(syscall_names, 60, 4));
	}
	if (kern.getMemoryMaps().isSet())
	{
		auto maps = kern.getMemoryMaps().getMemoryMaps();
		auto ioMaps = kern.getMemoryMaps().getIoMemoryMaps();

		fmt::print("  MemoryMaps:\n");
		for (size_t i = 0; i < maps.size(); i++)
		{
			fmt::print("    {:s}\n", formatMappingAsString(maps[i]));	
		}
		//fmt::print("  IoMaps:\n");
		for (size_t i = 0; i < ioMaps.size(); i++)
		{
			fmt::print("    {:s}\n", formatMappingAsString(ioMaps[i]));
		}
	}
	if (kern.getInterupts().isSet())
	{
		std::vector<std::string> interupts;
		for (auto itr = kern.getInterupts().getInteruptList().begin(); itr != kern.getInterupts().getInteruptList().end(); itr++)
		{
			interupts.push_back(fmt::format("0x{:x}", *itr));
		}
		fmt::print("  Interupts Flags:\n");
		fmt::print("{:s}", tc::cli::FormatUtil::formatListWithLineLimit(interupts, 60, 4));
	}
	if (kern.getMiscParams().isSet())
	{
		fmt::print("  ProgramType:        {:s} ({:d})\n", pie::hac::KernelCapabilityUtil::getProgramTypeAsString(kern.getMiscParams().getProgramType()), (uint32_t)kern.getMiscParams().getProgramType());
	}
	if (kern.getKernelVersion().isSet())
	{
		fmt::print("  Kernel Version:     {:d}.{:d}\n", kern.getKernelVersion().getVerMajor(), kern.getKernelVersion().getVerMinor());
	}
	if (kern.getHandleTableSize().isSet())
	{
		fmt::print("  Handle Table Size:  0x{:x}\n", kern.getHandleTableSize().getHandleTableSize());
	}
	if (kern.getMiscFlags().isSet())
	{
		auto misc_flags = kern.getMiscFlags().getMiscFlags();
		fmt::print("  Misc Flags:\n");
		std::vector<std::string> misc_flags_names;
		for (size_t misc_flags_bit = 0; misc_flags_bit < misc_flags.size(); misc_flags_bit++)
		{
			if (misc_flags.test(misc_flags_bit))
				misc_flags_names.push_back(pie::hac::KernelCapabilityUtil::getMiscFlagsBitAsString(pie::hac::kc::MiscFlagsBit(misc_flags_bit)));
		}
		fmt::print("{:s}", tc::cli::FormatUtil::formatListWithLineLimit(misc_flags_names, 60, 4));
	}
}

std::string nstool::MetaProcess::formatMappingAsString(const pie::hac::MemoryMappingHandler::sMemoryMapping& map) const
{
	return fmt::format("0x{:016x} - 0x{:016x} (perm={:s}) (type={:s})", ((uint64_t)map.addr << 12), (((uint64_t)(map.addr + map.size) << 12) - 1), pie::hac::KernelCapabilityUtil::getMemoryPermissionAsString(map.perm), pie::hac::KernelCapabilityUtil::getMappingTypeAsString(map.type));
}
```

`src/MetaProcess.h`:

```h
#pragma once
#include "types.h"
#include "KeyBag.h"

#include <pietendo/hac/Meta.h>

namespace nstool {

class MetaProcess
{
public:
	MetaProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setKeyCfg(const KeyBag& keycfg);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	const pie::hac::Meta& getMeta() const;

private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	KeyBag mKeyCfg;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	pie::hac::Meta mMeta;

	void importMeta();

	void validateAcidSignature(const pie::hac::AccessControlInfoDesc& acid, byte_t key_generation);
	void validateAciFromAcid(const pie::hac::AccessControlInfo& aci, const pie::hac::AccessControlInfoDesc& acid);

	void displayMetaHeader(const pie::hac::Meta& hdr);
	void displayAciHdr(const pie::hac::AccessControlInfo& aci);
	void displayAciDescHdr(const pie::hac::AccessControlInfoDesc& aci);
	void displayFac(const pie::hac::FileSystemAccessControl& fac);
	void displaySac(const pie::hac::ServiceAccessControl& sac);
	void displayKernelCap(const pie::hac::KernelCapabilityControl& kern);

	std::string formatMappingAsString(const pie::hac::MemoryMappingHandler::sMemoryMapping& map) const;
};

}
```

`src/NacpProcess.cpp`:

```cpp
#include "NacpProcess.h"

#include <pietendo/hac/ApplicationControlPropertyUtil.h>

nstool::NacpProcess::NacpProcess() :
	mModuleName("nstool::NacpProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false)
{
}

void nstool::NacpProcess::process()
{
	importNacp();

	if (mCliOutputMode.show_basic_info)
		displayNacp();
}

void nstool::NacpProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::NacpProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::NacpProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

const pie::hac::ApplicationControlProperty& nstool::NacpProcess::getApplicationControlProperty() const
{
	return mNacp;
}

void nstool::NacpProcess::importNacp()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// check if file_size does matches expected size
	size_t file_size = tc::io::IOUtil::castInt64ToSize(mFile->length());
	if (file_size != sizeof(pie::hac::sApplicationControlProperty))
	{
		throw tc::Exception(mModuleName, "File was incorrect size.");
	}

	// read cnmt
	tc::ByteData scratch = tc::ByteData(file_size);
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	mNacp.fromBytes(scratch.data(), scratch.size());
}

void nstool::NacpProcess::displayNacp()
{
	fmt::print("[ApplicationControlProperty]\n");
	
	// Title
	if (mNacp.getTitle().size() > 0)
	{
		fmt::print("  Title:\n");
		for (auto itr = mNacp.getTitle().begin(); itr != mNacp.getTitle().end(); itr++)
		{
			fmt::print("    {:s}:\n", pie::hac::ApplicationControlPropertyUtil::getLanguageAsString(itr->language));
			fmt::print("      Name:       {:s}\n", itr->name);
			fmt::print("      Publisher:  {:s}\n", itr->publisher);
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  Title:                                  None\n");
	}

	// Isbn
	if (mNacp.getIsbn().empty() == false)
	{
		fmt::print("  ISBN:                                   {:s}\n", mNacp.getIsbn());
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  ISBN:                                   (NotSet)\n");
	}
	
	// StartupUserAccount
	if (mNacp.getStartupUserAccount() != pie::hac::nacp::StartupUserAccount_None || mCliOutputMode.show_extended_info)
	{
		fmt::print("  StartupUserAccount:                     {:s}\n", pie::hac::ApplicationControlPropertyUtil::getStartupUserAccountAsString(mNacp.getStartupUserAccount()));
	}

	// UserAccountSwitchLock
	if (mNacp.getUserAccountSwitchLock() != pie::hac::nacp::UserAccountSwitchLock_Disable || mCliOutputMode.show_extended_info)
	{
		fmt::print("  UserAccountSwitchLock:                  {:s}\n", pie::hac::ApplicationControlPropertyUtil::getUserAccountSwitchLockAsString(mNacp.getUserAccountSwitchLock()));
	}

	// AddOnContentRegistrationType
	if (mNacp.getAddOnContentRegistrationType() != pie::hac::nacp::AddOnContentRegistrationType_AllOnLaunch || mCliOutputMode.show_extended_info)
	{
		fmt::print("  AddOnContentRegistrationType:           {:s}\n", pie::hac::ApplicationControlPropertyUtil::getAddOnContentRegistrationTypeAsString(mNacp.getAddOnContentRegistrationType()));
	}

	// Attribute
	if (mNacp.getAttribute().size() > 0)
	{
		fmt::print("  Attribute:\n");
		for (auto itr = mNacp.getAttribute().begin(); itr != mNacp.getAttribute().end(); itr++)
		{
			fmt::print("    {:s}\n", pie::hac::ApplicationControlPropertyUtil::getAttributeFlagAsString(*itr));
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  Attribute:                              None\n");
	}

	// SupportedLanguage
	if (mNacp.getSupportedLanguage().size() > 0)
	{
		fmt::print("  SupportedLanguage:\n");
		for (auto itr = mNacp.getSupportedLanguage().begin(); itr != mNacp.getSupportedLanguage().end(); itr++)
		{
			fmt::print("    {:s}\n", pie::hac::ApplicationControlPropertyUtil::getLanguageAsString(*itr));
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  SupportedLanguage:                      None\n");
	}

	// ParentalControl
	if (mNacp.getParentalControl().size() > 0)
	{
		fmt::print("  ParentalControl:\n");
		for (auto itr = mNacp.getParentalControl().begin(); itr != mNacp.getParentalControl().end(); itr++)
		{
			fmt::print("    {:s}\n", pie::hac::ApplicationControlPropertyUtil::getParentalControlFlagAsString(*itr));
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  ParentalControl:                        None\n");
	}

	// Screenshot
	if (mNacp.getScreenshot() != pie::hac::nacp::Screenshot_Allow || mCliOutputMode.show_extended_info)
	{
		fmt::print("  Screenshot:                             {:s}\n", pie::hac::ApplicationControlPropertyUtil::getScreenshotAsString(mNacp.getScreenshot()));
	}

	// VideoCapture
	if (mNacp.getVideoCapture() != pie::hac::nacp::VideoCapture_Disable || mCliOutputMode.show_extended_info)
	{
		fmt::print("  VideoCapture:                           {:s}\n", pie::hac::ApplicationControlPropertyUtil::getVideoCaptureAsString(mNacp.getVideoCapture()));
	}

	// DataLossConfirmation
	if (mNacp.getDataLossConfirmation() != pie::hac::nacp::DataLossConfirmation_None || mCliOutputMode.show_extended_info)
	{
		fmt::print("  DataLossConfirmation:                   {:s}\n", pie::hac::ApplicationControlPropertyUtil::getDataLossConfirmationAsString(mNacp.getDataLossConfirmation()));
	}

	// PlayLogPolicy
	if (mNacp.getPlayLogPolicy() != pie::hac::nacp::PlayLogPolicy_All || mCliOutputMode.show_extended_info)
	{
		fmt::print("  PlayLogPolicy:                          {:s}\n", pie::hac::ApplicationControlPropertyUtil::getPlayLogPolicyAsString(mNacp.getPlayLogPolicy()));
	}

	// PresenceGroupId
	if (mNacp.getPresenceGroupId() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  PresenceGroupId:                        0x{:016x}\n", mNacp.getPresenceGroupId());
	}

	// RatingAge
	if (mNacp.getRatingAge().size() > 0)
	{
		fmt::print("  RatingAge:\n");
		
		for (auto itr = mNacp.getRatingAge().begin(); itr != mNacp.getRatingAge().end(); itr++)
		{
			fmt::print("    {:s}:\n", pie::hac::ApplicationControlPropertyUtil::getOrganisationAsString(itr->organisation));
			fmt::print("      Age: {:d}\n", itr->age);
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  RatingAge:                              None\n");
	}

	// DisplayVersion
	if (mNacp.getDisplayVersion().empty() == false)
	{
		fmt::print("  DisplayVersion:                         {:s}\n", mNacp.getDisplayVersion());
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  DisplayVersion:                         (NotSet)\n");
	}

	// AddOnContentBaseId
	if (mNacp.getAddOnContentBaseId() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  AddOnContentBaseId:                     0x{:016x}\n", mNacp.getAddOnContentBaseId());
	}

	// SaveDataOwnerId
	if (mNacp.getSaveDataOwnerId() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  SaveDataOwnerId:                        0x{:016x}\n", mNacp.getSaveDataOwnerId());
	}

	// UserAccountSaveDataSize
	if (mNacp.getUserAccountSaveDataSize().size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  UserAccountSaveDataSize:                {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getUserAccountSaveDataSize().size));
	}

	// UserAccountSaveDataJournalSize
	if (mNacp.getUserAccountSaveDataSize().journal_size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  UserAccountSaveDataJournalSize:         {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getUserAccountSaveDataSize().journal_size));
	}

	// DeviceSaveDataSize
	if (mNacp.getDeviceSaveDataSize().size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  DeviceSaveDataSize:                     {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getDeviceSaveDataSize().size));
	}

	// DeviceSaveDataJournalSize
	if (mNacp.getDeviceSaveDataSize().journal_size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  DeviceSaveDataJournalSize:              {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getDeviceSaveDataSize().journal_size));
	}

	// BcatDeliveryCacheStorageSize
	if (mNacp.getBcatDeliveryCacheStorageSize() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  BcatDeliveryCacheStorageSize:           {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getBcatDeliveryCacheStorageSize()));
	}

	// ApplicationErrorCodeCategory
	if (mNacp.getApplicationErrorCodeCategory().empty() == false)
	{
		fmt::print("  ApplicationErrorCodeCategory:           {:s}\n", mNacp.getApplicationErrorCodeCategory());
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  ApplicationErrorCodeCategory:           (NotSet)\n");
	}

	// LocalCommunicationId
	if (mNacp.getLocalCommunicationId().size() > 0)
	{
		fmt::print("  LocalCommunicationId:\n");
		for (auto itr = mNacp.getLocalCommunicationId().begin(); itr != mNacp.getLocalCommunicationId().end(); itr++)
		{
			fmt::print("    0x{:016x}\n", *itr);
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  LocalCommunicationId:                   None\n");
	}

	// LogoType
	//if (mNacp.getLogoType() != pie::hac::nacp::LogoType_Nintendo || mCliOutputMode.show_extended_info)
	//{
		fmt::print("  LogoType:                               {:s}\n", pie::hac::ApplicationControlPropertyUtil::getLogoTypeAsString(mNacp.getLogoType()));
	//}

	// LogoHandling
	if (mNacp.getLogoHandling() != pie::hac::nacp::LogoHandling_Auto || mCliOutputMode.show_extended_info)
	{
		fmt::print("  LogoHandling:                           {:s}\n", pie::hac::ApplicationControlPropertyUtil::getLogoHandlingAsString(mNacp.getLogoHandling()));
	}

	// RuntimeAddOnContentInstall
	if (mNacp.getRuntimeAddOnContentInstall() != pie::hac::nacp::RuntimeAddOnContentInstall_Deny || mCliOutputMode.show_extended_info)
	{
		fmt::print("  RuntimeAddOnContentInstall:             {:s}\n", pie::hac::ApplicationControlPropertyUtil::getRuntimeAddOnContentInstallAsString(mNacp.getRuntimeAddOnContentInstall()));
	}

	// RuntimeParameterDelivery
	if (mNacp.getRuntimeParameterDelivery() != pie::hac::nacp::RuntimeParameterDelivery_Always || mCliOutputMode.show_extended_info)
	{
		fmt::print("  RuntimeParameterDelivery:               {:s}\n", pie::hac::ApplicationControlPropertyUtil::getRuntimeParameterDeliveryAsString(mNacp.getRuntimeParameterDelivery()));
	}

	// CrashReport
	if (mNacp.getCrashReport() != pie::hac::nacp::CrashReport_Deny || mCliOutputMode.show_extended_info)
	{
		fmt::print("  CrashReport:                            {:s}\n", pie::hac::ApplicationControlPropertyUtil::getCrashReportAsString(mNacp.getCrashReport()));
	}

	// Hdcp
	if (mNacp.getHdcp() != pie::hac::nacp::Hdcp_None || mCliOutputMode.show_extended_info)
	{
		fmt::print("  Hdcp:                                   {:s}\n", pie::hac::ApplicationControlPropertyUtil::getHdcpAsString(mNacp.getHdcp()));
	}

	// SeedForPsuedoDeviceId
	if (mNacp.getSeedForPsuedoDeviceId() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  SeedForPsuedoDeviceId:                  0x{:016x}\n", mNacp.getSeedForPsuedoDeviceId());
	}

	// BcatPassphase
	if (mNacp.getBcatPassphase().empty() == false)
	{
		fmt::print("  BcatPassphase:                          {:s}\n", mNacp.getBcatPassphase());
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  BcatPassphase:                          (NotSet)\n");
	}

	// StartupUserAccountOption
	if (mNacp.getStartupUserAccountOption().size() > 0)
	{
		fmt::print("  StartupUserAccountOption:\n");
		for (auto itr = mNacp.getStartupUserAccountOption().begin(); itr != mNacp.getStartupUserAccountOption().end(); itr++)
		{
			fmt::print("    {:s}\n", pie::hac::ApplicationControlPropertyUtil::getStartupUserAccountOptionFlagAsString(*itr));
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  StartupUserAccountOption:               None\n");
	}

	// UserAccountSaveDataSizeMax
	if (mNacp.getUserAccountSaveDataMax().size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  UserAccountSaveDataSizeMax:             {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getUserAccountSaveDataMax().size));
	}

	// UserAccountSaveDataJournalSizeMax
	if (mNacp.getUserAccountSaveDataMax().journal_size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  UserAccountSaveDataJournalSizeMax:      {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getUserAccountSaveDataMax().journal_size));
	}

	// DeviceSaveDataSizeMax
	if (mNacp.getDeviceSaveDataMax().size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  DeviceSaveDataSizeMax:                  {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getDeviceSaveDataMax().size));
	}

	// DeviceSaveDataJournalSizeMax
	if (mNacp.getDeviceSaveDataMax().journal_size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  DeviceSaveDataJournalSizeMax:           {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getDeviceSaveDataMax().journal_size));
	}

	// TemporaryStorageSize
	if (mNacp.getTemporaryStorageSize() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  TemporaryStorageSize:                   {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getTemporaryStorageSize()));
	}

	// CacheStorageSize
	if (mNacp.getCacheStorageSize().size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  CacheStorageSize:                       {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getCacheStorageSize().size));
	}

	// CacheStorageJournalSize
	if (mNacp.getCacheStorageSize().journal_size != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  CacheStorageJournalSize:                {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getCacheStorageSize().journal_size));
	}

	// CacheStorageDataAndJournalSizeMax
	if (mNacp.getCacheStorageDataAndJournalSizeMax() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  CacheStorageDataAndJournalSizeMax:      {:s}\n", pie::hac::ApplicationControlPropertyUtil::getSaveDataSizeAsString(mNacp.getCacheStorageDataAndJournalSizeMax()));
	}

	// CacheStorageIndexMax
	if (mNacp.getCacheStorageIndexMax() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  CacheStorageIndexMax:                   0x{:04x}\n", mNacp.getCacheStorageIndexMax());
	}

	// PlayLogQueryableApplicationId
	if (mNacp.getPlayLogQueryableApplicationId().size() > 0)
	{
		fmt::print("  PlayLogQueryableApplicationId:\n");
		for (auto itr = mNacp.getPlayLogQueryableApplicationId().begin(); itr != mNacp.getPlayLogQueryableApplicationId().end(); itr++)
		{
			fmt::print("    0x{:016x}\n", *itr);
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  PlayLogQueryableApplicationId:          None\n");
	}

	// PlayLogQueryCapability
	if (mNacp.getPlayLogQueryCapability() != pie::hac::nacp::PlayLogQueryCapability_None || mCliOutputMode.show_extended_info)
	{
		fmt::print("  PlayLogQueryCapability:                 {:s}\n", pie::hac::ApplicationControlPropertyUtil::getPlayLogQueryCapabilityAsString(mNacp.getPlayLogQueryCapability()));
	}

	// Repair
	if (mNacp.getRepair().size() > 0)
	{
		fmt::print("  Repair:\n");
		for (auto itr = mNacp.getRepair().begin(); itr != mNacp.getRepair().end(); itr++)
		{
			fmt::print("    {:s}\n", pie::hac::ApplicationControlPropertyUtil::getRepairFlagAsString(*itr));
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  Repair:                                 None\n");
	}

	// ProgramIndex
	if (mNacp.getProgramIndex() != 0 || mCliOutputMode.show_extended_info)
	{
		fmt::print("  ProgramIndex:                           0x{:02x}\n", mNacp.getProgramIndex());
	}

	// RequiredNetworkServiceLicenseOnLaunch
	if (mNacp.getRequiredNetworkServiceLicenseOnLaunch().size() > 0)
	{
		fmt::print("  RequiredNetworkServiceLicenseOnLaunch:\n");
		for (auto itr = mNacp.getRequiredNetworkServiceLicenseOnLaunch().begin(); itr != mNacp.getRequiredNetworkServiceLicenseOnLaunch().end(); itr++)
		{
			fmt::print("    {:s}\n", pie::hac::ApplicationControlPropertyUtil::getRequiredNetworkServiceLicenseOnLaunchFlagAsString(*itr));
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  RequiredNetworkServiceLicenseOnLaunch:  None\n");
	}

	// NeighborDetectionClientConfiguration
	auto detect_config = mNacp.getNeighborDetectionClientConfiguration();
	if (detect_config.countSendGroupConfig() > 0 || detect_config.countReceivableGroupConfig() > 0)
	{
		fmt::print("  NeighborDetectionClientConfiguration:\n");
		if (detect_config.countSendGroupConfig() > 0)
		{
			fmt::print("    SendGroupConfig:\n");
			fmt::print("      GroupId:  0x{:016x}\n", detect_config.send_data_configuration.group_id);
			fmt::print("        Key:    {:s}\n", tc::cli::FormatUtil::formatBytesAsString(detect_config.send_data_configuration.key.data(), detect_config.send_data_configuration.key.size(), false, ""));
		}
		else if (mCliOutputMode.show_extended_info)
		{
			fmt::print("    SendGroupConfig: None\n");
		}
		if (detect_config.countReceivableGroupConfig() > 0)
		{
			fmt::print("    ReceivableGroupConfig:\n");
			for (size_t i = 0; i < pie::hac::nacp::kReceivableGroupConfigurationCount; i++)
			{
				if (detect_config.receivable_data_configuration[i].isNull())
					continue;

				fmt::print("      GroupId:  0x{:016x}\n", detect_config.receivable_data_configuration[i].group_id);
				fmt::print("        Key:    {:s}\n", tc::cli::FormatUtil::formatBytesAsString(detect_config.receivable_data_configuration[i].key.data(), detect_config.receivable_data_configuration[i].key.size(), false, ""));
			}
		}
		else if (mCliOutputMode.show_extended_info)
		{
			fmt::print("    ReceivableGroupConfig: None\n");
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  NeighborDetectionClientConfiguration:   None\n");
	}
	
	// JitConfiguration
	if (mNacp.getJitConfiguration().is_enabled || mCliOutputMode.show_extended_info)
	{
		fmt::print("  JitConfiguration:\n");
		fmt::print("    IsEnabled:  {}\n", mNacp.getJitConfiguration().is_enabled);
		fmt::print("    MemorySize: 0x{:016x}\n", mNacp.getJitConfiguration().memory_size);
	}
	
	// PlayReportPermission
	if (mNacp.getPlayReportPermission() != pie::hac::nacp::PlayReportPermission_None || mCliOutputMode.show_extended_info)
	{
		fmt::print("  PlayReportPermission:                   {:s}\n", pie::hac::ApplicationControlPropertyUtil::getPlayReportPermissionAsString(mNacp.getPlayReportPermission()));
	}

	// CrashScreenshotForProd
	if (mNacp.getCrashScreenshotForProd() != pie::hac::nacp::CrashScreenshotForProd_Deny || mCliOutputMode.show_extended_info)
	{
		fmt::print("  CrashScreenshotForProd:                 {:s}\n", pie::hac::ApplicationControlPropertyUtil::getCrashScreenshotForProdAsString(mNacp.getCrashScreenshotForProd()));
	}

	// CrashScreenshotForDev
	if (mNacp.getCrashScreenshotForDev() != pie::hac::nacp::CrashScreenshotForDev_Deny || mCliOutputMode.show_extended_info)
	{
		fmt::print("  CrashScreenshotForDev:                  {:s}\n", pie::hac::ApplicationControlPropertyUtil::getCrashScreenshotForDevAsString(mNacp.getCrashScreenshotForDev()));
	}

	// AccessibleLaunchRequiredVersion
	if (mNacp.getAccessibleLaunchRequiredVersionApplicationId().size() > 0)
	{
		fmt::print("  AccessibleLaunchRequiredVersion:\n");
		fmt::print("    ApplicationId:\n");
		for (auto itr = mNacp.getAccessibleLaunchRequiredVersionApplicationId().begin(); itr != mNacp.getAccessibleLaunchRequiredVersionApplicationId().end(); itr++)
		{
			fmt::print("      0x{:016x}\n", *itr);
		}
	}
	else if (mCliOutputMode.show_extended_info)
	{
		fmt::print("  AccessibleLaunchRequiredVersion:        None\n");
	}
}
```

`src/NacpProcess.h`:

```h
#pragma once
#include "types.h"

#include <pietendo/hac/ApplicationControlProperty.h>

namespace nstool {

class NacpProcess
{
public:
	NacpProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	const pie::hac::ApplicationControlProperty& getApplicationControlProperty() const;

private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	pie::hac::ApplicationControlProperty mNacp;

	void importNacp();
	void displayNacp();
};

}
```

`src/NcaProcess.cpp`:

```cpp
#include "NcaProcess.h"
#include "MetaProcess.h"
#include "util.h"

#include <pietendo/hac/ContentArchiveUtil.h>
#include <pietendo/hac/AesKeygen.h>
#include <pietendo/hac/HierarchicalSha256Stream.h>
#include <pietendo/hac/HierarchicalIntegrityStream.h>
#include <pietendo/hac/BKTREncryptedStream.h>
#include <pietendo/hac/PartitionFsSnapshotGenerator.h>
#include <pietendo/hac/RomFsSnapshotGenerator.h>
#include <pietendo/hac/CombinedFsSnapshotGenerator.h>

nstool::NcaProcess::NcaProcess() :
	mModuleName("nstool::NcaProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false),
	mFileSystem(),
	mFsProcess()
{
}

void nstool::NcaProcess::process()
{
	// import header
	importHeader();

	// determine keys
	generateNcaBodyEncryptionKeys();

	// import/generate fs header data
	generatePartitionConfiguration();

	// validate signatures
	if (mVerify)
		validateNcaSignatures();

	// display header
	if (mCliOutputMode.show_basic_info)
		displayHeader();

	// process partition
	processPartitions();
}

void nstool::NcaProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::NcaProcess::setBaseNcaPath(const tc::Optional<tc::io::Path>& nca_path)
{
	mBaseNcaPath = nca_path;
}

void nstool::NcaProcess::setKeyCfg(const KeyBag& keycfg)
{
	mKeyCfg = keycfg;
}

void nstool::NcaProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::NcaProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::NcaProcess::setShowFsTree(bool show_fs_tree)
{
	mFsProcess.setShowFsTree(show_fs_tree);
}

void nstool::NcaProcess::setFsRootLabel(const std::string& root_label)
{
	mFsProcess.setFsRootLabel(root_label);
}

void nstool::NcaProcess::setExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs)
{
	mFsProcess.setExtractJobs(extract_jobs);
}

const std::shared_ptr<tc::io::IFileSystem>& nstool::NcaProcess::getFileSystem() const
{
	return mFileSystem;
}

void nstool::NcaProcess::importHeader()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// read header block
	if (mFile->length() < tc::io::IOUtil::castSizeToInt64(sizeof(pie::hac::sContentArchiveHeaderBlock)))
	{
		throw tc::Exception(mModuleName, "Corrupt NCA: File too small.");
	}
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read((byte_t*)(&mHdrBlock), sizeof(pie::hac::sContentArchiveHeaderBlock));

	// decrypt header block
	if (mKeyCfg.nca_header_key.isNull())
	{
		throw tc::Exception(mModuleName, "Failed to decrypt NCA header. (nca_header_key could not be loaded)");
	}
	pie::hac::ContentArchiveUtil::decryptContentArchiveHeader((byte_t*)&mHdrBlock, (byte_t*)&mHdrBlock, mKeyCfg.nca_header_key.get());

	// generate header hash
	tc::crypto::GenerateSha2256Hash(mHdrHash.data(), (byte_t*)&mHdrBlock.header, sizeof(pie::hac::sContentArchiveHeader));

	// proccess main header
	mHdr.fromBytes((byte_t*)&mHdrBlock.header, sizeof(pie::hac::sContentArchiveHeader));
}

void nstool::NcaProcess::generateNcaBodyEncryptionKeys()
{
	// create zeros key
	KeyBag::aes128_key_t zero_aesctr_key;
	memset(zero_aesctr_key.data(), 0, zero_aesctr_key.size());
	
	// get key data from header
	byte_t masterkey_rev = pie::hac::AesKeygen::getMasterKeyRevisionFromKeyGeneration(mHdr.getKeyGeneration());
	byte_t keak_index = mHdr.getKeyAreaEncryptionKeyIndex();

	// process key area
	sKeys::sKeyAreaKey kak;
	for (size_t i = 0; i < mHdr.getKeyArea().size(); i++)
	{
		if (mHdr.getKeyArea()[i] != zero_aesctr_key)
		{
			kak.index = (byte_t)i;
			kak.enc = mHdr.getKeyArea()[i];
			kak.decrypted = false;
			// key[0-3]
			if (i < 4 && mKeyCfg.nca_key_area_encryption_key[keak_index].find(masterkey_rev) != mKeyCfg.nca_key_area_encryption_key[keak_index].end())
			{
				kak.decrypted = true;
				pie::hac::AesKeygen::generateKey(kak.dec.data(), kak.enc.data(), mKeyCfg.nca_key_area_encryption_key[keak_index][masterkey_rev].data());
			}
			// key[KeyBankIndex_AesCtrHw]
			else if (i == pie::hac::nca::KeyBankIndex_AesCtrHw && mKeyCfg.nca_key_area_encryption_key_hw[keak_index].find(masterkey_rev) != mKeyCfg.nca_key_area_encryption_key_hw[keak_index].end())
			{
				kak.decrypted = true;
				pie::hac::AesKeygen::generateKey(kak.dec.data(), kak.enc.data(), mKeyCfg.nca_key_area_encryption_key_hw[keak_index][masterkey_rev].data());
			}
			else
			{
				kak.decrypted = false;
			}
			mContentKey.kak_list.push_back(kak);
		}
	}

	// clear content key
	mContentKey.aes_ctr = tc::Optional<pie::hac::detail::aes128_key_t>();

	// if this has a rights id, the key needs to be sourced from a ticket
	if (mHdr.hasRightsId() == true)
	{
		KeyBag::aes128_key_t tmp_key;
		if (mKeyCfg.external_content_keys.find(mHdr.getRightsId()) != mKeyCfg.external_content_keys.end())
		{
			mContentKey.aes_ctr = mKeyCfg.external_content_keys[mHdr.getRightsId()];
		}
		else if (mKeyCfg.fallback_content_key.isSet())
		{
			mContentKey.aes_ctr = mKeyCfg.fallback_content_key.get();
		}
		else if (mKeyCfg.fallback_enc_content_key.isSet())
		{
			tmp_key = mKeyCfg.fallback_enc_content_key.get();
			if (mKeyCfg.etik_common_key.find(masterkey_rev) != mKeyCfg.etik_common_key.end())
			{
				pie::hac::AesKeygen::generateKey(tmp_key.data(), tmp_key.data(), mKeyCfg.etik_common_key[masterkey_rev].data());
				mContentKey.aes_ctr = tmp_key;
			}
		}
	}
	// otherwise used decrypt key area
	else
	{
		for (size_t i = 0; i < mContentKey.kak_list.size(); i++)
		{
			if (mContentKey.kak_list[i].index == pie::hac::nca::KeyBankIndex_AesCtr && mContentKey.kak_list[i].decrypted)
			{
				mContentKey.aes_ctr = mContentKey.kak_list[i].dec;
			}
		}
	}

	// if the keys weren't generated, check if the keys were supplied by the user
	if (mContentKey.aes_ctr.isNull())
	{
		if (mKeyCfg.fallback_content_key.isSet())
		{
			mContentKey.aes_ctr = mKeyCfg.fallback_content_key.get();
		}
	}
	
	if (mCliOutputMode.show_keydata)
	{
		if (mContentKey.aes_ctr.isSet())
		{
			fmt::print("[NCA Content Key]\n");
			fmt::print("  AES-CTR Key: {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mContentKey.aes_ctr.get().data(), mContentKey.aes_ctr.get().size(), true, ""));
		}
	}
}

nstool::NcaProcess nstool::NcaProcess::readBaseNCA()
{
	// open base nca stream
	if (mBaseNcaPath.isNull())
	{
		throw tc::Exception(mModuleName, "Base NCA not supplied. Necessary for update NCA.");
	}
	std::shared_ptr<tc::io::IStream> base_stream = std::make_shared<tc::io::FileStream>(tc::io::FileStream(mBaseNcaPath.get(), tc::io::FileMode::Open, tc::io::FileAccess::Read));

	// process base nca with output suppressed
	NcaProcess obj;
	nstool::CliOutputMode cliOutput;
	cliOutput.show_basic_info = false;
	cliOutput.show_extended_info = false;
	cliOutput.show_keydata = false;
	cliOutput.show_layout = false;
	obj.setCliOutputMode(cliOutput);
	obj.setVerifyMode(true);
	obj.setKeyCfg(mKeyCfg);
	obj.setInputFile(base_stream);
	obj.process();

	// return processed base nca
	return obj;
}

void nstool::NcaProcess::generatePartitionConfiguration()
{
	for (size_t i = 0; i < mHdr.getPartitionEntryList().size(); i++)
	{
		// get reference to relevant structures
		const pie::hac::ContentArchiveHeader::sPartitionEntry& partition = mHdr.getPartitionEntryList()[i];
		pie::hac::sContentArchiveFsHeader& fs_header = mHdrBlock.fs_header[partition.header_index];

		// output structure
		sPartitionInfo& info = mPartitions[partition.header_index];

		// validate header hash
		pie::hac::detail::sha256_hash_t fs_header_hash;
		tc::crypto::GenerateSha2256Hash(fs_header_hash.data(), (const byte_t*)&mHdrBlock.fs_header[partition.header_index], sizeof(pie::hac::sContentArchiveFsHeader));
		if (fs_header_hash != partition.fs_header_hash)
		{
			throw tc::Exception(mModuleName, fmt::format("NCA FS Header [{:d}] Hash: FAIL", partition.header_index));
		}

		if (fs_header.version.unwrap() != pie::hac::nca::kDefaultFsHeaderVersion)
		{
			throw tc::Exception(mModuleName, fmt::format("NCA FS Header [{:d}] Version({:d}): UNSUPPORTED", partition.header_index, fs_header.version.unwrap()));
		}

		// setup AES-CTR 
		pie::hac::ContentArchiveUtil::getNcaPartitionAesCtr(&fs_header, info.aes_ctr.data());

		// save partition configinfo
		info.offset = partition.offset;
		info.size = partition.size;
		info.format_type = (pie::hac::nca::FormatType)fs_header.format_type;
		info.hash_type = (pie::hac::nca::HashType)fs_header.hash_type;
		info.enc_type = (pie::hac::nca::EncryptionType)fs_header.encryption_type;
		info.metadata_hash_type = (pie::hac::nca::MetaDataHashType)fs_header.meta_data_hash_type;

		if (info.hash_type == pie::hac::nca::HashType_HierarchicalSha256)
		{
			info.hierarchicalsha256_hdr.fromBytes(fs_header.hash_info.data(), fs_header.hash_info.size());
		}	
		else if (info.hash_type == pie::hac::nca::HashType_HierarchicalIntegrity)
		{
			info.hierarchicalintegrity_hdr.fromBytes(fs_header.hash_info.data(), fs_header.hash_info.size());
		}

		// create reader
		try 
		{
			// handle partition encryption and partition compaction (sparse layer)
			if (fs_header.sparse_info.generation.unwrap() != 0)
			{
				throw tc::Exception("SparseStorage: Not currently supported.");
			}
			else
			{
				// create raw partition
				info.raw_reader = std::make_shared<tc::io::SubStream>(tc::io::SubStream(mFile, info.offset, info.size));

				// handle encryption if required reader based on encryption type
				if (info.enc_type == pie::hac::nca::EncryptionType_None)
				{
					// no encryption so do nothing
					info.decrypt_reader = info.raw_reader;
				}
				else if (info.enc_type == pie::hac::nca::EncryptionType_AesCtr)
				{
					if (mContentKey.aes_ctr.isNull())
						throw tc::Exception(mModuleName, "AES-CTR Key was not determined");

					// get partition key
					pie::hac::detail::aes128_key_t partition_key = mContentKey.aes_ctr.get();

					// get partition counter
					pie::hac::detail::aes_iv_t partition_ctr = info.aes_ctr;
					tc::crypto::IncrementCounterAes128Ctr(partition_ctr.data(), info.offset >> 4);

					// create decryption stream
					info.decrypt_reader = std::make_shared<tc::crypto::Aes128CtrEncryptedStream>(tc::crypto::Aes128CtrEncryptedStream(info.raw_reader, partition_key, partition_ctr));
				}
				else if (info.enc_type == pie::hac::nca::EncryptionType_AesCtrEx)
				{
					if (mContentKey.aes_ctr.isNull())
						throw tc::Exception(mModuleName, "AES-CTR Key was not determined");

					// get partition key
					pie::hac::detail::aes128_key_t partition_key = mContentKey.aes_ctr.get();

					// get partition counter
					pie::hac::detail::aes_iv_t partition_ctr = info.aes_ctr;
					tc::crypto::IncrementCounterAes128Ctr(partition_ctr.data(), info.offset >> 4);

					// TODO see if AesCtrEx encryption can just be for creating the transparent decryption, with IndirectStorage IStream construction being done after decryption but before hash layer processing
					// this might be relevant when processing compressed or sparse storage

					NcaProcess nca_base = readBaseNCA();
					if (nca_base.mHdr.getProgramId() != mHdr.getProgramId())
					{
						throw tc::Exception(mModuleName, "Invalid base nca. ProgramID diferent.");
					}

					std::shared_ptr<tc::io::IStream> base_reader;
					for (auto& partition_base : nca_base.mPartitions)
					{
						if (partition_base.format_type == pie::hac::nca::FormatType::FormatType_RomFs && partition_base.raw_reader != nullptr)
						{
							base_reader = partition_base.decrypt_reader;
						}
					}
					if (base_reader == nullptr)
					{
						throw tc::Exception(mModuleName, "Cannot determine RomFs from base nca.");
					}

					// create decryption stream
					info.decrypt_reader = std::make_shared<pie::hac::BKTREncryptedStream>(pie::hac::BKTREncryptedStream(info.raw_reader, partition_key, partition_ctr, fs_header.patch_info, base_reader));
				}
				else if (info.enc_type == pie::hac::nca::EncryptionType_AesXts)
				{
					throw tc::Exception(mModuleName, fmt::format("EncryptionType({:s}): UNSUPPORTED", pie::hac::ContentArchiveUtil::getEncryptionTypeAsString(info.enc_type)));
				}
				else
				{
					throw tc::Exception(mModuleName, fmt::format("EncryptionType({:s}): UNKNOWN", pie::hac::ContentArchiveUtil::getEncryptionTypeAsString(info.enc_type)));
				}
			}

			// filter out unrecognised hash types, and hash based readers
			switch (info.hash_type)
			{
			case (pie::hac::nca::HashType_None):
				// no hash layer, do nothing
				info.reader = info.decrypt_reader;
				break;
			case (pie::hac::nca::HashType_HierarchicalSha256):
				info.reader = std::make_shared<pie::hac::HierarchicalSha256Stream>(pie::hac::HierarchicalSha256Stream(info.decrypt_reader, info.hierarchicalsha256_hdr));
				break;
			case (pie::hac::nca::HashType_HierarchicalIntegrity):
				info.reader = std::make_shared<pie::hac::HierarchicalIntegrityStream>(pie::hac::HierarchicalIntegrityStream(info.decrypt_reader, info.hierarchicalintegrity_hdr));
				break;
			default:
				throw tc::Exception(mModuleName, fmt::format("HashType({:s}): UNKNOWN", pie::hac::ContentArchiveUtil::getHashTypeAsString(info.hash_type)));
			}

			// filter out unrecognised format types
			switch (info.format_type)
			{
			case (pie::hac::nca::FormatType_PartitionFs):
				info.fs_snapshot = pie::hac::PartitionFsSnapshotGenerator(info.reader);
				info.fs_reader = std::make_shared<tc::io::VirtualFileSystem>(tc::io::VirtualFileSystem(info.fs_snapshot));
				break;
			case (pie::hac::nca::FormatType_RomFs):
				info.fs_snapshot = pie::hac::RomFsSnapshotGenerator(info.reader);
				info.fs_reader = std::make_shared<tc::io::VirtualFileSystem>(tc::io::VirtualFileSystem(info.fs_snapshot));
				break;
			default:
				throw tc::Exception(mModuleName, fmt::format("FormatType({:s}): UNKNOWN", pie::hac::ContentArchiveUtil::getFormatTypeAsString(info.format_type)));
			}
		}
		catch (const tc::Exception& e)
		{
			info.fail_reason = std::string(e.error());
		}
	}
}

void nstool::NcaProcess::validateNcaSignatures()
{
	// validate signature[0]
	if (mKeyCfg.nca_header_sign0_key.find(mHdr.getSignatureKeyGeneration()) != mKeyCfg.nca_header_sign0_key.end())
	{
		if (tc::crypto::VerifyRsa2048PssSha2256(mHdrBlock.signature_main.data(), mHdrHash.data(), mKeyCfg.nca_header_sign0_key[mHdr.getSignatureKeyGeneration()]) == false)
		{
			fmt::print("[WARNING] NCA Header Main Signature: FAIL\n");
		}
	}
	else
	{
		fmt::print("[WARNING] NCA Header Main Signature: FAIL (could not load header key)\n");
	}
	

	// validate signature[1]
	if (mHdr.getContentType() == pie::hac::nca::ContentType_Program)
	{
		try {
			if (mPartitions[pie::hac::nca::ProgramContentPartitionIndex_Code].format_type == pie::hac::nca::FormatType_PartitionFs)
			{
				if (mPartitions[pie::hac::nca::ProgramContentPartitionIndex_Code].fs_reader != nullptr)
				{
					std::shared_ptr<tc::io::IStream> npdm_file;
					try {
						mPartitions[pie::hac::nca::ProgramContentPartitionIndex_Code].fs_reader->openFile(tc::io::Path(kNpdmExefsPath), tc::io::FileMode::Open, tc::io::FileAccess::Read, npdm_file);
					}
					catch (tc::io::FileNotFoundException&) {
						throw tc::Exception(fmt::format("\"{:s}\" not present in ExeFs", kNpdmExefsPath));
					}

					MetaProcess npdm;
					npdm.setInputFile(npdm_file);
					npdm.setKeyCfg(mKeyCfg);
					npdm.setVerifyMode(true);
					npdm.setCliOutputMode(CliOutputMode(false, false, false, false));
					npdm.process();

					if (tc::crypto::VerifyRsa2048PssSha2256(mHdrBlock.signature_acid.data(), mHdrHash.data(), npdm.getMeta().getAccessControlInfoDesc().getContentArchiveHeaderSignature2Key()) == false)
					{
						throw tc::Exception("Bad signature");
					}
				}
				else
				{
					throw tc::Exception("ExeFs was not mounted");
				}
			}
			else
			{
				throw tc::Exception("No ExeFs partition");
			}
		}
		catch (tc::Exception& e) {
			fmt::print("[WARNING] NCA Header ACID Signature: FAIL ({:s})\n", e.error());
		}
	}
}

void nstool::NcaProcess::displayHeader()
{
	fmt::print("[NCA Header]\n");
	fmt::print("  Format Type:     {:s}\n", pie::hac::ContentArchiveUtil::getFormatHeaderVersionAsString((pie::hac::nca::HeaderFormatVersion)mHdr.getFormatVersion()));
	fmt::print("  Dist. Type:      {:s}\n", pie::hac::ContentArchiveUtil::getDistributionTypeAsString(mHdr.getDistributionType()));
	fmt::print("  Content Type:    {:s}\n", pie::hac::ContentArchiveUtil::getContentTypeAsString(mHdr.getContentType()));
	fmt::print("  Key Generation:  {:d}\n", mHdr.getKeyGeneration());
	fmt::print("  Sig. Generation: {:d}\n", mHdr.getSignatureKeyGeneration());
	fmt::print("  Kaek Index:      {:s} ({:d})\n", pie::hac::ContentArchiveUtil::getKeyAreaEncryptionKeyIndexAsString((pie::hac::nca::KeyAreaEncryptionKeyIndex)mHdr.getKeyAreaEncryptionKeyIndex()), mHdr.getKeyAreaEncryptionKeyIndex());
	fmt::print("  Size:            0x{:x}\n", mHdr.getContentSize());
	fmt::print("  ProgID:          0x{:016x}\n", mHdr.getProgramId());
	fmt::print("  Content Index:   {:d}\n", mHdr.getContentIndex());
	fmt::print("  SdkAddon Ver.:   {:s} (v{:d})\n", pie::hac::ContentArchiveUtil::getSdkAddonVersionAsString(mHdr.getSdkAddonVersion()), mHdr.getSdkAddonVersion());
	if (mHdr.hasRightsId())
	{
		fmt::print("  RightsId:        {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mHdr.getRightsId().data(), mHdr.getRightsId().size(), true, ""));
	}
	
	if (mContentKey.kak_list.size() > 0 && mCliOutputMode.show_keydata)
	{
		fmt::print("  Key Area:\n");
		fmt::print("    <--------------------------------------------------------------------------->\n");
		fmt::print("    | IDX | ENCRYPTED KEY                    | DECRYPTED KEY                    |\n");
		fmt::print("    |-----|----------------------------------|----------------------------------|\n");
		for (size_t i = 0; i < mContentKey.kak_list.size(); i++)
		{
			std::string enc_key = tc::cli::FormatUtil::formatBytesAsString(mContentKey.kak_list[i].enc.data(), mContentKey.kak_list[i].enc.size(), true, "");
			std::string dec_key = mContentKey.kak_list[i].decrypted ? tc::cli::FormatUtil::formatBytesAsString(mContentKey.kak_list[i].dec.data(), mContentKey.kak_list[i].dec.size(), true, "") : "<unable to decrypt>";
			
			fmt::print("    | {:3d} | {:32s} | {:32s} |\n", mContentKey.kak_list[i].index, enc_key, dec_key);
		
		}
		fmt::print("    <--------------------------------------------------------------------------->\n");
	}

	if (mCliOutputMode.show_layout)
	{
		fmt::print("  Partitions:\n");
		for (size_t i = 0; i < mHdr.getPartitionEntryList().size(); i++)
		{
			uint32_t index = mHdr.getPartitionEntryList()[i].header_index;
			sPartitionInfo& info = mPartitions[index];
			if (info.size == 0) continue;

			fmt::print("    {:d}:\n", index);
			fmt::print("      Offset:      0x{:x}\n", info.offset);
			fmt::print("      Size:        0x{:x}\n", info.size);
			fmt::print("      Format Type: {:s}\n", pie::hac::ContentArchiveUtil::getFormatTypeAsString(info.format_type));
			fmt::print("      Hash Type:   {:s}\n", pie::hac::ContentArchiveUtil::getHashTypeAsString(info.hash_type));
			fmt::print("      Enc. Type:   {:s}\n", pie::hac::ContentArchiveUtil::getEncryptionTypeAsString(info.enc_type));
			if (info.enc_type == pie::hac::nca::EncryptionType_AesCtr)
			{
				pie::hac::detail::aes_iv_t aes_ctr;
				memcpy(aes_ctr.data(), info.aes_ctr.data(), aes_ctr.size());
				tc::crypto::IncrementCounterAes128Ctr(aes_ctr.data(), info.offset>>4);
				fmt::print("      AesCtr Counter:\n");
				fmt::print("        {:s}\n", tc::cli::FormatUtil::formatBytesAsString(aes_ctr.data(), aes_ctr.size(), true, ""));
			}
			if (info.hash_type == pie::hac::nca::HashType_HierarchicalIntegrity)
			{
				auto hash_hdr = info.hierarchicalintegrity_hdr;
				fmt::print("      HierarchicalIntegrity Header:\n");
				for (size_t j = 0; j < hash_hdr.getLayerInfo().size(); j++)
				{
					if (j+1 == hash_hdr.getLayerInfo().size())
					{
						fmt::print("        Data Layer:\n");
					}
					else
					{
						fmt::print("        Hash Layer {:d}:\n", j);
					}
					fmt::print("          Offset:          0x{:x}\n", hash_hdr.getLayerInfo()[j].offset);
					fmt::print("          Size:            0x{:x}\n", hash_hdr.getLayerInfo()[j].size);
					fmt::print("          BlockSize:       0x{:x}\n", hash_hdr.getLayerInfo()[j].block_size);
				}
				for (size_t j = 0; j < hash_hdr.getMasterHashList().size(); j++)
				{
					fmt::print("        Master Hash {:d}:\n", j);
					fmt::print("          {:s}\n", tc::cli::FormatUtil::formatBytesAsString(hash_hdr.getMasterHashList()[j].data(), 0x10, true, ""));
					fmt::print("          {:s}\n", tc::cli::FormatUtil::formatBytesAsString(hash_hdr.getMasterHashList()[j].data()+0x10, 0x10, true, ""));
				}
			}
			else if (info.hash_type == pie::hac::nca::HashType_HierarchicalSha256)
			{
				auto hash_hdr = info.hierarchicalsha256_hdr;
				fmt::print("      HierarchicalSha256 Header:\n");
				fmt::print("        Master Hash:\n");
				fmt::print("          {:s}\n", tc::cli::FormatUtil::formatBytesAsString(hash_hdr.getMasterHash().data(), 0x10, true, ""));
				fmt::print("          {:s}\n", tc::cli::FormatUtil::formatBytesAsString(hash_hdr.getMasterHash().data()+0x10, 0x10, true, ""));
				fmt::print("        HashBlockSize:     0x{:x}\n", hash_hdr.getHashBlockSize());
				for (size_t j = 0; j < hash_hdr.getLayerInfo().size(); j++)
				{
					if (j+1 == hash_hdr.getLayerInfo().size())
					{
						fmt::print("        Data Layer:\n");
					}
					else
					{
						fmt::print("        Hash Layer {:d}:\n", j);
					}
					fmt::print("          Offset:          0x{:x}\n", hash_hdr.getLayerInfo()[j].offset);
					fmt::print("          Size:            0x{:x}\n", hash_hdr.getLayerInfo()[j].size);
				}
			}
		}
	}
}


void nstool::NcaProcess::processPartitions()
{
	std::vector<pie::hac::CombinedFsSnapshotGenerator::MountPointInfo> mount_points;

	for (size_t i = 0; i < mHdr.getPartitionEntryList().size(); i++)
	{
		uint32_t index = mHdr.getPartitionEntryList()[i].header_index;
		struct sPartitionInfo& partition = mPartitions[index];

		// if the reader is null, skip
		if (partition.fs_reader == nullptr)
		{
			fmt::print("[WARNING] NCA Partition {:d} not readable.", index);
			if (partition.fail_reason.empty() == false)
			{
				fmt::print(" ({:s})", partition.fail_reason);
			}
			fmt::print("\n");
			continue;
		}

		std::string mount_point_name;
		/*
		if (mHdr.getContentType() == pie::hac::nca::ContentType_Program)
		{
			mount_point_name = pie::hac::ContentArchiveUtil::getProgramContentParititionIndexAsString((pie::hac::nca::ProgramContentPartitionIndex)index);
		}
		else
		*/
		{
			mount_point_name = fmt::format("{:d}", index);
		}

		mount_points.push_back( { mount_point_name, partition.fs_snapshot } );
	}

	tc::io::VirtualFileSystem::FileSystemSnapshot fs_snapshot = pie::hac::CombinedFsSnapshotGenerator(mount_points);

	std::shared_ptr<tc::io::IFileSystem> nca_fs = std::make_shared<tc::io::VirtualFileSystem>(tc::io::VirtualFileSystem(fs_snapshot));

	mFsProcess.setInputFileSystem(nca_fs);
	mFsProcess.setFsFormatName("ContentArchive");
	mFsProcess.setFsRootLabel(getContentTypeForMountStr(mHdr.getContentType()));
	mFsProcess.process();
}

std::string nstool::NcaProcess::getContentTypeForMountStr(pie::hac::nca::ContentType cont_type) const
{
	std::string str;

	switch (cont_type)
	{
		case (pie::hac::nca::ContentType_Program):
			str = "program";
			break;
		case (pie::hac::nca::ContentType_Meta):
			str = "meta";
			break;
		case (pie::hac::nca::ContentType_Control):
			str = "control";
			break;
		case (pie::hac::nca::ContentType_Manual):
			str = "manual";
			break;
		case (pie::hac::nca::ContentType_Data):
			str = "data";
			break;
		case (pie::hac::nca::ContentType_PublicData):
			str = "publicdata";
			break;
		default:
			str = "";
			break;
	}

	return str;
}
```

`src/NcaProcess.h`:

```h
#pragma once
#include "types.h"
#include "KeyBag.h"
#include "FsProcess.h"

#include <pietendo/hac/ContentArchiveHeader.h>
#include <pietendo/hac/HierarchicalIntegrityHeader.h>
#include <pietendo/hac/HierarchicalSha256Header.h>

namespace nstool {

class NcaProcess
{
public:
	NcaProcess();

	void process();

	// generic
	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setKeyCfg(const KeyBag& keycfg);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);
	void setBaseNcaPath(const tc::Optional<tc::io::Path>& nca_path);


	// fs specific
	void setShowFsTree(bool show_fs_tree);
	void setFsRootLabel(const std::string& root_label);
	void setExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs);

	// post process() get FS out
	const std::shared_ptr<tc::io::IFileSystem>& getFileSystem() const;
private:
	const std::string kNpdmExefsPath = "/main.npdm";

	std::string mModuleName;

	// user options
	std::shared_ptr<tc::io::IStream> mFile;
	KeyBag mKeyCfg;
	CliOutputMode mCliOutputMode;
	bool mVerify;
	tc::Optional<tc::io::Path> mBaseNcaPath;

	// fs processing
	std::shared_ptr<tc::io::IFileSystem> mFileSystem;
	FsProcess mFsProcess;

	// nca data
	pie::hac::sContentArchiveHeaderBlock mHdrBlock;
	pie::hac::detail::sha256_hash_t mHdrHash;
	pie::hac::ContentArchiveHeader mHdr;

	// crypto
	struct sKeys
	{
		struct sKeyAreaKey
		{
			byte_t index;
			bool decrypted;
			KeyBag::aes128_key_t enc;
			KeyBag::aes128_key_t dec;

			void operator=(const sKeyAreaKey& other)
			{
				index = other.index;
				decrypted = other.decrypted;
				enc = other.enc;
				dec = other.dec;
			}

			bool operator==(const sKeyAreaKey& other) const
			{
				return (index == other.index) \
					&& (decrypted == other.decrypted) \
					&& (enc == other.enc) \
					&& (dec == other.dec);
			}

			bool operator!=(const sKeyAreaKey& other) const
			{
				return !(*this == other);
			}
		};
		std::vector<sKeyAreaKey> kak_list;

		tc::Optional<pie::hac::detail::aes128_key_t> aes_ctr;
	} mContentKey;

	struct SparseInfo
	{

	};

	// raw partition data
	struct sPartitionInfo
	{
		std::shared_ptr<tc::io::IStream> raw_reader; // raw unprocessed partition stream
		std::shared_ptr<tc::io::IStream> decrypt_reader; // partition stream with transparent decryption
		std::shared_ptr<tc::io::IStream> reader; // partition stream with transparent decryption & hash layer processing
		tc::io::VirtualFileSystem::FileSystemSnapshot fs_snapshot;
		std::shared_ptr<tc::io::IFileSystem> fs_reader;
		std::string fail_reason;
		int64_t offset;
		int64_t size;

		// meta data
		pie::hac::nca::FormatType format_type;
		pie::hac::nca::HashType hash_type;
		pie::hac::nca::EncryptionType enc_type;
		pie::hac::nca::MetaDataHashType metadata_hash_type;

		// hash meta data
		pie::hac::HierarchicalIntegrityHeader hierarchicalintegrity_hdr;
		pie::hac::HierarchicalSha256Header hierarchicalsha256_hdr;

		// crypto metadata
		pie::hac::detail::aes_iv_t aes_ctr;

		// sparse metadata
		SparseInfo sparse_info;
	};
	
	std::array<sPartitionInfo, pie::hac::nca::kPartitionNum> mPartitions;

	void importHeader();
	void generateNcaBodyEncryptionKeys();
	void generatePartitionConfiguration();
	void validateNcaSignatures();
	void displayHeader();
	void processPartitions();

	NcaProcess readBaseNCA();

	std::string getContentTypeForMountStr(pie::hac::nca::ContentType cont_type) const;
};

}
```

`src/NroProcess.cpp`:

```cpp
#include "NroProcess.h"

nstool::NroProcess::NroProcess() :
	mModuleName("nstool::NroProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false)
{
}

void nstool::NroProcess::process()
{
	importHeader();
	importCodeSegments();

	if (mCliOutputMode.show_basic_info)
		displayHeader();

	processRoMeta();

	if (mIsHomebrewNro)
		mAssetProc.process();
}

void nstool::NroProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::NroProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::NroProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::NroProcess::setIs64BitInstruction(bool flag)
{
	mRoMeta.setIs64BitInstruction(flag);
}

void nstool::NroProcess::setListApi(bool listApi)
{
	mRoMeta.setListApi(listApi);
}

void nstool::NroProcess::setListSymbols(bool listSymbols)
{
	mRoMeta.setListSymbols(listSymbols);
}

void nstool::NroProcess::setAssetIconExtractPath(const tc::io::Path& path)
{
	mAssetProc.setIconExtractPath(path);
}

void nstool::NroProcess::setAssetNacpExtractPath(const tc::io::Path& path)
{
	mAssetProc.setNacpExtractPath(path);
}

void nstool::NroProcess::setAssetRomfsShowFsTree(bool show_fs_tree)
{
	mAssetProc.setRomfsShowFsTree(show_fs_tree);
}

void nstool::NroProcess::setAssetRomfsExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs)
{
	mAssetProc.setRomfsExtractJobs(extract_jobs);
}

const nstool::RoMetadataProcess& nstool::NroProcess::getRoMetadataProcess() const
{
	return mRoMeta;
}

void nstool::NroProcess::importHeader()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// check if file_size is smaller than NRO header size
	if (tc::io::IOUtil::castInt64ToSize(mFile->length()) < sizeof(pie::hac::sNroHeader))
	{
		throw tc::Exception(mModuleName, "Corrupt NRO: file too small.");
	}

	// read nro
	tc::ByteData scratch = tc::ByteData(sizeof(pie::hac::sNroHeader));
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	// parse nro header
	mHdr.fromBytes(scratch.data(), scratch.size());

	// setup homebrew extension
	pie::hac::sNroHeader* raw_hdr = (pie::hac::sNroHeader*)scratch.data();

	int64_t file_size = mFile->length();
	if (((tc::bn::le64<uint64_t>*)raw_hdr->reserved_0.data())->unwrap() == pie::hac::nro::kNroHomebrewStructMagic && file_size > int64_t(mHdr.getNroSize()))
	{
		mIsHomebrewNro = true;
		mAssetProc.setInputFile(std::make_shared<tc::io::SubStream>(tc::io::SubStream(mFile, int64_t(mHdr.getNroSize()), file_size - int64_t(mHdr.getNroSize()))));
		mAssetProc.setCliOutputMode(mCliOutputMode);
		mAssetProc.setVerifyMode(mVerify);
	}
	else
		mIsHomebrewNro = false;
}

void nstool::NroProcess::importCodeSegments()
{
	if (mHdr.getTextInfo().size > 0)
	{
		mTextBlob = tc::ByteData(mHdr.getTextInfo().size);
		mFile->seek(mHdr.getTextInfo().memory_offset, tc::io::SeekOrigin::Begin);
		mFile->read(mTextBlob.data(), mTextBlob.size());
	}

	if (mHdr.getRoInfo().size > 0)
	{
		mRoBlob = tc::ByteData(mHdr.getRoInfo().size);
		mFile->seek(mHdr.getRoInfo().memory_offset, tc::io::SeekOrigin::Begin);
		mFile->read(mRoBlob.data(), mRoBlob.size());
	}

	if (mHdr.getDataInfo().size > 0)
	{
		mDataBlob = tc::ByteData(mHdr.getDataInfo().size);
		mFile->seek(mHdr.getDataInfo().memory_offset, tc::io::SeekOrigin::Begin);
		mFile->read(mDataBlob.data(), mDataBlob.size());
	}
}

void nstool::NroProcess::displayHeader()
{
	fmt::print("[NRO Header]\n");
	fmt::print("  RoCrt:       \n");
	fmt::print("    EntryPoint: 0x{:x}\n", mHdr.getRoCrtEntryPoint());
	fmt::print("    ModOffset:  0x{:x}\n", mHdr.getRoCrtModOffset());
	fmt::print("  ModuleId:    {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mHdr.getModuleId().data(), mHdr.getModuleId().size(), false, ""));
	fmt::print("  NroSize:     0x{:x}\n", mHdr.getNroSize());
	fmt::print("  Program Sections:\n");
	fmt::print("     .text:\n");
	fmt::print("      Offset:     0x{:x}\n", mHdr.getTextInfo().memory_offset);
	fmt::print("      Size:       0x{:x}\n", mHdr.getTextInfo().size);
	fmt::print("    .ro:\n");
	fmt::print("      Offset:     0x{:x}\n", mHdr.getRoInfo().memory_offset);
	fmt::print("      Size:       0x{:x}\n", mHdr.getRoInfo().size);
	if (mCliOutputMode.show_extended_info)
	{
		fmt::print("    .api_info:\n");
		fmt::print("      Offset:     0x{:x}\n", mHdr.getRoEmbeddedInfo().memory_offset);
		fmt::print("      Size:       0x{:x}\n", mHdr.getRoEmbeddedInfo().size);
		fmt::print("    .dynstr:\n");
		fmt::print("      Offset:     0x{:x}\n", mHdr.getRoDynStrInfo().memory_offset);
		fmt::print("      Size:       0x{:x}\n", mHdr.getRoDynStrInfo().size);
		fmt::print("    .dynsym:\n");
		fmt::print("      Offset:     0x{:x}\n", mHdr.getRoDynSymInfo().memory_offset);
		fmt::print("      Size:       0x{:x}\n", mHdr.getRoDynSymInfo().size);
	}                                                                
	fmt::print("    .data:\n");
	fmt::print("      Offset:     0x{:x}\n", mHdr.getDataInfo().memory_offset);
	fmt::print("      Size:       0x{:x}\n", mHdr.getDataInfo().size);
	fmt::print("    .bss:\n");
	fmt::print("      Size:       0x{:x}\n", mHdr.getBssSize());
}

void nstool::NroProcess::processRoMeta()
{
	if (mRoBlob.size())
	{
		// setup ro metadata
		mRoMeta.setApiInfo(mHdr.getRoEmbeddedInfo().memory_offset, mHdr.getRoEmbeddedInfo().size);
		mRoMeta.setDynSym(mHdr.getRoDynSymInfo().memory_offset, mHdr.getRoDynSymInfo().size);
		mRoMeta.setDynStr(mHdr.getRoDynStrInfo().memory_offset, mHdr.getRoDynStrInfo().size);
		mRoMeta.setRoBinary(mRoBlob);
		mRoMeta.setCliOutputMode(mCliOutputMode);
		mRoMeta.process();
	}
}
```

`src/NroProcess.h`:

```h
#pragma once
#include "types.h"
#include "RoMetadataProcess.h"
#include "AssetProcess.h"

#include <pietendo/hac/NroHeader.h>

namespace nstool {

class NroProcess
{
public:
	NroProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	void setIs64BitInstruction(bool flag);
	void setListApi(bool listApi);
	void setListSymbols(bool listSymbols);

	// for homebrew NROs with Asset blobs appended
	void setAssetIconExtractPath(const tc::io::Path& path);
	void setAssetNacpExtractPath(const tc::io::Path& path);
	void setAssetRomfsShowFsTree(bool show_fs_tree);
	void setAssetRomfsExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs);

	const nstool::RoMetadataProcess& getRoMetadataProcess() const;
private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	pie::hac::NroHeader mHdr;
	tc::ByteData mTextBlob, mRoBlob, mDataBlob;
	nstool::RoMetadataProcess mRoMeta;
	bool mIsHomebrewNro;
	nstool::AssetProcess mAssetProc;

	void importHeader();
	void importCodeSegments();
	void displayHeader();
	void processRoMeta();
};

}
```

`src/NsoProcess.cpp`:

```cpp
#include "NsoProcess.h"

#include <lz4.h>

nstool::NsoProcess::NsoProcess() :
	mModuleName("nstool::NsoProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false),
	mIs64BitInstruction(true),
	mListApi(false),
	mListSymbols(false)
{
}

void nstool::NsoProcess::process()
{
	importHeader();
	importCodeSegments();
	if (mCliOutputMode.show_basic_info)
		displayNsoHeader();

	processRoMeta();
}

void nstool::NsoProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::NsoProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::NsoProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::NsoProcess::setIs64BitInstruction(bool flag)
{
	mRoMeta.setIs64BitInstruction(flag);
}

void nstool::NsoProcess::setListApi(bool listApi)
{
	mRoMeta.setListApi(listApi);
}

void nstool::NsoProcess::setListSymbols(bool listSymbols)
{
	mRoMeta.setListSymbols(listSymbols);
}

const nstool::RoMetadataProcess& nstool::NsoProcess::getRoMetadataProcess() const
{
	return mRoMeta;
}

void nstool::NsoProcess::importHeader()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// check if file_size is smaller than NSO header size
	size_t file_size = tc::io::IOUtil::castInt64ToSize(mFile->length());
	if (file_size < sizeof(pie::hac::sNsoHeader))
	{
		throw tc::Exception(mModuleName, "Corrupt NSO: file too small.");
	}

	// read nso
	tc::ByteData scratch = tc::ByteData(sizeof(pie::hac::sNsoHeader));
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	// parse nso header
	mHdr.fromBytes(scratch.data(), scratch.size());
}

void nstool::NsoProcess::importCodeSegments()
{
	tc::ByteData scratch;
	pie::hac::detail::sha256_hash_t calc_hash;

	// process text segment
	if (mHdr.getTextSegmentInfo().is_compressed)
	{
		// allocate/read compressed text
		scratch = tc::ByteData(mHdr.getTextSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getTextSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(scratch.data(), scratch.size());

		// allocate for decompressed text segment
		mTextBlob = tc::ByteData(mHdr.getTextSegmentInfo().memory_layout.size);

		// decompress text segment
		if (decompressData(scratch.data(), scratch.size(), mTextBlob.data(), mTextBlob.size()) != mTextBlob.size())
		{
			throw tc::Exception(mModuleName, "NSO text segment failed to decompress");
		}
	}
	else
	{
		// read text segment directly (not compressed)
		mTextBlob = tc::ByteData(mHdr.getTextSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getTextSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(mTextBlob.data(), mTextBlob.size());
	}
	if (mHdr.getTextSegmentInfo().is_hashed)
	{
		tc::crypto::GenerateSha2256Hash(calc_hash.data(), mTextBlob.data(), mTextBlob.size());
		if (calc_hash != mHdr.getTextSegmentInfo().hash)
		{
			throw tc::Exception(mModuleName, "NSO text segment failed SHA256 verification");
		}
	}

	// process ro segment
	if (mHdr.getRoSegmentInfo().is_compressed)
	{
		// allocate/read compressed ro segment
		scratch = tc::ByteData(mHdr.getRoSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getRoSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(scratch.data(), scratch.size());

		// allocate for decompressed ro segment
		mRoBlob = tc::ByteData(mHdr.getRoSegmentInfo().memory_layout.size);

		// decompress ro segment
		if (decompressData(scratch.data(), scratch.size(), mRoBlob.data(), mRoBlob.size()) != mRoBlob.size())
		{
			throw tc::Exception(mModuleName, "NSO ro segment failed to decompress");
		}
	}
	else
	{
		// read ro segment directly (not compressed)
		mRoBlob = tc::ByteData(mHdr.getRoSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getRoSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(mRoBlob.data(), mRoBlob.size());
	}
	if (mHdr.getRoSegmentInfo().is_hashed)
	{
		tc::crypto::GenerateSha2256Hash(calc_hash.data(), mRoBlob.data(), mRoBlob.size());
		if (calc_hash != mHdr.getRoSegmentInfo().hash)
		{
			throw tc::Exception(mModuleName, "NSO ro segment failed SHA256 verification");
		}
	}

	// process ro segment
	if (mHdr.getDataSegmentInfo().is_compressed)
	{
		// allocate/read compressed ro segment
		scratch = tc::ByteData(mHdr.getDataSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getDataSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(scratch.data(), scratch.size());

		// allocate for decompressed ro segment
		mDataBlob = tc::ByteData(mHdr.getDataSegmentInfo().memory_layout.size);

		// decompress ro segment
		if (decompressData(scratch.data(), scratch.size(), mDataBlob.data(), mDataBlob.size()) != mDataBlob.size())
		{
			throw tc::Exception(mModuleName, "NSO data segment failed to decompress");
		}
	}
	else
	{
		// read ro segment directly (not compressed)
		mDataBlob = tc::ByteData(mHdr.getDataSegmentInfo().file_layout.size);
		mFile->seek(mHdr.getDataSegmentInfo().file_layout.offset, tc::io::SeekOrigin::Begin);
		mFile->read(mDataBlob.data(), mDataBlob.size());
	}
	if (mHdr.getDataSegmentInfo().is_hashed)
	{
		tc::crypto::GenerateSha2256Hash(calc_hash.data(), mDataBlob.data(), mDataBlob.size());
		if (calc_hash != mHdr.getDataSegmentInfo().hash)
		{
			throw tc::Exception(mModuleName, "NSO data segment failed SHA256 verification");
		}
	}
}

void nstool::NsoProcess::displayNsoHeader()
{
	fmt::print("[NSO Header]\n");
	fmt::print("  ModuleId:           {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mHdr.getModuleId().data(), mHdr.getModuleId().size(), false, ""));
	if (mCliOutputMode.show_layout)
	{
		fmt::print("  Program Segments:\n");
		fmt::print("     .module_name:\n");
		fmt::print("      FileOffset:     0x{:x}\n", mHdr.getModuleNameInfo().offset);
		fmt::print("      FileSize:       0x{:x}\n", mHdr.getModuleNameInfo().size);
		fmt::print("    .text:\n");
		fmt::print("      FileOffset:     0x{:x}\n", mHdr.getTextSegmentInfo().file_layout.offset);
		fmt::print("      FileSize:       0x{:x}{:s}\n", mHdr.getTextSegmentInfo().file_layout.size, (mHdr.getTextSegmentInfo().is_compressed? " (COMPRESSED)" : ""));
		fmt::print("    .ro:\n");
		fmt::print("      FileOffset:     0x{:x}\n", mHdr.getRoSegmentInfo().file_layout.offset);
		fmt::print("      FileSize:       0x{:x}{:s}\n", mHdr.getRoSegmentInfo().file_layout.size, (mHdr.getRoSegmentInfo().is_compressed? " (COMPRESSED)" : ""));
		fmt::print("    .data:\n");
		fmt::print("      FileOffset:     0x{:x}\n", mHdr.getDataSegmentInfo().file_layout.offset);
		fmt::print("      FileSize:       0x{:x}{:s}\n", mHdr.getDataSegmentInfo().file_layout.size, (mHdr.getDataSegmentInfo().is_compressed? " (COMPRESSED)" : ""));
	}
	fmt::print("  Program Sections:\n");
	fmt::print("     .text:\n");
	fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getTextSegmentInfo().memory_layout.offset);
	fmt::print("      MemorySize:     0x{:x}\n", mHdr.getTextSegmentInfo().memory_layout.size);
	if (mHdr.getTextSegmentInfo().is_hashed && mCliOutputMode.show_extended_info)
	{
		fmt::print("      Hash:           {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mHdr.getTextSegmentInfo().hash.data(), mHdr.getTextSegmentInfo().hash.size(), false, ""));
	}
	fmt::print("    .ro:\n");
	fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getRoSegmentInfo().memory_layout.offset);
	fmt::print("      MemorySize:     0x{:x}\n", mHdr.getRoSegmentInfo().memory_layout.size);
	if (mHdr.getRoSegmentInfo().is_hashed && mCliOutputMode.show_extended_info)
	{
		fmt::print("      Hash:           {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mHdr.getRoSegmentInfo().hash.data(), mHdr.getRoSegmentInfo().hash.size(), false, ""));
	}
	if (mCliOutputMode.show_extended_info)
	{
		fmt::print("    .api_info:\n");
		fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getRoEmbeddedInfo().offset);
		fmt::print("      MemorySize:     0x{:x}\n", mHdr.getRoEmbeddedInfo().size);
		fmt::print("    .dynstr:\n");
		fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getRoDynStrInfo().offset);
		fmt::print("      MemorySize:     0x{:x}\n", mHdr.getRoDynStrInfo().size);
		fmt::print("    .dynsym:\n");
		fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getRoDynSymInfo().offset);
		fmt::print("      MemorySize:     0x{:x}\n", mHdr.getRoDynSymInfo().size);
	}
	
	fmt::print("    .data:\n");
	fmt::print("      MemoryOffset:   0x{:x}\n", mHdr.getDataSegmentInfo().memory_layout.offset);
	fmt::print("      MemorySize:     0x{:x}\n", mHdr.getDataSegmentInfo().memory_layout.size);
	if (mHdr.getDataSegmentInfo().is_hashed && mCliOutputMode.show_extended_info)
	{
		fmt::print("      Hash:           {:s}\n", tc::cli::FormatUtil::formatBytesAsString(mHdr.getDataSegmentInfo().hash.data(), mHdr.getDataSegmentInfo().hash.size(), false, ""));
	}
	fmt::print("    .bss:\n");
	fmt::print("      MemorySize:     0x{:x}\n", mHdr.getBssSize());
}

void nstool::NsoProcess::processRoMeta()
{
	if (mRoBlob.size())
	{
		// setup ro metadata
		mRoMeta.setApiInfo(mHdr.getRoEmbeddedInfo().offset, mHdr.getRoEmbeddedInfo().size);
		mRoMeta.setDynSym(mHdr.getRoDynSymInfo().offset, mHdr.getRoDynSymInfo().size);
		mRoMeta.setDynStr(mHdr.getRoDynStrInfo().offset, mHdr.getRoDynStrInfo().size);
		mRoMeta.setRoBinary(mRoBlob);
		mRoMeta.setCliOutputMode(mCliOutputMode);
		mRoMeta.process();
	}
}

size_t nstool::NsoProcess::decompressData(const byte_t* src, size_t src_len, byte_t* dst, size_t dst_capacity)
{
	if (src_len >= LZ4_MAX_INPUT_SIZE)
	{
		return 0;
	}

	int32_t src_len_input = int32_t(src_len);
	int32_t dst_capcacity_input = (dst_capacity < LZ4_MAX_INPUT_SIZE) ? int32_t(dst_capacity) : LZ4_MAX_INPUT_SIZE;

	int32_t decomp_size = LZ4_decompress_safe((const char*)src, (char*)dst, src_len_input, dst_capcacity_input);

	if (decomp_size < 0)
	{
		memset(dst, 0, dst_capacity);
		return 0;
	}

	return size_t(decomp_size);
}
```

`src/NsoProcess.h`:

```h
#pragma once
#include "types.h"
#include "RoMetadataProcess.h"

#include <pietendo/hac/define/meta.h>
#include <pietendo/hac/NsoHeader.h>

namespace nstool {

class NsoProcess
{
public:
	NsoProcess();

	void process();

	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	void setIs64BitInstruction(bool flag);
	void setListApi(bool listApi);
	void setListSymbols(bool listSymbols);

	const nstool::RoMetadataProcess& getRoMetadataProcess() const;
private:
	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;
	bool mIs64BitInstruction;
	bool mListApi;
	bool mListSymbols;

	pie::hac::NsoHeader mHdr;
	tc::ByteData mTextBlob, mRoBlob, mDataBlob;
	nstool::RoMetadataProcess mRoMeta;

	void importHeader();
	void importCodeSegments();
	void displayNsoHeader();
	void processRoMeta();

	size_t decompressData(const byte_t* src, size_t src_len, byte_t* dst, size_t dst_capacity);
};

}
```

`src/PfsProcess.cpp`:

```cpp
#include "PfsProcess.h"
#include "util.h"

#include <pietendo/hac/PartitionFsUtil.h>
#include <tc/io/LocalFileSystem.h>

#include <tc/io/VirtualFileSystem.h>
#include <pietendo/hac/PartitionFsSnapshotGenerator.h>


nstool::PfsProcess::PfsProcess() :
	mModuleName("nstool::PfsProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false),
	mPfs(),
	mFileSystem(),
	mFsProcess()
{
	mFsProcess.setFsFormatName("PartitionFs");
}

void nstool::PfsProcess::process()
{
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	tc::ByteData scratch;

	// read base header to determine complete header size
	if (mFile->length() < tc::io::IOUtil::castSizeToInt64(sizeof(pie::hac::sPfsHeader)))
	{
		throw tc::Exception(mModuleName, "Corrupt PartitionFs: File too small");
	}

	scratch = tc::ByteData(sizeof(pie::hac::sPfsHeader));
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());
	if (validateHeaderMagic(((pie::hac::sPfsHeader*)scratch.data())) == false)
	{
		throw tc::Exception(mModuleName, "Corrupt PartitionFs: Header had incorrect struct magic.");
	}

	// read complete size header
	size_t pfsHeaderSize = determineHeaderSize(((pie::hac::sPfsHeader*)scratch.data()));
	if (mFile->length() < tc::io::IOUtil::castSizeToInt64(pfsHeaderSize))
	{
		throw tc::Exception(mModuleName, "Corrupt PartitionFs: File too small");
	}

	scratch = tc::ByteData(pfsHeaderSize);
	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read(scratch.data(), scratch.size());

	// process PFS
	mPfs.fromBytes(scratch.data(), scratch.size());

	// create virtual filesystem
	mFileSystem = std::make_shared<tc::io::VirtualFileSystem>(tc::io::VirtualFileSystem(pie::hac::PartitionFsSnapshotGenerator(mFile, mVerify ? pie::hac::PartitionFsSnapshotGenerator::ValidationMode_Warn : pie::hac::PartitionFsSnapshotGenerator::ValidationMode_None)));
	mFsProcess.setInputFileSystem(mFileSystem);

	// set properties for FsProcess
	mFsProcess.setFsProperties({
		fmt::format("Type:        {:s}", pie::hac::PartitionFsUtil::getFsTypeAsString(mPfs.getFsType())), 
		fmt::format("FileNum:     {:d}", mPfs.getFileList().size())
	});
	
	mFsProcess.process();
}

void nstool::PfsProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::PfsProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
	mFsProcess.setShowFsInfo(mCliOutputMode.show_basic_info);
}

void nstool::PfsProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::PfsProcess::setShowFsTree(bool show_fs_tree)
{
	mFsProcess.setShowFsTree(show_fs_tree);
}

void nstool::PfsProcess::setFsRootLabel(const std::string& root_label)
{
	mFsProcess.setFsRootLabel(root_label);
}

void nstool::PfsProcess::setExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs)
{
	mFsProcess.setExtractJobs(extract_jobs);
}

const pie::hac::PartitionFsHeader& nstool::PfsProcess::getPfsHeader() const
{
	return mPfs;
}

const std::shared_ptr<tc::io::IFileSystem>& nstool::PfsProcess::getFileSystem() const
{
	return mFileSystem;
}

size_t nstool::PfsProcess::determineHeaderSize(const pie::hac::sPfsHeader* hdr)
{
	size_t fileEntrySize = 0;
	if (hdr->st_magic.unwrap() == pie::hac::pfs::kPfsStructMagic)
		fileEntrySize = sizeof(pie::hac::sPfsFile);
	else
		fileEntrySize = sizeof(pie::hac::sHashedPfsFile);

	return sizeof(pie::hac::sPfsHeader) + hdr->file_num.unwrap() * fileEntrySize + hdr->name_table_size.unwrap();
}

bool nstool::PfsProcess::validateHeaderMagic(const pie::hac::sPfsHeader* hdr)
{
	return hdr->st_magic.unwrap() == pie::hac::pfs::kPfsStructMagic || hdr->st_magic.unwrap() == pie::hac::pfs::kHashedPfsStructMagic;
}
```

`src/PfsProcess.h`:

```h
#pragma once
#include "types.h"
#include "FsProcess.h"

#include <pietendo/hac/PartitionFsHeader.h>

namespace nstool {

class PfsProcess
{
public:
	PfsProcess();

	void process();

	// generic
	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	// fs specific
	void setShowFsTree(bool show_fs_tree);
	void setFsRootLabel(const std::string& root_label);
	void setExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs);

	// post process() get PFS/FS out
	const pie::hac::PartitionFsHeader& getPfsHeader() const;
	const std::shared_ptr<tc::io::IFileSystem>& getFileSystem() const;

private:
	static const size_t kCacheSize = 0x10000;

	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	pie::hac::PartitionFsHeader mPfs;

	std::shared_ptr<tc::io::IFileSystem> mFileSystem;
	FsProcess mFsProcess;
	
	size_t determineHeaderSize(const pie::hac::sPfsHeader* hdr);
	bool validateHeaderMagic(const pie::hac::sPfsHeader* hdr);
};

}
```

`src/PkiValidator.cpp`:

```cpp
#include "PkiValidator.h"

#include <tc/crypto.h>
#include <pietendo/hac/define/types.h>
#include <pietendo/hac/es/SignUtils.h>

nstool::PkiValidator::PkiValidator() :
	mModuleName("nstool::PkiValidator")
{
	clearCertificates();
}

void nstool::PkiValidator::setKeyCfg(const KeyBag& keycfg)
{
	// save a copy of the certificate bank
	std::vector<pie::hac::es::SignedData<pie::hac::es::CertificateBody>> old_certs = mCertificateBank;
	
	// clear the certificate bank
	mCertificateBank.clear();

	// overwrite the root key
	mKeyCfg = keycfg;

	// if there were certificates before, reimport them (so they are checked against the new root key)
	if (old_certs.size() > 0)
	{
		addCertificates(old_certs);
	}
}

void nstool::PkiValidator::addCertificates(const std::vector<pie::hac::es::SignedData<pie::hac::es::CertificateBody>>& certs)
{
	for (size_t i = 0; i < certs.size(); i++)
	{
		addCertificate(certs[i]);
	}
}

void nstool::PkiValidator::addCertificate(const pie::hac::es::SignedData<pie::hac::es::CertificateBody>& cert)
{
	std::string cert_ident;
	pie::hac::es::sign::HashAlgo cert_hash_algo;
	tc::ByteData cert_hash;

	try 
	{	
		makeCertIdent(cert, cert_ident);

		if (doesCertExist(cert_ident) == true)
		{
			throw tc::Exception(mModuleName, "Certificate already exists");
		}

		cert_hash_algo = pie::hac::es::sign::getHashAlgo(cert.getSignature().getSignType());

		// get cert hash
		switch (cert_hash_algo)
		{
		case (pie::hac::es::sign::HASH_ALGO_SHA1):

			cert_hash = tc::ByteData(tc::crypto::Sha1Generator::kHashSize);
			tc::crypto::GenerateSha1Hash(cert_hash.data(), cert.getBody().getBytes().data(), cert.getBody().getBytes().size());
			break;
		case (pie::hac::es::sign::HASH_ALGO_SHA256):
			cert_hash = tc::ByteData(tc::crypto::Sha2256Generator::kHashSize);
			tc::crypto::GenerateSha2256Hash(cert_hash.data(), cert.getBody().getBytes().data(), cert.getBody().getBytes().size());
			break;
		default:
			throw tc::Exception(mModuleName, "Unrecognised hash type");
		}

		validateSignature(cert.getBody().getIssuer(), cert.getSignature().getSignType(), cert.getSignature().getSignature(), cert_hash);

		mCertificateBank.push_back(cert);
	}
	catch (const tc::Exception& e) 
	{
		throw tc::Exception(mModuleName, fmt::format("Failed to add certificate {:s} ({:s})", cert_ident, e.error()));
	}
}

void nstool::PkiValidator::clearCertificates()
{
	mCertificateBank.clear();
}

void nstool::PkiValidator::validateSignature(const std::string& issuer, pie::hac::es::sign::SignatureId signature_id, const tc::ByteData& signature, const tc::ByteData& hash) const
{	
	pie::hac::es::sign::SignatureAlgo sign_algo = pie::hac::es::sign::getSignatureAlgo(signature_id);	

	// validate signature
	bool sig_valid = false;

	// get public key
	// tc::crypto::EccKey ecc_key;
	tc::crypto::RsaKey rsa_key;

	// special case if signed by Root (legacy nstool only defers to keybag for "Root", it did not store certificates)
	if (issuer == "Root")
	{
		auto itr = mKeyCfg.broadon_signer.find(issuer);

		if (itr == mKeyCfg.broadon_signer.end())
		{
			throw tc::Exception(mModuleName, fmt::format("Public key for issuer \"{:s}\" does not exist.", issuer));
		}

		if (sign_algo != itr->second.key_type)
		{
			throw tc::Exception(mModuleName, fmt::format("Public key for issuer \"{:s}\" cannot verify this signature.", issuer));
		}

		if (sign_algo == pie::hac::es::sign::SIGN_ALGO_ECDSA240)
		{
			throw tc::Exception(mModuleName, "ECDSA signatures are not supported");	
		}

		rsa_key = itr->second.rsa_key;
	}
	else
	{
		// try to find issuer cert		
		const pie::hac::es::CertificateBody& issuer_cert = getCert(issuer).getBody();
		pie::hac::es::cert::PublicKeyType issuer_pubk_type = issuer_cert.getPublicKeyType();

		if (issuer_pubk_type == pie::hac::es::cert::RSA4096 && sign_algo == pie::hac::es::sign::SIGN_ALGO_RSA4096)
		{
			rsa_key = issuer_cert.getRsa4096PublicKey();
		}
		else if (issuer_pubk_type == pie::hac::es::cert::RSA2048 && sign_algo == pie::hac::es::sign::SIGN_ALGO_RSA2048)
		{
			rsa_key = issuer_cert.getRsa2048PublicKey();
		}
		else if (issuer_pubk_type == pie::hac::es::cert::ECDSA240 && sign_algo == pie::hac::es::sign::SIGN_ALGO_ECDSA240)
		{
			// ecc_key = issuer_cert.getEcdsa240PublicKey();
			throw tc::Exception(mModuleName, "ECDSA signatures are not supported");
		}
		else
		{
			throw tc::Exception(mModuleName, "Mismatch between issuer public key and signature type");
		}
	}

	// verify signature
	switch (signature_id) {
		case (pie::hac::es::sign::SIGN_ID_RSA4096_SHA1):
			sig_valid = tc::crypto::VerifyRsa4096Pkcs1Sha1(signature.data(), hash.data(), rsa_key);
			break;
		case (pie::hac::es::sign::SIGN_ID_RSA2048_SHA1):
			sig_valid = tc::crypto::VerifyRsa2048Pkcs1Sha1(signature.data(), hash.data(), rsa_key);
			break;
		case (pie::hac::es::sign::SIGN_ID_ECDSA240_SHA1):
			sig_valid = false;
			break;
		case (pie::hac::es::sign::SIGN_ID_RSA4096_SHA256):
			sig_valid = tc::crypto::VerifyRsa4096Pkcs1Sha2256(signature.data(), hash.data(), rsa_key);
			break;
		case (pie::hac::es::sign::SIGN_ID_RSA2048_SHA256):
			sig_valid = tc::crypto::VerifyRsa2048Pkcs1Sha2256(signature.data(), hash.data(), rsa_key);
			break;
		case (pie::hac::es::sign::SIGN_ID_ECDSA240_SHA256):
			sig_valid = false;
			break;
	}

	if (sig_valid == false)
	{
		throw tc::Exception(mModuleName, "Incorrect signature");
	}

	
}

void nstool::PkiValidator::makeCertIdent(const pie::hac::es::SignedData<pie::hac::es::CertificateBody>& cert, std::string& ident) const
{
	makeCertIdent(cert.getBody().getIssuer(), cert.getBody().getSubject(), ident);
}

void nstool::PkiValidator::makeCertIdent(const std::string& issuer, const std::string& subject, std::string& ident) const
{
	ident = issuer + pie::hac::es::sign::kIdentDelimiter + subject;
	ident = ident.substr(0, std::min<size_t>(ident.length(),64));
}

bool nstool::PkiValidator::doesCertExist(const std::string& ident) const
{
	bool exists = false;
	std::string full_cert_name;
	for (size_t i = 0; i < mCertificateBank.size(); i++)
	{
		makeCertIdent(mCertificateBank[i], full_cert_name);
		if (full_cert_name == ident)
		{
			exists = true;
			break;
		}
	}

	return exists;
}

const pie::hac::es::SignedData<pie::hac::es::CertificateBody>& nstool::PkiValidator::getCert(const std::string& ident) const
{
	std::string full_cert_name;
	for (size_t i = 0; i < mCertificateBank.size(); i++)
	{
		makeCertIdent(mCertificateBank[i], full_cert_name);
		if (full_cert_name == ident)
		{
			return mCertificateBank[i];
		}
	}

	throw tc::Exception(mModuleName, "Issuer certificate does not exist");
}
```

`src/PkiValidator.h`:

```h
#pragma once
#include "types.h"
#include "KeyBag.h"

#include <pietendo/hac/es/SignedData.h>
#include <pietendo/hac/es/CertificateBody.h>

namespace nstool {

class PkiValidator
{
public:
	PkiValidator();

	void setKeyCfg(const KeyBag& keycfg);
	void addCertificates(const std::vector<pie::hac::es::SignedData<pie::hac::es::CertificateBody>>& certs);
	void addCertificate(const pie::hac::es::SignedData<pie::hac::es::CertificateBody>& cert);
	void clearCertificates();

	void validateSignature(const std::string& issuer, pie::hac::es::sign::SignatureId signature_id, const tc::ByteData& signature, const tc::ByteData& hash) const;

private:
	std::string mModuleName;

	KeyBag mKeyCfg;
	std::vector<pie::hac::es::SignedData<pie::hac::es::CertificateBody>> mCertificateBank;

	void makeCertIdent(const pie::hac::es::SignedData<pie::hac::es::CertificateBody>& cert, std::string& ident) const;
	void makeCertIdent(const std::string& issuer, const std::string& subject, std::string& ident) const;
	bool doesCertExist(const std::string& ident) const;
	const pie::hac::es::SignedData<pie::hac::es::CertificateBody>& getCert(const std::string& ident) const;
};

}
```

`src/RoMetadataProcess.cpp`:

```cpp
#include "RoMetadataProcess.h"

#include <sstream>
#include <iostream>
#include <iomanip>

nstool::RoMetadataProcess::RoMetadataProcess() :
	mModuleName("nstool::RoMetadataProcess"),
	mCliOutputMode(true, false, false, false),
	mIs64BitInstruction(true),
	mListApi(false),
	mListSymbols(false),
	mApiInfo(),
	mDynSym(),
	mDynStr(),
	mRoBlob(),
	mSdkVerApiList(),
	mPublicApiList(),
	mDebugApiList(),
	mPrivateApiList(),
	mSymbolList()
{

}

void nstool::RoMetadataProcess::process()
{
	importApiList();
	
	if (mCliOutputMode.show_basic_info)
		displayRoMetaData();
}

void nstool::RoMetadataProcess::setRoBinary(const tc::ByteData& bin)
{
	mRoBlob = bin;
}

void nstool::RoMetadataProcess::setApiInfo(size_t offset, size_t size)
{
	mApiInfo.offset = offset;
	mApiInfo.size = size;
}
void nstool::RoMetadataProcess::setDynSym(size_t offset, size_t size)
{
	mDynSym.offset = offset;
	mDynSym.size = size;
}
void nstool::RoMetadataProcess::setDynStr(size_t offset, size_t size)
{
	mDynStr.offset = offset;
	mDynStr.size = size;
}

void nstool::RoMetadataProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
}

void nstool::RoMetadataProcess::setIs64BitInstruction(bool flag)
{
	mIs64BitInstruction = flag;
}

void nstool::RoMetadataProcess::setListApi(bool listApi)
{
	mListApi = listApi;
}

void nstool::RoMetadataProcess::setListSymbols(bool listSymbols)
{
	mListSymbols = listSymbols;
}

const std::vector<nstool::SdkApiString>& nstool::RoMetadataProcess::getSdkVerApiList() const
{
	return mSdkVerApiList;
}

const std::vector<nstool::SdkApiString>& nstool::RoMetadataProcess::getPublicApiList() const
{
	return mPublicApiList;
}

const std::vector<nstool::SdkApiString>& nstool::RoMetadataProcess::getDebugApiList() const
{
	return mDebugApiList;
}

const std::vector<nstool::SdkApiString>& nstool::RoMetadataProcess::getPrivateApiList() const
{
	return mPrivateApiList;
}

const std::vector<nstool::SdkApiString>& nstool::RoMetadataProcess::getGuidelineApiList() const
{
	return mGuidelineApiList;
}

const std::vector<nstool::ElfSymbolParser::sElfSymbol>& nstool::RoMetadataProcess::getSymbolList() const
{
	return mSymbolList.getSymbolList();
}

void nstool::RoMetadataProcess::importApiList()
{
	if (mRoBlob.size() == 0)
	{
		throw tc::Exception(mModuleName, "No ro binary set.");
	}

	if (mApiInfo.size > 0)
	{
		std::stringstream list_stream(std::string((char*)mRoBlob.data() + mApiInfo.offset, mApiInfo.size));
		std::string api_str;

		while(std::getline(list_stream, api_str, (char)0x00))
		{
			SdkApiString api(api_str);

			switch (api.getApiType())
			{
			case SdkApiString::API_SDK_VERSION:
				mSdkVerApiList.push_back(api);
				break;
			case SdkApiString::API_MIDDLEWARE:
				mPublicApiList.push_back(api);
				break;
			case SdkApiString::API_DEBUG:
				mDebugApiList.push_back(api);
				break;
			case SdkApiString::API_PRIVATE:
				mPrivateApiList.push_back(api);
				break;
			case SdkApiString::API_GUIDELINE:
				mGuidelineApiList.push_back(api);
				break;
			default:
				break;
			}
		}
	}

	if (mDynSym.size > 0)
	{
		mSymbolList.parseData(mRoBlob.data() + mDynSym.offset, mDynSym.size, mRoBlob.data() + mDynStr.offset, mDynStr.size, mIs64BitInstruction);
	}
}

void nstool::RoMetadataProcess::displayRoMetaData()
{
	size_t api_num = mSdkVerApiList.size() + mPublicApiList.size() + mDebugApiList.size() + mPrivateApiList.size();
	
	if (api_num > 0 && (mListApi || mCliOutputMode.show_extended_info))
	{
		fmt::print("[SDK API List]\n");
		if (mSdkVerApiList.size() > 0)
		{
			fmt::print("  Sdk Revision: {:s}\n", mSdkVerApiList[0].getModuleName());
		}
		if (mPublicApiList.size() > 0)
		{
			fmt::print("  Public APIs:\n");
			for (size_t i = 0; i < mPublicApiList.size(); i++)
			{
				fmt::print("    {:s} (vender: {:s})\n", mPublicApiList[i].getModuleName(), mPublicApiList[i].getVenderName());
			}
		}
		if (mDebugApiList.size() > 0)
		{
			fmt::print("  Debug APIs:\n");
			for (size_t i = 0; i < mDebugApiList.size(); i++)
			{
				fmt::print("    {:s} (vender: {:s})\n", mDebugApiList[i].getModuleName(), mDebugApiList[i].getVenderName());
			}
		}
		if (mPrivateApiList.size() > 0)
		{
			fmt::print("  Private APIs:\n");
			for (size_t i = 0; i < mPrivateApiList.size(); i++)
			{
				fmt::print("    {:s} (vender: {:s})\n", mPrivateApiList[i].getModuleName(), mPrivateApiList[i].getVenderName());
			}
		}
		if (mGuidelineApiList.size() > 0)
		{
			fmt::print("  Guideline APIs:\n");
			for (size_t i = 0; i < mGuidelineApiList.size(); i++)
			{
				fmt::print("    {:s} (vender: {:s})\n", mGuidelineApiList[i].getModuleName(), mGuidelineApiList[i].getVenderName());
			}
		}
	}
	if (mSymbolList.getSymbolList().size() > 0 && (mListSymbols || mCliOutputMode.show_extended_info))
	{
		fmt::print("[Symbol List]\n");
		for (size_t i = 0; i < mSymbolList.getSymbolList().size(); i++)
		{
			const ElfSymbolParser::sElfSymbol& symbol = mSymbolList.getSymbolList()[i];
			fmt::print("  {:s}  [SHN={:s} ({:04x})][STT={:s}][STB={:s}]\n", symbol.name, getSectionIndexStr(symbol.shn_index), symbol.shn_index, getSymbolTypeStr(symbol.symbol_type), getSymbolBindingStr(symbol.symbol_binding));
		}
	}
}

std::string nstool::RoMetadataProcess::getSectionIndexStr(uint16_t shn_index) const
{
	std::string str;
	switch (shn_index)
	{
		case (elf::SHN_UNDEF):
			str = "UNDEF";
			break;
		case (elf::SHN_LOPROC):
			str = "LOPROC";
			break;
		case (elf::SHN_HIPROC):
			str = "HIPROC";
			break;
		case (elf::SHN_LOOS):
			str = "LOOS";
			break;
		case (elf::SHN_HIOS):
			str = "HIOS";
			break;
		case (elf::SHN_ABS):
			str = "ABS";
			break;
		case (elf::SHN_COMMON):
			str = "COMMON";
			break;
		default:
			str = "UNKNOWN";
			break;
	}
	return str;
}

std::string nstool::RoMetadataProcess::getSymbolTypeStr(byte_t symbol_type) const
{
	std::string str;
	switch (symbol_type)
	{
		case (elf::STT_NOTYPE):
			str = "NOTYPE";
			break;
		case (elf::STT_OBJECT):
			str = "OBJECT";
			break;
		case (elf::STT_FUNC):
			str = "FUNC";
			break;
		case (elf::STT_SECTION):
			str = "SECTION";
			break;
		case (elf::STT_FILE):
			str = "FILE";
			break;
		case (elf::STT_LOOS):
			str = "LOOS";
			break;
		case (elf::STT_HIOS):
			str = "HIOS";
			break;
		case (elf::STT_LOPROC):
			str = "LOPROC";
			break;
		case (elf::STT_HIPROC):
			str = "HIPROC";
			break;
		default:
			str = "UNKNOWN";
			break;
	}
	return str;
}

std::string nstool::RoMetadataProcess::getSymbolBindingStr(byte_t symbol_binding) const
{
	std::string str;
	switch (symbol_binding)
	{
		case (elf::STB_LOCAL):
			str = "LOCAL";
			break;
		case (elf::STB_GLOBAL):
			str = "GLOBAL";
			break;
		case (elf::STB_WEAK):
			str = "WEAK";
			break;
		case (elf::STB_LOOS):
			str = "LOOS";
			break;
		case (elf::STB_HIOS):
			str = "HIOS";
			break;
		case (elf::STB_LOPROC):
			str = "LOPROC";
			break;
		case (elf::STB_HIPROC):
			str = "HIPROC";
			break;
		default:
			str = "UNKNOWN";
			break;
	}
	return str;
}
```

`src/RoMetadataProcess.h`:

```h
#pragma once
#include "types.h"
#include "SdkApiString.h"
#include "ElfSymbolParser.h"

#include <pietendo/hac/define/meta.h>

namespace nstool {

class RoMetadataProcess
{
public:
	RoMetadataProcess();

	void process();

	void setRoBinary(const tc::ByteData& bin);
	void setApiInfo(size_t offset, size_t size);
	void setDynSym(size_t offset, size_t size);
	void setDynStr(size_t offset, size_t size);

	void setCliOutputMode(CliOutputMode type);

	void setIs64BitInstruction(bool flag);
	void setListApi(bool listApi);
	void setListSymbols(bool listSymbols);

	const std::vector<nstool::SdkApiString>& getSdkVerApiList() const;
	const std::vector<nstool::SdkApiString>& getPublicApiList() const;
	const std::vector<nstool::SdkApiString>& getDebugApiList() const;
	const std::vector<nstool::SdkApiString>& getPrivateApiList() const;
	const std::vector<nstool::SdkApiString>& getGuidelineApiList() const;
	const std::vector<nstool::ElfSymbolParser::sElfSymbol>& getSymbolList() const;
private:
	std::string mModuleName;

	CliOutputMode mCliOutputMode;
	bool mIs64BitInstruction;
	bool mListApi;
	bool mListSymbols;	

	struct sLayout 
	{ 
		sLayout() : offset(0), size(0) {}
		size_t offset;
		size_t size;
	};

	sLayout mApiInfo;
	sLayout mDynSym;
	sLayout mDynStr;
	tc::ByteData mRoBlob;
	std::vector<SdkApiString> mSdkVerApiList;
	std::vector<SdkApiString> mPublicApiList;
	std::vector<SdkApiString> mDebugApiList;
	std::vector<SdkApiString> mPrivateApiList;
	std::vector<SdkApiString> mGuidelineApiList;
	
	ElfSymbolParser mSymbolList;

	void importApiList();
	void displayRoMetaData();

	std::string getSectionIndexStr(uint16_t shn_index) const;
	std::string getSymbolTypeStr(byte_t symbol_type) const;
	std::string getSymbolBindingStr(byte_t symbol_binding) const;
};

}
```

`src/RomfsProcess.cpp`:

```cpp
#include "RomfsProcess.h"
#include "util.h"

#include <tc/io/VirtualFileSystem.h>
#include <pietendo/hac/RomFsSnapshotGenerator.h>


nstool::RomfsProcess::RomfsProcess() :
	mModuleName("nstool::RomfsProcess"),
	mFile(),
	mCliOutputMode(true, false, false, false),
	mVerify(false),
	mDirNum(0),
	mFileNum(0),
	mFileSystem(),
	mFsProcess()
{
	mFsProcess.setFsFormatName("RomFs");
}

void nstool::RomfsProcess::process()
{
	// state checks
	if (mFile == nullptr)
	{
		throw tc::Exception(mModuleName, "No file reader set.");
	}
	if (mFile->canRead() == false || mFile->canSeek() == false)
	{
		throw tc::NotSupportedException(mModuleName, "Input stream requires read/seek permissions.");
	}

	// read base header to determine complete header size
	if (mFile->length() < tc::io::IOUtil::castSizeToInt64(sizeof(pie::hac::sRomfsHeader)))
	{
		throw tc::Exception(mModuleName, "Corrupt RomFs: File too small");
	}

	mFile->seek(0, tc::io::SeekOrigin::Begin);
	mFile->read((byte_t*)&mRomfsHeader, sizeof(mRomfsHeader));
	if (mRomfsHeader.header_size.unwrap() != sizeof(pie::hac::sRomfsHeader) ||
	    mRomfsHeader.dir_entry.offset.unwrap() != (mRomfsHeader.dir_hash_bucket.offset.unwrap() + mRomfsHeader.dir_hash_bucket.size.unwrap()) ||
	    mRomfsHeader.data_offset.unwrap() != align<int64_t>(mRomfsHeader.header_size.unwrap(), pie::hac::romfs::kRomfsHeaderAlign))
	{
		throw tc::ArgumentOutOfRangeException(mModuleName, "Corrupt RomFs: RomFsHeader is corrupted.");
	}

	/*
	fmt::print("RomFsHeader:\n");
	fmt::print(" > header_size = 0x{:04x}\n", mRomfsHeader.header_size.unwrap());
	fmt::print(" > dir_hash_bucket\n");
	fmt::print("   > offset =    0x{:04x}\n", mRomfsHeader.dir_hash_bucket.offset.unwrap());
	fmt::print("   > size =      0x{:04x}\n", mRomfsHeader.dir_hash_bucket.size.unwrap());
	fmt::print(" > dir_entry\n");
	fmt::print("   > offset =    0x{:04x}\n", mRomfsHeader.dir_entry.offset.unwrap());
	fmt::print("   > size =      0x{:04x}\n", mRomfsHeader.dir_entry.size.unwrap());
	fmt::print(" > file_hash_bucket\n");
	fmt::print("   > offset =    0x{:04x}\n", mRomfsHeader.file_hash_bucket.offset.unwrap())
	fmt::print("   > size =      0x{:04x}\n", mRomfsHeader.file_hash_bucket.size.unwrap());
	fmt::print(" > file_entry\n");
	fmt::print("   > offset =    0x{:04x}\n", mRomfsHeader.file_entry.offset.unwrap());
	fmt::print("   > size =      0x{:04x}\n", mRomfsHeader.file_entry.size.unwrap());
	fmt::print(" > data_offset = 0x{:04x}\n", mRomfsHeader.data_offset.unwrap());
	*/

	// get dir entry ptr
	tc::ByteData dir_entry_table = tc::ByteData();
	if (mRomfsHeader.dir_entry.size.unwrap() > 0)
	{
		dir_entry_table = tc::ByteData(tc::io::IOUtil::castInt64ToSize(mRomfsHeader.dir_entry.size.unwrap()));
		mFile->seek(mRomfsHeader.dir_entry.offset.unwrap(), tc::io::SeekOrigin::Begin);
		mFile->read(dir_entry_table.data(), dir_entry_table.size());
	}

	// get file entry ptr
	tc::ByteData file_entry_table = tc::ByteData();
	if (mRomfsHeader.file_entry.size.unwrap() > 0)
	{
		file_entry_table = tc::ByteData(tc::io::IOUtil::castInt64ToSize(mRomfsHeader.file_entry.size.unwrap()));
		mFile->seek(mRomfsHeader.file_entry.offset.unwrap(), tc::io::SeekOrigin::Begin);
		mFile->read(file_entry_table.data(), file_entry_table.size());
	}

	// count dir num
	mDirNum = 0;
	for (uint32_t v_addr = 0; size_t(v_addr) < dir_entry_table.size();)
	{
		uint32_t total_size = sizeof(pie::hac::sRomfsDirEntry) + align<uint32_t>(((pie::hac::sRomfsDirEntry*)(dir_entry_table.data() + v_addr))->name_size.unwrap(), 4);

		// don't count root directory
		if (v_addr != 0)
		{
			mDirNum += 1;
		}

		v_addr += total_size;
	}

	// count file num
	mFileNum = 0;
	for (uint32_t v_addr = 0; size_t(v_addr) < file_entry_table.size();)
	{
		uint32_t total_size = sizeof(pie::hac::sRomfsFileEntry) + align<uint32_t>(((pie::hac::sRomfsFileEntry*)(file_entry_table.data() + v_addr))->name_size.unwrap(), 4);

		mFileNum += 1;

		v_addr += total_size;
	}

	// create virtual filesystem
	mFileSystem = std::make_shared<tc::io::VirtualFileSystem>(tc::io::VirtualFileSystem(pie::hac::RomFsSnapshotGenerator(mFile)));
	mFsProcess.setInputFileSystem(mFileSystem);

	// set properties for FsProcess
	mFsProcess.setFsProperties({
		fmt::format("DirNum:      {:d}", mDirNum), 
		fmt::format("FileNum:     {:d}", mFileNum)
	});

	// process filesystem
	mFsProcess.process();
}

void nstool::RomfsProcess::setInputFile(const std::shared_ptr<tc::io::IStream>& file)
{
	mFile = file;
}

void nstool::RomfsProcess::setCliOutputMode(CliOutputMode type)
{
	mCliOutputMode = type;
	mFsProcess.setShowFsInfo(mCliOutputMode.show_basic_info);
}

void nstool::RomfsProcess::setVerifyMode(bool verify)
{
	mVerify = verify;
}

void nstool::RomfsProcess::setFsRootLabel(const std::string& root_label)
{
	mFsProcess.setFsRootLabel(root_label);
}

void nstool::RomfsProcess::setExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs)
{
	mFsProcess.setExtractJobs(extract_jobs);
}

void nstool::RomfsProcess::setShowFsTree(bool list_fs)
{
	mFsProcess.setShowFsTree(list_fs);
}
```

`src/RomfsProcess.h`:

```h
#pragma once
#include "types.h"
#include "FsProcess.h"

#include <pietendo/hac/define/romfs.h>

namespace nstool {

class RomfsProcess
{
public:
	RomfsProcess();

	void process();

	// generic
	void setInputFile(const std::shared_ptr<tc::io::IStream>& file);
	void setCliOutputMode(CliOutputMode type);
	void setVerifyMode(bool verify);

	// fs specific
	void setFsRootLabel(const std::string& root_label);
	void setExtractJobs(const std::vector<nstool::ExtractJob>& extract_jobs);
	void setShowFsTree(bool show_fs_tree);
private:
	static const size_t kCacheSize = 0x10000;

	std::string mModuleName;

	std::shared_ptr<tc::io::IStream> mFile;
	CliOutputMode mCliOutputMode;
	bool mVerify;

	pie::hac::sRomfsHeader mRomfsHeader;
	size_t mDirNum;
	size_t mFileNum;

	std::shared_ptr<tc::io::IFileSystem> mFileSystem;
	FsProcess mFsProcess;
};

}
```

`src/SdkApiString.cpp`:

```cpp
#include <sstream>
#include "SdkApiString.h"

nstool::SdkApiString::SdkApiString(const std::string& full_str) :
	SdkApiString(API_MIDDLEWARE, "", "")
{
	resolveApiString(full_str);
}

nstool::SdkApiString::SdkApiString(ApiType type, const std::string& vender_name, const std::string& module_name) :
	mApiType(type),
	mVenderName(vender_name),
	mModuleName(module_name)
{

}

void nstool::SdkApiString::operator=(const SdkApiString& other)
{
	mApiType = other.mApiType;
	mVenderName = other.mVenderName;
	mModuleName = other.mModuleName;
}

nstool::SdkApiString::ApiType nstool::SdkApiString::getApiType() const
{
	return mApiType;
}

void nstool::SdkApiString::setApiType(ApiType type)
{
	mApiType = type;
}

const std::string& nstool::SdkApiString::getVenderName() const
{
	return mVenderName;
}

void nstool::SdkApiString::setVenderName(const std::string& name)
{
	mVenderName = name;
}

const std::string& nstool::SdkApiString::getModuleName() const
{
	return mModuleName;
}

void nstool::SdkApiString::setModuleName(const std::string& name)
{
	mModuleName = name;
}

void nstool::SdkApiString::resolveApiString(const std::string& full_str)
{
	std::stringstream list_stream(full_str);
	std::string api_type, vender, module;

	std::getline(list_stream, api_type, kSplitChar);
	std::getline(list_stream, vender, kSplitChar);
	std::getline(list_stream, module);


	if (api_type == kSdkMiddleWareApiString)
	{
		if (vender == kVenderNintendo && module.find(kSdkVersionString) != std::string::npos)
		{
			mApiType = API_SDK_VERSION;
		}
		else
		{
			mApiType = API_MIDDLEWARE;
		}
	}
	else if (api_type == kSdkDebugApiString)
	{
		mApiType = API_DEBUG;
	}
	else if (api_type == kSdkPrivateApiString)
	{
		mApiType = API_PRIVATE;
	}
	else if (api_type == kSdkGuidelineApiString)
	{
		mApiType = API_GUIDELINE;
	}
	else
	{
		// TODO?
	}

	mVenderName = vender;
	mModuleName = module;
}
```

`src/SdkApiString.h`:

```h
#pragma once
#include "types.h"

namespace nstool {

class SdkApiString
{
public:
	enum ApiType
	{
		API_MIDDLEWARE,
		API_DEBUG,
		API_PRIVATE,
		API_SDK_VERSION,
		API_GUIDELINE,
	};

	SdkApiString(const std::string& full_str);
	SdkApiString(ApiType type, const std::string& vender_name, const std::string& module_name);

	void operator=(const SdkApiString& other);

	ApiType getApiType() const;
	void setApiType(ApiType type);

	const std::string& getVenderName() const;
	void setVenderName(const std::string& name);

	const std::string& getModuleName() const;
	void setModuleName(const std::string& name);
private:
	const std::string kModuleName = "SdkApiString";

	const char kSplitChar = '+';
	const std::string kSdkMiddleWareApiString = "SDK MW";
	const std::string kSdkDebugApiString = "SDK Debug";
	const std::string kSdkPrivateApiString = "SDK Private";
	const std::string kSdkGuidelineApiString = "SDK Guideline";
	const std::string kVenderNintendo = "Nintendo";
	const std::string kSdkVersionString = "NintendoSdk_nnSdk-";

	ApiType mApiType;
	std::string mVenderName;
	std::string mModuleName;

	void resolveApiString(const std::string& full_str);
};

}
```

`src/Settings.cpp`:

```cpp
#include "Settings.h"
#include "types.h"
#include "version.h"
#include "util.h"

#include <tc/cli.h>
#include <tc/os/Environment.h>
#include <tc/ArgumentException.h>
#include <tc/io/FileStream.h>
#include <tc/io/StreamSource.h>

#include <pietendo/hac/ContentArchiveUtil.h>
#include <pietendo/hac/AesKeygen.h>
#include <pietendo/hac/define/gc.h>
#include <pietendo/hac/define/pfs.h>
#include <pietendo/hac/define/nca.h>
#include <pietendo/hac/define/meta.h>
#include <pietendo/hac/define/romfs.h>
#include <pietendo/hac/define/cnmt.h>
#include <pietendo/hac/define/nacp.h>
#include <pietendo/hac/define/nso.h>
#include <pietendo/hac/define/nro.h>
#include <pietendo/hac/define/ini.h>
#include <pietendo/hac/define/kip.h>
#include <pietendo/hac/define/aset.h>
#include <pietendo/hac/es/SignedData.h>
#include <pietendo/hac/es/CertificateBody.h>
#include <pietendo/hac/es/SignUtils.h>
#include <pietendo/hac/es/TicketBody_V2.h>

class UnkOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	UnkOptionHandler(const std::string& module_label) : mModuleLabel(module_label)
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		throw tc::InvalidOperationException("getOptionStrings() not defined for UnkOptionHandler.");
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		throw tc::InvalidOperationException("getOptionRegexPatterns() not defined for UnkOptionHandler.");
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		throw tc::Exception(mModuleLabel, "Unrecognized option: \"" + option + "\"");
	}
private:
	std::string mModuleLabel;
};

class DeprecatedOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	DeprecatedOptionHandler(const std::string& warn_message, const std::vector<std::string>& opts) : 
		mWarnMessage(warn_message),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		fmt::print("[WARNING] Option \"{}\" is deprecated.{}{}\n", option, (mWarnMessage.empty() ? "" : " "), mWarnMessage);
	}
private:
	std::string mWarnMessage;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class FlagOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	FlagOptionHandler(bool& flag, const std::vector<std::string>& opts) : 
		mFlag(flag),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() != 0)
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" is a flag, that takes no parameters.", option));
		}

		mFlag = true;
	}
private:
	bool& mFlag;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class SingleParamStringOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	SingleParamStringOptionHandler(tc::Optional<std::string>& param, const std::vector<std::string>& opts) : 
		mParam(param),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() != 1)
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" requires a parameter.", option));
		}

		mParam = params[0];
	}
private:
	tc::Optional<std::string>& mParam;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class SingleParamPathOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	SingleParamPathOptionHandler(tc::Optional<tc::io::Path>& param, const std::vector<std::string>& opts) : 
		mParam(param),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() != 1)
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" requires a parameter.", option));
		}

		mParam = params[0];
	}
private:
	tc::Optional<tc::io::Path>& mParam;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class SingleParamSizetOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	SingleParamSizetOptionHandler(size_t& param, const std::vector<std::string>& opts) : 
		mParam(param),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() != 1)
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" requires a parameter.", option));
		}

		mParam = strtoul(params[0].c_str(), nullptr, 0);
	}
private:
	size_t& mParam;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class SingleParamAesKeyOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	SingleParamAesKeyOptionHandler(tc::Optional<nstool::KeyBag::aes128_key_t>& param, const std::vector<std::string>& opts) :
		mParam(param),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() != 1)
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" requires a parameter.", option));
		}

		tc::ByteData key_raw = tc::cli::FormatUtil::hexStringToBytes(params[0]);
		if (key_raw.size() != sizeof(nstool::KeyBag::aes128_key_t))
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option: \"{:s}\", requires an AES128 key as the parameter (must be 32 hex chars).", option));
		}

		nstool::KeyBag::aes128_key_t key_tmp;
		memcpy(key_tmp.data(), key_raw.data(), key_tmp.size());

		mParam = key_tmp;
	}
private:
	tc::Optional<nstool::KeyBag::aes128_key_t>& mParam;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class FileTypeOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	FileTypeOptionHandler(nstool::Settings::FileType& param, const std::vector<std::string>& opts) : 
		mParam(param),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() != 1)
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" requires a parameter.", option));
		}

		if (params[0] == "gc" \
		 || params[0] == "gamecard" \
		 || params[0] == "xci" \
		 || params[0] == "xcie" \
		 || params[0] == "xcir")
		{
			mParam = nstool::Settings::FILE_TYPE_GAMECARD;
		}
		else if (params[0] == "nsp")
		{
			mParam = nstool::Settings::FILE_TYPE_NSP;
		}
		else if (params[0] == "partitionfs" || params[0] == "hashedpartitionfs" \
		 || params[0] == "pfs" || params[0] == "pfs0"  \
		 || params[0] == "hfs" || params[0] == "hfs0")
		{
			mParam = nstool::Settings::FILE_TYPE_PARTITIONFS;
		}
		else if (params[0] == "romfs")
		{
			mParam = nstool::Settings::FILE_TYPE_ROMFS;
		}
		else if (params[0] == "nca" || params[0] == "contentarchive")
		{
			mParam = nstool::Settings::FILE_TYPE_NCA;
		}
		else if (params[0] == "meta" || params[0] == "npdm")
		{
			mParam = nstool::Settings::FILE_TYPE_META;
		}
		else if (params[0] == "cnmt")
		{
			mParam = nstool::Settings::FILE_TYPE_CNMT;
		}
		else if (params[0] == "nso")
		{
			mParam = nstool::Settings::FILE_TYPE_NSO;
		}
		else if (params[0] == "nro")
		{
			mParam = nstool::Settings::FILE_TYPE_NRO;
		}
		else if (params[0] == "ini")
		{
			mParam = nstool::Settings::FILE_TYPE_INI;
		}
		else if (params[0] == "kip")
		{
			mParam = nstool::Settings::FILE_TYPE_KIP;
		}
		else if (params[0] == "nacp")
		{
			mParam = nstool::Settings::FILE_TYPE_NACP;
		}
		else if (params[0] == "cert")
		{
			mParam = nstool::Settings::FILE_TYPE_ES_CERT;
		}
		else if (params[0] == "tik")
		{
			mParam = nstool::Settings::FILE_TYPE_ES_TIK;
		}
		else if (params[0] == "aset" || params[0] == "asset")
		{
			mParam = nstool::Settings::FILE_TYPE_HB_ASSET;
		}
		else
		{
			throw tc::ArgumentException(fmt::format("File type \"{}\" unrecognised.", params[0]));
		}
	}
private:
	nstool::Settings::FileType& mParam;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class InstructionTypeOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	InstructionTypeOptionHandler(bool& param, const std::vector<std::string>& opts) :
		mParam(param),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() != 1)
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" requires a parameter.", option));
		}

		if (params[0] == "32bit")
		{
			mParam = false;
		}
		else if (params[0] == "64bit")
		{
			mParam = true;
		}
		else
		{
			throw tc::ArgumentException(fmt::format("Instruction type \"{}\" unrecognised. Try \"32bit\" or \"64bit\"", params[0]));
		}
	}
private:
	bool& mParam;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class ExtractDataPathOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	ExtractDataPathOptionHandler(std::vector<nstool::ExtractJob>& jobs, const std::vector<std::string>& opts) : 
		mJobs(jobs),
		mOptStrings(opts),
		mOptRegex()
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() == 1)
		{
			mJobs.push_back({tc::io::Path("/"), tc::io::Path(params[0])});
		}
		else if (params.size() == 2)
		{
			mJobs.push_back({tc::io::Path(params[0]), tc::io::Path(params[1])});
		} 
		else
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" requires parameters in the format \"[<internal path>] <extract path>\".", option));
		}
	}
private:
	std::vector<nstool::ExtractJob>& mJobs;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
};

class CustomExtractDataPathOptionHandler : public tc::cli::OptionParser::IOptionHandler
{
public:
	CustomExtractDataPathOptionHandler(std::vector<nstool::ExtractJob>& jobs, const std::vector<std::string>& opts, const tc::io::Path& custom_path) : 
		mJobs(jobs),
		mOptStrings(opts),
		mOptRegex(),
		mCustomPath(custom_path)
	{}

	const std::vector<std::string>& getOptionStrings() const
	{
		return mOptStrings;
	}

	const std::vector<std::string>& getOptionRegexPatterns() const
	{
		return mOptRegex;
	}

	void processOption(const std::string& option, const std::vector<std::string>& params)
	{
		if (params.size() != 1)
		{
			throw tc::ArgumentOutOfRangeException(fmt::format("Option \"{:s}\" requires a parameter.", option));
		}

		fmt::print("[WARNING] \"{:s} {:s}\" is deprecated. ", option, params[0]);
		// if custom path is root path, use the shortened version of -x
		if (mCustomPath == tc::io::Path("/"))
		{
			fmt::print("Consider using \"-x {:s}\" instead.\n", params[0]);
		}
		else
		{
			fmt::print("Consider using \"-x {:s} {:s}\" instead.\n", mCustomPath.to_string(), params[0]);
		}
			

		mJobs.push_back({mCustomPath, tc::io::Path(params[0])});
	}
private:
	std::vector<nstool::ExtractJob>& mJobs;
	std::vector<std::string> mOptStrings;
	std::vector<std::string> mOptRegex;
	tc::io::Path mCustomPath;
};

nstool::SettingsInitializer::SettingsInitializer(const std::vector<std::string>& args) :
	Settings(),
	mModuleLabel("nstool::SettingsInitializer"),
	mShowLayout(false),
	mShowKeydata(false),
	mVerbose(false),
	mNcaEncryptedContentKey(),
	mNcaContentKey(),
	mTikPath(),
	mCertPath()
{
	// parse input arguments
	parse_args(args);
	if (infile.path.isNull())
		throw tc::ArgumentException(mModuleLabel, "No input file was specified.");

	// determine CLI output mode
	opt.cli_output_mode.show_basic_info = true;
	if (mVerbose)
	{
		opt.cli_output_mode.show_extended_info = true;
		opt.cli_output_mode.show_layout = true;
		opt.cli_output_mode.show_keydata = true;
	}
	if (mShowKeydata)
	{
		opt.cli_output_mode.show_keydata = true;
	}
	if (mShowLayout)
	{
		opt.cli_output_mode.show_layout = true;
	}

	// locate key file, if not specfied
	if (mKeysetPath.isNull())
	{
		std::string home_path_str;
		if (tc::os::getEnvVar("HOME", home_path_str) || tc::os::getEnvVar("USERPROFILE", home_path_str))
		{
			tc::io::Path keyfile_path = tc::io::Path(home_path_str);
			keyfile_path.push_back(".switch");
			keyfile_path.push_back(opt.is_dev ? "dev.keys" : "prod.keys");

			try {
				tc::io::FileStream test = tc::io::FileStream(keyfile_path, tc::io::FileMode::Open, tc::io::FileAccess::Read);
				
				mKeysetPath = keyfile_path;
			}
			catch (tc::io::FileNotFoundException&) {
				fmt::print("[WARNING] Failed to load \"{}\" keyfile. Maybe specify it with \"-k <path>\"?\n", opt.is_dev ? "dev.keys" : "prod.keys");
			}
		}
		else {
			fmt::print("[WARNING] Failed to located \"{}\" keyfile. Maybe specify it with \"-k <path>\"?\n", opt.is_dev ? "dev.keys" : "prod.keys");
		}
	}

	// generate keybag
	opt.keybag = KeyBagInitializer(opt.is_dev, mKeysetPath, mTikPath, mCertPath);
	opt.keybag.fallback_enc_content_key = mNcaEncryptedContentKey;
	opt.keybag.fallback_content_key = mNcaContentKey;

	// dump keys if requires
	if (mShowKeydata) // but not opt.cli_output_mode.show_keydata, since this that enabled by toggling -v,--verbose, personally I don't think a summary of imported keydata should be included in verbose output.
	{
		dump_keys();
	}

	// determine filetype if not manually specified
	if (infile.filetype == FILE_TYPE_ERROR)
	{
		determine_filetype();
		if (infile.filetype == FILE_TYPE_ERROR)
		{
			throw tc::ArgumentException(mModuleLabel, "Input file type was undetermined.");
		}
	}
}

void nstool::SettingsInitializer::parse_args(const std::vector<std::string>& args)
{
	// check for minimum arguments
	if (args.size() < 2)
	{
		usage_text();
		throw tc::ArgumentException(mModuleLabel, "Not enough arguments.");
	}
	
	// detect request for help
	for (auto itr = ++(args.begin()); itr != args.end(); itr++)
	{
		if (*itr == "-h" || *itr == "--help" || *itr == "-help")
		{
			usage_text();
			throw tc::ArgumentException(mModuleLabel, "Help required.");
		}
	}

	// save input file
	infile.path = tc::io::Path(args.back());

	// test new option parser
	tc::cli::OptionParser opts;

	// register unk option handler
	opts.registerUnrecognisedOptionHandler(std::shared_ptr<UnkOptionHandler>(new UnkOptionHandler(mModuleLabel)));

	// register handler for deprecated options DeprecatedOptionHandler
	// none just yet

	// get option flags
	opts.registerOptionHandler(std::shared_ptr<FlagOptionHandler>(new FlagOptionHandler(mShowLayout, {"--showlayout"})));
	opts.registerOptionHandler(std::shared_ptr<FlagOptionHandler>(new FlagOptionHandler(mShowKeydata, { "--showkeys" })));
	opts.registerOptionHandler(std::shared_ptr<FlagOptionHandler>(new FlagOptionHandler(mVerbose, {"-v", "--verbose"})));
	opts.registerOptionHandler(std::shared_ptr<FlagOptionHandler>(new FlagOptionHandler(opt.verify, {"-y", "--verify"})));
	opts.registerOptionHandler(std::shared_ptr<FlagOptionHandler>(new FlagOptionHandler(opt.is_dev, {"-d", "--dev"})));

	// process input file type
	opts.registerOptionHandler(std::shared_ptr<FileTypeOptionHandler>(new FileTypeOptionHandler(infile.filetype, { "-t", "--type" })));

	// get user-provided keydata
	opts.registerOptionHandler(std::shared_ptr<SingleParamPathOptionHandler>(new SingleParamPathOptionHandler(mKeysetPath, {"-k", "--keyset"})));
	opts.registerOptionHandler(std::shared_ptr<SingleParamAesKeyOptionHandler>(new SingleParamAesKeyOptionHandler(mNcaEncryptedContentKey, {"--titlekey"})));
	opts.registerOptionHandler(std::shared_ptr<SingleParamAesKeyOptionHandler>(new SingleParamAesKeyOptionHandler(mNcaContentKey, {"--contentkey", "--bodykey"})));
	opts.registerOptionHandler(std::shared_ptr<SingleParamPathOptionHandler>(new SingleParamPathOptionHandler(mTikPath, {"--tik"})));
	opts.registerOptionHandler(std::shared_ptr<SingleParamPathOptionHandler>(new SingleParamPathOptionHandler(mCertPath, {"--cert"})));

	// code options
	opts.registerOptionHandler(std::shared_ptr<FlagOptionHandler>(new FlagOptionHandler(code.list_api, { "--listapi" })));
	opts.registerOptionHandler(std::shared_ptr<FlagOptionHandler>(new FlagOptionHandler(code.list_symbols, { "--listsym" })));
	opts.registerOptionHandler(std::shared_ptr<InstructionTypeOptionHandler>(new InstructionTypeOptionHandler(code.is_64bit_instruction, { "--insttype" })));

	// fs options
	opts.registerOptionHandler(std::shared_ptr<FlagOptionHandler>(new FlagOptionHandler(fs.show_fs_tree, { "--fstree", "--listfs" })));
	opts.registerOptionHandler(std::shared_ptr<ExtractDataPathOptionHandler>(new ExtractDataPathOptionHandler(fs.extract_jobs, { "-x", "--extract" })));
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--fsdir" }, tc::io::Path("/"))));

	// xci options
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--update" }, tc::io::Path("/update/"))));
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--normal" }, tc::io::Path("/normal/"))));
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--secure" }, tc::io::Path("/secure/"))));
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--logo" }, tc::io::Path("/logo/"))));

	// nca options
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--part0" }, tc::io::Path("/0/"))));
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--part1" }, tc::io::Path("/1/"))));
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--part2" }, tc::io::Path("/2/"))));
	opts.registerOptionHandler(std::shared_ptr<CustomExtractDataPathOptionHandler>(new CustomExtractDataPathOptionHandler(fs.extract_jobs, { "--part3" }, tc::io::Path("/3/"))));

	opts.registerOptionHandler(std::shared_ptr<SingleParamPathOptionHandler>(new SingleParamPathOptionHandler(nca.base_nca_path, { "--basenca" })));

	// kip options
	opts.registerOptionHandler(std::shared_ptr<SingleParamPathOptionHandler>(new SingleParamPathOptionHandler(kip.extract_path, { "--kipdir" })));
	
	// aset options
	opts.registerOptionHandler(std::shared_ptr<SingleParamPathOptionHandler>(new SingleParamPathOptionHandler(aset.icon_extract_path, { "--icon" })));
	opts.registerOptionHandler(std::shared_ptr<SingleParamPathOptionHandler>(new SingleParamPathOptionHandler(aset.nacp_extract_path, { "--nacp" })));

	
	// process option
	opts.processOptions(args, 1, args.size() - 2);
}

void nstool::SettingsInitializer::determine_filetype()
{
	//fmt::print("infile path = \"{}\"\n", infile.path.get().to_string());
	
	auto file = tc::io::StreamSource(std::make_shared<tc::io::FileStream>(tc::io::FileStream(infile.path.get(), tc::io::FileMode::Open, tc::io::FileAccess::Read)));

	auto raw_data = file.pullData(0, 0x5000);

#define _TYPE_PTR(st) ((st*)(raw_data.data()))
#define _ASSERT_FILE_SIZE(sz) (file.length() >= tc::io::IOUtil::castSizeToInt64(sz))

	// do easy tests

	// detect "scene" XCI
	if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sGcHeader_Rsa2048Signed))
	 && _TYPE_PTR(pie::hac::sGcHeader_Rsa2048Signed)->header.st_magic.unwrap() == pie::hac::gc::kGcHeaderStructMagic)
	{
		infile.filetype = FILE_TYPE_GAMECARD;
	}
	// detect "SDK" XCI
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sSdkGcHeader))
		&& _TYPE_PTR(pie::hac::sSdkGcHeader)->signed_header.header.st_magic.unwrap() == pie::hac::gc::kGcHeaderStructMagic)
	{
		infile.filetype = FILE_TYPE_GAMECARD;
	}
	// detect PFS0
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sPfsHeader))
	      && _TYPE_PTR(pie::hac::sPfsHeader)->st_magic.unwrap() == pie::hac::pfs::kPfsStructMagic)
	{
		infile.filetype = FILE_TYPE_PARTITIONFS;
	}
	// detect HFS0
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sPfsHeader))
		&& _TYPE_PTR(pie::hac::sPfsHeader)->st_magic.unwrap() == pie::hac::pfs::kHashedPfsStructMagic)
	{
		infile.filetype = FILE_TYPE_PARTITIONFS;
	}
	// detect ROMFS
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sRomfsHeader))
		&& _TYPE_PTR(pie::hac::sRomfsHeader)->header_size.unwrap() == sizeof(pie::hac::sRomfsHeader)
		&& _TYPE_PTR(pie::hac::sRomfsHeader)->dir_entry.offset.unwrap() == (_TYPE_PTR(pie::hac::sRomfsHeader)->dir_hash_bucket.offset.unwrap() + _TYPE_PTR(pie::hac::sRomfsHeader)->dir_hash_bucket.size.unwrap()))
	{
		infile.filetype = FILE_TYPE_ROMFS;
	}
	// detect NPDM
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sMetaHeader))
		&& _TYPE_PTR(pie::hac::sMetaHeader)->st_magic.unwrap() == pie::hac::meta::kMetaStructMagic)
	{
		infile.filetype = FILE_TYPE_META;
	}
	// detect NSO
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sNsoHeader))
		&& _TYPE_PTR(pie::hac::sNsoHeader)->st_magic.unwrap() == pie::hac::nso::kNsoStructMagic)
	{
		infile.filetype = FILE_TYPE_NSO;
	}
	// detect NRO
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sNroHeader))
		&& _TYPE_PTR(pie::hac::sNroHeader)->st_magic.unwrap() == pie::hac::nro::kNroStructMagic)
	{
		infile.filetype = FILE_TYPE_NRO;
	}
	// detect INI
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sIniHeader))
		&& _TYPE_PTR(pie::hac::sIniHeader)->st_magic.unwrap() == pie::hac::ini::kIniStructMagic)
	{
		infile.filetype = FILE_TYPE_INI;
	}
	// detect KIP
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sKipHeader))
		&& _TYPE_PTR(pie::hac::sKipHeader)->st_magic.unwrap() == pie::hac::kip::kKipStructMagic)
	{
		infile.filetype = FILE_TYPE_KIP;
	}
	// detect HB ASET
	else if (_ASSERT_FILE_SIZE(sizeof(pie::hac::sAssetHeader))
		&& _TYPE_PTR(pie::hac::sAssetHeader)->st_magic.unwrap() == pie::hac::aset::kAssetStructMagic)
	{
		infile.filetype = FILE_TYPE_KIP;
	}

	// more complicated tests

	// detect NCA
	else if (determineValidNcaFromSample(raw_data))
	{
		infile.filetype = FILE_TYPE_NCA;
	}
	// detect Certificate
	else if (determineValidEsCertFromSample(raw_data))
	{
		infile.filetype = FILE_TYPE_ES_CERT;
	}
	// detect Ticket
	else if (determineValidEsTikFromSample(raw_data))
	{
		infile.filetype = FILE_TYPE_ES_TIK;
	}
	// detect Ticket
	else if (determineValidCnmtFromSample(raw_data))
	{
		infile.filetype = FILE_TYPE_CNMT;
	}
	// detect Ticket
	else if (determineValidNacpFromSample(raw_data))
	{
		infile.filetype = FILE_TYPE_NACP;
	}
#undef _TYPE_PTR
#undef _ASSERT_FILE_SIZE
}

void nstool::SettingsInitializer::usage_text() const
{
	fmt::print("{:s} v{:d}.{:d}.{:d} (C) {:s}\n", APP_NAME, VER_MAJOR, VER_MINOR, VER_PATCH, AUTHORS);
	fmt::print("Built: {:s} {:s}\n\n", __TIME__, __DATE__);
	fmt::print("Usage: {:s} [options... ] <file>\n", BIN_NAME);
	fmt::print("\n  General Options:\n");
	fmt::print("      -d, --dev       Use devkit keyset.\n");
	fmt::print("      -k, --keyset    Specify keyset file.\n");
	fmt::print("      -t, --type      Specify input file type. [xci, pfs, romfs, nca, meta, cnmt, nso, nro, ini, kip, nacp, aset, cert, tik]\n");
	fmt::print("      -y, --verify    Verify file.\n");
	fmt::print("\n  Output Options:\n");
	fmt::print("      --showkeys      Show keys generated.\n");
	fmt::print("      --showlayout    Show layout metadata.\n");
	fmt::print("      -v, --verbose   Verbose output.\n");
	fmt::print("\n  PFS0/HFS0 (PartitionFs), RomFs, NSP (Nintendo Submission Package)\n");
	fmt::print("    {:s} [--fstree] [-x [<virtual path>] <out path>] <file>\n", BIN_NAME);
	fmt::print("      --fstree        Print filesystem tree.\n");
	fmt::print("      -x, --extract   Extract a file or directory to local filesystem.\n");
	fmt::print("\n  XCI (GameCard Image)\n");
	fmt::print("    {:s} [--fstree] [-x [<virtual path>] <out path>] <.xci file>\n", BIN_NAME);
	fmt::print("      --fstree        Print filesystem tree.\n");
	fmt::print("      -x, --extract   Extract a file or directory to local filesystem.\n");
	fmt::print("      --update        Extract \"update\" partition to directory. (Alias for \"-x /update <out path>\")\n");
	fmt::print("      --logo          Extract \"logo\" partition to directory. (Alias for \"-x /logo <out path>\")\n");
	fmt::print("      --normal        Extract \"normal\" partition to directory. (Alias for \"-x /normal <out path>\")\n");
	fmt::print("      --secure        Extract \"secure\" partition to directory. (Alias for \"-x /secure <out path>\")\n");
	fmt::print("\n  NCA (Nintendo Content Archive)\n");
	fmt::print("    {:s} [--fstree] [-x [<virtual path>] <out path>] [--bodykey <key> --titlekey <key> -tik <tik path> --basenca <.nca file>] <.nca file>\n", BIN_NAME);
	fmt::print("      --fstree        Print filesystem tree.\n");
	fmt::print("      -x, --extract   Extract a file or directory to local filesystem.\n");
	fmt::print("      --titlekey      Specify (encrypted) title key extracted from ticket.\n");
	fmt::print("      --contentkey    Specify content key.\n");
	fmt::print("      --tik           Specify ticket to source title key.\n");
	fmt::print("      --cert          Specify certificate chain to verify ticket.\n");
	fmt::print("      --part0         Extract partition \"0\" to directory. (Alias for \"-x /0 <out path>\")\n");
	fmt::print("      --part1         Extract partition \"1\" to directory. (Alias for \"-x /1 <out path>\")\n");
	fmt::print("      --part2         Extract partition \"2\" to directory. (Alias for \"-x /2 <out path>\")\n");
	fmt::print("      --part3         Extract partition \"3\" to directory. (Alias for \"-x /3 <out path>\")\n");
	fmt::print("      --basenca       Specify base NCA file for update NCA files.\n");
	fmt::print("\n  NSO (Nintendo Shared Object), NRO (Nintendo Relocatable Object)\n");
	fmt::print("    {:s} [--listapi --listsym] [--insttype <inst. type>] <file>\n", BIN_NAME);
	fmt::print("      --listapi       Print SDK API List.\n");
	fmt::print("      --listsym       Print Code Symbols.\n");
	fmt::print("      --insttype      Specify instruction type [64bit|32bit] (64bit is assumed).\n");
	fmt::print("\n  INI (Initial Program Bundle)\n");
	fmt::print("    {:s} [--kipdir <dir>] <file>\n", BIN_NAME);
	fmt::print("      --kipdir        Extract embedded Initial Programs to directory.\n");
	fmt::print("\n  ASET (Homebrew Asset Blob)\n");
	fmt::print("    {:s} [--fstree] [-x [<virtual path>] <out path>] [--icon <file> --nacp <file>] <file>\n", BIN_NAME);
	fmt::print("      --fstree        Print RomFs filesystem tree.\n");
	fmt::print("      -x, --extract   Extract a file or directory from RomFs to local filesystem.\n");
	fmt::print("      --icon          Extract icon partition to file.\n");
	fmt::print("      --nacp          Extract NACP partition to file.\n");
}

void nstool::SettingsInitializer::dump_keys() const
{
	fmt::print("[KeyConfiguration]\n");
	fmt::print("  NCA Keys:\n");
	for (auto itr = opt.keybag.nca_header_sign0_key.begin(); itr != opt.keybag.nca_header_sign0_key.end(); itr++)
	{
		dump_rsa_key(itr->second, fmt::format("Header0-SignatureKey-{:02x}", itr->first), 4, opt.cli_output_mode.show_extended_info);
	}
	for (auto itr = opt.keybag.acid_sign_key.begin(); itr != opt.keybag.acid_sign_key.end(); itr++)
	{
		dump_rsa_key(itr->second, fmt::format("Acid-SignatureKey-{:02x}", itr->first), 4, opt.cli_output_mode.show_extended_info);
	}
	if (opt.keybag.nca_header_key.isSet())
	{
		fmt::print("    Header-EncryptionKey:\n");
		fmt::print("      Key0: {:s}\n", tc::cli::FormatUtil::formatBytesAsString(opt.keybag.nca_header_key.get()[0].data(), opt.keybag.nca_header_key.get()[0].size(), true, ""));
		fmt::print("      Key1: {:s}\n", tc::cli::FormatUtil::formatBytesAsString(opt.keybag.nca_header_key.get()[1].data(), opt.keybag.nca_header_key.get()[1].size(), true, ""));
	}
	std::vector<std::string> kaek_label = {"Application", "Ocean", "System"};
	for (size_t kaek_index = 0; kaek_index < opt.keybag.nca_key_area_encryption_key.size(); kaek_index++)
	{
		for (auto itr = opt.keybag.nca_key_area_encryption_key[kaek_index].begin(); itr != opt.keybag.nca_key_area_encryption_key[kaek_index].end(); itr++)
		{
			fmt::print("    KeyAreaEncryptionKey-{:s}-{:02x}:\n      {:s}\n", kaek_label[kaek_index], itr->first, tc::cli::FormatUtil::formatBytesAsString(itr->second.data(), itr->second.size(), true, ""));
		}
	}
	for (size_t kaek_index = 0; kaek_index < opt.keybag.nca_key_area_encryption_key_hw.size(); kaek_index++)
	{
		for (auto itr = opt.keybag.nca_key_area_encryption_key_hw[kaek_index].begin(); itr != opt.keybag.nca_key_area_encryption_key_hw[kaek_index].end(); itr++)
		{
			fmt::print("    KeyAreaEncryptionKeyHw-{:s}-{:02x}:\n      {:s}\n", kaek_label[kaek_index], itr->first, tc::cli::FormatUtil::formatBytesAsString(itr->second.data(), itr->second.size(), true, ""));
		}
	}
	fmt::print("  NRR Keys:\n");
	for (auto itr = opt.keybag.nrr_certificate_sign_key.begin(); itr != opt.keybag.nrr_certificate_sign_key.end(); itr++)
	{
		dump_rsa_key(itr->second, fmt::format("Certificate-SignatureKey-{:02x}", itr->first), 4, opt.cli_output_mode.show_extended_info);
	}
	fmt::print("  XCI Keys:\n");
	if (opt.keybag.xci_header_sign_key.isSet())
	{
		dump_rsa_key(opt.keybag.xci_header_sign_key.get(), fmt::format("Header-SignatureKey"), 4, opt.cli_output_mode.show_extended_info);
	}
	for (auto itr = opt.keybag.xci_header_key.begin(); itr != opt.keybag.xci_header_key.end(); itr++)
	{
		fmt::print("    ExtendedHeader-EncryptionKey-{:02x}:\n      {:s}\n", itr->first, tc::cli::FormatUtil::formatBytesAsString(itr->second.data(), itr->second.size(), true, ""));
	}
	if (opt.keybag.xci_cert_sign_key.isSet())
	{
		dump_rsa_key(opt.keybag.xci_cert_sign_key.get(), fmt::format("CERT-SignatureKey"), 4, opt.cli_output_mode.show_extended_info);
	}

	fmt::print("  Package1 Keys:\n");
	for (auto itr = opt.keybag.pkg1_key.begin(); itr != opt.keybag.pkg1_key.end(); itr++)
	{
		fmt::print("    EncryptionKey-{:02x}:\n      {:s}\n", itr->first, tc::cli::FormatUtil::formatBytesAsString(itr->second.data(), itr->second.size(), true, ""));
	}

	fmt::print("  Package2 Keys:\n");
	if (opt.keybag.pkg2_sign_key.isSet())
	{
		dump_rsa_key(opt.keybag.pkg2_sign_key.get(), fmt::format("Header-SignatureKey"), 4, opt.cli_output_mode.show_extended_info);
	}
	for (auto itr = opt.keybag.pkg2_key.begin(); itr != opt.keybag.pkg2_key.end(); itr++)
	{
		fmt::print("    EncryptionKey-{:02x}:\n      {:s}\n", itr->first, tc::cli::FormatUtil::formatBytesAsString(itr->second.data(), itr->second.size(), true, ""));
	}

	fmt::print("  ETicket Keys:\n");
	for (auto itr = opt.keybag.etik_common_key.begin(); itr != opt.keybag.etik_common_key.end(); itr++)
	{
		fmt::print("    CommonKey-{:02x}:\n      {:s}\n", itr->first, tc::cli::FormatUtil::formatBytesAsString(itr->second.data(), itr->second.size(), true, ""));
	}

	fmt::print("  BroadOn Signer Profiles:\n");
	for (auto itr = opt.keybag.broadon_signer.begin(); itr != opt.keybag.broadon_signer.end(); itr++)
	{
		fmt::print("    {:s}:\n", itr->first);
		fmt::print("      SignType: ");
		switch(itr->second.key_type) {
			case pie::hac::es::sign::SIGN_ALGO_RSA2048:
				fmt::print("RSA-2048\n");
				break;
			case pie::hac::es::sign::SIGN_ALGO_RSA4096:
				fmt::print("RSA-4096\n");
				break;
			case pie::hac::es::sign::SIGN_ALGO_ECDSA240:
				fmt::print("ECDSA-240\n");
				break;
			default:
				fmt::print("Unknown\n");
		}
		switch(itr->second.key_type) {
			case pie::hac::es::sign::SIGN_ALGO_RSA2048:
			case pie::hac::es::sign::SIGN_ALGO_RSA4096:
				dump_rsa_key(itr->second.rsa_key, "RsaKey", 6, opt.cli_output_mode.show_extended_info);
				break;
			case pie::hac::es::sign::SIGN_ALGO_ECDSA240:
			default:
				break;
		}
	}
}

void nstool::SettingsInitializer::dump_rsa_key(const KeyBag::rsa_key_t& key, const std::string& label, size_t indent, bool expanded_key_data) const
{
	std::string indent_str;

	indent_str.clear();
	for (size_t i = 0; i < indent; i++)
	{
		indent_str += " ";
	}

	fmt::print("{:s}{:s}:\n", indent_str, label);
	if (key.n.size() > 0)
	{
		if (expanded_key_data)
		{
			fmt::print("{:s}  Modulus:\n", indent_str);
			fmt::print("{:s}    {:s}", indent_str, tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(key.n.data(), key.n.size(), true, "", 0x10, indent + 4, false));
		}
		else
		{
			fmt::print("{:s}  Modulus: {:s}\n", indent_str, getTruncatedBytesString(key.n.data(), key.n.size()));
		}
	}
	if (key.d.size() > 0)
	{
		if (expanded_key_data)
		{
			fmt::print("{:s}  Private Exponent:\n", indent_str);
			fmt::print("{:s}    {:s}", indent_str, tc::cli::FormatUtil::formatBytesAsStringWithLineLimit(key.d.data(), key.d.size(), true, "", 0x10, indent + 4, false));
		}
		else
		{
			fmt::print("{:s}  Private Exponent: {:s}\n", indent_str, getTruncatedBytesString(key.d.data(), key.d.size()));
		}
	}
}


bool nstool::SettingsInitializer::determineValidNcaFromSample(const tc::ByteData& sample) const
{
	if (sample.size() < pie::hac::nca::kHeaderSize)
	{
		return false;
	}
	
	if (opt.keybag.nca_header_key.isNull())
	{
		fmt::print("[WARNING] Failed to load NCA Header Key.\n");
		return false;
	}

	pie::hac::detail::aes128_xtskey_t key = opt.keybag.nca_header_key.get();

	//fmt::print("NCA header key: {} {}\n", tc::cli::FormatUtil::formatBytesAsString(opt.keybag.nca_header_key.get()[0].data(), opt.keybag.nca_header_key.get()[0].size(), true, ""), tc::cli::FormatUtil::formatBytesAsString(opt.keybag.nca_header_key.get()[1].data(), opt.keybag.nca_header_key.get()[1].size(), true, ""));

	// init aes-xts
	tc::crypto::Aes128XtsEncryptor enc;
	enc.initialize(key[0].data(), key[0].size(), key[1].data(), key[1].size(), pie::hac::nca::kSectorSize, false);

	// decrypt main header
	byte_t raw_hdr[pie::hac::nca::kSectorSize];
	enc.decrypt(raw_hdr, sample.data() + pie::hac::ContentArchiveUtil::sectorToOffset(1), pie::hac::nca::kSectorSize, 1);
	pie::hac::sContentArchiveHeader* hdr = (pie::hac::sContentArchiveHeader*)(raw_hdr);

	/*
	fmt::print("NCA Header Raw:\n");
	fmt::print("{:s}\n", tc::cli::FormatUtil::formatBytesAsHxdHexString(sample.data() + pie::hac::ContentArchiveUtil::sectorToOffset(1), pie::hac::nca::kSectorSize));
	fmt::print("{:s}\n", tc::cli::FormatUtil::formatBytesAsHxdHexString(raw_hdr, pie::hac::nca::kSectorSize));
	*/

	if (hdr->st_magic.unwrap() != pie::hac::nca::kNca2StructMagic && hdr->st_magic.unwrap() != pie::hac::nca::kNca3StructMagic)
	{
		return false;
	}

	return true;
}

bool nstool::SettingsInitializer::determineValidCnmtFromSample(const tc::ByteData& sample) const
{
	if (sample.size() < sizeof(pie::hac::sContentMetaHeader))
		return false;

	const pie::hac::sContentMetaHeader* data = (const pie::hac::sContentMetaHeader*)sample.data();

	size_t minimum_size = sizeof(pie::hac::sContentMetaHeader) + data->exhdr_size.unwrap() + data->content_count.unwrap() * sizeof(pie::hac::sContentInfo) + data->content_meta_count.unwrap() * sizeof(pie::hac::sContentMetaInfo) + pie::hac::cnmt::kDigestLen;

	if (sample.size() < minimum_size)
		return false;

	// include exthdr/data check if applicable
	if (data->exhdr_size.unwrap() > 0)
	{
		if (data->type == (byte_t)pie::hac::cnmt::ContentMetaType_Application)
		{
			const pie::hac::sApplicationMetaExtendedHeader* meta = (const pie::hac::sApplicationMetaExtendedHeader*)(sample.data() + sizeof(pie::hac::sContentMetaHeader));
			if ((meta->patch_id.unwrap() & data->id.unwrap()) != data->id.unwrap())
				return false;
		}
		else if (data->type == (byte_t)pie::hac::cnmt::ContentMetaType_Patch)
		{
			const pie::hac::sPatchMetaExtendedHeader* meta = (const pie::hac::sPatchMetaExtendedHeader*)(sample.data() + sizeof(pie::hac::sContentMetaHeader));
			if ((meta->application_id.unwrap() & data->id.unwrap()) != meta->application_id.unwrap())
				return false;

			minimum_size += meta->extended_data_size.unwrap();
		}
		else if (data->type == (byte_t)pie::hac::cnmt::ContentMetaType_AddOnContent)
		{
			const pie::hac::sAddOnContentMetaExtendedHeader* meta = (const pie::hac::sAddOnContentMetaExtendedHeader*)(sample.data() + sizeof(pie::hac::sContentMetaHeader));
			if ((meta->application_id.unwrap() & data->id.unwrap()) != meta->application_id.unwrap())
				return false;
		}
		else if (data->type == (byte_t)pie::hac::cnmt::ContentMetaType_Delta)
		{
			const pie::hac::sDeltaMetaExtendedHeader* meta = (const pie::hac::sDeltaMetaExtendedHeader*)(sample.data() + sizeof(pie::hac::sContentMetaHeader));
			if ((meta->application_id.unwrap() & data->id.unwrap()) != meta->application_id.unwrap())
				return false;

			minimum_size += meta->extended_data_size.unwrap();
		}
		else if (data->type == (byte_t)pie::hac::cnmt::ContentMetaType_SystemUpdate)
		{
			const pie::hac::sSystemUpdateMetaExtendedHeader* meta = (const pie::hac::sSystemUpdateMetaExtendedHeader*)(sample.data() + sizeof(pie::hac::sContentMetaHeader));

			minimum_size += meta->extended_data_size.unwrap();
		}
	}

	if (sample.size() != minimum_size)
		return false;

	return true;
}

bool nstool::SettingsInitializer::determineValidNacpFromSample(const tc::ByteData& sample) const
{
	if (sample.size() != sizeof(pie::hac::sApplicationControlProperty))
		return false;

	const pie::hac::sApplicationControlProperty* data = (const pie::hac::sApplicationControlProperty*)sample.data();

	if (data->logo_type > (byte_t)pie::hac::nacp::LogoType_Nintendo)
		return false;

	if (data->display_version[0] == 0)
		return false;

	if (data->user_account_save_data_size.unwrap() == 0 && data->user_account_save_data_journal_size.unwrap() != 0)
		return false;

	if (data->user_account_save_data_journal_size.unwrap() == 0 && data->user_account_save_data_size.unwrap() != 0)
		return false;

	if (*((uint32_t*)(&data->supported_language_flag)) == 0)
		return false;

	return true;
}

bool nstool::SettingsInitializer::determineValidEsCertFromSample(const tc::ByteData& sample) const
{
	pie::hac::es::SignatureBlock sign;

	try
	{
		sign.fromBytes(sample.data(), sample.size());
	}
	catch (...)
	{
		return false;
	}

	if (sign.isLittleEndian() == true)
		return false;

	if (sign.getSignType() != pie::hac::es::sign::SIGN_ID_RSA4096_SHA256 && sign.getSignType() != pie::hac::es::sign::SIGN_ID_RSA2048_SHA256 && sign.getSignType() != pie::hac::es::sign::SIGN_ID_ECDSA240_SHA256)
		return false;

	return true;
}

bool nstool::SettingsInitializer::determineValidEsTikFromSample(const tc::ByteData& sample) const
{
	pie::hac::es::SignatureBlock sign;

	try
	{
		sign.fromBytes(sample.data(), sample.size());
	}
	catch (...)
	{
		return false;
	}

	if (sign.isLittleEndian() == false)
		return false;

	if (sign.getSignType() != pie::hac::es::sign::SIGN_ID_RSA2048_SHA256)
		return false;

	const pie::hac::es::sTicketBody_v2* body = (const pie::hac::es::sTicketBody_v2*)(sample.data() + sign.getBytes().size());

	if ((body->issuer.decode().substr(0, 5) == "Root-"
		&& body->issuer.decode().substr(16, 2) == "XS") == false)
		return false;

	return true;
}
```

`src/Settings.h`:

```h
#pragma once
#include "types.h"
#include <string>
#include <vector>
#include <tc/Optional.h>
#include <tc/io.h>

#include "KeyBag.h"

namespace nstool {

struct Settings
{
	enum FileType
	{
		FILE_TYPE_ERROR,
		FILE_TYPE_GAMECARD,
		FILE_TYPE_NSP,
		FILE_TYPE_PARTITIONFS,
		FILE_TYPE_ROMFS,
		FILE_TYPE_NCA,
		FILE_TYPE_META,
		FILE_TYPE_CNMT,
		FILE_TYPE_NSO,
		FILE_TYPE_NRO,
		FILE_TYPE_NACP,
		FILE_TYPE_INI,
		FILE_TYPE_KIP,
		FILE_TYPE_ES_CERT,
		FILE_TYPE_ES_TIK,
		FILE_TYPE_HB_ASSET,
	};

	struct InputFileOptions
	{
		FileType filetype;
		tc::Optional<tc::io::Path> path;
	} infile;

	struct Options
	{
		CliOutputMode cli_output_mode;
		bool verify;
		bool is_dev;
		KeyBag keybag;
	} opt;

	// code options
	struct CodeOptions
	{
		bool list_api;
		bool list_symbols;
		bool is_64bit_instruction; // true=64bit, false=32bit
	} code;

	// Generic FS options
	struct FsOptions 
	{
		bool show_fs_tree;
		std::vector<ExtractJob> extract_jobs;
	} fs;

	// XCI options
	struct XciOptions
	{
		tc::Optional<tc::io::Path> update_extract_path;
		tc::Optional<tc::io::Path> logo_extract_path;
		tc::Optional<tc::io::Path> normal_extract_path;
		tc::Optional<tc::io::Path> secure_extract_path;
	} xci;

	// NCA options
	struct NcaOptions
	{
		tc::Optional<tc::io::Path> part0_extract_path;
		tc::Optional<tc::io::Path> part1_extract_path;
		tc::Optional<tc::io::Path> part2_extract_path;
		tc::Optional<tc::io::Path> part3_extract_path;
		tc::Optional<tc::io::Path> base_nca_path;
	} nca;

	// KIP options
	struct KipOptions
	{
		tc::Optional<tc::io::Path> extract_path;
	} kip;

	// ASET Options
	struct AsetOptions
	{
		tc::Optional<tc::io::Path> icon_extract_path;
		tc::Optional<tc::io::Path> nacp_extract_path;
	} aset;

	Settings()
	{
		infile.filetype = FILE_TYPE_ERROR;
		infile.path = tc::Optional<tc::io::Path>();

		opt.cli_output_mode = CliOutputMode();
		opt.verify = false;
		opt.is_dev = false;
		opt.keybag = KeyBag();

		code.list_api = false;
		code.list_symbols = false;
		code.is_64bit_instruction = true;

		fs.show_fs_tree = false;
		fs.extract_jobs = std::vector<ExtractJob>();

		kip.extract_path = tc::Optional<tc::io::Path>();

		nca.base_nca_path = tc::Optional<tc::io::Path>();

		aset.icon_extract_path = tc::Optional<tc::io::Path>();
		aset.nacp_extract_path = tc::Optional<tc::io::Path>();
	}
};

class SettingsInitializer : public Settings
{
public:
	SettingsInitializer(const std::vector<std::string>& args);
private:
	void parse_args(const std::vector<std::string>& args);
	void determine_filetype();
	void usage_text() const;
	void dump_keys() const;
	void dump_rsa_key(const KeyBag::rsa_key_t& key, const std::string& label, size_t indent, bool expanded_key_data) const;

	std::string mModuleLabel;

	bool mShowLayout;
	bool mShowKeydata;
	bool mVerbose;

	tc::Optional<tc::io::Path> mKeysetPath;
	tc::Optional<KeyBag::aes128_key_t> mNcaEncryptedContentKey;
	tc::Optional<KeyBag::aes128_key_t> mNcaContentKey;
	tc::Optional<tc::io::Path> mTikPath;
	tc::Optional<tc::io::Path> mCertPath;

	bool determineValidNcaFromSample(const tc::ByteData& raw_data) const;
	bool determineValidEsCertFromSample(const tc::ByteData& raw_data) const;
	bool determineValidEsTikFromSample(const tc::ByteData& raw_data) const;
	bool determineValidCnmtFromSample(const tc::ByteData& raw_data) const;
	bool determineValidNacpFromSample(const tc::ByteData& raw_data) const;
};

}
```

`src/elf.h`:

```h
#pragma once
#include "types.h"

namespace nstool
{
	namespace elf
	{
		/* These constants are for the segment types stored in the image headers */
		enum SegmentType
		{
			PT_NULL = 0,
			PT_LOAD = 1,
			PT_DYNAMIC = 2,
			PT_INTERP = 3,
			PT_NOTE = 4,
			PT_SHLIB = 5,
			PT_PHDR = 6,
			PT_TLS = 7,               /* Thread local storage segment */
			PT_LOOS = 0x60000000,      /* OS-specific */
			PT_HIOS = 0x6fffffff,      /* OS-specific */
			PT_LOPROC = 0x70000000,
			PT_HIPROC = 0x7fffffff
		};

		/* These constants define the different elf file types */
		enum ElfType
		{
			ET_NONE = 0,
			ET_REL = 1,
			ET_EXEC = 2,
			ET_DYN = 3,
			ET_CORE = 4,
			ET_LOPROC = 0xff00,
			ET_HIPROC = 0xffff
		};

		/* This is the info that is needed to parse the dynamic section of the file */
		enum DynamicSectionType
		{
			DT_NULL = 0,
			DT_NEEDED = 1,
			DT_PLTRELSZ = 2,
			DT_PLTGOT = 3,
			DT_HASH = 4,
			DT_STRTAB = 5,
			DT_SYMTAB = 6,
			DT_RELA = 7,
			DT_RELASZ = 8,
			DT_RELAENT = 9,
			DT_STRSZ = 10,
			DT_SYMENT = 11,
			DT_INIT = 12,
			DT_FINI = 13,
			DT_SONAME = 14,
			DT_RPATH = 15,
			DT_SYMBOLIC = 16,
			DT_REL = 17,
			DT_RELSZ = 18,
			DT_RELENT = 19,
			DT_PLTREL = 20,
			DT_DEBUG = 21,
			DT_TEXTREL = 22,
			DT_JMPREL = 23,
			DT_ENCODING = 32,
			OLD_DT_LOOS = 0x60000000,
			DT_LOOS = 0x6000000d,
			DT_HIOS = 0x6ffff000,
			DT_VALRNGLO = 0x6ffffd00,
			DT_VALRNGHI = 0x6ffffdff,
			DT_ADDRRNGLO = 0x6ffffe00,
			DT_ADDRRNGHI = 0x6ffffeff,
			DT_VERSYM = 0x6ffffff0,
			DT_RELACOUNT = 0x6ffffff9,
			DT_RELCOUNT = 0x6ffffffa,
			DT_FLAGS_1 = 0x6ffffffb,
			DT_VERDEF = 0x6ffffffc,
			DT_VERDEFNUM = 0x6ffffffd,
			DT_VERNEED = 0x6ffffffe,
			DT_VERNEEDNUM = 0x6fffffff,
			OLD_DT_HIOS = 0x6fffffff,
			DT_LOPROC = 0x70000000,
			DT_HIPROC = 0x7fffffff
		};

		/* This info is needed when parsing the symbol table */
		enum SymbolBinding
		{
			STB_LOCAL = 0,
			STB_GLOBAL = 1,
			STB_WEAK = 2,
			STB_LOOS = 10,
			STB_HIOS = 12,
			STB_LOPROC,
			STB_HIPROC = 0xf
		};

		enum SymbolType
		{
			STT_NOTYPE = 0,
			STT_OBJECT = 1,
			STT_FUNC = 2,
			STT_SECTION = 3,
			STT_FILE = 4,
			STT_COMMON = 5,
			STT_TLS = 6,
			STT_LOOS = 10,
			STT_HIOS = 12,
			STT_LOPROC,
			STT_HIPROC = 0xf
		};

		/* These constants define the permissions on sections in the program
		header, p_flags. */
		enum PermissionFlag
		{
			PF_R = 0x4,
			PF_W = 0x2,
			PF_X = 0x1
		};

		/* sh_type */
		enum SectionHeaderType
		{
			SHT_NULL = 0,
			SHT_PROGBITS = 1,
			SHT_SYMTAB = 2,
			SHT_STRTAB = 3,
			SHT_RELA = 4,
			SHT_HASH = 5,
			SHT_DYNAMIC = 6,
			SHT_NOTE = 7,
			SHT_NOBITS = 8,
			SHT_REL	 = 9,
			SHT_SHLIB = 10,
			SHT_DYNSYM = 11,
			SHT_NUM	 = 12,
			SHT_LOPROC = 0x70000000,
			SHT_HIPROC = 0x7fffffff,
			SHT_LOUSER = 0x80000000,
			SHT_HIUSER = 0xffffffff
		};
		
		/* sh_flags */
		enum SectionHeaderFlag
		{
			SHF_WRITE = 0x1,
			SHF_ALLOC = 0x2,
			SHF_EXECINSTR = 0x4,
			SHF_RELA_LIVEPATCH = 0x00100000,
			SHF_RO_AFTER_INIT = 0x00200000,
			SHF_MASKPROC = 0xf0000000
		};
		
		/* special section indexes */
		enum SpecialSectionIndex
		{
			SHN_UNDEF = 0,
			SHN_LORESERVE = 0xff00,
			SHN_LOPROC = 0xff00,
			SHN_HIPROC = 0xff1f,
			SHN_LOOS = 0xff20,
			SHN_HIOS = 0xff3f,
			SHN_ABS = 0xfff1,
			SHN_COMMON = 0xfff2,
			SHN_HIRESERVE = 0xffff
		};

		enum ElfIdentIndex
		{
			EI_MAG0 = 0,		/* e_ident[] indexes */
			EI_MAG1 = 1,
			EI_MAG2 = 2,
			EI_MAG3 = 3,
			EI_CLASS = 4,
			EI_DATA = 5,
			EI_VERSION = 6,
			EI_OSABI = 7,
			EI_PAD = 8
		};

		enum ElfClass
		{
			ELFCLASSNONE = 0,		/* EI_CLASS */
			ELFCLASS32 = 1,
			ELFCLASS64 = 2,
			ELFCLASSNUM = 3
		};
		
		enum ElfData
		{
			ELFDATANONE = 0,		/* e_ident[EI_DATA] */
			ELFDATA2LSB = 1,
			ELFDATA2MSB = 2
		};
		
		enum ElfVersion
		{
			EV_NONE = 0,		/* e_version, EI_VERSION */
			EV_CURRENT = 1,
			EV_NUM = 2,
		};
		
		enum ElfOsAbi
		{
			ELFOSABI_NONE = 0,
			ELFOSABI_LINUX =3
		};
		

		/*
		* Notes used in ET_CORE. Architectures export some of the arch register sets
		* using the corresponding note types via the PTRACE_GETREGSET and
		* PTRACE_SETREGSET requests.
		*/
		enum NoteType
		{
			NT_PRSTATUS = 1,
			NT_PRFPREG = 2,
			NT_PRPSINFO = 3,
			NT_TASKSTRUCT = 4,
			NT_AUXV = 6,
		/*
		* Note to userspace developers: size of NT_SIGINFO note may increase
		* in the future to accomodate more fields, don't assume it is fixed!
		*/
			NT_SIGINFO = 0x53494749,
			NT_FILE = 0x46494c45,
			NT_PRXFPREG = 0x46e62b7f,      /* copied from gdb5.1/include/elf/common.h */
			NT_PPC_VMX = 0x100,		/* PowerPC Altivec/VMX registers */
			NT_PPC_SPE = 0x101,		/* PowerPC SPE/EVR registers */
			NT_PPC_VSX = 0x102,		/* PowerPC VSX registers */
			NT_PPC_TAR = 0x103,		/* Target Address Register */
			NT_PPC_PPR = 0x104,		/* Program Priority Register */
			NT_PPC_DSCR = 0x105,		/* Data Stream Control Register */
			NT_PPC_EBB = 0x106,		/* Event Based Branch Registers */
			NT_PPC_PMU = 0x107,		/* Performance Monitor Registers */
			NT_PPC_TM_CGPR = 0x108,		/* TM checkpointed GPR Registers */
			NT_PPC_TM_CFPR = 0x109,		/* TM checkpointed FPR Registers */
			NT_PPC_TM_CVMX = 0x10a,		/* TM checkpointed VMX Registers */
			NT_PPC_TM_CVSX = 0x10b,		/* TM checkpointed VSX Registers */
			NT_PPC_TM_SPR = 0x10c,		/* TM Special Purpose Registers */
			NT_PPC_TM_CTAR = 0x10d,		/* TM checkpointed Target Address Register */
			NT_PPC_TM_CPPR = 0x10e,		/* TM checkpointed Program Priority Register */
			NT_PPC_TM_CDSCR = 0x10f,		/* TM checkpointed Data Stream Control Register */
			NT_PPC_PKEY = 0x110,		/* Memory Protection Keys registers */
			NT_386_TLS = 0x200,		/* i386 TLS slots (struct user_desc) */
			NT_386_IOPERM = 0x201,		/* x86 io permission bitmap (1=deny) */
			NT_X86_XSTATE = 0x202,		/* x86 extended state using xsave */
			NT_S390_HIGH_GPRS = 0x300,	/* s390 upper register halves */
			NT_S390_TIMER = 0x301,		/* s390 timer register */
			NT_S390_TODCMP = 0x302,		/* s390 TOD clock comparator register */
			NT_S390_TODPREG = 0x303,		/* s390 TOD programmable register */
			NT_S390_CTRS = 0x304,		/* s390 control registers */
			NT_S390_PREFIX = 0x305,		/* s390 prefix register */
			NT_S390_LAST_BREAK = 0x306,	/* s390 breaking event address */
			NT_S390_SYSTEM_CALL = 0x307,	/* s390 system call restart data */
			NT_S390_TDB = 0x308,		/* s390 transaction diagnostic block */
			NT_S390_VXRS_LOW = 0x309,	/* s390 vector registers 0-15 upper half */
			NT_S390_VXRS_HIGH = 0x30a,	/* s390 vector registers 16-31 */
			NT_S390_GS_CB = 0x30b,		/* s390 guarded storage registers */
			NT_S390_GS_BC = 0x30c,		/* s390 guarded storage broadcast control block */
			NT_S390_RI_CB = 0x30d,		/* s390 runtime instrumentation */
			NT_ARM_VFP = 0x400,		/* ARM VFP/NEON registers */
			NT_ARM_TLS = 0x401,		/* ARM TLS register */
			NT_ARM_HW_BREAK = 0x402,		/* ARM hardware breakpoint registers */
			NT_ARM_HW_WATCH = 0x403,		/* ARM hardware watchpoint registers */
			NT_ARM_SYSTEM_CALL = 0x404,	/* ARM system call number */
			NT_ARM_SVE = 0x405,		/* ARM Scalable Vector Extension registers */
			NT_ARC_V2 = 0x600,		/* ARCv2 accumulator/extra registers */
			NT_VMCOREDD = 0x700,		/* Vmcore Device Dump Note */
			NT_MIPS_DSP = 0x800,		/* MIPS DSP ASE registers */
			NT_MIPS_FP_MODE = 0x801,		/* MIPS floating-point mode */
		};
		
		static const size_t kEIdentSize = 0x10;
		static const byte_t kElfMagic[sizeof(uint32_t)] = {0x7f, 'E', 'L', 'F'};


		inline byte_t get_elf_st_bind(byte_t st_info) { return st_info >> 4; }
		inline byte_t get_elf_st_type(byte_t st_info) { return st_info & 0xf; }
		inline byte_t get_elf_st_info(byte_t st_bind, byte_t st_type) { return (st_type & 0xf) | ((st_bind & 0xf) << 4);}

		/* The following are used with relocations */
		#define ELF32_R_SYM(x) ((x) >> 8)
		#define ELF32_R_TYPE(x) ((x) & 0xff)

		#define ELF64_R_SYM(i)			((i) >> 32)
		#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
	}

	struct Elf32_Dyn
	{
		int32_t d_tag;
		union{
			int32_t	d_val;
			uint32_t	d_ptr;
		} d_un;
	};

	struct Elf64_Dyn
	{
		int64_t d_tag;		/* entry tag value */
		union {
			uint64_t d_val;
			uint64_t d_ptr;
		} d_un;
	};

	struct Elf32_Rel
	{
		uint32_t	r_offset;
		uint32_t	r_info;
	};

	struct Elf64_Rel
	{
		uint64_t r_offset;	/* Location at which to apply the action */
		uint64_t r_info;	/* index and type of relocation */
	};

	struct Elf32_Rela
	{
		uint32_t	r_offset;
		uint32_t	r_info;
		int32_t	r_addend;
	};

	struct Elf64_Rela
	{
		uint64_t r_offset;	/* Location at which to apply the action */
		uint64_t r_info;	/* index and type of relocation */
		int64_t r_addend;	/* Constant addend used to compute value */
	};

	struct Elf32_Sym
	{
		uint32_t	st_name;
		uint32_t	st_value;
		uint32_t	st_size;
		byte_t	st_info;
		byte_t	st_other;
		uint16_t	st_shndx;
	};

	struct Elf64_Sym
	{
		uint32_t st_name;		/* Symbol name, index in string tbl */
		byte_t	st_info;	/* Type and binding attributes */
		byte_t	st_other;	/* No defined meaning, 0 */
		uint16_t st_shndx;		/* Associated section index */
		uint64_t st_value;		/* Value of the symbol */
		uint64_t st_size;		/* Associated symbol size */
	};

	struct Elf32_Ehdr
	{
		byte_t	e_ident[elf::kEIdentSize];
		uint16_t	e_type;
		uint16_t	e_machine;
		uint32_t	e_version;
		uint32_t	e_entry;  /* Entry point */
		uint32_t	e_phoff;
		uint32_t	e_shoff;
		uint32_t	e_flags;
		uint16_t	e_ehsize;
		uint16_t	e_phentsize;
		uint16_t	e_phnum;
		uint16_t	e_shentsize;
		uint16_t	e_shnum;
		uint16_t	e_shstrndx;
	};

	struct Elf64_Ehdr
	{
		byte_t	e_ident[elf::kEIdentSize];	/* ELF "magic number" */
		uint16_t e_type;
		uint16_t e_machine;
		uint32_t e_version;
		uint64_t e_entry;		/* Entry point virtual address */
		uint64_t e_phoff;		/* Program header table file offset */
		uint64_t e_shoff;		/* Section header table file offset */
		uint32_t e_flags;
		uint16_t e_ehsize;
		uint16_t e_phentsize;
		uint16_t e_phnum;
		uint16_t e_shentsize;
		uint16_t e_shnum;
		uint16_t e_shstrndx;
	};

	struct Elf32_Phdr
	{
		uint32_t	p_type;
		uint32_t	p_offset;
		uint32_t	p_vaddr;
		uint32_t	p_paddr;
		uint32_t	p_filesz;
		uint32_t	p_memsz;
		uint32_t	p_flags;
		uint32_t	p_align;
	};

	struct Elf64_Phdr
	{
		uint32_t p_type;
		uint32_t p_flags;
		uint64_t p_offset;		/* Segment file offset */
		uint64_t p_vaddr;		/* Segment virtual address */
		uint64_t p_paddr;		/* Segment physical address */
		uint64_t p_filesz;		/* Segment size in file */
		uint64_t p_memsz;		/* Segment size in memory */
		uint64_t p_align;		/* Segment alignment, file & memory */
	};

	struct Elf32_Shdr
	{
		uint32_t	sh_name;
		uint32_t	sh_type;
		uint32_t	sh_flags;
		uint32_t	sh_addr;
		uint32_t	sh_offset;
		uint32_t	sh_size;
		uint32_t	sh_link;
		uint32_t	sh_info;
		uint32_t	sh_addralign;
		uint32_t	sh_entsize;
	};

	struct Elf64_Shdr
	{
		uint32_t sh_name;		/* Section name, index in string tbl */
		uint32_t sh_type;		/* Type of section */
		uint64_t sh_flags;		/* Miscellaneous section attributes */
		uint64_t sh_addr;		/* Section virtual addr at execution */
		uint64_t sh_offset;		/* Section file offset */
		uint64_t sh_size;		/* Size of section in bytes */
		uint32_t sh_link;		/* Index of another section */
		uint32_t sh_info;		/* Additional section information */
		uint64_t sh_addralign;	/* Section alignment */
		uint64_t sh_entsize;	/* Entry size if section holds table */
	};

	/* Note header in a PT_NOTE section */
	struct Elf32_Nhdr
	{
		uint32_t	n_namesz;	/* Name size */
		uint32_t	n_descsz;	/* Content size */
		uint32_t	n_type;		/* Content type */
	};

	/* Note header in a PT_NOTE section */
	struct Elf64_Nhdr
	{
		uint32_t n_namesz;	/* Name size */
		uint32_t n_descsz;	/* Content size */
		uint32_t n_type;	/* Content type */
	};
}
```

`src/main.cpp`:

```cpp
#include <tc.h>
#include <tc/os/UnicodeMain.h>
#include "Settings.h"


#include "GameCardProcess.h"
#include "PfsProcess.h"
#include "RomfsProcess.h"
#include "NcaProcess.h"
#include "MetaProcess.h"
#include "CnmtProcess.h"
#include "NsoProcess.h"
#include "NroProcess.h"
#include "NacpProcess.h"
#include "IniProcess.h"
#include "KipProcess.h"
#include "EsCertProcess.h"
#include "EsTikProcess.h"
#include "AssetProcess.h"


int umain(const std::vector<std::string>& args, const std::vector<std::string>& env)
{
	try 
	{
		nstool::Settings set = nstool::SettingsInitializer(args);
		
		std::shared_ptr<tc::io::IStream> infile_stream = std::make_shared<tc::io::FileStream>(tc::io::FileStream(set.infile.path.get(), tc::io::FileMode::Open, tc::io::FileAccess::Read));

		if (set.infile.filetype == nstool::Settings::FILE_TYPE_GAMECARD)
		{	
			nstool::GameCardProcess obj;

			obj.setInputFile(infile_stream);
			
			obj.setKeyCfg(set.opt.keybag);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.setShowFsTree(set.fs.show_fs_tree);
			obj.setExtractJobs(set.fs.extract_jobs);
		
			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_PARTITIONFS || set.infile.filetype == nstool::Settings::FILE_TYPE_NSP)
		{
			nstool::PfsProcess obj;

			obj.setInputFile(infile_stream);

			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.setShowFsTree(set.fs.show_fs_tree);
			obj.setExtractJobs(set.fs.extract_jobs);
			
			obj.process();
		}
		
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_ROMFS)
		{
			nstool::RomfsProcess obj;

			obj.setInputFile(infile_stream);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.setShowFsTree(set.fs.show_fs_tree);
			obj.setExtractJobs(set.fs.extract_jobs);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_NCA)
		{
			nstool::NcaProcess obj;

			obj.setInputFile(infile_stream);
			obj.setBaseNcaPath(set.nca.base_nca_path);
			obj.setKeyCfg(set.opt.keybag);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.setShowFsTree(set.fs.show_fs_tree);
			obj.setExtractJobs(set.fs.extract_jobs);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_META)
		{
			nstool::MetaProcess obj;

			obj.setInputFile(infile_stream);
			obj.setKeyCfg(set.opt.keybag);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_CNMT)
		{
			nstool::CnmtProcess obj;

			obj.setInputFile(infile_stream);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_NSO)
		{
			nstool::NsoProcess obj;

			obj.setInputFile(infile_stream);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);
			
			obj.setIs64BitInstruction(set.code.is_64bit_instruction);
			obj.setListApi(set.code.list_api);
			obj.setListSymbols(set.code.list_symbols);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_NRO)
		{
			nstool::NroProcess obj;

			obj.setInputFile(infile_stream);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);
			
			obj.setIs64BitInstruction(set.code.is_64bit_instruction);
			obj.setListApi(set.code.list_api);
			obj.setListSymbols(set.code.list_symbols);

			if (set.aset.icon_extract_path.isSet())
				obj.setAssetIconExtractPath(set.aset.icon_extract_path.get());
			if (set.aset.nacp_extract_path.isSet())
				obj.setAssetNacpExtractPath(set.aset.nacp_extract_path.get());

			obj.setAssetRomfsShowFsTree(set.fs.show_fs_tree);
			obj.setAssetRomfsExtractJobs(set.fs.extract_jobs);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_NACP)
		{
			nstool::NacpProcess obj;

			obj.setInputFile(infile_stream);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_INI)
		{
			nstool::IniProcess obj;

			obj.setInputFile(infile_stream);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			if (set.kip.extract_path.isSet())
				obj.setKipExtractPath(set.kip.extract_path.get());

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_KIP)
		{
			nstool::KipProcess obj;

			obj.setInputFile(infile_stream);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_ES_CERT)
		{
			nstool::EsCertProcess obj;

			obj.setInputFile(infile_stream);
			obj.setKeyCfg(set.opt.keybag);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_ES_TIK)
		{
			nstool::EsTikProcess obj;

			obj.setInputFile(infile_stream);
			obj.setKeyCfg(set.opt.keybag);
			//obj.setCertificateChain(user_set.getCertificateChain());
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			obj.process();
		}
		else if (set.infile.filetype == nstool::Settings::FILE_TYPE_HB_ASSET)
		{
			nstool::AssetProcess obj;

			obj.setInputFile(infile_stream);
			obj.setCliOutputMode(set.opt.cli_output_mode);
			obj.setVerifyMode(set.opt.verify);

			if (set.aset.icon_extract_path.isSet())
				obj.setIconExtractPath(set.aset.icon_extract_path.get());
			if (set.aset.nacp_extract_path.isSet())
				obj.setNacpExtractPath(set.aset.nacp_extract_path.get());

			obj.setRomfsShowFsTree(set.fs.show_fs_tree);
			obj.setRomfsExtractJobs(set.fs.extract_jobs);

			obj.process();
		}
	}
	catch (tc::Exception& e)
	{
		fmt::print("[{0}{1}ERROR] {2}\n", e.module(), (strlen(e.module()) != 0 ? " ": ""), e.error());
		return 1;
	}
	return 0;
}
```

`src/types.h`:

```h
#pragma once
#include <tc/types.h>
#include <tc/Exception.h>
#include <tc/Optional.h>
#include <tc/io.h>
#include <tc/io/IOUtil.h>
#include <tc/cli.h>
#include <fmt/core.h>


namespace nstool {

struct CliOutputMode
{
	bool show_basic_info;
	bool show_extended_info;
	bool show_layout;
	bool show_keydata;

	CliOutputMode() : show_basic_info(false), show_extended_info(false), show_layout(false), show_keydata(false)
	{}

	CliOutputMode(bool show_basic_info, bool show_extended_info, bool show_layout, bool show_keydata) : show_basic_info(show_basic_info), show_extended_info(show_extended_info), show_layout(show_layout), show_keydata(show_keydata)
	{}
};

struct ExtractJob {
	tc::io::Path virtual_path;
	tc::io::Path extract_path;
};

}
```

`src/util.cpp`:

```cpp
#include "util.h"

#include <tc/io/FileStream.h>
#include <tc/io/SubStream.h>
#include <tc/io/IOUtil.h>

#include <sstream>
#include <algorithm>
#include <iostream>

inline bool isNotPrintable(char chr) { return isprint(chr) == false; }

void nstool::processResFile(const std::shared_ptr<tc::io::IStream>& file, std::map<std::string, std::string>& dict)
{
	if (file == nullptr || !file->canRead() || file->length() == 0)
	{
		return;
	}

	std::stringstream in_stream;

	// populate string stream
	tc::ByteData cache = tc::ByteData(0x1000);
	file->seek(0, tc::io::SeekOrigin::Begin);
	for (int64_t pos = 0; pos < file->length();)
	{
		size_t bytes_read = file->read(cache.data(), cache.size());

		in_stream << std::string((char*)cache.data(), bytes_read);

		pos += tc::io::IOUtil::castSizeToInt64(bytes_read);
	}

	// process stream
	std::string line, key, value;
	while (std::getline(in_stream, line))
	{
		// read up to comment line
		if (line.find(";") != std::string::npos)
			line = line.substr(0, line.find(";"));

		// change chars to lower string
		std::transform(line.begin(), line.end(), line.begin(), ::tolower);

		// strip whitespace
		line.erase(std::remove(line.begin(), line.end(), ' '), line.end());

		// strip nonprintable
		line.erase(std::remove_if(line.begin(), line.end(), isNotPrintable), line.end());

		// skip lines that don't have '='
		if (line.find("=") == std::string::npos)
			continue;

		key = line.substr(0,line.find("="));
		value = line.substr(line.find("=")+1);

		// skip if key or value is empty
		if (key.empty() || value.empty())
			continue;

		//std::cout << "[" + key + "]=(" + value + ")" << std::endl;

		dict[key] = value;
	}

}

void nstool::writeSubStreamToFile(const std::shared_ptr<tc::io::IStream>& in_stream, int64_t offset, int64_t length, const tc::io::Path& out_path, tc::ByteData& cache)
{
	writeStreamToStream(std::make_shared<tc::io::SubStream>(tc::io::SubStream(in_stream, offset, length)), std::make_shared<tc::io::FileStream>(tc::io::FileStream(out_path, tc::io::FileMode::Create, tc::io::FileAccess::Write)), cache);
}

void nstool::writeSubStreamToFile(const std::shared_ptr<tc::io::IStream>& in_stream, int64_t offset, int64_t length, const tc::io::Path& out_path, size_t cache_size)
{
	writeStreamToStream(std::make_shared<tc::io::SubStream>(tc::io::SubStream(in_stream, offset, length)), std::make_shared<tc::io::FileStream>(tc::io::FileStream(out_path, tc::io::FileMode::Create, tc::io::FileAccess::Write)), cache_size);
}

void nstool::writeStreamToFile(const std::shared_ptr<tc::io::IStream>& in_stream, const tc::io::Path& out_path, tc::ByteData& cache)
{
	writeStreamToStream(in_stream, std::make_shared<tc::io::FileStream>(tc::io::FileStream(out_path, tc::io::FileMode::Create, tc::io::FileAccess::Write)), cache);
}

void nstool::writeStreamToFile(const std::shared_ptr<tc::io::IStream>& in_stream, const tc::io::Path& out_path, size_t cache_size)
{
	writeStreamToStream(in_stream, std::make_shared<tc::io::FileStream>(tc::io::FileStream(out_path, tc::io::FileMode::Create, tc::io::FileAccess::Write)), cache_size);
}

void nstool::writeStreamToStream(const std::shared_ptr<tc::io::IStream>& in_stream, const std::shared_ptr<tc::io::IStream>& out_stream, tc::ByteData& cache)
{
	// iterate thru child files
	size_t cache_read_len;
	
	in_stream->seek(0, tc::io::SeekOrigin::Begin);
	out_stream->seek(0, tc::io::SeekOrigin::Begin);
	for (int64_t remaining_data = in_stream->length(); remaining_data > 0;)
	{
		cache_read_len = in_stream->read(cache.data(), cache.size());
		if (cache_read_len == 0)
		{
			throw tc::io::IOException("nstool::writeStreamToStream()", "Failed to read from source streeam.");
		}

		out_stream->write(cache.data(), cache_read_len);

		remaining_data -= int64_t(cache_read_len);
	}
}

void nstool::writeStreamToStream(const std::shared_ptr<tc::io::IStream>& in_stream, const std::shared_ptr<tc::io::IStream>& out_stream, size_t cache_size)
{
	tc::ByteData cache = tc::ByteData(cache_size);
	writeStreamToStream(in_stream, out_stream, cache);
}

std::string nstool::getTruncatedBytesString(const byte_t* data, size_t len)
{
	if (data == nullptr) { return fmt::format(""); }

	std::string str = "";

	if (len <= 8)
	{
		str = tc::cli::FormatUtil::formatBytesAsString(data, len, true, "");
	}
	else
	{
		str = fmt::format("{:02X}{:02X}{:02X}{:02X}...{:02X}{:02X}{:02X}{:02X}", data[0], data[1], data[2], data[3], data[len-4], data[len-3], data[len-2], data[len-1]);
	}

	return str;
}

std::string nstool::getTruncatedBytesString(const byte_t* data, size_t len, bool do_not_truncate)
{
	if (data == nullptr) { return fmt::format(""); }

	std::string str = "";

	if (len <= 8 || do_not_truncate)
	{
		str = tc::cli::FormatUtil::formatBytesAsString(data, len, true, "");
	}
	else
	{
		str = fmt::format("{:02X}{:02X}{:02X}{:02X}...{:02X}{:02X}{:02X}{:02X}", data[0], data[1], data[2], data[3], data[len-4], data[len-3], data[len-2], data[len-1]);
	}

	return str;
}
```

`src/util.h`:

```h
#pragma once
#include "types.h"

namespace nstool
{

void processResFile(const std::shared_ptr<tc::io::IStream>& file, std::map<std::string, std::string>& dict);

void writeSubStreamToFile(const std::shared_ptr<tc::io::IStream>& in_stream, int64_t offset, int64_t length, const tc::io::Path& out_path, tc::ByteData& cache);
void writeSubStreamToFile(const std::shared_ptr<tc::io::IStream>& in_stream, int64_t offset, int64_t length, const tc::io::Path& out_path, size_t cache_size = 0x10000);
void writeStreamToFile(const std::shared_ptr<tc::io::IStream>& in_stream, const tc::io::Path& out_path, tc::ByteData& cache);
void writeStreamToFile(const std::shared_ptr<tc::io::IStream>& in_stream, const tc::io::Path& out_path, size_t cache_size = 0x10000);
void writeStreamToStream(const std::shared_ptr<tc::io::IStream>& in_stream, const std::shared_ptr<tc::io::IStream>& out_stream, tc::ByteData& cache);
void writeStreamToStream(const std::shared_ptr<tc::io::IStream>& in_stream, const std::shared_ptr<tc::io::IStream>& out_stream, size_t cache_size = 0x10000);


std::string getTruncatedBytesString(const byte_t* data, size_t len);
std::string getTruncatedBytesString(const byte_t* data, size_t len, bool do_not_truncate);

}
```

`src/version.h`:

```h
#pragma once
#define APP_NAME	"NSTool"
#define BIN_NAME	"nstool"
#define VER_MAJOR	0
#define VER_MINOR	0
#define VER_PATCH   0
#define AUTHORS		"jakcron"
```