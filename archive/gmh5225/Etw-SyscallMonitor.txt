Project Path: arc_gmh5225_Etw-SyscallMonitor_tye5rhek

Source Tree:

```txt
arc_gmh5225_Etw-SyscallMonitor_tye5rhek
├── ETW-SycallMonitor.sln
├── ETW_syscall_monitor.png
├── README.md
└── src
    ├── App.config
    ├── ETW
    │   ├── EtwUserTrace.cs
    │   ├── EtwUserTraceProvider.cs
    │   ├── MIcrosoft-Windows-Threat-Intelligence.cs
    │   ├── Microsoft-Windows-Kernel-Audit-API-Calls.cs
    │   ├── Microsoft-Windows-Kernel-EventTracing.cs
    │   ├── Microsoft-Windows-Kernel-File.cs
    │   ├── Microsoft-Windows-Kernel-Network.cs
    │   ├── Microsoft-Windows-Kernel-Process.cs
    │   ├── Microsoft-Windows-Kernel-Registry.cs
    │   ├── Microsoft-Windows-Security-Auditing.cs
    │   ├── Microsoft-Windows-WFP.cs
    │   └── Microsoft-Windows-Win32k.cs
    ├── ETW-SyscallMonitor.csproj
    ├── MainWindow.xaml
    ├── MainWindow.xaml.cs
    ├── MemoryMap.cs
    ├── ProcessCreationTraitsMap.cs
    ├── ProcessProfile.cs
    ├── Program.cs
    ├── Properties
    │   └── AssemblyInfo.cs
    ├── Utilities
    │   ├── HashUtils.cs
    │   ├── Log.cs
    │   ├── MemoryExtensions.cs
    │   ├── PathUtils.cs
    │   ├── PeMetadata.cs
    │   ├── PeReaderExtensions.cs
    │   ├── ProcessUtils.cs
    │   ├── SymbolUtils.cs
    │   ├── TokenUtils.cs
    │   └── Win32.cs
    ├── app.manifest
    ├── libs
    │   └── PPLKillerDLL.dll
    └── packages.config

```

`ETW-SycallMonitor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28714.193
MinimumVisualStudioVersion = 10.0.40219.1
Project("{08FB35DE-EB89-4EBE-8671-8ACF755A295B}") = "ETW-SyscallMonitor", "src\ETW-SyscallMonitor.csproj", "{21A4C658-2929-484D-A54A-94360040EE3F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{21A4C658-2929-484D-A54A-94360040EE3F}.Debug|x64.ActiveCfg = Debug|x64
		{21A4C658-2929-484D-A54A-94360040EE3F}.Debug|x64.Build.0 = Debug|x64
		{21A4C658-2929-484D-A54A-94360040EE3F}.Release|x64.ActiveCfg = Release|x64
		{21A4C658-2929-484D-A54A-94360040EE3F}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {269C8D8C-CA9A-4872-9494-DF1CD513FBDE}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
![screenshot](ETW_syscall_monitor.png)

# Hunting hidden shellcode via syscall summaries

You can roughly determine an executable's purpose from its Import Table (or [ImpHash](https://www.mandiant.com/resources/blog/tracking-malware-import-hashing)).
<br/>Or, better yet, from a summary of its [capa](https://github.com/mandiant/capa)bilities extracted by automated static analysis of callsites and parameters.

This project is the *runtime* equivalent.

Using kernel ETW telemetry, we record the set of interesting syscalls (plus interesting parameters).

Malware can't use anti-analysis approaches to hide from the kernel at runtime. If (user-mode) malware needs to make syscalls to perform tasks then it must make those calls.

Anomalies in this set for a given process should have sufficient information to identify the presence of malicious code on the system. However, the profile will not have sufficient granularity to establish a perfect timeline of events.

See [[Black Hat Asia 2023] You Can Run, but You Can't Hide - Finding the Footprints of Hidden Shellcode](https://www.blackhat.com/asia-23/briefings/schedule/index.html#you-can-run-but-you-cant-hide---finding-the-footprints-of-hidden-shellcode-31237) for more details.

#### Notes
 * I'm not a UX developer.
 * This is a rough proof of concept.
 * For best results, run on Windows 10.
 * Uses BYOVD to enable PPL in order to collect Microsoft-Windows-Threat-Intelligence events
 * Periodically outputs a whole system `SyscallSummary.json` to the current directory
 * Periodically outputs per-process profiles to `SycallSummaries\%executable%__%startup_hash%.json`

```

`src/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="xunit.core" publicKeyToken="8d05b1bb7a6fdb6c" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-2.4.1.0" newVersion="2.4.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="xunit.execution.desktop" publicKeyToken="8d05b1bb7a6fdb6c" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-2.4.1.0" newVersion="2.4.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Validation" publicKeyToken="2fc06f0d701809a7" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-2.5.0.0" newVersion="2.5.0.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>

```

`src/ETW-SyscallMonitor.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.2.0.42\build\Microsoft.Diagnostics.Tracing.TraceEvent.props" Condition="Exists('..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.2.0.42\build\Microsoft.Diagnostics.Tracing.TraceEvent.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x64</Platform>
    <ProjectGuid>{21A4C658-2929-484D-A54A-94360040EE3F}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>SyscallSummariser</RootNamespace>
    <AssemblyName>ETW-SyscallMonitor</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject />
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationManifest>app.manifest</ApplicationManifest>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Microsoft.O365.Security.Native.ETW, Version=1.0.8150.2326, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=AMD64">
      <HintPath>..\packages\Microsoft.O365.Security.Native.ETW.4.2.3\lib\net45\Microsoft.O365.Security.Native.ETW.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>..\packages\Newtonsoft.Json.13.0.1\lib\net45\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="PeNet, Version=2.9.7.0, Culture=neutral, PublicKeyToken=6cf2bfba59bcfb3f, processorArchitecture=MSIL">
      <HintPath>..\packages\PeNet.2.9.7\lib\net48\PeNet.dll</HintPath>
    </Reference>
    <Reference Include="PeNet.Asn1, Version=2.0.0.0, Culture=neutral, PublicKeyToken=1e2e3568f0050bf5, processorArchitecture=MSIL">
      <HintPath>..\packages\PeNet.Asn1.2.0.0\lib\net48\PeNet.Asn1.dll</HintPath>
    </Reference>
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="System" />
    <Reference Include="System.Buffers, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Buffers.4.5.1\lib\net461\System.Buffers.dll</HintPath>
    </Reference>
    <Reference Include="System.Collections.Immutable, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Collections.Immutable.6.0.0\lib\net461\System.Collections.Immutable.dll</HintPath>
    </Reference>
    <Reference Include="System.Core" />
    <Reference Include="System.IO.Compression" />
    <Reference Include="System.IO.Compression.FileSystem" />
    <Reference Include="System.Management" />
    <Reference Include="System.Memory, Version=4.0.1.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Memory.4.5.4\lib\net461\System.Memory.dll</HintPath>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Numerics.Vectors, Version=4.1.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Numerics.Vectors.4.5.0\lib\net46\System.Numerics.Vectors.dll</HintPath>
    </Reference>
    <Reference Include="System.Reflection.Metadata, Version=6.0.0.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Reflection.Metadata.6.0.1\lib\net461\System.Reflection.Metadata.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.CompilerServices.Unsafe.6.0.0\lib\net461\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
    </Reference>
    <Reference Include="System.Security" />
    <Reference Include="System.Security.Cryptography.Pkcs, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Pkcs.6.0.0\lib\net461\System.Security.Cryptography.Pkcs.dll</HintPath>
    </Reference>
    <Reference Include="System.Xaml" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
    <Reference Include="Validation, Version=2.5.0.0, Culture=neutral, PublicKeyToken=2fc06f0d701809a7, processorArchitecture=MSIL">
      <HintPath>..\packages\Validation.2.5.51\lib\net45\Validation.dll</HintPath>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="xunit.abstractions, Version=2.0.0.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c, processorArchitecture=MSIL">
      <HintPath>..\packages\xunit.abstractions.2.0.3\lib\net35\xunit.abstractions.dll</HintPath>
    </Reference>
    <Reference Include="xunit.core, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c, processorArchitecture=MSIL">
      <HintPath>..\packages\xunit.extensibility.core.2.4.1\lib\net452\xunit.core.dll</HintPath>
    </Reference>
    <Reference Include="xunit.execution.desktop, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c, processorArchitecture=MSIL">
      <HintPath>..\packages\xunit.extensibility.execution.2.4.1\lib\net452\xunit.execution.desktop.dll</HintPath>
    </Reference>
    <Reference Include="Xunit.SkippableFact, Version=1.4.0.0, Culture=neutral, PublicKeyToken=b2b52da82b58eb73, processorArchitecture=MSIL">
      <HintPath>..\packages\Xunit.SkippableFact.1.4.13\lib\net452\Xunit.SkippableFact.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ETW\MIcrosoft-Windows-Threat-Intelligence.cs" />
    <Compile Include="ETW\Microsoft-Windows-WFP.cs" />
    <Compile Include="ETW\EtwUserTrace.cs" />
    <Compile Include="MemoryMap.cs" />
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="ETW\EtwUserTraceProvider.cs" />
    <Compile Include="ETW\Microsoft-Windows-Kernel-Audit-API-Calls.cs" />
    <Compile Include="ETW\Microsoft-Windows-Kernel-EventTracing.cs" />
    <Compile Include="ETW\Microsoft-Windows-Kernel-File.cs" />
    <Compile Include="ETW\Microsoft-Windows-Kernel-Process.cs" />
    <Compile Include="ETW\Microsoft-Windows-Kernel-Registry.cs" />
    <Compile Include="ETW\Microsoft-Windows-Kernel-Network.cs" />
    <Compile Include="ETW\Microsoft-Windows-Security-Auditing.cs" />
    <Compile Include="ETW\Microsoft-Windows-Win32k.cs" />
    <Compile Include="ProcessProfile.cs" />
    <Compile Include="ProcessCreationTraitsMap.cs" />
    <Compile Include="Utilities\HashUtils.cs" />
    <Compile Include="Utilities\Log.cs" />
    <Compile Include="Utilities\MemoryExtensions.cs" />
    <Compile Include="Utilities\PathUtils.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Utilities\PeMetadata.cs" />
    <Compile Include="Utilities\PeReaderExtensions.cs" />
    <Compile Include="Utilities\ProcessUtils.cs" />
    <Compile Include="Utilities\SymbolUtils.cs" />
    <Compile Include="Utilities\TokenUtils.cs" />
    <Compile Include="Utilities\Win32.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="app.manifest" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <Page Include="MainWindow.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Content Include="PPLKillerDLL.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`src/ETW/EtwUserTrace.cs`:

```cs
namespace SyscallSummariser.ETW {
    using Microsoft.O365.Security.ETW;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Threading;

    internal class EtwUserTrace {
        internal UserTrace trace = null;
        private static string _sessionName;
        private static readonly List<EtwUserTraceProvider> providers = new List<EtwUserTraceProvider>();  // enabled providers

        internal void Enable() {
            _sessionName = $"{typeof(Program).Namespace}-User-Trace";
            this.trace = new UserTrace(_sessionName);

            var properties = new EventTraceProperties
            {
                // we need a buffer large enough for 1 second of events
                // note - maximum single event size is 64KB
                BufferSize = 512 // KB
                
                // https://docs.microsoft.com/en-us/windows/win32/etw/logging-mode-constants
                // by default, ETW uses one buffer per processor - so events can arrive out of order
                // for low volumes (< 1000 events per second) you can specify the use of a common
                // buffer with EVENT_TRACE_NO_PER_PROCESSOR_BUFFERING
                // note - krabs enables this common buffer by default.
                // for high volume tracing this should be overridden to avoid dropped events
                //   LogFileMode = (uint)LogFileModeFlags.FLAG_EVENT_TRACE_REAL_TIME_MODE
            };
            this.trace.SetTraceProperties(properties);

            var providerTypes = Assembly.GetExecutingAssembly().GetTypes().Where(x => x.BaseType == typeof(EtwUserTraceProvider));
            foreach (var providerType in providerTypes) {
                var provider = (EtwUserTraceProvider)Activator.CreateInstance(providerType, new Object[] { this.trace });
                providers.Add(provider);
                provider.Enable();
            }

            var Lost_Event = new Provider(new Guid("{6a399ae0-4bc6-4de9-870b-3657f8947e7e}"));
            Lost_Event.OnEvent += (record) =>
            {
                Log.WarnWrite("Lost_Event received");
            };

            Lost_Event.OnError += (record) =>
            {
                Log.WarnWrite($"Lost_Event received");
            };
            trace.Enable(Lost_Event);
        }

        internal void BlockingStart() {

            foreach (var provider in providers)
            {
                if (provider.trace != null && provider.trace != this.trace)
                {
                    ThreadPool.QueueUserWorkItem(_this => {
                        var Lost_Event = new Provider(new Guid("{6a399ae0-4bc6-4de9-870b-3657f8947e7e}"));
                        Lost_Event.OnEvent += (record) =>
                        {
                            Log.WarnWrite($"[{provider.ProviderName}] Lost_Event received");
                        };

                        Lost_Event.OnError += (record) =>
                        {
                            Log.WarnWrite($"[{provider.ProviderName}] Lost_Event received");
                        };
                        ((UserTrace)_this).Enable(Lost_Event);
                        ((UserTrace)_this).Start();
                    }, provider.trace);
                }
            }

            try {
                Log.Write($"Starting UserTrace({_sessionName})...");
                this.trace.Start();
                Log.Write($"UserTrace.Start({_sessionName}) completed");
            } catch (NoTraceSessionsRemaining) {
                Log.ErrorWrite($"{_sessionName}.Start() failed - no trace sessions remaining");
            } catch (OpenTraceFailure) {
                Log.ErrorWrite($"{_sessionName}.Start() failed - trace failed to start");
            } catch (TraceAlreadyRegistered) {
                Log.ErrorWrite($"{_sessionName}.Start() failed - the ETW trace object is already registered");
            } catch (InvalidParameter) {
                Log.ErrorWrite($"{_sessionName}.Start() failed - an invalid parameter was provided");
            } catch (SEHException) {
                Log.ErrorWrite($"{_sessionName}.Start() trace threw SEH exception");
            }
        }

        internal void Stop() {
            foreach (var provider in providers)
            {
                if (provider.trace != null && provider.trace != this.trace)
                {
                    Log.ErrorWrite($"{provider.ProviderName} != this.trace");
                    provider.trace.Stop();
                }
            }

            if (this.trace != null) {
                Log.Write($"Stopping UserTrace({_sessionName})...");
                try {
                    this.trace.Stop();
                } catch (Exception e) {
                    Log.ErrorWrite($"UserTrace.Stop() threw {e.Message}");
                }
                this.trace = null;
            }
        }
    }
}
```

`src/ETW/EtwUserTraceProvider.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;

    internal abstract class EtwUserTraceProvider
    {
        internal UserTrace trace = null;

        internal EtwUserTraceProvider(UserTrace trace)
        {
            this.trace = trace;
        }

        /* derived clasess will need to implement a constructor */
        // public Microsoft_Windows_Something(UserTrace trace) : base(trace) { }

        internal virtual string ProviderName { get; set; }
        //get { return "Microsoft-Windows-Something"; }

        internal abstract void Enable();
        //{
        //    var somethingProvider = new Provider(providerName);
        //    somethingProvider.Any = 0x12345;
        //    var eventFilter = new EventFilter(Filter.EventIdIs(1337));
        //    eventFilter.OnEvent += (record) =>
        //    {
        //        Log.Write("Hello World");
        //    };
        //    somethingProvider.AddFilter(eventFilter);
        //    this.trace.Enable(somethingProvider);
        //}
    }
}

```

`src/ETW/MIcrosoft-Windows-Threat-Intelligence.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.InteropServices;
    using static Win32.Kernel32;
    using static Win32.Ntdll;

    /// <summary>
    /// profiles use of security relevant kernel APIs
    /// </summary>
    internal class Microsoft_Windows_Threat_Intellgience : EtwUserTraceProvider
    {
        public Microsoft_Windows_Threat_Intellgience(UserTrace trace) : base(trace) { }

        internal override string ProviderName
        {
            get { return "Microsoft-Windows-Threat-Intelligence"; }
        }

        private string EnrichPointer(IEventRecord record, string addressField, string mappedfilenameField, string regionTypeField)
        {
            var address = record.GetUInt64(addressField, 0);
            var targetPid = record.GetUInt32("TargetProcessId");
            var owner = MemoryMap.GetOwner(targetPid, address);

            if (owner == MemoryMap.Unknown && !string.IsNullOrEmpty(mappedfilenameField))
            {
                owner = Path.GetFileName(record.GetUnicodeString(mappedfilenameField, ""));
                if (string.IsNullOrEmpty(owner))
                    owner = $"{(MemoryType)record.GetUInt32(regionTypeField, 0)}";
            }

            return owner;
        }

        public static void EnableReadWriteMemoryLogging(int pid, string name, bool verbose = false)
        {
            // Note this only works on Windows 10.
            // This syscall has been hardened in Windows 11.
            using (var hProcess = OpenProcess(ProcessDesiredAccess.SetLimitedInformation, false, pid))
            {
                if (!hProcess.IsInvalid)
                {
                    var prwmli = new PROCESS_READWRITEVM_LOGGING_INFORMATION
                    {
                        Flags = 3 // EnableReadVmLogging | EnableWriteVmLogging 
                    };
                    _ = NtSetInformationProcess(hProcess, PROCESSINFOCLASS.ProcessEnableReadWriteVmLogging, ref prwmli, Marshal.SizeOf(prwmli));
                }
            }
        }

        /// <summary>
        /// enable ETW profiling via Microsoft-Windows-Threat-Intelligence events
        /// </summary>
        internal override void Enable()
        {
            if (!Program.runAsPPL)
            {
                Log.WarnWrite($"Skipping {ProviderName} - insufficient privilege");
                Log.WarnWrite(" --> PPLKillerDLL.dll (BYOVD) is missing");
                this.trace = null;
                return;
            }

            foreach (var name in ProcessCreationTraitsMap.interestingTargetProcesses)
            {
                foreach(var process in Process.GetProcessesByName(name)) {
                    EnableReadWriteMemoryLogging(process.Id, name);
                }
            }

            var tiProvider = new Provider(this.ProviderName)
            {
                TraceFlags = TraceFlags.IncludeStackTrace
            };

            //  1 ALLOCVM_REMOTE
            //  6 ALLOCVM_LOCAL
            // 21 ALLOCVM_REMOTE_KERNEL_CALLER
            // 26 ALLOCVM_LOCAL_KERNEL_CALLER
            var allocVMFilter = new EventFilter(Filter.EventIdIs(1)
                                            .Or(Filter.EventIdIs(6))
                                            .Or(Filter.EventIdIs(21))
                                            .Or(Filter.EventIdIs(26)));
            allocVMFilter.OnEvent += (record) => {

                var region = new MemoryRegion(record, true, (record.Id & 1) == 1);
                MemoryMap.Add(region.Pid, region.BaseAddress, region);

                var callingPid = (record.Id == 21 || record.Id == 26) ? 4 : record.GetUInt32("CallingProcessId");
                var targetPid = record.GetUInt32("TargetProcessId");
                var target = ProcessCreationTraitsMap.GetTarget(callingPid, targetPid);
                var protection = (MemoryProtection)record.GetUInt32("ProtectionMask");
                var type = $"{(MemoryState)record.GetUInt32("AllocationType")}".Replace(", ", "|"); ;
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtProtectVirtualMemory({target}, {protection}, {type})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            tiProvider.AddFilter(allocVMFilter);

            //  2 PROTECTVM_REMOTE
            //  7 PROTECTVM_LOCAL
            // 22 PROTECTVM_REMOTE_KERNEL_CALLER
            // 27 PROTECTVM_LOCAL_KERNEL_CALLER
            var protectVMFilter = new EventFilter(Filter.EventIdIs(2)
                                              .Or(Filter.EventIdIs(7))
                                              .Or(Filter.EventIdIs(22))
                                              .Or(Filter.EventIdIs(27)));
            protectVMFilter.OnEvent += (record) => {
                var region = new MemoryRegion(record, false, (record.Id & 1) == 0);
                MemoryMap.Add(region.Pid, region.BaseAddress, region);
                
                var callingPid = (record.Id == 22 || record.Id == 27) ? 4 : record.GetUInt32("CallingProcessId");
                var targetPid = record.GetUInt32("TargetProcessId");
                var target = ProcessCreationTraitsMap.GetTarget(callingPid, targetPid);
                var originalProtection = (MemoryProtection)record.GetUInt32("VaVadAllocationProtect", 0); // 21H2+
                var originalProtectionString = (originalProtection == MemoryProtection.Unknown) ? "" : $"{ originalProtection}->";
                var oldProtection = (MemoryProtection)record.GetUInt32("LastProtectionMask");
                var protection = (MemoryProtection)record.GetUInt32("ProtectionMask");
                var address = EnrichPointer(record, "BaseAddress", "VaVadMmfName", "VaVadRegionType");
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtProtectVirtualMemory({target}, {address}, {originalProtectionString}{oldProtection}->{protection})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);

            };
            tiProvider.AddFilter(protectVMFilter);

            //  3 MAPVIEW_REMOTE
            //  8 MAPVIEW_LOCAL
            // 23 MAPVIEW_REMOTE_KERNEL_CALLER
            // 28 MAPVIEW_LOCAL_KERNEL_CALLER
            var mapViewFilter = new EventFilter(Filter.EventIdIs(3)
                                              .Or(Filter.EventIdIs(8))
                                              .Or(Filter.EventIdIs(23))
                                              .Or(Filter.EventIdIs(28)));
            mapViewFilter.OnEvent += (record) => {
                var region = new MemoryRegion(record, (record.Id & 1) == 1);
                MemoryMap.Add(region.Pid, region.BaseAddress, region);
                // TODO kernel callers

                var callingPid = (record.Id == 23 || record.Id == 28) ? 4 : record.GetUInt32("CallingProcessId");
                var targetPid = record.GetUInt32("TargetProcessId");
                var target = ProcessCreationTraitsMap.GetTarget(callingPid, targetPid);
                var type = (MemoryType)record.GetUInt32("AllocationType");
                var protection = (MemoryProtection)record.GetUInt32("ProtectionMask");

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"API-MapViewOfSection({target}, {type}, {protection}))", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);

            };
            tiProvider.AddFilter(mapViewFilter);

            //  4 QUEUEUSERAPC_REMOTE
            // 24 QUEUEUSERAPC_REMOTE_KERNEL_CALLER
            var queueApcFilter = new EventFilter(Filter.EventIdIs(4)
                                             .Or(Filter.EventIdIs(24)));
            queueApcFilter.OnEvent += (record) => {
                var callingPid = (record.Id == 25) ? 4 : record.GetUInt32("CallingProcessId");
                var targetPid = record.GetUInt32("TargetProcessId");
                var target = ProcessCreationTraitsMap.GetTarget(callingPid, targetPid);
                var apcRoutine = EnrichPointer(record, "ApcRoutine", "ApcRoutineVadAllocationProtect", "ApcRoutineVadMmfName");
                var apcArgument1 = EnrichPointer(record, "ApcArgument1", "ApcArgument1VadMmfName", "ApcArgument1VadRegionType");
                var apcArgument2 = EnrichPointer(record, "ApcArgument2", null, null); // TODO(jdu) feature request?
                var apcArgument3 = EnrichPointer(record, "ApcArgument3", null, null);
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"API-QueueUserAPC({target}, {apcRoutine} {apcArgument1}, {apcArgument2}, {apcArgument3})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            tiProvider.AddFilter(queueApcFilter);

            //  5 SETTHREADCONTEXT_REMOTE
            // 25 SETTHREADCONTEXT_REMOTE_KERNEL_CALLER
            var threadContextFilter = new EventFilter(Filter.EventIdIs(5)
                                                  .Or(Filter.EventIdIs(25)));
            threadContextFilter.OnEvent += (record) => {
                var callingPid = (record.Id == 25) ? 4 : record.GetUInt32("CallingProcessId");
                var targetPid = record.GetUInt32("TargetProcessId");
                var target = ProcessCreationTraitsMap.GetTarget(callingPid, targetPid);
                var rip = EnrichPointer(record, "Pc", "PcVadMmfName", "PcVadRegionType");
                // TODO - enrich Reg0..Reg7, Sp, Fp to find oddities?
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"API-SetThreadContext({target}, {rip}))", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            tiProvider.AddFilter(threadContextFilter);

            // 11 READVM_LOCAL
            // 12 WRITEVM_LOCAL
            // 13 READVM_REMOTE
            // 14 WRITEVM_REMOTE
            var readWriteFilter = new EventFilter(Filter.EventIdIs(11)
                                              .Or(Filter.EventIdIs(12))
                                              .Or(Filter.EventIdIs(13))
                                              .Or(Filter.EventIdIs(14)));
            readWriteFilter.OnEvent += (record) => {
                var api = (record.Id % 2 == 1) ? "NtReadVirtualMemory" : "NtWriteVirtualMemory";
                var callingPid = record.GetUInt32("CallingProcessId");
                var targetPid = record.GetUInt32("TargetProcessId");
                var target = ProcessCreationTraitsMap.GetTarget(callingPid, targetPid);
                if (string.IsNullOrEmpty(target) || target == "self")
                    return;

                var originalProtection = (MemoryProtection)record.GetUInt32("VaVadAllocationProtect", 0);// 21H2+
                var targetRegion = EnrichPointer(record, "BaseAddress", "VaVadMmfName", "VaVadRegionType");
                var szOriginalProtection = originalProtection == MemoryProtection.Unknown ? "" : $", {originalProtection}";
                var szTargetRegion = (targetRegion == MemoryMap.Unknown || targetRegion == MemoryMap.NULL) ? "" : $", {targetRegion}";

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"{api}({target}{szTargetRegion}{szOriginalProtection})", record.GetStackTrace());
                if (value != null && (value.Contains("->kernelbase!K32GetModuleFileName") || value.Contains("->kernel32!CreateToolhelp32Snapshot->")))
                    return; // drop common PEB reads
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            tiProvider.AddFilter(readWriteFilter);

            // 15 SUSPEND_THREAD
            // 16 RESUME_THREAD
            // 17 SUSPEND_PROCESS
            // 18 RESUME_PROCESS
            // 19 FREEZE_PROCESS
            // 20 THAW_PROCESS
            var suspendResumeFilter = new EventFilter(Filter.EventIdIs(15)
                                                  .Or(Filter.EventIdIs(16))
                                                  .Or(Filter.EventIdIs(17))
                                                  .Or(Filter.EventIdIs(18))
                                                  .Or(Filter.EventIdIs(19))
                                                  .Or(Filter.EventIdIs(20)));
            suspendResumeFilter.OnEvent += (record) => {
                var api = "%error%";
                switch(record.Id)
                {
                    case 15:
                        api = "SuspendThread";
                        break;
                    case 16:
                        api = "ResumeThread";
                        break;
                    case 17:
                        api = "SuspendProcess";
                        break;
                    case 18:
                        api = "ResumeProcess";
                        break;
                    case 19:
                        api = "FreezeProcess";
                        break;
                    case 20:
                        api = "ThawProcess";
                        break;
                }
                var callingPid = record.GetUInt32("CallingProcessId");
                var targetPid = record.GetUInt32("TargetProcessId");
                var target = ProcessCreationTraitsMap.GetTarget(callingPid, targetPid);
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"API-{api}({target})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            tiProvider.AddFilter(suspendResumeFilter);

            // 29 DRIVER_DEVICE
            // 30 DRIVER_DEVICE
            var driverLoadFilter = new EventFilter(Filter.EventIdIs(29)
                                               .Or(Filter.EventIdIs(30)));
            driverLoadFilter.OnEvent += (record) => {
                var api = (record.Id == 29) ? "NtLoadDriver" : "NtUnloadDriver";
                var driverName = record.GetUnicodeString("DriverName");

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"{api}({driverName})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);

            };
            tiProvider.AddFilter(driverLoadFilter);

            // 31 DRIVER_DEVICE
            // 32 DRIVER_DEVICE
            var driverDeviceFilter = new EventFilter(Filter.EventIdIs(31)
                                                 .Or(Filter.EventIdIs(32)));
            driverDeviceFilter.OnEvent += (record) => {
                var api = (record.Id == 31) ? "NtCreateFile" : "NtClose";
                var driverName = record.GetUnicodeString("DriverName");
                var deviceName = record.GetUnicodeString("DeviceName");
                deviceName = deviceName != "(null)" ? deviceName : driverName;
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"{api}(\\Device{deviceName})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            tiProvider.AddFilter(driverDeviceFilter);

            this.trace.Enable(tiProvider);
        }
    }
}
```

`src/ETW/Microsoft-Windows-Kernel-Audit-API-Calls.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// profiles use of an (interesting) subset of syscalls using Microsoft-Windows-Kernel-Audit-API-Calls events
    /// </summary>
    internal class Microsoft_Windows_Kernel_Audit_API_Calls : EtwUserTraceProvider
    {
        public Microsoft_Windows_Kernel_Audit_API_Calls(UserTrace trace) : base(trace) { }

        internal override string ProviderName
        {
            get { return "Microsoft-Windows-Kernel-Audit-API-Calls"; }
        }

        enum ProcessAccessRights : uint {
            TERMINATE = 0x1,
            CREATE_THREAD = 0x2,
            SET_SESSIONID = 0x4,
            VM_OPERATION = 0x8,
            VM_READ = 0x10,
            VM_WRITE = 0x20,
            DUP_HANDLE = 0x40,
            CREATE_PROCESS = 0x80,
            SET_QUOTA = 0x100,
            SET_INFORMATION = 0x200,
            QUERY_INFORMATION = 0x400,
            SUSPEND_RESUME = 0x800,
            QUERY_LIMITED_INFORMATION = 0x1000,
            DELETE = 0x10000,
            READ_CONTROL = 0x20000,
            WRITE_DAC = 0x40000,
            WRITE_OWNER = 0x80000,
            SYNCHRONIZE = 0x100000
        }
        internal string DesiredAccess(uint desiredAccess) {

            if (desiredAccess == 0x1FFFFF)
                return "ALL_ACCESS";

            if (desiredAccess == 0x1F0FFF)
                return "ALL_ACCESS(XP)";

            var rights = new List<string>();
            foreach (uint right in Enum.GetValues(typeof(ProcessAccessRights))) {
                if ((desiredAccess & right) == right)
                    rights.Add(Enum.GetName(typeof(ProcessAccessRights), right));
            }
            return string.Join("|", rights);
        }
        enum ThreadAccessRights : uint {
            TERMINATE = 0x1,
            SUSPEND_RESUME = 0x2,
            ALERT = 0x4,
            GET_CONTEXT = 0x8,
            SET_CONTEXT = 0x10,
            SET_INFORMATION = 0x20,
            QUERY_INFORMATION = 0x40,
            SET_THREAD_TOKEN = 0x80,
            IMPERSONATE = 0x100,
            DIRECT_IMPERSONATION = 0x200,
            SET_LIMITED_INFORMATION = 0x400,
            QUERY_LIMITED_INFORMATION = 0x800,
            DELETE = 0x10000,
            READ_CONTROL = 0x20000,
            WRITE_DAC = 0x40000,
            WRITE_OWNER = 0x80000,
            SYNCHRONIZE = 0x100000
        }
        internal string threadAccessRights(uint desiredAccess) {

            if (desiredAccess == 0x1FFFFF)
                return "ALL_ACCESS";

            if (desiredAccess == 0x1F03FF)
                return "ALL_ACCESS(XP)";

            var rights = new List<string>();
            foreach (uint right in Enum.GetValues(typeof(ThreadAccessRights))) {
                if ((desiredAccess & right) == right)
                    rights.Add(Enum.GetName(typeof(ThreadAccessRights), right));
            }
            return string.Join("|", rights);
        }
        internal override void Enable()
        {
            /*
               Matt's mapping from event ids to API functions -
               https://twitter.com/mattifestation/status/1140655593318993920?s=19

               Event ID 1: PspLogAuditSetLoadImageNotifyRoutineEvent(kernel)
               Event ID 2: PspLogAuditTerminateRemoteProcessEvent
               Event ID 3: NtCreateSymbolicLink
               Event ID 4: PspSetContextThreadInternal
               Event ID 5: PspLogAuditOpenProcessEvent
               Event ID 6: PspLogAuditOpenThreadEvent
               Event ID 7: IoRegisterLastChanceShutdownNotification(kernel)
               Event ID 8: IoRegisterShutdownNotification(kernel)
             */

            var win32Provider = new Provider(this.ProviderName)
            {
                TraceFlags = TraceFlags.IncludeStackTrace
            };

            var terminateProcessFilter = new EventFilter(Filter.EventIdIs(2));
            terminateProcessFilter.OnEvent += (record) =>
            {
                var targetPid = record.GetUInt32("TargetProcessId");
                var target = ProcessCreationTraitsMap.GetTarget(record.ProcessId, targetPid);

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtTerminateProcess({target})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            win32Provider.AddFilter(terminateProcessFilter);

            var createSymbolicLinkFilter = new EventFilter(Filter.EventIdIs(3));
            createSymbolicLinkFilter.OnEvent += (record) =>
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtCreateSymbolicLinkObject", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);

            };
            win32Provider.AddFilter(createSymbolicLinkFilter);

            var openProcessFilter = new EventFilter(Filter.EventIdIs(5));
            openProcessFilter.OnEvent += (record) =>
            {
                var targetPid = record.GetUInt32("TargetProcessId");
                var desiredAccess = record.GetUInt32("DesiredAccess");
                var strDesiredAccess = DesiredAccess(desiredAccess);
                var target = ProcessCreationTraitsMap.GetTarget(record.ProcessId, targetPid);

                if(ProcessCreationTraitsMap.interestingTargets.Contains(target))
                {
                    var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtOpenProcess({target}, {strDesiredAccess})", record.GetStackTrace());
                    if (value != null && value.Contains("->kernel32!CreateToolhelp32Snapshot->"))
                        return; // drop some common occurances
                    TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
                }
            };
            win32Provider.AddFilter(openProcessFilter);

            var openThreadFilter = new EventFilter(Filter.EventIdIs(6));
            openThreadFilter.OnEvent += (record) =>
            {
                var targetPid = record.GetUInt32("TargetProcessId");
                var desiredAccess = record.GetUInt32("DesiredAccess");
                var strDesiredAccess = threadAccessRights(desiredAccess);
                var target = ProcessCreationTraitsMap.GetTarget(record.ProcessId, targetPid);
                if (string.IsNullOrEmpty(target) || target == "self")
                    return;

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtOpenThread({target}, {strDesiredAccess})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            win32Provider.AddFilter(openThreadFilter);

            this.trace.Enable(win32Provider);
        }
    }
}
```

`src/ETW/Microsoft-Windows-Kernel-EventTracing.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// profiles use of Event Tracing for Windows (ETW)
    /// </summary>
    internal class Microsoft_Windows_Kernel_EventTracing : EtwUserTraceProvider
    {
        public Microsoft_Windows_Kernel_EventTracing(UserTrace trace) : base(trace) { }

        internal override string ProviderName
        {
            get { return "Microsoft-Windows-Kernel-EventTracing"; }
        }

        private static Dictionary<string, bool> droppedEvents = new Dictionary<string, bool>();

        /// <summary>
        /// enable ETW profiling via Microsoft-Windows-Kernel-EventTracing events
        /// </summary>
        internal override void Enable()
        {
            var etwProvider = new Provider(this.ProviderName);
            etwProvider.Any = 0x10 |   // ETW_KEYWORD_SESSION
                              0x20 |   // ETW_KEYWORD_PROVIDER
                              0x40 |   // ETW_KEYWORD_LOST_EVENT
                              0x400;   // ETW_KEYWORD_ENABLEMENT
            etwProvider.TraceFlags = TraceFlags.IncludeStackTrace;

            // SessionStart
            var sessionStartFilter = new EventFilter(Filter.EventIdIs(2).Or(Filter.EventIdIs(10)));
            sessionStartFilter.OnEvent += (record) =>
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtTraceControl(SESSION_START)", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            etwProvider.AddFilter(sessionStartFilter);

            // SessionConfigure
            var sessionConfigureFilter = new EventFilter(Filter.EventIdIs(12).Or(Filter.EventIdIs(17)));
            sessionConfigureFilter.OnEvent += (record) =>
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtTraceControl(SESSION_CONFIGURE)", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            etwProvider.AddFilter(sessionConfigureFilter);

            // ProviderEnable
            var providerEnableFilter = new EventFilter(Filter.EventIdIs(14));
            providerEnableFilter.OnEvent += (record) =>
            {
                var provider = new Guid(record.GetBinary("ProviderName"));
                var any = record.GetUInt64("MatchAnyKeyword");
                var all = record.GetUInt64("MatchAllKeyword");
                var level = record.GetUInt8("Level");
                var property = record.GetUInt32("EnableProperty");
                // TODO(jdu) expand enable flags
                // https://docs.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-enable_trace_parameters

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtTraceControl(ENABLE_PROVIDER, {provider}, {level}, 0x{any:x}, 0x{all:x}, 0x{property:x})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            etwProvider.AddFilter(providerEnableFilter);

            // ProviderDisable
            var providerDisableFilter = new EventFilter(Filter.EventIdIs(15));
            providerDisableFilter.OnEvent += (record) =>
            {
                var provider = new Guid(record.GetBinary("ProviderName"));
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtTraceControl(DISABLE_PROVIDER, {provider})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            etwProvider.AddFilter(providerDisableFilter);

            // EnableInfo
            var enableInfoFilter = new EventFilter(Filter.EventIdIs(26));
            enableInfoFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("ProcessId", 0);
                var provider = new Guid(record.GetBinary("GUID"));
                var any = record.GetUInt64("MatchAnyKeyword");
                var all = record.GetUInt64("MatchAllKeyword");
                var level = record.GetUInt8("Level");
                var property = record.GetUInt32("EnableProperty");
                // TODO(jdu) expand enable flags
                // https://docs.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-enable_trace_parameters

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtTraceControl(CAPTURE_STATE, {provider}, {level}, 0x{any:x}, 0x{all:x}, 0x{property:x})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            etwProvider.AddFilter(enableInfoFilter);

            // Provider
            var providerFilter = new EventFilter(Filter.EventIdIs(27));
            providerFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("ProcessId", 0);
                var provider = new Guid(record.GetBinary("ProviderGUID"));
                var group = new Guid(record.GetBinary("GroupGUID"));
                var flags = record.GetUInt16("Flags");
                var mask = record.GetUInt8("EnableMask");
                var groupMask = record.GetUInt8("GroupEnableMask");
                // TODO(jdu) expand flags
                // https://docs.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties
                // https://github.com/microsoft/krabsetw/blob/master/krabs/krabs/perfinfo_groupmask.hpp

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtTraceControl(CAPTURE_STATE_KERNEL, {provider}, {group}, 0x{flags:x}, 0x{mask:x}, 0x{groupMask:x})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            etwProvider.AddFilter(providerFilter);

            // LostEvent
            var lostEventFilter = new EventFilter(Filter.EventIdIs(19));
            lostEventFilter.OnEvent += (record) =>
            {
                var sessionName = record.GetUnicodeString("SessionName", string.Empty);
                if (!droppedEvents.ContainsKey(sessionName) && sessionName.StartsWith(typeof(Program).Namespace))
                {
                    Log.WarnWrite($"Dropping events in session {sessionName}...");
                    droppedEvents[sessionName] = true;
                }
            };
            etwProvider.AddFilter(lostEventFilter);

            this.trace.Enable(etwProvider);
        }
    }
}
```

`src/ETW/Microsoft-Windows-Kernel-File.cs`:

```cs
namespace SyscallSummariser.ETW {
    using Microsoft.O365.Security.ETW;
    using System;
    using System.IO;
    using System.Linq;

    /// <summary>
    /// profiles use of file extensions in Win32 file APIs using Microsoft-Windows-Kernel-File events
    /// </summary>
    internal class Microsoft_Windows_Kernel_File : EtwUserTraceProvider {
        public Microsoft_Windows_Kernel_File(UserTrace trace) : base(trace) { }

        internal override string ProviderName {
            get { return "Microsoft-Windows-Kernel-File"; }
        }

        internal override void Enable() {
            var fileProvider = new Provider(this.ProviderName)
            {
                TraceFlags = TraceFlags.IncludeStackTrace
            };
            fileProvider.Any = 0x10 |  // KERNEL_FILE_KEYWORD_FILENAME
                               0x20 |  // KERNEL_FILE_KEYWORD_FILEIO
                               0x400 | // KERNEL_FILE_KEYWORD_DELETE_PATH
                               0x800 | // KERNEL_FILE_KEYWORD_RENAME_SETLINK_PATH
                               0x1000; // KERNEL_FILE_KEYWORD_CREATE_NEW_FILE

            // NameCreate || CreateNewFile
            var nameCreateFilter = new EventFilter(Filter.EventIdIs(10).Or(Filter.EventIdIs(30)));
            nameCreateFilter.OnEvent += (record) => {
                CreateFileEventHandler(record, "NtCreateFile");
            };
            fileProvider.AddFilter(nameCreateFilter);

            // SetInformation
            var setInformationFileFilter = new EventFilter(Filter.EventIdIs(17));
            setInformationFileFilter.OnEvent += (record) => {
                var infoClass = record.GetUInt32("InfoClass", UInt32.MaxValue);
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtSetInformationFile({FileInformationClass(infoClass)})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(setInformationFileFilter);

            // QueryInformation
            /* This event is way too verbose to usefully log */
            //var queryInformationFileFilter = new EventFilter(Filter.EventIdIs(22));
            //queryInformationFileFilter.OnEvent += (record) =>
            //{
            //    var infoClass = record.GetUInt32("InfoClass", UInt32.MaxValue);
            //    ProcessProfile.LogFeatureIfInterestingProcess(record.ProcessId, "Syscalls", $"File-QueryInformation({FileInformationClass(infoClass)})");
            //};
            //fileProvider.AddFilter(queryInformationFileFilter);

            // Rename, Rename29
            var renameFileFilter = new EventFilter(Filter.EventIdIs(19).Or(Filter.EventIdIs(29)));
            renameFileFilter.OnEvent += (record) =>
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtSetInformationFile(Rename)", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(renameFileFilter);

            // DirNotify
            var dirNotifyFilter = new EventFilter(Filter.EventIdIs(25));
            dirNotifyFilter.OnEvent += (record) => {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtNotifyChangeDirectoryFile()", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(dirNotifyFilter);

            // FSCTL
            var fsctlFilter = new EventFilter(Filter.EventIdIs(23));
            fsctlFilter.OnEvent += (record) => {
                var infoClass = (FSCTL)record.GetUInt32("InfoClass");
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtFsControlFile({infoClass})", record.GetStackTrace());
                if (value is null || value.Contains("kernelbase!ReplaceFile"))
                    return;
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(fsctlFilter);

            // DeletePath
            var deletePathFilter = new EventFilter(Filter.EventIdIs(26));
            deletePathFilter.OnEvent += (record) => {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtSetInformationFile(DeletePath)", record.GetStackTrace());
                if (value is null || value.Contains("kernelbase!ReplaceFile"))
                    return;
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(deletePathFilter);

            // RenamePath
            var renamePathFilter = new EventFilter(Filter.EventIdIs(27));
            renamePathFilter.OnEvent += (record) => {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtSetInformationFile(RenamePath)", record.GetStackTrace());
                if (value is null || value.Contains("kernelbase!ReplaceFile"))
                    return;
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(renamePathFilter);

            // SetLinkPath
            var setLinkPathFilter = new EventFilter(Filter.EventIdIs(28));
            setLinkPathFilter.OnEvent += (record) => {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "File-SetLinkPath", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(setLinkPathFilter);

            // SetSecurity
            var setSecurityFilter = new EventFilter(Filter.EventIdIs(31));
            setSecurityFilter.OnEvent += (record) => {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtSetSecurityObject(File)", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(setSecurityFilter);

            // QuerySecurity
            var querySecurityFilter = new EventFilter(Filter.EventIdIs(32));
            querySecurityFilter.OnEvent += (record) => {
                var callStack = record.GetStackTrace();
                if (MemoryMap.IsMonitored(record.ProcessId))
                {
                    var (callingModule, calledApi, callStackSummary) = MemoryMap.FinalUserModule(record.ProcessId, callStack);
                    if (callingModule == "ntdll" && calledApi == "ntdll!LdrpInitializeProcess" && callStackSummary.Contains("kernelbase!ConsoleAllocate"))
                        return; // ignore console side-effects
                }

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtQuerySecurityObject(File)", callStack);
                if (value is null || 
                    value.Contains("->kernelbase!CreateFile") ||
                    value.Contains("->kernelbase!GetFileVersionInfo") ||
                    value.Contains("->kernelbase!CreateProcessAsUser")
                    )
                    return;
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(querySecurityFilter);

            // SetEA
            var setEAFilter = new EventFilter(Filter.EventIdIs(33));
            setEAFilter.OnEvent += (record) => {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "File-SetEA", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            fileProvider.AddFilter(setEAFilter);

            // QueryEA
            //var queryEAFilter = new EventFilter(Filter.EventIdIs(34));
            //queryEAFilter.OnEvent += (record) => {
            //    var value = TraitsProfiler.EnrichFeature(record.ProcessId, "File-QueryEA", record.GetStackTrace());
            //    TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            //};
            //fileProvider.AddFilter(queryEAFilter);

            this.trace.Enable(fileProvider);
        }


        internal static readonly string[] interestingFileExtensions = { "sys", "dll", "exe" };
        // Monitor more types?
        // "com", "bat", "scr", "cpl", "xll", "msi", "msp", "vb", "vbs", "vbe", "js", "jse", "ws", "wsf", "ps1", "inf", "jar", "hta"

        private static void CreateFileEventHandler(IEventRecord record, string method) {
            var type = "File";
            var path = new WindowsPath(record.GetUnicodeString("FileName", string.Empty));
            
            if (!interestingFileExtensions.Contains(path.FileExtension))
                return;

            if (string.IsNullOrEmpty(path.NormalisedRoot))
                Log.WarnWrite($"NormalisedRoot={path.NormalisedRoot} Raw={path.Raw}");

            string attributes = string.Empty;
            try {
                attributes = string.Concat(File.GetAttributes(path.DrivePath).ToString().Where(c => !Char.IsWhiteSpace(c))).Replace(",", "|");

                if (attributes.Contains("Directory")) {
                    type = "Directory";
                    attributes = attributes.Replace("Directory", "").Replace("||", "|");
                    path.FileExtension = string.Empty;  // eliminate directory false positives
                }
            } catch {
                attributes = "Temp"; // file is deleted???
                return; // don't risk bad data
            }

            var target = $"{path.FileExtension}";
            if (!string.IsNullOrEmpty(path.AlternateDataStream))
                target += $", :{path.AlternateDataStream}";
            if (!string.IsNullOrEmpty(attributes))
                target += $", {attributes}";

            if (type == "File")
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"{method}({target})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            }
        }

        private static string FileInformationClass(UInt32 infoClass) {
            if (infoClass < _FileInformationClass.Length)
                return _FileInformationClass[infoClass];

            return $"{infoClass}";
        }

        // https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ne-wdm-_file_information_class
        private static readonly string[] _FileInformationClass =
        {
            "FileDirectoryInformation",
            "FileFullDirectoryInformation",
            "FileBothDirectoryInformation",
            "FileBasicInformation",
            "FileStandardInformation",
            "FileInternalInformation",
            "FileEaInformation",
            "FileAccessInformation",
            "FileNameInformation",
            "FileRenameInformation",
            "FileLinkInformation",
            "FileNamesInformation",
            "FileDispositionInformation",
            "FilePositionInformation",
            "FileFullEaInformation",
            "FileModeInformation",
            "FileAlignmentInformation",
            "FileAllInformation",
            "FileAllocationInformation",
            "FileEndOfFileInformation",
            "FileAlternateNameInformation",
            "FileStreamInformation",
            "FilePipeInformation",
            "FilePipeLocalInformation",
            "FilePipeRemoteInformation",
            "FileMailslotQueryInformation",
            "FileMailslotSetInformation",
            "FileCompressionInformation",
            "FileObjectIdInformation",
            "FileCompletionInformation",
            "FileMoveClusterInformation",
            "FileQuotaInformation",
            "FileReparsePointInformation",
            "FileNetworkOpenInformation",
            "FileAttributeTagInformation",
            "FileTrackingInformation",
            "FileIdBothDirectoryInformation",
            "FileIdFullDirectoryInformation",
            "FileValidDataLengthInformation",
            "FileShortNameInformation",
            "FileIoCompletionNotificationInformation",
            "FileIoStatusBlockRangeInformation",
            "FileIoPriorityHintInformation",
            "FileSfioReserveInformation",
            "FileSfioVolumeInformation",
            "FileHardLinkInformation",
            "FileProcessIdsUsingFileInformation",
            "FileNormalizedNameInformation",
            "FileNetworkPhysicalNameInformation",
            "FileIdGlobalTxDirectoryInformation",
            "FileIsRemoteDeviceInformation",
            "FileUnusedInformation",
            "FileNumaNodeInformation",
            "FileStandardLinkInformation",
            "FileRemoteProtocolInformation",
            "FileRenameInformationBypassAccessCheck",
            "FileLinkInformationBypassAccessCheck",
            "FileVolumeNameInformation",
            "FileIdInformation",
            "FileIdExtdDirectoryInformation",
            "FileReplaceCompletionInformation",
            "FileHardLinkFullIdInformation",
            "FileIdExtdBothDirectoryInformation",
            "FileDispositionInformationEx",
            "FileRenameInformationEx",
            "FileRenameInformationExBypassAccessCheck",
            "FileDesiredStorageClassInformation",
            "FileStatInformation",
            "FileMemoryPartitionInformation",
            "FileStatLxInformation",
            "FileCaseSensitiveInformation",
            "FileLinkInformationEx",
            "FileLinkInformationExBypassAccessCheck",
            "FileStorageReserveIdInformation",
            "FileCaseSensitiveInformationForceAccessCheck"
        };

        // https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/4dc02779-9d95-43f8-bba4-8d4ce4961458
        // TODO(jdu) plus many more in winioctl.h...
        enum FSCTL : uint
        {
            CREATE_OR_GET_OBJECT_ID = 0x900C0,
            DELETE_OBJECT_ID = 0x900A0,
            DELETE_REPARSE_POINT = 0x900AC,
            DUPLICATE_EXTENTS_TO_FILE = 0x98344,
            DUPLICATE_EXTENTS_TO_FILE_EX = 0x983E8,
            FILESYSTEM_GET_STATISTICS = 0x90060,
            FILE_LEVEL_TRIM = 0x98208,
            FIND_FILES_BY_SID = 0x9008F,
            GET_COMPRESSION = 0x9003C,
            GET_INTEGRITY_INFORMATION = 0x9027C,
            GET_NTFS_VOLUME_DATA = 0x90064,
            GET_REFS_VOLUME_DATA = 0x902D8,
            GET_OBJECT_ID = 0x9009C,
            GET_REPARSE_POINT = 0x900A8,
            GET_RETRIEVAL_POINTER_COUNT = 0x9042B,
            GET_RETRIEVAL_POINTERS = 0x90073,
            GET_RETRIEVAL_POINTERS_AND_REFCOUNT = 0x903D3,
            IS_PATHNAME_VALID = 0x9002C,
            LMR_SET_LINK_TRACKING_INFORMATION = 0x1400EC,
            MARK_HANDLE = 0x900FC,
            OFFLOAD_READ = 0x94264,
            OFFLOAD_WRITE = 0x98268,
            PIPE_PEEK = 0x11400C,
            PIPE_TRANSCEIVE = 0x11C017,
            PIPE_WAIT = 0x110018,
            QUERY_ALLOCATED_RANGES = 0x940CF,
            QUERY_FAT_BPB = 0x90058,
            QUERY_FILE_REGIONS = 0x90284,
            QUERY_ON_DISK_VOLUME_INFO = 0x9013C,
            QUERY_SPARING_INFO = 0x90138,
            READ_USN_JOURNAL = 0x900BB,
            READ_FILE_USN_DATA = 0x900EB,
            RECALL_FILE = 0x90117,
            REFS_STREAM_SNAPSHOT_MANAGEMENT = 0x90440,
            REQUEST_OPLOCK = 0x90240,
            SET_COMPRESSION = 0x9C040,
            SET_DEFECT_MANAGEMENT = 0x98134,
            SET_ENCRYPTION = 0x900D7,
            SET_INTEGRITY_INFORMATION = 0x9C280,
            SET_INTEGRITY_INFORMATION_EX = 0x90380,
            SET_OBJECT_ID = 0x90098,
            SET_OBJECT_ID_EXTENDED = 0x900BC,
            SET_REPARSE_POINT = 0x900A4,
            SET_SPARSE = 0x900C4,
            SET_ZERO_DATA = 0x980C8,
            SET_ZERO_ON_DEALLOCATION = 0x90194,
            SIS_COPYFILE = 0x90100,
            WRITE_USN_CLOSE_RECORD = 0x900EF
        }
    }
}
```

`src/ETW/Microsoft-Windows-Kernel-Network.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;
    using System;
    using System.Net;

    /// <summary>
    /// profiles Internet Protocol (TCP/IP) activity  using Microsoft-Windows-Kernel-Network events
    /// </summary>
    internal class Microsoft_Windows_Kernel_Network : EtwUserTraceProvider
    {
        public const ushort udpEphemeralPortStart = 48 * 1024;
        public const ushort tcpEphemeralPortStart = 32 * 1024;

        public Microsoft_Windows_Kernel_Network(UserTrace trace) : base(trace) { }

        internal override string ProviderName
        {
            get { return "Microsoft-Windows-Kernel-Network"; }
        }

        internal override void Enable()
        {
            var networkProvider = new Provider(this.ProviderName);

            // TODO(jdu) Log whether address is Broadcast/Multicast/LAN/Internet?

            // IPv4
            var udpSendFilter = new EventFilter(Filter.EventIdIs(42));  // KERNEL_NETWORK_TASK_UDPIPDatasentoverUDPprotocol
            udpSendFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("PID", 0);  // logging process pid != event pid for kernel providers
                var remoteIP = new IPAddress(record.GetUInt32("daddr", 0));
                var remotePortBytes = BitConverter.GetBytes(record.GetUInt16("dport", 0));
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(remotePortBytes);

                var remotePort = BitConverter.ToUInt16(remotePortBytes, 0);
                var truncatedPort = remotePort <= udpEphemeralPortStart ? $"{remotePort}" : $"{udpEphemeralPortStart}+";
                TraitsProfiler.LogFeature(pid, "Syscalls", $"send(IPv4, udp:{truncatedPort})");
            };
            networkProvider.AddFilter(udpSendFilter);

            var udpReceiveFilter = new EventFilter(Filter.EventIdIs(43));  // KERNEL_NETWORK_TASK_UDPIPDatareceivedoverUDPprotocol
            udpReceiveFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("PID", 0);  // logging process pid != event pid for kernel providers
                var localPortBytes = BitConverter.GetBytes(record.GetUInt16("dport", 0));
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(localPortBytes);

                var localPort = BitConverter.ToUInt16(localPortBytes, 0);
                var truncatedPort = localPort <= udpEphemeralPortStart ? $"{localPort}" : $"{udpEphemeralPortStart}+";
                TraitsProfiler.LogFeature(pid, "Syscalls", $"recv(IPv4, udp:{truncatedPort})");
            };
            networkProvider.AddFilter(udpReceiveFilter);

            var tcpConnectionFilter = new EventFilter(Filter.EventIdIs(12));  // KERNEL_NETWORK_TASK_TCPIPConnectionattempted
            tcpConnectionFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("PID", 0);  // logging process pid != event pid for kernel providers
                var remoteIP = new IPAddress(record.GetUInt32("daddr", 0));
                var remotePortBytes = BitConverter.GetBytes(record.GetUInt16("dport", 0));
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(remotePortBytes);

                var remotePort = BitConverter.ToUInt16(remotePortBytes, 0);
                var truncatedPort = remotePort <= tcpEphemeralPortStart ? $"{remotePort}" : $"{tcpEphemeralPortStart}+";
                TraitsProfiler.LogFeature(pid, "Syscalls", $"connect(IPv4, tcp:{truncatedPort})");
            };
            networkProvider.AddFilter(tcpConnectionFilter);

            var tcpAcceptFilter = new EventFilter(Filter.EventIdIs(15));  // KERNEL_NETWORK_TASK_TCPIPConnectionaccepted
            tcpAcceptFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("PID", 0);  // logging process pid != event pid for kernel providers
                var localPortBytes = BitConverter.GetBytes(record.GetUInt16("dport", 0));
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(localPortBytes);

                var localPort = BitConverter.ToUInt16(localPortBytes, 0);
                var truncatedPort = localPort <= tcpEphemeralPortStart ? $"{localPort}" : $"{tcpEphemeralPortStart}+";
                TraitsProfiler.LogFeature(pid, "Syscalls", $"accept(IPv4, tcp:{truncatedPort})");
            };
            networkProvider.AddFilter(tcpAcceptFilter);

            // IPv6
            var udp6SendFilter = new EventFilter(Filter.EventIdIs(58));  // KERNEL_NETWORK_TASK_UDPIPDatasentoverUDPprotocol.58
            udp6SendFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("PID", 0);  // logging process pid != event pid for kernel providers
                var remoteIP = new IPAddress(record.GetBinary("daddr"));
                var remotePortBytes = BitConverter.GetBytes(record.GetUInt16("dport", 0));
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(remotePortBytes);

                var remotePort = BitConverter.ToUInt16(remotePortBytes, 0);
                var truncatedPort = remotePort <= udpEphemeralPortStart ? $"{remotePort}" : $"{udpEphemeralPortStart}+";
                TraitsProfiler.LogFeature(pid, "Syscalls", $"send(IPv6, udp:{truncatedPort})");
            };
            networkProvider.AddFilter(udp6SendFilter);

            var udp6ReceiveFilter = new EventFilter(Filter.EventIdIs(59));  // KERNEL_NETWORK_TASK_UDPIPDatareceivedoverUDPprotocol.59
            udp6ReceiveFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("PID", 0);  // logging process pid != event pid for kernel providers
                var localPortBytes = BitConverter.GetBytes(record.GetUInt16("dport", 0));
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(localPortBytes);

                var localPort = BitConverter.ToUInt16(localPortBytes, 0);
                var truncatedPort = localPort <= udpEphemeralPortStart ? $"{localPort}" : $"{udpEphemeralPortStart}+";
                TraitsProfiler.LogFeature(pid, "Syscalls", $"recv(IPv6, udp:{truncatedPort})");
            };
            networkProvider.AddFilter(udp6ReceiveFilter);

            var tcp6ConnectionFilter = new EventFilter(Filter.EventIdIs(28));  // KERNEL_NETWORK_TASK_TCPIPConnectionattempted.28
            tcp6ConnectionFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("PID", 0);  // logging process pid != event pid for kernel providers
                var remoteIP = new IPAddress(record.GetUInt32("daddr", 0));
                var remotePortBytes = BitConverter.GetBytes(record.GetUInt16("dport", 0));
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(remotePortBytes);

                var remotePort = BitConverter.ToUInt16(remotePortBytes, 0);
                var truncatedPort = remotePort <= tcpEphemeralPortStart ? $"{remotePort}" : $"{tcpEphemeralPortStart}+";
                TraitsProfiler.LogFeature(pid, "Syscalls", $"connect(IPv6, tcp:{truncatedPort})");
            };
            networkProvider.AddFilter(tcp6ConnectionFilter);

            var tcp6AcceptFilter = new EventFilter(Filter.EventIdIs(31));  // KERNEL_NETWORK_TASK_TCPIPConnectionaccepted.31
            tcp6AcceptFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("PID", 0);  // logging process pid != event pid for kernel providers
                var localPortBytes = BitConverter.GetBytes(record.GetUInt16("dport", 0));
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(localPortBytes);

                var localPort = BitConverter.ToUInt16(localPortBytes, 0);
                var truncatedPort = localPort <= tcpEphemeralPortStart ? $"{localPort}" : $"{tcpEphemeralPortStart}+";
                TraitsProfiler.LogFeature(pid, "Syscalls", $"accept(IPv6, tcp:{truncatedPort})");
            };
            networkProvider.AddFilter(tcp6AcceptFilter);

            this.trace.Enable(networkProvider);
        }
    }
}
```

`src/ETW/Microsoft-Windows-Kernel-Process.cs`:

```cs
namespace SyscallSummariser.ETW {
    using Microsoft.O365.Security.ETW;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Security.Principal;

    using static Win32.Kernel32;
    using static Win32.Ntdll;
    using static Win32.Advapi;
    using static Win32.Psapi;
    using System;
    using System.Text;
    using SyscallSummariser.Utilities;
    using System.IO;

    /// <summary>
    /// records the latest ImageName for each ephemeral process id in the <c>ProcessPidMap</c>
    /// using Microsoft-Windows-Kernel-Process events
    /// </summary>
    internal class Microsoft_Windows_Kernel_Process : EtwUserTraceProvider {
        public Microsoft_Windows_Kernel_Process(UserTrace trace) : base(trace) { }

        internal override string ProviderName {
            get { return "Microsoft-Windows-Kernel-Process"; }
        }

        // https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/81d92bba-d22b-4a8c-908a-554ab29148ab
        internal static Dictionary<string, string> integrityLevelMap = new Dictionary<string, string>()
        {
            ["S-1-16-0"]      = "Untrusted",  // ML_UNSTRUSTED
            ["S-1-16-4096"]   = "Low",        // ML_LOW
            ["S-1-16-8192"]   = "Medium",     // ML_MEDIUM
            ["S-1-16-8448"]   = "Medium+",    // ML_MEDIUM_PLUS
            ["S-1-16-12288"]  = "High",       // ML_HIGH
            ["S-1-16-16384"]  = "System",     // ML_SYSTEM
            ["S-1-16-20480"]  = "Protected",  // ML_PROTECTED_PROCESS
            ["S-1-16-28672"]  = "Secure"      // ML_SECURE_PROCESS
        };

        /// <summary>
        /// return the friendly name of the integrity level
        /// </summary>
        /// <param name="sid">Mandatory Label (SID)</param>
        /// <returns>the friendly name (if any)</returns>
        internal static string IntegrityLevelFriendlyName(SecurityIdentifier sid) {
            string friendlyName = sid.ToString();
            if (integrityLevelMap.TryGetValue(friendlyName, out string lookup))
                friendlyName = lookup;

            return friendlyName;
        }

        internal override void Enable() {
            
            var processProvider = new Provider(this.ProviderName)
            {
                Any = 0x10 |  // WINEVENT_KEYWORD_PROCESS
                      0x20 |  // WINEVENT_KEYWORD_THREAD
                      0x40 |  // WINEVENT_KEYWORD_IMAGE
                      0x200,  // WINEVENT_KEYWORD_PROCESS_FREEZE
                TraceFlags = TraceFlags.IncludeStackTrace
            };

            var processFilter = new EventFilter(Filter.EventIdIs(1));  // ProcessStart
            processFilter.OnEvent += (record) => {
                ProcessCreationTraitsMap.AddProcess(record);

                var pid = record.GetUInt32("ProcessID");
                var name = Path.GetFileName(record.GetUnicodeString("ImageName"));
                Microsoft_Windows_Threat_Intellgience.EnableReadWriteMemoryLogging((int)pid, name);
                MemoryMap.Add(pid, name);

                var callStack = record.GetStackTrace();
                if (MemoryMap.IsMonitored(pid))
                {
                    var (callingModule, calledApi, callStackSummary) = MemoryMap.FinalUserModule(pid, callStack);
                    if (callingModule == "ntdll" && calledApi == "ntdll!LdrpInitializeProcess" && callStackSummary.Contains("kernelbase!ConsoleAllocate"))
                        return; // ignore conhost
                }

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtCreateUserProcess()", callStack);
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            processProvider.AddFilter(processFilter);

            var processStopFilter = new EventFilter(Filter.EventIdIs(2));  // ProcessStop
            processStopFilter.OnEvent += (record) =>
            {
                // TODO(jdu) handle any deferred events?
                ProcessCreationTraitsMap.RemoveProcess(record);

                // ensure that the output files are updated shortly after process exit
                TraitsProfiler.OutputJsonFiles();
            };
            processProvider.AddFilter(processStopFilter);

            var threadStartFilter = new EventFilter(Filter.EventIdIs(3));  // ThreadStart
            threadStartFilter.OnEvent += (record) => {
                var pid = record.GetUInt32("ProcessID");
                if (pid == 4)
                    return;

                if (pid == record.Id)
                {
                    // CreateThread()
                    var tid = record.GetUInt32("ThreadID");
                    var creatorProcess = pid == record.ProcessId ? null : ProcessCreationTraitsMap.GetProcessTree(record.ProcessId);
                    var win32StartAddress = record.GetUInt64("Win32StartAddr");
                    
                    var regionInfo = new MEMORY_BASIC_INFORMATION();
                    var hProcess = OpenProcess(ProcessDesiredAccess.QueryInformation, false, (int)pid);
                    WindowsPath fullModuleName = null;
                    string type = null;
                    string state = null;
                    string protect = null;
                    string allocationProtect = null;
                    if (!hProcess.IsInvalid)
                    {
                        if (0 != VirtualQueryEx(hProcess, new UIntPtr(win32StartAddress), ref regionInfo, (uint)Marshal.SizeOf(regionInfo)))
                        {
                            type = $"{regionInfo.Type}";
                            state = $"{regionInfo.State}";
                            protect = $"{regionInfo.Protect}";
                            allocationProtect = $"{regionInfo.AllocationProtect}";
                        }

                        var filename = new StringBuilder(WindowsPath.MAX_PATH);
                        if (0 != GetMappedFileName(hProcess, regionInfo.BaseAddress, filename, (uint)filename.Capacity))
                        {
                            fullModuleName = new WindowsPath(filename.ToString());
                        }
                    }

                    string win32StartAddr_Symbol = null;
                    if (TraitsProfiler.useCommonSymbols)
                    {
                        win32StartAddr_Symbol = SymbolUtils.GetCommonSymbol(fullModuleName, win32StartAddress - regionInfo.AllocationBase.ToUInt64());
                    }

                    var serviceTag = record.GetUInt32("SubProcessTag");
                    string serviceName = null;
                    if (serviceTag != 0)
                    {
                        var tagQuery = new SC_SERVICE_TAG_QUERY
                        {
                            ProcessId = pid,
                            ServiceTag = serviceTag,
                            Unknown = 0,
                            Buffer = IntPtr.Zero
                        };

                        if (I_QueryTagInformation(IntPtr.Zero, SC_SERVICE_TAG_QUERY_TYPE.ServiceNameFromTagInformation, ref tagQuery) == 0)
                        {
                            serviceName = Marshal.PtrToStringUni(tagQuery.Buffer);
                            LocalFree(tagQuery.Buffer);
                        }
                    }

                    var thread = (type == "MEM_IMAGE") ? fullModuleName.FileName() : $"{type} [{protect}, {allocationProtect}]";
                    if (creatorProcess != null)
                        thread += $", Creator={creatorProcess}";

                    if (!string.IsNullOrEmpty(serviceName))
                        thread += $", Service={serviceName}";

                    if (!string.IsNullOrEmpty(win32StartAddr_Symbol))
                        thread += $", Symbol={win32StartAddr_Symbol}";

                    var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"CreateThread({thread})", record.GetStackTrace());
                    TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
                }
                else
                {
                    // CreateRemoteThread
                    var hProcess = OpenProcess(ProcessDesiredAccess.QueryLimitedInformation, false, (int)pid);
                    var processInformation = new PROCESS_BASIC_INFORMATION();
                    // ignore thread starts in child processes
                    // TODO(jdu) - ignore initial thread start only?
                    if (!hProcess.IsInvalid &&
                        NtQueryInformationProcess(hProcess, PROCESSINFOCLASS.ProcessBasicInformation, ref processInformation, Marshal.SizeOf(processInformation), out _) != 0 &&
                        pid != processInformation.InheritedFromUniqueProcessId.ToUInt32())
                    {
                        var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"CreateRemoteThread({ProcessCreationTraitsMap.GetProcessName(pid)})", record.GetStackTrace());
                        TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
                    }
                }
            };
            processProvider.AddFilter(threadStartFilter);

            var moduleLoadFilter = new EventFilter(Filter.EventIdIs(5));  // ImageLoad
            moduleLoadFilter.OnEvent += (record) => {

                var image = new WindowsPath(record.GetUnicodeString("ImageName"));
                TraitsProfiler.LogModule(record.ProcessId, image, record);

                var pid = record.GetUInt32("ProcessID");
                var imageBase = record.GetUInt64("ImageBase");
                MemoryMap.Add(pid, new LoadedImage(record));
            };
            processProvider.AddFilter(moduleLoadFilter);

            var imageUnloadFilter = new EventFilter(Filter.EventIdIs(6));
            imageUnloadFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("ProcessID");
                UInt64 imageBase = record.GetUInt64("ImageBase");
                MemoryMap.Remove(pid, imageBase);
            };
            processProvider.AddFilter(imageUnloadFilter);

            // NtProcessSuspend - but not CREATE_SUSPENDED?
            var processFreezeFilter = new EventFilter(Filter.EventIdIs(11));  // ProcessFreeze
            processFreezeFilter.OnEvent += (record) => {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtProcessSuspend", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            processProvider.AddFilter(processFreezeFilter);

            this.trace.Enable(processProvider);
        }
    }
}
```

`src/ETW/Microsoft-Windows-Kernel-Registry.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;
    using System;
    using System.Text.RegularExpressions;

    /// <summary>
    /// profiles use of a registry APIs using Microsoft-Windows-Kernel-Registry events
    /// </summary>
    internal class Microsoft_Windows_Kernel_Registry : EtwUserTraceProvider
    {
        public Microsoft_Windows_Kernel_Registry(UserTrace trace) : base(trace) { }

        internal override string ProviderName
        {
            get { return "Microsoft-Windows-Kernel-Registry"; }
        }

        internal Regex hiveRegex = new Regex(@"^\\REGISTRY\\(?<hive>[^\\]+)\\");

        internal override void Enable()
        {
            var registryProvider = new Provider(this.ProviderName)
            {
                TraceFlags = TraceFlags.IncludeStackTrace
            };

            var createKeyFilter = new EventFilter(Filter.EventIdIs(1));
            createKeyFilter.OnEvent += (record) =>
            {
                // *** use registry kernel callbacks (or sysmon events) instead ***
                // only having access to relative paths makes this event impractical to profile accurately

                var relativeName = record.GetUnicodeString("RelativeName", string.Empty);
                var hiveMatch = hiveRegex.Match(relativeName);
                var hiveName = hiveMatch.Success ? hiveMatch.Groups["hive"].Value : "";

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtCreateKey({hiveName})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            registryProvider.AddFilter(createKeyFilter);

            var setValueKeyFilter = new EventFilter(Filter.EventIdIs(5));
            setValueKeyFilter.OnEvent += (record) =>
            {
                var callStack = record.GetStackTrace();
                if (MemoryMap.IsMonitored(record.ProcessId))
                {
                    var (callingModule, calledApi, _) = MemoryMap.FinalUserModule(record.ProcessId, callStack);
                    if (callingModule == "ntdll" && calledApi == "ntdll!LdrpInitializeProcess")
                        return; // ignore process initialisation
                }

                // log the data size (to the closest power of eight) for further profiling
                var dataSize = record.GetUInt32("DataSize", 0);
                int i = 0;
                for (i = 8; dataSize > (1 << i); i+=8)
                    ;
                var strDataSize = "size <= " + (8 << i);
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtSetValueKey({strDataSize})", callStack);
                if (value is null ||
                    value.Contains("->kernel32!CreateProcess") ||
                    value.Contains("->kernelbase!CreateProcessAsUser")
                    )
                    return;
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            registryProvider.AddFilter(setValueKeyFilter);

            var setInformationKeyFilter = new EventFilter(Filter.EventIdIs(11));
            setInformationKeyFilter.OnEvent += (record) =>
            {
                var infoClass = KeyInformationClass(record.GetUInt32("InfoClass", UInt32.MaxValue));
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtSetInformationKey({infoClass})", record.GetStackTrace());
                if (infoClass == "KeyFlagsInformation")
                    return;  // too common
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);

            };
            registryProvider.AddFilter(setInformationKeyFilter);


            var setSecurityKeyFilter = new EventFilter(Filter.EventIdIs(15));
            setSecurityKeyFilter.OnEvent += (record) =>
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtSetSecurityObject(RegistryKey)", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            registryProvider.AddFilter(setSecurityKeyFilter);

            this.trace.Enable(registryProvider);
        }

        private static string KeyInformationClass(UInt32 infoClass)
        {
            if (infoClass < _KeyInformationClass.Length)
                return _KeyInformationClass[infoClass];

            return $"{infoClass}";
        }

        // https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ne-wdm-_key_information_class
        private static readonly string[] _KeyInformationClass =
        {
            "KeyBasicInformation",
            "KeyNodeInformation",
            "KeyFullInformation",
            "KeyNameInformation",
            "KeyCachedInformation",
            "KeyFlagsInformation",
            "KeyVirtualizationInformation",
            "KeyHandleTagsInformation",
            "KeyTrustInformation",
            "KeyLayerInformation"
        };
    }
}
```

`src/ETW/Microsoft-Windows-Security-Auditing.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;
    using System;
    using System.Security.Principal;

    // Reference: https://medium.com/palantir/windows-privilege-abuse-auditing-detection-and-defense-3078a403d74e
    //
    // Note - we enable these events using auditpol.exe, not provider flags.

    internal class Microsoft_Windows_Security_Auditing : EtwUserTraceProvider
    {
        public Microsoft_Windows_Security_Auditing(UserTrace trace) : base(trace) { }

        internal override string ProviderName
        {
            get { return "Microsoft-Windows-Security-Auditing"; }
        }

        internal override void Enable() {
            if (!WindowsIdentity.GetCurrent().IsSystem)
            {
                Log.VerboseWrite("skipping Microsoft-Windows-Security-Auditing - insufficient privilege");
                return;
            }

            // We can only consume from the existing "EventLog-Security" session.
            // We cannot enable this provider on our own session - even as PPL.
            this.trace = new UserTrace("EventLog-Security");
            var securityAuditProvider = new Provider(this.ProviderName);

            var privilegeAdjustFilter = new EventFilter(Filter.EventIdIs(4703));
            privilegeAdjustFilter.OnEvent += (record) => {
                var pid = (UInt32)record.GetUInt64("ProcessId", 0);
                var privilegeList = record.GetUnicodeString("EnabledPrivilegeList", "");
                foreach (var privilege in privilegeList.Split(new char[] { '\r', '\n', '\t' }, StringSplitOptions.RemoveEmptyEntries))
                    TraitsProfiler.LogFeature(pid, "Syscalls", $"RtlAdjustPrivilege({privilege})");
            };
            securityAuditProvider.AddFilter(privilegeAdjustFilter);

            this.trace.Enable(securityAuditProvider);
        }
    }
}
```

`src/ETW/Microsoft-Windows-WFP.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;

    /// <summary>
    /// profiles network activity blocked by the Windows Filtering Platform (WFP) via Microsoft-Windows-WFP events
    /// </summary>
    /// Provider suggested by @pathtofile
    internal class Microsoft_Windows_WFP : EtwUserTraceProvider
    {
        public Microsoft_Windows_WFP(UserTrace trace) : base(trace) { }

        internal override string ProviderName
        {
            get { return "Microsoft-Windows-WFP"; }
        }

        internal ushort ephemeralPortStart = Microsoft_Windows_Kernel_Network.tcpEphemeralPortStart < Microsoft_Windows_Kernel_Network.udpEphemeralPortStart ? 
                                                Microsoft_Windows_Kernel_Network.tcpEphemeralPortStart : 
                                                Microsoft_Windows_Kernel_Network.udpEphemeralPortStart;

        internal override void Enable()
        {
            var wfpProvider = new Provider(this.ProviderName);
            wfpProvider.Any = 0x10;  // AOAC (alternatively 0x10000000000)
            var blockedPacketFilter = new EventFilter(Filter.EventIdIs(1001));  // task_0
            blockedPacketFilter.OnEvent += (record) =>
            {
                var app = record.GetUnicodeString("AppId", string.Empty);
                if (!app.Equals("NULL"))
                {
                    var sockaddr = record.GetBinary("RemoteAddress");
                    var version = sockaddr.Length < 16 ? "IPv4" : "IPv6";
                    var port = (ushort)(sockaddr[3] + 256 * sockaddr[2]);
                    // TODO(jdu) there doesn't appear to be a way to determine if it was a TCP or UDP packet???
                    var truncatedPort = port <= ephemeralPortStart ? $"{port}" : $"{ephemeralPortStart}+";
                    TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", $"connect({version}, ???:{truncatedPort})");
                }
            };
            wfpProvider.AddFilter(blockedPacketFilter);

            this.trace.Enable(wfpProvider);
        }
    }
}
```

`src/ETW/Microsoft-Windows-Win32k.cs`:

```cs
namespace SyscallSummariser.ETW
{
    using Microsoft.O365.Security.ETW;

    /// <summary>
    /// profiles use of kernel Graphics Device Interface (GDI) - aka Win32k[.sys]
    /// via Microsoft-Windows-Win32k events
    /// </summary>
    internal class Microsoft_Windows_Win32k : EtwUserTraceProvider
    {
        public Microsoft_Windows_Win32k(UserTrace trace) : base(trace) { }

        internal override string ProviderName
        {
            get { return "Microsoft-Windows-Win32k"; }
        }

        internal override void Enable()
        {
            var win32kProvider = new Provider(this.ProviderName)
            {
                Any = 0x00000000400 |  // AuditApiCalls
                      0x80000000000,   // ReadClipboard
                TraceFlags = TraceFlags.IncludeStackTrace
            };

            var clipboardEventFilter = new EventFilter(Filter.EventIdIs(463));  // ReadClipboard
            clipboardEventFilter.OnEvent += (record) =>
            {
                var pid = record.GetUInt32("CallerPid");  // logging process pid != event pid for kernel providers
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "Win32k-ReadClipboard", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            win32kProvider.AddFilter(clipboardEventFilter);

            var setWinEventHookFilter = new EventFilter(Filter.EventIdIs(1000));  // SetWinEventHook
            setWinEventHookFilter.OnEvent += (record) =>
            {
                var eventMin = record.GetUInt32("eventMin");
                var eventMax = record.GetUInt32("eventMax");

                var targetPid = record.GetUInt32("idEventProcess");
                var target = ProcessCreationTraitsMap.GetTarget(record.ProcessId, targetPid);

                var thread = record.GetUInt32("idEventThread") == 0 ? "all" : "single";
                var flags = record.GetUInt32("Flags");

                var value = TraitsProfiler.EnrichFeature(record.ProcessId, $"NtUserSetWinEventHook(0x{eventMin:x}..0x{eventMax:x}, {target}, {thread}, 0x{flags:x})", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);

            };
            win32kProvider.AddFilter(setWinEventHookFilter);

            var task1001Filter = new EventFilter(Filter.EventIdIs(1001));  // RegisterRawInputDevices
            task1001Filter.OnEvent += (record) =>
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "Win32k-RegisterRawInputDevices", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);

            };
            win32kProvider.AddFilter(task1001Filter);

            var setWindowsHookFilter = new EventFilter(Filter.EventIdIs(1002));  // SetWindowsHook
            setWindowsHookFilter.OnEvent += (record) =>
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "NtNtUserSetWindowsHookEx", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            win32kProvider.AddFilter(setWindowsHookFilter);

            var getAsyncKeyStateFilter = new EventFilter(Filter.EventIdIs(1003));  // GetAsyncKeyState
            getAsyncKeyStateFilter.OnEvent += (record) =>
            {
                var value = TraitsProfiler.EnrichFeature(record.ProcessId, "Win32k-GetAsyncKeyState", record.GetStackTrace());
                TraitsProfiler.LogFeature(record.ProcessId, "Syscalls", value);
            };
            win32kProvider.AddFilter(getAsyncKeyStateFilter);

            this.trace.Enable(win32kProvider);
        }
    }
}
```

`src/MainWindow.xaml`:

```xaml
<Window x:Class="SyscallSummariser.MainWindow"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             Title="ETW Syscall Monitor"
             Height="1200"
             Width="1000">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="24"/>
            <RowDefinition Height="1000*"/>
            <RowDefinition Height="200"/>
        </Grid.RowDefinitions>
        <TextBox Name="filterBox" Grid.Row="0" TextChanged="FilterText"/>
        <TreeView
            x:Name="treeView"
            Grid.Row="1"/>
        <RichTextBox
            x:Name="logWindow"
            Grid.Row="2"
            Background="Black"
            FontFamily="Lucida Console">
            <FlowDocument/>
        </RichTextBox>
    </Grid>
</Window>

```

`src/MainWindow.xaml.cs`:

```cs
namespace SyscallSummariser
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Threading;
    using System.Timers;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Documents;
    using System.Windows.Media;

    static class KeyValuePairExtensions
    {
        public static void Deconstruct<K, V>(this KeyValuePair<K, V> kvp, out K key, out V value)
        {
            key = kvp.Key;
            value = kvp.Value;
        }
    }

    /// <summary>
    /// Interaction logic for DebugWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private readonly Paragraph paragraph = new Paragraph();

        public MainWindow()
        {
            InitializeComponent();
            logWindow.Document.Blocks.Add(paragraph);
            Closing += OnWindowClosing;
            throttleTimer = new System.Timers.Timer(600);
            throttleTimer.AutoReset = false;
            throttleTimer.Elapsed += (s, e) => {
                this.Dispatcher.BeginInvoke(new Action(() =>
                {
                    foreach (TreeViewItem item in treeView.Items)
                    {
                        FilterItem(item, filterBox.Text);
                    }
                }));
            };
        }

        public void AddTreeView(Dictionary<string, Dictionary<string, SortedSet<string>>> summaries)
        {
            this.Dispatcher.BeginInvoke(new Action(() =>
            {
                // traitshash: { feature: set(observed values) }
                lock (summaries)
                {
                    treeView.Items.Clear();
                    foreach (var (traitshash, features) in summaries)
                    {
                        if (!features.ContainsKey("Syscalls"))
                            continue;
                        
                        var tvi = new TreeViewItem()
                        {
                            Header = traitshash,
                            IsTextSearchEnabled = true,
                            IsTextSearchCaseSensitive = false
                        };
                        foreach (var (feature, list) in features)
                        {
                            if (feature == "ProcessCreationTraitsHash")
                                continue;
                            var tvi2 = new TreeViewItem()
                            {
                                Header = feature,
                                IsTextSearchEnabled = true,
                                IsTextSearchCaseSensitive = false
                            };
                            foreach (var item in list)
                            {
                                var tvi3 = new TreeViewItem()
                                {
                                    Header = item,
                                    IsTextSearchEnabled = true,
                                    IsTextSearchCaseSensitive = false
                                };
                                tvi2.Items.Add(tvi3);

                            }
                            tvi.Items.Add(tvi2);
                        }
                        treeView.Items.Add(tvi);
                    }
                }

                foreach (TreeViewItem item in treeView.Items)
                {
                    FilterItem(item, filterBox.Text);
                }
            }));
        }

        private System.Timers.Timer throttleTimer;
        public void FilterText(object sender, TextChangedEventArgs e)
        {

            if(!throttleTimer.Enabled)
            {
                throttleTimer.Start();
            }
            else
            {
                throttleTimer.Stop();
                throttleTimer.Start();
            }
        }

        private Visibility FilterItem(TreeViewItem item, string keyword)
        {
            if (keyword.Length == 0)
            {
                item.Background = Brushes.White;
                item.Visibility = Visibility.Visible;
                foreach (TreeViewItem child in item.Items)
                {
                    var _ = FilterItem(child, keyword);
                }
            }

            else if (item.Header.ToString().IndexOf(keyword, 0, StringComparison.OrdinalIgnoreCase) != -1)
            {
                item.Background = Brushes.Yellow;
                item.Visibility = Visibility.Visible;
                item.IsExpanded = false;
            }
            else
            {
                item.Background = Brushes.White;
                item.IsExpanded = false;
                item.Visibility = Visibility.Collapsed;

                if (item.Items.IsEmpty)
                {
                    item.Visibility = Visibility.Collapsed;
                }
                else
                {
                    item.Visibility = Visibility.Collapsed;
                    foreach (TreeViewItem child in item.Items)
                    {
                        if (Visibility.Visible == FilterItem(child, keyword))
                        {
                            item.Visibility = Visibility.Visible;
                            item.IsExpanded = true;
                        }
                    }

                    PropagateVisible(item);
                }
            }

            return item.Visibility;
        }

        private void PropagateVisible(TreeViewItem item)
        {
            if (item.Visibility != Visibility.Visible)
                return;
            
            foreach (TreeViewItem child in item.Items)
            {
                child.Visibility = Visibility.Visible;
                PropagateVisible(child);
            }
        }

        public void AddLine(string message, Brush colour)
        {
            paragraph.Inlines.Add(new Span(new Run(message)) { Foreground = colour });
            paragraph.Inlines.Add(new LineBreak());
            logWindow.ScrollToEnd();
        }
        public void OnWindowClosing(object sender, CancelEventArgs e)
        {
            Log.Write("Window closed - stopping");
            Program.Stop();
        }
    }
}

```

`src/MemoryMap.cs`:

```cs
using Microsoft.O365.Security.ETW;
using SyscallSummariser.Utilities;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using static Win32.Kernel32;
using static Win32.Psapi;

namespace SyscallSummariser
{
    public class MemoryMap
    {
        // :TODO: - add a kernel module memory map...

        private static readonly Dictionary<uint, string> _MonitoredProcesses = new Dictionary<uint, string>();
        private static readonly Dictionary<UInt64, LoadedImage> _GlobalModuleMap = new Dictionary<UInt64, LoadedImage>();
        private static readonly Dictionary<uint, Dictionary<UInt64, LoadedImage>> _LocalModuleMap = new Dictionary<uint, Dictionary<UInt64, LoadedImage>>();
        private static readonly Dictionary<uint, Dictionary<UInt64, MemoryRegion>> _MemoryRegionCache = new Dictionary<uint, Dictionary<UInt64, MemoryRegion>>();

        public const string Unbacked = "Unbacked";
        public const string Unknown = "Unknown";
        public const string Shellcode = "Shellcode";
        public const string JIT = "JIT";
        public const string NULL = "NULL";
        public static List<string> apiModules = new List<string> { "ntdll", "kernelbase", "kernel32", "win32u", "user32", "wow64", "wow64cpu" };

        internal static bool IsInSystemImageRange(UInt64 address)
        {
            return ((address >= 0x7FF800000000) && (address < 0x7FFFFFFF0000)) || ((address >= 0x50000000) && (address < 0x78000000));
        }

        public static bool IsMonitored(uint pid)
        {
            return _MonitoredProcesses.ContainsKey(pid);
        }

        public static string GetProcessName(uint pid)
        {
            if (!_MonitoredProcesses.TryGetValue(pid, out var process))
            {
                return $"pid:{pid}";
            }

            return process;
        }

        private static string Normalise(string imageName)
        {
            imageName = imageName.ToLower().Replace(".dll", "");
            if (imageName.EndsWith(".exe"))
                imageName = "exe";

            return imageName;
        }

        public static (string, string, string) FinalUserModule(uint pid, List<UIntPtr> callStack)
        {

            var wow64 = false;
            var callingModule = "";
            var calledApi = "";
            var callStackSummary = "";
            var lastSymbol = "";
            var enrichedStack = new List<string>();
            foreach (var returnAddress in callStack.Select(x => x.ToUInt64()))
            {
                if (returnAddress >= 0x800000000000)
                {
                    continue; // ignore kernel addresses (for now)
                }

                var moduleName = GetOwner(pid, returnAddress);
                var apiModule = apiModules.Contains(moduleName.Split('|')[0]);
                wow64 = wow64 || (moduleName == "wow64") || (apiModule && returnAddress < 0x78000000);
                if (apiModule && returnAddress > 0x78000000)
                {
                    // enrich well-known modules with symbol information
                    moduleName = $"{moduleName}!{SymbolUtils.GetClosestCommonSymbol(returnAddress)}";
                }

                if (string.IsNullOrEmpty(callingModule) &&
                        (!apiModule || moduleName.EndsWith("Callback")))
                {
                    // final user module in the call stack found
                    callingModule = moduleName;
                    calledApi = lastSymbol;
                }

                if (!callStackSummary.EndsWith($"{moduleName};"))
                    callStackSummary += $"{moduleName};";

                lastSymbol = moduleName;
                enrichedStack.Add($"{returnAddress} {moduleName}");
            }

            if (string.IsNullOrEmpty(callingModule))
            {
                // ntdll!LdrpInitializeNode;ntdll!LdrpInitializeGraphRecurse;ntdll!LdrpPrepareModuleForExecution;ntdll!LdrpLoadDllInternal;ntdll!LdrpLoadDll;ntdll!LdrLoadDll;ntdll!LdrpInitializeProcess;ntdll!LdrpInitialize;ntdll!LdrInitializeThunk;
                // ntdll!NtMapViewOfSection;ntdll!LdrpMinimalMapModule;ntdll!LdrpMapDllWithSectionHandle;ntdll!LdrpMapDllNtFileName;ntdll!LdrpMapDllSearchPath;ntdll!LdrpProcessWork;ntdll!LdrpWorkCallback;ntdll!TppWorkpExecuteCallback;ntdll!TppWorkerThread;kernel32!BaseThreadInitThunk;ntdll!RtlUserThreadStart;
                // ntdll!NtMapViewOfSection;wow64!;wow64cpu!;wow64!;ntdll!LdrpInitializeProcess;ntdll!LdrpInitialize;ntdll!LdrInitializeThunk;ntdll!;
                if (callStackSummary.EndsWith("LdrpInitializeProcess;ntdll!LdrpInitialize;ntdll!LdrInitializeThunk;") ||
                    callStackSummary.EndsWith("ntdll!LdrpProcessWork;ntdll!LdrpWorkCallback;ntdll!TppWorkpExecuteCallback;ntdll!TppWorkerThread;kernel32!BaseThreadInitThunk;ntdll!RtlUserThreadStart;") ||
                    (wow64 && callStackSummary.Contains("ntdll!LdrpInitializeProcess;ntdll!LdrpInitialize;ntdll!LdrInitializeThunk;")))
                {
                    callingModule = "ntdll";
                    calledApi = "ntdll!LdrpInitializeProcess";
                }
                else if (callStackSummary.Contains("ntdll!LdrpInitialize;ntdll!LdrInitializeThunk;"))
                {
                    callingModule = "ntdll";
                    calledApi = "ntdll!LdrpInitialize"; // TODO is this a special case to handle or not?
                }
            }
            else if (calledApi == "ntdll!LdrpProcessWork")
            {
                callingModule = "ntdll";
                calledApi = "ntdll!LdrpInitializeProcess";
            }
            // ntdll!NtMapViewOfSection;ntdll!LdrpMinimalMapModule;ntdll!LdrpMapDllWithSectionHandle;ntdll!LdrpLoadKnownDll;ntdll!LdrpFindOrPrepareLoadingModule;ntdll!LdrpLoadDllInternal;ntdll!LdrpLoadForwardedDll;ntdll!LdrpGetDelayloadExportDll;ntdll!LdrpHandleProtectedDelayload;ntdll!LdrResolveDelayLoadedAPI;setupapi;exe;kernel32!BaseThreadInitThunk;ntdll!RtlUserThreadStart;
            else if (calledApi == "ntdll!LdrResolveDelayLoadedAPI")
            {
                callingModule = "ntdll";
            }

            return (callingModule, calledApi, callStackSummary);
        }

        internal static string GetOwner(uint pid, UInt64 address)
        {
            if (0 == address)
                return MemoryMap.NULL;

            if (!IsMonitored(pid) || !_MemoryRegionCache.TryGetValue(pid, out var regions))
                return Unknown;

            // find closest containing region
            // WARNING - logic does not account for overlapping calls
            foreach (var region in regions.Values)
            {
                if (address >= region.BaseAddress && (address < region.BaseAddress + region.RegionSize))  // is contained in region
                {
                    var actingRegion = region.ActingModule.Split('|')[0];
                    if (actingRegion == Unbacked || actingRegion == JIT)
                    {
                        if (region.Name == Unbacked || region.Name == Unknown || region.Name == JIT)
                            return Shellcode;
                        else
                            return region.Name;
                    }
                    else if (region.Name == Unbacked || region.Name == Unknown || region.Name == JIT)
                    {
                        return $"{JIT}|{actingRegion}";
                    }
                    else
                    {
                        return region.Name; 
                    }
                }
            }

            // modules loaded locally
            if (_LocalModuleMap.TryGetValue(pid, out var modules))
            {
                foreach (var module in modules.Values)
                {
                    if (address >= module.BaseAddress && address < module.BaseAddress + module.RegionSize)
                        return Normalise(module.ImageName);
                }
            }

            // modules loaded at shared system address
            foreach (var module in _GlobalModuleMap.Values)
            {
                if (address >= module.BaseAddress && address < module.BaseAddress + module.RegionSize)
                    return Normalise(module.ImageName);
            }

            // last chance
            var hProcess = OpenProcess(ProcessDesiredAccess.QueryInformation, false, (int)pid);
            if (!hProcess.IsInvalid)
            {
                var regionInfo = new MEMORY_BASIC_INFORMATION();
                var filename = new StringBuilder(WindowsPath.MAX_PATH);
                if (0 != VirtualQueryEx(hProcess, new UIntPtr(address), ref regionInfo, (uint)Marshal.SizeOf(regionInfo)))
                {
                    if (regionInfo.Type == MemoryType.MEM_IMAGE &&
                        (0 != GetMappedFileName(hProcess, regionInfo.BaseAddress, filename, (uint)filename.Capacity)))
                    {
                        return Normalise(Path.GetFileName(filename.ToString()));
                    }
                    else if (regionInfo.State == MemoryState.MEM_COMMIT)
                    {
                        return Unbacked;
                    }
                }
            }

            return Unknown;
        }

        public static string GetModulePath(uint pid, UInt64 address)
        {
            if (!_LocalModuleMap.TryGetValue(pid, out var modules))
                return Unknown;

            foreach (var module in modules.Values)
            {
                if (address >= module.BaseAddress && address < module.BaseAddress + module.RegionSize)
                    return module.RawImagePath;
            }

            foreach (var module in _GlobalModuleMap.Values)
            {
                if (address >= module.BaseAddress && address < module.BaseAddress + module.RegionSize)
                    return module.RawImagePath;
            }

            return Unbacked;
        }

        public static UInt64 GetImageBase(uint pid, UInt64 address)
        {
            if (!_LocalModuleMap.TryGetValue(pid, out var modules))
                return 0;
            foreach (var module in modules.Values)
            {
                if (address >= module.BaseAddress && address < module.BaseAddress + module.RegionSize)
                    return module.BaseAddress;
            }

            foreach (var module in _GlobalModuleMap.Values)
            {
                if (address >= module.BaseAddress && address < module.BaseAddress + module.RegionSize)
                    return module.BaseAddress;
            }

            return 0;
        }


        internal static void Remove(uint pid)
        {
            _MonitoredProcesses.Remove(pid);
            _MemoryRegionCache.Remove(pid);
            _LocalModuleMap.Remove(pid);
        }

        internal static void Add(uint pid, string path)
        {

            var name = Path.GetFileName(path);
            _MonitoredProcesses.Remove(pid);
            _MonitoredProcesses.Add(pid, name);
            _MemoryRegionCache.Remove(pid);
            _MemoryRegionCache.Add(pid, new Dictionary<ulong, MemoryRegion>());
            _LocalModuleMap.Remove(pid);
            _LocalModuleMap.Add(pid, new Dictionary<ulong, LoadedImage>());
        }

        internal static void Add(uint pid, LoadedImage image)
        {
            if (IsInSystemImageRange(image.BaseAddress))
            {
                // Ranges in the MiImageBitMap(s) can be freed and later reallocated to new dlls.
                // We need to remove any stale entries from our map.
                for (var va = image.BaseAddress; va < image.BaseAddress + image.RegionSize; va += (64 * 1024))
                {
                    _GlobalModuleMap.Remove(va);
                }
                _GlobalModuleMap.Add(image.BaseAddress, image);
            }
            else
            {
                _LocalModuleMap.TryGetValue(pid, out var modules);
                if (modules != null)
                {
                    for (var va = image.BaseAddress; va < image.BaseAddress + image.RegionSize; va += (64 * 1024))
                    {
                        modules.Remove(va);
                    }
                    modules.Add(image.BaseAddress, image);
                }
            }
        }

        internal static void Remove(uint pid, ulong imageBase)
        {
            _LocalModuleMap.TryGetValue(pid, out var modules);
            if (modules != null)
            {
                modules.Remove(imageBase);
            }
        }

        internal static void Add(uint pid, ulong imageBase, MemoryRegion region)
        {
            _MemoryRegionCache.TryGetValue(pid, out var modules);
            if (modules != null)
            {
                modules.Remove(imageBase);
                modules.Add(imageBase, region);
            }
        }
    }

    internal class MemoryRegion
    {
        public uint Pid;
        public MemoryProtection Protection;
        public UInt64 BaseAddress;
        public UInt64 RegionSize;
        public string Name;
        public string ActingModule;

        public MemoryRegion(IEventRecord record, bool newAllocation, bool remote)
        {
            var callingPid = record.GetUInt32("CallingProcessId");
            var targetPid = remote ? record.GetUInt32("TargetProcessId") : callingPid;
            if (!MemoryMap.IsMonitored(targetPid) || !MemoryMap.IsMonitored(callingPid))
                return;

            Pid = targetPid;
            Protection = (MemoryProtection)record.GetUInt32("ProtectionMask");
            BaseAddress = record.GetUInt64("BaseAddress");
            RegionSize = record.GetUInt64("RegionSize");
            (ActingModule, _, _) = MemoryMap.FinalUserModule(callingPid, record.GetStackTrace());
            Name = newAllocation ? MemoryMap.Unbacked : MemoryMap.GetOwner(targetPid, BaseAddress).Split('|')[0];

            if (Pid != callingPid)
                ActingModule += $"|{MemoryMap.GetProcessName(callingPid)}";
        }

        public MemoryRegion(IEventRecord record, bool remote)
        {
            // NtMapViewOfSection
            var callingPid = record.GetUInt32("CallingProcessId");
            var targetPid = remote ? record.GetUInt32("TargetProcessId") : callingPid;
            if (!MemoryMap.IsMonitored(callingPid) || !MemoryMap.IsMonitored(targetPid))
                return;

            Pid = targetPid;
            Protection = (MemoryProtection)record.GetUInt32("ProtectionMask");
            BaseAddress = record.GetUInt64("BaseAddress");
            RegionSize = record.GetUInt64("ViewSize");
            (ActingModule, _, _) = MemoryMap.FinalUserModule(callingPid, record.GetStackTrace());

            if (Pid != callingPid)
                ActingModule += $"({MemoryMap.GetProcessName(callingPid)})";
        }

        internal static bool IsReadExecutable(MemoryProtection protection)
        {
            return 0 != (protection & (MemoryProtection.EXECUTE | MemoryProtection.EXECUTE_READ | MemoryProtection.EXECUTE_WRITECOPY));
        }
        internal static bool IsExecutable(MemoryProtection protection)
        {
            return IsReadExecutable(protection) || (MemoryProtection.EXECUTE_READWRITE == protection);
        }
        internal static bool IsWritable(MemoryProtection protection)
        {
            return 0 != (protection & (MemoryProtection.READWRITE | MemoryProtection.EXECUTE_READWRITE));
        }
    }

    public class LoadedImage
    {
        public UInt64 BaseAddress;
        public UInt64 RegionSize;
        public string RawImagePath;
        public string ImageName;

        public LoadedImage(IEventRecord record)
        {
            BaseAddress = record.GetUInt64("ImageBase");
            RegionSize = record.GetUInt64("ImageSize");
            RawImagePath = record.GetUnicodeString("ImageName");
            ImageName = Path.GetFileName(RawImagePath);
        }
    }
}

```

`src/ProcessCreationTraitsMap.cs`:

```cs
using Microsoft.O365.Security.ETW;
using Newtonsoft.Json;
using SyscallSummariser.Utilities;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Management;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;

using static SyscallSummariser.ETW.Microsoft_Windows_Kernel_Process;
using static Win32.Advapi;
using static Win32.Kernel32;
using static Win32.Ntdll;
using static Win32.Psapi;


namespace SyscallSummariser {
    /*
     * maintain a mapping from pid -> CreationTraitsHash -> CreationTraits
     * 
     */
    class ProcessCreationTraitsMap {
        internal static ConcurrentDictionary<string, ProcessCreationTraits> hashTraitsMap = new ConcurrentDictionary<string, ProcessCreationTraits>();
        internal static ConcurrentDictionary<uint, string> pidHashMap = new ConcurrentDictionary<uint, string>();
        internal static ConcurrentDictionary<uint, string> pidTreeMap = new ConcurrentDictionary<uint, string>();
        internal static ConcurrentDictionary<uint, string> oldPidHashMap = new ConcurrentDictionary<uint, string>();

        internal static string GetProcessTree(uint pid) {
            pidTreeMap.TryGetValue(pid, out var tree);
            return tree;
        }

        internal static void AddProcessTree(uint pid, string parentTree) {
            var node = pidHashMap[pid].Split(':')[0];
            if (string.IsNullOrEmpty(parentTree) || parentTree == "idle")
                pidTreeMap[pid] = node;
            else
                pidTreeMap[pid] = $"{parentTree}->{node}";
        }

        internal static void AddProcess(IEventRecord record) {
            //  Microsoft-Windows-Kernel-Process
            var pid = record.GetUInt32("ProcessID");
            var parentProcessTree = GetProcessTree(record.GetUInt32("ParentProcessID"));
            var creatorProcess = string.Empty;
            if (record.Id == 1) // ProcessStart events only - ProcessRundown events don't include an accurate creator ThreadId
                creatorProcess = GetProcessTree(record.ProcessId);
            var sessionId = record.GetUInt32("SessionID");
            var flags = record.GetUInt32("Flags");
            var processTokenElevationType = record.GetUInt32("ProcessTokenElevationType");
            var processTokenIsElevated = record.GetUInt32("ProcessTokenIsElevated");
            var integrityLevel = IntegrityLevelFriendlyName(new SecurityIdentifier(record.GetBinary("MandatoryLabel"), 0));
            var fullProcessImageName = new WindowsPath(record.GetUnicodeString("ImageName", string.Empty));

            var processTraits = new ProcessCreationTraits
            {
                ParentProcessTree = parentProcessTree,
                CreatorProcess = creatorProcess,
                SessionID = $"{sessionId}",
                Flags = $"0x{flags:x}",
                ProcessTokenElevationType = $"{processTokenElevationType}",
                ProcessTokenIsElevated = $"{processTokenIsElevated}",
                MandatoryLabel = integrityLevel,
                OriginalFilename = PeMetadata.GetOriginalFilename(fullProcessImageName.DrivePath),
                Signer = PeMetadata.GetSigner(fullProcessImageName.DrivePath),
                ImageName = fullProcessImageName.NormalisedPath
            };

            // CommandLine (and UserSid) are best effort only.
            // These are availble in the 'Windows Kernel Trace' provider ETW process start event.
            // However introducing a second ETW session also introduces out-of-order events.
            var searcher = new ManagementObjectSearcher($"SELECT * FROM Win32_Process WHERE ProcessID = {pid}");
            foreach (ManagementObject wmiProcess in searcher.Get()) {
                if (pid != (uint)wmiProcess["ProcessId"])
                    continue;

                var commandLine = wmiProcess["CommandLine"] != null ? (string)wmiProcess["CommandLine"] : string.Empty;
                processTraits.CommandLineExtract = ExtractInterestingCommandLine(commandLine, fullProcessImageName);

                var argList = new string[] { string.Empty };
                try {
                    if (Convert.ToInt32(wmiProcess.InvokeMethod("GetOwnerSid", argList)) == 0)
                        processTraits.UserSID = ProcessUtils.NormaliseSID(argList[0]);
                } catch { }
                
            }

            LogProcess(pid, processTraits);
        }

        private static string ExtractInterestingCommandLine(string commandLine, WindowsPath fullProcessImageName) {
            var interestingCommandline = string.Empty;

            // some processes have entire commandlines that are interesting
            var interestingFullCommandlineRegex = new Regex(@"^(" +
                @"(%windir%\\system32\\svchost)|" +
                @"(%windir%\\System32\\dllhost)|" +
                @"(%windir%\\System32\\taskhostw)|" +
                @")\.exe$", RegexOptions.IgnoreCase);

            if (interestingFullCommandlineRegex.Match(fullProcessImageName.NormalisedPath).Success) {
                var commandWords = commandLine.Split(' ').ToList(); // splitting on ' ' is safe only because of the list of matching processes
                commandWords.RemoveAt(0);  // remove process name
                interestingCommandline = string.Join(" ", commandWords);
                interestingCommandline = "'" + interestingCommandline + "'";
            }

            // some processes have just an interesting first argument
            var interestingArgumentRegex = new Regex(@"^(" +
                @"(%windir%\\system32\\rundll32)|" +
                @")\.exe$", RegexOptions.IgnoreCase);
            if (interestingArgumentRegex.Match(fullProcessImageName.NormalisedPath).Success)
                interestingCommandline = commandLine.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)[1];

            // some processes have an interesting sub-type specified on the commandline - especially chrome
            var typeMatches = new Regex(@"(?<type>--type=\w+)", RegexOptions.IgnoreCase).Match(commandLine);
            if (string.IsNullOrEmpty(interestingCommandline) && typeMatches.Success)
                interestingCommandline = typeMatches.Groups["type"].Value;

            // Microsoft Office / Internet Explorer automation 'Embedding' instances are interesting
            if (string.IsNullOrEmpty(interestingCommandline) && commandLine.EndsWith(" -Embedding"))
                
                interestingCommandline = "-Embedding";

            return interestingCommandline;
        }

        internal static void LogProcess(UInt32 pid, ProcessCreationTraits processTraits) {
            var processHash = processTraits.Hash();
            hashTraitsMap[processHash] = processTraits;
            pidHashMap[pid] = processHash;
            AddProcessTree(pid, processTraits.ParentProcessTree);

            TraitsProfiler.LogFeature(pid, "ProcessCreationTraitsHash", processHash);

            TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"ImageName={processTraits.ImageName}");
            if (!string.IsNullOrEmpty(processTraits.CommandLineExtract))
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"CommandLineExtract={processTraits.CommandLineExtract}");
            if (processTraits.ParentProcessTree != null)
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"ParentProcessTree={processTraits.ParentProcessTree}");
            TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"SessionID={processTraits.SessionID}");
            if (processTraits.CreatorProcess != null)
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"CreatorProcess={processTraits.CreatorProcess}");
            if (processTraits.Flags != null)
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"Flags={processTraits.Flags}");
            if (processTraits.UserSID != null)
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"UserSID={processTraits.UserSID}");
            if (processTraits.ProcessTokenIsElevated != null)
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"ProcessToken IsElevated={processTraits.ProcessTokenIsElevated} Type={processTraits.ProcessTokenElevationType}");
            if (processTraits.MandatoryLabel != null)
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"MandatoryLabel={processTraits.MandatoryLabel}");
            if (processTraits.OriginalFilename != null)
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"OriginalFilename={processTraits.OriginalFilename}");
            if (processTraits.Signer != null)
                TraitsProfiler.LogFeature(pid, "ProcessCreationTraits", $"Signer={processTraits.Signer}");
        }

        internal static void RemoveProcess(IEventRecord record) {
            var pid = record.GetUInt32("ProcessID");
            // drop future events for exited processes/threads now rather than risk bad data
            // we could use the ProcessStartKey instead - but not all events include this, and there is no thread equivalent
            // ETW queues can either be system-wide with guaranteed event order, or per-processor for performance
            // ETW queues are flushed when full, or every second otherwise
            pidHashMap.TryRemove(pid, out var traitsHash);
            oldPidHashMap.TryRemove(pid, out _);
            oldPidHashMap[pid] = traitsHash;
        }

        internal static string GetCreationTraitsHash(uint pid) {
            pidHashMap.TryGetValue(pid, out var traitsHash);
            if (traitsHash == null)
            {
                // There is a race condition on startup between the process scan and
                // the ETW session starting.
                AddProcessViaScan((int)pid);
                pidHashMap.TryGetValue(pid, out traitsHash);
            }

            return traitsHash;
        }


        internal static ProcessCreationTraits GetCreationTraits(uint id) {
            ProcessCreationTraits creationTraits = null;
            pidHashMap.TryGetValue(id, out var hash);
            if(hash == null)
                oldPidHashMap.TryGetValue(id, out hash);
            if (hash != null)
                hashTraitsMap.TryGetValue(hash, out creationTraits);
            return creationTraits;
        }

        internal static string GetProcessName(uint id) {
            var creationTraits = GetCreationTraits(id);
            return creationTraits == null ? $"pid:{id}" : creationTraits.ProcessName();
        }

        internal static readonly string[] interestingTargetProcesses = { "lsass", "explorer", "svchost", "spoolsv", "winlogon" };
        internal static readonly string[] interestingTargets = { "lsass", "System" };

        internal static string GetTarget(uint callingPid, uint targetPid)
        {
            if(targetPid == 0)
            {
                return "all";
            }
            
            if (targetPid == callingPid)
            {
                return "self";
            }

            // :TODO: add "child"? requires a cache of parent pids

            var traits = ProcessCreationTraitsMap.GetCreationTraits(targetPid);
            if (Path.GetFileNameWithoutExtension(traits?.ProcessName()) == "lsass")
            {
                return "lsass";
            }

            return traits?.MandatoryLabel;

        }

        internal static void PrePopulateScan() {
            var bufferSize = 0x1000000; // YOLO
            var buffer = Marshal.AllocHGlobal(bufferSize);

            Log.Write("Listing processes via NtQuerySystemInformation(SystemProcessInformation)");
            if (NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS.SystemProcessInformation, buffer, bufferSize, out var _) != 0)
                throw new Exception($"SystemProcessInformation - buffer too small  error={Marshal.GetLastWin32Error()}");

            // Enumerate CommandLine and UserSID via WMI
            var commandLines = new ConcurrentDictionary<uint, string>();
            var userSids = new ConcurrentDictionary<uint, string>();
            var mgmtClass = new ManagementClass("Win32_Process");
            foreach (ManagementObject wmiProcess in mgmtClass.GetInstances()) {
                var pid = (uint)wmiProcess["ProcessId"];
                if (pid == 0)
                    continue;

                commandLines[pid] = wmiProcess["CommandLine"] != null ? (string)wmiProcess["CommandLine"] : string.Empty;

                var argList = new string[] { string.Empty };
                try {
                    if (Convert.ToInt32(wmiProcess.InvokeMethod("GetOwnerSid", argList)) == 0)
                        userSids[pid] = argList[0];
                } catch {
                    userSids[pid] = null;
                }
            }

            var process = new SYSTEM_PROCESS_INFORMATION();
            var processOffset = buffer;
            do {
                var processTraits = new ProcessCreationTraits();
                try {
                    process = (SYSTEM_PROCESS_INFORMATION)Marshal.PtrToStructure(processOffset, process.GetType());
                    processTraits.SessionID = $"{process.SessionId}";

                    var hProcessLimited = OpenProcess(ProcessDesiredAccess.QueryLimitedInformation, false, (int)process.UniqueProcessId);
                    if (hProcessLimited.IsInvalid) {
                        if ((int)process.UniqueProcessId == 0)
                            throw new NotSupportedException("The parameter is incorrect");  // Idle
                        if (Marshal.GetLastWin32Error() == 87)
                            throw new TimeoutException("The parameter is incorrect");  // process exited
                        throw new ApplicationException($"OpenProcess(QueryLimitedInformation) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    }

                    userSids.TryGetValue((uint)process.UniqueProcessId, out var userSid);
                    processTraits.UserSID = ProcessUtils.NormaliseSID(userSid);

                    var processInformation = new PROCESS_BASIC_INFORMATION();
                    if (NtQueryInformationProcess(hProcessLimited, PROCESSINFOCLASS.ProcessBasicInformation, ref processInformation, Marshal.SizeOf(processInformation), out _) != 0)
                        throw new ApplicationException($"NtQueryInformationProcess(ProcessBasicInformation) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    processTraits.ParentProcessTree = GetProcessTree((UInt32)processInformation.InheritedFromUniqueProcessId);

                    var maxPath = WindowsPath.MAX_PATH;
                    var nameBuffer = new StringBuilder((int)maxPath);
                    if (GetProcessImageFileName(hProcessLimited, nameBuffer, maxPath) > 0) {
                        var path = new WindowsPath(nameBuffer.ToString());
                        processTraits.OriginalFilename = PeMetadata.GetOriginalFilename(path.DrivePath);
                        processTraits.Signer = PeMetadata.GetSigner(path.DrivePath);
                        processTraits.ImageName = path.NormalisedPath;
                        if (commandLines.ContainsKey((uint)process.UniqueProcessId))
                        {
                            processTraits.CommandLineExtract = ExtractInterestingCommandLine(commandLines[(uint)process.UniqueProcessId], path);
                        }
                    } else
                        processTraits.ImageName = Process.GetProcessById((int)process.UniqueProcessId).ProcessName;

                    if (!OpenProcessToken(hProcessLimited, TOKEN_QUERY, out var hToken)) {
                        if ((int)process.UniqueProcessId == 4)
                            throw new NotSupportedException("Access is denied");  // System
                        throw new ApplicationException($"OpenProcessToken(TOKEN_QUERY) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    }

                    var isElevated = new TOKEN_ELEVATION();
                    if (!GetTokenInformation(hToken, TOKEN_INFORMATION_CLASS.TokenElevation, ref isElevated, (uint)Marshal.SizeOf(isElevated), out var _))
                        throw new ApplicationException($"GetTokenInformation(TokenElevation) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    processTraits.ProcessTokenIsElevated = $"{isElevated.TokenIsElevated}";

                    var elevationType = new TOKEN_ELEVATION_TYPE();
                    if (!GetTokenInformation(hToken, TOKEN_INFORMATION_CLASS.TokenElevationType, ref elevationType, (uint)Marshal.SizeOf(elevationType), out _))
                        throw new ApplicationException($"GetTokenInformation(TokenElevationType) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    processTraits.ProcessTokenElevationType = $"{elevationType.TokenElevationType}";

                    var mandatoryLabel = new TOKEN_MANDATORY_LABEL();
                    if (!GetTokenInformation(hToken, TOKEN_INFORMATION_CLASS.TokenIntegrityLevel, ref mandatoryLabel, (uint)Marshal.SizeOf(mandatoryLabel), out _))
                        throw new ApplicationException($"GetTokenInformation(TokenIntegrityLevel) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    processTraits.MandatoryLabel = IntegrityLevelFriendlyName(new SecurityIdentifier(mandatoryLabel.Sid));

                    var isWow64Process = false;
                    if (!IsWow64Process(hProcessLimited, out isWow64Process))
                        throw new ApplicationException($"IsWow64Process failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");

                    var hProcessRead = OpenProcess(ProcessDesiredAccess.QueryInformation | ProcessDesiredAccess.VirtualMemoryRead, false, (int)process.UniqueProcessId);
                    if (!hProcessRead.IsInvalid) {
                        var processParametersOffset = isWow64Process ? 0x10 : 0x20;
                        var processParametersBufferSize = isWow64Process ? 4 : 8;
                        var processParametersBuffer = new byte[processParametersBufferSize];
                        if (ReadProcessMemory(hProcessRead, new UIntPtr((UInt64)processInformation.PebBaseAddress + (UInt32)processParametersOffset), processParametersBuffer, processParametersBufferSize, out _)) {
                            UInt64 pProcessParameters = isWow64Process ? (UInt32)BitConverter.ToInt32(processParametersBuffer, 0) : (UInt64)BitConverter.ToInt64(processParametersBuffer, 0);
                            var flagsBuffer = new byte[4];
                            if (ReadProcessMemory(hProcessRead, new UIntPtr(pProcessParameters + sizeof(ulong) * 2), flagsBuffer, 4, out _)) {
                                processTraits.Flags = $"0x{(UInt32)BitConverter.ToInt32(flagsBuffer, 0):x}";
                            }
                        } else {
                            // ReadProcessMemory is failing with a seemingly valid handle...
                            // Close it to prevent future errors.
                            // This seems to occur for Isolated User Mode processes.
                            // :TODO: Check for IUM with IsSecureProcess()?
                            hProcessRead.Close();
                        }
                    }
                } catch (NotSupportedException) { }  // continue
                catch (TimeoutException) { }  // continue
                catch (ApplicationException e) {
                    Log.WarnWrite(e.Message);
                }

                if ((int)process.UniqueProcessId != 0 && processTraits.ImageName != null) {  // not Idle(0) and process has not exited
                    LogProcess((UInt32)process.UniqueProcessId, processTraits);
                }

                processOffset = (IntPtr)((UInt64)processOffset + process.NextEntryOffset);
            } while (0 != process.NextEntryOffset);

            Marshal.FreeHGlobal(buffer);
        }

        internal static void AddProcessViaScan(int pid) {
            var commandLine = string.Empty;
            var userSid = string.Empty;
            var searcher = new ManagementObjectSearcher($"SELECT * FROM Win32_Process WHERE ProcessID = {pid}");
            foreach (ManagementObject wmiProcess in searcher.Get()) {
                if (pid != (uint)wmiProcess["ProcessId"])
                    continue;

                commandLine = wmiProcess["CommandLine"] != null ? (string)wmiProcess["CommandLine"] : string.Empty;
                var argList = new string[] { string.Empty };
                try {
                    if (Convert.ToInt32(wmiProcess.InvokeMethod("GetOwnerSid", argList)) == 0)
                        userSid = argList[0];
                } catch { }
            }

            var bufferSize = 0x100000; // YOLO
            var buffer = Marshal.AllocHGlobal(bufferSize);
            if (NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS.SystemProcessInformation, buffer, bufferSize, out var requiredSize) != 0)
                throw new Exception($"SystemProcessInformation - buffer too small  error={Marshal.GetLastWin32Error()}");

            var processOffset = buffer;

            var process = (SYSTEM_PROCESS_INFORMATION)Marshal.PtrToStructure(processOffset, typeof(SYSTEM_PROCESS_INFORMATION));
            while (!((int)process.UniqueProcessId == pid || 0 == process.NextEntryOffset)) {
                processOffset = (IntPtr)((UInt64)processOffset + process.NextEntryOffset);
                process = (SYSTEM_PROCESS_INFORMATION)Marshal.PtrToStructure(processOffset, process.GetType());
            }

            if ((int)process.UniqueProcessId == pid) {
                var processTraits = new ProcessCreationTraits();
                try {
                    processTraits.SessionID = $"{process.SessionId}";

                    var hProcessLimited = OpenProcess(ProcessDesiredAccess.QueryLimitedInformation, false, (int)process.UniqueProcessId);
                    if (hProcessLimited.IsInvalid) {
                        if ((int)process.UniqueProcessId == 0)
                            throw new NotSupportedException("The parameter is incorrect");  // Idle
                        if (Marshal.GetLastWin32Error() == 87)
                            throw new TimeoutException("The parameter is incorrect");  // process exited
                        throw new ApplicationException($"OpenProcess(QueryLimitedInformation) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    }

                    processTraits.UserSID = ProcessUtils.NormaliseSID(userSid);

                    var processInformation = new PROCESS_BASIC_INFORMATION();
                    if (NtQueryInformationProcess(hProcessLimited, PROCESSINFOCLASS.ProcessBasicInformation, ref processInformation, Marshal.SizeOf(processInformation), out _) != 0)
                        throw new ApplicationException($"NtQueryInformationProcess(ProcessBasicInformation) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    
                    processTraits.ParentProcessTree = GetProcessTree((UInt32)processInformation.InheritedFromUniqueProcessId);

                    var maxPath = WindowsPath.MAX_PATH;
                    var nameBuffer = new StringBuilder((int)maxPath);
                    if (GetProcessImageFileName(hProcessLimited, nameBuffer, maxPath) > 0) {
                        var path = new WindowsPath(nameBuffer.ToString());
                        processTraits.OriginalFilename = PeMetadata.GetOriginalFilename(path.DrivePath);
                        processTraits.Signer = PeMetadata.GetSigner(path.DrivePath);
                        processTraits.ImageName = path.NormalisedPath;
                        processTraits.CommandLineExtract = ExtractInterestingCommandLine(commandLine, path);
                    } else
                        processTraits.ImageName = Process.GetProcessById((int)process.UniqueProcessId).ProcessName;

                    if (!OpenProcessToken(hProcessLimited, TOKEN_QUERY, out var hToken)) {
                        if ((int)process.UniqueProcessId == 4)
                            throw new NotSupportedException("Access is denied");  // System
                        throw new ApplicationException($"OpenProcessToken(TOKEN_QUERY) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    }

                    var isElevated = new TOKEN_ELEVATION();
                    if (!GetTokenInformation(hToken, TOKEN_INFORMATION_CLASS.TokenElevation, ref isElevated, (uint)Marshal.SizeOf(isElevated), out var _))
                        throw new ApplicationException($"GetTokenInformation(TokenElevation) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    processTraits.ProcessTokenIsElevated = $"{isElevated.TokenIsElevated}";

                    var elevationType = new TOKEN_ELEVATION_TYPE();
                    if (!GetTokenInformation(hToken, TOKEN_INFORMATION_CLASS.TokenElevationType, ref elevationType, (uint)Marshal.SizeOf(elevationType), out _))
                        throw new ApplicationException($"GetTokenInformation(TokenElevationType) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    processTraits.ProcessTokenElevationType = $"{elevationType.TokenElevationType}";

                    var mandatoryLabel = new TOKEN_MANDATORY_LABEL();
                    if (!GetTokenInformation(hToken, TOKEN_INFORMATION_CLASS.TokenIntegrityLevel, ref mandatoryLabel, (uint)Marshal.SizeOf(mandatoryLabel), out _))
                        throw new ApplicationException($"GetTokenInformation(TokenIntegrityLevel) failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");
                    processTraits.MandatoryLabel = IntegrityLevelFriendlyName(new SecurityIdentifier(mandatoryLabel.Sid));

                    var isWow64Process = false;
                    if (!IsWow64Process(hProcessLimited, out isWow64Process))
                        throw new ApplicationException($"IsWow64Process failed - pid={process.UniqueProcessId} error={Marshal.GetLastWin32Error()}");

                    var hProcessRead = OpenProcess(ProcessDesiredAccess.QueryInformation | ProcessDesiredAccess.VirtualMemoryRead, false, (int)process.UniqueProcessId);
                    if (!hProcessRead.IsInvalid) {
                        var processParametersOffset = isWow64Process ? 0x10 : 0x20;
                        var processParametersBufferSize = isWow64Process ? 4 : 8;
                        var processParametersBuffer = new byte[processParametersBufferSize];
                        if (ReadProcessMemory(hProcessRead, new UIntPtr((UInt64)processInformation.PebBaseAddress + (UInt32)processParametersOffset), processParametersBuffer, processParametersBufferSize, out _)) {
                            UInt64 pProcessParameters = isWow64Process ? (UInt32)BitConverter.ToInt32(processParametersBuffer, 0) : (UInt64)BitConverter.ToInt64(processParametersBuffer, 0);
                            var flagsBuffer = new byte[4];
                            if (ReadProcessMemory(hProcessRead, new UIntPtr(pProcessParameters + sizeof(ulong) * 2), flagsBuffer, 4, out _)) {
                                processTraits.Flags = $"0x{(UInt32)BitConverter.ToInt32(flagsBuffer, 0):x}";
                            }
                        }
                        // fall through on error
                    }
                } catch (NotSupportedException) { }  // continue
                catch (TimeoutException) { }  // continue
                catch (ApplicationException e) {
                    Log.WarnWrite(e.Message);
                }

                if ((int)process.UniqueProcessId != 0 && processTraits.ImageName != null) {  // not Idle(0) and process has not exited
                    LogProcess((UInt32)process.UniqueProcessId, processTraits);
                }
            }

            Marshal.FreeHGlobal(buffer);
        }
    }

    public class ProcessCreationTraits {
        public const string UnknownProcess = "Unknown";

        [JsonProperty(Order = 1)]
        public string ParentProcessTree { get; set; }

        // Note - we don't need to explcitly log the pid of the creator process
        // This is implied from the tid.
        [JsonProperty(Order = 2)]
        public string CreatorProcess { get; set; }

        [JsonProperty(Order = 3)]
        public string SessionID { get; set; }

        [JsonProperty(Order = 4)]
        public string Flags { get; set; }

        [JsonProperty(Order = 5)]
        public string ProcessTokenElevationType { get; set; }

        [JsonProperty(Order = 6)]
        public string ProcessTokenIsElevated { get; set; }

        [JsonProperty(Order = 7)]
        public string MandatoryLabel { get; set; }

        [JsonProperty(Order = 8)]
        public string ImageName { get; set; }

        [JsonProperty(Order = 9)]
        public string OriginalFilename { get; set; }

        [JsonProperty(Order = 10)]
        public string Signer { get; set; }
        
        [JsonProperty(Order = 11)]
        public string UserSID { get; set; }

        [JsonProperty(Order = 12)]
        public string CommandLineExtract { get; set; }

        // Note - We deliberately don't log variable fields such as file hash and file version
        // Doing this creates a more stable, though slightly lesss accurate, fingerprint

        public string Hash()
        {
            return Prefix() + HashUtils.SHA1(this.ToJson());
        }

        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        public string ProcessName() {
            if (ImageName == null)
                return UnknownProcess;
            if (ImageName.Contains("\\"))
                return new Regex(@"^.*\\(?<name>[^\\]+)$").Match(ImageName).Groups["name"].Value;
            return ImageName;
        }

        internal string Prefix() {
            return $"{ProcessName()}::";
        }

        public string FilePath() {
            return Hash().Replace(':', '_');
        }
    }
}

```

`src/ProcessProfile.cs`:

```cs
using Microsoft.O365.Security.ETW;
using Newtonsoft.Json;
using SyscallSummariser.Utilities;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;

namespace SyscallSummariser
{
    /* 
     *  for each process/thread, store a set of observed values for a number of interesting features
     *  use creation traits hash as key
     *  features include - modules, syscalls, Network endpoints
     *
     *  { traitshash : { feature : set(observed values) } 
     *  e.g. { "calc.exe_9baac013..." : { "Syscalls": ["API-LoadLibrary(%windir%, ntdll.dll) [ntdll.dll, Microsoft Corporation, 9AA4E92DA41B87A1CD9829A16F7EAE5A80D739B3]"] } }
     */
    public class TraitsProfiler
    {
        internal static bool useCommonSymbols = true;

        internal static Dictionary<string, Dictionary<string, SortedSet<string>>> summaries = new Dictionary<string, Dictionary<string, SortedSet<string>>>();

        internal static SortedSet<string> summariesWithNewBehaviours = new SortedSet<string>();

        private const uint MAX_VALUES = 500;

        private static Timer outputTimer = null;

        private const string outputFilename = "SyscallSummary.json";
        private static readonly object fileLock = new object();
        private static int outputJsonSize = 0;
        private const int maximumJsonSize = 64 * 1024 * 1024;  // 64 MB

        private const int outputStartupDelaySeconds = 120;
        private const int outputIntervalSeconds = 120;          // 2 minutes

        public const string summariesOutputDirectory = "SyscallSummaries";

        public TraitsProfiler()
        {
            Log.Write($"Console logfile                   : {Log.logfile}");
            Log.Write($"Whole system json output filename : {outputFilename}");
            Log.Write($"Per-process json output directory : {summariesOutputDirectory}");

            // restore state from previous run
            FromJson(outputFilename);
            UpdateTreeview();

            // periodically output the observed profile to a json file
            outputTimer = new Timer(delegate (object state)
            {
                OutputJsonFiles();
            }, null, outputStartupDelaySeconds * 1000, outputIntervalSeconds * 1000);
        }

        private void UpdateTreeview()
        {
            Program.mainWindow.AddTreeView(summaries);
        }

        public void Stop()
        {
            if (outputTimer != null)
            {
                outputTimer.Dispose();
                outputTimer = null;
            }
        }

        public static void OutputJsonFiles()
        {
            string json;
            lock (fileLock)
            {
                lock (summaries)
                {
                    // all profiles together
                    json = ToJson();
                    // if output file is too large, then reset our data collection
                    if (json.Length > maximumJsonSize)
                    {
                        Log.Write("Output file size limit reached - clearing state");
                        Clear();
                        Program.verbose = false;

                        File.WriteAllText(outputFilename, json);
                        PathUtils.CompressAndDeleteFile(outputFilename);

                        json = ToJson();
                        outputJsonSize = 0;
                    }

                    // individual profiles
                    foreach (var key in summaries.Keys)
                        SaveProfileToDisk(key, summaries[key]);
                }

                if (!Program.verbose && outputJsonSize != 0 && json.Length == outputJsonSize)
                {
                    Log.VerboseWrite("Startup collection complete - switching to verbose output");
                    Program.verbose = true;
                }

                if (json.Length != outputJsonSize)
                {
                    outputJsonSize = json.Length;
                    File.WriteAllText(outputFilename, json);
                }
            }
        }

        public static string ToJson()
        {
            return JsonConvert.SerializeObject(summaries, Formatting.Indented);
        }

        public static void FromJson(string jsonFile)
        {
            try
            {
                if (File.Exists(jsonFile))
                {
                    var json = File.ReadAllText(jsonFile);
                    summaries = JsonConvert.DeserializeObject<Dictionary<string, Dictionary<string, SortedSet<string>>>>(json);
                    if (summaries != null)
                    {
                        // we have (some) existing system state - it's okay to enable verbose output
                        Program.verbose = true;
                    }
                    else
                    {
                        summaries = new Dictionary<string, Dictionary<string, SortedSet<string>>>();
                    }
                }
            }
            catch { }
        }

        public static void Clear()
        {
            // clear all of the observed features
            lock (summaries)
                summaries.Clear();
        }

        internal static string EnrichFeature(uint pid, string originalValue, List<UIntPtr> callStack)
        {
            if (callStack.Count == 0)
                return originalValue;

            if (!MemoryMap.IsMonitored(pid))
                return null;

            var (callingModule, calledApi, _) = MemoryMap.FinalUserModule(pid, callStack);
            if (string.IsNullOrEmpty(callingModule) || callingModule == MemoryMap.Unknown || string.IsNullOrEmpty(calledApi))
            {
                return null;
            }

            var enrichedValue = $"{callingModule}->{calledApi}->{originalValue}";
            if (callingModule == MemoryMap.Shellcode)
            {
                Log.ErrorWrite($"{ProcessCreationTraitsMap.GetProcessName(pid)} {enrichedValue}");
            }
            else if(callingModule.Contains("TppTimerpExecuteCallback"))
            {
                Log.WarnWrite($"{ProcessCreationTraitsMap.GetProcessName(pid)} {enrichedValue}");
            }

            return enrichedValue;
        }

        internal static void LogFeature(uint pid, string feature, string value)
        {
            if (Program.stopping || string.IsNullOrEmpty(feature) || string.IsNullOrEmpty(value))
                return;

            var key = ProcessCreationTraitsMap.GetCreationTraitsHash(pid);
            if (key == null)
                return;

            lock (summaries)
            {
                if (!summaries.ContainsKey(key))
                    summaries.Add(key, new Dictionary<string, SortedSet<string>>());
            }

            var processFeatures = summaries[key];
            lock (processFeatures)
            {
                if (!processFeatures.ContainsKey(feature))
                    processFeatures.Add(feature, new SortedSet<string>());
            }

            var values = processFeatures[feature];
            lock (values)
            {
                if (!values.Contains(value))
                {
                    if (values.Count == MAX_VALUES)
                    {
                        values.Add("<OUTPUT_TRUNCATED>");
                        Log.WarnWrite($"MAX_VALUES exceeded in {ProcessCreationTraitsMap.GetProcessName(pid)} :: {feature}");
                    }

                    if (values.Count < MAX_VALUES)
                    {
                        values.Add(value);

                        // update TTPHash
                        if (processFeatures.ContainsKey("Syscalls"))
                        {
                            var TTPjson = JsonConvert.SerializeObject(processFeatures["Syscalls"], Formatting.Indented);

                            if (!processFeatures.ContainsKey("TTPHash"))
                                processFeatures.Add("TTPHash", new SortedSet<string>());
                            else
                                processFeatures["TTPHash"].Clear();
                            // flush old hash for now
                            // TODO(jdu) add (timestamp, hash) tuples

                            processFeatures["TTPHash"].Add(HashUtils.SHA1(TTPjson));
                        }

                        // monitored process with a new behaviour detected
                        if (MemoryMap.IsMonitored(pid) && !summariesWithNewBehaviours.Contains(key))
                        {
                            summariesWithNewBehaviours.Add(key);
                            Program.mainWindow.AddTreeView(summaries);
                        }
                    }
                }
            }
        }

        private static void SaveProfileToDisk(string key, Dictionary<string, SortedSet<string>> profile)
        {
            Debug.Assert(key != null);
            if (!summariesWithNewBehaviours.Contains(key))
                return;

            var json = JsonConvert.SerializeObject(profile, Formatting.Indented);

            try
            {
                // output the json to profilesOutputDirectory\\key.json
                Directory.CreateDirectory(summariesOutputDirectory);
                var filepath = Path.Combine(summariesOutputDirectory, key.Replace(':', '_') + ".json");
                File.WriteAllText(filepath, json);
            }
            catch (Exception e) when (e is PathTooLongException || e is DirectoryNotFoundException)
            {
                Log.WarnWrite(e.Message);
            }
        }

        // TODO(jdu) - improve on this name-only matching
        internal static readonly string[] commonMicrosoftModules = { "bcrypt", "cfgmgr32", "combase", "dbgcore", "dui70", "duser", "mpr", "winbrand", "wkscli" };
        internal static readonly string[] commonMicrosoftCallers = { "kernelbase!GetProcAddressForCaller", "user32!CreateWindowExW" };

        internal static bool IsMicrosoftSigner(string signer)
        {
            return signer == "Microsoft Corporation";
        }

        public static void LogModule(uint pid, WindowsPath moduleName, IEventRecord record)
        {
            if (moduleName.IsNullOrEmpty())
                return;

            // We normalise LoadLibrary events to just the module's signer
            // We could consider more verbose logging for specific modules here.
            var signer = PeMetadata.GetSigner(moduleName.DrivePath);
            var value = EnrichFeature(pid, $"NtMapViewOfSection({signer})", record.GetStackTrace());
            LogFeature(record.ProcessId, "Syscalls", value);
        }
    }
}

```

`src/Program.cs`:

```cs
using Microsoft.Win32;
using SyscallSummariser.ETW;
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Runtime.InteropServices;

using SyscallSummariser.Utilities;
using System.Windows;

namespace SyscallSummariser
{
    class Program
    {
        [DllImport("PPLKillerDLL.dll")]
        public static extern void EnablePPL(Int32 dwProcessId);

        [DllImport("PPLKillerDLL.dll")]
        public static extern void DisablePPL(Int32 dwProcessId);

        [DllImport("PPLKillerDLL.dll")]
        public static extern void InstallDriver();

        [DllImport("PPLKillerDLL.dll")]
        public static extern void UninstallDriver();

        public static bool verbose = false;
        public static bool runAsPPL = File.Exists("PPLKillerDLL.dll");
        public static bool startupComplete = false;

        private static readonly EtwUserTrace userTrace = new EtwUserTrace();
        private static TraitsProfiler jsonOutputThread = null;

        public static MainWindow mainWindow = null;

        public static void Main()
        {
            lock (_stopLock)  // can't call stop until startup is complete
            {
                // Launch our main GUI window
                var windowThread = new Thread(new ThreadStart(() =>
                    {
                        mainWindow = new MainWindow
                        {
                            Visibility = Visibility.Visible
                        };
                        mainWindow.FontSize = 16;
                        System.Windows.Threading.Dispatcher.Run();
                    }));
                windowThread.SetApartmentState(ApartmentState.STA);
                windowThread.IsBackground = true;
                windowThread.Start();
                while (mainWindow == null)
                    Thread.Sleep(100);

                Log.Write("================================================================================");

                var product = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "ProductName", "").ToString();
                var display = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "DisplayVersion", "").ToString();
                if (string.IsNullOrEmpty(display))
                {
                    display = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "ReleaseId", "").ToString();
                }
                var major = Environment.OSVersion.Version.Major;
                var minor = Environment.OSVersion.Version.Minor;
                var build = Environment.OSVersion.Version.Build;
                var release = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "UBR", "").ToString();
                var buildex = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "BuildLabEx", "").ToString();
                Log.Write($"{product} {display} ({major}.{minor}.{build}.{release} {buildex})");

                // Most of the interesting ETW events were introduced in Windows 10
                if (major < 10)
                {
                    Log.ErrorWrite("This program requires NT 10.0+");
                    return;
                }

                // We need Administrator to BYOVD to enable PPL for Microsoft-Windows-Threat-Intelligence
                // We also explicitly need SYSTEM for Microsoft-Windows-Security-Auditing
                if (!TokenUtils.ImpersonateSystem())
                {
                    Log.ErrorWrite("Failed to elevate to SYSTEM - This program must be run as Administrator");
                    return;
                }

                // On Windows 11, this call is hardened to kernel callers - so we see less events.
                if (major > 10)
                {
                    Log.Write("Insufficient privilege to call NtSetInformationProcess(EnableReadWriteVmLogging)");
                    Log.Write(" --> WriteProcessMemory/ReadProcessMemory events only available on Win10");
                }

                // Initialise our TraitsProfiler - this combines similiar processes started with similar attributes
                // into a single entity.
                // It also handles our periodic output to json file
                jsonOutputThread = new TraitsProfiler();

                // We're not using an AutoLogger ETW session (yet) - so enumerate current process state instead.
                // 1. processes - enables partial process tree reconstruction
                /* userTrace.EnumerateProcessState(); */
                // For reasons currently unknown, ETW rundown events are not always generated
                // So scan processes instead :-/
                ProcessCreationTraitsMap.PrePopulateScan();

                // Configure audit policy now.
                // Because, after we enable PPL, launching processes isn't straightforward.
                ProcessUtils.Execute(@"C:\Windows\system32\auditpol.exe", "/set /subcategory:\"Token Right Adjusted Events\"");

                // enable PPL so that we can subscribe to Threat-Intelligence events
                if (runAsPPL)
                {
                    Log.Write("Enabling PPL via DKOM through vulnerable driver...");
                    InstallDriver();
                    EnablePPL(Process.GetCurrentProcess().Id);
                }

                // enable ETW providers
                userTrace.Stop();
                userTrace.Enable();

                if (runAsPPL)
                {
                    // We need PPL for userTrace.trace.Start() below
                    // Afterwards, PPL affects our ability to debug and terminate this process
                    ThreadPool.QueueUserWorkItem(delegate (object _)
                    {
                        // Wait for the userTrace to start
                        do
                        {
                            Thread.Sleep(TimeSpan.FromMilliseconds(100));
                        } while (0 == userTrace.trace.QueryStats().EventsTotal);

                        Thread.Sleep(TimeSpan.FromSeconds(3));
                        startupComplete = true;

                        lock (_stopLock)
                        {
                            if (!stopping)
                            {
                                Log.Write("Disabling PPL via DKOM...");
                                DisablePPL(Process.GetCurrentProcess().Id);
                            }
                        }
                    });
                }

            } // startup complete

            // process the UserMode ETW events on this thread
            if (userTrace != null)
                userTrace.BlockingStart();
            Thread.Sleep(TimeSpan.FromSeconds(5));

            // cleanup
            Stop();
            Log.Write("All done.");
        }

        internal static bool stopping = false;
        internal static object _stopLock = new object();

        public static void Stop()
        {
            lock (_stopLock)
            {
                if (!stopping)
                {
                    stopping = true;

                    Log.Write("Stopping...");
                    if (jsonOutputThread != null)
                        jsonOutputThread.Stop();

                    if (runAsPPL)
                    {
                        // re-enable PPL so that we can exit cleanly
                        EnablePPL(Process.GetCurrentProcess().Id);
                    }

                    userTrace.Stop();
                    Thread.Sleep(TimeSpan.FromSeconds(5));
                }
            }
        }
    }
}

```

`src/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("ETW Syscall Monitor")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ETW Syscall Monitor")]
[assembly: AssemblyCopyright("John Uhlmann")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]
[assembly: Guid("537a8a97-8620-4e7a-85ad-863C07654452")]

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`src/Utilities/HashUtils.cs`:

```cs
using System.Security.Cryptography;
using System.Text;

namespace SyscallSummariser
{
    class HashUtils
    {
        public static string SHA1(string data)
        {
            return SHA1(Encoding.UTF8.GetBytes(data));
        }

        public static string SHA1(byte[] data)
        {
            return SHA1(data, 0, data.Length);
        }

        public static string SHA1(byte[] data, int offset, int count)
        {
            var strHash = string.Empty;
            try
            {
                StringBuilder sbHash = new StringBuilder();
                using (SHA1 hash = System.Security.Cryptography.SHA1.Create())
                {
                    byte[] hash_bytes = hash.ComputeHash(data, offset, count);
                    for (int i = 0; i < hash_bytes.Length; i++)
                    {
                        sbHash.AppendFormat("{0:x2}", hash_bytes[i]);
                    }
                }
                strHash = sbHash.ToString();
            }
            catch { }

            return strHash;
        }

        public static string SHA256(string data)
        {
            return SHA256(Encoding.UTF8.GetBytes(data));
        }

        public static string SHA256(byte[] data)
        {
            return SHA256(data, 0, data.Length);
        }

        public static string SHA256(byte[] data, int offset, int count)
        {
            var strHash = string.Empty;
            try
            {
                StringBuilder sbHash = new StringBuilder();
                using (SHA256 hash = System.Security.Cryptography.SHA256.Create())
                {
                    byte[] hash_bytes = hash.ComputeHash(data, offset, count);
                    for (int i = 0; i < hash_bytes.Length; i++)
                    {
                        sbHash.AppendFormat("{0:x2}", hash_bytes[i]);
                    }
                }
                strHash = sbHash.ToString();
            }
            catch { }

            return strHash;
        }
    }
}

```

`src/Utilities/Log.cs`:

```cs
namespace SyscallSummariser
{
    using System;
    using System.Collections.Generic;
    using System.IO;
        using System.Windows.Media;

    class Log
    {
        public const string logfile = "SyscallSummariser.log";
        private const long logfileMaximumSize = 10 * 1024 * 1024;  // 10 MB
        private static readonly object _logLock = new object();
        internal static SortedSet<string> consoleMessages = new SortedSet<string>();

        public static void Write(string message)
        {
            Write(message, Brushes.LightGray);
        }

        public static void Write(string message, Brush colour)
        {
            var logMessage = $"[{DateTime.UtcNow:u}] {message}" + Environment.NewLine;

            if (!consoleMessages.Contains(message) || (colour == Brushes.Red))
            {
                consoleMessages.Add(message);
                Program.mainWindow.Dispatcher.BeginInvoke(new Action(() =>
                    {
                        Program.mainWindow.AddLine(message, colour);
                    }));
            }

            lock (_logLock)
            {
                // TODO(jdu) handle file locked scenario
                File.AppendAllText(logfile, logMessage);
                if (new FileInfo(logfile).Length > logfileMaximumSize)
                    PathUtils.CompressAndDeleteFile(logfile);
            }
        }

        public static void ErrorWrite(string message)
        {
            Write("[!] " + message, Brushes.Red);
        }
        public static void WarnWrite(string message)
        {
            Write("[!] " + message, Brushes.Orange);
        }

        public static void VerboseWrite(string message)
        {
#if DEBUG
            Write("[*] " + message, Brushes.White);
#endif
        }
    }
}

```

`src/Utilities/MemoryExtensions.cs`:

```cs
using Win32;

namespace SyscallSummariser
{
    public static class MemoryExtensions
    {
        internal static bool IsExecutableMemory(this Kernel32.MemoryProtection protect)
        {
            return HasProtection(protect, Kernel32.MemoryProtection.EXECUTE) ||
                   HasProtection(protect, Kernel32.MemoryProtection.EXECUTE_READ) ||
                   HasProtection(protect, Kernel32.MemoryProtection.EXECUTE_READWRITE) ||
                   HasProtection(protect, Kernel32.MemoryProtection.EXECUTE_WRITECOPY);
        }

        internal static bool HasProtection(this Kernel32.MemoryProtection protect, Kernel32.MemoryProtection flag)
        {
            return (protect & flag) == flag;
        }
    }
}

```

`src/Utilities/PathUtils.cs`:

```cs
namespace SyscallSummariser {
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.IO;
    using System.IO.Compression;
    using System.Linq;
    using System.Text;
    using System.Text.RegularExpressions;

    using Win32;

    public class WindowsPath {
        public const int MAX_PATH = 32767;  // extended MAX_PATH;

        private static readonly string WINDIR = Environment.GetEnvironmentVariable("WINDIR").ToLower();
        private static readonly string SYSTEMROOT = Environment.GetEnvironmentVariable("SYSTEMROOT").ToLower();
        private static readonly string USERPUBLIC = Environment.GetEnvironmentVariable("PUBLIC").ToLower();
        private static readonly string SYSTEMDRIVE = Environment.GetEnvironmentVariable("SYSTEMDRIVE").ToLower();
        private static readonly string PROGRAMFILES = Environment.GetEnvironmentVariable("PROGRAMFILES").ToLower();
        private static readonly string PROGRAMFILESx86 = Environment.GetEnvironmentVariable("PROGRAMFILES(X86)").ToLower();
        private static readonly string PROGRAMDATA = Environment.GetEnvironmentVariable("PROGRAMDATA").ToLower();
        private static readonly string PROFILE = new Regex(@"^(?<profile>\w:\\[\w\\]+)\\[\w]+").Match(USERPUBLIC).Groups["profile"].Value;
        private static string NETWORKPROFILE = string.Empty;
        private static readonly Regex FilePathRegex = new Regex(@"^(?<drivepath>(\w:)?[^:]+\\(?<filename>[^:\\]+?(\.(?<fileExtension>[^\.\\\:,]+))?))(?<alternateDataStream>\:[^\.\\\:,]+)?$");

        public string Raw { get; set; }
        public string DrivePath { get; set; }
        public string NormalisedPath { get; set; }
        public string NormalisedRoot { get; set; }
        public string FileExtension { get; set; }
        public string AlternateDataStream { get; set; }

        public WindowsPath(string rawPath) {
            Raw = rawPath;
            DrivePath = rawPath;
            NormalisedPath = rawPath;
            NormalisedRoot = rawPath;

            if (string.IsNullOrEmpty(rawPath))
                return;

            // DrivePath - e.g. C:\Windows\system32\ntdll.dll
            DrivePath = rawPath.ToLower();
            DrivePath = Regex.Replace(DrivePath, @"^\\\\?\\", string.Empty);
            // adapted from https://stackoverflow.com/questions/48320430/convert-from-windows-nt-device-path-to-drive-letter-path
            if (DrivePath.StartsWith(@"\device\")) {
                var drive = Array.Find(DriveInfo.GetDrives(), d => DrivePath.StartsWith(d.GetDevicePath(), StringComparison.InvariantCultureIgnoreCase));
                if (drive != null)
                    DrivePath = Regex.Replace(DrivePath, drive.GetDevicePath().Replace(@"\", @"\\"), drive.GetDriveLetter().ToLower(), RegexOptions.IgnoreCase);
            }

            // we need to strip an Alternate Data Stream names from the DrivePath
            // we also extract the (likely) file extension at the same time
            // :TODO: due to NTFS design file extension logic is best effort only...and can produce false positives
            // so... do we only log 'interesting' file types?
            var fileExtensionMatches = FilePathRegex.Match(DrivePath);
            if (fileExtensionMatches.Success) {
                DrivePath = fileExtensionMatches.Groups["drivepath"].Value;
                FileExtension = fileExtensionMatches.Groups["fileExtension"].Value;
                AlternateDataStream = fileExtensionMatches.Groups["alternateDataStream"].Value;
            }

            // NormalisedPath - e.g. %windir%\system32\ntdll.dll
            NormalisedPath = DrivePath;
            // note - the order of replacements is important

            NormalisedPath = Regex.Replace(NormalisedPath, @"\\systemroot", SYSTEMROOT);
            NormalisedPath = NormalisedPath.Replace(WINDIR, "%windir%");

            NormalisedPath = NormalisedPath.Replace(PROGRAMFILESx86, "%programfiles(x86)%");
            NormalisedPath = NormalisedPath.Replace(PROGRAMFILES, "%programfiles%");
            NormalisedPath = NormalisedPath.Replace(PROGRAMDATA, "%programdata%");

            NormalisedPath = NormalisedPath.Replace(USERPUBLIC, "%public%");
            NormalisedPath = NormalisedPath.Replace(PROFILE, "%profile%");
            NormalisedPath = Regex.Replace(NormalisedPath, @"^%profile%\\[^;\\]+", "%userprofile%");

            NormalisedPath = Regex.Replace(NormalisedPath, "^" + SYSTEMDRIVE, "%drive-system%");
            NormalisedPath = Regex.Replace(NormalisedPath, @"^\w:", "%drive%");

            NormalisedPath = Regex.Replace(NormalisedPath, @"^\\fi_unknown", "%fi_unknown%");

            if (NormalisedPath.StartsWith(@"\device\")) {
                // best effort detection of roaming profiles / folder redirection
                var appdata = new Regex(@"^(?<profile>\\device\\mup\\.+)\\appdata\\(local|locallow|roaming)\\").Match(NormalisedPath);
                if (appdata.Success)
                    NETWORKPROFILE = appdata.Groups["profile"].Value;

                if (NETWORKPROFILE != string.Empty)
                    NormalisedPath = NormalisedPath.Replace(NETWORKPROFILE, "%userprofile%");

                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\harddisk\d+", "%drive-physical%");

                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\;csc\\", @"%clientsidecache%\");

                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\[^;\\]+\\pipe\\", @"%pipe%\");
                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\[^;\\]+\\sysvol\\[^;\\]+", "%sysvol%");

                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\;lanmanredirector\\;[a-z]:[0-9a-f]+\\[^;\\]+", "%drive-network%");
                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\dfsclient\\;[a-z]:[0-9a-f]+\\[^;\\]+\\dfs\\", @"%drive-network%\");
                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\dfsclient\\;[a-z]:[0-9a-f]+\\[^;\\]+", "%drive-network%");

                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\[^;\\]+\\dfs\\", @"%drive-network%\");
                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\[^;\\]+", "%drive-network%");

                NormalisedPath = Regex.Replace(NormalisedPath, @"^\\device\\mup\\", @"%mup%\");
            }

            NormalisedPath = Regex.Replace(NormalisedPath, @"^%userprofile%\\appdata\\local\\temp\\[a-z0-9]{8}\.[a-z0-9]{3}\\", @"%userprofile%\\appdata\\local\\temp\\%8.3%");
            NormalisedPath = Regex.Replace(NormalisedPath, @"\\[a-f0-9]{32}}\\", @"\\%32x%\\");

            // NormalisedRoot - e.g. %windir%
            var root = new Regex(@"^(?<root>%[^%]+%)").Match(NormalisedPath);
            if (root.Success)
                NormalisedRoot = root.Groups["root"].Value;
        }

        internal bool IsDevicePath() {
            return NormalisedPath.StartsWith(@"\device\");
        }

        internal bool IsNullOrEmpty() {
            return string.IsNullOrEmpty(Raw);
        }

        public string FileName() {
            return Path.GetFileName(DrivePath);
        }
    }
    public static class DriveInfoExtensions {

        public static string GetDriveLetter(this DriveInfo driveInfo) {
            return driveInfo.Name.Substring(0, 2);
        }

        public static string GetDevicePath(this DriveInfo driveInfo) {
            var devicePathBuilder = new StringBuilder(128);
            return Kernel32.QueryDosDevice(driveInfo.GetDriveLetter(), devicePathBuilder, devicePathBuilder.Capacity + 1) != 0 ?
                devicePathBuilder.ToString() :
                null;
        }
    }

    public static class PathUtils {
        public static void PruneDirectory(string directory, long maximumSize) {
            Trace.Assert(maximumSize > 0, "maximum directory size is not sane");
            Trace.Assert(Directory.Exists(directory), "directory does not exist");

            var files = new Stack(new DirectoryInfo(directory).EnumerateFiles().OrderByDescending(f => f.CreationTime).ToList());

            long directorySize = 0;
            foreach (FileInfo file in files)
                directorySize += file.Length;

            while (directorySize > maximumSize) {
                var oldestFile = (FileInfo)files.Pop();
                directorySize -= oldestFile.Length;
                Log.Write($"[log] deleted oldest file in directory - {oldestFile.FullName}");
                oldestFile.Delete();
            }
        }

        private static readonly object _zipLock = new object();
        public static void CompressAndDeleteFile(string filename) {
            lock (_zipLock) {
                if (File.Exists(filename)) {
                    var zipfile = filename + ".zip";
                    if (File.Exists(zipfile))
                        File.Delete(zipfile);

                    using (ZipArchive archive = ZipFile.Open(zipfile, ZipArchiveMode.Create))
                        archive.CreateEntryFromFile(filename, Path.GetFileName(filename));

                    File.Delete(filename);
                    Log.Write($"archived {filename} to {zipfile}");
                }
            }
        }
    }
}

```

`src/Utilities/PeMetadata.cs`:

```cs
using PeNet;
using PortableExecutable.Extensions;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Reflection.PortableExecutable;

namespace SyscallSummariser.Utilities
{
    class PeMetadata
    {
        internal static ConcurrentDictionary<string, string> originalFilenames = new ConcurrentDictionary<string, string>();
        internal static ConcurrentDictionary<string, string> signers = new ConcurrentDictionary<string, string>();
        private static readonly Dictionary<string, Dictionary<UInt64, string>> _PeExportCache = new Dictionary<string, Dictionary<UInt64, string>>();
        private static readonly Dictionary<string, ImmutableArray<SectionHeader>> _PeSectionCache = new Dictionary<string, ImmutableArray<SectionHeader>>();

        internal static string GetOriginalFilename(string path)
        {
            if (string.IsNullOrEmpty(path)) return null;
            if(!originalFilenames.ContainsKey(path))
                ParsePe(path);
            
            return originalFilenames[path];
        }

        internal static string GetSigner(string path)
        {
            if (string.IsNullOrEmpty(path)) return null;
            if (!signers.ContainsKey(path))
                ParsePe(path);

            return signers[path];
        }

        private static void ParsePe(string path)
        {
            string originalFilename = "<none>";
            string signer = "<unsigned>";
            try
            {
                var peFile = new PeFile(path);
                if (peFile.Resources != null)
                {
                    var vsVersionInfo = peFile.Resources.VsVersionInfo.StringFileInfo.StringTable[0];
                    originalFilename = vsVersionInfo.OriginalFilename;

                    // TODO(jdu) handle catalog signatures etc
                    // For now, just approximate with CompanyName...
                    signer = vsVersionInfo.CompanyName;
                    // var certificate = peFile.Authenticode.SigningCertificate;
                    //if (certificate != null)
                    //{
                    //    signer = certificate.Subject;
                    //}
                }

            }
            catch (AccessViolationException) { } // bug in PeNet?
            catch (FileNotFoundException) { }  // continue
            catch (ArgumentException) { }  // continue
            catch (NullReferenceException) { } // continue
            catch (Exception e) {
                Log.WarnWrite($"PeFile({path}) failed - {e.Message}");
            }

            originalFilenames.TryAdd(path, originalFilename);
            signers.TryAdd(path, signer);
        }


        public static Dictionary<UInt64, string> ExportedFunctions(string path)
        {
            var exportedFunctions = new Dictionary<UInt64, string>();
            var name = Path.GetFileNameWithoutExtension(path);

            // handle file not exists
            try
            {
                using (var peFile = new PEReader(File.Open(new WindowsPath(path).DrivePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))
                    foreach (var export in peFile.ExportedFunctions())
                        if (export.Address != 0) // deprecated/unused export
                                                 // just keep the first export name if multiples exist
                            if (!exportedFunctions.ContainsKey(export.Address))
                                exportedFunctions.Add(export.Address, $"{name}!{export}");
            }
            catch (Exception e)
            {
                Log.WarnWrite($"Exception parsing {path} - {e.Message}");
            }
            return exportedFunctions;
        }

        public static ImmutableArray<SectionHeader> Sections(string path)
        {
            var sections = new ImmutableArray<SectionHeader>();

            // handle file not exists
            try
            {
                using (var peFile = new PEReader(File.Open(new WindowsPath(path).DrivePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))
                {
                    sections = peFile.PEHeaders.SectionHeaders;
                }
            }
            catch (Exception e)
            {
                Log.WarnWrite($"Exception parsing {path} - {e.Message}");
            }
            return sections;
        }

        internal static string GetSectionName(string imagePath, ulong offset)
        {
            var shortName = Path.GetFileNameWithoutExtension(imagePath);
            if (!_PeSectionCache.ContainsKey(imagePath))
            {
                _PeSectionCache.Add(imagePath, Sections(imagePath));
            }
            _PeSectionCache.TryGetValue(imagePath, out var sections);
            foreach (SectionHeader section in sections)
                if ((int)offset >= section.VirtualAddress && (int)offset < section.VirtualAddress + section.VirtualSize)
                    return $"{shortName}/{section.Name}";
            return shortName;
        }

        internal static string GetExportName(string imagePath, ulong offset)
        {
            if (!_PeExportCache.ContainsKey(imagePath))
            {
                _PeExportCache.Add(imagePath, ExportedFunctions(imagePath));
            }
            _PeExportCache.TryGetValue(imagePath, out var exports);
            if (exports.ContainsKey(offset))
                return exports[offset];

            return Path.GetFileNameWithoutExtension(imagePath);
        }
    }
}

```

`src/Utilities/PeReaderExtensions.cs`:

```cs
namespace PortableExecutable.Extensions
{
    using System;
    using System.Diagnostics;
    using System.Reflection.Metadata;
    using System.Reflection.PortableExecutable;
    using System.Text;

        public struct IMAGE_EXPORT_DIRECTORY
    {
        public UInt32 Characteristics;
        public UInt32 TimeDateStamp;
        public UInt16 MajorVersion;
        public UInt16 MinorVersion;
        public UInt32 Name;
        public UInt32 Base;
        public UInt32 NumberOfFunctions;
        public UInt32 NumberOfNames;
        public UInt32 AddressOfFunctions;     // RVA from base of image
        public UInt32 AddressOfNames;         // RVA from base of image
        public UInt32 AddressOfNameOrdinals;  // RVA from base of image
    }
    public class ExportFunction
    {
        public ExportFunction(string name, UInt32 address, UInt16 ordinal)
        {
            Name = name;
            Address = address;
            Ordinal = ordinal;
        }

        public string Name { get; }
        public uint Address { get; }
        public ushort Ordinal { get; }

        public override string ToString()
        {
            return !string.IsNullOrEmpty(Name) ? Name : $"ORDINAL({Ordinal})";
        }
    }

    public static class PeReaderExtensions
    {
        public static ExportFunction[] ExportedFunctions(this PEReader pe)
        {
            var exports = new ExportFunction[0];

            var et = pe.PEHeaders.PEHeader.ExportTableDirectory;
            if (et.Size < 40) // sizeof(IMAGE_EXPORT_DIRECTORY)
                return exports;

            try
            {
                var etReader = pe.GetSectionData(et.RelativeVirtualAddress).GetReader(0, et.Size);
                var exportDirectory = new IMAGE_EXPORT_DIRECTORY
                {
                    Characteristics = etReader.ReadUInt32(),
                    TimeDateStamp = etReader.ReadUInt32(),
                    MajorVersion = etReader.ReadUInt16(),
                    MinorVersion = etReader.ReadUInt16(),
                    Name = etReader.ReadUInt32(),
                    Base = etReader.ReadUInt32(),
                    NumberOfFunctions = etReader.ReadUInt32(),
                    NumberOfNames = etReader.ReadUInt32(),
                    AddressOfFunctions = etReader.ReadUInt32(),
                    AddressOfNames = etReader.ReadUInt32(),
                    AddressOfNameOrdinals = etReader.ReadUInt32()
                };

                exports = new ExportFunction[exportDirectory.NumberOfFunctions];
                var exportAddressTableReader = pe.GetSectionData((int)exportDirectory.AddressOfFunctions).GetReader();
                for (var i = 0; i < exportDirectory.NumberOfFunctions; i++)
                    exports[i] = new ExportFunction(null, exportAddressTableReader.ReadUInt32(), (UInt16)(i + exportDirectory.Base));

                if (exportDirectory.NumberOfNames > 0) // add export names (if they exist)
                {
                    var exportNameTableReader = pe.GetSectionData((int)exportDirectory.AddressOfNames).GetReader();
                    var exportIndexReader = pe.GetSectionData((int)exportDirectory.AddressOfNameOrdinals).GetReader();

                    for (uint i = 0; i < exportDirectory.NumberOfNames; i++)
                    {
                        var nameReader = pe.GetSectionData(exportNameTableReader.ReadInt32()).GetReader();
                        var exportName = nameReader.ReadCString(256);
                        var exportIndex = exportIndexReader.ReadUInt16();

                        exports[exportIndex] = new ExportFunction(exportName, exports[exportIndex].Address, exports[exportIndex].Ordinal);
                    }
                }
            }
            catch (BadImageFormatException) { } // :TODO: log failures (if any)

            Debug.Assert(et.Size > 0 == exports.Length > 0);
            return exports;
        }

        public static string ReadCString(this BlobReader reader, int maxLength)
        {
            var sb = new StringBuilder(maxLength);
            if (reader.RemainingBytes > 0)
            {
                var nextChar = Convert.ToChar(reader.ReadByte());
                while (nextChar != '\0' && reader.RemainingBytes > 0 && sb.Length < maxLength)
                {
                    sb.Append(nextChar);
                    nextChar = Convert.ToChar(reader.ReadByte());
                }
            }

            return sb.ToString();
        }
    }
}

```

`src/Utilities/ProcessUtils.cs`:

```cs
namespace SyscallSummariser {
    using Microsoft.Win32.SafeHandles;
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using Win32;

    class ProcessUtils {

        internal static void Execute(string filename, string arguments)
        {
            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = filename,
                    Arguments = arguments,
                    CreateNoWindow = true,
                    UseShellExecute = false,
                    RedirectStandardOutput = true
                }
            };
            // process.OutputDataReceived += (sender, args) => Log.Write($"[{Path.GetFileNameWithoutExtension(filename)}] {args.Data}");

            Log.Write($"> {Path.GetFileName(filename)} {process.StartInfo.Arguments}");
            process.Start();
            process.BeginOutputReadLine();
            process.WaitForExit();
        }

        internal static WindowsPath GetModuleFileName(SafeProcessHandle hProcess, UIntPtr hModule) {
            // note - GetModuleFileNameEx returns the value from the PEB->LDR_TABLE_ENTRY
            //        this may be the *redirected* path for syswow64 processes
            try {
                var sbModuleFilePath = new StringBuilder(WindowsPath.MAX_PATH);

                if (Psapi.GetModuleFileNameEx(hProcess, hModule, sbModuleFilePath, (uint)sbModuleFilePath.Capacity) != 0)
                    return new WindowsPath(sbModuleFilePath.ToString());
            } catch { }

            return new WindowsPath(string.Empty);
        }

        internal static WindowsPath GetMappedFileName(SafeProcessHandle hProcess, UIntPtr hModule) {
            try {
                var sbModuleFilePath = new StringBuilder(WindowsPath.MAX_PATH);
                if (Psapi.GetMappedFileName(hProcess, hModule, sbModuleFilePath, (uint)sbModuleFilePath.Capacity) != 0)
                    return new WindowsPath(sbModuleFilePath.ToString());
            } catch { }

            return new WindowsPath(string.Empty);
        }

        internal static WindowsPath GetModuleName(SafeProcessHandle hProcess, UIntPtr hModule) {
            try {
                var moduleName = new StringBuilder(WindowsPath.MAX_PATH);
                if (Psapi.GetModuleBaseName(hProcess, hModule, moduleName, (uint)moduleName.Capacity) != 0)
                    return new WindowsPath(moduleName.ToString());
            } catch { }

            return new WindowsPath(string.Empty);
        }

        internal static List<WindowsPath> ModulePaths(Process process) {
            var moduleNames = new List<WindowsPath>();
            try {
                foreach (var module in Modules(process.SafeHandle))
                    moduleNames.Add(GetMappedFileName(process.SafeHandle, module));
            } catch (InvalidOperationException) { } // the process has exited
            catch (Win32Exception) { } // access is denied

            return moduleNames;
        }

        internal static UIntPtr[] Modules(SafeProcessHandle hProcess) {
            var modules = new UIntPtr[0];

            var totalNumberOfModules = 32;
            UIntPtr[] modulePointers;
            int bytesProvided;
            int bytesNeeded;
            try {
                do {
                    totalNumberOfModules *= 2;
                    modulePointers = new UIntPtr[totalNumberOfModules];
                    bytesProvided = UIntPtr.Size * totalNumberOfModules;
                    if (!Psapi.EnumProcessModulesEx(hProcess, modulePointers, bytesProvided, out bytesNeeded, (uint)Psapi.ModuleFilter.ListModulesAll))
                        return modules;
                } while (bytesNeeded > bytesProvided);
                modules = modulePointers;
            } catch (Win32Exception) { }  // access denied
            catch (InvalidOperationException) { } // the process has exited

            return modules;
        }

        internal static string NormaliseSID(string sid) {
            if (sid != null) {
                sid = Regex.Replace(sid, @"^S-1-5-21-\d+-\d+-\d+-(?<rid>5\d\d)", @"S-1-5-21-%domain%-${rid}");
                sid = Regex.Replace(sid, @"^S-1-5-21-\d+-\d+-\d+-\d+", @"S-1-5-21-%domain%-%rid%");
            }
            return sid;
        }
    }
}
```

`src/Utilities/SymbolUtils.cs`:

```cs
using Microsoft.Win32.SafeHandles;
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using static Win32.DbgHelp;
using static Win32.Kernel32;

namespace SyscallSummariser.Utilities {
    class SymbolUtils {
        private static readonly SemaphoreSlim _symbolsMutex = new SemaphoreSlim(1);
        private static bool _initialised = false;       
        private static readonly SafeProcessHandle CurrentProcess = new SafeProcessHandle(new IntPtr(-1), false);
        private static SafeProcessHandle hProcess = null;

        internal static void Initialize() {
            _symbolsMutex.Wait();
            {
                if (!_initialised) {
                    SymSetOptions(SymGetOptions() | 0x00800006);  // SYMOPT_DEFERRED_LOADS | SYMOPT_FAVOR_COMPRESSED | SYMOPT_UNDNAME

                    hProcess = OpenProcess(ProcessDesiredAccess.QueryInformation | ProcessDesiredAccess.VirtualMemoryRead, false, Process.GetCurrentProcess().Id);
                    if (!SymInitialize(hProcess, null, true)) {
                        throw new ApplicationException($"SymInitialize(CurrentProcess) failed - error=0x{(uint)Marshal.GetLastWin32Error():x}");
                    }

                    _initialised = true;
                }
            }
            _symbolsMutex.Release();
        }

        internal static void Cleanup() {
            _symbolsMutex.Wait();
            {
                if (_initialised) {
                    if (!SymCleanup(hProcess)) {
                        Log.WarnWrite($"SymCleanup(CurrentProcess) failed - error=0x{(uint)Marshal.GetLastWin32Error():x}");
                    }
                    hProcess = null;
                    _initialised = false;

                }
                _symbolsMutex.Release();
            }
        }

        internal static string GetCommonSymbol(WindowsPath fullModuleName, ulong offset) {
            var imageBase = GetModuleHandle(fullModuleName?.DrivePath ?? "");
            if (null == fullModuleName || UIntPtr.Zero == imageBase)
                return null;

            if (!_initialised)
                Initialize();

            var address = imageBase.ToUInt64() + offset;
            var symbolInfo = new SYMBOL_INFO();
            symbolInfo.SizeOfStruct = 88;
            symbolInfo.MaxNameLen = 128;  // YOLO
            if (!SymFromAddr(hProcess, address, out var displacement, ref symbolInfo)) {
                Log.WarnWrite($"SymFromAddr({fullModuleName.FileName()}) failed - error=0x{Marshal.GetLastWin32Error():x}");
                return null;
            }
            if (symbolInfo.NameLen > 128)
                throw new ApplicationException($"YOLO'd SymFromAddr() buffer too small");

            if (0 != displacement)
                return null; // exact match not found

            var modBaseName = Path.GetFileNameWithoutExtension(fullModuleName.DrivePath);
            var symbol = symbolInfo.Name.Split('<')[0]; // strip decorations            
            return $"{modBaseName}!{symbol}";
        }

        internal static string GetClosestCommonSymbol(ulong address)
        {
            // TODO - cache!

            if (!_initialised)
                Initialize();

            var symbolInfo = new SYMBOL_INFO();
            symbolInfo.SizeOfStruct = 88;
            symbolInfo.MaxNameLen = 128;  // YOLO
            if (!SymFromAddr(hProcess, address, out var displacement, ref symbolInfo))
            {
                return null;
            }
            if (symbolInfo.NameLen > 128)
                throw new ApplicationException($"YOLO'd SymFromAddr() buffer too small");

            return symbolInfo.Name.Split('<')[0]; // strip decorations
        }


    }
}

```

`src/Utilities/TokenUtils.cs`:

```cs
using Microsoft.Win32.SafeHandles;
using System;
using System.Diagnostics;
using System.Security.Principal;
using static Win32.Advapi;
using static Win32.Ntdll;

namespace SyscallSummariser.Utilities
{
    class TokenUtils
    {
        private static readonly SafeProcessHandle hCurrentProcess = new SafeProcessHandle(new IntPtr(-1), false);
        public static bool ImpersonateSystem()
        {
            // borrow SYSTEM from winlogon.exe
            try {
                // System.Diagnostics will find winlogon and open a handle with PROCESS_ALL_ACCESS for us
                var winlogon = Process.GetProcessesByName("winlogon")[0];

                var hWinlogon = new SafeProcessHandle(winlogon.Handle, false);
                if(!OpenProcessToken(hWinlogon, TOKEN_DUPLICATE, out var hWinlogonToken))
                {
                    Log.ErrorWrite("OpenProcessToken(winlogon, TOKEN_DUPLICATE) failed");
                    return false;
                }
                if (!DuplicateToken(hWinlogonToken, SecurityImpersonation, out var hSystemToken))
                {
                    Log.ErrorWrite("DuplicateToken(winlogon, SecurityImpersonation) failed");
                    return false;
                }
                if(!ImpersonateLoggedOnUser(hSystemToken))
                {
                    Log.ErrorWrite("ImpersonateLoggedOnUser(winlogon) failed");
                    return false;
                }
            }
            catch
            {
                Log.ErrorWrite("failed to open winlogon handle");
                return false;
            }

            return WindowsIdentity.GetCurrent().IsSystem;
        }
    }
}
```

`src/Utilities/Win32.cs`:

```cs
namespace Win32
{
    using Microsoft.Win32.SafeHandles;
    using System;
    using System.Runtime.InteropServices;
    using System.Text;

    internal class Kernel32
    {
        [DllImport("kernel32.dll")]
        internal static extern uint GetProcessId(SafeProcessHandle handle);

        // https://www.pinvoke.net/default.aspx/kernel32.virtualqueryex
        [DllImport("kernel32.dll")]
        internal static extern UInt64 VirtualQueryEx(
            SafeProcessHandle hProcess,
            UIntPtr lpAddress,
            ref MEMORY_BASIC_INFORMATION lpBuffer,
            uint dwLength);

        [Flags]
        internal enum MemoryState : uint
        {
            MEM_COMMIT = 0x1000,
            MEM_RESERVE = 0x2000,
            MEM_FREE = 0x10000,
        }

        [Flags]
        internal enum MemoryType : uint
        {
            Unknown = 0,
            MEM_PRIVATE = 0x20000,
            MEM_MAPPED = 0x40000,
            MEM_IMAGE = 0x1000000,
        }

        internal struct MEMORY_BASIC_INFORMATION
        {
            public UIntPtr BaseAddress;
            public UIntPtr AllocationBase;
            public MemoryProtection AllocationProtect;
            public UIntPtr RegionSize;
            public MemoryState State;
            public MemoryProtection Protect;
            public MemoryType Type;
        }

        [Flags]
        internal enum ProcessDesiredAccess : uint
        {
            Terminate = 0x1,
            CreateThread = 0x2,
            VirtualMemoryOperation = 0x8,
            VirtualMemoryRead = 0x10,
            VirtualMemoryWrite = 0x20,
            DuplicateHandle = 0x40,
            CreateProcess = 0x80,
            SetQuota = 0x100,
            SetInformation = 0x200,
            QueryInformation = 0x400,
            QueryLimitedInformation = 0x1000,
            SetLimitedInformation = 0x2000,
            Synchronize = 0x100000
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        internal static extern SafeProcessHandle OpenProcess(
            ProcessDesiredAccess dwDesiredAccess,
            bool bInheritHandle,
            int dwProcessId);

        [Flags]
        internal enum MemoryProtection : uint
        {
            Unknown = 0,
            EXECUTE = 0x10,
            EXECUTE_READ = 0x20,
            EXECUTE_READWRITE = 0x40,
            EXECUTE_WRITECOPY = 0x80,
            NOACCESS = 0x1,
            READONLY = 0x2,
            READWRITE = 0x4,
            WRITECOPY = 0x8,
            TARGETS_INVALID = 0x40000000,
            GUARD = 0x100,
            NOCACHE = 0x200,
            WRITECOMBINE = 0x400
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        internal static extern bool ReadProcessMemory(
            SafeProcessHandle hProcess,
            UIntPtr lpBaseAddress,
            [Out] byte[] lpBuffer,
            int dwSize,
            out UInt64 lpNumberOfBytesRead);

        [DllImport("Kernel32.dll", CharSet = CharSet.Unicode)]
        internal static extern uint QueryDosDevice(
            [In] string lpDeviceName,
            [Out] StringBuilder lpTargetPath,
            [In] int ucchMax);

        [DllImport("kernel32.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool IsWow64Process(
            [In] SafeProcessHandle processHandle,
            [Out, MarshalAs(UnmanagedType.Bool)] out bool wow64Process);

        [DllImport("kernel32.dll", SetLastError = true)]
        internal static extern IntPtr LocalFree(IntPtr hMem);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern UIntPtr GetModuleHandle(string lpModuleName);

        [DllImport("kernel32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CloseHandle(IntPtr handle);

    }

    internal class Psapi
    {
        [DllImport("psapi.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        internal static extern UInt32 GetMappedFileName(
           SafeProcessHandle hProcess,
           UIntPtr lpv,
           StringBuilder lpFileName,
           UInt32 nSize);

        [StructLayout(LayoutKind.Sequential)]
        internal struct ModuleInformation
        {
            public UIntPtr lpBaseOfDll;
            public uint SizeOfImage;
            public UIntPtr EntryPoint;
        }

        internal enum ModuleFilter
        {
            ListModulesDefault = 0x0,
            ListModules32Bit = 0x01,
            ListModules64Bit = 0x02,
            ListModulesAll = 0x03,
        }

        [DllImport("psapi.dll")]
        internal static extern bool EnumProcessModulesEx(SafeProcessHandle hProcess, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U4)] [In][Out] UIntPtr[] lphModule, int cb, [MarshalAs(UnmanagedType.U4)] out int lpcbNeeded, uint dwFilterFlag);

        [DllImport("psapi.dll")]
        internal static extern uint GetModuleFileNameEx(SafeProcessHandle hProcess, UIntPtr hModule, [Out] StringBuilder lpBaseName, [In] [MarshalAs(UnmanagedType.U4)] uint nSize);

        [DllImport("psapi.dll")]
        internal static extern uint GetModuleBaseName(SafeProcessHandle hProcess, UIntPtr hModule, [Out] StringBuilder lpBaseName, [In] [MarshalAs(UnmanagedType.U4)] uint nSize);

        [DllImport("psapi.dll", SetLastError = true)]
        internal static extern bool GetModuleInformation(SafeProcessHandle hProcess, UIntPtr hModule, out ModuleInformation lpmodinfo, uint cb);

        [DllImport("psapi.dll", SetLastError = true)]
        internal static extern uint GetProcessImageFileName([In] SafeProcessHandle hProcess, [Out] StringBuilder lpImageFileName, [In] [MarshalAs(UnmanagedType.U4)] int nSize);
    }

    internal class Advapi
    {
        internal static uint STANDARD_RIGHTS_READ = 0x00020000;
        internal static uint TOKEN_DUPLICATE = 0x0002;
        internal static uint TOKEN_QUERY = 0x0008;
        internal static uint TOKEN_QUERY_SOURCE = 0x0010;
        internal static uint TOKEN_ADJUST_PRIVILEGES = 0x0020;
        internal static uint TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY);

        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool OpenProcessToken(
            SafeProcessHandle ProcessHandle,
            UInt32 DesiredAccess,
            out SafeAccessTokenHandle TokenHandle);


        // SECURITY_IMPERSONATION_LEVEL
        internal static int SecurityImpersonation = 2;

        [DllImport("advapi32.dll")]
        internal static extern bool DuplicateToken(
            SafeAccessTokenHandle ExistingTokenHandle,
            int ImpersonationLevel,
            out SafeAccessTokenHandle DuplicateTokenHandle
        );

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool ImpersonateLoggedOnUser(
            SafeAccessTokenHandle hToken
        );

        internal enum TOKEN_INFORMATION_CLASS
        {
            TokenUser = 1,
            TokenGroups,
            TokenPrivileges,
            TokenOwner,
            TokenPrimaryGroup,
            TokenDefaultDacl,
            TokenSource,
            TokenType,
            TokenImpersonationLevel,
            TokenStatistics,
            TokenRestrictedSids,
            TokenSessionId,
            TokenGroupsAndPrivileges,
            TokenSessionReference,
            TokenSandBoxInert,
            TokenAuditPolicy,
            TokenOrigin,
            TokenElevationType,
            TokenLinkedToken,
            TokenElevation,
            TokenHasRestrictions,
            TokenAccessInformation,
            TokenVirtualizationAllowed,
            TokenVirtualizationEnabled,
            TokenIntegrityLevel,
            TokenUIAccess,
            TokenMandatoryPolicy,
            TokenLogonSid,
            MaxTokenInfoClass,
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        internal unsafe struct TOKEN_MANDATORY_LABEL  {
            public IntPtr Sid;
            public UInt32 Attributes;
            private fixed UInt64 Reserved[2];
        }

        internal struct TOKEN_ELEVATION
        {
            public UInt32 TokenIsElevated;
        }

        internal struct TOKEN_ELEVATION_TYPE
        {
            public UInt32 TokenElevationType;
        }


        [DllImport("advapi32.dll", SetLastError = true)]
        internal static extern bool GetTokenInformation(SafeHandle TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, ref TOKEN_ELEVATION TokenInformation, uint TokenInformationLength, out uint ReturnLength);

        [DllImport("advapi32.dll", SetLastError = true)]
        internal static extern bool GetTokenInformation(SafeHandle TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, ref TOKEN_ELEVATION_TYPE TokenInformation, uint TokenInformationLength, out uint ReturnLength);

        [DllImport("advapi32.dll", SetLastError = true)]
        internal static extern bool GetTokenInformation(SafeHandle TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, ref TOKEN_MANDATORY_LABEL TokenInformation, uint TokenInformationLength, out uint ReturnLength);

        internal enum SC_SERVICE_TAG_QUERY_TYPE
        {
            ServiceNameFromTagInformation = 1
        }

        internal struct SC_SERVICE_TAG_QUERY
        {
            public UInt32 ProcessId;
            public UInt32 ServiceTag;
            public UInt32 Unknown;
            public IntPtr Buffer;
        }

        [DllImport("advapi32.dll", SetLastError = true)]
        internal static extern int I_QueryTagInformation(IntPtr Unknown, SC_SERVICE_TAG_QUERY_TYPE QueryType, ref SC_SERVICE_TAG_QUERY Query);

    }

    internal class Ntdll
    {
        internal static uint NT_SUCCESS = 0;

        internal static uint SE_SECURITY_PRIVILEGE = 8;
        internal static uint SE_DEBUG_PRIVILEGE = 20;

        [DllImport("ntdll.dll", SetLastError = true)]
        internal static extern UInt32 RtlAdjustPrivilege(
            uint dwPrivilege,
            bool bEnablePrivilege,
            bool bIsThreadPrivilege,
            out UInt32 dwPreviousState);

        internal enum PROCESSINFOCLASS : int
        {
            ProcessBasicInformation = 0,
            ProcessWow64Information = 26,
            ProcessEnableReadWriteVmLogging = 87
        };

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public UIntPtr ExitStatus;
            public UIntPtr PebBaseAddress;
            public UIntPtr AffinityMask;
            public UIntPtr BasePriority;
            public UIntPtr UniqueProcessId;
            public UIntPtr InheritedFromUniqueProcessId;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        internal struct PROCESS_READWRITEVM_LOGGING_INFORMATION
        {
            public byte Flags;
        }

        [DllImport("ntdll.dll", SetLastError = true)]
        internal static extern int NtQueryInformationProcess(
            SafeProcessHandle hProcess,
            PROCESSINFOCLASS pic,
            ref PROCESS_BASIC_INFORMATION pbi,
            int cb,
            out int pSize);

        [DllImport("ntdll.dll", SetLastError = true)]
        internal static extern int NtQueryInformationProcess(
            SafeProcessHandle hProcess,
            PROCESSINFOCLASS pic,
            ref UIntPtr wow64Information,
            int cb,
            out int pSize);

        [DllImport("ntdll.dll", SetLastError = true)]
        internal static extern int NtQueryInformationProcess(
            SafeProcessHandle hProcess,
            PROCESSINFOCLASS pic,
            ref PROCESS_READWRITEVM_LOGGING_INFORMATION prwmli,
            int cb,
            out int pSize);

        [DllImport("ntdll.dll", SetLastError = true)]
        internal static extern int NtSetInformationProcess(
            SafeProcessHandle hProcess,
            PROCESSINFOCLASS pic,
            ref PROCESS_READWRITEVM_LOGGING_INFORMATION prwmli,
            int cb);

        public enum SYSTEM_INFORMATION_CLASS
        {
            SystemProcessInformation = 0x5,
            SystemModuleInformation = 11,
            SystemFullProcessInformation = 0x94
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct SYSTEM_MODULE_INFORMATION
        {
            public UInt32 ModulesCount;
            public SYSTEM_MODULE[] Modules;
        }


        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct SYSTEM_MODULE
        {
            public UIntPtr Reserved1; // BAADF00D
            public UIntPtr Reserved2; // 0
            public IntPtr ImageBase;
            public UInt32 ImageSize;
            public UInt32 Flags;
            public UInt16 LoadOrderIndex;
            public UInt16 InitOrderIndex;
            public UInt16 LoadCount;
            public UInt16 ModuleNameOffset;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
            public Char[] _ImageName;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct SYSTEM_PROCESS_INFORMATION
        {
            internal uint NextEntryOffset;
            internal uint NumberOfThreads;
            private fixed byte Reserved1[48];
            internal UNICODE_STRING ImageName;
            internal int BasePriority;
            internal IntPtr UniqueProcessId;
            private readonly UIntPtr Reserved2;
            internal uint HandleCount;
            internal uint SessionId;
            private readonly UIntPtr Reserved3;
            internal UIntPtr PeakVirtualSize;  // SIZE_T
            internal UIntPtr VirtualSize;
            private readonly uint Reserved4;
            internal UIntPtr PeakWorkingSetSize;  // SIZE_T
            internal UIntPtr WorkingSetSize;  // SIZE_T
            private readonly UIntPtr Reserved5;
            internal UIntPtr QuotaPagedPoolUsage;  // SIZE_T
            private readonly UIntPtr Reserved6;
            internal UIntPtr QuotaNonPagedPoolUsage;  // SIZE_T
            internal UIntPtr PagefileUsage;  // SIZE_T
            internal UIntPtr PeakPagefileUsage;  // SIZE_T
            internal UIntPtr PrivatePageCount;  // SIZE_T
            private fixed long Reserved7[6];
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct SYSTEM_THREAD_INFORMATION
        {
            private fixed long Reserved1[3];
            private readonly uint Reserved2;
            internal IntPtr StartAddress;
            internal CLIENT_ID ClientId;
            internal int Priority;
            internal int BasePriority;
            private readonly uint Reserved3;
            internal uint ThreadState;
            internal uint WaitReason;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct SYSTEM_EXTENDED_THREAD_INFORMATION
        {
            internal SYSTEM_THREAD_INFORMATION ThreadInfo;
            internal IntPtr StackBase;
            internal IntPtr StackLimit;
            internal IntPtr Win32StartAddress;
            internal IntPtr TebBase;
            private fixed long Reserved[3];
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct CLIENT_ID
        {
            internal IntPtr UniqueProcess;
            internal IntPtr UniqueThread;
        }

        [DllImport("ntdll.dll", SetLastError = true)]
        public static extern int NtQuerySystemInformation(
            SYSTEM_INFORMATION_CLASS SystemInformationClass,
            IntPtr SystemInformation,
            int SystemInformationLength,
            out uint ReturnLength);

        internal enum OBJECT_INFORMATION_CLASS : int
        {
            ObjectBasicInformation = 0,
            ObjectNameInformation = 1,
            ObjectTypeInformation = 2,
            ObjectAllTypesInformation = 3,
            ObjectHandleInformation = 4
        }

        [StructLayout(LayoutKind.Explicit)]
        internal struct OBJECT_TYPES_INFORMATION
        {
            [FieldOffset(0)] public UInt32 NumberOfTypes;
            [FieldOffset(0)] private IntPtr _alignment;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct UNICODE_STRING
        {
            public UInt16 Length;
            public UInt16 MaximumLength;
            public IntPtr Buffer;
        }


        [StructLayout(LayoutKind.Sequential)]
        internal struct GENERIC_MAPPING
        {
            public UInt32 GenericRead;
            public UInt32 GenericWrite;
            public UInt32 GenericExecute;
            public UInt32 GenericAll;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        internal struct OBJECT_TYPE_INFORMATION
        {
            public UNICODE_STRING TypeName;
            public UInt32 TotalNumberOfObjects;
            public UInt32 TotalNumberOfHandles;
            public UInt32 TotalPagedPoolUsage;
            public UInt32 TotalNonPagedPoolUsage;
            public UInt32 TotalNamePoolUsage;
            public UInt32 TotalHandleTableUsage;
            public UInt32 HighWaterNumberOfObjects;
            public UInt32 HighWaterNumberOfHandles;
            public UInt32 HighWaterPagedPoolUsage;
            public UInt32 HighWaterNonPagedPoolUsage;
            public UInt32 HighWaterNamePoolUsage;
            public UInt32 HighWaterHandleTableUsage;
            public UInt32 InvalidAttributes;
            public GENERIC_MAPPING GenericMapping;
            public UInt32 ValidAccessMask;
            public Byte SecurityRequired; // BOOLEAN
            public Byte MaintainHandleCount; // BOOLEAN
            public Byte TypeIndex;
            public Byte ReservedByte;
            public UInt32 PoolType;
            public UInt32 DefaultPagedPoolCharge;
            public UInt32 DefaultNonPagedPoolCharge;
        }

        [DllImport("ntdll.dll")]
        public static extern int NtQueryObject(
            IntPtr objectHandle,
            OBJECT_INFORMATION_CLASS informationClass,
            IntPtr informationPtr,
            uint informationLength,
            ref uint returnLength);
    }

    internal class DbgHelp
    {
        [DllImport("Dbghelp.dll")]
        public static extern int SymSetOptions(
            int SymOptions);

        [DllImport("Dbghelp.dll")]
        public static extern int SymGetOptions();

        [DllImport("Dbghelp.dll", SetLastError = true)]
        public static extern bool SymInitialize(
            SafeHandle hProcess,
            StringBuilder UserSearchPath,
            bool fInvadeProcess);

        [DllImport("Dbghelp.dll", SetLastError = true)]
        public static extern bool SymCleanup(
            SafeHandle hProcess);

        [DllImport("dbghelp.dll", SetLastError = true)]
        public static extern UIntPtr SymLoadModule64(
            SafeHandle hProcess,
            IntPtr hFile,
            string ImageName,
            string ModuleName,
            UIntPtr BaseOfDll,
            uint SizeOfDll);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal struct SYMBOL_INFO
        {
            public UInt32 SizeOfStruct;
            public UInt32 TypeIndex;        // Type Index of symbol
            public UInt64 Reserved;
            public UInt64 Reserved2;
            public UInt32 Index;
            public UInt32 Size;
            public UInt64 ModBase;          // Base Address of module comtaining this symbol
            public UInt32 Flags;
            public UInt64 Value;            // Value of symbol, ValuePresent should be 1
            public UInt64 Address;          // Address of symbol including base address of module
            public UInt32 Register;         // register holding value or pointer to value
            public UInt32 Scope;            // scope of the symbol
            public UInt32 Tag;              // pdb classification
            public UInt32 NameLen;          // Actual length of name
            public UInt32 MaxNameLen;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string Name;             // Name of symbol
        }

        [DllImport("Dbghelp.dll", SetLastError = true)]
        public static extern bool SymFromAddr(
            SafeProcessHandle hProcess,
            UInt64 Address,
            out UInt64 Displacement,
            ref SYMBOL_INFO Symbol);
    }
}

```

`src/app.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
		<requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" /> <!-- Windows 10 -->
    </application>
  </compatibility>

  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
        <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
    </windowsSettings>
  </application>
</assembly>

```

`src/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Microsoft.O365.Security.Native.ETW" version="4.2.3" targetFramework="net48" />
  <package id="Newtonsoft.Json" version="13.0.1" targetFramework="net48" />
  <package id="PeNet" version="2.9.7" targetFramework="net48" />
  <package id="PeNet.Asn1" version="2.0.0" targetFramework="net48" />
  <package id="System.Buffers" version="4.5.1" targetFramework="net472" />
  <package id="System.Collections.Immutable" version="6.0.0" targetFramework="net48" />
  <package id="System.Memory" version="4.5.4" targetFramework="net472" />
  <package id="System.Numerics.Vectors" version="4.5.0" targetFramework="net472" />
  <package id="System.Reflection.Metadata" version="6.0.1" targetFramework="net48" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Pkcs" version="6.0.0" targetFramework="net48" />
  <package id="Validation" version="2.5.51" targetFramework="net48" />
  <package id="xunit.abstractions" version="2.0.3" targetFramework="net472" />
  <package id="xunit.extensibility.core" version="2.4.1" targetFramework="net472" />
  <package id="xunit.extensibility.execution" version="2.4.1" targetFramework="net472" />
  <package id="Xunit.SkippableFact" version="1.4.13" targetFramework="net472" />
</packages>
```