Project Path: arc_gmh5225_NullBase_s0ht0b0p

Source Tree:

```txt
arc_gmh5225_NullBase_s0ht0b0p
├── LICENSE
├── NullBase
│   ├── Cheat.cpp
│   ├── Entity.cpp
│   ├── Entity.h
│   ├── Includes.h
│   ├── LocalPlayer.cpp
│   ├── LocalPlayer.h
│   ├── Math.cpp
│   ├── Math.h
│   ├── NullBase.vcxproj
│   ├── NullBase.vcxproj.filters
│   ├── NullBase.vcxproj.user
│   ├── NullMemory.cpp
│   ├── NullMemory.h
│   ├── Offsets.hpp
│   ├── W2S.h
│   └── Xor.h
├── NullBase.VC.db
├── NullBase.sln
└── README.md

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 Null Terminator

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`NullBase.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NullBase", "NullBase\NullBase.vcxproj", "{258BBD17-9C54-4005-888B-97967C3E693D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{258BBD17-9C54-4005-888B-97967C3E693D}.Debug|x64.ActiveCfg = Debug|x64
		{258BBD17-9C54-4005-888B-97967C3E693D}.Debug|x64.Build.0 = Debug|x64
		{258BBD17-9C54-4005-888B-97967C3E693D}.Debug|x86.ActiveCfg = Debug|Win32
		{258BBD17-9C54-4005-888B-97967C3E693D}.Debug|x86.Build.0 = Debug|Win32
		{258BBD17-9C54-4005-888B-97967C3E693D}.Release|x64.ActiveCfg = Release|x64
		{258BBD17-9C54-4005-888B-97967C3E693D}.Release|x64.Build.0 = Release|x64
		{258BBD17-9C54-4005-888B-97967C3E693D}.Release|x86.ActiveCfg = Release|Win32
		{258BBD17-9C54-4005-888B-97967C3E693D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`NullBase/Cheat.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Copyright 2018 Null Terminator																								  //
//
Permission is hereby granted, free of charge, to any person																		  //
obtaining a copy of this software and associated documentation                                                                    //
files(the "Software"), to deal in the Software without restriction,                                                               //
including without limitation the rights to use, copy, modify, merge,                                                              //
publish, distribute, sublicense, and/or sell copies of the Software,                                                              //
and to permit persons to whom the Software is furnished to do so,                                                                 //
subject to the following conditions :                                                                                             //
																																  //
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.    //
																																  //
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,																	  //
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF																  //
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.                                                            //
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                                       //
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                                             //
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR                                                             //
THE USE OR OTHER DEALINGS IN THE SOFTWARE.																						  //
*/																																  //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
NEED SOME HELP? FULL TUTORIALS ON HOW TO USE THIS BASE AND CODE CHEATS ON MY YOUTUBE CHANNEL:
Null Terminator
https://www.youtube.com/channel/UCZF93Qrt6yMAabRnlND4YsQ

STAY UPDATED ON THIS PROJECT AS IT IS A WORK IN PROGRESS
GITHUB LINK:
https://github.com/NullTerminatorr/NullBase
*/

#include "Includes.h"

//Flags
#define FL_ON_GROUND                     257
#define FL_ON_GROUND_CROUCHED             263
#define FL_IN_AIR_STAND                    256
#define FL_IN_AIR_MOVING_TO_STAND         258
#define FL_ON_GROUND_MOVING_TO_STAND     259
#define FL_IN_AIR_MOVING_TO_CROUCH         260
#define FL_ON_GROUND_MOVING_TO_CROUCH     261
#define FL_IN_AIR_CROUCHED                 262
#define FL_IN_WATER                     1280
#define FL_IN_PUDDLE                     1281
#define FL_IN_WATER_CROUCHED             1286
#define FL_IN_PUDDLE_CROUCHED             1287
#define FL_PARTIALGROUND (1 << 18)

//Team IDs
#define TEAM_ID_GOTV 1
#define TEAM_ID_T 2
#define TEAM_ID_CT 3

void bhop()
{
	//If we're holding space and the we're on the ground
	if (GetAsyncKeyState(VK_SPACE) && LocalPlayer::getLocalFlags() == FL_ON_GROUND)
	{
		//Jump!
		LocalPlayer::forceJump();
	}
}

int main()
{
	init();
	LocalPlayer::setLocalPlayer();
	
	while (!GetAsyncKeyState(VK_F10))
	{
		bhop();

		Sleep(1);
	}

	//Close handle to csgo.exe to prevent memory leaks
	CloseHandle(hProc);
}

```

`NullBase/Entity.cpp`:

```cpp
#include <windows.h>
#include "NullMemory.h"
#include "Entity.h"
#include "Offsets.hpp"

DWORD Entity::getEntBase(int index)
{
	return rpm<DWORD>(baseAddress + offs::dwEntityList + (index * 0x10));
}

int	Entity::getEntHp(DWORD playerBase)
{
	return rpm<int>(playerBase + netvars::m_iHealth);
}

bool Entity::isAlive(DWORD playerBase)
{
	if (getEntHp(playerBase) > 0 && getEntHp(playerBase) <= 100)
		return true;
	return false;
}

int	Entity::getEntTeam(DWORD playerBase)
{
	return rpm<int>(playerBase + netvars::m_iTeamNum);
}

int Entity::getGlowIndex(DWORD playerBase)
{
	return rpm<int>(playerBase + netvars::m_iGlowIndex);
}

DWORD Entity::getGlowObj()
{
	return rpm<DWORD>(baseAddress + offs::dwGlowObjectManager);
}

bool Entity::isValid(DWORD playerBase)
{
	auto dormant = rpm<bool>(playerBase + offs::m_bDormant);
	if ((Entity::isAlive(playerBase) && Entity::getEntTeam(playerBase) != 0) && !dormant)
		return true;
	return false;
}

//TODO: MINIMISE WPM CALLS HERE BY USING A GLOW STRUCT 
void Entity::glowEsp(DWORD glowObj, int glowInd, float r, float g, float b, float a)
{
	wpm<float>(r / 255, (glowObj + ((glowInd * 0x38) + 0x4)));
	wpm<float>(g / 255, (glowObj + ((glowInd * 0x38) + 0x8)));
	wpm<float>(b / 255, (glowObj + ((glowInd * 0x38) + 0xC)));
	wpm<float>(a / 255, (glowObj + ((glowInd * 0x38) + 0x10)));
	wpm<bool>(true, (glowObj + ((glowInd * 0x38) + 0x24)));
	wpm<bool>(false, (glowObj + ((glowInd * 0x38) + 0x25)));
}

bool Entity::getSpotted(DWORD playerBase)
{
	return rpm<bool>(playerBase + netvars::m_bSpotted);
}

void Entity::setSpotted(DWORD playerBase, bool val)
{
	wpm<bool>(val, playerBase + netvars::m_bSpotted);
}

D3DXVECTOR3	Entity::getEntPos(DWORD playerBase)
{
	return rpm<D3DXVECTOR3>(playerBase + netvars::m_vecOrigin);
}

char* Entity::getEntName(DWORD playerBase)
{
	return rpm<char*>(playerBase + netvars::m_szCustomName);
}

DWORD Entity::getEntBoneMatrix(DWORD playerBase)
{
	return rpm<DWORD>(playerBase + netvars::m_dwBoneMatrix);
}

D3DXVECTOR3 Entity::getEntEyePos(DWORD playerBase)
{
	return ((Entity::getEntPos(playerBase)) + (rpm<D3DXVECTOR3>(playerBase + netvars::m_vecViewOffset)));
}

bool Entity::getEntScoped(DWORD playerBase)
{
	return rpm<bool>(playerBase + netvars::m_bIsScoped);
}

bool Entity::getEntDefusing(DWORD playerBase)
{
	return rpm<bool>(playerBase + netvars::m_bIsDefusing);
}

bool Entity::getEntReloading(DWORD playerBase)
{
	return rpm<bool>(playerBase + netvars::m_bInReload);
}

bool Entity::getEntHelmet(DWORD playerBase)
{
	return rpm<bool>(playerBase + netvars::m_bHasHelmet);
}

bool Entity::getEntDefuser(DWORD playerBase)
{
	return rpm<bool>(playerBase + netvars::m_bHasDefuser);
}

bool Entity::getEntImmunity(DWORD playerBase)
{
	return rpm<bool>(playerBase + netvars::m_bGunGameImmunity);
}

DWORD Entity::getActiveWeapon(DWORD playerBase)
{
	DWORD WeaponIndex = rpm<DWORD>(playerBase + netvars::m_hActiveWeapon) & 0xFFF;
	return rpm<DWORD>((baseAddress + offs::dwEntityList + WeaponIndex * 0x10) - 0x10);
}

//Uses ClassID
bool Entity::isWeaponNonAim(int classID)
{
	if (classID == CKnife || classID == CKnifeGG || classID == CFlashbang || classID == CHEGrenade || classID == CSmokeGrenade
		|| classID == CMolotovGrenade || classID == CDecoyGrenade || classID == CIncendiaryGrenade || classID == CC4)
		return true;
	return false;
}

//Uses iItemDefinitionIndex
bool Entity::isWeaponNonAim2(int iWeaponID)
{
	if (iWeaponID == weapon_knife || iWeaponID == weapon_knifegg || iWeaponID == weapon_flashbang || iWeaponID == weapon_hegrenade || iWeaponID == weapon_smokegrenade
		|| iWeaponID == weapon_molotov || iWeaponID == weapon_decoy || iWeaponID == weapon_c4 || iWeaponID == weapon_incgrenade)
		return true;
	return false;
}

//Uses ClassID
bool Entity::isWeaponPistol(int classID)
{
	if (classID == CDEagle || classID == CWeaponElite || classID == CWeaponFiveSeven || classID == CWeaponGlock
		|| classID == CWeaponP228 || classID == CWeaponUSP || classID == CWeaponTec9 || classID == CWeaponTaser || classID == CWeaponHKP2000 || classID == CWeaponP250)
		return true;

	return false;
}

//Uses ClassID
bool Entity::isWeaponSniper(int classID)
{
	if (classID == CWeaponAWP || classID == CWeaponSSG08 || classID == CWeaponG3SG1 || classID == CWeaponSCAR20)
		return true;

	return false;
}

int	Entity::getEntClassID(DWORD entity)
{
	int one = rpm<int>(entity + 0x8);
	int two = rpm<int>(one + 2 * 0x4);
	int three = rpm<int>(two + 0x1);
	return rpm<int>(three + 0x14);
}

D3DXVECTOR3	Entity::getEntBonePos(DWORD playerBase, int boneID)
{
	Matrix3x4_t boneMatrix = rpm<Matrix3x4_t>(Entity::getEntBoneMatrix(playerBase) + boneID * 0x30);

	return{
		boneMatrix.Matrix[0][3],
		boneMatrix.Matrix[1][3],
		boneMatrix.Matrix[2][3]
	};
}

int Entity::getEntAmmo(DWORD playerBase)
{
	auto weapon = Entity::getActiveWeapon(playerBase);
	return rpm<int>(weapon + netvars::m_iClip1);
}
```

`NullBase/Entity.h`:

```h
#pragma once

#include <windows.h>

//Just for vector and matrix shit (im lazy)
#include <d3d9.h>
#include <d3dx9.h>

//SHIT
typedef struct {
	float Matrix[3][4];
} Matrix3x4_t;

//Entity class IDs (GetClientClasssID())
enum ClassID
{
	CAI_BaseNPC,
	CAK47,
	CBaseAnimating,
	CBaseAnimatingOverlay,
	CBaseAttributableItem,
	CBaseButton,
	CBaseCombatCharacter,
	CBaseCombatWeapon,
	CBaseCSGrenade,
	CBaseCSGrenadeProjectile,
	CBaseDoor,
	CBaseEntity,
	CBaseFlex,
	CBaseGrenade,
	CBaseParticleEntity,
	CBasePlayer,
	CBasePropDoor,
	CBaseTeamObjectiveResource,
	CBaseTempEntity,
	CBaseToggle,
	CBaseTrigger,
	CBaseViewModel,
	CBaseVPhysicsTrigger,
	CBaseWeaponWorldModel,
	CBeam,
	CBeamSpotlight,
	CBoneFollower,
	CBreakableProp,
	CBreakableSurface,
	CC4,
	CCascadeLight,
	CChicken,
	CColorCorrection,
	CColorCorrectionVolume,
	CCSGameRulesProxy,
	CCSPlayer,
	CCSPlayerResource,
	CCSRagdoll,
	CCSTeam,
	CDEagle,
	CDecoyGrenade,
	CDecoyProjectile,
	CDynamicLight,
	CDynamicProp,
	CEconEntity,
	CEconWearable,
	CEmbers,
	CEntityDissolve,
	CEntityFlame,
	CEntityFreezing,
	CEntityParticleTrail,
	CEnvAmbientLight,
	CEnvDetailController,
	CEnvDOFController,
	CEnvParticleScript,
	CEnvProjectedTexture,
	CEnvQuadraticBeam,
	CEnvScreenEffect,
	CEnvScreenOverlay,
	CEnvTonemapController,
	CEnvWind,
	CFEPlayerDecal,
	CFireCrackerBlast,
	CFireSmoke,
	CFireTrail,
	CFish,
	CFlashbang,
	CFogController,
	CFootstepControl,
	CFunc_Dust,
	CFunc_LOD,
	CFuncAreaPortalWindow,
	CFuncBrush,
	CFuncConveyor,
	CFuncLadder,
	CFuncMonitor,
	CFuncMoveLinear,
	CFuncOccluder,
	CFuncReflectiveGlass,
	CFuncRotating,
	CFuncSmokeVolume,
	CFuncTrackTrain,
	CGameRulesProxy,
	CHandleTest,
	CHEGrenade,
	CHostage,
	CHostageCarriableProp,
	CIncendiaryGrenade,
	CInferno,
	CInfoLadderDismount,
	CInfoOverlayAccessor,
	CItem_Healthshot,
	CItemDogtags,
	CKnife,
	CKnifeGG,
	CLightGlow,
	CMaterialModifyControl,
	CMolotovGrenade,
	CMolotovProjectile,
	CMovieDisplay,
	CParticleFire,
	CParticlePerformanceMonitor,
	CParticleSystem,
	CPhysBox,
	CPhysBoxMultiplayer,
	CPhysicsProp,
	CPhysicsPropMultiplayer,
	CPhysMagnet,
	CPlantedC4,
	CPlasma,
	CPlayerResource,
	CPointCamera,
	CPointCommentaryNode,
	CPointWorldText,
	CPoseController,
	CPostProcessController,
	CPrecipitation,
	CPrecipitationBlocker,
	CPredictedViewModel,
	CProp_Hallucination,
	CPropDoorRotating,
	CPropJeep,
	CPropVehicleDriveable,
	CRagdollManager,
	CRagdollProp,
	CRagdollPropAttached,
	CRopeKeyframe,
	CSCAR17,
	CSceneEntity,
	CSensorGrenade,
	CSensorGrenadeProjectile,
	CShadowControl,
	CSlideshowDisplay,
	CSmokeGrenade,
	CSmokeGrenadeProjectile,
	CSmokeStack,
	CSpatialEntity,
	CSpotlightEnd,
	CSprite,
	CSpriteOriented,
	CSpriteTrail,
	CStatueProp,
	CSteamJet,
	CSun,
	CSunlightShadowControl,
	CTeam,
	CTeamplayRoundBasedRulesProxy,
	CTEArmorRicochet,
	CTEBaseBeam,
	CTEBeamEntPoint,
	CTEBeamEnts,
	CTEBeamFollow,
	CTEBeamLaser,
	CTEBeamPoints,
	CTEBeamRing,
	CTEBeamRingPoint,
	CTEBeamSpline,
	CTEBloodSprite,
	CTEBloodStream,
	CTEBreakModel,
	CTEBSPDecal,
	CTEBubbles,
	CTEBubbleTrail,
	CTEClientProjectile,
	CTEDecal,
	CTEDust,
	CTEDynamicLight,
	CTEEffectDispatch,
	CTEEnergySplash,
	CTEExplosion,
	CTEFireBullets,
	CTEFizz,
	CTEFootprintDecal,
	CTEFoundryHelpers,
	CTEGaussExplosion,
	CTEGlowSprite,
	CTEImpact,
	CTEKillPlayerAttachments,
	CTELargeFunnel,
	CTEMetalSparks,
	CTEMuzzleFlash,
	CTEParticleSystem,
	CTEPhysicsProp,
	CTEPlantBomb,
	CTEPlayerAnimEvent,
	CTEPlayerDecal,
	CTEProjectedDecal,
	CTERadioIcon,
	CTEShatterSurface,
	CTEShowLine,
	CTesla,
	CTESmoke,
	CTESparks,
	CTESprite,
	CTESpriteSpray,
	CTest_ProxyToggle_Networkable,
	CTestTraceline,
	CTEWorldDecal,
	CTriggerPlayerMovement,
	CTriggerSoundOperator,
	CVGuiScreen,
	CVoteController,
	CWaterBullet,
	CWaterLODControl,
	CWeaponAug,
	CWeaponAWP,
	CWeaponBaseItem,
	CWeaponBizon,
	CWeaponCSBase,
	CWeaponCSBaseGun,
	CWeaponCycler,
	CWeaponElite,
	CWeaponFamas,
	CWeaponFiveSeven,
	CWeaponG3SG1,
	CWeaponGalil,
	CWeaponGalilAR,
	CWeaponGlock,
	CWeaponHKP2000,
	CWeaponM249,
	CWeaponM3,
	CWeaponM4A1,
	CWeaponMAC10,
	CWeaponMag7,
	CWeaponMP5Navy,
	CWeaponMP7,
	CWeaponMP9,
	CWeaponNegev,
	CWeaponNOVA,
	CWeaponP228,
	CWeaponP250,
	CWeaponP90,
	CWeaponSawedoff,
	CWeaponSCAR20,
	CWeaponScout,
	CWeaponSG550,
	CWeaponSG552,
	CWeaponSG556,
	CWeaponSSG08,
	CWeaponTaser,
	CWeaponTec9,
	CWeaponTMP,
	CWeaponUMP45,
	CWeaponUSP,
	CWeaponXM1014,
	CWorld,
	CWorldVguiText,
	DustTrail,
	MovieExplosion,
	ParticleSmokeGrenade,
	RocketTrail,
	SmokeTrail,
	SporeExplosion,
	SporeTrail,
};

//iItemDefinitionIndex
enum CSGO_Weapon_ID
{
	weapon_none,
	weapon_deagle,
	weapon_elite,
	weapon_fiveseven,
	weapon_glock,
	weapon_p228,
	weapon_usp,
	weapon_ak47,
	weapon_aug,
	weapon_awp,
	weapon_famas,
	weapon_g3sg1,
	weapon_galil,
	weapon_galilar,
	weapon_m249,
	weapon_m3,
	weapon_m4a1,
	weapon_mac10,
	weapon_mp5navy,
	weapon_p90,
	weapon_scout,
	weapon_sg550,
	weapon_sg552,
	weapon_tmp,
	weapon_ump45,
	weapon_xm1014,
	weapon_bizon,
	weapon_mag7,
	weapon_negev,
	weapon_sawedoff,
	weapon_tec9,
	weapon_taser,
	weapon_hkp2000,
	weapon_mp7,
	weapon_mp9,
	weapon_nova,
	weapon_p250,
	weapon_scar17,
	weapon_scar20,
	weapon_sg556,
	weapon_ssg08,
	weapon_knifegg,
	weapon_knife,
	weapon_flashbang,
	weapon_hegrenade,
	weapon_smokegrenade,
	weapon_molotov,
	weapon_decoy,
	weapon_incgrenade,
	weapon_c4,
	weapon_revolver,
	weapon_cz,
	weapon_knife_t
};

//Actual shit
namespace Entity
{
	//Entity void function
	extern void				setSpotted(DWORD playerBase, bool val);							//Set the spotted bool (Red dot on radar, its a bool so True (1) = Spotted and False (0) = Not spotted)
	extern void				glowEsp(DWORD glowObj, int glowInd,
									float r, float g, float b, float a);					//Sets the glow on desired object with given colour

	//Entity return functions
	extern DWORD			getEntBase(int index);											//Get the base address of the entity at provided index
	extern bool				isAlive(DWORD playerBase);										//Check if entity is alive 
	extern bool				isValid(DWORD playerBase);										//Checks if entity is a player
	extern int				getEntHp(DWORD playerBase);										//Return the health of the entity
	extern int				getEntTeam(DWORD playerBase);									//Get the team ID of the entity
	extern bool				getSpotted(DWORD playerBase);									//Get the spotted bool (Red dot on radar, its a bool so 1 = Spotted and 0 = Not spotted)
	extern int				getGlowIndex(DWORD playerBase);									//Get the glow index of the entity
	extern DWORD			getGlowObj();													//Get the pointer to glow object
	extern D3DXVECTOR3		getEntPos(DWORD playerBase);									//Get the entity pos
	extern char*			getEntName(DWORD playerBase);									//Get the entity name
	extern D3DXVECTOR3		getEntEyePos(DWORD playerBase);									//Get the entity bone pos
	extern DWORD		    getEntBoneMatrix(DWORD playerBase);								//Get the entity bone matrix
	extern bool				getEntScoped(DWORD playerBase);									//Get the entity scope state - true if they are scoped
	extern bool				getEntDefusing(DWORD playerBase);								//Get the entity defusing state - true if they are defusing
	extern bool				getEntReloading(DWORD playerBase);								//Get the entity reloading state - true if they are reloading
	extern bool				getEntHelmet(DWORD playerBase);									//Get the entity helmet state - true if they have one
	extern bool				getEntDefuser(DWORD playerBase);								//Get the entity defuser state - true if they have one
	extern bool				getEntImmunity(DWORD playerBase);								//Get the entity immunity state - true if they are in gun game immunity
	extern DWORD			getActiveWeapon(DWORD playerBase);								//Get the base address of their active weapon entity
	extern bool				isWeaponPistol(int classID);									//Get the weapon id and see if it is a pistol
	extern bool				isWeaponSniper(int iWeaponID);									//Get the weapon id and see if it is a sniper
	extern bool				isWeaponNonAim(int iWeaponID);									//Get the weapon id and see if it is aimbot worthy
	extern bool				isWeaponNonAim2(int iWeaponID);									//Get the weapon id and see if it is aimbot worthy
	extern int				getEntClassID(DWORD entity);									//Get the entity class id
	extern D3DXVECTOR3		getEntBonePos(DWORD playerBase, int boneID);					//Get the position of the desired bone of the entity
	extern int				getEntAmmo(DWORD playerBase);
}
```

`NullBase/Includes.h`:

```h
#pragma once
#include <windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <string>
#include "Offsets.hpp"
#include "Entity.h"
#include "LocalPlayer.h"
#include "NullMemory.h"
#include "Xor.h"
#include "W2S.h"
#include "Math.h"
#include <corecrt_math_defines.h>"


```

`NullBase/LocalPlayer.cpp`:

```cpp
#include "includes.h"

DWORD LocalPlayer::LocalBaseaddress = 0;

DWORD LocalPlayer::getLocalPlayer()
{
	return LocalPlayer::LocalBaseaddress;
}

void LocalPlayer::setLocalPlayer()
{
	LocalPlayer::LocalBaseaddress = rpm<DWORD>(baseAddress + offs::dwLocalPlayer);
}

int LocalPlayer::getLocalFlags()
{
	return rpm<int>(LocalPlayer::getLocalPlayer() + netvars::m_fFlags);
}

int LocalPlayer::getLocalHealth()
{
	return rpm<int>(LocalPlayer::getLocalPlayer() + netvars::m_iHealth);
}

int LocalPlayer::getLocalTeam()
{
	return rpm<int>(LocalPlayer::getLocalPlayer() + netvars::m_iTeamNum);
}

void LocalPlayer::forceJump(int waitTime)
{
	wpm<int>(1, baseAddress + offs::dwForceJump);
	Sleep(waitTime);
	wpm<int>(0, baseAddress + offs::dwForceJump);
}

int LocalPlayer::getLocalCrossID()
{
	auto temp = rpm<int>(LocalPlayer::getLocalPlayer() + netvars::m_iCrosshairId);
	if (temp <= 0 || temp > 32)
		return -1;
	return temp;
}

D3DXVECTOR3 LocalPlayer::getLocalPos()
{
	return rpm<D3DXVECTOR3>(LocalPlayer::getLocalPlayer() + netvars::m_vecOrigin);
}

D3DXMATRIX	LocalPlayer::getLocalViewMatrix()
{
	return rpm<D3DXMATRIX>(baseAddress + offs::dwViewMatrix);
}

D3DXVECTOR3 LocalPlayer::getLocalViewAngles()
{
	return rpm<D3DXVECTOR3>(clientState + offs::dwClientState_ViewAngles);
}

void LocalPlayer::setLocalViewAngles(D3DXVECTOR3 angles)
{
	wpm<D3DXVECTOR3>(angles, clientState + offs::dwClientState_ViewAngles);
}

D3DXVECTOR3 LocalPlayer::getLocalPunchAngles()
{
	return rpm<D3DXVECTOR3>(LocalPlayer::getLocalPlayer() + netvars::m_aimPunchAngle);
}
```

`NullBase/LocalPlayer.h`:

```h
#pragma once

#include <windows.h>

//Just for vector and matrix shit (im lazy)
#include <d3d9.h>
#include <d3dx9.h>

namespace LocalPlayer
{
	//Localplayer return functions
	extern DWORD			getLocalPlayer();												//Get the local player base address
	extern int				getLocalFlags();												//Get the local player flags
	extern int				getLocalHealth();												//Get the local player health
	extern int				getLocalCrossID();												//Get the local player crosshair ID
	extern int				getLocalTeam();													//Get the local player team ID
	extern D3DXVECTOR3		getLocalPos();													//Get the local player pos
	extern D3DXMATRIX		getLocalViewMatrix();											//Get the view matrix
	extern D3DXVECTOR3		getLocalViewAngles();											//Get the local player view angles
	extern D3DXVECTOR3		getLocalPunchAngles();											//Get the local player punch angles (recoil)

																							//Void functions 
	extern void				forceJump(int waitTime = 35);									//Force the local player to jump
	extern void				setLocalPlayer();												//Set the local player base address
	extern void				setLocalViewAngles(D3DXVECTOR3 angles);							//Set the local player view angles

	extern DWORD			LocalBaseaddress;												//Localplayer base address
}
```

`NullBase/Math.cpp`:

```cpp
#include "Includes.h"
#include <intrin.h>

D3DXVECTOR3 CalcAngle(register const D3DXVECTOR3& src, register const D3DXVECTOR3& dst)
{
	//square root func faster than normal func youd use
	const auto sqrtss = [](float in) {
		__m128 reg = _mm_load_ss(&in);
		return _mm_mul_ss(reg, _mm_rsqrt_ss(reg)).m128_f32[0];
	};


	D3DXVECTOR3 angles;

	//getting delta between source and destination vectors
	D3DXVECTOR3 delta = src - dst;

	//finding the hypoteneuse using pythagoras theorem a squared + b squared = c squared
	//this gives us the vector to our enemy
	float hyp = sqrtss(delta.x * delta.x + delta.y * delta.y);

	//now we need to find the angle needed to aim at the vector (aim angles)
	angles.x = asinf(delta.z / hyp)		* (180.0f / M_PI);
	angles.y = atanf(delta.y / delta.x)	* (180.0f / M_PI) + !((*(DWORD*)&delta.x) >> 31 & 1) * 180.0f;

	//!((*(DWORD*)&delta.x) >> 31 & 1) * 180.0f; is basically the if statement bellow - it removes code branching for better performance
	//if (delta.x >= 0.0)
	//	angles.y += 180.0;

	angles.z = 0.0f;

	return angles;
}

```

`NullBase/Math.h`:

```h
#pragma once

#include "Includes.h"

extern D3DXVECTOR3 CalcAngle(register const D3DXVECTOR3& src, register const D3DXVECTOR3& dst);

```

`NullBase/NullBase.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{258BBD17-9C54-4005-888B-97967C3E693D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>NullBase</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\x86;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <FloatingPointModel>Fast</FloatingPointModel>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Entity.cpp" />
    <ClCompile Include="LocalPlayer.cpp" />
    <ClCompile Include="Math.cpp" />
    <ClCompile Include="NullMemory.cpp" />
    <ClCompile Include="Cheat.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Entity.h" />
    <ClInclude Include="Includes.h" />
    <ClInclude Include="LocalPlayer.h" />
    <ClInclude Include="Math.h" />
    <ClInclude Include="NullMemory.h" />
    <ClInclude Include="Offsets.hpp" />
    <ClInclude Include="W2S.h" />
    <ClInclude Include="Xor.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NullBase/NullBase.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\SDK">
      <UniqueIdentifier>{2aa0999d-80c5-4162-acde-28e53a15d8c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Mem">
      <UniqueIdentifier>{9c605d05-1089-4dc2-b2c2-d48c277f9c25}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Cheat">
      <UniqueIdentifier>{d56dff22-19d5-4312-939d-177f2dee7a6c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\SDK">
      <UniqueIdentifier>{0e800206-1673-44d8-adcf-b607b65f5159}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Mem">
      <UniqueIdentifier>{c06ea5ec-b55b-4f0c-9907-af09595fb15d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Cheat.cpp">
      <Filter>Source Files\Cheat</Filter>
    </ClCompile>
    <ClCompile Include="LocalPlayer.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="Entity.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="NullMemory.cpp">
      <Filter>Source Files\Mem</Filter>
    </ClCompile>
    <ClCompile Include="Math.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LocalPlayer.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="Entity.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="NullMemory.h">
      <Filter>Header Files\Mem</Filter>
    </ClInclude>
    <ClInclude Include="W2S.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="Xor.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.hpp">
      <Filter>Header Files\Mem</Filter>
    </ClInclude>
    <ClInclude Include="Math.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NullBase/NullBase.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`NullBase/NullMemory.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Copyright 2018 Null Terminator																								  //
//
Permission is hereby granted, free of charge, to any person																		  //
obtaining a copy of this software and associated documentation                                                                    //
files(the "Software"), to deal in the Software without restriction,                                                               //
including without limitation the rights to use, copy, modify, merge,                                                              //
publish, distribute, sublicense, and/or sell copies of the Software,                                                              //
and to permit persons to whom the Software is furnished to do so,                                                                 //
subject to the following conditions :                                                                                             //
//
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.    //
//
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,																	  //
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF																  //
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.                                                            //
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                                       //
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                                             //
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR                                                             //
THE USE OR OTHER DEALINGS IN THE SOFTWARE.																						  //
*/																																  //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "Includes.h"

//Vars to use
DWORD baseAddress = NULL;
DWORD engineAddress = NULL;
DWORD clientState = NULL;

//Vars for process snapshot
HANDLE hProcSnap = NULL;
PROCESSENTRY32 procEntry32;

//Vars for module snapshot
HANDLE hModuleSnap = NULL;
MODULEENTRY32 modEntry32;

//Process ID of attached proc
DWORD pID = NULL;

//Handle to process
HANDLE hProc = NULL;

bool attatchProc(char* procName)
{
	//Defining size of structure so we can populate it
	procEntry32.dwSize = sizeof(PROCESSENTRY32);

	//Taking a snapshot of all processes running
	hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (hProcSnap == INVALID_HANDLE_VALUE)
	{
		std::cout << "Failed to take snapshot of process list." << std::endl;
		return false;
	}

	//While there is a next process in the snapshot
	while (Process32Next(hProcSnap, &procEntry32))
	{
		std::cout << procEntry32.szExeFile << std::endl;
		//If the process we're looking for matches the current process in snapshot
		if (!strcmp(procName, procEntry32.szExeFile))
		{
			//Outputting proc name and ID then getting all access to process and initialising a handle to the proc to we can read/write it's memory
			std::cout << "Found process " << procEntry32.szExeFile << " with process ID " << procEntry32.th32ProcessID << std::endl;
			hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procEntry32.th32ProcessID);
			pID = procEntry32.th32ProcessID;

			if (hProc == NULL)
			{
				std::cout << "Failed getting handle to process." << std::endl;
			}
			//Close handle to process snapshot then return true
			CloseHandle(hProcSnap);
			return true;
		}
	}

	std::cout << "Couldn't find " << procName << " in the process snapshot." << std::endl;
	CloseHandle(hProcSnap);
	return false;
}

DWORD getModule(LPSTR moduleName)
{
	//Taking snapshot of modules in process
	hModuleSnap = INVALID_HANDLE_VALUE;
	hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pID);

	if (hModuleSnap == INVALID_HANDLE_VALUE)
	{
		std::cout << "Failed to take a snapshot of modules." << std::endl;
		CloseHandle(hModuleSnap);
		return 0;
	}

	//Defining structure size
	modEntry32.dwSize = sizeof(MODULEENTRY32);

	//Getting information of first module in snapshot
	if (Module32First(hModuleSnap, &modEntry32))
	{
		//If the module we're looking for matches the module in snapshot
		if (!strcmp(moduleName, modEntry32.szModule))
		{
			//Outputting module name and base address
			std::cout << "Found module " << modEntry32.szModule << " with base address " << std::hex << (DWORD)modEntry32.modBaseAddr << std::endl;

			//Close handle to process snapshot then return base address
			CloseHandle(hModuleSnap);
			return (DWORD)modEntry32.modBaseAddr;
		}
	}

	//While there is a next module in the snapshot
	while (Module32Next(hModuleSnap, &modEntry32))
	{
		//If the module we're looking for matches the module in snapshot
		if (!strcmp(moduleName, modEntry32.szModule))
		{
			//Outputting module name and base address
			std::cout << "Found module " << modEntry32.szModule << " with base address 0x" << std::hex << std::uppercase << (DWORD)modEntry32.modBaseAddr << std::endl;

			//Close handle to process snapshot then return base address
			CloseHandle(hModuleSnap);
			return (DWORD)modEntry32.modBaseAddr;
		}
	}
	std::cout << "Couldn't find " << moduleName << " module in module snapshot of the process." << std::endl;
	CloseHandle(hModuleSnap);
	return false;
}

std::uint32_t find(const char* proc)
{
	auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 pe;
	pe.dwSize = sizeof(pe);

	if (Process32First(snapshot, &pe)) {
		while (Process32Next(snapshot, &pe))
		{
			if (!strcmp(proc, pe.szExeFile)) {
				CloseHandle(snapshot);
				//mylog << "Found proc!\n";
				return pe.th32ProcessID;
			}
		}
	}
	CloseHandle(snapshot);
	return 0;
}

void init()
{
	if (attatchProc(XOR("csgo.exe")))
	{
		baseAddress = getModule(XOR("client_panorama.dll"));
		engineAddress = getModule(XOR("engine.dll"));

		LocalPlayer::setLocalPlayer();

		clientState = rpm<DWORD>(engineAddress + offs::dwClientState);
	}
}
```

`NullBase/NullMemory.h`:

```h
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Copyright 2018 Null Terminator																								  //
//
Permission is hereby granted, free of charge, to any person																		  //
obtaining a copy of this software and associated documentation                                                                    //
files(the "Software"), to deal in the Software without restriction,                                                               //
including without limitation the rights to use, copy, modify, merge,                                                              //
publish, distribute, sublicense, and/or sell copies of the Software,                                                              //
and to permit persons to whom the Software is furnished to do so,                                                                 //
subject to the following conditions :                                                                                             //
//
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.    //
//
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,																	  //
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF																  //
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.                                                            //
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                                       //
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                                             //
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR                                                             //
THE USE OR OTHER DEALINGS IN THE SOFTWARE.																						  //
*/																																  //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma  once
#include <windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <string>
#include "Offsets.hpp"

//Vars to use
extern DWORD baseAddress;
extern DWORD engineAddress;
extern DWORD clientState;

//Vars for process snapshot
extern HANDLE hProcSnap;
extern PROCESSENTRY32 procEntry32;

//Vars for module snapshot
extern HANDLE hModuleSnap;
extern MODULEENTRY32 modEntry32;

//Process ID of attached proc
extern DWORD pID;

//Handle to process
extern HANDLE hProc;

//WPM wrapper - Lets us call WriteProcessMemory MUCH more easily (with less args)
template <class dataType>
void wpm(dataType valToWrite, DWORD addressToWrite)
{
	WriteProcessMemory(hProc, (PVOID)addressToWrite, &valToWrite, sizeof(dataType), 0);
}

//RPM wrapper - Lets us call ReadProcessMemory MUCH more easily (with less args)
template <class dataType>
dataType rpm(DWORD addressToRead)
{
	//Stores the value of the address being read
	dataType rpmBuffer;

	//RPM
	ReadProcessMemory(hProc, (PVOID)addressToRead, &rpmBuffer, sizeof(dataType), 0);

	//Return the value that was read
	return rpmBuffer;
}

//Attaches to process and gives ALL_ACCESS so you can rpm/wpm for your hack
extern bool attatchProc(char* procName);

//Gets the base address of a desired module within the process you've attached to, so you can offset from it
extern DWORD getModule(char* moduleName);

extern uintptr_t patternScan(char* base, size_t size, char* pattern);

extern void init();

extern std::uint32_t find(const char* proc);
```

`NullBase/Offsets.hpp`:

```hpp
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Copyright 2018 Null Terminator																								  //
//
Permission is hereby granted, free of charge, to any person																		  //
obtaining a copy of this software and associated documentation                                                                    //
files(the "Software"), to deal in the Software without restriction,                                                               //
including without limitation the rights to use, copy, modify, merge,                                                              //
publish, distribute, sublicense, and/or sell copies of the Software,                                                              //
and to permit persons to whom the Software is furnished to do so,                                                                 //
subject to the following conditions :                                                                                             //
//
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.    //
//
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,																	  //
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF																  //
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.                                                            //
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                                       //
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                                             //
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR                                                             //
THE USE OR OTHER DEALINGS IN THE SOFTWARE.																						  //
*/																																  //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once
#include <windows.h>
#include <cstddef>

namespace netvars {
	constexpr ::std::ptrdiff_t cs_gamerules_data = 0x0;
	constexpr ::std::ptrdiff_t m_ArmorValue = 0xB340;
	constexpr ::std::ptrdiff_t m_Collision = 0x31C;
	constexpr ::std::ptrdiff_t m_CollisionGroup = 0x474;
	constexpr ::std::ptrdiff_t m_Local = 0x2FBC;
	constexpr ::std::ptrdiff_t m_MoveType = 0x25C;
	constexpr ::std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x31B4;
	constexpr ::std::ptrdiff_t m_OriginalOwnerXuidLow = 0x31B0;
	constexpr ::std::ptrdiff_t m_SurvivalGameRuleDecisionTypes = 0x1320;
	constexpr ::std::ptrdiff_t m_SurvivalRules = 0xCF8;
	constexpr ::std::ptrdiff_t m_aimPunchAngle = 0x302C;
	constexpr ::std::ptrdiff_t m_aimPunchAngleVel = 0x3038;
	constexpr ::std::ptrdiff_t m_angEyeAnglesX = 0xB344;
	constexpr ::std::ptrdiff_t m_angEyeAnglesY = 0xB348;
	constexpr ::std::ptrdiff_t m_bBombPlanted = 0x99D;
	constexpr ::std::ptrdiff_t m_bFreezePeriod = 0x20;
	constexpr ::std::ptrdiff_t m_bGunGameImmunity = 0x392C;
	constexpr ::std::ptrdiff_t m_bHasDefuser = 0xB350;
	constexpr ::std::ptrdiff_t m_bHasHelmet = 0xB334;
	constexpr ::std::ptrdiff_t m_bInReload = 0x3285;
	constexpr ::std::ptrdiff_t m_bIsDefusing = 0x3918;
	constexpr ::std::ptrdiff_t m_bIsQueuedMatchmaking = 0x74;
	constexpr ::std::ptrdiff_t m_bIsScoped = 0x3910;
	constexpr ::std::ptrdiff_t m_bIsValveDS = 0x75;
	constexpr ::std::ptrdiff_t m_bSpotted = 0x93D;
	constexpr ::std::ptrdiff_t m_bSpottedByMask = 0x980;
	constexpr ::std::ptrdiff_t m_bStartedArming = 0x33D0;
	constexpr ::std::ptrdiff_t m_clrRender = 0x70;
	constexpr ::std::ptrdiff_t m_dwBoneMatrix = 0x26A8;
	constexpr ::std::ptrdiff_t m_fAccuracyPenalty = 0x3310;
	constexpr ::std::ptrdiff_t m_fFlags = 0x104;
	constexpr ::std::ptrdiff_t m_flC4Blow = 0x2990;
	constexpr ::std::ptrdiff_t m_flDefuseCountDown = 0x29AC;
	constexpr ::std::ptrdiff_t m_flDefuseLength = 0x29A8;
	constexpr ::std::ptrdiff_t m_flFallbackWear = 0x31C0;
	constexpr ::std::ptrdiff_t m_flFlashDuration = 0xA3F4;
	constexpr ::std::ptrdiff_t m_flFlashMaxAlpha = 0xA3F0;
	constexpr ::std::ptrdiff_t m_flLastBoneSetupTime = 0x2924;
	constexpr ::std::ptrdiff_t m_flLowerBodyYawTarget = 0x3A78;
	constexpr ::std::ptrdiff_t m_flNextAttack = 0x2D70;
	constexpr ::std::ptrdiff_t m_flNextPrimaryAttack = 0x3218;
	constexpr ::std::ptrdiff_t m_flSimulationTime = 0x268;
	constexpr ::std::ptrdiff_t m_flTimerLength = 0x2994;
	constexpr ::std::ptrdiff_t m_hActiveWeapon = 0x2EF8;
	constexpr ::std::ptrdiff_t m_hMyWeapons = 0x2DF8;
	constexpr ::std::ptrdiff_t m_hObserverTarget = 0x3388;
	constexpr ::std::ptrdiff_t m_hOwner = 0x29CC;
	constexpr ::std::ptrdiff_t m_hOwnerEntity = 0x14C;
	constexpr ::std::ptrdiff_t m_iAccountID = 0x2FC8;
	constexpr ::std::ptrdiff_t m_iClip1 = 0x3244;
	constexpr ::std::ptrdiff_t m_iCompetitiveRanking = 0x1A84;
	constexpr ::std::ptrdiff_t m_iCompetitiveWins = 0x1B88;
	constexpr ::std::ptrdiff_t m_iCrosshairId = 0xB3AC;
	constexpr ::std::ptrdiff_t m_iEntityQuality = 0x2FAC;
	constexpr ::std::ptrdiff_t m_iFOV = 0x31E4;
	constexpr ::std::ptrdiff_t m_iFOVStart = 0x31E8;
	constexpr ::std::ptrdiff_t m_iGlowIndex = 0xA40C;
	constexpr ::std::ptrdiff_t m_iHealth = 0x100;
	constexpr ::std::ptrdiff_t m_iItemDefinitionIndex = 0x2FAA;
	constexpr ::std::ptrdiff_t m_iItemIDHigh = 0x2FC0;
	constexpr ::std::ptrdiff_t m_iMostRecentModelBoneCounter = 0x2690;
	constexpr ::std::ptrdiff_t m_iObserverMode = 0x3374;
	constexpr ::std::ptrdiff_t m_iShotsFired = 0xA380;
	constexpr ::std::ptrdiff_t m_iState = 0x3238;
	constexpr ::std::ptrdiff_t m_iTeamNum = 0xF4;
	constexpr ::std::ptrdiff_t m_lifeState = 0x25F;
	constexpr ::std::ptrdiff_t m_nFallbackPaintKit = 0x31B8;
	constexpr ::std::ptrdiff_t m_nFallbackSeed = 0x31BC;
	constexpr ::std::ptrdiff_t m_nFallbackStatTrak = 0x31C4;
	constexpr ::std::ptrdiff_t m_nForceBone = 0x268C;
	constexpr ::std::ptrdiff_t m_nTickBase = 0x342C;
	constexpr ::std::ptrdiff_t m_rgflCoordinateFrame = 0x444;
	constexpr ::std::ptrdiff_t m_szCustomName = 0x303C;
	constexpr ::std::ptrdiff_t m_szLastPlaceName = 0x35B0;
	constexpr ::std::ptrdiff_t m_thirdPersonViewAngles = 0x31D8;
	constexpr ::std::ptrdiff_t m_vecOrigin = 0x138;
	constexpr ::std::ptrdiff_t m_vecVelocity = 0x114;
	constexpr ::std::ptrdiff_t m_vecViewOffset = 0x108;
	constexpr ::std::ptrdiff_t m_viewPunchAngle = 0x3020;
}
namespace offs {
	constexpr ::std::ptrdiff_t clientstate_choked_commands = 0x4D28;
	constexpr ::std::ptrdiff_t clientstate_delta_ticks = 0x174;
	constexpr ::std::ptrdiff_t clientstate_last_outgoing_command = 0x4D24;
	constexpr ::std::ptrdiff_t clientstate_net_channel = 0x9C;
	constexpr ::std::ptrdiff_t convar_name_hash_table = 0x2F0F8;
	constexpr ::std::ptrdiff_t dwClientState = 0x58CCFC;
	constexpr ::std::ptrdiff_t dwClientState_GetLocalPlayer = 0x180;
	constexpr ::std::ptrdiff_t dwClientState_IsHLTV = 0x4D40;
	constexpr ::std::ptrdiff_t dwClientState_Map = 0x28C;
	constexpr ::std::ptrdiff_t dwClientState_MapDirectory = 0x188;
	constexpr ::std::ptrdiff_t dwClientState_MaxPlayer = 0x388;
	constexpr ::std::ptrdiff_t dwClientState_PlayerInfo = 0x52B8;
	constexpr ::std::ptrdiff_t dwClientState_State = 0x108;
	constexpr ::std::ptrdiff_t dwClientState_ViewAngles = 0x4D88;
	constexpr ::std::ptrdiff_t dwEntityList = 0x4D04B04;
	constexpr ::std::ptrdiff_t dwForceAttack = 0x31361C0;
	constexpr ::std::ptrdiff_t dwForceAttack2 = 0x31361CC;
	constexpr ::std::ptrdiff_t dwForceBackward = 0x3136208;
	constexpr ::std::ptrdiff_t dwForceForward = 0x3136214;
	constexpr ::std::ptrdiff_t dwForceJump = 0x51A81BC;
	constexpr ::std::ptrdiff_t dwForceLeft = 0x313622C;
	constexpr ::std::ptrdiff_t dwForceRight = 0x3136220;
	constexpr ::std::ptrdiff_t dwGameDir = 0x632F70;
	constexpr ::std::ptrdiff_t dwGameRulesProxy = 0x521A504;
	constexpr ::std::ptrdiff_t dwGetAllClasses = 0xD1795C;
	constexpr ::std::ptrdiff_t dwGlobalVars = 0x58CA00;
	constexpr ::std::ptrdiff_t dwGlowObjectManager = 0x5245018;
	constexpr ::std::ptrdiff_t dwInput = 0x514FB50;
	constexpr ::std::ptrdiff_t dwInterfaceLinkList = 0x8C7E94;
	constexpr ::std::ptrdiff_t dwLocalPlayer = 0xCF2A3C;
	constexpr ::std::ptrdiff_t dwMouseEnable = 0xCF8588;
	constexpr ::std::ptrdiff_t dwMouseEnablePtr = 0xCF8558;
	constexpr ::std::ptrdiff_t dwPlayerResource = 0x313454C;
	constexpr ::std::ptrdiff_t dwRadarBase = 0x5139864;
	constexpr ::std::ptrdiff_t dwSensitivity = 0xCF8424;
	constexpr ::std::ptrdiff_t dwSensitivityPtr = 0xCF83F8;
	constexpr ::std::ptrdiff_t dwSetClanTag = 0x896A0;
	constexpr ::std::ptrdiff_t dwViewMatrix = 0x4CF6534;
	constexpr ::std::ptrdiff_t dwWeaponTable = 0x5150614;
	constexpr ::std::ptrdiff_t dwWeaponTableIndex = 0x323C;
	constexpr ::std::ptrdiff_t dwYawPtr = 0xCF81E8;
	constexpr ::std::ptrdiff_t dwZoomSensitivityRatioPtr = 0xCFD408;
	constexpr ::std::ptrdiff_t dwbSendPackets = 0xD286A;
	constexpr ::std::ptrdiff_t dwppDirect3DDevice9 = 0xA6030;
	constexpr ::std::ptrdiff_t force_update_spectator_glow = 0x393362;
	constexpr ::std::ptrdiff_t interface_engine_cvar = 0x3E9EC;
	constexpr ::std::ptrdiff_t is_c4_owner = 0x39F5A0;
	constexpr ::std::ptrdiff_t m_bDormant = 0xED;
	constexpr ::std::ptrdiff_t m_pStudioHdr = 0x294C;
	constexpr ::std::ptrdiff_t m_pitchClassPtr = 0x5139B10;
	constexpr ::std::ptrdiff_t m_yawClassPtr = 0xCF81E8;
	constexpr ::std::ptrdiff_t model_ambient_min = 0x58FD1C;
	constexpr ::std::ptrdiff_t set_abs_angles = 0x1CA8B0;
	constexpr ::std::ptrdiff_t set_abs_origin = 0x1CA6F0;
}


//CREDIT TO HAZED DUMPER FOR THESE OFFSETS :-D

```

`NullBase/W2S.h`:

```h
#pragma once
#include "LocalPlayer.h"

//Use this to transform an entities 3D position in-game to a 2D position on your screen for example - to render something on them (Wallhacks)


static bool ScreenTransform(const D3DXVECTOR3& point, D3DXVECTOR3& screen)
{
	const D3DXMATRIX& w2sMatrix = LocalPlayer::getLocalViewMatrix();
	screen.x = w2sMatrix.m[0][0] * point.x + w2sMatrix.m[0][1] * point.y + w2sMatrix.m[0][2] * point.z + w2sMatrix.m[0][3];
	screen.y = w2sMatrix.m[1][0] * point.x + w2sMatrix.m[1][1] * point.y + w2sMatrix.m[1][2] * point.z + w2sMatrix.m[1][3];
	screen.z = 0.0f;

	float w = w2sMatrix.m[3][0] * point.x + w2sMatrix.m[3][1] * point.y + w2sMatrix.m[3][2] * point.z + w2sMatrix.m[3][3];

	if (w < 0.001f) {
		screen.x *= 100000;
		screen.y *= 100000;
		return true;
	}

	float invw = 1.0f / w;
	screen.x *= invw;
	screen.y *= invw;

	return false;
}

static bool WorldToScreen(const D3DXVECTOR3 &origin, D3DXVECTOR3 &screen, int w, int h)
{
	if (!ScreenTransform(origin, screen)) {
		screen.x = (w / 2.0f) + (screen.x * w) / 2;
		screen.y = (h / 2.0f) - (screen.y * h) / 2;

		return true;
	}
	return false;
}

```

`NullBase/Xor.h`:

```h
#pragma once

//Use this to xor encrypt string literals throughout your cheat to make it harder to reverse


template <int XORSTART, int BUFLEN, int XREFKILLER>

class XorStr
{
private:
	XorStr();
public:
	char s[BUFLEN];

	XorStr(char * xs);

	~XorStr()
	{
		for (int i = 0; i < BUFLEN; i++) s[i] = 0;
	}
};

template <int XORSTART, int BUFLEN, int XREFKILLER>
XorStr<XORSTART, BUFLEN, XREFKILLER>::XorStr(char * xs)
{
	int xvalue = XORSTART;
	int i = 0;

	for (; i < (BUFLEN - 1); i++)
	{
		s[i] = xs[i - XREFKILLER] ^ xvalue;
		xvalue += 1;
		xvalue %= 256;
	}

	s[BUFLEN - 1] = 0;
}

#define XOR(a) a
```

`README.md`:

```md
# NullBase
A simple gamehack base that aims to be easy to follow and able to be built upon; allowing people to learn more efficiently and develop their cheats faster.
Youtube Channel: https://www.youtube.com/c/NullTerminator

```