Project Path: arc_gmh5225_mempeek_4it6bm35

Source Tree:

```txt
arc_gmh5225_mempeek_4it6bm35
├── Cargo.lock
├── Cargo.toml
├── LICENSE
├── README.md
├── screenshot.png
└── src
    ├── constraint.rs
    ├── int.rs
    └── main.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "autocfg"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "cc"
version = "1.0.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11"

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "clipboard-win"
version = "4.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f3e1238132dc01f081e1cbb9dace14e5ef4c3a51ee244bd982275fb514605db"
dependencies = [
 "error-code",
 "str-buf",
 "winapi",
]

[[package]]
name = "dirs-next"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1"
dependencies = [
 "cfg-if",
 "dirs-sys-next",
]

[[package]]
name = "dirs-sys-next"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d"
dependencies = [
 "libc",
 "redox_users",
 "winapi",
]

[[package]]
name = "endian-type"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c34f04666d835ff5d62e058c3995147c06f42fe86ff053337632bca83e42702d"

[[package]]
name = "errno"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f639046355ee4f37944e44f60642c6f3a7efa3cf6b78c78a0d989a8ce6c396a1"
dependencies = [
 "errno-dragonfly",
 "libc",
 "winapi",
]

[[package]]
name = "errno-dragonfly"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "error-code"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64f18991e7bf11e7ffee451b5318b5c1a73c52d0d0ada6e5a3017c8c1ced6a21"
dependencies = [
 "libc",
 "str-buf",
]

[[package]]
name = "fd-lock"
version = "3.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46e245f4c8ec30c6415c56cb132c07e69e74f1942f6b4a4061da748b49f486ca"
dependencies = [
 "cfg-if",
 "rustix",
 "windows-sys",
]

[[package]]
name = "getrandom"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9be70c98951c83b8d2f8f60d7065fa6d5146873094452a1008da8c2f1e4205ad"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "io-lifetimes"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9448015e586b611e5d322f6703812bbca2f1e709d5773ecd38ddb4e3bb649504"

[[package]]
name = "libc"
version = "0.2.126"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836"

[[package]]
name = "libprocmem"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2402273fe03fd8e2d11cb8153f86a24699eef50a49409205013ffcd38313d66a"

[[package]]
name = "linux-raw-sys"
version = "0.0.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4d2456c373231a208ad294c33dc5bff30051eafd954cd4caae83a712b12854d"

[[package]]
name = "log"
version = "0.4.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e"
dependencies = [
 "cfg-if",
]

[[package]]
name = "memchr"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"

[[package]]
name = "memoffset"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce"
dependencies = [
 "autocfg",
]

[[package]]
name = "mempeek"
version = "0.1.3"
dependencies = [
 "libprocmem",
 "quoted_strings",
 "rustyline",
]

[[package]]
name = "nibble_vec"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a5d83df9f36fe23f0c3648c6bbb8b0298bb5f1939c8f2704431371f4b84d43"
dependencies = [
 "smallvec",
]

[[package]]
name = "nix"
version = "0.23.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f866317acbd3a240710c63f065ffb1e4fd466259045ccb504130b7f668f35c6"
dependencies = [
 "bitflags",
 "cc",
 "cfg-if",
 "libc",
 "memoffset",
]

[[package]]
name = "proc-macro2"
version = "1.0.39"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c54b25569025b7fc9651de43004ae593a75ad88543b17178aa5e1b9c4f15f56f"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1feb54ed693b93a84e14094943b84b7c4eae204c512b7ccb95ab0c66d278ad1"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "quoted_strings"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1c6d56aa6564abc425bab3c1035089117da5218bffb3f9fb3d0066912f32a2c"

[[package]]
name = "radix_trie"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c069c179fcdc6a2fe24d8d18305cf085fdbd4f922c041943e203685d6a1c58fd"
dependencies = [
 "endian-type",
 "nibble_vec",
]

[[package]]
name = "redox_syscall"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62f25bc4c7e55e0b0b7a1d43fb893f4fa1361d0abe38b9ce4f323c2adfe6ef42"
dependencies = [
 "bitflags",
]

[[package]]
name = "redox_users"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b033d837a7cf162d7993aded9304e30a83213c648b6e389db233191f891e5c2b"
dependencies = [
 "getrandom",
 "redox_syscall",
 "thiserror",
]

[[package]]
name = "rustix"
version = "0.34.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2079c267b8394eb529872c3cf92e181c378b41fea36e68130357b52493701d2e"
dependencies = [
 "bitflags",
 "errno",
 "io-lifetimes",
 "libc",
 "linux-raw-sys",
 "winapi",
]

[[package]]
name = "rustyline"
version = "9.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db7826789c0e25614b03e5a54a0717a86f9ff6e6e5247f92b369472869320039"
dependencies = [
 "bitflags",
 "cfg-if",
 "clipboard-win",
 "dirs-next",
 "fd-lock",
 "libc",
 "log",
 "memchr",
 "nix",
 "radix_trie",
 "scopeguard",
 "smallvec",
 "unicode-segmentation",
 "unicode-width",
 "utf8parse",
 "winapi",
]

[[package]]
name = "scopeguard"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"

[[package]]
name = "smallvec"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83"

[[package]]
name = "str-buf"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e08d8363704e6c71fc928674353e6b7c23dcea9d82d7012c8faf2a3a025f8d0"

[[package]]
name = "syn"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbaf6116ab8924f39d52792136fb74fd60a80194cf1b1c6ffa6453eef1c3f942"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "thiserror"
version = "1.0.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd829fe32373d27f76265620b5309d0340cb8550f523c1dda251d6298069069a"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0396bc89e626244658bef819e22d0cc459e795a5ebe878e6ec336d1674a8d79a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "unicode-ident"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d22af068fba1eb5edcb4aea19d382b2a3deb4c8f9d475c589b6ada9e0fd493ee"

[[package]]
name = "unicode-segmentation"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8820f5d777f6224dc4be3632222971ac30164d4a258d595640799554ebfd99"

[[package]]
name = "unicode-width"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973"

[[package]]
name = "utf8parse"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "936e4b492acfd135421d8dca4b1aa80a7bfc26e702ef3af710e0752684df5372"

[[package]]
name = "wasi"
version = "0.10.2+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-sys"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "030b7ff91626e57a05ca64a07c481973cbb2db774e4852c9c7ca342408c6a99a"
dependencies = [
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_msvc"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29277a4435d642f775f63c7d1faeb927adba532886ce0287bd985bffb16b6bca"

[[package]]
name = "windows_i686_gnu"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1145e1989da93956c68d1864f32fb97c8f561a8f89a5125f6a2b7ea75524e4b8"

[[package]]
name = "windows_i686_msvc"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4a09e3a0d4753b73019db171c1339cd4362c8c44baf1bcea336235e955954a6"

[[package]]
name = "windows_x86_64_gnu"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ca64fcb0220d58db4c119e050e7af03c69e6f4f415ef69ec1773d9aab422d5a"

[[package]]
name = "windows_x86_64_msvc"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08cabc9f0066848fef4bc6a1c1668e6efce38b661d2aeec75d18d8617eebb5f1"

```

`Cargo.toml`:

```toml
[package]
name = "mempeek"
version = "0.1.4"
edition = "2021"
license = "BSD-2-Clause"
description = "A command line tool that resembles a debugger as well as Cheat Engine, to search for values in memory"
documentation = "https://docs.rs/mempeek"
repository = "https://github.com/gamozolabs/mempeek"
keywords = ["proc", "mem", "maps"]
categories = ["os::linux-apis", "command-line-utilities"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
libprocmem = "0.1"
quoted_strings = "0.1.0"
rustyline = "9.1"


```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2022, gamozolabs
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# Summary

This is a small command-line tool designed to peek around memory of a running
Linux process. It also provides filtering mechanisms similar to Cheat Engine
to scan for memory of certain values.

It uses `rustyline` to maintain a history of command line arguments which is
persisted in the `.peekieboi` file. Allowing "up-arrow" to work across
different runs of the tool!

# Installing

Simply run `cargo install mempeek` to install this tool! Then invoke it by
running `mempeek <pid of process to introspect>`

# Commands

## Expression support

I've added extremely basic support for expressions of various radix as well as
add, subtract, multiply, and divide. No support for parenthesis (yet).

This allows you to use an expression like `0x13370000+0o100*4` in any argument
to a command which expects a constant value. _The default radix for numbers
is 16, thus, hex unless you use an `0b`, `0o`, or `0d` prefix_

## Types

Types may be one of the following:

- `b` - `u8`
- `w` - `u16`
- `d` - `u32`
- `q` - `u64`
- `B` - `i8`
- `W` - `i16`
- `D` - `i32`
- `Q` - `i64`
- `f` - `f32`
- `F` - `f64`

## Constraints

Constraints may be any one of the following:

- `=[val]`  - Equal to `[val]`
- `![val]`  - Not equal to `[val]`
- `>[val]`  - Greater than `[val]`
- `>=[val]` - Greater than or equal to `[val]`
- `<[val]`  - Less than `[val]`
- `<=[val]` - Less than or equal to `[val]`

Currently this only supports a few commands

## `q` | `exit` | `quit`

Exit the program

## `h <query index | l>`

Get the results from a previous memory scan. Takes the query index of the query
to retrieve. Optionally, you can use `l` in place of the query index to get the
most recent query results

## `s[bwdqBWDQfF] <addr> <length> [constraints]`

Scan memory for a value of a given type starting at `addr` for `length` bytes
using `constraints`

## `u[bwdqBWDQfFo] <query #> [constraints]`

Using the address list from a previous query, interpret the pointed-to-value as
the specified type `o` implies that the update should use the type of the
original query.

## `d[bwdqBWDQfF] <addr> [<number of bytes>]`

Dump memory interpreted as a given type for a given number of bytes

## `ss <addr> <length> <string>`

Search for a `string` in a region of memory specified by `addr` and `length`
(in bytes)

## `m`

Dump memory regions and their permissions.

# Example

![Example of mempeek](/screenshot.png)

_Green values in the dump output indicate that the value is a valid pointer
when cast to a `u64`_


```

`src/constraint.rs`:

```rs
///! Basic constraints

use crate::{Error, Result, Value};

/// Different constraints we can apply on a value
#[derive(Debug, Clone, Copy)]
pub enum Constraint {
    /// `=`
    Equal(Value),
    
    /// `!`
    NotEqual(Value),

    /// `>`
    Greater(Value),

    /// `>=`
    GreaterEqual(Value),

    /// `<`
    Less(Value),

    /// `<=`
    LessEqual(Value),
}

impl Constraint {
    /// Replace the value with a new one
    pub fn update_val(&mut self, val: Value) {
        match self {
            Self::Greater(ref mut rhs) |
            Self::GreaterEqual(ref mut rhs) |
            Self::Less(ref mut rhs) |
            Self::LessEqual(ref mut rhs) |
            Self::Equal(ref mut rhs) => *rhs = val,
            Self::NotEqual(ref mut rhs) => *rhs = val,
        }
    }

    /// Check a condition
    pub fn check(&self, lhs: Value) -> bool {
        match *self {
            Self::Greater(rhs)      => lhs >  rhs,
            Self::GreaterEqual(rhs) => lhs >= rhs,
            Self::Less(rhs)         => lhs <  rhs,
            Self::LessEqual(rhs)    => lhs <= rhs,
            Self::Equal(rhs)        => lhs == rhs,
            Self::NotEqual(rhs)     => lhs != rhs,
        }
    }

    /// Create a new constraint from `s` using `val` as the type for the value
    pub fn from_str_value(s: &str, val: Option<Value>) -> Result<Self> {
        if s.starts_with("=") {
            if let Some(mut val) = val {
                val.update_str(&s[1..])?;
                Ok(Constraint::Equal(val))
            } else {
                Ok(Constraint::Equal(Value::U8(0)))
            }
        } else if s.starts_with("!") {
            if let Some(mut val) = val {
                val.update_str(&s[1..])?;
                Ok(Constraint::NotEqual(val))
            } else {
                Ok(Constraint::NotEqual(Value::U8(0)))
            }
        } else if s.starts_with(">=") {
            if let Some(mut val) = val {
                val.update_str(&s[2..])?;
                Ok(Constraint::GreaterEqual(val))
            } else {
                Ok(Constraint::GreaterEqual(Value::U8(0)))
            }
        } else if s.starts_with(">") {
            if let Some(mut val) = val {
                val.update_str(&s[1..])?;
                Ok(Constraint::Greater(val))
            } else {
                Ok(Constraint::Greater(Value::U8(0)))
            }
        } else if s.starts_with("<=") {
            if let Some(mut val) = val {
                val.update_str(&s[2..])?;
                Ok(Constraint::LessEqual(val))
            } else {
                Ok(Constraint::LessEqual(Value::U8(0)))
            }
        } else if s.starts_with("<") {
            if let Some(mut val) = val {
                val.update_str(&s[1..])?;
                Ok(Constraint::Less(val))
            } else {
                Ok(Constraint::Less(Value::U8(0)))
            }
        } else {
            Err(Error::InvalidConstraint)
        }
    }
}


```

`src/int.rs`:

```rs
//! Integer parsing helper libraries

use crate::Error;

macro_rules! impl_expr {
    ($name:ident, $name_int:ident, $ty:ty) => {
        pub fn $name(s: &str) -> crate::Result<$ty> {
            #[derive(Clone, Copy, Debug)]
            enum Expr {
                Add,
                Sub,
                Mul,
                Div,
                Val($ty),
            }

            // Split expression into components
            let mut components = Vec::new();

            let mut cur = String::new();
            for chr in s.chars() {
                if matches!(chr, '+' | '-' | '*' | '/') {
                    // Push the current component
                    components.push(Expr::Val($name_int(&cur)?));
                    match chr {
                        '+' => components.push(Expr::Add),
                        '-' => components.push(Expr::Sub),
                        '*' => components.push(Expr::Mul),
                        '/' => components.push(Expr::Div),
                        _   => unreachable!(),
                    }
                    cur.clear();
                    continue;
                }

                cur.push(chr);
            }

            // Flush remaining data
            if !cur.is_empty() {
                components.push(Expr::Val($name_int(&cur)?));
            }

            let mut ii = 0;
            while ii < components.len().saturating_sub(2) {
                let (left, op, right) = (
                    components[ii + 0],
                    components[ii + 1],
                    components[ii + 2],
                );

                let res = match (left, op, right) {
                    (Expr::Val(l), Expr::Mul, Expr::Val(r)) =>
                        l.wrapping_mul(r),
                    (Expr::Val(l), Expr::Div, Expr::Val(r)) =>
                        l.wrapping_div(r),
                    _ => {
                        ii += 1;
                        continue;
                    }
                };

                // Replace the expression with the result
                components[ii] = Expr::Val(res);

                // Remove the operation and right side as we've "consumed" them
                components.drain(ii + 1..ii + 3);
            }
            
            let mut ii = 0;
            while ii < components.len().saturating_sub(2) {
                let (left, op, right) = (
                    components[ii + 0],
                    components[ii + 1],
                    components[ii + 2],
                );

                let res = match (left, op, right) {
                    (Expr::Val(l), Expr::Add, Expr::Val(r)) =>
                        l.wrapping_add(r),
                    (Expr::Val(l), Expr::Sub, Expr::Val(r)) =>
                        l.wrapping_sub(r),
                    _ => {
                        ii += 1;
                        continue;
                    }
                };

                // Replace the expression with the result
                components[ii] = Expr::Val(res);

                // Remove the operation and right side as we've "consumed" them
                components.drain(ii + 1..ii + 3);
            }

            match components.as_slice() {
                [Expr::Val(ret)] => Ok(*ret),
                _ => Err(Error::InvalidExpression),
            }
        }
    }
}

macro_rules! int_parse {
    ($name:ident, $name_int:ident, $ty:ty) => {
        /// Parse an integer with optional base override prefix
        pub fn $name_int(mut s: &str) -> crate::Result<$ty> {
            // Default base
            let mut base = 16;

            // Invert sign
            let mut inv = false;

            // Check for a prefix
            match s.get(0..3) {
                Some("-0x" | "-0X") => { base = 16; s = &s[3..]; inv = true; }
                Some("-0d" | "-0D") => { base = 10; s = &s[3..]; inv = true; }
                Some("-0o" | "-0O") => { base =  8; s = &s[3..]; inv = true; }
                Some("-0b" | "-0B") => { base =  2; s = &s[3..]; inv = true; }
                _ => {
                    // Check for a prefix
                    match s.get(0..2) {
                        Some("0x" | "0X") => { base = 16; s = &s[2..]; }
                        Some("0d" | "0D") => { base = 10; s = &s[2..]; }
                        Some("0o" | "0O") => { base =  8; s = &s[2..]; }
                        Some("0b" | "0B") => { base =  2; s = &s[2..]; }
                        _ => {}
                    }
                }
            }

            // Parse the integer
            <$ty>::from_str_radix(s, base).map_err(crate::Error::ParseSigned)
                .map(|x| if inv { -x } else { x })
        }

        impl_expr!($name, $name_int, $ty);
    }
}

macro_rules! uint_parse {
    ($name:ident, $name_int:ident, $ty:ty) => {
        /// Parse an integer with optional base override prefix
        pub fn $name_int(mut s: &str) -> crate::Result<$ty> {
            // Default base
            let mut base = 16;

            // Check for a prefix
            match s.get(0..2) {
                Some("0x" | "0X") => { base = 16; s = &s[2..]; }
                Some("0d" | "0D") => { base = 10; s = &s[2..]; }
                Some("0o" | "0O") => { base =  8; s = &s[2..]; }
                Some("0b" | "0B") => { base =  2; s = &s[2..]; }
                _ => {}
            }

            // Parse the integer
            <$ty>::from_str_radix(s, base).map_err(crate::Error::ParseUnsigned)
        }
        
        impl_expr!($name, $name_int, $ty);
    }
}

uint_parse!(parse_u8,    parse_u8_int,    u8);
uint_parse!(parse_u16,   parse_u16_int,   u16);
uint_parse!(parse_u32,   parse_u32_int,   u32);
uint_parse!(parse_u64,   parse_u64_int,   u64);
uint_parse!(parse_usize, parse_usize_int, usize);
int_parse!(parse_i8,     parse_i8_int,    i8);
int_parse!(parse_i16,    parse_i16_int,   i16);
int_parse!(parse_i32,    parse_i32_int,   i32);
int_parse!(parse_i64,    parse_i64_int,   i64);
int_parse!(parse_isize,  parse_isize_int, isize);


```

`src/main.rs`:

```rs
#![feature(array_chunks)]

pub mod int;
pub mod constraint;

use std::str::FromStr;
use crate::int::*;
use crate::constraint::*;
use libprocmem::Memory;
use rustyline::Editor;
use rustyline::error::ReadlineError;
use quoted_strings::QuotedParts;

/// Wrapper for `Result`
type Result<T> = std::result::Result<T, Error>;

/// Error type
#[derive(Debug)]
pub enum Error {
    /// Error interacting with libprocmem
    Memory(libprocmem::Error),

    /// Failed to parse a signed value
    ParseSigned(std::num::ParseIntError),

    /// Failed to parse an unsigned value
    ParseUnsigned(std::num::ParseIntError),

    /// Failed to read command
    Readline(ReadlineError),

    /// Integer truncation happened when converting a `u64` to a `usize`
    TooBig,

    /// Failed to parse a floating point value
    ParseFloat(std::num::ParseFloatError),

    /// Invalid constraint
    InvalidConstraint,

    /// Got an invalid PID on the command line
    InvalidPid(std::num::ParseIntError),

    /// An invalid expression was used
    ///
    /// Currently we just support add, sub, mul, and div. No spaces. Numbers
    /// can be any base (with the correct override)
    InvalidExpression,
}

/// Different values
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub enum Value {
    F32(f32),
    F64(f64),
    U8(u8),
    U16(u16),
    U32(u32),
    U64(u64),
    I8(i8),
    I16(i16),
    I32(i32),
    I64(i64),
}

impl Value {
    /// Create a new (zero) value with the format specified by `chr`
    pub fn default_from_letter(chr: char) -> Value {
        // Get the value
        match chr {
            'f' => Value::F32(0.),
            'F' => Value::F64(0.),
            'b' => Value::U8(0),
            'w' => Value::U16(0),
            'd' => Value::U32(0),
            'q' => Value::U64(0),
            'B' => Value::I8(0),
            'W' => Value::I16(0),
            'D' => Value::I32(0),
            'Q' => Value::I64(0),
            _ => unreachable!(),
        }
    }

    /// Interpret the value as a `u64` through casting
    pub fn as_u64(&self) -> u64 {
        match self {
            Self::F32(x) => x.to_bits() as u64,
            Self::F64(x) => x.to_bits(),
            Self::U8 (x) => *x as u64,
            Self::U16(x) => *x as u64,
            Self::U32(x) => *x as u64,
            Self::U64(x) => *x,
            Self::I8 (x) => *x as u64,
            Self::I16(x) => *x as u64,
            Self::I32(x) => *x as u64,
            Self::I64(x) => *x as u64,
        }
    }

    /// Get number of bytes per `self`
    pub fn bytes(&self) -> usize {
        match self {
            Self::F32(_) => 4,
            Self::F64(_) => 8,
            Self::U8 (_) => 1,
            Self::U16(_) => 2,
            Self::U32(_) => 4,
            Self::U64(_) => 8,
            Self::I8 (_) => 1,
            Self::I16(_) => 2,
            Self::I32(_) => 4,
            Self::I64(_) => 8,
        }
    }

    /// Get number of bytes per `self` when `Display`ed
    pub fn display(&self) -> usize {
        match self {
            Self::F32(_) => 25,
            Self::F64(_) => 25,
            Self::U8 (_) => 2,
            Self::U16(_) => 4,
            Self::U32(_) => 8,
            Self::U64(_) => 16,
            Self::I8 (_) => 4,
            Self::I16(_) => 6,
            Self::I32(_) => 11,
            Self::I64(_) => 21,
        }
    }

    /// Update value from little-endian bytes
    pub fn from_le_bytes(&mut self, bytes: &[u8]) {
        match self {
            Self::F32(ref mut val) =>
                *val = f32::from_le_bytes(bytes.try_into().unwrap()),
            Self::F64(ref mut val) =>
                *val = f64::from_le_bytes(bytes.try_into().unwrap()),
            Self::U8 (ref mut val) =>
                *val = u8::from_le_bytes(bytes.try_into().unwrap()),
            Self::U16(ref mut val) =>
                *val = u16::from_le_bytes(bytes.try_into().unwrap()),
            Self::U32(ref mut val) =>
                *val = u32::from_le_bytes(bytes.try_into().unwrap()),
            Self::U64(ref mut val) =>
                *val = u64::from_le_bytes(bytes.try_into().unwrap()),
            Self::I8 (ref mut val) =>
                *val = i8::from_le_bytes(bytes.try_into().unwrap()),
            Self::I16(ref mut val) =>
                *val = i16::from_le_bytes(bytes.try_into().unwrap()),
            Self::I32(ref mut val) =>
                *val = i32::from_le_bytes(bytes.try_into().unwrap()),
            Self::I64(ref mut val) =>
                *val = i64::from_le_bytes(bytes.try_into().unwrap()),
        }
    }

    /// Update `self` to a new value of the same type from `s`
    pub fn update_str(&mut self, s: &str) -> Result<()> {
        match self {
            Self::F32(ref mut val) => {
                *val = f32::from_str(s).map_err(Error::ParseFloat)?;
            }
            Self::F64(ref mut val) => {
                *val = f64::from_str(s).map_err(Error::ParseFloat)?;
            }
            Self::U8 (ref mut val) => *val = parse_u8 (s)?,
            Self::U16(ref mut val) => *val = parse_u16(s)?,
            Self::U32(ref mut val) => *val = parse_u32(s)?,
            Self::U64(ref mut val) => *val = parse_u64(s)?,
            Self::I8 (ref mut val) => *val = parse_i8 (s)?,
            Self::I16(ref mut val) => *val = parse_i16(s)?,
            Self::I32(ref mut val) => *val = parse_i32(s)?,
            Self::I64(ref mut val) => *val = parse_i64(s)?,
        }

        Ok(())
    }
}

impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::F32(val) =>
                f.write_fmt(format_args!("{:25.6}", val)),
            Self::F64(val) =>
                f.write_fmt(format_args!("{:25.6}", val)),
            Self::U8 (val) => f.write_fmt(format_args!("{:02x}", val)),
            Self::U16(val) => f.write_fmt(format_args!("{:04x}", val)),
            Self::U32(val) => f.write_fmt(format_args!("{:08x}", val)),
            Self::U64(val) => f.write_fmt(format_args!("{:016x}", val)),
            Self::I8 (val) => f.write_fmt(format_args!("{:4}", val)),
            Self::I16(val) => f.write_fmt(format_args!("{:6}", val)),
            Self::I32(val) => f.write_fmt(format_args!("{:11}", val)),
            Self::I64(val) => f.write_fmt(format_args!("{:21}", val)),
        }
    }
}

impl std::fmt::LowerHex for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::F32(val) =>
                f.write_fmt(format_args!("{:08x}", val.to_bits())),
            Self::F64(val) =>
                f.write_fmt(format_args!("{:016x}", val.to_bits())),
            Self::U8 (val) => f.write_fmt(format_args!("{:02x}", val)),
            Self::U16(val) => f.write_fmt(format_args!("{:04x}", val)),
            Self::U32(val) => f.write_fmt(format_args!("{:08x}", val)),
            Self::U64(val) => f.write_fmt(format_args!("{:016x}", val)),
            Self::I8 (val) => f.write_fmt(format_args!("{:02x}", val)),
            Self::I16(val) => f.write_fmt(format_args!("{:04x}", val)),
            Self::I32(val) => f.write_fmt(format_args!("{:08x}", val)),
            Self::I64(val) => f.write_fmt(format_args!("{:016x}", val)),
        }
    }
}

/// A memory scanner!
struct Scan {
    /// Memory
    memory: Memory,

    /// Searches which yielded results
    matches: Vec<(Vec<Constraint>, Vec<(u64, Value)>)>,
}

impl Scan {
    /// Handle a command to the scanner
    fn handle_command(&mut self, command: &[String]) -> Result<()> {
        // Nothing to do
        if command.len() == 0 { return Ok(()); }

        match command[0].as_str() {
            "exit" | "q" | "quit" => {
                // Exit the program
                std::process::exit(0);
            }
            "h" => {
                // History, displays old query results
                if command.len() != 2 {
                    println!("h <query #>");
                    return Ok(());
                }

                // Get the query number
                let query = if command[1] == "l" {
                    // 'l' is a shortcut for "last" command
                    self.matches.len() - 1
                } else {
                    parse_usize(&command[1])?
                };
                if let Some((constraints, matches)) = self.matches.get(query) {
                    for &(addr, old) in matches.iter() {
                        // Read the new value
                        let tmp =
                            self.memory.read_slice::<u8>(addr, old.bytes())
                            .map_err(Error::Memory)?;

                        // Get the new value with the same typing as the old
                        // value
                        let mut new = old;
                        new.from_le_bytes(&tmp);

                        if old != new {
                            println!("{:016x} query: {} -> {}",
                                addr, old, new);
                        } else {
                            println!("{:016x} query: {}", addr, old);
                        }
                    }

                    println!(
                        "Query #{} had {} matches with constraints:\n{:#?}",
                        query, matches.len(), constraints);
                } else {
                    println!("No matching query");
                }
            }
            "m" => {
                // Print address maps
                if let Ok(maps) = self.memory.query_address_space() {
                    for region in maps {
                        println!("{:016x}-{:016x} {}{}{}",
                            region.base, region.end,
                            if region.r { "r" } else { " " },
                            if region.w { "w" } else { " " },
                            if region.x { "x" } else { " " });
                    }
                } else {
                    println!("Failed to query address map.");
                }
            }
            "uo" |
            "ub" | "uw" | "ud" | "uq" |
            "uB" | "uW" | "uD" | "uQ" | "uf" | "uF" => {
                // Re-query only the addresses of a previous query with new
                // constraints
                if command.len() < 3 {
                    println!("u[bwdqBWDQfF] <query #> [constraints]");
                    return Ok(());
                }

                // Create value associated with type
                let value = if command[0] == "uo" {
                    None
                } else {
                    Some(Value::default_from_letter(
                        command[0].as_bytes()[1] as char))
                };

                // Create list of constraints
                let mut constraints = Vec::new();
                for constraint in &command[2..] {
                    constraints.push(
                        Constraint::from_str_value(constraint, value)?);
                }

                // Get query ID
                let query = if command[1] == "l" {
                    self.matches.len() - 1
                } else {
                    parse_usize(&command[1])?
                };
                if let Some((_, old_matches)) = self.matches.get(query) {
                    // Search through old query matches
                    let mut matches = Vec::new();
                    for &(addr, old_value) in old_matches {
                        // Check if we have a concrete value, if not, compare
                        // against the last observed value
                        let mut value = if let Some(value) = value {
                            value
                        } else {
                            for constraint in constraints.iter_mut() {
                                constraint.update_val(old_value);
                            }

                            old_value
                        };

                        // Read the new value
                        let tmp = self.memory.read_slice::<u8>(
                            addr, value.bytes())
                            .map_err(Error::Memory)?;
                        value.from_le_bytes(&tmp);

                        // Check constraints
                        if constraints.iter().all(|x| x.check(value)) {
                            matches.push((addr, value));
                        }
                    }

                    if !matches.is_empty() {
                        println!("Got {} matches, saving as query #{:x}",
                            matches.len(), self.matches.len());
                        if matches.len() < 100 {
                            for (addr, value) in &matches {
                                println!("{:016x} {}", addr, value);
                            }
                        }
                        self.matches.push((constraints, matches));
                    } else {
                        println!("No matches.");
                    }
                } else {
                    println!("No matching query");
                }
            }
            "ss" => {
                // Search for a string
                if command.len() != 4 {
                    println!("ss <addr> <length> <string>");
                    return Ok(());
                }

                // Get the address and size
                let addr = parse_u64(&command[1])?;
                let size = parse_usize(&command[2])?;

                // Read the memory
                let tmp = self.memory.read_slice::<u8>(addr, size)
                    .map_err(Error::Memory)?;

                // String search
                tmp.windows(command[3].len()).enumerate()
                        .for_each(|(ii, window)| {
                    if window == command[3].as_bytes() {
                        println!("{:016x} {}", addr + ii as u64, command[3]);
                    }
                });
            }
            "sb" | "sw" | "sd" | "sq" |
            "sB" | "sW" | "sD" | "sQ" | "sf" | "sF" => {
                // Search for a value
                if command.len() <= 3 {
                    println!("s[bwdqBWDQfF] <addr> <length> [constraints]");
                    return Ok(());
                }

                // Get the address and size
                let addr = parse_u64(&command[1])?;
                let size = parse_usize(&command[2])?;

                // Read the memory
                let tmp = self.memory.read_slice::<u8>(addr, size)
                    .map_err(Error::Memory)?;

                // Create value associated with type
                let mut value =
                    Value::default_from_letter(
                        command[0].as_bytes()[1] as char);

                // Create list of constraints
                let mut constraints = Vec::new();
                for constraint in &command[3..] {
                    constraints.push(
                        Constraint::from_str_value(constraint, Some(value))?);
                }

                // Go through memory
                let mut matches = Vec::new();
                for (ii, chunk) in tmp.chunks_exact(value.bytes()).enumerate(){
                    // Update value
                    value.from_le_bytes(chunk);

                    // Check constraints
                    if constraints.iter().all(|x| x.check(value)) {
                        let addr = addr + ii as u64 * value.bytes() as u64;
                        matches.push((addr, value));
                    }
                }

                // If we got matches, save them off
                if !matches.is_empty() {
                    println!("Got {} matches, saving as query #{:x}",
                        matches.len(), self.matches.len());
                    if matches.len() < 100 {
                        for (addr, value) in &matches {
                            println!("{:016x} {}", addr, value);
                        }
                    }
                    self.matches.push((constraints, matches));
                } else {
                    println!("No matches.");
                }
            }
            "db" | "dw" | "dd" | "dq" |
            "dB" | "dW" | "dD" | "dQ" | "df" | "dF" =>{
                // Display memory
                if !matches!(command.len(), 2 | 3) {
                    println!("d[bwdqBWDQfF] <addr> [<number of bytes>]");
                    return Ok(());
                }

                // Get the letter used with this command and use it to create a
                // dummy expected value
                let mut value =
                    Value::default_from_letter(
                        command[0].as_bytes()[1] as char);

                // Parse integer address
                let addr = parse_u64(&command[1])?;

                // Determine number of bytes to read
                let bytes = if let Some(x) = command.get(2) {
                    parse_usize(x)?
                } else {
                    64
                };

                // Read memory
                let tmp = self.memory.read_slice::<u8>(addr, bytes)
                    .map_err(Error::Memory)?;

                // Print the new line header
                print!("\x1b[0;34m{:016x}\x1b[0m: ", addr);

                // Display all the values
                let mut output_used = 0;
                let mut iter = tmp.chunks_exact(
                    value.bytes()).map(|x| Some(x)).chain(
                    std::iter::repeat(None)).enumerate().peekable();
                while let Some((ii, val)) = iter.next() {
                    if let Some(val) = val {
                        // Print the value
                        value.from_le_bytes(val);

                        // Convert the value to a `u64` and try to use it as
                        // an address to see if it is a pointer
                        let maybe_addr = value.as_u64();
                        let valid_ptr =
                            self.memory.read::<u8>(maybe_addr).is_ok();

                        if valid_ptr {
                            print!("\x1b[0;32m{}\x1b[0m ", value);
                        } else {
                            print!("{} ", value);
                        }
                    } else {
                        // Clean
                        for _ in 0..value.display() {
                            print!("?");
                        }
                        print!(" ");
                    }

                    // Update output used for this line
                    output_used += 1;
                    let vals_per_line = 16 / value.bytes();
                    if output_used == vals_per_line {
                        // Before we make the newline, print the ASCII
                        let ascii = ii / vals_per_line * vals_per_line *
                            value.bytes();
                        for byte in tmp[ascii..].iter().take(16) {
                            if byte.is_ascii_graphic() {
                                print!("{}", *byte as char);
                            } else {
                                print!(".");
                            }
                        }
                        println!();

                        // If we have nothing more to print after this, we're
                        // done
                        if matches!(iter.peek(), Some((_, None))) {
                            return Ok(());
                        }

                        // Print the new line header
                        print!("\x1b[34m{:016x}\x1b[0m: ",
                            addr + (ii as u64 + 1) * value.bytes() as u64);

                        // Update state
                        output_used = 0;
                    }
                }
            }
            _ => {
                println!("Unknown command: {:?}", command);
            }
        }

        Ok(())
    }
}

fn main() -> Result<()> {
    // Get the arguments
    let args = std::env::args().collect::<Vec<_>>();
    if args.len() != 2 {
        println!("Usage: peek <pid>");
        return Ok(());
    }

    // Get the PID
    let pid = usize::from_str_radix(&args[1], 10)
        .map_err(Error::InvalidPid)?;

    // Create a readline handler
    let mut rl = Editor::<()>::new();
    let _ = rl.load_history(".peekieboi");

    // Create a memory scanner
    let mut scan = Scan {
        memory:  Memory::pid(pid).map_err(Error::Memory)?,
        matches: Vec::new(),
    };

    // Wait for commands
    loop {
        // Get command
        let command = match rl.readline(">> ") {
            Ok(x) => x,
            Err(ReadlineError::Interrupted) => {
                // Ctrl+c
                break;
            }
            Err(x) => return Err(Error::Readline(x)),
        };
        rl.add_history_entry(command.as_str());
        let _ = rl.save_history(".peekieboi");

        // Split command
        let command = QuotedParts::from(command.trim()).collect::<Vec<_>>();
        if let Err(err) = scan.handle_command(&command) {
            println!("Failed to execute command: {:?}", err);
        }
    }

    Ok(())
}


```