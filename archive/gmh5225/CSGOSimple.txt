Project Path: arc_gmh5225_CSGOSimple_uqmuicec

Source Tree:

```txt
arc_gmh5225_CSGOSimple_uqmuicec
├── CSGOSimple
│   ├── CSGOSimple.vcxproj
│   ├── CSGOSimple.vcxproj.filters
│   ├── UI.cpp
│   ├── config.hpp
│   ├── features
│   │   ├── bhop.cpp
│   │   ├── bhop.hpp
│   │   ├── chams.cpp
│   │   ├── chams.hpp
│   │   ├── glow.cpp
│   │   ├── glow.hpp
│   │   ├── visuals.cpp
│   │   └── visuals.hpp
│   ├── fonts
│   │   ├── cousine.hpp
│   │   ├── droid.hpp
│   │   └── fonts.hpp
│   ├── helpers
│   │   ├── input.cpp
│   │   ├── input.hpp
│   │   ├── math.cpp
│   │   ├── math.hpp
│   │   ├── utils.cpp
│   │   ├── utils.hpp
│   │   ├── vfunc_hook.cpp
│   │   └── vfunc_hook.hpp
│   ├── hooks.cpp
│   ├── hooks.hpp
│   ├── imgui
│   │   ├── LICENSE.txt
│   │   ├── imconfig.h
│   │   ├── imgui.cpp
│   │   ├── imgui.h
│   │   ├── imgui_draw.cpp
│   │   ├── imgui_internal.h
│   │   ├── imgui_widgets.cpp
│   │   ├── impl
│   │   │   ├── imgui_impl_dx9.cpp
│   │   │   ├── imgui_impl_dx9.h
│   │   │   ├── imgui_impl_win32.cpp
│   │   │   └── imgui_impl_win32.h
│   │   ├── imstb_rectpack.h
│   │   ├── imstb_textedit.h
│   │   └── imstb_truetype.h
│   ├── main.cpp
│   ├── menu.cpp
│   ├── menu.hpp
│   ├── options.cpp
│   ├── options.hpp
│   ├── render.cpp
│   ├── render.hpp
│   ├── singleton.hpp
│   ├── ui.hpp
│   └── valve_sdk
│       ├── csgostructs.cpp
│       ├── csgostructs.hpp
│       ├── interfaces
│       │   ├── CClientState.hpp
│       │   ├── CInput.hpp
│       │   ├── IAppSystem.hpp
│       │   ├── IBaseClientDll.hpp
│       │   ├── IClientEntity.hpp
│       │   ├── IClientEntityList.hpp
│       │   ├── IClientMode.hpp
│       │   ├── IClientNetworkable.hpp
│       │   ├── IClientRenderable.hpp
│       │   ├── IClientThinkable.hpp
│       │   ├── IClientUnknown.hpp
│       │   ├── ICollideable.hpp
│       │   ├── IConVar.hpp
│       │   ├── ICvar.hpp
│       │   ├── IEngineSound.hpp
│       │   ├── IEngineTrace.hpp
│       │   ├── IGameEventmanager.hpp
│       │   ├── IInputSystem.hpp
│       │   ├── IMDLCache.hpp
│       │   ├── IMaterialSystem.hpp
│       │   ├── IMoveHelper.hpp
│       │   ├── IPanel.hpp
│       │   ├── IPhysics.hpp
│       │   ├── IPrediction.hpp
│       │   ├── IRefCounted.hpp
│       │   ├── IRenderView.hpp
│       │   ├── ISurface.hpp
│       │   ├── IVDebugOverlay.hpp
│       │   ├── IVEngineClient.hpp
│       │   ├── IVModelInfoClient.hpp
│       │   ├── IVModelRender.hpp
│       │   └── IViewRender.hpp
│       ├── math
│       │   ├── QAngle.hpp
│       │   ├── VMatrix.cpp
│       │   ├── VMatrix.hpp
│       │   ├── Vector.hpp
│       │   ├── Vector2D.cpp
│       │   ├── Vector2D.hpp
│       │   ├── Vector4D.cpp
│       │   └── Vector4D.hpp
│       ├── misc
│       │   ├── BaseHandle.hpp
│       │   ├── CUserCmd.hpp
│       │   ├── ClientClass.hpp
│       │   ├── Color.cpp
│       │   ├── Color.hpp
│       │   ├── Convar.cpp
│       │   ├── Convar.hpp
│       │   ├── EHandle.hpp
│       │   ├── Enums.hpp
│       │   ├── GlobalVars.hpp
│       │   ├── IHandleEntity.hpp
│       │   ├── Recv.hpp
│       │   ├── Studio.hpp
│       │   ├── UtlBuffer.cpp
│       │   ├── UtlBuffer.hpp
│       │   ├── UtlMemory.hpp
│       │   ├── UtlString.cpp
│       │   ├── UtlString.hpp
│       │   ├── UtlVector.hpp
│       │   ├── characterset.cpp
│       │   ├── characterset.hpp
│       │   ├── checksum_crc.cpp
│       │   ├── checksum_crc.hpp
│       │   ├── checksum_md5.cpp
│       │   ├── checksum_md5.hpp
│       │   ├── datamap.hpp
│       │   ├── glow_outline_effect.hpp
│       │   ├── platform.hpp
│       │   └── vfunc.hpp
│       ├── netvars.cpp
│       ├── netvars.hpp
│       ├── sdk.cpp
│       └── sdk.hpp
├── CSGOSimple.DotSettings
├── CSGOSimple.sln
├── CSGOSimple.sln.DotSettings
├── LICENSE
├── README.md
└── SimpleInjector
    ├── README.md
    ├── SimpleInjector.vcxproj
    ├── SimpleInjector.vcxproj.filters
    └── main.cpp

```

`CSGOSimple.DotSettings`:

```DotSettings
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CppFormatting/CASE_BLOCK_BRACES/@EntryValue">NEXT_LINE</s:String>
	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CppFormatting/INDENT_CASE_FROM_SWITCH/@EntryValue">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CppFormatting/OTHER_BRACES/@EntryValue">END_OF_LINE</s:String>
	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CppFormatting/PLACE_CATCH_ON_NEW_LINE/@EntryValue">False</s:Boolean>
	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CppFormatting/PLACE_ELSE_ON_NEW_LINE/@EntryValue">False</s:Boolean>
	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CppFormatting/PLACE_WHILE_ON_NEW_LINE/@EntryValue">False</s:Boolean>
	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CppFormatting/USE_INDENT_FROM_VS/@EntryValue">False</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EFeature_002EServices_002ECpp_002ECodeStyle_002ESettingsUpgrade_002ENamespaceIndentationSettingsUpgrader/@EntryIndexedValue">True</s:Boolean></wpf:ResourceDictionary>
```

`CSGOSimple.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CSGOSimple", "CSGOSimple\CSGOSimple.vcxproj", "{F3E42845-8D56-4BB3-821D-8163AB1337F0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SimpleInjector", "SimpleInjector\SimpleInjector.vcxproj", "{D6A5475A-A3D9-4971-B971-A94520CB0354}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Debug|x64.ActiveCfg = Debug|Win32
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Debug|x86.ActiveCfg = Debug|Win32
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Debug|x86.Build.0 = Debug|Win32
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Release|x64.ActiveCfg = Release|Win32
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Release|x86.ActiveCfg = Release|Win32
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Release|x86.Build.0 = Release|Win32
		{D6A5475A-A3D9-4971-B971-A94520CB0354}.Debug|x64.ActiveCfg = Debug|x64
		{D6A5475A-A3D9-4971-B971-A94520CB0354}.Debug|x64.Build.0 = Debug|x64
		{D6A5475A-A3D9-4971-B971-A94520CB0354}.Debug|x86.ActiveCfg = Debug|Win32
		{D6A5475A-A3D9-4971-B971-A94520CB0354}.Debug|x86.Build.0 = Debug|Win32
		{D6A5475A-A3D9-4971-B971-A94520CB0354}.Release|x64.ActiveCfg = Release|x64
		{D6A5475A-A3D9-4971-B971-A94520CB0354}.Release|x64.Build.0 = Release|x64
		{D6A5475A-A3D9-4971-B971-A94520CB0354}.Release|x86.ActiveCfg = Release|Win32
		{D6A5475A-A3D9-4971-B971-A94520CB0354}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`CSGOSimple.sln.DotSettings`:

```DotSettings
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/Environment/InjectedLayers/FileInjectedLayer/=CBE417346466784E83BDFA9C3F62BA54/AbsolutePath/@EntryValue">C:\Users\Marcelo\Documents\Development\Sources\CSGOSimple\CSGOSimple.DotSettings</s:String>
	<s:String x:Key="/Default/Environment/InjectedLayers/FileInjectedLayer/=CBE417346466784E83BDFA9C3F62BA54/RelativePath/@EntryValue">..\CSGOSimple.DotSettings</s:String>
	<s:Boolean x:Key="/Default/Environment/InjectedLayers/FileInjectedLayer/=CBE417346466784E83BDFA9C3F62BA54/@KeyIndexDefined">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/InjectedLayers/InjectedLayerCustomization/=FileCBE417346466784E83BDFA9C3F62BA54/@KeyIndexDefined">True</s:Boolean>
	<s:Double x:Key="/Default/Environment/InjectedLayers/InjectedLayerCustomization/=FileCBE417346466784E83BDFA9C3F62BA54/RelativePriority/@EntryValue">1</s:Double></wpf:ResourceDictionary>
```

`CSGOSimple/CSGOSimple.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F3E42845-8D56-4BB3-821D-8163AB1337F0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>CSGOSimple</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <TargetName>csgosimple</TargetName>
    <LibraryPath>$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <TargetName>csgosimple</TargetName>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(NETFXKitsDir)Lib\um\x86;$(DXSDK_DIR)Lib\x86</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;CSGOSIMPLE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;CSGOSIMPLE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <DebugInformationFormat>None</DebugInformationFormat>
      <SDLCheck>false</SDLCheck>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="features\bhop.cpp" />
    <ClCompile Include="features\chams.cpp" />
    <ClCompile Include="features\glow.cpp" />
    <ClCompile Include="features\visuals.cpp" />
    <ClCompile Include="helpers\input.cpp" />
    <ClCompile Include="helpers\math.cpp" />
    <ClCompile Include="helpers\utils.cpp" />
    <ClCompile Include="helpers\vfunc_hook.cpp" />
    <ClCompile Include="hooks.cpp" />
    <ClCompile Include="imgui\imgui.cpp" />
    <ClCompile Include="imgui\imgui_draw.cpp" />
    <ClCompile Include="imgui\imgui_widgets.cpp" />
    <ClCompile Include="imgui\impl\imgui_impl_dx9.cpp" />
    <ClCompile Include="imgui\impl\imgui_impl_win32.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="menu.cpp" />
    <ClCompile Include="render.cpp" />
    <ClCompile Include="ui.cpp" />
    <ClCompile Include="valve_sdk\csgostructs.cpp" />
    <ClCompile Include="valve_sdk\sdk.cpp" />
    <ClCompile Include="valve_sdk\math\Vector2D.cpp" />
    <ClCompile Include="valve_sdk\math\Vector4D.cpp" />
    <ClCompile Include="valve_sdk\math\VMatrix.cpp" />
    <ClCompile Include="valve_sdk\misc\characterset.cpp" />
    <ClCompile Include="valve_sdk\misc\checksum_crc.cpp" />
    <ClCompile Include="valve_sdk\misc\checksum_md5.cpp" />
    <ClCompile Include="valve_sdk\misc\Color.cpp" />
    <ClCompile Include="valve_sdk\misc\Convar.cpp" />
    <ClCompile Include="valve_sdk\misc\UtlBuffer.cpp" />
    <ClCompile Include="valve_sdk\misc\UtlString.cpp" />
    <ClCompile Include="valve_sdk\netvars.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="config.hpp" />
    <ClInclude Include="fonts\cousine.hpp" />
    <ClInclude Include="fonts\fonts.hpp" />
    <ClInclude Include="imgui\impl\imgui_impl_dx9.h" />
    <ClInclude Include="imgui\impl\imgui_impl_win32.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="valve_sdk\Misc\datamap.hpp" />
    <ClInclude Include="fonts\droid.hpp" />
    <ClInclude Include="features\bhop.hpp" />
    <ClInclude Include="features\chams.hpp" />
    <ClInclude Include="features\glow.hpp" />
    <ClInclude Include="features\visuals.hpp" />
    <ClInclude Include="helpers\input.hpp" />
    <ClInclude Include="helpers\math.hpp" />
    <ClInclude Include="helpers\utils.hpp" />
    <ClInclude Include="helpers\vfunc_hook.hpp" />
    <ClInclude Include="hooks.hpp" />
    <ClInclude Include="imgui\imconfig.h" />
    <ClInclude Include="imgui\imgui.h" />
    <ClInclude Include="imgui\imgui_internal.h" />
    <ClInclude Include="imgui\stb_rect_pack.h" />
    <ClInclude Include="imgui\stb_textedit.h" />
    <ClInclude Include="imgui\stb_truetype.h" />
    <ClInclude Include="valve_sdk\interfaces\IRefCounted.hpp" />
    <ClInclude Include="menu.hpp" />
    <ClInclude Include="options.hpp" />
    <ClInclude Include="render.hpp" />
    <ClInclude Include="singleton.hpp" />
    <ClInclude Include="ui.hpp" />
    <ClInclude Include="valve_sdk\csgostructs.hpp" />
    <ClInclude Include="valve_sdk\sdk.hpp" />
    <ClInclude Include="valve_sdk\interfaces\CClientState.hpp" />
    <ClInclude Include="valve_sdk\interfaces\CInput.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IAppSystem.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IBaseClientDll.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientEntity.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientEntityList.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientMode.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientNetworkable.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientRenderable.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientThinkable.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientUnknown.hpp" />
    <ClInclude Include="valve_sdk\interfaces\ICollideable.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IConVar.hpp" />
    <ClInclude Include="valve_sdk\interfaces\ICvar.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IEngineSound.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IEngineTrace.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IGameEventmanager.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IMaterialSystem.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IMDLCache.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IMoveHelper.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IPanel.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IPhysics.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IPrediction.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IRenderView.hpp" />
    <ClInclude Include="valve_sdk\interfaces\ISurface.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IVDebugOverlay.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IVEngineClient.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IViewRender.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IVModelInfoClient.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IVModelRender.hpp" />
    <ClInclude Include="valve_sdk\math\QAngle.hpp" />
    <ClInclude Include="valve_sdk\math\Vector.hpp" />
    <ClInclude Include="valve_sdk\math\Vector2D.hpp" />
    <ClInclude Include="valve_sdk\math\Vector4D.hpp" />
    <ClInclude Include="valve_sdk\math\VMatrix.hpp" />
    <ClInclude Include="valve_sdk\misc\BaseHandle.hpp" />
    <ClInclude Include="valve_sdk\misc\characterset.hpp" />
    <ClInclude Include="valve_sdk\misc\checksum_crc.hpp" />
    <ClInclude Include="valve_sdk\misc\checksum_md5.hpp" />
    <ClInclude Include="valve_sdk\misc\ClientClass.hpp" />
    <ClInclude Include="valve_sdk\misc\Color.hpp" />
    <ClInclude Include="valve_sdk\misc\Convar.hpp" />
    <ClInclude Include="valve_sdk\misc\CUserCmd.hpp" />
    <ClInclude Include="valve_sdk\misc\EHandle.hpp" />
    <ClInclude Include="valve_sdk\misc\Enums.hpp" />
    <ClInclude Include="valve_sdk\misc\GlobalVars.hpp" />
    <ClInclude Include="valve_sdk\misc\glow_outline_effect.hpp" />
    <ClInclude Include="valve_sdk\misc\IHandleEntity.hpp" />
    <ClInclude Include="valve_sdk\misc\platform.hpp" />
    <ClInclude Include="valve_sdk\misc\Recv.hpp" />
    <ClInclude Include="valve_sdk\misc\Studio.hpp" />
    <ClInclude Include="valve_sdk\misc\UtlBuffer.hpp" />
    <ClInclude Include="valve_sdk\misc\UtlMemory.hpp" />
    <ClInclude Include="valve_sdk\misc\UtlString.hpp" />
    <ClInclude Include="valve_sdk\misc\UtlVector.hpp" />
    <ClInclude Include="valve_sdk\misc\vfunc.hpp" />
    <ClInclude Include="valve_sdk\netvars.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGOSimple/CSGOSimple.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\SDK">
      <UniqueIdentifier>{532bd2d3-56d4-4b80-9705-133b9cef34df}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\imgui">
      <UniqueIdentifier>{be04c48c-66c1-4221-ac11-38f6bab82130}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\features">
      <UniqueIdentifier>{2bc982e4-598c-49fb-ad20-458d3b3bc2a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\SDK">
      <UniqueIdentifier>{edb96b28-881c-4810-bf58-6ef7ed18cd5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\imgui">
      <UniqueIdentifier>{162aa2f8-15b9-4b39-a283-b120ebdf8013}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\features">
      <UniqueIdentifier>{69bb20b4-f120-4f70-8694-cf3aaa9c085c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\fonts">
      <UniqueIdentifier>{69d9715e-6194-4271-9c84-4b80235b0dba}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Helpers\math.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Helpers\utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="menu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\characterset.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\checksum_crc.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\checksum_md5.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\csgostructs.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\sdk.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\UtlBuffer.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\UtlString.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\math\Vector2D.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\math\Vector4D.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="helpers\vfunc_hook.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\math\VMatrix.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_draw.cpp">
      <Filter>Source Files\imgui</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui.cpp">
      <Filter>Source Files\imgui</Filter>
    </ClCompile>
    <ClCompile Include="features\bhop.cpp">
      <Filter>Source Files\features</Filter>
    </ClCompile>
    <ClCompile Include="features\chams.cpp">
      <Filter>Source Files\features</Filter>
    </ClCompile>
    <ClCompile Include="features\glow.cpp">
      <Filter>Source Files\features</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\Convar.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\Color.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\netvars.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="helpers\input.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="render.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ui.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals.cpp">
      <Filter>Source Files\features</Filter>
    </ClCompile>
    <ClCompile Include="imgui\impl\imgui_impl_dx9.cpp">
      <Filter>Source Files\imgui</Filter>
    </ClCompile>
    <ClCompile Include="imgui\impl\imgui_impl_win32.cpp">
      <Filter>Source Files\imgui</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_widgets.cpp">
      <Filter>Source Files\imgui</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="valve_sdk\misc\BaseHandle.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CClientState.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\characterset.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\checksum_crc.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\checksum_md5.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CInput.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\ClientClass.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Color.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Convar.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\CUserCmd.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\EHandle.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Enums.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\GlobalVars.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\glow_outline_effect.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IAppSystem.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IBaseClientDll.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientEntity.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientEntityList.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientMode.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientNetworkable.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientRenderable.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientThinkable.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientUnknown.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\ICollideable.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IConVar.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\ICvar.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IEngineSound.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IEngineTrace.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IGameEventmanager.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\IHandleEntity.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMaterialSystem.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMDLCache.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMoveHelper.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IPanel.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IPhysics.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IPrediction.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IRenderView.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\ISurface.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVDebugOverlay.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVEngineClient.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IViewRender.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVModelInfoClient.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVModelRender.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\platform.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\math\QAngle.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Recv.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\sdk.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="imgui\stb_rect_pack.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="imgui\stb_textedit.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="imgui\stb_truetype.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Studio.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\UtlBuffer.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\UtlMemory.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\UtlString.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\UtlVector.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\math\Vector.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\math\Vector2D.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\math\Vector4D.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\vfunc.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\math\VMatrix.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="hooks.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="helpers\math.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="menu.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="options.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="singleton.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="helpers\utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="helpers\vfunc_hook.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imgui_internal.h">
      <Filter>Header Files\imgui</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imgui.h">
      <Filter>Header Files\imgui</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imconfig.h">
      <Filter>Header Files\imgui</Filter>
    </ClInclude>
    <ClInclude Include="features\bhop.hpp">
      <Filter>Header Files\features</Filter>
    </ClInclude>
    <ClInclude Include="features\chams.hpp">
      <Filter>Header Files\features</Filter>
    </ClInclude>
    <ClInclude Include="features\glow.hpp">
      <Filter>Header Files\features</Filter>
    </ClInclude>
    <ClInclude Include="features\visuals.hpp">
      <Filter>Header Files\features</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\csgostructs.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\netvars.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="helpers\input.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ui.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="render.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IRefCounted.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\Misc\datamap.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="imgui\impl\imgui_impl_dx9.h">
      <Filter>Header Files\imgui</Filter>
    </ClInclude>
    <ClInclude Include="imgui\impl\imgui_impl_win32.h">
      <Filter>Header Files\imgui</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="fonts\droid.hpp">
      <Filter>Header Files\fonts</Filter>
    </ClInclude>
    <ClInclude Include="fonts\fonts.hpp">
      <Filter>Header Files\fonts</Filter>
    </ClInclude>
    <ClInclude Include="fonts\cousine.hpp">
      <Filter>Header Files\fonts</Filter>
    </ClInclude>
    <ClInclude Include="config.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CSGOSimple/UI.cpp`:

```cpp
#include "ui.hpp"
#include "menu.hpp"
#include <deque>
#include <algorithm>
#include <vector>

//template <class T>
//bool ComboForSkins(const char* label, std::vector current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1) {
//	
//}
bool ImGui::ToggleButton(const char* label, bool* v, const ImVec2& size_arg)
{

	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	int flags = 0;
	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);

	ImVec2 pos = window->DC.CursorPos;
	ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	const ImRect bb(pos, pos + size);
	ImGui::ItemSize(bb, style.FramePadding.y);
	if (!ImGui::ItemAdd(bb, id))
		return false;

	if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat) flags |= ImGuiButtonFlags_Repeat;
	bool hovered, held;
	bool pressed = ImGui::ButtonBehavior(bb, id, &hovered, &held, flags);

	// Render
	const ImU32 col = ImGui::GetColorU32((hovered && held || *v) ? ImGuiCol_ButtonActive : (hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button));
	ImGui::RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);
	ImGui::RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);
	if (pressed)
		*v = !*v;

	return pressed;
}

static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
	const char* const* items = (const char* const*)data;
	if (out_text)
		*out_text = items[idx];
	return true;
}

static auto vector_getter = [](void* vec, int idx, const char** out_text) {
	auto& vector = *static_cast<std::vector<std::string>*>(vec);
	if (idx < 0 || idx >= static_cast<int>(vector.size())) { return false; }
	*out_text = vector.at(idx).c_str();
	return true;
};

bool ImGui::Combo(const char* label, int* currIndex, std::vector<std::string>& values) {
	if (values.empty()) { return false; }
	return ImGui::Combo(label, currIndex, vector_getter,
		static_cast<void*>(&values), values.size());
}

bool ImGui::BeginGroupBox(const char* name, const ImVec2& size_arg)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	ImGuiWindowFlags flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow;

	window->DC.CursorPos.y += GImGui->FontSize / 2;
	const ImVec2 content_avail = ImGui::GetContentRegionAvail();
	ImVec2 size = ImFloor(size_arg);
	if (size.x <= 0.0f) {
		size.x = ImMax(content_avail.x, 4.0f) - fabsf(size.x); // Arbitrary minimum zero-ish child size of 4.0f (0.0f causing too much issues)
	}
	if (size.y <= 0.0f) {
		size.y = ImMax(content_avail.y, 4.0f) - fabsf(size.y);
	}

	ImGui::SetNextWindowSize(size);
	bool ret;
	ImGui::Begin(name, &ret, flags);
	//bool ret = ImGui::Begin(name, NULL, size, -1.0f, flags);

	window = ImGui::GetCurrentWindow();

	auto padding = ImGui::GetStyle().WindowPadding;

	auto text_size = ImGui::CalcTextSize(name, NULL, true);

	if (text_size.x > 1.0f) {
		window->DrawList->PushClipRectFullScreen();
		//window->DrawList->AddRectFilled(window->DC.CursorPos - ImVec2{ 4, 0 }, window->DC.CursorPos + (text_size + ImVec2{ 4, 0 }), GetColorU32(ImGuiCol_ChildWindowBg));
		//RenderTextClipped(pos, pos + text_size, name, NULL, NULL, GetColorU32(ImGuiCol_Text));
		window->DrawList->PopClipRect();
	}
	//if (!(window->Flags & ImGuiWindowFlags_ShowBorders))
	//	ImGui::GetCurrentWindow()->Flags &= ~ImGuiWindowFlags_ShowBorders;

	return ret;
}

void ImGui::EndGroupBox()
{
	ImGui::EndChild();
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	window->DC.CursorPosPrevLine.y -= GImGui->FontSize / 2;
}

const char* const KeyNames[] = {
	"Unknown",
	"VK_LBUTTON",
	"VK_RBUTTON",
	"VK_CANCEL",
	"VK_MBUTTON",
	"VK_XBUTTON1",
	"VK_XBUTTON2",
	"Unknown",
	"VK_BACK",
	"VK_TAB",
	"Unknown",
	"Unknown",
	"VK_CLEAR",
	"VK_RETURN",
	"Unknown",
	"Unknown",
	"VK_SHIFT",
	"VK_CONTROL",
	"VK_MENU",
	"VK_PAUSE",
	"VK_CAPITAL",
	"VK_KANA",
	"Unknown",
	"VK_JUNJA",
	"VK_FINAL",
	"VK_KANJI",
	"Unknown",
	"VK_ESCAPE",
	"VK_CONVERT",
	"VK_NONCONVERT",
	"VK_ACCEPT",
	"VK_MODECHANGE",
	"VK_SPACE",
	"VK_PRIOR",
	"VK_NEXT",
	"VK_END",
	"VK_HOME",
	"VK_LEFT",
	"VK_UP",
	"VK_RIGHT",
	"VK_DOWN",
	"VK_SELECT",
	"VK_PRINT",
	"VK_EXECUTE",
	"VK_SNAPSHOT",
	"VK_INSERT",
	"VK_DELETE",
	"VK_HELP",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"VK_LWIN",
	"VK_RWIN",
	"VK_APPS",
	"Unknown",
	"VK_SLEEP",
	"VK_NUMPAD0",
	"VK_NUMPAD1",
	"VK_NUMPAD2",
	"VK_NUMPAD3",
	"VK_NUMPAD4",
	"VK_NUMPAD5",
	"VK_NUMPAD6",
	"VK_NUMPAD7",
	"VK_NUMPAD8",
	"VK_NUMPAD9",
	"VK_MULTIPLY",
	"VK_ADD",
	"VK_SEPARATOR",
	"VK_SUBTRACT",
	"VK_DECIMAL",
	"VK_DIVIDE",
	"VK_F1",
	"VK_F2",
	"VK_F3",
	"VK_F4",
	"VK_F5",
	"VK_F6",
	"VK_F7",
	"VK_F8",
	"VK_F9",
	"VK_F10",
	"VK_F11",
	"VK_F12",
	"VK_F13",
	"VK_F14",
	"VK_F15",
	"VK_F16",
	"VK_F17",
	"VK_F18",
	"VK_F19",
	"VK_F20",
	"VK_F21",
	"VK_F22",
	"VK_F23",
	"VK_F24",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"VK_NUMLOCK",
	"VK_SCROLL",
	"VK_OEM_NEC_EQUAL",
	"VK_OEM_FJ_MASSHOU",
	"VK_OEM_FJ_TOUROKU",
	"VK_OEM_FJ_LOYA",
	"VK_OEM_FJ_ROYA",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"VK_LSHIFT",
	"VK_RSHIFT",
	"VK_LCONTROL",
	"VK_RCONTROL",
	"VK_LMENU",
	"VK_RMENU"
};

bool ImGui::Hotkey(const char* label, int* k, const ImVec2& size_arg)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	ImGuiIO& io = g.IO;
	const ImGuiStyle& style = g.Style;

	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);
	ImVec2 size = ImGui::CalcItemSize(size_arg, ImGui::CalcItemWidth(), label_size.y + style.FramePadding.y*2.0f);
	const ImRect frame_bb(window->DC.CursorPos + ImVec2(label_size.x + style.ItemInnerSpacing.x, 0.0f), window->DC.CursorPos + size);
	const ImRect total_bb(window->DC.CursorPos, frame_bb.Max);

	ImGui::ItemSize(total_bb, style.FramePadding.y);
	if (!ImGui::ItemAdd(total_bb, id))
		return false;

	const bool focus_requested = ImGui::FocusableItemRegister(window, g.ActiveId == id, false);
	const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);
	const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

	const bool hovered = ImGui::ItemHoverable(frame_bb, id);

	if (hovered) {
		ImGui::SetHoveredID(id);
		g.MouseCursor = ImGuiMouseCursor_TextInput;
	}

	const bool user_clicked = hovered && io.MouseClicked[0];

	if (focus_requested || user_clicked) {
		if (g.ActiveId != id) {
			// Start edition
			memset(io.MouseDown, 0, sizeof(io.MouseDown));
			memset(io.KeysDown, 0, sizeof(io.KeysDown));
			*k = 0;
		}
		ImGui::SetActiveID(id, window);
		ImGui::FocusWindow(window);
	}
	else if (io.MouseClicked[0]) {
		// Release focus when we click outside
		if (g.ActiveId == id)
			ImGui::ClearActiveID();
	}

	bool value_changed = false;
	int key = *k;

	if (g.ActiveId == id) {
		for (auto i = 0; i < 5; i++) {
			if (io.MouseDown[i]) {
				switch (i) {
				case 0:
					key = VK_LBUTTON;
					break;
				case 1:
					key = VK_RBUTTON;
					break;
				case 2:
					key = VK_MBUTTON;
					break;
				case 3:
					key = VK_XBUTTON1;
					break;
				case 4:
					key = VK_XBUTTON2;
					break;
				}
				value_changed = true;
				ImGui::ClearActiveID();
			}
		}
		if (!value_changed) {
			for (auto i = VK_BACK; i <= VK_RMENU; i++) {
				if (io.KeysDown[i]) {
					key = i;
					value_changed = true;
					ImGui::ClearActiveID();
				}
			}
		}

		if (IsKeyPressedMap(ImGuiKey_Escape)) {
			*k = 0;
			ImGui::ClearActiveID();
		}
		else {
			*k = key;
		}
	}

	// Render
	// Select which buffer we are going to display. When ImGuiInputTextFlags_NoLiveEdit is Set 'buf' might still be the old value. We Set buf to NULL to prevent accidental usage from now on.

	char buf_display[64] = "None";

	ImGui::RenderFrame(frame_bb.Min, frame_bb.Max, ImGui::GetColorU32(ImVec4(0.20f, 0.25f, 0.30f, 1.0f)), true, style.FrameRounding);

	if (*k != 0 && g.ActiveId != id) {
		strcpy_s(buf_display, KeyNames[*k]);
	}
	else if (g.ActiveId == id) {
		strcpy_s(buf_display, "<Press a key>");
	}

	const ImRect clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size
	ImVec2 render_pos = frame_bb.Min + style.FramePadding;
	ImGui::RenderTextClipped(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding, buf_display, NULL, NULL, style.ButtonTextAlign, &clip_rect);
	//RenderTextClipped(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding, buf_display, NULL, NULL, GetColorU32(ImGuiCol_Text), style.ButtonTextAlign, &clip_rect);
	//draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos, GetColorU32(ImGuiCol_Text), buf_display, NULL, 0.0f, &clip_rect);

	if (label_size.x > 0)
		ImGui::RenderText(ImVec2(total_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), label);

	return value_changed;
}


bool ImGui::ListBox(const char* label, int* current_item, std::string items[], int items_count, int height_items) {
	char **tmp;
	tmp = new char*[items_count];//(char**)malloc(sizeof(char*) * items_count);
	for (int i = 0; i < items_count; i++) {
		//tmp[i] = new char[items[i].size()];//(char*)malloc(sizeof(char*));
		tmp[i] = const_cast<char*>(items[i].c_str());
	}

	const bool value_changed = ImGui::ListBox(label, current_item, Items_ArrayGetter, static_cast<void*>(tmp), items_count, height_items);
	return value_changed;
}

bool ImGui::ListBox(const char* label, int* current_item, std::function<const char*(int)> lambda, int items_count, int height_in_items)
{
	return ImGui::ListBox(label, current_item, [](void* data, int idx, const char** out_text)
	{
		*out_text = (*reinterpret_cast<std::function<const char*(int)>*>(data))(idx);
		return true;
	}, &lambda, items_count, height_in_items);
}

bool ImGui::Combo(const char* label, int* current_item, std::function<const char*(int)> lambda, int items_count, int height_in_items)
{
	return ImGui::Combo(label, current_item, [](void* data, int idx, const char** out_text)
	{
		*out_text = (*reinterpret_cast<std::function<const char*(int)>*>(data))(idx);
		return true;
	}, &lambda, items_count, height_in_items);
}

```

`CSGOSimple/config.hpp`:

```hpp
#pragma once
#include "options.hpp"
#include "singleton.hpp"

#include <fstream>




class Config : public Singleton<Config> {
public:
	void Save() {
		std::ofstream fout("csgosimple.cfg", std::ios::binary);
		const auto sz = sizeof(Options);
		const auto var_sz = sizeof(Var<bool>);
		const auto cnt = sz / var_sz;
		for (auto i = 0; i < cnt; i++) {
			const auto el = &(*(Var<int>*)(&g_Options)) + i;
			auto name = el->name;
			auto val = el->value;
			auto sizeof_val = el->size;
			fout << name << "\t" << Utils::BytesToString((unsigned char*)*(int*)&val, sizeof_val) << std::endl;
		}
		fout.close();
	}


	void Load() {
		std::ifstream fin("csgosimple.cfg", std::ios::binary);
		std::stringstream ss;
		ss << fin.rdbuf();


		auto lines = Utils::Split(ss.str(), "\n");

		for (auto line : lines) {
			auto data = Utils::Split(line, "\t");
			const auto sz = sizeof(Options);
			const auto var_sz = sizeof(Var<bool>);
			const auto cnt = sz / var_sz;
			for (auto i = 0; i < cnt; i++) {
				const auto &el = &(*(Var<bool>*)(&g_Options)) + i;
				if (data[0] == el->name) {
					auto bytes = Utils::HexToBytes(data[1]);
					memcpy(*(void**)&el->value, bytes.data(), el->size);
				}
			}
		}
		fin.close();
	}
};
```

`CSGOSimple/features/bhop.cpp`:

```cpp
#include "bhop.hpp"

#include "../valve_sdk/csgostructs.hpp"

void BunnyHop::OnCreateMove(CUserCmd* cmd)
{
  static bool jumped_last_tick = false;
  static bool should_fake_jump = false;

  if (!g_LocalPlayer)
	  return;

  if (!g_LocalPlayer->IsAlive())
	  return;

  if (g_LocalPlayer->m_nMoveType() == MOVETYPE_LADDER || g_LocalPlayer->m_nMoveType() == MOVETYPE_NOCLIP)
	  return;

  if (g_LocalPlayer->m_fFlags() & FL_INWATER)
	  return;

  if(!jumped_last_tick && should_fake_jump) {
    should_fake_jump = false;
    cmd->buttons |= IN_JUMP;
  } else if(cmd->buttons & IN_JUMP) {
    if(g_LocalPlayer->m_fFlags() & FL_ONGROUND) {
      jumped_last_tick = true;
      should_fake_jump = true;
    } else {
      cmd->buttons &= ~IN_JUMP;
      jumped_last_tick = false;
    }
  } else {
    jumped_last_tick = false;
    should_fake_jump = false;
  }
}
```

`CSGOSimple/features/bhop.hpp`:

```hpp
#pragma once

class C_BasePlayer;
class CUserCmd;

namespace BunnyHop
{
    void OnCreateMove(CUserCmd* cmd);
}
```

`CSGOSimple/features/chams.cpp`:

```cpp
#include "chams.hpp"
#include <fstream>

#include "../valve_sdk/csgostructs.hpp"
#include "../options.hpp"
#include "../hooks.hpp"
#include "../helpers/input.hpp"


Chams::Chams() {
	materialRegular = g_MatSystem->FindMaterial("debug/debugambientcube");
	materialFlat = g_MatSystem->FindMaterial("debug/debugdrawflat");
}

Chams::~Chams() {
}


void Chams::OverrideMaterial(bool ignoreZ, bool flat, bool wireframe, bool glass, const Color& rgba) {
	IMaterial* material = nullptr;

	if (flat) {
		material = materialFlat;
	}
	else {
		material = materialRegular;
	}

	material->SetMaterialVarFlag(MATERIAL_VAR_IGNOREZ, ignoreZ);


	if (glass) {
		material = materialFlat;
		material->AlphaModulate(0.45f);
	}
	else {
		material->AlphaModulate(
			rgba.a() / 255.0f);
	}

	material->SetMaterialVarFlag(MATERIAL_VAR_WIREFRAME, wireframe);
	material->ColorModulate(
		rgba.r() / 255.0f,
		rgba.g() / 255.0f,
		rgba.b() / 255.0f);

	g_MdlRender->ForcedMaterialOverride(material);
}


void Chams::OnDrawModelExecute(
	IMatRenderContext* ctx,
	const DrawModelState_t& state,
	const ModelRenderInfo_t& info,
	matrix3x4_t* matrix)
{
	static auto fnDME = Hooks::mdlrender_hook.get_original<decltype(&Hooks::hkDrawModelExecute)>(index::DrawModelExecute);

	const auto mdl = info.pModel;

	bool is_arm = strstr(mdl->szName, "arms") != nullptr;
	bool is_player = strstr(mdl->szName, "models/player") != nullptr;
	bool is_sleeve = strstr(mdl->szName, "sleeve") != nullptr;
	//bool is_weapon = strstr(mdl->szName, "weapons/v_")  != nullptr;

	if (is_player && g_Options.chams_player_enabled) {
		// 
		// Draw player Chams.
		// 
		auto ent = C_BasePlayer::GetPlayerByIndex(info.entity_index);

		if (ent && g_LocalPlayer && ent->IsAlive()) {
			const auto enemy = ent->m_iTeamNum() != g_LocalPlayer->m_iTeamNum();
			if (!enemy && g_Options.chams_player_enemies_only)
				return;

			const auto clr_front = enemy ? g_Options.color_chams_player_enemy_visible : g_Options.color_chams_player_ally_visible;
			const auto clr_back = enemy ? g_Options.color_chams_player_enemy_occluded : g_Options.color_chams_player_ally_occluded;

			if (g_Options.chams_player_ignorez) {
				OverrideMaterial(
					true,
					g_Options.chams_player_flat,
					g_Options.chams_player_wireframe,
					false,
					clr_back);
				fnDME(g_MdlRender, 0, ctx, state, info, matrix);
				OverrideMaterial(
					false,
					g_Options.chams_player_flat,
					g_Options.chams_player_wireframe,
					false,
					clr_front);
			}
			else {
				OverrideMaterial(
					false,
					g_Options.chams_player_flat,
					g_Options.chams_player_wireframe,
					g_Options.chams_player_glass,
					clr_front);
			}
		}
	}
	else if (is_sleeve && g_Options.chams_arms_enabled) {
		auto material = g_MatSystem->FindMaterial(mdl->szName, TEXTURE_GROUP_MODEL);
		if (!material)
			return;
		// 
		// Remove sleeves when drawing Chams.
		// 
		material->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, true);
		g_MdlRender->ForcedMaterialOverride(material);
	}
	else if (is_arm) {
		auto material = g_MatSystem->FindMaterial(mdl->szName, TEXTURE_GROUP_MODEL);
		if (!material)
			return;
		if (g_Options.misc_no_hands) {
			// 
			// No hands.
			// 
			material->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, true);
			g_MdlRender->ForcedMaterialOverride(material);
		}
		else if (g_Options.chams_arms_enabled) {
			if (g_Options.chams_arms_ignorez) {
				OverrideMaterial(
					true,
					g_Options.chams_arms_flat,
					g_Options.chams_arms_wireframe,
					false,
					g_Options.color_chams_arms_occluded);
				fnDME(g_MdlRender, 0, ctx, state, info, matrix);
				OverrideMaterial(
					false,
					g_Options.chams_arms_flat,
					g_Options.chams_arms_wireframe,
					false,
					g_Options.color_chams_arms_visible);
			}
			else {
				OverrideMaterial(
					false,
					g_Options.chams_arms_flat,
					g_Options.chams_arms_wireframe,
					g_Options.chams_arms_glass,
					g_Options.color_chams_arms_visible);
			}
		}
	}
}
```

`CSGOSimple/features/chams.hpp`:

```hpp
#pragma once

#include "../singleton.hpp"

class IMatRenderContext;
struct DrawModelState_t;
struct ModelRenderInfo_t;
class matrix3x4_t;
class IMaterial;
class Color;

class Chams
    : public Singleton<Chams>
{
    friend class Singleton<Chams>;

    Chams();
    ~Chams();

public:
	void OnDrawModelExecute(
        IMatRenderContext* ctx,
        const DrawModelState_t &state,
        const ModelRenderInfo_t &pInfo,
        matrix3x4_t *pCustomBoneToWorld);

private:
    void OverrideMaterial(bool ignoreZ, bool flat, bool wireframe, bool glass, const Color& rgba);

    IMaterial* materialRegular = nullptr;
    IMaterial* materialFlat = nullptr;
};
```

`CSGOSimple/features/glow.cpp`:

```cpp
#include "glow.hpp"

#include "../valve_sdk/csgostructs.hpp"
#include "../options.hpp"

Glow::Glow()
{
}

Glow::~Glow()
{
    // We cannot call shutdown here unfortunately.
    // Reason is not very straightforward but anyways:
    // - This destructor will be called when the dll unloads
    //   but it cannot distinguish between manual unload 
    //   (pressing the Unload button or calling FreeLibrary)
    //   or unload due to game exit.
    //   What that means is that this destructor will be called
    //   when the game exits.
    // - When the game is exiting, other dlls might already 
    //   have been unloaded before us, so it is not safe to 
    //   access intermodular variables or functions.
    //   
    //   Trying to call Shutdown here will crash CSGO when it is
    //   exiting (because we try to access g_GlowObjManager).
    //
}

void Glow::Shutdown()
{
    // Remove glow from all entities
    for(auto i = 0; i < g_GlowObjManager->m_GlowObjectDefinitions.Count(); i++) {
        auto& glowObject = g_GlowObjManager->m_GlowObjectDefinitions[i];
        auto entity = reinterpret_cast<C_BasePlayer*>(glowObject.m_pEntity);

        if(glowObject.IsUnused())
            continue;

        if(!entity || entity->IsDormant())
            continue;

        glowObject.m_flAlpha = 0.0f;
    }
}

void Glow::Run()
{
    for(auto i = 0; i < g_GlowObjManager->m_GlowObjectDefinitions.Count(); i++) {
        auto& glowObject = g_GlowObjManager->m_GlowObjectDefinitions[i];
        auto entity = reinterpret_cast<C_BasePlayer*>(glowObject.m_pEntity);

        if(glowObject.IsUnused())
            continue;

        if(!entity || entity->IsDormant())
            continue;

        auto class_id = entity->GetClientClass()->m_ClassID;
        auto color = Color{};

        switch(class_id) {
            case ClassId_CCSPlayer:
            {
                auto is_enemy = entity->m_iTeamNum() != g_LocalPlayer->m_iTeamNum();

                if(entity->HasC4() && is_enemy && g_Options.glow_c4_carrier) {
                    color = g_Options.color_glow_c4_carrier;
                    break;
                }

                if(!g_Options.glow_players || !entity->IsAlive())
                    continue;

                if(!is_enemy && g_Options.glow_enemies_only)
                    continue;

                color = is_enemy ? g_Options.color_glow_enemy : g_Options.color_glow_ally;

                break;
            }
            case ClassId_CChicken:
                if(!g_Options.glow_chickens)
                    continue;
                entity->m_bShouldGlow() = true;
                color = g_Options.color_glow_chickens;
                break;
            case ClassId_CBaseAnimating:
                if(!g_Options.glow_defuse_kits)
                    continue;
                color = g_Options.color_glow_defuse;
                break;
            case ClassId_CPlantedC4:
                if(!g_Options.glow_planted_c4)
                    continue;
                color = g_Options.color_glow_planted_c4;
                break;
            default:
            {
                if(entity->IsWeapon()) {
                    if(!g_Options.glow_weapons)
                        continue;
                    color = g_Options.color_glow_weapons;
                }
            }
        }

        glowObject.m_flRed = color.r() / 255.0f;
        glowObject.m_flGreen = color.g() / 255.0f;
        glowObject.m_flBlue = color.b() / 255.0f;
        glowObject.m_flAlpha = color.a() / 255.0f;
        glowObject.m_bRenderWhenOccluded = true;
        glowObject.m_bRenderWhenUnoccluded = false;
    }
}

```

`CSGOSimple/features/glow.hpp`:

```hpp
#pragma once
#include "../Singleton.hpp"

class Glow
    : public Singleton<Glow>
{
    friend class Singleton<Glow>;

    Glow();
    ~Glow();

public:
    void Run();
    void Shutdown();
};
```

`CSGOSimple/features/visuals.cpp`:

```cpp
#include <algorithm>

#include "visuals.hpp"

#include "../options.hpp"
#include "../helpers/math.hpp"
#include "../helpers/utils.hpp"


RECT GetBBox(C_BaseEntity* ent)
{
	RECT rect{};
	auto collideable = ent->GetCollideable();

	if (!collideable)
		return rect;

	auto min = collideable->OBBMins();
	auto max = collideable->OBBMaxs();

	const matrix3x4_t& trans = ent->m_rgflCoordinateFrame();

	Vector points[] = {
		Vector(min.x, min.y, min.z),
		Vector(min.x, max.y, min.z),
		Vector(max.x, max.y, min.z),
		Vector(max.x, min.y, min.z),
		Vector(max.x, max.y, max.z),
		Vector(min.x, max.y, max.z),
		Vector(min.x, min.y, max.z),
		Vector(max.x, min.y, max.z)
	};

	Vector pointsTransformed[8];
	for (int i = 0; i < 8; i++) {
		Math::VectorTransform(points[i], trans, pointsTransformed[i]);
	}

	Vector screen_points[8] = {};

	for (int i = 0; i < 8; i++) {
		if (!Math::WorldToScreen(pointsTransformed[i], screen_points[i]))
			return rect;
	}

	auto left = screen_points[0].x;
	auto top = screen_points[0].y;
	auto right = screen_points[0].x;
	auto bottom = screen_points[0].y;

	for (int i = 1; i < 8; i++) {
		if (left > screen_points[i].x)
			left = screen_points[i].x;
		if (top < screen_points[i].y)
			top = screen_points[i].y;
		if (right < screen_points[i].x)
			right = screen_points[i].x;
		if (bottom > screen_points[i].y)
			bottom = screen_points[i].y;
	}
	return RECT{ (long)left, (long)top, (long)right, (long)bottom };
}

Visuals::Visuals()
{
	InitializeCriticalSection(&cs);
}

Visuals::~Visuals() {
	DeleteCriticalSection(&cs);
}

//--------------------------------------------------------------------------------
void Visuals::Render() {
}
//--------------------------------------------------------------------------------
bool Visuals::Player::Begin(C_BasePlayer* pl)
{
	if (pl->IsDormant() || !pl->IsAlive())
		return false;

	ctx.pl = pl;
	ctx.is_enemy = g_LocalPlayer->m_iTeamNum() != pl->m_iTeamNum();
	ctx.is_visible = g_LocalPlayer->CanSeePlayer(pl, HITBOX_CHEST);

	if (!ctx.is_enemy && g_Options.esp_enemies_only)
		return false;

	ctx.clr = ctx.is_enemy ? (ctx.is_visible ? g_Options.color_esp_enemy_visible : g_Options.color_esp_enemy_occluded) : (ctx.is_visible ? g_Options.color_esp_ally_visible : g_Options.color_esp_ally_occluded);

	auto head = pl->GetHitboxPos(HITBOX_HEAD);
	auto origin = pl->m_vecOrigin();

	head.z += 15;

	if (!Math::WorldToScreen(head, ctx.head_pos) ||
		!Math::WorldToScreen(origin, ctx.feet_pos))
		return false;

	auto h = fabs(ctx.head_pos.y - ctx.feet_pos.y);
	auto w = h / 1.65f;

	ctx.bbox.left = static_cast<long>(ctx.feet_pos.x - w * 0.5f);
	ctx.bbox.right = static_cast<long>(ctx.bbox.left + w);
	ctx.bbox.bottom = static_cast<long>(ctx.feet_pos.y);
	ctx.bbox.top = static_cast<long>(ctx.head_pos.y);

	return true;
}
//--------------------------------------------------------------------------------
void Visuals::Player::RenderBox() {
	Render::Get().RenderBoxByType(ctx.bbox.left, ctx.bbox.top, ctx.bbox.right, ctx.bbox.bottom, ctx.clr, 1);
}
//--------------------------------------------------------------------------------
void Visuals::Player::RenderName()
{
	player_info_t info = ctx.pl->GetPlayerInfo();

	auto sz = g_pDefaultFont->CalcTextSizeA(14.f, FLT_MAX, 0.0f, info.szName);

	Render::Get().RenderText(info.szName, ctx.feet_pos.x - sz.x / 2, ctx.head_pos.y - sz.y, 14.f,  ctx.clr);
}
//--------------------------------------------------------------------------------
void Visuals::Player::RenderHealth()
{
	auto  hp = ctx.pl->m_iHealth();
	float box_h = (float)fabs(ctx.bbox.bottom - ctx.bbox.top);
	//float off = (box_h / 6.f) + 5;
	float off = 8;

	int height = (box_h * hp) / 100;

	int green = int(hp * 2.55f);
	int red = 255 - green;

	int x = ctx.bbox.left - off;
	int y = ctx.bbox.top;
	int w = 4;
	int h = box_h;

	Render::Get().RenderBox(x, y, x + w, y + h, Color::Black, 1.f, true);
	Render::Get().RenderBox(x + 1, y + 1, x + w - 1, y + height - 2, Color(red, green, 0, 255), 1.f, true);
}
//--------------------------------------------------------------------------------
void Visuals::Player::RenderArmour()
{
	auto  armour = ctx.pl->m_ArmorValue();
	float box_h = (float)fabs(ctx.bbox.bottom - ctx.bbox.top);
	//float off = (box_h / 6.f) + 5;
	float off = 4;

	int height = (((box_h * armour) / 100));

	int x = ctx.bbox.right + off;
	int y = ctx.bbox.top;
	int w = 4;
	int h = box_h;

	Render::Get().RenderBox(x, y, x + w, y + h, Color::Black, 1.f, true);
	Render::Get().RenderBox(x + 1, y + 1, x + w - 1, y + height - 2, Color(0, 50, 255, 255), 1.f, true);
}
//--------------------------------------------------------------------------------
void Visuals::Player::RenderWeaponName()
{
	auto weapon = ctx.pl->m_hActiveWeapon().Get();

	if (!weapon) return;
	if (!weapon->GetCSWeaponData()) return;

	auto text = weapon->GetCSWeaponData()->szWeaponName + 7;
	auto sz = g_pDefaultFont->CalcTextSizeA(14.f, FLT_MAX, 0.0f, text);
	Render::Get().RenderText(text, ctx.feet_pos.x, ctx.feet_pos.y, 14.f, ctx.clr, true,
		g_pDefaultFont);
}
//--------------------------------------------------------------------------------
void Visuals::Player::RenderSnapline()
{

	int screen_w, screen_h;
	g_EngineClient->GetScreenSize(screen_w, screen_h);

	Render::Get().RenderLine(screen_w / 2.f, (float)screen_h,
		ctx.feet_pos.x, ctx.feet_pos.y, ctx.clr);
}
//--------------------------------------------------------------------------------
void Visuals::RenderCrosshair()
{
	int w, h;

	g_EngineClient->GetScreenSize(w, h);

	int cx = w / 2;
	int cy = h / 2;
	Render::Get().RenderLine(cx - 25, cy, cx + 25, cy, g_Options.color_esp_crosshair);
	Render::Get().RenderLine(cx, cy - 25, cx, cy + 25, g_Options.color_esp_crosshair);
}
//--------------------------------------------------------------------------------
void Visuals::RenderWeapon(C_BaseCombatWeapon* ent)
{
	auto clean_item_name = [](const char* name) -> const char* {
		if (name[0] == 'C')
			name++;

		auto start = strstr(name, "Weapon");
		if (start != nullptr)
			name = start + 6;

		return name;
	};

	// We don't want to Render weapons that are being held
	if (ent->m_hOwnerEntity().IsValid())
		return;

	auto bbox = GetBBox(ent);

	if (bbox.right == 0 || bbox.bottom == 0)
		return;

	Render::Get().RenderBox(bbox, g_Options.color_esp_weapons);


	auto name = clean_item_name(ent->GetClientClass()->m_pNetworkName);

	auto sz = g_pDefaultFont->CalcTextSizeA(14.f, FLT_MAX, 0.0f, name);
	int w = bbox.right - bbox.left;


	Render::Get().RenderText(name, ImVec2((bbox.left + w * 0.5f) - sz.x * 0.5f, bbox.bottom + 1), 14.f, g_Options.color_esp_weapons);
}
//--------------------------------------------------------------------------------
void Visuals::RenderDefuseKit(C_BaseEntity* ent)
{
	if (ent->m_hOwnerEntity().IsValid())
		return;

	auto bbox = GetBBox(ent);

	if (bbox.right == 0 || bbox.bottom == 0)
		return;

	Render::Get().RenderBox(bbox, g_Options.color_esp_defuse);

	auto name = "Defuse Kit";
	auto sz = g_pDefaultFont->CalcTextSizeA(14.f, FLT_MAX, 0.0f, name);
	int w = bbox.right - bbox.left;
	Render::Get().RenderText(name, ImVec2((bbox.left + w * 0.5f) - sz.x * 0.5f, bbox.bottom + 1), 14.f, g_Options.color_esp_defuse);
}
//--------------------------------------------------------------------------------
void Visuals::RenderPlantedC4(C_BaseEntity* ent)
{
	auto bbox = GetBBox(ent);

	if (bbox.right == 0 || bbox.bottom == 0)
		return;


	Render::Get().RenderBox(bbox, g_Options.color_esp_c4);


	int bombTimer = std::ceil(ent->m_flC4Blow() - g_GlobalVars->curtime);
	std::string timer = std::to_string(bombTimer);

	auto name = (bombTimer < 0.f) ? "Bomb" : timer;
	auto sz = g_pDefaultFont->CalcTextSizeA(14.f, FLT_MAX, 0.0f, name.c_str());
	int w = bbox.right - bbox.left;

	Render::Get().RenderText(name, ImVec2((bbox.left + w * 0.5f) - sz.x * 0.5f, bbox.bottom + 1), 14.f, g_Options.color_esp_c4);
}
//--------------------------------------------------------------------------------
void Visuals::RenderItemEsp(C_BaseEntity* ent)
{
	std::string itemstr = "Undefined";
	const model_t * itemModel = ent->GetModel();
	if (!itemModel)
		return;
	studiohdr_t * hdr = g_MdlInfo->GetStudiomodel(itemModel);
	if (!hdr)
		return;
	itemstr = hdr->szName;
	if (ent->GetClientClass()->m_ClassID == ClassId_CBumpMine)
		itemstr = "";
	else if (itemstr.find("case_pistol") != std::string::npos)
		itemstr = "Pistol Case";
	else if (itemstr.find("case_light_weapon") != std::string::npos)
		itemstr = "Light Case";
	else if (itemstr.find("case_heavy_weapon") != std::string::npos)
		itemstr = "Heavy Case";
	else if (itemstr.find("case_explosive") != std::string::npos)
		itemstr = "Explosive Case";
	else if (itemstr.find("case_tools") != std::string::npos)
		itemstr = "Tools Case";
	else if (itemstr.find("random") != std::string::npos)
		itemstr = "Airdrop";
	else if (itemstr.find("dz_armor_helmet") != std::string::npos)
		itemstr = "Full Armor";
	else if (itemstr.find("dz_helmet") != std::string::npos)
		itemstr = "Helmet";
	else if (itemstr.find("dz_armor") != std::string::npos)
		itemstr = "Armor";
	else if (itemstr.find("upgrade_tablet") != std::string::npos)
		itemstr = "Tablet Upgrade";
	else if (itemstr.find("briefcase") != std::string::npos)
		itemstr = "Briefcase";
	else if (itemstr.find("parachutepack") != std::string::npos)
		itemstr = "Parachute";
	else if (itemstr.find("dufflebag") != std::string::npos)
		itemstr = "Cash Dufflebag";
	else if (itemstr.find("ammobox") != std::string::npos)
		itemstr = "Ammobox";
	else if (itemstr.find("dronegun") != std::string::npos)
		itemstr = "Turrel";
	else if (itemstr.find("exojump") != std::string::npos)
		itemstr = "Exojump";
	else if (itemstr.find("healthshot") != std::string::npos)
		itemstr = "Healthshot";
	else {
		/*May be you will search some missing items..*/
		/*static std::vector<std::string> unk_loot;
		if (std::find(unk_loot.begin(), unk_loot.end(), itemstr) == unk_loot.end()) {
			Utils::ConsolePrint(itemstr.c_str());
			unk_loot.push_back(itemstr);
		}*/
		return;
	}
	
	auto bbox = GetBBox(ent);
	if (bbox.right == 0 || bbox.bottom == 0)
		return;
	auto sz = g_pDefaultFont->CalcTextSizeA(14.f, FLT_MAX, 0.0f, itemstr.c_str());
	int w = bbox.right - bbox.left;


	//Render::Get().RenderBox(bbox, g_Options.color_esp_item);
	Render::Get().RenderText(itemstr, ImVec2((bbox.left + w * 0.5f) - sz.x * 0.5f, bbox.bottom + 1), 14.f, g_Options.color_esp_item);
}
//--------------------------------------------------------------------------------
void Visuals::ThirdPerson() {
	if (!g_LocalPlayer)
		return;

	if (g_Options.misc_thirdperson && g_LocalPlayer->IsAlive())
	{
		if (!g_Input->m_fCameraInThirdPerson)
		{
			g_Input->m_fCameraInThirdPerson = true;
		}

		float dist = g_Options.misc_thirdperson_dist;

		QAngle *view = g_LocalPlayer->GetVAngles();
		trace_t tr;
		Ray_t ray;

		Vector desiredCamOffset = Vector(cos(DEG2RAD(view->yaw)) * dist,
			sin(DEG2RAD(view->yaw)) * dist,
			sin(DEG2RAD(-view->pitch)) * dist
		);

		//cast a ray from the Current camera Origin to the Desired 3rd person Camera origin
		ray.Init(g_LocalPlayer->GetEyePos(), (g_LocalPlayer->GetEyePos() - desiredCamOffset));
		CTraceFilter traceFilter;
		traceFilter.pSkip = g_LocalPlayer;
		g_EngineTrace->TraceRay(ray, MASK_SHOT, &traceFilter, &tr);

		Vector diff = g_LocalPlayer->GetEyePos() - tr.endpos;

		float distance2D = sqrt(abs(diff.x * diff.x) + abs(diff.y * diff.y));// Pythagorean

		bool horOK = distance2D > (dist - 2.0f);
		bool vertOK = (abs(diff.z) - abs(desiredCamOffset.z) < 3.0f);

		float cameraDistance;

		if (horOK && vertOK)  // If we are clear of obstacles
		{
			cameraDistance = dist; // go ahead and set the distance to the setting
		}
		else
		{
			if (vertOK) // if the Vertical Axis is OK
			{
				cameraDistance = distance2D * 0.95f;
			}
			else// otherwise we need to move closer to not go into the floor/ceiling
			{
				cameraDistance = abs(diff.z) * 0.95f;
			}
		}
		g_Input->m_fCameraInThirdPerson = true;

		g_Input->m_vecCameraOffset.z = cameraDistance;
	}
	else
	{
		g_Input->m_fCameraInThirdPerson = false;
	}
}


void Visuals::AddToDrawList() {
	for (auto i = 1; i <= g_EntityList->GetHighestEntityIndex(); ++i) {
		auto entity = C_BaseEntity::GetEntityByIndex(i);

		if (!entity)
			continue;
		
		if (entity == g_LocalPlayer && !g_Input->m_fCameraInThirdPerson)
			continue;

		if (i <= g_GlobalVars->maxClients) {
			auto player = Player();
			if (player.Begin((C_BasePlayer*)entity)) {
				if (g_Options.esp_player_snaplines) player.RenderSnapline();
				if (g_Options.esp_player_boxes)     player.RenderBox();
				if (g_Options.esp_player_weapons)   player.RenderWeaponName();
				if (g_Options.esp_player_names)     player.RenderName();
				if (g_Options.esp_player_health)    player.RenderHealth();
				if (g_Options.esp_player_armour)    player.RenderArmour();
			}
		}
		else if (g_Options.esp_dropped_weapons && entity->IsWeapon())
			RenderWeapon(static_cast<C_BaseCombatWeapon*>(entity));
		else if (g_Options.esp_dropped_weapons && entity->IsDefuseKit())
			RenderDefuseKit(entity);
		else if (entity->IsPlantedC4() && g_Options.esp_planted_c4)
			RenderPlantedC4(entity);
		else if (entity->IsLoot() && g_Options.esp_items)
			RenderItemEsp(entity);
	}


	if (g_Options.esp_crosshair)
		RenderCrosshair();

}

```

`CSGOSimple/features/visuals.hpp`:

```hpp
#pragma once

#include "../singleton.hpp"

#include "../render.hpp"
#include "../helpers/math.hpp"
#include "../valve_sdk/csgostructs.hpp"




class Visuals : public Singleton<Visuals>
{
	friend class Singleton<Visuals>;

	CRITICAL_SECTION cs;

	Visuals();
	~Visuals();
public:
	class Player
	{
	public:
		struct
		{
			C_BasePlayer* pl;
			bool          is_enemy;
			bool          is_visible;
			Color         clr;
			Vector        head_pos;
			Vector        feet_pos;
			RECT          bbox;
		} ctx;

		bool Begin(C_BasePlayer * pl);
		void RenderBox();
		void RenderName();
		void RenderWeaponName();
		void RenderHealth();
		void RenderArmour();
		void RenderSnapline();
	};
	void RenderCrosshair();
	void RenderWeapon(C_BaseCombatWeapon* ent);
	void RenderDefuseKit(C_BaseEntity* ent);
	void RenderPlantedC4(C_BaseEntity* ent);
	void RenderItemEsp(C_BaseEntity* ent);
	void ThirdPerson();
public:
	void AddToDrawList();
	void Render();
};

```

`CSGOSimple/fonts/cousine.hpp`:

```hpp
// File: 'Cousine-Regular.ttf' (43912 bytes)
// Exported using binary_to_compressed_c.cpp
static const unsigned int Cousine_compressed_size = 37630;
static const unsigned int Cousine_compressed_data[37632/4] =
{
    0x0000bc57, 0x00000000, 0x88ab0000, 0x00000400, 0x00010025, 0x82110000, 0x00042604, 0x49534410, 0x820d8247, 0x44ab210c, 0x082c0782, 0x4d544646, 
    0xc867e44e, 0x6cab0000, 0x1c280f82, 0x46454447, 0x04000501, 0x4c200f82, 0x202c0f82, 0x322f534f, 0x4f9e26f9, 0x98010000, 0x603c0f82, 0x70616d63, 
    0x9fad085d, 0xb0030000, 0x7a020000, 0x20747663, 0xb55e164d, 0xa0110000, 0x3c270f82, 0x6d677066, 0x8223d373, 0x2c062d1b, 0x05070000, 0x70736167, 
    0x09001800, 0x34204f82, 0x10383f82, 0x66796c67, 0x7f5d5439, 0x90150000, 0x44890000, 0x64616568, 0x88a5ddf6, 0x1c205f82, 0x36211f82, 0x23108268, 
    0x6202780b, 0x54200f82, 0x24280f82, 0x78746d68, 0xca460a4f, 0xf8200f82, 0xb82c0382, 0x61636f6c, 0xd24d1a6c, 0xdc130000, 0xb2280f82, 0x7078616d, 
    0x67027c04, 0x78200b82, 0x32082f82, 0x6d616e20, 0x38e51165, 0x9e0000f9, 0x0a0000d4, 0x736f7032, 0xff7cec74, 0xa90000c7, 0x02000008, 0x6572702a, 
    0xf798d970, 0x0d000094, 0x04000034, 0x8201006a, 0x2b038235, 0xa51633bd, 0xf53c0f5f, 0x00081f00, 0xc9230083, 0x87d52d6f, 0xf6ff2707, 0xd60439fe, 
    0x0f82a806, 0x02000822, 0x02830582, 0x062d3382, 0x0099fda9, 0xffcd0400, 0x04f7fff6, 0x834984d6, 0x20038719, 0x28118404, 0x007900d8, 0x006a0005, 
    0x2c398204, 0x002f0010, 0x0300005a, 0x0052012d, 0x241d8203, 0x01cd0403, 0x281d8290, 0x059a0508, 0x01000033, 0x3a07851d, 0x66006103, 0x05081202, 
    0x09040702, 0x02050202, 0x00a00404, 0x0040af02, 0x8600fb78, 0x41313f00, 0x40004353, 0x19222000, 0x7efee704, 0xa9062602, 0x00606702, 0xd7df9f00, 
    0x3a040000, 0x26824505, 0x01002026, 0x4400cd04, 0xa1820982, 0x03840020, 0x01030227, 0x00360015, 0x3c138242, 0x01f6012b, 0x00500156, 0x017400f8, 
    0x014e0103, 0x007200f0, 0x0094007c, 0x00800090, 0x2c038267, 0x009e0097, 0x018d0085, 0x006001f0, 0x22018474, 0x822c005e, 0x00a22437, 0x82a20071, 
    0x84c22001, 0x00ca2207, 0x220b82b0, 0x828100ed, 0x86662005, 0x004f2603, 0x008e004c, 0x302b820a, 0x00240024, 0x009a0149, 0x000e0173, 0x01fbff85, 
    0x24578292, 0x008200b3, 0x2459828a, 0x008f008a, 0x270382b9, 0x00ec0075, 0x00630086, 0xb3201783, 0xf2241982, 0xbe00a700, 0x45241982, 0x5e001500, 
    0x9324a982, 0x1302e300, 0x6c221382, 0x35820302, 0x95823820, 0x0f823420, 0x4f019f28, 0xce001f00, 0x99827f00, 0x59821f20, 0xc5824720, 0x32013822, 
    0x90226182, 0xcb827f00, 0x1d01772e, 0x6b00e200, 0x11001b00, 0x99000b00, 0x02898b82, 0xb9840120, 0xa222c383, 0x0186ca00, 0xbb841b20, 0x85006621, 
    0x009d2401, 0x868e0038, 0x82242001, 0x828e2019, 0x888020b7, 0x82142003, 0x828520c1, 0x2003838b, 0x83c1828f, 0x847d2003, 0x828220bf, 0x22038319, 
    0x826e0074, 0x84b920c1, 0x82422003, 0x82422005, 0x142c0825, 0x1b011c00, 0xff007401, 0xf6ffaa00, 0x8f018d01, 0xb1005d01, 0xb200b200, 0x5a015001, 
    0xcc006e01, 0xf0015b00, 0xfa002501, 0xc500ea00, 0x0320ac82, 0x1c220386, 0x09820100, 0x39820020, 0x09840320, 0x04001c24, 0x11825801, 0x00222808, 
    0x00040020, 0x007e0002, 0x013101ff, 0x02c60253, 0x20dc02da, 0x201a2014, 0x2022201e, 0x2044203a, 0x221522ac, 0x82ffff19, 0x0020222b, 0x202382a0, 
    0x24238652, 0x20182013, 0x2023821c, 0x3f238939, 0x0000e3ff, 0x6fff8fff, 0xeafdfdfd, 0xb3e0e9fd, 0xafe0b0e0, 0x96e0ace0, 0x26e08de0, 0xbadebcde, 
    0x20207984, 0x029b4982, 0x0003c308, 0x00630062, 0x00650064, 0x00670066, 0x00690068, 0x006b006a, 0x006d006c, 0x006e0010, 0x0070006f, 0x00720071, 
    0x00740073, 0x00760075, 0x00780077, 0x007a0079, 0x007c007b, 0x007e007d, 0x0080007f, 0x00820081, 0x00840083, 0x00860085, 0x00880087, 0x008a0089, 
    0x008c008b, 0x008e008d, 0x0090008f, 0x00920091, 0x00940093, 0x00960095, 0x00980097, 0x009a0099, 0x009c009b, 0x009e009d, 0x00a0009f, 0x00a200a1, 
    0x00a400a3, 0x00a600a5, 0x00a800a7, 0x00aa00a9, 0x00ac00ab, 0x00ae00ad, 0x00b000af, 0x00b200b1, 0x00b400b3, 0x00b600b5, 0x00b800b7, 0x00ba00b9, 
    0x00bc00bb, 0x00be00bd, 0x010000bf, 0xe8840006, 0x0121e483, 0x21058202, 0x008d0002, 0x00019808, 0x05040300, 0x09080706, 0x0d0c0b0a, 0x11100f0e, 
    0x15141312, 0x19181716, 0x1d1c1b1a, 0x21201f1e, 0x25242322, 0x29282726, 0x2d2c2b2a, 0x31302f2e, 0x35343332, 0x39383736, 0x3d3c3b3a, 0x41403f3e, 
    0x45444342, 0x49484746, 0x4d4c4b4a, 0x51504f4e, 0x55545352, 0x59585756, 0x5d5c5b5a, 0x61605f5e, 0x87858400, 0x9c969189, 0xa4a2a0a1, 0xa9a7a5a3, 
    0xadabaaa8, 0xb1afaeac, 0xb6b4b2b3, 0xbbb9bab5, 0x637000bc, 0x76ce6864, 0x006a6e9f, 0x86006974, 0x00710098, 0x84756600, 0x7a6b27a6, 0x7fb8a600, 
    0x0c836d62, 0x007b6c2f, 0x95838003, 0xc7c6c2c1, 0xc9c8cccb, 0x23de82b7, 0xd0cfd2d1, 0x773b1a82, 0x8200cdca, 0x888b818a, 0x8c8f8e8d, 0x92009493, 
    0xc0999b9a, 0x006fc5c3, 0x8278c400, 0x0058081e, 0x59454000, 0x53545558, 0x4f505152, 0x4b4c4d4e, 0x4748494a, 0x43444546, 0x3f404142, 0x3b3c3d3e, 
    0x3738393a, 0x30313536, 0x2c2d2e2f, 0x25262728, 0x21222324, 0x1114181f, 0x0d0e0f10, 0x08090a0b, 0x04050607, 0x00010203, 0x4623452c, 0x26b02060, 
    0x2604b060, 0x2d484823, 0x23210f83, 0x20108261, 0x22108a61, 0x8220b060, 0x8d462012, 0x20b02123, 0x61203783, 0x298c1a82, 0x29824020, 0x298e6620, 
    0x29854020, 0x53884020, 0x20100135, 0x2d3c003c, 0x2345202c, 0x44cdb020, 0x01b82023, 0x8258515a, 0x448d260b, 0xb0205923, 0x200b84ed, 0x210b844d, 
    0x0c842604, 0x0c820d20, 0x82212121, 0x20230831, 0x44681845, 0x6001b020, 0x46b04520, 0x458a6876, 0x2c2d4460, 0x0a0bb101, 0x65432343, 0x002c2d0a, 
    0x820b0ab1, 0x820b200a, 0x28b02809, 0x01b17023, 0x84013e28, 0x28022808, 0x02b13a45, 0x820d0800, 0xb0453644, 0x61452503, 0x5150b064, 0x1b444558, 
    0x2d592121, 0x0eb0492c, 0x82498223, 0x43002155, 0xb0245284, 0x07b04306, 0x20225284, 0xba82b069, 0x208b0037, 0x8ac02cb1, 0x0010b88c, 0x0c2b6062, 
    0x61642364, 0x03b0585c, 0x3c3b8261, 0x8a45038a, 0x11b0878a, 0x2329b02b, 0x7a29b044, 0x2c2d18e4, 0x2cb06545, 0xb0454423, 0x2155832b, 0x6788524b, 
    0x72894b20, 0x05b00129, 0x20231025, 0x8200f58a, 0xed2322ce, 0x8ac782ec, 0x86612011, 0x25062411, 0x8300f510, 0x4624081c, 0x8a604623, 0x2023468a, 
    0x8a608a46, 0x80ffb861, 0x10202362, 0x0cb18a23, 0x45708a0c, 0x00b02060, 0x01b05850, 0xba2c1782, 0x46b01b8b, 0x10b0598c, 0x3a016860, 0x462eec86, 
    0x13b04b52, 0xb0585b51, 0x20462502, 0xfe826168, 0x3f260282, 0x1b382123, 0xc0821121, 0x0322f582, 0x3f824625, 0x002b1e95, 0xb04307b0, 0x2d0b4306, 
    0x8321212c, 0xb88b24f8, 0x82620040, 0x80b0230c, 0x0f855851, 0x6200202c, 0x4000b21b, 0xb0592b2f, 0x19836002, 0x1987c020, 0x83551521, 0x87802019, 
    0x083e8819, 0x2123602d, 0x534b2c2d, 0x04b08a58, 0x23644925, 0x40b06945, 0x80b0618b, 0x6120b062, 0x230eb06a, 0xb0102344, 0x211bf60e, 0x11128a23, 
    0x822f3920, 0x202b82a3, 0x28b48220, 0x20696449, 0xb02605b0, 0x8b358306, 0x04b02230, 0x20328326, 0x2104828a, 0x3b824423, 0xb0234483, 0x821bed0e, 
    0x11262560, 0x23392012, 0x47834682, 0x45234523, 0x22028660, 0x82186876, 0x2d203071, 0x2b48b02c, 0x45202c2d, 0x585400b0, 0x824440b0, 0x61402108, 
    0x23061642, 0x2f30b145, 0x61263182, 0x6001b060, 0xb1824469, 0xb0585129, 0xb070232f, 0x42422314, 0x4b220537, 0x96835851, 0x53694523, 0x85328458, 
    0xb0452715, 0x00b04314, 0x35866360, 0x452fb022, 0x45253b82, 0x8a452023, 0x20088460, 0x33068345, 0x5851234b, 0xff3300b9, 0x2034b1e0, 0x0033b31b, 
    0x44590034, 0x2c081d82, 0x584316b0, 0x452603b0, 0x6664588a, 0x1b601fb0, 0x6020b064, 0x1b582066, 0x5940b021, 0x596101b0, 0x59655823, 0x442329b0, 
    0x29b01023, 0x236e82e0, 0x59212121, 0x022bc282, 0x4b585443, 0x514b2353, 0x8238585a, 0x84592015, 0x83188319, 0x2504224e, 0x22468e45, 0x851b5823, 
    0x05b03046, 0x2508b025, 0x02582008, 0xb059031b, 0x82102504, 0x46202110, 0x23220882, 0x05823c42, 0x2507b023, 0x23038208, 0x2506b010, 0xd1821584, 
    0x20241882, 0x001b0158, 0x86822d87, 0x2029b025, 0x86446545, 0x8c0f8327, 0x230c8254, 0x48432503, 0x06244d87, 0x2503b025, 0x43244782, 0x59211b48, 
    0x0283bd82, 0x022c2d22, 0x20201e82, 0x23216284, 0x20828242, 0x21238208, 0x1a874845, 0x20250322, 0x08221e82, 0x468202b0, 0x24081382, 0x23452c2d, 
    0x20184520, 0x205000b0, 0x23652358, 0x20682359, 0x585040b0, 0x5940b021, 0x59655823, 0x2d44608a, 0x060c412c, 0x82452021, 0x0595410d, 0x58544b22, 
    0x2c410d8b, 0x2c2d240a, 0x822100b0, 0x8538201e, 0x02b02728, 0xb0585443, 0x43412b46, 0x200f8408, 0x410f8447, 0xb021076b, 0x201e8e48, 0x820f8449, 
    0x8a202b1e, 0x534b2308, 0x5a514b8a, 0x50862358, 0xb9820020, 0x00b04924, 0xa6825853, 0x82113821, 0x2c2d2ef6, 0x46234601, 0x61462360, 0x20102023, 
    0x05cf4346, 0x40b18a35, 0x45708a40, 0x2d3a6860, 0x238a202c, 0x238a6449, 0x843c5853, 0x524b262d, 0x7a1b7d58, 0x08a78259, 0x4b00122a, 0x42544b01, 
    0x02b12c2d, 0x23b14200, 0xb1518801, 0x53880140, 0x10b9585a, 0x88200000, 0x02b25854, 0x60430201, 0x24b15942, 0x58251b82, 0x000020b9, 0x20158440, 
    0x83158302, 0x20228314, 0x830c8320, 0x82522049, 0x8408202f, 0xb91b252f, 0x80000040, 0x04202a84, 0x0f841084, 0x01b86323, 0x85138400, 0x24138224, 
    0xb8630001, 0x20138502, 0x20278710, 0x20138202, 0x20138504, 0x20138440, 0x38008259, 0x18452c2d, 0x514b2368, 0x45202358, 0x40b06420, 0x597c5850, 
    0x59608a68, 0x24c58244, 0x02b01600, 0x37028225, 0x2301b001, 0x02b0003e, 0x01b13e23, 0xb00c0602, 0x4265230a, 0x42230bb0, 0x3f201783, 0x3f201783, 
    0x06201785, 0x07311783, 0x01b04223, 0x2c2d0116, 0x45108a7a, 0x2d18f523, 0x08db8200, 0x03096485, 0xf501fd04, 0xf21f2850, 0xf11f2846, 0xf01f2a46, 
    0x8b1f3546, 0xabee9bee, 0xef6b03ee, 0xbb02ef8b, 0xefa401ef, 0x5bef1b01, 0x03ef6bef, 0xec44ec04, 0x46eb0a02, 0xe4e71fff, 0xe4e61f26, 0xe4e51f3d, 
    0xe2e31f1e, 0xe20b1f46, 0x46e24001, 0xe0e11f16, 0xe0bb1f46, 0xe0dbe0cb, 0x33e04003, 0x46e04636, 0x01bc1f18, 0x013e0014, 0x01550012, 0x3d0c4013, 
    0x3ddf5503, 0x3dde55dd, 0x41bb55dc, 0x00160109, 0x82540001, 0x82642005, 0xff023103, 0xb31601c0, 0x2046160c, 0xb21601b8, 0xbc000201, 0x10201482, 
    0xcf080382, 0xb2150102, 0xb81f3ddc, 0x63401101, 0x101fff03, 0x40dd20dd, 0x80dd50dd, 0x06ddb0dd, 0xdc50dc20, 0xdcb0dc80, 0x01dc0f04, 0x1f3315d0, 
    0xc86fc85f, 0x5f03c87f, 0x7fc36fc3, 0xc2bf03c3, 0x2650c101, 0x01be701f, 0xbe30be20, 0x7003bec0, 0x02be80be, 0xbc1fbc0f, 0x3fbc2f02, 0xafbc6fbc, 
    0x05bcdfbc, 0x1f26adb9, 0xb830b820, 0xb870b850, 0xb805b880, 0x1c40c0ff, 0x462913b8, 0x2001b710, 0x80b750b7, 0x04b7b0b7, 0xb5b0b580, 0x3fb30f02, 
    0x03b3efb3, 0x400d01b8, 0x1f48aa2b, 0xb090b080, 0xc0b0b002, 0x03b0d0b0, 0xaf3faf2f, 0xb0ada002, 0xadc002ad, 0x2f02add0, 0x02ac3fac, 0xc001ab9f, 
    0x02aad0aa, 0x0f010f41, 0x0e013200, 0x00005500, 0x10000e01, 0x20200382, 0x70200382, 0x043b0382, 0x10010f00, 0x50011540, 0x709c609c, 0x9699039c, 
    0x46981f26, 0x97301f26, 0x82029740, 0x96b32487, 0x82461c16, 0x2a403907, 0x46110e96, 0x1fff1b95, 0x94af940f, 0x400394bf, 0x46311d94, 0x1b169440, 
    0x37080482, 0x0f460f0c, 0x3f932f93, 0xef937f93, 0xba0f0593, 0x6f000c01, 0x20400c01, 0x268d9202, 0xff53911f, 0x0190df1f, 0x1f019030, 0x02902f90, 
    0x907f906f, 0x108f0002, 0x038f208f, 0x25085783, 0x1c188f20, 0x308e2046, 0x8d4f028e, 0x8d6f8d5f, 0x018c3003, 0x8c1f8c0f, 0x40038c2f, 0x4613108c, 
    0x0b01bf10, 0x03822000, 0x03823020, 0xc0ff0329, 0x17b20b01, 0x83b94620, 0x40360808, 0x46141050, 0x1f26828b, 0x1f3c4a89, 0x1f3d8788, 0x1f3c8487, 
    0x1fff4a86, 0x1001859f, 0x30842084, 0x83300384, 0x01827f01, 0x0c098240, 0x26507346, 0x35466f1f, 0x03826e1f, 0x18011a30, 0x18331955, 0x03330755, 
    0xff030655, 0x1b82601f, 0x03825f20, 0xe0ffb927, 0x1fb20701, 0x825f8226, 0x1f402d08, 0x5e461c13, 0x5c1f485a, 0x5b1f3146, 0x5a200782, 0x133f0782, 
    0x05551232, 0x04550301, 0xb8550332, 0x1bb50801, 0x030f1f3c, 0x1901b901, 0x35b21801, 0x82b8401f, 0x28172706, 0x0a01b846, 0x50822540, 0x50522c08, 
    0x51ef1f1b, 0x400251ff, 0x46383551, 0x28255140, 0x0150cf46, 0x4c014cdf, 0x4b1f1d46, 0x501f4846, 0x401b01b8, 0x464a015a, 0x82491f26, 0x82482098, 
    0x82472003, 0xaf370803, 0x46df0146, 0x800246ef, 0x32160146, 0x01115515, 0x3210550f, 0x0102550f, 0x00015500, 0x0f1f1f01, 0x0f5f0f3f, 0x0f040f7f, 
    0x4f0f2f0f, 0x8f0f6f0f, 0xff0fdf0f, 0x823f070f, 0xef250813, 0x006f030f, 0x01004f01, 0x050116a0, 0x9001b801, 0x2b5354b1, 0x07b84b2b, 0xb04b52ff, 
    0xb05b5009, 0x25b08801, 0x08058353, 0x5a514022, 0xb08806b0, 0x5b5a5500, 0x0101b158, 0x8d85598e, 0x1d42008d, 0x5332b04b, 0x1d60b058, 0x64b04b59, 
    0x40200882, 0x80200883, 0x102c0882, 0x0016b11d, 0x74735942, 0x2b757473, 0x01200083, 0x73280886, 0x742b2b00, 0x732b2b74, 0x04841483, 0x09820120, 
    0x25841482, 0x822b2b21, 0x8200200d, 0x74732204, 0x821c8474, 0x82318215, 0x2b74220d, 0x21058475, 0x1783732b, 0x22827320, 0x00204283, 0x2b246082, 
    0x74737301, 0x6a820882, 0x01732b23, 0x82098273, 0x74732119, 0x00207083, 0x74221082, 0x33827400, 0x73223482, 0x7984735f, 0x81826384, 0x2b735e22, 
    0x01227683, 0x33825e2b, 0x73204282, 0x73318885, 0x005e5f18, 0x05cc0500, 0x057d00cc, 0x00150045, 0x20058460, 0x29008b00, 0x14003a04, 0x00007700, 
    0x1583ecff, 0xfe210589, 0xc90f8357, 0x00082103, 0xb42c0084, 0xaa00bd00, 0xc800a000, 0x8500b400, 0x00281184, 0x7e008800, 0xc000a500, 0x06850d86, 
    0xc900bf2c, 0x8c00ab00, 0x9b00bc00, 0x12858d00, 0xb9200594, 0x7c204782, 0x94221984, 0x07845f00, 0x01270494, 0x006f00a8, 0x82a40078, 0x82832077, 
    0x00bb2e4f, 0x018a015e, 0x00600003, 0x00810074, 0x347b82b8, 0x04b10450, 0x004cfec3, 0x00b201eb, 0x000901c3, 0x022b017b, 0x20838296, 0x264e9496, 
    0x00920000, 0x826b00a8, 0x82b72005, 0x839b2005, 0xf2023323, 0x3e029200, 0xa5026e00, 0x89004503, 0x6000a000, 0x17824c02, 0x0000c32e, 0xa4004e01, 
    0x5e005b01, 0x69008000, 0x00208582, 0x68200982, 0x02891982, 0x4a032626, 0x7b008700, 0x75211082, 0x2f198a00, 0x33028205, 0xf4ff0b00, 0x89008300, 
    0x96008f00, 0x71243d82, 0x52005b00, 0x02832782, 0x0302b222, 0x8d280682, 0xbb001f03, 0xb500ae00, 0x00220b82, 0x05848b00, 0x062b0482, 0x027003a9, 
    0xfd0802bc, 0x82910099, 0x4d380801, 0x64004d00, 0x81016400, 0xa8009f00, 0x9cfe68fe, 0x45019b00, 0x90004501, 0x1700f6fe, 0x45057a00, 0x0c004d02, 
    0x9805eeff, 0x6e008b02, 0x62004c00, 0xe8004600, 0x11054400, 0x2c214a82, 0x09018500, 0x7e0054ac, 0x30023001, 0x08040603, 0x5c042404, 0x0c059204, 
    0x76054a05, 0xac059205, 0x5c06da05, 0x2207a806, 0x3208e807, 0x6409bc08, 0x6a0a9e09, 0x340b0e0b, 0x9c0b4c0b, 0x260cd60b, 0xdc0d9c0c, 0xc20e3e0e, 
    0xae0f540f, 0x2c10f20f, 0xf410b010, 0x84113a11, 0x0e12ec11, 0x0613a412, 0xd0137813, 0xda145e14, 0xc2158a15, 0x7e161a16, 0xf8177417, 0xac185a18, 
    0x0819d818, 0x78193019, 0xaa198c19, 0xd61a581a, 0xde1b5c1b, 0xc81c681c, 0xc61d761d, 0x5a1e061e, 0xfe1ece1e, 0xea1f941f, 0xd6204e20, 0xb0215c21, 
    0x9a224222, 0x5e23f422, 0xca244e24, 0x98255625, 0x32261826, 0x1427b226, 0xc4273e27, 0x28295e28, 0xd429ac29, 0x082bdc2a, 0x9c2c0a2c, 0x0e2dec2c, 
    0xee2de42d, 0xa22e4e2e, 0x862ffe2e, 0x1230a42f, 0x5c305430, 0xf030b030, 0x9a314c31, 0xde31c031, 0x7a320032, 0xaa329232, 0xda32c232, 0x0c33f432, 
    0x90337c33, 0xc033a833, 0xf233d833, 0x22340a34, 0x54343a34, 0xe834d034, 0x18350035, 0x48353035, 0xcc356235, 0x92367a36, 0xc236aa36, 0xf436dc36, 
    0x0a385237, 0x38382238, 0x70385238, 0xa4388c38, 0x98398439, 0xc639b039, 0xf439dc39, 0x263a103a, 0x683a443a, 0x303b1a3b, 0x5e3b483b, 0x8a3b743b, 
    0xee3ba23b, 0xc43cac3c, 0xf23cda3c, 0x223d0c3d, 0xbe3da63d, 0x683eee3d, 0x483f203f, 0x2040c83f, 0x48403440, 0x98406e40, 0x0a41c640, 0xa4415641, 
    0x0e42e041, 0x5e423c42, 0x22430043, 0xbc436443, 0xa2444a44, 0x02000000, 0x04824400, 0x5505643b, 0x07000300, 0x01b12e00, 0xb23c2f00, 0xed1c0407, 
    0x0506b132, 0x03b23cdc, 0x220a8202, 0x8303b100, 0x83052016, 0x07b22716, 0x3cfc1d06, 0x178301b2, 0x21113337, 0x11212511, 0x20024421, 0x980124fe, 
    0x550568fe, 0x0444abfa, 0x215783cd, 0x57820302, 0x4405c922, 0x4a085784, 0x03154029, 0x00029807, 0x02041004, 0x09080404, 0x05020101, 0x0302049d, 
    0xed2f3f00, 0x112f3911, 0x2f390112, 0x32ed335d, 0x23013031, 0x35033303, 0xb1021533, 0xc6c41894, 0x038d01c2, 0xc9bcfab7, 0x010200c9, 0x034d0315, 
    0x84cc05b6, 0x2725084f, 0x96031440, 0x07090202, 0x01062f96, 0x06010600, 0x06000005, 0x3f000002, 0x322f3333, 0x5d5d2f01, 0x2f3912ed, 0x844d85ed, 
    0x8e8c3151, 0x15fee028, 0x03e0298d, 0xfd7f024d, 0x007f0281, 0xc4080082, 0x00360002, 0x058b0400, 0x001b0045, 0xb9f0001f, 0xf0ff0400, 0x110d9940, 
    0x161d0648, 0x031d261d, 0x01160106, 0x12030126, 0x040b0e0f, 0x1d08130a, 0x1404151c, 0x00010409, 0x05180419, 0x071e1f16, 0x13170604, 0xac0514ac, 
    0x18ac1706, 0x3f032f1a, 0x1a030203, 0x06301803, 0x06500640, 0x20181003, 0x18e00218, 0x140218f0, 0x06181806, 0x210a0314, 0x0c0c1111, 0x0a00ac09, 
    0x04080a01, 0x1d0daf0c, 0x001c0d01, 0x1911af10, 0x114f1115, 0x5f114f01, 0x0311ef11, 0x221f4011, 0x8f0d7f48, 0x030d9f0d, 0x0d5f0d4f, 0x0d110d02, 
    0x13170511, 0x00050a03, 0x333f332f, 0x2f393912, 0x2b715d2f, 0x3311715d, 0x32ed1033, 0x82068632, 0x33ed27f4, 0x112f332f, 0x20821712, 0x1f832182, 
    0x2f5d2f24, 0x0183ed10, 0x038b1583, 0x5d30312c, 0x03012b5d, 0x03211521, 0x03831323, 0x33352329, 0x21352313, 0x83033313, 0x82332003, 0x212e0817, 
    0x43a20313, 0xe5fe0401, 0xfe566e58, 0x546e5495, 0xf143e1c9, 0x6e590701, 0x586b0158, 0xfdd3586e, 0x6a014540, 0xfe410343, 0x68fe6cc3, 0x03839801, 
    0x3d016c23, 0x0809856c, 0x6c68fe74, 0x3d01c3fe, 0x03000000, 0x73ff4200, 0xc4057e04, 0x44003900, 0x19014f00, 0x3d44c740, 0x65023d54, 0x476e014e, 
    0x013c6501, 0x75012f6a, 0x022a852a, 0x29862976, 0x86227602, 0x0e650222, 0x890a7901, 0x0979020a, 0x79020989, 0x02038903, 0x1f8a1f7a, 0x2d6f2c02, 
    0x334b452d, 0x243f0627, 0x1f070711, 0x00850075, 0x006f0002, 0x20451045, 0x70456045, 0x08830545, 0x08823020, 0x45905008, 0x45b045a0, 0x51454507, 
    0x400b6f0c, 0x8e482012, 0x0b0b010b, 0x1f006f3a, 0x00021f40, 0xf01f101f, 0x321f031f, 0x4a247340, 0x3f337312, 0x2d2d243f, 0x40252427, 0x25482720, 
    0x48171240, 0x06242525, 0x0873114b, 0x0c100c00, 0x0c500c40, 0x83050c60, 0x0ca03806, 0x0cf00cb0, 0x080c0c05, 0x07010790, 0x18080507, 0x33333f00, 
    0x82115d2f, 0x10712903, 0x333f32ed, 0x112b2b2f, 0x11251182, 0xed332f39, 0x24118232, 0x715d2f01, 0x211d82ed, 0x2384ed2b, 0x125ded22, 0x33251982, 
    0x3232cd33, 0x25108232, 0x30315ded, 0x00895d00, 0x015d0133, 0x07020e14, 0x2e352315, 0x1e372701, 0x26111703, 0x2a018227, 0x35052e23, 0x37023e34, 
    0x82153335, 0x07d70813, 0x1127032e, 0x1401051e, 0x1117021e, 0x3401030e, 0x1127022e, 0x7e04033e, 0x77af7238, 0x22f3d780, 0x4d2d0baa, 0x07084d70, 
    0x02030604, 0x4c586231, 0x72401f38, 0x66805d9d, 0x14406691, 0x3f270aae, 0x723a3b58, 0x24415867, 0x4528b0fc, 0x6247365d, 0xa4021b3c, 0x3a6a5030, 
    0x2b4d6b41, 0x804b7c01, 0xa105395f, 0xa7b907a1, 0x445b3625, 0xe9010429, 0x02010202, 0x271d0c01, 0x3f614937, 0x284f7752, 0x04828203, 0x4c75502c, 
    0x394f3021, 0x56fe0421, 0x3a2b1f0e, 0x36026c51, 0x1e2f4736, 0x039d010e, 0xfd453521, 0x34513f5e, 0x29fe0f21, 0x52381e04, 0x00050000, 0x04f4ff00, 
    0x005105ce, 0x00170003, 0x003f002b, 0xb9c10053, 0xd8ff3e00, 0x0e090e40, 0x09283848, 0x8334480c, 0xb82e2404, 0x82b3d8ff, 0x82162011, 0x201a8407, 
    0x20158310, 0x2004830c, 0x20128306, 0x2b1b8216, 0x02890279, 0x56030202, 0x86007600, 0x4d084f82, 0x01100301, 0x00f0ffba, 0x40c0ff03, 0x480e0a3a, 
    0x012f011f, 0x0303013f, 0x13010301, 0x3bb44a31, 0x70b431b5, 0x02408040, 0x55134040, 0xb509b418, 0x4513b422, 0x4fb72cb6, 0x271936b6, 0x1db70eb6, 
    0x020704b6, 0x00180006, 0xed3f3f3f, 0x0383edf4, 0x822f0121, 0x12112708, 0xfd5d2f39, 0x0782edf4, 0x2f2f3929, 0x38382b5d, 0x825d3311, 0x30312102, 
    0x3608ae49, 0x33012333, 0x021e3225, 0x020e1415, 0x022e2223, 0x023e3435, 0x822e3413, 0x820e200b, 0x021e2613, 0x023e3233, 0x081f9e01, 0x0391dd28, 
    0xa0fc93a4, 0x2d4d673a, 0x3c684e2d, 0x2c4e693c, 0xc66a4e2d, 0x21332312, 0x12243623, 0x22352413, 0x13243320, 0x219f0802, 0x49052508, 0x814d1f08, 
    0x50826063, 0x834f2323, 0x4d816360, 0x42b0fe1f, 0x16153558, 0x40425735, 0x17173657, 0xd8fe5736, 0x340822a0, 0x00030000, 0x04ecff2b, 0x004d05a1, 
    0x004f003d, 0x40f4005f, 0x834e7318, 0x5179024e, 0x65025189, 0x85587558, 0x53690358, 0x01253901, 0xe8ffb820, 0x480e09b3, 0x0807841c, 0x2e480c94, 
    0x40f0ffb8, 0x480c093d, 0x06011225, 0x02121612, 0x23194948, 0x3e303e49, 0x013b3001, 0x49313b3b, 0x01506b30, 0x141c140c, 0x2803146c, 0x0414534b, 
    0x34502d3e, 0x70190405, 0x903e803e, 0x3e3e033e, 0xffb81930, 0x103f40c0, 0x303f4813, 0x19301901, 0x48566130, 0x170b400f, 0x2d600f48, 0x2d802d70, 
    0x01506503, 0x05015029, 0x042d3450, 0x4b45300a, 0x4b654b55, 0x30144b03, 0x5b055328, 0x031e5143, 0x00515b37, 0x3f00160a, 0x3f32ed33, 0x391712ed, 
    0x04832f5d, 0x015d5d25, 0x45ed2b2f, 0x2b270532, 0x5d2f3912, 0x84391711, 0xed103517, 0x5d5d2f32, 0xed10ed10, 0x5d003031, 0x2b2b2b5d, 0x005d015d, 
    0x05260384, 0x27022e22, 0xd541030e, 0x2e372707, 0x3e343503, 0xcc413302, 0x1e073406, 0x013e1703, 0x010e1737, 0x33011e07, 0x15373632, 0x4101010e, 
    0x162b08f8, 0x03033e17, 0x0e27012e, 0x42141501, 0xad080504, 0x4c293004, 0x1c163a43, 0x3b675647, 0x31669e6d, 0x3e6b4e2d, 0x0c151b0f, 0x5984572b, 
    0x30567645, 0x4e937244, 0x4a443e1f, 0x143f2a2a, 0x31571a91, 0x1a28612b, 0x38181530, 0x2d18bbfe, 0x492c2740, 0x17261e35, 0x31557140, 0x42a1594a, 
    0x40205e55, 0x47274161, 0x150c313c, 0x191a2f23, 0x3a182632, 0x4d508a66, 0x2051677e, 0x4c49441c, 0x516d3e25, 0x6444232e, 0x566c4740, 0x64362146, 
    0x572e5d60, 0x8b2b79c6, 0x33365ee5, 0x0b870907, 0x2249040b, 0x19162738, 0x412a432e, 0x321b2b74, 0xcbfc473a, 0x2e74e164, 0x5c346595, 0x1e132744, 
    0x00820026, 0xf601013e, 0xd6024d03, 0x0300cc05, 0x0d401c00, 0x02009603, 0x04020201, 0x02000005, 0x333f0000, 0x2006aa47, 0x055a47ed, 0x47ac0221, 
    0x00280651, 0x56010100, 0x7b0357fe, 0x22083782, 0x40280015, 0xf0061016, 0x1f050f11, 0x05050205, 0x00f00017, 0x100b010b, 0x001b0600, 0x2f013f3f, 
    0x4712ed5d, 0x142408ec, 0x2317021e, 0x08056141, 0x0e33372c, 0x29110203, 0xbe608958, 0x2b59875c, 0x5c87592b, 0x588960be, 0x8a120229, 0x76e1e6f4, 
    0xfbe6db71, 0xe5f99090, 0xe17671d9, 0x6f83f4e6, 0x6f825020, 0x6f847520, 0x1340242a, 0x0b0bf000, 0xf0051117, 0x10266582, 0x10060206, 0x6c860500, 
    0x32ed3322, 0x08060a48, 0x020e1428, 0x033e2307, 0x022e3435, 0x031e3327, 0x582a7503, 0x60c05c87, 0x2a2a588a, 0xc0608a58, 0x2a58875c, 0xfb901402, 
    0x6184dbe6, 0x84898a21, 0xe5d92275, 0x086b82f9, 0x02f80033, 0x05d403fc, 0x000e00cb, 0x5b1740af, 0x02066b06, 0x03500300, 0x0f030360, 0x6f095f09, 
    0x030b0309, 0xffb80807, 0x0b4c40c0, 0x08084811, 0x04050d0a, 0x08098240, 0x0204043e, 0x0d0a0e0e, 0x800a700e, 0x060a020a, 0x100d000e, 0x0d0d020d, 
    0x0a02100f, 0x000b010a, 0x850c750c, 0x0903020c, 0x0b7f0804, 0x0b020b8f, 0x0c090608, 0x050d050b, 0x07800770, 0x07030790, 0xb6375082, 0x07480c09, 
    0x00000d07, 0x2b2f333f, 0x1712335d, 0x115d2f39, 0x84331133, 0x49078204, 0xcd2e0538, 0x2b5dc439, 0x4d101801, 0x2b2f39e4, 0xef821133, 0x332b3f08, 
    0x5e5f3031, 0x5d005d5d, 0x05172501, 0x010b0717, 0x37253727, 0x02330305, 0x2d08019f, 0x77b9e6fe, 0xbd779c96, 0x012de8fe, 0x04880c0b, 0x498467a4, 
    0x020148fa, 0xf84800ff, 0x016b8649, 0xf3830029, 0xb400742f, 0x9e045704, 0x49000b00, 0x0e0b2540, 0x3ecc8201, 0xaa010904, 0x02000640, 0x02030a01, 
    0x020d0c02, 0x0507040e, 0x0107300e, 0xad040007, 0x82b30509, 0x32ed25a5, 0x002b5dc6, 0xe6208a82, 0x83829a84, 0x821a3321, 0x299d8413, 0x013031e6, 
    0x21112311, 0xc2822135, 0x02152137, 0x58fe93af, 0x0193a801, 0xfe6002a8, 0x92ac0154, 0x54feac01, 0x3f7a8292, 0x03010100, 0xb50295fe, 0x03002b01, 
    0x27403900, 0x00190009, 0x0e100002, 0x02094811, 0x02020219, 0x012a0983, 0x03970299, 0x6f002f9a, 0x24827f00, 0x019c0037, 0x1000049b, 0x2f01edf6, 
    0xedfded5d, 0x5d2b3031, 0x13015d2b, 0x24488221, 0xfe0901a9, 0x224d82c9, 0x826afd96, 0x014e2657, 0x027e03d0, 0x28328270, 0x030f401d, 0x00000503, 
    0x265a8210, 0x012fba00, 0x82000101, 0x223f823b, 0x822f3912, 0x21352ba7, 0x024e0115, 0xa0d00130, 0x378200a0, 0x0000f024, 0x8f84db02, 0x0c401a24, 
    0x12829603, 0x04000029, 0x009b0105, 0x84ed2f00, 0x825d20e8, 0x26d68374, 0x01ebf001, 0x83d5fe2b, 0xff722620, 0x055904ec, 0x086b82cc, 0x1c403d22, 
    0x3901018a, 0x79016901, 0x02010301, 0x05020210, 0x36010385, 0x76036603, 0x00030303, 0xb7f0ffb8, 0x03233083, 0x43000119, 0x38230521, 0x825d5d32, 
    0x33383a87, 0x30315d5d, 0x01330117, 0xb2350372, 0x0514cffc, 0x0020fae0, 0x00030000, 0x085b827c, 0x5a054f63, 0x27001300, 0x79002b00, 0x20365240, 
    0x56114601, 0x0d460211, 0x49020d56, 0x02075907, 0x03590349, 0x202a1002, 0x2a40022a, 0x00022a50, 0x292a0129, 0x001e292a, 0x5014406e, 0x14000214, 
    0x2d141401, 0x0a006f1e, 0x0a020a10, 0x4f01284f, 0x02285f28, 0x23292928, 0x070f7319, 0x19057323, 0x3fed3f00, 0x228482ed, 0x43715dcd, 0x712007b3, 
    0x22064a45, 0x4831715d, 0x013406bb, 0x010e0214, 0x012e2223, 0x12343502, 0x3233013e, 0x0712011e, 0x080e0747, 0x33352552, 0x4d4f0415, 0x6766b485, 
    0x4b4b83b2, 0x656ab484, 0xb74c84b1, 0x48714e28, 0x284f744c, 0x49724f29, 0x2b4f7247, 0x02eb58fe, 0xf7fec3a3, 0xa34747a4, 0xccc30a01, 0x409f0c01, 
    0xf4fe9f40, 0x7ed49fcc, 0xd37e3534, 0x80d29a9f, 0xd2803838, 0x00f9f922, 0x47080082, 0x00940001, 0x056a0400, 0x00120045, 0x00394059, 0x11110111, 
    0x08026f10, 0x01011f08, 0x013f010f, 0x015f014f, 0x019f018f, 0x010701af, 0x02100e01, 0x70021001, 0x03028002, 0x14130202, 0x09097308, 0x10060e03, 
    0x18007301, 0x3223e682, 0x4133333f, 0x712007c6, 0x39080a82, 0x2f33715d, 0x2f32ed10, 0x3330315d, 0x0e112135, 0x32352303, 0x3337023e, 0x9d152111, 
    0x6013b701, 0x4a428e7d, 0x1a607c8f, 0x916101a6, 0x4728fd03, 0x22941f34, 0xfb32543d, 0x9784914c, 0x97829020, 0x053c3d08, 0x0026005a, 0x755c4087, 
    0x02068506, 0x74012039, 0x021b841b, 0x1a861a76, 0x87157702, 0x16770215, 0x69021687, 0x106b010a, 0x01105901, 0x26011a05, 0x1f6e1d26, 0x02083f08, 
    0x08bf086f, 0x0032c582, 0x136e1228, 0x24600013, 0x24802470, 0xcf242403, 0xab420100, 0x12122705, 0x0718730d, 0xba872401, 0x2f33ed26, 0x5d5d2f01, 
    0x2605894a, 0x391211ed, 0x82715d2f, 0x0c5c4abb, 0x3e353324, 0x95413505, 0x27072306, 0xcc46033e, 0x04470806, 0x90152107, 0xa5a3902c, 0x47275485, 
    0x5d363b61, 0xb8072c46, 0xa26f4009, 0x75a7696a, 0xa487563e, 0x0220809c, 0xa46175d3, 0x85818491, 0x39573c4a, 0x593c1e1b, 0x864c113b, 0x5d303a65, 
    0xa15e598a, 0x81808290, 0x82009246, 0xff80249a, 0x824b04ec, 0x3b4708f3, 0x6340e600, 0x39853975, 0x01396302, 0x39503940, 0x88347802, 0x346c0234, 
    0x5b344b01, 0x2f740234, 0x06022f84, 0x862e762e, 0x2977032e, 0x6c022987, 0x255a0125, 0x01126301, 0x55010d64, 0x0879010d, 0x79020889, 0x4b078907, 
    0x340805f6, 0x028b027b, 0x311a3602, 0x5f203f6e, 0x20200220, 0x40136e00, 0x13000113, 0xffb81301, 0x153c40c0, 0x131a4818, 0x3d0a131a, 0x27276e26, 
    0x0acf6e0b, 0x0aef0adf, 0x05d14203, 0x73193634, 0x2c101a1a, 0x73232626, 0x7310072c, 0x900b4005, 0x0483020b, 0x030bf03c, 0x19050b0b, 0x2f333f00, 
    0xed10715d, 0x2f33ed3f, 0x2f391211, 0x2f0139ed, 0x0c825d5d, 0x2006f549, 0x251c832b, 0xed712f33, 0x4a413911, 0x07b04b0c, 0xf8490120, 0x37273706, 
    0x3233031e, 0x2e343536, 0x35012b02, 0x023e3233, 0x23263435, 0x66410622, 0x026a080a, 0x031e1507, 0x793f4b04, 0xb48274b2, 0xba093a74, 0x6d4a2b08, 
    0x459b8849, 0x66337967, 0x5b6e3362, 0x7783853b, 0x0bb50c93, 0x599e7b50, 0x336ca977, 0x4a6f4925, 0x2b547d52, 0x915b7201, 0x6b413664, 0x38114989, 
    0x7e24425c, 0x355a4479, 0x37199c16, 0x776a3f59, 0x5d0e6f7a, 0x382d5b8a, 0x37498160, 0x0f405667, 0x573c0904, 0x0082006a, 0x00022508, 0x04000067, 
    0x00450565, 0x000d000a, 0x69354055, 0x89067906, 0x097f0306, 0x08090901, 0x060d6f01, 0x02a00290, 0x28080082, 0x106f0c0f, 0x00040104, 0x05087304, 
    0x0c1f0c0f, 0x0c6f0c2f, 0x010c0c04, 0x0106060b, 0x3f3f0018, 0x2f391233, 0xed33335d, 0x08b14732, 0x32250b82, 0x30315d2f, 0x05c5455d, 0x33012708, 
    0x09153311, 0xa9032101, 0x0272fdb4, 0xfebcc77b, 0x010cfe90, 0xfe3f01f4, 0x8c3f01c1, 0x88fc7a03, 0xfd43038e, 0x1f42004b, 0x45470809, 0x8e002c00, 
    0x08695e40, 0x08890879, 0x79076903, 0x03078907, 0x175a174a, 0x55134502, 0x40220213, 0x2248110d, 0x156e0022, 0x1f212425, 0x0a20206f, 0x00011540, 
    0xd015c015, 0x15150315, 0xf06e0b2e, 0x0acf010a, 0x41020adf, 0x253205e2, 0x1a202073, 0x01286f73, 0x24102828, 0x10062173, 0xd9410573, 0x44102007, 
    0x5d2405ba, 0xed2f33ed, 0x5d20be82, 0x20057248, 0x28d18271, 0x323233ed, 0x2f32ed10, 0x06d5412b, 0x210dc741, 0x2643023e, 0x23c60808, 0x21152113, 
    0x33013e03, 0x04021e32, 0xbb7e404b, 0x72a56f7b, 0x0bb60e43, 0x48654528, 0x2c517246, 0x48714e2a, 0x35414c2d, 0x032fb017, 0x1d85fd21, 0x69639030, 
    0x014076a8, 0x7bab64bc, 0x7a5b3446, 0x4b281546, 0x502b233b, 0x673c4975, 0x1c102b4c, 0xd8021425, 0x2557fe91, 0x9c714035, 0x02000000, 0xecff9700, 
    0x5a054804, 0x38002400, 0x7d40ab00, 0x038a037a, 0x8a027a02, 0x03680202, 0x03880378, 0x77236703, 0x03238723, 0x22772267, 0x45032287, 0x02375537, 
    0x31533143, 0x5a2d4a02, 0x274b022d, 0x1c02275b, 0x3c1b2c1b, 0x6e15031b, 0x6e001414, 0x400125af, 0x25000125, 0x25d025c0, 0x3a252503, 0x906e2f1d, 
    0x2c41a00a, 0x0ae03d05, 0x0a040af0, 0x206f732a, 0x20201001, 0x20200220, 0x0f731834, 0x1501158f, 0x34070f15, 0x3006ec45, 0x105d2f33, 0x2f3912ed, 
    0x01ed5d5d, 0xed715d2f, 0x200b8332, 0x20078271, 0x05244b2f, 0x450ffa42, 0x022907f1, 0x012e0717, 0x020e2223, 0x052d4115, 0x080fff45, 0x3b480462, 
    0x7b6faa73, 0x453d7ab8, 0x4876bb82, 0x174e677e, 0x517b1cac, 0x2d54784a, 0x6073b231, 0xb73c6f9d, 0x466a4824, 0x33516431, 0x426a4b28, 0x26486741, 
    0xab64be01, 0xac5d467d, 0x01b198f5, 0x1e5fb810, 0x1f506e43, 0x8645515b, 0x5f5b81c5, 0x6ba0723e, 0x2d507043, 0x41624121, 0x39628148, 0x0074522d, 
    0x37080082, 0x009e0001, 0x052d0400, 0x000e0045, 0x05104035, 0x0c06066e, 0x0b0b6f00, 0x100c0010, 0xb80c020c, 0x0b40c0ff, 0x0c481814, 0x0d730c00, 
    0x00180506, 0x32ed3f3f, 0x5d2b2f01, 0x2b52e482, 0x062d0807, 0x2315020a, 0x37021a34, 0x04213521, 0x82ab602d, 0x8650bc4c, 0x1ffd61b0, 0xba048f03, 
    0xfedafe8a, 0x9fc6fecf, 0x013b019e, 0x85240132, 0x08738291, 0x85000351, 0x4604ecff, 0x29005a05, 0x51003d00, 0x7e40b600, 0x28852875, 0x860c7602, 
    0x0278020c, 0x78020288, 0x02088808, 0x1d871d77, 0x89227902, 0x12780222, 0x6a021288, 0x406a0146, 0x01506501, 0x65014a65, 0x3665013c, 0x1f102401, 
    0x1f156e34, 0x82152a6e, 0x000a3601, 0x013e406e, 0x3ec03e00, 0x3e033ed0, 0x6e48533e, 0x0af00ae0, 0x0af84202, 0x10102436, 0x39397343, 0x861a764d, 
    0x732f021a, 0x0579071a, 0x4d020589, 0x2205c641, 0x84ed3f5d, 0x113922d3, 0x0af94233, 0x3925e282, 0xed102f2f, 0x44088310, 0x03430fd0, 0x34352507, 
    0x3537023e, 0x230eef4c, 0x03031e15, 0x4e0ed047, 0x8d080fe8, 0x75394604, 0xb57c7db5, 0x4f2f3977, 0x5d3b3665, 0x7039213f, 0xa9736da6, 0x3f21366f, 
    0x683d3d5d, 0x1bde2b4d, 0x4649643e, 0x161c3f63, 0x5650663a, 0x23113766, 0x5673441c, 0x20456f4f, 0x51724620, 0x1d446f53, 0x91547a01, 0x6b3d3d6c, 
    0x73475391, 0x04093454, 0x64543e0e, 0x607d4435, 0x7e603a39, 0x54643444, 0x0a040c3d, 0x02715435, 0x3c522f33, 0x523c2323, 0x4552252f, 0x52452e2d, 
    0x592dbbfd, 0x482c2c47, 0x653b2f5a, 0x4b292a4a, 0x00820067, 0x8d000226, 0x3f04ecff, 0x39065b43, 0x7a7740a5, 0x02088a08, 0x078a077a, 0x77206702, 
    0x03208720, 0x1a781a68, 0x54431a88, 0x31452205, 0x0b544355, 0x11134608, 0x11331123, 0x6e001303, 0x258f253f, 0x25af259f, 0xd025c004, 0x25250225, 
    0x6e0b3a1d, 0x6e2f0a0a, 0x1df01de0, 0x011dcf02, 0x1d101d00, 0x73341d02, 0x13401813, 0x18184816, 0x22732a0e, 0x05730e07, 0x0b800b70, 0x08644602, 
    0x21068b44, 0x8944332b, 0x2f332106, 0x2007a547, 0x0b884133, 0x29074949, 0x1e372702, 0x3e323301, 0x834e3702, 0x32332109, 0x08105449, 0x463f0477, 
    0x5177bd84, 0x16486682, 0x5b771cac, 0x3155784a, 0x5d491501, 0x9b60386b, 0x783f3b6c, 0xf1ec6faf, 0x6b4925c4, 0x48684146, 0x68462327, 0x53673245, 
    0xb1bf0235, 0x5db7f2fe, 0x4f704621, 0x44555b1b, 0x2f81c484, 0x441b334a, 0x6865a97a, 0xfe4278a9, 0x8349b0b4, 0x532d3b63, 0x73424673, 0x43223257, 
    0x01020065, 0x020000f0, 0x003a04db, 0x00070003, 0x06124024, 0x06fb4a05, 0x04080925, 0x4a0f059b, 0x3f2005ff, 0x2807014b, 0x30313233, 0x11331121, 
    0x2a038203, 0xebebf001, 0xfe2b01eb, 0x830f03d5, 0x25468205, 0x95fe6001, 0x4b861203, 0x83010021, 0x21132223, 0x26278201, 0x01a985fe, 0x85c9fe09, 
    0xfb310828, 0xfd960286, 0x0000006a, 0x00740001, 0x0457049a, 0x000600aa, 0x0100b577, 0x05040552, 0x400d01b8, 0x14000610, 0x06050006, 0x52010201, 
    0x04010403, 0x2f148303, 0x14010228, 0x02030102, 0x00040806, 0x02001000, 0x04383d82, 0x3f050204, 0x7f066f06, 0x40060306, 0x06481512, 0x01020f03, 
    0x5d2f0002, 0x2605484d, 0x332f3d39, 0x82180133, 0xde10280e, 0x0487c1d4, 0x8401102b, 0x84c42005, 0x2b183f07, 0x31c42b87, 0x01351330, 0x15010915, 
    0xfce30374, 0x025a03a6, 0xa201cd3b, 0xfe92fe9a, 0x9f829991, 0x74000237, 0x57045801, 0x0300ec03, 0x4c000700, 0x02073740, 0x01000409, 0x3e978210, 
    0x041fad05, 0x049f047f, 0x04bf04af, 0x12400405, 0x00044816, 0x500130ad, 0x70016001, 0x82500401, 0x01802704, 0x01d001b0, 0x754c0f05, 0x715d2705, 
    0x712b2fed, 0x8c8301ed, 0x8332ce21, 0x15212476, 0x84213501, 0x031d2a77, 0x945803e3, 0x9400fe94, 0x0f134194, 0x52010622, 0xfe836c82, 0x0600102f, 
    0x01060014, 0x01040500, 0x05020352, 0x05134102, 0x14050426, 0x04030504, 0x2a091441, 0x02020506, 0x01040f03, 0x4d3f0104, 0x40290637, 0x00481512, 
    0x5d2b2f00, 0x417b8232, 0xc4240812, 0x1032ce10, 0x25171341, 0x01093537, 0x9b820135, 0xa6fc5a2f, 0x999ae303, 0x6e016f01, 0xcd5efe9a, 0x30008200, 
    0x005e0002, 0x05310400, 0x0027005a, 0x406d002b, 0x067b4849, 0x79046931, 0x03048904, 0x1b5a1b4a, 0x17250702, 0x53660225, 0x3a0805c0, 0x0a982b09, 
    0x001e2828, 0x01130098, 0x1d2d1313, 0x400a1e98, 0x0a48140f, 0x9d29230a, 0x76236628, 0x03238623, 0x9e181d1d, 0x3f000423, 0x5d2f33ed, 0x3911ed2f, 
    0x2f012b2f, 0x503912ed, 0x33230545, 0x435d32ed, 0x01270644, 0x07060e14, 0x4a073e23, 0x3b080fe7, 0x15333501, 0x3e253104, 0x3f4f524f, 0x02af0127, 
    0x504e3e27, 0x29253c4d, 0x44446d4d, 0x0732526f, 0x7e4a0cb8, 0xb16c70b0, 0x8ffd447e, 0x45ea03c3, 0x3b425268, 0x3753443b, 0x41516643, 0x35340883, 
    0x1e395437, 0x3e654726, 0x6c975a0c, 0x895d303d, 0xc9c9bcfb, 0x5008eb84, 0x04e5fe2c, 0x00cc05a5, 0x0178005f, 0x0191403b, 0x02441144, 0x3f553f35, 
    0x01033f75, 0x023e113e, 0x347c346c, 0x1703348c, 0x480e0b18, 0x087c086c, 0x6c03088c, 0x02667c66, 0x665a664a, 0x015d2602, 0x6501536a, 0x85497549, 
    0x3f7f0349, 0x3f023f8f, 0x30278240, 0x0301397e, 0x2a7f2a6f, 0x02032a8f, 0x2a5f2a4f, 0x083d8402, 0x7a376a6a, 0x03378a37, 0x4b015169, 0x4c1f4c0f, 
    0x564c4c02, 0x2937d300, 0x600ad32f, 0xd26a0a28, 0x1440371a, 0x37104818, 0x3f1a2f01, 0x0a37021a, 0x370a1a1a, 0xb8417a03, 0x0db5e8ff, 0xd3414811, 
    0xc0ffb856, 0x20172640, 0x6f325648, 0x050f15d6, 0x21d66315, 0x26192828, 0x0f212601, 0x2f151f15, 0xaf159f15, 0x21900515, 0x210221a0, 0x172d2a83, 
    0x4b480c09, 0x15212115, 0x3c46034b, 0x3f428210, 0x005bd53c, 0xb851d546, 0x3f000f01, 0x2bed3fed, 0x2f391712, 0x5d2b2f2f, 0x5d33115d, 0xed102f33, 
    0x22058258, 0x872b2f01, 0x5d5d221a, 0x8215872b, 0x2f392d07, 0x5d00335d, 0x30315d01, 0x5f5d2b00, 0x39820182, 0x00825d20, 0x845d0121, 0x087e4608, 
    0x3e013c25, 0x44233501, 0x043008f6, 0x021e3233, 0x33373317, 0x15030e03, 0x32331614, 0x20089d49, 0x08635501, 0x84173721, 0x0201262e, 0x011a3435, 
    0x28308236, 0x34051201, 0x0e222326, 0x07805304, 0x3e37d908, 0x29a50403, 0x1e48724e, 0x01162734, 0x2e0f0601, 0x3f2a493b, 0x17173556, 0x6251412c, 
    0x2b3e2a38, 0x2005091c, 0x0f086374, 0x141d060b, 0x192f4128, 0x60946535, 0x427fbb78, 0x66a26f3b, 0x5159663b, 0x612b4726, 0x7f497e6f, 0x544d8ecc, 
    0x8396e9a1, 0xfe3f80c3, 0x253b4662, 0x1b283440, 0x2c1b0b0e, 0x3a472720, 0x08030d2e, 0xf3020407, 0x60acef90, 0x2c3c2510, 0x0a0c0b02, 0x36472703, 
    0x8b6b411f, 0x88964c4a, 0x1b305575, 0x97243f2f, 0x512a05fe, 0x34153d49, 0xc9915024, 0xa6e08179, 0xfee78660, 0xfa98b1c8, 0x2a1962b3, 0x2557213a, 
    0x711f3544, 0xb62601d0, 0x016301d1, 0xc8769204, 0x6a76f8fe, 0x644b2c6d, 0x3c397771, 0x372b4b67, 0x13578f64, 0x00313634, 0x00020000, 0x04350082, 
    0x004505cc, 0x00140007, 0x13424072, 0x01050302, 0x030d0352, 0x06f8435e, 0x01143f08, 0x52010600, 0x5e000d00, 0x07140607, 0x10040d06, 0x07070107, 
    0x8f047f16, 0x07040204, 0x145f0201, 0x0d5a1313, 0x010d4b01, 0x0305060d, 0x00120004, 0x333f323f, 0x395d5d33, 0x32ed332f, 0xdb58012f, 0x39122f05, 
    0x2b872b87, 0xc0c010c4, 0x87c10010, 0x0c861805, 0x30314b08, 0x03210321, 0x09330123, 0x27032e01, 0x0307030e, 0x8a0a0421, 0xc489cdfd, 0x01d9fe01, 
    0x0df1fdf5, 0x0411171c, 0x19171004, 0xcf01970d, 0x82fe7e01, 0xbbfa4505, 0x4e26ba03, 0x0c0c3546, 0x254e4636, 0x030059fe, 0x0000a200, 0xc3828004, 
    0x00165608, 0x002e0021, 0x654f4077, 0x246a012d, 0x01206601, 0x028b027b, 0x840b7402, 0x030b940b, 0x6f010b07, 0x124b0112, 0x1202125b, 0x175a0d29, 
    0x48140d40, 0x00061717, 0x0122005a, 0x1c302222, 0x06005a29, 0x06a00610, 0x060406b0, 0x1c5f2812, 0x5f1b291c, 0x5f290307, 0x4cd28206, 0xed210509, 
    0x4ace8239, 0xed2805d1, 0x2b2f3912, 0x5d3911ed, 0x27098059, 0x020e1401, 0x21112123, 0x2709e355, 0x2b263401, 0x32331101, 0x8205d557, 0x8221200a, 
    0x0455080a, 0xbc8e5480, 0x0128fe68, 0x80b8759c, 0x64432143, 0x58835544, 0x97eefe2e, 0x51e1df97, 0x51214872, 0x50825d33, 0x490a01fc, 0x01335b7d, 
    0x5b90677c, 0x2645052a, 0x38567c4f, 0x0e3b5165, 0x71573809, 0x5b6b2802, 0x391f60fe, 0x3fd9fd50, 0xfe1a3958, 0x5e381722, 0x08008200, 0x71000194, 
    0x7604ecff, 0x29005a05, 0x2d40a400, 0x46012739, 0x661d561d, 0x1c66031d, 0x01033601, 0x1f301f20, 0x701f6002, 0x1fa0021f, 0x201f1f01, 0x48241d40, 
    0x0b0a2020, 0x010ab00b, 0xc0ffb80a, 0x0c094540, 0x2b0a0a48, 0x00860076, 0x305b0002, 0x50154015, 0x15000315, 0x15021510, 0x1a561a46, 0x1a5f2502, 
    0x041a2020, 0x0a200a10, 0x0a600a30, 0x30050a70, 0xd00a800a, 0x040ae00a, 0x10490a0a, 0x05021059, 0x0013105f, 0x335ded3f, 0x3f715d2f, 0xed102f33, 
    0x0982015d, 0x125ded25, 0x822b2f39, 0x33112314, 0x1a832b2f, 0x6c457220, 0x021e2508, 0x023e3233, 0x200a7e43, 0x05fc4b12, 0x07175508, 0x2223032e, 
    0x3a01020e, 0x5c835428, 0x3a4f653f, 0x521c9f15, 0x8d669b74, 0x404187cd, 0x658aca84, 0x194d6f98, 0x49340fa8, 0x7f593c61, 0xa9022652, 0x488ccb83, 
    0x36664e30, 0x69854641, 0x01b86540, 0x01a69e02, 0x375baf01, 0x4142795d, 0x2a44582e, 0x00c78744, 0x02230082, 0x4e00a200, 0x480805d7, 0x0017000c, 
    0x75454061, 0x02028502, 0x108a107a, 0x80177002, 0x17140217, 0x17641724, 0x8f0f7f03, 0x0f1b020f, 0x0f6b0f2b, 0x010b3403, 0x3b010a34, 0x5a000103, 
    0x0da00d00, 0x190d0d02, 0x06005a14, 0x06020610, 0x03075f13, 0x071f4214, 0x4c07e04e, 0x8f490ce6, 0x05144205, 0x34073808, 0x012b022e, 0x12323311, 
    0x98506504, 0x8efe8cdd, 0xf39e3701, 0x38c055a6, 0x7975ac72, 0x02ced4a2, 0xfffea8b0, 0x450559ae, 0xacfaa24d, 0x3979c087, 0x0a01f3fb, 0x84010000, 
    0x05623cb3, 0x000b0045, 0x073b405a, 0x48140a40, 0x0a000707, 0x0a000303, 0x0d0a0a01, 0x485a0905, 0x082b05ae, 0x3f050f5f, 0x8f057f05, 0x826f0405, 
    0x059f2504, 0x05df05bf, 0x09270082, 0x03015f04, 0x42005f09, 0x712208c7, 0xc842ed72, 0x2f332c08, 0x2f391211, 0x3330312b, 0x82152111, 0x330384a8, 
    0xfd9703a2, 0xfd9c0228, 0x05010364, 0x5afe9c45, 0x9c33fe9a, 0xc2248782, 0x3d040000, 0x092c8782, 0x2d404700, 0x08060202, 0x05010b08, 0x3c060b41, 
    0x013f5f04, 0x018f017f, 0x6f013f03, 0x03019f01, 0x29154001, 0x05010148, 0x03075f00, 0x22798205, 0x8212ed3f, 0x895d2066, 0x05215579, 0x23207484, 
    0x012f0582, 0xfda40281, 0x7b03bf5c, 0x12fea904, 0x82e3fd9e, 0x08d34277, 0x64824f20, 0x00294008, 0x084a4088, 0x1e150102, 0x1e751e25, 0x55041e85, 
    0x27270112, 0x15af250a, 0x14151501, 0xc05a0014, 0x0225d025, 0x258f257f, 0x01250002, 0x362b2525, 0x861d761d, 0x041db61d, 0x0a305b1d, 0x51500a40, 
    0x210807d3, 0x28285f27, 0xffb80f20, 0x0d0e40f0, 0x5f184811, 0x0f15150f, 0x055f2004, 0xed3f0013, 0x102f333f, 0x99822bed, 0x2005bb4e, 0x2909825d, 
    0xed5d5d5d, 0x2f332f32, 0xb084115d, 0x0f820020, 0x2d462520, 0x09ae4208, 0x0805ba4e, 0x33121056, 0x37023e32, 0x21352111, 0x5f244d04, 0x864e8974, 
    0x3e4082c6, 0x6489c882, 0x184b6f97, 0x6f8b26ab, 0x234f7e5a, 0x5330aca9, 0xfe0d3143, 0x85df01db, 0x1e2d3618, 0x0101ba69, 0x0101a799, 0x59345aaf, 
    0x6e384579, 0xc7874579, 0xfef4fe82, 0x191711ea, 0xa0500109, 0x2f070342, 0x0045052a, 0x4057000b, 0x085a0b3c, 0x002f001f, 0x08058049, 0x006f0529, 
    0x008f007f, 0x000400bf, 0x03070d00, 0x0104705a, 0x04100400, 0x04b004a0, 0x5f020404, 0xa0010750, 0x0207b007, 0x45090707, 0x3923099f, 0x85715d2f, 
    0x059f4fe3, 0x31ed332a, 0x21112130, 0x33112311, 0x20080582, 0x6b031133, 0xbfbff6fd, 0x02bf0a02, 0x0591fd6f, 0x02cafd45, 0x00bbfa36, 0x00010000, 
    0x040000ca, 0x2e878401, 0x06384059, 0x040e0106, 0x00000707, 0x82700e09, 0x5a042f1b, 0x093f090f, 0x099f098f, 0x5f094f04, 0x0a827f09, 0xdf09cf39, 
    0x09100609, 0x0c090901, 0x5f08040d, 0x0b031207, 0x0003005f, 0x8232ed3f, 0x12112202, 0x82888201, 0x5dc42f89, 0x3301112b, 0x4d102f18, 0x312f32e4, 
    0x89421330, 0x82352006, 0x03ca3592, 0x01c4fe37, 0x01c9fc3c, 0x05c4fe3c, 0xf3fb9c45, 0x0d049c9c, 0x6f828a82, 0xecffb024, 0x8b82da03, 0x4b00153d, 
    0x751065b7, 0x03108510, 0xe8ffb80b, 0x110d2240, 0x08131348, 0x11115a00, 0x83801708, 0x08003b7c, 0x08020810, 0x03145f13, 0x09055f0e, 0x00130509, 
    0x102f333f, 0x01ed3fed, 0xdb415d2f, 0x41ed2006, 0x2b2805df, 0x0e14015d, 0x26222302, 0x08079353, 0x3521112a, 0x33da0321, 0xab629665, 0x0abb23cc, 
    0x29493a2a, 0xc9fe6968, 0xa401f501, 0x3e73a364, 0x401fc0b2, 0x8f1d3c5d, 0x9c09038a, 0x2007a741, 0x089382cb, 0x97000b48, 0x0a743440, 0x46020a84, 
    0x660a560a, 0x0764030a, 0x07840774, 0x01008d03, 0x007b006b, 0x59004902, 0x0a390200, 0x010a1401, 0x110b2001, 0x0b010a48, 0x09820972, 0xffb80902, 
    0x0b2d40e0, 0x0908480f, 0x00090910, 0x0282100b, 0x0b020b39, 0x03070d0b, 0x1004005a, 0x02040204, 0x76010a07, 0x02078607, 0x41080107, 0x39250ad1, 
    0x1133115d, 0x22cf8233, 0x821132ed, 0x333835d2, 0x33382f33, 0x39115d2b, 0x312b0039, 0x015d5d30, 0x005d5d5d, 0x21240583, 0x23110701, 0x21082b82, 
    0x01093301, 0x19feeb03, 0x02bfbfa3, 0x08fee13c, 0x7e024502, 0x052bfea9, 0x025ffd45, 0xfcc4fda1, 0xcf8300f7, 0x0000ed24, 0xcf824c04, 0x26000526, 
    0x04041640, 0x2f248582, 0x02003f00, 0x22057144, 0x44030301, 0x77820656, 0x41415d20, 0x2b848205, 0xed152111, 0x05a002bf, 0x9c57fb45, 0x81204383, 
    0x4b204382, 0x2c334382, 0x00b99900, 0x40e8ff1e, 0x48110d13, 0x1e361e26, 0x82182a02, 0x2a292f09, 0x0c022a39, 0x40f0ffb8, 0x48110b19, 0x0483100d, 
    0x24240c2f, 0x2a5c2c1c, 0x1c194000, 0x2e000048, 0x341d831e, 0x00110a0d, 0x5c1b1e4c, 0x1c101c00, 0xffb81c02, 0x2d28b3c0, 0x2a078348, 0x1e180940, 
    0x15061c48, 0x82241d15, 0x0c402b15, 0x2448110e, 0x1d2a0d0d, 0x8e481c03, 0x2f392306, 0x1d412b33, 0x2b590805, 0x32ed5d2b, 0x2f39122b, 0x11ed332b, 
    0x33331139, 0x30312b2b, 0x2b5d2b5d, 0x36341121, 0x06373637, 0x07010e07, 0x2e032303, 0x27262703, 0x011e1716, 0x11231115, 0x011e1333, 0x36171617, 
    0x37013e37, 0x03113313, 0x020201a9, 0x0e111101, 0x89a40e21, 0x0f0e06a6, 0x13120810, 0x08008201, 0xb9eda03c, 0x0c0b1709, 0x0b0c0e0d, 0xe1b90918, 
    0x6a336403, 0x3731332c, 0x26642d35, 0xb6014afe, 0x312f290f, 0x303c3718, 0x33692d34, 0x45059cfc, 0x4d1717fe, 0x2f312c26, 0x194e252b, 0x5f43ea01, 
    0xa2210806, 0x2a040000, 0x13004505, 0x24407800, 0x18005c12, 0x00481109, 0x11901180, 0x11e011d0, 0x01113f04, 0x080982c0, 0x116f0244, 0x118f117f, 
    0x15111103, 0xe8ffb80a, 0x110b2d40, 0x5c070a48, 0x00010870, 0xa0081008, 0x0408b008, 0x01018c08, 0x6901017a, 0x01110101, 0x0b830309, 0x010b7501, 
    0x0b010b66, 0x00120800, 0x5d33333f, 0x05855d5d, 0x5d2f0123, 0x05114171, 0x715d5d2a, 0xed2b3371, 0x01213031, 0x0126f888, 0x012e2726, 0xf3821135, 
    0xfd442308, 0x030404f8, 0x02deaa05, 0x04040510, 0x6a04ac05, 0x59262d2b, 0x0594fc27, 0x288efb45, 0x3362272e, 0xc2846003, 0x02003708, 0xecff6600, 
    0x5a056604, 0x1d001100, 0x56407900, 0x1d861d76, 0x011d3402, 0x19861976, 0x01193402, 0x17891779, 0x01173b02, 0x13891379, 0x01133b02, 0x45011056, 
    0x735a0110, 0x5b002a0e, 0x1201125f, 0x481c1940, 0x2f078200, 0x5b181f12, 0x10010a50, 0x150a010a, 0x1b040f5f, 0x4406ae45, 0x122505c2, 0x2b5d2f39, 
    0x0c774771, 0x5d20de82, 0x0810555a, 0x10030043, 0x02222302, 0x33121011, 0x66041232, 0x78bf8446, 0x4080c07f, 0x7cbf8244, 0xc90801f7, 0x9c9c989e, 
    0x94a3999e, 0xfeada902, 0x5e59b1fa, 0xa70501b3, 0xac0201ad, 0xfea5fe56, 0x010e01aa, 0xfef9fe07, 0x220182f2, 0x821801ec, 0xa22508e3, 0x5f040000, 
    0x0e004505, 0x5b001900, 0x17663e40, 0x86007601, 0x0f490200, 0x0f690f59, 0x7f5a0003, 0x020f8f0f, 0x27bf840f, 0x0f0f010f, 0x5a07141b, 0x2e099b41, 
    0x40145f06, 0x14481109, 0x5f130714, 0x47070309, 0x9647081e, 0x5d2b2209, 0x055a4aed, 0x554a0120, 0x11232605, 0x021e3221, 0x08504a07, 0x5f042d08, 
    0x7bb6793b, 0x01bfe7fe, 0x7cba7dcc, 0xa4a4c03e, 0x7952fef6, 0xb103264f, 0x48789b54, 0x4505fefd, 0x5e956a3a, 0xedfd817d, 0x00664a2b, 0x4c08af82, 
    0x047dfe66, 0x005a0571, 0x002c0020, 0x3562408b, 0x852c752c, 0x2835032c, 0x28852875, 0x7a263a03, 0x03268a26, 0x227a223a, 0x6903228a, 0x89117911, 
    0x044a0311, 0x4602045a, 0x021f561f, 0x1c561c46, 0x145a0502, 0x5b000b0b, 0x01215f21, 0x3bd68421, 0x21140121, 0x272e2114, 0x0119505b, 0x19011910, 
    0x041e5f24, 0x145f2a05, 0x5f600813, 0x0027f282, 0x3fed5d2f, 0x413f33ed, 0x392907a3, 0x2b5d2f2f, 0x32ed1071, 0x062e612f, 0x00845d20, 0x0461df83, 
    0x22232709, 0x2e27022e, 0x065c3503, 0x0eb04105, 0x8d623335, 0x6586295a, 0x2617401c, 0x8155315b, 0x701b4661, 0x413871a8, 0x933411be, 0x166daceb, 
    0x0508727e, 0x330d0986, 0x0b578a5f, 0x9cf9b267, 0x2017c941, 0x06cb4100, 0x05994e08, 0x00110045, 0xb997001b, 0xf0ff1a00, 0x4d000fb3, 0xe0ffb810, 
    0x110f2340, 0x01894c00, 0x01000b01, 0x110e2000, 0x10110048, 0x04011111, 0x10100110, 0x860b7603, 0x5a0b020b, 0xc0ffb812, 0x18153640, 0x8f127f48, 
    0x12000212, 0x1d121201, 0x05ac4516, 0x35058347, 0x1f5f0210, 0x02167f16, 0x166f163f, 0x16ef169f, 0x00161604, 0xba455f15, 0x12ed2508, 0x715d2f39, 
    0x20052159, 0x240b8332, 0x5ded2b5d, 0x30138211, 0x382f3233, 0x5d5d2b33, 0x002b3031, 0x2301212b, 0x05044211, 0x1415cb08, 0x0107020e, 0x01293403, 
    0x3e322111, 0xfebd0302, 0x01bfee92, 0x77b378e2, 0x8254273b, 0xf890015b, 0xf0fed0fe, 0x71531801, 0x3f021f45, 0x4505c1fd, 0x578a6133, 0x4c677b3e, 
    0x03abfd0f, 0x2afedfcd, 0x005a4328, 0x00010000, 0x04ecff4f, 0x005a0568, 0x40b0003f, 0x013d3479, 0x4b012d6d, 0x021d5b1d, 0x6001106b, 0x3e74010c, 
    0x74023e84, 0x3d40013d, 0x86023d50, 0x3c44013c, 0x76023c54, 0x02378637, 0x27842774, 0x74210402, 0x03218421, 0x89010b54, 0x077a0107, 0x01028b01, 
    0x2a010279, 0x0029295a, 0x0113005a, 0x411f1313, 0x087f5a09, 0x0802088f, 0x1f005a34, 0x1f021f10, 0x2f051334, 0x2a2a2460, 0x5f0e0424, 0x50094005, 
    0x8a470209, 0x105d2107, 0x2c057b49, 0x01393912, 0xd6ed5d2f, 0x1211ed5d, 0x20088239, 0x0e355832, 0xc7465d20, 0x25058205, 0x23020e14, 0xa4472422, 
    0x05d24f05, 0xe4662720, 0x32332305, 0x3f4c021e, 0x14152107, 0x7b080b82, 0x6804051e, 0x86c37f3e, 0x24fbfeea, 0x54300cb9, 0x7748557a, 0x6a413055, 
    0x66324485, 0x223d515e, 0x64ac7e48, 0x4471a374, 0x2b0bbc14, 0x50446447, 0x351d426c, 0x3745795b, 0x42596770, 0x55720126, 0xb83a688f, 0x5a3725ae, 
    0x3a1b2441, 0x58463f5a, 0x0d112338, 0x4b35271d, 0x89604365, 0x52292857, 0x33215079, 0x211c3650, 0x3c2d4e39, 0x1220314b, 0x392a1f0e, 0x00006e52, 
    0x004c0001, 0x2505974e, 0x404a0007, 0xfb600731, 0x5a013305, 0x023f020f, 0x029f028f, 0x02cf02bf, 0x5f024f06, 0x0e827f02, 0xdf02cf34, 0x02100602, 
    0x08020201, 0x5f040009, 0x12010305, 0x22493f00, 0x60c6200b, 0x152f0efc, 0xfebec502, 0x04340445, 0x0457fba9, 0x839c9ca9, 0x8e2b086f, 0x3d04ecff, 
    0x19004505, 0x44405e00, 0x15751565, 0x65031585, 0x850f750f, 0x5a00030f, 0x17901780, 0x17e017d0, 0x3f0517f0, 0x82c00117, 0x7f02340b, 0x02178f17, 
    0x0d1b1717, 0x9f0a8f5a, 0x030aaf0a, 0x5b010acf, 0x18230515, 0x4512030b, 0x33280663, 0x5d5d2f01, 0x3912ed71, 0x71200683, 0x21056545, 0xb0661401, 
    0x33112206, 0x06a26411, 0x11352f08, 0x3a3d0433, 0x747ab577, 0xbf3a73ae, 0x50693d19, 0x1d446f53, 0x89ea01be, 0x35387bc2, 0x0387bb75, 0x61adfc6d, 
    0x2828588a, 0x03679059, 0xaf830046, 0x00000a24, 0xaf82c204, 0x00105808, 0x0f554082, 0x48110e20, 0x0f390f29, 0x010f2b02, 0x03860376, 0x64035402, 
    0x03360203, 0x24020346, 0x01000103, 0x0f090f52, 0x1400105e, 0x01001010, 0x09035201, 0x01025e03, 0x03010214, 0x10020902, 0x10100110, 0x8f027f12, 
    0x0f020202, 0x09550302, 0x01094401, 0x46010009, 0x3f2006ea, 0x1131c383, 0x125d2f33, 0xc1001039, 0x872b0587, 0x1887c42b, 0x059e5510, 0x845d0121, 
    0x212b2500, 0x01330123, 0x0809e747, 0x02330126, 0x07fec6c9, 0x104001c9, 0x0d0e0c1d, 0x1e0c0e0c, 0xc93e0110, 0x7afc4505, 0x302a612d, 0x29302d2f, 
    0x86032f62, 0x4351c784, 0x01322c07, 0x2111404c, 0x4d000c08, 0x83101802, 0x0c0b2804, 0xb8104c00, 0x83b4e8ff, 0xb81a3008, 0x1040f0ff, 0x4c001110, 
    0x00111831, 0x8318314d, 0x82142014, 0x2b1d8414, 0xe0ffb823, 0x0f0b1c40, 0x18224c00, 0x10260584, 0x014d000a, 0x2e820b20, 0x83200021, 0x82002034, 
    0x0db42420, 0x844c000e, 0x0a092408, 0x82124c00, 0x1140213b, 0x12211b83, 0x21188328, 0x15832812, 0x27821120, 0x83134021, 0x09223f37, 0x02020932, 
    0x01010904, 0x2b235201, 0x0701b823, 0x01090c40, 0x23010914, 0x22520111, 0x1083221a, 0x1109483d, 0x11090914, 0x31520100, 0x325e312b, 0x32321400, 
    0x52011200, 0x5e141a14, 0x83141213, 0x2b2f0802, 0x13031a09, 0x32013210, 0x09133432, 0x224f222f, 0x2203225f, 0x13311a22, 0x001a2b03, 0x011a2401, 
    0x0301111a, 0x3f001212, 0x115d3317, 0x5d331133, 0x012706f2, 0x2f33112f, 0x4117125d, 0x78411071, 0x08065206, 0x5f5d0025, 0x8d2b015d, 0x30312100, 
    0x21200f83, 0x27068649, 0x030e0706, 0x03230307, 0x22098649, 0x82133703, 0x1703260c, 0x3e321716, 0x080b8202, 0xd0fa0326, 0x0f0e0568, 0x1111070f, 
    0x0f071112, 0x6a050e0f, 0x6dbdd3d0, 0x05050b08, 0x07101004, 0x060e0f0e, 0x066daf6d, 0x71080782, 0x01101007, 0x060c0a06, 0x8301bd68, 0x3f3b3413, 
    0x4d4c461e, 0x3b3f1e46, 0x7dfe1333, 0xbdfc4505, 0x39317c41, 0x1d434533, 0x17373c3d, 0x71fe8f01, 0x3d3b3816, 0x4446431d, 0x03367a66, 0x01000043, 
    0x00002400, 0x4505a904, 0xc8000b00, 0x09095c40, 0x01060b01, 0x03590309, 0x01012902, 0x03010104, 0x01000702, 0x0b040b08, 0x09070206, 0x050a0801, 
    0x1282060a, 0x09026008, 0x02070100, 0x08015201, 0x5e010807, 0x02140702, 0x0a050702, 0x040b5201, 0x5e0b0405, 0x0a14050a, 0x100a0b05, 0x020a200a, 
    0x0a020a02, 0x09000603, 0xb8040804, 0x1840c0ff, 0x04481c0a, 0x40080d04, 0x08481b0b, 0x06030900, 0x04080104, 0x03010a12, 0x3f333f00, 0x39171233, 
    0x112b2f01, 0x822b2f33, 0x39392409, 0x42712f2f, 0x058605dd, 0x1887c424, 0x0b872b10, 0xc0c01024, 0x03838710, 0x08c00822, 0x05830982, 0x0130312e, 
    0x5d005d5d, 0x01095d5d, 0x23010933, 0x25080284, 0x01660233, 0x4dfecd4d, 0xfecddc01, 0xcd8bfe8a, 0x4dfedc01, 0x024403cd, 0xfd7cfd01, 0xfd3d023f, 
    0x02c102c3, 0x07410084, 0xa83d0807, 0x08004505, 0x68409600, 0x06440634, 0x5c030654, 0x073b0107, 0x0902074b, 0x29071907, 0x05530307, 0x44053401, 
    0x00030205, 0x20051005, 0x050c0305, 0x010e0807, 0x050e0204, 0x0401042f, 0x16094506, 0x02100433, 0x0a020201, 0x40030609, 0x60005000, 0x003f0300, 
    0x21708201, 0x12450407, 0x12332705, 0x5d5d2f39, 0x3b4e3333, 0xc6392308, 0x1b45325d, 0x31322705, 0x5d5e5f30, 0x00835d5f, 0x015d0025, 0x83112311, 
    0x023337d8, 0x1cfebcc4, 0x017601cd, 0x4802cd74, 0x4802b8fd, 0x9dfdfd02, 0x55826302, 0x00004924, 0xc3828304, 0x00093208, 0x89264075, 0x08690108, 
    0x77085701, 0x08290208, 0x08490839, 0x14080403, 0x01080208, 0x03020352, 0x1408075e, 0x07030807, 0xc0ffb804, 0x48140fb3, 0x3e078200, 0x0e091d40, 
    0x00070448, 0x03040700, 0x3f012f0b, 0x03014f01, 0x5f040701, 0x08020305, 0x4e12015f, 0x012206e3, 0xe8565d2f, 0x068b4106, 0xc42b8724, 0x74443031, 
    0x01293f05, 0x35210135, 0x21011521, 0xc6fb8304, 0x17fd3203, 0xcefcc203, 0x048f6103, 0xfb8b9c1a, 0xf68200e2, 0xfe9a013d, 0x05bd0357, 0x000700cc, 
    0x021c402f, 0x05090707, 0x8f007ff2, 0x003f0200, 0x8202006f, 0x04002820, 0x050001f5, 0x821b00f5, 0x603f206f, 0x332009a6, 0x11236382, 0x82211521, 
    0x9a013003, 0x91fe2302, 0x57fe6f01, 0xf98b7507, 0x82008ba1, 0x00012600, 0x04ecff73, 0x2d57825a, 0x403f0003, 0x01008b1d, 0x3901007a, 0x52826900, 
    0x0310033f, 0x02850503, 0x66023601, 0x03027602, 0xffb80102, 0x0100b7f0, 0x00020101, 0x3f001900, 0x21d0823f, 0x58663338, 0x315d2d08, 0x33010530, 
    0xfca40301, 0x3503b2cf, 0x82075a66, 0xfe0e242e, 0x84310357, 0x40292eb7, 0x60f20717, 0x02020102, 0x00000409, 0x24628230, 0x0005f504, 0x25b28a01, 
    0x2f391233, 0xb182ed5d, 0xaf823520, 0x01210382, 0x20ad820e, 0x25b58291, 0x5f068b57, 0xb182f88b, 0x8500013d, 0x4604ba01, 0x06004505, 0x2f406300, 
    0x79010585, 0x02048904, 0x8c010405, 0x82290100, 0x007933b7, 0x03010003, 0x06001006, 0x06700610, 0x06040680, 0xbf830806, 0xc1828620, 0xc1820320, 
    0x000f4024, 0x22820103, 0x86821020, 0x01000023, 0x24f68204, 0x322f3333, 0x83cd855d, 0x1238227f, 0x21d68239, 0x04823311, 0x09303124, 0xd5832302, 
    0xb7feac35, 0x0198bafe, 0x7c01cb7a, 0x2303ba01, 0x8b03ddfc, 0x820075fc, 0xff012800, 0x0424fffb, 0x8284ffd1, 0xb40e3876, 0xbb000003, 0xed2f0001, 
    0x312f2f01, 0x21350730, 0xd6040515, 0x836060dc, 0x92013d27, 0x3a03b104, 0x0500b405, 0x0e401a00, 0x03840374, 0x01048002, 0x8c030104, 0x3f009300, 
    0xcd363182, 0x5d30315d, 0x33352501, 0xbe021517, 0xe3c5d4fe, 0x1de6b104, 0x3b8214ef, 0x00023b08, 0x04ecff80, 0x004e0488, 0x00410032, 0x8a3f40a5, 
    0x1e7a0124, 0x69021e8a, 0x893d793d, 0x3625033d, 0x13023635, 0x480c0920, 0x17161706, 0x2d091d02, 0x03093d09, 0x2d152d05, 0xeb820002, 0x30035108, 
    0x4f0c1b46, 0x02385f38, 0x43153838, 0xb8274726, 0x2d40f8ff, 0x270127c0, 0x00473f27, 0x39150115, 0x331b1b51, 0x1f260f2c, 0x262f0226, 0x26ff268f, 
    0x21262603, 0x33102c50, 0x51001250, 0x120c0707, 0x333f0016, 0x10ed2f33, 0x33ed3fed, 0x11715d2f, 0x83061753, 0x4938200c, 0x3324059f, 0x2f32ed33, 
    0x21060157, 0x00825d2b, 0x36322537, 0x010e1537, 0x022e2223, 0x030e2327, 0x35262223, 0x3f023e34, 0x0d4f5b01, 0x1516da08, 0x25161411, 0x3d023e32, 
    0x030e0701, 0x04161415, 0x0e1e0f4d, 0x33264322, 0x03182e49, 0x58441c06, 0xa09e4a72, 0x54a3804f, 0x54371bec, 0x3a513238, 0x0abc0625, 0x6b976437, 
    0xfd2ac9c8, 0x517a53da, 0x6f37be28, 0x6f593859, 0x08700304, 0x51371b08, 0x3b543436, 0x6b96ac20, 0x011f4e89, 0x5e433b04, 0x270f1b3a, 0x40113343, 
    0xbb2b4e6b, 0x502efeb1, 0x603f0651, 0x04593574, 0x5b300f01, 0x0064524c, 0xffb30002, 0x054204ec, 0x002000cc, 0x40610034, 0x8a027a42, 0x33440202, 
    0x33643354, 0x5b234b03, 0x03236b23, 0x3501053a, 0x1f05011c, 0x1f751f15, 0x00041f85, 0x01216047, 0x2b362121, 0x00461406, 0x02138013, 0x1a502613, 
    0x0013101e, 0x5030150d, 0x00160306, 0x3fed333f, 0x2504823f, 0xed5d2f01, 0xd2423232, 0x5d002106, 0x01290084, 0x22230210, 0x14232726, 0x053d6c0e, 
    0x1133112d, 0x06070614, 0x013e3307, 0x61123233, 0x04320f1a, 0x74bdcb42, 0x020230aa, 0xae010303, 0x01020201, 0x008201b4, 0x30044a08, 0xc4c375a9, 
    0x5f3f1eba, 0x496a4242, 0x69492828, 0x40603f41, 0xfe220221, 0x56e6fee4, 0x2e371a62, 0x2b090421, 0x0427483c, 0x1d59feed, 0x171a1639, 0xebfe5f69, 
    0xa170e1fe, 0x672d3167, 0x9e777ca9, 0x662e275f, 0x000100a3, 0x08fb8282, 0x4e043846, 0x9d002500, 0x16645240, 0x01106401, 0x1e891e79, 0x011a6402, 
    0x15541544, 0x5b114b02, 0x08750211, 0x0b020885, 0x1c0a0a47, 0x4f1b3f47, 0x9f1b8f1b, 0x051baf1b, 0x1bdf1bcf, 0x60031bff, 0x1b1b011b, 0x00471327, 
    0x2a084d82, 0x00011b70, 0x601b101b, 0x801b701b, 0x061bc01b, 0xc0ffb81b, 0x1e1b1c40, 0x181b1b48, 0x0e162150, 0x0b1f0550, 0x0b8f0b7f, 0x82400b03, 
    0x0b0b2914, 0x3f001005, 0x5d2b2f33, 0x20055742, 0x09186a2b, 0xed715d22, 0x260aef4b, 0x135d5d01, 0x4b023e34, 0x5f5506ce, 0x1e142105, 0x36200f82, 
    0x08062f58, 0x5682029d, 0x625fb48d, 0x0d466f9a, 0x768010c0, 0x1f477556, 0x5575471f, 0xbe118e6c, 0x9e724409, 0x77bf8964, 0xa31e0236, 0x323580d8, 
    0x0e447657, 0x6937695b, 0x9f64649b, 0x6d6a3a6e, 0x5e7c430c, 0xcd975639, 0x8a000200, 0x1904e6ff, 0x1f00cc05, 0x6b003300, 0x22444b40, 0x22642254, 
    0x5b324b03, 0x03326b32, 0x016a013a, 0x010a3502, 0x07150705, 0x07850775, 0x1a040a04, 0x8a047a04, 0x46130404, 0x1250002a, 0xa0129001, 0x12120212, 
    0x00472035, 0x1a060106, 0x2f001215, 0x10080b50, 0x42005025, 0x33210610, 0x09ac6eed, 0x33337122, 0x2109a450, 0xd2820e25, 0x1011022f, 0x17163221, 
    0x34263433, 0x33113526, 0x25df8211, 0x032e2317, 0xe8840135, 0x0808a95c, 0x5e03025e, 0xca79a231, 0x798801be, 0x010231a3, 0x0201b401, 0x01ac0102, 
    0xfd020304, 0x603d1de1, 0x496b4543, 0x6a482525, 0x3f604045, 0x5f69ae20, 0x18011601, 0x62563602, 0x2d322a05, 0xfba30109, 0x3c482713, 0x2404092b, 
    0x011a3a32, 0x68a0706c, 0xa8693031, 0x609d7478, 0xa3662e2a, 0x02000000, 0x08057f64, 0x004e0441, 0x002b0020, 0x64654090, 0x03640124, 0x59294901, 
    0x03296929, 0x24592449, 0x851d7502, 0x1c77021d, 0x78021c87, 0x020e880e, 0x0d8a0d7a, 0x54024402, 0x03026402, 0x1f1f4727, 0x0acf490b, 0x57ff0adf, 
    0x2d080561, 0x0a030a60, 0x00262d0a, 0xe0150047, 0x00150215, 0x05262650, 0x101a5021, 0xdf105005, 0x020aef0a, 0x0a010a80, 0x0016100a, 0x5d2f333f, 
    0x585b105d, 0x088e5806, 0x02425d20, 0x5d5d220b, 0x41028201, 0xf541060b, 0x42352007, 0x9d080614, 0x2201011d, 0x2107020e, 0x4201032e, 0x4a714c26, 
    0x324a5d37, 0x40109e0c, 0x7368986a, 0x4f437eb6, 0x8360af86, 0xfe3372b5, 0x56652e25, 0x4802033b, 0x624d3408, 0x8f55f701, 0x2c193967, 0x2d2d243d, 
    0x482f495b, 0x9c8dd58e, 0x543882d4, 0x1880d497, 0x4a1dd201, 0x7e5e627f, 0x0000204c, 0x8a000100, 0x4b040000, 0x1f00cc05, 0x00b95e00, 0x40f0ff0a, 
    0x480c0936, 0x0246011d, 0x0501053f, 0x1e020605, 0x022f111e, 0x026f023f, 0x028f027f, 0x14400205, 0x02004825, 0x02110201, 0x17212011, 0x3d820c50, 
    0x051d502b, 0x0015010f, 0xed333f3f, 0x05dd6232, 0x2f2f392c, 0x115d2b5d, 0x33112f33, 0xfb822f33, 0x3031322b, 0x11012b00, 0x35211123, 0x21d68721, 
    0xfa5a1517, 0x1d390805, 0x02152101, 0xfafeb444, 0x642d0601, 0x501d729f, 0x12154750, 0x13484f48, 0x1f406242, 0xac03eb01, 0xac0354fc, 0x8f65198e, 
    0x06032a5b, 0x03910408, 0x14030506, 0x0a4b5e36, 0x08be828e, 0x00020083, 0x0458fe8f, 0x004b041e, 0x00450031, 0x7a3e409c, 0x02308a30, 0x45013f66, 
    0x650c550c, 0x3a4b030c, 0x3a6b3a5b, 0x01213503, 0x1d151d05, 0x1d851d75, 0x1a170a04, 0x8a177a17, 0x462f0417, 0x0e502232, 0xa00e9001, 0x0e0e020e, 
    0x4606471a, 0xf0ffba05, 0xc0ff0500, 0x150f2840, 0x3c050548, 0x011ab047, 0x1ad01a00, 0x0f281a02, 0x1f225037, 0x0f504110, 0x50091515, 0x30062000, 
    0x06060206, 0x3f001b00, 0x82e08332, 0x200283fa, 0x05c37601, 0x35462b20, 0x0c074306, 0x22015d25, 0x6427022e, 0x3d2106ad, 0x09b85f01, 0x32330230, 
    0x34331716, 0x3337023e, 0x1115030e, 0x30660614, 0x027c080f, 0x63895a67, 0x11b80d3d, 0x5b395c71, 0x13022341, 0x486e533b, 0x2b5c9066, 0x6e985f2b, 
    0x032da771, 0x01050303, 0x020201ab, 0x3021d401, 0x4335654f, 0x1e1e4062, 0x3542613f, 0xfe315066, 0x62472658, 0x514b193c, 0x56784b22, 0x3a4c28c2, 
    0xca864223, 0x8dcc8387, 0x1961694a, 0x0328373e, 0x493c2b09, 0xe3c6fc27, 0x71cf03e5, 0x2d2c639e, 0x75719d63, 0x2b275e9c, 0x01009b60, 0x0000b900, 
    0x08063344, 0x27403f2f, 0x0e800e70, 0x140d0402, 0x840d740d, 0x4611040d, 0x05211212, 0x00461e02, 0x021f801f, 0x15111f1f, 0x0b055018, 0x00000010, 
    0xed333f3f, 0x059f573f, 0x39123222, 0x2106d750, 0xd8823313, 0x3e33072b, 0x1e323303, 0x23111502, 0x07246711, 0x23113608, 0x0306b5b9, 0x52401803, 
    0x82534069, 0x21b52f5a, 0x3b30503b, 0xb42c4d67, 0x7afecc05, 0x2f2e6532, 0x2c1d354c, 0xfd65905c, 0x50b7022f, 0x2d183d67, 0xfd517d55, 0x06fb418d, 
    0x00002608, 0xcc056504, 0x0d000900, 0x28404800, 0x04050707, 0x4a0b0504, 0x01010c0c, 0x05a04600, 0x0e050501, 0x0a300b0f, 0x058c4360, 0x08500728, 
    0x5004000f, 0xb14a1503, 0x5d2f2205, 0x059e7371, 0x32ed7129, 0xed2f322f, 0x822f3311, 0x303128ae, 0x21152125, 0x82112135, 0x35273a03, 0xe9021533, 
    0x2afc7c01, 0xc1fea601, 0xc8c8f301, 0x038e8e8e, 0xc0d28e1e, 0x247f85c0, 0x0357fe75, 0x087f8244, 0x1d001931, 0x2c404b00, 0x13851375, 0x1a030a02, 
    0x18180203, 0x4a1a150a, 0x46001d1d, 0x15011500, 0x0a1f1e15, 0x80011a30, 0x1b1a011a, 0x0f185017, 0x4a055010, 0x2f2005c5, 0x01208382, 0x01528482, 
    0x08795b06, 0x76500520, 0x35272806, 0x3233031e, 0x8735023e, 0x032d088d, 0x9c764744, 0x4c522956, 0x3c161841, 0x38284f48, 0xfe294861, 0xc84b0269, 
    0x976d1cc8, 0x0c072a5f, 0x058c090f, 0x1c070a0c, 0x03435f3d, 0x22a886c5, 0x41ec0001, 0x4c080627, 0x40af000b, 0x7607662c, 0x03078607, 0x09740964, 
    0x7b030984, 0x02018b01, 0x01590149, 0x49030169, 0x02085908, 0x007b006b, 0x4903008b, 0x02005900, 0xe8ffb80a, 0x110b2840, 0x080a0148, 0x09441009, 
    0x09020954, 0x0b9f0009, 0x0bbf0baf, 0x05af5903, 0x0b0b1031, 0x4603070d, 0x04010400, 0xb3c0ffb8, 0x8448251f, 0x1b162107, 0x40390784, 0x48110d11, 
    0x0a070204, 0x08010701, 0x0400050f, 0x3f001500, 0x393f3f32, 0x07a55839, 0xed5d2b3b, 0x2f331132, 0x335d5d38, 0x385d2f33, 0x31393933, 0x5d5d2b30, 
    0x5d5d005d, 0x59048201, 0x21080cc3, 0x8492fe92, 0xdb01b4b4, 0x0149fed3, 0x62f301ce, 0xcc056ffe, 0x0d0261fc, 0x97fd2ffe, 0x01000000, 0xe7828600, 
    0xcc055c2e, 0x33000900, 0x08081a40, 0x05040405, 0x24080942, 0x50070b0a, 0x411f8208, 0x112808ff, 0x2f390112, 0x2f32ed71, 0x2111f841, 0xf441e002, 
    0x01df2806, 0x8e8e8ed5, 0x828eb004, 0x205f825e, 0x083f8263, 0x4e046475, 0x8e003900, 0xff2a00b9, 0x0f09b3d0, 0xffb82048, 0x095940d0, 0x3922480d, 
    0x0d000048, 0x2fbf482e, 0x2fff2fcf, 0x702f6003, 0x2f1f022f, 0x2f3f2f2f, 0x5f2f4f03, 0x8f2f7f2f, 0x2f10042f, 0x2f302f20, 0x3b2f2f03, 0x00480c19, 
    0x020d100d, 0x0f010df0, 0x020d3f0d, 0x0ddf0dcf, 0x010d1002, 0x5006350d, 0x03282219, 0x0f13101f, 0x15000d2f, 0x32323f00, 0x6e173f3f, 0x5d230558, 
    0x61727171, 0x09820596, 0x12ed712c, 0x39ed2f39, 0x2b003031, 0x4f43212b, 0x2b0a830a, 0x031e3327, 0x033e3315, 0x17163233, 0x320f7443, 0x02111506, 
    0x2b1b0c13, 0x26342120, 0x0201a914, 0x83950102, 0x0d023304, 0x2e463324, 0x02135758, 0x48382b12, 0x34543d2f, 0x2583a817, 0x4d422308, 0x6a4fae02, 
    0x5d331b41, 0xa1fd5183, 0x4b225303, 0x05073043, 0x14383529, 0x1f364727, 0x492f6460, 0x9f431a32, 0x08278406, 0xfda8a833, 0x0100008d, 0x0000b300, 
    0x4e041904, 0x3d002500, 0x22702640, 0x04022280, 0x74211421, 0x04218421, 0x00004625, 0x460c1927, 0x0d800d00, 0x06190d02, 0x85ec8350, 0x3f3f22eb, 
    0x053a44ed, 0x99083944, 0x021e25da, 0x64031115, 0x83082f44, 0x01aa2ec4, 0x03020302, 0x6a554118, 0x57805342, 0x0b31442d, 0x2c23b987, 0x44143b39, 
    0x00200953, 0x02260082, 0xecff8200, 0xab824904, 0x000f4308, 0x40590023, 0x0122643d, 0x22562246, 0x011c6402, 0x1c561c46, 0x01186b02, 0x18591849, 
    0x01126b02, 0x12591249, 0xaf470002, 0x10000110, 0x10601010, 0x25101003, 0x0a00471a, 0x50150a01, 0x501f100d, 0x9e4e1605, 0x56ed2007, 0xb46a05ed, 
    0x084c540a, 0x4b121021, 0x7408130b, 0xb57e4349, 0x7db16d72, 0xf4e8fd44, 0x4d2bbdee, 0x6e41406a, 0x4f2f2d4f, 0x6f413969, 0x1e022d50, 0x458cd38e, 
    0x8fd38c44, 0x19011701, 0xe6feeafe, 0x2762a47e, 0x7ba46329, 0x2862a57e, 0x00a66227, 0xb3000200, 0x420457fe, 0x28005004, 0x65003c00, 0x3b644440, 
    0x563b4601, 0x2b6b023b, 0x592b4901, 0x2606022b, 0x26762616, 0x34042686, 0x083b0121, 0x89037901, 0x3bcb8203, 0x29012960, 0x1e333e29, 0x12004611, 
    0x12021280, 0x241e502e, 0x110f1810, 0x0a50381b, 0xed4bce83, 0x079e561a, 0x27022e25, 0x45031e23, 0x7b4206d6, 0x021e2109, 0x2b10dc6e, 0x965c2842, 
    0x5664376e, 0x01051743, 0x59080082, 0x020201b5, 0x0301af01, 0x19040303, 0x3e64503f, 0x285c966e, 0x613b18ba, 0x4d683b49, 0x6a48252d, 0x3b624944, 
    0x7b220219, 0x145596d0, 0x0232462c, 0x1d3a2e1f, 0x030559fe, 0x2a3b4a28, 0x34250309, 0x4c341a3c, 0x93501731, 0x9c647dce, 0x6125386b, 0x9d7387ac, 
    0x6e392a61, 0x008200a2, 0x00025b08, 0x0457fe8a, 0x004a041a, 0x00380024, 0x4b474066, 0x6b2d5b2d, 0x3144032d, 0x31643154, 0x011c3a03, 0x05010335, 
    0x75241524, 0x04248524, 0x201a200a, 0x208a207a, 0x25461204, 0x01135005, 0x13a01390, 0x3a131302, 0x2200472f, 0x50342201, 0x12161f19, 0x05502a1b, 
    0x3f001000, 0xff4ced32, 0x39122307, 0xe6475d2f, 0x3201230c, 0xcd47021e, 0x5d23200a, 0x2322056d, 0x905b030e, 0x09fc7a05, 0x32051264, 0x66421102, 
    0x02183d4f, 0x01050303, 0x020201af, 0x8201b501, 0x023b0800, 0x65513f19, 0xc3beca41, 0x4a281202, 0x61444169, 0x3c1c1d3d, 0x683b4560, 0x4a042d4e, 
    0x2f452e16, 0x23313919, 0x44280903, 0x36fb4362, 0x3a1ab701, 0x331c1e1a, 0x011a354e, 0x82150119, 0x1d4e0803, 0x9e77e0fd, 0x6933285e, 0x9f6a6ea1, 
    0x6327366a, 0x000100ab, 0x040000f2, 0x004e0415, 0x4046001f, 0x8806782b, 0x1a040206, 0x04021a14, 0x02191419, 0x16211f1f, 0x100a4609, 0x6f0a1f10, 
    0x8f0a7f0a, 0x160a040a, 0x101c5203, 0x15090f10, 0x93433f00, 0x7c332606, 0xed10182f, 0x42f18232, 0x012005d3, 0x4706c670, 0x272305cc, 0x44031e33, 
    0x3b08056a, 0x15041716, 0x543e672f, 0xb4315c86, 0x0612100c, 0x0e0f07ab, 0x1c05020a, 0x5274553e, 0x032a6c38, 0x440b0896, 0xfe589c75, 0x38bd0204, 
    0x18526774, 0x44433e18, 0x46643e1d, 0x00070a26, 0xa72ea782, 0x2404ecff, 0x38004b04, 0x58408500, 0x445d186c, 0x6c500805, 0x366a0117, 0x83317301, 
    0x31470231, 0x24023157, 0x1d2a0137, 0x1a030a01, 0x20050203, 0x28022015, 0x00272749, 0x1f151548, 0x0a490b3a, 0x00482f0a, 0x701f601f, 0x041f801f, 
    0x05152f1f, 0x2022502d, 0x02289028, 0x10222828, 0x0b055010, 0x0016050b, 0x24051561, 0x105d2f33, 0x068a59ed, 0xed2f3323, 0x4bdb8211, 0x5d200d96, 
    0x200ae142, 0x068b4737, 0xb95b3420, 0x4d362006, 0x032206b1, 0x7e592223, 0x038d0805, 0x703b2404, 0x975e69a3, 0x9f124d72, 0x624b350c, 0x48633a39, 
    0x79583329, 0x637e4047, 0x4fc9d43d, 0x0e496c8a, 0x432e07a2, 0x2bf52e54, 0x41416c4e, 0x01497189, 0x557a4c35, 0x673e1b2e, 0x41371f4c, 0x29110b22, 
    0x3d323041, 0x11131e2a, 0x4d644128, 0x3f1da693, 0x2d144563, 0x970c2138, 0x1b26392e, 0x462a1011, 0x0100006d, 0xf0ffbe00, 0x5405f903, 0x58001b00, 
    0x186a3640, 0x188a187a, 0x09281803, 0x0606480e, 0x051d1212, 0x901a4609, 0x08008201, 0x401a022a, 0x1a482512, 0x480e0b40, 0x1a011a00, 0x1617500c, 
    0x01500008, 0x01050303, 0x333f000f, 0xed102f33, 0x01ed3f32, 0x2b2b5d2f, 0x3c06a74b, 0x332f3912, 0x0030312f, 0x35135d2b, 0x11331333, 0x11211521, 
    0x32331614, 0x1537023e, 0x08e8820e, 0x11352632, 0x783aaabe, 0x50feb001, 0x55286155, 0x1618454f, 0x36665746, 0xac03a2a2, 0xfe1a018e, 0x74fd8ee6, 
    0x0a074c4f, 0x0689050c, 0x890a0e10, 0x009f0294, 0x3708af83, 0x04ecffb9, 0x003a041f, 0x40450025, 0x8f227f2c, 0x217b0222, 0x0a02218b, 0x2a211a21, 
    0x1c390321, 0x460e1901, 0x01270b0b, 0x80240046, 0x19240224, 0x161f5006, 0x000c1514, 0x3220a582, 0x20067d42, 0x219a82ed, 0x794233ed, 0x015d2205, 
    0x098c5911, 0x20084b4e, 0x2ea08323, 0x1135022e, 0x35176d01, 0x67403f55, 0x46b52749, 0x1a380913, 0x466a523e, 0x2754825a, 0x52fd3a04, 0x1b416a4f, 
    0x517d552d, 0xadfc7302, 0x4605cf46, 0x91230915, 0x83d10264, 0x004524b3, 0x82870400, 0x102308b3, 0x42409400, 0x49010456, 0x020e590e, 0x0f5b0f1b, 
    0x010f0902, 0x03550325, 0x16030602, 0x01280203, 0x59020168, 0x4b2005b3, 0x210bb359, 0xb359024b, 0x10703907, 0x10021080, 0x40c0ffb8, 0x480e0a1e, 
    0x02121010, 0x480e0b40, 0x0f020f02, 0x2805be59, 0x093a092a, 0x01000902, 0x08ae6015, 0x5906ec56, 0x5d201bc5, 0x3b05c559, 0x033e1703, 0x02330137, 
    0x4ffed5cb, 0x080c01ca, 0x06111412, 0x15141306, 0xc9140108, 0x4030e882, 0x3f443f16, 0x423f1515, 0xc202163f, 0x15000100, 0xb820d382, 0x3208d382, 
    0x4052012a, 0x841e7410, 0x1e46021e, 0x24021e56, 0x021e341e, 0xe0ffb81d, 0x18134a40, 0x011d9048, 0x1d751d65, 0x24031d85, 0x021d341d, 0x1d161d06, 
    0x82201c02, 0x1c9f3a18, 0x7b1c6b01, 0x031c8b1c, 0x1c2d1c1d, 0x0b031c3d, 0x1b7b011c, 0x1b021b8b, 0x2fd08220, 0x110d200e, 0x2a0e1a48, 0x030e3a0e, 
    0x0d010e0b, 0x1f204e83, 0x902c3582, 0x0d25010d, 0x0d750d35, 0x01040d85, 0x01294684, 0x3a012a01, 0x03017a01, 0x20238300, 0x08368270, 0x2500156f, 
    0x03003500, 0x01000603, 0x1052010e, 0x0f4b1016, 0x0f0f140e, 0x52010d0e, 0x4c1c161c, 0x07140d07, 0x5201010d, 0x4c1d231d, 0x07140107, 0x00071d01, 
    0x23295201, 0x002a4b29, 0x23002a14, 0x0f031607, 0x2a742a14, 0x2a032a84, 0x2a0f2c2a, 0x32010766, 0x07020107, 0x29161c1c, 0x0f03102a, 0x7516230f, 
    0x02168516, 0x00010d16, 0x3f00150e, 0x3c008233, 0x3f33115d, 0x39123317, 0x5d5f332f, 0x2f012f5d, 0x5d2f3311, 0x87391712, 0xc42b872b, 0x08b35910, 
    0x5b188721, 0x5f230e42, 0x875d2b5d, 0x20098202, 0x850c845d, 0x23212b04, 0x27012e03, 0x07062726, 0xc559010e, 0x15032806, 0x013e3736, 0x63331337, 
    0x34210557, 0x05c3593e, 0x088fcc26, 0x090b0914, 0x85080282, 0xcb940a14, 0x035db2b7, 0x0b080b0b, 0x0714090b, 0x0682c187, 0x0a0b0913, 0x030c0c08, 
    0xd701b065, 0x2520451b, 0x1f242525, 0x2dfe1f47, 0xa1fd3a04, 0x5c605518, 0x23292d1d, 0xa8011449, 0x471457fe, 0x1e2e2923, 0x19565f5a, 0x00005f02, 
    0x5e000100, 0x6d040000, 0x0b003a04, 0x7040b900, 0x76010447, 0x02078607, 0x01790139, 0x76030189, 0x08190108, 0x0a020859, 0x03070902, 0x060b0608, 
    0x04090201, 0x00050803, 0x09820a05, 0x04070236, 0x01090203, 0x02030852, 0x094b0803, 0x09091402, 0x52010002, 0x4b262682, 0x05140005, 0x25820600, 
    0x04040723, 0x08b58203, 0x700b1026, 0x030b800b, 0x050d0b0b, 0x0a070305, 0x08040104, 0x00030f05, 0x323f0015, 0x3917333f, 0x2f332f01, 0x5d2f3311, 
    0x145b0582, 0x22a3590f, 0x215d0128, 0x09230109, 0x02843301, 0xa4032408, 0xbdfebffe, 0xfe9f01c2, 0x2c01c773, 0xfec92a01, 0x01a40173, 0x0244febc, 
    0xfe0e022c, 0xfda5015b, 0x82d2fdf4, 0xfe4224f7, 0x82890457, 0x1f8108f7, 0x5240af00, 0x120f181e, 0x75126548, 0x03128512, 0x1d591d49, 0x0d200302, 
    0x032d4811, 0x2b02033d, 0x02023b02, 0x490c4800, 0x00850075, 0x66002602, 0x106a0200, 0x108a107a, 0x59104903, 0x10000210, 0x79186918, 0x03188918, 
    0x0c091018, 0x081f1848, 0x1f1e1108, 0xffb81f10, 0x110ab7c0, 0x211f1f48, 0xffb81112, 0x110a40f0, 0x480f0b40, 0x01188211, 0xe0ffb818, 0x100d0d40, 
    0x10101848, 0x0c0f111e, 0x05d84d50, 0x2f39332c, 0x015d2b33, 0x33382b2f, 0x05833311, 0x2f39122a, 0x5d2b3912, 0x5d333311, 0x31270082, 0x5d2b0030, 
    0x82012b5d, 0x21580803, 0x2223030e, 0x1e352726, 0x36323301, 0x3301013f, 0x17031e01, 0x1337033e, 0x25c10233, 0x4e786250, 0x13203a22, 0x8b4f1130, 
    0x2afe1230, 0x0b0801c0, 0x02171e20, 0x1f1e1703, 0x62befc0c, 0x043b6f9d, 0x03038707, 0x04318176, 0x1b7efd2f, 0x093e4d4f, 0x4f4b3d0b, 0x0081021d, 
    0x44080082, 0x00930001, 0x042c0400, 0x0009003a, 0x06374058, 0x26071607, 0x04075607, 0x02520107, 0x064b0201, 0x07061407, 0x06600602, 0x08060301, 
    0x03030608, 0xaf019f0b, 0x0301bf01, 0x01010100, 0x04500306, 0x5007010f, 0x062c4f00, 0x2f013224, 0xdf595d5d, 0x415d2005, 0x872005c6, 0x2105de59, 
    0xd9593533, 0x15290806, 0xfda90293, 0xfd4c037f, 0x89cf0256, 0x898b2603, 0x008bdafc, 0xe3000100, 0x250457fe, 0x3100cc05, 0x12407500, 0x0f860f76, 
    0x06d07a02, 0x0918022a, 0xb814480c, 0x3740e0ff, 0x35080882, 0x01318018, 0x20333131, 0x2505f12c, 0x010c3f05, 0x7f110c0c, 0x05000105, 0x0b250501, 
    0x4f0c0ff5, 0x030c6f0c, 0x0caf0c8f, 0x300c0c02, 0x0018f519, 0x1b00f530, 0x55533f00, 0x715d2305, 0x9f8339ed, 0x2f333325, 0x4839125d, 0x5d3505a3, 
    0x00303133, 0x5d5d2b2b, 0x022e2201, 0x2e341135, 0x3e352702, 0x31088203, 0x2133023e, 0x0e222315, 0x14111502, 0x1507020e, 0x0882031e, 0x3b165f08, 
    0x1c031501, 0x2b4e6c41, 0x33634e2f, 0x2f4e6333, 0x416c4e2b, 0x2dd50901, 0x29132a41, 0x2b295342, 0x50284153, 0x57fed55b, 0x446f502c, 0x573f5f01, 
    0x89021a36, 0x56371a02, 0x4660013e, 0x8b2a4f70, 0x364a2e15, 0x5c39a6fe, 0x020a2c45, 0x5d442d0a, 0x6aa5fe3a, 0x01008b59, 0x57fe1302, 0xff82b902, 
    0x17000329, 0xab030a40, 0x82040000, 0x3fbb83d6, 0x0112113f, 0x31ed2f39, 0x33110130, 0xa6130211, 0x750757fe, 0x00008bf8, 0xa7000100, 0xe90357fe, 
    0x313b3382, 0x0d407300, 0x22862276, 0x79296902, 0x03298929, 0xe0ffb81c, 0x0d093d40, 0x82182f48, 0x300b3404, 0x25250125, 0x11f12c20, 0x19330505, 
    0x007f004f, 0x8303008f, 0x260b363f, 0x2f250ff5, 0x6f254f25, 0x258f0425, 0x250225af, 0xf5180125, 0x098b5a19, 0x2f391222, 0x82083441, 0xed33250b, 
    0x5d2f3232, 0x2f054a4e, 0x35135d5d, 0x35363233, 0x023e3411, 0x032e3537, 0x2e310882, 0x35012b02, 0x021e3221, 0x1e141115, 0x0e151702, 0x35088203, 
    0xa723020e, 0x28515bd5, 0x292b5241, 0x14294252, 0xd52d412a, 0x42410901, 0xfe2f080f, 0x6a598b57, 0x5d3a5b01, 0x020a2d44, 0x5c452c0a, 0x365a0139, 
    0x8b152e4a, 0x46704f2a, 0x563ea0fe, 0x89021a37, 0x57361a02, 0x44a1fe3f, 0x822c506f, 0x08ff82fe, 0x29026c20, 0x27036004, 0x5d002000, 0x04161a40, 
    0x04360426, 0x04960466, 0x100604a6, 0x00140930, 0x0584114c, 0xffb81e25, 0x832540c0, 0x841f200f, 0x0d32080f, 0x011d1022, 0x0dad181d, 0x1c174000, 
    0x09400048, 0x1d00480c, 0x130fad0a, 0x2f001301, 0xdd33ed5d, 0xed322b2b, 0x105d2f01, 0x2b3031ce, 0x2b2b2b00, 0xd382015d, 0x031e1722, 0xde48ee82, 
    0x27440806, 0x0e222326, 0x3e350702, 0x29730101, 0x254b4d4f, 0x33333215, 0x347b4517, 0x443d3c1f, 0x49914528, 0x41265881, 0x321d383c, 0x0d270384, 
    0x070d1a14, 0x32080e10, 0x1f16952a, 0x1a2c0813, 0x20170c2d, 0x2e268f15, 0x0233c383, 0xf6fe0302, 0x3a04c902, 0x07000300, 0x15402c00, 0x82980402, 
    0x07103409, 0x08070702, 0x03000009, 0x0f079d06, 0x0e01b803, 0x183f3f00, 0x080fd24d, 0x2313336a, 0x35231513, 0x18941b02, 0x02c2c6c4, 0x0549fcad, 
    0x00c9c944, 0x85000100, 0x4604c3ff, 0x29006305, 0x60409300, 0x10881068, 0x54284402, 0x264a0228, 0x1b02265a, 0x0d18490c, 0x2006130d, 0x06212147, 
    0x10050046, 0x05050205, 0x0046272b, 0xe0131013, 0x0413f013, 0x18502413, 0x217f211f, 0x2103218f, 0x0b181b21, 0x0105200e, 0x602e2683, 0x80057005, 
    0x0605c005, 0x50000505, 0x0182180e, 0x190f0c2f, 0x000c1901, 0x125d2f2f, 0x2f2f3939, 0x05155b10, 0x4a113321, 0xff6f0524, 0x06314b08, 0x32ed3329, 
    0x5d003031, 0x70015d5d, 0x072006e2, 0xbd08bc82, 0x3435032e, 0x3537023e, 0x031e1533, 0x012e0717, 0x15062223, 0x7b021614, 0x2f485d38, 0x3a09b609, 
    0x805a8c63, 0x366da46e, 0x68a3703a, 0x61855680, 0x11b90d3d, 0xa19c7a83, 0x1c0d01a8, 0x0c365136, 0x3e5c743e, 0x08c3c308, 0x6eb88953, 0x538abf76, 
    0x07b8b809, 0x3f6f5637, 0xc96c5b0e, 0x00c9c6bd, 0x00380001, 0x05930400, 0x0036005a, 0x0362409c, 0x480f0c18, 0x1b011406, 0x2d29226f, 0x224f106f, 
    0x7f02225f, 0x020c8f0c, 0x0c012a0f, 0x2a22222a, 0x0006030c, 0x0136006f, 0x32383636, 0x0f0f066e, 0x24174006, 0x10060048, 0x2c060206, 0x1f29730e, 
    0x0f3f010f, 0x0f9f0f6f, 0x0fdf0fcf, 0x20820fef, 0x7325322f, 0x16222216, 0x73320707, 0x06363606, 0x05314c18, 0x333f3224, 0xd94f102f, 0x26f68205, 
    0x5d2f7c01, 0x8418332b, 0x2f7d2411, 0x45ed185d, 0x5d210620, 0x671c825d, 0x2b2d05fc, 0x23030e25, 0x033e3521, 0x3523013d, 0x08fb5633, 0x020e3224, 
    0x16410607, 0x011d2605, 0x15211521, 0x09108214, 0x36322116, 0x09930437, 0x3a513620, 0x482b8ffc, 0xbaba1d33, 0x6c9f6833, 0x48657e4a, 0x180e0112, 
    0x3227111f, 0x7a4e7516, 0xfe980178, 0x3c240f68, 0x3b58022c, 0x2bf00b39, 0x9a2b4456, 0x66463016, 0xdc8e8d4b, 0x3766935c, 0x39563a1d, 0x050a0806, 
    0x403f100c, 0x8ed87d73, 0x4d603b8b, 0x3535173c, 0x9e000200, 0x2f04e100, 0x23007304, 0xea003700, 0x22499d40, 0x2d022259, 0x02223d22, 0x1d591d49, 
    0x3d1d2d02, 0x1949021d, 0x2d021959, 0x02193d19, 0x14561446, 0x32142202, 0x10460214, 0x22021056, 0x02103210, 0x0b560b46, 0x320b2202, 0x0746020b, 
    0x22020756, 0x02073207, 0x02590249, 0x3d022d02, 0x21030202, 0x180c1e06, 0x1815150f, 0x0004211e, 0x1216160e, 0x012e6faa, 0x2e012e10, 0x0439002e, 
    0xaa242020, 0x00100000, 0x00030080, 0x030f060c, 0x1e182115, 0x0603211e, 0x171b0904, 0xb0291f1f, 0x1b601b40, 0x011b3f02, 0x05050d1b, 0x0009b033, 
    0x2f33ed2f, 0x5d5d2f33, 0x11250683, 0x11391712, 0x21018533, 0x12862f01, 0x1c833920, 0x332f3223, 0x251b8911, 0x5d5d3031, 0x00825d00, 0x1b610120, 
    0x08098505, 0x36341324, 0x17372737, 0x3233013e, 0x17371716, 0x15011e07, 0x17070614, 0x010e2707, 0x27262223, 0x2e372707, 0x895a3701, 0xb650080e, 
    0x68642529, 0x497f3663, 0x61367e47, 0x2b256068, 0x6664262c, 0x477e3665, 0x69348048, 0x29256666, 0x664c2d9a, 0x4d66393a, 0x664d2c2c, 0x4c663a39, 
    0x47ac022d, 0x6764367f, 0x2a2b2765, 0x60696126, 0x47477f36, 0x69643580, 0x2a292565, 0x66696926, 0x25824a82, 0x822c2c21, 0x853a2035, 0x82002035, 
    0x01560800, 0x00003400, 0x45059804, 0xb3001600, 0x155d6f40, 0x01154b01, 0x15291519, 0x52031539, 0x40030113, 0x13140113, 0x13341324, 0x40000003, 
    0x03005000, 0x114f110f, 0x0c03115f, 0x06060104, 0x0b100816, 0x1509120b, 0x12080e16, 0x2f130e09, 0x14120112, 0x5c080004, 0x95700d11, 0x10043507, 
    0x09090109, 0x0b071817, 0x0c040c60, 0x10600f03, 0x0c100014, 0x08350182, 0x08031215, 0x3f3f0012, 0x39391233, 0x33112f2f, 0x32ed1033, 0x21048411, 
    0x78620112, 0x32ed3205, 0x5dc43932, 0x18012b32, 0x32e44d10, 0x2f391211, 0x24048433, 0x5e5f3031, 0x2100825d, 0x00825d5f, 0x15210122, 0xdb590184, 
    0x21373805, 0x33012135, 0x02330109, 0xfe4101fc, 0xfe7f0181, 0x83feb281, 0x82027d01, 0x403f080b, 0x01c765fe, 0xc76d0169, 0x898ea702, 0x0100ff90, 
    0x8e899000, 0x97fd9e02, 0x00006902, 0x13020200, 0xb90239fe, 0x0300ae05, 0x25000700, 0x07031140, 0x040400ab, 0x00050908, 0x04010005, 0x8200011b, 
    0x20aa85ab, 0x229f8212, 0x4732ed33, 0x03200537, 0x2d053b47, 0xa402a6a6, 0xf6fc0a03, 0x0b0395fb, 0x4f83f5fc, 0x9f00c508, 0x2c0454ff, 0x4d00cc05, 
    0x05016100, 0x10737340, 0x69021083, 0x60750156, 0x43026085, 0x025f535f, 0x5b535b43, 0x535a4302, 0x835a735a, 0x3e43045a, 0x6a023e53, 0x8a157a15, 
    0x142a0315, 0x145a144a, 0x4a512a03, 0x6a515a51, 0x502a0451, 0x0d185001, 0x482a4811, 0x7c396c01, 0x03398c39, 0x0501392a, 0x021f151f, 0x241a240a, 
    0x154d0502, 0x1d5d024d, 0x41495822, 0x0e4e5346, 0x49064b49, 0x22493705, 0xc0ffb84b, 0x19124040, 0x054b4148, 0x4b052222, 0x182c0441, 0x104e0049, 
    0x4e4e024e, 0x00492d63, 0x532c012c, 0x3c5d4613, 0x8646761d, 0x466a0246, 0x001d4601, 0x20275132, 0x022d802d, 0x0b272d2d, 0x06060051, 0x3f25c982, 
    0xed102f32, 0x07a9502f, 0x115d5d24, 0x02823333, 0x23088445, 0x2f391711, 0x2b220082, 0x0183ed10, 0x39391227, 0x3911ed10, 0x05904539, 0x82079d4c, 
    0x21028307, 0x306a3201, 0x50062007, 0x152606b0, 0x07020e14, 0x0683031e, 0x9d5a2320, 0x33032205, 0x058d5d32, 0xc1452720, 0x26068306, 0x2e340136, 
    0x820e2702, 0x08408227, 0x02033e8e, 0x6c8a4f78, 0x08a10f49, 0x2e55432e, 0x5332817d, 0x8b443b6d, 0x371c4670, 0x4f313652, 0x703a1e37, 0x9a5d6ba4, 
    0xa1134f75, 0x634e370c, 0x4d663a39, 0x7b5f392c, 0x68834141, 0x543b2041, 0x394b2a35, 0xe101d321, 0x3d715835, 0x1f3c593a, 0x3c6c5231, 0x27445d36, 
    0x3f1ecc05, 0x2d144562, 0x5911253d, 0x2e402d47, 0x2e100e20, 0x2d4c6a49, 0x0d374957, 0x51403315, 0x53754933, 0x68401b2c, 0x47371f4d, 0x2d151029, 
    0x49362f44, 0x0f102333, 0x5a082482, 0x47532d49, 0x2e0e0f35, 0x8b305040, 0x30cbfc9b, 0x0e233345, 0x45342103, 0x30422e27, 0x18010f22, 0x0000462f, 
    0x044f0102, 0x057c03c3, 0x0003007b, 0x40310007, 0x0085031f, 0x10850700, 0x05040104, 0x0f049001, 0x5f003f00, 0xbf00af00, 0x40000500, 0x00481e16, 
    0x5d2b2f00, 0x4432ed32, 0xed27056b, 0x35013031, 0x82211533, 0xd9022803, 0xa5d3fda3, 0x82b8c304, 0x82002000, 0x038e0800, 0x26001f00, 0xcc05ad04, 
    0x3d002900, 0x1c015100, 0x507b7740, 0x7402508b, 0x024a844a, 0x4f864f76, 0x864b7602, 0x4674024b, 0x7b024684, 0x02408b40, 0x45894579, 0x89417902, 
    0x50030241, 0x03025013, 0x024a134a, 0x121c120c, 0x0303122c, 0x23181318, 0x00660318, 0x00860076, 0x15c40003, 0x1fc6200a, 0x1f701f0b, 0x0f021f80, 
    0x021f1f1f, 0x153f152f, 0x10401502, 0x1f154814, 0x3e341f15, 0x48110d10, 0x2a10c33e, 0x532a2a01, 0xf0ffb848, 0x10825740, 0x34c3482e, 0x0a400a30, 
    0x0ac00ab0, 0x30050ad0, 0x25080884, 0x050a0a03, 0xc92510c9, 0x1a20201a, 0x108f107f, 0x10ff10ef, 0xb01a5004, 0x031ac01a, 0x1a101a00, 0x1a801a70, 
    0x08821004, 0x43694d3a, 0x43894379, 0x39c84303, 0x764d6600, 0x034d864d, 0xd02fc84d, 0x5ded3f00, 0x122c0282, 0x2f2f3939, 0x115d715d, 0xed102f33, 
    0x23051548, 0x2bed2f01, 0x5d200e82, 0x1c830582, 0x5d5d2b22, 0x10241d82, 0xed1032ed, 0x45062d63, 0x00200581, 0x201ce15e, 0x06057917, 0x18140521, 
    0x08211e4b, 0x1c8e01a7, 0x29385438, 0x0c212f3f, 0x4a341373, 0x855a4363, 0x562b2b57, 0x63435782, 0x72103148, 0x3c2e200a, 0x35533a27, 0x5b1f0319, 
    0x7879d59e, 0x5c5c9fd4, 0x7979d49e, 0x5c5b9ed5, 0x66b2864d, 0x4d84b265, 0x65b2844d, 0x4d86b266, 0x7848fb02, 0x2d1b3056, 0x2b231c38, 0x40263f51, 
    0x625e9e72, 0x243b6f9c, 0x21274b3b, 0x1726321a, 0x4a76532e, 0xb2effebb, 0x01b25555, 0x01bbbb11, 0x5656b111, 0xbbeffeb1, 0x4798eea7, 0xa7ee9847, 
    0x4698efa8, 0x00ef9846, 0x02ce0002, 0x05fd038b, 0x002a0098, 0xb97a003b, 0xe8ff0300, 0x05db4cb3, 0x3740d82d, 0x22480d09, 0x48110928, 0x820d1829, 
    0x82282004, 0x1e1e3517, 0x0624e217, 0x35013500, 0x0d3d0035, 0x2b0e0ee3, 0x100000e3, 0x24084682, 0x28e4301a, 0x0505e436, 0x28212413, 0xb41601b8, 
    0xe40a0d0d, 0x1501b813, 0x33ed3f00, 0x33333f2f, 0xed2f3912, 0x08944210, 0x0e821120, 0x33335d29, 0x312f32ed, 0x832b0030, 0x34132100, 0x18058264, 
    0x24095149, 0x14111516, 0x05de4a16, 0x22230126, 0x0e232726, 0xeb460683, 0x3d690807, 0x030e0701, 0x82633ace, 0x565ebf47, 0x950b5c54, 0x79543008, 
    0x1fa6994f, 0x091c0c2b, 0x52173817, 0x2b04034b, 0x89796692, 0x39261293, 0x415c3b27, 0x5a329a22, 0x66032844, 0x18385c45, 0x5d2b0401, 0x0a4d4459, 
    0x233e522f, 0xddfe8586, 0x03053c3a, 0x5507065e, 0x72594d4b, 0x26321c7d, 0x51442d16, 0x01043325, 0x00351e0d, 0x08dc8200, 0x8d007f45, 0xac036004, 
    0x11000800, 0x2b405000, 0x0308eb00, 0x06ec04eb, 0x130101eb, 0x11eb090a, 0xec0deb0c, 0x0a00eb0f, 0x020b0a01, 0x090c010a, 0x0f020100, 0x03060603, 
    0x00ee00ef, 0x3d39e43f, 0x1133172f, 0x82113233, 0x18012c04, 0xfded5d2f, 0x11edd4ed, 0x842f3912, 0x30312b08, 0x01350125, 0x01091533, 0x08872115, 
    0xfeac0326, 0xb25201ae, 0x54370482, 0xb0fe6ffd, 0xfeb15001, 0x8d5101b1, 0x013f6d01, 0x8cfe1f73, 0x8a1d91fe, 0x00003b0a, 0x00740001, 0x025704b4, 
    0x000500f2, 0x00124021, 0x000705aa, 0x02021002, 0x1a823f02, 0x03ad022e, 0xfd3f00b3, 0x2f015dc6, 0xedde105d, 0x11306e82, 0x11213521, 0xaefcc603, 
    0x01b4e303, 0xc2fd92ac, 0x0021e282, 0x080b4404, 0x00137208, 0x00350027, 0x40ec003e, 0x8b267b29, 0x20740226, 0x76022084, 0x02258625, 0x21862176, 
    0x841c7402, 0x167b021c, 0x7902168b, 0x021b891b, 0x17891779, 0xffb82f02, 0x0b1540d8, 0x28334811, 0x03480c09, 0x02261326, 0x20132003, 0x29293402, 
    0x40f0ffb8, 0x3b312926, 0x282cc42b, 0x35351035, 0x7036c431, 0x02368036, 0x362c362c, 0x0d10140a, 0xc3144811, 0x22a68210, 0x831e4000, 0x8232202a, 
    0x1e2d0810, 0x2c280ac3, 0x3bc82a34, 0x002dc83a, 0x022d102d, 0x2d2d3b2c, 0x23032c3b, 0x19791969, 0x19031989, 0x66000fc8, 0x86237623, 0xc8230323, 
    0x08df4305, 0x2f391723, 0x25e2822f, 0x32ed10ed, 0xda433311, 0x825d200e, 0x382f2214, 0x23058233, 0x11383911, 0x25058955, 0x5d5d2b2b, 0xab5d5d01, 
    0x745d2005, 0x4e181086, 0x052e12dc, 0x23112303, 0x16322111, 0x07061415, 0xe5730313, 0x04362206, 0x20ac43ad, 0xc7defe34, 0x33017fa1, 0x5568978e, 
    0x515f9fdd, 0x5450b6aa, 0x9d43f902, 0xfa3c0822, 0xb0fe5001, 0x6f7e3f03, 0xfe137b66, 0x455002a2, 0x55d3fe48, 0xffffff00, 0x04f205fb, 0x125206d1, 
    0x00420007, 0x00ce0600, 0x01020000, 0x03200347, 0x005a0585, 0x00270013, 0x1100b94a, 0x2a05c743, 0xe8ffb80d, 0x0c092640, 0x82180748, 0x83032004, 
    0xac143f04, 0xac1e0000, 0x0a100a00, 0x0a030a80, 0x0500af23, 0x19050501, 0x00040faf, 0x2f33ed3f, 0x3746ed5d, 0x2b002108, 0xf85b0082, 0x06d16308, 
    0x080f155b, 0x2d85033a, 0x3b3b694e, 0x2e2e4e68, 0x3b3b684e, 0x6d2d4e69, 0x2641301b, 0x1c304125, 0x2541301c, 0x1b304126, 0x683b3d04, 0x4d2d2d4d, 
    0x683c3b68, 0x4d2c2c4d, 0x41263c68, 0x311c1c31, 0x31242583, 0x41311d1d, 0x0032bf83, 0x04000074, 0x00c30457, 0x000f000b, 0x0f37406a, 0x5218040c, 
    0x06200988, 0x3f08df82, 0x0202030a, 0xad0d1110, 0x0e020c40, 0x0e050704, 0x073f072f, 0x8f03078f, 0xdf079f07, 0x0407ef07, 0xad040007, 0xffb80509, 
    0x1613b3c0, 0x2f000548, 0x32ed332b, 0x2b715dc6, 0x4d101800, 0xed1a2fe6, 0x08a45218, 0x2b211682, 0x25148301, 0x31323311, 0xfd490130, 0x33112905, 
    0x01152111, 0x02152135, 0x08aa5218, 0x1dfc5508, 0xa802e303, 0x8b0175fe, 0xfe8a0191, 0x58fd9176, 0x01009191, 0x33023801, 0x8d059403, 0x53002000, 
    0x6a025ab5, 0xb8150202, 0x2840d8ff, 0x1f480e09, 0x6fe1171f, 0x02088f08, 0x22000808, 0x0f0fe00e, 0x001e1e00, 0x02001000, 0x0b0e0e00, 0x01de14e4, 
    0xdd00e41e, 0x2705bf61, 0x2f012f33, 0x112f335d, 0x2006864e, 0x0608455d, 0x015d0126, 0x35053e27, 0x0a564e18, 0x14151622, 0x3e08ed82, 0x3a011721, 
    0x64581b02, 0x47345267, 0x0858444a, 0x4c2e0685, 0x9183436c, 0x63675536, 0xcb011653, 0x67330202, 0x47505f3d, 0x3e325249, 0x0844494b, 0x25405733, 
    0x623d707f, 0x4e494952, 0x82006b2f, 0x01012600, 0x03270232, 0x08b78299, 0x7b00352e, 0xff2a00b9, 0x092040e8, 0x2802480f, 0x30480c09, 0xe122162d, 
    0x2d082323, 0x164f1ce1, 0x1602165f, 0x081c161c, 0xb80fe100, 0x2240c0ff, 0x0f271f82, 0xe109370f, 0x82100800, 0x153033d8, 0x0c1616e4, 0x1f222228, 
    0x0cde28e4, 0x090903e4, 0x5d4edf03, 0x5d4f1805, 0x12ed240c, 0x822b2f39, 0x2f392504, 0xed105d2f, 0x3127e586, 0x2b2b0030, 0x49061401, 0x012106ad, 
    0x4b4f1833, 0x0660081c, 0x031e1507, 0x8e9b9903, 0x24497457, 0x58098806, 0x25534d55, 0x3d1d4338, 0x323d1d39, 0x44474a20, 0x07870654, 0x3a674f32, 
    0x23466845, 0x4b345a56, 0x1b031630, 0x40278074, 0x430d2b51, 0x2d4c4845, 0x6d091d36, 0x28351f0d, 0x4146453c, 0x39563a0c, 0x4f3b211c, 0x146e4b2e, 
    0x36250502, 0x01010044, 0x2c0cf36b, 0x028b027b, 0x01038002, 0x8c020003, 0x0bf36b05, 0x37355208, 0x01051533, 0xfec5e392, 0x14b104d4, 0x00e61def, 
    0x00010000, 0x0477fe90, 0x003a043c, 0x40680027, 0x0f100b18, 0x07394812, 0x05462201, 0x1f201f10, 0xc01f6002, 0x031fd01f, 0xc0ffb81f, 0x53242a40, 
    0x291f1f48, 0x46110d15, 0x53274012, 0x1c401248, 0x39048223, 0x00481512, 0x20120112, 0x1b120f13, 0x050c501a, 0x15001609, 0x333f3f00, 0x0482ed33, 
    0x5d2f012e, 0xed2b2b2b, 0x39123232, 0x715d2b2f, 0x24058e68, 0x032e212b, 0x05014735, 0x1e232722, 0x5a05f07a, 0x41080f48, 0x03019403, 0x35040303, 
    0x805272a7, 0x01030420, 0x3f1bb6b6, 0x70434965, 0x01b52e52, 0x06010202, 0x133f3e31, 0x3a406e6d, 0xfe1b3f20, 0xfdc3058b, 0x5574457c, 0x7e5b342f, 
    0xfc69024b, 0x434c22af, 0xdb830731, 0xfe7f3408, 0x053804bc, 0x00130045, 0x05184041, 0x0106009a, 0x020c0606, 0x9a011313, 0x00150202, 0x020c100c, 
    0xb813040c, 0x12b71001, 0x12010707, 0x00010603, 0x823f332f, 0x05dc47aa, 0xed230882, 0x82112f32, 0xed5d2106, 0x08055c43, 0x2311233f, 0x022e2211, 
    0x023e3435, 0x03152133, 0x85c584b7, 0x35608550, 0x578a5f32, 0xcb044702, 0x0f06f1f9, 0xbe03f1f9, 0x5886582d, 0x325d8554, 0xffff007a, 0xa401f001, 
    0xcf02db02, 0xd3000612, 0x24938300, 0x0144fe77, 0x080982e3, 0x52001b24, 0xff1a00b9, 0x0f2f40e8, 0x1a444813, 0x03021a54, 0x48130d18, 0x17191918, 
    0x0c094016, 0x08161648, 0x27828710, 0x08010829, 0x40199213, 0x8248100d, 0x8d0b3219, 0x3f009505, 0x2f392fed, 0x2f01ed2b, 0xed2f335d, 0x290a8211, 
    0x33113333, 0x2b003031, 0xe1442b5d, 0x27262305, 0x3f4c1635, 0x26580805, 0x07012a23, 0x1e073337, 0x1ee30101, 0x144b6841, 0x2432192d, 0x0f223929, 
    0x1d0e483d, 0x276b410e, 0xfefe5e5e, 0x1a31452a, 0x06620301, 0x1320160d, 0xb6022a28, 0x00530364, 0x021d0101, 0x059b0333, 0x00120082, 0x3f22403f, 
    0x11110111, 0x0802e010, 0x0e010108, 0x02100200, 0x132a0082, 0x09e40814, 0xdc0e0309, 0x0b440110, 0x83332007, 0x01122290, 0x22998239, 0x18332f33, 
    0x20078d54, 0x8d541801, 0x3322080c, 0x01230115, 0x4a370d09, 0x57302b56, 0x79113849, 0x6b3302ec, 0x2a1a6202, 0x126d111e, 0xfd213223, 0xf5826b1c, 
    0x00024908, 0x038b02e2, 0x009805ea, 0x00210013, 0x7a304052, 0x02198a19, 0x158a157a, 0x85217502, 0x1c750221, 0x00021c85, 0xa01490e3, 0x0314c014, 
    0x1a231414, 0x010a6fe3, 0x0a100a00, 0x0a030a50, 0xb80fe417, 0x1fb21501, 0x01b805e4, 0x21080862, 0xc941ed71, 0x05985006, 0x0a025d18, 0x32335108, 
    0x3407021e, 0x06222326, 0x021e1415, 0x03363233, 0x926231ea, 0x61905d62, 0x92613033, 0x5d936762, 0x7278952c, 0x3d227d74, 0x7f753355, 0x8f571204, 
    0x68393968, 0x8f54578f, 0x683a3b68, 0x8697558f, 0x6d4c9588, 0x00852045, 0x6b000200, 0x4c048d00, 0x08085f49, 0xeb032a27, 0x0601ec08, 0xeb0005eb, 
    0x0a130101, 0xec10eb0c, 0x0eeb0f0a, 0x110aeb09, 0x0f071008, 0x08070009, 0x0303030c, 0x145e4906, 0xedd4ed24, 0x5e49fd10, 0x2b098405, 0x23253031, 
    0x35010935, 0x01150133, 0x022c0887, 0x5201b2fa, 0x01b0b0fe, 0xb4d3fc52, 0xb22e0983, 0x1d8d4f01, 0x74016f01, 0x3f8dfe1f, 0x0a8893fe, 0xff003e08, 
    0x001b00ff, 0x05cd0400, 0x00271045, 0x00f6fed4, 0x00261000, 0x110000d1, 0x01d70007, 0x00b6fd98, 0x03174028, 0x03181802, 0x01195002, 0x19011940, 
    0x01146001, 0x00200014, 0x5d110001, 0x24028435, 0x0035355d, 0x8303823f, 0x8211204b, 0x86b0204b, 0x85ec204b, 0x83f0204b, 0x01d52b4b, 0x00b4fdac, 
    0x020d4018, 0x418f1817, 0x00203c82, 0x0b203b83, 0xcd223b82, 0x87825105, 0x21ffd622, 0x19203b85, 0x20258789, 0x02031240, 0x27878335, 0x3a40013a, 
    0x40003a01, 0x7f888287, 0x02004008, 0xdffe9900, 0x39046c04, 0x2b002700, 0x36407700, 0x06760666, 0x66030686, 0x86047604, 0x1b450304, 0x69021b55, 
    0x89007900, 0x090a0300, 0x2b2b9828, 0x00981e00, 0x801d701d, 0x1d1d031d, 0x8298132d, 0x34438274, 0xc0ffb809, 0x130f1540, 0x23090948, 0x692b9d2a, 
    0x89237923, 0x25208223, 0xb8239e18, 0x43480e01, 0x05624305, 0x2508e74f, 0xed2f3912, 0x544d3233, 0x34372706, 0x3337063e, 0x3642070e, 0x58461805, 
    0x01022508, 0x99352315, 0x1dbc4b18, 0x6c71af29, 0x02447eb1, 0x184fc371, 0x2821bb4b, 0xc9c94404, 0xffff0000, 0x08008200, 0x06cc0426, 0x002612a7, 
    0x11000024, 0xff430007, 0x00f300a3, 0x1502b415, 0xb8022605, 0x16b4a3ff, 0x25070419, 0x00352b01, 0x2f880282, 0x2f88a820, 0x5d007428, 0x1300f400, 
    0x30840b40, 0x18155d22, 0x5f8a2d89, 0xc3202f89, 0x2f857082, 0x26051626, 0x151b0002, 0x9d202f94, 0xc5205f88, 0x90832f88, 0x30200022, 0x5d202f94, 
    0x69202f88, 0xe2252f82, 0x0d401700, 0x24908303, 0x19000203, 0x83318517, 0x823520c0, 0x20c3881c, 0x30338660, 0x03c40006, 0x40160055, 0x3802030c, 
    0x03020303, 0x4292861f, 0x49080697, 0x01000200, 0xab040000, 0x0f004505, 0x85001800, 0x040b5140, 0x049b042b, 0x02011703, 0x02520104, 0x035e0211, 
    0x04031404, 0x05090302, 0x080d0509, 0x0f185c0c, 0x0d0d030f, 0x5f01031a, 0x085f0b17, 0x083f080f, 0x088f087f, 0x04826f04, 0x089f2b08, 0x08df08bf, 
    0x17081705, 0x07110c08, 0x0c03045f, 0x120f035f, 0xed333f00, 0x1232ed3f, 0x2f2f3939, 0xed107271, 0x2f01ed10, 0x02833912, 0x15863320, 0x2d08975b, 
    0x31c0c010, 0x015d0130, 0x01230321, 0x46181521, 0x5f0807eb, 0x0e231121, 0x21030703, 0xb1fe8602, 0xe601a88e, 0xaffe9b02, 0xb9fe4701, 0xdbfd7a01, 
    0x15140449, 0x018b0615, 0xfe9c011c, 0x98450564, 0xfe9652fe, 0xb204982f, 0x44484210, 0x006ffe12, 0x7100ffff, 0x760444fe, 0x26125a05, 0x00002600, 
    0x78000711, 0x00006201, 0x01b60b00, 0x152a321b, 0x2b01250b, 0x26063741, 0x040000a2, 0x82a80662, 0x84282027, 0xff433427, 0x00f400b9, 0x0c01b415, 
    0xb8012605, 0x0db49dff, 0x420a0010, 0x2f8f0a2b, 0x5b007422, 0x84052b42, 0x0c3f2230, 0x202d890f, 0x8f878300, 0x052b422f, 0x0d205f82, 0xe4235f84, 
    0x920c12b4, 0x885d205f, 0x0069288f, 0x00e20014, 0x8302b619, 0x8202205f, 0xb4f82391, 0x31850e10, 0x2305fd41, 0xca00ffff, 0x0120c382, 0x2c20c384, 
    0xaf20c386, 0xb020c38b, 0x0120c383, 0x2f8fc38a, 0x67007422, 0x6720c38a, 0x2d88c382, 0x2f8fc384, 0x2008ef42, 0x20c48301, 0x93c18200, 0x85c3832f, 
    0x08bf428f, 0x0020c486, 0x3184c182, 0x0025c185, 0x00020000, 0x08c3821b, 0x45056540, 0x1f001000, 0x62408e00, 0x16821672, 0x16300202, 0x14021660, 
    0x02162416, 0x1a891a79, 0x8f197f02, 0x191b0219, 0x193b192b, 0x1104196b, 0x5a000611, 0x17011700, 0x131e2117, 0x060a065a, 0x21590808, 0x12220805, 
    0x1f1e5f08, 0x02094f09, 0x096f093f, 0x09cf099f, 0x09ef09df, 0x1f400906, 0x09094828, 0x0b5f1d13, 0x4c181303, 0x2b260a3c, 0xed33715d, 0x9b4b0132, 
    0xed102705, 0x2f391232, 0x3566ed5d, 0x5d5d2208, 0x06294e5f, 0x23112137, 0x21113335, 0x01021e32, 0x32331121, 0x2e341112, 0x11012b02, 0x344a1821, 
    0x87320807, 0x9e370187, 0xfe55a6f3, 0xa2dffe1d, 0x7238ced4, 0x017975ac, 0xa8b00221, 0x59aefffe, 0x02955502, 0xfaa24d5b, 0x47fef9fe, 0x0a010a01, 
    0x3979c087, 0x1f4241fe, 0x062a3e07, 0x0026129e, 0x11000031, 0x00c50007, 0x00f50000, 0x010b4013, 0x01260514, 0x082f1f00, 0x07b94112, 0x2f830020, 
    0xecff6626, 0xa8066604, 0x32202f82, 0x43342f84, 0xf400aaff, 0x02b41500, 0x0226051e, 0xb4aaffb8, 0x000a221f, 0x8f0aeb41, 0x0074222f, 0x05eb4162, 
    0x62223084, 0x2d89211e, 0xeb415f94, 0x1f022108, 0x00226082, 0x2f941e24, 0x8f889d20, 0x8309db44, 0x29002290, 0x202f9439, 0x232f885d, 0x00030069, 
    0x8206db44, 0x02032430, 0x85202202, 0x081b4231, 0x00013508, 0x04e1009d, 0x0073042e, 0x408e000b, 0xc902b91d, 0x0302d902, 0x00c900b9, 0xb60300d9, 
    0xd608c608, 0x06b60308, 0x06d606c6, 0xffb80703, 0x120e40f0, 0x10014816, 0x0a200482, 0x04200483, 0xb3201282, 0x05200c82, 0xb6200782, 0x19230782, 
    0x82030105, 0x2640210a, 0x03220b83, 0x23830901, 0x01091623, 0x2607840b, 0x8004010b, 0x494f010a, 0x02330521, 0xb201070a, 0x333f1900, 0x5d5d2f01, 
    0x3031335d, 0x852b5d00, 0x2b2b2401, 0x822b2b01, 0x5d360813, 0x37010913, 0x09170109, 0x01090701, 0xfe62019d, 0x5e0168a0, 0xfe695e01, 0x666001a2, 
    0x9cfe9ffe, 0x62014a01, 0xfe676001, 0x695f019f, 0xa0fea4fe, 0xfe610169, 0x0082009d, 0x00032a08, 0x04daff38, 0x00700592, 0x0022001a, 0x40c5002b, 
    0x011d8b8c, 0x19751965, 0x6a031985, 0x8a0c7a0c, 0x0b77030c, 0x87256701, 0x05d85a25, 0x56114623, 0xf95f1811, 0x3439080a, 0x84227422, 0x1f760322, 
    0x7b021f86, 0x021e8b1e, 0x74011e36, 0x26390126, 0x7b2b3b01, 0x032b8b2b, 0x251e261d, 0x181b2304, 0x040b0815, 0x5b00170e, 0x1b011b5f, 0x481c1940, 
    0x08078200, 0x232d1b2e, 0x0e500a5b, 0x010e1001, 0x1d251e0e, 0x29200426, 0x180b085f, 0x16050415, 0x5f200413, 0x00130509, 0x3fed333f, 0x39171233, 
    0x391711ed, 0x712afe82, 0x3912ed33, 0x712b5d2f, 0x108232ed, 0x18821120, 0x10655818, 0x005d5d22, 0x5a062843, 0x352607a2, 0x013e1234, 0xc15a3233, 
    0x07770805, 0x16012734, 0x01123233, 0x2e011714, 0x02222301, 0x84466604, 0xac6f78bf, 0x8d5e753f, 0x82442f30, 0x80d97cbf, 0x308c5e74, 0xfe1ec930, 
    0xa3984f00, 0x1e92fd94, 0x74270002, 0x029c9c4b, 0xfafeada9, 0x444659b1, 0x58bd419c, 0x01ad91e8, 0x8656ac02, 0x55bb419c, 0x72a492e4, 0x018a52fd, 
    0xa60a0118, 0x42ac0274, 0x00f9fe41, 0x00ffff00, 0x04ecff8e, 0x12a8063d, 0x43380026, 0x9f2f0623, 0x1500f400, 0x051a01b4, 0xffb80126, 0x421bb4a0, 
    0x2f920ac5, 0x56007422, 0x84052343, 0x1a562230, 0x0ec3421d, 0x23435f8f, 0x1b012108, 0x00226082, 0x2f941a20, 0x8f885d20, 0x820a0f45, 0x01022491, 
    0x421c1e00, 0x93820df3, 0x00002424, 0xc384a804, 0xc3843c20, 0x65007422, 0x09209386, 0x65246382, 0x08040c09, 0x18091744, 0x080af746, 0x1b00102e, 
    0x42406300, 0x0f860f76, 0x751a6502, 0x031a851a, 0x127a126a, 0x0003128a, 0x8f117f5a, 0x40110211, 0x00481c19, 0x11110111, 0x070b161d, 0x0afc4618, 
    0x06601626, 0x060b6015, 0x07240182, 0x12070309, 0x2607c05a, 0xed10ed10, 0x4e5d2f01, 0x5d23059c, 0x41ed5d2b, 0x012c05fa, 0x23020e14, 0x11231521, 
    0x32211533, 0x14014718, 0x0d01bf23, 0x0247187d, 0x0254080b, 0x789f58b4, 0x4505fe47, 0x9c6f3ceb, 0xfd958663, 0x6b4f2cc0, 0x01000000, 0xe3ff8e00, 
    0xcc058f04, 0xbd004300, 0x3a7c2940, 0x75023a8c, 0x02388538, 0x66014265, 0x3f440141, 0x3f743f54, 0x65043f84, 0x2e65012f, 0x2e852e75, 0x09280303, 
    0xb833480c, 0x2540e8ff, 0x27080882, 0x36011f39, 0x3d261f48, 0x3d023d36, 0x18401848, 0x18901850, 0x1f0418a0, 0x09181809, 0x002a031f, 0xffb81148, 
    0x1712b3c0, 0x2a080784, 0x0e092940, 0x45111148, 0x402b462a, 0x00481512, 0x112b012b, 0x05031f3d, 0x00315024, 0x0960152b, 0x09800970, 0x0e090903, 
    0x4a160550, 0x3f2e05d7, 0x1712ed3f, 0x5d2f0139, 0x3912ed2b, 0x05822b2f, 0x26077554, 0x5ded105d, 0x44003031, 0x5d2f0509, 0x5d005d01, 0x020e1401, 
    0x2f262223, 0x50031e01, 0x042305e9, 0x823e3435, 0x822e2003, 0x020e2615, 0x11231115, 0x05387934, 0x1415a108, 0x1415040e, 0x8f04041e, 0x5f875729, 
    0x02379450, 0x4e4a421a, 0x36625c25, 0x36515f51, 0x313a3121, 0x5a3f2121, 0x496b4439, 0x783fb427, 0x9b666eae, 0x33213569, 0x3721333a, 0x37525f52, 
    0x76422701, 0x18193458, 0x121a0fa4, 0x3b4f5f0a, 0x47393f52, 0x4933465e, 0x3f34303a, 0x2d3e252b, 0x7a4d231a, 0x0403fc58, 0x70ac7703, 0x6d502e36, 
    0x43573b3e, 0x20323134, 0x403a3d28, 0xffff6f54, 0xecff8000, 0xb4058804, 0x44002612, 0x06110000, 0x008e4300, 0x02b41500, 0x02261142, 0xb470ffb8, 
    0x03154643, 0x8f0c7346, 0x4d74262f, 0x40130000, 0x2230840b, 0x8945422f, 0x275b922d, 0x0000eec3, 0x4302b719, 0x20285b82, 0xffb80148, 0x4248b4d0, 
    0x5d223084, 0x83490035, 0x205f8507, 0x268f88a9, 0x0000f8c5, 0x840e4022, 0x4d30275f, 0x014d2001, 0x3a824d10, 0x4db4da23, 0x203a855d, 0x883c865d, 
    0x887b206f, 0xf069273b, 0x401e0000, 0x3c83030a, 0x20020323, 0x23378246, 0x4446b4d2, 0x35203785, 0x87065446, 0x0b062137, 0xc4203788, 0x17317382, 
    0x02030d40, 0x03261147, 0x424c1202, 0x01252f27, 0x0830872b, 0x14000376, 0xb804ecff, 0x41004e04, 0x59005000, 0x8140c600, 0x588c587c, 0x8c547c02, 
    0x136a0254, 0x138a137a, 0x7c116c03, 0x03118c11, 0x3d153d05, 0x15370502, 0x21030237, 0x1b022113, 0x480e0928, 0x00563814, 0x4b244b49, 0x0a0a4909, 
    0xcf574840, 0x024bdf4b, 0x4b015710, 0x1e574b57, 0x30482f5b, 0x4f484230, 0x9f1e5f1e, 0x041eaf1e, 0x502a511e, 0x56500035, 0x5624514b, 0x24080182, 
    0x2f35383b, 0x022f8f2f, 0x10352f2f, 0x19504506, 0x80190f14, 0x09090109, 0x3f001619, 0x115d2f33, 0xed103333, 0x25098632, 0x2f2f3939, 0x0183ed10, 
    0x2f013229, 0x2f33ed5d, 0x831211ed, 0x5d5d2113, 0x0c822382, 0x39262a83, 0x00303139, 0x00855d2b, 0x64150121, 0x1727054d, 0x2223030e, 0x8527022e, 
    0x141a7e06, 0x013e1729, 0x021e3233, 0x6d05011d, 0x7c080560, 0x0e07013d, 0x0e220103, 0x2e210702, 0x01a70201, 0x31462c15, 0x8a10594b, 0x6d492b0c, 
    0x485c394d, 0x36151235, 0x443a5c49, 0x391e3f61, 0xa73e765d, 0x2434210f, 0x17263320, 0x2808a804, 0x5b50714a, 0x7d2d2379, 0x4e81604c, 0x3905fc20, 
    0x34513839, 0x4a257a19, 0x9e02253a, 0x23333e1c, 0x09690102, 0x11f70158, 0x37628852, 0x2d2d485e, 0x182f495b, 0x31405937, 0x2c243e55, 0x6b4b7754, 
    0x114d7e89, 0x4a45462b, 0xd29b5841, 0x52cc187a, 0x09527e64, 0x1d520236, 0xab627f4a, 0x00ffff9d, 0x0444fe82, 0x124e0438, 0x00460026, 0x2b050f4c, 
    0x00000051, 0x2101b60b, 0x1c00262e, 0x26090f4c, 0x04ecff85, 0x82b40546, 0x82482027, 0x00063427, 0x0000b143, 0x2c02b415, 0xb8022611, 0x2db4b2ff, 
    0x431f1530, 0x2f8f0c1b, 0x436f7421, 0x3083051b, 0x2f2c6f22, 0x83822d89, 0xc3212b8f, 0x202b8507, 0x225c822d, 0x922c3207, 0x887b202b, 0x08692287, 
    0x05014e00, 0x03245882, 0x2e300802, 0x034c2d85, 0x008f2408, 0x84650400, 0x85c020b7, 0x00bd38b7, 0x0b401e00, 0x26110a01, 0x010b6001, 0xb8010b50, 
    0x0bb4a9ff, 0x8201030e, 0x0a3f43be, 0x7421378f, 0x84938468, 0x0a542237, 0x832e840d, 0x82002064, 0x282b8fbf, 0x00000ac3, 0x010e4022, 0x2663830b, 
    0x10500110, 0x82103001, 0xb4f62366, 0x37840a10, 0x67905d20, 0x9f85cf83, 0x00296927, 0x1f402f00, 0x30688302, 0x0e900102, 0x010e8001, 0x60010e70, 
    0x0e50010e, 0x24538201, 0x060c0e00, 0x82aa8409, 0x435d2045, 0x5d080787, 0xff7d0002, 0x054e04ec, 0x002500d8, 0x40bb0037, 0x55364581, 0x03366536, 
    0x31553145, 0x4a033165, 0x6a2e5a2e, 0x284a032e, 0x286a285a, 0x3b042b03, 0x03046b04, 0x24152405, 0x06101302, 0x08120409, 0x0c120c08, 0x47172112, 
    0x01267003, 0x000126a0, 0x60261026, 0x26260326, 0xff473039, 0x02820121, 0x21004908, 0x10652101, 0x10851075, 0x7a066a03, 0x03068a06, 0x06130910, 
    0x2b110704, 0x00030050, 0x00100000, 0x07000702, 0x50330c00, 0x1112161c, 0x00000c11, 0x332f333f, 0x3911ed3f, 0x5d2f2f39, 0xed103311, 0x39171211, 
    0x2f015d5d, 0x079c4918, 0x33727122, 0x33211d85, 0x0b37492f, 0x16320129, 0x27012e17, 0x82372705, 0x1e332905, 0x17251701, 0x1d121607, 0x210b7b59, 
    0x38463401, 0x05714306, 0x64026808, 0x272b7547, 0xfcfe4c69, 0x7838da37, 0x532dd142, 0x3708012a, 0x39a7a4d3, 0x7d84bc78, 0x343876b5, 0xb201ba74, 
    0x50714721, 0x21497351, 0x76519190, 0xd303244b, 0x9f591b20, 0x5e6e7345, 0x14234e2d, 0x6c721f33, 0x7dfe955c, 0xc47906f4, 0x84494b8a, 0xb66b6fb9, 
    0x0efe4b86, 0x2c5a895e, 0x5c885c2d, 0x5a2cb2be, 0x77ffff8b, 0x052c050b, 0x002612a9, 0x11000051, 0x0ac50006, 0x28051342, 0x01261126, 0x13413109, 
    0x0a5f4c24, 0xecff8226, 0xb4054904, 0x52202b82, 0x43302b84, 0x150000ba, 0x112402b4, 0xffb80226, 0x2825b4bb, 0x8f0e0b49, 0x6574212f, 0x30845b84, 
    0x27246522, 0x8f0cbb4c, 0x00c3212b, 0x25202b85, 0x00225c82, 0x2b92242a, 0x8785b383, 0x2b86c520, 0x00228883, 0x2b923f2f, 0xb3887b20, 0x2b826920, 
    0x0d401723, 0x24848303, 0x28000203, 0x0c8d4926, 0x00035b08, 0x04df0074, 0x00750457, 0x00070003, 0x4063000b, 0x0b0e063c, 0x700e0805, 0x03050105, 
    0x3f00ab0b, 0x02084f08, 0x0a010800, 0x0d080803, 0x40ae090c, 0x01040e08, 0xae000e05, 0x013f012f, 0x4f03014f, 0x9f018f01, 0x0401ef01, 0x05ad0401, 
    0xed3f00b3, 0xed715dd6, 0x1018002b, 0xa35af64d, 0x335d2309, 0x6d1832ed, 0x312807e7, 0x33350130, 0x21350115, 0x33380382, 0xa8110215, 0xe303bbfd, 
    0x03a8bafd, 0xfeb7b7be, 0xfe9292a2, 0x00b7b77f, 0x39088d82, 0x04ecff6e, 0x004e045d, 0x00250019, 0x40db0031, 0x55244524, 0x03246524, 0x4a01306b, 
    0x02305a30, 0x110b200c, 0x89077948, 0x40070207, 0x74480f0b, 0x02198419, 0xc0ffb819, 0x0d830940, 0x14841424, 0x0d831402, 0x0d826720, 0x1e2a1d26, 
    0x1a260429, 0x3f062f4c, 0x20470017, 0x401a301a, 0x801a701a, 0x061a901a, 0x1a501a00, 0x1ab01aa0, 0x00051ac0, 0x601a101a, 0x2e081784, 0x1a061ae0, 
    0x4726331a, 0x0e0a0a0e, 0x482e2840, 0x1b18400e, 0x1d2a0e48, 0x21041e29, 0x180b082d, 0x05130415, 0x502d1616, 0x50211013, 0x74090905, 0xed2608c5, 
    0x12112f33, 0x03833917, 0x2b2f0123, 0x08a1682b, 0x32ed7223, 0x095d4c2f, 0x015d2b25, 0x83005d2b, 0x5d002105, 0x6607d574, 0x352306fb, 0x4c023e34, 
    0x162e0557, 0x27263407, 0x33011e01, 0x25023e32, 0x5a4c1614, 0x0e700805, 0x465d0402, 0x6577bc83, 0x4c4d40a6, 0x43333054, 0xd579bc81, 0x504e487a, 
    0x1011bd61, 0x722b03fe, 0x56764540, 0x118bfd30, 0x2afd0111, 0x75454571, 0x1e023055, 0x458cd38e, 0x44573635, 0x7abc455f, 0x468dd18c, 0x5a445264, 
    0x784cf789, 0x35c0fd2e, 0xa662272a, 0x2e754b7e, 0x27324002, 0x00a46329, 0xffff0000, 0xecffb900, 0xb4051f04, 0x58002612, 0x3105f742, 0x150000a2, 
    0x112601b4, 0xffb80126, 0x2a27b49c, 0x27461324, 0x212f8f0c, 0x53435a74, 0x26542209, 0x922d8929, 0x82c3205b, 0x205b8272, 0x235b8427, 0x262cb4fa, 
    0x7b205b94, 0x69208b88, 0x19222f82, 0x8c8302b6, 0x8d820220, 0x2ab4fa23, 0x46318528, 0xbf84052d, 0x57fe4224, 0xbf848904, 0xbf845c20, 0x856b7421, 
    0x8220208f, 0x206b2364, 0xe5461123, 0x00022209, 0x082b82b9, 0xcc054252, 0x38001300, 0x44406500, 0x21892179, 0x01126402, 0x12561246, 0x01026b02, 
    0x02590249, 0x01163502, 0x0601263a, 0x761b161b, 0x041b861b, 0x0060471e, 0x3a000001, 0x462f0a32, 0x30803000, 0x00313002, 0x0f281b2f, 0x14162350, 
    0x10195005, 0x33ed3f00, 0x3f200283, 0x4c095a4c, 0x5d200658, 0x77780083, 0x3e01240f, 0x18323303, 0x32099075, 0x031e2327, 0x11231115, 0x06141133, 
    0x03070607, 0x793b1888, 0xfd230d83, 0x793f19e8, 0xc179069f, 0x01b4210e, 0x02210082, 0x0e7f7922, 0x79ce0121, 0xbb790798, 0x75072c0e, 0x391d59fe, 
    0x00171a16, 0x4100ffff, 0x7b230533, 0x41002612, 0x69300533, 0x17000005, 0x01020d40, 0x02261120, 0x22240501, 0x41053541, 0x01280665, 0x00008f00, 
    0x3a046504, 0x7f05df7d, 0xdf7d05ed, 0x0a0b2108, 0x7d0edf7f, 0xe9201bdf, 0x2609d47f, 0x038e8e8e, 0x82008e1e, 0x023c0800, 0xfbff1400, 0x4b05c504, 
    0x28001700, 0x49407400, 0x26862676, 0x56094602, 0x04490209, 0x12020459, 0x160e120e, 0x1b5c1511, 0x1616061b, 0x065c242a, 0x110f5f14, 0x117f113f, 
    0x6f04118f, 0x9f390482, 0xdf11bf11, 0x11110511, 0x5f16180e, 0x17030317, 0x5f0f1f12, 0x0e0b0b0e, 0x0b3c6c03, 0x3911322c, 0xed72712f, 0x12ed2f01, 
    0x02822f39, 0xd255ed20, 0x05044e05, 0x010e2126, 0x11022223, 0x5506e84f, 0x252509bb, 0x11373632, 0x1b46182e, 0x02ce0808, 0x1a311761, 0x7b3decff, 
    0x333a7cb9, 0x72fe2e02, 0x91fe6f01, 0x3bfdb701, 0x13133b16, 0x754e153b, 0x4f28274e, 0x01030274, 0xb45c0152, 0x4ca20001, 0x48fe9806, 0x9839fe96, 
    0x0404028c, 0x3a030321, 0x8e8fc87f, 0x003f84cc, 0x1c000300, 0xb404ecff, 0x26004e04, 0x43003a00, 0x7340aa00, 0x428b427b, 0x8a3e7a02, 0x3876023e, 
    0x79023886, 0x022a892a, 0x03760366, 0x64030386, 0x84337433, 0x2f6b0333, 0x2f8b2f7b, 0x15220503, 0x1a050222, 0x0a021a15, 0x02151a15, 0x00401d10, 
    0x18272748, 0x09490825, 0x10482509, 0x41410141, 0x4f483145, 0x9f185f18, 0x0418af18, 0x40500018, 0x2c3b3640, 0x1b1d2050, 0x50360510, 0x130e1013, 
    0x08010880, 0x794b1308, 0xed33260d, 0x2f391232, 0x08f958ed, 0x5a2f3221, 0x3221058a, 0x09d66839, 0x00825d20, 0x335b0120, 0x17373105, 0x2223030e, 
    0x23010e27, 0x35022e22, 0x32331210, 0x2008594b, 0x89691825, 0x085d4b0e, 0x13c84408, 0x412c4029, 0x0b8a0e4e, 0x48664428, 0x852a51b6, 0x55784b5b, 
    0xbba2aa2d, 0x51852d4f, 0x1f4a7b5b, 0x2c186bfd, 0x4127273f, 0x2e1b192f, 0x4128233e, 0x4c01192e, 0x202f3719, 0x08440102, 0x55f70150, 0x4b39678f, 
    0xb7350648, 0x8c445a5d, 0x17018fd3, 0x5eb11901, 0xd29b5853, 0x7e27187a, 0x0c9a7da4, 0x4b290221, 0x4e080535, 0x01000000, 0xb1041b01, 0xb405b103, 
    0x25000900, 0x01201740, 0x01600150, 0x01040180, 0x0b200306, 0x8e03480f, 0x02058c09, 0x333f0093, 0x012bedfd, 0x315dc42f, 0x23150130, 0x23072327, 
    0x03333735, 0x02db69b1, 0xa4fe68e8, 0x8a14c504, 0x82ef148a, 0x02002f4e, 0x7c047401, 0x0b065803, 0x27001300, 0xb3628b00, 0x480f2c06, 0xe8ffb80d, 
    0x0f096140, 0x82180748, 0x83032004, 0x14410804, 0x10000084, 0x03002000, 0x00700030, 0x00b00080, 0x00d000c0, 0x01006006, 0x001f000f, 0x841e0002, 
    0x0a010a00, 0x0f7f8e19, 0x0f020f8f, 0x480c0940, 0x2f8e230f, 0x6f054f05, 0x0405df05, 0x052f050f, 0x340c843f, 0x059f057f, 0x050805bf, 0x48191640, 
    0x2b2f0005, 0xd4ed715d, 0x05f1622b, 0x5d5dd426, 0x31ed7271, 0x62058d66, 0x582820f4, 0x3d5b3c1e, 0x1e3c5b3d, 0x792a0787, 0x212e1d0d, 0x0d1e2e21, 
    0x07831e0d, 0x050d1d3d, 0x38482744, 0x48382121, 0x37482727, 0x48372121, 0x181d0f27, 0x1d180f0f, 0x831e0f0f, 0x001e2b07, 0xff000100, 0xcc03b104, 
    0xc382a905, 0x10405128, 0x1f1a1f0a, 0xed831e02, 0x0f053508, 0x0e020f15, 0x40e8ffb8, 0x480f0924, 0x1b0f831a, 0x1b3f1b2f, 0x1b8f1b7f, 0x0a1b1b05, 
    0x300b0083, 0x1a0b020b, 0x8c108f05, 0x000a8f15, 0x323f0093, 0x33edfded, 0x2005e54d, 0x24c3845d, 0x015d2b5d, 0x05304a22, 0x45230721, 0x3508052e, 
    0x023e3233, 0x030e3337, 0x542a0203, 0x17234d50, 0x050a131d, 0x2d14056f, 0x542c3b4a, 0x17214a50, 0x040a141e, 0x2b140570, 0x25b1044a, 0x1e10252d, 
    0x582d1d2c, 0x0a832c47, 0x1c2c1f26, 0x2d47582c, 0x2808af82, 0x04c301aa, 0x004c0222, 0xb50f0003, 0xb9000002, 0x3f00bc01, 0x2f2f01ed, 0x35133031, 
    0x03aa1521, 0x89c30178, 0xff010089, 0x202782f6, 0x202794d6, 0x22278203, 0x85e0040a, 0x01220827, 0x035e038d, 0x00cc053f, 0xb52a0003, 0x01160106, 
    0xffb80102, 0x0e1140f0, 0x9a034811, 0x99019700, 0x12820200, 0x00009c22, 0x75186584, 0x013007ee, 0x03012103, 0xf7fea93f, 0xcc053701, 0x6e0292fd, 
    0x00231f82, 0x828f0101, 0x8441204b, 0x4033244b, 0x82180022, 0x00092743, 0x09020019, 0x76181902, 0x00200c47, 0x0322c682, 0x528d019c, 0x012b5d24, 
    0x42822113, 0x0901a92a, 0x5e03c9fe, 0x92fd6e02, 0x01285482, 0x95fe5d01, 0x03010f03, 0x3b229f82, 0x53992840, 0x53822f20, 0x00100024, 0x76180002, 
    0xae870b9c, 0x5d205b86, 0xfe215b84, 0x265b8695, 0x03b10002, 0x841a045e, 0x000729af, 0x0506b557, 0x05020516, 0x0920fd83, 0x0b41b982, 0x82262009, 
    0x9a07300d, 0x99059704, 0x069f062f, 0x10060002, 0x41060206, 0x1020071c, 0x0524d982, 0x039c0107, 0x3323cd83, 0x832f0132, 0x5d2f2173, 0x2b267987, 
    0x2103015d, 0x03822101, 0xa9630228, 0x3701f7fe, 0x35413202, 0x0539410a, 0xb2000222, 0x1b208782, 0x68248786, 0x18044b40, 0x09277182, 0x02041904, 
    0x82190609, 0x8210206b, 0x33f9930e, 0x97069905, 0x04009a07, 0x04900410, 0x99010403, 0x9a039702, 0x21080741, 0x62410507, 0x85948406, 0xfded2895, 
    0x2b3031ed, 0x832b5d5d, 0x13012103, 0x03829882, 0xa9690228, 0xc9fe0901, 0x7941cefd, 0x6e02240a, 0x820092fd, 0x94fe2d97, 0x02011b04, 0x07000300, 
    0x4c406a00, 0x042997c4, 0x01059c00, 0x1000089b, 0x051f6df4, 0xfe2199a8, 0x42958394, 0x33080817, 0x03910150, 0x00bc037b, 0x40370013, 0x25111525, 
    0x03113511, 0x0d250d15, 0x1a030d35, 0x3a072a07, 0x031a0307, 0x033a032a, 0x10000003, 0x050a010a, 0x2f000f05, 0x2106f265, 0x4a613031, 0x7b033914, 
    0x3a664d2c, 0x2b4b6339, 0x39634b2b, 0x2c4d663a, 0x663aaa02, 0x4c2d2d4c, 0x64351582, 0x4a2b2b4a, 0x01010064, 0x038d005a, 0x00ac035d, 0x402e0008, 
    0x08856a18, 0x01014f22, 0x01221b82, 0x726a0102, 0x3333230b, 0x0a421801, 0xedd42105, 0x210a636a, 0x4f6aaa02, 0x203f8214, 0x205b826e, 0x225b8471, 
    0x611a4030, 0x00290981, 0xd0016001, 0x08010301, 0x0b716107, 0x6b615d85, 0x0a616105, 0x61200221, 0x51200658, 0x3f094e61, 0x00010000, 0x030000cc, 
    0x004505fe, 0xb7270003, 0x03100302, 0x01000503, 0x40f0ffb8, 0x1001000a, 0x023cb782, 0x00180006, 0x2f013f3f, 0x1233385d, 0x33382f39, 0x23213031, 
    0x42013301, 0x73bf0276, 0x00203682, 0x68084383, 0x04ecff5b, 0x005a0563, 0x4096003c, 0x01316955, 0x03470337, 0x2b030357, 0x350c2a2a, 0x0b390000, 
    0x3e1c0c0c, 0x39010133, 0x00201c6e, 0x17170117, 0x1616221c, 0x0e0b401c, 0x17011c48, 0x183b1873, 0x21732036, 0x186f2133, 0x01213f01, 0x21182118, 
    0x25732e06, 0x07252b2b, 0x30117306, 0x0b0b010b, 0x3f001911, 0x105d2f33, 0x200582ed, 0x06bb6610, 0x72115d21, 0x0126085a, 0x2f332b2f, 0x21821133, 
    0xed103223, 0x064e7232, 0x1282ac82, 0xaf821120, 0x5d5d0028, 0x031e2101, 0xd0603233, 0x23272909, 0x012e3335, 0x37363435, 0x30530882, 0x07172105, 
    0x08050749, 0x15210725, 0x15010e21, 0x03211714, 0x0835fe69, 0x50744d2a, 0x424b5734, 0x582a4c1e, 0x783e6c60, 0x0d477bb2, 0x82027783, 0x774d0800, 
    0xe5fb1d81, 0x575d6438, 0x8a3a522b, 0x53724956, 0xcd010b33, 0x010125fe, 0x01da0103, 0x547a4fcf, 0x251e122b, 0x2e1c8713, 0x7d441220, 0x17906db2, 
    0x231a1222, 0xecea8e12, 0x1e2c1c0e, 0x1c3a2a8c, 0x8d5f7a47, 0x2a152b0e, 0x00000020, 0x07576501, 0x00030027, 0x03184028, 0x2a128296, 0x05040000, 
    0x000f9b01, 0x823f001f, 0x0e402815, 0x00004811, 0x695d2b2f, 0xc265052d, 0x11332a05, 0x01ebf001, 0xfe2b01a4, 0x2d3082d5, 0x4d022501, 0x4505c702, 
    0x44001200, 0xe0641c40, 0x09003914, 0x03090901, 0x1101b80e, 0xe40110b3, 0x1201b800, 0x32ed3f00, 0x2f33333f, 0x0a825787, 0x0805e964, 0x01303130, 
    0x0e113335, 0x32352303, 0x3337023e, 0x01153311, 0x2f0d8749, 0x120d2f33, 0x112f3330, 0x4d027479, 0x1a01026b, 0x770a1724, 0x212c1b0c, 0x235873fd, 
    0x02fa3805, 0x0504034d, 0x00200051, 0x1500b94f, 0x2040d8ff, 0x1f481109, 0x69e1171f, 0x5f2d1079, 0x0e0e010e, 0xb814e40b, 0x01b31301, 0x208c891e, 
    0x5d8c82ed, 0xa24906e6, 0x312f2607, 0x132b0030, 0x147f6935, 0xfa153808, 0x54544a18, 0x3c332a44, 0x82083b3d, 0x5c412706, 0x2e79783d, 0x44525647, 
    0x027c0110, 0x5537614d, 0x47403f48, 0x3e40392c, 0x502f053d, 0x6770213a, 0x414b5937, 0x8526413f, 0x02ea24af, 0x82ed023b, 0x003325af, 0x2a00b98a, 
    0x4020af82, 0x0321af82, 0x32048228, 0x1c101c00, 0x7b031c20, 0xe1220130, 0x2d0a2323, 0x82181ce1, 0x000a2901, 0xe10b11e1, 0x3511110a, 0x2e087e5c, 
    0x16171830, 0x5f280e16, 0x22220122, 0x8228e41f, 0x09402dcf, 0x5005e40e, 0x0b0b010b, 0x1401b805, 0x2007bc42, 0x26d882ed, 0x2f391211, 0x823911c4, 
    0x825d20df, 0xed102109, 0x6906ce42, 0x00220589, 0xa958015d, 0x0f771805, 0x0c8b690a, 0x34353627, 0x06222326, 0x3d7a1807, 0x06740808, 0x011e1507, 
    0x4427ed02, 0x5c40385e, 0x8806223e, 0x36304109, 0x36291942, 0x4425291d, 0x2d293640, 0x07870642, 0x3055442c, 0x1d3a573a, 0x4b524543, 0x53361a03, 
    0x3c251d39, 0x3c0d274c, 0x25413c3d, 0x6d0a1a2f, 0x32354239, 0x360c393f, 0x1f1a3650, 0x422a4a37, 0x12021a55, 0x02000064, 0x4b02c500, 0x45053503, 
    0x17000a00, 0x12405d00, 0x01080909, 0x600612e0, 0x07c27b18, 0x11192c08, 0x401701b8, 0x0d400420, 0x04004811, 0x04020410, 0x08e40400, 0x1f110f05, 
    0x9f112f11, 0x0511bf11, 0x0b011111, 0x1101ba06, 0x76010100, 0x78180614, 0x2b2108cc, 0x08ff82ed, 0x33335d4a, 0x2f3232ed, 0x15013031, 0x35213523, 
    0x33113301, 0x030e0315, 0x11210307, 0x0236023c, 0x89fe7fbb, 0x7a8d6901, 0x181506f8, 0x01b90717, 0xec020109, 0x0163a1a1, 0x650cfef6, 0x1f09d901, 
    0xff0a2022, 0x0d040100, 0x001b1f20, 0x1e240083, 0x01006e01, 0x03820883, 0x6c003522, 0x01240b86, 0xb2000700, 0x02200b86, 0xca200b82, 0x03240b86, 
    0xf8001200, 0x04240b86, 0x1b010700, 0x05240b86, 0x3d010c00, 0x06200b86, 0x5a201782, 0x07220b86, 0xe1825000, 0x08245f85, 0x7f021400, 0x09231786, 
    0x87020e00, 0x010a245f, 0x86890563, 0x000b2417, 0x8627071c, 0x000c240b, 0x86a2072e, 0x000d230b, 0x5f870835, 0x1a000e26, 0x0300a908, 0x0920c482, 
    0x6a20b382, 0x0b850382, 0x0e000124, 0x1786a200, 0x0b820220, 0x0b86ba20, 0x24000324, 0x0b86d200, 0x0e000424, 0x0b860b01, 0x18000524, 0x0b862301, 
    0x17820620, 0x0b864a20, 0xa0000724, 0x0b866201, 0x28000824, 0x0b865502, 0x1c000924, 0x0b869402, 0xc6020a24, 0x0b86c102, 0x38000b24, 0x0b86ed06, 
    0x5c000c24, 0x0b864407, 0x6a000d24, 0x0b86d107, 0x34000e2a, 0x44007308, 0x67006900, 0x74200382, 0x7a260382, 0x64006500, 0x03822000, 0x74006124, 
    0x09826100, 0x6f006328, 0x79007000, 0x25847200, 0x15826820, 0x28002026, 0x29006300, 0x32241b82, 0x31003000, 0x20220382, 0x25824700, 0x45826f20, 
    0x3f826c20, 0x43002022, 0x72200d82, 0x6f203582, 0x47833582, 0x0f826920, 0x006e3808, 0x4400002e, 0x74696769, 0x64657a69, 0x74616420, 0x6f632061, 
    0x69727970, 0x20746867, 0x20296328, 0x30313032, 0x6f6f4720, 0x20656c67, 0x70726f43, 0x7461726f, 0x826e6f69, 0x224f8336, 0x82730075, 0x826e2081, 
    0x43002a5f, 0x6973756f, 0x0000656e, 0x240d8252, 0x00750067, 0x20a9826c, 0x240e8272, 0x6c756765, 0x20088261, 0x202b8241, 0x201b8263, 0x20c7826e, 
    0x22838265, 0x822d0020, 0x29458ead, 0x65637341, 0x7265646e, 0x6d822d20, 0x228e5086, 0x56216888, 0x83468300, 0x006f2280, 0x204a826e, 0x20cc8231, 
    0x24f88230, 0x72655600, 0x25a38273, 0x302e3120, 0xf7840030, 0x568da793, 0xc7822020, 0x44827320, 0x03826120, 0x9d827420, 0xa5846120, 0xc3846d20, 
    0x13826b20, 0x66006f22, 0x51410582, 0x8261200d, 0x82642076, 0x20258315, 0x20078279, 0x20908262, 0x223b8220, 0x84670065, 0x8474204d, 0x05bb41a0, 
    0x2b826920, 0x63002022, 0x74201184, 0x0f855582, 0x75006a22, 0x69242f82, 0x64007300, 0x63223182, 0x05827400, 0x7320cc83, 0x5141ca82, 0x69203107, 
    0x20612073, 0x64617274, 0x72616d65, 0x666f206b, 0x3d078f41, 0x20646e61, 0x2079616d, 0x72206562, 0x73696765, 0x65726574, 0x6e692064, 0x72656320, 
    0x07826174, 0x72756a2f, 0x69647369, 0x6f697463, 0x002e736e, 0x11824100, 0x20151442, 0x08864100, 0x220af241, 0x82530000, 0x0065229f, 0x20e58476, 
    0x20c3824d, 0x220f8474, 0x826f0073, 0x53002edb, 0x65766574, 0x74614d20, 0x6f736574, 0x0f76416e, 0x77002022, 0x73223082, 0xe8822000, 0xee826520, 
    0x67006922, 0x1a413482, 0x00622205, 0x9b178279, 0x8620205c, 0x8261203b, 0x00202233, 0x20058269, 0x2074826e, 0x20828476, 0x20908469, 0x2041822c, 
    0x21988272, 0x05830066, 0x68007322, 0x67202584, 0x73201582, 0x6e202582, 0x20207182, 0x65200382, 0x69221d82, 0x858e6600, 0xc6822020, 0x4b846820, 
    0xa3835b83, 0x49826d20, 0x2b847420, 0x17826320, 0x6c006c22, 0x6320a184, 0x6d227382, 0x29847000, 0x62006922, 0x65201582, 0x77204982, 0x74206982, 
    0x60436f82, 0x84752005, 0x05de4235, 0x45824e20, 0x22217724, 0xe6422e00, 0x82202010, 0x82662049, 0x05bf4287, 0x6d207583, 0x72205782, 0x1341d384, 
    0x826f2005, 0x822d20e3, 0x846320b1, 0x846520cf, 0x22d983f7, 0x82640061, 0x8262207f, 0x846c2073, 0x82792077, 0x8263205b, 0x8261207d, 0x00612227, 
    0x85c98263, 0x827320e3, 0x82692009, 0x05d2420f, 0x35826e20, 0xb183e585, 0x6e25c183, 0x45002d00, 0x20ad8300, 0x2079826f, 0x20538265, 0x2449826e, 
    0x00470057, 0x2051944c, 0x208b8220, 0x20538265, 0x20298420, 0x20238264, 0x22ad8273, 0x8276006c, 0x206383e3, 0x83838274, 0x826e205b, 0x8265200f, 
    0x4313836d, 0x64200532, 0x25831182, 0x2f826c20, 0x0b827020, 0x49827220, 0x83002021, 0x006f220d, 0x08a5416b, 0x1d826620, 0x55827220, 0x11827720, 
    0x67826420, 0x9f826820, 0x83156f41, 0x826e2029, 0x20758521, 0x2033826f, 0x206f8261, 0x20ff8264, 0x42598265, 0x6f200561, 0x7522f982, 0x6d826d00, 
    0x20202983, 0x2006f444, 0x10394174, 0x27826120, 0x79827220, 0x93847320, 0x95827020, 0x59826120, 0x6d208b85, 0x2e211382, 0x08844300, 0x7361772f, 
    0x73656420, 0x656e6769, 0x79622064, 0x0dee4220, 0x1d822020, 0x6e612308, 0x6e6e6920, 0x7461766f, 0x2c657669, 0x66657220, 0x68736572, 0x20676e69, 
    0x736e6173, 0x72657320, 0x42866669, 0x68742037, 0x69207461, 0x656d2073, 0x63697274, 0x796c6c61, 0x6d6f6320, 0x353a8270, 0x20656c62, 0x68746977, 
    0x756f4320, 0x72656972, 0x77654e20, 0x0c452eaa, 0x6f202d07, 0x72656666, 0x6d692073, 0x766f7270, 0x6f288982, 0x63732d6e, 0x6e656572, 0x61276f82, 
    0x69626164, 0x8274696c, 0x6168254b, 0x74636172, 0x73287182, 0x73636974, 0x646e6120, 0x652b7282, 0x6e617020, 0x7275452d, 0x8265706f, 0x475724ac, 
    0x8763204c, 0x209e8228, 0x25268474, 0x766c6f73, 0x2d847365, 0x65656e24, 0x71827364, 0x7622b482, 0x34826c65, 0x6c237882, 0x836b6f6f, 0x6f6622d2, 
    0x23a68272, 0x2d687464, 0x6623b78a, 0x82746e6f, 0x206f363a, 0x72646461, 0x20737365, 0x75636f64, 0x746e656d, 0x726f7020, 0x239c8774, 0x6f726361, 
    0x70231b82, 0x8274616c, 0x736d2745, 0x6800002e, 0x01827400, 0x3a007024, 0x01822f00, 0x83007721, 0x002e2201, 0x0e304661, 0x6f006329, 0x70007200, 
    0x42002e00, 0x2f200519, 0x742a3882, 0x2f3a7074, 0x7777772f, 0x3946612e, 0x6f632406, 0x822e7072, 0xb61d8394, 0x00742256, 0x20668279, 0x0eaa4465, 
    0x8e827220, 0xaa842e20, 0x6c006d22, 0x74237a9d, 0x42657079, 0x7225062c, 0x74682e73, 0x222f826d, 0x8269004c, 0x006522b7, 0x4346826e, 0x752005e3, 
    0x64210b82, 0x052b4400, 0x28073f43, 0x00490053, 0x0020004c, 0x2080844f, 0x2009826e, 0x42f58246, 0x418d05c5, 0x1b822c20, 0x08130147, 0x00003123, 
    0x6563694c, 0x6465736e, 0x646e7520, 0x74207265, 0x53206568, 0x4f204c49, 0x206e6570, 0x746e6f46, 0x21208620, 0x2947202c, 0x41368209, 0x73200d85, 
    0x7220ad82, 0x7022b382, 0xf8847400, 0x0b827320, 0x2e006c22, 0x72248d82, 0x2f006700, 0x4620a182, 0x0021a982, 0x05814168, 0x72637333, 0x73747069, 
    0x6c69732e, 0x67726f2e, 0x4c464f2f, 0x21008200, 0x00840002, 0x0023fe23, 0x20088254, 0x8d038201, 0x84d82002, 0x02580815, 0x04000300, 0x06000500, 
    0x08000700, 0x0a000900, 0x0c000b00, 0x0e000d00, 0x10000f00, 0x12001100, 0x14001300, 0x16001500, 0x18001700, 0x1a001900, 0x1c001b00, 0x1e001d00, 
    0x20001f00, 0x22002100, 0x24002300, 0x26002500, 0x28002700, 0x2a002900, 0x2c002b00, 0x2e002d00, 0x3c08a682, 0x00310030, 0x00330032, 0x00350034, 
    0x00370036, 0x00390038, 0x003b003a, 0x003d003c, 0x003f003e, 0x00410040, 0x00430042, 0x00450044, 0x00470046, 0x00490048, 0x004b004a, 0x004d004c, 
    0x26e4824e, 0x00510050, 0x82530052, 0x550c09bf, 0x57005600, 0x59005800, 0x5b005a00, 0x5d005c00, 0x5f005e00, 0x61006000, 0x8400a300, 0xbd008500, 
    0xe8009600, 0x8e008600, 0x9d008b00, 0xa400a900, 0xda008a00, 0x93008300, 0x03010201, 0x97008d00, 0xc3008800, 0x0401de00, 0xaa009e00, 0xf400f500, 
    0xa200f600, 0xc900ad00, 0xae00c700, 0x63006200, 0x64009000, 0x6500cb00, 0xca00c800, 0xcc00cf00, 0xce00cd00, 0x6600e900, 0xd000d300, 0xaf00d100, 
    0xf0006700, 0xd6009100, 0xd500d400, 0xeb006800, 0x8900ed00, 0x69006a00, 0x6d006b00, 0x6e006c00, 0x6f00a000, 0x70007100, 0x73007200, 0x74007500, 
    0x77007600, 0x7800ea00, 0x79007a00, 0x7d007b00, 0xb8007c00, 0x7f00a100, 0x80007e00, 0xec008100, 0xba00ee00, 0xb000d700, 0xd800b100, 0xd900dd00, 
    0xb300b200, 0xb700b600, 0xb400c400, 0xc500b500, 0xbe008700, 0xbc00bf00, 0x06010501, 0x08010701, 0x0a010901, 0x696e7507, 0x32423030, 0x33200786, 
    0x39250786, 0x72754504, 0x330c836f, 0x39313232, 0x656e6f0b, 0x63617266, 0x6e6f6974, 0x6f77740b, 0x0d240b87, 0x65726874, 0x69281984, 0x0c6e6f74, 
    0x72756f66, 0x00201a87, 0x032c0083, 0x02000800, 0x01001100, 0x0300ffff, 0x01201082, 0x00220382, 0x05820100, 0x03820e20, 0x03821820, 0x1f820020, 
    0x11820120, 0x0382d720, 0x0f820420, 0x83000221, 0x24218300, 0xb0fec700, 0x2b0c83df, 0x248976bd, 0x00000000, 0xc42d6fc9, 0x2c56fa05, 0x00009529, 
};


```

`CSGOSimple/fonts/droid.hpp`:

```hpp
#pragma once
// File: 'droid.ttf' (190044 bytes)
// Exported using binary_to_compressed_c.cpp
//#include "droid.h"
static const unsigned int Droid_compressed_size = 134345;
static const unsigned int Droid_compressed_data[134348 / 4] =
{
	0x0000bc57, 0x00000000, 0x5ce60200, 0x00000400, 0x00010025, 0x82130000, 0x00042e04, 0x45444730, 0x03260046, 0x3d020087, 0x28158220, 0x4f50471e,
	0xa2bd9453, 0x300f82f0, 0xa8000040, 0x555347fa, 0x74916c42, 0xe602008f, 0x271f823c, 0x53544c20, 0xb99bc948, 0x10312b82, 0x0300001c, 0x2f534f86,
	0x95cba032, 0x0100008b, 0x3c1f82b8, 0x616d6360, 0xd411ce70, 0x560000a2, 0x07000078, 0x7476639e, 0x3e7e3920, 0x6800004c, 0x2c23820c, 0x677066fc,
	0x23d3736d, 0x5e0000b0, 0x281f8218, 0x73616705, 0x00040070, 0x206f8207, 0x083f8214, 0x6c670c28, 0x93c26679, 0x000051c6, 0x01001071, 0x64681ea8,
	0x0eef786d, 0x0000abfa, 0x0000a413, 0x6568d442, 0xc6eb6461, 0x4b82350a, 0x2f823c20, 0x82683621, 0x530c2210, 0x211b8209, 0x0f827401, 0x6d68242b,
	0xd7d27874, 0x0000272e, 0x2d5f8202, 0x6f6c040e, 0xfa926163, 0x00004c29, 0x6f82086a, 0x616d0628, 0x2a067078, 0x3f828502, 0x2f829820, 0x6e203208,
	0xb5656d61, 0x00569059, 0x00301902, 0x70a20600, 0xd874736f, 0x0027a950, 0x00d41f02, 0x703f1d00, 0x82706572, 0x001321dc, 0x00206500, 0x00ec0200,
	0x82358201, 0x1d5e2b03, 0x0f5fc1b5, 0x1900f53c, 0x00830008, 0x339ac122, 0x002c0683, 0x038c1bc6, 0xd5fd89fb, 0x62085a09, 0x06221082, 0x2f820200,
	0x33820283, 0xfe6d072d, 0x0900001d, 0xfe89fb64, 0x845a09a2, 0x86198349, 0x80032103, 0x03291183, 0x00a00082, 0x007a0016, 0x25398205, 0x002f0010,
	0x8a82005a, 0x00390123, 0x241d8203, 0x01990403, 0x23198290, 0x059a0508, 0x01216e82, 0x2507851e, 0x6600d003, 0x2782f201, 0x06060b30, 0x02040803,
	0x00e00402, 0x0040ef02, 0x5a825b20, 0x03822820, 0x41310025, 0x82004353, 0xfdff2f10, 0x14fe1f06, 0x6d078400, 0x0020e301, 0x1b839f01, 0x054a0423,
	0x260782b6, 0x04020020, 0x84c100cd, 0x00142311, 0x03830200, 0x9300273e, 0x85003703, 0x33002b05, 0x7b006804, 0x66009a06, 0x6d009e05, 0x8500cf01,
	0x52006802, 0x3d200382, 0x52201782, 0x66260382, 0x3f000002, 0x13829302, 0x93002526, 0x1400fc02, 0x62201382, 0xb2200382, 0x60200382, 0x17202386,
	0x83200782, 0x71200382, 0x5a200382, 0x6a200382, 0x02200383, 0x25222f83, 0x0b823f00, 0x03876620, 0x00680335, 0x00ee0625, 0x00dd046d, 0x00f80400,
	0x00d304c7, 0x8279057d, 0x00392807, 0x00ee03c7, 0x828505c7, 0x009c240f, 0x82b602c7, 0xff2b246f, 0x85a20448, 0xf6062117, 0xd5201b82, 0xf0230382,
	0x82047d00, 0xee05211f, 0xb8200782, 0x27303782, 0x27046800, 0x96051400, 0x8b04b800, 0x12070000, 0x60209f82, 0x37205b82, 0x50200382, 0x6d224382,
	0xb382a400, 0x6d021722, 0x4236e782, 0x4a032900, 0x9e04fcff, 0x3f048901, 0xb0045e00, 0xb403ae00, 0x07827100, 0x4804713a, 0xa2027100, 0x25041d00,
	0xb6042500, 0x1202ae00, 0x1202a000, 0xf803bcff, 0xae240b84, 0xae002b07, 0x04211783, 0x202f849e, 0x213383ae, 0x3f823103, 0x5a009c22, 0x2120ab82,
	0xa4261b82, 0x0000d503, 0x7f82f805, 0x23000028, 0x0a00e903, 0x7f828703, 0x3d00d528, 0xe9016804, 0x7f82d502, 0x66006822, 0x23077b41, 0xbc006804,
	0x44200382, 0x7b200382, 0x1d200382, 0x03232383, 0x827900e3, 0x06332b9b, 0x026400a8, 0x034400a6, 0x7f4100e5, 0x00932205, 0x26138352, 0xfaff0004,
	0x83006d03, 0x8266202f, 0x8231201f, 0x841f2003, 0x00c124cb, 0x823d05ae, 0x002526bf, 0x00a40193, 0x24178223, 0x00cd023f, 0x243f8242, 0x00e50554,
	0x2003823f, 0x2803822c, 0x0068031f, 0x00dd0444, 0x29039300, 0xfeffd106, 0x7d00d304, 0x8b413904, 0x82078705, 0x823e20db, 0x82522003, 0x82112003,
	0x05402503, 0x052f0079, 0x23068741, 0x7d00f005, 0xc782038b, 0x0f848d20, 0xb8009623, 0x21038a05, 0x73823704, 0x57829c20, 0xae00d126, 0x5e003f04,
	0x06290393, 0x035e00aa, 0x047100b4, 0x27038d48, 0xdeff1202, 0xae001202, 0xbd200782, 0xee240382, 0x6f009e04, 0x20088741, 0x8b2b829e, 0x00682203,
	0x201f8266, 0x201f8273, 0x27038ba4, 0x0a00e903, 0xae00b004, 0xff830784, 0x078f8383, 0x7f84fb82, 0xf7820796, 0x4382c720, 0x07827120, 0x07832f20,
	0x82390421, 0x9eab83cf, 0x85052707, 0x25047d00, 0x07982500, 0x47829c20, 0xae00b62e, 0x00009c05, 0x1200b604, 0xf5ffb602, 0xa324e782, 0x3d00b602,
	0xeb200782, 0x30200782, 0xde200782, 0x52240782, 0x44001202, 0xae240786, 0x5200e104, 0xa0245782, 0x48ff2b02, 0xbc261f82, 0xc700a204, 0xe382f803,
	0xee220383, 0x2b82c700, 0x8503ab21, 0x86662007, 0x84ae2007, 0x82662007, 0x00ee2223, 0x2233821d, 0x86d505f6, 0x22078f7b, 0x88ffff46, 0x82f0201b,
	0x009e23bf, 0x078e0571, 0x001f0724, 0xff83077d, 0x7782b820, 0xae003123, 0x20078504, 0x28078660, 0x00270472, 0x009c0368, 0x20079a5a, 0x20cb8214,
	0x8c1f8221, 0x96052707, 0xb604b800, 0x07a7a400, 0x0012072f, 0x00f80514, 0x00370414, 0x00e90300, 0x2707830a, 0x52005004, 0x52008703, 0x0221078f,
	0x23a7824c, 0x04cb0068, 0x2706fb41, 0xfeffd106, 0x5e00aa06, 0x7320db86, 0x9e23ab88, 0x83040201, 0x01752203, 0x2407821b, 0x00120221, 0x240782a0,
	0x007b016d, 0x2217841f, 0x82df009e, 0x82f82007, 0x04143203, 0x02e9ffdd, 0x04930025, 0x06e7ffc9, 0x03e7ff17, 0x240782b2, 0x05e7ff42, 0x26078254,
	0x02e7ff4a, 0x84e4ff9e, 0x44f8206f, 0x042705c7, 0x0425008b, 0x83c70039, 0x9c05219b, 0x2105cf44, 0xab82b602, 0x1382a220, 0x00008b22, 0x2307e744,
	0x52003f04, 0x05219783, 0x82178287, 0x42042327, 0x9f824e00, 0x0625e784, 0x04680023, 0x822b8260, 0x20238207, 0x203f824e, 0x30f78440, 0x037100b0,
	0x045a00a0, 0x02ae00b6, 0x04a4009e, 0x820382b8, 0xd1042213, 0x05fb4200, 0x6f009e22, 0x03231f83, 0x837100a4, 0x87042323, 0x27837100, 0x00f80329,
	0xff1704ae, 0x82c104f2, 0x00232207, 0x271f8400, 0x0571009e, 0x0419000a, 0x0f844782, 0x5b82b420, 0x12009822, 0x05215383, 0x283f8296, 0x05ecff31,
	0x06a400ec, 0x20438406, 0x826b8415, 0x83078333, 0x25e38313, 0x1400a005, 0xe345ee03, 0x20bb8205, 0x20a78268, 0x2a038252, 0xff2b0240, 0x00480748,
	0x82750700, 0x202382ff, 0x22fb8304, 0x841900ae, 0x44dd20eb, 0x2f41062b, 0x33052306, 0x4b830e00, 0x0085062b, 0x005c0404, 0x00d50548, 0x830383c9,
	0x5a052233, 0x052f4100, 0x41064741, 0xd322082b, 0x6f827d00, 0x82041421, 0x072b4153, 0x829a0521, 0x0048266b, 0x00fa07a6, 0x250383c7, 0x14003d05,
	0x5b419606, 0x00c12406, 0x821d083b, 0x82b8200b, 0x3f2008ef, 0x8f045e00, 0x89047500, 0x3303ae00, 0x6004ae00, 0x48042900, 0xc3057100, 0xae030400,
	0xe9044400, 0x03821382, 0xae26d782, 0x10005e04, 0x0f85be05, 0xfb830420, 0x0b82c120, 0x5346b020, 0x87033105, 0xe9032900, 0x93050a00, 0x00047100,
	0xd1042300, 0xac301b82, 0xf4069a00, 0x0407ae00, 0x6d05ae00, 0xfe052900, 0x67831382, 0x3700b224, 0x0b827906, 0x27823f20, 0x04236b82, 0x831200b6,
	0xb403277b, 0x9c037100, 0x8b465a00, 0x02ee2a06, 0x06bcff12, 0x06100083, 0x832b82e5, 0x41ee2023, 0x778206d7, 0xc7208f82, 0x0f433383, 0x43078f07,
	0x0023081f, 0x86085200, 0x4a032703, 0x6601fcff, 0x03831700, 0x00000223, 0x2407823f, 0x00e70219, 0x29038317, 0x3f008103, 0x7b00e303, 0x0382f803,
	0x96000236, 0x93006f06, 0x66005a09, 0x8500cf01, 0x85003703, 0x52004e02, 0x032f0383, 0x019300f6, 0x02a0fe0a, 0x046a00f8, 0x82600068, 0x06442403,
	0x82960000, 0x063f2c07, 0x048d0068, 0x07770000, 0x82c700e7, 0x05252ceb, 0x044e00f0, 0x066600f4, 0x8253000e, 0x82332003, 0x824f2003, 0x04712a03,
	0x046200a6, 0x0529008b, 0x322782ee, 0x044a000c, 0x04660068, 0x05250064, 0x037700a8, 0x84100019, 0x8713830f, 0x00aa2603, 0x00b4046d, 0x2a03841d,
	0x02cf009e, 0x04bcff12, 0x82870100, 0x826f2003, 0x027d2403, 0x822500a6, 0x820c2003, 0x863b2003, 0x472f200b, 0x2120062f, 0x00248f82, 0x00000008,
	0x02290787, 0x020000ab, 0x01000000, 0x20138255, 0x200b8268, 0x200b8225, 0x2010829a, 0x860382cd, 0x00082302, 0x03835400, 0x01376783, 0x04170066,
	0x040a00cd, 0x06000052, 0x061200a0, 0x07c700f6, 0x44ae002b, 0x422e0853, 0xaa02d3fe, 0x33037300, 0x56079300, 0x03831d00, 0x7d34f782, 0x7100aa04,
	0xb800f405, 0xa4002f05, 0x8ffc0000, 0x48fd0000, 0x46200782, 0x04200782, 0x31220382, 0xfb823904, 0xc900d53c, 0x71004804, 0xae00e904, 0x7d00db07,
	0x00006f06, 0x14002505, 0x1400dd04, 0x1f822707, 0xae00b622, 0x002a3f82, 0x0a006404, 0xc7002907, 0x0f821206, 0x1f827f20, 0x0f82f020, 0x0f828b20,
	0x8782a220, 0x39005e2e, 0x1700ae03, 0x68002306, 0xa400ec05, 0x9b427b84, 0x03002205, 0x21e382dd, 0x078400c1, 0x00640931, 0x0058087d, 0x003f0671,
	0x0019057d, 0x82b20771, 0x8250206f, 0x20778607, 0x07074704, 0x6800df24, 0x97827504, 0xf4009e26, 0xe1019e04, 0x07290383, 0x072900e9, 0x052900a6,
	0x201782e7, 0x327382fc, 0x042f009c, 0x04120089, 0x04c7009c, 0x03ae00b0, 0x822f00ee, 0x051222ff, 0x260f8200, 0x06ae0008, 0x820400e9, 0x0404248f,
	0x8248005c, 0x0544229b, 0x2017820a, 0x2037824a, 0x200782a2, 0x2607842b, 0x00f8032f, 0x82440512, 0x82d120cb, 0x00cd2457, 0x82fa04e5, 0x005c2837,
	0x00ac05e5, 0x824408ae, 0x82b820db, 0x00ec26eb, 0x00f2047d, 0x289b8871, 0x03140027, 0x04290087, 0x20d38237, 0x87db82d5, 0x82d32007, 0x003d280b,
	0x00890623, 0x828b0514, 0x0048274f, 0x00bc04a6, 0x0783059a, 0x0784ac20, 0x8204c721, 0x77062757, 0x1d053d00, 0x07873300, 0x00b60229, 0x00850652,
	0x82c30504, 0x824a2003, 0x822d209b, 0x826a2073, 0x0071244b, 0x829c0510, 0x82e92093, 0x82cb200f, 0x87f38207, 0x0607274b, 0xd105c700, 0x3b83ae00,
	0x46070342, 0x04200f5f, 0x21062348, 0xbb828f05, 0x66004822, 0x6b870787, 0x84071741, 0x00b82707, 0x00d5051b, 0x6b8304c9, 0x7b470787, 0x0ad3410e,
	0xb2033b2c, 0xae043700, 0xe9031900, 0x078f0a00, 0x1b44a387, 0x96062107, 0xfe20ab82, 0x21099f41, 0xdb82c304, 0x23002f24, 0x07826004, 0x07820020,
	0x89009c2c, 0x7100b004, 0x8900f406, 0x0782fe06, 0x00fc2e08, 0x0046064e, 0x00c50450, 0x0010044e, 0x00a40750, 0x00a40600, 0x00e50710, 0x002f07c7,
	0x00c305ae, 0x00e1047d, 0x00810571, 0x00120514, 0x26bf8229, 0x00ae036f, 0x825a055c, 0x005e224f, 0x0f0f4110, 0x12200f8e, 0x5e200f8e, 0x7b490fb0,
	0x3904271e, 0x48042700, 0xab491200, 0xb6022717, 0x12025200, 0x07866200, 0xe3489e20, 0x200f8e0f, 0x490f8e33, 0xaa200d13, 0x9b062349, 0x0fdb4807,
	0x44060f44, 0x07970717, 0x4808bb45, 0x03200ae3, 0x2805d34a, 0xfb000071, 0xfc0000db, 0x2007826a, 0x21078589, 0x078264fc, 0x038a7320, 0xa4016426,
	0x10003100, 0x002d0182, 0x01018203, 0x18281a01, 0x010a0101, 0x2504822b, 0x1401160b, 0x00880b05, 0x82141421, 0x1c3d080a, 0x1422260b, 0x0b12010b,
	0x15151915, 0x22191c14, 0x1b161e13, 0x1017151b, 0x01122610, 0x01200105, 0x1c0b1101, 0x192a150b, 0x0a0c0c2e, 0x152e180c, 0x2a120b0b, 0x0b192e0b,
	0x1912161a, 0x20068218, 0x2e448228, 0x0115180b, 0x0b271404, 0x10010401, 0x8211110b, 0x0114294d, 0x01270a11, 0x261c0a01, 0x01210084, 0x21898214,
	0x00821901, 0x22190b22, 0x0b220083, 0x00821522, 0x16132623, 0x21008411, 0x0d821c16, 0x820c1521, 0x2e152100, 0x15230983, 0x822e150b, 0x0b162400,
	0x83112616, 0x1c142101, 0x6b830185, 0x87150121, 0x190b2101, 0x33820185, 0x0c192e22, 0x15280187, 0x150c1517, 0x0c140a0a, 0x24240184, 0x2e190c14,
	0x18240183, 0x15222e19, 0x2a230183, 0x83121628, 0x2a1b2101, 0x0b210186, 0x8301821b, 0x25038743, 0x16260b10, 0x00841226, 0x260b302c, 0x22160111,
	0x012a1b15, 0xc3832401, 0x5b080383, 0x2d151426, 0x150d150c, 0x19222616, 0x15120117, 0x19151922, 0x2211191c, 0x1b201315, 0x19101926, 0x0b261922,
	0x12162e16, 0x15160c0b, 0x172e1616, 0x122d0a16, 0x18151818, 0x01181813, 0x13131912, 0x15121618, 0x0e011812, 0x191b1419, 0x19281519, 0x1530150e,
	0x19221326, 0x1218011f, 0x10211082, 0x08a7821c, 0x1b141327, 0x15101930, 0x17191914, 0x24161910, 0x19141116, 0x19151614, 0x0a19191a, 0x15191316,
	0x191c0b12, 0x161a1916, 0x361f8212, 0x19111918, 0x142e1511, 0x0c0c2a1c, 0x2e18180c, 0x1712160a, 0x830b1001, 0x16262101, 0x1523af83, 0x82151915,
	0x82192003, 0x2b143100, 0x0c191918, 0x0b0b1901, 0x01010b11, 0x0122192a, 0x0c293382, 0x2b1e1726, 0x17170101, 0x2200820b, 0x82141419, 0x01012220,
	0x85008511, 0x852e20f3, 0x01012a06, 0x1611150c, 0x26181c18, 0x22108211, 0x82221414, 0x2c1985f7, 0x1d191519, 0x01262017, 0x18181c01, 0x28938216,
	0x191a0114, 0x18152213, 0x2a018216, 0x19151401, 0x14181d01, 0x82240d1c, 0x012e282c, 0x17011916, 0x82120b13, 0x19192515, 0x01151a12, 0x0a229d82,
	0x9782180b, 0x192e1929, 0x1c141312, 0x8226191b, 0x19193301, 0x1613152a, 0x18191214, 0x160a160a, 0x20191819, 0x32821818, 0x14191823, 0x21cb8212,
	0x82821126, 0x82011621, 0x151522d6, 0x21458218, 0xdc821112, 0xe0411920, 0x11162305, 0x01831630, 0x142c3b82, 0x14121810, 0x1a100116, 0x15170b13,
	0x16236282, 0x82271817, 0x171324aa, 0x42101a12, 0x6042065a, 0x42058b05, 0x09850960, 0x190c1923, 0x9159850c, 0x2e152505, 0x1c192e15, 0x26210187,
	0x20018316, 0x0512410b, 0x00200585, 0x13350083, 0x84030000, 0x00040706, 0x02020203, 0x04050304, 0x03020201, 0x820b8203, 0x86032005, 0x20118300,
	0x271a8203, 0x03040404, 0x02040403, 0x05201a82, 0x0d850b82, 0x84030521, 0x0203212e, 0x03211982, 0x82068304, 0x8402201f, 0x0302231f, 0x15830402,
	0x0a821482, 0x05205087, 0x02200882, 0x38823583, 0x02040423, 0x83398401, 0x21528327, 0x15820405, 0x60847e84, 0x68886282, 0x37850884, 0x00820220,
	0x3f871f8d, 0x84820782, 0xbd860d85, 0x158b0682, 0x02863a82, 0x93847c82, 0xa1859b82, 0xba845285, 0x05228b84, 0x01830204, 0x28844788, 0x05852485,
	0x1f84ad85, 0x04030224, 0x3a820503, 0x4e820c84, 0x82030121, 0x263d8200, 0x04050305, 0x83040205, 0x82032081, 0x04032270, 0x239c8705, 0x04060306,
	0x24823583, 0xf1851e8a, 0x28824c82, 0x02060522, 0x06226782, 0x0e820503, 0x0621b382, 0x82088206, 0x83408210, 0x85068212, 0x040325aa, 0x04040306,
	0x06201d82, 0x04200582, 0xd5820082, 0x11820420, 0x42820320, 0x87820d82, 0x06820520, 0x04060624, 0x72820305, 0x74820320, 0x4d820320, 0x04050523,
	0x20578303, 0x84258205, 0x060627c7, 0x02010102, 0x3d820201, 0x06020323, 0x22088207, 0x82010302, 0x0305240c, 0x82060305, 0x82052041, 0x847d8400,
	0x223b8241, 0x42030404, 0x03200a24, 0x0223cf82, 0x82030102, 0x00002244, 0x204b8206, 0x83358204, 0x02022136, 0x38827a82, 0x00830020, 0x04207182,
	0x3c824c84, 0x0b828182, 0x5c840320, 0x0321af82, 0x21188207, 0x04820506, 0xb4822482, 0x82060621, 0x82032023, 0x04022503, 0x03050503, 0x0f821485,
	0x00820420, 0x18822482, 0x82056b41, 0x8311821d, 0x20ca8302, 0x82728202, 0x2211852a, 0x84020505, 0x833d8417, 0x41318327, 0x2a420ac0, 0x25638405,
	0x02030506, 0x9e840304, 0x05050622, 0xb584bb83, 0xe7840520, 0x0a8b328a, 0x05897f85, 0x960a9642, 0x85168731, 0x00042133, 0x012e0087, 0x09070101,
	0x02040004, 0x04050302, 0x48820506, 0x82040421, 0x83ed8604, 0x83022035, 0x410320c9, 0x0523063a, 0x41020405, 0xed82055e, 0x05050426, 0x04040406,
	0x41066c43, 0x3c8205f8, 0x06020423, 0x20008204, 0x23d68203, 0x04040604, 0x02200682, 0x13841583, 0x02060423, 0x2e1f8303, 0x03030403, 0x02050404,
	0x03020301, 0x83050505, 0x84068203, 0x83042037, 0x85052000, 0x41618200, 0x158406fb, 0x96840620, 0x4b42ec93, 0x076d4305, 0x07410d83, 0x851b8509,
	0x05574305, 0x05200583, 0x7f439385, 0x85058305, 0x86052020, 0x06042206, 0x08bb4306, 0x8205ac41, 0x020421c4, 0x21824b8b, 0x1c846482, 0x05040222,
	0x05213082, 0x05614304, 0x01040223, 0x21008204, 0xbe840205, 0x05020624, 0x1a820304, 0x04225982, 0x40820605, 0x04230b82, 0x42040604, 0x8a820549,
	0x00820420, 0x04030322, 0x07820985, 0x1f827784, 0x82020621, 0x04062118, 0x22057a43, 0x86070702, 0x82032043, 0x8358826a, 0x8605204b, 0x0505294a,
	0x06050808, 0x04070404, 0x41820082, 0x83430620, 0x206a820b, 0x05a34304, 0x04060324, 0x34450404, 0x06062405, 0x82040304, 0x8406200b, 0x26168200,
	0x01030707, 0x42010201, 0x0627051e, 0x02030208, 0x82010302, 0x206c8322, 0x20678207, 0x83008205, 0x86042075, 0x8204208f, 0x82022000, 0x20308503,
	0x2b7a8203, 0x01020207, 0x01010204, 0x07070000, 0x04230982, 0x82060606, 0x030221ec, 0x04210684, 0x21008300, 0x89840504, 0x05060423, 0x22038205,
	0x86070406, 0x2127820f, 0x0c820904, 0x06203282, 0x20054241, 0x87ee8404, 0x221485ce, 0x41030403, 0x0720057e, 0x26822782, 0x1e830320, 0x82040421,
	0x8457820d, 0x05844150, 0x8508c141, 0x85ea8208, 0x4145841f, 0x688609c0, 0x03201b82, 0x0d87a382, 0x5382b584, 0xa9410720, 0x89718605, 0x85098935,
	0x20058a7d, 0x0d1e4202, 0x13853393, 0x00203386, 0x01260087, 0x0a080101, 0x83430005, 0x06072705, 0x04020202, 0x9c460204, 0x202a8605, 0x83118202,
	0x050524e9, 0x82040405, 0x050226d0, 0x06060804, 0x82a38205, 0x8208200d, 0x412e8255, 0x0322071d, 0x2e820504, 0x82080221, 0x0305212b, 0x06221483,
	0xdd820404, 0xef420320, 0x220b8205, 0x82030705, 0x84072010, 0x822482f1, 0x8203202c, 0x83062045, 0x06062303, 0x85460706, 0x820d8209, 0x41178502,
	0x3d8205fb, 0x03820720, 0x4b820420, 0x43020221, 0x05210da3, 0x82418204, 0x43f68803, 0x1b860bb8, 0xb3832182, 0x86040221, 0x82052001, 0x82052047,
	0x2010884f, 0x821e8206, 0x24068603, 0x05070705, 0x41018303, 0x03200864, 0x0320b482, 0x07831d87, 0x04060824, 0x72850404, 0x64820220, 0x06070722,
	0x23052543, 0x01050205, 0x05228082, 0x51850206, 0x17820220, 0x05040623, 0x82038306, 0x06062233, 0x20278205, 0x200f8306, 0x203d8204, 0x202a8202,
	0x21388404, 0x07850402, 0xae825284, 0x05213f82, 0x83078205, 0x02042315, 0x37820808, 0x06233b84, 0x82040804, 0x08062208, 0x840e8406, 0x231d8264,
	0x08050507, 0x05243a82, 0x06040403, 0x8208a343, 0x430d8458, 0x1e8308a3, 0x43020221, 0x042306d1, 0x83060803, 0x21c78201, 0x83430808, 0x280b8206,
	0x02090603, 0x04020203, 0x824a8401, 0x8267826e, 0x82b2836b, 0x8206204f, 0x82042015, 0x06664660, 0x02832f82, 0x0804083b, 0x04010203, 0x00010202,
	0x02080800, 0x07040501, 0x04060808, 0x07030306, 0x21388207, 0x00830005, 0x08318a83, 0x07050506, 0x07040606, 0x08060605, 0x06040407, 0x261e8206,
	0x0a040604, 0x83050608, 0x22fd848b, 0x82080505, 0x8205200e, 0x03042500, 0x06080405, 0x69416f82, 0x22ec8505, 0x42060706, 0x67820729, 0x28820c82,
	0x82070521, 0x432a8201, 0x0620058c, 0x36821182, 0x58820620, 0x04070722, 0xc5830582, 0x00820420, 0x4209c041, 0x0423092c, 0x42060703, 0x052906c1,
	0x06060807, 0x07080404, 0x82558409, 0x42052039, 0x0591055a, 0x89138343, 0x85099b5d, 0x05124139, 0x00820020, 0x02020234, 0x00050c09, 0x04020205,
	0x06080506, 0x06030302, 0x9c460205, 0x06e74205, 0x82020221, 0x20dc8308, 0x82d88205, 0x050321a0, 0xf0830c82, 0x0620ed82, 0x0522b182, 0x12820303,
	0x05202383, 0x0520d682, 0x02212e82, 0x200d8208, 0x21698205, 0x32820505, 0x0320dd82, 0x13841583, 0x04070527, 0x07030505, 0x056d4205, 0x02020628,
	0x07050404, 0x6b430807, 0x84062005, 0x82388337, 0x8307200f, 0x07052200, 0x86008306, 0x08052189, 0x2005fa41, 0x08834302, 0x05201887, 0x0145f285,
	0x88062009, 0x41838319, 0x07470910, 0x04062209, 0x43d88403, 0x03220583, 0x83430204, 0x23db8308, 0x08090507, 0x820dc844, 0x0cc241ce, 0x44050621,
	0x03490689, 0x200e8205, 0x072f4608, 0x83050221, 0x06052859, 0x05070602, 0x82080708, 0x279f8259, 0x04070605, 0x06080605, 0x0521d282, 0x22ef8405,
	0x43060407, 0x10820683, 0x85050421, 0x43238234, 0x06210583, 0x05834306, 0x05273a83, 0x09030404, 0x82050609, 0x83052013, 0x820820cf, 0x07052509,
	0x06070608, 0x06274a86, 0x07070808, 0x41090505, 0x05220563, 0x08830406, 0x0d840620, 0x40840420, 0x2c820820, 0x07040522, 0x24059b44, 0x08020202,
	0x820a8208, 0x0583433c, 0x09222982, 0x5f480409, 0x06033408, 0x0304020b, 0x04010403, 0x05080505, 0x08090507, 0x82080607, 0x217f8500, 0x5c840307,
	0x04060623, 0x09ea4402, 0x05090525, 0x82020309, 0x010227f8, 0x09090000, 0xaa820202, 0x06080829, 0x04030705, 0x82070909, 0x83002082, 0x28078200,
	0x06070805, 0x06060805, 0x82078206, 0x04052303, 0x1e830606, 0x0c050622, 0x08232682, 0x82070807, 0x205682fd, 0x85ee8305, 0x208382a2, 0x84268206,
	0x0606240c, 0x84060506, 0x055c448f, 0x82040621, 0x0707214c, 0xca831584, 0x82080421, 0x824f850a, 0x05764518, 0x05080822, 0x0720c382, 0x5a827482,
	0x82060421, 0x05e0413f, 0x2407ac43, 0x04050506, 0x82768407, 0x82052009, 0x050726e6, 0x09070a05, 0x82298308, 0x065a4219, 0x42115343, 0x0a840a61,
	0x04020423, 0x91598502, 0x823d9105, 0x8700206b, 0x02022f00, 0x060c0a02, 0x02030500, 0x08060604, 0x83430207, 0x89042006, 0x02022161, 0x21058343,
	0x83430606, 0x03042117, 0xe182cf83, 0x20158343, 0x21168204, 0x50850203, 0x04080626, 0x08030505, 0x04211182, 0x43988204, 0x07220683, 0x00840604,
	0x36420920, 0x201b8206, 0x33834306, 0x2008ac44, 0x22834305, 0x9382f282, 0x20069443, 0x07834304, 0x05060722, 0x23368343, 0x05070809, 0x22055c43,
	0x84020603, 0x088343ce, 0x0520e982, 0x220e8343, 0x43080608, 0x07222683, 0x83430605, 0x20088205, 0x82008206, 0x0a83430e, 0x0820f282, 0x0a221482,
	0x0682070a, 0x83430a20, 0x0707241a, 0x43080405, 0x0a211983, 0x0a83430a, 0x430c0921, 0x08230a83, 0x43070905, 0x07230783, 0x43050606, 0x06200883,
	0x2d0b8343, 0x030a050a, 0x03060203, 0x00000102, 0x83430a0a, 0x43082008, 0x0a201083, 0x09204382, 0x08230383, 0x830a0608, 0x07834393, 0x0a210c82,
	0x421d8208, 0x0a23050b, 0x8205060a, 0x0505256c, 0x08050604, 0x2a0c8343, 0x080a0607, 0x04060607, 0x83060404, 0x08052101, 0x201e8343, 0x16834309,
	0x2205a143, 0x82060506, 0x07082163, 0x83436783, 0x0908210a, 0x07211282, 0x68834305, 0x070e0b30, 0x03030600, 0x09060705, 0x03030308, 0x9b4e0606,
	0x86062005, 0x34118300, 0x070a0506, 0x06080707, 0x03080805, 0x0a050703, 0x09060908, 0x240d8207, 0x07060907, 0x822e8207, 0x830620c9, 0x06042803,
	0x05020206, 0x82060a02, 0x47042000, 0x08830727, 0xe3824484, 0x04090627, 0x09040605, 0x27048206, 0x07060604, 0x04040203, 0x08225382, 0x00840705,
	0x06070922, 0x03200082, 0x08220082, 0x00830908, 0x08090622, 0x15840082, 0x06221882, 0x0583050a, 0x00820220, 0x06889b86, 0x84060721, 0x063f4301,
	0x08060822, 0x06201988, 0xed450b82, 0x4d058305, 0x072709fe, 0x07020305, 0x82050505, 0x220382ae, 0x86020503, 0x06082124, 0x0382db82, 0x070a0a23,
	0x44018304, 0x052007c2, 0x0521c682, 0x82498904, 0x82082027, 0x05b04373, 0x7e820220, 0x090a0923, 0x222c8206, 0x43060606, 0x07290683, 0x04090703,
	0x04090809, 0x289b8407, 0x07030908, 0x05080a07, 0x219b8209, 0x64820705, 0x2f820f82, 0x20057242, 0x05aa4a05, 0x08204083, 0x68827184, 0x06040822,
	0x072bbc85, 0x03030306, 0x07080a0a, 0x84070806, 0x0609224b, 0x21098208, 0x4a82080a, 0x82050721, 0x080829ab, 0x09080b0b, 0x070c0707, 0x04203182,
	0x05202682, 0x07204883, 0x2005b143, 0x05a34306, 0x06080828, 0x06060905, 0xf2820406, 0x82020221, 0x820520ab, 0x09042123, 0x09204382, 0x06235882,
	0x47050b0b, 0x052c0607, 0x0d090505, 0x03030503, 0x06040106, 0x09265c82, 0x09090b06, 0x00820907, 0x83070621, 0x25968429, 0x06060706, 0x03820206,
	0x00850420, 0x060b0624, 0x8343040b, 0x0b0b2e07, 0x07070202, 0x070a0a08, 0x04040906, 0x226b820a, 0x83000708, 0x208a8300, 0x23b9840b, 0x080a0607,
	0x93822183, 0x82090821, 0x06082416, 0x82090b0e, 0x201d8268, 0x21558205, 0xd0820606, 0x052b0784, 0x09060704, 0x07050608, 0x82050706, 0x08072d01,
	0x0b070906, 0x0707090a, 0x07060505, 0x0a218584, 0x82498209, 0x21a38242, 0x0b820307, 0xa5411482, 0x070a2205, 0x21218303, 0xc5850a09, 0xee4a4583,
	0x05e04105, 0x8206d244, 0x04062339, 0x67830809, 0x00820620, 0x090a0928, 0x0a060609, 0x2e820b09, 0x84070821, 0x20678477, 0x42059007, 0x0a840a61,
	0x03020323, 0x91598502, 0x20908405, 0x84a78207, 0x214b8503, 0x07470006, 0x0f0c210a, 0x2b058343, 0x080a0708, 0x07040403, 0x03040307, 0x07200582,
	0x03210086, 0x43088203, 0x06230683, 0x82040808, 0x090b21d8, 0x0720f083, 0x0b205082, 0x04281b82, 0x05060404, 0x06070707, 0x06253982, 0x06030307,
	0x28158303, 0x04060407, 0x06090507, 0x20068205, 0x84158204, 0x0706274d, 0x0706040a, 0x2f820a04, 0x07040426, 0x02030807, 0x09233b82, 0x84050909,
	0x0a07231d, 0x00820607, 0x04204f82, 0x82058243, 0x82082065, 0x821c8500, 0x060b2105, 0x4b820482, 0x15889284, 0x84059c41, 0x0628410e, 0x3341ec83,
	0x08374309, 0xd982af82, 0x0382dd83, 0x82060721, 0x826d8245, 0x030625ae, 0x03060406, 0x07236c82, 0x85080709, 0x07092306, 0x83430b0b, 0x087c4105,
	0x0f830420, 0x83074641, 0x090b2107, 0x1e857982, 0x7d820320, 0x0f820a20, 0x09820d82, 0x02070322, 0x03238d84, 0x82060907, 0x088343dc, 0x23820882,
	0x83080921, 0x4366821c, 0x1482059c, 0x06244682, 0x04070705, 0x06210482, 0x20a48206, 0x83108206, 0x821a8339, 0x82062007, 0x0304221a, 0x823a820b,
	0x0707211b, 0x82056e42, 0x080b21a9, 0x08294a87, 0x080b0b08, 0x0c07070a, 0x21008207, 0x76820605, 0xcc822682, 0x06230d82, 0x82090505, 0x221f8240,
	0x82060709, 0x05072222, 0x20f88206, 0x83dd8203, 0x0b05226d, 0x82018309, 0x0c0c2114, 0x2f0b8343, 0x0405030f, 0x04020604, 0x070a0707, 0x0a0d060a,
	0x25058343, 0x08080707, 0xac410707, 0x07072207, 0x0a834303, 0x0c060c2d, 0x07020304, 0x00010203, 0x820c0c00, 0x09072109, 0x07246382, 0x0b050409,
	0x0922b882, 0x00830008, 0x07090623, 0x840d8207, 0x0a0a2303, 0x03820707, 0x0909062b, 0x05080709, 0x0d0e0508, 0x20178209, 0x21a5820b, 0x00820706,
	0x09820c20, 0x07200682, 0x0723a582, 0x8207090a, 0x060721f4, 0x07260582, 0x08090708, 0x11830b0c, 0x70450720, 0x0a062205, 0x82408208, 0x080a2617,
	0x0904080a, 0x09a14109, 0x04090b23, 0x24008207, 0x07060b0a, 0x20018309, 0x84418309, 0x430f8409, 0x052106d5, 0x21638208, 0x6782090a, 0x9e825f82,
	0x0b215b84, 0x827f830a, 0x080621ad, 0x8e096642, 0x0f944309, 0x04030422, 0x89064342, 0x20098763, 0x44b78408, 0x614705f0, 0x20bd8205, 0x2e008700,
	0x0d020202, 0x07000810, 0x08050403, 0x43090b07, 0x14430783, 0x05f24206, 0x06230582, 0x8208080b, 0x09062beb, 0x08030509, 0x0a090b06, 0x9d820a07,
	0x0b070922, 0x04231b82, 0x82070405, 0x8208203c, 0x070426af, 0x06030308, 0x2a2c8303, 0x04060508, 0x070a0608, 0x82050606, 0x06d4436f, 0x0b08062c,
	0x04070605, 0x0706070b, 0x50820505, 0x05030328, 0x0a0a0605, 0x5d82060a, 0x0b220282, 0x00820708, 0x00820520, 0x82090921, 0x820a2015, 0x82092065,
	0x07072100, 0x07211784, 0x09834307, 0xda822f85, 0x06210883, 0x827a8208, 0x4307200b, 0xec83076d, 0x41093141, 0x08220812, 0x67510809, 0x22058305,
	0x82030608, 0x060621c9, 0x82098343, 0x2238821e, 0x840a0809, 0x0c0c2301, 0x01830508, 0x410d8343, 0x07830746, 0xdc820b20, 0x1e850720, 0xa1820420,
	0x0a0b0b26, 0x08060708, 0x03228782, 0x96830208, 0x08030829, 0x090a060a, 0x8408040a, 0x0a0929be, 0x0b080805, 0x090a0709, 0xda829a83, 0x07050a22,
	0x0420b082, 0xc0822a82, 0x08080624, 0x45820604, 0x0e850620, 0x1f820820, 0x82040b21, 0x070b220b, 0x2615820a, 0x0c030505, 0x82080a0c, 0x080821a1,
	0x0b220e82, 0x80820907, 0x82090b21, 0x2a0e824a, 0x0909070a, 0x0b090d0d, 0x820d0808, 0x05072b0d, 0x06090707, 0x07060808, 0x00820809, 0x06050624,
	0xa3430709, 0x0b062406, 0x43080707, 0x08270783, 0x06080606, 0x830a0b05, 0x23c48201, 0x02050d0d, 0x2108674f, 0x83431009, 0x834a8205, 0x0a0d247f,
	0x820a080a, 0x82082000, 0x0c834352, 0x3f06ac41, 0x07050505, 0x040d070d, 0x03070203, 0x00000103, 0x02030d0d, 0x0b0b0708, 0x0a07080b, 0x0b0b0504,
	0x09213d82, 0x2c008300, 0x08070907, 0x08080a0d, 0x0708090c, 0x25bc820c, 0x06070a0c, 0x10820a0a, 0x06080625, 0x820a0e0f, 0x281d821b, 0x08070806,
	0x0c0d0808, 0x05d1410a, 0x49820520, 0x83070921, 0x057c4414, 0x090a0824, 0x33820b0d, 0x05070622, 0x0624b682, 0x090b0707, 0x25059441, 0x090b090b,
	0xf4820b05, 0xa6820920, 0x0e821283, 0x0b244283, 0x0a07070b, 0x0b200182, 0x07204582, 0xe0411a84, 0x092c4205, 0x0b050724, 0x6782060a, 0x07070725,
	0x820c0b08, 0x0d0723ae, 0xa3820d0b, 0x07080923, 0x05df4306, 0x8909d843, 0x0e924309, 0x03050724, 0x59850305, 0x8e830591, 0x87090a21, 0x22b78401,
	0x87000806, 0x03033800, 0x08110e03, 0x04040700, 0x0c080906, 0x0404030a, 0x05040808, 0x88080504, 0x26118300, 0x090c0608, 0x820a0809, 0x050a28cc,
	0x0c070803, 0x48080b0a, 0x0d200553, 0x04239382, 0x43070405, 0x08280504, 0x04080704, 0x0d040704, 0x05213c83, 0x20d68207, 0x83a9820a, 0x82042008,
	0x08082156, 0x0c25e382, 0x05080705, 0x2e2f820c, 0x08080505, 0x05030409, 0x0a0a0705, 0x8409060a, 0x430c2000, 0x0a220883, 0x00830b0a, 0x820b0821,
	0x070a211c, 0x48823983, 0x820c0721, 0x209e8209, 0x884d8504, 0x080722a1, 0x05674307, 0x21072041, 0xc041080a, 0x82188205, 0x070a2112, 0x15820186,
	0x23096751, 0x04030808, 0xae826e83, 0x07040725, 0x41040705, 0x0a200639, 0xdd83d982, 0x430d0c21, 0x6b410683, 0x21c68207, 0x5e410507, 0x0a0d210b,
	0x72851a82, 0x09080428, 0x0b0c0c07, 0xa0850708, 0x08030822, 0x09290082, 0x060b0804, 0x040b090b, 0x279d8309, 0x050b0a08, 0x0a0c0908, 0x0820d282,
	0x62822782, 0x07050b22, 0x04203d82, 0x07822982, 0xd7820620, 0x07820720, 0x49080721, 0x8343055a, 0x0d0d2610, 0x0a08080a, 0x25688209, 0x080b0709,
	0x4b830a0a, 0x12820b20, 0x0b080722, 0x0d261682, 0x090c090d, 0x4f820f08, 0x2382b582, 0x09820820, 0x06821c82, 0x43070521, 0x09220583, 0x3782080b,
	0x05080829, 0x04040707, 0x820c0c04, 0x07082483, 0x830a0d06, 0x07072601, 0x060e0e07, 0x36008203, 0x07060606, 0x110c0607, 0x04040603, 0x08050207,
	0x0b080c08, 0x820a0e07, 0x0b0b24c5, 0x8209080b, 0x0a08217f, 0x57821582, 0xb0840820, 0xe64f0720, 0x07053605, 0x050e070e, 0x04080204, 0x00000103,
	0x03040e0e, 0x0c0b0808, 0x23a9820d, 0x0d0d0605, 0x8343eb82, 0x080a3006, 0x090b0d08, 0x090a0d08, 0x090a0c07, 0x820c0d09, 0x820a2093, 0x09072557,
	0x0b0f1107, 0x0d221b82, 0x3b44080b, 0x0d0e2105, 0x0826be84, 0x08090507, 0x14840a0b, 0x05830720, 0x0d820a20, 0x830c0f21, 0x05072211, 0x83008207,
	0x20498240, 0x43178208, 0x09210583, 0x05454508, 0x0c080926, 0x0709050a, 0x0c236882, 0x830b0807, 0x08092101, 0x84062d47, 0x8308200d, 0x059f460d,
	0x0c050725, 0x8405070b, 0x0c08300f, 0x080b0c0c, 0x0e0c0d07, 0x0a080a0c, 0x41070809, 0xd9460570, 0x07092111, 0x84085a4a, 0x08072538, 0x04050405,
	0x05915985, 0x08204b82, 0x83057248, 0x05514205, 0x300c8343, 0x0009120f, 0x07040408, 0x0b0c080a, 0x08050504, 0x464c8208, 0x08200698, 0x04210082,
	0x2f048204, 0x0a0a0d06, 0x08080a09, 0x04060b0a, 0x0b0d0709, 0x56824a84, 0x08090e28, 0x05060508, 0xab840608, 0x2a820820, 0x042b4882, 0x0909080d,
	0x05070609, 0x430b0708, 0x09200e83, 0x82058343, 0x05052eb6, 0x040a0809, 0x07050503, 0x060b0b0b, 0x2000840a, 0x05ba450d, 0x06060623, 0x8214820a,
	0x84082002, 0x204d8206, 0x20008408, 0x0883430d, 0x09206e82, 0x08200082, 0x07213084, 0x22bb8209, 0x4a0a080a, 0xaa820847, 0x34841884, 0x37430820,
	0x080b2307, 0xb551080b, 0x09042108, 0x0920f282, 0x83439d82, 0x05394108, 0x06820a20, 0xdd830920, 0x4b0e0d21, 0x304105d6, 0x07072105, 0x41059143,
	0x0e210b5e, 0x41c6820b, 0x04200580, 0x0d266482, 0x07090b0d, 0x99820907, 0x03090422, 0x092a9b82, 0x0c09040a, 0x0c0a0c07, 0x81830a04, 0x0623ca82,
	0x820d0a09, 0x830b2040, 0x2962829b, 0x0908060b, 0x08040807, 0xc0820909, 0x09080728, 0x08070704, 0x39820708, 0x08220e82, 0x3882080b, 0x0c20de82,
	0x092a0982, 0x04060607, 0x090b0f0e, 0xd9820b09, 0x080a0823, 0x244c820c, 0x0b0d0b09, 0x2212820b, 0x820b0908, 0x0e0e2616, 0x090a0d0a, 0x247c8210,
	0x08080608, 0x8348830b, 0x21608238, 0x0d830707, 0x0a0d0d2a, 0x0c07080b, 0x06080808, 0x20058343, 0x0583430d, 0x830b0e21, 0x21c48201, 0x83430f0f,
	0x82082007, 0x04122227, 0x08834307, 0x0f080c23, 0x0583430c, 0x0b0a0923, 0x205c8209, 0x82458206, 0x090922b4, 0x43088204, 0x08330683, 0x050f080f,
	0x04080304, 0x00000203, 0x03040f0f, 0x820c0809, 0x0c082573, 0x0e0e0605, 0x83433d82, 0x0b082205, 0x2e4c8208, 0x0b0d090a, 0x0a0d080a, 0x0c0e090a,
	0x820b0708, 0x07092b54, 0x10120709, 0x0c0d090b, 0x0b820c0f, 0x0f225c83, 0x63840b0e, 0x0a060824, 0xba820c08, 0xca820920, 0x0a070928, 0x0c080b09,
	0x3f82100a, 0x41070921, 0x09210579, 0x05994207, 0x09261782, 0x0c06090c, 0x70430a0b, 0x82082005, 0x820b2061, 0x2106823b, 0x1284080d, 0x6e824583,
	0x09200b83, 0x57439183, 0x080a2507, 0x0b0d0608, 0x2506c142, 0x0e0e0e09, 0xa482090c, 0x0a20f384, 0xd5462f83, 0x46118511, 0x08860802, 0x06040623,
	0x09674304, 0x0820098e, 0x83075642, 0x20b98617, 0x0a074700, 0x0a141022, 0x2a058343, 0x040b0d09, 0x09090505, 0x46040504, 0x09200698, 0x04210082,
	0x25048204, 0x0b0b0e07, 0xcc820b0a, 0x04060b26, 0x0c0e0809, 0x0a204a82, 0x0a270d82, 0x0908090e, 0x82050605, 0x820920cf, 0x04092809, 0x04040908,
	0x820e0408, 0x06092731, 0x08090507, 0xe182080c, 0x82060921, 0x82128315, 0x060d2122, 0x0d323082, 0x06090708, 0x0a090906, 0x06060304, 0x0c0c0c08,
	0x00840b07, 0x080a0e22, 0x06200082, 0x0b210082, 0x2010840c, 0x22058409, 0x840a0908, 0x0e09223d, 0x21908508, 0x0f850404, 0x08210586, 0x06644409,
	0x21086d43, 0x9f480b09, 0x43058405, 0x15820837, 0x21098343, 0x4582080a, 0xae826d82, 0x08040827, 0x0c040806, 0x21018309, 0x25820c0b, 0x0924dd82,
	0x060a0f0e, 0x7c480183, 0x08052108, 0x5a410182, 0x0c0e210b, 0x61843e82, 0x82050821, 0x0e0e2134, 0x07207482, 0x8343a084, 0x040b3405, 0x0d070c0a,
	0x0b050d0b, 0x080a080b, 0x060b0b09, 0x820e0a09, 0x090b305e, 0x0d080809, 0x060b0d09, 0x09070908, 0x82090905, 0x0707261c, 0x08050909, 0x20188208,
	0x05eb4609, 0x0c080b29, 0x0909050c, 0x83080c09, 0x0606283c, 0x0b0f0f04, 0x820b0a09, 0x224b827f, 0x820c090e, 0x0b0e2147, 0x0a2e0e82, 0x090d0a08,
	0x10100a0b, 0x0a0a0d0b, 0x31820a10, 0x09090625, 0x8209070b, 0x090b2197, 0xbe820082, 0x09080b25, 0x820e0e09, 0x0d0821d8, 0x06271082, 0x04040708,
	0x830e0e04, 0x0608236a, 0x01830c0e, 0x08080825, 0x47071010, 0x082a0607, 0x140c0708, 0x05050704, 0x4a820208, 0x0d090d28, 0x0b0d1008, 0x00820c0a,
	0x0b0a0923, 0x825c820a, 0x23478215, 0x040a0909, 0x06203782, 0x082e0085, 0x05100810, 0x04090304, 0x00000203, 0x09821010, 0x820c0921, 0x0d092173,
	0x21068343, 0x0083000a, 0x090c0827, 0x0b0d1009, 0x29b98209, 0x0b0c0e09, 0x090e0f09, 0x07820d07, 0x0822c482, 0x17821113, 0x0d100d22, 0x5d830b82,
	0x820f1021, 0x2708822b, 0x080b0608, 0x07090b0e, 0x082e7882, 0x0a0b0809, 0x0b0c090b, 0x0a0d0d11, 0x9841080a, 0x08092e05, 0x0a0b0b0d, 0x090b090a,
	0x0a0d0a0d, 0x41598306, 0x0a2005a3, 0x06206582, 0x0e220a83, 0x1d82080e, 0x45825c82, 0x81820920, 0x0d840c20, 0x43090b21, 0x0927085b, 0x0c0d0608,
	0x820a0608, 0x0909245f, 0x820f0e0e, 0x0e102382, 0x3b820e10, 0xa24e0a20, 0x0e4f4305, 0x2e833f86, 0x8343038b, 0x2033831c, 0x05f84b0a, 0xba820b20,
	0x00820820, 0x20059644, 0x2e008200, 0x11030303, 0x09000a14, 0x0b070404, 0x430c0e09, 0x0f201883, 0x0c2a4182, 0x0c0c0909, 0x080a0506, 0xf0820d0f,
	0x0d820b20, 0x090f0a2b, 0x06050a09, 0x0a070905, 0x21d38209, 0x83430609, 0x090f2a05, 0x060a0a0a, 0x08090608, 0x0e83430d, 0x060e0a37, 0x0e050908,
	0x06090709, 0x0b090a06, 0x06060304, 0x0d0d0d08, 0x822f8207, 0x0a0e2202, 0x20008209, 0x20008206, 0x8214820c, 0x0d092102, 0x4305fb41, 0x6e821083,
	0x00820a20, 0x20059c43, 0x827a8308, 0x08564111, 0x0c0a0c22, 0x4e823186, 0x080c0922, 0x09220186, 0x8343090c, 0x080b2409, 0x430a0405, 0x0d210b83,
	0x20018309, 0x2004820b, 0x24dd820a, 0x0b0f0f0a, 0x43018306, 0x062108cc, 0x43018209, 0x058505a8, 0x820d0f21, 0x05c9411b, 0x88820520, 0x0d0e0e26,
	0x0a08090a, 0x04228782, 0xcf84030a, 0x0d0a0429, 0x0d0b0d08, 0x820b0a05, 0x0c0a251e, 0x0a0a060d, 0x0d203382, 0x0e289b84, 0x060d0e09, 0x09080a09,
	0x43833a82, 0x0a09082b, 0x09090805, 0x0b0a0808, 0x82cf820a, 0x0d0c21aa, 0x09211a82, 0x2809820d, 0x0606090a, 0x0c100f05, 0x82d6820a, 0x090b294b,
	0x0d0d0a0e, 0x0c0f0b0a, 0x0a2d4a82, 0x090e0a09, 0x11110b0c, 0x0a0b0e0b, 0x21688312, 0xf1820906, 0x38844982, 0x08080a22, 0x092efd82, 0x0b0f0f09,
	0x0e08090c, 0x06090909, 0x83430808, 0x0f072209, 0x8201830d, 0x111121c7, 0x21098343, 0x83430f06, 0x090e230b, 0xc5820e12, 0x72820d20, 0x0b0c0a22,
	0x07205c82, 0x22058143, 0x41040a0a, 0x200806ac, 0x09060606, 0x06110911, 0x05090304, 0x00000203, 0x03041111, 0x0f0d0a0a, 0x0d090a0f, 0x10100706,
	0x20b7820d, 0x82008300, 0x11092acd, 0x0f0a0b0e, 0x0f090a0c, 0x20b5820c, 0x2293820e, 0x830a0d0c, 0x121427f1, 0x0d0f0a0d, 0x0b820e11, 0x0a0a0926,
	0x0e10110a, 0xfa820683, 0x0c22ee82, 0x3343080a, 0x0a0b2705, 0x0b0d090c, 0x43820f12, 0x19470820, 0x08092f05, 0x0a0c0c0d, 0x090c090b, 0x0a0e0a0e,
	0xa1820e06, 0x0c220c83, 0x61820b09, 0x090a0627, 0x0e0e090a, 0x22778209, 0x820e090d, 0x080a2245, 0x210b830d, 0x01820d0a, 0x2009b045, 0x20368209,
	0x2c2b8209, 0x0a0a0809, 0x0d100f0f, 0x0e10090b, 0x212e8211, 0x77840b0d, 0x4d08c74d, 0x098309d1, 0x820c0646, 0x0406230c, 0xda4b0406, 0x20059105,
	0x219f820c, 0x01870a0c, 0x44055242, 0x83430596, 0x16123006, 0x0509000b, 0x0a0c0704, 0x05040d0f, 0x820a0a05, 0x0614434c, 0x00820a20, 0x82040421,
	0x10083304, 0x0c0b0b0b, 0x0d0c090a, 0x090a0506, 0x0b0d0d10, 0xda820b0d, 0x82100a21, 0x0705238d, 0x2f820a05, 0x0b080b22, 0x0b370682, 0x05090505,
	0x0b0a0b10, 0x0609070b, 0x090d0a0b, 0x0a06080a, 0x83050a06, 0x820a2044, 0x060f252c, 0x0f060a0a, 0x0626ed82, 0x0c0b0a06, 0x06820404, 0x0d0d0d22,
	0x2305734a, 0x0a0b0f0b, 0x83430082, 0x820a200a, 0x0d0d231b, 0x17840b09, 0x0f0a0a24, 0x00820a08, 0x00820520, 0x11860a20, 0x820b0a21, 0x08604400,
	0x2207f146, 0x870c0b0c, 0x872f821f, 0x20b383fa, 0x08725d06, 0x050a0b27, 0x09090a05, 0x82ae8209, 0x09062203, 0x821e8305, 0x21028203, 0x01820d0a,
	0x0b101023, 0x41018307, 0x0621086a, 0x86018209, 0x22fd8224, 0x82100b0d, 0x06f643dc, 0x82820520, 0x0d0f0f22, 0xa0844f82, 0x28058343, 0x0e0b040b,
	0x0e0c0e08, 0x21be8206, 0xca820a0b, 0x820a0621, 0x20078233, 0x2527820b, 0x0d0e0a0e, 0xb0820906, 0x1c821d82, 0x0b080837, 0x0909060a, 0x0a08090b,
	0x0a080b0c, 0x0a0d0b08, 0x0b060d0c, 0x2807820a, 0x090b0a0d, 0x10050606, 0x20088211, 0x22ed830d, 0x820e0a0c, 0x0c0a2444, 0x820d0d10, 0x0b09210f,
	0x0c270d82, 0x0f0c1212, 0x82130b0b, 0x070a2149, 0x08256a82, 0x0a090b0b, 0x393e820e, 0x0a08080b, 0x0b0b090d, 0x0e0c1010, 0x0a0f080a, 0x08070b0a,
	0x05050509, 0x2082100f, 0x07090b24, 0x01830d10, 0x090a0939, 0x03071212, 0x06030403, 0x08080606, 0x04150f07, 0x09060607, 0x820a0702, 0x090e266a,
	0x0b0d0e13, 0x8200820e, 0x4560828d, 0x0b200530, 0x05200082, 0x080a8343, 0x12091220, 0x0a030506, 0x00020405, 0x05121200, 0x0f0a0b03, 0x0a0b1010,
	0x1107060e, 0x0d0a0d11, 0x0083000c, 0xc2820a20, 0x0c0e1228, 0x0b0d100b, 0x0782100a, 0x93821120, 0x0d0c0e23, 0x2800830a, 0x0a0d1316, 0x0e120e11,
	0x0503500b, 0x82111221, 0x820b2023, 0x0b0725c6, 0x0a0d0e09, 0x09241483, 0x0b0c090a, 0x0c288982, 0x0c0d0f13, 0x0809080b, 0x13827e82, 0x0d0d0f23,
	0x2b17830b, 0x0c0f0c0f, 0x0c0d0e06, 0x0d0a0c0a, 0x65822682, 0x0b060e23, 0x2187820a, 0x77820a0f, 0x0e0a0d27, 0x0a080a0d, 0x431a8308, 0x68830523,
	0x1f820b20, 0x0a0b0c26, 0x090e0f07, 0x0a2d6782, 0x100b0b09, 0x0b0f1011, 0x130f1209, 0x23258210, 0x0c080a0c, 0x8e095c42, 0x05364609, 0x06230589,
	0x43050605, 0x1186117d, 0x0d219082, 0x4301870c, 0x0b2105d4, 0x29008700, 0x13040404, 0x0a000b17, 0x6e820405, 0x040d1024, 0x83430606, 0x0c0c3616,
	0x090a0d0c, 0x05060e0d, 0x0e110a0b, 0x0c0e0b0e, 0x0b0e0a0a, 0x24838211, 0x0a060706, 0x20cd8208, 0x08834309, 0x0d821120, 0x09080b2c, 0x0e0a0b06,
	0x07080a0a, 0x8343070a, 0x0b0a3807, 0x0a0a0710, 0x080a1006, 0x0b06060a, 0x04040c0b, 0x0e0a0706, 0x82080e0e, 0x2102825d, 0x83430c10, 0x820d2007,
	0x83028214, 0x0e0e221b, 0x0783430a, 0x43091021, 0x67431783, 0x0c092106, 0x0d200184, 0x1c41f282, 0x06064109, 0xb3820a20, 0x83430b20, 0x090b240d,
	0x84050a09, 0x0a062201, 0x221e8305, 0x820d0b0e, 0x25b58206, 0x11110a0e, 0x0183080c, 0x2108fc44, 0x01820a06, 0x05852485, 0x830e1121, 0x82082063,
	0x050826cb, 0x100a0c0a, 0x210f8210, 0x00820b09, 0x040b0522, 0xdd820582, 0x090e0b2b, 0x060f0d0f, 0x0b0a0c0c, 0x22ca820a, 0x820c0b06, 0x0e0e2133,
	0x62830c82, 0x0a060e22, 0x24098343, 0x060a0b09, 0x28268209, 0x0b0c0a09, 0x0b090a09, 0x242f840d, 0x0a0e0b0a, 0x2a5b820d, 0x11050606, 0x0b0b0d12,
	0x830b0c0e, 0x821020e9, 0x0d0b231c, 0x4a820e11, 0x0e325a82, 0x120c0e0a, 0x0c100c12, 0x0a0c140c, 0x0b070a0a, 0x83430e0a, 0x09092109, 0x0b2d4082,
	0x0d11110b, 0x0f090a0f, 0x070b0a0a, 0x09834309, 0x11080a23, 0x8201830e, 0x13133035, 0x04030308, 0x07070703, 0x0f070808, 0x43080417, 0x0f260883,
	0x0e0e130a, 0x00820e0c, 0x83437f82, 0x0c0c2309, 0x3045050b, 0x06062606, 0x0a130a06, 0x08834313, 0x0513132f, 0x100a0b03, 0x0a0c1111, 0x1208060f,
	0x20a08312, 0x82008300, 0x130b26f5, 0x110b0c0f, 0x2603820e, 0x130d0e0f, 0x82080a11, 0x0b0a2157, 0x16250182, 0x120b0e14, 0x221d820f, 0x820b0c09,
	0x12132200, 0x2905820e, 0x07090b0b, 0x0e100a0c, 0xe782080a, 0x090b092e, 0x0b0e0b0d, 0x10140c0f, 0x090c0c0e, 0x25069841, 0x0d0d100a, 0x17840c0b,
	0x060c0f25, 0x820d0e10, 0x820e20ef, 0x2361820e, 0x0a0c060e, 0x10213d82, 0x2077820a, 0x2145840e, 0x1a83090a, 0x11828f82, 0x4a090c21, 0x0c28051b,
	0x10070a0b, 0x0b07090f, 0x0b32cd82, 0x1111110b, 0x13090b0f, 0x0e111410, 0x0a0c0d0a, 0xbd460d08, 0x06624208, 0x83430f88, 0x92598513, 0x820b2005,
	0x4b0c2077, 0x0e2105f8, 0x4339850c, 0x14350c83, 0x0a000c18, 0x0d080505, 0x050e110b, 0x0b0b0606, 0x07050605, 0x2100880b, 0x0a820505, 0x0d110938,
	0x0b0e0c0c, 0x070d0e0a, 0x110a0b06, 0x100c100e, 0x0d0b0b0c, 0x1b82120c, 0x12820620, 0x0b0c082e, 0x0a0c090c, 0x050c0b07, 0x13050a05, 0x0c280d82,
	0x0c070908, 0x0a0a0f0a, 0x0721dd82, 0x3b44840b, 0x0c090b0b, 0x0b0a0711, 0x090a1106, 0x0c07070b, 0x04050d0c, 0x0f0a0707, 0x0d090f0f, 0x11200084,
	0x0b205382, 0x07241982, 0x100e0e07, 0x0b210083, 0x21178310, 0x17840c0b, 0x110b0b22, 0x20088343, 0x8211860b, 0x440c201a, 0x0d2107f9, 0x0581430b,
	0x0e090c25, 0x410c0e0c, 0x05830560, 0x0b20fe82, 0x0d250383, 0x070c0d0c, 0x26018705, 0x05060a0d, 0x430a0a0b, 0x23410a83, 0x0c0e2305, 0x01830b10,
	0x0c121223, 0x4c018308, 0x0721080c, 0x4401820b, 0xfb8209cc, 0x5d820f20, 0x06311e85, 0x110b0d0b, 0x0b0b1011, 0x0b0c0c09, 0x040c050c, 0x2900820c,
	0x0f0d050d, 0x110d1109, 0x13820d06, 0x0d0b0b2a, 0x0c0b0710, 0x100b0e11, 0x0b240e82, 0x0f0b0f0b, 0x08220f83, 0x2982060c, 0x080b0b2f, 0x060b0c09,
	0x0a0c0a0a, 0x0c0d0b09, 0x24468209, 0x0f0f0a0d, 0x20378206, 0x2bba820f, 0x07070b0c, 0x0e131306, 0x0d0d0c0b, 0x6a825f82, 0x0e0e0b27, 0x0d110d0b,
	0x2d0e8310, 0x0d0b0f0c, 0x0d13130d, 0x150d0c10, 0x4a820b0c, 0x0a0b2d08, 0x0c0c080f, 0x0c0e0b0a, 0x090c0c0b, 0x0a0f0a09, 0x11110c0c, 0x090b100e,
	0x0c0a0b11, 0x05090908, 0x11110505, 0x0c0a0a0c, 0x0f120809, 0x0b260183, 0x14140a0a, 0x00820408, 0x08080839, 0x0f080a0a, 0x06080517, 0x07030a06,
	0x0b0f0b0b, 0x0f140a10, 0x820f0c10, 0x0c0c2200, 0x2160820e, 0x6482080e, 0x820b0b21, 0x0a0523b6, 0xb2520a0a, 0x0a210806, 0x07140a14, 0x050b0305,
	0x00000204, 0x04051414, 0x11110b0c, 0x100b0d13, 0x12120807, 0x0d0f0b10, 0x24008300, 0x0c0a0e0b, 0x3db48213, 0x0b0d0e12, 0x0d0f0f12, 0x080b1113,
	0x0b100f0f, 0x0a0c0a0c, 0x0c101518, 0x10131012, 0xb683090c, 0x13140c24, 0x00830c0e, 0x0c080a27, 0x0b0f110a, 0x2e788208, 0x0d0a0b0a, 0x0f0c0d0c,
	0x0f11150e, 0x52090c0c, 0x0b200527, 0x0d211d82, 0x2717830d, 0x0d100d10, 0x0d0f1107, 0x22087246, 0x83070e11, 0x1111240c, 0x820f0a0b, 0x22458301,
	0x820e090b, 0x05e041c3, 0x43090d21, 0x0d250555, 0x10080b0c, 0x25678310, 0x0c0c0a0b, 0x27821212, 0x11130928, 0x0b0f1213, 0xaa550e0e, 0x0bfc4805,
	0x60420b89, 0x23098509, 0x05070507, 0x05915985, 0x0d21b784, 0x8501860f, 0x051a482f, 0x00820020, 0x04040438, 0x000d1a15, 0x0806050b, 0x0f110c0e,
	0x0c060604, 0x0607060c, 0x00880c08, 0x0c221183, 0xe8821209, 0x0a0b0e2c, 0x06080f0e, 0x0f120a0c, 0xec820c0f, 0x0c0f0a2d, 0x0b0c0b13, 0x0b060806,
	0x820b0c09, 0x430b20d1, 0x3d820883, 0x07090827, 0x0b100b0c, 0x2206820b, 0x82050c07, 0x27138256, 0x07110c0a, 0x11070c0a, 0x07252f82, 0x0e0c0c07,
	0x0d834306, 0x0b0d1222, 0x08200082, 0x0e210082, 0x2000840f, 0x2005850c, 0x0671430c, 0x820a1221, 0x050b211e, 0x4b820082, 0x0b220289, 0x1a410b0c,
	0x460a2006, 0x0e2205f3, 0x31860e0c, 0x83432f83, 0x20b38207, 0x05dd540c, 0x0d240583, 0x0c05060b, 0x830b8343, 0x0c0f221e, 0x8206850e, 0x0d1422d9,
	0x43018308, 0x0b230564, 0x83070a09, 0x831d8701, 0x10132207, 0x2079820c, 0x27208309, 0x0b0d0c06, 0x0c0f1212, 0x0c21d782, 0x0883430c, 0x100d0629,
	0x110e100a, 0x820d0d06, 0x0f0b2727, 0x0d0c080f, 0x07820f12, 0x0a0b0c26, 0x100b100c, 0x0c250f82, 0x0c060c09, 0x251e820c, 0x0c0c0909, 0x26820a06,
	0x0d0c0a24, 0x16820a0c, 0x1f820f20, 0x0c201a82, 0xdc822f82, 0x06080829, 0x0c0f1413, 0x820d0f0c, 0x0b0e222c, 0x27448312, 0x0f0f120e, 0x0a0d0c0f,
	0x0f284a82, 0x0e14140e, 0x150d0d11, 0x0b244982, 0x0f0b0c08, 0x0a214d82, 0x262f820c, 0x090a0c0c, 0x430b0f0b, 0x0a2d0683, 0x0c0b0b12, 0x05090a08,
	0x12110505, 0x236d820c, 0x1013080a, 0x0c250183, 0x15150b0b, 0x08834309, 0x19120923, 0x05834304, 0x100c0c2a, 0x150b110c, 0x100d0f11, 0x0c200082,
	0xb6835284, 0x820c0c21, 0x050c2253, 0x0530450b, 0x07072208, 0x0b150b07, 0x04050715, 0x0204060c, 0x15150000, 0x0c0d0405, 0x0d131211, 0x0807100b,
	0x0c0f1313, 0x06834310, 0x14318a82, 0x130c0d11, 0x120b0d0f, 0x140d0e0f, 0x10090b11, 0x28a78210, 0x1a0b0c0b, 0x130d1016, 0x221d8211, 0x820c0d0a,
	0x14152200, 0x82058210, 0x830820bf, 0x090b352a, 0x0a0c0b0d, 0x0d0e0a0c, 0x0e110c0f, 0x0d101216, 0x090a0a0d, 0x0b238482, 0x82110b0b, 0x820e2048,
	0x0e112499, 0x82080e11, 0x830b2055, 0x0c0f250c, 0x0f120c0e, 0x3d823b82, 0x0b0b1223, 0x2501820f, 0x090b0f12, 0xc0410a0b, 0x0a0d2309, 0x01830b0c,
	0x0b0c0e26, 0x0a101108, 0x0b202b82, 0x1229d482, 0x0c101212, 0x1512140a, 0x24428212, 0x0e090b0e, 0x1581430c, 0xa3460d20, 0x23088708, 0x05080508,
	0x09915d89, 0x8305f64b, 0x43778505, 0x16270c83, 0x0b000d1a, 0x83080606, 0x070422b5, 0x15834307, 0x830d1321, 0x0f0b28ff, 0x0d06080f, 0x8310130b,
	0x38da824a, 0x0c0c130d, 0x0708070c, 0x0c0d090c, 0x0c0d0a0d, 0x060d0b07, 0x14060b06, 0x2e00820d, 0x0d070a09, 0x0b0b100b, 0x080c080a, 0x8206060c,
	0x0c0c3a28, 0x07120d0b, 0x12070c0b, 0x070c090b, 0x0e0d0d07, 0x08070506, 0x1010100b, 0x822f8209, 0x0d132102, 0x08202583, 0x0f200082, 0x02821482,
	0x0f100c22, 0x0c210082, 0x2317840d, 0x0a120c0c, 0x06201f83, 0x2f850082, 0x08837482, 0x4308f944, 0x0d240581, 0x0f0d0f0a, 0x2f833186, 0x860b0f21,
	0x63158201, 0x06210833, 0x2293820d, 0x510b0b0d, 0x0b230578, 0x41060b07, 0x0f200523, 0x10250685, 0x0d15140d, 0x44018309, 0x072008ee, 0x07202482,
	0x8307ca44, 0x10132407, 0x450c0b0c, 0x062a054b, 0x130c0d0c, 0x0b0d1012, 0x93820d0a, 0x040d0622, 0x062a9f84, 0x110a110d, 0x0d07110f, 0x8e820c0e,
	0x08100f24, 0x33820d0d, 0x0d0f1022, 0x10253782, 0x0810100c, 0x20b0820c, 0x27f78207, 0x0a0a0d0b, 0x0b070d0d, 0x0a22c882, 0xc5840e0d, 0x1a831f83,
	0x0f0c102c, 0x080b0d0c, 0x15140608, 0xc0820d0f, 0x0e224b82, 0x3c82120c, 0x130f0d23, 0x224a820f, 0x820d0b0d, 0x160f3622, 0x0e120f16, 0x0c0d170d,
	0x0c090c0d, 0x0d0a100c, 0x100c0b0d, 0x3800820d, 0x100b0a0a, 0x140d0d0b, 0x0c110e14, 0x0c0c130a, 0x0a0a090d, 0x12060606, 0x22fb8213, 0x43090a0d,
	0x20080883, 0x04091616, 0x08040504, 0x0b0b0808, 0x041a1208, 0x0b070708, 0x0c0c0803, 0x0b120c11, 0x0e101116, 0x20008211, 0x217f820d, 0x83430c0c,
	0x215a8205, 0x8343060c, 0x0b16240a, 0x43060716, 0x16340683, 0x0d040616, 0x1413120c, 0x07110c0d, 0x10141409, 0x000e100d, 0x0c270083, 0x160d0c10,
	0x820d0e11, 0x130c2b11, 0x140e0e11, 0x100a0c12, 0xac821010, 0x1a0b0d29, 0x150e1117, 0x82121611, 0x820c20fd, 0x1516215c, 0x0d22be84, 0xee82090b,
	0x0a0c1022, 0x20050b43, 0x2881820e, 0x13170f11, 0x0a0d0e10, 0x05154a0b, 0x0f120b22, 0x28059441, 0x0e120e12, 0x0f101208, 0x2001820c, 0x059f410d,
	0x0c0d0826, 0x12130c0d, 0x1482b382, 0x45821220, 0x0d206e82, 0x8207e041, 0x0d0b2168, 0x0f3e0182, 0x12090c0d, 0x0d090b11, 0x0d0b0c0c, 0x1413140d,
	0x160b0d11, 0x10131612, 0x0c0f0f0d, 0xc54d0f0a, 0x0b024908, 0x0c200b83, 0x0822008e, 0x43420806, 0x096d4306, 0x8e830987, 0x870e1021, 0x05834301,
	0x20059644, 0x36008200, 0x17050505, 0x0c000e1c, 0x0f080606, 0x0410130d, 0x0d0d0707, 0x43060706, 0x0d200614, 0x06210082, 0x38048206, 0x0e0e140a,
	0x0b0c100e, 0x06081010, 0x11140b0d, 0x0e110d11, 0x0d100c0c, 0x21b98214, 0x83430907, 0x0d0b2b05, 0x0e0c080c, 0x060b0606, 0x32820e14, 0x080a0925,
	0x43110b0e, 0x0d200583, 0x0d204484, 0x1335e482, 0x070d0b08, 0x0d0a0c13, 0x0e0d0808, 0x0805060f, 0x11110b08, 0x05f74d11, 0x82140e21, 0x0c0c2253,
	0x20008208, 0x05a87d10, 0x10110d22, 0x0c210082, 0x2317840d, 0x0b130c0c, 0x20088343, 0x8361820e, 0x820e2002, 0x0d0b2300, 0x484a0e0b, 0x460b2005,
	0xfa8305f3, 0x21092141, 0x01860c10, 0x0e100e22, 0x20098343, 0x0c83430e, 0x060b0824, 0x01830e11, 0x04821020, 0xdd820d20, 0x15140d24, 0x0183090e,
	0x2108064c, 0x01820c08, 0x23094841, 0x11140e10, 0x20088343, 0x23a18207, 0x0d111314, 0x0d22d782, 0x83430d0d, 0x060e3206, 0x120b120e, 0x0e08120f,
	0x0c0d0c0e, 0x0811100c, 0x2133830d, 0x0c821011, 0x0d120c3c, 0x0c081112, 0x080e0a0d, 0x0b0e0d0e, 0x0e0a0a0d, 0x0c0b080d, 0x0d0b0b0e, 0x0e820d0f,
	0x0c100e25, 0x82081011, 0x2bba831a, 0x08080c0e, 0x10161506, 0x0e100d0d, 0x0f206882, 0x11273c82, 0x140f0d11, 0x82101110, 0x120d2b0e, 0x160f100d,
	0x0e130f16, 0x6882180e, 0x0d090d24, 0xab4a100c, 0x372c8205, 0x0b0a0b0d, 0x0d0e0b10, 0x12101414, 0x0c130b0d, 0x0b090e0c, 0x0606060a, 0x0b26dd82,
	0x090b0e0b, 0x01831114, 0x1721c782, 0x07834317, 0x0a0a0a36, 0x08041b12, 0x030b0808, 0x110d0d08, 0x170c120d, 0x110e1112, 0x7f840082, 0x42100d21,
	0x0e24051b, 0x0c060d0e, 0x8205ac41, 0x170c352b, 0x0608170c, 0x05060d04, 0x17000002, 0x0e040617, 0x1414120c, 0x08280482, 0x11151509, 0x000f110d,
	0x0c340083, 0x160e0c11, 0x150d0e12, 0x140c0e10, 0x160e1011, 0x120b0d13, 0x0d2fca82, 0x1c0b0d0b, 0x150f1218, 0x0e131612, 0x820d0e0b, 0x16172200,
	0x27078411, 0x0d0e090b, 0x0b0d1012, 0x2482d982, 0x100d0f30, 0x1810120e, 0x0e0e1114, 0x0c0a0c0b, 0x13820c0b, 0x0f101323, 0x2617830e, 0x0f130f13,
	0x42101208, 0x0f2607ee, 0x0811140d, 0x68820c0e, 0x1023f582, 0x830c100c, 0x0b0d2145, 0x0e20c982, 0x0d238f82, 0x820e0d11, 0x0783433b, 0x46121321,
	0x0d2c06f1, 0x13151414, 0x14160c0e, 0x0d111517, 0x0b224b82, 0x43830d0f, 0x82430393, 0x080c240e, 0x85060806, 0x25059159, 0x0e100e10, 0x01870f11,
	0x20128343, 0x05834318, 0x82100a21, 0x070524b5, 0x820d0d07, 0x1083434c, 0x0f152008, 0x0d100e0f, 0x0911110c, 0x150c0e07, 0x120e1212, 0x110d0d0e,
	0x0d0d150e, 0x0709070d, 0x820e0a0d, 0x0d0e2ad3, 0x060e0d08, 0x16060c06, 0x2b00820e, 0x0e080b0a, 0x0c0c120c, 0x090d090b, 0x3a068343, 0x140e0c0d,
	0x080d0c08, 0x0d0a0c14, 0x0e0e0808, 0x08050610, 0x12120c08, 0x840f0a12, 0x0e142100, 0x0d214e82, 0x21008209, 0x00841210, 0x11120d22, 0x0d210082,
	0x2317840e, 0x0b140d0d, 0x21051444, 0x5f820606, 0xba510283, 0x0e0c2205, 0x050a450c, 0x21058143, 0xf2830b0e, 0x8206a343, 0x08124106, 0x0e110e22,
	0x27094e6b, 0x06070c0f, 0x0c0c0c0e, 0x0382ae82, 0x060c0822, 0x1222d283, 0x0685100e, 0x150e1223, 0x055a4f16, 0x21088a48, 0x01820d08, 0x43821120,
	0x15240387, 0x0d0c0d12, 0x07291e85, 0x140d0f0d, 0x0d0e1214, 0x24aa820b, 0x040e060e, 0x3300820e, 0x120e060f, 0x1310130b, 0x0d0f0f08, 0x110d0d0e,
	0x0f0e0912, 0x12213382, 0x260c8211, 0x130d130d, 0x820d0912, 0x820820b0, 0x0e0c2d29, 0x0e0e0b0b, 0x0e0c0c08, 0x0f0e0b0c, 0x1023c584, 0x8312120d,
	0x0d12351a, 0x0d0e0d11, 0x16070909, 0x0e0e1117, 0x0f0e0f11, 0x140d100d, 0x0e341c82, 0x12111510, 0x0d0e0e11, 0x110d130e, 0x10171710, 0x190e0f14,
	0x0d290d82, 0x100d0d0a, 0x0c0e0e0b, 0x281c820d, 0x0a0b0e0e, 0x0e0c100c, 0x0583430e, 0x0d0d1426, 0x0b0b0a0e, 0x83058343, 0x150a226d, 0x08018312,
	0x0c0c0d23, 0x040a1818, 0x09040504, 0x0b0b0909, 0x051c120a, 0x0c08080a, 0x0d0d0803, 0x0c130d12, 0x0f121318, 0x82008212, 0x22ba827f, 0x820d0911,
	0x430f2000, 0x18220e83, 0x8343180c, 0x18183108, 0x0d0e0406, 0x0f161514, 0x0a08130d, 0x0e121616, 0x82068343, 0x170e334d, 0x150e0f13, 0x150d0f11,
	0x170e1112, 0x130b0d14, 0xac821212, 0x1c0c0e32, 0x160f1319, 0x0e131713, 0x0e0d0f0b, 0x17180e0e, 0x07821682, 0x0f0a0c26, 0x0d10140d, 0x2b060b43,
	0x0e110e10, 0x15191012, 0x0b0e0f12, 0x0c21e882, 0x2301820d, 0x0e101114, 0x13291783, 0x090f130f, 0x0d101014, 0x22f98210, 0x82100e11, 0x0f092265,
	0x823d820d, 0x0d1122f5, 0x21458411, 0xde410b0d, 0x455d8207, 0x103906b8, 0x140a0d0e, 0x0e0a0c12, 0x0e0c0d0d, 0x1515150e, 0x170c0d13, 0x11151814,
	0x21a5820e, 0xc54d100b, 0x0b024908, 0x60420b83, 0x22098509, 0x42090609, 0x63890643, 0x4b820987, 0x470a8343, 0x1a480551, 0x82002005, 0x05052200,
	0x20058205, 0x22038603, 0x8201001c, 0x02002409, 0x830300d8, 0xe2042509, 0xbc020400, 0x9c081182, 0x00800090, 0x00100006, 0x017f017e, 0x01a10192,
	0x01f001b0, 0x021902ff, 0x02c702bc, 0x02dd02c9, 0x030103f3, 0x03090303, 0x0323030f, 0x038c038a, 0x03ce03a1, 0x04d603d2, 0x044f040d, 0x0486045f,
	0x1e130591, 0x1e3f1e01, 0x1ef11e85, 0x204d1ff9, 0x2015200b, 0x2022201e, 0x20302026, 0x203a2033, 0x2044203c, 0x20a4207f, 0x21ac20a7, 0x21132105,
	0x21222116, 0x212e2126, 0x2202225e, 0x220f2206, 0x221a2212, 0x222b221e, 0x22602248, 0xfbca2565, 0xfffffe04, 0x00fffffd, 0x00200000, 0x229182a0,
	0x82af01a0, 0x02fa2291, 0x20918218, 0x209182c6, 0x209182d8, 0x20918800, 0x24918284, 0x03a3038e, 0x349182d1, 0x040e0400, 0x04600450, 0x1e920488,
	0x1e3e1e00, 0x1ea01e80, 0x269182f2, 0x20132000, 0x84202017, 0x20322291, 0x20918639, 0x209182a3, 0x20918cab, 0x2091865b, 0x20918a11, 0x20918264,
	0x08918201, 0xfffffc3a, 0xc2ffe3ff, 0xbf00b0ff, 0x6100b200, 0x31ff49ff, 0x85fe96ff, 0x76fe84fe, 0x63ff68ff, 0x5dff62ff, 0x44ff6700, 0xcffdd0fd,
	0xcdfdcefd, 0x7ffe82fe, 0x9afd0000, 0x0cfe0000, 0x55080382, 0xe458e409, 0xe47ae318, 0xe300007d, 0xe142e20d, 0xe1eee1ef, 0xe1eae1ed, 0xe1e0e1e1,
	0xe1dae1db, 0xe199e1d3, 0x0074e176, 0xe118e100, 0xe009e10b, 0xe0fbe0fe, 0xe0c8e0f4, 0xe022e025, 0xe019e01a, 0xe00fe012, 0xdfe7df03, 0xdccddfd0,
	0x03000069, 0x0053024f, 0x00af0001, 0x30826020, 0x03827820, 0x03829420, 0x9c200287, 0x07940887, 0x15948e20, 0x6c20148f, 0x6f081085, 0x9c016802,
	0x9e019d01, 0xa0019f01, 0xa201a101, 0xa401a301, 0xa601a501, 0x6902a701, 0xea016a02, 0xec01eb01, 0xee01ed01, 0xf001ef01, 0xf201f101, 0xf401f301,
	0x6b02f501, 0xf701f601, 0x94029302, 0x96029502, 0x98029702, 0x9a029902, 0xf901f801, 0x01020002, 0x70036f03, 0x72037103, 0x74037303, 0x1c027503,
	0x35023402, 0x5e025d02, 0x0a020600, 0x01217583, 0x10074100, 0x02000122, 0x1c830182, 0x9d000221, 0x05414100, 0x0003bc08, 0x00050004, 0x00070006,
	0x00090008, 0x000b000a, 0x000d000c, 0x000f000e, 0x00110010, 0x00130012, 0x00150014, 0x00170016, 0x00190018, 0x001b001a, 0x001d001c, 0x001f001e,
	0x00210020, 0x00230022, 0x00250024, 0x00270026, 0x00290028, 0x002b002a, 0x002d002c, 0x002f002e, 0x00310030, 0x00330032, 0x00350034, 0x00370036,
	0x00390038, 0x003b003a, 0x003d003c, 0x003f003e, 0x00410040, 0x00430042, 0x00450044, 0x00470046, 0x00490048, 0x004b004a, 0x004d004c, 0x004f004e,
	0x00510050, 0x00530052, 0x00550054, 0x00570056, 0x00590058, 0x005b005a, 0x005d005c, 0x005f005e, 0x82610060, 0x86de08e0, 0x89008700, 0x93008b00,
	0x9e009800, 0xa200a300, 0xa600a400, 0xa700a500, 0xab00a900, 0xac00aa00, 0xaf00ad00, 0xb000ae00, 0xb300b100, 0xb400b500, 0xb800b600, 0xbc00b700,
	0xbd00bb00, 0x0d02be00, 0x64007200, 0x69006500, 0x78000f02, 0x7000a100, 0x20026b00, 0x6a007600, 0x88003002, 0x2d029a00, 0x31027300, 0x67003202,
	0x27027700, 0x29022a02, 0x2e028d01, 0x7c006c00, 0xa8002102, 0x8100ba00, 0x6e006300, 0x42012c02, 0x28022f02, 0x7d006d00, 0x62001002, 0x85008200,
	0x14019700, 0x02021501, 0x0a020302, 0x06020b02, 0xb9000702, 0xc1003302, 0x17023a01, 0x14021c02, 0x34021502, 0x0e023502, 0x08027900, 0x11020c02,
	0x8c008400, 0x8d008300, 0x8f008a00, 0x91009000, 0x95008e00, 0xe1829600, 0x9c00943c, 0x9b009d00, 0x4b01f300, 0x71005201, 0x4f014e01, 0x7a005001,
	0x51015301, 0x04104c01, 0x08bc02c5, 0x45400057, 0x54555859, 0x50515253, 0x4c4d4e4f, 0x48494a4b, 0x44454647, 0x40414243, 0x3c3d3e3f, 0x38393a3b,
	0x31353637, 0x2d2e2f30, 0x2627282c, 0x22232425, 0x14181f21, 0x0e0f1011, 0x090a0b0d, 0x05060708, 0x01020304, 0x23452c00, 0xb0206046, 0x04b06026,
	0x48482326, 0x210f832d, 0x10826123, 0x108a6120, 0x20b06022, 0x46201282, 0xb021238d, 0x20378320, 0x8c1a8261, 0x82402029, 0x8e662029, 0x85402029,
	0x88402029, 0x10013553, 0x3c003c20, 0x45202c2d, 0xcdb02023, 0xb8202344, 0x58515a01, 0x8d260b82, 0x20592344, 0x0b84edb0, 0x0b844d20, 0x84260421,
	0x820d200c, 0x2121210c, 0x23083182, 0x68184520, 0x01b02044, 0xb0452060, 0x8a687646, 0x2d446045, 0x0bb1012c, 0x4323430a, 0x2c2d0a65, 0x0b0ab100,
	0x0b200a82, 0xb0280982, 0xb1702328, 0x013e2801, 0x02280884, 0xb13a4528, 0x0d080002, 0x45364482, 0x452503b0, 0x50b06461, 0x44455851, 0x5921211b,
	0xb0492c2d, 0x4982230e, 0x00215582, 0x24528443, 0xb04306b0, 0x22528407, 0x82b06920, 0x8b0037ba, 0xc02cb120, 0x10b88c8a, 0x2b606200, 0x6423640c,
	0xb0585c61, 0x3b826103, 0x45038a3c, 0xb0878a8a, 0x29b02b11, 0x29b04423, 0x2d18e47a, 0xb065452c, 0x4544232c, 0x55832bb0, 0x88524b21, 0x894b2067,
	0xb0012972, 0x23102505, 0x00f58a20, 0x2322ce82, 0xc782eced, 0x6120118a, 0x06241186, 0x00f51025, 0x24081c83, 0x60462346, 0x23468a8a, 0x608a4620,
	0xffb8618a, 0x20236280, 0xb18a2310, 0x708a0c0c, 0xb0206045, 0xb0585000, 0x2c178201, 0xb01b8bba, 0xb0598c46, 0x01686010, 0x2eec863a, 0xb04b5246,
	0x585b5113, 0x462502b0, 0x82616820, 0x260282fe, 0x3821233f, 0x8211211b, 0x22f582c0, 0x82462503, 0x2b1e953f, 0x4307b000, 0x0b4306b0, 0x21212c2d,
	0x8b24f883, 0x620040b8, 0xb0230c82, 0x85585180, 0x00202c0f, 0x00b21b62, 0x592b2f40, 0x836002b0, 0x87c02019, 0x55152119, 0x80201983, 0x3e881987,
	0x23602d08, 0x4b2c2d21, 0xb08a5853, 0x64492504, 0xb0694523, 0xb0618b40, 0x20b06280, 0x0eb06a61, 0x10234423, 0x1bf60eb0, 0x128a2321, 0x2f392011,
	0x2b82a382, 0xb4822020, 0x69644928, 0x2605b020, 0x358306b0, 0xb022308b, 0x32832604, 0x04828a20, 0x82442321, 0x2344833b, 0x1bed0eb0, 0x26256082,
	0x39201211, 0x83468223, 0x23452347, 0x02866045, 0x18687622, 0x20307182, 0x48b02c2d, 0x202c2d2b, 0x5400b045, 0x4440b058, 0x40210882, 0x06164261,
	0x30b14523, 0x2631822f, 0x01b06061, 0x82446960, 0x585129b1, 0x70232fb0, 0x422314b0, 0x22053742, 0x8358514b, 0x69452396, 0x32845853, 0x45271585,
	0xb04314b0, 0x86636000, 0x2fb02235, 0x253b8245, 0x45202345, 0x0884608a, 0x06834520, 0x51234b33, 0x3300b958, 0x34b1e0ff, 0x33b31b20, 0x59003400,
	0x081d8244, 0x4316b02c, 0x2603b058, 0x64588a45, 0x601fb066, 0x20b0641b, 0x58206660, 0x40b0211b, 0x6101b059, 0x65582359, 0x2329b059, 0xb0102344,
	0x6e82e029, 0x21212123, 0x2bc28259, 0x58544302, 0x4b23534b, 0x38585a51, 0x59201582, 0x18831984, 0x04224e83, 0x468e4525, 0x1b582322, 0xb0304685,
	0x08b02505, 0x58200825, 0x59031b02, 0x102504b0, 0x20211082, 0x22088246, 0x823c4223, 0x07b02305, 0x03820825, 0x06b01023, 0x82158425, 0x241882d1,
	0x1b015820, 0x822d8700, 0x29b02586, 0x44654520, 0x0f832786, 0x0c82548c, 0x43250323, 0x244d8748, 0x03b02506, 0x24478225, 0x211b4843, 0x83bd8259,
	0x2c2d2202, 0x201e8202, 0x21628420, 0x82824223, 0x23820820, 0x87484521, 0x2503221a, 0x221e8220, 0x8202b008, 0x08138246, 0x452c2d24, 0x18452023,
	0x5000b020, 0x65235820, 0x68235923, 0x5040b020, 0x40b02158, 0x65582359, 0x44608a59, 0x0c412c2d, 0x45202106, 0x95410d82, 0x544b2205, 0x410d8b58,
	0x2d240a2c, 0x2100b02c, 0x38201e82, 0xb0272885, 0x58544302, 0x412b46b0, 0x0f840843, 0x0f844720, 0x21076b41, 0x1e8e48b0, 0x0f844920, 0x202b1e82,
	0x4b23088a, 0x514b8a53, 0x8623585a, 0x82002050, 0xb04924b9, 0x82585300, 0x113821a6, 0x2d2ef682, 0x2346012c, 0x46236046, 0x10202361, 0xcf434620,
	0xb18a3505, 0x708a4040, 0x3a686045, 0x8a202c2d, 0x8a644923, 0x3c585323, 0x4b262d84, 0x1b7d5852, 0xa782597a, 0x00122a08, 0x544b014b, 0xb12c2d42,
	0xb1420002, 0x51880123, 0x880140b1, 0xb9585a53, 0x20000010, 0xb2585488, 0x43020102, 0xb1594260, 0x251b8224, 0x0020b958, 0x15844000, 0x15830220,
	0x22831483, 0x0c832020, 0x52204983, 0x08202f82, 0x1b252f84, 0x000040b9, 0x202a8480, 0x84108404, 0xb863230f, 0x13840001, 0x13822485, 0x63000124,
	0x138502b8, 0x27871020, 0x13820220, 0x13850420, 0x13844020, 0x00825920, 0x452c2d38, 0x4b236818, 0x20235851, 0xb0642045, 0x7c585040, 0x608a6859,
	0xc5824459, 0xb0160024, 0x02822502, 0x01b00137, 0xb0003e23, 0xb13e2302, 0x0c060201, 0x65230ab0, 0x230bb042, 0x20178342, 0x2017833f, 0x2017853f,
	0x31178306, 0xb0422307, 0x2d011601, 0x108a7a2c, 0x18f52345, 0xdb82002d, 0x09105c08, 0x1fff03f8, 0xf79ff78f, 0x01f37f02, 0xb801f260, 0x2b40e8ff,
	0x46100ceb, 0x55dd33df, 0x55dcffde, 0xdd01dd30, 0xdc550301, 0x301ffa03, 0xc06f01c2, 0xfc02c0ef, 0x301f18b6, 0xb76001b7, 0xb802b780, 0x3840c0ff,
	0x46130fb7, 0x1f01b1e7, 0x3faf2faf, 0xaf4f03af, 0xaf6faf5f, 0x82af4003, 0xac3a0815, 0x1f1f1851, 0x029c5f9c, 0x03019be0, 0x1f019a2b, 0x9a90019a,
	0x73029aa0, 0x029a839a, 0xeaffb805, 0x099a1940, 0x97af460b, 0x030297bf, 0x1f01962b, 0x969f0196, 0x7c0296af, 0x1d840196, 0x82968521, 0x2f59081d,
	0x4f923f92, 0x92400392, 0x2f460f0c, 0x919f0191, 0x18868701, 0x507c401f, 0x1003027c, 0x30742074, 0x74020374, 0x0174f201, 0xff016f0a, 0x6fa9016f,
	0x016f9701, 0x6f856f75, 0x016f4b02, 0xff016e0a, 0x6ea9016e, 0x016e9701, 0x06016e4b, 0x5518011a, 0x1fff1319, 0x1fff0407, 0x08fb8206, 0x01673f23,
	0x672f671f, 0x67ff673f, 0x50664004, 0xb066a066, 0x653f0466, 0xaf650f01, 0xa0050265, 0x0264e064, 0x08e48303, 0x06644f4e, 0x5f61460a, 0x5f601f2b,
	0x505f1f47, 0x5bf71f22, 0x015bec01, 0x5b845b54, 0x015b4902, 0xf9015b3b, 0x5aef015a, 0x015a6b01, 0x3b015a4b, 0x1306015a, 0x05551233, 0x04550301,
	0x1f550333, 0x030f0103, 0x03af033f, 0x1f570f03, 0x03572f57, 0xb32b5383, 0x46151256, 0xb3e0ffb8, 0x820b0756, 0xb3c02207, 0x080f8454, 0x6d40c087,
	0x460b0654, 0x1f2b5052, 0x504f503f, 0xfa03505f, 0x48ef0148, 0x01488701, 0x56014865, 0x483a0148, 0x0147fa01, 0x870147ef, 0x473b0147, 0x1b1c0601,
	0x33161fff, 0x01115515, 0x3310550f, 0x0102550f, 0x47015500, 0xfafb5500, 0x1bfa1f2b, 0x0f0f1f12, 0xcf0f1f01, 0x0f0f020f, 0x06020fff, 0x007f006f,
	0x00ef00af, 0x01001004, 0x05011680, 0x9001b801, 0x2b5354b1, 0x07b84b2b, 0xb04b52ff, 0xb05b5006, 0x25b08801, 0x08058353, 0x5a514022, 0xb08806b0,
	0x5b5a5500, 0x0101b158, 0x8d85598e, 0x1d42008d, 0x5332b04b, 0x1d60b058, 0x64b04b59, 0x40200882, 0x80200883, 0x102d0882, 0x0016b11d, 0x73735942,
	0x7574735e, 0x2200862b, 0x88735f01, 0x73002300, 0x1683012b, 0x00735f24, 0x08827473, 0x0f831b8c, 0x835f2b21, 0x7373233b, 0x0d820074, 0x1e852b20,
	0x3e847420, 0x31827420, 0x10827420, 0x07822b20, 0x01732b22, 0x73242882, 0x735f7474, 0x00200785, 0x01276382, 0x732b002b, 0x83730174, 0x822b2005,
	0x2b732206, 0x2102822b, 0x3d822b01, 0x182b0034, 0x0014065e, 0x054e000b, 0x001700b6, 0x05b60575, 0x008c00cd, 0x004a0429, 0x008f0014, 0x83ecff00,
	0x22058916, 0x83fe14fe, 0x2103c810, 0x00840008, 0xb600ac24, 0x0982bc00, 0x0382d520, 0x552c0283, 0x97008300, 0x7d009f00, 0xae00e500, 0x71220182,
	0x16837100, 0x00ba0023, 0x830382c5, 0x82a4200a, 0x838c201d, 0xc7002108, 0x7d200182, 0x0c842982, 0xb0240486, 0x8a00b900, 0x9b220b84, 0xc782a600,
	0x0b847720, 0x96200485, 0x05840685, 0x6e006929, 0xb4009000, 0x8700c100, 0x00002e79, 0x006f0066, 0x00960078, 0x01d500c0, 0x24258447, 0x01fe0000,
	0x2079823a, 0x22078278, 0x86f60116, 0x20068f13, 0x221082ee, 0x82880096, 0x009633ad, 0x000c0189, 0x00180196, 0x001d0300, 0x005a0294, 0x75830382,
	0x8400a821, 0x790231b1, 0xb400d900, 0x00000a01, 0x6d008301, 0xa0007f00, 0x00203982, 0x88200982, 0x048b0784, 0x1b849320, 0x89008222, 0x05291489,
	0x0094fcb6, 0x00efff11, 0x83d78283, 0x006d2216, 0x8606837b, 0x01bc2403, 0x845403aa, 0x00bc260b, 0x01d701b6, 0x300b8295, 0x00000196, 0xfeb605ae,
	0xfe6ffebc, 0x026f0083, 0x211382ad, 0x0185002a, 0x006fba08, 0x012901a1, 0x037102e2, 0x034d0329, 0x03ac037c, 0x040f04e2, 0x045b0444, 0x05b40495,
	0x053f0506, 0x06120694, 0x07cc0665, 0x0867073f, 0x08820811, 0x093d09da, 0x09bb0979, 0x0b6a0af7, 0x0ca00b34, 0x0c740c17, 0x0dec0cb3, 0x0d970d39,
	0x0e100ecd, 0x0e970e49, 0x0f2b0fb7, 0x10d50f7c, 0x108b1022, 0x116611fc, 0x12e511a7, 0x13ee1238, 0x139e134d, 0x14f713d1, 0x143b1417, 0x14701459,
	0x15081595, 0x16ae1569, 0x166b160e, 0x17a217ce, 0x181418e3, 0x18af185f, 0x193919c8, 0x1ac01977, 0x1a831a22, 0x1b391bc9, 0x1ccf1b8e, 0x1dd41c27,
	0x1ece1d65, 0x1e751e1b, 0x1ff51e99, 0x0b018248, 0xf41f90bc, 0x01216a20, 0xa4217421, 0xa1225d22, 0xb4234a23, 0x35240824, 0x0c253d24, 0x7e252325,
	0x0a26ba25, 0xa4267f26, 0x2b27ee26, 0xab276527, 0x2a28e227, 0xa3287a28, 0xf728c828, 0x85296d29, 0xb4299c29, 0xe429cb29, 0x722a092a, 0x9d2a852a,
	0xcc2ab42a, 0xfd2ae52a, 0x2b2b142b, 0xa82b442b, 0xd72bbf2b, 0x052cee2b, 0x362c1d2c, 0x1c2d9b2c, 0x4b2d342d, 0x7c2d632d, 0xdd2d932d, 0x8f2e782e,
	0xbb2ea52e, 0xe92ed12e, 0xb12f012f, 0xdb2fc42f, 0x0730f12f, 0x37301f30, 0x65304e30, 0x0e317e30, 0x3b312431, 0x68315131, 0x98317f31, 0x82320932,
	0xaf329932, 0xde32c532, 0x5933f432, 0x89337133, 0xb6339f33, 0xe333cc33, 0x17340034, 0x46342f34, 0x75345e34, 0xa5348e34, 0xd534bd34, 0xf034e834,
	0x80356935, 0xad359635, 0xda35c335, 0x0536f135, 0x3d362636, 0x6a365336, 0x97368036, 0xc536ae36, 0xf036dd36, 0x1e370637, 0x8c373b37, 0xfe37e737,
	0x2c381538, 0x5a384338, 0x84387138, 0xaf389838, 0xf138c838, 0x2c391539, 0x56394339, 0xb2396939, 0xe739ca39, 0x0e3afa39, 0x3e3a263a, 0x743a513a,
	0x0e3bc13a, 0x3b3b253b, 0x623b4f3b, 0x903b793b, 0x133cb23b, 0x833c6c3c, 0xb03c993c, 0xe03cc73c, 0x693df83c, 0x0f3ef73d, 0x383e253e, 0x643e4c3e,
	0x933e7c3e, 0xc03ea93e, 0xea3ed63e, 0x143ffd3e, 0x3d3f2a3f, 0x683f513f, 0xd13f7a3f, 0x53403b40, 0x81406940, 0xae409740, 0xdd40c440, 0x0e41f540,
	0x39412641, 0x63414c41, 0x91417a41, 0xc041a741, 0xed41d741, 0x1b420442, 0x48423242, 0xdf427b42, 0x9644c143, 0xc544ae44, 0xf244dc44, 0x18450545,
	0x84454e45, 0xd7459c45, 0x4e46fe45, 0xc2467b46, 0x32470547, 0xbc47a347, 0x1b48f647, 0x82484148, 0xe748b348, 0x28490f49, 0x38493049, 0xb6496a49,
	0xc649be49, 0x3d4ace49, 0x4d4a454a, 0xa14a994a, 0xf64aa94a, 0x294bfe4a, 0x794b314b, 0x894b814b, 0x204c184c, 0x104d8e4c, 0x424d294d, 0x6e4d584d,
	0x9c4d844d, 0x234eb14d, 0x044fa54e, 0x08508c4f, 0xae506e50, 0x5e512051, 0xe2516651, 0x72523052, 0x1a531253, 0xc8536e53, 0x90543754, 0x1c55da54,
	0x2e569a55, 0x19578f56, 0x4b573257, 0x77576157, 0xae579557, 0x3f582858, 0xb258aa58, 0xd358ba58, 0x7259db58, 0x2f5ad159, 0x5d5a465a, 0xae5aa65a,
	0x095b015b, 0x845b115b, 0x195c8c5b, 0xfb5c9c5c, 0x5b5d135d, 0xc75dbf5d, 0xd75dcf5d, 0xe75ddf5d, 0xf75def5d, 0x6f5e675e, 0xac5e775e, 0x3b5ff35e,
	0xe75f915f, 0x8b603d60, 0x6561ee60, 0xea61e261, 0xd7626562, 0x6563ff62, 0xe2636d63, 0xa4646064, 0xf564bb64, 0xa5654065, 0xf365eb65, 0x24661c66,
	0x6b662c66, 0xf0667366, 0x3267f866, 0xbd677267, 0x73681668, 0x1f69d568, 0xfc698869, 0x6b6a536a, 0xf06ada6a, 0x546b4c6b, 0x756b5c6b, 0xf56b7d6b,
	0xae6c546c, 0xda6cc46c, 0x546d1f6d, 0x976d7f6d, 0xc56dae6d, 0xf66ddc6d, 0x286e106e, 0x5b6e406e, 0x916e766e, 0xe56eba6e, 0x446f116f, 0xce6f726f,
	0x94702a70, 0x7571ef70, 0x5d72b871, 0x32732a73, 0x6d733a73, 0xb473a273, 0x1574d273, 0xf7747074, 0x15768175, 0x4177c376, 0x7e78f777, 0xe9788678,
	0x41791279, 0x9b797079, 0x627a157a, 0xdb7a917a, 0x2d7b017b, 0x1a7cc97b, 0x1b7da37c, 0xa47d607d, 0x0f7ef07d, 0x707e2d7e, 0xc97ea37e, 0x137fee7e,
	0x9f7f567f, 0x5b80fc7f, 0x27818a80, 0x01999181, 0xdb82820a, 0x5a834e83, 0x0b846283, 0x24858884, 0x52853b85, 0x7a856685, 0xf485a785, 0x74864786,
	0x1587a086, 0xdb877c87, 0x63883e88, 0xcf888888, 0x2e890e89, 0x5e894689, 0x8c897589, 0xe48a298a, 0xda8b658b, 0xbc8c4b8c, 0xd38d408d, 0x178f6b8e,
	0x5c90b88f, 0xba910a91, 0x9393a492, 0xa3939b93, 0x70941094, 0x3895d094, 0x6c955295, 0x42962c96, 0x4697c896, 0x33994a98, 0xe69af999, 0x979b489b,
	0x9b9c569c, 0x0d9dde9c, 0x1d9e3e9d, 0x619fbb9e, 0x44a0e99f, 0x24a1a8a0, 0x11a2b2a1, 0xcfa261a2, 0xd1a333a3, 0x9ca486a4, 0x26a5b2a4, 0xffa591a5,
	0xd8a672a6, 0x8ea744a7, 0x2ea8e0a7, 0xd0a887a8, 0x89a91ea9, 0xadaafca9, 0x6bab57ab, 0xceab7fab, 0x25ac1dac, 0xf9ac88ac, 0x0fae68ad, 0x36afcfae,
	0xf3af94af, 0xb6b04fb0, 0x67b119b1, 0x2fb2adb1, 0x4cb3bfb2, 0xeeb3e6b3, 0x1cb405b4, 0xf9b48ab4, 0xc4b56cb5, 0x77b616b6, 0x17b7beb6, 0xbdb771b7,
	0xc1b841b8, 0xe0b8c9b8, 0x0fb9f6b8, 0x2fb927b9, 0x4eb937b9, 0xcab964b9, 0x42ba28ba, 0x74ba5bba, 0xa8ba8eba, 0x2cbbc2ba, 0xacbb94bb, 0xddbbc3bb,
	0x0fbcf6bb, 0x30bc28bc, 0x51bc38bc, 0x83bc69bc, 0xb5bc9dbc, 0xe5bccbbc, 0x16bdfdbc, 0x47bd2ebd, 0xa6bd5fbd, 0xfabde1bd, 0x25be13be, 0x50be37be,
	0xe7be66be, 0xe4bf9abf, 0x66c0ecbf, 0x8bc1f2c0, 0xa2c21dc2, 0xbbc328c3, 0x84c428c4, 0x4fc5ebc4, 0x26c6cbc5, 0x05c787c6, 0x9dc789c7, 0xc8c7b1c7,
	0xf6c7dfc7, 0x27c80dc8, 0x5ac840c8, 0x8dc873c8, 0xc0c8a6c8, 0xfdc8d9c8, 0x37c91ec9, 0x69c950c9, 0x9bc982c9, 0xcdc9b4c9, 0x08cae6c9, 0x40ca29ca,
	0x6eca57ca, 0x9dca85ca, 0xcdcab3ca, 0x00cbe6ca, 0x33cb19cb, 0x66cb4ccb, 0xa3cb7fcb, 0xdbcbc4cb, 0x0accf2cb, 0x39cc22cc, 0x68cc51cc, 0x98cc7fcc,
	0xcbccb2cc, 0xfecce5cc, 0x31cd18cd, 0x6dcd4bcd, 0xa8cd91cd, 0xd7cdbfcd, 0x06ceeecd, 0x36ce1ece, 0x65ce4dce, 0x94ce7dce, 0xc3ceacce, 0xf2cedace,
	0x1fcf07cf, 0x4acf34cf, 0x78cf60cf, 0xa5cf8dcf, 0xd5cfbdcf, 0x02d0ebcf, 0x30d019d0, 0x5ad046d0, 0xf6d09dd0, 0xbad14bd1, 0x7ad22fd2, 0x29d3c8d2,
	0xbfd392d3, 0x0fd4e7d3, 0x02000000, 0x0000c100, 0xb6050a04, 0x07000300, 0x0b402b00, 0x09020205, 0x80037004, 0x05e54a03, 0x09060927, 0x03040348,
	0x331e8207, 0x332f323f, 0x5d2b2f01, 0x2f331133, 0x13303133, 0x37211121, 0xc1300382, 0xb7fc4903, 0xfd790268, 0xfab60587, 0xe604684a, 0x93245382,
	0x9101e3ff, 0x30085384, 0xb93a0017, 0xf0ff0100, 0x140a1340, 0x80191048, 0xa0199019, 0x0e030419, 0x0202049a, 0xc0ffb804, 0x0a070a40, 0x09010448,
	0x0302139b, 0xf52f3f00, 0x086182ce, 0x102f3347, 0x315d32e1, 0x23012b30, 0x34033303, 0x3233023e, 0x1415021e, 0x2223020e, 0x5001022e, 0xf0df3379,
	0x1b2e2214, 0x14222f1a, 0x1a2f2214, 0x14222e1b, 0x18049e01, 0x3526b9fa, 0x210f0f21, 0x35252635, 0x22101022, 0x24dd8335, 0x02a60385, 0x3e8984b2,
	0x40370007, 0x07980423, 0x09d00907, 0x2f0209e0, 0x7f096f09, 0x98000309, 0x03100300, 0x82f003e0, 0x020624e4, 0x82030702, 0x82332085, 0x2f0130df,
	0x5d5de15d, 0xe12f3912, 0x03013031, 0x82210323, 0x4a012f03, 0x02297329, 0x2972292d, 0xf0fdb605, 0x03831002, 0x33246383, 0xf8040000, 0x70086382,
	0x001f001b, 0x03584099, 0x181a1a03, 0x071d1e16, 0x17170604, 0x01001906, 0xb1050404, 0x15211818, 0x04081c1f, 0x12141409, 0x040b0e0f, 0x500ab113,
	0x10100110, 0x50090c0c, 0x1c0a010a, 0x010d4801, 0x080cae0d, 0x001f0c04, 0x1911ae10, 0x113f1115, 0x11df114f, 0x0c110c03, 0x13170511, 0x00050a06,
	0x333f332f, 0x2f393912, 0x33115d2f, 0x32e11033, 0x22068432, 0x8232325d, 0x2db383ac, 0xe4105d2f, 0x11323917, 0x11391712, 0x0a832f33, 0x0b863320,
	0x832f3321, 0x152121c5, 0x1320c582, 0x35230384, 0x82211321, 0x03332303, 0x03821321, 0x82011521, 0x0331080e, 0x18013fd7, 0x9352cdfe, 0x52ddfe54,
	0xfefe4e90, 0xfe411d01, 0x522b01ee, 0x25015293, 0x01549054, 0x01ebfc06, 0xddfe4023, 0xb8fe7d03, 0x0154fe89, 0x270383ac, 0x89480189, 0x50feb001,
	0x80080383, 0x01b8fe89, 0x00030048, 0x0389ff7b, 0x001206d9, 0x0036002d, 0x40b4003f, 0x292f3433, 0x212f2901, 0x70062101, 0x3c013c2f, 0x1e011e2f,
	0x01072013, 0x2e0d0707, 0x000f246e, 0xff02001f, 0x00000100, 0x41000701, 0x6e370d0d, 0x190119e0, 0x40c0ffb8, 0x480b0830, 0x14143319, 0x133c3c29,
	0x3d08372e, 0x25217328, 0x0e401f21, 0x1f1f4811, 0x0121501e, 0x211f210f, 0x34210802, 0x0e087313, 0x05060608, 0x33348208, 0x480d0ab3, 0x2b2f0008,
	0x112f3333, 0x32e11033, 0x5d5d5e2f, 0x2b200b82, 0x12320c84, 0x39123939, 0x11333311, 0x2b2f0133, 0x2f33e15d, 0x1e82d610, 0xe1327125, 0x822f3911,
	0x335d2525, 0x5d32e15d, 0x28080182, 0x14013031, 0x1507020e, 0x2e223523, 0x1e352702, 0x2e113303, 0x3e343503, 0x33353702, 0x17161615, 0x27262607,
	0x07031e11, 0x081d8234, 0x363611d8, 0x021e1401, 0x06061117, 0x5d32d903, 0x328a5485, 0x20546066, 0x65605721, 0x5683592f, 0x815b312a, 0xa9648a4f,
	0x8c384243, 0x5b87584a, 0x2b14b02e, 0x5b5d3346, 0x281112fe, 0x53593142, 0x7246be01, 0xe60c3754, 0x1a1209dd, 0x2110ac11, 0xb201111a, 0x6e55421e,
	0x536f434a, 0xb0b40935, 0x911f2a05, 0xfe062919, 0x53421f5a, 0x3721486b, 0xfe12262d, 0x02620e8b, 0x2f3924a3, 0x71011126, 0x00005910, 0xff660005,
	0x053306ec, 0x000900cb, 0x0027001d, 0x003f003b, 0x103cb25d, 0xf0ffb83e, 0x3e3c3340, 0x14283e3c, 0xb532b41e, 0x4128b423, 0x0501410f, 0x00b50ab4,
	0x201410b4, 0x03143014, 0x3e063f14, 0x37b62518, 0x2db621b7, 0x0fb60319, 0x19b607b7, 0xe13f0007, 0x0384e1f4, 0x2f013f23, 0x220b825d, 0x82de105d,
	0x12113505, 0x2f2f3939, 0x30313838, 0x33161413, 0x23101132, 0x14050622, 0x20059643, 0x06a64335, 0x19990120, 0x0123013d, 0x9c5047fa, 0x0147509c,
	0x734a24c7, 0x4c70494f, 0x71492326, 0x4d714b4e, 0x86ac0127, 0x23c62119, 0x4a221982, 0x19864b70, 0x274c2708, 0xd5fc00ff, 0x042c039e, 0x01a5a502,
	0xa348014a, 0x76ac6ca5, 0xac763f3f, 0x75aa6c6c, 0xaa753e3e, 0xa4a54afd, 0x18844901, 0x1883ab20, 0x1887ab20, 0x92035608, 0xb6054afa, 0x00030000,
	0x05ecff6d, 0x00cd057d, 0x00210011, 0x40800053, 0x1718274d, 0x2c49044a, 0x470a4849, 0x42474136, 0x36014220, 0x1d423642, 0x473c3b05, 0x47004804,
	0x2c102c00, 0x2c2c0802, 0x01482022, 0x481d5548, 0x22202210, 0x41412202, 0x4f511231, 0x323b8416, 0x3b3c470f, 0x49310405, 0x31500f15, 0x3fe12f00,
	0x82391712, 0xe13f2b02, 0x012f3911, 0x10e15d2f, 0x09825dc6, 0xe15d5e23, 0x2b178211, 0x2f2f3939, 0x10e1105d, 0x113311e1, 0x31382482, 0x1e140130,
	0x033e1702, 0x022e3435, 0x13062223, 0x37023e32, 0x15030e01, 0x25211582, 0x420b8234, 0xf2440569, 0x07620807, 0x37033e01, 0x07030e33, 0x0e272301,
	0x2e222303, 0x10a60102, 0x3b243421, 0x191c3856, 0x562a422f, 0x623a8764, 0xfe204854, 0x3750347d, 0x6042231c, 0x4d287dfe, 0x3c1f476f, 0x5e321c2d,
	0x8353588a, 0x5432305b, 0x60013c6d, 0x1b222b1b, 0x290fb80a, 0x01274135, 0x31a8e115, 0x4e7c6c60, 0x3d73a769, 0xd9828d04, 0x25436608, 0x46403e23,
	0x2c3d2429, 0xaffb5919, 0x1f362817, 0x3f219701, 0x36385548, 0xf024415b, 0x56647a4e, 0x574d242a, 0x774b3963, 0x532b2b53, 0x6d404b77, 0xfe244f5d,
	0x443c1d8c, 0x6f422f4e, 0xfe295562, 0x472dacdb, 0x67351b31, 0x00010095, 0x01a60385, 0x00b6054a, 0x402a0003, 0xd005c01c, 0x0305e005, 0x056f052f,
	0x0b6c4502, 0x03020227, 0x333f0003, 0x0568452f, 0x23056445, 0x73294a01, 0x20065b45, 0x24478200, 0x02bcfe52, 0x2a47822b, 0x401a0013, 0xf20e060d,
	0x823ff009, 0xf90e2615, 0x3f00f805, 0x0837833f, 0x3132e438, 0x3e341330, 0x06333702, 0x1e141502, 0x2e231702, 0x4a245203, 0x8cac4e71, 0x6a472591,
	0x714eaa45, 0x3102244a, 0xd3e5f37d, 0x32fec15d, 0xe2ec77f4, 0xce5a5ed4, 0x5d83f0e1, 0x5d823d20, 0x5d841720, 0x0e401c22, 0x0b225d82, 0x5d82b0f0,
	0xf80e1524, 0x5e83f905, 0x5dde1023, 0x3f5f83e1, 0x020e1401, 0x033e2307, 0x27023435, 0x02031e33, 0x714b2417, 0x6a45aa4e, 0x8d902448, 0x4b714eac,
	0x7c315f82, 0x5acee1f0, 0xece2d45e, 0xce01f477, 0xe5d35dc1, 0x2ebd84f3, 0x14047702, 0x0e001406, 0x15402400, 0x8201101f, 0x800e39fc, 0x030e900e,
	0x061f0e08, 0x00060601, 0x323f0000, 0x2f015d2f, 0x5de55d5e, 0x3708ff83, 0x13051725, 0x27030307, 0x05372513, 0x2b980203, 0xfe1a8d01, 0xb0b2f586,
	0xfef2b89e, 0x87011d89, 0xfe14062b, 0x1cc16f77, 0x0160bafe, 0x609afe66, 0xc11c4601, 0x0089016f, 0x3008b582, 0x04060166, 0x00a20402, 0x4029000b,
	0x010d1018, 0x03aa0906, 0x200100ef, 0xa0006000, 0x09000300, 0x0306ad00, 0x333f00b3, 0x2f0132e1, 0xe1325d5d, 0x08708332, 0x21352120, 0x21113311,
	0x23112115, 0x7dfee901, 0x01968301, 0x967dfe83, 0x01968702, 0x967bfe85, 0x59837ffe, 0xf8fe3f30, 0xee007901, 0x38000c00, 0x0ecf1440, 0xc1821001,
	0x0ea02108, 0x2b0c1b03, 0x010c020c, 0xb8070697, 0x0d40c0ff, 0x5f481410, 0x07100107, 0x9c060701, 0xed2f000c, 0x2b256583, 0x5d32ed33, 0x0868825d,
	0x0e172522, 0x3e230703, 0x6a013703, 0x2f270e0f, 0x0f8a1933, 0x08161b1d, 0x7a3617ee, 0x3d387b7c, 0x357d8384, 0x52266983, 0x4202d101, 0xae827902,
	0x09401525, 0x82400502, 0xb90025d6, 0xe12f0001, 0x102e4c82, 0x133031ce, 0x52152135, 0xd101f001, 0x1a82a8a8, 0xff932708, 0x009101e3, 0x001300fa,
	0x801b4035, 0xa0159015, 0x15110315, 0xc0960a01, 0x0200d000, 0x00440034, 0x00740064, 0x9e820004, 0x0a07b627, 0x9b050048, 0x2397840f, 0xed5d5d2b,
	0x37209483, 0x200e5648, 0x0f514893, 0x4c486f20, 0x0001280f, 0x02000014, 0x82b605e7, 0xb11e26a1, 0xffb80201, 0x25a782f0, 0x00100003, 0x12820105,
	0x112f3f38, 0x32383301, 0x3133382f, 0x23010130, 0xfde70201, 0x2102b3e0, 0x8544b605, 0x00022805, 0x04ecff62, 0x82cd0508, 0x00273db1, 0x1e154026,
	0x1029006f, 0x6f140129, 0x0a010a20, 0x070f7323, 0x19057319, 0x3fe13f00, 0xe124ef83, 0xe1de105d, 0x14394782, 0x23060602, 0x02262622, 0x36123435,
	0x16323336, 0x14051216, 0x3233021e, 0x0811823e, 0x23022e53, 0x04020e22, 0xb2713308, 0x73af767f, 0xb16f3339, 0x74b0777e, 0x1e13fd3a, 0x4d4d6b42,
	0x1f1f456c, 0x4d4d6c45, 0x021e426b, 0xe8feb1dd, 0xc26666c2, 0xb1b11801, 0x66c11801, 0xe8fec165, 0x95e096b2, 0xe1944a4b, 0x94e09697, 0xe0944a4a,
	0x00010000, 0x20e182b2, 0x08e182c7, 0x35001066, 0x12402140, 0x0e010f01, 0xbf6e000e, 0x0201ff01, 0x0001017e, 0x20011001, 0x04014001, 0x0f0d0106,
	0x00180006, 0x01cd3f3f, 0x5d5d5e2f, 0x2f33e15d, 0x315d3311, 0x11232130, 0x37023e34, 0x0707030e, 0x02330127, 0x0301b0c7, 0x1a110103, 0x94151e1b,
	0x967f0160, 0x622b9103, 0x12225961, 0x121b181a, 0x2b017b79, 0x2b087182, 0x03000060, 0x00cb05f0, 0x403c0023, 0x6f082320, 0x10251b1b, 0x6f220125,
	0x11012101, 0x01012011, 0x10220801, 0x0716730d, 0x01742202, 0xe1297082, 0x33e13f32, 0x2f013912, 0x2771835d, 0x115ded10, 0x33e12f33, 0x21227882,
	0x52450135, 0x27072308, 0x3f45033e, 0x154c0809, 0xfcf00321, 0x4b5e0170, 0x222c5376, 0x5f35563f, 0x28664599, 0x41766a5c, 0x3b6c9b60, 0x4b815d35,
	0xb102e7fe, 0x517d019c, 0x4c818086, 0x203f5a3b, 0x24773c4d, 0x361b2e3f, 0x555b9165, 0x5196959a, 0x0008d5fe, 0x52000100, 0xee03ecff, 0x4008a982,
	0x405d0039, 0x2130210b, 0x6f1a1230, 0x006f2709, 0x40c0ffb8, 0x48171428, 0x3b090000, 0x4f013b20, 0x06120112, 0x21ab7320, 0x01217901, 0x0801210b,
	0x2f152121, 0x0735732c, 0x0e127315, 0x333f0019, 0x41c184e1, 0xc8830536, 0xce105d2d, 0xe12b2f32, 0x3911e110, 0x482f2f39, 0x1621077a, 0x05f04a16,
	0x35272624, 0xef411616, 0x35232108, 0x22210a88, 0x08e68706, 0x2ec103a6, 0xb1477453, 0xca8441b8, 0x55c16d8a, 0x5c5dcb57, 0x35295786, 0x85598d62,
	0x557e5185, 0x5c42242c, 0x4aa36b38, 0x6e5d265c, 0xa36c467d, 0x6004386e, 0x39587849, 0xb516060c, 0x74a06091, 0xaa2d2240, 0x4a28322e, 0x6144436c,
	0x28971e3f, 0x343d664a, 0x431e3952, 0x361f7d36, 0x61361829, 0x00020085, 0x04000017, 0x00be053f, 0x0018000a, 0x092c404e, 0x00010056, 0x116e0200,
	0x20070b0c, 0x03030103, 0x011a101a, 0x18871877, 0x055f1802, 0x06090501, 0x05017418, 0x07110205, 0x00180206, 0x12333f3f, 0xe1332f39, 0x2105a64a,
	0x0c825d5d, 0x82335d21, 0x32e12400, 0x82325d2f, 0x234608ee, 0x21112311, 0x11330135, 0x34112133, 0x2337023e, 0x0107030e, 0xb0d53f04, 0x97025dfd,
	0x7bfed5bc, 0x01050403, 0x19150709, 0x65fe0b1a, 0xb8fe4801, 0x039f4801, 0x0130fcd7, 0x757b3864, 0x31142266, 0xfd102e31, 0x918200a0, 0xecff8328,
	0xb605f603, 0xa3822a00, 0x26182e08, 0x2c056f1a, 0x27012c10, 0x68282424, 0x23590123, 0xf0232301, 0xb80f010f, 0x1240c0ff, 0x0f480b08, 0x0000731d,
	0x24742715, 0x10731506, 0x0698410a, 0xe1279b82, 0x5d2b2f01, 0x825d2f33, 0x331126a3, 0xe1de105d, 0x4ca38233, 0x27230a7f, 0x41031e35, 0x95080584,
	0x0e222326, 0x13270702, 0x03211521, 0x21023636, 0x487fab63, 0x80c58644, 0x525b6333, 0x62592121, 0x7c4f2a63, 0xa8b02e56, 0x393f3f1b, 0x02375a15,
	0x27ecfdb2, 0x81036920, 0x69a06c37, 0x437eb672, 0x141e130a, 0x182417ac, 0x764e250d, 0x05978f51, 0x39040908, 0xfea6b002, 0x000e065d, 0x71000200,
	0x0a04ecff, 0x2b00cb05, 0x37003f00, 0x6e312040, 0x1041220c, 0x3b170141, 0x1000006f, 0x03002000, 0x1d753600, 0x732c071d, 0x73101927, 0x3f000707,
	0x11e13fe1, 0xbf822f39, 0x32e15d22, 0x3228b882, 0x133031e1, 0x33043e34, 0x1722bc82, 0xad832615, 0x33070422, 0x24091943, 0x022e2223, 0x0a484401,
	0x14158808, 0x1571021e, 0xc68e5c35, 0x2f2e1385, 0x5823112b, 0x64895a2b, 0x03142a43, 0x4c39140c, 0x9a5f3b5f, 0x743e3b6c, 0xaf6466a4, 0xdb014a80,
	0x2748633c, 0x42634221, 0x2b4e6f43, 0x026e4925, 0xbfd06971, 0x024579a4, 0x9b050705, 0x4e2b0c0c, 0x5094836c, 0x1a2d3f24, 0x6aa5723b, 0x447fb672,
	0xfef2a04e, 0x7f5329b9, 0x4e6f4657, 0x604b2f2a, 0x6a854330, 0x00010043, 0x0400005a, 0x00b60506, 0xb12b0006, 0xffb80006, 0x821140f0, 0x05012afc,
	0x01081008, 0x74020502, 0x05674403, 0x0132e127, 0xce105d2f, 0x08e08232, 0x31333880, 0x21012130, 0x01152135, 0x33021901, 0xac030efd, 0x1005d5fd,
	0xdbfa91a6, 0x6a000300, 0x0004ecff, 0x2700cd05, 0x4a003a00, 0x53408000, 0x6e32231e, 0x48280a0f, 0xd305c36e, 0x05b50205, 0x0f050501, 0x014c104c,
	0x3e196e28, 0x0123d56e, 0xba0123cc, 0x23230123, 0x19201910, 0x1e0a1902, 0x38983868, 0x01385902, 0x38383828, 0x38033848, 0x26014393, 0x02435643,
	0x2d004343, 0x3b191473, 0x6a410073, 0x5d5d2708, 0x5d5d5dc1, 0x9a823939, 0x822f3321, 0x10e12209, 0x82a383e1, 0x12e1260a, 0x11e11039, 0x09394239,
	0x031e0722, 0x2205cf43, 0x4935022e, 0x032009e4, 0x270acb45, 0x06062727, 0x15062201, 0x08071c4a, 0x350226b7, 0x42719554, 0x38604628, 0x35576f3a,
	0x66a97943, 0x3d75ab6e, 0x3a684c2d, 0x253f5631, 0xc7957243, 0x48684420, 0x24486b46, 0x3f664927, 0x01807e1e, 0x237d6a16, 0x3033573e, 0x7e243f55,
	0x582ccd05, 0x6c435884, 0x1f1c4557, 0x49765f4c, 0x3868955c, 0x5c926536, 0x4a60784b, 0x5a491f1c, 0x8357426d, 0xa6fb2c58, 0x233f5935, 0x385c4123,
	0x40485434, 0x9b3c0e1f, 0x656a5403, 0x33405239, 0x42341618, 0x6a653654, 0x00020000, 0x04ecff6a, 0x00cb0504, 0x003d0029, 0x391e4035, 0x3f006f15,
	0x2f013f10, 0x20100c6e, 0x20022020, 0x1b1b7534, 0x25732a07, 0x07751007, 0x0b87421a, 0x5de13330, 0x32e1de10, 0x14013031, 0x2223040e, 0xcc44022e,
	0x23372107, 0x4c05cb4a, 0x22220835, 0xf983020e, 0x23055843, 0x0404022e, 0x3e078842, 0x23112c2e, 0xae872b58, 0x0d052b66, 0x604c3814, 0x6c9a5f3b,
	0xa5733f3b, 0x80ae6566, 0x4225fe4a, 0x443c0786, 0x252b4e6e, 0x46036e49, 0xa5bed169, 0x05024578, 0x0d9c0506, 0xd6a15e0c, 0x2e3e2477, 0x29058442,
	0x4e447fb7, 0x4701f3a0, 0x84425428, 0x426b210b, 0x933be183, 0x9101e3ff, 0x13006604, 0x3e002700, 0x29101c40, 0x29902980, 0x1e0429a0, 0x4814960a,
	0x40291150, 0x480a070b, 0x199b2300, 0x05554810, 0x01ed3f2c, 0x5d5d2b2f, 0x5d32e533, 0x58483031, 0x4811200f, 0x78481f68, 0x9103361f, 0x0e213527,
	0x2735210e, 0x10223425, 0x00342210, 0xfe3f0002, 0x08af84f8, 0x20000c2b, 0x2f406100, 0x22802210, 0x22a02290, 0xc0961704, 0x020dd00d, 0x0d740d64,
	0x010d5002, 0x3b010d44, 0x0d1f010d, 0x0d020d2f, 0x0db2490d, 0xb2491120, 0x9b1c2309, 0xb6491012, 0x29c88305, 0x332b5d5d, 0x335d32ed, 0x00845d2f,
	0xc049e520, 0x108b510b, 0x200cd049, 0x49c98f11, 0x02210be1, 0x08c58fed, 0x66000141, 0x0204ee00, 0x0600dd04, 0x30404e00, 0x08400800, 0x01014001,
	0x05010201, 0x6f060305, 0x02007f00, 0x00010030, 0x03200400, 0x70035001, 0xd0038003, 0x0503f003, 0x0001033f, 0x03060103, 0x825e2f00, 0x337121a0,
	0x3228a883, 0x2f3d3912, 0x18013333, 0x4e08b482, 0x3031ce10, 0x01350125, 0x04010115, 0x0364fc02, 0x0221fd9c, 0xa801eedf, 0xa0e10166, 0xbefe94fe,
	0x66000200, 0x0204ba01, 0x0300e903, 0x5c000700, 0x02073d40, 0x01094009, 0x0100c604, 0xa90100bb, 0x00860100, 0x01007b01, 0x42010068, 0x82390100,
	0xad043981, 0x052f051f, 0x01057f02, 0x05100500, 0x05050602, 0x01f0ad00, 0x6f010f01, 0x0020ab82, 0xe1217282, 0x228b8333, 0x4101e171, 0x5d260633,
	0x105d335d, 0xb24a32ce, 0x35012605, 0x03661521, 0x2889839c, 0x95955403, 0x969666fe, 0x8c548200, 0x840520fb, 0x01062efb, 0x01040506, 0x6f000301,
	0x02067f06, 0x210e8230, 0xfba10206, 0xfb8e3320, 0x84011321, 0x026624fc, 0x8320fde0, 0x8f012b76, 0x6c014201, 0x661ffea0, 0xfb8258fe, 0xff253108,
	0x052503e3, 0x002700cb, 0x403e003b, 0x289a3221, 0x00462728, 0x460b1400, 0x3d2f3d1c, 0x170b1401, 0x0601000f, 0x9b2d0000, 0x51101337, 0x3f000417,
	0xe521dd82, 0x21e08232, 0xdf823912, 0xe1de1025, 0x822f3911, 0x31e12812, 0x34350130, 0x4937023e, 0x36210a75, 0x08754936, 0x15030e23, 0x102d4215,
	0x0f192008, 0x30324227, 0x1e152b44, 0x53385539, 0x513f4696, 0x955d61bc, 0x361b3868, 0x42343650, 0x42bb0e26, 0x26080f40, 0x39259e01, 0x2a4d505c,
	0x4f454329, 0x394f3035, 0x9122341f, 0x60333b2a, 0x6943578b, 0x2d2f545a, 0x2c423f43, 0x4bd1fe12, 0x71080fa9, 0xff6d0002, 0x0581064a, 0x005700b6,
	0x406f0068, 0x6017583f, 0x01171f27, 0x1701277f, 0x27464627, 0x314e0317, 0x00010020, 0x016a406a, 0x014e403b, 0x5b0c2c4e, 0x64120712, 0x1f120f1c,
	0x0312bf12, 0x011c0006, 0x121c1207, 0x5336401c, 0x49454003, 0xc1332f00, 0x3912c13f, 0x5e2f2f39, 0x105d5e5d, 0x103311c1, 0x013232c1, 0x5dc15d2f,
	0xc171de10, 0x19821711, 0x825d2f21, 0xc1102118, 0x440aeb44, 0x17250ee3, 0x14060603, 0x0be54414, 0x04222322, 0x2a05b74e, 0x023e3233, 0x06061537,
	0x4b242223, 0x242805ea, 0x16043233, 0x16140112, 0xc5081984, 0x23262637, 0x06020e22, 0x39251381, 0x2d3a614c, 0x06213449, 0x47361204, 0x774d3559,
	0x6f3b2b52, 0x5a2d629e, 0x17174552, 0x22150101, 0x462e172b, 0x9856182f, 0xfea97bd1, 0x4f5aaffe, 0x3d93e399, 0x2b646f77, 0xb382d856, 0x66c3e7fe,
	0x3701db76, 0x06019cc1, 0x15fc6abf, 0x4e375565, 0x0e041a32, 0x4a2a4d1c, 0x021c3f65, 0x717d3edb, 0x1e294861, 0x25234132, 0x381c3142, 0x65568e65,
	0x08447aa8, 0xfe08110e, 0x101b1660, 0x44350308, 0x683d0f28, 0xdd8e4e8c, 0xc76f4f98, 0x97a2effe, 0x0e52a0ea, 0x8d111f18, 0xc3662c26, 0xbcb31901,
	0x88ee4501, 0xf1febd65, 0x7785d5fe, 0x4573532d, 0x3a0d08fd, 0x0000785e, 0x00820002, 0xdd047e08, 0x0700bc05, 0x84001400, 0x05062440, 0x46010246,
	0x14020114, 0x01084903, 0x08010149, 0x0e0e0001, 0x10000003, 0x07800107, 0x07d00790, 0xffb80703, 0x061840c0, 0x1007480a, 0x0f160707, 0x2f161f16,
	0x9f168f16, 0x0616df16, 0xb8040307, 0x1140f0ff, 0x0e5f0204, 0x480e0a20, 0x1414050e, 0x00040305, 0x323f0012, 0x122f393f, 0x01e12b39, 0x5e33382f,
	0x2f33115d, 0x715d2b38, 0x39121133, 0x2416823d, 0x125d5d39, 0x08048239, 0x31333397, 0x21032130, 0x33012303, 0x2e030101, 0x030e2703, 0x1f040307,
	0xa2dffda0, 0xaa1902bc, 0x67fe1a02, 0x12110694, 0x12070812, 0x91061112, 0x3bfec501, 0x44fabc05, 0xa8016a02, 0x413c3412, 0x3d421f1f, 0x58fe1133,
	0x00030000, 0x040000c7, 0x00b60587, 0x00220017, 0x4062002f, 0x5a1e0b3e, 0xe5010605, 0x0206f506, 0x060106d6, 0x5b2a2406, 0x11801170, 0x31671102,
	0x318f317f, 0x01311002, 0x175a2418, 0x230b3064, 0x01187960, 0x0801180b, 0x24001818, 0x22121760, 0x494f8260, 0x5e3b06c7, 0x39e15d5d, 0xe1f61001,
	0x105d5d32, 0x12e15df6, 0x5d5d2f39, 0x3132e171, 0x4a211330, 0x0721068e, 0x06554815, 0x47132121, 0x26270538, 0x11112323, 0x4e3e3221, 0x7508051c,
	0x808f01c7, 0x274283c3, 0x45456d4a, 0x41345a79, 0xfe6fb07b, 0x54f4ba1b, 0x9a1f4672, 0x0a01dfa6, 0x20497758, 0x5c7c4b21, 0x5727b605, 0x6c3e678d,
	0x0a093752, 0x784f2d0c, 0x6d9d6456, 0x1e4a033a, 0x783b593b, 0xfd97fd68, 0x654828f0, 0x435e383d, 0x01000025, 0xecff7d00, 0xcb059804, 0x4c002300,
	0x0eaf1440, 0x15400e01, 0x0e0e4818, 0x0120ba18, 0x20702060, 0xb3412002, 0x20203807, 0x0125af25, 0x66185b05, 0x5f002124, 0x0a0d041d, 0x0013135f,
	0x8233e13f, 0x26d68302, 0x2f33115d, 0x825d5d2b, 0x5d2b24d6, 0x48013031, 0x36240800, 0x030e1537, 0x080cf34e, 0x2607176a, 0x6b190326, 0x3b437bae,
	0x5976b076, 0x4e274ea0, 0xa43b6155, 0x574c9df0, 0x6ca2faa9, 0x3f4e4fc4, 0x51270594, 0x8d89da98, 0x234e96db, 0x170fa217, 0xc66c070e, 0xa6a91601,
	0x6ec61401, 0x209c2a2c, 0x0002002e, 0x040000c7, 0x00b605fc, 0x0017000c, 0x0d154026, 0x1967005b, 0x14011910, 0x1864065a, 0x03076013, 0x12066014,
	0x3f219f82, 0x229d84e1, 0x82e1f610, 0x02143495, 0x21230406, 0x16322111, 0x34071216, 0x2323022e, 0x82203311, 0x60300846, 0xa8f7feb6, 0x970192fe,
	0x5faef899, 0xb87e42c5, 0x01a2c975, 0x020c0108, 0xe9feb9e9, 0xb6055ebb, 0xf4feb55c, 0x8ad592b6, 0x0189fb43, 0x01000024, 0x03217d83, 0x087d82be,
	0x42000b29, 0x08142640, 0x01080801, 0x0d670004, 0x015a0a06, 0x5f090c64, 0x0f01064f, 0x0206af06, 0x0a060608, 0x03025f05, 0x85015f0a, 0x3912258c,
	0x715d5e2f, 0x322a9384, 0x1132e610, 0x315d2f39, 0x92822130, 0x03861520, 0xfdbe0335, 0xfdf70209, 0xfd1702c3, 0x053d02e9, 0x3cfea4b6, 0x8af8fda2,
	0x00092471, 0x82114070, 0x0f24086e, 0x03ff0103, 0x90038001, 0x0303d003, 0xc0ffb803, 0x0a073840, 0x0b030348, 0x0b2f0b0f, 0x0baf0b8f, 0x00060704,
	0x0a238d82, 0x830f5f09, 0x063f348d, 0x06ff066f, 0x40060804, 0x06481d1a, 0x48151040, 0x83000606, 0x8200209b, 0xe13f2199, 0x2b219882, 0x209a882b,
	0x06ce415e, 0x16827120, 0x23229f82, 0x9f852111, 0xba810122, 0x9a829c87, 0xa4fcfd23, 0x06434200, 0x05f22908, 0x002b00cb, 0x2b1e4037, 0x5a290c2b,
	0x2d670214, 0x1f012d10, 0x2c660c5b, 0x00005f2b, 0x115f1a24, 0x075f2404, 0xe13f0013, 0xe1206a84, 0x29069441, 0x3911e132, 0x0130312f, 0x24421121,
	0x3324280a, 0x07171632, 0x4223032e, 0x55080844, 0x1137023e, 0x010e0321, 0x767037e4, 0xf29d4b82, 0xb65f56a6, 0x6fab0b01, 0x244858cc, 0x2e5d5853,
	0x427fbc7a, 0x86be7837, 0x373e492c, 0x03d5fe1a, 0x1233fd04, 0x690a131c, 0xae1701c3, 0xc31601ac, 0xa22a2c69, 0x0e171e11, 0x89da9851, 0x569cd882,
	0x050b0805, 0xbb83b401, 0x00c72d08, 0x05d50400, 0x000b00b6, 0x0923403d, 0x65005a01, 0x010dc00d, 0x20010dbf, 0x0408010d, 0x0c64055a, 0x080f5f03,
	0x08080801, 0x0503060a, 0x24058f44, 0x5e2f3933, 0x27c1845d, 0x5d5d5d32, 0x32e1f610, 0x3b052241, 0x33112311, 0x33112111, 0xfdbad504, 0x02baba66,
	0xaa02ba9a, 0xb60556fd, 0x680298fd, 0x52246b83, 0x64020000, 0x3b086b84, 0x0b264057, 0x020d2b0d, 0x0d9b0d7b, 0x0dfb0dab, 0x010d5404, 0x0d3b0d2b,
	0x1f030d4b, 0x0802010d, 0x055a0a0b, 0x0103c902, 0xf8ffb803, 0x100d1040, 0x01030048, 0x04090306, 0x0a030306, 0xc1258383, 0x32c13f32, 0x28858201,
	0x32c15d2b, 0x5f32c1f1, 0x2000825d, 0x08858271, 0x37352127, 0x21352711, 0x17110715, 0xeefd6402, 0x1202acac, 0x2966acac, 0x66299804, 0x68fb2966,
	0xff010029, 0x017bfe48, 0x08858273, 0x2f001324, 0x15df1c40, 0x70156001, 0x152f0215, 0x0c5a0f01, 0x0c000303, 0x07020c10, 0x07030d0c, 0x2f00005f,
	0x63833fe1, 0x102f3323, 0x235e82e1, 0x22033031, 0x8209bd50, 0x142408e9, 0x331d020e, 0x4e221c4c, 0x3d4b252d, 0x693bbb26, 0x0d7bfe93, 0x0b09a00b,
	0x44583213, 0x5efab605, 0x31659a69, 0x20076341, 0x377182a2, 0x4064000c, 0x660c022d, 0x000c010c, 0x0b100b0a, 0x0000010b, 0x07020010, 0x00290482,
	0x010eb00e, 0x10010e2f, 0x0575410e, 0x10020d2b, 0x0848100b, 0x40f0ffb8, 0x3208820c, 0x0a050802, 0x05000306, 0x333f0012, 0x3912333f, 0x452b2b39,
	0x5d27064a, 0x382f3311, 0x82335d5e, 0x11332205, 0x270d8239, 0x23213031, 0x23110701, 0x373fa082, 0x04013301, 0x3dfed3a2, 0x79baba8b, 0xfdd1c401,
	0x72ba02f8, 0xb605b8fd, 0x02a825fd, 0x4383fd33, 0x05360bc7, 0x13402300, 0x07af0704, 0x01071001, 0x64005a03, 0x03030106, 0x7082005f, 0x833fe121,
	0x845d206a, 0x8233205a, 0x15212555, 0x3d02bac7, 0xf021df82, 0x059543a6, 0x822f0621, 0x00193cdb, 0x3613408b, 0x00390119, 0x080e1701, 0x39480f0c,
	0x110e010e, 0xffb8195a, 0x821c40f8, 0x0019210e, 0x00321483, 0x090c0d0d, 0x4f1b6510, 0x1b20011b, 0x011b0f01, 0x20830b08, 0x20821a20, 0x010b263a,
	0x5a08020b, 0x181a6409, 0x09100101, 0x0e014812, 0x0c11030b, 0xb6f0ffb8, 0x0c210c82, 0x298a8308, 0x322b3232, 0x2b33333f, 0xfd843311, 0x2b5d3231,
	0x5d5d5d5e, 0x3911f610, 0x2b331139, 0x82e12b33, 0x31323411, 0x215d5d30, 0x17162301, 0x11151616, 0x01211123, 0x82210133, 0x343b0807, 0x37363736,
	0x23030123, 0x060845fe, 0xac050404, 0x9c011401, 0x019e0106, 0x0304ba14, 0xfe080304, 0x4a000541, 0x398b3f49, 0xb60596fc, 0xa80458fb, 0x77034afa,
	0x473d8634, 0x8502fb49, 0x0e0521e7, 0x2d08e782, 0x40510017, 0x01280e29, 0x5a150101, 0xb0196500, 0x198f0119, 0x10190001, 0x0c270219, 0x09030c01,
	0x18640a5a, 0x06100216, 0x0b024818, 0xbd830d03, 0x0d210a82, 0x20bd860a, 0x86a5823f, 0x82b884ba, 0x21af82b0, 0xae892321, 0x3301332e, 0x032e2726,
	0x05331135, 0x31fdd70e, 0xd533aa85, 0x0307cc02, 0x03030104, 0xba04ae01, 0x8e414c4d, 0x82e7fc39, 0x4c4c32a4, 0x4343204a, 0x20031a3e, 0x00020000,
	0x05ecff7d, 0x068f5571, 0x40342108, 0x005b1e20, 0x29c02967, 0x0129bf01, 0x2f012970, 0x02295f29, 0x660a5b14, 0x0f5f2328, 0x055f1904, 0x41058944,
	0x5d2105d9, 0x081d465d, 0x081f9d55, 0x51710548, 0xa39beda0, 0x4c4c9def, 0x9ba3f09e, 0xfb51a0eb, 0xa56b34d1, 0x6ba57272, 0xa46a3232, 0x6ca67272,
	0xa9dd0234, 0x6cc6eafe, 0x1701c66c, 0x1501aaaa, 0xc56b6bc4, 0x89abebfe, 0x515199db, 0x8a89db99, 0x515197da, 0xb183da97, 0x00c74108, 0x05330400,
	0x000e00b6, 0x40460019, 0x285b152c, 0x48003800, 0x67000300, 0x011bcf1b, 0x0f011b40, 0x0f06011b, 0x64085a07, 0x30600f1a, 0x02064006, 0x19070606,
	0x07030960, 0x3f3f0012, 0x2f3911e1, 0x42068544, 0x5d310505, 0x013031e1, 0x23020e14, 0x11231123, 0x021e3221, 0x08454801, 0x33046508, 0x98cf7e37,
	0x6a01ba96, 0x3c7ec286, 0x5d814efd, 0xa42e5b8b, 0x0a04a0ae, 0x4d81a85b, 0xb605c7fd, 0xfea06d39, 0x71472067, 0x00898e51, 0xfe7d0002, 0x05710562,
	0x001d00cd, 0x40380031, 0x005b2822, 0x33c03367, 0x0133bf01, 0x2f013370, 0x02335f33, 0x66145b1e, 0x195f2d32, 0x055f2304, 0x0009130f, 0xe1333f2f,
	0x41066a47, 0x8b8505d9, 0x5d5d0720, 0x41062006, 0x312d2158, 0x2b5d8e5f, 0x67795a89, 0x291133ad, 0x1f624112, 0xb5e2832d, 0x8f5e2684, 0xc6498e3c,
	0x4102027f, 0x3108256b, 0x00b605a0, 0x001c000f, 0x09564082, 0x020f190f, 0x0f010ff9, 0x480f0b08, 0x0c090c0f, 0x010c0701, 0x07085b16, 0x07020718,
	0x010e0907, 0x0ef90ee9, 0x1d830e02, 0x0d0e2008, 0x3f1e0d10, 0x9f1e8f1e, 0xdf1ebf1e, 0x1e20051e, 0x5a011001, 0x0c1d6402, 0x00601003, 0x82080100,
	0x601c3203, 0x010e0303, 0x333f0012, 0x3911e13f, 0xe15d5e2f, 0x08eb4912, 0x3238ce27, 0x32715d2b, 0x2313832f, 0x33115d5e, 0x31310c82, 0x23110130,
	0x16202111, 0x020e1415, 0x01230107, 0x05a94127, 0x022e7008, 0x81012323, 0x016401ba, 0x5131fe0a, 0x8e013768, 0xe5a1fedb, 0x517e5aa4, 0x7f532925,
	0x5c02a057, 0xb605a4fd, 0x8257d1ce, 0xfd143e5d, 0x9e5c0271, 0x45674523, 0x1d406448, 0x68000100, 0xc903ecff, 0x3300cb05, 0x27404200, 0x23012359,
	0x67005a11, 0xff35bf35, 0x35600235, 0x01353f01, 0x1b095a2a, 0x2a113466, 0x245f2705, 0x600e0420, 0x82130509, 0x3fe122b0, 0x83ac8233, 0xe13221ad,
	0x2105b941, 0xbb415d33, 0x22232205, 0x051c5526, 0x34353627, 0x2e27022e, 0x05dd5103, 0x07171625, 0x52232626, 0x5b0806d9, 0xc903031e, 0x73b88045,
	0x2241c16f, 0x32666057, 0x491d99a0, 0x83595d7a, 0x74402955, 0xbe7761a1, 0xa541434a, 0x1e867a58, 0x5b547346, 0x012f5c89, 0x6a996187, 0xb2222337,
	0x0f181f10, 0x50367078, 0x23253f43, 0x54846853, 0x325f8a58, 0x1d9c232d, 0x3960712b, 0x213b4353, 0x7e604c24, 0x5f08d382, 0x04000014, 0x00b60512,
	0x405e0007, 0x01090f32, 0x4f0109d0, 0x0209cf09, 0x09200910, 0xaf030930, 0x0206ef06, 0x06010684, 0x025a0706, 0x03e00340, 0x01030f02, 0x57030308,
	0x77026702, 0xb8020302, 0x0b40c0ff, 0x02480a07, 0x045f0307, 0x00120003, 0x32e13f3f, 0x5d2b2f01, 0x5d5e2f33, 0x32e1105d, 0x2005e04f, 0x05be4771,
	0x15213531, 0xbb710221, 0xfe035efe, 0x12055ffe, 0x8200a4a4, 0xb82b0881, 0xdd04ecff, 0x1700b805, 0x1c402f00, 0x65015a16, 0x0119b019, 0x19af196f,
	0x01191002, 0x640b5a0e, 0x065f1118, 0x03000c13, 0x42323f00, 0x4e4408ff, 0x5f112005, 0x1122074a, 0xf94d1133, 0x112a0806, 0x8542dd04, 0xc48088c9,
	0xadbb4485, 0x528059af, 0xb8050128, 0xc4724cfc, 0x8e4d5290, 0xae037ac7, 0xc0af48fc, 0x51886236, 0x7b82b803, 0x00000024, 0xfd828b04, 0x6c000c34,
	0x02031040, 0x00040909, 0x01700160, 0x01f001b0, 0xdb830104, 0x06162608, 0x1001480a, 0x2f0e0101, 0xbf0e7f0e, 0x400e030e, 0x05480906, 0xf0ffb804,
	0x040504b4, 0xffb80903, 0x110ab3e0, 0x22078248, 0x820a40f0, 0x0209251a, 0x01001203, 0x332daa82, 0x2b33333f, 0x01333f2b, 0x2b33382f, 0x05534d5d,
	0x3912332c, 0x33332f3d, 0x33013031, 0x03822301, 0x17161636, 0x03373636, 0x17fec6c5, 0xc519febb, 0x2a1d2701, 0x1f2e0f11, 0x2705005b, 0xa95b61fc,
	0x61a94a4a, 0x2105a341, 0xa582fe06, 0xdf002a2e, 0x150810b6, 0x0f104818, 0xb5f8ffb8, 0x0f210882, 0x22a58207, 0x821240f8, 0x0001210a, 0x00221983,
	0x06831d16, 0x821c1d21, 0x2f402120, 0x28081682, 0x0714251c, 0x44070401, 0x0307b407, 0x14250407, 0x44252425, 0x05255425, 0x25251607, 0x1e030716,
	0x010e000d, 0x0e800e70, 0x83db82c0, 0x071838f0, 0x100e480a, 0x6f2c0e0e, 0x022c7f2c, 0x2c302c20, 0x012c0f02, 0x821e1f08, 0x134024f2, 0x8220161e,
	0x101621ed, 0x1627e982, 0x031e000d, 0x41252507, 0x07820601, 0x82b6f021, 0x10252416, 0x8400121d, 0x331121fb, 0x33220682, 0x554e2b2b, 0x415d2005,
	0x71310603, 0x39171233, 0x2f2f2f3d, 0x715d5e5d, 0x332b3311, 0x3b04892b, 0x33013031, 0x17031e13, 0x1337033e, 0x03230133, 0x26272626, 0x06070627,
	0x23030706, 0x4d081988, 0xe5c52903, 0x13191d0f, 0x100c0406, 0xc7c80b13, 0xfebc91fe, 0x0c0b1a0e, 0x0a0b0b0b, 0xbcf20e19, 0xdfc57efe, 0x0e11140c,
	0x140f0505, 0xb6050d17, 0x7038a8fc, 0x26265e69, 0x3167635a, 0x4afa7203, 0x6c33aa03, 0x3334372f, 0x36702f37, 0x1f825cfc, 0x632e872a, 0x25265b62,
	0x316f6c62, 0x08061142, 0xb6056044, 0x81000b00, 0x0a091d40, 0x000a0a10, 0x0b010b37, 0x01053808, 0x01020205, 0x70010000, 0xc0008000, 0xb8000300,
	0x1440c0ff, 0x00480a07, 0x0d000010, 0x0d1f0d0f, 0x0d7f0d2f, 0x06070804, 0xb3f0ffb8, 0x6e4f0606, 0x04102b05, 0x27010228, 0x08020108, 0x12820904,
	0x00120030, 0x333f323f, 0x5d393912, 0x382f015d, 0x714f3232, 0x3d392a0c, 0x335d332f, 0x33115d33, 0x25178218, 0x23213031, 0x02820101, 0x01013329,
	0x60040133, 0x829efed3, 0xc50139eb, 0x01c65afe, 0xbe4e014c, 0x7b025bfe, 0xfc0285fd, 0xd1fdba02, 0x4cfd2f02, 0x00209a82, 0x04210082, 0x3dbd8237,
	0x40730008, 0x010aef19, 0x0c09400a, 0x07ab0848, 0x01079801, 0x1b010740, 0x070f0107, 0xa0820701, 0x072f403d, 0x80010507, 0x024f0102, 0x01021b01,
	0x02021002, 0x775a0400, 0x97058705, 0x534f0305, 0x072906b7, 0x01003605, 0x12040100, 0x05d14207, 0x82391221, 0x5d5e25b4, 0x39e15d5d, 0x0782b882,
	0x33113324, 0x0782382f, 0x335d5d26, 0x30315d2b, 0x113ba783, 0x33011123, 0x54011b02, 0xbb42fec8, 0x02cb42fe, 0xfce302d3, 0x02c7fd83, 0x4b87032f,
	0x032106a1, 0x08a182fe, 0x38000921, 0x09092040, 0x0b670703, 0x0b3f0b0f, 0x0b9f0b4f, 0x04080804, 0x0a660104, 0x055f0407, 0x4d080203, 0x392b05cf,
	0x0139e13f, 0x2f32e610, 0x825d5e32, 0x2f322606, 0x21213031, 0x05cc5835, 0xfe032135, 0xc70254fc, 0x83034dfd, 0xdb023afd, 0xa67f0491, 0x8381fb91,
	0xfea42465, 0x823902bc, 0x00073b65, 0x04174026, 0xf106f300, 0x01100100, 0x01c001b0, 0xf5050104, 0xf506f802, 0x395ef901, 0x32ed2108, 0x2135ba82,
	0x23152111, 0x39023311, 0x95016bfe, 0xbcfedfdf, 0xfa95fa06, 0x244b8331, 0x02000017, 0x254b82e9, 0xb7210003, 0x46820102, 0x03000528, 0xb4f0ffb8,
	0xc45e0203, 0x012f3505, 0x1133382f, 0x33113833, 0x01133031, 0x02c90123, 0xe0fdb220, 0x8305c443, 0xfe33243f, 0x84c901bc, 0x4024368b, 0xf3000314,
	0x0660f101, 0x06020670, 0x07f50009, 0x04f503f9, 0x238885f8, 0xe15dd610, 0x17248983, 0x35231133, 0x333f8d82, 0x9601dfdf, 0x05ae6afe, 0x06f995cf,
	0x00010000, 0x04250229, 0x00c10519, 0xb6120006, 0x82080303, 0x00062812, 0x2f01cd3f, 0x832f3311, 0x82332078, 0x0121087a, 0x66cb0129, 0xfea1bf01,
	0x02a3feaf, 0xfc9c0325, 0xfddf0264, 0xff010021, 0x03bcfefc, 0x0048ff4e, 0x293b8203, 0x01050000, 0x0002ba01, 0x3b86e12f, 0x3521012c, 0xfc4e0321,
	0xfe5203ae, 0x56828cbc, 0x89014708, 0x1203d904, 0x0d002106, 0x0a401600, 0x80080600, 0x005f000f, 0x2f000002, 0x01cc1a5d, 0x3031cd2f, 0x032e2301,
	0x1e333527, 0x12031703, 0x4d522378, 0x10db103f, 0x15302e2b, 0x531cd904, 0x151b5158, 0x4c515122, 0x3282001d, 0xff5e6f08, 0x049c03ec, 0x0023005e,
	0x40540032, 0x29011011, 0x34552347, 0x346f340f, 0x48300602, 0xffb81a0c, 0x0d1e40d0, 0x101a4811, 0x1a480c09, 0x33560c1a, 0x1d501619, 0x1010522a,
	0x5024101d, 0x00160702, 0x3f3f0015, 0x393fe133, 0xe110e12f, 0xe6100132, 0x2b2b2f32, 0x5d5ee110, 0x32e1f610, 0x21303132, 0x030e2327, 0x022e2223,
	0x37363435, 0x20643537, 0x27072105, 0x08065755, 0x32251162, 0x3535023e, 0x15030e07, 0x19031614, 0x42210825, 0x453f604e, 0xe7305574, 0x371db8ec,
	0x8f533451, 0xb64a4042, 0x61956664, 0x3d2ffe30, 0x8f2b4c68, 0x20497a5a, 0x412d9861, 0x5127142a, 0xb0a4547b, 0x43450708, 0x3018375a, 0x38288922,
	0x628a5929, 0x267f10fd, 0x634f754d, 0x39200407, 0x565c3351, 0x3308e583, 0x04ecffae, 0x0014063f, 0x002f001f, 0x482db538, 0x31315705, 0x40b8ffb8,
	0x15490a17, 0x12472510, 0x00133054, 0x502a1512, 0x20160a0f, 0x10001b50, 0xe1323f00, 0x3f21d483, 0x20c58401, 0x05cc462b, 0x2e0b315d, 0x11230723,
	0x06141133, 0x33070607, 0x4f17033e, 0x363708a5, 0x02263435, 0x6d9a5e9e, 0x9a6d3c3c, 0x4d603b5e, 0x250c173b, 0x8202b685, 0x08430800, 0x604d3a17,
	0x416b5019, 0x6c411b1b, 0x7f7f8751, 0x8f485e04, 0xd58d8cd4, 0x2b1a4990, 0x068b203a, 0x2388fe14, 0x2628224f, 0x192c3c23, 0x9c683397, 0x6b9d6569,
	0xd0ccda37, 0x000100ce, 0x03ecff71, 0x825e046f, 0x402a3ac1, 0x210d1d18, 0x217f215f, 0x01211002, 0x56054816, 0x0a511320, 0x00511910, 0x09ea5116,
	0xce105d29, 0x05303132, 0x48022e22, 0x440808b0, 0x2223032e, 0x16141506, 0x37363233, 0x02060615, 0x82b06552, 0xb2854c4a, 0x32954e66, 0x3c381736,
	0x909d1a3a, 0x83519491, 0x147b3636, 0x96d5893f, 0x3e89db9d, 0x0a9a1922, 0xc9090f13, 0x25c3d3d4, 0x1e1da219, 0x06c35d00, 0x14060222, 0x20088982,
	0x40340030, 0x1b00261d, 0x32551e47, 0x2e013210, 0x31560b48, 0x001c151f, 0x1016502b, 0x01502010, 0x20908206, 0x09474133, 0x20071142, 0x08104225,
	0x2e05056b, 0x27263317, 0x11352626, 0x25231133, 0x42023e32, 0xaa820723, 0x54032208, 0x4d3b1608, 0x9a5d3c60, 0x6e3c3c6e, 0x603b5d9a, 0x0c163c4d,
	0x04020303, 0xc6fe93b6, 0x1f41694c, 0x064a4102, 0x3d229324, 0x4d411a2e, 0x3a2c3108, 0x1a1f2220, 0xb4011037, 0x2e83ecf9, 0x295e8d5e, 0x21054941,
	0xbf85cdd1, 0xe1033008, 0x1e005e04, 0x43002700, 0x48232840, 0x29571019, 0x6f0129e0, 0x11220129, 0x28560548, 0x221b5011, 0x0f02222b, 0x22060122,
	0x501f1422, 0x4114100a, 0x1224075b, 0x5d5e2f39, 0x2308f650, 0xe132f610, 0x240b6441, 0x1515021e, 0x05d96021, 0x1537b908, 0x2203030e, 0x34210706,
	0x6002022e, 0x4883b66e, 0x65a77842, 0x3b6e9e63, 0x99054cfd, 0x51573397, 0x4d28274c, 0x72605751, 0xec010b85, 0x1458391b, 0x87d28e4a, 0x4e95d688,
	0x6eb58147, 0x0ab6c171, 0xa2121d13, 0x08121c13, 0x959cdb03, 0x2c507144, 0x1d000100, 0xf0020000, 0x1b001f06, 0x4e407000, 0x1ddf1dcf, 0x801d6002,
	0xa01d901d, 0x1d1f041d, 0x1d4f1d3f, 0x7f1b1b03, 0x0210bf10, 0x021a1010, 0x03070347, 0x051f050f, 0x05af052f, 0x00050504, 0x20031003, 0x90038003,
	0x0603a003, 0x05010306, 0x1a00074f, 0x0f1a0701, 0x010d5014, 0x3f001502, 0x5e3fe13f, 0x32e1335d, 0x3205ed50, 0x1033115d, 0x2f3232e1, 0x5d2f395d,
	0x30315d5d, 0x82112301, 0x37352101, 0x200cfe4a, 0x08ef820e, 0x8b0233b0, 0xc2c2b7f5, 0x4e7c552d, 0x2f27633b, 0x2828491f, 0xf513263a, 0x3ffcc103,
	0x444bc103, 0x548d6b60, 0x8d0e1723, 0x3013110b, 0x00684153, 0x25000300, 0xfc0314fe, 0x3f005e04, 0x5e005200, 0x1940a700, 0x5305320d, 0x2f123747,
	0x37703760, 0x37033780, 0x272f372f, 0x47591d48, 0xc0ffb805, 0x0a074d40, 0x01050548, 0xfd011d0a, 0x1db0011d, 0x011d8801, 0x1d301d20, 0x1d031d40,
	0x601f601d, 0xdf60bf01, 0x60a00260, 0x40274001, 0x27480f0c, 0x0d320502, 0x52563c04, 0x5c220a0a, 0x4e2c3c4f, 0x0701170f, 0x103c1717, 0x1b224f45,
	0x000f0001, 0xe782c13f, 0x5e2f3937, 0x1039c15d, 0x2f3911e1, 0x391712e1, 0xc12b2f01, 0x11715d5d, 0x3aea8333, 0x3933715d, 0x10e12b2f, 0x393911c1,
	0x105d2f2f, 0x12e110c1, 0x30313939, 0x62071501, 0x0e2609be, 0x1e141503, 0x195a3302, 0x05dd4407, 0x37023e28, 0x34352626, 0x244c3736, 0x83012009,
	0x36322e25, 0x022e3435, 0x0e222323, 0x16141302, 0x080e8333, 0x222326d2, 0xc5fc0306, 0x5f2f261c, 0x2c165d8c, 0x1b21110e, 0x38291811, 0x805db01f,
	0x86412451, 0xa06b8bcd, 0x4227356a, 0x362a2f57, 0x472b4540, 0x62321b31, 0x4f256192, 0x1a40fe1b, 0xba48613b, 0x5a3718b9, 0x4c23b041, 0x6c5c293f,
	0x69676463, 0x046a6364, 0x231b714a, 0x814c456d, 0x0301355e, 0x2820190a, 0x12211b18, 0x6d502f06, 0x618c583d, 0x71502a34, 0x425b3c47, 0x52130b2a,
	0x2a593d35, 0x60513f12, 0x628c5933, 0xfb090b34, 0x2e402502, 0x2e6c731b, 0x100c213a, 0x60034d2c, 0x776f7073, 0x0078747b, 0x00ae0001, 0x06120400,
	0x00190014, 0x001d4032, 0x1b551947, 0x1b601b10, 0x0f031b80, 0x0b470a0e, 0x04101a54, 0x0c101550, 0x15000b00, 0x3f323f00, 0x2a060157, 0x105d3232,
	0x3031e1f6, 0x82341121, 0x020e27e4, 0x11231115, 0xa2611133, 0x16510805, 0x5c031115, 0x6e517069, 0xb6b61d43, 0x45190a08, 0xb7305c52, 0x82c302b9,
	0x94663482, 0x06c7fd60, 0x9032fe14, 0x142a3f2b, 0x33fdd2bf, 0x00020000, 0x010000a0, 0x00e50575, 0x00110003, 0x10144025, 0x02132013, 0x0447000c,
	0x07125401, 0x020f0f53, 0x057b460f, 0x01e52f27, 0xe132f610, 0x05ab6532, 0x34033322, 0x0806b25b, 0x22230625, 0xb6640126, 0x2d3dc4b6, 0x111d2716,
	0x3d2d2c3f, 0x29014a04, 0x1c0d363c, 0x393a1e2b, 0xff020038, 0x8414febc, 0x13240861, 0x2e002100, 0x23101940, 0x1c022320, 0x140c470f, 0x540c0303,
	0x1f531722, 0x070f0d1f, 0x001b0050, 0x333fe13f, 0xe6246783, 0x10322f32, 0x13206a84, 0x20100854, 0x2f788b13, 0x173f3042, 0x1b23361a, 0xb613232e,
	0x136d4822, 0xfe348389, 0x940b0e14, 0x270f0b0a, 0xf4043341, 0x7b4d18fb, 0x5f072f57, 0x79419489, 0x033a0805, 0x001406f0, 0x405e000e, 0x0404070b,
	0x06030302, 0x05010544, 0x40c0ffb8, 0x480a0717, 0x05051005, 0x2f100f10, 0x0d070210, 0x540a4709, 0x00000b0f, 0x40f8ffb8, 0x480f0c10, 0x04820807,
	0x0307002a, 0x03150a06, 0x3f3f000f, 0x46052854, 0x5e2005c7, 0x2e06e14b, 0x33113333, 0x31331139, 0x01370130, 0x54010133, 0x2508072a, 0x87560103,
	0xfed32501, 0xd1ac016f, 0xb46db0fe, 0x370210b4, 0xfe6901aa, 0x0191fd25, 0x5afe52f8, 0x36fd1406, 0x9f85edfe, 0x82640121, 0x0003329f, 0x100e401a,
	0x02052005, 0x54014700, 0x00000204, 0x23718215, 0xe1f61001, 0x23068a41, 0xb6b66401, 0x4a082782, 0x00ae0001, 0x04870600, 0x002c005e, 0x233f4065,
	0x0bb9470a, 0xa60b9601, 0x0b89020b, 0x770b6701, 0x0b0b020b, 0x2c470016, 0x2ef02e55, 0x012ecf01, 0x2e502e20, 0x012e0f02, 0x47151908, 0x232d5416,
	0x0f041a1a, 0x101f2850, 0x42160f17, 0x3220056d, 0xe122d782, 0x02543232, 0x5d5e2106, 0x2205b34f, 0x822f3911, 0xe15d2208, 0x0d7e4232, 0x260a8842,
	0x033e3317, 0x86163233, 0x152e0806, 0x64d10511, 0x41664969, 0x6963b71e, 0x1b3f684d, 0x0a1a94b6, 0x594f4218, 0x269f782e, 0x57491a08, 0xb1af3260,
	0x8282c302, 0x58875b2f, 0xa842a2fd, 0x4a043009, 0x2a3f2b94, 0x2f5e5814, 0xbf162d44, 0x4133fdd2, 0x04210513, 0x3de18212, 0x40300018, 0x1847001c,
	0x1a101a55, 0x1a801a60, 0x470a0e03, 0x0f19540b, 0x10145004, 0x2c430f0c, 0x122b430e, 0x2a439b88, 0x43948208, 0x8186102a, 0x55657b84, 0x822d2005,
	0x0013227b, 0x3c7d821f, 0x00481a1d, 0x21402157, 0x21e021d0, 0x01210f03, 0x0a481406, 0x501d2056, 0x5017100f, 0x09224805, 0xf1535e20, 0x0dec6e08,
	0xa3440520, 0x2d042c0a, 0x6fb27d43, 0x477fae67, 0x84b37c43, 0x00fd2507, 0x879a9a89, 0x21080383, 0xd5892702, 0x914c4c91, 0xd38889d5, 0x914b4b91,
	0xd3d188d3, 0xcfd1d1d3, 0x020000cf, 0x14feae00, 0x91823f04, 0x20088f82, 0x1e403600, 0x571b482e, 0x01321032, 0x0c061026, 0x31540d47, 0x16115020,
	0x0c0f0e10, 0x05502b1b, 0x25928200, 0x3f3fe132, 0x4d58333f, 0x07414405, 0x2e220524, 0xc1552702, 0x41332008, 0x1e2b0517, 0x0e141502, 0x0e220302,
	0x45150702, 0x2622075b, 0x66499e02, 0x03032c05, 0x94b60402, 0x3a17081a, 0x493c604d, 0x81200681, 0x220b2448, 0x482b1a14, 0xfe280618, 0x9436062b,
	0x1b2d3d23, 0x25073248, 0x5e2edb03, 0x26485f8c, 0xced02106, 0x7120c383, 0x0220c382, 0x1022c382, 0xc3833000, 0x05202b26, 0x55244725, 0x0e2fc683,
	0x31561648, 0x0f221b24, 0x1b500b20, 0x82002c10, 0x06045ccd, 0x013f3f25, 0x48e1f610, 0x322205e8, 0xce483031, 0x4917200e, 0x1e25088e, 0x37331702,
	0x08915633, 0x02030e23, 0x20a88b35, 0x09f04866, 0x173c4c2f, 0xb6931b08, 0x03030204, 0x4d3b160c, 0x0dce4860, 0xbf879720, 0x3d2d1b31, 0xcaf99423,
	0x3a13d501, 0x2222201b, 0x421a2e3d, 0x03210593, 0x08c18208, 0x41001633, 0x03b20b40, 0x900203c2, 0x0203a003, 0xc0ffb803, 0x0b071b40, 0x18030348,
	0x18501830, 0x11031880, 0x540e470d, 0x0d0f0f17, 0x00071215, 0xc13f0010, 0x20c98533, 0x06025b32, 0x01303123, 0x06f35232, 0x0806d345, 0x3e33172c,
	0x1d890203, 0x1c181a48, 0x683f1a3b, 0x94b6294b, 0x39190816, 0x5e045847, 0x05a80505, 0x855f3307, 0x04b0fd51, 0x502bc94a, 0x8b82253d, 0xecff5a24,
	0x8b823f03, 0x00352e08, 0x252d4048, 0x00904713, 0x000200a0, 0x373f3757, 0x379f375f, 0x01371003, 0x9f09472c, 0x021daf1d, 0x2636561d, 0x2c135029,
	0x09102205, 0x05b1420e, 0x123f322c, 0x32e13939, 0x5df61001, 0x3a5ee132, 0x53332005, 0x1f5e0e9f, 0x18a05305, 0x3a3f5d08, 0x6d609a6d, 0x4c1f3b9c,
	0x412c5954, 0x141a395b, 0x48485c35, 0x372b5073, 0x61568c64, 0x413f48a1, 0x62664789, 0x465e3817, 0x2a507148, 0x78502d01, 0x22232851, 0x181f10a6,
	0x3b29160f, 0x31321f24, 0x3c1f1f32, 0x4643614a, 0x2a264a6d, 0x2b1d9322, 0x34233e43, 0x1e1d2f2e, 0x00604b3c, 0x4608df82, 0x02ecff21, 0x0046058f,
	0xb150001d, 0xffb80519, 0x082f40c0, 0x0505480b, 0x4f1f3f1f, 0x1b17021f, 0x121f1447, 0x1202122f, 0x10101000, 0x10b01020, 0x10d010c0, 0x1a100606,
	0x14164f12, 0x50000f17, 0x3f00160b, 0x49333fe1, 0xc6210680, 0x2408825d, 0x2f33115d, 0x25e7822b, 0x023e3225, 0x444d1537, 0x113e0806, 0x37373523,
	0x15211533, 0x16141121, 0x2d12fa01, 0x0d09232a, 0x19343028, 0x2c4d6a3e, 0x694e9b9b, 0xecfe1401, 0x0604813f, 0x068a0308, 0x2005090c, 0x0265854e,
	0xe64e517d, 0x83fd89fc, 0xa9826261, 0xffa42208, 0x040804ec, 0x001a004a, 0x011c4030, 0x551a4717, 0x601c101c, 0x031c801c, 0x540c470f, 0x0f0d181b,
	0x0bd74d12, 0xd1423320, 0x4d312008, 0xce530acb, 0x82352008, 0x75032209, 0x05cd471b, 0x8a5b2208, 0x6ab62f5c, 0x436e516f, 0x2b93b61d, 0x2e14293f,
	0x02699862, 0x823dfdcd, 0x94653482, 0xfb3a0260, 0x060351b6, 0x82d50321, 0x00112f81, 0x1100b96d, 0x0f40f8ff, 0x11480e0a, 0x05820800, 0x0909002c,
	0xb8100f01, 0x12b3c0ff, 0x07834815, 0x071c4025, 0x8210480b, 0x13200800, 0x13cf13bf, 0x500313ef, 0x130f0113, 0x134f132f, 0x01020703, 0x40f0ffb8,
	0x0947010a, 0x010f0901, 0x27060d48, 0x2f015d39, 0x5d5ec138, 0x2906ce52, 0x3912c12b, 0x2b332f3d, 0xbe822b33, 0x2005a252, 0x05bd5233, 0x77012408,
	0xc7bc89fe, 0x191e1e0b, 0x18050704, 0xc70b1e1e, 0x0489febc, 0x219dfd4a, 0x19606c68, 0x686c6019, 0x82630221, 0x000126b0, 0x05000014, 0x25af82e3,
	0xb9c3002f, 0xaf822f00, 0xa9820c20, 0x08002f29, 0x00480e09, 0x82b82027, 0x82122010, 0x1f20210a, 0x1f221083, 0xc7831009, 0x830f1021, 0x82092016,
	0x180f3216, 0x27012754, 0x40e0ffb8, 0x480a0715, 0x1801185b, 0x29078220, 0x18180927, 0x11032709, 0xeb862e2d, 0x40210783, 0x30eb8213, 0x2e2e102e,
	0x30312031, 0x310f0231, 0x11120701, 0x24e282b8, 0x1f2d1116, 0x3ae48209, 0x19270f11, 0x19661906, 0x19031976, 0x00151000, 0x5d33333f, 0x333f3311,
	0x8233335d, 0x823320f4, 0x331125f4, 0x2b2b382f, 0x2207c153, 0x822b5d2b, 0x0ec1531f, 0x2e032127, 0x27262703, 0x0cb65323, 0x23051341, 0x17031e13,
	0x59080985, 0xa8f00301, 0x0d0c0c04, 0x060f0e06, 0x190b0d0e, 0xfed3ac0b, 0x0a83bfe7, 0x040e1214, 0x15110506, 0xc4b30a16, 0x161709ac, 0x03060412,
	0x0b15120d, 0xe4feba89, 0x2d126802, 0x3a193432, 0x323a3f3e, 0x9cfd256a, 0xb8fd4a04, 0x5b67692d, 0x61571a1d, 0x6b02215f, 0x5c2295fd, 0x0d82585f,
	0x6d683008, 0xfb48022f, 0x000100b6, 0x03000023, 0x004a04db, 0x40e5000b, 0x010989a1, 0x06010386, 0x04f70104, 0x0104e501, 0x04010436, 0x0106e805,
	0x82e70306, 0x09890829, 0xf8010209, 0x02ea0102, 0x01023901, 0x056b0102, 0x5702057b, 0x053a0105, 0x6402054a, 0x02017401, 0x35010158, 0x02014501,
	0x01090105, 0x0b030509, 0xf7010806, 0x08e50108, 0x01083601, 0x16400708, 0x40074819, 0x6b48110e, 0x02077b07, 0x3a010757, 0x02074a07, 0x0d100d07,
	0x90020d30, 0x020db00d, 0x06010d0f, 0xc8010ad9, 0x0aba010a, 0x010a0901, 0x4b0b3b0a, 0x0b28020b, 0x150b0501, 0x070b020b, 0x000f0115, 0x2f013f3f,
	0x05216b5d, 0x5d5e5d26, 0xde10715d, 0x2b220d82, 0x0582c12b, 0x17127127, 0x182f3d39, 0x821f832f, 0x8410200e, 0x33112513, 0x5d33335d, 0x312d0b85,
	0x5d5d0030, 0x13330101, 0x01013313, 0x08028323, 0x9ffe9821, 0xcffafacf, 0x75019dfe, 0xfef4fecf, 0x3302cff2, 0x66fe1702, 0xe9fd9a01, 0xb401cdfd,
	0x82004cfe, 0xfe0a32f7, 0x04df0314, 0x0022004a, 0x1022b664, 0x0e000808, 0x0631420f, 0x24080783, 0x0b071d40, 0x0f100f48, 0x24bf240f, 0x24ef24cf,
	0x01245003, 0x242f240f, 0x0703244f, 0xb8000118, 0x0c40f0ff, 0x26368200, 0x15501c23, 0x82000e1b, 0x3f322bc1, 0x333311e1, 0x382f0133, 0x244333c1,
	0x3133240f, 0x42331330, 0x0e220a03, 0xe44a2303, 0x37440809, 0xd7bd0a37, 0x12191d0e, 0x16050604, 0xc70b1d1b, 0x1c4efebc, 0x50745641, 0x151b4c34,
	0x46302340, 0x390f2534, 0x9bfd4a04, 0x52585828, 0x61561923, 0x6302215e, 0x815127fb, 0x060b315a, 0x17070591, 0xa029402c, 0x5224d183, 0x35030000,
	0x092fd182, 0x0b406c00, 0x01039709, 0x0d090803, 0x82070348, 0x114036d6, 0x07480a07, 0x0b3f0b07, 0x0b7f0b5f, 0x01089803, 0xf8ffb808, 0x221e82b5,
	0x82020408, 0x12b7271f, 0x023f4815, 0x2b820201, 0x1240f02c, 0x07480c07, 0x0f054f04, 0x09821002, 0x4f080229, 0x3f001501, 0x832b32e1, 0x2f012703,
	0x33332b5d, 0x42455d2b, 0x5d2b2105, 0x9354d982, 0xfd35330a, 0xfe18021d, 0xfdb00209, 0x7d1e02f4, 0x92894403, 0x9983d1fc, 0xfe3d3008, 0x05a202bc,
	0x002700b6, 0x1a254040, 0x20f70505, 0x1323f127, 0x0c10f60f, 0x0f230c01, 0x0110d9f5, 0x105f100f, 0x29101002, 0xf819f51a, 0x5406f505, 0x122605a1,
	0x5d5d2f39, 0x738239e1, 0x3333e639, 0x2fe232f1, 0x05303132, 0x17021e14, 0x35032e15, 0x23263411, 0x82363235, 0x05c44507, 0x11154b08, 0x15070614,
	0x01151616, 0x412d18f4, 0x5f834d28, 0x7d7d8336, 0x835f3683, 0x2d41284d, 0x73737718, 0x3d301077, 0x96010d23, 0x6e472101, 0x674e014e, 0x67569b56,
	0x6e4e4d01, 0x95012147, 0x3d230d01, 0x69b4fe30, 0x140c147b, 0xb3826a7a, 0xe9014308, 0x7f0214fe, 0x03001406, 0x1f402d00, 0x30010500, 0x70054005,
	0x04058005, 0x0300aa02, 0x03400310, 0x03c00380, 0x02030705, 0x0000001b, 0x2f013f3f, 0x5de15d5e, 0x01303171, 0x01231133, 0x069696e9, 0x1882f814,
	0x33000122, 0x9820fb82, 0x2920fb82, 0x2308fb83, 0xf724240d, 0x1af10007, 0x900314f6, 0x041d011d, 0x19eff51a, 0xd90219ff, 0x19190119, 0x23f5240e,
	0x0ef50df9, 0x20051455, 0x22fb8811, 0x86e63333, 0x341326fb, 0x26353736, 0x7af28226, 0xf2820568, 0x33021e25, 0x82062215, 0x020e2708, 0x033e3507,
	0xe783e135, 0x2123ff87, 0x413e6041, 0x01230901, 0x827a6a3b, 0x697b27dd, 0x3d304c01, 0xf3820d23, 0x47216808, 0xb3fe4e6e, 0x142d4834, 0xfe67569b,
	0x476e4eb2, 0x01960121, 0x303d230d, 0x66000100, 0x02044a02, 0x23005a03, 0x0d403c00, 0x2510251d, 0x010a1001, 0x0aad170a, 0xc0ffb81f, 0x13101640,
	0x051f1f48, 0x0d0f1cad, 0x0d3f0d1f, 0x0d6f0d4f, 0x0d060d8f, 0x335d2f00, 0x2b2fc8f1, 0x2f01e132, 0xce105d5d, 0x2e013031, 0x83222303, 0x3629089c,
	0x021e3233, 0x33031e17, 0x37023e32, 0x22230615, 0x1202022e, 0x292d3725, 0x3b3c1c16, 0x94641938, 0x4337321d, 0x2f37252f, 0x22108428, 0x83956318,
	0x8b022f10, 0x050d1610, 0x192c2113, 0x0d056ca2, 0x0d8c1419, 0x00020033, 0x018bfe93, 0x005e0491, 0x00170003, 0x0000b941, 0x053b7eff, 0xa019302f,
	0xc019b019, 0x04020419, 0x03030e9a, 0x39b2830e, 0x480a070f, 0x9b09000e, 0x10020013, 0x02070202, 0x5d5e2f00, 0x01cef52f, 0x427e2b2f, 0x33132408,
	0x5b132313, 0x8a6d0758, 0x79d53b06, 0x13efdf33, 0x1a1b2e23, 0x1414232e, 0x1b1a2e23, 0x0213232e, 0x05e7fba4, 0x417e2648, 0x066a6d07, 0x01003408,
	0xecffbc00, 0xcb05ba03, 0x5a002500, 0x03122540, 0x04040f46, 0x2715250a, 0x1e012740, 0x300a0048, 0xd00a400a, 0x0a06040a, 0x120f731b, 0x0573210f,
	0x830f0502, 0x0f0c399a, 0x050f4812, 0x1003050f, 0x00190307, 0x39123f3f, 0x2b2f2f39, 0xe1103311, 0x5a420383, 0xc6103005, 0x2f391132, 0x3132e133,
	0x07062430, 0x7c352315, 0x84540d64, 0x7603360c, 0x57894c6e, 0x3534628a, 0x89568b61, 0x352e8848, 0x3b3c3817, 0x06865419, 0x1ed42008, 0x0dcec802,
	0x89c7854b, 0x4b88cb8d, 0x03a4ac0d, 0x0a9a1721, 0xca090f13, 0x25c3d2d4, 0x8200a118, 0x004437c7, 0x05230400, 0x002800c9, 0x0d114075, 0x0f236f11,
	0x020f1f0f, 0x05821f07, 0x17031922, 0xb323b382, 0x82480e0a, 0xc8300807, 0x09063040, 0x2a171748, 0x21012a10, 0x0e0b4019, 0x29191948, 0x0d752110,
	0x227f222f, 0x22af228f, 0x22df22bf, 0x220722ff, 0x74160022, 0x73071819, 0x820a1071, 0x011127cb, 0x332b2f33, 0x0582115d, 0x84332b21, 0x5d5e21f5,
	0x154be284, 0x1521270c, 0x0e141521, 0x07820702, 0x3e358508, 0x23353503, 0x34113335, 0x9a02023e, 0x4242ae6a, 0x304b8d38, 0x01213c52, 0x1788fe78,
	0x021b3327, 0x2c21fcec, 0xc61e3549, 0x92693bc6, 0x232dc905, 0x1b2b1d90, 0xfe425e3b, 0x3ed389d9, 0x102b4059, 0x290b9aa6, 0xd5436144, 0x57440189,
	0x00325f89, 0x017b0002, 0x04ec031d, 0x0023008b, 0x40860037, 0x168f0e23, 0x2e161601, 0x0c0f15ab, 0x211e0618, 0x70000803, 0x12120112, 0x01391039,
	0xaa242004, 0x00010080, 0x4508ff82, 0x0a063140, 0x38000048, 0x011f8017, 0x18060c1f, 0x04060f1e, 0x00ae2909, 0x0d1b011b, 0xcfae3305, 0x0209ef09,
	0x09a00990, 0x1f0309b0, 0x6f093f09, 0x00090309, 0x5d5d5d2f, 0x2f32c6e1, 0x1712e15d, 0xc6331139, 0xff84325d, 0x5d241383, 0x5d2f3311, 0x2b081582,
	0x5d2fc0f1, 0x13303132, 0x27373634, 0x36361737, 0x17163233, 0x16071737, 0x06141516, 0x27071707, 0x22230606, 0x27072726, 0x37262637, 0x080a0f72,
	0x0e222342, 0x1f23ba02, 0x2f7f6281, 0x6b3c3c6c, 0x8263812e, 0x2123251f, 0x2e81607f, 0x6e3c3c6b, 0x7f607f2d, 0x258a231f, 0x33325741, 0x26264259,
	0x32335942, 0x02254157, 0x2f6b3bd3, 0x20816281, 0x81202424, 0x6d202a82, 0x24212a88, 0x22318220, 0x823c6c2d, 0x26262125, 0x00203589, 0x08052b55,
	0x054c0422, 0x001600b6, 0x305b4095, 0x130f0118, 0x15aa160c, 0x0c151501, 0xab010804, 0x021f0102, 0x98020201, 0x2e082882, 0x5a0b0307, 0x14011499,
	0x010c0f10, 0x00010c8a, 0x400c100c, 0x0c07030c, 0x0f600e0a, 0x12060f07, 0x00031360, 0x8f0f7f13, 0x1330020f, 0x8213d001, 0x131f2a48, 0x0f130f02,
	0x120b0113, 0x07755b15, 0x2f2f392d, 0x5d715d5d, 0x10333311, 0x831132e1, 0x2f012204, 0x2811825e, 0xe15d3333, 0x5d393232, 0x341e8232, 0x11393933,
	0x335d2f33, 0x5d393912, 0x01013031, 0x15330133, 0x24018321, 0x21112311, 0x82018335, 0x33022e11, 0xfebf5a01, 0xd3feef7f, 0xd3fe2d01, 0x300685b2,
	0xc085feea, 0xe302d302, 0x9e8900fd, 0x01fafe89, 0x24068206, 0x00000003, 0x0afd4502, 0x00072608, 0x00254039, 0x09300109, 0x09700940, 0x02040980,
	0x0003aa06, 0x40071007, 0xc0078007, 0x07070507, 0x03040304, 0x05054606, 0xaf823920, 0x3322a083, 0x0b4632e1, 0x46112007, 0x9629060f, 0xfc140696,
	0xfc19fef4, 0x085f82f3, 0xff79005e, 0x065e03f6, 0x0045001f, 0x4079005a, 0x0856054b, 0x26214651, 0x463c464c, 0xff102929, 0x21a00121, 0x210221b0,
	0x015cc05c, 0x46015cbf, 0x46170046, 0x00310808, 0x00000100, 0x00300010, 0x00d000c0, 0x080600f0, 0x4c265b00, 0x56175605, 0x0d04294c, 0x152e5037,
	0x010d5014, 0x3fe13f00, 0x33055f42, 0x10013311, 0x715d5ec6, 0xe12f3232, 0x5d5de110, 0x5d5dce10, 0x122b0b83, 0xe1103939, 0x31393911, 0x55341330,
	0x3e22065b, 0x864e3302, 0x15062c07, 0x17021e14, 0x1415031e, 0x5507020e, 0xc8760999, 0x022e2508, 0x37032e27, 0x17242383, 0x3435033e, 0x28080e82,
	0x1a89030e, 0x4b1f3a2d, 0x8c643755, 0x489d6156, 0x478c4138, 0x39186663, 0x7148465f, 0x29182a4e, 0x4c451c34, 0x609b6c3b, 0x05254e6c, 0x452bc508,
	0x1117375d, 0x494c5e33, 0x9a295073, 0x48653f1c, 0x21291423, 0x6c411a15, 0x262f1952, 0x33290317, 0x0f2d4053, 0x3d547226, 0x28254462, 0x271c8b20,
	0x2e1b393b, 0x1c1d2f2c, 0x3e614e41, 0x31445534, 0x4e6d2610, 0x284d6f47, 0x0f9e2021, 0x180e171e, 0x1d1b3327, 0x1f312d2d, 0x644e3e1f, 0x3a3f2559,
	0x0d0f1e37, 0x22382e24, 0x393b4026, 0x2d1f081e, 0x0200003a, 0x0c053301, 0xd9056a03, 0x19000b00, 0x21403500, 0x14af860c, 0x06c01401, 0x10000086,
	0x50004000, 0x00060400, 0x1791030f, 0x09cf099f, 0x01093002, 0x5d2f0009, 0x32e5335d, 0x5d5e2f01, 0x5ddc1ae1, 0x013031e1, 0x32333634, 0x06141516,
	0x25262223, 0x080c0b55, 0x28383324, 0x273a3a27, 0x77013828, 0x23132838, 0x263a101a, 0x73053828, 0x35313036, 0x35323235, 0x190c3036, 0x09821b26,
	0x0300003b, 0xecff6400, 0xcb054406, 0x41002500, 0x6a005500, 0xc5054340, 0x220f0f1a, 0x0801821a, 0xc34c262c, 0xc0013400, 0x57340134, 0x0a26c342,
	0xc90015c9, 0x1f150f1f, 0x7f152f15, 0x9f158f15, 0x00080615, 0x601f101f, 0x801f701f, 0x1782051f, 0x472d1f2d, 0xc8513bc8, 0x3f00042d, 0x57e12fe1,
	0x5e2c0557, 0x10e1105d, 0xe12f01e1, 0x715dde10, 0x11231385, 0x83102f33, 0x084a5bbe, 0xf54e3e20, 0x41342009, 0x012008f9, 0x2105fd77, 0x7d751504,
	0x44042005, 0x2f080f5e, 0x5e3d7b03, 0x3d1d2140, 0x3617435f, 0x18193839, 0x233c3531, 0x33659866, 0x64996936, 0x3e3b843f, 0xbefc6134, 0xa78a6136,
	0xc06868c0, 0x36618aa7, 0x6d280b8b, 0x85eaaf65, 0x65afea85, 0x21080787, 0x532c1d04, 0x784e4b78, 0x0c072b52, 0x0b830911, 0x42070e12, 0x6567aa7a,
	0x214378a7, 0x1c1a7f1d, 0x448ebefe, 0x35628925, 0x82896235, 0x82458b5c, 0x0060084d, 0x44000200, 0x42021003, 0x1e00c705, 0x4e002d00, 0x012d2f40,
	0x1d00e00f, 0x1d021d10, 0x1f2f0f2f, 0x7f2f4f2f, 0x052faf2f, 0x170be024, 0x010b6017, 0xe42d2e0b, 0x011a0f0f, 0x0600e427, 0x1ae413c0, 0xe13f00de,
	0xe1c4dc1a, 0x2f391139, 0xc61001e1, 0x102f325d, 0xd6105de1, 0x3232e15d, 0x27013031, 0x230c625d, 0x06222326, 0x0805615d, 0x1115165c, 0x15030e03,
	0x32331614, 0x3535023e, 0x121ce701, 0x23382f27, 0x1d34482b, 0x3d638f8d, 0x2a5a3038, 0x3c753330, 0x33c9777d, 0x32122944, 0x2b3a222a, 0x521d0319,
	0x0d192316, 0x334d331a, 0x04056c66, 0x1d39481f, 0x241a6416, 0x3afe7a6a, 0x12033901, 0x331d2b1e, 0x412c152d, 0xd382312c, 0x00525308, 0x03930373,
	0x000600c7, 0x4060000d, 0x0d040211, 0x04500aeb, 0x04020460, 0x060a040a, 0xffb8090b, 0x092140c0, 0x0f09480c, 0x0f9f0f0f, 0x06030faf, 0x01039feb,
	0x03000603, 0x0a0a070d, 0x01030305, 0x0108050c, 0x2f332f00, 0x3d391233, 0x1139122f, 0x02823333, 0x2f180123, 0x22dd825d, 0x42322bc6, 0x1021052d,
	0x05ba5fe1, 0x13031726, 0x01250107, 0x523f0684, 0xee753501, 0xcbfe75ee, 0x36019701, 0x74eded74, 0x2902cafe, 0xfe4e9e01, 0x4ea4fea4, 0x891b9b01,
	0x0037080a, 0x01660001, 0x03020406, 0x0005001d, 0x02244039, 0x100701aa, 0x04960107, 0x01048b01, 0x56010479, 0x044b0104, 0x01043801, 0x09010412,
	0x04040104, 0x00b305ad, 0x4d01e13f, 0x5d3d06ca, 0xde105d5d, 0x013031e1, 0x21112311, 0x95020435, 0x1d03f9fc, 0x8101e9fd, 0xffff0096, 0x06e17f00,
	0x00060227, 0x00000010, 0x08374304, 0x00085e08, 0x003a001e, 0x40c2004e, 0xb416a47d, 0x0316c416, 0x17c417b4, 0x01161702, 0x170e1552, 0x15c5160e,
	0x1515140e, 0x00090e0e, 0x091ac519, 0x041504c5, 0x00011a00, 0xd01ac01a, 0x8f07031a, 0x041a0104, 0x451f041a, 0x012d00c3, 0x2d012dc0, 0x1fc33b50,
	0x00c9180e, 0x161b1600, 0xc9081a15, 0x082c821b, 0x1f1a0f26, 0x7f1a2f1a, 0x9f1a8f1a, 0x0008061a, 0x601b101b, 0x801b701b, 0x1b1a051b, 0x40261b1a,
	0x4a1334c8, 0x000426c8, 0x31057a71, 0x5d2f2f39, 0x10715d5e, 0x333311e1, 0x10391211, 0x7b4332e1, 0x201b830c, 0x82158211, 0x39113217, 0x102b1087,
	0x0587c100, 0x01c4102b, 0x5d30315d, 0x06b35a01, 0x14052334, 0x1607020e, 0x17021e17, 0x23032317, 0x33112311, 0x8f431632, 0xe7023d1f, 0x534f5b48,
	0x92014659, 0x1f392d1b, 0x2a173543, 0xb30a0a21, 0xe99d5fce, 0xebfb9ea8, 0x3b288943, 0x45480003, 0x30813b4a, 0x0d28394b, 0x4725576e, 0x01111138,
	0x03a0fe60, 0xc3fe827d, 0x28288343, 0x06faff01, 0x06060414, 0x196561a0, 0x06042708, 0x0c04f4fb, 0x008c1406, 0x7b000200, 0xf2025603, 0x1300cb05,
	0x43002700, 0xab1e2c40, 0x299f290a, 0x30aa1401, 0x1d824000, 0x10ae1930, 0x020f200f, 0x0ff00fe0, 0x010f6f02, 0x0e830f00, 0x0f060326, 0x05ae230f,
	0x2d056276, 0x5d5d5d5e, 0x2f01e171, 0x105de15d, 0xc746e1d6, 0x0b335c05, 0x2a0fbb44, 0x7355327b, 0x56734141, 0x83563232, 0x32552c07, 0x46341e7b,
	0x35462828, 0x83351e1e, 0x1e342307, 0x1e888f04, 0x31557235, 0x41725531, 0x1e344527, 0x2745341e, 0x1f354728, 0x8247351f, 0x662a0897, 0x02040000,
	0x0b00a204, 0x3a000f00, 0x11102140, 0x08080f01, 0x0caa0906, 0xef030101, 0x00200100, 0x00a00060, 0xad0d0003, 0x4318090c, 0x2f200942, 0x5d29a683,
	0x33113333, 0x113232e1, 0x4a431833, 0x2135240f, 0x18e90115, 0x23094e43, 0x9c037dfe, 0x09524318, 0xfafe4208, 0x01009696, 0x4a023100, 0xc9056d02,
	0x40001e00, 0xe1081540, 0x4f201700, 0x02207f20, 0x0a064020, 0x01e11d48, 0xb8010f0f, 0x0e40c0ff, 0x01481815, 0xe50b1d08, 0xe51dde12, 0x3f00dd01,
	0x12e13fe1, 0x06dd4c39, 0x105d2b2f, 0x31e132de, 0x35210130, 0x35033e37, 0x09c84434, 0x0805f857, 0x21070739, 0xc4fd6d02, 0x284839d1, 0x3336420f,
	0x364e2d5d, 0x613c5285, 0x361d2544, 0x0194334f, 0x704a028c, 0x43553ee4, 0x4041223b, 0x305e2632, 0x5b3f2141, 0x55563239, 0x829d375b, 0x021f249f,
	0x82680239, 0x0030389f, 0x033c4061, 0x0e191900, 0x00e11e06, 0x06e11500, 0x8f325f32, 0x83320232, 0x27272aa8, 0x2019400e, 0x19030e48, 0x055f43e4,
	0xdf1a5f35, 0x1a08051a, 0x2326121a, 0x12de2ce5, 0xdf0b0fe5, 0x82333f00, 0x123326b4, 0x5d5e2f39, 0x83ba85e1, 0x33e124b8, 0x8211e12f, 0x39122114,
	0x1421c082, 0x0b944806, 0x43161621, 0x35200742, 0x5d080884, 0x2223022e, 0x3e270706, 0x1e323303, 0x514e0202, 0x28585845, 0x46567e53, 0x843f397b,
	0x6b586235, 0x5c626260, 0x2f231454, 0x33613b1b, 0x443d1d45, 0x69452c4c, 0xe7042346, 0x17186a4e, 0x643c4e6a, 0x1f192847, 0x53262285, 0x71434a49,
	0x2f20404f, 0x25290e1e, 0x1a251760, 0x533c220f, 0x1d640100, 0x00062e0d, 0x0c0f8005, 0x0c020c5f, 0x1a5d2f00, 0x051d64cd, 0x033e3d08, 0x0e153337,
	0x01230703, 0x2f2f1689, 0x10db102a, 0x23514d3f, 0x1df40479, 0x2251514c, 0x58511b15, 0x00001c53, 0xfeae0001, 0x04120414, 0x001d004a, 0x0d224037,
	0x550a4709, 0x201f101f, 0x3507db47, 0x1c471d14, 0x1b1a1e54, 0x16115003, 0x091c150b, 0x333f000f, 0x2b703f3f, 0x5d322305, 0x257df610, 0x057b4605,
	0x11331125, 0x4c232723, 0x966f0517, 0x01333b07, 0x526f6a64, 0xb61c436e, 0x300a1b93, 0x6a486790, 0x02020123, 0x01b6b601, 0x30568287, 0x53932d08,
	0x262a2e54, 0x2a552328, 0x3606c0fe, 0x71289382, 0x6604fcfe, 0x13001406, 0x2d089382, 0x00990421, 0x40053005, 0x04055005, 0x0d050506, 0x15009901,
	0x00011510, 0x020d100d, 0x0012030d, 0x2f000005, 0x01c13f32, 0x105d5d2f, 0xb141e1d6, 0x07cc6005, 0x5f061121, 0x240807b7, 0x66042133, 0x3d79cf78,
	0x6d9b5f55, 0xa677413c, 0xfe330264, 0xf97906fc, 0x12330387, 0x8cc07633, 0x3278c593, 0x26798200, 0x01480293, 0x825e0391, 0x40332b79, 0x8015101a,
	0xa0159015, 0x45180415, 0xe5271d9e, 0x5d2b2f01, 0x435ded5d, 0x932011fd, 0x210f197a, 0xa94fd302, 0x23360812, 0x980114fe, 0x19000000, 0x1f403900,
	0x15131314, 0x128f127f, 0x06121202, 0x1b00840d, 0x8c121a06, 0x0e094015, 0x13151548, 0x00038d0a, 0x392fe12f, 0x01e12b2f, 0xed82c610, 0x2f391127,
	0x1133335d, 0x20ef8233, 0x22ea8214, 0x42352726, 0x34080686, 0x3727022e, 0x031e0733, 0x968d9801, 0x0f0f2d16, 0x50471031, 0x253f2e1a, 0x2239795a,
	0xfe192b3a, 0x066c61e1, 0x03036c03, 0x2318312b, 0xb009131a, 0x291a0873, 0x08ff833a, 0x4a023f3c, 0xb605ba01, 0x34000e00, 0x104f2140, 0x1002107f,
	0x480a0640, 0xe1020e0e, 0x8f037f00, 0x03200203, 0x03020330, 0x090ddd02, 0x00dc00e5, 0x3fcde13f, 0x5d5d2f01, 0x2f33e133, 0x72525d2b, 0x11530805,
	0x37023e34, 0x07070606, 0x87330127, 0x03030191, 0x16260e01, 0xb6054a5e, 0x040294fc, 0x383c3c19, 0x11281116, 0x00006049, 0x03420002, 0x058b0210,
	0x001300c7, 0xb22e001f, 0xb800e01a, 0x1440c0ff, 0x00480f09, 0x01210f21, 0x200ae014, 0xc005e417, 0x490fe41d, 0xf582051b, 0x5de1d625, 0x702bd610,
	0x6c5b0701, 0x0bd35c0a, 0x8b023408, 0x446d4d29, 0x2b4e6a3f, 0x446d4c29, 0x2c4e6b3e, 0x564b3afe, 0x554b4b55, 0x6d044b56, 0x2f598253, 0x5382592f,
	0x2e588153, 0x5381582e, 0x77797977, 0x83737378, 0x0054248f, 0x48960373, 0x562206eb, 0xd0482f40, 0xeb072406, 0x820a0204, 0x0b033701, 0xeb000e09,
	0x1001039f, 0x40032003, 0x0d030303, 0x00060a07, 0x01820a03, 0x230be348, 0x2f2f3d39, 0x2309e348, 0xc610e15d, 0x2d05e248, 0x5de13311, 0x01013031,
	0x37031327, 0x06850501, 0x96032008, 0xed74cafe, 0x360174ed, 0xcbfe68fe, 0x75eeee75, 0x0e023501, 0x014e65fe, 0x4e5c015c, 0x891b62fe, 0x003f080a,
	0x3f00ffff, 0x8b050000, 0x2600b605, 0x00007b00, 0x17022700, 0x00004a02, 0x3c020701, 0xb7fdfc02, 0x1d403000, 0x18160203, 0x16bf0203, 0x01168f01,
	0x1601163f, 0x01114001, 0x11011100, 0x82004000, 0x355d2307, 0x03845d11, 0x35355d26, 0x35353f00, 0x2c205182, 0xa0205182, 0xed205185, 0x35205185,
	0x00235183, 0x82330374, 0x40282d51, 0x18140218, 0x01140002, 0x11b00114, 0x11244c83, 0x01007000, 0x49844c85, 0x4a835182, 0x1f204982, 0xce224982,
	0x9b82c905, 0x9b867520, 0x4983a820, 0x033c0223, 0x2549823f, 0x0327403c, 0x9b823802, 0x38702108, 0x01385001, 0x33b40138, 0x0133a401, 0x64013384,
	0x33500133, 0x01333001, 0x33013320, 0x5d014c0f, 0x5d20a382, 0xac840083, 0x0032a784, 0xfe440002, 0x04440377, 0x0027005e, 0x4044003b, 0xff7d3212,
	0x0b320806, 0x3d0f3d14, 0x460b0801, 0xc0ffb81c, 0x1b0f1040, 0x170b1c48, 0x9b2d2727, 0x10131037, 0x2f001751, 0xe53f33e1, 0x39122f32, 0xe12b2f01,
	0xce105d5e, 0x12823911, 0x31e12f29, 0x14150130, 0x6307020e, 0x322406e5, 0x06173736, 0x24082b44, 0x35033e37, 0x0f7c5335, 0x10500224, 0x057e4127,
	0x54373407, 0x52404596, 0x955d61bc, 0x351b3867, 0x42343651, 0x53ba0e26, 0x25241199, 0x4c515b3a, 0x3509057e, 0x2a922333, 0x8a60333a, 0x5a684458,
	0x432d2f54, 0x132b433e, 0x10442f01, 0xffff220e, 0x08008200, 0x07dd0426, 0x00260273, 0x01000024, 0xff430007, 0x005201bd, 0x1502b415, 0xb8022605,
	0x1bb49cff, 0x25070415, 0x00352b01, 0x2f920282, 0x8d007622, 0x13242f82, 0x21020b40, 0x6c223082, 0x2d9b1b15, 0x004b0123, 0x225d8b1f, 0x931db4ff,
	0x8735205d, 0x202b828d, 0x205d8606, 0x225d821d, 0x922c1e01, 0x882b205d, 0x006a22bb, 0x2c2d8221, 0x030d4017, 0x26051e02, 0x15010203, 0x832f8529,
	0x003521bc, 0x0420bd88, 0x24083186, 0x1f500106, 0x4031007d, 0xef020320, 0x1adf011a, 0x011a5001, 0x20011a40, 0x1a10011a, 0x011a0001, 0x0002031a,
	0x21a0861f, 0x2a420035, 0x35320808, 0xff020000, 0x060000fe, 0x00b60556, 0x0013000f, 0x062a4084, 0x5a0e0a13, 0x10011101, 0xa9130403, 0x13240113,
	0x13541334, 0x01011003, 0x13010c14, 0x04820c01, 0x05033b08, 0x15670008, 0xffb80504, 0x052040f0, 0x065f1309, 0x0d105f03, 0x0a4f0a5f, 0xaf0a0f01,
	0x1008020a, 0x060a100a, 0x5f0e0403, 0x00120105, 0x2fe1333f, 0x2f39393f, 0x715d5e2f, 0x0183e110, 0x2f013228, 0xe6103338, 0x487f1132, 0x5d5d2706,
	0xc4c4877d, 0x21520111, 0x05ef7a05, 0x01230322, 0x0806537a, 0x01211152, 0x06231121, 0xfe08fd56, 0x02bacb25, 0xfdc9038f, 0xfd1602c3, 0xfb3d02ea,
	0x6c930175, 0x3bfec501, 0xfea4b605, 0xf8fda23c, 0xa802c601, 0x00ffff00, 0x0414fe7d, 0x02cb0598, 0x00260026, 0x00070100, 0x00fc017a, 0xb60b0000,
	0x242a4f01, 0x01252018, 0x2a05ff41, 0x030000c7, 0x027307be, 0x84280026, 0xff433425, 0x005201b7, 0x0c01b415, 0xb8012605, 0x12b4c2ff, 0x4200010c,
	0x2f8f0a2f, 0x3f007622, 0x2105d141, 0x30821801, 0x120c4a22, 0x01232d9b, 0x8bf1ff4b, 0xb4fd225d, 0x205d9314, 0x228d882b, 0x42f5ff6a, 0x02290501,
	0x26051501, 0x0c010102, 0x425f8520, 0x3e240801, 0x64020000, 0x2c20bf84, 0xfe21bf85, 0x20618bb5, 0x20bf8fa8, 0x202f8252, 0x222f8a8a, 0x8a78ff76,
	0x8e6a20bf, 0x821120bf, 0x89a9202d, 0x20bf822d, 0x202d860f, 0x20ed820c, 0x20bd8e02, 0x212d8240, 0xbd830777, 0x6a228b85, 0xbd8c0dff, 0xbd8d0020,
	0x02004008, 0x00002f00, 0xb605fc04, 0x1f001000, 0x3a405d00, 0x110e1a1a, 0x2167085b, 0x18012120, 0x100e5a1c, 0x640e0110, 0x5f101b20, 0x01000f18,
	0x003f000f, 0x00af006f, 0x00ff00df, 0x40000806, 0x82481d1a, 0x1c22086e, 0x17120e60, 0x00030260, 0xe13fe13f, 0x2b2f3911, 0x33715d5e, 0x100132e1,
	0x2f3232e6, 0x5d32e110, 0x1683f610, 0x13303123, 0x05d17d33, 0x02141538, 0x21230406, 0x34252311, 0x2323022e, 0x21152111, 0x00203311, 0xd77d982f,
	0x60450805, 0xa8f7feb6, 0x049892fe, 0xb87e4208, 0x5001c975, 0x01a2b0fe, 0x030c0108, 0x5c910225, 0xb0f4feb5, 0xbbe9feb9, 0x6083025e, 0x438ad592,
	0xfea20efe, 0xff24011d, 0x00c700ff, 0x070e0500, 0x00260235, 0x01000031, 0x20f58207, 0x0627418b, 0x26052027, 0x2f210a01, 0x0b43420a, 0xecff7d26,
	0x73077105, 0x32202d82, 0x2105b341, 0x2d825400, 0x02b4152c, 0x02260528, 0xb4abffb8, 0x2f9c282e, 0x02017622, 0x02215d85, 0x22308234, 0x9b2e2858,
	0x4b01232d, 0x2d86ae00, 0x05215e83, 0x835b9330, 0x828b84b9, 0x857d2029, 0x8430208b, 0xb4f0238b, 0x5d923f31, 0xbb882b20, 0xaa006a22, 0x2905e341,
	0x05310203, 0x01020326, 0x2f853c28, 0x0805a142, 0x00010021, 0x032d018d, 0x007b04dd, 0xb987000b, 0xf0ff0600, 0x481714b3, 0xe0ffb806, 0x120f1840,
	0x82100048, 0x2000210d, 0x09200982, 0x09200983, 0x03210983, 0x822485b8, 0x40e02207, 0x341a8230, 0x07010d40, 0x0b030505, 0x03500101, 0x0a080301,
	0x0202040a, 0x2a598220, 0x50002000, 0x80007000, 0x5500a000, 0x092c054a, 0x00b30006, 0x5d5e3f19, 0x33113271, 0x01240282, 0x11335d2f, 0x5d240184,
	0x2b003031, 0x01200082, 0x56080484, 0x01013701, 0x07010117, 0x01270101, 0x69c2fecb, 0x42013d01, 0x01bffe68, 0xbefe663f, 0x0267c3fe, 0x693f01d3,
	0x3e01c2fe, 0xfebffe67, 0x3d0166c0, 0x0067c5fe, 0x7d000300, 0x7105b4ff, 0x1a00fc05, 0x31002600, 0x3a405c00, 0x1e2a1f29, 0x5b271b04, 0x0e0b1901,
	0x78041104, 0x1b390fff, 0x3266115b, 0x2a1e291f, 0x5f222d04, 0x0b0e0119, 0x161a0904, 0x0c5f2d04, 0x06547709, 0x39171226, 0x391711e1, 0x8209617a,
	0x3210830c, 0x07013031, 0x14151216, 0x23060602, 0x27072722, 0x18022637, 0x08070c50, 0x01371780, 0x01171614, 0x22232626, 0x1005020e, 0x16160127,
	0x023e3233, 0x5b5c1405, 0xeda0515e, 0x4e85bd9b, 0x5b615a89, 0xa3f09e4c, 0x5042a15e, 0x302eb7fc, 0x72304302, 0x6ca67247, 0x586a0334, 0x722fbefd,
	0x6ba57245, 0x95ae0532, 0xb7defe63, 0xc6eafea9, 0x4e7f476c, 0x2a016491, 0x1501aabe, 0x262a6bc4, 0x83e1fc7f, 0xb1034ed1, 0x9751201d, 0x01018ada,
	0x1c54fc97, 0xdb99511e, 0xb800ffff, 0x5d47ecff, 0x42382006, 0x3d3106b9, 0x15005201, 0x051801b4, 0xffb80126, 0x181eb4c0, 0x0be9420b, 0x76222f8f,
	0x8b42c500, 0x24012105, 0x48223082, 0x2d9b1e18, 0x004b0123, 0x225d8b79, 0x9320b4fd, 0x022b235d, 0x8d850026, 0x7d006a22, 0x29058b42, 0x05210102,
	0x01010226, 0x5f852c18, 0x220c2f47, 0x82730737, 0x843c2031, 0x007622bf, 0x208f8631, 0x248f8215, 0x070f0963, 0x07eb4502, 0x00020022, 0x3f077b7b,
	0x001b0010, 0x1721403c, 0x1d67005b, 0x10011d9f, 0x0b11011d, 0x64085a07, 0x0660111c, 0x060b601b, 0x07200182, 0x2806707b, 0x2f393912, 0x10e1102f,
	0x051871e1, 0xc1685d20, 0x14012c05, 0x2323020e, 0x33112311, 0x7b323315, 0xba211373, 0x0d737bb0, 0x5b0e032b, 0xfe4d81a8, 0xfcb605c3, 0x07747b39,
	0x82888f21, 0x005d08b2, 0x04ecffae, 0x001f0675, 0x406d004b, 0x2e460748, 0x0f004735, 0x2f191f19, 0x40190319, 0x5f48130d, 0x022e6f2e, 0x001f000f,
	0x0803002f, 0x00002e19, 0x4103192e, 0x57114724, 0x204d104d, 0x034dc04d, 0x54414740, 0x3507244c, 0x503a1603, 0x15410147, 0x161a501f, 0x333f0016,
	0xe13f3fe1, 0x068a4212, 0x83f61021, 0x2f2f270a, 0x5d5d5e2f, 0xcd835d2b, 0x82303121, 0x150421c2, 0x20095258, 0x07f77923, 0x260b5766, 0x2e343504,
	0x67222302, 0x34200501, 0x0805bc70, 0x2bf20353, 0x2b3f4b3f, 0x3946270e, 0x213d5838, 0x558d6538, 0x1a358b61, 0x254c4841, 0x18345138, 0x38482b11,
	0x1635553f, 0x3e483e29, 0x533c2129, 0x42583133, 0x713fb627, 0x985c5c9c, 0xec043c6c, 0x3c495939, 0x151e3637, 0x26312721, 0x60524825, 0x517e573e,
	0x06786627, 0x2d194d08, 0x3b242840, 0x28233a38, 0x2a464344, 0x363f4f36, 0x2a2c433a, 0x1313293e, 0xfb415330, 0x68b0044e, 0x2625558d, 0xffff744c,
	0xecff5e00, 0x21069c03, 0x44002602, 0x06010000, 0x00944300, 0x02b41500, 0x02261133, 0xb4e5ffb8, 0x220c3339, 0x9207f741, 0x3576282d, 0x40130000,
	0x823f020b, 0x3385222e, 0x222b9b39, 0x85e24b01, 0x215a832b, 0x57923b33, 0x87e30521, 0x52012285, 0x202b85bd, 0x2257823b, 0x914a3c29, 0xd9052157,
	0x6a30b188, 0x170000de, 0x02030d40, 0x0326113c, 0x47332f02, 0xd9422d85, 0x20e18508, 0x205b8887, 0x202f8750, 0x212f8338, 0x89863d30, 0x00222f85,
	0x2f820003, 0x44066108, 0x38005e04, 0x50004700, 0x1a407c00, 0x1e4b142f, 0x42420448, 0x26484c00, 0x4f52571d, 0x9f525f52, 0x48390352, 0xffb80e00,
	0x0d2e40c0, 0x0e0e4811, 0x00515600, 0x02421042, 0x00501e42, 0x02041004, 0x1f4b0f04, 0x4b07024b, 0x3c21114b, 0x342c2f50, 0x0a0d4816, 0x11141750,
	0x333f0010, 0x3232e133, 0x11360584, 0x5d5e2f39, 0x32e15d33, 0xe610015d, 0x102b2f32, 0xf6105de1, 0x055fe132, 0x05be5a05, 0x210ff874, 0xfe741716,
	0x72152006, 0x23230a2e, 0x57272622, 0x372205c6, 0xaf571614, 0x0e072405, 0x72220103, 0x5e200544, 0x080d0f75, 0x2ba68327, 0x6167a633, 0xfd396c9a,
	0x93930560, 0x4a4e5531, 0x4f4b2725, 0xca8a3155, 0x5f4c223e, 0x7b474a74, 0x61bd345a, 0x0831754f, 0x6e85032b, 0xd7010b7f, 0x0154371a, 0x0d337533,
	0x555d5523, 0x0f74725d, 0x3673722c, 0x271f3b55, 0x5c527b51, 0x4c752656, 0x63023708, 0x7144959c, 0xff002c50, 0xfe7100ff, 0x046f0314, 0x0026025e,
	0x7d4a0046, 0x00422c05, 0xb60b0000, 0x20262f01, 0x4a250d05, 0x7126067d, 0xe103ecff, 0x25822106, 0x97424820, 0x11282b0b, 0xffb80226, 0x282eb4b9,
	0x97420f05, 0x212d8f0a, 0x3f425276, 0x82342005, 0x2876222e, 0x222b9b2e, 0x85de4b01, 0x215a832b, 0x57923003, 0x88d90521, 0xda6a2185, 0x27066b42,
	0x03261131, 0x3c280002, 0x3b425985, 0xffff2205, 0x214a82ff, 0xb5846701, 0xdb84f320, 0x55fe4322, 0x152cdb82, 0x110401b4, 0xffb80126, 0x040ab49a,
	0x240c054b, 0x020000ae, 0x222f8a42, 0x8230ff76, 0x4013242f, 0x8210010b, 0x04742230, 0x212d8b0a, 0x2d82bdff, 0x2d895520, 0xfe4b0123, 0x832d86bb,
	0x0c00215e, 0xff215b8c, 0x202d82ee, 0x85bb8425, 0x846a208b, 0x40172c2d, 0x0d01020d, 0x01022611, 0x4b180400, 0x61080b31, 0x6f000200, 0x2d04ecff,
	0x27002306, 0x74003900, 0x28124640, 0x20230048, 0x1c041916, 0x221c1822, 0x03181c22, 0x3b57000a, 0x3bd03b40, 0x0f033be0, 0x3206013b, 0x3a560a48,
	0x16231920, 0x21211704, 0x0f502d1d, 0x0faf0f12, 0x30020fbf, 0x0f17010f, 0x011d0f17, 0x16055037, 0x3fe13f00, 0x2f2f3939, 0xee615d5d, 0x45112005,
	0x5e24064b, 0xe6105d5d, 0x8305e24c, 0x53102012, 0x516e05f2, 0x1716270b, 0x27262637, 0x05832705, 0x82163721, 0x0717240d, 0x4507031e, 0x14250748,
	0x3233021e, 0x05676e36, 0xaf688708, 0x763f477f, 0x9a6669a8, 0x781f082b, 0x4a00ff5a, 0x2f5528d9, 0x3b7a4146, 0x43c34ae3, 0xbc2c4f6f, 0x4b6e4622,
	0x21466d4d, 0x4c6d4721, 0x3d02879a, 0x4f98dc8e, 0x77b97f42, 0x417eb877, 0x76043c3b, 0x729951c0, 0x1a371c83, 0x2c48207b, 0x4175718a, 0xb0ddbb9c,
	0x32526b38, 0x5583582e, 0x315a7d4c, 0xffff00c7, 0x0000ae00, 0xe3051204, 0x51002602, 0x06010000, 0x00f95201, 0x0b401300, 0x26112101, 0x30220201,
	0x9142170b, 0x2d04230d, 0x2b822106, 0xbf425220, 0x00d82f05, 0x02b41500, 0x02261120, 0xb4d7ffb8, 0x3b4a2026, 0xff71220c, 0x212d8cec, 0x59845076,
	0x822c0221, 0x204e222e, 0x222b9b26, 0x8afb4b01, 0xb4fa2259, 0x84599228, 0x228784b3, 0x84e25201, 0x8428202d, 0xb4fd2387, 0x5b913729, 0x88d90521,
	0xf96a2bb5, 0xb6190000, 0x11290203, 0xb7820326, 0x20b4f923, 0x0cc34a34, 0x00037508, 0x04f80066, 0x00ac0402, 0x00170003, 0x4060002b, 0x012d3015,
	0x1818aa22, 0x0356aa0e, 0x28020366, 0x02033803, 0xffb80003, 0x092840f0, 0x0400480d, 0x1d10ad27, 0x011d0f01, 0x09011d1d, 0x101300ad, 0x60132013,
	0xc013b013, 0x0713d013, 0x00131307, 0x00b301ad, 0x2f33e13f, 0x11e15d5e, 0x715d2f33, 0x332f01e1, 0x5d5d332b, 0xe12f33e1, 0x1330315d, 0x01152135,
	0x0e435218, 0x0f535218, 0x9c036634, 0x1f12bffd, 0x2a171829, 0x20121220, 0x2918172a, 0x0f8f121f, 0x96870236, 0x23eefe96, 0x0d0d1e2f, 0x21232f1e,
	0x0e0e1f2f, 0xdb022f1f, 0x5508108e, 0x00030000, 0x04b4ff73, 0x0091042f, 0x0024001a, 0x405c002d, 0x281f273b, 0x251b041e, 0x16181748, 0x0a080715,
	0x000d0809, 0x2f402f57, 0x2fe02fd0, 0x012f0f03, 0x0d481b06, 0x1e282e56, 0x2b041f27, 0x0a075022, 0x05041518, 0x2b101216, 0x16050850, 0xe1c63f00,
	0xdc4ac63f, 0x5d5e240a, 0x4af6105d, 0x142209db, 0xd64a020e, 0x35262106, 0x1627e584, 0x07173717, 0x4a051616, 0x062207d9, 0xd84a3405, 0x04363405,
	0xb27d432f, 0x44627d6f, 0x463f5083, 0x6fb37c43, 0x8231713f, 0x453e330b, 0x161300fd, 0x4b1d8d01, 0x02879a2d, 0x72fe2744, 0x0983481f, 0xd5892729,
	0x6d354c91, 0x7148834a, 0x26080576, 0x496c1c1d, 0x86d14981, 0x02338354, 0xcf121187, 0xfd639fd1, 0xd310117b, 0x00ffff00, 0x04ecffa4, 0x02210608,
	0x42580026, 0xa33105bb, 0xb4150000, 0x26111b01, 0x9bffb801, 0x0c1b21b4, 0x0ae94219, 0x76282d8f, 0x13000060, 0x27010b40, 0x57222e82, 0x2b9b211b,
	0x084b0122, 0x5a832b85, 0x92230021, 0xd9052157, 0x6a2b8588, 0x19000002, 0x240102b6, 0x82022611, 0xb4fb2387, 0x5b852f1b, 0x2408e947, 0x0314fe0a,
	0x20b784df, 0x21b7845c, 0x5d850e76, 0x89822f20, 0x29236723, 0x08314600, 0x08076772, 0x0014062a, 0x00310020, 0x2f1f4038, 0x33570a48, 0x27013310,
	0x1b151f20, 0x32541c47, 0x1b1b001d, 0x0f15502c, 0x00502116, 0x3f001005, 0x200a8d7a, 0x4a008232, 0x875906bd, 0x14152505, 0x2223020e, 0x220c7472,
	0x72250711, 0x01210d6a, 0x0b5c7264, 0x2806de7b, 0x04020303, 0x0108b6b6, 0x0bc2711f, 0x72b60321, 0x78720b5e, 0x0008250a, 0x119436fe, 0x220d6d72,
	0x8400ffff, 0xd90524f5, 0x85002602, 0xb16a30f5, 0x40170000, 0x2c01020d, 0x01022611, 0x8537230b, 0x0ce94bf7, 0xc106dd22, 0x22087953, 0x5333004d,
	0x172905a9, 0xb8022605, 0x15b4ffff, 0x0c7b5316, 0xecff5e26, 0x6f059c03, 0x21083f49, 0xc749e64d, 0x82352005, 0x3323225e, 0x056d4934, 0x200c3354,
	0x225b8840, 0x4c21004e, 0x02210545, 0x535c821a, 0x2d860862, 0xee205985, 0x4e215988, 0x205985d4, 0x20598238, 0x07974925, 0x00262b86, 0xdd0442fe,
	0x5988bc05, 0x62035126, 0x14000000, 0x803ae782, 0x27300127, 0x27270001, 0x01250000, 0x355d5d2b, 0x5e00ffff, 0xb80342fe, 0x59865e04, 0x51010724,
	0x2d825a02, 0x16402035, 0x0145f002, 0x900145a0, 0x45800145, 0x01453001, 0x86454500, 0x855d2036, 0xff7d2639, 0x079804ec, 0x081b5373, 0x0a017622,
	0x0127c185, 0x01260530, 0x532a24cd, 0x23530620, 0xff712605, 0x066f03ec, 0x06cb4821, 0x76000636, 0x1700004a, 0x2c010e40, 0x10012611, 0x20a70120,
	0x250d0526, 0x35209482, 0x5d8ec586, 0x004b0123, 0x0af54db4, 0x532c7721, 0x5d89077e, 0x5d898f20, 0xf54b0122, 0x20205d85, 0x28235d83, 0x49285301,
	0x5d20052f, 0x37205d8d, 0x0123bb87, 0x8600024f, 0x822f205d, 0x248022bb, 0x21bb912c, 0xbb86e505, 0x4f010725, 0x85003301, 0x852b205f, 0x204d22bd,
	0x22bd9d28, 0x86a8004c, 0x8229205f, 0x2f6b215f, 0xa020bd91, 0x4c21bd8a, 0x205d8506, 0x235d8325, 0x2b64012b, 0xc726bd8e, 0xfc040000, 0x8f827307,
	0x00002728, 0x4c010701, 0x97424a00, 0x051d2a05, 0xffb80226, 0x1823b4b7, 0x0b414f06, 0xecff7126, 0x14065205, 0x47202f82, 0x02232f83, 0x82d90238,
	0xb60b28bf, 0x3e3e5e02, 0x4a251d1d, 0x47530647, 0x06022306, 0x1d829200, 0x82000221, 0x04420835, 0x0014069e, 0x00380027, 0x1f314055, 0x472d001b,
	0x0b1d1d26, 0x3a552622, 0x36013a10, 0x39560b48, 0x1d251527, 0x1e1e224f, 0x33002010, 0x10001650, 0x10201010, 0x28101003, 0x16060050, 0xe1333f00,
	0x03825d3f, 0x2f391225, 0x7532e133, 0xe62b06b5, 0x2f391132, 0x3232e110, 0x7e303132, 0xa76716a4, 0x33152305, 0xac7e2315, 0x85fe272a, 0x9cb67b01,
	0xb27e939c, 0x46250812, 0x8786cc8a, 0x19478bce, 0x21203a2c, 0x10371a1f, 0xb6b6899e, 0x832bfb89, 0x5a85592c, 0x66956127, 0xc6c3cf34, 0x058153c3,
	0x06be0323, 0x073955c1, 0x004d0122, 0x2607d142, 0x0126050e, 0x4a0d0c02, 0x71260c91, 0xe103ecff, 0xf14a6f05, 0x432d8207, 0x2a260593, 0x11022611,
	0x494b2928, 0x05f1550c, 0x59884020, 0xfbff4e22, 0x20060f42, 0x21598211, 0xc1551606, 0x2059850d, 0x215988ee, 0x5985ea4e, 0x59822d20, 0x4b320f21,
	0x59850d77, 0x59881a20, 0x3f014f2a, 0x13003501, 0x17010b40, 0x07225982, 0xb392140c, 0x5986e520, 0x4f010725, 0x85002b01, 0x8233205b, 0x280c225b,
	0x25b58d30, 0xbe0342fe, 0x5b88b605, 0x21025122, 0x0e382d82, 0xff0100b9, 0x1212b4c1, 0x01250000, 0xffff352b, 0x61fe7100, 0x5e04e103, 0x23085588,
	0x003b0251, 0x4027001f, 0x3bf00213, 0x013be001, 0x90013ba0, 0x3b50013b, 0x013b0001, 0xb4caffb8, 0x1a1a3b3b, 0x5d203a82, 0x35210084, 0x07794100,
	0x23094157, 0xf9ff4c01, 0x210a1f41, 0x1f411704, 0x09f14c12, 0xe44c0122, 0x21091f41, 0x1f413309, 0xff7d240d, 0x84f204ec, 0x002a2859, 0x01070100,
	0x86d7004b, 0x052c2859, 0x346d0126, 0x47010c2c, 0x25240aa1, 0xfc0314fe, 0x4a205984, 0x06232d82, 0x84c64b01, 0x5f032859, 0x03032611, 0x55275f67,
	0x59820e81, 0xf5824020, 0x4e225985, 0x5986c900, 0x59823120, 0x92365f21, 0xee052159, 0x59852d82, 0x00b14e27, 0x03b41500, 0x24588264, 0xb4efffb8,
	0x205b9369, 0x225b8837, 0x860c024f, 0x8337205b, 0x342c215b, 0x0521b591, 0x255b86e5, 0x004f0107, 0x5d8400f2, 0x5d846a20, 0x5fb4ec23, 0x25b98d67,
	0xf2043bfe, 0x5d87cb05, 0x01390223, 0x252f8217, 0x5101b60b, 0x5886322c, 0x00ffff22, 0x220e0b41, 0x412d3a02, 0xb283050b, 0x8d651c21, 0x00c726af,
	0x07d50400, 0x21518273, 0x6541002b, 0x587f2005, 0xff240b41, 0x050c14b4, 0x200b3b41, 0x222f82ae, 0x82aa0712, 0x864b202f, 0x012b392f, 0x401f0089,
	0x010d7014, 0x01010c70, 0x1a011a70, 0x19012602, 0x180b1a22, 0x27059e41, 0x5d5d355d, 0x00020000, 0x30080082, 0xb6059c05, 0x17001300, 0x2f405600,
	0x5a0c0414, 0x19650b07, 0xaf0119b0, 0x19100119, 0x0f031701, 0x6410005a, 0x175f0e18, 0x60120a16, 0x13030713, 0x24018217, 0x120b1001, 0x05496c05,
	0x39123325, 0x6c2f2f39, 0x32220546, 0xd77ee110, 0x5d323005, 0xf6105d5d, 0x3232e132, 0x35133031, 0x82211533, 0x15332603, 0x11231123, 0x38038221,
	0x35013523, 0xbac71521, 0xc7ba9a02, 0x66fdbac7, 0x1b04c7ba, 0xc30466fd, 0x080082f3, 0xd3fb964f, 0x56fdaa02, 0xfe962d04, 0x00dfdf8b, 0x00120001,
	0x06120400, 0x00210014, 0x13344055, 0x2147000b, 0x23102355, 0x23802360, 0x12161703, 0x0b0f470a, 0x0d152254, 0x0ebf124f, 0x0e020ecf, 0x0417100e,
	0x101d0050, 0x031d201d, 0x0010101d, 0x06ea7f0b, 0x82e15d21, 0x5d2f24a7, 0x8632e133, 0x823220a0, 0x12e1229f, 0x0d777d39, 0x33352322, 0x2123a882,
	0x7f152115, 0x9c2711fe, 0x7b01b69c, 0x180885fe, 0x08080440, 0x82829a2f, 0x60946634, 0xd504f0fd, 0x89b6b689, 0x3f2b90b8, 0xd2bf142a, 0xff005cfd,
	0x00f5ffff, 0x07c40200, 0x00260235, 0x0100002c, 0xfe520107, 0x067142f3, 0x26051426, 0x23150101, 0x210b4744, 0x2d82a3ff, 0xe3057222, 0xf3202d82,
	0xa1202d86, 0x22054744, 0x82110c01, 0x1b0d212d, 0x200c7544, 0x222d823d, 0x88c1067c, 0xff4d225b, 0x205b8622, 0x455b830e, 0xff210d57, 0x222d82eb,
	0x886f052a, 0xfe4d225b, 0x205b86d0, 0x215b8306, 0x5b8c0504, 0x2d823020, 0x40078a22, 0x4e215b88, 0x075d5aff, 0x5b821120, 0x59450220, 0xdeff210d,
	0x38222d82, 0x5b88ee05, 0xbdfe4e22, 0x09205b86, 0x02215b82, 0x0c17500e, 0xfe520027, 0x05640242, 0x225b88b6, 0x439c0051, 0x00210527, 0x07a25b19,
	0x00ffff29, 0x0142fe44, 0x82e50583, 0x004c2f25, 0x01060100, 0x00002551, 0x020a4010, 0xa882256f, 0x25240b82, 0x355d2b01, 0x52202782, 0x64227b82,
	0x4d883707, 0x50004f22, 0x20060541, 0x20a98217, 0x0ba94500, 0x2405577c, 0x4a046401, 0x0fff7f00, 0xff7f0f20, 0x4a042113, 0xfe265f83, 0x0529047b,
	0xc14100b6, 0x2d002306, 0xad82b602, 0x40382808, 0x7f18010e, 0x184f0118, 0x07401801, 0xb8184807, 0x1740c0ff, 0xbf480606, 0x21a00121, 0x01218f01,
	0x0f012150, 0x83210121, 0x5d2b211c, 0x2b200083, 0x11200682, 0xa026b183, 0x870314fe, 0x5182e505, 0x0724d983, 0x12024d00, 0x2e3f5182, 0x02032040,
	0x011ecf1e, 0x9f0135df, 0x35800135, 0x01355f01, 0x20013540, 0x35000135, 0x82403501, 0x8247855b, 0x3511214b, 0xff234782, 0x5c7bfe48, 0x2d28065f,
	0x07010000, 0xcafe4b01, 0x1420f986, 0x1c23f983, 0x450e0d14, 0xff2b0983, 0x0214febc, 0x02210657, 0x86370226, 0x07a3412d, 0x26111424, 0x2d8d0001,
	0xfec7002b, 0x05a2043b, 0x002602b6, 0x2e2d822e, 0x73390206, 0xb90e0000, 0xb1ff0100, 0x44130db4, 0xff290573, 0xfeae00ff, 0x06f0033b, 0x20258214,
	0x2025854e, 0x25258621, 0x150fb4c4, 0x7d84050a, 0x00013708, 0x030000ae, 0x004a04f0, 0x40490011, 0x1010010a, 0x440f0f0e, 0xb8110111, 0x1c40c0ff,
	0x11480a07, 0x13111110, 0x132f130f, 0x03070702, 0x12540447, 0x050e010c, 0xb043040f, 0x39332705, 0xf6100139, 0x411832e1, 0x400808ff, 0x11393311,
	0x21303133, 0x23110701, 0x14113311, 0x07060706, 0x01330137, 0xfe230301, 0xb4b46dac, 0x04040305, 0xcd330183, 0xac016ffe, 0xfe51e901, 0xfe4a0468,
	0x26663ce7, 0x01b0242c, 0xfd16fe81, 0x0d1747a0, 0xb7822f20, 0x76000724, 0x574565ff, 0x05122b05, 0xffb80126, 0x0c06b470, 0x3b410400, 0xab002709,
	0x34020000, 0xe782ac07, 0x2f864f20, 0x8b012235, 0x14401f00, 0x70010370, 0x70010102, 0x02100110, 0x53660126, 0x5d23092e, 0x845d5d35, 0x3bfe2169,
	0x8306eb47, 0x02062369, 0x21412d39, 0x88dd2006, 0xffff2963, 0x3bfe6600, 0x14066c01, 0x02245f87, 0x00f7fe39, 0xe0212786, 0x475487b4, 0x052107cf,
	0x842782b7, 0x380234b7, 0xa3ff0001, 0x0d401600, 0x01030b01, 0x60010610, 0x83020c06, 0x625d20b7, 0xae2006bb, 0xb420b782, 0x06385788, 0x003b3802,
	0x11401800, 0x0e400401, 0x40044810, 0x5e480906, 0x03030404, 0x2b22e982, 0x5f88352b, 0x5f87b620, 0x014f012c, 0x0065fde3, 0xab01b60b, 0x10410e06,
	0x05855206, 0x06a2022b, 0x00260014, 0x0100004f, 0x08258207, 0x38fd2d21, 0x16402b00, 0xef0113ff, 0x139f0113, 0x01138f01, 0x5f01137f, 0x131f0113,
	0x01b80101, 0x4804b42e, 0x5d200669, 0x36820085, 0x1d003508, 0xbe030000, 0x0d00b605, 0x32406100, 0x0c05060b, 0x04030005, 0x0504040d, 0x08080a05,
	0x010faf0f, 0x0c010f10, 0x03060d0d, 0x000b5a07, 0x050e640a, 0x040c0d04, 0x012a0182, 0x120a5f07, 0x3f000301, 0x7146e13f, 0x11220806, 0xf6100133,
	0x32e13232, 0x332f3332, 0x33115d5d, 0x2f391211, 0x877d1033, 0x10c4c404, 0x31c4c487, 0x13821330, 0x17372508, 0x15211105, 0x27071121, 0x4ee3bac7,
	0x3d02cffe, 0x496109fd, 0x1203a402, 0x7d8f63fd, 0xa639febe, 0x7d3cf801, 0xff259982, 0x020000f6, 0x2ddf821d, 0x4069000b, 0x500d403b, 0x0609020d,
	0x9e830a05, 0x0b0a0b37, 0xdd04080b, 0x05bb0105, 0x0f0205cb, 0x2f051f05, 0x05060305, 0x2aa48205, 0x08000947, 0x0a0b0c54, 0x820a0405, 0x07012401,
	0x82000115, 0x27a190a2, 0x5d5e2f32, 0x11335d5d, 0x9f88a982, 0x875d0121, 0x110722a1, 0x369f8223, 0x4e6bb6ae, 0x4e6ab6b9, 0x1e03f602, 0x794559fd,
	0x023ffd78, 0x5e79464a, 0x732008cb, 0x2307cb5e, 0xf2007600, 0x220abd4d, 0x531e1855, 0xae260c4b, 0x12040000, 0x2d542106, 0x76002f07, 0x1300006f,
	0x25010b40, 0x5c012611, 0x2d541f19, 0xfec7260c, 0x050e053b, 0x235987b6, 0xd9003902, 0x21078142, 0x5787b4e1, 0x2305f143, 0x5e041204, 0x02225387,
	0xa7424c39, 0xb4de2106, 0xa7915187, 0x004c0123, 0x26a7869c, 0x0126051d, 0x9b182300, 0x4c0128a7, 0x1500000c, 0x821e01b4, 0xffb825a6, 0x1924b4fa,
	0x5d82a98b, 0x04003408, 0x00b605a1, 0x00510027, 0x0100008f, 0xe8070206, 0x40290000, 0x5518001d, 0x0127ef27, 0x9f0127bf, 0x275f0127, 0x01272f01,
	0x08084027, 0x06402748, 0x452b4806, 0x1022053b, 0x328234f6, 0xfec70023, 0x08ed837b, 0x00250044, 0x182a404a, 0x205a1f0c, 0x20150404, 0x27b02765,
	0x01278f01, 0x27102700, 0x0e131702, 0x64155a14, 0x160d1f26, 0x18121503, 0x5f07120c, 0xe12f0000, 0x3f3f333f, 0x10013333, 0x3232e1f6, 0x5d5d5d32,
	0x774de610, 0x30312206, 0x09707c01, 0x18013521, 0x0809fd43, 0x2633012c, 0x35262627, 0x14113311, 0x8b03020e, 0x221b4d33, 0x4b252d4e, 0x08fd263d,
	0x04040608, 0x02d5ac05, 0x040307cc, 0x37ae0503, 0x5b188f64, 0x59180a81, 0x75270b29, 0x7d384141, 0x18200334, 0x6a09935b, 0x2f0805dd, 0x0028005e,
	0x0322403a, 0x470c1703, 0x102a5524, 0x802a602a, 0x161a032a, 0x29541747, 0x2050101a, 0x170f1810, 0x00500715, 0xe13f001b, 0xe13f3f3f, 0x7861b885,
	0x20b18b08, 0x6b461813, 0x03152111, 0x0221b182, 0x0d4818ee, 0x69022909, 0x436e5170, 0x1a94b61d, 0x2208fc48, 0x186d4822, 0x210a1448, 0x0b496d03,
	0x04c72306, 0x0649944a, 0x95fc3b05, 0x2f577b4d, 0x7d00ffff, 0x7105ecff, 0x2602c106, 0x00003200, 0x4d010701, 0x1342bc00, 0x2a022705, 0x00022605,
	0x13422928, 0xff71260c, 0x052d04ec, 0x0707566f, 0x144d012a, 0x40130000, 0x1122020b, 0x20212b82, 0x842b8c21, 0x40072159, 0x4e225988, 0x5986aa00,
	0x59822d20, 0x61320121, 0x59850d55, 0x5988ee20, 0x00004e27, 0x02b41500, 0x24588225, 0xb4ffffb8, 0x0dbd562a, 0x0f625b85, 0x53012308, 0x5b82ec00,
	0x0d40172a, 0x05340203, 0x43020326, 0x820d5361, 0x0e4957e7, 0x46530123, 0x051d5c00, 0x82112c21, 0x5645202f, 0x02210ebf, 0x08618200, 0x05a40644,
	0x001900cd, 0x405b002a, 0x01161436, 0x14001616, 0x27275a18, 0x67001209, 0x012c1f2c, 0x66095b1f, 0x4f5f172b, 0x140f0114, 0x080214af, 0x12191414,
	0x1a03115f, 0x24040e5f, 0x1913045f, 0x0012005f, 0x0185e13f, 0x18391221, 0x27089f60, 0x32e6105d, 0xe12f3911, 0x5d250483, 0x21213031, 0xc4591806,
	0x6517200c, 0xb67409be, 0x37362b08, 0x06262611, 0x2b0afda4, 0x5918305b, 0x623d07c1, 0xfdf40254, 0xfd1702c2, 0xfc3e02e9, 0x6ca67256, 0xa56b3434,
	0x265a3472, 0x0b095926, 0x245b186c, 0x65172008, 0x043a05e1, 0xda975185, 0x99db898a, 0x040f1251, 0x00111058, 0x71000300, 0xe106ecff, 0xdf825e04,
	0x00364108, 0x4064003f, 0x3f03133b, 0x31d0481d, 0x0b313101, 0x1c254837, 0x410f4157, 0x0141ff01, 0x2b014140, 0x40560b48, 0x3f1b501d, 0x0f023f2b,
	0x3f06013f, 0x343c2e3f, 0x10131650, 0x502e2010, 0x16060003, 0x2405bd5c, 0xe133333f, 0xd04e1832, 0x5d5d220a, 0x06b75c71, 0x32e15d2a, 0x30313939,
	0x27262205, 0x2109f868, 0xb55c3233, 0x14012114, 0x09d24c18, 0x2e34053d, 0x06222302, 0x82600507, 0xc63f41cc, 0x7fae6780, 0xb37c4347, 0x3fc3796f,
	0x1875b93c, 0x3711fc4e, 0x9a899afb, 0x978c8b96, 0xf004879a, 0x3e58391b, 0x140b8572, 0x706d6d70, 0x07544818, 0x696a6f23, 0x0f995c70, 0xd13b0230,
	0xdcd1c9d3, 0x4462cfce, 0x9c2c5071, 0x29450095, 0xa0042605, 0x26027307, 0x059f6a00, 0x6f647620, 0x05292b07, 0xffb80226, 0x231db4ee, 0x89480d02,
	0x00ae230a, 0x19570300, 0x00552705, 0x00060100, 0xd345ce76, 0x11232805, 0x17400126, 0x8a030e1d, 0xfec7262b, 0x05a0043b, 0x2b5b86b6, 0x77390206,
	0xb90e0000, 0xb6ff0200, 0x81825588, 0x3bfe6026, 0x5e040803, 0x51832582, 0x39020725, 0x8400f1fe, 0xff012327, 0x5187b408, 0x012aa991, 0x010e004c,
	0xb4150052, 0xa9842202, 0x28b4a923, 0x20a98c1d, 0x22a98272, 0x8721060a, 0x4c012357, 0x578270ff, 0x01b41523, 0x25aa821c, 0xb4e3ffb8, 0xad8c1722,
	0xecff6826, 0x7307c903, 0x36202f82, 0x21056349, 0xc5433b00, 0x40012805, 0x70012605, 0x4e083a34, 0x5a200be9, 0x3f202d82, 0x56205d84, 0x06232d82,
	0x41dc7600, 0x42200507, 0x5d225c82, 0x2b8c3c36, 0x0123598e, 0x86edff4b, 0x82342059, 0x3c222259, 0x8e2d8c34, 0x4b012259, 0x2059859b, 0x22598236,
	0x8c363e1c, 0xfe68262b, 0x05c90314, 0x22b388cb, 0x4135017a, 0xfa22073b, 0x57863ab4, 0x00ffff23, 0x2227825a, 0x825e043f, 0x24ad8327, 0x007a0007,
	0x242782f0, 0x0101b60b, 0x8250873c, 0x22a78f25, 0x86e6ff4c, 0x823920a7, 0x3f1b21a7, 0x4c21a79d, 0x20a78597, 0x21a7823b, 0xa78d4118, 0x3bfe1426,
	0xb6051204, 0x37277f82, 0x06010000, 0x41f93902, 0xd82506e1, 0x030e08b4, 0x066f5205, 0x3bfe2126, 0x46058f02, 0x57202582, 0x07242582, 0x5dff3902,
	0xf724cd87, 0x12241eb4, 0x14262787, 0x12040000, 0x4d867307, 0x4c010724, 0xa786c8ff, 0xa7820d20, 0x08130322, 0x71565185, 0xff212606, 0x06e802ec,
	0x2c558614, 0x6f380206, 0xb60b0000, 0x24246101, 0x05835018, 0x0a275c18, 0x000f5c08, 0x1f4c4073, 0x11e00111, 0xdf115f01, 0x11200211, 0x11401130,
	0x05bf0803, 0x050205ff, 0x5a060a05, 0x50010f01, 0x0202f002, 0x0201021f, 0x01770d02, 0x01970187, 0x01013103, 0x01100100, 0x07030120, 0x600d0a01,
	0x03000007, 0x0206120b, 0x0003035f, 0x3f32e13f, 0x332f3912, 0x490132e1, 0x33360579, 0x125d5d2f, 0x32e11039, 0x395d2f32, 0x715d5d5d, 0x11013031,
	0x0c453521, 0x82232007, 0xb6013c0b, 0xfe035efe, 0x27015ffe, 0xfebbd9fe, 0x013303d7, 0xfea4a4df, 0x62fd9521, 0x18959e02, 0x080a2f49, 0x6a002541,
	0x011f14b6, 0x051c1c20, 0x40c0ffb8, 0x480b0837, 0x2f270505, 0x02273f27, 0x47231b1f, 0x1f160f13, 0x18160216, 0x10100014, 0xb010a010, 0x0510c010,
	0x22111007, 0x1f1f144f, 0x4f1e150b, 0x181b181a, 0x890c3c49, 0x333324a6, 0x82325dc4, 0x115d2ba1, 0x332b2f33, 0x5d003311, 0x49183031, 0x35230c49,
	0x82333523, 0x37372303, 0xb8821533, 0x49180384, 0x8b2e1151, 0x4e9b9b8b, 0xfe140169, 0xfe0201ec, 0x49183ffe, 0xfb2c0d57, 0x4e51f88a, 0xf889fce6,
	0x6261fb8a, 0x21083d66, 0xaf650235, 0x52012306, 0x03826000, 0x01b4152c, 0x01260520, 0xb4ffffb8, 0x0f662f21, 0xffa4260c, 0x050804ec, 0x272f82e3,
	0x01000058, 0xf3520106, 0x22098744, 0x5b322406, 0xb8200c73, 0xef592b82, 0x82382005, 0x0107242b, 0x858f004d, 0x861a205b, 0x1918215b, 0x6f205b92,
	0x4d215b88, 0x265b8521, 0x0126111d, 0x911c1b05, 0x4007215b, 0x4e22b788, 0x694a7d00, 0x6622200b, 0xb5850d95, 0x5988ee20, 0x850c4e21, 0x82202059,
	0x25042159, 0x840dfd5b, 0xd90721b5, 0x50225988, 0x316b7b00, 0x051d2507, 0x00010226, 0xd75a5b87, 0x215d8408, 0x5d888706, 0x5d825020, 0x0d401724,
	0x5e820102, 0x05010222, 0x2f885f87, 0x230e8167, 0xb2005301, 0x24206187, 0x36206183, 0x83102367, 0x5d0e2061, 0x01240917, 0x00005053, 0x27216184,
	0x20918211, 0x108f5c48, 0x42feb826, 0xb805dd04, 0x512ac388, 0x00001902, 0x01b60b00, 0xde67250d, 0xffff2307, 0x2582a400, 0x4a041622, 0x0724b786,
	0xb8025101, 0x0e252585, 0x1a1a2121, 0x06c75825, 0x00001426, 0x7307fe06, 0x3a272582, 0x07010000, 0x45014b01, 0x2b27079f, 0x00012605, 0x501e2b33,
	0x00200a6d, 0x05212d82, 0x20a984e3, 0x212d855a, 0x5382ae00, 0x0b401325, 0x82113001, 0x3038232d, 0xe96f2e11, 0x0afb670e, 0xff4b0123, 0x06c541d0,
	0x5b820920, 0x09110222, 0x5c09fb67, 0x655d076f, 0x4b012209, 0x097b42a9, 0x232b0222, 0x8209655d, 0x2374822b, 0x2b073704, 0x3c20b582, 0x00238783,
	0x41ceff6a, 0x12270763, 0x01022605, 0x851d0901, 0x0895415b, 0x00005223, 0x20e78503, 0x2231843d, 0x86390076, 0x8216208b, 0x0a5e228b, 0x0c275310,
	0x35202d83, 0x5d208b84, 0x20058746, 0x208b85d6, 0x20e58216, 0x222b9260, 0x823707fe, 0x2359848b, 0x29014f01, 0x210ae168, 0x9f6e0a0b, 0x2159840d,
	0x2d82e505, 0x07245983, 0xcd004f01, 0x20064141, 0x205b8215, 0x8a2d9214, 0x4c0123b5, 0x5b86e0ff, 0xb5820f20, 0x63150621, 0x00200cc7, 0x0122b58e,
	0xb585864c, 0x59820f20, 0x2b8b1020, 0x01003308, 0x0000ae00, 0x1f06be02, 0x25001300, 0x09091540, 0x10150015, 0x03152015, 0x54004713, 0x06500d14,
	0x00150001, 0x01e13f3f, 0x5de1f610, 0x312f3311, 0x0d613330, 0x724f1805, 0x2dae320a, 0x3b4e7c55, 0x1f2f2663, 0x3a282848, 0xb0041327, 0x5957186b,
	0x4efb210b, 0x32086582, 0x0314fecb, 0x00cb05e9, 0x404a002b, 0x012d302a, 0x011f1f29, 0x12161247, 0x0a121414, 0x1012000a, 0x40123012, 0x12070412,
	0x16600013, 0x230d2929, 0x82071c50, 0x001b217c, 0x45058379, 0x332107df, 0x2f82822f, 0xe1103311, 0x5d322f32, 0x11013031, 0x23020e14, 0x230a964d,
	0x37352311, 0x11065818, 0x8f021530, 0x4e7b552d, 0x1a1c3d20, 0x3b281f39, 0x58181326, 0xb1880713, 0x4403f624, 0xb4833ffc, 0x9906092d, 0x30130a08,
	0xc3034153, 0x8c89444b, 0x899125c6, 0x00040000, 0xc8080082, 0xaa07dd04, 0x23001600, 0x3e003100, 0x5e400101, 0x29012989, 0x302a2abe, 0x381d3131,
	0x1f0d0f83, 0x0d10020d, 0x0d020d20, 0x6623560d, 0x07230223, 0x69175908, 0x17060217, 0x83321d05, 0x001f000f, 0x0003006f, 0x010ad600, 0x0a470a37,
	0x0ac70a57, 0x03d90a04, 0x48033801, 0xc8035803, 0x1d030403, 0x1005091d, 0x04800104, 0x04d00490, 0xffb80403, 0x061840c0, 0x1004480a, 0x0f400404,
	0x2f401f40, 0x9f408f40, 0x0640df40, 0xb8090807, 0x3140f0ff, 0x235f0709, 0x0e0a201d, 0x030a1d48, 0x0135193c, 0x10128c35, 0x128f013c, 0x600212ef,
	0x31100112, 0x23023120, 0x3131123c, 0x04233c12, 0x04092904, 0x333f0012, 0x3917122f, 0x2000822f, 0x2800825d, 0x115de110, 0x2b333333, 0xc26f1810,
	0x3912260e, 0x5d332f3d, 0x2802835d, 0xe15d2f18, 0x39391211, 0x3a03835d, 0x715d2f33, 0x2f3311e1, 0xed2f3333, 0x0130315d, 0x01070614, 0x03210323,
	0x62260123, 0x1e2c0653, 0x2e030302, 0x030e2703, 0x3e130307, 0x0807ce79, 0x26341326, 0x15062223, 0x33171614, 0x50033632, 0xfc01333c, 0xd3fd9abe,
	0xf801bc9c, 0x3b203a33, 0x54313252, 0x940c233e, 0x0a057018, 0x30158523, 0x08ff792f, 0x3fbc7008, 0x333f3132, 0x3f320c31, 0x60469c05, 0x0123fb19,
	0x0479fe87, 0x466019db, 0x1d384f33, 0xfc4f371d, 0x107d015f, 0x1c3b362e, 0x2e363c1c, 0x0483fe0f, 0x413d188b, 0x16101c40, 0x16424741, 0x3c34f6fe,
	0x3b33343c, 0x05003c03, 0xecff5e00, 0xaa079c03, 0x31000d00, 0x54004000, 0x9c006000, 0x83552340, 0x411f410f, 0x4103412f, 0x4b835b41, 0x824b0d06,
	0x1a500801, 0x47370f1e, 0x3f625531, 0x483e0162, 0xffb8281a, 0x0d3a40d0, 0x10284811, 0x28480c09, 0x61561a28, 0x50508c58, 0x700d600d, 0x0d0d030d,
	0x5e055050, 0x5046408c, 0x46460246, 0x2b502427, 0x1e1e5238, 0x5032102b, 0x0e16150f, 0x01050f15, 0x5d2f0005, 0x0a8d5e18, 0x5d2f3326, 0x2f3911e1,
	0x10210682, 0x059c69e1, 0x2b059d69, 0x113232e1, 0x2f2f3939, 0xe110cd10, 0xe1231c82, 0x41013031, 0x01200842, 0x29af5e18, 0x18140121, 0x200d3a55,
	0x077d4107, 0x36323324, 0x5841c701, 0x23522508, 0x25520178, 0x27d95e18, 0x2386013c, 0x3231543d, 0x21213b52, 0x3032523b, 0x75233e54, 0x3f32313f,
	0x3f313839, 0x6d41b806, 0x5cf9220a, 0x035f1898, 0x08052929, 0x1d385133, 0x334f381d, 0x2406c841, 0x3c3c3534, 0x2d038235, 0xfeffffff, 0x56060000,
	0x26027307, 0xab458800, 0x25022105, 0x2905934c, 0x02260520, 0xb44801b8, 0x1f5b1a14, 0xff5e260c, 0x064406ec, 0x202f8221, 0x212f85a8, 0x53457501,
	0x5d032905, 0x71032611, 0x1c005751, 0x220a9546, 0x72b4ff7d, 0x9a20060b, 0x02202d86, 0x28055345, 0x26053e03, 0x38325803, 0x0b235611, 0xb4ff7324,
	0x5b842f04, 0x0946ba20, 0x05416705, 0x823a0321, 0x2e4c2359, 0xbd4c0d34, 0xfe68220b, 0x0a374c3b, 0x39020622, 0x2107674b, 0xe74cb4da, 0xffff2307,
	0x25825a00, 0x8209354c, 0x4bbb2025, 0xe12106b5, 0x08e14cb4, 0x01016b08, 0x03d90402, 0x0021069a, 0x40250014, 0x040e0f11, 0x08c00004, 0x00800e04,
	0x085f080f, 0x2f000802, 0xcc1a335d, 0x1a2f0132, 0x2f3d39cc, 0x30313333, 0x26262301, 0x07060627, 0x033e3523, 0x031e3337, 0x799a0317, 0x36346c33,
	0x1a79336a, 0x103b4344, 0x433b10c0, 0xd9041945, 0x37376122, 0x1d1b2261, 0x2251514c, 0x4c515122, 0x6b8e001d, 0x10050630, 0x0bc00010, 0x10800d13,
	0x065f060f, 0x6b840602, 0x6b8ccd20, 0x07030e33, 0x27032e23, 0x16163335, 0x37363617, 0x199a0333, 0x2b638645, 0x33791a44, 0x6c34366a, 0x06067933,
	0x50236482, 0x82502323, 0x221b2664, 0x61383861, 0x206b8222, 0x32d7821b, 0x006f055a, 0x40150003, 0x0000010a, 0x5f030f8f, 0x82030203, 0x7ee12064,
	0x212b0508, 0x1b012115, 0xc1fd3f02, 0x82966f05, 0x8221202f, 0x057b2d2f, 0x001500ee, 0x151c402f, 0x0100ff83, 0x83339c82, 0x0a7f000a, 0x0a9f0a8f,
	0x10800a03, 0x5f050f8f, 0x83050205, 0xcd1a2241, 0x27a7825d, 0x5ddc1ae1, 0x013031e1, 0x0805ba6c, 0x1e332731, 0x3e323303, 0x7b033702, 0x6d4d2c04,
	0x496d4947, 0x046c0327, 0x2c43301c, 0x22334124, 0x3dee0504, 0x27294a65, 0x2b3f6649, 0x09071932, 0x8228311b, 0x05a03c62, 0x05750100, 0x000d00e5,
	0x0810401c, 0x91030087, 0x0bcf0b9f, 0x30030bef, 0x820b010b, 0xe55d2369, 0x62822f01, 0x46181320, 0xa0200bcc, 0x09505b18, 0x3c73052f, 0x2b1c0d36,
	0x38393a1e, 0x01020000, 0x08c3826d, 0x87063131, 0x1f001300, 0x2d404000, 0x000f8314, 0x004f003f, 0x0004005f, 0x0a30831a, 0x8c170a01, 0x0f1f0f0f,
	0x0f4f0f3f, 0x0faf0f5f, 0x06070fff, 0x898c1d0f, 0x5ed428d6, 0x2f01e15d, 0x84d4e15d, 0x1ae243d6, 0x43310321, 0x202106a9, 0x0fa94320, 0x43b20521,
	0xed82166f, 0x42fe1f39, 0x00005e01, 0x16001400, 0x80060940, 0x120d8400, 0x000a8e03, 0x822fe12f, 0x1a3908e5, 0x173031cc, 0x32331614, 0x06153736,
	0x26222306, 0x023e3435, 0xb4063337, 0x2d192234, 0x1d401a0e, 0x2f1e6464, 0x8b811a38, 0x052b2dee, 0x08087104, 0x4b2a5a68, 0x85133440, 0x06594200,
	0x05d12808, 0x001b00e3, 0x0f234038, 0x02172f17, 0x20090017, 0x09070209, 0x0e8f0516, 0x48131040, 0x0b07400e, 0x130e0e48, 0x820f098f, 0x2f003489,
	0x33e1325d, 0xe12b2b2f, 0x5e2f0133, 0x315dcc5d, 0x51220130, 0x232005c2, 0x83051367, 0x0e333b87, 0x28fe0203, 0x20464c4f, 0x680e302d, 0x4a352105,
	0x4c512a2e, 0x2e2d1d45, 0x0d83690f, 0xdb042008, 0x35232b23, 0x45623c3e, 0x232a2325, 0x613c3e34, 0x00002645, 0x04df0002, 0x06be03d9, 0x820d0021,
	0x402d2d8f, 0x0e0e1419, 0x00504007, 0x4f003f01, 0x13241c82, 0x1b809205, 0x08964018, 0xed1a332e, 0x5d2f0132, 0x39cd1a5d, 0x3031cd2f, 0x2009cf46,
	0x08964525, 0x2f16df30, 0xc7102a2f, 0x514d3f10, 0x6b016523, 0x0d823015, 0x0d84c620, 0x40186420, 0x6b430cb5, 0xc1401805, 0xf8012108, 0x04208582,
	0x272c8584, 0x10051640, 0x0548110c, 0x000c4006, 0x8182fd82, 0x1a218088, 0x247e82ed, 0x32cd1a33, 0x0c0a462b, 0x0af82308, 0x04101314, 0x2d2106c7,
	0x046c1834, 0x514d1ef4, 0x18152150, 0x2056574e, 0x14010300, 0x89030c05, 0xdf84b406, 0x6600292b, 0x841c1940, 0x241f240f, 0x37048302, 0x240324cf,
	0x480c0940, 0x160d2424, 0xffb80e84, 0x092740c0, 0x0e0e480d, 0x0c3b8086, 0x0c92050d, 0x91111f0c, 0x0119ff27, 0x19b01960, 0x0f0319d0, 0x02191f19,
	0x4f001906, 0xe5230561, 0x822f3932, 0x82332093, 0x2f332491, 0x8211e12b, 0x715d2104, 0x200ca746, 0x0b0d4327, 0x0de74918, 0x190bfe39, 0xcf081618,
	0x3d383012, 0x38ea5220, 0x1a231329, 0x29263a10, 0x18b50138, 0x320af649, 0x4f4b1e87, 0x20142451, 0x2551504d, 0x0c303606, 0x181b2619, 0x250c044a,
	0xe9ffffff, 0xad670000, 0xfd54350c, 0x0097fff1, 0x1a02b618, 0x22300203, 0xe9ffb801, 0x042222b4, 0x18082b5b, 0x82732141, 0x82e720a5, 0x054d30a5,
	0x002700b8, 0x008f0028, 0x01070100, 0x82effd54, 0x2e2a08a7, 0x031101b4, 0xffb81201, 0x0f08b2c0, 0x9dffb848, 0x12120f40, 0x00250202, 0xbf1b6700,
	0x1b0f011b, 0x5d5d0101, 0x0134fe10, 0xe95b2b2b, 0x82ff2005, 0x50052149, 0x26234982, 0x897b2b00, 0x8a312047, 0x82112047, 0x40b12647, 0x06121212,
	0x29478206, 0x011b6f65, 0x10011b2f, 0x0482011b, 0x5d5d5d24, 0x4a8534fe, 0x95850020, 0x84600321, 0x002c2295, 0x22958afc, 0x83164066, 0x12c03696,
	0x0112a001, 0x20011230, 0x12100112, 0x01120001, 0x40a5ffb8, 0x3c58852f, 0xd00100f0, 0x00c00100, 0x0100af01, 0x60010070, 0x00500100, 0x01004001,
	0x0001003f, 0x286c8220, 0x48070740, 0x0907401b, 0x21ba8248, 0x7882115d, 0x35200285, 0x5c059e59, 0xff2c06b7, 0x05ecffe7, 0x00cd05c3, 0x52320026,
	0x2408cd89, 0x02304047, 0xa002032d, 0x2e80012e, 0x012e7001, 0x20012e50, 0x2e10012e, 0x012e0001, 0x0a2e2e24, 0x0001250a, 0x2a708450, 0x37bf6700,
	0x01370f01, 0x82100137, 0x5d5d23da, 0x5f863434, 0xe3866084, 0x84540521, 0x013c22e3, 0x2fe38a1d, 0x0e01b44b, 0xb80f0103, 0x16b6c0ff, 0x0fa04817,
	0x25080a84, 0x481109b2, 0x40d6ffb8, 0x070f0f1c, 0xc0002507, 0x05b00105, 0x01057f01, 0x05010520, 0x2f01183f, 0x180f0118, 0xc9820101, 0x3528d084,
	0x2b5d2b2b, 0x353f0035, 0x06216786, 0x22c98300, 0x895a7601, 0x403539c9, 0x03350123, 0x01362001, 0x00013610, 0x36160136, 0x25131336, 0x011d5000,
	0x1d280282, 0x013fbf67, 0x3f013f0f, 0xbb83bc87, 0xe42a4f87, 0x7702ecff, 0x2602b406, 0xb5848601, 0xd0fe5535, 0x18000000, 0x02030f40, 0x0124c001,
	0x20012440, 0x6a153a24, 0x35230687, 0x82ffff35, 0x0509431d, 0x24000623, 0x07715600, 0xb6058726, 0x25000602, 0x3c081b82, 0x00c70001, 0x05be0300,
	0x000500b6, 0xc40a4043, 0x0200f400, 0x020100b0, 0xc0ffb800, 0x13081f40, 0x07000048, 0x072f070f, 0x076f074f, 0x11400704, 0x5a034818, 0x02066404,
	0x0303055f, 0x07f84d12, 0x115d2b3a, 0x5f2b2f33, 0x30315d5d, 0x11211501, 0xbe031123, 0x05bac3fd, 0xf0faa6b6, 0x00215882, 0x21698302, 0x63846804,
	0x58000e30, 0x04051140, 0x0b020606, 0x7001605b, 0x6f18b001, 0x2608080c, 0x480a0627, 0x2f100101, 0x6f105f10, 0x9f107f10, 0x0610bf10, 0x09064010,
	0x025b0a48, 0x110a2006, 0x03040648, 0x82025f0a, 0x3fe12674, 0x2f012b33, 0x227585e1, 0x4812e15d, 0x2e0806d8, 0x35211525, 0x06073301, 0x21030706,
	0x04262603, 0x01bdfb68, 0x115ebbc2, 0x02fe1d2a, 0x2e1ffcae, 0x05857d7d, 0xa84acd31, 0x020afd5b, 0x41a861f0, 0xfb83060b, 0x00060224, 0x0f830028,
	0x00005226, 0xb605fe03, 0x3d200f82, 0x20082b41, 0x210f84d5, 0x1a82002b, 0x2205c35a, 0x7000cd05, 0x2208056b, 0x00344053, 0x0e010001, 0x67045b22,
	0x012dd02d, 0x80012dcf, 0x2d3f012d, 0x18022d6f, 0x2c660e5b, 0x7d0f6003, 0x042b0614, 0x1d000008, 0x04135f27, 0x18095f1d, 0x27084379, 0x01e15d5e,
	0x5de1f610, 0x06820082, 0x3939122b, 0x30312f2f, 0x21152101, 0x055c7a25, 0x597a2620, 0x18162009, 0x2b10668a, 0x1602ec01, 0x8503eafd, 0x9beda051,
	0x1d6b7318, 0xa1390326, 0xeafea945, 0x1fd07418, 0x84074963, 0x882c20ed, 0x84a220fd, 0x822e200f, 0x820120fd, 0x04003a03, 0x00b6058b, 0x405f000c,
	0xef0e2f1c, 0x030eff0e, 0x1512400e, 0x0d400e48, 0x08048210, 0x4809064c, 0x05050b0c, 0xffb80a09, 0x0a2240f0, 0x4f002f01, 0x9f005f00, 0xcf00af00,
	0x0700ef00, 0x00010010, 0x20050010, 0x05480e0a, 0x000a030b, 0x323f0012, 0x012b333f, 0x5d5d382f, 0x33382f32, 0x332f3d39, 0x2b2b2b33, 0x2130315d,
	0xa44a0123, 0x23013e05, 0x8b043301, 0x1fdbfec6, 0x2a110f2e, 0xc5d9fe1d, 0x03bbe701, 0x4ba8619a, 0xfc5ba84b, 0x278c8260, 0xc700ffff, 0x2f060000,
	0x3020a784, 0x0521b787, 0x200f840e, 0x26b38231, 0x00520003, 0x82ee0300, 0x00032e2a, 0x000b0007, 0x143e4063, 0x011b0100, 0x088e8201, 0x060b0124,
	0x01080006, 0x3f0108c0, 0x0d080108, 0x0d6f0d4f, 0x010d3002, 0x0b700707, 0x4f020b80, 0x030b010b, 0xbf820f5f, 0x0008022d, 0x5f0b0400, 0x5f07120a,
	0x7e000304, 0x6b4906cf, 0x335d2f05, 0x105d5d2f, 0x715d5dce, 0x39112f32, 0x0d822f39, 0x13303126, 0x03211521, 0x013c0382, 0xcd352115, 0x5afda602,
	0xfc4a0352, 0xfc7303b6, 0xa24e0364, 0xfba40a03, 0x00a4a492, 0x2507135d, 0x0602cd05, 0xa9823200, 0xc9830120, 0x82c10421, 0x072008a9, 0x1e403100,
	0x65005a01, 0x0109b009, 0x099f096f, 0x100309af, 0x5a040109, 0x03086405, 0x0503065f, 0x42053c41, 0x1025073f, 0x3031e1f6, 0x05536721, 0xc104212b,
	0xba7bfdbb, 0x1205fa03, 0x41f483fa, 0x0423051f, 0x82b60533, 0x84332065, 0x824e2065, 0x821220cc, 0x0b3a0865, 0x0d405a00, 0x20065b08, 0x02481714,
	0x01060206, 0xc0ffb80a, 0x15062640, 0x0d0a0a48, 0x0d2f0d0f, 0x0d8f0d6f, 0x09070604, 0x012f035b, 0x0102013f, 0x09020208, 0x03045f07, 0x7f835f09,
	0x433fe121, 0x0124057a, 0x335d2f18, 0x2606a163, 0x3939122b, 0x822b2f2f, 0x3324088e, 0x35010135, 0x01211521, 0x4e152101, 0x6efe9e01, 0x58fd7d03,
	0x67fe8501, 0x0298f702, 0x93250266, 0xfdeefda4, 0x20050541, 0x828f8514, 0x0037229f, 0x06b14400, 0xaf843720, 0xaf823c20, 0x00035b08, 0x05ecff68,
	0x00cb05ba, 0x002e0021, 0x4081003b, 0x67022250, 0x5a110111, 0x129a213b, 0x01128701, 0x1201127a, 0x5b281b12, 0x2f3d6708, 0x3d00013d, 0x013dd001,
	0x3dbf3daf, 0x013d9002, 0x30013d5f, 0x3d0f013d, 0x06023d1f, 0x661b5b35, 0x603b223c, 0x2e131013, 0x0221602f, 0x01821321, 0x00131126, 0x3f3f0004,
	0x1124b683, 0x32e11033, 0x01240484, 0x5ee1f610, 0x21059946, 0x0b827171, 0x2f391122, 0x33280d82, 0x325de133, 0x01303132, 0x35052a7c, 0x040e1415,
	0x23152323, 0x2e222335, 0x3e343504, 0x13333302, 0x747b3233, 0x032b2705, 0x15020e22, 0x13821e14, 0xb4025c08, 0xc28649bb, 0x34183c7e, 0x659f7854,
	0x652fbb2f, 0x3554789f, 0xc27e3d18, 0x1abb4a85, 0x2e5b8b5d, 0x577f5329, 0x5739bb39, 0x2e28547f, 0x1a5d8b5b, 0x5eb4cb05, 0x3d66c499, 0x526e7b81,
	0x30e1e130, 0x817b6e52, 0x99c4663d, 0x3b53fc5e, 0x4e589469, 0x3c3c688b, 0x584e8b68, 0x413b6994, 0x6408062d, 0x02b60560, 0x003b0006, 0x00010000,
	0x05000068, 0x00b605ba, 0x40700025, 0x09671f47, 0x1c5a0901, 0x87010a9a, 0x0a7a010a, 0x130a0a01, 0x67005b23, 0x01272f27, 0xd0012700, 0x27af0127,
	0x900227bf, 0x275f0127, 0x01273001, 0x271f270f, 0x5b160602, 0x1f266613, 0x0b08601c, 0x1d24090b, 0x12090314, 0x333f3f00, 0x069f5833, 0x2b151a41,
	0x31325de1, 0x0e140130, 0x11232304, 0x222b0182, 0x1135042e, 0x1e141133, 0x82333302, 0x32332207, 0x210e8236, 0x0341ba05, 0x84c1200e, 0xbb2608ee,
	0xc0b7ba1a, 0x7f3dd703, 0x2e4e6a77, 0xbe0142fe, 0x77684e2d, 0xe3013d7e, 0x8d5821fe, 0x5a033462, 0xb1c6a6fc, 0xdb83e301, 0xdb824e20, 0x05a64908,
	0x002f00cd, 0x0e51407c, 0x5b220b5b, 0x300b2025, 0x0b04020b, 0x3f252f01, 0xef25df25, 0x250b0425, 0x250b0701, 0x2b13250b, 0x1623065b, 0x1d230223,
	0x31d03167, 0x0131cf01, 0x3f013180, 0x02316f31, 0x0d190d09, 0x050d0802, 0x302be682, 0x04185f00, 0x0d0a2226, 0x820c255f, 0xe13324e5, 0x54323232,
	0x332005cc, 0x2905ff41, 0x5d32f610, 0x393911e1, 0x0f842f2f, 0x18e11021, 0x2a0be753, 0x35211517, 0x35032e21, 0x18023e34, 0x20086985, 0x20138221,
	0x0812823e, 0x02022e58, 0x6aa472fa, 0x83512332, 0x01b0fd5f, 0x506f4062, 0xeca0512e, 0xa0eb9b9a, 0x6e502e51, 0xfd620141, 0x51835fb0, 0xa46a3223,
	0x81442905, 0xbb6475ba, 0x934197ab, 0xa88730a4, 0xf4966fc7, 0xac5e5eac, 0xc76f96f4, 0xa43087a8, 0xab974193, 0xba7564bb, 0xff004481, 0x431800ff,
	0x03572ec9, 0x71200834, 0x9104ecff, 0x26022106, 0x00007e01, 0x54010601, 0x13000019, 0x4a020b40, 0x16022611, 0x2f16443e, 0x240a2551, 0x03ecff5a,
	0x202b845c, 0x202b8582, 0x292b84ca, 0x26114601, 0x403a6d01, 0x2b8a2d18, 0x14feae22, 0x21059164, 0x2b858401, 0x2b854420, 0x2b822520, 0x91646220,
	0xffa4240e, 0x847702ec, 0x05e94857, 0xcefe5422, 0x20053f5e, 0x262c8222, 0xb4fdffb8, 0x51152216, 0x2f820b53, 0x063d0423, 0x20b382b4, 0x305b8492,
	0x00001055, 0x0203b212, 0xeeffb801, 0x05422cb4, 0x2487831b, 0x02003535, 0x08dd8400, 0x005e0429, 0x003d0010, 0x381e4038, 0x2f47051e, 0x3f103f28,
	0x16480e01, 0x0f223e56, 0x1b500b1e, 0x2c2f380f, 0x11335000, 0x423f0016, 0x33200614, 0x24066971, 0x32e132d4, 0x1f671832, 0x17162a1a, 0x37363633,
	0x15030e33, 0x0a0c4f11, 0x27022e25, 0x18030e23, 0x08122a67, 0xa2713d2f, 0x31907064, 0x19210a0c, 0x0d130b8f, 0x0e223208, 0x410f0825, 0x323f2622,
	0x160c0c24, 0x83604d3b, 0x6898622f, 0x6b9d650f, 0xd1ccda37, 0x366718cd, 0x55533a08, 0x211f5223, 0x377e7968, 0x333c5dfe, 0x09850307, 0x40271011,
	0x2e3d2230, 0x065d761a, 0x1f067524, 0xe3821b00, 0x40594308, 0x05483934, 0x331f0508, 0x3302332f, 0x15053305, 0x570c472c, 0x303f203f, 0x1522023f,
	0x3e541647, 0x32081b15, 0x01330f50, 0x00333308, 0x11502722, 0x00501c16, 0xe13f0001, 0x1132e13f, 0x5d5e2f39, 0xfc8439e1, 0x34062b6d, 0x5d2f2f39,
	0xe1103912, 0x32013031, 0x1415021e, 0x16150706, 0x05827616, 0x1127262d, 0x3e341123, 0x0e221702, 0x51111502, 0x3525054f, 0x23022e34, 0x29911823,
	0x02660808, 0x76a36077, 0xb08f9843, 0xad783fb9, 0x3ca4606d, 0xa87945b6, 0x4b643863, 0x524e202c, 0x6f502452, 0x60351f46, 0x4d664f84, 0x254e7752,
	0x065f4426, 0x9462311f, 0x17ad9562, 0xbaca1506, 0x376da26c, 0xe9fd1f20, 0xb27b3406, 0x1f963773, 0xfc607f4c, 0x151e1292, 0x6f4d280b, 0x4d755047,
	0x49289825, 0x5e3f3d66, 0x62181f3e, 0x34080a7f, 0x4063001b, 0x12401d16, 0x1d504815, 0x2f1d0f01, 0x031d4f1d, 0x01051a07, 0xb8064805, 0x1540f0ff,
	0x000b0606, 0x1a0c1313, 0x1b201b00, 0x08031b40, 0x0d1b101b, 0x3a19830c, 0x0c1a0c0a, 0x0b00130f, 0x001b0515, 0x33333f3f, 0x2f01333f, 0x382f3338,
	0x4a335d5e, 0x33300574, 0xe1382f18, 0x5d5d5e5d, 0x2530312b, 0x2315030e, 0x3720fa82, 0x0ba96518, 0x60023708, 0x0c182216, 0x251b0fbe, 0xbd60fe15,
	0x1a1e0ed9, 0x05060414, 0x0b1b1914, 0x3e12bcc7, 0x347e8688, 0x8d89792a, 0xfd3e043f, 0x5a5d28ba, 0x521a1b50, 0x02215a5d, 0x0b7d004c, 0x1f440808,
	0x44003200, 0x2e405100, 0x3800461a, 0x332e0505, 0x57240f48, 0xd0464046, 0x0346e046, 0x0601460f, 0x562e483d, 0x42240045, 0x38380a1a, 0x2950420a,
	0x10501516, 0x3f00010a, 0xe13fe133, 0x122f3911, 0x33391239, 0x2206ce46, 0x8332f610, 0x39392512, 0x013031e1, 0x2209b644, 0x182e0717, 0x2108aa83,
	0x8f181e17, 0x01240c17, 0x27022e34, 0x084b4c18, 0x1402c208, 0x25435d38, 0x4a7d5c33, 0x51607144, 0x49204a23, 0x2a335b51, 0x1b12273c, 0x5547623c,
	0x45315c86, 0x676db27f, 0x43477fae, 0xb4019972, 0x3552391e, 0x44687e3a, 0x43694926, 0xaa03998e, 0x62564b20, 0x46694839, 0x271f1422, 0x26149113,
	0x2517121e, 0x3e251b32, 0x3129413d, 0x58937e6c, 0x4383c17f, 0x6eaa753d, 0x537aa36a, 0x6f4551fe, 0x101f4959, 0x6791623a, 0x2d516f42, 0x000100b4,
	0x03ecff5a, 0x005e045c, 0x40590039, 0x01231d37, 0x2d101801, 0x3ba03b57, 0x3bc03bb0, 0x5f3b3f03, 0x3b10023b, 0x23463401, 0x18470523, 0x021e3a56,
	0x0139bf50, 0x39893979, 0x0a393902, 0x10285031, 0x1613500a, 0x062e5a00, 0xe15d5d2d, 0xf6100139, 0xe12f33e1, 0x655d5d5d, 0x122c0527, 0x01303139,
	0x06222315, 0x021e1415, 0x09018a18, 0x35022e27, 0x37023e34, 0x0b2f4135, 0xa9582620, 0x08268205, 0x819c025f, 0x4629858a, 0x5c333760, 0x3b1f4751,
	0xa6716d9e, 0x3f26356c, 0x462b2c52, 0x693a1c33, 0x5a355690, 0x3f284d52, 0x6c47814b, 0x64482773, 0x9987023d, 0x45335e5b, 0x180f122a, 0x22a0101f,
	0x75563129, 0x3e583e43, 0x0e0b0f29, 0x32503e2b, 0x264a6d46, 0x141c1309, 0x4d262293, 0x27402d4d, 0x08f78212, 0x6ffe712b, 0x14066a03, 0x39003300,
	0x032e1f40, 0x1a461f03, 0x14011420, 0xc0351035, 0x480a0235, 0x29000029, 0x2e193456, 0x01500003, 0x23df8200, 0x012f3232, 0x2f27d082, 0x105de110,
	0x82325dd6, 0x7c3320e2, 0x0e2105b4, 0x23441805, 0x2307210a, 0x2005a346, 0x08d68327, 0x36361266, 0x06070637, 0x02ae2306, 0x7eb880b6, 0x2d0d284c,
	0x474b7854, 0x15193a5f, 0xaa162b22, 0x14222b18, 0x4d5b300e, 0x2e5c8759, 0x6cc99a5c, 0x60282f2b, 0x997b052f, 0xb3cd768d, 0x306f859a, 0x23406c59,
	0x3b2e0f11, 0x582d2a48, 0x201f4b52, 0x1d434848, 0x1f222514, 0x6c42110f, 0x01946698, 0x6cd9e801, 0x04020303, 0x08935318, 0x18005e28, 0x1d403100,
	0x6e184700, 0x0e2c0f69, 0x10145004, 0x150b0f0c, 0x3f001b00, 0x220daf68, 0x18013031, 0x290b9671, 0x033e3317, 0x15163233, 0x71180311, 0x93680795,
	0x14fe2309, 0x8668af04, 0x47fb2210, 0x05896600, 0x17042108, 0x13002b06, 0x27001e00, 0x3a405b00, 0x00471925, 0x290f2957, 0x0129d001, 0x299f297f,
	0x01294002, 0x21080d82, 0x471a2406, 0x1a28560a, 0x0124cb50, 0x890124ba, 0x02249924, 0x0801240f, 0x1f142424, 0x14010f50, 0x4a420550, 0x5d5e2108,
	0xe1210082, 0x05a36e01, 0x71200a82, 0x073b5418, 0x67060221, 0x98080c6e, 0x01121616, 0x37023e32, 0x13031e21, 0x07020e22, 0x04020221, 0xb3703417,
	0x74af767e, 0xb16f3338, 0x75b0767e, 0x492bfe3a, 0x03234568, 0x2102cbfd, 0x474a6844, 0x05234466, 0x84093302, 0xfebc0c03, 0x6d6dced7, 0xbc2901ce,
	0xce2901bc, 0xfecd6b6c, 0x4ab9fcd7, 0x9395df94, 0x054b95df, 0xcd894510, 0x01110189, 0x01000013, 0xecffa400, 0x48047702, 0x35001500, 0x09302340,
	0x17090901, 0x17101700, 0x17601720, 0x17901770, 0x17d017c0, 0x47010808, 0x04165414, 0x00160f50, 0x07c44f0f, 0x115d5e24, 0x345d2f33, 0x42162005,
	0x165705fe, 0x11353905, 0x483f5a01, 0x242a2d12, 0x30290d09, 0x6a3e1834, 0x48042c4d, 0x6261fcfc, 0x0ca86b18, 0xff040330, 0x00ae00ff, 0x04f00300,
	0x0006024a, 0x8b8200fa, 0xfff2ff36, 0x061704ec, 0x002e0021, 0x222a4068, 0x121a1515, 0x0a290112, 0x30080182, 0x011a5000, 0x1a441a34, 0x101a0002,
	0x031a201a, 0x60301a1a, 0x02309030, 0x0601300f, 0xffb8002e, 0x000f40f0, 0x0129152e, 0x50170e01, 0x5007161e, 0x058d460e, 0x2f391124, 0x6a183f33,
	0x2608092e, 0x125d5d5d, 0x2f3d3939, 0x33112f18, 0x39121133, 0x30313311, 0x2e270123, 0x06222303, 0x36363507, 0x021e3233, 0x82160117, 0x069256ce,
	0x022e6308, 0x032e0327, 0x06062327, 0x010e0307, 0x1f0d35b8, 0x222b3d2b, 0x421a1432, 0x4f694a23, 0x48011f3f, 0x0e262e12, 0x37170826, 0x2f3b2725,
	0x0b870f25, 0x05161b1d, 0x1f350d06, 0xa03304e5, 0x1b314329, 0x07910507, 0x87592a0a, 0x3636fc5d, 0x85030739, 0x28110e0c, 0xa2012e40, 0x57615e21,
	0x4faa4d19, 0xf782c1fd, 0x0a7b5618, 0x26403f25, 0x18090c0d, 0x2b0f7c56, 0x1b471a00, 0x1b1a1e54, 0x50030d14, 0x0c7f5618, 0x65483320, 0x32322b05,
	0xe1f6105d, 0x30313232, 0x56181401, 0x3a084f83, 0x03000000, 0x004a04cf, 0x403b0014, 0x07131416, 0x470d0007, 0x1016570e, 0x16b00116, 0x01160f01,
	0xb8000106, 0x00b6f0ff, 0x0d151407, 0x3f000f00, 0x01333f32, 0x5e32382f, 0x82715d5d, 0x05f74693, 0x30313c08, 0x1e133311, 0x3e331703, 0x33351202,
	0x06020214, 0xc9bc2307, 0x191e1f0c, 0x725a0605, 0x25b61942, 0xc0759a5c, 0xb0fd4a04, 0x5c676321, 0xe7cd6019, 0xa3970501, 0xf5fee0fe, 0x44007ffd,
	0x46320ad3, 0x4e407e00, 0x113b3b32, 0x4641012a, 0x242d2d38, 0xc765001c, 0x084b0805, 0x461c0101, 0x11011120, 0x5f483f48, 0xef487f48, 0x48100448,
	0x24480701, 0x323c4756, 0x2a395038, 0x591c4900, 0x031c691c, 0x07011c38, 0x16031c24, 0x00004f01, 0x16003916, 0x3f3f00fa, 0xe12f3912, 0x5d391711,
	0x1039115d, 0x513232e1, 0x10280564, 0xc0f15dd6, 0x115d5e2f, 0x33271d82, 0x113912e1, 0x45332f33, 0xa84d05f0, 0x06f94605, 0x5e081845, 0x372105ab,
	0x29078635, 0x06060706, 0x21352323, 0xd84d2315, 0x23032607, 0x577f51a2, 0x142a452d, 0xb8b22708, 0x37664e2f, 0x4f2d7265, 0x27223e6b, 0x3e2e5521,
	0x49378102, 0x20477391, 0x03517246, 0x55318977, 0x604e4171, 0x3645223b, 0x22330814, 0x7f4db5c7, 0x0c114363, 0x4875861c, 0x13314966, 0x04020303,
	0x4e268d99, 0x51354e75, 0xff001c37, 0xff7100ff, 0x042d04ec, 0x0006025e, 0x00000052, 0x82190001, 0xc925080f, 0x18004a04, 0x38405800, 0x168f470a,
	0x0e161601, 0x00141403, 0x02031003, 0x2f1a0303, 0xef1a9f1a, 0x0d10031a, 0x08b65147, 0x48151036, 0x1519540e, 0x1250100c, 0x00150e0f, 0x00160750,
	0x3f3fe13f, 0x33052f41, 0x33e15d2b, 0x2f33115d, 0x112f335d, 0x5d2f3912, 0x253031e1, 0x0809d659, 0x1121113c, 0x35231123, 0x23152137, 0x04161411,
	0x0f2f1c50, 0x71304a0f, 0xb66dfe71, 0x270489dd, 0x0d812fd3, 0x11099008, 0xbe028284, 0xb00350fc, 0xfd9a504a, 0x0037464e, 0xa4000200, 0xb78314fe,
	0x001a002f, 0x40390027, 0x00482521, 0x29cf2957, 0x06744501, 0x0f091f30, 0x28541047, 0x1016501b, 0x50221b0f, 0x92820508, 0x93833320, 0xf6100122,
	0x5e209782, 0x21052853, 0xbb5e3031, 0x27262105, 0x4d08636f, 0x0125067f, 0x11070622, 0x06d36b16, 0x2d044508, 0x68a7753f, 0x06368f4b, 0x01020201,
	0xa97841b6, 0x77a36169, 0x893bfe43, 0x8f360382, 0x7d7b8c4b, 0xd5892702, 0x2d2d4c91, 0x61272e2b, 0x04ddfe2e, 0x91d38813, 0xd3914b4b, 0xc8c41801,
	0x3133acfe, 0xcfd1d1d3, 0x0806ab42, 0x5e046f47, 0x51003100, 0x27273640, 0x00104615, 0x200a100a, 0x330a030a, 0x335f333f, 0x33ef337f, 0x01331004,
	0x561f4800, 0x512d2832, 0x28010a37, 0x48153815, 0x0a150315, 0x0f04001f, 0xfa0f1024, 0x123f3f00, 0x5d5d3917, 0x098b42e1, 0x33e13223, 0x18c9832f,
	0x47090864, 0x3e240b91, 0x16323302, 0x25079749, 0x491c2d01, 0x8e47617e, 0x844d3b10, 0x83493762, 0x954e6ab3, 0x38173632, 0x501a3a3c, 0x02224972,
	0x4e796006, 0x8d47162f, 0x410f3213, 0x9a82b476, 0x224995e2, 0x130a9a19, 0x7039090f, 0x060b4da4, 0x04852808, 0x0016004a, 0x40360029, 0x48212421,
	0x57001012, 0x902b102b, 0xb02ba02b, 0x052be02b, 0x560a4817, 0x5025122a, 0x461c0f0f, 0xc68507f6, 0x32f61023, 0x33471832, 0x15212510, 0x05031e21,
	0x08064149, 0x26343559, 0x0e222327, 0x3e2d0402, 0x6b75b47a, 0x4d447daf, 0x0180ce90, 0x25f6fee9, 0xfd1c3041, 0x6e472100, 0x476d4c4d, 0x3b4b4f21,
	0x2b5a8b5f, 0xc06ff801, 0x8a46508d, 0xda9c85cb, 0x299a3e8a, 0x367c6c5d, 0x3b699055, 0x4e866237, 0x2c59d790, 0x0000a163, 0xff120001, 0x826603e5,
	0x1c2508b1, 0x24403a00, 0x1f0d0f01, 0x0d06020d, 0x1e101e57, 0x3b1a2b01, 0x031a021a, 0xe0181047, 0x02180218, 0x0f1c5019, 0x07f44908, 0x2f01322c,
	0x5dc6e15d, 0x5ee6105d, 0xa656325d, 0x08e64905, 0x0807e746, 0x37352135, 0x8cfe6603, 0x243e2d19, 0x24282a12, 0x2e270d0d, 0x75401b35, 0xd7fe3459,
	0x9a4a0486, 0x523ba2fd, 0x06031733, 0x06870407, 0x1d060b0c, 0x0268864d, 0x83504a73, 0xffa42493, 0x823d04ec, 0x1d260893, 0x18402900, 0x571b4710,
	0x601f101f, 0x031f801f, 0x54054708, 0x0f06151e, 0x1600500d, 0x3fe13f00, 0xf6100133, 0x03825de1, 0x05303125, 0x51022e22, 0x59080723, 0x34353632,
	0x3327022e, 0x1015031e, 0x815c0202, 0xb62964aa, 0x46664220, 0x10098d92, 0x0fb60f17, 0xf4081018, 0xbd8c5014, 0xfd58026d, 0x638c56b2, 0x47f7e836,
	0x3d74757d, 0x8177723d, 0xfec1fe4b, 0x000200d3, 0x0514fe71, 0x005e0425, 0x00350025, 0x313c405e, 0x96164725, 0x1882a600, 0x26060037, 0x37571f48,
	0x0f013720, 0x37e00137, 0x7f376f01, 0x03379f37, 0x3b0f8340, 0x0602371f, 0x56064711, 0x0b502b36, 0x1631101a, 0x16012450, 0x3f001b00, 0x32e1333f,
	0x07530382, 0x08055308, 0x31231782, 0x4b110130, 0x3721050d, 0x051b4c17, 0x34111723, 0x08005136, 0x18011121, 0x0808694e, 0x02033ea2, 0x86b76d66,
	0x4e38204b, 0x3f258d2d, 0x5833192d, 0x91a54074, 0x3766925a, 0x68be9056, 0x361e4f01, 0x311b2b49, 0x7b481625, 0x14fe3359, 0x4305da01, 0x5397d589,
	0x377d8a98, 0x72683360, 0x996f477d, 0x02073061, 0x50c1bc5e, 0x957ac990, 0x054a90d9, 0x250426fe, 0x33659462, 0x41573517, 0x3b07a0fd, 0x00009f6b,
	0xfeecff01, 0x04250414, 0x0028004e, 0x681a40a0, 0x021f781f, 0x7709671f, 0x0309c709, 0x1c760609, 0x011c3701, 0x071e1c1c, 0xc0ffb808, 0x16130e40,
	0x01083448, 0x08081008, 0x120112c0, 0x3d081283, 0x480b0619, 0x0f2a1212, 0x4f2a3f2a, 0x042acf2a, 0xc025b006, 0x25250225, 0xffb81e1d, 0x1e1f40f0,
	0x1b1e291e, 0x06270617, 0x281c1802, 0x091c021c, 0x0004061f, 0x1b16500f, 0x50230f07, 0x36450f00, 0x17123505, 0x3f5d5d39, 0x2f330111, 0x2f333338,
	0x115d5e5d, 0x5d2b2f33, 0x5d3b0d82, 0x3912332b, 0x5d5d2f3d, 0x335d3333, 0x1330315d, 0x17021e32, 0x01330113, 0x5f031e13, 0xa508082a, 0x0327022e,
	0x03012301, 0x22232626, 0x36363507, 0x3a492dbc, 0x017b1531, 0x73feb21f, 0x261d0eb2, 0x2e1a2534, 0x28391610, 0x33475f43, 0xb6fe8317, 0xa0c601c2,
	0x2435471b, 0x043e161c, 0x5c3e1f4e, 0x02a8fe3d, 0xfef8fc4a, 0x33422620, 0x8d03051d, 0x46260b06, 0x6a014166, 0x3e0383fd, 0x594fbe01, 0x0a078f0a,
	0x00010000, 0x0514fea4, 0x00120671, 0x404c0027, 0x4717012f, 0x1e181826, 0x57114706, 0x40293029, 0xb0299029, 0x0529c029, 0x291f290f, 0x47210602,
	0x0b28541e, 0x26010f1f, 0x16191650, 0x00001b17, 0x15423f00, 0x084d4e06, 0x3911e123, 0x060f422f, 0x20064d4c, 0x053e4e33, 0x23110725, 0x42032e11,
	0x4a0806dc, 0x56031117, 0x345f834e, 0x10180f08, 0x101810b6, 0xc4935708, 0xbc6fb26d, 0x36b64c89, 0x0642785a, 0x0973fa12, 0x679c6c3c, 0x837e8047,
	0x7e834849, 0xdc9d447e, 0xfe07458c, 0x04da0126, 0x9ad68841, 0xd9fd1f02, 0x2e619a72, 0x828f0505, 0x713a08c1, 0x9605ecff, 0x3b004a04, 0x48407000,
	0x011d6738, 0x1ad5471d, 0x011ab701, 0x9a011aa9, 0x1a03011a, 0x4825051a, 0x043d5730, 0x023d143d, 0x3df43dc4, 0x9b3d7b02, 0x3d40023d, 0x07560201,
	0x48103a08, 0x1b3c5605, 0x0f0a2a1b, 0x39501520, 0x00160035, 0xe132323f, 0x39333f32, 0x20db862f, 0x06c84b5f, 0x5f21e082, 0x2200825d, 0x43395de1,
	0x342406b0, 0x3337023e, 0x2205f542, 0x433e3233, 0xa14905c0, 0x07c04305, 0x0e142708, 0x26222302, 0x06062327, 0x8c5ae901, 0x1f0f3260, 0x20ba202f,
	0x1d0f1f2f, 0x2e2d4b36, 0xb2162c44, 0x4b2d5163, 0x17831d36, 0x1783bb20, 0x60324708, 0x8b6b5a8d, 0x8b1f0a1f, 0xcb925214, 0x878f5179, 0x86494887,
	0x62528e87, 0x29346596, 0x01396248, 0x81cefe32, 0x9665348b, 0x878e5262, 0x87484986, 0x79518f87, 0x575292cb, 0x00575b5b, 0x1500ffff, 0x7702ecff,
	0x135cd905, 0x6a003b07, 0x0000e2fe, 0x0d401700, 0x111f0102, 0x32010226, 0x00142a16, 0x352b0125, 0x03830035, 0xa4243182, 0x3d04ecff, 0x92263184,
	0x06010000, 0x2f826a00, 0x02b61924, 0x2e832701, 0xdeffb825, 0x53321eb4, 0x3187062f, 0x280fd574, 0x00000e54, 0x020b4013, 0x2131822c, 0x4c18203d,
	0x5d840d1f, 0x82210621, 0x225d848f, 0x84105401, 0x2a01272b, 0x1d012611, 0x5985241e, 0xc9485882, 0x96052106, 0x96202b84, 0x07248982, 0xc3005401,
	0x21248b82, 0x48010940, 0x60302d82, 0xb83c013c, 0x0940c0ff, 0x3d480b09, 0x3005423c, 0x2b21c582, 0x6d46185d, 0x00c72507, 0x07be0300, 0x28915918,
	0x01006908, 0xecff1400, 0xb6050605, 0x85002500, 0x04045a40, 0x0f5a0c13, 0x21df0121, 0x210221ff, 0x270f2755, 0x277f276f, 0xf41a0603, 0x18a00118,
	0x740218b0, 0x18180118, 0x00135a12, 0x40153015, 0xc0155015, 0x15150515, 0x670113b0, 0x02137713, 0x3f01135e, 0x02134f13, 0x13011300, 0x1a1a5f11,
	0x5f151907, 0x12130316, 0x13005f07, 0x27051244, 0x2f391232, 0x5d2f01e1, 0x33250083, 0xe1105d2f, 0x270b8332, 0x105d5e32, 0xe1715df6, 0x31271c82,
	0x26220530, 0x42163527, 0x3526053f, 0x21232634, 0x8b702311, 0x32470807, 0x1515021e, 0x03020e14, 0x19462f9e, 0x2027441d, 0x69213340, 0xbbbbfe7b,
	0xb103acfe, 0x5a015efe, 0x3565925d, 0x14845f35, 0x09a00b0d, 0x5733130c, 0x74738545, 0x120523fd, 0x6ffea4a4, 0x598b5e31, 0x659a6989, 0x5dffff31,
	0x072505df, 0x01260273, 0x05c56661, 0x66330021, 0x012905c5, 0x01260512, 0x040c063e, 0x57551800, 0x014a0808, 0xecff7d00, 0xcb059804, 0x5f002600,
	0x40111340, 0x07481813, 0x1b110711, 0x700123ca, 0x02238023, 0xc0ffb823, 0x0a072440, 0x28232348, 0x050128bf, 0x661b5b08, 0x0f5f0827, 0x0205af05,
	0x0d050508, 0x205f0024, 0x105f0d04, 0x64181316, 0x01240c69, 0x32e1f610, 0x20051245, 0x05215a5d, 0x01303129, 0x07020e22, 0x45211521, 0x0e230606,
	0x5c222303, 0x17330af1, 0x03262607, 0x78a05f19, 0x74020d4d, 0x400586fd, 0x1871ab76, 0x29176a98, 0x6faf7a41, 0x8ac982a2, 0x98182348, 0x5973146b,
	0xcb052707, 0x36000602, 0xe95c0000, 0x30535712, 0xfe48ff27, 0x0573017b, 0x245182b6, 0x0000002d, 0x08558202, 0xdf06e96a, 0x2a00b605, 0x8d003500,
	0x5a2b25b5, 0xb8080d06, 0x5340f8ff, 0x08481714, 0x1e99235a, 0x1e101e01, 0x90060023, 0xe0060206, 0x23b40123, 0x23d423c4, 0x50230003, 0xa0239023,
	0x06070423, 0x15230623, 0x67005b2f, 0x0137cf37, 0x09064037, 0x36151548, 0x250f5f35, 0x080225af, 0x082b2525, 0x1903235f, 0x2b131260, 0x00120660,
	0x250aea77, 0x330111e1, 0xd1792b2f, 0x58392005, 0x5e2a05a4, 0x3833115d, 0x2be1105d, 0x9e491032, 0x11212708, 0x07030e21, 0x0c6d030e, 0x36372c0a,
	0x37121236, 0x32331121, 0x1801021e, 0x0807da65, 0xdf06237d, 0x86c27e3c, 0xc2febffe, 0x22211f0f, 0x4f351410, 0x4a234e6e, 0x203a171c, 0x1a2a3e30,
	0x27200c0c, 0x9302162b, 0x7ecf986d, 0x7777fd37, 0x5b2ea4ae, 0x01585d8b, 0x709e61ac, 0x7112053d, 0x51d4ecf4, 0x3b6fa267, 0x0d9a0b0e, 0x75623f10,
	0x01c83936, 0xaa3a0106, 0x714298fd, 0x849dfe98, 0x3c614688, 0x0002001b, 0x070000c7, 0x00b6050c, 0x00210016, 0x11324053, 0x060e5a17, 0x821b0a06,
	0x233108fe, 0x0f01230f, 0x7f231f23, 0x0423ff23, 0x0a5a090d, 0x08212264, 0x0d0f115f, 0x08020daf, 0x0b0f0d0d, 0x0a601703, 0x3f001206, 0x333fe133,
	0x5d5e2f39, 0x05544b33, 0x5b5d3221, 0x904606a7, 0x0e142305, 0xf3822302, 0x11231125, 0x82211133, 0x21e48d03, 0xe4850c07, 0xbab8fd26, 0xba4802ba,
	0x0229cd94, 0x0556fdaa, 0x0298fdb6, 0x74bc8d68, 0x052105ad, 0x08bd8206, 0x73001550, 0x5a084d40, 0x0f175507, 0x7f176f17, 0xf4060317, 0x14a00114,
	0x740214b0, 0x14140114, 0x0f5a0e00, 0x11301100, 0x11501140, 0x110511c0, 0x010fb011, 0x0f770f67, 0x010f5e02, 0x0f4f0f3f, 0x010f0002, 0x5f11150f,
	0x005f0d12, 0x03120700, 0xd683070f, 0x39123f25, 0x8210e12f, 0x442f20d4, 0x32200a38, 0x5e200c83, 0x2505374a, 0x1e322101, 0xd9821502, 0x210b2f44,
	0x10442302, 0x44ba2005, 0x03290a22, 0x8b5e3181, 0x01f2fd59, 0x071844f6, 0x27050d44, 0x7307a204, 0xb4012602, 0x20060d44, 0x060d4489, 0x26051726,
	0x110b2201, 0x82090d44, 0xff19262d, 0x07ae04ec, 0x202d8269, 0x232d83bd, 0x23003602, 0x27202d86, 0x0d232d82, 0x4413222c, 0x27080b3b, 0x047ffec7,
	0x00b605c1, 0x4063000b, 0xd602c641, 0x5a020202, 0x03d503c5, 0x0103a802, 0x03010396, 0x48110e10, 0x3a010347, 0x28080a82, 0x5a090503, 0xb00d6500,
	0x0d6f010d, 0x0daf0d9f, 0x010d1003, 0x64055a08, 0x03060a0c, 0x02055f08, 0x00050102, 0x2f33332f, 0x07324b10, 0xe2425d20, 0x5d2f3005, 0x5d5d2b5d,
	0x315de15d, 0x11212130, 0x41211123, 0x043405df, 0xb15afec1, 0x02ba5dfe, 0x7ffebb85, 0xb6058101, 0x1005f0fa, 0x420ffb62, 0x04210577, 0x08a18233,
	0x1b001031, 0x2e404b00, 0x0801085f, 0x5b151108, 0x0f1d6700, 0x7f1d5f1d, 0x041dcf1d, 0x5a110b06, 0x1b1c6406, 0xaf0b0f5f, 0x0b08020b, 0x5f0a110b,
	0x43110307, 0x12220776, 0xb7612f39, 0x5e322106, 0x0f829283, 0x01208b82, 0x20066f42, 0x0f4e4315, 0x3c330433, 0xfe86c27e, 0xfd140396, 0xcf9896a6,
	0x4efd377e, 0x053443a0, 0x34438120, 0xa4b62306, 0x1c433cfe, 0x06a3410b, 0x1808a163, 0x2c0a9541, 0x00610106, 0x00020000, 0x057ffe0e, 0x20c5820a,
	0x08c58211, 0x0b408b73, 0x1b281b18, 0x37071b02, 0xb8140114, 0x0b40f8ff, 0x14481714, 0x070f0e5a, 0xb8070701, 0x1040f0ff, 0x0ec00e30, 0x070e0702,
	0x5a12050e, 0x005a0110, 0x40c0ffb8, 0x48151025, 0x65100000, 0x011d201d, 0x08011d0f, 0x05055a04, 0x0e5f141c, 0x08510903, 0x5f06101b, 0x05050003,
	0x3f001203, 0x10332f33, 0x2f3232e1, 0x11e13fe2, 0xe12f3301, 0x105d5d5e, 0x1eab18e4, 0x5d56080a, 0x105d5e38, 0x115d2be1, 0x30315d33, 0x21112301,
	0x33112311, 0x2137053e, 0x11213311, 0x07050e21, 0xfcb00a05, 0x2f71b064, 0x30414d56, 0x6502041d, 0xfe83fec2, 0x2e1f04fa, 0x274d463d, 0x81017ffe,
	0x27027ffe, 0xe6d9c855, 0xfa69e3e8, 0x4c6a04f0, 0xc8d1cab9, 0x9b634bb7, 0x01002710, 0x00000400, 0xf5848106, 0x40cb4f08, 0x7609664e, 0x03098609,
	0x09470937, 0x09030957, 0x0d470606, 0x0d020df7, 0x7900695a, 0x03008900, 0x00480038, 0x00030058, 0x0ea80303, 0x99020eb8, 0x0e86010e, 0x670e5701,
	0x030e770e, 0x0a110e0e, 0x0b080807, 0x70010a00, 0xc00a800a, 0xf660030a, 0x073d0805, 0x100a480a, 0xf0130a0a, 0x13bf0113, 0x13df13cf, 0x0113a003,
	0x4001138f, 0x130f0113, 0x0802131f, 0x10010102, 0xf0ffb811, 0x11110f40, 0x03030612, 0x0e0a1104, 0x04010712, 0x333f0003, 0x23028233, 0x33113912,
	0x2006004c, 0x063d5e11, 0x33115d29, 0x5d2b382f, 0x82333371, 0x3912231a, 0x00825d2f, 0x5d2e0a82, 0x325de15d, 0x5d5d3311, 0x01013031, 0x36840133,
	0x01012408, 0x23110123, 0x02230111, 0xcdedfd25, 0x02b30a02, 0xedfdcd0a, 0xfdd32102, 0xeefdb3ee, 0x02f202d3, 0x873cfdc4, 0x0efd2503, 0x1bfde502,
	0x4e080383, 0x00010000, 0x03ecff48, 0x00cb05ec, 0x40680039, 0x005b273f, 0x30002105, 0x21000021, 0x1c130330, 0x3b670b5b, 0x70013b9f, 0x02138013,
	0x134f133f, 0x1303135f, 0x20053a13, 0x0121aa60, 0x0f012178, 0x21080121, 0x2c2f1921, 0x19043560, 0x47101460, 0xa6820cb6, 0xd0833920, 0x1020b482,
	0x07765c18, 0xf85b1120, 0x0e142306, 0xa0180702, 0x222b07ee, 0x1e352726, 0x36323303, 0x5b263435, 0x23210ae8, 0x276c1822, 0x03920808, 0x7d5b33d1,
	0x5e8a574b, 0xcd884332, 0x55c06e89, 0x6363602b, 0xcfb0b22e, 0x5cb0bfba, 0x2532618e, 0x6e3a5f44, 0x265c4ba9, 0x47837462, 0x3971a66d, 0x78496004,
	0x060c3958, 0x7759390b, 0x74a06048, 0xaa2d2240, 0x0d182417, 0x81878794, 0x65482797, 0x3a53363d, 0x7d36431e, 0x1829361f, 0x00856136, 0xc9000100,
	0x10050000, 0x1700b605, 0x1b406b00, 0x5a0e0b14, 0xd019650d, 0x19af0119, 0x30192001, 0x09160219, 0x64175a02, 0xb8091718, 0x14b3e8ff, 0x07824818,
	0x2340e031, 0x0648130a, 0x26091609, 0x0d090309, 0x82181412, 0x20142117, 0x09351382, 0x29141914, 0x14070314, 0x0003000b, 0x5e32323f, 0x3f2b2b5d,
	0x20048233, 0xfd9a1833, 0xf6103108, 0x313232e1, 0x11331330, 0x07020e14, 0x01330706, 0x09138518, 0x23013108, 0x0201aec9, 0x04040202, 0xd5cc0207,
	0x040406ac, 0x31fd0805, 0xfcb605d7, 0x433e1ae0, 0x4c4a2043, 0x4afab404, 0x8e391903, 0xfb4d4c41, 0xffff0046, 0x0725bd85, 0x01260269, 0x066945b2,
	0x52018932, 0x01b41500, 0x0126051d, 0xb4ebffb8, 0x0c001822, 0x240aa749, 0x040000c7, 0x30ed82a2, 0x405e000a, 0x09090821, 0x00010910, 0x02001000,
	0x08048207, 0xb00c0028, 0x0c2f010c, 0x010c1001, 0x56010a97, 0xb80a010a, 0x1440f8ff, 0x0a480c08, 0x5a030707, 0x070b6404, 0x05080402, 0x45640403,
	0x12332305, 0xd6843939, 0x2b331123, 0x3100835d, 0x382f3311, 0x33335d5e, 0x31331138, 0x01232130, 0xa1422311, 0xa2043705, 0xbabafddb, 0xcf3502ba,
	0xe502cbfd, 0xb6051bfd, 0xc4023cfd, 0xb08242fd, 0xff000025, 0x829304e9, 0x001f258f, 0x0308b162, 0x39086f83, 0x4817143b, 0x19895a03, 0x19101901,
	0xb4011ee0, 0xd41ec41e, 0x1e00031e, 0x1e801e50, 0x1e1e0703, 0x005a0110, 0x210f2165, 0x217f211f, 0x10100803, 0x1e5f0320, 0x11601403, 0x9683130d,
	0x2305bf5c, 0x5e2f3301, 0x2006f845, 0x2599825e, 0xe15d3833, 0xea64322b, 0x16ce4805, 0xba930424, 0xba4885fe, 0x48d0201a, 0x75441aa5, 0x0f4b6606,
	0x01680420, 0x0fb16508, 0xc72b0f82, 0xc1040000, 0x0602b605, 0x86006e01, 0x096b653f, 0x04272f85, 0x02cb0598, 0x84260006, 0x0ceb641f, 0x0806b955,
	0xb605ae5f, 0x6f002100, 0x01121040, 0x21131b1b, 0x00700060, 0x00f000b0, 0xffb80004, 0x061040c0, 0x1000480a, 0x0f230000, 0x02237f23, 0xb8130914,
	0x0c40f0ff, 0xe7221313, 0x021af71a, 0x1a011ad6, 0x40e0ffb8, 0x480e0a10, 0x031a0112, 0x0a5f0d00, 0x00131306, 0x323f0003, 0x11e1333f, 0x5d2b3917,
	0x0694445d, 0x29068c44, 0x11391233, 0x30313333, 0x0e4a0101, 0x0152080d, 0x031e0133, 0x033e3317, 0xae040137, 0x532654fe, 0x336f9c70, 0x5925255a,
	0x42523534, 0xeefd1c38, 0x057f01cc, 0x0409090a, 0x0b0b0302, 0x3701030b, 0xfafbb605, 0x487ba45d, 0x14b90f0f, 0x56351719, 0xfc3f043f, 0x1a180ad7,
	0x1f090917, 0x03071d21, 0x794b0018, 0xba052105, 0x0121ff83, 0x23ff8473, 0x04000000, 0x240bad64, 0x057ffec7, 0x32ff8271, 0x403b000b, 0x025a0321,
	0x005a0902, 0x010db00d, 0x48010daf, 0x002d0a12, 0x02055f08, 0x00120502, 0x102f333f, 0x30d982e1, 0xe1f61001, 0x105d5d5d, 0x2f33e1d4, 0x253031e1,
	0x0b0b4833, 0xfcb0b02a, 0x8502ba06, 0xd9fda6bb, 0x23070b48, 0xa6000100, 0x81207982, 0x32086982, 0x40480015, 0x5a01131d, 0x70176500, 0x0217a017,
	0x1001172f, 0x5a0d0117, 0x0a700a60, 0x0ab00aa0, 0xffb80a04, 0x070e40c0, 0x130a480a, 0x05055f10, 0x42030b14, 0x39270590, 0x0133e12f, 0x845d2b2f,
	0xe1f62178, 0x23058742, 0x22230606, 0x0806c753, 0x32331629, 0x33113736, 0x73ba8104, 0x925d62c3, 0x69ba3565, 0x70b95a7b, 0x2c5602ba, 0x8a5f312e,
	0xfd470259, 0x287473d1, 0x82c60228, 0x00c7248d, 0x84330700, 0x40603af7, 0x01085642, 0x05175a08, 0x96058601, 0x0305a605, 0x05770567, 0x01050502,
	0x08a38209, 0x0d000d32, 0x20020d10, 0x700d500d, 0xc00d800d, 0xe00dd00d, 0x0d0f070d, 0x5a040701, 0x0a0c6401, 0x08030206, 0x12015f04, 0x32e13f00,
	0x0133333f, 0x5ee1f610, 0x2205a859, 0x822f3911, 0x06284908, 0x2905044b, 0x07331121, 0xba94f933, 0x02831f02, 0x24052449, 0x1005f0fa, 0x238f8300,
	0xe3077ffe, 0x47088f82, 0x4071000f, 0x010c564b, 0x09175a0c, 0x96098601, 0x0309a609, 0x09770967, 0x05090902, 0x03005a0d, 0x0002025a, 0x11001165,
	0x20021110, 0x70115011, 0xc0118011, 0xe011d011, 0x110f0711, 0x5a080701, 0x0e106405, 0x0c03060a, 0x8c0eb141, 0x32e4259c, 0xe110e12f, 0xbd41a089,
	0x8411200b, 0xb0b021a4, 0xc441a688, 0x26ab850a, 0x00140002, 0x49d50400, 0x522b06c5, 0x110b3340, 0x0106905a, 0x49080606, 0x012e06c8, 0x1d2f1d0f,
	0x1d5f1d3f, 0x06051daf, 0xca490808, 0x5f08220b, 0x0fca4909, 0x33011124, 0x3c4c5e2f, 0x4d5d2007, 0x35200b30, 0x3810cc49, 0xc27e3cd5, 0xfe95fe86,
	0x950f02ac, 0x377fcf98, 0xaea04efd, 0x8a5c2da3, 0x07cc495d, 0x4ca41221, 0x03260d2c, 0x0000c700, 0xab82cf05, 0x000e3108, 0x001d0019, 0x132b4049,
	0x0100005b, 0x1a060000, 0x1f651d5a, 0x1f9f1f0f, 0x0f090602, 0x1e64065a, 0x090f5f19, 0x080209af, 0x071b0909, 0x1a600f03, 0x5e0be44c, 0x8a68075f,
	0x31e12106, 0x4c050359, 0x012311d9, 0x4a113311, 0xba200773, 0x220e704a, 0x4abb9303, 0xa58c0773, 0x0556fd25, 0x4b4afab6, 0xab830a1d, 0x2e404825,
	0x82905b13, 0x1b6731a9, 0x1b5f1b0f, 0x401b0602, 0x1b481815, 0x48130d40, 0x1a20ae84, 0xad83ae89, 0xe121ac83, 0x091b4b3f, 0x5e2b2b25, 0x74f6105d,
	0xa8910885, 0xa194a497, 0x43088682, 0x04ecff3b, 0x00cb0544, 0x40510024, 0x5b201d2f, 0x161e160c, 0x670c041e, 0xcf26bf26, 0x0326df26, 0x1e250404,
	0x011faa5f, 0x0f011f78, 0x1f08011f, 0x5f1a071f, 0x03131117, 0x04075f00, 0x33e13f00, 0x11e1333f, 0x5d2e9e83, 0x0111e15d, 0x105d2f33, 0x393911e6,
	0x214f2f2f, 0x06222805, 0x36362707, 0x18163233, 0x2108d867, 0x9751022e, 0x12990805, 0x21352113, 0xba01032e, 0x4e3f945e, 0xa26cc44f, 0x5252a2f4,
	0x3aa4f7a5, 0x274e5661, 0xed59a04e, 0x8bfd06f7, 0x47097102, 0x27059d73, 0x2a9c202e, 0xfec16d2c, 0xfeb39df6, 0x076dcae0, 0xa20f170e, 0x17012317,
	0x6fa20601, 0x00407ab0, 0xffc70002, 0x059e07ec, 0x001a00cd, 0x405e002e, 0x0a5b1b3c, 0x11011190, 0x5b250d11, 0x0f306700, 0x303f0130, 0x307f306f,
	0x30ff30ef, 0x11403005, 0x0c104814, 0x2f640d5a, 0x04165f2a, 0x100f5f0b, 0x10100801, 0x0d030e0d, 0x055f2012, 0x21d48213, 0x8d4c3f3f, 0x423f2005,
	0x2b20051e, 0x2408c542, 0x3031e133, 0x08446e01, 0x11212729, 0x11331123, 0x84033e21, 0x099c59e1, 0x022e2b08, 0x020e2223, 0x9b4f9e07, 0xe19796e5,
	0xfe065098, 0x01babaae, 0x98550b56, 0xe59591db, 0xfafb4f9a, 0x6c9d6731, 0x30669d6d, 0x07826530, 0x31679e2e, 0xfea9dd02, 0x646cc6ea, 0xa00301b7,
	0x26051e4f, 0x5aa7ec92, 0x18fec56b, 0x08141fa3, 0x0000192b, 0xb605f203, 0x1c000f00, 0x09409b00, 0xe6010006, 0x0200f600, 0xf8ffb800, 0x0f0b2440,
	0x5a0e1c48, 0x08000003, 0x3f1e650d, 0x9ea1181e, 0x0106280b, 0xf601e601, 0x83010201, 0x820d2028, 0x01590828, 0x0201024b, 0x480b0840, 0xf0ffb802,
	0x02022640, 0x08df5b16, 0x08ff08ef, 0x0f400803, 0x08074813, 0x08020817, 0x1c1d6608, 0x0f0f0360, 0x0b601101, 0x12010e03, 0x3f333f00, 0x2f3912e1,
	0x1001e133, 0x2b5d5ef6, 0x2f33e15d, 0x335d2b38, 0x5d715d2b, 0x11f6105d, 0xe1331139, 0x300c8232, 0x01013031, 0x032e0123, 0x33363435, 0x11231121,
	0x08e15d11, 0x02338908, 0xdbb2fe42, 0x63377d01, 0xfbfd2c4b, 0xbcbb7501, 0x294f734a, 0x51774e27, 0xfd5c02b4, 0x148f02a4, 0x5d88613e, 0x4afac9c6,
	0xbb025c02, 0x44613e1d, 0x284a6942, 0x00ffff00, 0x03ecff5e, 0x025e049c, 0x00440006, 0x00020000, 0x04ecff75, 0x00230621, 0x003b0027, 0x2d2c4049,
	0x571e0948, 0x013dd03d, 0x40013d7f, 0x3d0f013d, 0x37130601, 0x3c560048, 0x19135032, 0x50280819, 0x08091623, 0x0948100b, 0x00010851, 0x3f2be13f,
	0x62056957, 0x102b0964, 0x31e132f6, 0x12341330, 0x82373636, 0x0e172302, 0x02820703, 0x5e183320, 0x01200d0c, 0x83068b6c, 0x07c008cf, 0x75021e14,
	0x71a26831, 0x2166f27d, 0x757d7b32, 0x48643e2c, 0x120d0429, 0x406b543e, 0x32659663, 0x68ae7c45, 0x427bad6b, 0x623ce101, 0x3a1a2646, 0x6a3d415a,
	0x190d3953, 0x93027241, 0xcb1901b5, 0x311b197e, 0x1608a014, 0x0e0a1818, 0x71a57142, 0x20313c1d, 0x6cb48349, 0x458ace89, 0xfefdad59, 0x8f582794,
	0x5f865469, 0x49443033, 0x93bc641a, 0x00030059, 0x040000ae, 0x004a0419, 0x00200015, 0x405c002b, 0x211b033a, 0x0f000046, 0x57094716, 0x012d202d,
	0x2d902d40, 0x2dd02db0, 0x0f052df0, 0x2606012d, 0x540f471b, 0x501a032c, 0x790126bf, 0x02268926, 0x251b2626, 0x1b0f1050, 0x00150f50, 0x600eb865,
	0x2f28098e, 0x313912e1, 0x06140130, 0x29088e4c, 0x32211121, 0x3403021e, 0x09832326, 0x09863e20, 0x82323321, 0xf6500809, 0x61386b7b, 0x652f2947,
	0x39fe719f, 0x8e53c501, 0x82903b67, 0x0100ff80, 0x435d3804, 0x6c6d1e26, 0x3eecf5fe, 0x031f3f5c, 0x12756835, 0x3d240707, 0x74433f5b, 0x4a043056,
	0xfd6b401c, 0xfe485cc7, 0x452a12a8, 0x404d0c02, 0x240fd7fe, 0x0100003c, 0x0321e383, 0x3fe3820a, 0x402f0005, 0x1000001c, 0x00000200, 0x0107a007,
	0x50010781, 0x47020107, 0x01065403, 0x020f0450, 0x09244118, 0x115d5d25, 0x825d2f33, 0x11212fb2, 0x03211123, 0xb65afe0a, 0xb0035c02, 0x458250fc,
	0x29000226, 0x370483fe, 0x5a080982, 0x0017000f, 0x17104079, 0x0c461207, 0x073f072f, 0x1b070b02, 0xb8070207, 0x3940f0ff, 0x0cb20ca2, 0x140c0402,
	0x0c07020c, 0x10050c07, 0x46010e47, 0x0e200000, 0x19550e01, 0x19cf19af, 0x01193002, 0x0401192f, 0x18050546, 0x0f0c4f12, 0x50060e17, 0x00051503,
	0x323f00fb, 0x8232e13f, 0x01112103, 0x2106f966, 0x8b475de4, 0x2f392b06, 0x385d5d2f, 0xe1105d5d, 0xc94f3311, 0x1202210a, 0x0805ca4f, 0x030e2331,
	0xae370407, 0x56ae4efd, 0x22436341, 0x97170201, 0x07c0b2fe, 0x34513a24, 0x7d0183fe, 0x170283fe, 0x01f3df5f, 0x50fc7f00, 0xd7672403, 0x6053c2d1,
	0x032905a5, 0x025e04e1, 0x00480006, 0x05c14f00, 0x82be0521, 0x112208db, 0x1f409c00, 0x0a030306, 0x00000f46, 0xb9010bd6, 0x020bc90b, 0x97010ba6,
	0x0b0b010b, 0x0504070e, 0xe8820805, 0x12b3c024, 0x07834815, 0x24402e08, 0x0f480b07, 0x07060107, 0x13070710, 0x13101300, 0x0113df02, 0x13701330,
	0x0f031390, 0x11070113, 0x0e0d1010, 0x40f0ffb8, 0x120e0e0f, 0x27698203, 0x150a080d, 0x0f010411, 0x2817984f, 0x2f331171, 0x2b5d5e38, 0x0e974f2b,
	0x8432e121, 0x0d8f4ffc, 0x3301013e, 0x01a48f02, 0x58fec5a0, 0xfecece01, 0x44fea443, 0xfecf01cf, 0x3502c558, 0xebfd1502, 0xfd250383, 0xfd2d02cb,
	0x820384d3, 0x32e98213, 0x03ecff44, 0x005e0452, 0x405f0039, 0x1646053a, 0x8239161b, 0x0c310801, 0x57214734, 0xc03bb03b, 0x033bd03b, 0x20013b6f,
	0x0c29013b, 0x381b3a56, 0x0139cf50, 0x39993989, 0x01390f02, 0x11393908, 0x1626502f, 0x10115008, 0x08697200, 0xe15d5d27, 0xe6100139, 0x068a4f32,
	0x2f393923, 0x06884f2f, 0x023e3225, 0x4f263435, 0x15200a6b, 0x85139a4f, 0x23610824, 0x3d710135, 0x73274864, 0x4b81476c, 0x524d283f, 0x9056355a,
	0x331c3a69, 0x522c2b46, 0x6c35263f, 0xaf6d71a6, 0x574c1f3a, 0x60373361, 0x8a852946, 0x12870281, 0x4d2d4027, 0x9322264d, 0x09131c14, 0x466d4a26,
	0x293b4d32, 0x2c0e0b0e, 0x433e5a42, 0x23315675, 0x1f10a622, 0x2a120f18, 0x5b5e3345, 0x05114399, 0x3b043108, 0x0b004a04, 0x1b405100, 0x18091003,
	0x46060348, 0x000d5505, 0x200d100d, 0xc00da00d, 0xf00dd00d, 0xb80d070d, 0x0eb3c0ff, 0xb8094811, 0x1140f0ff, 0x092d2582, 0x540a4600, 0x0b03080c,
	0x0a02060f, 0x06ba4115, 0xf6100127, 0x2b2b32e1, 0x0806845d, 0x01303127, 0x33010711, 0x13112311, 0x01112301, 0x04020c5a, 0xfd0bace9, 0x4a04eafe,
	0x03fc64fd, 0x02b6fb98, 0xfc0f0187, 0x667c826a, 0x043f058b, 0x0217063b, 0x00d20126, 0x02060100, 0x00002536, 0x1101b415, 0xb8012611, 0x16b4ffff,
	0x4f040a0c, 0xae240a4f, 0xe5030000, 0x0a283882, 0x23404100, 0x04010100, 0x37053a63, 0x0c030310, 0x0a010c0f, 0x07470602, 0x02050b54, 0x00070a0a,
	0x07040f08, 0x3f209f83, 0x8405494d, 0x5d3230a2, 0x382f3311, 0x1133335d, 0x01303133, 0x4f010133, 0x022b0635, 0x61fec4fa, 0xfecec601, 0x82b4b44b,
	0xfdf126a5, 0xfd2d02c5, 0x280982d3, 0x000100eb, 0x03f2ff10, 0x087382b0, 0x4c001434, 0x46033140, 0xf4011304, 0x13800113, 0x13c01390, 0x540413d0,
	0x13130113, 0x0047010b, 0x160f1655, 0x16ff162f, 0x0b0b0603, 0x13500315, 0x084f0e0f, 0x81820116, 0x53e13f21, 0x5e200595, 0x2306224f, 0x715d5d5d,
	0x20060874, 0x057d6802, 0x35273008, 0x36323316, 0x21371236, 0xfeb6b003, 0x5f4014fe, 0x311c5682, 0x371b1710, 0x12334559, 0xb0035402, 0x94fefdfe,
	0x060669e6, 0xf1750683, 0x41fa6f01, 0x052105bf, 0x08958210, 0x5e002042, 0x011f3f40, 0x22550046, 0x400122cf, 0x02225022, 0x0601220f, 0x11461013,
	0x0f022154, 0x0f4b0f3b, 0x09030f5b, 0x290f190f, 0x1f0f030f, 0x19340f12, 0x19541944, 0x16190603, 0x03192619, 0x11010919, 0x3325a382, 0x5d5d3333,
	0x2104833f, 0xbf463311, 0x4d102008, 0x0e2a073d, 0x23010703, 0x27032e01, 0x1e822311, 0x17031e35, 0x0137033e, 0xa1100533, 0x12141106, 0x87f8fe07,
	0x8305f7fe, 0xa2320809, 0x0d0b01dd, 0x040f1316, 0x16130e06, 0xd90e010d, 0x39158103, 0xfd12363b, 0x0db00250, 0x1a3e3b31, 0x4a047ffc, 0x432247fd,
	0x1110323c, 0x21413b31, 0x8942bd02, 0x5b44080c, 0x06021740, 0x0d550547, 0x0d200d00, 0x400d3002, 0xd00d500d, 0x050df00d, 0xc0ffb80d, 0x110e2340,
	0x47090148, 0x080c540a, 0x0101eb50, 0x01b901a9, 0x1f010f02, 0x03012f01, 0x0a010106, 0x00031505, 0x323f000f, 0x21056f58, 0x6d495d5d, 0x3132260b,
	0x21110130, 0x057e4e11, 0x01112338, 0xb6210264, 0xb6dffdb6, 0x39fe4a04, 0xb6fbc701, 0x17fee901, 0xb1654a04, 0xae280812, 0x12040000, 0x07004a04,
	0x1c402d00, 0x55044705, 0x20091009, 0x70096009, 0x05098009, 0x54014700, 0x02500708, 0x1500050f, 0x71847883, 0xe5755d20, 0x64012e0c, 0xb66403b6,
	0x4a0408fe, 0xb003b6fb, 0x2b618200, 0x0414feae, 0x025e043f, 0x00530006, 0x71240f83, 0x6f03ecff, 0x462a0f84, 0x01000000, 0x00002900, 0x71845e03,
	0x3c405828, 0xdf010920, 0x6c830109, 0x095f0228, 0x01000f01, 0x058200cc, 0x8200bf21, 0x02003d3d, 0x05600347, 0x05d00570, 0x01051f03, 0x03000505,
	0x03b00310, 0x030403c0, 0x06500501, 0x3006c946, 0x5d2f0132, 0x5d5d2f33, 0x2f32e110, 0x715d5d5e, 0x4603825d, 0x353b07d2, 0xfe5e0321, 0xc1feb7c1,
	0xb0033503, 0xb00350fc, 0x00ffff9a, 0x0314fe0a, 0x824a04df, 0x825c205f, 0x00032c8d, 0x0514fe71, 0x00140623, 0x82220019, 0x74300899, 0x00274b40,
	0x171d460b, 0x49130d0c, 0x0cc90cb9, 0xa70c9702, 0x0c0c020c, 0x05482312, 0x2b202b57, 0x012b0f01, 0x2bef2b9f, 0x012b8002, 0x40012b6f, 0x1f371083,
	0x1a06022b, 0x2a561248, 0x1e260018, 0x10170050, 0x0a501d27, 0x620b160d, 0x322209be, 0x104f013f, 0x759e8305, 0x2b2508c7, 0x32e13333, 0x60ad8232,
	0x83080cac, 0x37023e34, 0x14013311, 0x0e111716, 0x26340503, 0x36361127, 0xbd712103, 0x86474c88, 0x72aa77be, 0x474c89bf, 0xaa79c185, 0xae9c0cfe,
	0x25507d58, 0xaa9b3903, 0x5a0499ac, 0xc68f550c, 0x91c87d7d, 0x24fe0b56, 0x560adc01, 0x7d7ec990, 0x0b558fc7, 0x13fcba01, 0x0313d2bb, 0x673d093c,
	0xccba5e91, 0x14c6fc14, 0xffff00d1, 0x00002300, 0x4a04db03, 0x5b000602, 0x01000000, 0x83feae00, 0x4a04b204, 0x44000b00, 0x4732d682, 0x0601000f,
	0x47070000, 0x0a010a8f, 0x200d100d, 0xf94f600d, 0x06063206, 0x0c540347, 0x0a0f0408, 0x15035006, 0x3f00fb01, 0x0809513f, 0x5dd41028, 0x5e2f33e1,
	0xba47e15d, 0x05ef4f06, 0xb2043336, 0xb6b2fcb6, 0xa0b6f801, 0x7d0183fe, 0x50fc4a04, 0x50fcb003, 0x9a207382, 0xfe208382, 0x18287382, 0x1c403100,
	0x0b470c08, 0x08f29b18, 0x1747012c, 0x03081954, 0x0b121250, 0xf6420915, 0x2f392205, 0x08b664e1, 0x60823220, 0x3314112b, 0x37023e32, 0x23113311,
	0x073a6511, 0x50012b08, 0x4c502db8, 0xb6b62a4d, 0x5e55502c, 0x527a4e3a, 0xfe4a042b, 0x1c0fae66, 0xd5011c2c, 0xe901b6fb, 0x1120301e, 0x4473542f,
	0x9943a601, 0x46062105, 0x2f08f384, 0x00434066, 0xc609b647, 0x09a90209, 0x09740301, 0x09940984, 0x01096703, 0x05090906, 0x55044701, 0x010d200d,
	0x80010d0f, 0x020df00d, 0x40010d6f, 0x2f300d83, 0x0806020d, 0x0c540547, 0x05500800, 0x02060a15, 0x2105e847, 0xed4132e1, 0x07ae6408, 0x5d5d5f22,
	0xe1230282, 0x5a253031, 0x11200628, 0x032f0782, 0xb7ba01d5, 0x01b668fa, 0x039ab6bb, 0x41b6fbb0, 0x89410517, 0xe5062105, 0x0f2d9582, 0x4e407700,
	0x07b6470a, 0xa90207c6, 0x32958207, 0x94078407, 0x07670307, 0x07070601, 0x0e470b03, 0x820e4701, 0x0024082e, 0x0e010ebf, 0x01112011, 0x4001110f,
	0xe0118011, 0x0411f011, 0x112f110f, 0x47060602, 0x0c105403, 0x0e0f0408, 0x200bac41, 0x0aa15132, 0xc4107126, 0x5d2f325d, 0x88050751, 0x5a0120a6,
	0xa88308d1, 0x06331126, 0x7ffab6e5, 0xb182a883, 0xc3419f20, 0xb0032b0b, 0x020050fc, 0x00002900, 0xb182fc04, 0x000e3708, 0x405c001b, 0x04470f3e,
	0x1d501d57, 0x1d901d60, 0x3f041de0, 0x1600011d, 0x0c000a47, 0xb0020c10, 0x020cf00c, 0x0a000c0c, 0x0a500a10, 0x0aa00a60, 0x150a0805, 0xc583bf50,
	0x500c1627, 0x50160f0d, 0x09634b0a, 0x2f01e12c, 0x2f335d5e, 0xe110715d, 0x745c5d32, 0x05e17308, 0x21112128, 0x34012135, 0x5c4b022e, 0x48022506,
	0xccd41401, 0x0805504b, 0x0298fe28, 0x2102021f, 0xff406041, 0x37040100, 0x0226445d, 0x4d9b9c87, 0x032f587c, 0xf8fc9ab0, 0x11284231, 0x2911a8fe,
	0x1b4c0042, 0x053f0805, 0x004a0450, 0x0010000c, 0x4061001d, 0x00471840, 0x20041004, 0xd0047004, 0x04060504, 0x470e0a04, 0x0f1f550d, 0x1fbf011f,
	0x1fdf1fcf, 0xa0041fff, 0x1f0f011f, 0x07021f7f, 0x0a471200, 0x85111e54, 0x0b0f25be, 0x0e50120f, 0x115ebd83, 0x069e4505, 0xc1635e20, 0x05164309,
	0x87323321, 0x01332bc0, 0x01331123, 0x3e323311, 0xc8833502, 0xec640122, 0x622dc186, 0xb6ec03b6, 0xdb14fcb6, 0x26435d38, 0x87c78221, 0x4a0427bf,
	0x4a04b6fb, 0xbe84a4fd, 0xc8833020, 0x02000022, 0x3e08df4c, 0x0019000c, 0x14294040, 0x1b570447, 0x00011b00, 0x701b201b, 0xb01b901b, 0x061bd01b,
	0x820e0008, 0x0d1a21ac, 0x0b22ac85, 0x68410e0f, 0x2f392106, 0x7127a888, 0x31e1f610, 0x89210130, 0x111122a0, 0x219c8921, 0x9d861501, 0x01b63923,
	0x8c989104, 0x014b0894, 0xecff3700, 0x5e044203, 0x5e002600, 0x0e0e3e40, 0x480f0c04, 0x8f285722, 0x0228af28, 0x18012840, 0x041f040f, 0x0403042f,
	0x48110c40, 0x0d275804, 0x010eef50, 0x0eb90ea9, 0x1f0e0f02, 0x030e2f0e, 0x070e0e06, 0x101d5112, 0x70005107, 0xe1250ce1, 0x2be61001, 0x050d4271,
	0x39113223, 0x0cba622f, 0x3521372b, 0x23262621, 0x07020e22, 0x09824e27, 0x42014c08, 0x36367c59, 0x74495283, 0xfe043052, 0x0ddb0123, 0x3b198c92,
	0x3517383c, 0x4e484018, 0x84b36626, 0xba8c514d, 0xa21d1e14, 0x54282519, 0xa69a5c84, 0x130f0997, 0x160c9a0a, 0x893e0910, 0xd4929ddb, 0x0000438a,
	0xffae0002, 0x820806ec, 0x821a20d1, 0x722008d3, 0x481b4b40, 0x0111200a, 0x1101114f, 0x48210d11, 0x0f285700, 0x02282f28, 0x28ff28ef, 0x01284702,
	0x26080c84, 0x0d470c10, 0x50242754, 0x500b1016, 0xa90110ef, 0x0210b910, 0x0b01102c, 0x02101b10, 0x0d101006, 0x150d0f0e, 0x8405501e, 0x123f21e0,
	0x21051552, 0x4551e15d, 0x09374206, 0x51715d21, 0x0e250547, 0x2e222302, 0x0b455102, 0x18021e21, 0x080b9583, 0x40080623, 0x626aab78, 0x074675a2,
	0xb6b6effe, 0x480a1301, 0x6263a076, 0xfd4479a7, 0x8f8e8029, 0x8e8f807e, 0x056b6c7e, 0xbe814230, 0x0417fe7c, 0x7439fe4a, 0x4b3e78b1, 0xa018d391,
	0x3e080b77, 0x03000023, 0x004a0491, 0x001c0011, 0x02144053, 0x18071111, 0x550e470f, 0x6f1e0f1e, 0x031e8f1e, 0xb8010006, 0x1940f0ff, 0x46120101,
	0x15124007, 0x1d560748, 0x18501002, 0x50190018, 0x480f0f0d, 0xce820629, 0x0132e137, 0xe12bf610, 0x33382f33, 0xf6105d5e, 0x391132e1, 0x30313311,
	0x05e45033, 0x023e4208, 0x23112133, 0x14032311, 0x3333021e, 0x06222311, 0x2301c6e9, 0x2841542d, 0x538a6438, 0xf4b6bc01, 0x5a4125dd, 0x6bfedb36,
	0x0ccd0168, 0x476c4c30, 0x2a51794e, 0xb001b6fb, 0x46305401, 0x6601162e, 0x075d485f, 0xd905e12b, 0x48002602, 0x06010000, 0x97741800, 0x01002b1c,
	0x14fe1200, 0x14061204, 0xdb823100, 0x1f322c08, 0x2d470c17, 0x33103355, 0x33803360, 0x1e222303, 0x171b4716, 0x19213254, 0x1a1a1e4f, 0x5010231c,
	0x29102900, 0x29032920, 0x18001c0f, 0x220bbf5c, 0x7c33e15d, 0x32220884, 0x257132e1, 0x39122205, 0x7a5d1831, 0x1811200c, 0x2109c85c, 0x65183523,
	0x142410c6, 0xf002020e, 0x09d15c18, 0x51706928, 0xb61d436e, 0x65189c9c, 0x5c180dd3, 0x44200ed5, 0x15e16518, 0x4dbefc26, 0x002f577b, 0x2e056b4c,
	0x21060a03, 0xcd012602, 0x06010000, 0x66d47600, 0x122705f1, 0x45012611, 0x61030c06, 0x97490b25, 0x00330806, 0x404f0022, 0x16171731, 0x8f240d1f,
	0x0224af24, 0x16012440, 0x56054819, 0xef501923, 0x16a90116, 0x0f0216b9, 0x2f161f16, 0x16060316, 0x51131c16, 0x431c100a, 0xf6261194, 0x5d5d32e1,
	0x9243ce10, 0x022e2107, 0x6e058b7c, 0x0624063b, 0x21152107, 0x2208fe72, 0x18655202, 0x380f35ab, 0x010e928b, 0x0923fedb, 0x83518a92, 0x147b3636,
	0x96d5893f, 0x3e89db9d, 0x05226e22, 0x9aa69729, 0x1925a4b8, 0x821e1da2, 0xff5a23e3, 0x5f4a03ec, 0x00562105, 0xa020f383, 0x7527e982, 0x0602e505,
	0x82004c00, 0xeeff210f, 0x2ded7518, 0xffffff26, 0x0114febc, 0x4d214185, 0x083c8200, 0xff100041, 0x041206f2, 0x001d004a, 0x406b002a, 0x1c460c45,
	0x0a472500, 0x90011cd4, 0x021ca01c, 0x00011c24, 0x0a1c011c, 0x1e140a1c, 0x2c570447, 0x2c2f2c0f, 0x2c5f2c3f, 0x2cbf2c7f, 0x14072cef, 0x45242b14,
	0x25290564, 0x0f1c500c, 0x16114f17, 0x066b4525, 0xe13fe126, 0x5d2f3912, 0x2706f855, 0x3911e1f6, 0x5d2f2f39, 0x10270082, 0xe11032e1, 0x46013031,
	0x2320091b, 0x3610384d, 0x022e3401, 0x33112323, 0x03023e32, 0xcbd4ec87, 0x719f652e, 0x4dd962fe, 0x2b2b0f4a, 0x4121d901, 0xdbd74060, 0x46435d38,
	0x5e4d0af6, 0x0b04470e, 0xae000226, 0x75060000, 0x2a08ef82, 0x00210014, 0x05304053, 0x0f02471c, 0x4715130f, 0xef235709, 0x23800123, 0x01233f01,
	0x01012310, 0x54134712, 0x50111b22, 0x8201bf05, 0x1c002400, 0x4c0f1350, 0xcc820892, 0x655d2f21, 0x1e500803, 0x6b112005, 0x21220896, 0xb9823311,
	0x2208b947, 0x8a112311, 0x640124ce, 0x46b6cf01, 0xfe2e08fa, 0x1505b631, 0x3f614121, 0x5d37dcd8, 0xc04c2644, 0x3dfe2105, 0x4c05bf47, 0xbd8b05c6,
	0x12000127, 0x12040000, 0x26bb8506, 0x01146832, 0x18000b14, 0x21179269, 0x69180e0e, 0x0f230b8d, 0x180b0010, 0x180c8d69, 0x230e8c69, 0x315d3911,
	0x0c84a918, 0x2112c643, 0xb9435c03, 0x18022016, 0x321b8d69, 0x0000ae00, 0x2106e503, 0xd4012602, 0x06010000, 0x43087600, 0x172805a7, 0x0c012611,
	0x0307110b, 0x4c071150, 0x062507b1, 0x00260217, 0x222b835c, 0x85b13602, 0x8228202b, 0x2d0a232b, 0x73180023, 0xc34b09cb, 0x04122205, 0x08d7824a,
	0x3d405924, 0xb70106d6, 0x0206c706, 0x07b54706, 0x07d507c5, 0x86077603, 0x074a0207, 0x0702075a, 0x47010907, 0xd74b5504, 0x0005340a, 0x0c540947,
	0x09500005, 0x0afb0615, 0x3f000f02, 0x4b3f3f33, 0x1128096f, 0x5d5d2f39, 0x5d5de15d, 0x2e08c24a, 0x11211123, 0x01640133, 0xb3feb6f8, 0x4aa0feb7,
	0x1a4a05c2, 0x21a68205, 0xe182c700, 0xe306be31, 0x44000700, 0x5a002c40, 0x03ef03df, 0x500303ff, 0x033505cc, 0xd009b009, 0x090f0209, 0x050209af,
	0x0864065a, 0x20075f04, 0x2e008201, 0x12060307, 0x333f3f00, 0xe1105d2f, 0x82f61001, 0x8211206e, 0xe15d260b, 0x11013031, 0x316f8233, 0x0e031123,
	0xbac3fdb0, 0x2d01b605, 0xf0fa2dfe, 0xc34bb605, 0x0a032305, 0x69828905, 0x1c403034, 0x00004705, 0x00020010, 0x47020900, 0x10085403, 0xff822006,
	0x4f010622, 0x8207f954, 0x8358834e, 0x20558356, 0x05ae5d21, 0xfe0a0332, 0xa601b65a, 0xfcc103b6, 0x014a043f, 0x00ffff3f, 0x0e655818, 0x00430023,
	0x050761e7, 0x26052b2b, 0xacffb801, 0x1e2b31b4, 0x0aa5410e, 0x0d675818, 0x4300062a, 0x1500004c, 0x113001b4, 0x9e252d83, 0x113036b4, 0x182d8d2e,
	0x230bc358, 0xa0017600, 0x13245d82, 0x37010b40, 0x64225e82, 0x5b9a312b, 0x2d820720, 0x00001724, 0x2d821300, 0x5e823c20, 0x36306922, 0x2b2c5b92,
	0x3a002602, 0x07010000, 0x39016a00, 0x19275b82, 0x340102b6, 0x82022605, 0xb4ff23bb, 0x5f853f2b, 0x8408876d, 0xd90521bd, 0x5a203382, 0x00213385,
	0x836182ac, 0x11392133, 0x30213386, 0x88658544, 0x20208233, 0x2b591804, 0x4300230a, 0x214172ff, 0x82092005, 0xffb824c2, 0x180fb4a4, 0x201b2d59,
	0x202f8207, 0x2342824b, 0x2301b415, 0x2f83c482, 0xcb422920, 0x5225080d, 0xae03d101, 0x03007902, 0x00b91d00, 0x40c0ff02, 0x480c060b, 0x00050202,
	0xbd01b900, 0x01e13f00, 0x2f33112f, 0x05537c2b, 0x5c035229, 0xa8a8d101, 0x82000100, 0xa8072035, 0xbb072035, 0xff022835, 0x0331fefc, 0x82d3ff4e,
	0x000734a1, 0x0418402a, 0x05090000, 0xefba0501, 0x0206ff06, 0x78ba0206, 0x01240642, 0xe15d2f00, 0x01220282, 0xb082332f, 0x30313325, 0x84352101,
	0x4e032501, 0x5203aefc, 0xfe250383, 0x8b8c8b31, 0x08bd8200, 0xc1031728, 0xb6055001, 0x25000c00, 0x0e5f1740, 0x070f0601, 0x076f075f, 0x07cf07bf,
	0x980c0705, 0x069c0c01, 0xe53f0003, 0x50822f01, 0x825d3321, 0x272108fb, 0x3337033e, 0x2507030e, 0x2e270e0e, 0x0f891934, 0x08161a1d, 0x3616c103,
	0x387b7c7a, 0x7c83843d, 0x82559335, 0x010f2d4a, 0x016f015f, 0x01cf01bf, 0x9c060105, 0x5583c282, 0x5583a782, 0x82170121, 0x82232051, 0x42012159,
	0x2f335682, 0x0e891933, 0x08161b1d, 0x3716b605, 0x387a7d79, 0x8284843c, 0x26578256, 0x01f8fe3f, 0x82ee0079, 0xb9352cad, 0xc0ff0e00, 0x180a1440,
	0x85980c48, 0x847f205a, 0x06012a5a, 0xc0ffb807, 0x481510b7, 0x20658207, 0x29bb84a8, 0x2f33332b, 0x312be15d, 0x67882530, 0x0e0f6a23, 0x21678227,
	0x67830f8a, 0x8717ee21, 0x837d20bd, 0x031926bd, 0x055201c1, 0x3a6582b6, 0x5f1c402b, 0x0f06010e, 0x6f055f05, 0xbf057f05, 0xdf05cf05, 0x05050705,
	0x880b9800, 0x82e120c2, 0x08c3835b, 0x031e132a, 0x032e2317, 0x08ee3727, 0x0f1d1a16, 0x2e341989, 0x050e0e27, 0x847c35b6, 0x7a383c84, 0x1637797d,
	0x17000200, 0xd102c103, 0x38085b84, 0x40620019, 0x011bbf48, 0x0f011b90, 0x6f1b5f1b, 0x0f13031b, 0x6f145f14, 0xbf147f14, 0xdf14cf14, 0x14140714,
	0x0c0e9819, 0x50010098, 0x70016001, 0xc001b001, 0x0701d001, 0x0da34101, 0x9c0c192d, 0x00030613, 0x32e5333f, 0x845d2f01, 0x852f20e8, 0x5d5d2492,
	0x41013031, 0x212007ae, 0x01210887, 0x0bb841a6, 0x41b8fd21, 0xd14118c6, 0x2cb79e0b, 0x14501400, 0x14701460, 0x14c014b0, 0x2ab785d0, 0x0e5f0e0f,
	0x0ebf0e6f, 0x82050ecf, 0x07a041c2, 0xcf01bf24, 0xc284df01, 0x06130725, 0x82000d9c, 0x833220b7, 0x20b685b7, 0x41b78a5d, 0x212007a8, 0x21151942,
	0x27424802, 0x0b324218, 0x00023008, 0x02f8fe3f, 0x00ee00fa, 0x0019000c, 0xd051407e, 0xf01be01b, 0x1ba4031b, 0x1bc41bb4, 0x011b9003, 0x301b2002,
	0x601b401b, 0x801b701b, 0x8713061b, 0x2bc783c9, 0x19141406, 0xe00e9098, 0x030ef00e, 0x0220ce83, 0xc683c88a, 0x42010621, 0x4024056b, 0x4818100a,
	0xa822cf85, 0xcf843f00, 0x21057042, 0xd1865d2f, 0x5d5d5f23, 0x0a7c425d, 0x8542d389, 0x42d38d0c, 0x9e420b93, 0x0069080b, 0x007b0001, 0x06680300,
	0x000b0014, 0x9052407c, 0xe00da00d, 0x040df00d, 0x10010d6f, 0x400d300d, 0x0607030d, 0x080804c0, 0xf40be403, 0x0bd6020b, 0x010b7701, 0x54010b6a,
	0x0b45010b, 0x010b2601, 0x0a09c00b, 0x36090901, 0xbe020102, 0x03100300, 0x030303a0, 0x05000104, 0x070a0bbf, 0x0008c206, 0x3f2f0003, 0x323232f6,
	0x2a0382e1, 0xe15d2f01, 0x3311325d, 0x82e61033, 0x250283c2, 0x332f3311, 0xcf8433e6, 0x13250136, 0x35051323, 0x03330305, 0xfe680325, 0x37d937b5,
	0x3701c9fe, 0x01310682, 0x1fdd034b, 0xfc0304fc, 0x011eb41f, 0x1e5ffea1, 0x20b58600, 0x08b5827d, 0xb000154e, 0x17007140, 0xb017a001, 0x0317f017,
	0x2001177f, 0x50174017, 0x0d080317, 0x0f0b0ec0, 0x0401050f, 0x12f40112, 0x0112e601, 0x7a011287, 0x12640112, 0x01125501, 0x12461236, 0x10c01202,
	0x10101114, 0x04000315, 0x0a0a05be, 0x05000609, 0x2508b982, 0x05200510, 0x05a00550, 0x080605b0, 0x0b131405, 0x1112bf0c, 0x0fc20d0e, 0x00010900,
	0x0306bf08, 0x05c20702, 0xd3872f00, 0x5e27dc8a, 0x3333715d, 0x83102f33, 0x20e58cea, 0x240d8271, 0xe633332f, 0x06dd5532, 0x87152521, 0x82f087eb,
	0x31022e10, 0xb4fe4c01, 0xfe38d937, 0x2f4c01b4, 0x2205832f, 0x8337d938, 0x012f3013, 0x1fb41ef0, 0x790187fe, 0x011eb41f, 0x83130122, 0xfe782206,
	0x08148388, 0x0000ed32, 0x01960001, 0x036d02e5, 0x001300f2, 0x2f244046, 0x6f155f15, 0xcf157f15, 0xff15ef15, 0x15100715, 0x6f0a5f01, 0xaf0a9f0a,
	0xef0adf0a, 0xd00a060a, 0xb82f3082, 0x0c40c0ff, 0x00480a07, 0x0f010f1f, 0x82010510, 0xc55d25cf, 0x2b2f015d, 0x5d200582, 0x12a69418, 0x24962b08,
	0x3132563f, 0x25254056, 0x32315640, 0x02243f56, 0x3f6447ec, 0x643f1c1c, 0x3f644647, 0x643f1e1e, 0x93000300, 0xdb05e3ff, 0x8582fa00, 0x00278a08,
	0x40a80039, 0x243b1476, 0x3bfb023b, 0x013be401, 0x3bcb3bbb, 0x013ba402, 0x64013b8b, 0x023b743b, 0x34013b4b, 0x3b0b013b, 0x66961e01, 0x02147614,
	0x28001414, 0x01322496, 0xe00132fb, 0x32d40132, 0x0132bb01, 0x8b0132a4, 0x32720132, 0x01326601, 0x3001324b, 0x20020132, 0x320f0132, 0x0a320601,
	0xf000e096, 0x00540200, 0x00020064, 0x20001000, 0x00070300, 0x9b05192d, 0x000f2337, 0xed33332f, 0x2f013232, 0x5d5d5d5e, 0x200583ed, 0x066c425f,
	0x71260682, 0x2f3911ed, 0x1088ed5d, 0x30317124, 0x4a183437, 0x23240974, 0x25022e22, 0x26210f9c, 0xb1951893, 0x91252010, 0x23132211, 0xc5e3182e,
	0x49363208, 0x2135266f, 0x35210f0f, 0x22352526, 0x35221010, 0x080f9b25, 0x07004252, 0xecff6600, 0xcb05f408, 0x1d000900, 0x3b002700, 0x49003f00,
	0x89005d00, 0xb4405c40, 0x1e4ab554, 0x23b532b4, 0x3ea028b4, 0x403c3001, 0x033cb03c, 0x28402830, 0x283c3e02, 0x033e3c28, 0x4ab44514, 0x4f5f3f5f,
	0x7f5f5f5f, 0x055faf5f, 0xb50ab405, 0x0913e118, 0x59b64727, 0x4fb643b7, 0x1be11819, 0xe13f231e, 0xe118e1f4, 0x1229091f, 0x2f2f3917, 0x5d5d5d2f,
	0x2f168210, 0x31e1f410, 0x16141330, 0x10113233, 0x05062223, 0x0e1a5918, 0x19990120, 0x01230122, 0xfa3a1d99, 0x9c9c5047, 0xc7014750, 0x4f734a24,
	0x264c7049, 0x4e714923, 0x274d714b, 0x1986ac01, 0xe118c620, 0x0226163f, 0x9b514797, 0x3a82519b, 0x4a2c208b, 0x04274c72, 0x01a5a502, 0xa348014a,
	0x2e59e118, 0xa502fc25, 0x844901a4, 0x76ab3d37, 0xab763f3f, 0x75aa6c6c, 0xaa753e3e, 0x8500ffff, 0x4a01a603, 0x0602b605, 0x00000a00, 0x02210f85,
	0x080f84b2, 0x00000540, 0x52000100, 0xfc017300, 0x0600c703, 0x04b13c00, 0xc0ffb802, 0x0c091f40, 0x3f080248, 0xaf089f08, 0xef08df08, 0x0608ff08,
	0x039feb06, 0x00060301, 0x05010303, 0x2f2f0001, 0x2f3d3912, 0x9e183333, 0x312309ef, 0x18011330, 0x180dde9e, 0x8c0bd49e, 0x403f2465, 0x4ceb0028,
	0x1025069b, 0x02032003, 0x24698c03, 0x01023f04, 0x25689302, 0x5d2f5d33, 0x9618e15d, 0x0126086c, 0x75cbfefc, 0x9618eded, 0xdf820e5b, 0xe3ff932c,
	0xb6056203, 0x04002700, 0xe082d101, 0x04000622, 0x0932e782, 0x01312fb5, 0x5d013110, 0x0100005d, 0x0000a0fe, 0x23826802, 0x1d000322, 0x0c3dde18,
	0x0012012d, 0x3f3f0003, 0x32382f01, 0x6433382f, 0x022a051d, 0x9dd5fc68, 0xb6052b03, 0x31824afa, 0x00013808, 0x021d036a, 0x00c70593, 0x40410014,
	0x00e00017, 0x16140114, 0x16c01660, 0x16f016e0, 0x01160f04, 0x0be00a0e, 0x40c0ffb8, 0x480f0a0e, 0xc0000a0b, 0x11e4040e, 0x82dc0cde, 0x33e12d56,
	0x0132cc1a, 0x32e12b2f, 0xd6105d5d, 0xb052cb84, 0x3329080a, 0x33363317, 0x02111532, 0x2d3f3f14, 0x7f152a41, 0x40091069, 0x1d03e582, 0x4451a601,
	0x41573415, 0x9d02a6fe, 0xfefa6558, 0x22c18250, 0x82006000, 0x088f82d6, 0x7600112a, 0x10024840, 0x00051002, 0x200b100b, 0x0b0b030b, 0x01133013,
	0x5a04000e, 0xdf050905, 0x07070107, 0x05100500, 0x070305c0, 0x603e0282, 0x11080008, 0x0e0f0e5f, 0x0e6f0e3f, 0x400e0803, 0x08481510, 0x040e080e,
	0x030a5f0d, 0xa3831204, 0x3939122a, 0x5e2b2f2f, 0x11e1105d, 0x070fa618, 0x5d2f3322, 0x32200b84, 0x2f200682, 0x2c05c377, 0x21013031, 0x23112115,
	0x33352311, 0x82098311, 0xc3013e03, 0xdcfe2401, 0x02b0b0b3, 0x02c3fdf0, 0x01eafd16, 0xfafe898f, 0x04890601, 0xfcfda427, 0x20b583a4, 0x32b58244,
	0x00c90523, 0x40870030, 0x150d1110, 0x23272b6f, 0x8223130f, 0x1e4b0801, 0xffb81b03, 0x093e40c0, 0x1b1b480e, 0x01321032, 0x401e2529, 0x1e480e0b,
	0x26752514, 0x29102611, 0x2a0d2a75, 0xd001266f, 0x2a0f012a, 0x2a3f2a1f, 0x2aaf2a4f, 0x26062abf, 0x002a262a, 0x1d741a1e, 0x00730718, 0xe13f0007,
	0x5132e13f, 0xb48407e3, 0x01240484, 0x33332b2f, 0x2b21bd83, 0x22df8433, 0x5c113311, 0x32230708, 0x56071716, 0x152105c0, 0x84c48215, 0x0da91803,
	0x8235200e, 0x343527e4, 0x9a02023e, 0xa918ae6a, 0x01240c11, 0x1788fe78, 0x0c15a918, 0x0f17a918, 0x9e89c031, 0x593e1389, 0xa6102b40, 0x44290b9a,
	0x82154361, 0xdd230810, 0x325f8957, 0x96000300, 0xb605ecff, 0x1b00b605, 0x35002a00, 0x18407900, 0x121c6f31, 0x186e0f10, 0x821c1815, 0x242c0801,
	0x050105ff, 0x48151240, 0xc0ffb805, 0x0e092c40, 0x37050548, 0x3701370f, 0x48100b40, 0x246e232b, 0x180f367c, 0x15121575, 0x1522732b, 0x24300182,
	0x06257335, 0x75001824, 0x3f001909, 0xe13f3fe1, 0xc741ea84, 0xf6102a07, 0x5d2b32e1, 0x2b2f3311, 0x05c2412b, 0x1033112f, 0x103232e1, 0x253031e1,
	0x37023e32, 0x07cd6c15, 0x37352334, 0x33153337, 0x14112315, 0x0e140116, 0x11232302, 0x43771123, 0x064a6206, 0x3b054a08, 0x1e23240f, 0x3f501707,
	0x24405835, 0x6b419c9c, 0xfe34d1d1, 0xcc7c348c, 0xfbb22f98, 0x3a7bbf86, 0x5d1abdfd, 0xa42e5b8b, 0x048139ae, 0x8a030806, 0x4622140c, 0xbf01486a,
	0xd3bd4d52, 0x4c56fe89, 0x5b89034e, 0xfd4d81a8, 0xbdca18c7, 0x0001320d, 0x04ecff3f, 0x00cb054a, 0xb4860039, 0x36280712, 0x08fb8319, 0x0d094b51,
	0x3b191948, 0x2c013b10, 0x05132323, 0x222e6f0d, 0x28012863, 0x23133a28, 0x24102460, 0x2d602c08, 0x245f2d05, 0x248f247f, 0x24ff24ef, 0x1f2d0f05,
	0x5f2d2f2d, 0xcf2d9f2d, 0x2d24062d, 0x37162d24, 0x07337400, 0x1d195f16, 0x333f0019, 0x42e13fe1, 0x5d200506, 0x3005d742, 0xe1103311, 0x33011132,
	0x33335d2f, 0x333232e1, 0x092a4211, 0x2709aa7a, 0x14060714, 0x17141415, 0x2d0b5555, 0x022e2223, 0x33352327, 0x34353426, 0x08823536, 0x33033e22,
	0x08054f42, 0x450803d3, 0x12435e76, 0x41feb001, 0x01020101, 0x2292fe81, 0x874b95b9, 0x5b853b3b, 0x5887b673, 0x0294a415, 0x12a09402, 0x72b88758,
	0x504fa061, 0x27057733, 0x5b8f6334, 0x0c0e0f89, 0x2913091a, 0xb8af8916, 0x1ca21a20, 0xc187491f, 0x1e178979, 0x082e161d, 0x90ca7d89, 0x92312b4e,
	0x00002b1f, 0xff8d0004, 0x05db05f8, 0x000300c1, 0x002b0017, 0x40860048, 0x3902010a, 0x0eb41846, 0xb8020003, 0x4a40f0ff, 0x46904670, 0x46d046a0,
	0x010edf04, 0x46021000, 0x0e00000e, 0x31040246, 0x040fb422, 0xff04ef01, 0x4a040204, 0x3100b440, 0x10310001, 0xe0312031, 0x0531f031, 0xfc423108,
	0xfc3dfd2c, 0xfc270736, 0xfc1dfd13, 0x06031909, 0x3f001801, 0xf4e13f3f, 0x056247e1, 0x715d5e25, 0x82de10e1, 0x17112304, 0x00822f39, 0x5d5d382a,
	0x10331138, 0x113311e1, 0x20063045, 0x0e604701, 0x210f746a, 0xaa562201, 0x2651080a, 0x06222326, 0x32331415, 0x06153736, 0xfc0a0506, 0x2b039dd5,
	0x502d6e01, 0x6e3f4470, 0x502c2f51, 0x6e3e4471, 0x33fe2f52, 0x2b3c2611, 0x11253c2a, 0x2a3c2511, 0x11263c2b, 0x7945cbfd, 0x5c35345a, 0x6433487d,
	0x551f2120, 0xc25f6722, 0x23235a33, 0x05a84563, 0x5398fb29, 0x2d2d577f, 0x87537f57, 0x337e0807, 0x23233e56, 0x3433563e, 0x21213d55, 0x9201553d,
	0x5a805226, 0x2652845f, 0x0d6b0f16, 0xe5767414, 0x126b1011, 0x02000013, 0xecff7700, 0xcb057b03, 0x3a002d00, 0x32405500, 0x4023702e, 0x23481410,
	0x06051123, 0x6e28353c, 0x11101419, 0x11301120, 0x11901180, 0x15181105, 0x11147636, 0x30002828, 0x00071e76, 0x06060b75, 0x3f00190b, 0xe1102f33,
	0x3912e13f, 0xe133332f, 0x2f013232, 0x0782c55d, 0xc1d61022, 0x2b201182, 0x30077143, 0x23030e33, 0x35022e22, 0x07060635, 0x37363635, 0x0ac54911,
	0x11070109, 0x13021e14, 0x0e222334, 0x3e111502, 0x206f0203, 0x031e2e39, 0x46260464, 0x6a3a4669, 0x612e3051, 0x2d5f3431, 0x4b68401c, 0x213d5736,
	0x477c5c35, 0x63372411, 0x17292066, 0x334e3609, 0x32167718, 0x83533b52, 0x5425305a, 0x11e76388, 0x0e790c1c, 0xee010f1e, 0x31536c3b, 0x456f4f2a,
	0x6886a663, 0x30d3fe26, 0x04213b51, 0x321bbc21, 0x6afe2a45, 0x79624e21, 0xc7000400, 0x89070000, 0x1700b605, 0x37002b00, 0xba003b00, 0x010e7240,
	0x39005a15, 0x22e12c39, 0xb0010010, 0x009f0100, 0x40003001, 0x22000200, 0x320a2200, 0x3a0f18e1, 0x3a2f3a1f, 0xef3a3a03, 0x67180118, 0xbf3d6f3d,
	0x033dcf3d, 0x0c013d40, 0x5a090308, 0x2f3c640a, 0xe5351de5, 0xdf1dcf27, 0x031def1d, 0x0b06401d, 0x1f270f48, 0x6f275f27, 0xef277f27, 0x1d060627,
	0x16271d27, 0x18061003, 0x030b0348, 0x0e38e539, 0xb6f0ffb8, 0x0e2b0d82, 0x00120a01, 0x2b33333f, 0x823fe033, 0x39392804, 0x5d5e2f2f, 0x18105d2b,
	0x2908c693, 0x105d5d32, 0x2f325de6, 0xd7571071, 0x4c0a8208, 0x312305ce, 0x18232130, 0x240e8977, 0x1135032e, 0x119d4233, 0x09087418, 0x35032308,
	0xa8041521, 0x0887fdcd, 0x05040406, 0x7602cfa6, 0x01040306, 0xa4010203, 0x4d29e102, 0x6b3f446d, 0x07832c4d, 0x4e6b3e3c, 0x4842fe2c, 0x47475151,
	0x63485151, 0xba04f001, 0x8e414c4d, 0x05e7fc39, 0xd018fbb6, 0xfc2409d9, 0x598253b9, 0x0c969f18, 0x73717e08, 0x6d727173, 0x931ffd6d, 0x00020093,
	0x05e50225, 0x00b60550, 0x00200007, 0x005d40a3, 0x0a1301c4, 0xc011c410, 0xe006d006, 0x066f0306, 0x40063001, 0x03065006, 0x0401061f, 0x11200106,
	0x010211d0, 0x06111106, 0x1e030301, 0xc4181519, 0x17af179f, 0x0f221702, 0x3f222f22, 0x40220322, 0x22481815, 0x48120f40, 0x03ef03cf, 0x091f0302,
	0x180c2009, 0x03070948, 0x141804c8, 0x40e0ffb8, 0x2e0e820c, 0x01081114, 0x04121501, 0x333f0003, 0x822f3333, 0x332b3503, 0x3332e110, 0x0133112b,
	0x2b2b5d2f, 0x5dd6105d, 0x323232e1, 0x4c05dd43, 0x27460574, 0x23013407, 0x21352311, 0x03012315, 0x15031e23, 0x33112311, 0x82331313, 0x3e343b06,
	0x03233702, 0xc47f6801, 0x02c70a02, 0x0107ba40, 0x7b010102, 0xb2bfb4ba, 0x0082017f, 0xc3066408, 0x6502e502, 0x9bfd6c6c, 0x22102502, 0xfe06181e,
	0xfdd10249, 0xfd2702d9, 0x09ac012f, 0x0c23231e, 0xffffdbfd, 0x00004e00, 0xcd05a605, 0x76010602, 0x02000000, 0xddff6600, 0x48048b04, 0x2f002200,
	0x21403b00, 0x111e4a23, 0x4a132f31, 0x05010510, 0x12181d1d, 0x3b2f2b4e, 0x2f2f022f, 0x0c4e2918, 0x5e4e180f, 0x5d2409b2, 0x2f3911e1, 0xe123cb82,
	0x18de1032, 0x2b0ae7c4, 0x1e323304, 0x11211502, 0x3233031e, 0x6408af82, 0x13030e17, 0x23032e11, 0x07020e22, 0x82790211, 0x2c4586c6, 0x8076664c,
	0x8ec2713f, 0x16c5fc51, 0x2e584d40, 0x4d5e744a, 0x53244822, 0x13cc8f6e, 0x355d4d3b, 0x3c495733, 0x9d5e2318, 0xa0636ecc, 0x1d3c5c7e, 0x83d1934f,
	0x2c189cfe, 0x3c201522, 0x39293757, 0x022c4d65, 0x1415018b, 0x1316232a, 0xfe172a21, 0x08d582e9, 0xecff5342, 0xb605d305, 0x7b002600, 0x27000014,
	0x5e021702, 0x07010000, 0x62034002, 0x3000b3fd, 0x03041f40, 0x01192702, 0xe40111f4, 0x11d00111, 0x0111b001, 0x300111a0, 0x2f110111, 0x590f0159,
	0x115d5d01, 0x25058441, 0x353f0035, 0x51823535, 0x51843320, 0x5182c920, 0x51867520, 0x518a8b20, 0x28403c22, 0x23085182, 0xf0011949, 0x33d00133,
	0x0133c401, 0xa00133b4, 0x33940133, 0x01336001, 0x24013330, 0x2f330133, 0x7b0f017b, 0x60825a89, 0x4f205d88, 0xaf825d84, 0x983d0221, 0x823d205d,
	0x01273f5d, 0xc40127d0, 0x27b40127, 0x0127a001, 0x60012794, 0x27300127, 0x01272401, 0x016f2f27, 0x5d956f0f, 0x5d887120, 0x41423f21, 0x3920050d,
	0x3422bb8a, 0xbb822240, 0x01191f3d, 0xeb0109f4, 0x09cb0109, 0x0109b401, 0x7f01099b, 0x092b0109, 0x512f0901, 0x8a510f01, 0x08b38557, 0x00020034,
	0x04ecff62, 0x00c5053b, 0x0043002b, 0x3321403b, 0x57004719, 0x01454045, 0x0601450f, 0x0c21483f, 0x4f384456, 0x212c1313, 0x0427501c, 0x1607502c,
	0x01483f00, 0xe12f2905, 0x32f61001, 0x5d5d5ee1, 0x3a059468, 0x040e1401, 0x022e2223, 0x043e3435, 0x17163233, 0x34353436, 0x0e222326, 0x60350702,
	0x012605da, 0x37043e32, 0x1282032e, 0x15047d08, 0x04021e14, 0x6541203b, 0x6a6db18a, 0x1722538c, 0x99735132, 0x2d935b62, 0x1f898b02, 0x1b414344,
	0x4f4b4318, 0x63a67d25, 0x359efd2a, 0x3543515e, 0x290a0a25, 0x3e2a493b, 0x253a4f66, 0x462d1512, 0xe16aa603, 0x528dbcd4, 0x4c8f6e42, 0x838d8d3c,
	0x454f3d65, 0xbe0b2a13, 0x1f160cc9, 0x170cae13, 0x96590a11, 0x2c73fcc4, 0x857a684d, 0x33452843, 0x6851301e, 0x322f6e6f, 0x00244056, 0x2a08f382,
	0x04000029, 0x00b60562, 0x000e0005, 0x02114058, 0x05090901, 0x04605b0e, 0x04b00470, 0x040404f0, 0x40c0ffb8, 0x480a0627, 0x18100404, 0x37115561,
	0x0d055b0d, 0x0912055f, 0x48110a20, 0x00030109, 0x3f2b333f, 0xe12f01e1, 0x21051f4a, 0xdd4de15d, 0x313b0805, 0x33013730, 0x01211501, 0x06272626,
	0x21030706, 0xbbbe0129, 0xc7fbc001, 0x2d207702, 0x1d2a110f, 0x71a602fa, 0xb9fa4505, 0x619a036f, 0xa84b4ba8, 0x0004fd5b, 0xfec70001, 0x82270514,
	0x00072e99, 0x00114037, 0x0965075a, 0x09300900, 0x05dd6840, 0x97830920, 0x18140f2f, 0x045a0348, 0x5f020864, 0x00040305, 0x08e6681b, 0x105d2b2b,
	0x3031e1f6, 0x11211101, 0x30038223, 0x14fd6d04, 0xfe6004ba, 0xf9fc0614, 0xf8a20704, 0x245d825e, 0x0414fe4a, 0x2f5d82e3, 0x405c000b, 0x705b080b,
	0x06020106, 0x0a000602, 0xb7275782, 0x0a480e09, 0x82070d0a, 0x40e02b63, 0x48180f09, 0x00000309, 0x71840d0c, 0x48181325, 0x18020208, 0x8207c05e,
	0x18e12071, 0x3207c05e, 0x1833112b, 0x2b33332f, 0x2f331132, 0x3939122b, 0x825d2f2f, 0x18132082, 0x3d0ac15e, 0xfd70024a, 0xfc4804a0, 0xfd3a02bc,
	0xfe9b03b0, 0x92037314, 0xa4722b03, 0x9dfc09fd, 0x938200a4, 0x02662408, 0x03020487, 0x0003001d, 0x021f4032, 0x01009605, 0x7901008b, 0x00560100,
	0x01004b01, 0x14010038, 0x82090100, 0xad002427, 0x1800b301, 0x2e0ba0ad, 0x3031ce10, 0x15213513, 0x029c0366, 0x83969687, 0xff25304b, 0x06c504f2,
	0x000800a0, 0x0113402c, 0x83050600, 0x080739de, 0x03030810, 0x070404ae, 0x2f2f0000, 0x01e12f39, 0x33382f2f, 0x2f193939, 0x2208ba82, 0x31333311,
	0x01230530, 0x13213523, 0x73023301, 0xb4ebfe85, 0x02e52901, 0x030e9200, 0x69fd8f0a, 0x8200ac05, 0x77790899, 0x31059101, 0x23000e04, 0x43003300,
	0x4f407600, 0x48011749, 0x45f0010d, 0x5f452f01, 0x273a0245, 0x276a274a, 0x01372a03, 0x27081a37, 0x2f773f04, 0x2f022f97, 0x301220aa, 0x78120212,
	0xab3f013f, 0xae2a3400, 0xae243a17, 0x1a273708, 0x00051704, 0x020d100d, 0x1f0d0d07, 0x2001179f, 0x00170117, 0x335d5d2f, 0x5d5e2f33, 0x39171233,
	0xe11032e1, 0xe12f0132, 0xe15d2f5d, 0x200f825d, 0x2b00825d, 0x5d5d3031, 0x020e1401, 0x27262223, 0x2606f848, 0x33023e34, 0x43171632, 0x8b08055b,
	0x37363205, 0x22232626, 0x1415020e, 0x2201021e, 0x16160706, 0x023e3233, 0x022e3435, 0x4d2b3105, 0x9b5d426d, 0x4e461d41, 0x6e412b53, 0x4e2b2d4f,
	0x9e55436f, 0x4f441d3e, 0x6d423057, 0x7bfc2b4d, 0x31346c3f, 0x4028456b, 0x2c15182c, 0x3f7c0241, 0x6c33376b, 0x2d402744, 0x402e1918, 0x723fcd02,
	0x73693457, 0x1e384f30, 0x4875522c, 0x31567341, 0x4e30706b, 0x522d1f38, 0x6157f975, 0x331d5a5e, 0x42242644, 0x6a011e32, 0x5c5d6157, 0x44080d82,
	0x31432627, 0x0001001c, 0x0314fe10, 0x00140606, 0x40370023, 0xd0251023, 0x04140225, 0x01040601, 0x1bac0d04, 0x15090115, 0x1e101501, 0x1e021e20,
	0x1c12ae19, 0x0000ae07, 0x3fe13f00, 0x5d2f01e1, 0xe15d5d33, 0x20f68432, 0x20e28201, 0x20d98615, 0x93721811, 0x343b080f, 0x8302023e, 0x12164b22,
	0x4233243d, 0x59321027, 0x4b244a7c, 0x233e1417, 0x122a4533, 0x0679572f, 0x93090914, 0x41271109, 0xd7fa2d54, 0x2956865e, 0x0893080b, 0x54402510,
	0x82270530, 0x00282a0e, 0x01660002, 0x0402047b, 0x08a18225, 0x4b004743, 0x1d412e40, 0x01491049, 0x200a102e, 0x400a020a, 0xaf31ad29, 0x0aad1743,
	0x051caf1f, 0xef0ddfad, 0x030dff0d, 0x120f400d, 0x3b0d0d48, 0xb3432ead, 0xe1333f00, 0x5d2b2f33, 0x32f533e1, 0xe1f510e1, 0x26ba8433, 0x3132ce10,
	0x472e0130, 0x3522051d, 0xba183336, 0x0320105a, 0x02271b9a, 0x2d372512, 0x181c1629, 0x201a76ba, 0x2e219a2f, 0x321d9761, 0xbc014337, 0x050d1610,
	0x182c2113, 0x231398ba, 0x1510ae01, 0x20281c82, 0x6da21a2c, 0x14190e05, 0x2d200d85, 0x74082a85, 0x66000100, 0x0204a400, 0x13000405, 0x1140a600,
	0x110e0d0a, 0x12120912, 0x07040300, 0x09081308, 0xf0ffb813, 0x10094f40, 0x09130913, 0x150b1006, 0x01011540, 0xbb0106c6, 0x06a90106, 0x01068601,
	0x6801067b, 0x06420106, 0x01063901, 0x08080906, 0x07ad040d, 0x11121213, 0x1f0ead00, 0x02032f03, 0x0001037f, 0x02031003, 0x0a030306, 0x0f0107f0,
	0x02076f07, 0x08fd4207, 0x33715d2f, 0x113232e1, 0x32e11033, 0x01331133, 0x05bb472f, 0x335d5d22, 0x2905a863, 0x382f2f39, 0x7d331138, 0x0082c487,
	0x10330122, 0x31270784, 0x35230130, 0x82211321, 0x07172603, 0x03211533, 0x08038221, 0x5e01272a, 0x793e01f8, 0xfc0149fe, 0xfa698a85, 0x017bc1fe,
	0x8100feba, 0x96ba0189, 0x01950401, 0x95e03b1b, 0xfe96fcfe, 0x020039ea, 0x2108ef82, 0x04020400, 0x000600dd, 0x4052000a, 0x0c000932, 0x08010c40,
	0x01010140, 0x05050102, 0x006f0603, 0xe718007f, 0xb48433bf, 0x25303135, 0x15013501, 0x21350209, 0xfc020415, 0xfd9c0364, 0x83df0221, 0x01ee2107,
	0x08c8e718, 0x9671fe24, 0x89920096, 0x89850520, 0x0601062a, 0x01010405, 0x066f0003, 0x354de718, 0x13218986, 0x218a8301, 0x8a821501, 0xe2026626,
	0x9c031efd, 0x012c8783, 0x0142018f, 0x1ffea26a, 0xee58fe66, 0x39088785, 0x0400006d, 0x00c3053f, 0x00090005, 0x0236405d, 0x04050901, 0x03070907,
	0x0b00ac06, 0x40010bff, 0x800b500b, 0xc00bb00b, 0x0b0f050b, 0x08020b2f, 0x010310aa, 0x00080303, 0x01820806, 0xad070222, 0xad302c82, 0xe12f0002,
	0x3912e13f, 0x2f2f3d39, 0x33113311, 0x2305ec54, 0xde105d5d, 0x11211483, 0x08128233, 0x30313331, 0x01230101, 0x03093301, 0x3cfe3f04, 0x013efe4c,
	0x0c014cc2, 0xcffecffe, 0xe1023101, 0xdf021ffd, 0x1efde402, 0x00fe0002, 0xff00fefd, 0x821d00ff, 0x172d0897, 0x26001f06, 0x00004900, 0x4c000701,
	0x0000a202, 0x18402400, 0x1daf0102, 0x011d5001, 0x0f011d1f, 0xaf1d011d, 0x2f40012f, 0x012f0f01, 0x06ff495d, 0x86353521, 0x8a06203d, 0x844f203d,
	0x4022223d, 0x263c8e17, 0x21400121, 0x89210f01, 0x01003f3c, 0xd904cf00, 0x1706cd03, 0x3f001500, 0x17002940, 0xaf021720, 0x0217cf17, 0x17701730,
	0x1f820f02, 0x0a000029, 0x06020a30, 0x827f0a0a, 0x0640360c, 0x00004809, 0x00058e10, 0x2f33e12f, 0x01335d2b, 0x335d5e2f, 0x060a5a2f, 0x2105bd45,
	0x494b3327, 0x08568206, 0x8d5d3143, 0x588c6764, 0x05aa0529, 0x354c321b, 0x2236492c, 0x4e170606, 0x27295176, 0x39507750, 0x13102949, 0x0035482b,
	0xfebcff01, 0x04640114, 0x0013004a, 0x10134023, 0x02152015, 0x030c470f, 0x14540c03, 0xafcc180d, 0xc15c1808, 0x30312207, 0x214d1813, 0x33112a0a,
	0x020e1411, 0x173f3042, 0x9dcc181a, 0x7d841809, 0x042c080a, 0x4d18fbf4, 0x002f577b, 0x87010100, 0x7902cd04, 0x0d001406, 0x0c401900, 0x063f8505,
	0x000c0601, 0x0005920c, 0x01e53f00, 0x5ddd332f, 0x0c906e18, 0x0987013a, 0x040e1112, 0x291f06b4, 0x0460162e, 0x514d1ee7, 0x19142150, 0x2056564e,
	0x6f264b82, 0x75023bfe, 0x4b8283ff, 0x09401628, 0x0500000c, 0x49830685, 0x48822f20, 0x2f32e125, 0x18303133, 0x320a8175, 0x181a0b6f, 0x06b20413,
	0x1d362c1f, 0x1956fe62, 0x8253544c, 0x574d2348, 0x95832156, 0xd9047d26, 0x21068302, 0x17224982, 0x49850a40, 0x82920521, 0x86938307, 0x030e384a,
	0x3e352307, 0x02333703, 0x181a0c83, 0x05b20412, 0x1c372d1f, 0x84060662, 0x1815214a, 0x2b089382, 0x00020021, 0x02390225, 0x00c7057f, 0x001d000b,
	0x0619402a, 0x4f1f0ce1, 0x021f7f1f, 0x0a06401f, 0x16e10048, 0xde1be509, 0xdf11e503, 0x24068b46, 0x105d2be1, 0x21f282de, 0xe94e1413, 0x0d045909,
	0x47b81624, 0x00824e51, 0x2b0f9258, 0x02049a95, 0xa79fa1a5, 0xa59f9fa5, 0x26065058, 0x74a96c6c, 0x8200ec3c, 0x020c3c85, 0x058f024a, 0x000a00bc,
	0x40460015, 0xe102092a, 0x0303070b, 0x8f175f17, 0x83170217, 0x15250889, 0x040105e1, 0x0b0f09e5, 0x0b2f0b1f, 0x0b0b0803, 0x07e50f02, 0x00dd02dc,
	0x12e13f3f, 0x5d5e2f39, 0x0132e133, 0x519d822f, 0x5f080626, 0x23013031, 0x21352315, 0x11330135, 0x34352133, 0x030e3736, 0x8f020707, 0x89fe8f7d,
	0x7d8d7901, 0x0303f4fe, 0x18161405, 0x0a039b09, 0x026fc0c0, 0xc3cdfd43, 0x0b31632a, 0x0f282a25, 0x010000f0, 0x37023b00, 0xb6056602, 0x4a002400,
	0x22211740, 0x1d1d1e22, 0xe114200b, 0x264f2605, 0x2602267f, 0x0b359383, 0x40c0ffb8, 0x48181211, 0x00e5170b, 0xe5211100, 0xe511dc1e, 0x05294108,
	0xe1298682, 0x2b2b2f01, 0xe1de105d, 0x21938433, 0x93823311, 0x021e3226, 0x23061415, 0x0ce84618, 0x0e224c08, 0x13270702, 0x07211521, 0x42013636,
	0x2d4f6b3d, 0x793fa1a6, 0x3d3c1a2c, 0x5f55183b, 0x250d595f, 0x430e2527, 0xfeba0121, 0x391412be, 0x44236d04, 0x9d8c4165, 0x128d1a1c, 0x4c0a131b,
	0x04554d58, 0x2b020706, 0xd77ba801, 0x41000603, 0xd53408d1, 0x2d001d00, 0x20403800, 0xe1210a10, 0x2f4f2f00, 0x2f022f7f, 0x152eb583, 0x240ae129,
	0x191915e4, 0x1ede0f10, 0xae8405e5, 0x2f393323, 0x21ae8233, 0xaf8432e1, 0x82391221, 0x0a7753a9, 0x0e173728, 0x36330703, 0xbd823336, 0x36320522,
	0x0806c74c, 0x1e141575, 0x2a7f0202, 0x40446f4e, 0x452f526e, 0x2d6eb27e, 0x40607f4f, 0x631b0b0f, 0x405a364a, 0x44dbfe24, 0x27474d54, 0x19192d3f,
	0x66033d2d, 0x2d506f41, 0x5380582d, 0x6d8fb36e, 0x401b6d27, 0x2b3b604f, 0x69482531, 0x52565cf7, 0x3729195a, 0x35492c1e, 0x0001001d, 0x024a022f,
	0x00b60564, 0xb9380006, 0xf0ff0000, 0x00001f40, 0x05e10102, 0x7f084f08, 0x83080208, 0x02d030c1, 0x02f002e0, 0xe5020203, 0xdd00dc03, 0x823f3f00,
	0x845d20ba, 0x391135b9, 0x3031382f, 0x35210113, 0x8d011521, 0x62fe4001, 0xbffe3502, 0x25085182, 0xfc647bf1, 0x000300f8, 0x02390231, 0x00c70571,
	0x00340025, 0x40770044, 0x21e13822, 0x0a05e142, 0x041c323d, 0x01822105, 0xe12c172a, 0x464f460f, 0x4602467f, 0x38086a83, 0xb817e126, 0x2740c0ff,
	0x17481815, 0x323d1c0a, 0x325b324b, 0x329b326b, 0x320532ab, 0x3db63514, 0x3dd63dc6, 0x29003d03, 0x35df14e5, 0x00de00e5, 0xe13fe13f, 0x115d3911,
	0x24038412, 0x2b2f0139, 0x2b9884e1, 0x2f393912, 0x3917122f, 0xe110e110, 0x22070642, 0x7407020e, 0x74180538, 0x2e2607e1, 0x3e343503, 0x59430302,
	0x022e2e06, 0x06062727, 0x15062213, 0x17021e14, 0x081b823e, 0x520126aa, 0x2a465e34, 0x1e342716, 0x1c303e22, 0x3f694d2a, 0x2a19968b, 0x2e1b1f38,
	0x482b1323, 0x484a625f, 0x27164b4a, 0x410f2137, 0x3f389442, 0x1a2d2012, 0x13202c18, 0x1bc70541, 0x25385437, 0x1128323e, 0x45372d13, 0x425d392a,
	0x2a738324, 0x112b3845, 0x3e352b14, 0x37533825, 0x3b68fd1c, 0x1e3b4646, 0x0f202730, 0x014d2206, 0x1b3637e8, 0x0d1d242a, 0x2c231c0c, 0x0037361c,
	0x02210002, 0x057b0239, 0x002500c9, 0x403b0035, 0xe0113122, 0x37001c09, 0x377f374f, 0x06403702, 0xe129480a, 0x11e42c1c, 0x26051717, 0x0cde21e5,
	0x21065742, 0x584212e1, 0x5d2b2506, 0x3911de10, 0x08144318, 0x21098b45, 0xbf4b2337, 0x021e220b, 0x4bef8325, 0x1d0908ab, 0x5a217b02, 0x401981a2,
	0x19361515, 0x1d406c53, 0x240d0903, 0x3c263d30, 0x29244460, 0x41436c4b, 0xfe305472, 0x4a5644cb, 0x2d3f264c, 0x3e2a1518, 0xbb604204, 0x07085b93,
	0x350a0d7d, 0x123d7257, 0x25111b24, 0x42416647, 0x2f2d516f, 0x5eac9361, 0x19584c58, 0x241a3329, 0x00243b48, 0x54001600, 0xc10781fe, 0x0500ee05,
	0x11000b00, 0x1b001700, 0x23001f00, 0x2b002700, 0x33002f00, 0x3b003700, 0x43003f00, 0x53004700, 0x6f005f00, 0x81007800, 0xe4009000, 0x2c345940,
	0x18381c20, 0x707a5157, 0x6467746f, 0x6b7e8264, 0x51c05170, 0x510351d0, 0x6f6b6b6f, 0x895d0351, 0x8c5f8c4f, 0x448c8c02, 0x17092428, 0x604b505d,
	0x4b4b024b, 0x00313d41, 0x46422a0c, 0x8632263e, 0x796f8f8f, 0x7a707067, 0x546f7a60, 0x6f704848, 0x61026f80, 0xb86f016f, 0x2540c0ff, 0x6f480c07,
	0x4e5a606f, 0x1f788a4e, 0x3f602f60, 0x04606f60, 0x2c016060, 0x0c12181c, 0x07213539, 0x0701010f, 0x5e2f0001, 0x7353335d, 0x12332306, 0x0c832f39,
	0x11332f28, 0x5d2b2f33, 0x0883335d, 0x73441120, 0x822f2006, 0x2103830d, 0x2d822f01, 0x82333321, 0x5e088828, 0x112006d7, 0x06824685, 0x2d843e82,
	0x1330313c, 0x23152111, 0x21352515, 0x01352311, 0x33153311, 0x33352115, 0x21113335, 0x09822135, 0x01152122, 0x01240782, 0x11331123, 0x0b870382,
	0x33200783, 0x35201786, 0x03831783, 0x3526222b, 0x32373634, 0x06141516, 0x06394427, 0x14150625, 0x84330116, 0x15072212, 0x23198316, 0x33132323,
	0x23221c85, 0x09861515, 0x16350523, 0x820a8316, 0x14230863, 0x54222306, 0x05c02f01, 0x6d3001ce, 0xc06f00f9, 0x6dc30e05, 0x110149fd, 0x0e01e1fb,
	0x0e01f2fe, 0x826db704, 0xc2fb3100, 0x30fc1001, 0xc0026f6f, 0x01771001, 0x6fa8fa11, 0x06290082, 0xfa6d6dfe, 0x87877f99, 0x0803837f, 0x3f3f483e,
	0x42424548, 0x6dac9f01, 0x382d2d70, 0xcf5e6d33, 0x242e427b, 0x4a3b3029, 0x34262531, 0x20100e01, 0x7d312514, 0x043d5f68, 0x6f3001be, 0xfe6fc1c1,
	0x02f9c1d0, 0x6dc22f01, 0xd1fec26d, 0x6d326482, 0x6f6ffe06, 0x0e01a8fa, 0x0f010202, 0x6d6d3bfa, 0x7f82a601, 0x69824a20, 0xfc6f4e08, 0x7910012f,
	0x68fd0f01, 0x8afe1001, 0x9b918e9f, 0x8e919c01, 0x5e67689f, 0x5e66665e, 0xea01675e, 0x44315343, 0x440b0408, 0x0159513a, 0x22202262, 0x2b9ae31d,
	0xfc2a2025, 0x24050366, 0xfe920132, 0x00645e72, 0xfe540003, 0x06aa07c1, 0x08098214, 0x2f00233e, 0x28405000, 0x24232304, 0x2a302a20, 0x2a032a40,
	0x01244f2a, 0x1c022424, 0x15020b0b, 0x23230215, 0x2d012d30, 0x0327272d, 0x03101019, 0x332f1900, 0x11332f18, 0x2f332f33, 0x012f335d, 0x0d830e84,
	0x0f820382, 0x06825d20, 0x30313337, 0x35050309, 0x36373634, 0x2e343536, 0x0e222302, 0x36170702, 0x068d4136, 0x15060623, 0x077d4415, 0x23267208,
	0xfe030622, 0x54fcac03, 0xeb0356fc, 0x4d634c21, 0x51835b31, 0x52575a2b, 0x7e445222, 0x273e3f38, 0x1b4a4552, 0x47444647, 0x47464447, 0x56fc1406,
	0xa90357fc, 0x3e2c2ffb, 0x59834c3a, 0x274a6b45, 0x14231b10, 0x3a2e22b2, 0x4144312f, 0x3b507935, 0x493eedfe, 0x49403e49, 0xffff0049, 0x14febcff,
	0x21065502, 0x37022602, 0x07000000, 0xbbfe4c01, 0x21178200, 0x3f691700, 0x06022305, 0x17820702, 0x00025608, 0x04ecff0a, 0x002b06b2, 0x004f000c,
	0x4d474075, 0x3e10430d, 0x47083b00, 0x3b1a4343, 0x10004f47, 0x51101001, 0x3f0151a0, 0x47330151, 0x1a101a00, 0x1a031a20, 0x3e295022, 0x004e4f4f,
	0x1029004e, 0x40293029, 0x05295029, 0x294e2906, 0x5005384e, 0x50380148, 0x05b35315, 0x02581220, 0x33112905, 0x1032e110, 0x5d2f01e1, 0x2406ad6c,
	0x3911e133, 0x2103822f, 0x21821139, 0x01303125, 0x4523032e, 0x05270583, 0x14151616, 0x53060602, 0x2d7f06d5, 0x36362708, 0x021e3233, 0x6c501415,
	0x32332605, 0x26341112, 0x05cb4527, 0x2a081883, 0x03153317, 0x4d390d6a, 0x564c305b, 0x01ab6a2e, 0x4002023c, 0x6f83c481, 0x0a225692, 0x1f1f0a0b,
	0x25103618, 0x32366425, 0x82132c45, 0x1560080f, 0xa43a4e30, 0xae0202a4, 0x274396f2, 0x68597f51, 0x124b75a1, 0x6cd1038f, 0x583d74aa, 0x52693848,
	0x3a168a33, 0xeefe9f1f, 0x5f3773c9, 0x5d28457d, 0x2d184b59, 0x7f0a0f21, 0x321c1a11, 0x56232844, 0x2a2d615d, 0x011f364a, 0x17300132, 0x4b02143e,
	0x43519a78, 0x542e5270, 0x898bdf9c, 0x00010000, 0x7d080082, 0xc3054804, 0x8f002200, 0x24af1b40, 0x240224ef, 0x480c0940, 0x0121ab22, 0x40012198,
	0x211b0121, 0x01210f01, 0xf0ffb821, 0x21214440, 0x0d1b1f00, 0x010d0f01, 0x1612200d, 0xaf0d9f48, 0x0d7d020d, 0x010d6b01, 0x4f010d5a, 0x0d2b010d,
	0x0d020d3b, 0x775a1e0d, 0x971f871f, 0x1f4f031f, 0x101f0001, 0x1f07021f, 0x211f001d, 0x11121f03, 0x3f00040a, 0x123f3fc1, 0x2f013939, 0x5d5d5d5e,
	0xc64e32e1, 0x712b2706, 0x33391171, 0x1382382f, 0x335d5d2a, 0x30315d2b, 0x37033e01, 0x5005f35c, 0x590806e1, 0x07050e07, 0x01112311, 0x191d0233,
	0x183c3f3d, 0x40352f16, 0x112b2329, 0x0b0d200d, 0x1323201c, 0x3632280d, 0xbb133236, 0x02cb42fe, 0xa0a84bdb, 0x3d282c89, 0x08091427, 0x07050391,
	0x18232a17, 0x85806e55, 0xe3fd3c85, 0x87032f02, 0x12000200, 0x6006ecff, 0x1c004a04, 0xfb823c00, 0x19476e08, 0x2f012f67, 0x012cd547, 0xa9012cb7,
	0x2c9a012c, 0x2c2c0301, 0xab483703, 0x0212bb12, 0x143e1212, 0x3e54013e, 0x3e843e64, 0x3eb43ea4, 0x013e4005, 0x013e3002, 0x22013e0f, 0x10030048,
	0x40033003, 0x05035003, 0xffb80306, 0x121540c0, 0x1a034815, 0x272d2d00, 0x50080e1d, 0x27320f0b, 0x16001650, 0xe1323f00, 0x32e13f32, 0x2f391232,
	0x31fe8212, 0xe15d5e2b, 0x5d5f5d5d, 0x3311715d, 0x11e15d2f, 0x0b822f39, 0x13825d20, 0x30313932, 0x35262205, 0x37023e34, 0x21373521, 0x031e2315,
	0x2306244a, 0x03060623, 0x0a235c18, 0x15333523, 0x081b4714, 0x02278b08, 0x12c3b629, 0xfe1a2b20, 0xc80586eb, 0x1b2618f3, 0x6ab5c40f, 0x1f0b1f8b,
	0x2816ba8b, 0x361d121f, 0x442e2d4b, 0x62b3162c, 0x364b2d52, 0x24190f1d, 0xf3ea1415, 0x7b7e7d39, 0x9a504a38, 0x7d7e7b38, 0x57eaf339, 0x03575b5b,
	0x797636c4, 0x83623a7a, 0x4829214e, 0xb0b03962, 0x4e218a82, 0x7a3a6283, 0x00367679, 0xc700ffff, 0x2f060000, 0x26027507, 0x00003000, 0x76000701,
	0x54017901, 0x0b401300, 0x26052701, 0x201a4b01, 0x196f0f09, 0x82ae200a, 0x0687222d, 0x202d8221, 0x822d8650, 0x282d843f, 0x0126113a, 0x16332d7a,
	0x262d8a2b, 0x04d5fd00, 0x82bc05dd, 0x8324202d, 0x5b022f2d, 0x00001b01, 0x03b70d00, 0x151f0102, 0x29830704, 0x83833520, 0xd5fd5e26, 0x5e049c03,
	0x44202782, 0x00212785, 0x212786bc, 0xac183d14, 0xff2508f5, 0xffd3feff, 0xef7918ec, 0x5c02230b, 0x278240fe, 0xb63f3008, 0x032d0203, 0xb8350203,
	0x09b2c0ff, 0xffb8480f, 0x351a4021, 0x250a0a35, 0x00b00001, 0x01008001, 0x5001007f, 0x00400100, 0x01001f01, 0x845d1100, 0x35352700, 0x35352b2b,
	0x03823f00, 0x00020032, 0x02d5fd73, 0x0083ff37, 0x001f0013, 0x1428403a, 0x10517f18, 0x8c1d2008, 0x05100500, 0x05400530, 0x05a00550, 0x060705f0,
	0x0f8c1705, 0xd4e12f00, 0x01e15d5e, 0x18e15d2f, 0x08204b7f, 0x23370220, 0x3231543d, 0x20203b52, 0x3032523b, 0x74233e54, 0x3f323140, 0x40313839,
	0x5133aefe, 0x82181d38, 0x998212bb, 0x68049328, 0xc705d902, 0x99820d00, 0x0940422b, 0x400e3015, 0x110e020e, 0x08ec821a, 0x091c4031, 0x1a1a4810,
	0x04010d2b, 0x020d140d, 0x0c05060d, 0x113f0c05, 0x115f114f, 0x001d1103, 0x395dcc2f, 0x012f2f39, 0x5d5dcd2f, 0x332b2f32, 0x43395dcd, 0x332f0586,
	0x07030e15, 0x36342523, 0x06061537, 0x4c1e1415, 0x013d06b4, 0x18190bb0, 0x12cf0816, 0x1f3e3830, 0x78e3fe52, 0x1f393c7a, 0x2f321f25, 0x8904453a,
	0x4a7d181e, 0x4e783809, 0x164c1f73, 0x1213182e, 0x251c1a10, 0xff004627, 0x001d00ff, 0x50b90600, 0x3a08076f, 0x49002700, 0x0000a202, 0x4c000701,
	0x00004405, 0x26403800, 0x398f0203, 0x01397001, 0x2f013940, 0x390f0139, 0xe0013901, 0x1fb0011f, 0x4baf1f01, 0x014b7001, 0x0f014b40, 0x505d014b,
	0x352005c4, 0x5005a341, 0x062107c9, 0x205992a8, 0x2259844f, 0x99254036, 0x013d2958, 0x40013d70, 0x3d0f013d, 0x4a08588f, 0x7d000200, 0x2506ecff,
	0x20001406, 0x4b003400, 0x061b2c40, 0x5b200913, 0x5b2b0101, 0xc0366709, 0x36bf0136, 0x01367001, 0x365f362f, 0x135b2102, 0x1b063566, 0x205f300e,
	0x5f260418, 0x3f00130e, 0xe1ce3fe1, 0x01393912, 0x82e1f610, 0x825d20b1, 0x2f332206, 0x065146e1, 0x030e1723, 0x084b4607, 0x02262627, 0x36123435,
	0x05bc5636, 0x14013524, 0xa956021e, 0x22232e07, 0x1706020e, 0x3f280c0e, 0x2d2b3f5a, 0xa0791851, 0xef280808, 0x51ec9ea4, 0x08193129, 0x6b34f2fb,
	0xa57272a5, 0x6a32326b, 0xa67272a4, 0x1406346c, 0x61703c16, 0xd859184c, 0xebfeaa7f, 0x0baa7918, 0x0c666f2b, 0x345d4a35, 0xdb89c9fc, 0x7fee1899,
	0xff71260f, 0x04f404ec, 0x08e982f2, 0x4a002c2d, 0x4a172c40, 0x121e1919, 0x0048270a, 0x02001000, 0x2e000007, 0x2e902e10, 0x2eb02ea0, 0x0a482104,
	0x1e122d56, 0x17502a05, 0x7a24100f, 0xc62006fa, 0x1124e988, 0x5d5e2f33, 0xec820d83, 0x860d434e, 0x853320de, 0x0bf57afb, 0x2d042308, 0x6fb27d43,
	0x477fae67, 0x6fb37c43, 0x2e3fa964, 0xc6061934, 0x3f2d100f, 0x24203956, 0x9a8900fd, 0x0383879a, 0x27026608, 0x4c91d589, 0x89d5914c, 0x4b91d388,
	0x370d4447, 0x17335d4b, 0x435e784a, 0x5e9e4114, 0xd1d3d3d1, 0x00d0d0d0, 0xb8000100, 0x4e06ecff, 0x24001406, 0x32405100, 0x08085b06, 0x9f015a23,
	0x0eb0010e, 0x010eaf01, 0x70260e0e, 0xf0268026, 0x265f0326, 0x10260001, 0x5a1b0226, 0x01256418, 0x06240d0d, 0x5f1e0319, 0x05bb4113, 0x2f333323,
	0x06bb4133, 0x5d24d382, 0xe133715d, 0x1523d285, 0x8435033e, 0x4f1120c4, 0x11220720, 0x94451133, 0x37420805, 0x34dd0411, 0xc60a203e, 0x55320f0f,
	0x85425b80, 0xc48088c9, 0xacbb4485, 0x528059b0, 0xb6050128, 0x4e3206c4, 0x47163864, 0x0f4a6982, 0xc47291fd, 0x8e4d5290, 0xae037ac7, 0xbfb048fc,
	0x51886236, 0xbd82b603, 0xffa44708, 0x047905ec, 0x002700f2, 0x1f334054, 0x0121214a, 0x271a4717, 0x29102927, 0xa0298001, 0x0329e029, 0x0001296f,
	0x30292029, 0x0f070329, 0x28540c47, 0x1f26261a, 0x120f0d18, 0x16070250, 0x3f001500, 0x3fe1333f, 0xc086c633, 0x465d5e21, 0x3322056f, 0xc08432e1,
	0x4d272121, 0xb7880770, 0x33113522, 0x0334d589, 0x190a1b75, 0x305c5245, 0x2f5c8a5b, 0x516f6ab6, 0xb61d436e, 0x9324d58a, 0x14293f2b, 0x0fd1d818,
	0xd8827b20, 0x1738653c, 0x486d8847, 0x00b0fc07, 0x8ffc0100, 0x19fed904, 0x0d002106, 0x0a401600, 0xe7180600, 0xfe3a1b9b, 0x51237919, 0xdb10404d,
	0x302e2b10, 0x1cd90416, 0x1b515853, 0x51502315, 0x49821d4c, 0x8248fd21, 0x87d12049, 0x00062549, 0x0c0f8005, 0x17c7c318, 0x1548fd25, 0x822b2e30,
	0x4d3f2b48, 0x04792252, 0x514c1df4, 0x83182350, 0xfc2c0805, 0xffd90446, 0x00e30514, 0x4038001b, 0x4c198418, 0x2842fe37, 0x1f474c4f, 0x680e302d,
	0x4a352105, 0x4d51292e, 0x2e2d1d45, 0x2b0d830f, 0x23db0449, 0x3e35232b, 0x2645613c, 0x0a198418, 0x04fd0128, 0x79feb804, 0x8d828f06, 0x12402628,
	0x0d080805, 0x05821500, 0x190f1234, 0x1902191f, 0x2f000680, 0x325dcc1a, 0x01331139, 0x0683cc2f, 0x25054d43, 0x27230707, 0xba4b033e, 0x06580805,
	0x36363507, 0xfe163233, 0x3c2d1b79, 0x0e710a22, 0x172a3c25, 0x1d322415, 0x1010341c, 0x85852932, 0x3a27d305, 0x6f071b29, 0x181006b0, 0x20181821,
	0x03030713, 0x5b05036c, 0xfd010000, 0xfe98fe31, 0x007dff06, 0xb50f000d, 0x0b008708, 0x2f000391, 0xe12f01e5, 0x34053031, 0x08050e4c, 0x23020e20,
	0x31fd2622, 0x3f2b2d3e, 0x15271d11, 0x3cf63e2d, 0x1d3c3737, 0x370e1c2b, 0xc700ffff, 0xbd180000, 0xc92a2c51, 0x10050000, 0x26027307, 0x7e82b201,
	0x43000734, 0x52014200, 0x01b41500, 0x01260518, 0xb4a3ffb8, 0x5818181e, 0x5f820995, 0xecff712a, 0x2106e103, 0x48002602, 0x06242f82, 0x00944300,
	0x02202d82, 0x1633b318, 0x0000ae24, 0x2d833b04, 0x85d20121, 0x83ca202d, 0x0c01222d, 0x215b8511, 0x49180c12, 0x5f080ca1, 0x07ecff7d, 0x00c9055e,
	0x40710045, 0x39041448, 0x36c5255a, 0xa6369601, 0x36890236, 0x1d363601, 0x670c5b41, 0x10470047, 0x47000247, 0x47504720, 0x47d04770, 0x070647e0,
	0x661d5b2e, 0x33373746, 0x035f2900, 0x22072626, 0x09201404, 0x3c14480e, 0x18115f33, 0x333f0013, 0x2b3232e1, 0x1133333f, 0x12260882, 0x10012f39,
	0x5418e1f6, 0x5d21090e, 0x2315825d, 0x01303139, 0x11215218, 0x23272626, 0x22230606, 0x6a0b0746, 0x14290743, 0x3233021e, 0x33113736, 0x0abe5c11,
	0x3c687708, 0x3b4c2a5e, 0xb777518f, 0x813f407d, 0xaa6f88c6, 0xa84b0249, 0x81c6886e, 0xb77d403f, 0x3b8f5177, 0x3c5f294c, 0x2b507145, 0x5c8a5c2e,
	0xbb2e7639, 0x5c3b762e, 0x2c2e5c8b, 0x25057150, 0x2a9c202e, 0xfeb8632c, 0xfeaaa6f8, 0x3277d2df, 0x77323030, 0xaa2101d2, 0xb80801a6, 0x9c2a2c63,
	0x8a462e20, 0xe58d88cf, 0x262459a4, 0x43febd01, 0xa4592426, 0xcf888de5, 0x3b4c468a, 0xf4053a05, 0x2c004a04, 0x0940e700, 0xc9011065, 0x0222f922,
	0xf0ffb821, 0x48100ab3, 0x2107832c, 0x07841b12, 0x0a19403a, 0x1000480f, 0x26481b0a, 0x210e220d, 0x002c1522, 0x660f5606, 0x0e0f020f, 0x49082582,
	0x0e1f4840, 0x7f0e6f01, 0xdf0e9f0e, 0x0e59040e, 0x010e4f01, 0x6b011574, 0x15240115, 0x24021534, 0x44063406, 0x94067406, 0x060e0506, 0x060e1515,
	0x471b0103, 0x1c101c00, 0x1c1c0702, 0x202e102e, 0xd02e302e, 0x052ee02e, 0x4c830102, 0x26011e2a, 0x481d1540, 0x140c2026, 0x22086d82, 0x0e1b0310,
	0x06150f01, 0x06360626, 0x00220602, 0x323f0015, 0x33115d32, 0x1733333f, 0x012b2b39, 0x8233382f, 0x5e2f2a0d, 0x1712e15d, 0x2f2f3d39, 0x068e4c18,
	0x84715d21, 0x11332618, 0x12113333, 0x36298239, 0x315d2b2b, 0x01215d30, 0x16161333, 0x033e3317, 0x33031337, 0x83031e13, 0x3598080a, 0x02021433,
	0x03230706, 0x0e352626, 0x01030703, 0xbc89fe77, 0x09261ce0, 0x1a150707, 0xa2770f1d, 0x1f0cc9bc, 0x0705181e, 0x1941725a, 0x9a5c25b7, 0x0c77c075,
	0x0906010d, 0x0498040a, 0x5756fd4a, 0x3a16339d, 0x01204541, 0xfdcf010c, 0x676321b0, 0xd067195c, 0xa398ffe2, 0xf5fedffe, 0x54017ffc, 0x01033520,
	0x0a1d1b13, 0x0000aafe, 0x00140002, 0x06bc0400, 0x00160014, 0x409b0021, 0x1700130a, 0x15150c5a, 0xb80c1006, 0x0d40c0ff, 0x2048271a, 0x9002010c,
	0x020ca00c, 0xb3231183, 0x84481813, 0x40440819, 0x0c480e0b, 0x5b1b0e0c, 0x00236706, 0x50233023, 0x80236023, 0x23e00523, 0x01239f01, 0x0e012350,
	0x16005f21, 0x13105f0d, 0x0100b010, 0x4f010089, 0x100f0100, 0x10000701, 0x00111000, 0x120c6017, 0x3fe13f00, 0x2005234f, 0x06db6a5d, 0x01e11023,
	0x370b822f, 0xe1f61071, 0x2b2f3911, 0x715f5d2b, 0x3912332b, 0x32e1102f, 0x01303132, 0x2a07064f, 0x21112123, 0x33112135, 0x82152111, 0x50322005,
	0x3808056a, 0x960a0223, 0x377ecf98, 0x86c27e3c, 0xc4fe96fe, 0x01ba3c01, 0xa087fe79, 0x5b2ea4ae, 0x03815d8b, 0x9871424e, 0x709e6157, 0xa460043d,
	0xf0fe1001, 0x8440fca4, 0x3c614688, 0x0601411b, 0x27056d32, 0x21001400, 0x09408100, 0x47160213, 0x010c0010, 0x472ce684, 0x0c481a0d, 0x0e000c00,
	0x5706471c, 0x103fe882, 0x23700223, 0x23c02390, 0x0e0423e0, 0x01025015, 0x1310500d, 0x1f020f10, 0x40020202, 0x82481e0c, 0x100f34e3, 0x0702101f,
	0x10021002, 0x3001117f, 0x16110111, 0x82150c50, 0x85db82ed, 0x2b7122ef, 0x0916505d, 0x1220ed83, 0x2b221783, 0xe785335d, 0x3230de82, 0x0e141516,
	0x11212302, 0x35333523, 0x01211533, 0x09684518, 0xfee30232, 0xd31501d5, 0x9f652fcd, 0xee39fe71, 0x2b01b6ee, 0x042c1082, 0x26435e37, 0x40604121,
	0xd7feb003, 0x08cb4618, 0x18dddd21, 0x080e7545, 0xecffc737, 0xcb05ec06, 0x58002d00, 0x05082f40, 0x07221b5b, 0x22071111, 0x2a2a1e03, 0x5a1d212f,
	0x2b2e641e, 0x04275f00, 0x5f1c081b, 0x210f0522, 0x21210801, 0x121e031f, 0x2867180d, 0x393f2308, 0x796c5e2f, 0xe13f3205, 0xf6100133, 0x331132e1,
	0x17122f7d, 0x2f2f1839, 0x6cbf822f, 0x1e2c0983, 0x36323303, 0x030e1537, 0x26262223, 0x0c954418, 0x07171627, 0x6d052626, 0x3367185f, 0x75230809,
	0xa05971ac, 0x564e274e, 0xeb9e3a61, 0xfe05529d, 0x01babab0, 0xa7630e56, 0xc46c95e9, 0x953f4e4f, 0x18412705, 0x080e3b67, 0x01b8644a, 0x56fd9f03,
	0x98fdb605, 0x5ca7eb8f, 0x209c2a2c, 0x0100002e, 0xecffae00, 0x5e047105, 0x64002900, 0x1d203940, 0x0c4f0548, 0x0c1f0c01, 0x1427081f, 0x070b2b14,
	0x2a540847, 0x1115511a, 0x06052010, 0xa90c1d50, 0x020bb90b, 0x2906f459, 0x090b0b06, 0x2315080f, 0x5b4f2651, 0x843f2005, 0x21ec86eb, 0xec88e133,
	0x39123322, 0x5d20ed83, 0x0522ed84, 0xdb8f2e22, 0xf1822e20, 0x6d070621, 0x043c0b7a, 0x81a96154, 0xf1fe074f, 0x1301b6b6, 0xa581550c, 0x32954e5e,
	0x3c381736, 0x918c193b, 0x07d84218, 0x3682523b, 0x3a147c35, 0xfe87c17b, 0xfe4a0417, 0x72b58039, 0x9a192234, 0x090f130a, 0xde421897, 0x00002308,
	0x00820002, 0x2f054908, 0x0b00b605, 0xae001800, 0x06084940, 0xe806d801, 0x07070206, 0xe707d701, 0x07a60207, 0x01019b01, 0x00a70077, 0x090a0d02,
	0x0704030c, 0x08131306, 0x000100a7, 0x09050101, 0x00010800, 0x20081008, 0x80087008, 0x0608c008, 0x4f080b82, 0x1a901a08, 0x1a021aa0, 0x40c0ffb8,
	0x4818150f, 0x40011a8f, 0x1a0f011a, 0x05040801, 0x40f0ffb8, 0x030b0513, 0x0a10135f, 0x0c13480e, 0x0004060c, 0x03061209, 0x333f3f00, 0x2f391233,
	0x32e12b39, 0x33382f01, 0x5d5d5d5e, 0x33115d2b, 0x715d382f, 0x33251783, 0x3d39115d, 0x2322832f, 0x39391239, 0x5d2d1c82, 0x31715d71, 0x11232130,
	0x01230123, 0x08038233, 0x21272395, 0x27032e27, 0x0207030e, 0xfe7fa6ec, 0x3902c5fe, 0xc73b02bb, 0xe87afefe, 0x12352301, 0x0711161c, 0x19151109,
	0xfdaa0211, 0xfab60556, 0xa4aa024a, 0x434c308f, 0x41252541, 0x002d4943, 0x0a000200, 0x5a040000, 0x0b004a04, 0xcf001700, 0x02393840, 0x02790259,
	0x1b040289, 0x02022b02, 0x960105b5, 0x0205a605, 0x09010587, 0x02031903, 0x08160806, 0x19120902, 0x11060212, 0x07021116, 0x11020312, 0x00b60908,
	0xffb80001, 0x0a1b40f8, 0x0bb9480f, 0x82080b01, 0x0b003607, 0x0c010cb4, 0x0605050c, 0x10010a06, 0xffb80102, 0x1512b3c0, 0x08078348, 0x07184037,
	0x0101480b, 0xe019c019, 0x19af0219, 0x01195001, 0x191f190f, 0xb80a0902, 0x0f40f0ff, 0x5008040a, 0x11110b0c, 0x0a0f0b01, 0x00150106, 0x3f33333f,
	0x122f3912, 0x05234139, 0x00825d20, 0x2f331126, 0x38332b2b, 0x332e1582, 0x2f3d3912, 0x2b33335d, 0x125d2b5d, 0x02823939, 0x1f825e20, 0x31290283,
	0x015d5d30, 0x23032301, 0x08018211, 0x0123032b, 0x07030e17, 0x27032e33, 0xb401a602, 0xa260bbbc, 0x01bdba60, 0x1b0571b4, 0xf00d2523, 0x1b23250e,
	0xfb4a0404, 0xfee901b6, 0x3f038317, 0x19794a04, 0x225e6055, 0x54605f22, 0x02000019, 0x0000c700, 0xb6052907, 0x20001300, 0x1b40bf00, 0x27081a42,
	0x15050e06, 0x03141112, 0x05263e82, 0x0e0f0100, 0xc383051b, 0x805d6208, 0x1bcb0101, 0x011b8401, 0x1b7b1b2b, 0x1f050f02, 0x7f052f05, 0xdf05cf05,
	0x0705ff05, 0x1b010508, 0x0305011b, 0x00101011, 0x70101010, 0xf010b010, 0x10100510, 0x50223022, 0xd022c022, 0x0522e022, 0x095a080c, 0x06132164,
	0x1b0d5f03, 0x48100920, 0x0e14141b, 0x11010409, 0x030e0a12, 0x3f333f00, 0x06374233, 0x32e13336, 0xf6100132, 0x115d32e1, 0x385d2f33, 0x3d391733,
	0x2f2f182f, 0x24050441, 0x33331138, 0x23018311, 0x11393912, 0x06820282, 0x425d5d21, 0x2122083e, 0x1c822311, 0x42132121, 0x042f0d46, 0xfe81a5e7,
	0x0801c4fd, 0xbaba7ffe, 0x42f1c101, 0x792a054d, 0x352301e9, 0x11151c13, 0x4d420808, 0x05514207, 0x0298fd23, 0x13554268, 0x00ae3c08, 0x04080600,
	0x0013004a, 0x40eb001f, 0x0105a531, 0x05960586, 0x01057702, 0x09160906, 0x29021902, 0x69024902, 0x05027902, 0x1a01020b, 0x08190203, 0x0b120914,
	0x0d110a13, 0x42c60e47, 0x1728064e, 0xc9480f0a, 0x08130113, 0x00290782, 0x0114c413, 0x05051414, 0x05254206, 0x0a2f1332, 0x0aaf0a3f, 0x0a060a03,
	0x540e0106, 0x10010220, 0x080c6242, 0x0b072c3d, 0x21010148, 0xbf0121d0, 0x21600121, 0x21902170, 0x01214f03, 0x08012100, 0x5008040b, 0x19131412,
	0x130f0219, 0x06090e0f, 0x3f001502, 0x3f333333, 0x2f391233, 0xe1333912, 0x41013232, 0x1131053e, 0x2b2b2f33, 0xe6103338, 0x2f393911, 0x33385d2f,
	0x0b6d4211, 0x32e11024, 0x54411211, 0x43112005, 0x5d23059b, 0x4230315d, 0x13200a71, 0x20076041, 0x06794217, 0x42540421, 0xc3280879, 0xb6b6e9fe,
	0x70b55401, 0x42167f42, 0xfe280583, 0x79c70139, 0x5f605419, 0x08098742, 0x00001424, 0xb6056a05, 0x26002300, 0x1140c000, 0x86012286, 0x1259011a,
	0x25021289, 0x480c0910, 0xf0ffb826, 0x08822c40, 0x0a255208, 0x2424060b, 0x261b5a1a, 0x100a0007, 0x030a200a, 0x07071b0a, 0x00030a1b, 0x20111012,
	0x11d00211, 0x90118001, 0xb8110211, 0x3b40c0ff, 0x11480a07, 0x281f2811, 0x0128f001, 0x28df28cf, 0x50284002, 0x03287028, 0x283f280f, 0x00230702,
	0x24611c19, 0x2305190b, 0x0a002d0a, 0x085f2607, 0x00121b03, 0x323f0012, 0x2b073d55, 0x33715d5e, 0x0132e133, 0x5d5e332f, 0x71200082, 0x2105e75a,
	0xc15a3371, 0x10240808, 0x2f3d39e1, 0x33113333, 0x5d5d2b2b, 0x335d3031, 0x37033e13, 0x15213501, 0x17031e01, 0x2e032313, 0x11232303, 0x59080182,
	0x07020e22, 0x21010103, 0x36187b14, 0xfe5f7c54, 0xfe490490, 0x56806185, 0xbe7a1837, 0x3626147b, 0xbb183d4f, 0x364f3d18, 0x017b1426, 0xfd4a01eb,
	0x55c5016f, 0x063a6288, 0x8b8be701, 0x380619fe, 0xfe568962, 0x48c1013b, 0xfd17395f, 0x17b80248, 0xfe485f39, 0x015a033f, 0xef4400b8, 0x04e53506,
	0x0023004a, 0x40c70026, 0x861a760d, 0x031a961a, 0x0c071025, 0x20053d41, 0x3c088218, 0x06011209, 0x060b0123, 0x461a2424, 0x260a251b, 0x011ba707,
	0xc0ffb80a, 0x19161040, 0x08484148, 0x01112023, 0x06d64411, 0x40280783, 0x480b073f, 0x10281111, 0x08064341, 0x9028602e, 0x281f0228, 0x2302284f,
	0x26070a00, 0x1c190850, 0x26241652, 0xa6243624, 0x0b240424, 0x061f060f, 0x065f064f, 0x06060704, 0x121b0f08, 0x2005034b, 0x0518483f, 0x32e15d29,
	0x3232e110, 0x41332f01, 0x2b200748, 0x25074741, 0x33115d2b, 0x4a413311, 0x5d5d2606, 0x315d2b2b, 0x1d484130, 0x21135308, 0x2c167b0a, 0xfe536742,
	0xfecf03ce, 0x436853c9, 0xba7b172c, 0x3024147b, 0xa6043544, 0x30463504, 0x017a1425, 0x0afefcb4, 0x653d5401, 0x0109314d, 0xfe696964, 0x4c31089c,
	0xacfe3d67, 0x48365001, 0xf6fd112b, 0x2b110a02, 0xb0fe3648, 0x2d018302, 0x11450000, 0x89240805, 0x2800b605, 0xca002b00, 0x1f861540, 0x89175901,
	0x0b100217, 0x5a1f2929, 0x09102a20, 0xb82b480c, 0x3340f0ff, 0x2a3c0882, 0x000c2b0f, 0x200f100f, 0x0f07030f, 0x0c20200c, 0x2816030f, 0x00c000b0,
	0x1f000f02, 0x4e084b82, 0x00170700, 0x02161016, 0x16801670, 0x160316c0, 0x40c0ffb8, 0x480a0734, 0xe02d1616, 0x2d9f012d, 0x40022dbf, 0x2d2f012d,
	0x5a060a01, 0x0f2c6407, 0x0d5f2b0c, 0x6121051e, 0x0b0f1029, 0x0b0b0801, 0x07030d08, 0x00032017, 0x173f0012, 0x41333f32, 0xe1210543, 0x05434132,
	0xe1f61023, 0x07344632, 0x21055647, 0x93425d5d, 0x5d5e2706, 0x33113311, 0x4d412b2b, 0x30312608, 0x36361321, 0x06b94337, 0x371a9a42, 0x137b3302,
	0x7bfe1c29, 0xa402baba, 0x4a0495fe, 0x806185fe, 0x7b183755, 0x23069f42, 0x3c19ba19, 0x220c9f42, 0x492e7344, 0x01210565, 0x22a342dd, 0x0000ae38,
	0x4a049806, 0x2b002800, 0x0d40cf00, 0x1f861f76, 0x2a031f96, 0x53410710, 0x822c2006, 0x09280808, 0x0b100117, 0x461f2929, 0x2b0f2a20, 0x0120a70c,
	0x0c0c200f, 0x16030f20, 0x002f001f, 0x0100ff02, 0x17070000, 0x16011620, 0x8306a242, 0x403a0807, 0x480b073f, 0xcf2d1616, 0x2db0012d, 0x012d9f01,
	0x4f012d60, 0x2d00012d, 0x0a022d30, 0x54074706, 0x2b0c0f2c, 0x051e0d50, 0x29a65221, 0x0f102901, 0x020b1f0b, 0x080b0b07, 0x4b820f0d, 0x15000322,
	0x200b5f41, 0x0f60415d, 0x115d5d2d, 0x2b2b2f33, 0x39123371, 0x43715d2f, 0xac4208f5, 0x2b2b2209, 0x2660415d, 0x0121133a, 0x1d107bbc, 0xb6edfe13,
	0xfe0b02b6, 0xfece03d5, 0x436853c9, 0xbb7b172d, 0x2409b742, 0x14243145, 0x06b7427b, 0x204b2a22, 0x2105ef49, 0xbb425e01, 0x018f0820, 0x46fe3900,
	0xd506ec03, 0x9f007600, 0x18212740, 0x59480e09, 0x4d515962, 0x3b51474d, 0x516c675b, 0x67354467, 0x67145114, 0x05443551, 0x725b2e24, 0x5a057867,
	0xc0ffb824, 0x18143640, 0x525d2448, 0x9f568f4d, 0x0356af56, 0x0b074056, 0x47565648, 0x4f60346c, 0x350f0135, 0x080235af, 0x43293535, 0x40036251,
	0x15034761, 0xfb1f5f0a, 0x13006029, 0x3fe13f00, 0xe13f33e1, 0x39123317, 0x715d5e2f, 0x331139e1, 0x335d2b2f, 0x2b2f01e1, 0x4ef610e1, 0x182105e3,
	0x2800822f, 0x10391211, 0x333311e1, 0x2503832f, 0x2b003031, 0xaf5c2205, 0x023e2707, 0x021e3233, 0x866b1517, 0x77232005, 0x2e6d0850, 0x23232205,
	0x098f5635, 0x2707062b, 0x2e373636, 0x33352703, 0x056b6d16, 0x5b171621, 0xcb6207ac, 0x3c5f1805, 0x012d0807, 0x345a47e1, 0x3d240e14, 0x5361412f,
	0x422b3251, 0x080c2331, 0x354d361f, 0x5c4a4731, 0x4f886846, 0x9d663120, 0x5180596c, 0x91673926, 0xbc6b1858, 0x3b80080d, 0x371867a6, 0x79143236,
	0x1a366133, 0x2a4b433b, 0x0b0e2f1f, 0x30161122, 0x52142e30, 0x332b557e, 0x574b7d5b, 0x43325e8a, 0x1214c483, 0x16182920, 0x040e1a24, 0x0a070404,
	0x07b6070f, 0x030c1012, 0x48290203, 0x623c3760, 0x48262646, 0x65474469, 0x27971d3f, 0x363e6448, 0x431e3a53, 0x4b307d36, 0x3f411e11, 0x221b173a,
	0x46243861, 0x05092338, 0x17070577, 0x0d213829, 0x45765c3f, 0x3958774a, 0x0a2e6c18, 0x01008008, 0x73fe1700, 0x52055203, 0xb7007000, 0x18407140,
	0x68480e09, 0x036c6268, 0x586c030c, 0x6c161146, 0x015fe011, 0x3311525f, 0x6c11336c, 0x43055f52, 0x571c474d, 0xd072c072, 0x0372e072, 0x3001727f,
	0x720f0172, 0x46260701, 0x110c4043, 0x16164348, 0x52895051, 0x0f025299, 0x52080152, 0x68486252, 0x40005207, 0x00481410, 0x480c0740, 0x006c5e00,
	0x0c505b03, 0x2b341062, 0x48fb3e50, 0x41162150, 0x333806e2, 0x2f3317e1, 0x33e12b2b, 0x2f391211, 0xe15d5d5e, 0x012f3d39, 0xe12b2f18, 0x5d210b82,
	0x0cea415d, 0xeb415d20, 0x0a356e10, 0x41067264, 0x232007a6, 0x200c0542, 0x15044216, 0x098b6d18, 0x52232621, 0x024205bf, 0xcf02300a, 0x0b0e2f1f,
	0x2e151121, 0x37132d2e, 0x18233f59, 0x080b045e, 0x2f594b53, 0x3a220e0f, 0x5d63322c, 0x47422153, 0x2822090d, 0x5520132c, 0x58396f64, 0x22184070,
	0x376e9056, 0x852c4c64, 0x3d61818a, 0x73274864, 0x4b81476c, 0x416b393f, 0x2c303117, 0x62337912, 0x433a1a36, 0x0952054b, 0x07057705, 0x1f332615,
	0x5845310e, 0x365e1835, 0x5b3a0808, 0x5674443d, 0x261a0e31, 0x18231617, 0x0304030d, 0x0a971316, 0x03060a0f, 0x472e0303, 0x592f2956, 0x2b132a46,
	0x5b5e3345, 0x40271299, 0x264d4d2d, 0x221c9322, 0x373b1c08, 0xfa411532, 0xffff3907, 0x00006800, 0xb605ba05, 0x75010602, 0xffff0000, 0x14fea400,
	0x12067105, 0x47080f82, 0x00000095, 0xff7d0003, 0x057105ec, 0x001300cd, 0x0029001e, 0x2532404f, 0x67005b19, 0x012bd02b, 0x80012bcf, 0x2b3f012b,
	0x24022b6f, 0x660a5b1a, 0x4f601a2a, 0x240f0124, 0x24df24af, 0x24240803, 0x0f5f1f14, 0x055f1404, 0x2005a543, 0x05a04312, 0x2205524b, 0x745d5d5d,
	0x02200725, 0x200efc53, 0xdd851816, 0x032e240e, 0x59517105, 0x9a3e0afa, 0xfd51a0ec, 0x6b9e6a87, 0x9afc0639, 0x9e6b3a06, 0x6c9c696d, 0x6403083d,
	0x9b693b08, 0xf559dd02, 0xc56b370e, 0x07fdebfe, 0x7ac28647, 0x4786c27a, 0x80439a04, 0xb87575b8, 0xd9834380, 0xecff7126, 0x5e042d04, 0x1a22d982,
	0xd9822100, 0x1f333008, 0x57004817, 0xd0234023, 0x0323e023, 0x1e01230f, 0x560a4818, 0xef501822, 0x1ea9011e, 0x0f021eb9, 0x2f1e1f1e, 0x1e06031e,
	0x501b141e, 0x5914100f, 0xe12006fe, 0x5d21da84, 0x05814f5d, 0x0e21d989, 0x094b4402, 0x01021e2f, 0x21373632, 0x22131616, 0x26210706, 0x0df45926,
	0x7fae6734, 0x8d23fe47, 0xbefd0a88, 0x898c8c09, 0x3e020e88, 0xef598a0d, 0x914b250d, 0xb2d4fdd3, 0x03290082, 0xa4a4a244, 0x010000a2, 0x08008200,
	0x05020522, 0x001c00c3, 0x0729405a, 0x010d0b06, 0x0d010dfb, 0x1990080d, 0x190219d0, 0x1e001e19, 0x011eb001, 0x2208b485, 0x1e5f1e4f, 0x07061e7f,
	0xffb80809, 0x080c40f0, 0x04166000, 0x0d030809, 0x00120706, 0x3f33333f, 0x4fe13f33, 0x712c0626, 0x5d2f3311, 0x2f3d3912, 0x3333715d, 0x2e062d51,
	0x33012301, 0x17161601, 0x13373636, 0x7133033e, 0x3c080583, 0x35249604, 0xfe12242a, 0x19fecdd7, 0x1d2701c5, 0x2a0e112e, 0x3d1f8d1a, 0x234b674c,
	0x35171a44, 0x48252d05, 0xe9fb4267, 0x61fcb605, 0x4e4faf5b, 0x000261bc, 0x2b629c71, 0x0997080d, 0x33bf860d, 0x52040e04, 0x6d001f00, 0xff1e00b9,
	0x0a1640f8, 0x081f480e, 0x2b080483, 0x0d20071e, 0x07074811, 0x0116e000, 0xe0ffb816, 0x0a071a40, 0x21161648, 0x21cf21bf, 0x500321ef, 0x210f0121,
	0x214f212f, 0x00010703, 0x0030d084, 0x151f071e, 0x0f134f1a, 0x000f0001, 0xe13f323f, 0xd086d482, 0xd0825d20, 0xd1842b20, 0x33332b27, 0x30312b2b,
	0x07c75411, 0x4208cc8a, 0x07062223, 0xc9bc2303, 0x1a1f200b, 0x14040605, 0x56091918, 0x58433519, 0x11221a3c, 0x2f12260b, 0xf3e0183a, 0xa2fd4a04,
	0x616e6a21, 0x6c5f1919, 0x40012167, 0x1842755e, 0x03870505, 0xfc585005, 0x41ffffdf, 0x0725058f, 0x02260273, 0x38de8280, 0x04760307, 0x005201b8,
	0x0102b619, 0x0226051d, 0x82ffb801, 0x081d31b4, 0x05d35f19, 0x35352b23, 0x23338500, 0x21060e04, 0x81203382, 0x50203386, 0x33834782, 0x84112021,
	0xb4942533, 0x16002034, 0x45083389, 0x7d000300, 0x5a0914fe, 0x1300cd05, 0x4a002700, 0x0a40a100, 0x381e5b00, 0x372f2f4a, 0xffb82829, 0x282340f0,
	0x40004028, 0xf0024010, 0x401f0140, 0x403f402f, 0x011e0003, 0x401e401e, 0x1037360a, 0x37e037d0, 0x064a3702, 0x0b2f0805, 0x4c373748, 0x0f014c0f,
	0x2f4c1f4c, 0x7f4c4f4c, 0xdf4cbf4c, 0x084cef4c, 0x0a5b1407, 0x2f384b66, 0x44284a4a, 0x361b3d50, 0x5f230f28, 0x4319040f, 0x3f2607ca, 0x11e13f33,
	0x6d181139, 0x8e4c0725, 0xc1382605, 0x2f393912, 0x06554b2f, 0x3d280d83, 0x1033332f, 0x013031e1, 0x57053464, 0x16230ae0, 0x5d140512, 0x25200de6,
	0x24099341, 0x030e0133, 0x0a206923, 0x05374808, 0xdd964c1f, 0x93e09891, 0xe1934747, 0x95dd9099, 0x2f23fc4c, 0x67679661, 0x2e2e6096, 0x68679460,
	0x042f6197, 0x0dd7bd43, 0x0413191d, 0x1b170406, 0xbcc70b1d, 0x401d4efe, 0x34507456, 0x40151b4c, 0x34463023, 0x44390f25, 0xab20141c, 0x080e0e5e,
	0x9bfde396, 0x53585828, 0x61561922, 0x6302215e, 0x815127fb, 0x060b315a, 0x17070591, 0xa029402c, 0x00ffff00, 0x0814fe71, 0x005e044e, 0x00520026,
	0x00070100, 0x006f045c, 0xb1110000, 0x04b80202, 0x2f20b414, 0x0125000a, 0x3500352b, 0x00020000, 0x0583ff7d, 0x003106c3, 0x003f001f, 0x30334052,
	0x4167005b, 0x41c441b4, 0x01419002, 0x80413002, 0x5b200241, 0x19406610, 0x180b0118, 0x14080401, 0x38070208, 0x1b5f3b35, 0x28031518, 0x05085f25,
	0x3f00120b, 0x32e13333, 0x322b0484, 0x5d5d5d5e, 0xe1f61001, 0x775d5f5d, 0x142706dc, 0x0607020e, 0x65222306, 0x372d0770, 0x32333636, 0x031e1716,
	0x021e1405, 0x08555f17, 0x022e3423, 0x08268527, 0x05030e95, 0xc58949c3, 0x374a0e7c, 0x810d483b, 0x454587c7, 0x0d81c787, 0x4a373b48, 0x89c57b0e,
	0x2d7ffb4a, 0x11537f57, 0x45313543, 0x57805211, 0x80572d2d, 0x31461052, 0x53114335, 0x022d577f, 0xc0fc95dd, 0x363f177d, 0x7d163f36, 0x9696fec0,
	0x177bbffb, 0x3d33313f, 0xfbbf7d17, 0x92c07496, 0x26301562, 0x62152e28, 0x7374c092, 0x166292bf, 0x30292932, 0xbf916116, 0x00020000, 0x0491ff71,
	0x00b604a8, 0x0037001f, 0x482cb554, 0x39395700, 0xb3c0ffb8, 0x8348140e, 0x24402907, 0x20480c09, 0x38561048, 0x2f0b0d41, 0x50352f32, 0x0f15021b,
	0x50232629, 0x160b0508, 0x41050e41, 0x2b240e0f, 0xe1f6102b, 0x4106215c, 0x1620160d, 0x24060c41, 0x34353636, 0x060b4126, 0x06064808, 0x6b39a804,
	0x3c095f99, 0x083b3a38, 0x3d6e995d, 0x629a6c39, 0x373a3b08, 0x985b093d, 0x85fc3c6d, 0x390b7b6f, 0x0c393234, 0x786e6d79, 0x3432390c, 0x6f7b0b39,
	0xbf762702, 0x39125a8e, 0x12382d2e, 0x77c08e5a, 0x828dbf75, 0x29e8080d, 0x5b123a2a, 0xac75bc8d, 0x202c1fcd, 0xcc1f2a20, 0x20c8a9ab, 0x2d20202b,
	0x0000c81f, 0xff7d0003, 0x083507ec, 0x0045003d, 0x006d005b, 0x379240da, 0x14042414, 0x03241404, 0x0c5b411c, 0x6f006f67, 0x00026f10, 0x506f206f,
	0x906f806f, 0xd06fa06f, 0x086fe06f, 0x661c5b2d, 0x4768636e, 0x51685c47, 0x52505240, 0x52035260, 0x68005f52, 0x68206810, 0x68906880, 0xe0680705,
	0xbf4d014d, 0x0256cf56, 0x46ef5256, 0x47474601, 0x5201524f, 0xc06b6052, 0xe06bd06b, 0x6f6b046b, 0xaf5f7f5f, 0x045fef5f, 0x5f015f10, 0x115f3c32,
	0x8f377f14, 0x40370237, 0x37480a07, 0x13111737, 0x28030325, 0x07215f00, 0x333f0004, 0x113332e1, 0x33333f33, 0x335d2b2f, 0x2f32e110, 0x5dcc5d5d,
	0x33712f32, 0x105dcd10, 0x5dcd5ddd, 0x5d5e2f01, 0x5d2c1d82, 0x32cd10cd, 0x1039112f, 0x715de1f6, 0x210a7a49, 0xe05b3311, 0x0ee24716, 0xdf5b1720,
	0x023e220c, 0x05fc7237, 0x2e34353e, 0x23150302, 0x23022e22, 0x15150622, 0x36343523, 0x021e3233, 0x06140533, 0x36363507, 0x12841e83, 0x3f051622,
	0x250e025c, 0x4745a267, 0x015c67a0, 0x562a2916, 0x1717424e, 0x2a564e42, 0x3d06045c, 0x90561003, 0x2e2a647a, 0x6d7c853a, 0x8577703a, 0x78effe4e,
	0x1f383c79, 0x2e321f24, 0x225c443b, 0x2c2a2310, 0x225c2a2c, 0x23132816, 0x2f1c1c2f, 0x5c591323, 0x022b0622, 0x2a2481a6, 0x10352d24, 0x82656b23,
	0x4de22708, 0x164c1f73, 0x0664192d, 0x268b0805, 0x00030046, 0x05ecff71, 0x000807df, 0x00590043, 0x40b2006c, 0x4567606b, 0x4f675a45, 0x50505040,
	0x5d505002, 0x679f676f, 0x01671002, 0x0b152467, 0x03033f35, 0x3f482c0b, 0x481e6e57, 0x006d560b, 0xdf4b014b, 0x50540154, 0x4401440f, 0x506f4545,
	0x00505001, 0x6ae0016a, 0x6a026af0, 0x5d7f5d0f, 0x2f5d0702, 0x1634511b, 0x10103a16, 0x00512921, 0x10402403, 0x40244815, 0x24480c07, 0x16000624,
	0x32323f00, 0x332b2b2f, 0x5d32e110, 0x2f2506a6, 0x5dcc5d5e, 0x05e14171, 0xdd107129, 0x0171cd5d, 0x82e1f610, 0x39122b02, 0x39122f3d, 0x18333912,
	0xf1415d2f, 0x3031230b, 0x3d432205, 0x022e2305, 0x384d3435, 0x2e072306, 0xb56e2303, 0x37362106, 0x08be7818, 0x5e182220, 0x13200dc4, 0x2318d841,
	0x042e3435, 0x0805d741, 0x5110043d, 0x6a2b2b6d, 0x7fa95f50, 0x936d3f4a, 0x3c401f54, 0x113f1434, 0x122b2b29, 0x888d6970, 0x16297349, 0x29423931,
	0x70698c85, 0x292b2b12, 0x35144011, 0x54203f3c, 0x4a3f6d93, 0x413aa97e, 0x862507d5, 0x70396e7c, 0x05d54178, 0x150f742e, 0x320f151a, 0x14443b2e,
	0x23202023, 0x07955b18, 0x16100939, 0x130a9a0c, 0xd3ca090f, 0x2034c3d3, 0x0e181e10, 0xcad3d3c3, 0x18130f09, 0x2e09355f, 0x3f89d596, 0x2482aa06,
	0x342e242b, 0x416c2311, 0x340808cf, 0x0f0d3329, 0x170f0a0c, 0x46262612, 0x00020000, 0x07ecff7d, 0x0004075e, 0x0053000d, 0x2362409b, 0x335a4712,
	0x960144c5, 0x0244a644, 0x44014489, 0x5b4f2b44, 0x081d821a, 0x1a2b0d47, 0x55005567, 0x00025510, 0x50552055, 0xd0557055, 0x0655e055, 0x2b5b3c07,
	0x45455466, 0x5f370e41, 0x09341130, 0x80000404, 0x023f060a, 0x02cf027f, 0x02ef02df, 0x15340205, 0x234a0430, 0x480e0920, 0x1f5f4123, 0x05695f26,
	0x3f322b32, 0x5d2f3333, 0xcd1a3333, 0x11332f39, 0x32e11033, 0x550a735f, 0x10250557, 0x2f3911e1, 0x08795f5d, 0x23071524, 0x03862327, 0x875f3520,
	0x528b2d42, 0x31b83222, 0x32b83123, 0x1c035022, 0x5f0e9143, 0x07242b94, 0x67ac1b04, 0xac230082, 0x5f21fe1b, 0x00203a9e, 0x2a05795a, 0x00a405f4,
	0x013a000d, 0x820d4023, 0x2a0d2907, 0x0130b90f, 0x2f013082, 0x2006a55f, 0x2207833a, 0x83481b13, 0x19402907, 0xa9480f0a, 0x100e010e, 0x0e211082,
	0x280c8210, 0x341c1b30, 0x1d011d66, 0x0825821c, 0x0f534054, 0x3f1c1f1c, 0x1c4f031c, 0x1c7f1c6f, 0x1cbf1c9f, 0x341c1c05, 0x90232f30, 0x23740123,
	0x01236b01, 0x23342324, 0x140e3a02, 0x24013490, 0x44143414, 0x94147414, 0x34230514, 0x23341414, 0x47290f03, 0x2a102a00, 0x2a2a0702, 0x203c103c,
	0x033c303c, 0x57830f10, 0x410f3521, 0x300806e5, 0x027f020f, 0x029f028f, 0x14400204, 0x34024817, 0x481d1540, 0x140c2034, 0x1e341b48, 0x1c290e03,
	0x14230f0f, 0x14361426, 0x0e301402, 0x333f0015, 0x05c75f33, 0x39171226, 0x2b2f2b2b, 0x2007fc41, 0x0fd25f01, 0x825d2f21, 0x53332027, 0x33310598,
	0x2f183311, 0x3338715d, 0xc0c0875d, 0x5d2b2b01, 0x2903822b, 0x3912115d, 0x312f2f39, 0x13420130, 0x5f03200c, 0x042123eb, 0x07f641ba, 0x50233123,
	0x29f75f04, 0x41a40521, 0xfa2107e4, 0x3003605c, 0x00014908, 0x0414fe7d, 0x00cb0598, 0x40540023, 0x0f5a1117, 0x10070110, 0x48120f40, 0xba181010,
	0x20600120, 0x20022070, 0x40c0ffb8, 0x480a061a, 0xaf252020, 0x5b050125, 0x21246618, 0x041d5f00, 0x135f0a0f, 0x001b1013, 0x33e13f3f, 0x4c06145e,
	0x5d270513, 0x2b2f3912, 0x4ce15d5e, 0x152005e5, 0x2306924a, 0x11231137, 0x08108e62, 0x6b19033a, 0x3b437bae, 0x1d76b076, 0x1525282d, 0xf0a410bb,
	0xa9574c9d, 0xc46ca2fa, 0x943f4e4f, 0x98512705, 0xdb8d89da, 0x09044e96, 0x62fd090d, 0xc66cd801, 0xa6aa1501, 0x6ec61401, 0x0808f95d, 0x14fe7135,
	0x5e046f03, 0x3e001f00, 0x471d2540, 0x110e401c, 0x041c1c48, 0x215f210c, 0x1002217f, 0x48150121, 0x1b205604, 0x161f5118, 0x51121b1c, 0x0010090d,
	0x83e1333f, 0x100128b5, 0x5d5de1f6, 0x8211ce10, 0x20ad82af, 0x077c4504, 0x45171621, 0xb8830c7b, 0xb0ed0128, 0x854c4a82, 0xc15d66b2, 0x909d2908,
	0x683e9491, 0x1412b723, 0x5d07fe44, 0x4e0806b5, 0xc3d3d3ca, 0x5afd141b, 0x0000d801, 0xff680001, 0x057904fa, 0x0113000a, 0x0d674025, 0x02111d11,
	0x011d010d, 0x120b0202, 0x0702020b, 0x07020712, 0x130c1110, 0x01000b12, 0x07020308, 0x0d040f04, 0x120a0c11, 0x0801090b, 0x05070206, 0x820d050e,
	0x0a11211e, 0x12212082, 0x21228209, 0x24820601, 0x04024408, 0x020b0c05, 0x4f0f0e01, 0x0b400101, 0x010b0501, 0x0b010f0f, 0x60120405, 0xf0117011,
	0xb8110311, 0x4d40c0ff, 0x11480a07, 0x15110708, 0x15301520, 0x00060302, 0x01070409, 0x0a130201, 0x0b040d10, 0x82121111, 0x0730080d, 0x0b0b0807,
	0x0c0b0b01, 0x0cc00cb0, 0x1f120f02, 0x08000212, 0x02020810, 0x0c0c0812, 0x04021208, 0x400e0f04, 0x0e480d07, 0x2f000405, 0x332b2f33, 0x20052155,
	0x05cf5c2f, 0x33117123, 0x8203832f, 0x82098214, 0x5d012105, 0x32270782, 0x335d2b2f, 0x822f3917, 0x825d2000, 0x3311210f, 0x10230183, 0x8dc0c087,
	0xc0082103, 0x10210185, 0x25078587, 0x3031c008, 0x58825e00, 0x05015d2a, 0x27032507, 0x05372513, 0x17210384, 0x080f8203, 0x014c0233, 0xe3fe471c,
	0xfeb481b4, 0x1f0146e5, 0x47e4fec6, 0x7fb61d01, 0x4a1f01b6, 0xb001e5fe, 0xfea47ba6, 0x3b014ac7, 0x01a47ba4, 0xa47da45a, 0xfe493901, 0x390c82c4,
	0xc9000100, 0xb0038f04, 0x1500b805, 0x0fb54200, 0x480a0720, 0xe0ffb803, 0x08821e40, 0x120c2808, 0x00001712, 0x20061006, 0xa0069006, 0x06070506,
	0x0f0f1606, 0x0303000b, 0x322f0000, 0x32cd102f, 0x3301112f, 0x825d5e2f, 0x332f29c1, 0x312b2b00, 0x06060130, 0x08065277, 0x3621332f, 0x16323336,
	0x23061415, 0x2c068b01, 0x09283830, 0x011d2517, 0x302d05c1, 0x392b2a38, 0x332cee04, 0x251c3833, 0x312d0916, 0x29393632, 0x26898200, 0x03e504f4,
	0x83d905df, 0x11403c89, 0x08900880, 0x17080802, 0x14101400, 0x07031420, 0xc0ffb814, 0x100d1240, 0x82141448, 0x09143454, 0x05bf400e, 0x09800501,
	0xdd1a2f00, 0x11cd1a5d, 0x83cd2f33, 0x5e2b228c, 0x200a825d, 0x2289825d, 0x83023e32, 0x1528087f, 0x26343523, 0x020e2223, 0x01352323, 0x77854e02,
	0x7c6d3a70, 0x2a2e3a85, 0x55917965, 0x24660510, 0x6c65242b, 0x2e341123, 0x81200882, 0x29088582, 0xd704e101, 0x3506d302, 0x20001100, 0x0e0b1240,
	0x064f063f, 0x3f000602, 0x5f034f03, 0x0f030303, 0x5dcc2f00, 0x5dcd2f01, 0x63823932, 0x0808b067, 0x16141524, 0x26261517, 0x3b44e101, 0x251f322f,
	0x7a3c391f, 0x39b60578, 0x1b262646, 0x1311111a, 0x4c152e19, 0x5d8b731f, 0x5d831320, 0x003f0729, 0x0002004f, 0x6e3f0e03, 0x03200617, 0x0d6e5d85,
	0x087c4a06, 0x2506a448, 0x7a78d302, 0x5748393c, 0xb6052808, 0x4c1f734d, 0x48192e15, 0x082e0b15, 0xc1fe2900, 0x9105c107, 0x27001300, 0x5f823b00,
	0x77006326, 0x9f008b00, 0x65567c82, 0x23072905, 0x32333636, 0x0317021e, 0x01200f8e, 0x21200f8e, 0x1fbf0f8e, 0x036f0435, 0x192e2418, 0x14212f1e,
	0x64054b03, 0x364d3167, 0x924f031e, 0xf4012313, 0x28821703, 0x212f1f27, 0x054c0313, 0x21288565, 0x14922ffb, 0x92310421, 0x20299514, 0x216882f0,
	0x5382192d, 0x68277c84, 0x1f364c31, 0x92bef903, 0xcf04313e, 0x0613231c, 0x1e231205, 0x331c685a, 0xf2f92b48, 0x59270f87, 0x47331d69, 0x8816012b,
	0x210f821f, 0x0d8d2b48, 0x8ddb0321, 0x210d8d0f, 0x0f8819fe, 0x4b836820, 0x27080d8d, 0x00080000, 0x077ffe29, 0x00d3057d, 0x0019000c, 0x00330026,
	0x004d0040, 0x0067005a, 0x0e170500, 0x3e230703, 0x27033703, 0x33200482, 0x012a0c82, 0x17031e37, 0x27032e15, 0x04820705, 0x0c823520, 0x82370121,
	0x2127831a, 0x1f820701, 0x03212783, 0x201a8227, 0x201a8337, 0x83048217, 0x37042e27, 0x201c0a0b, 0x0a611223, 0x05101215, 0x330c8b3b, 0x260e2302,
	0x27575755, 0x575b5d2a, 0x0e68fb25, 0x56575527, 0x03320c85, 0x502202a6, 0x45285654, 0x494e4f25, 0x02eafc1e, 0x0d884f23, 0x14112b33, 0x0f242729,
	0x34331743, 0x6a031732, 0x27281411, 0x240d8225, 0x16323434, 0x21428a23, 0x5c8a9804, 0x9816fe21, 0xaa012284, 0x224f8210, 0x83440f25, 0xfc16224f,
	0x210d8b95, 0x8683de02, 0x46285522, 0xe9208685, 0x0d878683, 0x02004f08, 0x7ffec900, 0x6807d305, 0x31001b00, 0x4840b300, 0x26301c1c, 0x0126d001,
	0x26cf26af, 0x30262002, 0x03268026, 0x0a172626, 0x181a1a19, 0x0007151b, 0x3365175a, 0xaf0133d0, 0x33200133, 0x13023330, 0x095a0c08, 0x9f263264,
	0x401c011c, 0x3e820906, 0x218e2c2d, 0x13fb1a05, 0xb3e8ffb8, 0x82481814, 0x40e03407, 0x48130a26, 0x13161306, 0x09031326, 0x005f1713, 0x82180612,
	0x2006211a, 0x09371682, 0x29061906, 0x06070306, 0x00030a16, 0x5e33333f, 0x3f2b2b5d, 0x833333e1, 0x2e078206, 0x335d2b2f, 0xe1f61001, 0x5d5d3232,
	0x82f4105d, 0x33332807, 0x11332f39, 0x822f3912, 0x33713110, 0x2130312f, 0x37363411, 0x01233736, 0x11331123, 0x09918418, 0x2303332b, 0x030e0313,
	0x022e2223, 0xac411827, 0x04ae0807, 0x04040564, 0x31fd0806, 0x0301aed7, 0x03040103, 0xd5cc0207, 0xa6da8fc3, 0x5d31069d, 0x8c67648d, 0xaa042a58,
	0x4c321c04, 0x37492b35, 0x19030622, 0x4c418f38, 0x0546fb4d, 0x1ae0fcb6, 0x1f44433e, 0xb4044c4a, 0xd9fdf0fa, 0x68078101, 0x2950774d, 0x50774f27,
	0x10294839, 0x35472c12, 0x00020000, 0x0483feae, 0x001706f2, 0x0025000f, 0x103a4096, 0x341a0410, 0x031a841a, 0x0b1a1a07, 0x0e0e0d05, 0x10090c0f,
	0x09481809, 0x0b460002, 0x27a42755, 0x27d427c4, 0x800427f4, 0x00020127, 0x20271027, 0x60275027, 0x06277027, 0xf0ffb803, 0x29822540, 0x0708033f,
	0x26540446, 0x01107f1a, 0x09064010, 0x20101048, 0x0e11158e, 0x050209fb, 0x08600b0f, 0x052a5f04, 0x333fe124, 0x2d413f33, 0x5d2b220c, 0x062f415f,
	0x30412b20, 0x5d5e2108, 0x29052e41, 0x11230113, 0x01071133, 0x23411133, 0x8f032f13, 0xeafefd0b, 0x04020cac, 0xb67bb7e9, 0x1941477a, 0x6d761814,
	0x64fd2e07, 0xfc9803fc, 0x01e9fd50, 0x4e17067d, 0xf1421876, 0x2c123609, 0x02003548, 0x00002f00, 0xb6053304, 0x21001600, 0x2c405200, 0x08096a13,
	0x2006e669, 0x08d2690e, 0x69008921, 0x032009cc, 0x680ecc69, 0xc66908da, 0x15c06905, 0x6906d768, 0x01210bc0, 0x0ac06981, 0xba989826, 0xc5fe3b01,
	0x2114be69, 0xbc69b2b2, 0x28b58209, 0x04000012, 0x00140619, 0x08b58214, 0x3b40613d, 0x1c0e0101, 0x23570847, 0x23bf236f, 0x23ff23df, 0x16000304,
	0x0e111247, 0x50152254, 0x500f0304, 0x04120012, 0x48240740, 0x0f01120f, 0x02121f12, 0x04120407, 0x16001312, 0x6a150e50, 0x71210991, 0x27c5872b,
	0x33c4f610, 0x5d3232e1, 0x1226cc82, 0x30312f39, 0xb3822101, 0x9f692120, 0x6911200d, 0x0125099d, 0xfe170164, 0x099f69e9, 0xb69c9c23, 0x089b6901,
	0x8921053a, 0x9b9ceffd, 0x2f587c4d, 0xf3899804, 0xa8fedafb, 0x30422911, 0x11284231, 0xc720c782, 0x3336c782, 0x1300b605, 0x88002200, 0x051b4f40,
	0x181a061a, 0x07071908, 0x01821906, 0x1e0c4a08, 0x3800285b, 0x03004800, 0xcf246700, 0x24400124, 0x01240f01, 0x5a0c1406, 0x1923640d, 0x1aaf1b18,
	0x141a1a01, 0x07b00622, 0x0c070701, 0x60140805, 0x0b400b30, 0x0c0b0b02, 0x030e6022, 0x3f00120c, 0x3911e13f, 0x39e15d2f, 0x20c78239, 0x0593435d,
	0x43393921, 0x5e2205ae, 0xe0825d5d, 0x12e15d27, 0x2f2f3939, 0x211b8311, 0x4c743239, 0x0e142b06, 0x07170702, 0x23230627, 0xe6822311, 0x021e4f08,
	0x36323301, 0x17372737, 0x34353636, 0x04232326, 0x4b2f1633, 0x816a6e36, 0xba967c5d, 0xc2866a01, 0x4efd3c7e, 0x1f442681, 0x33706d5c, 0xa0aea434,
	0x6f3a0a04, 0x9b205664, 0xfd1bb64e, 0x39b605c7, 0x67fea06d, 0x4c850505, 0x577324a0, 0xf782898e, 0xfeae4b08, 0x043f0414, 0x0023005e, 0x40720039,
	0x32353440, 0x202a3333, 0x371f1f1e, 0x1b2a2148, 0x3b303b57, 0x0c102a01, 0x3a540d47, 0x2f323533, 0x341f340f, 0x34cf346f, 0x34340704, 0x1050242f,
	0x0f0e1016, 0x0020201f, 0x1e211b0c, 0x8651502f, 0x20e38205, 0x23e4823f, 0x333f3f33, 0x5e21f383, 0x85d7825d, 0x823220e8, 0x391127e6, 0x392f39e1,
	0x04821133, 0x3133392e, 0x2e220530, 0x16232702, 0x15161617, 0x3328e182, 0x033e3317, 0x021e3233, 0x08640119, 0x0e220324, 0xbc4c0702, 0x82f78505,
	0x02ad08f6, 0x4d603b9e, 0x030c163c, 0xb6040203, 0x16081a94, 0x3c604d3b, 0x3c6e995e, 0x6a6d525a, 0x46411f75, 0x1f41694c, 0x6c411b02, 0x0f211151,
	0x546e6d6a, 0x2c19147f, 0x1f22203a, 0xfe10371a, 0x9436062b, 0x1b2d3e22, 0x8cd48f48, 0x9a44f2af, 0x0b09a64e, 0x5e2edb03, 0x65295e8d, 0x03376b9d,
	0x9e4c9805, 0xced0ee6a, 0x00010000, 0x0300002f, 0x00b605be, 0x4089000d, 0x2f051f15, 0x05050205, 0x1f000f08, 0x00900200, 0x00e000a0, 0xffb80003,
	0x071e40c0, 0x0000480a, 0x3f0f1f0f, 0xbf0f9f0f, 0x0703040f, 0x0a000c5a, 0x800a0601, 0x0208c008, 0x32228308, 0x480a0626, 0x5f090608, 0x2f0c0f03,
	0x4f0c3f0c, 0x820f040c, 0x0caf3006, 0x0cff0cdf, 0x0c0c0805, 0x0d5f0207, 0x18120703, 0x2a08ee44, 0x32e13371, 0x5d2b2f01, 0x825d5ec6, 0x05cf4d09,
	0x3912712b, 0x30315d2f, 0x11211501, 0x4f5b1821, 0xbe033708, 0x5001c3fd, 0x98bab0fe, 0xa6b60598, 0xfda215fe, 0xa283027d, 0xbd839102, 0xbd821220,
	0x4a040a22, 0x6e3ebd82, 0x0b0b1d40, 0x30062000, 0x06060206, 0xa00f700f, 0x030fc00f, 0x04470d09, 0x02ef02df, 0xc5830202, 0x1512b323, 0x08078348,
	0x06214022, 0x0c00480b, 0x4f094f01, 0x02045f04, 0x1c174004, 0x1b040b48, 0x04070204, 0x50080004, 0x15000f05, 0x2b20a588, 0xa6829c83, 0x87c62b21,
	0x825d20a5, 0x303125a3, 0x35231133, 0x83051e6e, 0x9cae3ca8, 0xfe5c029c, 0xfe17015a, 0x89e101e9, 0xfe9ae001, 0x1ffe89ba, 0xc7000100, 0x820400fe,
	0x003408b5, 0x40660026, 0x01150941, 0x05070707, 0x28125b22, 0x7f0128c0, 0x02288f28, 0x28402810, 0x0a1c1c02, 0x64055a04, 0x5f201d27, 0x60001c17,
	0x0d2f0d0f, 0x0f030d3f, 0xdf2d0482, 0x040dff0d, 0x050d0d08, 0x03065f09, 0x0a3b4105, 0x064fe120, 0x32f12905, 0x5d5d2fc0, 0xe1de105d, 0x00299484,
	0x22015d5e, 0x23110706, 0x4a948311, 0x5608059f, 0x020e1415, 0x022e2223, 0x16163527, 0x34112033, 0xfc01022e, 0xba1a3c25, 0xc3fdf702, 0x9a2d471d,
	0x5257a5f0, 0x3176c992, 0x1f3d444e, 0x01487f3f, 0xae7b4377, 0x05058302, 0xb60587fd, 0x050bfea6, 0xf2ab5c03, 0xa2f8aa97, 0x130c064f, 0x1817a20c,
	0xb979ef01, 0x8200407e, 0xae4a08db, 0xc5030afe, 0x23004a04, 0x39405c00, 0x22192209, 0x14032229, 0x480a1214, 0x250f251f, 0x5f02251f, 0xff257f25,
	0x03030325, 0x12471117, 0x00042454, 0x1a0b510d, 0x07021a1b, 0x16121a1a, 0x120f1350, 0x00510715, 0xe13f001b, 0x805d3f3f, 0x11e92105, 0x23054243,
	0x715d2f39, 0xd182d288, 0xbb842620, 0x35363225, 0x93232634, 0x023b08de, 0x2e6a4b29, 0x76426a2b, 0x1a9d9075, 0x02b61f3e, 0x1d5afe5c, 0xb3661f3b,
	0x6f404c85, 0x1f0afe96, 0x2518a11d, 0xcad4d2c3, 0x35fe080a, 0xfe9a4a04, 0x3e0505c3, 0x969ddb8a, 0x824088d5, 0xfe043cc7, 0x05cb067f, 0x001500b6,
	0x115740e2, 0x48181440, 0x13092011, 0x1a110a48, 0x83000211, 0x8400200e, 0x1a003c0e, 0x10070200, 0x5a020d0d, 0xa80a0a07, 0x0203b803, 0x8d010399,
	0x03570103, 0x82770367, 0x035e08e5, 0x00061203, 0x0f100f0e, 0x48180c40, 0x150f110f, 0x0112045a, 0x12841274, 0x120312c4, 0x40c0ffb8, 0x480a0727,
	0x04171212, 0x17f00117, 0x0117e401, 0x020117a0, 0x17301720, 0x17701760, 0x0f051790, 0x09080117, 0x06080508, 0x40f0ffb8, 0x16060613, 0x0a0dfb13,
	0x080f000a, 0x5f11030b, 0x4e680305, 0x3fe13505, 0x39123333, 0x113f3311, 0x382f3301, 0x33113333, 0x5f5d5d5e, 0x3006b25b, 0xe1715d2b, 0x2b2f3333,
	0x11323338, 0x5f2f3912, 0x8200825d, 0x32e12121, 0x2b332583, 0x2b2b5d2b, 0x01213031, 0x01112311, 0x33010123, 0x82331101, 0x82088244, 0xae053c10,
	0xfdb3eefd, 0x2102d3ee, 0x02cdedfd, 0x0a02b30a, 0x01edfdcd, 0x02b0c3a8, 0x841bfde5, 0x02f22403, 0x873cfdc4, 0xfd2e0803, 0x01d9fdb4, 0x01000081,
	0x83fe0400, 0x4a040406, 0x11011500, 0x10276c40, 0x29021037, 0x020e390e, 0x09360926, 0x370a2702, 0x0427020a, 0x04860437, 0x01370123, 0x1d5e4102,
	0x0d0d1037, 0x0a074602, 0x0103cd0a, 0xa90103b9, 0x03960103, 0x01038701, 0x095a4103, 0x5a410a20, 0x12462805, 0xb3c0ffb8, 0x83481512, 0x17403807,
	0x12480b07, 0x17101712, 0x01170001, 0x17f417e4, 0xc417b402, 0x82170217, 0x13402f23, 0x3048110d, 0x20020117, 0x170f0117, 0x60410701, 0x110f2415,
	0x49030560, 0x60410939, 0x5d2b2512, 0x1171715d, 0x4105bf62, 0x5d200e61, 0x20066241, 0x0661415d, 0x5d5d0024, 0x00835d01, 0x3c156a41, 0x43fef004,
	0xcf44fea4, 0x58fecf01, 0xa49f01c5, 0xfec5a001, 0xc54f0158, 0xfd2d02ae, 0x240384d3, 0xfd150235, 0x080387eb, 0xfd65fe2a, 0xff7d01e9, 0xfe4800ff,
	0x05ec0342, 0x012602cb, 0x010000b1, 0x017f0307, 0x00000048, 0x0101b111, 0xb4ffffb8, 0x0b134248, 0x8206b35c, 0x8244202b, 0x0452222b, 0x202b825e,
	0x212b85d1, 0x2b88f200, 0x2b82f820, 0x86212921, 0x0024082b, 0xfec70001, 0x05ec047f, 0x001000b6, 0x055940a6, 0x48181440, 0x05cd05bd, 0x050305dd,
	0x48100920, 0x052a051a, 0x27050443, 0x00cd00bd, 0x000300dd, 0x003c1584, 0x0602002a, 0x0e081010, 0x0f7f100f, 0x00020f9f, 0x400f300f, 0x0f06030f,
	0x5a04050f, 0x103a7282, 0x01070201, 0x12b01201, 0x5a080c01, 0x0c116409, 0x40f0ffb8, 0x48100b16, 0x04821006, 0x09060c3a, 0x00030a0f, 0x0905055f,
	0x00fb0212, 0x2f333f3f, 0x12333fe1, 0x2b2b3939, 0x2a08af6d, 0xe1335d5e, 0x5e2f3332, 0x82385d5d, 0x33112319, 0x01852b5d, 0x25303129, 0x11231133,
	0x82070123, 0x11333f05, 0x01330137, 0xb1b73504, 0x8b3dfe6c, 0x0179baba, 0xf8fdd1c4, 0x01d9fda6, 0x72ba0281, 0x2d19b8fd, 0x012f091e, 0x83feae00,
	0x4a042b04, 0x99000e00, 0x84086a40, 0xcd0826e7, 0x0308dd08, 0x24d18408, 0x02082a08, 0x26158403, 0xdd03cd03, 0x84030303, 0x033f0815, 0x0802032a,
	0x01004607, 0x01860176, 0x01016d02, 0x2b010155, 0x4b013b01, 0x01140301, 0x01010b01, 0x00010306, 0x02041004, 0x0e100404, 0x0b470a02, 0x02090f54,
	0x0b000e0e, 0x15085003, 0x600cfb05, 0x3f2105ca, 0x44c284e1, 0x322505dc, 0x5d2f3311, 0x05066c33, 0x115d5d22, 0xda89e582, 0x0120cc82, 0xdc84dd85,
	0xc4fa0238, 0x4b0161fe, 0xfe66aec1, 0x04b4b44b, 0xfef1fd4a, 0x01e9fd5f, 0x8118027d, 0x48080937, 0x040000c7, 0x00b605a2, 0xb9970012, 0xe0ff0f00,
	0x15125d40, 0x600f5048, 0x0f22020f, 0x0f420f32, 0x09400203, 0x070b480d, 0x1234085a, 0x12021254, 0x0103570f, 0x041d0c03, 0x01040b01, 0x08000404,
	0x11101364, 0x10000111, 0x08028200, 0x00070220, 0x14b01400, 0x01142f01, 0x0b011410, 0x20080905, 0x40043004, 0x0d040304, 0x09100d04, 0x65820803,
	0x3f323f2e, 0x2f393933, 0x12115d2f, 0x5d013939, 0x2408c083, 0x385d5e2f, 0x33113333, 0x3911e610, 0x335d5d2f, 0x32325dc1, 0x32e1105d, 0x2b003031,
	0x212b5d5d, 0x23150123, 0x06ad4111, 0x15331122, 0x3c08e382, 0xfed3a204, 0xba7785ae, 0x018577ba, 0xf8fdd141, 0x01cdf401, 0xd7fd6264, 0x06fdb605,
	0xb36301a4, 0x65fda601, 0xae000100, 0x23040000, 0x13004a04, 0x11b59c00, 0x48110b40, 0xc0ffb80a, 0x080782b3, 0xffb80e52, 0x085740f0, 0x0a0e480d,
	0x12011226, 0x99138907, 0x0313a913, 0x132f131f, 0x0b03133f, 0x13130113, 0x4702060f, 0x0b145403, 0x0f100c0c, 0x300f2010, 0x0f0f020f, 0x10150015,
	0x15000215, 0x15601540, 0x15a01580, 0x15e015c0, 0x0d0e0707, 0x13080606, 0x022b0182, 0x100f040b, 0x3f001502, 0x82333f33, 0x2f2f2ddc, 0x33113912,
	0x5d5e0133, 0x2f331171, 0xf622e286, 0x684e32e1, 0x20e58405, 0x28e2832b, 0x1127012b, 0x11331123, 0x24db8237, 0x15013313, 0x08ef8301, 0x6dcf0127,
	0x7d6db4b4, 0x50fec5eb, 0xfecfd701, 0xb2017df8, 0x04d3fd7b, 0x7bebfd4a, 0x01b94601, 0x4916fe0d, 0x2701e9fd, 0x057f49cd, 0xa2042708, 0x1400b605,
	0x40408500, 0x14661402, 0x04131401, 0x0e500e40, 0x000e0e02, 0x5a040c10, 0x64050709, 0x10131215, 0xa7411313, 0xb0163b0a, 0x162f0116, 0x01161001,
	0x0c5f060f, 0x02000909, 0x48100b10, 0xf0ffb810, 0x08830c40, 0x12050225, 0x4105030a, 0xcd8206b0, 0x822b2b21, 0xe13322b7, 0x0bb24132, 0x33382f25,
	0x82c6f610, 0x28d38414, 0x5d391211, 0x30313311, 0x055a4321, 0x22053d4d, 0x43231533, 0xa22a0562, 0x8b3dfed3, 0xba9898ba, 0x6443d5d5, 0xba023105,
	0x04b8fd72, 0xb2b2a460, 0xa87bfea4, 0x83fd3302, 0x2208cb82, 0x03000012, 0x001406f0, 0x40840016, 0x0e0e110f, 0x0908040f, 0x14471303, 0x06010600,
	0xb3c0ffb8, 0x83481510, 0x403a0807, 0x480e0935, 0x160f0606, 0x17541401, 0x0d100d0c, 0x0f35100f, 0x100f0001, 0x030f200f, 0x180f0f08, 0x0901180f,
	0x14140211, 0x4f15070f, 0x02010104, 0x0f0c150f, 0x3f000002, 0xc5853f3f, 0x20053f4c, 0x44af8201, 0x33210520, 0x21c98211, 0x1c82c632, 0x712b2b28,
	0x3217e110, 0xca833911, 0x3533132f, 0x15211533, 0x33031121, 0x01330137, 0x08d98601, 0xb49c122e, 0x85fe7b01, 0x01870410, 0x6ffed325, 0xfed1ac01,
	0x9cb46db0, 0xb6b65e05, 0xfe75fe89, 0x6901aaed, 0x91fd25fe, 0xfe52f801, 0x00d5045a, 0x143dd782, 0x44050000, 0x0e00b605, 0x33405700, 0x0d0e0e02,
	0x205a040a, 0x40053005, 0xf0058005, 0x24008205, 0x0d0c0700, 0x0a9e410d, 0x1010102a, 0x050a0201, 0x085f070c, 0x24078541, 0x391233e1, 0x21b28639,
	0xb1823338, 0xae822f20, 0x86e15d21, 0x067541aa, 0x21352123, 0x2aaa8311, 0xfed34405, 0xfebb8b3d, 0x410f02ac, 0x05240a6e, 0x25fda412, 0x08076b41,
	0x00002940, 0x4a04c904, 0x67000d00, 0x0d024040, 0x47060b0d, 0x00010700, 0x20071007, 0xc0076007, 0x07080507, 0x00090307, 0xf501d501, 0x04010201,
	0x03001003, 0x03020310, 0x0f400f03, 0x0f020fe0, 0x3382010f, 0x50090727, 0x070f0a00, 0x05f44203, 0x3912e127, 0x5d013311, 0x06ee425d, 0xa2820783,
	0x715d5e29, 0x113232e1, 0x41303133, 0x11220542, 0xa5821123, 0x11076908, 0xfec5dd03, 0xcfc70160, 0xfeb54cfe, 0x021f0298, 0xf1fd4a04, 0x2d02c5fd,
	0xb003d3fd, 0xedfd029a, 0x00010000, 0x057ffee5, 0x00b605a4, 0x4063000f, 0x045a043f, 0x01740101, 0x01940184, 0x11010103, 0x005a050d, 0xf411e411,
	0x11c00211, 0x11100201, 0x11401120, 0x0c041180, 0x64095a08, 0x0f5f0710, 0x0c08010c, 0x0a0e050c, 0x5f21c382, 0x05264605, 0x3f33e123, 0x20918433,
	0x052646e1, 0x5d5d5f26, 0x32e1dc10, 0x7121af83, 0x071846e1, 0xa06e1120, 0x33112d06, 0xb0b0f404, 0xbb67fdbb, 0xbb9902bb, 0x20051346, 0x05676eaa,
	0x82680221, 0xfeae269b, 0x04db0483, 0x3a9b824a, 0x08524079, 0x0b044700, 0x0f0b0b01, 0xd40cc447, 0x0c0c020c, 0x24110411, 0x83d40211, 0x82b0209e,
	0x8230209e, 0x8250209c, 0x9026089e, 0x0611a011, 0x04470307, 0xfb0d1054, 0x07eb5002, 0xb907a901, 0x070f0207, 0x072f071f, 0x07070603, 0x0f050900,
	0x8551500b, 0x86e12005, 0x5d5d23ad, 0xb0883fe1, 0xad837120, 0x2f33e128, 0x3132e15d, 0xac892130, 0x1133112f, 0x85031123, 0xb6b6dffd, 0xa0b62102,
	0x09e572b6, 0x82054d51, 0x00e536b1, 0x05480600, 0x000d00b6, 0x093b405d, 0x00005a01, 0x010b4005, 0x21b782e0, 0x3e43200f, 0x30210805, 0x600f400f,
	0xb00fa00f, 0x080fe00f, 0x5a040806, 0x0d0e6405, 0x060a0a5f, 0x080f5f03, 0x08080801, 0x078d4206, 0x5e2f3924, 0x8a82e15d, 0x29054941, 0x10715d5e,
	0x11715dc6, 0x95842f39, 0x96882320, 0x21152124, 0x4341f404, 0x0f022406, 0x4102acfe, 0xa4210841, 0x05a14500, 0x04a40523, 0x3391824a, 0x08214068,
	0x09054704, 0x00004701, 0x0e54050b, 0x000f0b0b, 0x02219582, 0x088b8290, 0xd00fc032, 0x050ff00f, 0xc0ffb80f, 0x0c071f40, 0xeb500348, 0x08a90108,
	0x0f0208b9, 0x2f081f08, 0x08060308, 0x0a0d0008, 0x00050f06, 0x323f0015, 0x12c4333f, 0x5d249e83, 0x2b01e15d, 0x33239482, 0x84e6102f, 0x92102099,
	0xb63b219c, 0x23053141, 0x97fe1f02, 0x20093241, 0x089b829a, 0x00fec72e, 0xb605db07, 0x5f002700, 0x0b093a40, 0x12120701, 0x215a2000, 0x5b182521,
	0x296f2908, 0x255a2401, 0x601d2864, 0x032f030f, 0x0f03033f, 0xdf3c0482, 0x0403ff03, 0x25030308, 0x03265f23, 0x13122521, 0x1c0d5f16, 0x33e13f00,
	0xe13f333f, 0x71299284, 0xf61001e1, 0xde105de1, 0x279084e1, 0x30312f39, 0x015d5e00, 0x2317684d, 0x11072223, 0x29054b41, 0x1ec10421, 0xf09a2e49,
	0x6b4d56a5, 0x3d433505, 0x497e3f1f, 0x7c437701, 0x334b6bae, 0xba7bfdbb, 0x1b03fa03, 0x26166b4d, 0x0589fd0c, 0x82eefa12, 0x015808cb, 0x0afeae00,
	0x4a047506, 0x77002400, 0x230b4e40, 0x0302231b, 0x47111903, 0xc2011202, 0x12a60112, 0x770212b6, 0x02128712, 0x0a161212, 0x0f262048, 0x02261f26,
	0x265f264f, 0x26ff26af, 0x01261004, 0x54164715, 0x0b510d25, 0x021b1b1b, 0x161b1b07, 0x0f175014, 0x04151612, 0x8906884d, 0x21e885e9, 0xea85715d,
	0x5d5d5d25, 0x8432e171, 0x158e4dee, 0x4c18e684, 0x04210844, 0x098f4dd9, 0x1f3e1c2a, 0xb608feb6, 0x3f3a6403, 0x28158f4d, 0x50fcb003, 0x27fe4a04,
	0x08914d0c, 0x00026608, 0x05acff7d, 0x00cd0596, 0x0052003e, 0x0550407a, 0x0432104e, 0x005b4900, 0x02201020, 0x20352035, 0x005b3f18, 0x540f5467,
	0x544f541f, 0x547f545f, 0x54af549f, 0x5b2b0707, 0x44536618, 0x00054e60, 0x203a103a, 0x703a603a, 0x063a803a, 0x26073a3a, 0x041d215f, 0x5f303210,
	0x0e5f0713, 0x0013130e, 0xe12f333f, 0x28d08210, 0x12e1333f, 0x395d2f39, 0x20ee8439, 0x3aa2185e, 0xe15d3608, 0x31391712, 0x0e140130, 0x33160702,
	0x15373632, 0x22230606, 0x10046527, 0x6e032e21, 0x3721097d, 0x084f6326, 0x2e340723, 0x08188702, 0x033e17ee, 0x41276f05, 0x51362d55, 0x1d1f4625,
	0x8ba6264f, 0x963c7c32, 0x4d519de8, 0x42a6f29e, 0x0a352578, 0x15333028, 0x336ca976, 0x64a0703c, 0x5b4f2630, 0x4c836037, 0x3962854b, 0x3d2a16c5,
	0x293d2927, 0x36291815, 0x2e422a1f, 0x65a60218, 0x246f90af, 0xaa0b0e19, 0x11620c0d, 0x01c06a11, 0x01b5a50e, 0x1669c71f, 0x0a059c0f, 0x9a510509,
	0xda948dde, 0x69074690, 0x859b1601, 0x383b7bc1, 0x5495c67b, 0x37366389, 0x48508762, 0x27657685, 0x88776221, 0x00020000, 0x04c5ff71, 0x005e04a4,
	0x004d000d, 0x44494079, 0x04321105, 0x5448003f, 0x02216421, 0x21352135, 0x3f480819, 0x573f4a4a, 0x8b4f7b4f, 0x034fbb4f, 0x4f6f4f5f, 0x014f1b02,
	0x07014f0f, 0x19482a02, 0x440b4e56, 0x473a3a05, 0x1e225025, 0x2f321110, 0x50471450, 0x16140e0e, 0x2d0a5a41, 0x2f3912e9, 0x01c13939, 0x5fe1f610,
	0x00825d5e, 0x32e61025, 0x78e1102f, 0x60410530, 0x021e2107, 0x2306e553, 0x22010622, 0x200d9764, 0x0d646616, 0x26373627, 0x3e343526, 0x05395302,
	0x07020e23, 0x07994116, 0xdd029208, 0x152a2014, 0x3d384839, 0x4c01413e, 0x28398845, 0xb3754762, 0x783c3f7a, 0x524279b4, 0x4a13291a, 0x4370542a,
	0x6e431e1c, 0x03322550, 0x55314a39, 0x6f404172, 0x341e2e52, 0x37142745, 0x1c391a1d, 0xf4014219, 0x394b5c35, 0x6b962812, 0xfd7a7a67, 0x11252a68,
	0xcc975717, 0x97d68375, 0x96061053, 0x6f3a1005, 0x945967a0, 0x02083c6b, 0x5e77b442, 0x272b5988, 0x46638a56, 0x1b4d6378, 0x08060d0a, 0xff070993,
	0xfe7d00ff, 0x05980442, 0x002602cb, 0x05754d26, 0x002f022d, 0xb70e0000, 0x32750101, 0x4d20182c, 0x27820572, 0x42fe712a, 0x5e046f03, 0x46002602,
	0x01212785, 0x24278671, 0x05282e52, 0x0827850d, 0x00010057, 0x047ffe14, 0x00b60512, 0x406f000b, 0x010d1f39, 0x5f010de0, 0x020ddf0d, 0x0d300d20,
	0x04030d40, 0x1f010f5a, 0x01070201, 0xef0aaf01, 0x0a0a020a, 0x40065a0b, 0x0207e007, 0x0801070f, 0x06570707, 0x06770667, 0xffb80603, 0x070f40c0,
	0x0b06480a, 0x03085f07, 0x084b4700, 0x32e13f31, 0x5d2b2f01, 0x5d5e2f33, 0x32e1105d, 0x82395d2f, 0x5de12409, 0x47715d5d, 0x35370949, 0x02211521,
	0xbbb0b071, 0xfe035efe, 0xfda65ffe, 0x058101d9, 0x82a4a412, 0x290027b6, 0x5e0383fe, 0x9d844a04, 0x0df04d39, 0x010daf01, 0x0d500d40, 0x010d2f02,
	0x08af470b, 0x08cf08bf, 0x82400803, 0x08330878, 0x0105df08, 0x8f01059d, 0x05050105, 0x60004707, 0xd0027002, 0x021f0302, 0x00020201, 0xb0001000,
	0x0400c000, 0x06fb0900, 0x0f035002, 0x15005007, 0x82e13f00, 0x183f209c, 0x820a568b, 0x82392095, 0x259d83ab, 0x2130315d, 0x98832111, 0x11331138,
	0x68011123, 0x3503c1fe, 0xb69fc1fe, 0x9a9ab003, 0xe9fdeafc, 0x956d7d01, 0x05372707, 0x000602b6, 0xad83003c, 0x14fe0024, 0xad82d503, 0x7c001336,
	0x0a0a1340, 0x01a64700, 0x97018701, 0x01010201, 0x10121103, 0x080c4e50, 0x0b072042, 0x15121248, 0xdf0115f0, 0x0215ef15, 0x15901550, 0x4f0315a0,
	0x15300115, 0x01150f01, 0xffb80304, 0x031040f0, 0x050f0311, 0x020a150a, 0x020a1307, 0x001b0015, 0x33333f3f, 0x333f5d5e, 0x33382f01, 0x0282b082,
	0x2f331129, 0x33382b2b, 0x722f3912, 0x312205ed, 0xb1820130, 0x13333908, 0x3317031e, 0x1337033e, 0x46020133, 0xbc71feb7, 0x1b2010c7, 0x04070514,
	0x10201b15, 0x71febcc7, 0xe80114fe, 0xcffd4e04, 0x4f5e642e, 0x5e4f1919, 0x31022e64, 0x0100b2fb, 0x0021c982, 0x08d58204, 0x0010002e, 0xef19409f,
	0x40120112, 0x00480c09, 0x5a080400, 0x96090d09, 0x09770109, 0x06020987, 0x40c0ffb8, 0x4818150d, 0x0606090b, 0x02030b09, 0x0805b364, 0x0fab383c,
	0x010f9001, 0x0f010f14, 0x10100201, 0x02ef0102, 0x0102d001, 0x800102bf, 0x024f0102, 0x1402025f, 0x02000102, 0x02020701, 0x5f0a0712, 0x0d0d0004,
	0x0f120801, 0x3f000301, 0xc2823f33, 0xe1333928, 0x33011132, 0xdb855e2f, 0x38715d23, 0x20d68233, 0x2ede825d, 0x2f2f3917, 0x5d5d2b2f, 0xe1103311,
	0x823d3932, 0x23e8820a, 0x15013301, 0x0805c255, 0x21352128, 0x02330135, 0xc854011b, 0x270142fe, 0xfebbd9fe, 0xfe2601da, 0xd302cb42, 0x83fce302,
	0xa8fea43d, 0x33a45801, 0xa7418703, 0x0019310b, 0x0e154085, 0x4701170e, 0x0102a606, 0x02970287, 0x07230082, 0x77101615, 0x37080cb2, 0x480b0720,
	0xf01b1616, 0x1bdf011b, 0x50021bef, 0xa01b901b, 0x1b4f031b, 0x011b3001, 0x08011b0f, 0xf0ffb807, 0x15071340, 0x03000f07, 0x150e054f, 0x0e07020e,
	0x01150617, 0x2107ac41, 0xae4132e1, 0x82ec8217, 0x303125c9, 0x11231105, 0x0120c082, 0x2a0bb441, 0x46021521, 0x01f6feb7, 0x4173fe08, 0x012910ba,
	0x9dfe890a, 0x04896301, 0x0ebe414a, 0x89b62b08, 0x00000100, 0xb4047ffe, 0x0f00b605, 0x88400601, 0x48010f47, 0x0f030109, 0x05060b00, 0x070e070a,
	0x090b000c, 0x0d080a05, 0x12820c08, 0x82090021, 0x05320814, 0x030f0c09, 0x080e0606, 0xaa01050a, 0xca05ba05, 0xfa05ea05, 0x30050505, 0x05480e0b,
	0x0d015a04, 0x0e0b100e, 0xbb0eab01, 0xeb0ecb0e, 0x050efb0e, 0x1982400e, 0x000a0e2f, 0xba00aa01, 0xea00ca00, 0x0500fa00, 0x082d8300, 0x04000e3e,
	0x02011401, 0x11010107, 0x11e411d4, 0xc00311f4, 0x20020111, 0x02114011, 0xc0ffb811, 0x14100b40, 0x01110f48, 0x070a0a0b, 0xf0ffb808, 0x28081440,
	0x0c270106, 0x05060c01, 0x07030a0d, 0x28093544, 0x12333f33, 0x5d5d3939, 0x057c5401, 0x5d2b5d24, 0x864d5d5f, 0x33332505, 0x2f715d2b, 0x38240382,
	0x32e11033, 0x11300782, 0x2f3d3912, 0x87103317, 0xc004c00e, 0x0ec08710, 0x08220482, 0x058608c0, 0x37820120, 0x5408cb51, 0x4308058f, 0x03013301,
	0x77b0b6fe, 0x91fe9efe, 0xfec501bc, 0x4c01c65a, 0xfebe4e01, 0xd9fda65b, 0x7b028101, 0xfc0285fd, 0xd1fdba02, 0x4cfd2f02, 0x00010000, 0x0483fe23,
	0x004a041f, 0x4039010f, 0x010d5925, 0xb4010356, 0x203ab282, 0x3d48110e, 0x0c29010c, 0x1b0c0b01, 0x0b0c020c, 0x03000846, 0x0d0d0306, 0xda830401,
	0x15714508, 0x04b54818, 0xa9049901, 0x046a0204, 0x048a047a, 0x55044503, 0x04060204, 0xdb050401, 0xfb02eb02, 0x02c90302, 0x0102bb01, 0x02a60296,
	0x75026502, 0x03028502, 0x025a024a, 0xdf010202, 0xff05ef05, 0x40050305, 0x3b3a6382, 0x02054b05, 0x0a010527, 0x02051a05, 0x01440134, 0x01012802,
	0x01150105, 0x06820502, 0x073b0f24, 0x8a830701, 0x08075408, 0x40c0ffb8, 0x480c0749, 0x60110808, 0x90118011, 0xd011b011, 0xf011e011, 0x0edb0711,
	0x010ec901, 0x65010eba, 0x850e750e, 0x0e4a030e, 0x09020e5a, 0x3b0e010e, 0x020f4b0f, 0x05010f28, 0x020f150f, 0x010d030f, 0x0c50070e, 0x04fb0915,
	0x3f000f01, 0x4e3f3f33, 0x2f24054c, 0xc55d5d5d, 0x2a068e43, 0x2b2f3311, 0x125d2b33, 0x832f3939, 0x22158216, 0x86105d2b, 0x2007861c, 0x0690412b,
	0x8432e121, 0x30312a1d, 0x015d5d00, 0x13133301, 0x05045633, 0x01232c08, 0x98012301, 0xfacf9ffe, 0x9dfecffa, 0xaeaa0f01, 0xfef4fe65, 0x3302cff2,
	0x66fe1702, 0xe9fd9a01, 0xe9fd67fe, 0xb4017d01, 0x46004cfe, 0x0633059f, 0x00b60560, 0x4094000f, 0x045a010d, 0x105a0804, 0x82d00105, 0x08f183fd,
	0x12074444, 0x11050548, 0xa00111df, 0x110f0111, 0x114f112f, 0x0704118f, 0x0e200e10, 0x0e500e40, 0x0e800e60, 0x000e0e06, 0x0b0f095a, 0x0b2f0b1f,
	0x0b6f0b5f, 0x08060baf, 0x09300b0b, 0x09500940, 0x09900980, 0x48830905, 0x0a071123, 0x30248248, 0x030c025f, 0x095f0004, 0x00fb0612, 0x32e13f3f,
	0x063e5a3f, 0x5e2f3322, 0x2005bf46, 0x2fd5825e, 0x2b2f3311, 0x33e1715d, 0x3031e12f, 0x33112125, 0x23210182, 0x062f4611, 0x02710228, 0xb0b0ba85,
	0xcc4606fc, 0x10052106, 0x2305b85f, 0xa4a41205, 0x2926cd82, 0x6d0583fe, 0xcd824a04, 0x0bb68028, 0x020e0e47, 0x7d820f47, 0x180eb323, 0x2a078348,
	0x0b073340, 0x110f0f48, 0x841f110f, 0x82bf20ca, 0x07062ed8, 0x08e00860, 0x080308f0, 0x03470a08, 0x061a421f, 0x0300052a, 0x03600310, 0x03040370,
	0x142fbd84, 0x09034818, 0x060c5005, 0x500a0e0f, 0x8f001503, 0x83bc87bd, 0x852b20ba, 0x880120b9, 0x82bb82b3, 0x6d0524c3, 0x46b2fcb7, 0x012705e7,
	0xfea0b6f8, 0x467d0183, 0x032405ed, 0x0050fcb0, 0xa63ebb82, 0x31057ffe, 0x1d00b605, 0x12406300, 0x0d1b0d0b, 0x5a041a02, 0x1da01d90, 0x031d1d02,
	0x8783005a, 0x072c2b08, 0x00004810, 0x1f1f0f1f, 0x4f1f2f1f, 0x7f1f5f1f, 0xbf1faf1f, 0x1207081f, 0x1e640f5a, 0x0a1a5f15, 0x101b040a, 0x045f1d03,
	0xa2840112, 0x12333f25, 0x4b332f39, 0x9c830618, 0x2307b44e, 0x2311255d, 0x0e260182, 0x2e222303, 0x4f183502, 0x37200883, 0x05350982, 0x3abab031,
	0x31616369, 0x3565925d, 0x2d7b69ba, 0x38665e5a, 0x05be43ba, 0x22165636, 0x5e310c16, 0x4702598b, 0x7473d1fd, 0x141e140a, 0xf0fac602, 0x2308bd82,
	0x0483fe9a, 0x004a049e, 0x4061001c, 0x1b090b17, 0x03092b09, 0x47001507, 0x471c1818, 0x19101900, 0x19031920, 0x2208c283, 0x48150e25, 0x0f1e1919,
	0x7f1e5f1e, 0xcf1ebf1e, 0x470e051e, 0x1a1d540b, 0x501015fb, 0x16000606, 0x48180f0c, 0xba83063d, 0x3f33e127, 0xe1f61001, 0x20ba835d, 0x27bb825d,
	0x303132e1, 0x11215d5e, 0x3323b78a, 0x83023e32, 0x823320b6, 0x480334ce, 0x5e55502c, 0x527a4e3a, 0x2db8b62b, 0x2a4d4c50, 0x18b7a0b6, 0x280baa91,
	0x0fae66fe, 0x011d2b1c, 0x088f4fd5, 0x00a65808, 0x05810400, 0x001d00b6, 0x0b2e4070, 0x02041b04, 0x041d0f1c, 0x020e140e, 0x060e0e07, 0x165a1713,
	0x1f701f65, 0x2f021fa0, 0x1f10011f, 0x605a0901, 0xa0067006, 0x0406b006, 0xc0ffb806, 0x0a071640, 0x100e0648, 0x1b131d0e, 0x5f0c031d, 0x14170101,
	0x12170307, 0x843f3f00, 0x331726be, 0x2f32322f, 0x06f64801, 0x3227c982, 0x5e2f3911, 0x82c1335d, 0x015d21c7, 0x250a7b41, 0x11331133, 0xc7833636,
	0x06112329, 0x23110706, 0x41215002, 0x0c2c067f, 0x44763885, 0x7742baba, 0xfc018539, 0x08097b41, 0xfe580121, 0x192209b4, 0x4afac602, 0x251a5602,
	0x00c9fe0b, 0x009a0001, 0x04fe0300, 0x001c004a, 0x8442406b, 0x072308cd, 0x501c0e1b, 0x0d04010d, 0x0d240d14, 0x0d0d0803, 0x5a161206, 0x101e5515,
	0x801e601e, 0x5a09031e, 0x4a1d5406, 0x0d28068b, 0x121c0d0f, 0x0b031c1a, 0x1625c682, 0x160f0713, 0x74c68d15, 0xc48805f3, 0x5e23c585, 0x8930315d,
	0x913320c8, 0x2f0e21c7, 0x08058e41, 0x2f7d0627, 0xb6b6335b, 0x7d325932, 0x542f6a01, 0xa6014473, 0x01ae66fe, 0x0ee5fe2d, 0xd5012330, 0xe901b6fb,
	0xff103323, 0x57c58200, 0x3a08070f, 0x40500017, 0x14070436, 0x0c070207, 0x19650b5a, 0x195f192f, 0x198f196f, 0x19af199f, 0x19ef19cf, 0x100919ff,
	0x16020119, 0x1864175a, 0x005f1015, 0x02051005, 0x0b170505, 0x83030012, 0x2f3923b9, 0xae57e15d, 0x755d2005, 0x002505a6, 0x33135d5e, 0x06e84f11,
	0x23113308, 0x23263411, 0x07020e22, 0xbac72311, 0x5d62c373, 0xbb356592, 0x5a2d7b68, 0xba38655f, 0xaafdb605, 0x5e312d2d, 0xb8fd598a, 0x75732f02,
	0x141e140a, 0x2d5139fd, 0x04240805, 0x004a0412, 0xb93f0018, 0xe0ff1400, 0x0a072240, 0x18470048, 0x1aef1a55, 0x601a1001, 0x031a801a, 0x0a47090d,
	0x07749418, 0x510a0f21, 0x3921050f, 0x238b8e2f, 0x3411212b, 0x11227e86, 0x4c601133, 0x03112206, 0x06b7425c, 0xc942b620, 0x016b0808, 0x1c0fae9a,
	0x2bfe1c2c, 0x16fe4a04, 0x11202f1f, 0x4473532f, 0x02005afe, 0xecff3d00, 0xcd050606, 0x36002b00, 0x3e406400, 0x0b145b32, 0x380f3867, 0x2902381f,
	0x22012220, 0x5b0c3122, 0x801f7000, 0x031fc01f, 0x0c1f371f, 0x2b4f3160, 0xaf2b0f01, 0x032bff2b, 0x0801250f, 0x252b252b, 0x145f1105, 0x5f2c131a,
	0x3f000405, 0x4d333fe1, 0x5e3905d8, 0x33715d5d, 0x100132e1, 0xe1325dd6, 0x5d2f3332, 0xf6105dc1, 0x3031e132, 0x2ca68301, 0x15121616, 0x031e2115,
	0x37363233, 0x05884315, 0x2227eb08, 0x36343526, 0x06063337, 0x01331415, 0x07020e22, 0x022e3421, 0x5b0a6601, 0x998ddd9c, 0xfc3e88d6, 0x743f0725,
	0xcf8070a9, 0x695b2a5b, 0xeb984c7c, 0x8f095ca4, 0x9c0b129a, 0x02670f06, 0x6e955b89, 0x12030741, 0x038b5625, 0xabf49a39, 0xfec56b5b, 0x7a45abeb,
	0x2c4786c2, 0x1a0faa20, 0xb3610a12, 0x7a759bfd, 0x0f17422a, 0x0161233e, 0xb97e41f0, 0x80b87578, 0x02000043, 0xecff3300, 0x5e04b604, 0x35002c00,
	0x2b408400, 0x1e274831, 0x37ff3757, 0xb0379001, 0x371f0237, 0x3002377f, 0x0f05481f, 0x080108df, 0x05001308, 0x05200510, 0x50054003, 0xb8050205,
	0x2840c0ff, 0x05481310, 0x501f0536, 0x2b121b30, 0x120f0212, 0x2b0b1b01, 0x0b0f020b, 0x0b120601, 0x2d220b12, 0x22101850, 0x16002751, 0xe1323f00,
	0x3912e13f, 0x3b4b2f39, 0xe1333205, 0xc6100132, 0x32715d2b, 0xc15d2f32, 0x5d32e110, 0x0623415d, 0x2e220525, 0x41262702, 0x1621090f, 0x07296233,
	0x21153408, 0x32331616, 0x1537023e, 0x2203030e, 0x34210706, 0x3503022e, 0x4b82b36b, 0x128e8504, 0x0e069509, 0x0e1b3131, 0x5a98744c, 0x3b6e9e63,
	0x99054cfd, 0x19573397, 0x080e9b38, 0x46145982, 0x0281c788, 0x3f27726f, 0x223a0e15, 0xa96c312f, 0x81473e75, 0xc1716eb5, 0x1d130ab6, 0x1c13a212,
	0xdb030812, 0x7144959c, 0x00002c50, 0xfe3d0002, 0x0506067f, 0x002e00cd, 0x40720039, 0x1c5a1b46, 0x5b35221c, 0x3b670b14, 0x3b1f3b0f, 0x25202c02,
	0x34252501, 0x70005b0c, 0xc0228022, 0x3a220322, 0x34600c22, 0x0f012e4f, 0xaf2e3f2e, 0x280f032e, 0x282e0801, 0x1a05282e, 0x1d601114, 0x2ffb1b12,
	0x22062b42, 0x5933e13f, 0x2d420561, 0x39122216, 0x1631422f, 0x23110725, 0x42032e11, 0x252a2a33, 0x3a64584e, 0x8ac480b6, 0x3442084d, 0x170e2d26,
	0xfe020b11, 0x10730191, 0x8eebb06d, 0x08133a42, 0x33000275, 0xb60483fe, 0x2d005e04, 0x92003600, 0x47043040, 0x320b0505, 0x57242d48, 0x0138ff38,
	0x38b03890, 0x7f381f02, 0x25310238, 0xdf150b48, 0x0e0e010e, 0x100b0019, 0x030b200b, 0x0b500b40, 0xffb80b02, 0x102b40c0, 0x370b4813, 0x3150250b,
	0x182b181b, 0x01180f02, 0x112b111b, 0x01110f02, 0x18111806, 0x502e2811, 0x5128101e, 0x1606032d, 0x3f00fb04, 0x4233333f, 0x39412443, 0x06252205,
	0x06284106, 0x201d4c42, 0x06494201, 0x4285042a, 0x54b64c80, 0x03386389, 0x361c4d42, 0x857283fe, 0x1bec010b, 0x20355939, 0x95fe0423, 0x54117501,
	0x426fb284, 0x02211952, 0x064d42f0, 0xffff3a08, 0x00005200, 0xb6056402, 0x2c000602, 0xffff0000, 0x00000400, 0x69078106, 0xb0012602, 0x07010000,
	0xf4003602, 0x13005201, 0x17010b40, 0x00012605, 0x0a11121c, 0x352b0125, 0x85028200, 0xbe05232d, 0x2d821706, 0x2d86d020, 0x18009321, 0x8209af8e,
	0x070e212d, 0x00202d87, 0x08057563, 0xb605e143, 0x67002500, 0x1b1b3f40, 0x115b2105, 0x0a100a09, 0x48180c40, 0x11040a0a, 0x40271027, 0x080b0227,
	0x055a0408, 0x5f1f2664, 0x081c161c, 0x2f600003, 0xef0c5f0c, 0x040cff0c, 0x1510400c, 0x050c0c48, 0x06736309, 0x39123329, 0xe15d2b2f, 0x493f3333,
	0x3223050f, 0x715d3311, 0x382905ca, 0x11e11033, 0x30312f39, 0x05976201, 0x01113324, 0xa1520133, 0x0d756307, 0x4146022c, 0xbaba285c, 0xfdcf3502,
	0x095606d1, 0x487f370d, 0x7c437701, 0x116f02ae, 0x05b0fd0e, 0x023cfdb6, 0x5558fdc4, 0x7663eca3, 0x76b3220e, 0x08db823a, 0x0afeae54, 0x4a04e903,
	0x72002300, 0x080b4740, 0x2202081b, 0x231f1023, 0x1d232301, 0x1e0d0d05, 0x25054814, 0x5f01250f, 0x7f256f25, 0xbf259f25, 0xff25df25, 0x21000725,
	0x1e471d21, 0x1c212454, 0x000b5119, 0x0702001b, 0x221e0000, 0x151e0f1f, 0x0a0e5111, 0xd882001b, 0x21057648, 0xe6825d5e, 0xf6100123, 0x55e383e1,
	0x112006fd, 0x7129fe82, 0x30313338, 0x1e015d00, 0x054f6403, 0x21099263, 0x9363022e, 0x08fb8306, 0x5e2b0229, 0x3f4578a3, 0x4c57966f, 0x692c2f69,
	0x23757643, 0x204e724a, 0xb4b42955, 0x02c49801, 0x8440056a, 0xd59694d0, 0x631f4088, 0x6a2d0592, 0x102d6097, 0x0450fe0d, 0x010afe4a, 0x26dd82f6,
	0x057ffe00, 0x82b60556, 0x733a08dd, 0xb80207b1, 0x4640f8ff, 0x02481714, 0x0118895a, 0xe0181018, 0x1db4011d, 0x1dd41dc4, 0x501d0003, 0x1d07021d,
	0x210f1f1d, 0x5a002222, 0x251f2023, 0x25c02590, 0x0f0325f0, 0xf9821f25, 0x0f080333, 0x5f02fb21, 0x6013031d, 0x5f1f130c, 0x3f001200, 0x2a0184e1,
	0x5d5e2f01, 0x32d4105d, 0x6c39e132, 0x0e820535, 0x38335d2f, 0x322be15d, 0x11213031, 0x07030e21, 0x0cbc7e0e, 0x12363625, 0x6b213712, 0xd92a0519,
	0x200f85fe, 0x14102121, 0xb8184f35, 0xd02c120a, 0xa5d98fc3, 0xf5711205, 0x6751d4eb, 0x12f9b718, 0x20056e4c, 0x08e58200, 0x83fe1041, 0x4a046604,
	0x58001800, 0x46023840, 0x12e412d4, 0x70126002, 0xb012a012, 0x12340412, 0x0a121201, 0x00171716, 0x14151847, 0x1a201a55, 0x0f021ab0, 0x0a08011a,
	0x5002fb16, 0x4f0d0f12, 0x4a141607, 0xd38306e8, 0xf420d185, 0x3925d186, 0x5d5d5d2f, 0x20ca84e1, 0xf8a01802, 0x39c4840f, 0xfefefa02, 0x825f4014,
	0x10311c56, 0x59371c16, 0x02123345, 0xb77ab654, 0xa118037b, 0xfc250f00, 0x01e9fd50, 0x08af837d, 0x00fee53b, 0xb605f404, 0x4b001b00, 0x05052b40,
	0x5a0c1410, 0xc01d6517, 0x1dbf011d, 0x011d2001, 0x105a0f13, 0x5f0e1c64, 0x0801130f, 0x15101313, 0x12100311, 0x00065f09, 0x323f001c, 0x085742e1,
	0xf6100122, 0x2106eb46, 0x334332e1, 0x022e2106, 0x2507d965, 0x23112111, 0x05823311, 0x14113326, 0xd102020e, 0x22078e66, 0x5bfdc6bb, 0x522405c0,
	0x00fec992, 0x23068266, 0x1f02f7f0, 0x2507c95b, 0xf8aaddfa, 0x17434fa2, 0x3b042305, 0xa3824a04, 0x1a406924, 0xa3820303, 0x17473408, 0x1d001d55,
	0x30021d20, 0x501d401d, 0xf01dd01d, 0xb81d051d, 0x2840c0ff, 0x1348110e, 0x5410470f, 0xeb500e1c, 0x13a90113, 0x0f0213b9, 0x2f131f13, 0x84060313,
	0x100f25bf, 0x04510715, 0xbf8a4a82, 0x071d4418, 0x715d2b22, 0xc186c883, 0x22060743, 0x8e35023e, 0x4ca02ac1, 0x692c2f69, 0x3d5b3b42, 0x05a15a1f,
	0x663fb621, 0x2d2f088a, 0x01699661, 0x0417feb2, 0x0139fe4a, 0x66f3fbc7, 0xe5360687, 0xb6057ffe, 0x0f00b605, 0x32405200, 0x0d030302, 0x01045a05,
	0x1a5d1100, 0x50c02007, 0x205d0533, 0xd4102f2b, 0x32e13232, 0x31332f39, 0x03332530, 0xd85b1323, 0x04332609, 0xd98fc2f4, 0x171e5da6, 0x00010029,
	0x0483feae, 0x824a04f2, 0x4076318d, 0x0e0e0d4f, 0x0f470008, 0xbb0bab0c, 0x110b020b, 0x22581c5d, 0x885dd410, 0x0c1c5db1, 0x0320bc82, 0x23071c5d,
	0x7ab67bb7, 0x4209eb5b, 0xa62209a5, 0x8f4d7ffe, 0x40592a06, 0x1a5a1d21, 0x5a00161a, 0x0c824d19, 0x5a0e3008, 0x0b700b60, 0x0bb00ba0, 0xffb80b04,
	0x071440c0, 0x160b480a, 0x06065f11, 0xfb1b1a0c, 0x121a5f1d, 0x00030c17, 0xe13f333f, 0x3912113f, 0x4d33e12f, 0x32250b7e, 0x3031e12f, 0x0b3f4e25,
	0x23059249, 0x23113311, 0x03210182, 0x11f94ec7, 0xa6b0ba24, 0xf74eb001, 0xfe4a2414, 0x4e27027f, 0x754d05fb, 0x40402a06, 0x18471b25, 0x471c1418,
	0x08624d17, 0x0a470d33, 0xfb191d54, 0x05500f14, 0x501b0b05, 0x0b151518, 0x849e840f, 0x05df4e9c, 0xe1f61023, 0x209a8432, 0x12d94e01, 0x33209883,
	0x2113da4e, 0xdb4ea0b6, 0xb6fb2514, 0x170283fe, 0xc73d9782, 0xf2067ffe, 0x1f00b605, 0x36b69a00, 0x0039011f, 0xffb81f01, 0x0c2c40f8, 0x001f480f,
	0x29058208, 0x0c0d0d00, 0x13120910, 0x0d830e13, 0x010e3934, 0x5a151d0e, 0x21101114, 0x21c02120, 0x01210f02, 0x30830b08, 0x2a821020, 0x010b263f,
	0x5a08020b, 0x10206409, 0xffb80c5f, 0x091640f0, 0x09004812, 0x1215030c, 0x011efb12, 0x24468201, 0x0a0e0148, 0x2ad98203, 0x33112b33, 0x33173f3f,
	0x8401e12b, 0x2b5d21d7, 0x2307ad45, 0x2b5d3232, 0x2b05b145, 0x2b331139, 0x30312b33, 0x01215d5d, 0x2308546d, 0x01330121, 0x0805a445, 0x34112339,
	0x3637023e, 0x03012337, 0x0845fe23, 0x06040405, 0x011401ac, 0x9e01069c, 0x90c31401, 0x01baa6d9, 0x03020202, 0x41fe0804, 0x494a0005, 0xfc398b3f,
	0xfbb60596, 0x45a80458, 0x032a059f, 0x413d1977, 0x49471e42, 0x054302fb, 0x05700805, 0x004a04c7, 0x40870024, 0x1807085a, 0x22201018, 0x001e2323,
	0xaf212446, 0x0220bf20, 0x26e02620, 0x0126cf01, 0x26402630, 0x26a02650, 0x01260f04, 0x460f1206, 0x22255410, 0x0e3b01fb, 0x0e5b0e4b, 0x1b0e0b03,
	0x030e2b0e, 0x111e0e0e, 0x3450200f, 0x54184418, 0x18050318, 0x18251815, 0x18100803, 0x00150003, 0x5d32173f, 0x333fe15d, 0x5d5d2f33, 0x2005b850,
	0x21f98232, 0x10435d5d, 0x12112109, 0x3338f882, 0x11213031, 0x0107030e, 0x032e0123, 0x11231127, 0x031e0133, 0x37033e17, 0x2206bb71, 0x18066f04,
	0x2f142da6, 0x0e06050e, 0x010d1613, 0x7bb7d90e, 0x81037ab6, 0x1f31a618, 0x49055443, 0x002b12b5, 0xdd040000, 0x26026907, 0x49002400, 0x212005b5,
	0x2805b549, 0x26051a02, 0x151f0002, 0x08874904, 0x5e263d82, 0xa103ecff, 0x2d821706, 0x2d824420, 0x36020632, 0x130000d4, 0x38020b40, 0x25022611,
	0x220c333d, 0x8207b349, 0x2059852b, 0x2259872b, 0x83006a00, 0x40172c59, 0x1e02030d, 0x02032605, 0x85291501, 0xfd95185b, 0x215d8308, 0x1419059c,
	0xff2d287b, 0x060000fe, 0x02b60556, 0x00880006, 0x239d8500, 0x5e044406, 0xa8200f82, 0xc7240f84, 0xc8030000, 0x2820db84, 0xff21db85, 0x29db85fb,
	0x26051101, 0x0c160601, 0xaf8a0001, 0xdb827120, 0xdb84e120, 0xdb854820, 0x0719ea20, 0x00221641, 0x2b820002, 0x12053e08, 0x1e00cd05, 0x49002900,
	0x1a242f40, 0x2b670e5b, 0x2b8f2b0f, 0x2bbf2baf, 0x0b402b04, 0x5b25480f, 0x2a661903, 0x192f5f25, 0x197f195f, 0x09191903, 0x13135f1f, 0x095f0003,
	0xe13f0004, 0x06597133, 0xf610012a, 0x5d2be132, 0x32e1f610, 0x2005734a, 0x07564f35, 0x09a14718, 0x21355208, 0x3203032e, 0x2137023e, 0x02021e14,
	0x5bcf8079, 0x7d695a2a, 0xa5f4a04c, 0xe89d5154, 0x87d79996, 0x07db033e, 0x43a97340, 0x426d955b, 0x26edfc07, 0x29058c55, 0x0faa202c, 0x6c0a131a,
	0xabe9fec6, 0xc2ebfeae, 0x01c46b68, 0x7a46ab15, 0xfb4786c1, 0x05354f66, 0x00447f22, 0x6620cb82, 0xd722f782, 0xcb825e04, 0x00272d08, 0x22294043,
	0x57054811, 0x0129b029, 0x2301293f, 0x56101948, 0x9f502328, 0xcf10af10, 0x0410df10, 0x1f001010, 0x19160a50, 0x10005114, 0x5d20c58f, 0x3222c587,
	0x534a021e, 0x022e2b05, 0x26213535, 0x0e222326, 0xd7820702, 0x36321322, 0x3a08c284, 0xb66ee701, 0x78424983, 0x9e6366a7, 0xb5023b6e, 0x33979a05,
	0x274c5057, 0x57514c28, 0x0b857360, 0x391b14fe, 0x4a5e0458, 0x8887d28e, 0x474e95d6, 0x716eb581, 0x130ab6c0, 0x82a1121c, 0xfc092203, 0x09834c25,
	0xff712a08, 0x071205ec, 0x0226022b, 0x010000e1, 0x006a0007, 0x00520146, 0x0203b619, 0x03260533, 0xd3ffb802, 0x183e2ab4, 0x2b01250e, 0x08654235,
	0x0521ef84, 0x203382d9, 0x243382e2, 0xc46a0006, 0x21318400, 0x31841131, 0x28b4f425, 0x8c050f3c, 0x00042431, 0x83810600, 0x05d94c65, 0xf4206582,
	0x172c6582, 0x01020d40, 0x0226051b, 0x26120001, 0x8805db4c, 0x21318263, 0x6383be05, 0x00d00122, 0x91219785, 0x82658300, 0x82112030, 0xffb82530,
	0x2612b4ff, 0x8805e14c, 0xff482433, 0x84ec03ec, 0x85b12065, 0xbfff2133, 0x0222cb84, 0x64834301, 0xf4ffb827, 0x134e3ab4, 0x20998c0b, 0x20338244,
	0x20678452, 0x203386d1, 0x20678655, 0x20678543, 0x6c3382d9, 0x6785051c, 0x00010022, 0x64086784, 0x2000b605, 0x2d407200, 0x1c1b5b00, 0x4020205b,
	0x1d481810, 0x1b20201b, 0x160d031d, 0x2267055b, 0x7001229f, 0x020d800d, 0x0d4f0d3f, 0x0d030d5f, 0x1e5f1d20, 0xf0ffb81b, 0x0d071840, 0xaa191b48,
	0x00780100, 0x01000f01, 0x1e000008, 0x0e601303, 0x3f00130a, 0x393fe133, 0x5d5d5e2f, 0x2b33335d, 0x0132e110, 0x230a822f, 0x12e1f610, 0x25054e5c,
	0xe110e110, 0x6f4c3031, 0x9744180b, 0x35233108, 0x21352101, 0x73f40115, 0x434784ba, 0x6e89cd88, 0x0a44bd18, 0x017b2108, 0x03a6fda6, 0x053b033d,
	0x66976435, 0x4074a060, 0x17aa2d22, 0x940d1824, 0x97818787, 0x91a6d101, 0x1b23d382, 0x630314fe, 0x3d080545, 0x003e4064, 0x4a201f4a, 0x13402424,
	0x1f214818, 0x211f2424, 0x47180d03, 0x6f265705, 0x02269f26, 0x0f012630, 0x0d070126, 0x48110c40, 0x5021240d, 0x001d1f22, 0x480c0920, 0x0f220000,
	0x3a4d5013, 0x2f392407, 0x8433332b, 0x832b20c3, 0x18c59fd0, 0x85089652, 0xa83e08c7, 0x497da85f, 0x73ba8447, 0x1f3ab573, 0x36665b4e, 0x30567747,
	0x548b6337, 0xfd92016d, 0x010603c6, 0x754107d5, 0xb76e6ca6, 0x22244984, 0x181f10a6, 0x7d572e0f, 0x527d564e, 0xed017d27, 0xbd18859a, 0x063d0731,
	0x012602c1, 0x010000b2, 0x004d0107, 0x005201b0, 0x1a01b415, 0xb8012605, 0x18b4feff, 0x9b641819, 0x00ae260c, 0x053b0400, 0x202f826f, 0x242f82d2,
	0x394d0106, 0x212d8300, 0x2d83110e, 0x0cb4ff25, 0x44040a0d, 0xc9260ae9, 0x10050000, 0x5d872b07, 0x006a0023, 0x0669429c, 0x69422120, 0x205f8205,
	0x425f852c, 0x91820535, 0xd9206185, 0x00226187, 0xcf42256a, 0x42152005, 0x63820567, 0x63852020, 0x7d243188, 0x7105ecff, 0x00216583, 0x059b4232,
	0x43aa0021, 0x032b0535, 0x26053102, 0x28010203, 0x42000a3c, 0x71250ccd, 0x2d04ecff, 0x21638205, 0x99435200, 0x43f92005, 0x29200599, 0x23059943,
	0x3420b4f9, 0x6384318e, 0x02cd052a, 0x007e0206, 0x00ffff00, 0x04214184, 0x200f825e, 0x880f847f, 0x211f8383, 0xe9820701, 0x04298386, 0x26053303,
	0x2a010304, 0x88518e3e, 0x82022083, 0x06012141, 0x00283182, 0x0d401700, 0x112b0304, 0x00222f82, 0x2f8e3622, 0xb3823b20, 0xe5834420, 0x82c70121,
	0x216182b3, 0x4b4197ff, 0x412e2006, 0xa625054b, 0x043925b4, 0x24e78c0c, 0x03ecff37, 0x21e78342, 0x3386e701, 0xb5433820, 0x41302006, 0xca25054d,
	0x033b27b4, 0x20338c22, 0x26678219, 0x02c106ae, 0x83bd0126, 0x4d012333, 0x11422700, 0x05242105, 0x22051142, 0x46132322, 0x0a2a0bcd, 0xdf0314fe,
	0x26026f05, 0x11425c00, 0x00bb2d05, 0x0b401300, 0x26112501, 0x24230101, 0x0c47f618, 0xc3845b84, 0xf3825b84, 0xc3861220, 0xc3852b20, 0x22b4fd23,
	0x415d8536, 0x131908dd, 0xa7281017, 0x40170000, 0x2c01020d, 0x0122c283, 0x61853723, 0x63852f88, 0xbf887320, 0x66005322, 0x22050d42, 0x832e0102,
	0x95512064, 0x21062161, 0x5321c188, 0x20618600, 0x2061832f, 0x2361905a, 0x040000a6, 0x2005a545, 0x055541c1, 0x87540021, 0x831f2061, 0x160f2261,
	0x0ebb412a, 0x00009a26, 0xd905fe03, 0xe1209382, 0x06233182, 0x86066a00, 0x83222061, 0x19082461, 0x410a172d, 0x434b0983, 0x034b0805, 0x00b605be,
	0x40640009, 0x0100140b, 0xd00100e4, 0x00020100, 0x40c0ffb8, 0x48130835, 0x2f0b0000, 0x6f0b4f0b, 0x040b8f0b, 0x1811400b, 0xbf5a0748, 0x0204cf04,
	0x0f010484, 0x02041f04, 0x03040407, 0x0a64085a, 0x03095f02, 0x5c075f03, 0x3f2006f8, 0x34051a4b, 0x5d5d5e2f, 0x5d2be15d, 0x2b2f3311, 0x715d5d5f,
	0x15013031, 0x078a4c21, 0xc3fdbe2e, 0x05bab0b0, 0x96fba6b6, 0x8101d9fd, 0x01288382, 0x83feae00, 0x4a040a03, 0x4e268d82, 0x02203240, 0x00820230,
	0xc00b2a08, 0x0ba1010b, 0x010b7001, 0x06bf4709, 0x840206cf, 0x060f0106, 0x0702061f, 0x47050606, 0x050a5400, 0x08150950, 0x015004fb, 0x05a6750f,
	0xf6100124, 0x7a8532e1, 0x25056d5d, 0x3330315d, 0x79862111, 0x5c02ae28, 0xb6a05afe, 0x88634a04, 0xffff2d06, 0x0000c700, 0x2b07cf05, 0xc5012602,
	0x20066541, 0x056541fc, 0x2703042b, 0x03042605, 0x06321e00, 0x0cb9421c, 0x3182ae20, 0xd9055022, 0xe5203182, 0xb0203186, 0x8205c941, 0x85112031,
	0x0d0a2131, 0x2f2a318c, 0xbe036dfe, 0x2602b605, 0x31839b02, 0x00800323, 0x2a3182a6, 0x1f01b30a, 0x1001071f, 0x8235113c, 0x82122087, 0x82fd8223,
	0x849c2023, 0x00812223, 0x20238789, 0x2a23870d, 0x046dfe00, 0x00b6059a, 0x843b0026, 0x03802223, 0x35238223, 0x1d01b117, 0xb2c0ffb8, 0xb8481513,
	0x1db49eff, 0x2500001d, 0x95542b01, 0x82232005, 0x04112231, 0x2031824a, 0x2231845b, 0x829a0281, 0xb3122831, 0x011d5001, 0x829affb8, 0x0707212c,
	0x5d212c82, 0x06bb6335, 0x5d826020, 0x00113308, 0x462740b2, 0x020f560f, 0x09590949, 0x01003602, 0x06010639, 0x04000f09, 0x0103030c, 0x3f011130,
	0x11070107, 0x01051107, 0xffb80a0b, 0x0a0ab3f0, 0x07820504, 0x05144034, 0x0e100e0d, 0x1001020e, 0x70010100, 0xc0018001, 0x64820301, 0x2740c028,
	0x01480a07, 0xc0501301, 0x137f3a05, 0x06000804, 0x28090f5f, 0x0c270103, 0x0a0c0301, 0x0d010909, 0x0105030a, 0x06d87012, 0x39112f2b, 0x115d5d39,
	0x0132e133, 0x6106825e, 0x332205b1, 0x0283382f, 0x11250383, 0x2f393912, 0x2621822f, 0x332f3d39, 0x825d3317, 0x30312400, 0x83230101, 0x35212502,
	0x01330121, 0x21260282, 0x01c50215, 0xa961d39b, 0xfe9a2605, 0xfe1401df, 0x06ad6192, 0x018e4008, 0xfdb4021c, 0xfd7b024c, 0xa4b40285, 0xd1fd5e02,
	0xa2fd2f02, 0x000100a4, 0x03000023, 0x004a04db, 0x40170111, 0x900880bf, 0x00080208, 0x0f0b0008, 0xf7010506, 0x05e50105, 0x01053601, 0x82070605,
	0x0d9508f0, 0x0d101001, 0xf8010309, 0x03ea0103, 0x01033901, 0x066b0203, 0x5702067b, 0x063a0106, 0x6402064a, 0x02027402, 0x35010258, 0x02024502,
	0x020d0206, 0x0f03060d, 0xf7010c06, 0x0ce5010c, 0x010c3601, 0x16400b0c, 0x400b4819, 0x6b48110e, 0x020b7b0b, 0x3a010b57, 0x020b4a0b, 0x10130b0b,
	0x02133013, 0x13b01390, 0x01130f02, 0xf8010e09, 0x0eea010e, 0x010e3901, 0x7b0f6b0e, 0x0f58020f, 0x450f3501, 0x0d0f020f, 0x044f100a, 0x0101ef07,
	0x011b010b, 0x015b012b, 0x289c826b, 0x0f020101, 0x0205150b, 0x074c410f, 0x5d5d5e26, 0x32e13333, 0x2405bd48, 0x5d5d5dc1, 0x22028271, 0x822fce10,
	0x2b2b2109, 0x12250f84, 0x2f3d3917, 0x07946118, 0x13841020, 0x83331121, 0x86048201, 0x0572410e, 0x13303123, 0x058e6121, 0x21152122, 0x08067041,
	0x0001685f, 0xfacfcffe, 0xcdfecffa, 0xf7fe0401, 0xfecf4a01, 0xcff2fef4, 0xfbfe4a01, 0xcf017b02, 0x9a0166fe, 0xfe8931fe, 0xfeb4010e, 0x00f2014c,
	0x89000200, 0xf6030000, 0x0e00b605, 0x40001900, 0x19062940, 0x1b65095a, 0x10011b9f, 0x5b15011b, 0x0f1a6600, 0x4f063f5f, 0x9f066f06, 0xdf06bf06,
	0x28008206, 0x095f1907, 0x00030712, 0x09634c3f, 0x9c4be120, 0x34132407, 0x8233023e, 0x211125a7, 0x01022e22, 0x0805d36a, 0x3333162e, 0xcf7f3789,
	0xfebb9598, 0x7ec28695, 0x81b2023c, 0x2e5b8a5d, 0x019fafa3, 0x719857ac, 0xfa680242, 0x9e703d4a, 0x3c1b5f01, 0x84884661, 0x27076747, 0x02140602,
	0x00470006, 0xff23a384, 0x823b06ec, 0x232108a3, 0x63003200, 0x09183f40, 0x1a1a5a32, 0x015a2211, 0x340f3465, 0x9f346f01, 0x0334ef34, 0x34503440,
	0x080e8202, 0x5b2a0633, 0x24336611, 0x2323175f, 0x174f173f, 0x17bf176f, 0x170517df, 0x1d031817, 0x0609602d, 0x3f00130e, 0x32e13333, 0x5d2f393f,
	0xe1102f33, 0xe1f61001, 0xe269185e, 0x39e12f09, 0x01303132, 0x020e1411, 0x27262223, 0x4718030e, 0xd4830756, 0x33161428, 0x35023e32, 0xd8870511,
	0x53080d83, 0x5b2d3b06, 0x99725e8c, 0x523f182b, 0xe4d73f67, 0x96d78a41, 0x6167bb7a, 0x1c33482c, 0x5d81bafd, 0x7e2d5b8b, 0x385b4386, 0xfe500317,
	0x668b5118, 0x264d613a, 0xd2192e3f, 0x72a367d6, 0xfb68023c, 0x1e6970b2, 0x01325039, 0x431ea6e8, 0x82804d6b, 0x294d3e25, 0x7120f383, 0x5a22f382,
	0xf1821406, 0x00433d08, 0x1039405c, 0x5047382c, 0x2e2e012e, 0x0647031b, 0x456f4555, 0x459f457f, 0x45ef45cf, 0x01454005, 0x452f450f, 0x48410602,
	0x0444561b, 0x503e3304, 0x2c102025, 0x50330000, 0x16160b10, 0x3f22ed86, 0x4e18e133, 0x5d21082e, 0x20f3825d, 0x2aff8211, 0x313932e1, 0x36322530,
	0x85331135, 0x022e23f1, 0x16522327, 0x063a6b06, 0x26331725, 0x83262627, 0x031e2220, 0x08ef8221, 0x34353737, 0x2223022e, 0x16141506, 0x626fd304,
	0x8b5c2fb6, 0x5167415b, 0x1b06173d, 0x51795b44, 0x3c6e9a5d, 0x5d9a6e3c, 0x3b4d603b, 0x03030c17, 0x01b60402, 0xfd512c0f, 0x087e7ea6, 0x7f7f873e,
	0x01828283, 0x69c1fe35, 0x1e2e6298, 0x292c4a36, 0x4820374a, 0x8d8cd48f, 0x1a4990d5, 0x0805937e, 0x0111366d, 0x3e92fbb4, 0x2e2d4e6a, 0x295f8c5e,
	0x376b9d65, 0xcdd1ccda, 0x00010000, 0x06ecff4e, 0x00cb0544, 0x4085003f, 0x205b0d56, 0x252b5b00, 0x2b200720, 0x0307202b, 0x365a3316, 0x417f4165,
	0x419f418f, 0x41ff41ef, 0x20410005, 0x03413041, 0x16801670, 0x4f163f02, 0x16160216, 0x60062540, 0x01340007, 0x07df3434, 0x0107aa01, 0x6b010778,
	0x1b280500, 0x133b5f30, 0x1b601215, 0x2109404f, 0x00825d5e, 0x5d2f3327, 0x1139e110, 0x4c078201, 0x11270571, 0x2f2f3917, 0x4c39122f, 0x34270672,
	0x2323022e, 0x4b323335, 0x222106a5, 0xc9af1806, 0x1507230b, 0xa97f031e, 0x0a644106, 0x29033a08, 0x5d926535, 0x8e5cb0bf, 0x44253261, 0xa96e3a5f,
	0x62265c4b, 0x6d478374, 0x333971a6, 0x574b7d5b, 0x18325e8a, 0x6f374f32, 0x6638b762, 0x94575991, 0x87013c6c, 0x21466d4d, 0xd55d1897, 0x1f74080a,
	0x36182936, 0x4a4f8561, 0x0c395877, 0x59390b06, 0x684a4877, 0x81771e41, 0x2dfec901, 0x2e629869, 0x009c642f, 0x50000100, 0xa205ecff, 0x3b005e04,
	0x23408100, 0x20004715, 0x31363146, 0x19310019, 0x03003119, 0x0b470827, 0x3d0f3d55, 0x013dd001, 0x30013dbf, 0xb827013d, 0x2940c0ff, 0x5f481512,
	0x27270127, 0x5019363c, 0xdf09091a, 0x1a99011a, 0x0b021aa9, 0x2e06907d, 0x50232605, 0x5005102c, 0x3f001610, 0x73e13fe1, 0x5d230566, 0x412f335d,
	0x2b20072a, 0x25075243, 0x2f2f3917, 0x2d41112f, 0x1e142308, 0x70423302, 0x3435220c, 0x083e4126, 0x41232621, 0x0331113d, 0x50311552, 0xb660693b,
	0x608f5f2f, 0x3564905c, 0x3b5d1885, 0x4d28360c, 0x56355a52, 0x1c3a6990, 0x322b4633, 0x01223c53, 0x3849274c, 0x09614221, 0x7b542b23, 0x105d184f,
	0x1d13240b, 0x18260913, 0x39088bbb, 0x523e2909, 0x00010000, 0x047ffe4e, 0x00cb059c, 0x40830031, 0x275b0f54, 0x01822209, 0x01184a08, 0x802e705a,
	0x2e2e022e, 0x2f2f5a00, 0x01330033, 0x33d033c0, 0x01339f02, 0x33203300, 0x70033330, 0x02188018, 0x184f183f, 0x32181802, 0x0827fb30, 0x0109df60,
	0x780109aa, 0x090f0109, 0x09090801, 0x60141701, 0x5f2e041d, 0x054f5a01, 0x23072641, 0x3f39e15d, 0x36075042, 0x3311715d, 0x2f32e12f, 0x3912e15d,
	0x122f2f39, 0x3031e139, 0x42112321, 0x15292155, 0x03231133, 0x6738bbec, 0x1f494295, 0x01b0b027, 0x416443a0, 0x1e3c4220, 0xd9fdfa38, 0x50000100,
	0xf20383fe, 0x2d005e04, 0x1a408d00, 0x221d460c, 0x0182061d, 0x00132308, 0x2d292947, 0x302a2047, 0x602a402a, 0xb82a042a, 0x0e40c0ff, 0x2a48130f,
	0x2fc02f2a, 0x2fe02fd0, 0x12831303, 0x122d2a08, 0x135f4815, 0x2e131301, 0x0522fb2b, 0x0106df50, 0x06a90699, 0x5f064f02, 0x060b0206, 0x0702061b,
	0x12000606, 0x1018500f, 0x07925a29, 0x20081441, 0x061441e9, 0x2305a44a, 0x2f32e15d, 0x25071241, 0x3031e110, 0x28421121, 0x1515281e, 0x11231133,
	0x42819c02, 0x2c29191f, 0xa0263f52, 0x5e2b01b7, 0x205f1865, 0x0d0f4209, 0x422c0e25, 0x5a913d5b, 0x770807c7, 0x06e9ff00, 0x00b605ec, 0x40920031,
	0xe706d765, 0x07060206, 0x01d70101, 0x010201f7, 0x10171c5a, 0x8b481810, 0x10170117, 0x17480e07, 0x1e5a311c, 0xe0011eb0, 0x1cb4011c, 0x1cd41cc4,
	0x501c0003, 0xa01c901c, 0x1c07041c, 0x0e1e1c1e, 0x65275a24, 0x6f334f33, 0x9f337f33, 0xdf33af33, 0x33200633, 0x01330f01, 0x1225250e, 0x031c5f01,
	0x2c601221, 0x3f00130b, 0x3f32e133, 0x2f20f782, 0x2207df50, 0x62393911, 0x102f0608, 0x2b3311e1, 0xe1102b5d, 0x5d32715d, 0x5c013031, 0x1420187b,
	0x08478218, 0x23020e27, 0x35022e22, 0x1e885c03, 0x446e6321, 0x92220768, 0x915c3a68, 0xd1fb231a, 0x5e447781, 0x2c4d0809, 0x006c9960, 0x10000100,
	0x0006ecff, 0x28004a04, 0x39405c00, 0x28114601, 0x13a01347, 0x0111db01, 0x900111c4, 0x0211a011, 0x10011124, 0x13110111, 0x1b091311, 0x2a551e47,
	0x2acf2a7f, 0x09032aef, 0x010c1c1c, 0x180f1150, 0x06234f0c, 0x22f98c16, 0x84e1f610, 0x05ac6af7, 0x20066845, 0x11a05c21, 0x5c114d44, 0x414414ae,
	0x6691220b, 0x10b95c36, 0x413dfd25, 0x44204162, 0x2e230933, 0x83699662, 0xffc728d9, 0x052d07ec, 0x821d00b6, 0x1b3724d9, 0x82a05a13, 0x003108ed,
	0x095a0617, 0x1fc01f65, 0xbf1faf01, 0x1f20021f, 0x011f0f01, 0x175a161a, 0x5f151e64, 0x0f07071a, 0x1a08011a, 0x181c171a, 0x03121703, 0x00130e5f,
	0x08d25c3f, 0x20076e48, 0x47d68332, 0x31220882, 0xb0410130, 0x091c5c10, 0x62d50437, 0xb6636e6f, 0x59906638, 0x3a689158, 0xbaba66fd, 0x01ba9a02,
	0x0f884187, 0x782d0121, 0x37080bab, 0x8b06ecff, 0x1f004a04, 0x47406c00, 0x05471a02, 0x470d1e05, 0x00215510, 0x02212021, 0x21502140, 0x21902180,
	0x21f021b0, 0x01210f06, 0x1e471d01, 0x501c2054, 0xeb0e0e01, 0x10c1bd18, 0x1f031e29, 0x0a151e0f, 0x8a161550, 0x05e745c7, 0x9f5d0120, 0x85712005,
	0x32e121c8, 0x8f5dc782, 0x10e14505, 0x1121353b, 0x64011123, 0x15b62102, 0x6a3b5031, 0x5f2fb65f, 0x925b608f, 0xdffd3666, 0x05d35cb6, 0x22138041,
	0x8217fe6e, 0x003808c2, 0xff7d0001, 0x055205ec, 0x002a00cb, 0x2a294047, 0x5b290c2a, 0x09401401, 0x1414480e, 0xbf2c6701, 0x2c70012c, 0x0c5b1f01,
	0x5f2a2b66, 0x1a240000, 0x0411155f, 0x13075f24, 0x3325af83, 0x2f3912e1, 0x27a883e1, 0xe6105d5d, 0x102b2f32, 0xa8821083, 0x18152121, 0x270ca15e,
	0x16323324, 0x032e0717, 0x0805d749, 0x33021e54, 0x35023e32, 0x02170321, 0xde8e423b, 0xa6f29d9c, 0x01b65f56, 0xcc6fab0b, 0x53244858, 0x7a2e5d58,
	0x36427fbc, 0x6c75ab70, 0xfe295d95, 0x56f60288, 0xaffefea8, 0x01c3695b, 0x01acae17, 0x2c69c316, 0x1e11a22a, 0x98510e17, 0xd88289da, 0x7742569c,
	0xc78264a6, 0xecff7131, 0x5e047b04, 0x81002800, 0x28285a40, 0x8247270c, 0x110c21c7, 0x4b08c783, 0x2a142a57, 0xe4022a24, 0x022af42a, 0x02012ad0,
	0x2a502a40, 0x2aa02a80, 0x1d052ac0, 0x29560c48, 0x40005028, 0xcb481915, 0xeb00db00, 0x00a90300, 0x8f0200b9, 0x02009f00, 0x001b000b, 0x0603002b,
	0x18220000, 0x10111550, 0x16075022, 0x5e21f888, 0x2000825d, 0x23fe852b, 0x715d5d5f, 0x440f0141, 0x3421061c, 0x82ef823e, 0x054957fe, 0x2005ac48,
	0x08fe823e, 0x027b0245, 0xba783900, 0x88cb8781, 0xdb954c44, 0x4dad6f8f, 0x5b943c3e, 0x34659561, 0x5e875629, 0x234a7451, 0x4a02b8fe, 0x89c88244,
	0xd3934f47, 0x94d38284, 0x8d272550, 0x6d3a291d, 0x9b5d629d, 0x502d3e70, 0x82004470, 0x821420f7, 0xc93508f7, 0x1900b605, 0x2f406500, 0x65095a06,
	0x7f1b4f1b, 0xaf1b9f1b, 0x1b00041b, 0xef18af01, 0x18840218, 0x00181801, 0x1540135a, 0x01150f01, 0x57151508, 0x77136713, 0x05534613, 0x0a07102c,
	0x15191348, 0x0707165f, 0x52430316, 0x2f392107, 0x74053f55, 0x9d490a90, 0x154e4305, 0x1521352a, 0x62710221, 0xb7626e6f, 0x27054a43, 0x5efe3a69,
	0x5ffefe03, 0x21114943, 0xdf6d9503, 0x08b58205, 0x4a046f3c, 0x6d001b00, 0x470d4a40, 0x0f1d5510, 0x1dcf011d, 0x1dff1def, 0x401d3003, 0x031d601d,
	0x1d1f1d0f, 0x01030f02, 0x0f0103cc, 0x0203bf03, 0x05030306, 0x00601a47, 0x00d00070, 0xf9821f03, 0x1a00003d, 0x1a021a10, 0x0a010e0e, 0x04161550,
	0x0f015000, 0x32e13f00, 0x3911e13f, 0x822f012f, 0x054a75ba, 0x5d5d5e23, 0x062e4971, 0x13303122, 0x1120aa83, 0x3a11d844, 0x35032911, 0x3115c1fe,
	0x5f693b50, 0x8f5f2fb7, 0x66925c60, 0x9ab00336, 0x44d7fd9a, 0x022111bc, 0x207d8235, 0x08c1826f, 0xcb050c43, 0x5d003900, 0x345b13b4, 0xffb8001a,
	0x172e40c0, 0x1a00481a, 0x0a2f1a00, 0x9f3b270a, 0x5b20013b, 0x343a662f, 0x18aa601b, 0x01187801, 0x0801180f, 0x23051818, 0x132a2660, 0x050b600e,
	0x333f0004, 0x820282e1, 0x34a482af, 0x0139e15d, 0x5de1f610, 0x2f32ce10, 0x2f393912, 0x39122b2f, 0x26b182e1, 0x33023e34, 0x77021e32, 0x33210c7f,
	0x08244d15, 0x0e793620, 0x022e2205, 0x08288235, 0x2e353763, 0x733b9c03, 0x7b486da9, 0x5c265a69, 0x3967a24b, 0x2c26445f, 0xc3578257, 0x65925dbf,
	0x6ca4aa35, 0xc05353cc, 0x83c38080, 0x895f3142, 0x54784a57, 0x4f60042d, 0x18366185, 0x7d1f3629, 0x3a1e4336, 0x643e3653, 0x21972748, 0x89436543,
	0xaa2b318e, 0x6f3c2526, 0x7b48609c, 0x060b3d5e, 0x7758390c, 0x30fb8200, 0x03ecff5c, 0x005e046a, 0xb46d0037, 0x011e4632, 0x20fb8323, 0x08fb823d,
	0x23012339, 0x0f2b1801, 0xe039d039, 0x0339f039, 0x4001398f, 0x47050139, 0x1d385618, 0x37ef5002, 0xb937a901, 0x370f0237, 0x372f371f, 0x37370603,
	0x2c502f0a, 0x500a1028, 0x4116130f, 0x1220060a, 0x41058458, 0x5d25060a, 0x32ce105d, 0x090b4111, 0x23150124, 0x43430622, 0x83f78f07, 0x323321ff,
	0x85066a43, 0x02830825, 0x858a819e, 0x37604629, 0x4d576133, 0x73af3c1e, 0x356ba26e, 0x30594328, 0x1e35492b, 0x5690693a, 0x3f50a25a, 0x6647834b,
	0x5f44266d, 0x99870239, 0x45335e5b, 0x160e122a, 0x1da2101e, 0x78563028, 0x405b3d47, 0x0e0b0d29, 0x324d3b29, 0x264a6d46, 0x22932725, 0x2d4d4d26,
	0x00122740, 0x0000ffff, 0x2f056dfe, 0x2602b605, 0x0000b501, 0x80030701, 0x0000b803, 0x01b40d00, 0x00313101, 0x113c1001, 0x83350035, 0xfe102627,
	0x044c046d, 0x2027824a, 0x212784d5, 0x07820281, 0x26212784, 0x26278b26, 0x0498fe00, 0x5dbc05dd, 0x672208cf, 0x4f82d304, 0x0b40132a, 0x27141802,
	0x1b150002, 0x210dcf5d, 0x841898fe, 0x67220cc3, 0x2d866f04, 0x27173626, 0x39330d02, 0x2012d15d, 0x225b88e1, 0x5dd10466, 0x0226054f, 0x0226051b,
	0x2b5e2a21, 0x069c2211, 0x202d828f, 0x23b18344, 0x75046602, 0x39255b86, 0x36022611, 0x132d5e48, 0x5b87d120, 0x04770323, 0x2d5b82cb, 0x0203b619,
	0x03260515, 0xffffb802, 0x5f861db4, 0x26085356, 0x04ecff5e, 0x877f0647, 0x20338261, 0x05595489, 0x33020323, 0x21348211, 0x63863b33, 0x1e823188,
	0x07dd0422, 0x78206589, 0x1d206588, 0x25216587, 0x0e955e1d, 0xecff1224, 0x658a9c03, 0x88047821, 0x843b2065, 0x3b432165, 0x8d052541, 0x4a082165,
	0x7920cb88, 0x0622cba6, 0xcb88f806, 0x65897920, 0x0821cb9b, 0x20658862, 0x20cba27a, 0x21cb835e, 0x65881007, 0xcb8e7a20, 0x31410b20, 0x98fe2511,
	0x7307dd04, 0x002a6585, 0x004b0127, 0x0152011f, 0x57420207, 0x40253105, 0x142d0310, 0x05150227, 0x2a000326, 0x25070430, 0x240ca941, 0x2b00352b,
	0x05595535, 0x98fe5e26, 0x21069c03, 0x00257985, 0xd44b0126, 0x2b458400, 0x0000006f, 0x03164022, 0x0227174b, 0x0d27e883, 0x220c4e48, 0x87250225,
	0x21428688, 0x2782ffff, 0xdd040024, 0xef881308, 0xef847b20, 0x0d401725, 0x82260203, 0x0002237e, 0xb9412129, 0x21ed840e, 0xed88c106, 0x7b047b22,
	0x27071f42, 0x03261144, 0x3f471e02, 0x8914b941, 0xb07c2063, 0xa67c2063, 0x88582063, 0x897d20c7, 0x841a2063, 0x13e742c7, 0x079c0323, 0x20c78806,
	0x2063897d, 0x41c78438, 0x002311b5, 0x42dd0400, 0x7e200a1b, 0x194263a6, 0x8f7e2009, 0x5e502163, 0x250f2b41, 0xdd0498fe, 0x19425b07, 0x004e2408,
	0x426d0121, 0x22270819, 0x2e031640, 0x83022714, 0x2b0026d2, 0x25070431, 0x084c6202, 0x2609d341, 0x0398fe5e, 0x42ee059c, 0x4e200815, 0x230e1542,
	0x0227174c, 0x0d22e283, 0x7d824f49, 0x621e0221, 0x41890762, 0x4182c720, 0xb605be22, 0x28214182, 0x05514200, 0x6544aa20, 0x0f012705, 0x03012714,
	0xe361120c, 0x222d820d, 0x825e04e1, 0x8648202d, 0x85be202d, 0x2b02212d, 0x30246982, 0x0f052e28, 0x260a275d, 0x030000c7, 0x88e107be, 0x0466225b,
	0x05ef4491, 0x05120126, 0x210d0126, 0x20133f62, 0x225b888f, 0x86980466, 0x112e265b, 0x3d2d0226, 0x205b9228, 0x235b8735, 0xd4ff5201, 0x15235b82,
	0x821401b4, 0xffb8255a, 0x2315b4fb, 0xff25b98d, 0x05e103ec, 0x2a5d86e3, 0xde520106, 0x40130000, 0x8230020b, 0x311e225b, 0x235b8f3f, 0xd1075c04,
	0x03235b87, 0x829e0477, 0xb619245b, 0x5b0c0102, 0x142007cf, 0xb344bb86, 0x45712008, 0x4824084b, 0x07010000, 0x250b4b45, 0x03261128, 0x35190302,
	0x318807bb, 0x00002724, 0x658abe03, 0x65887820, 0x0227c282, 0xfdffb801, 0x85141cb4, 0x203388c3, 0x21c58312, 0xc5867f06, 0x45030721, 0xc8820a4b,
	0x38216582, 0x88c98530, 0x00c72631, 0x081b0400, 0x20cb884a, 0x45cba679, 0xcb85054b, 0x960a4b45, 0x236582cb, 0x6208be03, 0x7a206588, 0x7120cba2,
	0x0721cb83, 0x45cb8810, 0xcb970a4b, 0x0398fe25, 0x857307be, 0x27002565, 0xf1ff4b01, 0x3a064b45, 0x000000aa, 0x02104025, 0x01271424, 0x0226050c,
	0x01272103, 0xb8012500, 0x41b4fdff, 0x4b4507a9, 0x8271200a, 0x06e12247, 0x24798521, 0x4b012600, 0x09f942de, 0x16402227, 0x27174003, 0x25e88302,
	0x05433d1c, 0xba41250f, 0x09354309, 0x00005226, 0xe1076402, 0x2c214182, 0x223b8300, 0x42b00366, 0x13200ad9, 0x200ed942, 0x22238262, 0x828f06d7,
	0x86f3202d, 0x825e202d, 0x40132aaf, 0x110a010b, 0x19130126, 0x0ca94204, 0x98fe5226, 0xb6056402, 0x67225b88, 0x2d82be03, 0x01b41523, 0x23dc820f,
	0xb4ffffb8, 0x260e9343, 0x0198fe9e, 0x82e50575, 0x844c202f, 0x0367225d, 0x212f846d, 0xc6821502, 0xfeffb827, 0x041812b4, 0x0a95430c, 0x98fe7d26,
	0xcd057105, 0x32202f82, 0x05212f85, 0x288d855c, 0x27142b02, 0x2e280002, 0x0b075f0a, 0x98fe7126, 0x5e042d04, 0xf3822d82, 0x02070125, 0x85b20467,
	0x8423205d, 0xb4ff235d, 0x2f8c2620, 0x20053160, 0x225d88e1, 0x414e0566, 0x02270519, 0x0226052e, 0x8c283d15, 0xff71262d, 0x062d04ec, 0x225d888f,
	0x86a40466, 0x1126268b, 0x35130226, 0x852d8c20, 0x87d1205b, 0x7703235b, 0x3b5d5805, 0x02032805, 0x03260528, 0x86300502, 0x0c95435d, 0x7f066822,
	0x03235f87, 0x82aa0477, 0xb619255f, 0x11200203, 0xb8243082, 0x28b4faff, 0x77616386, 0x2065890e, 0x20658978, 0x21658430, 0x075f3038, 0x8433200e,
	0x206589c5, 0x20658878, 0x90658728, 0x21cb8499, 0xcb884a08, 0xcba47920, 0xf8062d22, 0x7920cb88, 0x0821cba7, 0x20658862, 0x20cba07a, 0x21cb8371,
	0x65881007, 0xcba37a20, 0x0598fe25, 0x85730771, 0x27002565, 0xae004b01, 0x22059743, 0x48005c05, 0x402d059d, 0x28022714, 0x00032605, 0x000a433d,
	0x09a84125, 0x26095143, 0x0498fe71, 0x8521062d, 0x26002477, 0x43fb4b01, 0xb2200593, 0x28314182, 0x38030940, 0x20022717, 0xb8032611, 0x35b5ffff,
	0x4144833b, 0x47890bbc, 0xecff7d24, 0x8b832506, 0x005f0222, 0x00234182, 0x42060176, 0x4128067f, 0x02022605, 0x01133b35, 0x210db368, 0x7583f404,
	0x82600221, 0x0006342d, 0x00005076, 0x3a02b415, 0xb8022611, 0x2db4ebff, 0x8a190a33, 0x225b8f2d, 0x82540043, 0x202f825b, 0x255a8235, 0xb451ffb8,
	0x5d9c353b, 0x84d84321, 0x842e205d, 0xb4d7235d, 0xdd422d34, 0x22b9820f, 0x852602e1, 0x430220b9, 0x15230539, 0x843c02b4, 0xb4bc225d, 0x205d934a,
	0x832f828f, 0x020721bb, 0x82053b43, 0x8434202f, 0xb4b0235f, 0xbd922d42, 0x5f873520, 0x7d20b982, 0x3d20bd85, 0x96235f84, 0x914c3eb4, 0xe30521bd,
	0x06235f86, 0x84e25201, 0x842d20bd, 0xb4fd235d, 0xbd8d4436, 0x0698fe25, 0x88140625, 0x056723bd, 0x2f84005c, 0x27143827, 0xa7ffb802, 0x0f7941b4,
	0x0498fe25, 0x88f204f4, 0x085744bd, 0x83173021, 0x419b202f, 0xb8200f7b, 0xdd2e2f82, 0x2602b805, 0x00003800, 0x67020701, 0x29442f05, 0x1b012805,
	0x00012714, 0x440b1e18, 0xa4200bb5, 0x08222d82, 0x2d824a04, 0x2d855820, 0x84b80421, 0x1e012b8d, 0xb8012717, 0x1bb4feff, 0xd9410c21, 0xffb8260b,
	0x07dd04ec, 0x225d88e1, 0x421d0566, 0x01270535, 0x0126051e, 0x8d182d11, 0x222d825d, 0x888f0608, 0x0466225d, 0x268b86a6, 0x01261121, 0x8f1b300e,
	0x4e06235b, 0xe9827307, 0x91426120, 0xc5002105, 0x15235b82, 0x823101b4, 0xffb8275a, 0x2b25b490, 0x65420818, 0xffa4260a, 0x067905ec, 0x202f8221,
	0x282f8262, 0x60760006, 0xb1110000, 0x25b68201, 0x2e28b49f, 0x2a84210c, 0xff003527, 0xffb800ff, 0x22598cec, 0x853d0043, 0x84252059, 0xb4082359,
	0x599c252b, 0x86a34321, 0xe2fe2459, 0x91282eb4, 0x87e12059, 0x410220b3, 0x8585050f, 0x3ab45922, 0x85845687, 0x8f20af85, 0x0721af86, 0x050d4102,
	0x56222b85, 0x57923db4, 0x57873520, 0x09491e19, 0xb1842d20, 0x2eb44723, 0x21b1913c, 0x5b86e305, 0x52010623, 0x24b186f3, 0x31b44eff, 0x25b18c3f,
	0x4e0698fe, 0xb1881406, 0x29051f42, 0x2801b415, 0xb8012714, 0x654148ff, 0x98fe2510, 0xf2047905, 0x6720b588, 0x21072142, 0x2f83172b, 0x6a414520,
	0x057f4d09, 0x98fe002a, 0xb6053704, 0x3c002602, 0x20065142, 0x0551427f, 0x5f840c20, 0x09b4ff25, 0x4102070f, 0x0a260ac5, 0xdf0314fe, 0x7d654a04,
	0x02072406, 0x828b0567, 0xb111292f, 0x01b80101, 0x2923b432, 0x5005de65, 0x1882059b, 0x07370423, 0x225b88e1, 0x42710466, 0x0f26067d, 0x14012605,
	0x5991091e, 0x888f0621, 0x04662259, 0x067d424a, 0x82112921, 0x2338212d, 0x850c9b66, 0x8735205b, 0x5201235b, 0x5b86b3ff, 0x5b821120, 0x20120122,
	0x05215b91, 0x083366e3, 0x008c5228, 0x0b401300, 0x59822b01, 0x3a2c0122, 0x7126598c, 0x9e04bcfe, 0x2b821406, 0x0000d328, 0x42000701, 0x6c82b400,
	0xb90e5608, 0xd2ff0200, 0x0b393ab4, 0x2b012523, 0xfb020035, 0xfed904db, 0x002106ba, 0x001b000d, 0x1419402d, 0x40070e0e, 0x3f010050, 0x02004f00,
	0x92071500, 0x010f0f80, 0x0102015f, 0x335d2f00, 0x0132ed1a, 0x1a5d5d2f, 0xcd2f39cd, 0x23013031, 0x3527032e, 0x17031e33, 0x32098805, 0x2364bafe,
	0x103f4d51, 0x2f2a10c6, 0x96fe1530, 0x82522364, 0x84c7200d, 0xd9042d0d, 0x5158531c, 0x5023151b, 0x1b1d4c51, 0x42080b8a, 0x6afc0200, 0xbeffd904,
	0x10007f06, 0x52001c00, 0x0c0d3140, 0x01171004, 0x1c2f4017, 0x1c4f1c3f, 0x04041c03, 0x5f002f1c, 0x9f008f00, 0xc0000400, 0x1b1b1608, 0x8f0c7f04,
	0x800c020c, 0x5f080f00, 0x84080208, 0x5dcc229d, 0x2a988232, 0xcc1a2f01, 0x3d39395d, 0x822f182f, 0x115d23a9, 0xaa833333, 0x27262634, 0x23070606,
	0x37363635, 0x17161633, 0x37033e27, 0x11831533, 0xd9fe3c08, 0x346c3364, 0x65336a36, 0xc0307533, 0x4e337430, 0x1d1d2114, 0x6a2db410, 0xd9046537,
	0x30305422, 0x3b1b2254, 0x84454584, 0x2d19c23b, 0x1521342e, 0x002b673c, 0x0489fb02, 0x86ddfed9, 0x404a2fb1, 0x0c03042a, 0x1601161f, 0x0c0c1c40,
	0x92822f1c, 0x9f088f33, 0xc0080408, 0x12121600, 0x8f037f0c, 0x80030203, 0x20aa8a10, 0x21aa8fcd, 0xa986cd1a, 0x1521a086, 0x20b18623, 0x28088337,
	0x031e3335, 0x336ffc17, 0x34a18474, 0x366a3364, 0x64336b35, 0x6a38644d, 0x1d10b42d, 0x0414201e, 0x20a285f4, 0x29b0851b, 0x3c672bc3, 0x2e342115,
	0x5b41192d, 0x7d200806, 0x1000f806, 0x5e002800, 0x19163840, 0x0e062019, 0x111c1948, 0x3f232f80, 0x03234f23, 0x23040423, 0x250c5e41, 0x261f1919,
	0x62411818, 0x32cc2418, 0x41331139, 0x32230d66, 0x41112b39, 0x13361367, 0x07020e14, 0x36272307, 0x26343536, 0x07062223, 0x33363635, 0x74411632,
	0x14a43310, 0x06192e22, 0x41370a56, 0x27162b39, 0x1f260b0b, 0x7d416463, 0x7601330e, 0x151e2b1d, 0x09835106, 0x1925251f, 0x03520303, 0xdd824503,
	0xfe232682, 0x821007e9, 0x002c2bdd, 0x043b4061, 0x000c0c03, 0x82412828, 0xc0003a09, 0x27001a1a, 0x1fcf8e16, 0x1fef1fdf, 0x09401f03, 0x1f1f480d,
	0x11198e24, 0x16984111, 0x332f3228, 0x2b2f33e1, 0xe382e15d, 0x1a2f332c, 0x325dcc10, 0x3d39112f, 0xe083332f, 0x230f9e41, 0x022e2201, 0x232dd783,
	0x3233033e, 0x3233021e, 0x0e333736, 0x10aa4103, 0x24be0134, 0x1c404547, 0x5d0e2a28, 0x41301d05, 0x454a252a, 0x0d821a3e, 0x1c055c24, 0xbc414130,
	0x5a012a0e, 0x2a1c221c, 0x3b513032, 0x21088221, 0x0883312b, 0xe9820020, 0xd904733b, 0xc106cdfe, 0x1f000b00, 0x19403200, 0x0b0b8006, 0x010c2f1f,
	0x1415c00c, 0x360a8205, 0x0f1a8014, 0x02115f11, 0x5d2f0011, 0x32cd1a33, 0x01cc2f32, 0x821a332f, 0x2f3926bd, 0x3031cd1a, 0x08f24201, 0x030e2528,
	0x27262223, 0xb2821e33, 0x37023e27, 0x20145efd, 0x06f1421e, 0x6f012608, 0x6e4d2b05, 0x06919246, 0x301b046c, 0x41242c44, 0x05052133, 0x2e2c19f8,
	0x3c152135, 0x3c062c67, 0x8c264563, 0x4519197e, 0xfc022108, 0x3829958b, 0x80051e40, 0x1613400b, 0x229a8a48, 0x911f0000, 0x88cd209a, 0x842b209a,
	0x08e4429b, 0x9b8e1720, 0xe342d120, 0x93fc2009, 0x2cdd2a9a, 0x21153c67, 0x192c2e35, 0x419a8e15, 0x072c0731, 0x00130006, 0x4042002a, 0x1c1c1921,
	0x25288a82, 0x002f1325, 0x08090001, 0x222e0e82, 0x1b1bc028, 0x0e800813, 0x055f050f, 0x39410502, 0x2f392206, 0x06e2421a, 0x3d413320, 0x220d8405,
	0x8d013031, 0x4227209b, 0x332411db, 0xcdfe1632, 0x2b20a692, 0x2c06de42, 0x2c394138, 0x150b2715, 0x0563643a, 0x32af8de3, 0x1f2b1d96, 0x5a290614,
	0x25252009, 0x52030318, 0x42004506, 0x132d0add, 0x48002f00, 0x1d1c2740, 0x2b2a081d, 0x30c0842b, 0x2a0809c0, 0xdf22cf19, 0x0322ef22, 0x141c2722,
	0x27c79014, 0x33332f32, 0x32325dcd, 0x82066b41, 0x3311230e, 0xc791332f, 0x9414c242, 0x422f20c7, 0xd08f1ac5, 0xc5425020, 0x00013b13, 0x0142fe31,
	0x00000071, 0x40180014, 0x00800f09, 0x12020808, 0x2f00020b, 0xa682332f, 0x1a332f2e, 0x173031cc, 0x1e332734, 0x06141503, 0x08947b18, 0xdb363a08,
	0x391a818b, 0x64651e2f, 0x0e1a401d, 0x3422192d, 0x138569ee, 0x2a4b4034, 0x0808685a, 0x2b050471, 0x10000100, 0x77016dfe, 0x1100a600, 0x09b61200,
	0x060d1001, 0x2f0000fa, 0x2056833f, 0x070879c4, 0x0806fe7a, 0x11353622, 0x1a017701, 0x263f5939, 0x3b0e163f, 0xa6322e22, 0x6642d9fe, 0x09112446,
	0x310e0796, 0x003c0131, 0x9a204f88, 0x9a224fb4, 0x4f8be5fe, 0xf0823020, 0x1b220282, 0x57824a01, 0x02820882, 0x03823420, 0x03820120, 0x0a226983,
	0x17863400, 0x07000224, 0x0b863e00, 0x15000324, 0x0b864500, 0x89000421, 0x00052423, 0x865a000c, 0x00062417, 0x86660009, 0x0007240b, 0x866f004e,
	0x0008240b, 0x86bd0014, 0x000a240b, 0x86d10067, 0x000d240b, 0x8638012e, 0x000e230b, 0x3b87012a, 0x5f841220, 0x01000324, 0x93820904, 0x90016823,
	0x240b8500, 0x01140001, 0x240b86f8, 0x020e0002, 0x240b860c, 0x022a0003, 0x200b861a, 0x24238a04, 0x022c0005, 0x24178644, 0x02120006, 0x240b8670,
	0x029c0007, 0x240b8682, 0x03280008, 0x240b861e, 0x03ce000a, 0x240b8646, 0x0438000b, 0x240b8614, 0x045c000c, 0x200b864c, 0x200b820d, 0x080b86a8,
	0x54000e54, 0x69440405, 0x69746967, 0x2064657a, 0x61746164, 0x706f6320, 0x67697279, 0xa9207468, 0x30303220, 0x47202c37, 0x6c676f6f, 0x6f432065,
	0x726f7072, 0x6f697461, 0x72442e6e, 0x2064696f, 0x736e6153, 0x75676552, 0x4172616c, 0x6e656373, 0x20726564, 0x1b89202d, 0x72655623, 0x242d8273,
	0x302e3120, 0x83158430, 0x31088430, 0x20736920, 0x72742061, 0x6d656461, 0x206b7261, 0x6587666f, 0x646e6132, 0x79616d20, 0x20656220, 0x69676572,
	0x72657473, 0x69279982, 0x6563206e, 0x82617472, 0x756a2707, 0x64736972, 0x87836369, 0x882e7321, 0x899d8a77, 0x24668580, 0x616d7568, 0x2149826e,
	0xaf827320, 0x65732035, 0x20666972, 0x65707974, 0x65636166, 0x73656420, 0x826e6769, 0x6f662462, 0x82752072, 0x6920221c, 0x8373826e, 0x2073211b,
	0x652f8c83, 0x7463656c, 0x696e6f72, 0x6f632063, 0x82756d6d, 0x05034108, 0x82694c21, 0x827320f2, 0x84752039, 0x687427f8, 0x70412065, 0x06826361,
	0x2c211986, 0x07004120, 0x302e322e, 0x70747468, 0x772f2f3a, 0x612e7777, 0x2e252584, 0x2f67726f, 0x2943856c, 0x494c2f73, 0x534e4543, 0x29822d45,
	0x00440025, 0x82670069, 0x82742003, 0x007a2603, 0x00640065, 0x24038220, 0x00740061, 0x28098261, 0x006f0063, 0x00790070, 0x20258472, 0x22158268,
	0x82a90020, 0x00322217, 0x22018230, 0x822c0037, 0x8247200b, 0x826f2023, 0x826c2043, 0x0020223d, 0x200d8243, 0x20338272, 0x8333826f, 0x82692045,
	0x006e220f, 0x2067822e, 0x20098272, 0x205f8469, 0x245b8253, 0x0073006e, 0x26318252, 0x00750067, 0x8261006c, 0x8241202d, 0x82632011, 0x826e2011,
	0x82652023, 0x0020220f, 0x205d822d, 0x20098244, 0x837d826f, 0x20378797, 0x20258256, 0x852d8272, 0x0020225b, 0x835f8231, 0x0020228f, 0x204d8262,
	0x204f8269, 0x20398264, 0x20178231, 0x87778a33, 0x20518b3d, 0x20458269, 0x20e98420, 0x20af8474, 0x20598264, 0x208d846d, 0x2241826b, 0x9066006f,
	0x006121df, 0x20219f83, 0x20258300, 0x201d8279, 0x20f58462, 0x83c98472, 0x8474204d, 0x0547419b, 0x2b826920, 0x63002022, 0x74201184, 0x0f855582,
	0xa3826a20, 0xd1827220, 0x64007322, 0x63220582, 0x05827400, 0x29826f20, 0xc5827320, 0x41110341, 0x1541154f, 0x84202013, 0x20cd8553, 0x83638268,
	0x846e20a1, 0x82742013, 0x827320a7, 0x846e207f, 0x847320ed, 0x8469208f, 0x007424db, 0x82700079, 0x8266200f, 0x8463201d, 0x826420c9, 0x82732005,
	0x82672035, 0x24c58591, 0x006f0066, 0x20418272, 0x413d8275, 0xc7830597, 0x45847420, 0x73203787, 0x19411f82, 0x00652207, 0x831b826c, 0x827220d7,
	0x20818339, 0x06494263, 0x6d006d22, 0x11859782, 0x220b1b42, 0x82740068, 0x00702401, 0x822f003a, 0x00772101, 0x2e200183, 0x73219182, 0x0b0f4200,
	0x87846320, 0x2e007022, 0x6f201582, 0x2f214982, 0x8737b700, 0x20eb8df5, 0x20df8272, 0x2053842e, 0x22c1826d, 0x8669004c, 0x8273207d, 0x846420cd,
	0x099942ff, 0x27827420, 0x13826520, 0x70004122, 0x6320a782, 0x338d0d86, 0x1f822c20, 0x200fa942, 0x20bd8232, 0x89b79830, 0x842e204b, 0x006722eb,
	0x8b89822f, 0x82732087, 0x004c2a11, 0x00430049, 0x004e0045, 0x21058253, 0x5385002d, 0x02000023, 0x23008400, 0x660066ff, 0x048e0884, 0x00820325,
	0x82020100, 0x03380825, 0x05000400, 0x07000600, 0x09000800, 0x0b000a00, 0x0d000c00, 0x0f000e00, 0x11001000, 0x13001200, 0x15001400, 0x17001600,
	0x19001800, 0x1b001a00, 0x1d001c00, 0x1f001e00, 0x2130cf82, 0x23002200, 0x25002400, 0x27002600, 0x29002800, 0x7061c619, 0x00ac6f0e, 0x008400a3,
	0x00bd0085, 0x00e80096, 0x008e0086, 0x009d008b, 0x01a400a9, 0x018a0003, 0x00830004, 0x00f20093, 0x008d00f3, 0x01880097, 0x00de0005, 0x009e00f1,
	0x00f500aa, 0x00f600f4, 0x00ad00a2, 0x00c700c9, 0x006200ae, 0x00900063, 0x00cb0064, 0x00c80065, 0x00cf00ca, 0x00cd00cc, 0x00e900ce, 0x00d30066,
	0x00d100d0, 0x006700af, 0x009100f0, 0x00d400d6, 0x006800d5, 0x00ed00eb, 0x006a0089, 0x006b0069, 0x006c006d, 0x00a0006e, 0x0071006f, 0x00720070,
	0x00750073, 0x00760074, 0x00ea0077, 0x007a0078, 0x007b0079, 0x007c007d, 0x00a100b8, 0x007e007f, 0x00810080, 0x00ee00ec, 0x010601ba, 0x01080107,
	0x010a0109, 0x00fd000b, 0x010c01fe, 0x010e010d, 0x01ff000f, 0x01100100, 0x01120111, 0x01140113, 0x01160115, 0x01180117, 0x011a0119, 0x011c011b,
	0x011e011d, 0x00f8001f, 0x012001f9, 0x01220121, 0x01240123, 0x01260125, 0x01280127, 0x012a0129, 0x012c012b, 0x012e012d, 0x0030012f, 0x013101d7,
	0x01330132, 0x01350134, 0x01370136, 0x01390138, 0x013b013a, 0x013d013c, 0x003f013e, 0x01e300e2, 0x01410140, 0x01430142, 0x01450144, 0x01470146,
	0x01490148, 0x014b014a, 0x014d014c, 0x00b0004e, 0x014f01b1, 0x01510150, 0x01530152, 0x01550154, 0x01570156, 0x00fb0058, 0x00e400fc, 0x015901e5,
	0x015b015a, 0x015d015c, 0x015f015e, 0x01610160, 0x01630162, 0x01650164, 0x01670166, 0x01690168, 0x016b016a, 0x016d016c, 0x01bb006e, 0x0170016f,
	0x00720171, 0x01e700e6, 0x01a60073, 0x01750174, 0x01770176, 0x01790178, 0x007b017a, 0x01e100d8, 0x00db007c, 0x00dd00dc, 0x00d900e0, 0x017d01df,
	0x017f017e, 0x01810180, 0x01830182, 0x01850184, 0x01870186, 0x01890188, 0x018b018a, 0x018d018c, 0x018f018e, 0x01910190, 0x01930192, 0x01950194,
	0x01970196, 0x01990198, 0x019b019a, 0x019d019c, 0x019f019e, 0x01a101a0, 0x01a301a2, 0x01a501a4, 0x01a701a6, 0x01a901a8, 0x01ab01aa, 0x01ad01ac,
	0x01af01ae, 0x01b101b0, 0x01b301b2, 0x00b501b4, 0x01b6019b, 0x01b801b7, 0x01ba01b9, 0x01bc01bb, 0x01be01bd, 0x01c001bf, 0x01c201c1, 0x01c401c3,
	0x01c601c5, 0x01c801c7, 0x01ca01c9, 0x01cc01cb, 0x01ce01cd, 0x01d001cf, 0x01d201d1, 0x01d401d3, 0x01d601d5, 0x01d801d7, 0x01da01d9, 0x01dc01db,
	0x01de01dd, 0x01e001df, 0x01e201e1, 0x01e401e3, 0x01e601e5, 0x01e801e7, 0x01ea01e9, 0x01ec01eb, 0x01ee01ed, 0x01f001ef, 0x01f201f1, 0x01f401f3,
	0x01f601f5, 0x01f801f7, 0x01fa01f9, 0x01fc01fb, 0x01fe01fd, 0x020002ff, 0x02020201, 0x02040203, 0x02060205, 0x02080207, 0x020a0209, 0x020c020b,
	0x020e020d, 0x0210020f, 0x02120211, 0x02140213, 0x02160215, 0x02180217, 0x021a0219, 0x021c021b, 0x021e021d, 0x0220021f, 0x02220221, 0x02240223,
	0x02260225, 0x02280227, 0x00b20029, 0x022a02b3, 0x00b6002b, 0x02c400b7, 0x00b4002c, 0x00c500b5, 0x00c20082, 0x00ab0087, 0x022d02c6, 0x00be002e,
	0x002f02bf, 0x003002bc, 0x023102f7, 0x02330232, 0x02350234, 0x008c0036, 0x0237029f, 0x02390238, 0x003b023a, 0x003c0298, 0x0099009a, 0x00a500ef,
	0x009c0092, 0x008f00a7, 0x00950094, 0x023d02b9, 0x023f023e, 0x02410240, 0x02430242, 0x02450244, 0x02470246, 0x02490248, 0x024b024a, 0x024d024c,
	0x024f024e, 0x02510250, 0x02530252, 0x02550254, 0x02570256, 0x02590258, 0x025b025a, 0x025d025c, 0x025f025e, 0x02610260, 0x02630262, 0x02650264,
	0x02670266, 0x02690268, 0x026b026a, 0x026d026c, 0x026f026e, 0x02710270, 0x02730272, 0x02750274, 0x02770276, 0x02790278, 0x027b027a, 0x027d027c,
	0x027f027e, 0x02810280, 0x02830282, 0x02850284, 0x02870286, 0x02890288, 0x028b028a, 0x028d028c, 0x028f028e, 0x02910290, 0x02930292, 0x02950294,
	0x02970296, 0x02990298, 0x029b029a, 0x029d029c, 0x029f029e, 0x02a102a0, 0x02a302a2, 0x02a502a4, 0x02a702a6, 0x02a902a8, 0x02ab02aa, 0x02ad02ac,
	0x02af02ae, 0x02b102b0, 0x02b302b2, 0x02b502b4, 0x02b702b6, 0x02b902b8, 0x02bb02ba, 0x02bd02bc, 0x02bf02be, 0x02c102c0, 0x02c302c2, 0x02c502c4,
	0x02c702c6, 0x02c902c8, 0x02cb02ca, 0x02cd02cc, 0x02cf02ce, 0x02d102d0, 0x02d302d2, 0x02d502d4, 0x02d702d6, 0x02d902d8, 0x02db02da, 0x02dd02dc,
	0x02df02de, 0x02e102e0, 0x02e302e2, 0x02e502e4, 0x02e702e6, 0x02e902e8, 0x02eb02ea, 0x02ed02ec, 0x02ef02ee, 0x02f102f0, 0x02f302f2, 0x02f502f4,
	0x02f702f6, 0x02f902f8, 0x02fb02fa, 0x02fd02fc, 0x03ff02fe, 0x03010300, 0x03030302, 0x03050304, 0x03070306, 0x03090308, 0x030b030a, 0x030d030c,
	0x030f030e, 0x03110310, 0x03130312, 0x03150314, 0x03170316, 0x03190318, 0x031b031a, 0x031d031c, 0x031f031e, 0x03210320, 0x03230322, 0x03250324,
	0x03270326, 0x03290328, 0x032b032a, 0x032d032c, 0x032f032e, 0x03310330, 0x03330332, 0x03350334, 0x03370336, 0x03390338, 0x033b033a, 0x033d033c,
	0x033f033e, 0x03410340, 0x03430342, 0x03450344, 0x03470346, 0x03490348, 0x034b034a, 0x034d034c, 0x034f034e, 0x03510350, 0x03530352, 0x03550354,
	0x03570356, 0x03590358, 0x035b035a, 0x035d035c, 0x035f035e, 0x03610360, 0x03630362, 0x03650364, 0x03670366, 0x03690368, 0x036b036a, 0x036d036c,
	0x036f036e, 0x03710370, 0x03730372, 0x03750374, 0x03770376, 0x03790378, 0x037b037a, 0x037d037c, 0x037f037e, 0x03810380, 0x03830382, 0x03850384,
	0x03870386, 0x03890388, 0x6e2e058a, 0x076c6c75, 0x30696e75, 0x09444130, 0x7265766f, 0x726f6373, 0x65700e65, 0x646f6972, 0x746e6563, 0x64657265,
	0x616d4107, 0x6e6f7263, 0x07856107, 0x62410628, 0x65766572, 0x06846106, 0x6f410729, 0x656e6f67, 0x8561076b, 0x430b2d07, 0x63726963, 0x6c666d75,
	0x630b7865, 0x04260b89, 0x746f6443, 0x04826304, 0x63440623, 0x214e8261, 0x06856406, 0x72634425, 0x8274616f, 0x2106830d, 0x63854507, 0x85650721,
	0x45062107, 0x06216484, 0x21068465, 0x3e82450a, 0x83636121, 0x650a2198, 0x07210a88, 0x21798545, 0x07856507, 0x85450621, 0x84652058, 0x470b2106,
	0x0b218389, 0x210b8967, 0x40824704, 0x82670421, 0x470c2604, 0x6d6d6f63, 0x21578561, 0x0c8a670c, 0x89480b21, 0x680b212f, 0x04260b89, 0x72616248,
	0x04826804, 0x74490628, 0x65646c69, 0x06846906, 0x85490721, 0x690721b5, 0x06210785, 0x21b68449, 0x06846906, 0x85490721, 0x6907219f, 0x0a210785,
	0x27c28849, 0x024a4902, 0x4a0b6a69, 0x0b216289, 0x210b896a, 0x938a4b0c, 0x8c6b0c21, 0x7267330c, 0x6c6e6565, 0x69646e61, 0x614c0663, 0x65747563,
	0x06846c06, 0x8b4c0c21, 0x8a6c2027, 0x4c06280c, 0x6f726163, 0x846c066e, 0x4c042106, 0x04218582, 0x2104826c, 0x3f854e06, 0x3f856e20, 0x328a4e20,
	0x8a6e0c21, 0x4e06210c, 0x06213884, 0x3506846e, 0x70616e0b, 0x7274736f, 0x6568706f, 0x676e4503, 0x676e6503, 0xff854f07, 0x856f0721, 0x4f062807,
	0x76657262, 0x846f0665, 0x4f0d2f06, 0x676e7568, 0x6d757261, 0x7475616c, 0x0d8b6f0d, 0x84520621, 0x7206217c, 0x0c210684, 0x21768a52, 0x0c8a720c,
	0x84520621, 0x7206217c, 0x53200685, 0x06212e84, 0x21068473, 0x3a41530b, 0x730b2109, 0x0c210b89, 0x21408a54, 0x0c8a740c, 0x85540621, 0x84742046,
	0x54042606, 0x04726162, 0x28048274, 0x69745506, 0x0665646c, 0x21068475, 0xcd855507, 0x85750721, 0x55062107, 0x0621ce84, 0x27068475, 0x69725505,
	0x7505676e, 0x0d210583, 0x20e18c55, 0x210d8b75, 0xfd415507, 0x75072105, 0x0b210785, 0x21a18957, 0x0b8a770b, 0x0b8a5920, 0x0b897920, 0x845a0621,
	0x7a0621e4, 0x0a210684, 0x0843425a, 0x887a0a21, 0x6c05270a, 0x73676e6f, 0x8b83410a, 0x61202685, 0x07220a88, 0x12844541, 0x65610722, 0x0b260784,
	0x616c734f, 0x0b856873, 0x0b896f20, 0x41530c21, 0x0c210a20, 0x200c8a73, 0x2efe8506, 0x6e6f7405, 0x640d736f, 0x65726569, 0x84736973, 0x410a250d,
	0x6168706c, 0x092e0a84, 0x746f6e61, 0x69656c65, 0x70450c61, 0x91826973, 0x08221684, 0x1f867445, 0x866f4921, 0x4f0c2709, 0x7263696d, 0x1f846e6f,
	0x8a550c21, 0x4f0a242c, 0x8567656d, 0x6911212e, 0x6b8c2e82, 0x6b840520, 0x65420433, 0x47056174, 0x616d6d61, 0x696e7507, 0x34393330, 0x216f8607,
	0x1a825a04, 0x6f820320, 0x68540522, 0x04200982, 0x05367083, 0x7070614b, 0x614c0661, 0x6164626d, 0x02754d02, 0x5802754e, 0x81860769, 0x69500231,
	0x6f685203, 0x67695305, 0x5403616d, 0x86077561, 0x5003258d, 0x43036968, 0x50220382, 0x66856973, 0x0c394122, 0x91874f83, 0x28860f20, 0x0a210f87,
	0x08084161, 0x8a650c21, 0x820820d1, 0x20e78488, 0x84cf8309, 0x75142109, 0xdc8d1f85, 0x04213f84, 0x212e8262, 0xdc836705, 0x65640526, 0x0761746c,
	0x04214b86, 0x2018827a, 0x21038203, 0xda847405, 0x05214c83, 0x20da846b, 0x85da846c, 0x434229a4, 0x02756e02, 0x6f076978, 0x25056141, 0x6f687203,
	0xdc837306, 0x84053121, 0x74032106, 0x7f86e382, 0x82700321, 0x826320df, 0x268e8203, 0x656d6f05, 0x410c6167, 0x0f200b73, 0x0c20a68e, 0xc3845386,
	0x1c860c20, 0x0a200c84, 0x0a843c84, 0x66610929, 0x30316969, 0x87333230, 0x31352109, 0x32200988, 0x1d890988, 0x13883420, 0x09883520, 0x09883620,
	0x09883720, 0x09883820, 0x09873920, 0x88303621, 0x20638809, 0x21638736, 0x4f883431, 0x45883120, 0x45883120, 0x45883120, 0x45883220, 0x45883220,
	0xa9883220, 0x9f883220, 0x4f883220, 0x9f883220, 0x59883220, 0x59883220, 0x59883220, 0x59883320, 0x59883320, 0x59883320, 0x03413320, 0x88332008,
	0x88332063, 0x88332063, 0x88332063, 0x88332063, 0x88332063, 0x88342063, 0x88342063, 0x88342063, 0x88342063, 0x88342063, 0x09174163, 0x63883420,
	0x63883420, 0x63883420, 0x63883420, 0x95883620, 0x31883620, 0x31883620, 0x31883620, 0x31883620, 0x95883720, 0x8b883720, 0x8b883720, 0x8b883720,
	0x59883720, 0x59883720, 0x59883720, 0x59883720, 0x59883720, 0x59883820, 0xef883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820,
	0x63883820, 0x63883820, 0x63883820, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x45893720,
	0x31216387, 0x21638730, 0x1d873031, 0x42303121, 0x302008bb, 0x31216387, 0x21638730, 0x63873031, 0x87303121, 0x30312163, 0x31216387, 0x21c78730,
	0x63883031, 0x63883120, 0x3520b389, 0x3829db89, 0x72675706, 0x06657661, 0x24068577, 0x75636157, 0x840d8274, 0x57092106, 0x21079d44, 0x09877709,
	0x85590621, 0x84792028, 0x61092d06, 0x30696966, 0x38303230, 0x646e750d, 0x2b06484a, 0x0d6c6264, 0x746f7571, 0x76657265, 0x65251282, 0x696d0664,
	0x2c55836e, 0x6f636573, 0x6509646e, 0x616c6378, 0x2925826d, 0x75736e09, 0x69726570, 0x4785726f, 0x3439382f, 0x65700631, 0x61746573, 0x72754504,
	0x2215846f, 0x42323136, 0x0982068f, 0x3d069f41, 0x35333136, 0x73650932, 0x616d6974, 0x09646574, 0x65656e6f, 0x74686769, 0x68740c68, 0x0b866572,
	0x660b7324, 0x0b877669, 0x82730c21, 0x856e208b, 0x05732e24, 0x746c6544, 0x6e750761, 0x30424669, 0x2a078631, 0x79630d32, 0x6c6c6972, 0x83626369,
	0x64082db7, 0x656c746f, 0x106a7373, 0x6f726163, 0x200b0849, 0x0a14470b, 0x0b8a1120, 0x746f7222, 0x0c248c82, 0x6f72657a, 0x0c24d687, 0x72756f66,
	0x8e820c89, 0x0b230c87, 0x87786973, 0x840d200b, 0x840d889b, 0x233488a4, 0x656e696e, 0xa9830c87, 0x30303223, 0x84078630, 0x303223b9, 0x0f863230,
	0x07863320, 0x07863420, 0x07863520, 0x07863620, 0x07863720, 0x07863820, 0x07863920, 0x07864120, 0x07834220, 0x46454623, 0x22078446, 0x86434646,
	0x83442007, 0x31302307, 0x07843046, 0x84423221, 0x33302317, 0x0f843144, 0x84443321, 0x840f827f, 0x45312367, 0x17834533, 0x47840782, 0x85453121,
	0x840782af, 0x4631222f, 0x2b4f8534, 0x09334632, 0x69736164, 0x69786f61, 0x84078b41, 0x42462bc1, 0x4f053430, 0x6e726f68, 0x05846f05, 0x05845520,
	0x05837520, 0x51857185, 0x41333021, 0x078205bb, 0x6804332e, 0x086b6f6f, 0x62746f64, 0x776f6c65, 0x34202584, 0x34212586, 0x216f8530, 0xbf853534,
	0x86353421, 0x8636200f, 0x8436200f, 0x34302297, 0x21c78536, 0x85843634, 0x34200f82, 0x36214785, 0x84078635, 0x201782df, 0x200f8637, 0x20078638,
	0x20078639, 0x20078641, 0x41078642, 0x34210527, 0x206f8736, 0x20178645, 0x21078546, 0x07863037, 0x07863120, 0x37207f86, 0x37207f86, 0x37207f86,
	0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x38217f86, 0x21778530,
	0x07863138, 0x38207f86, 0x38207f86, 0x38207f86, 0x38207f86, 0x38207f86, 0x38207786, 0x38207786, 0x38207786, 0x38207786, 0x38207786, 0x38207786,
	0x38207786, 0x39207786, 0x39206786, 0x39206786, 0x39206786, 0x39206786, 0x39206786, 0x3920e786, 0x39206f86, 0x39206f86, 0x39206f86, 0x39206f86,
	0x39206f86, 0x39206f86, 0x39206f86, 0x41216f86, 0x21df8530, 0x07863141, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86,
	0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x42217f86, 0x21778530, 0x07863142, 0x42207f86, 0x42207f86,
	0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x8f437f86, 0x42342106, 0x42207f86, 0x42207f86, 0x43217f86,
	0x21778530, 0x07863143, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86,
	0x4320ff86, 0x43207f86, 0x43207f86, 0x44217f86, 0x44778530, 0x3420062f, 0x21062f44, 0x7f864434, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420,
	0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864520, 0x85314521, 0x86452087, 0x864520ff,
	0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f,
	0x0637457f, 0x31463422, 0x46207f85, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86,
	0xa7457f86, 0x34302205, 0x207f8646, 0x457f8646, 0x302105c7, 0x06074535, 0x2d453520, 0x46352006, 0x1782052f, 0x35217f85, 0x217f8530, 0x7f853035,
	0x85303521, 0x3035217f, 0x35217f85, 0x217f8530, 0x7f853035, 0x85303521, 0x3035217f, 0x35217f85, 0x21ff8530, 0x7f853035, 0x85303521, 0x3035217f,
	0x3522ff85, 0xf7843031, 0x31313522, 0xff850786, 0x84313521, 0x4531217f, 0x82059f43, 0x821f8407, 0x821f8407, 0x841f8707, 0x840f829f, 0x8407829f,
	0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x4531219f, 0x82059f43, 0x46312007,
	0x422005b7, 0x9f437f86, 0x86178205, 0x059f437f, 0x7f860f82, 0x82059f43, 0x437f860f, 0x0f82059f, 0x9f437f86, 0x860f8205, 0x059f437f, 0x7f860f82,
	0x21059f43, 0x9f434531, 0x86078205, 0x8643207f, 0x059f437f, 0x7f861782, 0x82059f43, 0x437f860f, 0x0f82059f, 0x9f437f86, 0x860f8205, 0x059f437f,
	0x7f860f82, 0x82059f43, 0x437f860f, 0x3121059f, 0x059f4345, 0x7f860782, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f,
	0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x21059f43, 0x9f434531, 0x86078205, 0x059f43ff,
	0xff860f82, 0x82059f43, 0x43ff860f, 0x0f82059f, 0x9f43ff86, 0x860f8205, 0x059f43ff, 0xff860f82, 0x82059f43, 0x43ff860f, 0x3121059f, 0x059f4345,
	0x31200782, 0x4305ff41, 0x0f82058f, 0x8f43ef86, 0x860f8205, 0x058f43ef, 0xef840f82, 0x46303221, 0x33230607, 0x51134630, 0x612809af, 0x65747563,
	0x626d6f63, 0x6723138a, 0x84766172, 0x89122013, 0x6f682327, 0x268e6b6f, 0x6c697423, 0x25268464, 0x6572620e, 0x49886576, 0x44880e85, 0x1d840d20,
	0x1c853f87, 0x10203a88, 0x8307cb4a, 0x656c241f, 0x4a117466, 0x692108dc, 0x21138367, 0x118f4355, 0x00434c22, 0x022a0082, 0x02000500, 0x0300ffff,
	0x0d820100, 0x03820c20, 0x15841620, 0x03210d82, 0x20138281, 0x820d8204, 0x2e05860b, 0x001e000a, 0x6c01002c, 0x006e7461, 0x82040008, 0x82002015,
	0x8201203b, 0x6b012307, 0x13837265, 0x84000021, 0x201b820d, 0x20218202, 0x21038301, 0x0d823aa5, 0x01003808, 0x03ea03f0, 0x074c07ea, 0x07d4085a,
	0x0a32095a, 0x0c220bc0, 0x0e3e0d10, 0x0f0a0f24, 0x127e11f0, 0x148213ac, 0x19de14b0, 0x1dee1960, 0x23362190, 0x07822768, 0x8268284c, 0x826e2001,
	0x29802603, 0x2930291a, 0x08098236, 0x48296830, 0x6e285629, 0xea29d429, 0x002aea29, 0xf02ada2a, 0xba2b4c07, 0xd62bc82b, 0x242e242e, 0x6630d62b,
	0x220bac32, 0xe435fe34, 0xfe34fe34, 0x0185240e, 0x37c23623, 0x23018744, 0x9e387e11, 0x39210185, 0x836184a8, 0x25038265, 0x6e284829, 0x0186623e,
	0x7a3e6c22, 0x29230187, 0x86943e48, 0x409e2601, 0x28320924, 0x27038368, 0x68284240, 0x6e28220b, 0x07830183, 0x85d44121, 0x5242214b, 0x0e230783,
	0x83584224, 0x362923db, 0x0183f00f, 0x83d44121, 0x21218505, 0xc3827e11, 0x05854820, 0x43293f85, 0x446e2842, 0x414c444c, 0x20ff82d4, 0x31038360,
	0xea29901d, 0xda2a6823, 0x8227c248, 0x384d8227, 0x73834e50, 0x6e283f08, 0x4a511c51, 0x86515851, 0x26521852, 0xca538c52, 0xee552854, 0xda58b858,
	0x0a5af459, 0xf25db45a, 0x1a5f005e, 0x9a60f45f, 0xf6644064, 0x7e652065, 0xbe65b065, 0x2a6a7066, 0x6828306a, 0x07824a6a, 0xa26a9c38, 0xda6ad06a,
	0x6828086b, 0xbc6b7a6b, 0x186ce26b, 0x446c366c, 0x03825a6c, 0x8a6c6c2c, 0xd66cc46c, 0x2c6d4829, 0xa3833e6d, 0x8c6d8d08, 0x646f6e6e, 0x3473b672,
	0xb4734a73, 0x64759274, 0xa0762a76, 0xf4795678, 0xc47c1a7c, 0x887f4a7d, 0x58819280, 0x2483f281, 0x94857e84, 0xe88b9e86, 0x208e768d, 0x9c8fda8e,
	0x10919690, 0x20929291, 0xfc929692, 0x14948293, 0x74943294, 0x2c95aa94, 0x2896a295, 0x0097b296, 0x20985e97, 0x2499b298, 0xf0999a99, 0x6e284a9a,
	0x229bb09a, 0x6e28689b, 0xb89baa9b, 0x6e286e28, 0x349c2a9c, 0x389dba9c, 0xb09d3e9d, 0x1494269e, 0xea29901d, 0x23250387, 0xa1da2a68, 0x08018290,
	0x9ea19e20, 0x32093209, 0xeea4aca4, 0x24837494, 0x10912098, 0x94852896, 0xf4790097, 0x9280f479, 0x0383aa94, 0x96248325, 0x837e8428, 0xe88b2305,
	0x03832098, 0x20207982, 0x03850f83, 0xa5209827, 0x99da8e30, 0x293b839a, 0x28967e84, 0x5e979e86, 0x11832a76, 0x83289621, 0x83478705, 0x850f8307,
	0x833b831f, 0x230d8369, 0x20989e86, 0x1d830383, 0x76270387, 0x8324832a, 0x834a7324, 0x874d8535, 0x4a732119, 0x94219d83, 0x21b18374, 0x47832896,
	0x3183a587, 0x99851185, 0x87289621, 0x850783b1, 0x5e972169, 0xd1859387, 0xcd89a385, 0x99833f85, 0x09212783, 0x42019532, 0xad420bf5, 0x240e2505,
	0x48297e11, 0xa4210397, 0x250187ac, 0x60196019, 0x0187eea4, 0x2a682323, 0x2f0387da, 0x2400d800, 0x2c00aeff, 0x37002900, 0x39005200, 0x3a240382,
	0x3b006600, 0x3c200f82, 0x3d200b82, 0x46240782, 0x4700c3ff, 0x48200382, 0x4a240382, 0x5200d7ff, 0x54200782, 0x57200382, 0x59201b82, 0x5a240382,
	0x5c001400, 0x82200782, 0x83204782, 0x84200382, 0x85200382, 0x86200382, 0x87200382, 0x88240382, 0x8e005cff, 0x8f201f82, 0x90200382, 0x91200382,
	0x9f200382, 0xa8205b82, 0xa9204382, 0xaa200382, 0xab200382, 0xac200382, 0xad200382, 0xb4200382, 0xb5200382, 0xb6200382, 0xb7200382, 0xb8200382,
	0xba200382, 0xbf200382, 0xc1203782, 0xc2200382, 0xc4205382, 0xc6200382, 0xc9200382, 0xcb201782, 0xcd200382, 0xcf200382, 0xd5200382, 0xd7200382,
	0xd9200382, 0xdb200382, 0xdd200382, 0xec200382, 0xf0203382, 0xf2280382, 0x0f012900, 0x1101c3ff, 0x13200382, 0x15200382, 0x24240382, 0x26015200,
	0x36280382, 0x37016600, 0x38011400, 0x39200b82, 0x3a202782, 0x3b200782, 0xff820782, 0x823f0121, 0xff432407, 0x825f01ae, 0x82692003, 0x82712003,
	0x8279201b, 0x827e203b, 0x82802003, 0x8282201b, 0x828a2007, 0x828c2007, 0x828e2007, 0x82902003, 0x21e38203, 0x07829301, 0x17829420, 0x07829620,
	0x03829920, 0x03829b20, 0x3b829d20, 0x9affa424, 0x0782a601, 0x3d00a824, 0x4f82aa01, 0x85ffae24, 0x0b82b001, 0x7f82b120, 0x0b82b520, 0x1b82bc20,
	0x0f82bd20, 0x0121ef82, 0x820b82c4, 0xd80121d7, 0xdb203b82, 0xdc200382, 0xdd204f82, 0xde200382, 0xea200b82, 0xed200382, 0xfa200382, 0xfb20bb82,
	0xfc203b82, 0xfd200782, 0xfe200782, 0xff300782, 0x00021400, 0x01025200, 0x28022900, 0x5802aeff, 0x60240382, 0x6a02c3ff, 0x6d200382, 0x72201382,
	0x76240f82, 0x7f023d00, 0x81200f82, 0x83200f82, 0x85200382, 0x87200b82, 0x89200382, 0x8b200382, 0x8d200f82, 0x9f200782, 0xa9202382, 0xaa204782,
	0xb2200f82, 0xb4200f82, 0xb5200382, 0xb6200f82, 0xb7200f82, 0xb8200782, 0xb9200782, 0xba200782, 0xbb200782, 0xbd202b82, 0xca200b82, 0xce240782,
	0xd90285ff, 0xdb206382, 0xdd200382, 0xe0200382, 0xe5203782, 0xf0201782, 0xf2200782, 0xf4200382, 0xf7200382, 0xf8200f82, 0xf9203782, 0xfa200782,
	0xfb200782, 0xfc280782, 0x05032900, 0x07033d00, 0x0a240382, 0x0c03c3ff, 0x0e200382, 0x10201382, 0x11240382, 0x160385ff, 0x17240f82, 0x18035200,
	0x1a200f82, 0x1b200b82, 0x1d241382, 0x1f03aeff, 0x21200382, 0x23200382, 0x25200382, 0x27200382, 0x29200382, 0x2b200382, 0x2d200382, 0x2f200382,
	0x31200382, 0x33200382, 0x36200382, 0x38203782, 0x3a200382, 0x3c200382, 0x3e200382, 0x40200382, 0x42200382, 0x44200382, 0x45200382, 0x47205b82,
	0x4a200382, 0x4c200b82, 0x4e200382, 0x50200382, 0x52200382, 0x54200382, 0x56200382, 0x58200382, 0x5a200382, 0x5c200382, 0x5e200382, 0x60200382,
	0x6f200382, 0x70209782, 0x71203782, 0x72200782, 0x73200782, 0x742e0782, 0x03002900, 0x7b002d00, 0x7b00f600, 0x0782a301, 0x26005e26, 0x2a00c3ff,
	0x32200382, 0x34200382, 0x37280382, 0x38009aff, 0x3900d7ff, 0x3a240782, 0x3c00aeff, 0x89200782, 0x94201782, 0x95200382, 0x96200382, 0x97200382,
	0x98200382, 0x9a200382, 0x9b200382, 0x9c202b82, 0x9d200382, 0x9e200382, 0x9f200382, 0xc8202f82, 0xce201782, 0xde200382, 0xe0200382, 0xe2200382,
	0xe4240382, 0x0e01c3ff, 0x12200382, 0x24240382, 0x26019aff, 0x2c240382, 0x3001d7ff, 0x32200382, 0x34200382, 0x36240382, 0x3801aeff, 0x3a201782,
	0x66200382, 0x6d202782, 0x71200382, 0xb8200b82, 0xbb200782, 0xbc200382, 0xfa200b82, 0xfc202382, 0xfe300382, 0x0002aeff, 0x5f029aff, 0x6102c3ff,
	0x6c02d7ff, 0x7e200782, 0x84200382, 0x86200382, 0x88200382, 0x8a200382, 0x8c200382, 0xa9200382, 0xb1202782, 0xb3200782, 0xb5200382, 0xb7200b82,
	0xb9200382, 0xbd200382, 0xe1200382, 0xe3201382, 0xef200382, 0xf1200382, 0xf3240382, 0x1503c3ff, 0x17240382, 0x19039aff, 0x49200782, 0x4b200382,
	0x4d200382, 0x4f200382, 0x51200382, 0x53200382, 0x55200382, 0x57200382, 0x59200382, 0x5b200382, 0x5d200382, 0x8b820382, 0xff610325, 0x826303d7,
	0x82652003, 0x82672003, 0x82692003, 0x826b2003, 0x826d2003, 0x826f2003, 0x82712053, 0xff732603, 0x0017009a, 0x82cd8237, 0x7201250d, 0xb001c3ff,
	0xb520fd82, 0xe1830382, 0xd982c420, 0xd1827620, 0x03829f20, 0xb18bb983, 0x1382bb20, 0xb582bd20, 0x0782ca20, 0x0382ce20, 0x5582e520, 0x03820520,
	0x03820720, 0x03821120, 0x1b2ab583, 0x6300d7ff, 0xaeff0500, 0x03820a00, 0xecff2624, 0x03822a00, 0x03823220, 0x03823420, 0x85ff3724, 0x07823800,
	0xc3ff3924, 0x29823a00, 0x2205df41, 0x829400ec, 0x82952013, 0x82962003, 0x82972003, 0x82982003, 0x829a2003, 0x829b2003, 0x829c2003, 0x829d2003,
	0x829e2003, 0x05df4103, 0xce00ec22, 0xde200b82, 0xe0200382, 0xe2200382, 0xe4240382, 0x0e01ecff, 0x12200382, 0x14200382, 0x2424c982, 0x260185ff,
	0x2c200382, 0x30200f82, 0x32200382, 0x34200382, 0x36200382, 0xe3411b82, 0x01ec2209, 0x2013826d, 0x20278271, 0x200782b8, 0x200382bb, 0x200b82bc,
	0x202382fa, 0x200382fc, 0x20e182fe, 0x24ed8200, 0x02aeff07, 0x2403820b, 0x02ecff5f, 0x20038261, 0x2003826c, 0x2003827e, 0x20038284, 0x20038286,
	0x20038288, 0x2003828a, 0x2403828c, 0x0285ffa9, 0x200782b1, 0x200382b3, 0x200b82b5, 0x200382b7, 0x200382b9, 0x200382bd, 0x201382e1, 0x200382e3,
	0x200382ef, 0x240382f1, 0x03ecfff3, 0x24038215, 0x0385ff17, 0x20078219, 0x20038249, 0x2003824b, 0x2003824d, 0x2003824f, 0x20038251, 0x20038253,
	0x20038255, 0x20038257, 0x20038259, 0x2003825b, 0x2003825d, 0x2003825f, 0x20038261, 0x20038263, 0x20038265, 0x20038267, 0x20038269, 0x2003826b,
	0x4103826d, 0x18260beb, 0xecff2c00, 0x03823700, 0x03823920, 0x03823b20, 0x03823c20, 0xed829f20, 0x03822420, 0x03822620, 0x03823820, 0x03823a20,
	0x03827120, 0x9982bc20, 0xc9840020, 0xb502ec22, 0xb7200782, 0xb9200382, 0xbd200382, 0xec22a984, 0x07824503, 0x61844720, 0x8203ec21, 0x7303212f,
	0x3b264b82, 0x29000500, 0x03820a00, 0x03820c20, 0xd7ff2624, 0x03822a00, 0x03823220, 0x03823420, 0x13824020, 0x03826020, 0x0b828920, 0x03829420,
	0x03829520, 0x03829620, 0x03829720, 0x03829820, 0x03829a20, 0x0382c820, 0x0382ce20, 0x0382de20, 0x0382e020, 0x0382e220, 0xd7ffe424, 0x03820e01,
	0x03821220, 0x03826620, 0x03826d20, 0x0382b820, 0xd7ffbb28, 0x29000702, 0x03820b02, 0x0b825f20, 0x03826c20, 0x03827e20, 0x03828420, 0x03828620,
	0x03828820, 0x03828a20, 0x03828c20, 0x0382b120, 0x0382b320, 0x0382e120, 0x0382e320, 0x0382ef20, 0x0382f120, 0xd7fff324, 0x03821503, 0x03821920,
	0x03824920, 0x03824b20, 0x03824d20, 0x03824f20, 0x03825120, 0x03825320, 0x03825520, 0x03825720, 0x03825920, 0x03825b20, 0x03825d20, 0x00276f82,
	0xff0f004b, 0x821100c3, 0x82242003, 0x055b41fb, 0x3900c322, 0x3a200b82, 0x22085f41, 0x823d00d7, 0x8282200b, 0x82832003, 0x82842003, 0x82852003,
	0x82862003, 0x82872003, 0x82882003, 0x828e203b, 0x828f2007, 0x82902003, 0x82912003, 0x829f2003, 0x82c220f1, 0x82c42007, 0x82c62003, 0x82ec2003,
	0x82f02003, 0xfff22803, 0xff2401ec, 0x822601c3, 0xff362803, 0xff3801ec, 0x823a01d7, 0x823b2003, 0x823d200b, 0x823f2003, 0x82432003, 0x825f2003,
	0x82692003, 0x82712003, 0x82aa2027, 0x82bc2007, 0x82fa2007, 0x82fc2007, 0xfffe2403, 0x820002ec, 0x822820f5, 0x82582007, 0x82722003, 0xffa92403,
	0x82b502c3, 0x82b72003, 0x82b92003, 0x82bd2003, 0x82d92003, 0x82db2017, 0xffdd2803, 0xff1703ec, 0x821d03c3, 0x821f2007, 0x82212003, 0x82232003,
	0x82252003, 0x82272003, 0x82292003, 0x822b2003, 0x822d2003, 0x822f2003, 0x82312003, 0x82332003, 0x091b4203, 0x7103d726, 0x7303d7ff, 0x3926d382,
	0x3d000500, 0x03820a00, 0x29000c28, 0x9aff0f00, 0x03821100, 0x0b822220, 0x1d842420, 0x3a001426, 0x3c001400, 0x27420382, 0x82822007, 0x82832017,
	0x82842003, 0x82852003, 0x82862003, 0x82872003, 0xff882403, 0x829f00c3, 0x82c22027, 0x82c4200b, 0xffc62803, 0x003601d7, 0x82380114, 0x823a2003,
	0x82432003, 0x825f200f, 0x82692003, 0x82aa2003, 0x82fa2003, 0x82fc2013, 0x00fe2403, 0x82000214, 0x00072403, 0x820b023d, 0xff282403, 0x825802d7,
	0x82722003, 0x82d92003, 0x82db2003, 0x82dd2003, 0x821d20ad, 0x821f2003, 0x82212003, 0x82232003, 0x82252003, 0x82272003, 0x82292003, 0x822b2003,
	0x822d2003, 0x822f2003, 0x82312003, 0x82332003, 0x006f2403, 0x82710314, 0x82732003, 0x43e58393, 0xf1440501, 0xff89210f, 0x2019dd44, 0x441b82c8,
	0xec231dc9, 0x44ff6601, 0xa14405a5, 0x0af94206, 0x4402ec21, 0x85441b89, 0x17754407, 0x20327144, 0x43e58b00, 0xdb430de3, 0x4314203b, 0x63268edf,
	0x9aff0500, 0x03820a00, 0x460fcb41, 0xae2409bd, 0xc3ff3a00, 0x41069d48, 0xbd4619df, 0x01ec2135, 0x2019bd46, 0x0aa148c3, 0x2917bd46, 0xfffc01c3,
	0xfffe01c3, 0xbd4602c3, 0x029a2505, 0x029aff0b, 0x45b7bd46, 0xd721176d, 0x056d4500, 0x3c00d723, 0x1f6d45ff, 0x4500d721, 0x3526e76d, 0x33ff0f00,
	0x03821100, 0x7d492420, 0x07ef4706, 0xd7ff3d23, 0x19954e00, 0x89007126, 0x9f00ecff, 0x514e0382, 0x069f440b, 0x1f480120, 0xff3b2407, 0x823d01d7,
	0x823f2003, 0x0b054e03, 0xaeffaa28, 0xecffbb01, 0x03820002, 0x2207614d, 0x4caeff72, 0x03200bf5, 0x212f994c, 0x5f48ff6f, 0x43034209, 0x0342c320,
	0x000b22e8, 0x0adb4937, 0x2107d349, 0xcf49ffa9, 0x20012714, 0x52000500, 0x03820a00, 0x9aff0f24, 0x9f471000, 0x4d85200c, 0x362c109f, 0x3700ecff,
	0x44001400, 0x460085ff, 0x47200382, 0x48200382, 0x4a200382, 0x50243782, 0x5100aeff, 0x52200382, 0x53200f82, 0x54200782, 0x55200782, 0x56200782,
	0x58200782, 0x59240782, 0x5a00c3ff, 0x5b200382, 0x5c200382, 0x5d200382, 0x82200382, 0x83201b82, 0x84200382, 0x85200382, 0x86200382, 0x87200382,
	0x88230382, 0x4d0071ff, 0xa2201bf7, 0xa3202382, 0xa4200382, 0xa5200382, 0xa6200382, 0xa7200382, 0xa8200382, 0xa9200382, 0xaa200382, 0xab200382,
	0xac200382, 0xad200382, 0xb3200382, 0xb4207f82, 0xb5200782, 0xb6200382, 0xb7200382, 0xb8200382, 0xba200382, 0xbb200382, 0xbc201b82, 0xbd200382,
	0xbe200382, 0xbf200382, 0xc1209782, 0xc2200382, 0xc3201b82, 0xc4200382, 0xc5200382, 0xc6200382, 0xc7200382, 0xc8200382, 0xc9201b82, 0xcb200782,
	0xcd200382, 0xce200382, 0xcf200f82, 0xd5200782, 0xd7200382, 0xd9200382, 0xdb200382, 0xdd200382, 0x834e0382, 0xff06240f, 0x820801ae, 0x820a2003,
	0xff0e2803, 0xff0f01c3, 0x82110185, 0x82122003, 0x8213200b, 0x82142007, 0x82152007, 0xff1c2407, 0x821d01ec, 0x821f2007, 0x82202003, 0x8221200b,
	0x82222007, 0x82232007, 0x00242407, 0x82260114, 0x82372003, 0x8239202b, 0x82402003, 0x82432003, 0x82442017, 0x824a2003, 0x825f2003, 0x82662003,
	0x82692013, 0x826d2007, 0x82712007, 0x8279202b, 0x827b200b, 0x827e2073, 0x82802007, 0x82822013, 0x82842007, 0x828a200f, 0x828c200b, 0x828e200b,
	0x82902003, 0x82912003, 0x8293200f, 0x82942007, 0x82962007, 0x82992007, 0x829b2003, 0x82a02003, 0x82aa207b, 0x080b4f07, 0xca205382, 0xf7820f82,
	0x82d80121, 0x82db2007, 0x82dc2003, 0x82dd2033, 0x82de2003, 0x82ea200b, 0x82ed2003, 0x82ee2003, 0x82fb2003, 0x82fd2013, 0xffff2403, 0x820102c3,
	0xff022c03, 0xff0302ae, 0x0007029a, 0x820b0252, 0xff282403, 0x82580285, 0x82592003, 0x825f2003, 0x8260201f, 0x826a2007, 0x826c2003, 0x21bf820b,
	0x0b827202, 0x0b827e20, 0x07827f20, 0x07828120, 0x674f8320, 0x82852006, 0x8286200f, 0x8287200b, 0x82882007, 0x82892007, 0x21cf8207, 0x0b828b02,
	0x03828c20, 0x0f828d20, 0x1400a924, 0x0b82aa02, 0x0382b120, 0x0f82b220, 0x0782b320, 0x0782b420, 0x1782b520, 0x0b82b620, 0x0782b720, 0x0782b820,
	0x0782b920, 0x0782ba20, 0x0782bd20, 0x1f82d920, 0x0382da20, 0x0221d382, 0x200782dc, 0x200382dd, 0x4f0382e0, 0xf0200bab, 0xf1200f82, 0xf2202f82,
	0xf3200782, 0xf4200782, 0xf8200782, 0xfa200782, 0xfc280382, 0x0a03c3ff, 0x0c0385ff, 0x0e200382, 0x10200b82, 0x15200382, 0x16200382, 0x17240f82,
	0x18031400, 0x19200b82, 0x1a200382, 0x1d200f82, 0x1e200382, 0x1f200382, 0x21200382, 0x22200382, 0x23200382, 0x24200382, 0x25200382, 0x26200382,
	0x27200382, 0x28200382, 0x29200382, 0x2a200382, 0x2b200382, 0x2c200382, 0x2d200382, 0x2e200382, 0x2f200382, 0x30200382, 0x31200382, 0x32200382,
	0x33200382, 0x34200382, 0x36200382, 0x38200382, 0x3a200382, 0x3c200382, 0x3e200382, 0x40200382, 0x42200382, 0x44200382, 0x49200382, 0x4a208382,
	0x4b200782, 0x4c200782, 0x4d200782, 0x4e200782, 0x4f200782, 0x50200782, 0x51200782, 0x52200782, 0x53200782, 0x54200782, 0x55200782, 0x56200782,
	0x57200782, 0x58200782, 0x59200782, 0x5a200782, 0x5b200782, 0x5c200782, 0x5d200782, 0x5e200782, 0x5f200782, 0x60200782, 0x62240782, 0x6403aeff,
	0x66200382, 0x68200382, 0x6a200382, 0x6c200382, 0x6e200382, 0x70200382, 0x72202382, 0x742a0382, 0x2300c3ff, 0xd7ff0f00, 0x03821100, 0x334d2420,
	0x00d7211c, 0x200a1f4d, 0x0bf34c01, 0xecffaa23, 0x0bdb4c02, 0x4c0bc74c, 0x00212ec3, 0x0c0f45e8, 0x2109ab4c, 0xd74e00c3, 0x8244200f, 0x0d0f56bb,
	0x5000c322, 0x5120c582, 0x20061756, 0x20078253, 0x20238254, 0x20078255, 0x20038256, 0x20038258, 0x200f8282, 0x20038283, 0x20038284, 0x20038285,
	0x20038286, 0x23038287, 0x0085ff88, 0x201b434b, 0x202382a2, 0x200382a3, 0x200382a4, 0x200382a5, 0x200382a6, 0x560382a7, 0xb3201737, 0xb4206b82,
	0x20163b56, 0x201b82bb, 0x200382bc, 0x200382bd, 0x200382be, 0x202782c2, 0x200382c3, 0x200382c4, 0x200382c5, 0x200382c6, 0x200382c7, 0x561b82c8,
	0xce200b53, 0x57560f82, 0x0fb74f17, 0xd7ff0624, 0x03820801, 0x03820a20, 0x03820e20, 0x20076b56, 0x240b8212, 0x01c3ff13, 0x20078214, 0x20078215,
	0x2007821d, 0x2003821f, 0x20038221, 0x20038223, 0x20138243, 0x20038244, 0x200b824a, 0x2007825f, 0x20078266, 0x20078269, 0x2007826d, 0x20078279,
	0x2007827b, 0x2007827e, 0x20038282, 0x560b8284, 0x93200b67, 0x5f561382, 0x82aa200b, 0x062f500f, 0x82ca0121, 0x0b3b560b, 0x220b3356, 0x44d7ffee,
	0xc3260a8b, 0xc3ff5802, 0x03825902, 0x17825f20, 0x20072756, 0x200b826c, 0x20138272, 0x2007827e, 0x8207827f, 0x8502217b, 0x86200782, 0x87200f82,
	0x88200782, 0x89200782, 0x77500782, 0x828d2007, 0x82b1200b, 0x82b22013, 0x82b32007, 0x82b42007, 0x82d92007, 0x82da2003, 0x82db2003, 0x82dc2003,
	0x82dd2003, 0x82e02003, 0x0b9b5003, 0x0f82f020, 0x2f82f120, 0x0782f220, 0x0782f320, 0xc3fff424, 0x03820a03, 0x03820c20, 0xd7ff1524, 0x07821603,
	0x07821920, 0x07821a20, 0x03821d20, 0x03821e20, 0x03821f20, 0x03822120, 0x03822220, 0x03822320, 0x03822420, 0x03822520, 0x03822620, 0x03822720,
	0x03822820, 0x03822920, 0x03822a20, 0x03822b20, 0x03822c20, 0x03822d20, 0x03822e20, 0x03822f20, 0x03823020, 0x03823120, 0x03823220, 0x03823320,
	0x03823420, 0x201f1756, 0x20838249, 0x2027824a, 0x2007824b, 0x2007824c, 0x2007824d, 0x2007824e, 0x2007824f, 0x20078250, 0x20078251, 0x20078252,
	0x20078253, 0x20078254, 0x20078255, 0x20078256, 0x20078257, 0x20078258, 0x20078259, 0x2007825a, 0x2007825b, 0x2007825c, 0x2007825d, 0x2007825e,
	0x2007825f, 0x20078260, 0x20078262, 0x20038264, 0x20038266, 0x20038268, 0x2003826a, 0x2a03826c, 0x00d7ff6e, 0x000500e9, 0x820a0066, 0xff0f2403,
	0x821100ae, 0x82242003, 0x0fab4d15, 0x13824420, 0x03824620, 0x03824720, 0x03824820, 0xecff4a24, 0x03825000, 0x03825120, 0x0f825220, 0x07825320,
	0x07825420, 0x07825520, 0x07825620, 0x07825820, 0x03825d20, 0x21197d50, 0xcb4f00ae, 0x82a2201b, 0x82a32043, 0x82a42003, 0x82a52003, 0x82a62003,
	0x82a72003, 0x82a82003, 0x82a92003, 0x82aa2003, 0x82ab2003, 0x82ac2003, 0x82ad2003, 0x82b32003, 0x82b4206b, 0x82b52007, 0x82b62003, 0x82b72003,
	0x82b82003, 0x82ba2003, 0x82bb2003, 0x82bc201b, 0x82bd2003, 0x82be2003, 0x82c22003, 0x82c32013, 0x82c42003, 0x82c52003, 0x82c62003, 0x82c72003,
	0x82c82003, 0x82c9201b, 0x82cb2007, 0x82cd2003, 0x82ce2003, 0x82cf200f, 0x82d52007, 0x82d72003, 0x82d92003, 0x82db2003, 0x82dd2003, 0x0f2d5503,
	0xecff0624, 0x03820801, 0x39550a20, 0xff0f2406, 0x821101d7, 0x82122003, 0x8213200f, 0x82142007, 0x82152007, 0x0fa14307, 0x17824020, 0x17824320,
	0x03824420, 0x2205a543, 0x826601d7, 0x82692013, 0x826d200f, 0x82792007, 0x827b2007, 0x827e2007, 0x82822007, 0x82842003, 0x828c200b, 0x828e2007,
	0x82902003, 0x82932003, 0x82962003, 0x82992003, 0x519b2003, 0xdb5006a9, 0xca012106, 0xcf200f82, 0xd8200382, 0xdb200382, 0xde200382, 0xea200382,
	0xed200382, 0xa5430382, 0x02662a05, 0x0266000b, 0x02d7ff28, 0x20038258, 0x24038259, 0x02ecff5f, 0x20078260, 0x2003826a, 0x200b826c, 0x20078272,
	0x2007827e, 0x2007827f, 0x20078284, 0x20078285, 0x20078286, 0x20078287, 0x20078288, 0x55078289, 0x8d2007ad, 0xb1200b82, 0xb2201382, 0xb3200782,
	0xb4200782, 0xd9200782, 0xda200382, 0x7f820382, 0x82dc0221, 0x82dd2007, 0x82e02003, 0x0b475103, 0x0f82f020, 0x2f82f120, 0x0782f220, 0x0782f320,
	0xd7fff424, 0x03820a03, 0x03820c20, 0xecff1524, 0x07821603, 0x07821920, 0x07821a20, 0x03821d20, 0x59521e20, 0x8222200a, 0x8223200b, 0x82242003,
	0x82252003, 0x82262003, 0x82272003, 0x82282003, 0x82292003, 0x822a2003, 0x822b2003, 0x822c2003, 0x822d2003, 0x822e2003, 0x822f2003, 0x82302003,
	0x82312003, 0x82322003, 0x82332003, 0x82342003, 0x82362003, 0x82382003, 0x823a2003, 0x823c2003, 0x823e2003, 0x82402003, 0x82422003, 0x82442003,
	0x82492003, 0x824a2083, 0x824b2007, 0x824c2007, 0x824d2007, 0x824e2007, 0x824f2007, 0x82502007, 0x82512007, 0x82522007, 0x82532007, 0x82542007,
	0x82552007, 0x82562007, 0x82572007, 0x82582007, 0x82592007, 0x825a2007, 0x825b2007, 0x825c2007, 0x825d2007, 0x825e2007, 0x825f2007, 0x82602007,
	0x82622007, 0x82642007, 0x82662003, 0x82682003, 0x826a2003, 0x826c2003, 0xff6e2403, 0x568c00ec, 0x37470813, 0x8246200f, 0x8247201d, 0x82482003,
	0x82522003, 0x82542003, 0x1bfb4603, 0x1f82a820, 0x0382a920, 0x0382aa20, 0x0382ab20, 0x0382ac20, 0x0382ad20, 0x0382b420, 0x0382b520, 0x0382b620,
	0x0382b720, 0x0382b820, 0x0382ba20, 0x2205b746, 0x82cb00ec, 0x82cd200b, 0x05b74603, 0xd500ec22, 0xd7200b82, 0xd9200382, 0xdb200382, 0xdd200382,
	0xb7460382, 0x05ab460f, 0x1101ec25, 0x4601ecff, 0xec2005ab, 0x2106ab46, 0x835601ec, 0x82792007, 0x827e201b, 0x82822003, 0x828c2003, 0x828e2003,
	0x82902003, 0x82932003, 0x82962003, 0x82992003, 0x829b2003, 0x077b4603, 0x0b82cf20, 0x0382d820, 0x0382db20, 0x0382de20, 0x0382ea20, 0xecffed22,
	0x200cc356, 0x200f8260, 0x5603826a, 0x7f2007cb, 0x63460b82, 0x02ec2105, 0x21056346, 0x634602ec, 0x02ec2105, 0x21096346, 0x634602ec, 0x02ec2105,
	0x22056346, 0x82e002ec, 0x0d4f4637, 0xf102ec26, 0xf202d7ff, 0x4f461782, 0x03ec2605, 0x03ecff0a, 0x4603820c, 0xec21054f, 0x054f4603, 0x3603ec22,
	0x38201382, 0x3a200382, 0x3c200382, 0x3e200382, 0x40200382, 0x42200382, 0x44200382, 0xf3450382, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105,
	0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105,
	0x2205f345, 0x490601ec, 0x9a201679, 0x28107949, 0x00ecff36, 0x009aff44, 0x20038246, 0x20038247, 0x4e038248, 0xc3260581, 0xc3ff5100, 0x0f825200,
	0x07825320, 0x07825420, 0x07825520, 0xaeff5624, 0x07825800, 0xd7ff5b24, 0x3b825c00, 0x2205794e, 0x8283009a, 0x8284201f, 0x82852003, 0x82862003,
	0x82872003, 0x05794e03, 0x5800d721, 0xa22017a9, 0xa3202382, 0xa4200382, 0xa5200382, 0xa6200382, 0xa7200382, 0xa8200382, 0xa9200382, 0xaa200382,
	0xab200382, 0xac200382, 0xad200382, 0xb3200382, 0xb4207782, 0xb5200782, 0xb6200382, 0xb7200382, 0xb8200382, 0xba200382, 0xbb200382, 0xbc201b82,
	0xbd200382, 0xbe200382, 0xbf200382, 0xc1209b82, 0xc2200382, 0xc3201b82, 0xc4200382, 0xc5200382, 0xc6200382, 0xc7200382, 0xd9420382, 0x009a2205,
	0x200b82cb, 0x420382cd, 0x9a2205d9, 0x0b82d500, 0x0382d720, 0x0382d920, 0x0382db20, 0x0382dd20, 0x240fd942, 0x01c3ff06, 0x20038208, 0x4203820a,
	0x9a2405e5, 0x9aff1101, 0x2006e542, 0x06e5429a, 0x4e019a21, 0xae250579, 0xaeff1f01, 0x05794e01, 0x4e01ae21, 0xae250579, 0xecff3901, 0x056d4e01,
	0x44019a22, 0x4a203b82, 0x5f202382, 0xa5490782, 0x019a2105, 0x2205a549, 0x827b019a, 0x827e2063, 0x82802017, 0x8282202f, 0x82842007, 0x828a200f,
	0x828c200b, 0x828e200b, 0x82902003, 0x82932003, 0x82962003, 0x82992003, 0x829b2003, 0x05614e03, 0x49019a21, 0x9a2209b1, 0x1782cf01, 0x0382d820,
	0x0382db20, 0x3f82dd20, 0x0782de20, 0x0382ea20, 0x0382ed20, 0xaeffee26, 0xecff0102, 0x260ab949, 0xff58029a, 0x8259029a, 0x05b94903, 0x6a029a22,
	0x6c240b82, 0x6d02d7ff, 0x72202782, 0xbd490b82, 0x029a2205, 0x200f8281, 0x08614383, 0x61439a20, 0x439a2006, 0x9a220661, 0x33828a02, 0x1f828b20,
	0x07828c20, 0x37828d20, 0x20056543, 0x0665439a, 0xb8029a22, 0xba201b82, 0xd9200382, 0xda201b82, 0x9f820382, 0x82dc0221, 0x82dd2007, 0x82e02003,
	0x0d814303, 0x81439a20, 0x029a2106, 0x22058143, 0x82f8029a, 0x82fa203b, 0xfffc2803, 0xff0a03ec, 0x820c039a, 0x820e2003, 0x4310200b, 0x9a200895,
	0x22069543, 0x821d039a, 0x821e201b, 0x821f2003, 0x82212003, 0x82222003, 0x82232003, 0x82242003, 0x82252003, 0x82262003, 0x82272003, 0x82282003,
	0x82292003, 0x822a2003, 0x822b2003, 0x822c2003, 0x822d2003, 0x822e2003, 0x822f2003, 0x82302003, 0x82312003, 0x82322003, 0x82332003, 0x82342003,
	0x82362003, 0x82382003, 0x823a2003, 0x823c2003, 0x823e2003, 0x82402003, 0x82422003, 0x82442003, 0x05f14303, 0xf1439a20, 0x439a2006, 0x9a2006f1,
	0x2006f143, 0x06f1439a, 0xf1439a20, 0x439a2006, 0x9a2006f1, 0x2006f143, 0x06f1439a, 0xf1439a20, 0x439a2006, 0x9a2006f1, 0x2606f143, 0xff62039a,
	0x826403c3, 0x82662003, 0x82682003, 0x826a2003, 0x826c2003, 0x826e2003, 0xff702403, 0x827203ec, 0xff742203, 0x0c7758ec, 0x490d4f5e, 0x5d591b91,
	0x05b94821, 0xecff6d23, 0x835d5901, 0x0a000126, 0x0400d7ff, 0x20072f5b, 0x06af5a02, 0x4a260021, 0x592308ef, 0x64001400, 0x14220561, 0x0b82bf00,
	0x1400c124, 0x03823701, 0x03823920, 0x03828020, 0x03828a20, 0x03829120, 0x03829420, 0x0382dc20, 0x0382dd20, 0x0382fb20, 0x0382fd20, 0x1400ff24,
	0x03820102, 0x49000721, 0x6d200543, 0x81200b82, 0x83200382, 0x8b200382, 0xaa200382, 0xb6200382, 0xb8200382, 0xba200382, 0xf8200382, 0xfa200382,
	0xfc240382, 0x0e031400, 0x10200382, 0x18200382, 0x70200382, 0x72200382, 0x74200382, 0x05207f82, 0x2008e347, 0x2559844a, 0x000b0229, 0xc7830029,
	0xc784c320, 0x0a002924, 0xe7462900, 0x03002307, 0xdf825b00, 0xecff5d28, 0xecff4001, 0xd5881f00, 0x0d824420, 0x03824a20, 0x0382a220, 0x0382a320,
	0x0382a420, 0x0382a520, 0x0382a620, 0x0382a720, 0x0382c320, 0x0382c520, 0x3982c720, 0x01232b82, 0x82ecffca, 0x20c58553, 0x200b8259, 0x240382da,
	0x03ecffdc, 0x2003821e, 0x20038222, 0x20038224, 0x20038226, 0x20038228, 0x2003822a, 0x2003822c, 0x2003822e, 0x20038230, 0x20038232, 0x834b8234,
	0x825220b9, 0x0052229d, 0x20b98457, 0x20b98252, 0x55918252, 0x4920070b, 0x3620158a, 0x5220e588, 0xa820bf82, 0xb74b0382, 0x4b012016, 0x13240743,
	0x1501d7ff, 0xf74a0382, 0x4ad8201b, 0x054805df, 0x07c34a08, 0xd7ff7f24, 0x03828502, 0x03828720, 0x03828920, 0x03828d20, 0x0382b220, 0x874ab420,
	0x82f02006, 0x82f22007, 0x0b734a03, 0xd7ff1624, 0x03821a03, 0x03824a20, 0x03824c20, 0x03824e20, 0x03825020, 0x0321af82, 0x20078254, 0x20038256,
	0x20038258, 0x2003825a, 0x2003825c, 0x2003825e, 0x20c78260, 0x089b5d05, 0x3d2cef85, 0x3d000b02, 0x52003200, 0xa800ecff, 0x61490382, 0x26e78216,
	0xff1101ec, 0x821301ec, 0x49152003, 0xd8201e05, 0xde231f82, 0x4802ecff, 0x7f2007e1, 0x85200b82, 0x87200382, 0x89200382, 0x8d200382, 0xb2200382,
	0xb4200382, 0xe0200382, 0xf0200382, 0xf2200382, 0xf4210382, 0x09a948ff, 0x0b821620, 0x03821a20, 0x03824a20, 0x03824c20, 0x03824e20, 0x03825020,
	0xdf82a782, 0x5603ec22, 0x58200b82, 0x5a200382, 0x5c200382, 0x5e200382, 0x60200382, 0x0326bf82, 0xd7ff7101, 0x03827801, 0x29009123, 0x240d8300,
	0xff72019a, 0x221182c3, 0x629300c3, 0x0d2808a3, 0x0f0085ff, 0x1e004400, 0x22240382, 0x2600c3ff, 0x2a203982, 0x2d230382, 0x62005e00, 0x3d241bb7,
	0x49003b00, 0x57202782, 0x59240382, 0x5a00d7ff, 0x5c200782, 0x82200782, 0x97440382, 0x13155c1b, 0x3382bf20, 0xd14dc120, 0x12115e06, 0x00f60023,
	0x28df625e, 0xecff3728, 0x9aff3801, 0xf7823901, 0x07823a20, 0x3b003b23, 0x21ab8201, 0x07823f01, 0x4d5e6620, 0xff712406, 0x82800185, 0x828a201f,
	0x82912003, 0x82942003, 0x82a32003, 0x0b076363, 0x1382dc20, 0x0382dd20, 0x0382fa20, 0x3782fb20, 0x0782fc20, 0x0782fd20, 0x0782fe20, 0xecffff2b,
	0x9aff0002, 0xd7ff0102, 0x131f6302, 0x854d6d20, 0x82812006, 0x82832007, 0x0f2b6303, 0x13828b20, 0x20072f63, 0x630b82aa, 0xb6200b33, 0xb7240f82,
	0xb80285ff, 0xb9200782, 0xba200782, 0x3f630782, 0xf8022116, 0xfa201b82, 0xfc240382, 0x0e03d7ff, 0x10200382, 0x15280382, 0x1703ecff, 0x180385ff,
	0x6306854d, 0x70204f57, 0x71245782, 0x72039aff, 0x73200782, 0x74240782, 0x9000d7ff, 0x42204d42, 0x45423349, 0x4102104e, 0x91209c01, 0x200a4142,
	0x0a8f447f, 0x8f44d720, 0xff57282c, 0xff5900e5, 0x825a00d5, 0xff5c2207, 0x1cb152db, 0x22158744, 0x82c100db, 0x163b4937, 0x202e8744, 0x068744e5,
	0x4401db21, 0xdb261d87, 0xd5ff8a01, 0x03829101, 0x03829420, 0x25118744, 0xffdd01d5, 0x874401db, 0x01e52105, 0x21058744, 0x874401e5, 0x44e52005,
	0xdb200687, 0x2a168744, 0xff7e02db, 0xff8102ec, 0x828302db, 0x11874403, 0x4402db21, 0xd5200987, 0x230cbb67, 0x02d5ffb6, 0x21058744, 0x874402db,
	0x02db2105, 0x22198744, 0x82fa02db, 0xfffc245f, 0x820e03db, 0x82102003, 0x09874403, 0xdf67d520, 0x82702054, 0x05874463, 0x4403db21, 0xdb280587,
	0x05009400, 0x0a0066ff, 0x0d210382, 0x450210ff, 0x06283501, 0x070266ff, 0x0a02aeff, 0x0b200782, 0x20200782, 0x210e3b63, 0x5142ff6d, 0x09f365ed,
	0x65571020, 0x07c94606, 0xecff8424, 0x03828900, 0xc9688a20, 0x17c36b06, 0x22074b44, 0x463d00f6, 0x87480881, 0x82a32007, 0x837b4d13, 0xe34b3720,
	0x83e58f08, 0x678b20e1, 0xdd4022c3, 0x0020229b, 0x1a595d24, 0x2463555d, 0xff0c0056, 0x10376bd7, 0xf6ff2d24, 0x99823600, 0xc3ff3724, 0x1f823900,
	0x200fd165, 0x20138240, 0x6b038260, 0xd9651947, 0xf600292c, 0x1c01f6ff, 0x2001ecff, 0x22200382, 0x2032576b, 0x203382a0, 0x6b4382a3, 0x42208b5f,
	0x240c3d5f, 0x00ecff30, 0x2003823d, 0x1aef4144, 0xd7ff8823, 0x176b4f00, 0x6f4fc220, 0x4fc42006, 0xc6200673, 0x6c06774f, 0x5f820f6d, 0x716c0120,
	0xffaa2407, 0x5fca01ec, 0x59200a81, 0x72200b82, 0xd9200382, 0xda200382, 0xdb200382, 0xdc200382, 0xdd240382, 0x1d03ecff, 0x2006a74f, 0x2007821f,
	0x20038221, 0x20038222, 0x20038223, 0x20038224, 0x06b74f25, 0x07822720, 0x03822820, 0xbf4f2920, 0x4f2b2006, 0x2d2006c3, 0x2006c74f, 0x06cb4f2f,
	0x07823120, 0x796c3220, 0x82342006, 0x002e2a83, 0x00520005, 0x00c3ff09, 0x2507820a, 0x003d000c, 0x716c000d, 0x0dd56405, 0x24094f56, 0x00beff2d,
	0x242f8230, 0x00d7ff32, 0x20038234, 0x24ed8236, 0x00270037, 0x24378239, 0x0014003a, 0x56438240, 0x49230f67, 0x5600e5ff, 0x114e236b, 0x0b735607,
	0x4f826020, 0x56ff8221, 0x0024ec77, 0x01befff6, 0x24437b56, 0x01270024, 0x26038226, 0x01140036, 0x56ecff37, 0x7120248b, 0x79212f82, 0x178f56ff,
	0x5601d721, 0x91240b8f, 0x9301d7ff, 0x94202b82, 0x97560782, 0x82a3200f, 0x82aa20c3, 0x079b561b, 0x5782bc20, 0x0f82ca20, 0x4f0b9f56, 0xec21052d,
	0x0ea35601, 0x82fa0121, 0x82fb20af, 0x82fc20af, 0x82fd2007, 0x82fe2007, 0xffff2207, 0x68bb56ec, 0x2700a923, 0x05614f02, 0xb202d723, 0x09c356ff,
	0x1782b520, 0xd7ffb624, 0x0782b702, 0x8f82b820, 0x0782b920, 0x0782ba20, 0x0782bd20, 0x225bd756, 0x4f270017, 0xd7230699, 0x10ff1a03, 0x0501df16,
	0x0500022a, 0x0a0098ff, 0x0300d7ff, 0x02210987, 0x200d820b, 0x200d8206, 0x2417826f, 0xff49006f, 0x0c3d55db, 0xbe203183, 0xbe221982, 0xc3536100,
	0xff0f2408, 0x821100be, 0xff222803, 0xff4600b4, 0x824700f6, 0x82482003, 0x00492403, 0x824a0014, 0x82522007, 0x82542003, 0x00572403, 0x82a80006,
	0x82a92007, 0x82aa2003, 0x82ab2003, 0x82ac2003, 0x82ad2003, 0x82b42003, 0x82b52003, 0x82b62003, 0x82b72003, 0x82b82003, 0x82ba2003, 0x82c92003,
	0x82cb2003, 0x82cd2003, 0x82cf2003, 0x82d52003, 0x82d72003, 0x82d92003, 0x82db2003, 0xffdd2403, 0x820f01f6, 0x82112003, 0x82132003, 0x82152003,
	0x82792003, 0x827e2003, 0x82822003, 0x828c2003, 0x828e2003, 0x82902003, 0x82932003, 0x82962003, 0x82992003, 0x829b2003, 0x214f8203, 0x0782d801,
	0x0382db20, 0x0382de20, 0x0382ea20, 0xf6ffed2c, 0x3d000702, 0x8dff0802, 0x07820b02, 0x07820c20, 0x81ff1028, 0x0c001502, 0x1b826002, 0x03826a20,
	0x03827f20, 0x03828520, 0x03828720, 0x03828920, 0x03828d20, 0x0382b220, 0x0382b420, 0x0382e020, 0x0382f020, 0x0382f220, 0xf6fff424, 0x03820a03,
	0x03820c20, 0x03821620, 0x03821a20, 0x03823620, 0x03823820, 0x03823a20, 0x03823c20, 0x03823e20, 0x03824020, 0x03824220, 0x03824420, 0x03824a20,
	0x03824c20, 0x03824e20, 0x03825020, 0x03825220, 0x03825420, 0x03825620, 0x03825820, 0x03825a20, 0x03825c20, 0x03825e20, 0xff826020, 0x85410720,
	0x0b515510, 0xdb4f6420, 0x095b5408, 0x5b54e120, 0x2ff9511c, 0x5116af4f, 0x137728f1, 0x097d58ef, 0x8f000c28, 0xa4002200, 0x03824000, 0x52004524,
	0x03824b00, 0x3d004c24, 0x03824d00, 0x0b824e20, 0x03824f20, 0xb800602c, 0xf600ae00, 0xcd00b000, 0x0382b100, 0x1382e720, 0x2f82e920, 0x0a01eb24,
	0x0f82ed00, 0x1b82ef20, 0x2900f124, 0x3382f500, 0xe100f724, 0x1f82f900, 0x0382fc20, 0x5200fe24, 0x03820001, 0x03820220, 0x52000428, 0x8f000702,
	0x6f820b02, 0x2d000126, 0x3a006600, 0x4208734c, 0x52200915, 0x42081542, 0xed411b01, 0x8d377421, 0xe9884220, 0x14003022, 0x2006f14b, 0x0a3177d7,
	0x2405c371, 0x00ecff59, 0x2403825c, 0x00d7ff9f, 0x05095fbf, 0x280cad4b, 0x01ecff23, 0x01d7ff24, 0x20038226, 0x200b8236, 0x20078238, 0x20078239,
	0x2007823a, 0x20038271, 0x200b8280, 0x2003828a, 0x20038291, 0x20038294, 0x200382a0, 0x201782bc, 0x200782dc, 0x770382dd, 0x3d5e0f0d, 0x02292805,
	0x0229000b, 0x5eecff6d, 0x8b200815, 0xa9240b82, 0xaa02d7ff, 0xb5200782, 0xb6200782, 0xb7200782, 0xb8200782, 0xb9200782, 0xba200782, 0xbd200782,
	0xc55d0782, 0x07bd5d0b, 0xd7ff1728, 0xecff1803, 0x07826f03, 0x07827020, 0x07827120, 0x07827220, 0x07827320, 0x83827420, 0xe3601d20, 0x692f1016,
	0x2f105502, 0x20060261, 0x05754401, 0x2015194f, 0x0a8f7b5c, 0x210f194f, 0x194f00ec, 0x3b114f0f, 0x01090f10, 0x238d654f, 0x201d014f, 0x0c014fec,
	0x4e139165, 0x996523f9, 0xff0f251f, 0xff2802d7, 0x22599d65, 0x692700a9, 0xdd4e0607, 0x73d94e0d, 0x10ff1921, 0x0901d50e, 0xf549c520, 0x61102008,
	0x3d580a55, 0xff362707, 0xff3800d7, 0x0d6c00ec, 0x053b5313, 0x5c00d722, 0x6c2e4961, 0x75612f29, 0x82c9200b, 0x09316c8b, 0xcf00ec22, 0x316c0f82,
	0x00ec2115, 0x0f754418, 0xecff0f24, 0x03821101, 0x13631220, 0x05dd7206, 0x1c01ec26, 0x2001d7ff, 0x22200382, 0x44180382, 0x37200f89, 0x39201382,
	0x09590382, 0x07556c07, 0x13828020, 0x47828220, 0x07828a20, 0x520b5d6c, 0xec21059f, 0x059f5201, 0x6c01ec21, 0xa0200765, 0xb8202782, 0xbb202f82,
	0x696c0382, 0x058f520b, 0x6c01d721, 0x01210a71, 0x202b82fb, 0x220382fd, 0x61d7ffff, 0x431805b9, 0x9f630845, 0x6c612005, 0xec210885, 0x07c16102,
	0x13827f20, 0x200bc561, 0x6f0f8285, 0xec21054f, 0x054f6f02, 0x8a02ec22, 0xd1611382, 0x828d2007, 0x056f520b, 0xb202ec22, 0x576f0b82, 0x02ec2205,
	0x207382b6, 0x200382b8, 0x6c0382ba, 0xec2105a5, 0x0d451802, 0x82f02007, 0x054f6f27, 0x6f02ec21, 0xec20054f, 0x240cd961, 0x03ecff0a, 0x6103820c,
	0x16200be1, 0xe1610f82, 0x821a2007, 0x21bd6c0b, 0x4a03ec22, 0x0b6f2782, 0x03ec2105, 0x22050b6f, 0x644f03ec, 0x0b6f064b, 0x03ec2105, 0x21050b6f,
	0x0b6f03ec, 0x03ec2105, 0x22050b6f, 0x825903ec, 0x825a2027, 0x050b6f03, 0x6f03ec21, 0xec21050b, 0x050b6f03, 0x1803ec21, 0x241b8d45, 0x03d7ff70,
	0x24038272, 0x00d7ff74, 0x545d6533, 0x14000b22, 0x24746165, 0x0062010b, 0x05ff7129, 0x6d300782, 0x7101ecff, 0x720185ff, 0x73019aff, 0x7501d7ff,
	0x78200382, 0x88200b82, 0x91241b82, 0x0300c3ff, 0x08cd4218, 0xecff7326, 0x5f010b00, 0x64202f82, 0x67200382, 0x6c200382, 0x70200382, 0xc3203f84,
	0xd7223f82, 0x3b827401, 0x0f827720, 0x07827820, 0x2d828820, 0x10002422, 0x6d224182, 0x3582c3ff, 0x62019a22, 0x200a1b76, 0x20218273, 0x20038276,
	0x20698279, 0x06ed557a, 0x1f827d20, 0x0b827e20, 0xaeff8124, 0x07828201, 0x1f828320, 0x13828420, 0x07828520, 0x07828620, 0x03828720, 0x03828920,
	0x916c8c20, 0x828f2006, 0x82902007, 0x82922003, 0x82932013, 0x82942033, 0x82952027, 0x8296200b, 0x8298200b, 0x8299200b, 0x829a201b, 0xff9b280f,
	0xff0202ae, 0x840302c3, 0x827120cd, 0x82722011, 0x82782003, 0x0119220d, 0x20278279, 0x2003827d, 0x2003827e, 0x20038280, 0x20038281, 0x85c18283,
	0x01d72673, 0x01290088, 0x2013828a, 0x2013828b, 0x2007828c, 0x2007828d, 0x2003828f, 0x200b8290, 0x20078291, 0x20078292, 0x20038293, 0x200b8294,
	0x20078295, 0x85078296, 0x01d7227b, 0x240f829a, 0x00d7ff9b, 0x1049524f, 0x501b5764, 0xfd611b43, 0x21575013, 0x4218d720, 0xd7201a9b, 0x149b4218,
	0x29090b42, 0xff7801c3, 0xff91019a, 0x491801c3, 0x03201e61, 0x184fb165, 0x210bf54a, 0x491800ec, 0x8d421f05, 0x01d72605, 0x01ecff70, 0x20038271,
	0x20038272, 0x42038274, 0xec20058d, 0xec29c182, 0xecff9401, 0xecff0002, 0xa5401803, 0x1871200b, 0x7f083744, 0x97760b49, 0x4344180f, 0xff6d2513,
	0xff7d009a, 0x411d5f76, 0x441835af, 0x5f28254b, 0x620185ff, 0x66019aff, 0x6920e582, 0x6d200782, 0x73230782, 0x4301aeff, 0x85220555, 0x3d7e7a01,
	0x8281200e, 0x05417e23, 0x4301c321, 0x8a240b4d, 0x8c01c3ff, 0x8d202b82, 0x8e200782, 0x8f202382, 0x430a557e, 0x85220559, 0x1b829401, 0x26055943,
	0x0097019a, 0x82980129, 0x8299200f, 0x055d4327, 0xfa019a22, 0x44180f82, 0x02240bbf, 0x03029aff, 0x07200382, 0x44180382, 0x23420ac7, 0x51b22058,
	0x3b1016a1, 0x227101ff, 0x75140062, 0x71210873, 0x05b96bff, 0x2a095546, 0xff7901c3, 0x008801c3, 0x7b8d0129, 0x03201dbf, 0x20f7277b, 0x0b6d4708,
	0xff920125, 0x829501d7, 0x05734303, 0x9a01d726, 0x4600d7ff, 0x61109161, 0x81611789, 0xc94c1846, 0x82622028, 0xff6724a9, 0x486901ec, 0x78201619,
	0xcf551f82, 0xff28240f, 0x605802ec, 0x4c180663, 0x05203fb5, 0x200c3b41, 0x24858281, 0x00290088, 0x18d3782a, 0x181bbf78, 0x181fdb4e, 0x240bff4a,
	0x01aeff73, 0x05a54191, 0x23081970, 0x03d7ff5f, 0x2fa34e18, 0x2748cf20, 0x82222008, 0x4d2420b7, 0x5118127f, 0x40181389, 0x4b1851d1, 0x40182d1b,
	0xec2175e5, 0xe5401800, 0x00ec210d, 0x19e54018, 0x180dfb4d, 0x210de540, 0x401801ec, 0xec2109e5, 0xe5401801, 0xdf4b181b, 0x09434919, 0x0b094118,
	0x490bb56f, 0xd720114f, 0x21184f49, 0x4018ff28, 0xec220bcd, 0x0f826002, 0xecff6122, 0x257e1145, 0xff4a03ec, 0x874d03c3, 0x4dc32005, 0xc3200687,
	0x2106874d, 0x874d03c3, 0x4dc32005, 0xc3200687, 0x2006874d, 0x06874dc3, 0x874dc320, 0x03c32106, 0x2005874d, 0x06874dc3, 0x874dc320, 0x03c32106,
	0x6224df83, 0x6303d7ff, 0x6420e782, 0x65200782, 0x66200782, 0x67200782, 0x68200782, 0x69200782, 0x6a200782, 0x6b200782, 0x6c200782, 0x6d200782,
	0x6e200782, 0x0e1d5518, 0x2209a74c, 0x45290088, 0x21459a25, 0x05ad4a1b, 0x4501d721, 0x36205b25, 0x706d4c18, 0xaeff6228, 0xecff6401, 0x07826901,
	0x07827420, 0x03827820, 0xd7ff8124, 0x03828801, 0xd7ff8e22, 0x0b814c18, 0x3c714c18, 0xe9452920, 0x77b58262, 0x0220091d, 0x2033e545, 0x0cab4ae9,
	0x5c0de566, 0xb54c6151, 0x00d72105, 0x01c34b10, 0x05914d57, 0x1801c321, 0x240bc74b, 0x01c3ff73, 0x21038276, 0x954dff79, 0x187d2009, 0x500ad74b,
	0x852205ef, 0x13828401, 0x03828620, 0x03828720, 0x14008824, 0x4b188901, 0x994d0eeb, 0x01ae210d, 0x07f34b18, 0x27829520, 0x5b829620, 0x3d009724,
	0x0b829801, 0x2205994d, 0x189b01ae, 0x4d14c74b, 0x4b180699, 0x032019c7, 0x01df4a10, 0x002d2103, 0x25050f50, 0xff1100c3, 0xc152009a, 0x019a2511,
	0x01d7ff6d, 0x2105d941, 0xc55201d7, 0x01ae2905, 0x01c3ff7b, 0x01ecff7c, 0x22055152, 0x827f019a, 0x05774f23, 0x5201ae21, 0xe54113cd, 0x01c32105,
	0x21055d52, 0x7f4f019a, 0x019a2505, 0x019aff90, 0x20055d52, 0x08df68c3, 0x20057f4f, 0x0a7f4fae, 0x52019a21, 0x0a250fdd, 0xd7ff5f01, 0x09874b01,
	0x5201d721, 0x742007ed, 0x77209982, 0x78201b82, 0x88240782, 0x1700d7ff, 0x8308a54d, 0x827920c3, 0x22b785b3, 0x827e01ec, 0x8281200b, 0x82852003,
	0x82862003, 0x20a38303, 0x08f5528c, 0x9782ec20, 0x5201d721, 0xec2105f5, 0x0df15201, 0xf152ec20, 0x00ec2a06, 0xff0f000c, 0xff1100ae, 0x208f82ae,
	0x208f84c3, 0x20778269, 0x51461881, 0x82ec2008, 0x01ec21d5, 0x0a774318, 0x86030021, 0x01d722a9, 0x209d8278, 0x1065632c, 0x53073153, 0x09531b1d,
	0x09616321, 0x8b827320, 0xe9868020, 0x9120e183, 0x0cdb4318, 0xa950ec20, 0xee00212f, 0x5d1ac76c, 0x6d2779ad, 0x7d00c3ff, 0x1000d7ff, 0x3f01bf2c,
	0x5617b55d, 0x0f4409d1, 0x01c3231f, 0x0f44ff7e, 0x05754205, 0xe1569a20, 0x0d8f530c, 0x0f44ec20, 0xff8d2208, 0x0e1344d7, 0x5301d721, 0x9a210593,
	0x09ed5601, 0x440b9353, 0x9a200713, 0x5d0cab6c, 0x421016cd, 0x2a0401a7, 0x00880101, 0x01060029, 0x44d7ff79, 0x8c2408fb, 0x9001ecff, 0x93240382,
	0x1400ecff, 0xec201982, 0x2106d545, 0xbd4101ec, 0x01ec2105, 0x58091d45, 0x3183051f, 0x45091b58, 0xec220725, 0x45829501, 0x03829720, 0x03829820,
	0x03829920, 0x51829a20, 0x94010126, 0x0b00ecff, 0x20087d6a, 0x20638249, 0x241b8281, 0x0129008d, 0x2007828e, 0x200f8291, 0x20038294, 0xff5c1896,
	0x02002209, 0x05216701, 0x3789d720, 0x3783b184, 0xb9828c20, 0x20079358, 0x220b8293, 0x18d7ff99, 0x20088742, 0x2225821c, 0x587a01ae, 0xc32008e5,
	0xd726c182, 0xc3ff8101, 0x13828201, 0x20059346, 0x22cd82d7, 0x828601d7, 0x8287200f, 0x09f1587d, 0x8c01d722, 0x8d202782, 0x8f200382, 0x90200382,
	0x91200382, 0x7f420382, 0x82c32005, 0x01c322d9, 0x200f8296, 0x20038298, 0x46038299, 0xc322058b, 0xd7821000, 0x0a005224, 0x9f845200, 0x51827d20,
	0x03827e20, 0x5d828020, 0x20055359, 0x085359ec, 0x13828d20, 0x03829120, 0x9720b383, 0x09154618, 0x45090021, 0x418407fd, 0x21827e20, 0x03828120,
	0x45828220, 0xa5458c20, 0x0d002109, 0x830c3f41, 0x82802067, 0x24638321, 0x013d0088, 0x8531828a, 0x01c3225f, 0x0a0f4194, 0x2409f36b, 0x01140049,
	0x2003828d, 0x2853848e, 0x000b023d, 0x0003003d, 0x203b821e, 0x0505417e, 0x42185f82, 0x7f410afb, 0x01042108, 0x3982cf84, 0x29008a28, 0x14009101,
	0xe56d0700, 0x1801200b, 0x8307d343, 0x0091245b, 0x4b0e0029, 0x718208ef, 0x827d0021, 0x20218333, 0x83638281, 0x838c203f, 0x204b82a7, 0x2007828f,
	0x05fb4190, 0x071d4718, 0x8c040021, 0xff942457, 0x8b1500ec, 0x7901214b, 0x7a203382, 0x7e200382, 0x53850382, 0x8201d722, 0x85200b82, 0x13424782,
	0x01d72205, 0x200f8290, 0x05c94292, 0x82940121, 0x05b1477b, 0x9901d722, 0x8d0a6f41, 0x21498267, 0x5b821300, 0x4101ec21, 0xd72005bb, 0x21063142,
	0x5b4101ec, 0x01292205, 0x204f828c, 0x0873428d, 0x5b09eb42, 0xeb420703, 0x9b01210a, 0x3820b582, 0x2210a777, 0x6b3d002d, 0x91780833, 0x07435f3b,
	0xbd47be20, 0x635f180d, 0x003d2e70, 0x00c3ff05, 0x01c3ff0a, 0x0185ff9d, 0x240382a6, 0x01d7ffb0, 0x200782bc, 0x240782bd, 0x01ecffbf, 0x201b82c1,
	0x6f5718c4, 0x01ec2208, 0x201382df, 0x281382e1, 0x02aeffe4, 0x02c3ff07, 0x2003820b, 0x24c5826d, 0x02d7ff76, 0x200b827c, 0x2003827d, 0x20038280,
	0x20138281, 0x20078282, 0x20078283, 0x2003828b, 0x241f829f, 0x0285ffa9, 0x201382aa, 0x200782b5, 0x200782b6, 0x6a0782b7, 0x852205e7, 0x2382ba02,
	0x2382bb20, 0x1382bd20, 0x1b82bf20, 0x0382c020, 0x0382c120, 0x0382c220, 0x1782ca20, 0x0782d420, 0x0382d520, 0x0b82e520, 0x0382f720, 0x2f82f820,
	0x0782f920, 0x0782fa20, 0x0782fb20, 0x0782fc20, 0x1f82fd20, 0xc3fffe28, 0xd7ff0503, 0x03820703, 0x0b820d20, 0xecff0e24, 0x07820f03, 0x41181020,
	0xc32208a7, 0x8d42d400, 0xff102208, 0x08f17e5c, 0x1811db5c, 0x2c81775f, 0x01ecff9f, 0x019affa4, 0x0185ffaa, 0x200382ae, 0x740382b5, 0xec260517,
	0xc3ffbe01, 0x0f82ca01, 0xd7ffcb24, 0x0b82cc01, 0x0382cd20, 0x5cffce24, 0x1382cf01, 0x0b82d020, 0x0382d120, 0x0382d220, 0x0382d320, 0x0382d420,
	0x1b82d520, 0x0782d620, 0x0382d720, 0x2382d820, 0x0782d920, 0x0382da20, 0x0f4d5918, 0x1382df20, 0x0382e020, 0x0382e120, 0x0382e220, 0x0382e320,
	0x0382e420, 0x0382e520, 0x0382e620, 0x0382e720, 0x0382e820, 0x9782e920, 0x4782ea20, 0x0b82ec20, 0x0782ed20, 0xaeffee28, 0x3d00f001, 0x6782f201,
	0x1382f320, 0x0382f520, 0x0382f720, 0x0382f920, 0x200f675b, 0x06c54d07, 0xecff5f23, 0x05076202, 0x6b028529, 0x6c02c3ff, 0x1802d7ff, 0x20078559,
	0x0155187d, 0x02852108, 0x09895918, 0x8502d726, 0x860285ff, 0x87202782, 0x88200782, 0x89200782, 0x8a200782, 0x8b200782, 0x8c202f82, 0x8d200782,
	0x96200f82, 0x9a200b82, 0xa0200382, 0xa4200382, 0xa6200382, 0xaa200382, 0xac200382, 0xae200382, 0xb0200382, 0xb1200382, 0xb2202b82, 0xb3202b82,
	0xb4200782, 0x24069142, 0x02c3ffb8, 0x200382ba, 0x068142bc, 0x0782c220, 0x0382c420, 0xaeffc528, 0x71ffc602, 0x0782c702, 0x0f82cb20, 0x2f82ce20,
	0x5cffcf24, 0x0b82d102, 0x9942d320, 0x82d72006, 0x18d92007, 0x2218cd59, 0x82e302d7, 0x82e62067, 0x82ec2023, 0x82ee2003, 0x82ef2003, 0x82f0200f,
	0x82f1202f, 0x82f22007, 0x82f32007, 0xd9591807, 0xfe02250e, 0x0003c3ff, 0x06200382, 0x08200382, 0x09280382, 0x0a035cff, 0x0b0385ff, 0x59180782,
	0x11200bf1, 0x12201382, 0x14201382, 0x08b95518, 0x18038522, 0x21660b82, 0x03852205, 0x201f821b, 0x5e1f821c, 0x1f2057eb, 0x2008f946, 0x0821649f,
	0xbe01d726, 0xde01ecff, 0xe1200f82, 0x0720d982, 0x2406fd63, 0x02ecff6c, 0x180f827d, 0x1817d368, 0x20079b45, 0x202382c0, 0x200382c2, 0x0d5318d5,
	0x82f1200e, 0x82f3203f, 0xfffe2e03, 0xff1503d7, 0xff1903ec, 0x010500ec, 0x206982a0, 0x202982dc, 0x200382aa, 0x261982b6, 0x00d7ff18, 0x859f011a,
	0xdd012115, 0x83820782, 0x82e40121, 0x866d2037, 0x954d187f, 0x648b2007, 0x31640641, 0x02ec2205, 0x870f82ba, 0x82c5207b, 0x86c7204d, 0x0a7f6f83,
	0x7b830220, 0x8307836f, 0x09cf7d69, 0x4d0f7f5f, 0xc1833ff5, 0x25062b46, 0x29000b02, 0x6a185f02, 0x3d411e11, 0x3f541807, 0x0631410b, 0x4e072d41,
	0x34203021, 0x29076960, 0x85ffa601, 0xd7ffa801, 0x0382b001, 0xecffb522, 0x21062746, 0x274601ec, 0x01ae2105, 0x21052746, 0x6b4101d7, 0x02c32105,
	0x4607455f, 0xae2a051b, 0xd7ff7d02, 0xaeff8002, 0x03828202, 0x21090f46, 0x0f4602d7, 0x02d72605, 0x0285ffb7, 0x460382b9, 0xae220907, 0x3382c002,
	0x2f82c120, 0x0782c220, 0x0382ca20, 0xecffce24, 0x0f82d402, 0x0b82d520, 0x22050b46, 0x82f902ec, 0x82fb2013, 0x82fd2003, 0xfffe2217, 0x0aff45d7,
	0x0f03ae26, 0x1103aeff, 0x2608fb45, 0xff1b03d7, 0x883100ec, 0x07f546d1, 0xd187d585, 0x8201d721, 0x46cd8871, 0xec2205f1, 0x7182e401, 0xec22d189,
	0x6d827c02, 0x75827d20, 0xec21d189, 0x05e14602, 0xec21d193, 0x05d94602, 0xd182ae20, 0x8502ec21, 0x02ec22d1, 0x22cd88ca, 0x82e502ec, 0x82f7200b,
	0x82f92063, 0x82fb2003, 0x20cd8503, 0x22cd82ec, 0x820703ec, 0x820d20c1, 0x2ecd83c9, 0x0385ff17, 0x00d7ff18, 0xff9d011d, 0x82a6019a, 0x07774103,
	0x2209e742, 0x42f601c3, 0x6d2056eb, 0x2858ab56, 0x01d7ff9f, 0x012900a4, 0x460382b5, 0xd72d05e3, 0xaeffbe01, 0xecffcb01, 0x1400ce01, 0xab571801,
	0x096f680b, 0x4801d721, 0xd722058d, 0x3f82ea01, 0x6944ed20, 0x185f200a, 0x2208a757, 0x826d02d7, 0x094f460b, 0x6802d721, 0xd7220963, 0x1b828502,
	0x21054f46, 0x4f4602d7, 0x02d72205, 0x6813828a, 0xd7220563, 0x57448d02, 0x052f4606, 0x4602d721, 0xd720052f, 0x200c6368, 0x06a948c0, 0x2900ce24,
	0x0b82d502, 0x6c18e020, 0xf0200e05, 0xe7450f82, 0x02d72105, 0x2005e745, 0x0b7368d7, 0xfffe0223, 0xd35718c3, 0xff0e2408, 0x821003d7, 0x00112403,
	0x82150329, 0x44162007, 0x032005cf, 0x2205cb45, 0x821b03d7, 0x2fa15d17, 0xdb4c6720, 0x094d4808, 0xb501712e, 0xbb019aff, 0xbc01d7ff, 0xbe012900,
	0xc42c0782, 0xc9011400, 0xca01ecff, 0xcc01aeff, 0xcd200f82, 0x51480382, 0x01ae2205, 0x200b82d1, 0x200382d2, 0x200382d3, 0x480382d4, 0xd722054d,
	0x0b82d701, 0x2f82d820, 0x0782d920, 0x0382da20, 0x0b82db20, 0x0382de20, 0xf745e020, 0xe2012105, 0xe3200782, 0xe5200382, 0xe6200382, 0xe8200382,
	0xe9200382, 0xea200382, 0xec200382, 0xed200382, 0xee202b82, 0xf0280782, 0xf2015200, 0xf30171ff, 0xf5200b82, 0xf7200382, 0xf9200382, 0x240a6b61,
	0x02aeff6a, 0x240f826b, 0x0285ff72, 0x2007827d, 0x200f827f, 0x20038285, 0x20038287, 0x20038289, 0x2003828d, 0x20178296, 0x2003829a, 0x200382a4,
	0x240382a6, 0x022900a9, 0x200782ac, 0x200382ae, 0x200382b0, 0x202382b2, 0x200382b4, 0x201782b5, 0x200382b7, 0x200382b9, 0x450382bd, 0xc42007ef,
	0xce232382, 0x47029aff, 0xd72105d9, 0x21eb8202, 0x1382d502, 0x0382d720, 0x2205d947, 0x82db02ae, 0x82dc207f, 0x82dd2043, 0x82e02007, 0x20c38207,
	0x21bf8202, 0x0b82f002, 0x0382f220, 0x8344f420, 0xff002806, 0xff0a03d7, 0x820c03ae, 0xff112303, 0x9d47039a, 0x03d72205, 0x240f8216, 0x03290017,
	0x2007821a, 0x2417821b, 0x005cff1c, 0xa4676789, 0x9aff9d30, 0xecff9f01, 0x3d00a401, 0x85ffa601, 0xab43ae01, 0x01ec2108, 0x07cd7018, 0x45ffbe21,
	0x9a22073b, 0x1f82d501, 0x0f82dc20, 0x22059f43, 0x82e701c3, 0x82f2200f, 0x1e8f6703, 0xff6c0223, 0x065b45ec, 0x7e02c322, 0x180a5f45, 0x180f4d49,
	0x20094949, 0x494918d7, 0x0949460e, 0x20097345, 0x067345c3, 0x4902c321, 0xc32a05cb, 0xaeffc702, 0x2900ce02, 0x0382cf02, 0x21055146, 0x374702c3,
	0x45022012, 0xc3210587, 0x077f4503, 0x29001124, 0x03821203, 0x09714918, 0x1903d726, 0x1b03ecff, 0x1c201382, 0x63490382, 0x012a2657, 0x01d7ff9d,
	0x4d0382bc, 0xd7220d9b, 0xe748d001, 0x82e12006, 0xffe4211b, 0x2607874d, 0xff8002d7, 0x828202c3, 0x78a02003, 0xd7210863, 0x05637802, 0xb702d722,
	0xb9202782, 0xbc200382, 0x4d065f78, 0xd7210573, 0x05734d02, 0xcb02d722, 0x734d1782, 0x02d72205, 0x109946e6, 0xfe02c326, 0x0603d7ff, 0x0820f582,
	0x0d240382, 0x0f03c3ff, 0x17200382, 0x2205a944, 0x18002100, 0x2023ff71, 0x82b582b0, 0xbd01217d, 0xbf200782, 0x00206182, 0x76200382, 0x9f200382,
	0x120f7218, 0xa584bb20, 0x47052f47, 0xf5470527, 0x081f4708, 0x21691720, 0x4d8f200e, 0xb9420be5, 0x12494d05, 0x4d07454d, 0x5b519e41, 0x6a022207,
	0x290d10ff, 0x002f6401, 0xff9d0142, 0x00a301d7, 0x00a401f6, 0x82a60129, 0x00aa220b, 0x12f34414, 0x2005e54c, 0x201f82c1, 0x200382c4, 0x202b82ce,
	0x200382d5, 0x200b82e1, 0x320782e7, 0x016600f1, 0x022900f2, 0x02ecff6c, 0x02140072, 0x4cd7ff7c, 0x802008fd, 0x82200b82, 0x12ad5218, 0x4405d744,
	0xad430bd3, 0x82bd2009, 0x82bf202f, 0x05154b03, 0xc202d722, 0xc6200b82, 0xc7440382, 0x02d72209, 0x200f82d5, 0x206b82d9, 0x200382db, 0x440382dd,
	0xd72615d3, 0xd7fffe02, 0x03820d03, 0x6b480f20, 0x09d34406, 0x210ccf44, 0xaf543100, 0x82102008, 0x15a549d5, 0xcb01c322, 0xf1451b82, 0x84ae2009,
	0x000724f5, 0x820b023d, 0x846c2003, 0x02ae22f5, 0x3775187e, 0x05c17116, 0x20055949, 0x20dd84b6, 0x2ad982ae, 0xffc502ae, 0xffc602c3, 0x82c7029a,
	0x23e18707, 0x02aeffd5, 0x125f7518, 0xae21cd82, 0x09994503, 0x4318d720, 0x954508f5, 0x26002106, 0x2408a14e, 0x01ecffb1, 0x084945b5, 0xbe01ec22,
	0xbf200f82, 0xc1200f82, 0xc4200782, 0xc7200382, 0x200a9353, 0x200b827c, 0x20038280, 0x20038282, 0x200382a1, 0x829d82a9, 0x083d453b, 0x21058f41,
	0x3b8202ec, 0x82ce0221, 0x82d4201b, 0x82e72023, 0x82e92003, 0x82f52003, 0x82f72003, 0x099d4c03, 0x0d03ec26, 0x0f03ecff, 0x11240382, 0x1703d7ff,
	0x1b240382, 0x4c00d7ff, 0x210e6554, 0x761800d7, 0xeb670bcf, 0x05af413f, 0x554b3d20, 0x01d72112, 0x2205a942, 0x82e401ae, 0x62f220fd, 0x02200d1d,
	0x181fb341, 0x2107eb76, 0xab41ffc0, 0x2f9f4105, 0xfd831920, 0x21083147, 0x771803d7, 0x56202b13, 0x2494496a, 0x01d7ff9d, 0x200382a4, 0x240382a6,
	0x01ecffaa, 0x550382ae, 0xc322054d, 0x0b82bf01, 0x456ac420, 0x72022519, 0x7602ecff, 0x08077b18, 0x0d2b7718, 0x22050d4f, 0x82ca02c3, 0x82d9201f,
	0x82db2027, 0x82dd2003, 0x0f7b1803, 0x3f77180b, 0x43452047, 0x711808eb, 0xa4246bd9, 0xaa01aeff, 0xae220382, 0x934c9aff, 0x01ec2206, 0x200b82ce,
	0x241382d5, 0x02aefff2, 0x18ed8200, 0x22094f77, 0x825802ae, 0x82722013, 0x05ab4b03, 0x0df97118, 0xaeff0924, 0x734b0b03, 0x03ae2108, 0x2005634b,
	0x3c9f65ae, 0x09514218, 0x57717a18, 0x26053553, 0xffbb01d7, 0x55be01d7, 0x6318057b, 0x8d430cb1, 0x45c32005, 0x8d431841, 0x02c32a09, 0x02c3ffc2,
	0x02aeffc6, 0x450782d5, 0xc3201529, 0x378d7a18, 0x66520121, 0x25107c03, 0x275301fb, 0x01c3ff9f, 0x01ecffa0, 0x21058343, 0x83430185, 0x7b711807,
	0x82be200b, 0x00c42623, 0xffca0114, 0x0a695885, 0x69587120, 0x05655810, 0x58017121, 0xe5203765, 0xe6206782, 0x5d580382, 0x01c32205, 0x236f82ea,
	0x012900eb, 0x21096158, 0x27500185, 0x01852105, 0x180f6158, 0x580ff771, 0x71180761, 0x6d5817ef, 0x58c32005, 0xc3210e6d, 0xf7711802, 0x136d5833,
	0x1400a923, 0x11715802, 0xb202c326, 0xb30285ff, 0x1e177218, 0x1f82bc20, 0x3f82bd20, 0x58075552, 0xc3220581, 0x3b82c602, 0x1b82c720, 0x0382cb20,
	0x2005fb44, 0x2a815871, 0xe302c322, 0x81583782, 0x02c3210d, 0x21058158, 0x721802c3, 0x8158165b, 0x58852012, 0x72180681, 0xe3500d73, 0x03712105,
	0x21058158, 0x721803c3, 0x8b45137f, 0x10712005, 0x0401a727, 0x554b6320, 0xaeff2511, 0x9affaa01, 0x5306e75b, 0xbe270599, 0xc401ecff, 0x53012900,
	0xc3210591, 0x05e35b01, 0xcf017122, 0x4310db5b, 0x9a210b75, 0x09db5b01, 0xde01c322, 0xcf5b5782, 0x1169430f, 0x6543c320, 0x01c32206, 0x5b5b82ee,
	0x654305c7, 0x079d6110, 0xff6a0229, 0xff6b029a, 0x827202c3, 0x827d2007, 0x827f2007, 0x82852007, 0x82872003, 0x82892003, 0x828d2003, 0x07154303,
	0x7f5ba420, 0x0b7b5b06, 0x1f82b220, 0x0382b420, 0x200be142, 0x08d147c6, 0x2213d542, 0x82da029a, 0x82db201f, 0x057d5333, 0xe0029a22, 0xec200b82,
	0x20064b5b, 0x200b82f0, 0x200382f2, 0x5b0382f4, 0x09280733, 0x0a0385ff, 0x0b039aff, 0x0c200782, 0xa1420782, 0x8216200b, 0x821a200f, 0x06914203,
	0x5b510020, 0x05bd4905, 0xa801c32a, 0xaa01ecff, 0xae01d7ff, 0xb0220382, 0x2d4cc3ff, 0x01c32206, 0x200f82bf, 0x200f82c4, 0x200782c7, 0x200782ce,
	0x200382d5, 0x248182f2, 0x02d7ff72, 0x20078276, 0x2003829f, 0x200b82a1, 0xed8018a9, 0x82bb200e, 0x82bd200f, 0x82ca2003, 0x82ce2003, 0x82cf201f,
	0x0b801807, 0xe502210a, 0xe7200f82, 0xe9201782, 0xf5280382, 0x0503d7ff, 0x0703c3ff, 0x11200382, 0x12200b82, 0x17200782, 0x1b200382, 0x1c240b82,
	0x2e00c3ff, 0x220c695b, 0x4e3d00a4, 0xd7210e93, 0x05835301, 0xe101ec22, 0x755b5582, 0xff7c230b, 0x035702ec, 0x02ec2105, 0x5307d34c, 0xb1201353,
	0xb3202782, 0xbf200382, 0x855f0382, 0x02ec2205, 0x06814dc2, 0x1382d420, 0x20055748, 0x084f7fec, 0x21065f5a, 0x1b82fd02, 0xa982fe20, 0x5308e34c,
	0x1b530623, 0x30002106, 0x4f084d4f, 0xbc210b49, 0x06814dff, 0x01140023, 0x4f0b82c1, 0x14200541, 0xd721bd82, 0x0b414f01, 0x5c053d4f, 0xbd87053b,
	0x12657a18, 0xb5850220, 0xc102d722, 0xc2248d82, 0xc502d7ff, 0xc6200382, 0xc7200382, 0x2108254f, 0xc5850214, 0x4f02d721, 0xbd850b25, 0xa14dd720,
	0x24bd8209, 0x03140012, 0x08d95317, 0x3e001424, 0xa1829d01, 0xe100a32a, 0x3d00a401, 0x2900aa01, 0x83087b41, 0x82bd20c5, 0x82be200f, 0x86bf201f,
	0x82c420c9, 0x82c7200b, 0x82ce200b, 0x82d1202b, 0x051d4f07, 0xd984ec20, 0x1b82e420, 0x2921dd8d, 0x059f4102, 0x9b41d720, 0x00a12308, 0xe1830214,
	0xc982aa20, 0x0382b520, 0x8518b620, 0xe9900d1f, 0x20090350, 0x060350ec, 0xdb022926, 0xdd022900, 0xe7200382, 0xe9204b82, 0xf5200382, 0xf7200382,
	0xf9200f82, 0xfb200382, 0xf5950382, 0xf5842920, 0xf9881820, 0x1e002922, 0x230e2762, 0xffa80171, 0x62052762, 0xd720091f, 0x6206215b, 0x7c220513,
	0x7f54c3ff, 0x17155b08, 0x21059d55, 0x438202c3, 0x82d40221, 0xfffd232f, 0x4b5403c3, 0x05e55a09, 0xab5b2020, 0xffbc2214, 0x0a996285, 0x9a257987,
	0x9aff0b02, 0x2079af02, 0x207982c5, 0x970382c7, 0x01232181, 0x830bd94d, 0x071744f7, 0x20054950, 0x069355c3, 0xbf01ec26, 0xd501d7ff, 0xf2200382,
	0x500a0f44, 0x0b440f31, 0x02d72105, 0x22050b44, 0x82cf02c3, 0x82e5202b, 0x0a29507d, 0x220aff43, 0x501203c3, 0xc3220829, 0xf55b1c03, 0x09674e06,
	0xecffa822, 0x2106a544, 0x8d8501d7, 0x4f55d720, 0x01d72206, 0x228d8cce, 0x829f02d7, 0x5dbb2069, 0xd7200845, 0xd7217986, 0x22798d02, 0x820703d7,
	0x05794471, 0x4403d721, 0xd7240575, 0x0a001900, 0xdc204d82, 0x635c0382, 0x01ec2205, 0x200b82e4, 0x5f4d82f6, 0x4e18054f, 0x855f0dcf, 0xb96c1806,
	0xffc02408, 0x82c202ec, 0x82d52003, 0x0d475f03, 0x5f03ec21, 0x21200b47, 0xd020b384, 0xd7226988, 0x0b82df01, 0xe382e120, 0xd7226d89, 0x44187d02,
	0x8b200a23, 0xa0208182, 0x8209f75f, 0x02d72271, 0x200f82ba, 0x870382bc, 0x82cb2075, 0x2079830b, 0x180782e6, 0x250ac165, 0xecfffe02, 0xeb820603,
	0x03820820, 0x2407735b, 0x00d7ff18, 0x07994724, 0x20085757, 0x8f8582dd, 0x078f4e89, 0x8305595c, 0x02d722ff, 0x85618283, 0x02ec2191, 0x87090341,
	0x02ec2191, 0xec219189, 0x18918502, 0x860c7944, 0x03ec2291, 0x7d441808, 0x2091830a, 0x060d4f07, 0xed019a2e, 0xf201ecff, 0xcf029aff, 0x12039aff,
	0x1c2a0382, 0x10009aff, 0x1400ca01, 0x6d59ce01, 0x01d72a08, 0x01c3ffe4, 0x027b00f1, 0x0a19417d, 0x240b4f61, 0x021400da, 0x200382dc, 0x83f982fe,
	0x000d225f, 0x41e1820a, 0xec250577, 0xecffdf01, 0x05534102, 0xb602ec22, 0xbc200b82, 0xcb204582, 0xe6200382, 0x2f412d82, 0xff182407, 0x462000ec,
	0x995d0889, 0x08ef6109, 0x20108d5d, 0x8341826a, 0x716a188f, 0x20a38b1b, 0x182f82e0, 0x200a7d6a, 0x82ab8302, 0x0c0321a5, 0x16208582, 0x1a240382,
	0x1d00d7ff, 0x2408a941, 0x01ecffd1, 0x200382dc, 0x5f0382dd, 0xd72205af, 0x3550f601, 0x15f5610a, 0xb820df85, 0xf5612782, 0x18d5200b, 0x610d6d51,
	0xec220eed, 0xf7882100, 0x7618cb20, 0xe1201241, 0x09457618, 0xd308c14f, 0x692220fb, 0xd0200c63, 0xd1207582, 0xd520fb82, 0x200af162, 0x201382df,
	0x200f82f2, 0x060960f6, 0x430bf162, 0xf5620d33, 0x07e74105, 0x2f82cf20, 0x21052b43, 0x701802ec, 0x27430737, 0x03ec2609, 0x03ecff10, 0x29038212,
	0x03d7ff18, 0x00ecff1c, 0x7d8d0113, 0xdf01ec22, 0xe4207582, 0x7d820382, 0x86144942, 0x087d4361, 0xec204d85, 0x17204d84, 0x8208d341, 0xd8012125,
	0x08bd7418, 0x20054956, 0x189b826a, 0x213ad36b, 0x876a3000, 0xffca270c, 0xffce01d7, 0x6983019a, 0xc3ffd522, 0xd7226d82, 0x1382db01, 0x1400dd24,
	0x0782de01, 0x0382ed20, 0x1f82f220, 0x6d18f620, 0x0225099f, 0x02d7ff6a, 0x200f826d, 0x2007827f, 0x20078281, 0x18038283, 0x200b416d, 0x200f828b,
	0x456d188d, 0x82b8200a, 0x82ba200f, 0xffcf2403, 0x82da02c3, 0x18dc2017, 0x2011596d, 0xfd6e1802, 0x07e3420b, 0x07056f18, 0xc3ff1223, 0x06ef4203,
	0xff1c0323, 0x099d44c3, 0x82490021, 0xffca22a5, 0x21c182ec, 0xbd8501c3, 0xdc01ec22, 0xec22b984, 0x6d82f201, 0x4107a144, 0xaa201733, 0xb2249582,
	0xb402ecff, 0xb6200382, 0xec22a188, 0x6d18dc02, 0x8d851a1b, 0x1803ec28, 0x1a031400, 0x9184ecff, 0x89421c20, 0x0a3d631c, 0xbd459582, 0x0b7d4205,
	0x200fa945, 0x062746cf, 0xd7ffe622, 0x420ca145, 0x1d220b71, 0x4a18cb01, 0xde200e7f, 0xe1200f82, 0xea200382, 0x83062f42, 0x427d20f3, 0x95461e2b,
	0x0b6e180b, 0x2079840e, 0x20df820a, 0x2003820c, 0x82038216, 0x150022eb, 0x059b4a01, 0xdc012922, 0xe4206d86, 0x2406e559, 0x011400e9, 0x05e959f1,
	0x00f60124, 0x79830214, 0xb149aa20, 0x24658706, 0x022900cf, 0x201382d5, 0x244d82fe, 0x03290012, 0x24078218, 0x0029001c, 0x21558216, 0x1b4a013d,
	0x01ec2109, 0x21051b4a, 0xcb860114, 0x192059b8, 0x9a21a782, 0x05bb4601, 0x2407754a, 0xfff60171, 0x060d63c3, 0x28090563, 0x02d7ff8b, 0x029affaa,
	0x180382b6, 0x4507354b, 0x35470b8b, 0xfb6c180d, 0xff182409, 0x431c009a, 0xdc2108af, 0x4e6d90ff, 0x2547082f, 0x2071c505, 0x08254811, 0x4407f144,
	0xd724056f, 0xecfff201, 0xd722df82, 0x0148a002, 0x82cb2006, 0x136b4407, 0xecff1c24, 0x45981000, 0xff46f620, 0x0e0f4506, 0x830cad44, 0x3d5d1841,
	0x82012008, 0x1c00217f, 0x24064944, 0xffd501d7, 0x0649449a, 0x64050d47, 0xb7470597, 0x826a2005, 0x1b014791, 0x9affcf23, 0x0ef94602, 0x22081764,
	0x449aff12, 0x9a2d0a09, 0xeb010200, 0xf4013d00, 0x21003d00, 0x05bb4701, 0xdd019a26, 0xde01c3ff, 0x200a0347, 0x498b82e4, 0xc32205a5, 0x7b827d02,
	0xc3ff8124, 0x03828302, 0x03828b20, 0x41058543, 0xf76a07f5, 0x02d72107, 0x4907f941, 0xd7220537, 0x3782e602, 0x0a6d8418, 0x48fe0221, 0x0e240a07,
	0x1003c3ff, 0x18240382, 0x1f009aff, 0xf743858c, 0x01d72105, 0x02218182, 0xdf6d826d, 0x0101217d, 0x0021e782, 0x0a9b471c, 0x3166ec20, 0x0b89410a,
	0x25071948, 0x000b0229, 0x91410229, 0x178d411f, 0x23088348, 0xd7ffca01, 0x220c7f45, 0x82d7fff2, 0x02ec2155, 0x4513a746, 0xd7211573, 0x05154602,
	0x1802ec21, 0x45138f72, 0xda201373, 0x22c4c16e, 0x6e85ffbc, 0x7f6108c5, 0x294a189e, 0x73c16e10, 0x3f71a920, 0x1bc56e06, 0x220d5b71, 0x82b902c3,
	0x6eba2033, 0xbd2006d1, 0x53560b82, 0xb1d56e0d, 0x2005fd6a, 0x060d69c3, 0x2061d96e, 0xbb981803, 0xc300210b, 0x44b39d18, 0x19198f18, 0x45af9d18,
	0x0b558f18, 0x53a79d18, 0x27a39d18, 0x6f9f9d18, 0x279b9d18, 0x07359018, 0xc3ff6024, 0x03826a02, 0x0b939d18, 0x0f828520, 0x03828720, 0x03828920,
	0x23879d18, 0x5200b924, 0x9d18bb02, 0xf920327f, 0xfb223382, 0x9d183d00, 0x9d181073, 0x7132a36b, 0x73035200, 0x10005200, 0x3d004500, 0x66004900,
	0x07824b00, 0x09c76218, 0x4f003d22, 0x57200f82, 0x59201782, 0x5a200382, 0x5b240382, 0x5c002900, 0x5d280782, 0x70032900, 0x72036600, 0x74200382,
	0x41a70f82, 0x89005221, 0x8c142041, 0x03022e41, 0x0385ff09, 0x0085ff0b, 0x00960002, 0x32018205, 0x000a0000, 0x0001000b, 0x0011000f, 0x00240003,
	0x82060027, 0x8229207d, 0x002c2215, 0x3819822c, 0x002f002e, 0x0032000c, 0x000e0035, 0x003e0037, 0x00440012, 0x001a0046, 0x22c58248, 0x824e001d,
	0x00212201, 0x2edd8250, 0x00550022, 0x00250057, 0x005e0059, 0x826d0028, 0x002e2201, 0x3c01827d, 0x0082002f, 0x00300087, 0x00920089, 0x00940036,
	0x00400098, 0x009f009a, 0x00a20045, 0x224382ad, 0x82b800b3, 0x00ba2c37, 0x005d00bf, 0x00c900c1, 0x82cb0063, 0x006c2401, 0x82cf00cd, 0x00d12643,
	0x007000d1, 0x220182d5, 0x82d70071, 0x00722801, 0x00db00d9, 0x82dd0073, 0x00762201, 0x220182ec, 0x82f00077, 0x00782201, 0x220182f2, 0x82f80079,
	0x007a2801, 0x00fb00fa, 0x82fd007b, 0x7d040901, 0x0101ff00, 0x03017e00, 0x81000301, 0x06010601, 0x08018200, 0x83000801, 0x0a010a01, 0x0e018400,
	0x85000f01, 0x13011101, 0x15018700, 0x8a001501, 0x1d011d01, 0x1f018b00, 0x8c001f01, 0x24012101, 0x26018d00, 0x91002701, 0x2c012c01, 0x30019300,
	0x94003001, 0x32013201, 0x34019500, 0x96003401, 0x3b013601, 0x3d019700, 0x9d003d01, 0x40013f01, 0x43019e00, 0xa0004401, 0x4a014a01, 0x5601a200,
	0xa3005601, 0x62015a01, 0x6401a400, 0xad006401, 0x69016601, 0x6c01ae00, 0xb2006d01, 0x7c016f01, 0x7e01b400, 0xc2008401, 0x88018601, 0x8a01c900,
	0xcc008e01, 0x91019001, 0x9301d100, 0xd3009701, 0x99019901, 0x9b01d800, 0xd900a201, 0xa801a401, 0xaa01e100, 0xe600ae01, 0xb101b001, 0xb401eb00,
	0xed00b401, 0xb801b801, 0xba01ee00, 0xef00c001, 0xc401c301, 0xc601f600, 0xf800c801, 0xd101ca01, 0xd401fb00, 0x03220182, 0x0182d801, 0xda010434,
	0x0501e001, 0xea01e301, 0xec010c01, 0x1401ee01, 0x0182f001, 0x01177a09, 0x01f601f2, 0x02f80118, 0x021d0103, 0x01060206, 0x020a0229, 0x022a010a,
	0x01280228, 0x0258022b, 0x022c0158, 0x01600260, 0x0262022d, 0x022e0162, 0x016a026a, 0x026c022f, 0x02300172, 0x01740274, 0x02760237, 0x0238017c,
	0x018c027e, 0x0295023f, 0x024e019d, 0x01a0029f, 0x02a20257, 0x025901af, 0x01c002b1, 0x02c30267, 0x027701c3, 0x01c502c5, 0x02c70278, 0x027901c7,
	0x01cc02c9, 0x02ce027a, 0x027e01cf, 0x01d302d2, 0x02d60280, 0x028201d9, 0x01db02db, 0x02de0286, 0x028701de, 0x01e902e0, 0x02ef0288, 0x029201fc,
	0x010003ff, 0x030303a0, 0x03a20108, 0x011d030b, 0x031f03a8, 0x03bb011f, 0x01210321, 0x032303bc, 0x03bd0123, 0x01250325, 0x032703be, 0x03bf0127,
	0x01290329, 0x032b03c0, 0x03c1012b, 0x012d032d, 0x032f03c2, 0x03c3012f, 0x01310331, 0x033303c4, 0x03c50133, 0x01360336, 0x033803c6, 0x03c70138,
	0x013a033a, 0x033c03c8, 0x03c9013c, 0x013e033e, 0x034003ca, 0x03cb0140, 0x01420342, 0x034403cc, 0x03cd0145, 0x01470347, 0x034903cf, 0x03d00156,
	0x01580358, 0x035a03de, 0x03df015a, 0x015c035c, 0x035e03e0, 0x03e1015e, 0x01610360, 0x036303e2, 0x03e40163, 0x01660366, 0x036803e5, 0x03e60168,
	0x016a036a, 0x036c03e7, 0x03e8016c, 0x0174036e, 0xfba818e9, 0x001c2208, 0xfba8181e, 0x00002410, 0x05000000, 0x5d0350fa, 0x00000011,
};
```

`CSGOSimple/fonts/fonts.hpp`:

```hpp
#pragma once
namespace Fonts {
	#include "droid.hpp"
	#include "cousine.hpp"
}
```

`CSGOSimple/helpers/input.cpp`:

```cpp
#include "input.hpp"

#include "../valve_sdk/sdk.hpp"
#include "../imgui/imgui.h"
#include "../imgui/impl/imgui_impl_win32.h"
#include "../menu.hpp"

InputSys::InputSys()
	: m_hTargetWindow(nullptr), m_ulOldWndProc(0)
{
}

InputSys::~InputSys()
{
	if (m_ulOldWndProc)
		SetWindowLongPtr(m_hTargetWindow, GWLP_WNDPROC, m_ulOldWndProc);
	m_ulOldWndProc = 0;
}
void InputSys::Initialize()
{
	D3DDEVICE_CREATION_PARAMETERS params;

	if (FAILED(g_D3DDevice9->GetCreationParameters(&params)))
		throw std::runtime_error("[InputSys] GetCreationParameters failed.");

	m_hTargetWindow = params.hFocusWindow;
	m_ulOldWndProc = SetWindowLongPtr(m_hTargetWindow, GWLP_WNDPROC, (LONG_PTR)WndProc);

	if (!m_ulOldWndProc)
		throw std::runtime_error("[InputSys] SetWindowLongPtr failed.");
}

LRESULT __stdcall InputSys::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	Get().ProcessMessage(msg, wParam, lParam);

	if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam) && Menu::Get().IsVisible())
		return true;

	return CallWindowProc((WNDPROC)Get().m_ulOldWndProc, hWnd, msg, wParam, lParam);
}

bool InputSys::ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg) {
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
	case WM_LBUTTONDBLCLK:
	case WM_XBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_LBUTTONDOWN:
	case WM_XBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_RBUTTONUP:
	case WM_LBUTTONUP:
	case WM_XBUTTONUP:
		return ProcessMouseMessage(uMsg, wParam, lParam);
	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_SYSKEYDOWN:
	case WM_SYSKEYUP:
		return ProcessKeybdMessage(uMsg, wParam, lParam);
	default:
		return false;
	}
}

bool InputSys::ProcessMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	auto key = VK_LBUTTON;
	auto state = KeyState::None;
	switch (uMsg) {
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_MBUTTONDBLCLK:
		state = uMsg == WM_MBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_MBUTTON;
		break;
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_RBUTTONDBLCLK:
		state = uMsg == WM_RBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_RBUTTON;
		break;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_LBUTTONDBLCLK:
		state = uMsg == WM_LBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_LBUTTON;
		break;
	case WM_XBUTTONDOWN:
	case WM_XBUTTONUP:
	case WM_XBUTTONDBLCLK:
		state = uMsg == WM_XBUTTONUP ? KeyState::Up : KeyState::Down;
		key = (HIWORD(wParam) == XBUTTON1 ? VK_XBUTTON1 : VK_XBUTTON2);
		break;
	default:
		return false;
	}

	if (state == KeyState::Up && m_iKeyMap[key] == KeyState::Down)
		m_iKeyMap[key] = KeyState::Pressed;
	else
		m_iKeyMap[key] = state;
	return true;
}

bool InputSys::ProcessKeybdMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	auto key = wParam;
	auto state = KeyState::None;

	switch (uMsg) {
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		state = KeyState::Down;
		break;
	case WM_KEYUP:
	case WM_SYSKEYUP:
		state = KeyState::Up;
		break;
	default:
		return false;
	}

	if (state == KeyState::Up && m_iKeyMap[int(key)] == KeyState::Down) {
		m_iKeyMap[int(key)] = KeyState::Pressed;

		auto& hotkey_callback = m_Hotkeys[key];

		if (hotkey_callback)
			hotkey_callback();

	}
	else {
		m_iKeyMap[int(key)] = state;
	}

	return true;
}
KeyState InputSys::GetKeyState(std::uint32_t vk)
{
	return m_iKeyMap[vk];
}
bool InputSys::IsKeyDown(std::uint32_t vk)
{
	return m_iKeyMap[vk] == KeyState::Down;
}
bool InputSys::WasKeyPressed(std::uint32_t vk)
{
	if (m_iKeyMap[vk] == KeyState::Pressed) {
		m_iKeyMap[vk] = KeyState::Up;
		return true;
	}
	return false;
}

void InputSys::RegisterHotkey(std::uint32_t vk, std::function<void(void)> f)
{
	m_Hotkeys[vk] = f;
}
void InputSys::RemoveHotkey(std::uint32_t vk)
{
	m_Hotkeys[vk] = nullptr;
}

```

`CSGOSimple/helpers/input.hpp`:

```hpp
#pragma once

#define NOMINMAX
#include <Windows.h>
#include <cstdint>
#include <functional>
#include <map>
#include <memory>
#include <stdexcept>
#include <d3d9.h>

#include "../singleton.hpp"

enum class KeyState
{
    None = 1,
    Down,
    Up,
    Pressed /*Down and then up*/
};

DEFINE_ENUM_FLAG_OPERATORS(KeyState);

class InputSys 
    : public Singleton<InputSys>
{
    friend class Singleton<InputSys>;

    InputSys();
    ~InputSys();

public:
    void Initialize();

    HWND GetMainWindow() const { return m_hTargetWindow; }

    KeyState      GetKeyState(uint32_t vk);
    bool          IsKeyDown(uint32_t vk);
    bool          WasKeyPressed(uint32_t vk);

    void RegisterHotkey(uint32_t vk, std::function<void(void)> f);
    void RemoveHotkey(uint32_t vk);

private:
    static LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

    bool ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    bool ProcessMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    bool ProcessKeybdMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);


    HWND            m_hTargetWindow;
    LONG_PTR        m_ulOldWndProc;
    KeyState       m_iKeyMap[256];

    std::function<void(void)> m_Hotkeys[256];
};
```

`CSGOSimple/helpers/math.cpp`:

```cpp
#include "Math.hpp"

namespace Math
{
	//--------------------------------------------------------------------------------
	float VectorDistance(const Vector& v1, const Vector& v2)
	{
		return FASTSQRT(pow(v1.x - v2.x, 2) + pow(v1.y - v2.y, 2) + pow(v1.z - v2.z, 2));
	}
	//--------------------------------------------------------------------------------
	QAngle CalcAngle(const Vector& src, const Vector& dst)
	{
		QAngle vAngle;
		Vector delta((src.x - dst.x), (src.y - dst.y), (src.z - dst.z));
		double hyp = sqrt(delta.x*delta.x + delta.y*delta.y);

		vAngle.pitch = float(atanf(float(delta.z / hyp)) * 57.295779513082f);
		vAngle.yaw = float(atanf(float(delta.y / delta.x)) * 57.295779513082f);
		vAngle.roll = 0.0f;

		if (delta.x >= 0.0)
			vAngle.yaw += 180.0f;

		return vAngle;
	}
	//--------------------------------------------------------------------------------
	float GetFOV(const QAngle& viewAngle, const QAngle& aimAngle)
	{
		Vector ang, aim;

		AngleVectors(viewAngle, aim);
		AngleVectors(aimAngle, ang);

		auto res = RAD2DEG(acos(aim.Dot(ang) / aim.LengthSqr()));
		if (std::isnan(res))
			res = 0.f;
		return res;
	}
    //--------------------------------------------------------------------------------
    void ClampAngles(QAngle& angles)
    {
        if(angles.pitch > 89.0f) angles.pitch = 89.0f;
        else if(angles.pitch < -89.0f) angles.pitch = -89.0f;

        if(angles.yaw > 180.0f) angles.yaw = 180.0f;
        else if(angles.yaw < -180.0f) angles.yaw = -180.0f;

        angles.roll = 0;
    }
    //--------------------------------------------------------------------------------
    void VectorTransform(const Vector& in1, const matrix3x4_t& in2, Vector& out)
    {
        out[0] = in1.Dot(in2[0]) + in2[0][3];
        out[1] = in1.Dot(in2[1]) + in2[1][3];
        out[2] = in1.Dot(in2[2]) + in2[2][3];
    }
    //--------------------------------------------------------------------------------
    void AngleVectors(const QAngle &angles, Vector& forward)
    {
        float	sp, sy, cp, cy;

        DirectX::XMScalarSinCos(&sp, &cp, DEG2RAD(angles[0]));
        DirectX::XMScalarSinCos(&sy, &cy, DEG2RAD(angles[1]));

        forward.x = cp*cy;
        forward.y = cp*sy;
        forward.z = -sp;
    }
    //--------------------------------------------------------------------------------
    void AngleVectors(const QAngle &angles, Vector& forward, Vector& right, Vector& up)
    {
        float sr, sp, sy, cr, cp, cy;

        DirectX::XMScalarSinCos(&sp, &cp, DEG2RAD(angles[0]));
        DirectX::XMScalarSinCos(&sy, &cy, DEG2RAD(angles[1]));
        DirectX::XMScalarSinCos(&sr, &cr, DEG2RAD(angles[2]));

        forward.x = (cp * cy);
        forward.y = (cp * sy);
        forward.z = (-sp);
        right.x = (-1 * sr * sp * cy + -1 * cr * -sy);
        right.y = (-1 * sr * sp * sy + -1 * cr *  cy);
        right.z = (-1 * sr * cp);
        up.x = (cr * sp * cy + -sr*-sy);
        up.y = (cr * sp * sy + -sr*cy);
        up.z = (cr * cp);
    }
    //--------------------------------------------------------------------------------
    void VectorAngles(const Vector& forward, QAngle& angles)
    {
        float	tmp, yaw, pitch;

        if(forward[1] == 0 && forward[0] == 0) {
            yaw = 0;
            if(forward[2] > 0)
                pitch = 270;
            else
                pitch = 90;
        } else {
            yaw = (atan2(forward[1], forward[0]) * 180 / DirectX::XM_PI);
            if(yaw < 0)
                yaw += 360;

            tmp = sqrt(forward[0] * forward[0] + forward[1] * forward[1]);
            pitch = (atan2(-forward[2], tmp) * 180 / DirectX::XM_PI);
            if(pitch < 0)
                pitch += 360;
        }

        angles[0] = pitch;
        angles[1] = yaw;
        angles[2] = 0;
    }
    //--------------------------------------------------------------------------------
    static bool screen_transform(const Vector& in, Vector& out)
    {
        static auto& w2sMatrix = g_EngineClient->WorldToScreenMatrix();

        out.x = w2sMatrix.m[0][0] * in.x + w2sMatrix.m[0][1] * in.y + w2sMatrix.m[0][2] * in.z + w2sMatrix.m[0][3];
        out.y = w2sMatrix.m[1][0] * in.x + w2sMatrix.m[1][1] * in.y + w2sMatrix.m[1][2] * in.z + w2sMatrix.m[1][3];
        out.z = 0.0f;

        float w = w2sMatrix.m[3][0] * in.x + w2sMatrix.m[3][1] * in.y + w2sMatrix.m[3][2] * in.z + w2sMatrix.m[3][3];

        if(w < 0.001f) {
            out.x *= 100000;
            out.y *= 100000;
            return false;
        }

        out.x /= w;
        out.y /= w;

        return true;
    }
    //--------------------------------------------------------------------------------
    bool WorldToScreen(const Vector& in, Vector& out)
    {
        if(screen_transform(in, out)) {
            int w, h;
            g_EngineClient->GetScreenSize(w, h);

            out.x = (w / 2.0f) + (out.x * w) / 2.0f;
            out.y = (h / 2.0f) - (out.y * h) / 2.0f;

            return true;
        }
        return false;
    }
    //--------------------------------------------------------------------------------
}

```

`CSGOSimple/helpers/math.hpp`:

```hpp
#pragma once

#include "../valve_sdk/sdk.hpp"

#include <DirectXMath.h>

#define RAD2DEG(x) DirectX::XMConvertToDegrees(x)
#define DEG2RAD(x) DirectX::XMConvertToRadians(x)
#define M_PI 3.14159265358979323846
#define PI_F	((float)(M_PI)) 

namespace Math
{
	inline float FASTSQRT(float x)
	{
		unsigned int i = *(unsigned int*)&x;

		i += 127 << 23;
		// approximation of square root
		i >>= 1;
		return *(float*)&i;
	}
	float VectorDistance(const Vector& v1, const Vector& v2);
	QAngle CalcAngle(const Vector& src, const Vector& dst);
	float GetFOV(const QAngle& viewAngle, const QAngle& aimAngle);
	template<class T>
	void Normalize3(T& vec)
	{
		for (auto i = 0; i < 2; i++) {
			while (vec[i] < -180.0f) vec[i] += 360.0f;
			while (vec[i] >  180.0f) vec[i] -= 360.0f;
		}
		vec[2] = 0.f;
	}
    void ClampAngles(QAngle& angles);
    void VectorTransform(const Vector& in1, const matrix3x4_t& in2, Vector& out);
    void AngleVectors(const QAngle &angles, Vector& forward);
    void AngleVectors(const QAngle &angles, Vector& forward, Vector& right, Vector& up);
    void VectorAngles(const Vector& forward, QAngle& angles);
    bool WorldToScreen(const Vector& in, Vector& out);
}
```

`CSGOSimple/helpers/utils.hpp`:

```hpp
#pragma once

#define NOMINMAX
#include <Windows.h>
#include <string>
#include <initializer_list>
#include "../valve_sdk/sdk.hpp"

namespace Utils {
	std::vector<char> HexToBytes(const std::string& hex);
	std::string BytesToString(unsigned char* data, int len);
	std::vector<std::string> Split(const std::string& str, const char* delim);
	unsigned int FindInDataMap(datamap_t * pMap, const char * name);
    /*
     * @brief Create console
     *
     * Create and attach a console window to the current process
     */
	void AttachConsole();

    /*
     * @brief Detach console
     *
     * Detach and destroy the attached console
     */
    void DetachConsole();

    /*
     * @brief Print to console
     *
     * Replacement to printf that works with the newly created console
     */
    bool ConsolePrint(const char* fmt, ...);
    
    /*
     * @brief Blocks execution until a key is pressed on the console window
     *
     */
    char ConsoleReadKey();

    /*
     * @brief Wait for all the given modules to be loaded
     *
     * @param timeout How long to wait
     * @param modules List of modules to wait for
     *
     * @returns See WaitForSingleObject return values.
     */
    int WaitForModules(std::int32_t timeout, const std::initializer_list<std::wstring>& modules);

    /*
     * @brief Scan for a given byte pattern on a module
     *
     * @param module    Base of the module to search
     * @param signature IDA-style byte array pattern
     *
     * @returns Address of the first occurence
     */
    std::uint8_t* PatternScan(void* module, const char* signature);

    /*
     * @brief Set player clantag
     *
     * @param tag New clantag
     */
    void SetClantag(const char* tag);

    /*
     * @brief Set player name
     *
     * @param name New name
     */
    void SetName(const char* name);
}

```

`CSGOSimple/helpers/vfunc_hook.cpp`:

```cpp
#include "vfunc_hook.hpp"

vfunc_hook::vfunc_hook()
    : class_base(nullptr), vftbl_len(0), new_vftbl(nullptr), old_vftbl(nullptr)
{
}
vfunc_hook::vfunc_hook(void* base)
    : class_base(base), vftbl_len(0), new_vftbl(nullptr), old_vftbl(nullptr)
{
}
vfunc_hook::~vfunc_hook()
{
    unhook_all();

    delete[] new_vftbl;
}

bool vfunc_hook::setup(void* base /*= nullptr*/)
{
    if(base != nullptr)
        class_base = base;

    if(class_base == nullptr)
        return false;

    old_vftbl = *(std::uintptr_t**)class_base;
    vftbl_len = estimate_vftbl_length(old_vftbl) * sizeof(std::uintptr_t);

    if(vftbl_len == 0)
        return false;

    new_vftbl = new std::uintptr_t[vftbl_len + 1]();

	std::memcpy(&new_vftbl[1], old_vftbl, vftbl_len * sizeof(std::uintptr_t));

    try {
        auto guard = detail::protect_guard{ class_base, sizeof(std::uintptr_t), PAGE_READWRITE };
		new_vftbl[0] = old_vftbl[-1];
		*(std::uintptr_t**)class_base = &new_vftbl[1];
    } catch(...) {
        delete[] new_vftbl;
        return false;
    }

    return true;
}
std::size_t vfunc_hook::estimate_vftbl_length(std::uintptr_t* vftbl_start)
{
	MEMORY_BASIC_INFORMATION memInfo = { NULL };
	int m_nSize = -1;
	do {
		m_nSize++;
		VirtualQuery(reinterpret_cast<LPCVOID>(vftbl_start[m_nSize]), &memInfo, sizeof(memInfo));
	} while (memInfo.Protect == PAGE_EXECUTE_READ || memInfo.Protect == PAGE_EXECUTE_READWRITE);

	return m_nSize;
}
```

`CSGOSimple/helpers/vfunc_hook.hpp`:

```hpp
#pragma once
#define NOMINMAX
#include <Windows.h>

#include <cstdint>
#include <stdexcept>

namespace detail
{
	class protect_guard
	{
	public:
		protect_guard(void* base, size_t len, std::uint32_t flags)
		{
			_base = base;
			_length = len;
			if (!VirtualProtect(base, len, flags, (PDWORD)&_old))
				throw std::runtime_error("Failed to protect region.");
		}
		~protect_guard()
		{
			VirtualProtect(_base, _length, _old, (PDWORD)&_old);
		}

	private:
		void*         _base;
		size_t        _length;
		std::uint32_t _old;
	};
}

class vfunc_hook
{
public:
	vfunc_hook();
	vfunc_hook(void* base);
	~vfunc_hook();

	bool setup(void* class_base = nullptr);

	template<typename T>
	void hook_index(int index, T fun)
	{
		assert(index >= 0 && index <= (int)vftbl_len);
		new_vftbl[index + 1] = reinterpret_cast<std::uintptr_t>(fun);
	}
	void unhook_index(int index)
	{
		new_vftbl[index] = old_vftbl[index];
	}
	void unhook_all()
	{
		try {
			if (old_vftbl != nullptr) {
				auto guard = detail::protect_guard{ class_base, sizeof(std::uintptr_t), PAGE_READWRITE };
				*(std::uintptr_t**)class_base = old_vftbl;
				old_vftbl = nullptr;
			}
		}
		catch (...) {
		}
	}

	template<typename T>
	T get_original(int index)
	{
		return (T)old_vftbl[index];
	}

private:
	static inline std::size_t estimate_vftbl_length(std::uintptr_t* vftbl_start);

	void*           class_base;
	std::size_t     vftbl_len;
	std::uintptr_t* new_vftbl;
	std::uintptr_t* old_vftbl;
};
```

`CSGOSimple/hooks.cpp`:

```cpp
#include "hooks.hpp"
#include <intrin.h>  

#include "render.hpp"
#include "menu.hpp"
#include "options.hpp"
#include "helpers/input.hpp"
#include "helpers/utils.hpp"
#include "features/bhop.hpp"
#include "features/chams.hpp"
#include "features/visuals.hpp"
#include "features/glow.hpp"
#pragma intrinsic(_ReturnAddress)  

namespace Hooks {

	void Initialize()
	{
		hlclient_hook.setup(g_CHLClient);
		direct3d_hook.setup(g_D3DDevice9);
		vguipanel_hook.setup(g_VGuiPanel);
		vguisurf_hook.setup(g_VGuiSurface);
		sound_hook.setup(g_EngineSound);
		mdlrender_hook.setup(g_MdlRender);
		clientmode_hook.setup(g_ClientMode);
		ConVar* sv_cheats_con = g_CVar->FindVar("sv_cheats");
		sv_cheats.setup(sv_cheats_con);

		direct3d_hook.hook_index(index::EndScene, hkEndScene);
		direct3d_hook.hook_index(index::Reset, hkReset);
		hlclient_hook.hook_index(index::FrameStageNotify, hkFrameStageNotify);
		hlclient_hook.hook_index(index::CreateMove, hkCreateMove_Proxy);
		vguipanel_hook.hook_index(index::PaintTraverse, hkPaintTraverse);
		sound_hook.hook_index(index::EmitSound1, hkEmitSound1);
		vguisurf_hook.hook_index(index::LockCursor, hkLockCursor);
		mdlrender_hook.hook_index(index::DrawModelExecute, hkDrawModelExecute);
		clientmode_hook.hook_index(index::DoPostScreenSpaceEffects, hkDoPostScreenEffects);
		clientmode_hook.hook_index(index::OverrideView, hkOverrideView);
		sv_cheats.hook_index(index::SvCheatsGetBool, hkSvCheatsGetBool);
	}
	//--------------------------------------------------------------------------------
	void Shutdown()
	{
		hlclient_hook.unhook_all();
		direct3d_hook.unhook_all();
		vguipanel_hook.unhook_all();
		vguisurf_hook.unhook_all();
		mdlrender_hook.unhook_all();
		clientmode_hook.unhook_all();
		sound_hook.unhook_all();
		sv_cheats.unhook_all();

		Glow::Get().Shutdown();
	}
	//--------------------------------------------------------------------------------
	long __stdcall hkEndScene(IDirect3DDevice9* pDevice)
	{
		static auto oEndScene = direct3d_hook.get_original<decltype(&hkEndScene)>(index::EndScene);

		static auto viewmodel_fov = g_CVar->FindVar("viewmodel_fov");
		static auto mat_ambient_light_r = g_CVar->FindVar("mat_ambient_light_r");
		static auto mat_ambient_light_g = g_CVar->FindVar("mat_ambient_light_g");
		static auto mat_ambient_light_b = g_CVar->FindVar("mat_ambient_light_b");
		static auto crosshair_cvar = g_CVar->FindVar("crosshair");

		viewmodel_fov->m_fnChangeCallbacks.m_Size = 0;
		viewmodel_fov->SetValue(g_Options.viewmodel_fov);
		mat_ambient_light_r->SetValue(g_Options.mat_ambient_light_r);
		mat_ambient_light_g->SetValue(g_Options.mat_ambient_light_g);
		mat_ambient_light_b->SetValue(g_Options.mat_ambient_light_b);
		
		crosshair_cvar->SetValue(!(g_Options.esp_enabled && g_Options.esp_crosshair));

		DWORD colorwrite, srgbwrite;
		IDirect3DVertexDeclaration9* vert_dec = nullptr;
		IDirect3DVertexShader9* vert_shader = nullptr;
		DWORD dwOld_D3DRS_COLORWRITEENABLE = NULL;
		pDevice->GetRenderState(D3DRS_COLORWRITEENABLE, &colorwrite);
		pDevice->GetRenderState(D3DRS_SRGBWRITEENABLE, &srgbwrite);

		pDevice->SetRenderState(D3DRS_COLORWRITEENABLE, 0xffffffff);
		//removes the source engine color correction
		pDevice->SetRenderState(D3DRS_SRGBWRITEENABLE, false);

		pDevice->GetRenderState(D3DRS_COLORWRITEENABLE, &dwOld_D3DRS_COLORWRITEENABLE);
		pDevice->GetVertexDeclaration(&vert_dec);
		pDevice->GetVertexShader(&vert_shader);
		pDevice->SetRenderState(D3DRS_COLORWRITEENABLE, 0xffffffff);
		pDevice->SetRenderState(D3DRS_SRGBWRITEENABLE, false);
		pDevice->SetSamplerState(NULL, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
		pDevice->SetSamplerState(NULL, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
		pDevice->SetSamplerState(NULL, D3DSAMP_ADDRESSW, D3DTADDRESS_WRAP);
		pDevice->SetSamplerState(NULL, D3DSAMP_SRGBTEXTURE, NULL);

		
		ImGui_ImplDX9_NewFrame();
		ImGui_ImplWin32_NewFrame();
		ImGui::NewFrame();


		auto esp_drawlist = Render::Get().RenderScene();

		Menu::Get().Render();
	

		ImGui::Render(esp_drawlist);

		ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());

		pDevice->SetRenderState(D3DRS_COLORWRITEENABLE, colorwrite);
		pDevice->SetRenderState(D3DRS_SRGBWRITEENABLE, srgbwrite);
		pDevice->SetRenderState(D3DRS_COLORWRITEENABLE, dwOld_D3DRS_COLORWRITEENABLE);
		pDevice->SetRenderState(D3DRS_SRGBWRITEENABLE, true);
		pDevice->SetVertexDeclaration(vert_dec);
		pDevice->SetVertexShader(vert_shader);

		return oEndScene(pDevice);
	}
	//--------------------------------------------------------------------------------
	long __stdcall hkReset(IDirect3DDevice9* device, D3DPRESENT_PARAMETERS* pPresentationParameters)
	{
		static auto oReset = direct3d_hook.get_original<decltype(&hkReset)>(index::Reset);

		Menu::Get().OnDeviceLost();

		auto hr = oReset(device, pPresentationParameters);

		if (hr >= 0)
			Menu::Get().OnDeviceReset();

		return hr;
	}
	//--------------------------------------------------------------------------------
	void __stdcall hkCreateMove(int sequence_number, float input_sample_frametime, bool active, bool& bSendPacket)
	{
		static auto oCreateMove = hlclient_hook.get_original<decltype(&hkCreateMove_Proxy)>(index::CreateMove);

		oCreateMove(g_CHLClient, 0, sequence_number, input_sample_frametime, active);

		auto cmd = g_Input->GetUserCmd(sequence_number);
		auto verified = g_Input->GetVerifiedCmd(sequence_number);

		if (!cmd || !cmd->command_number)
			return;
		
		if (Menu::Get().IsVisible())
			cmd->buttons &= ~IN_ATTACK;

		if (g_Options.misc_bhop)
			BunnyHop::OnCreateMove(cmd);

		// https://github.com/spirthack/CSGOSimple/issues/69
		if (g_Options.misc_showranks && cmd->buttons & IN_SCORE) // rank revealer will work even after unhooking, idk how to "hide" ranks  again
			g_CHLClient->DispatchUserMessage(CS_UM_ServerRankRevealAll, 0, 0, nullptr);


		verified->m_cmd = *cmd;
		verified->m_crc = cmd->GetChecksum();
	}
	//--------------------------------------------------------------------------------
	__declspec(naked) void __fastcall hkCreateMove_Proxy(void* _this, int, int sequence_number, float input_sample_frametime, bool active)
	{
		__asm
		{
			push ebp
			mov  ebp, esp
			push ebx; not sure if we need this
			push esp
			push dword ptr[active]
			push dword ptr[input_sample_frametime]
			push dword ptr[sequence_number]
			call Hooks::hkCreateMove
			pop  ebx
			pop  ebp
			retn 0Ch
		}
	}
	//--------------------------------------------------------------------------------
	void __fastcall hkPaintTraverse(void* _this, int edx, vgui::VPANEL panel, bool forceRepaint, bool allowForce)
	{
		static auto panelId = vgui::VPANEL{ 0 };
		static auto oPaintTraverse = vguipanel_hook.get_original<decltype(&hkPaintTraverse)>(index::PaintTraverse);

		oPaintTraverse(g_VGuiPanel, edx, panel, forceRepaint, allowForce);

		if (!panelId) {
			const auto panelName = g_VGuiPanel->GetName(panel);
			if (!strcmp(panelName, "FocusOverlayPanel")) {
				panelId = panel;
			}
		}
		else if (panelId == panel) 
		{
			//Ignore 50% cuz it called very often
			static bool bSkip = false;
			bSkip = !bSkip;

			if (bSkip)
				return;

			Render::Get().BeginScene();
		}
	}
	//--------------------------------------------------------------------------------
	void __fastcall hkEmitSound1(void* _this, int edx, IRecipientFilter& filter, int iEntIndex, int iChannel, const char* pSoundEntry, unsigned int nSoundEntryHash, const char *pSample, float flVolume, int nSeed, float flAttenuation, int iFlags, int iPitch, const Vector* pOrigin, const Vector* pDirection, void* pUtlVecOrigins, bool bUpdatePositions, float soundtime, int speakerentity, int unk) {
		static auto ofunc = sound_hook.get_original<decltype(&hkEmitSound1)>(index::EmitSound1);


		if (!strcmp(pSoundEntry, "UIPanorama.popup_accept_match_beep")) {
			static auto fnAccept = reinterpret_cast<bool(__stdcall*)(const char*)>(Utils::PatternScan(GetModuleHandleA("client.dll"), "55 8B EC 83 E4 F8 8B 4D 08 BA ? ? ? ? E8 ? ? ? ? 85 C0 75 12"));

			if (fnAccept) {

				fnAccept("");

				//This will flash the CSGO window on the taskbar
				//so we know a game was found (you cant hear the beep sometimes cause it auto-accepts too fast)
				FLASHWINFO fi;
				fi.cbSize = sizeof(FLASHWINFO);
				fi.hwnd = InputSys::Get().GetMainWindow();
				fi.dwFlags = FLASHW_ALL | FLASHW_TIMERNOFG;
				fi.uCount = 0;
				fi.dwTimeout = 0;
				FlashWindowEx(&fi);
			}
		}

		ofunc(g_EngineSound, edx, filter, iEntIndex, iChannel, pSoundEntry, nSoundEntryHash, pSample, flVolume, nSeed, flAttenuation, iFlags, iPitch, pOrigin, pDirection, pUtlVecOrigins, bUpdatePositions, soundtime, speakerentity, unk);

	}
	//--------------------------------------------------------------------------------
	int __fastcall hkDoPostScreenEffects(void* _this, int edx, int a1)
	{
		static auto oDoPostScreenEffects = clientmode_hook.get_original<decltype(&hkDoPostScreenEffects)>(index::DoPostScreenSpaceEffects);

		if (g_LocalPlayer && g_Options.glow_enabled)
			Glow::Get().Run();

		return oDoPostScreenEffects(g_ClientMode, edx, a1);
	}
	//--------------------------------------------------------------------------------
	void __fastcall hkFrameStageNotify(void* _this, int edx, ClientFrameStage_t stage)
	{
		static auto ofunc = hlclient_hook.get_original<decltype(&hkFrameStageNotify)>(index::FrameStageNotify);
		// may be u will use it lol
		ofunc(g_CHLClient, edx, stage);
	}
	//--------------------------------------------------------------------------------
	void __fastcall hkOverrideView(void* _this, int edx, CViewSetup* vsView)
	{
		static auto ofunc = clientmode_hook.get_original<decltype(&hkOverrideView)>(index::OverrideView);

		if (g_EngineClient->IsInGame() && vsView)
			Visuals::Get().ThirdPerson();

		ofunc(g_ClientMode, edx, vsView);
	}
	//--------------------------------------------------------------------------------
	void __fastcall hkLockCursor(void* _this)
	{
		static auto ofunc = vguisurf_hook.get_original<decltype(&hkLockCursor)>(index::LockCursor);

		if (Menu::Get().IsVisible()) {
			g_VGuiSurface->UnlockCursor();
			g_InputSystem->ResetInputState();
			return;
		}
		ofunc(g_VGuiSurface);

	}
	//--------------------------------------------------------------------------------
	void __fastcall hkDrawModelExecute(void* _this, int edx, IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& pInfo, matrix3x4_t* pCustomBoneToWorld)
	{
		static auto ofunc = mdlrender_hook.get_original<decltype(&hkDrawModelExecute)>(index::DrawModelExecute);

		if (g_MdlRender->IsForcedMaterialOverride() &&
			!strstr(pInfo.pModel->szName, "arms") &&
			!strstr(pInfo.pModel->szName, "weapons/v_")) {
			return ofunc(_this, edx, ctx, state, pInfo, pCustomBoneToWorld);
		}

		Chams::Get().OnDrawModelExecute(ctx, state, pInfo, pCustomBoneToWorld);

		ofunc(_this, edx, ctx, state, pInfo, pCustomBoneToWorld);

		g_MdlRender->ForcedMaterialOverride(nullptr);
	}

	
	
	bool __fastcall hkSvCheatsGetBool(PVOID pConVar, void* edx)
	{
		static auto dwCAM_Think = Utils::PatternScan(GetModuleHandleW(L"client.dll"), "85 C0 75 30 38 86");
		static auto ofunc = sv_cheats.get_original<bool(__thiscall *)(PVOID)>(13);
		if (!ofunc)
			return false;

		if (reinterpret_cast<DWORD>(_ReturnAddress()) == reinterpret_cast<DWORD>(dwCAM_Think))
			return true;
		return ofunc(pConVar);
	}
}

```

`CSGOSimple/hooks.hpp`:

```hpp
#pragma once

#include "valve_sdk/csgostructs.hpp"
#include "helpers/vfunc_hook.hpp"
#include <d3d9.h>

namespace index
{
	constexpr auto EmitSound1               = 5;
	constexpr auto EmitSound2               = 6;
    constexpr auto EndScene                 = 42;
    constexpr auto Reset                    = 16;
    constexpr auto PaintTraverse            = 41;
    constexpr auto CreateMove               = 22;
    constexpr auto PlaySound                = 82;
    constexpr auto FrameStageNotify         = 37;
    constexpr auto DrawModelExecute         = 21;
    constexpr auto DoPostScreenSpaceEffects = 44;
	constexpr auto SvCheatsGetBool          = 13;
	constexpr auto OverrideView             = 18;
	constexpr auto LockCursor               = 67;
}

namespace Hooks
{
    void Initialize();
    void Shutdown();

    inline vfunc_hook hlclient_hook;
	inline vfunc_hook direct3d_hook;
	inline vfunc_hook vguipanel_hook;
	inline vfunc_hook vguisurf_hook;
	inline vfunc_hook mdlrender_hook;
	inline vfunc_hook viewrender_hook;
	inline vfunc_hook sound_hook;
	inline vfunc_hook clientmode_hook;
	inline vfunc_hook sv_cheats;


    long __stdcall hkEndScene(IDirect3DDevice9* device);
    long __stdcall hkReset(IDirect3DDevice9* device, D3DPRESENT_PARAMETERS* pPresentationParameters);
    void __stdcall hkCreateMove(int sequence_number, float input_sample_frametime, bool active, bool& bSendPacket);
	void __fastcall hkCreateMove_Proxy(void* _this, int, int sequence_number, float input_sample_frametime, bool active);
	void __fastcall hkPaintTraverse(void* _this, int edx, vgui::VPANEL panel, bool forceRepaint, bool allowForce);
	void __fastcall hkEmitSound1(void* _this, int, IRecipientFilter & filter, int iEntIndex, int iChannel, const char * pSoundEntry, unsigned int nSoundEntryHash, const char * pSample, float flVolume, int nSeed, float flAttenuation, int iFlags, int iPitch, const Vector * pOrigin, const Vector * pDirection, void * pUtlVecOrigins, bool bUpdatePositions, float soundtime, int speakerentity, int unk);
    void __fastcall hkDrawModelExecute(void* _this, int, IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& pInfo, matrix3x4_t* pCustomBoneToWorld);
    void __fastcall hkFrameStageNotify(void* _this, int, ClientFrameStage_t stage);
	void __fastcall hkOverrideView(void* _this, int, CViewSetup * vsView);
	void __fastcall hkLockCursor(void* _this);
    int  __fastcall hkDoPostScreenEffects(void* _this, int, int a1);
	bool __fastcall hkSvCheatsGetBool(void* pConVar, void* edx);
}

```

`CSGOSimple/imgui/LICENSE.txt`:

```txt
The MIT License (MIT)

Copyright (c) 2014-2019 Omar Cornut

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`CSGOSimple/imgui/imconfig.h`:

```h
//-----------------------------------------------------------------------------
// COMPILE-TIME OPTIONS FOR DEAR IMGUI
// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.
// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.
//-----------------------------------------------------------------------------
// A) You may edit imconfig.h (and not overwrite it when updating imgui, or maintain a patch/branch with your modifications to imconfig.h)
// B) or add configuration directives in your own file and compile with #define IMGUI_USER_CONFIG "myfilename.h"
// If you do so you need to make sure that configuration settings are defined consistently _everywhere_ dear imgui is used, which include
// the imgui*.cpp files but also _any_ of your code that uses imgui. This is because some compile-time options have an affect on data structures.
// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.
// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.
//-----------------------------------------------------------------------------

#pragma once

//---- Define assertion handler. Defaults to calling assert().
//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)
//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts

//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows.
//#define IMGUI_API __declspec( dllexport )
//#define IMGUI_API __declspec( dllimport )

//---- Don't define obsolete functions/enums names. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS

//---- Don't implement demo windows functionality (ShowDemoWindow()/ShowStyleEditor()/ShowUserGuide() methods will be empty)
//---- It is very strongly recommended to NOT disable the demo windows during development. Please read the comments in imgui_demo.cpp.
//#define IMGUI_DISABLE_DEMO_WINDOWS

//---- Don't implement some functions to reduce linkage requirements.
//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc.
//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] Don't implement default IME handler. Won't use and link with ImmGetContext/ImmSetCompositionWindow.
//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function.
//#define IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS             // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself if you don't want to link with vsnprintf.
//#define IMGUI_DISABLE_MATH_FUNCTIONS                      // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 wrapper so you can implement them yourself. Declare your prototypes in imconfig.h.
//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().

//---- Include imgui_user.h at the end of imgui.h as a convenience
//#define IMGUI_INCLUDE_IMGUI_USER_H

//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)
//#define IMGUI_USE_BGRA_PACKED_COLOR

//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version
// By default the embedded implementations are declared static and not available outside of imgui cpp files.
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.
// This will be inlined as part of ImVec2 and ImVec4 class declarations.
/*
#define IM_VEC2_CLASS_EXTRA                                                 \
        ImVec2(const MyVec2& f) { x = f.x; y = f.y; }                       \
        operator MyVec2() const { return MyVec2(x,y); }

#define IM_VEC4_CLASS_EXTRA                                                 \
        ImVec4(const MyVec4& f) { x = f.x; y = f.y; z = f.z; w = f.w; }     \
        operator MyVec4() const { return MyVec4(x,y,z,w); }
*/

//---- Use 32-bit vertex indices (default is 16-bit) to allow meshes with more than 64K vertices. Render function needs to support it.
//#define ImDrawIdx unsigned int

//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.
/*
namespace ImGui
{
    void MyFunction(const char* name, const MyMatrix44& v);
}
*/

```

`CSGOSimple/imgui/imgui.cpp`:

```cpp
// dear imgui, v1.69 WIP
// (main code and documentation)

// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui
// Releases change-log at https://github.com/ocornut/imgui/releases
// Technical Support for Getting Started https://discourse.dearimgui.org/c/getting-started
// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/1269

// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but I need your support to sustain development and maintenance.
// Businesses: you can support continued maintenance and development via support contracts or sponsoring, see docs/README.
// Individuals: you can support continued maintenance and development via donations or Patreon https://www.patreon.com/imgui.

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- END-USER GUIDE
- PROGRAMMER GUIDE (read me!)
  - Read first.
  - How to update to a newer version of Dear ImGui.
  - Getting started with integrating Dear ImGui in your code/engine.
  - This is how a simple application may look like (2 variations).
  - This is how a simple rendering function may look like.
  - Using gamepad/keyboard navigation controls.
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
  - How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
  - How can I display an image? What is ImTextureID, how does it works?
  - How can I have multiple widgets with the same label or with an empty label? A primer on labels and the ID Stack.
  - How can I use my own math types instead of ImVec2/ImVec4?
  - How can I load a different font than the default?
  - How can I easily use icons in my application?
  - How can I load multiple fonts?
  - How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?
  - How can I interact with standard C++ types (such as std::string and std::vector)?
  - How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
  - How can I use Dear ImGui on a platform that doesn't have a mouse or a keyboard? (input share, remoting, gamepad)
  - I integrated Dear ImGui in my engine and the text or lines are blurry..
  - I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
  - How can I help?

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
// [SECTION] MISC HELPERS/UTILITIES (Maths, String, Format, Hash, File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer
// [SECTION] ImGuiListClipper
// [SECTION] RENDER HELPERS
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] COLUMNS
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUG WINDOW

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize screen real-estate usage.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption (NB- we do allocate when "growing" content e.g. creating a window,.
   opening a tree node for the first time, etc. but a typical frame should not allocate anything).

 Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:
 - Doesn't look fancy, doesn't animate.
 - Limited layout features, intricate layouts are typically crafted in code.


 END-USER GUIDE
 ==============

 - Double-click on title bar to collapse window.
 - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().
 - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).
 - Click and drag on any empty space to move window.
 - TAB/SHIFT+TAB to cycle through keyboard editable fields.
 - CTRL+Click on a slider or drag box to input value as text.
 - Use mouse wheel to scroll.
 - Text editor:
   - Hold SHIFT or use mouse to select text.
   - CTRL+Left/Right to word jump.
   - CTRL+Shift+Left/Right to select words.
   - CTRL+A our Double-Click to select all.
   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/
   - CTRL+Z,CTRL+Y to undo/redo.
   - ESCAPE to revert text to its original value.
   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)
   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.
 - General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.
 - General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW


 PROGRAMMER GUIDE
 ================

 READ FIRST:

 - Read the FAQ below this section!
 - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction
   or destruction steps, less superfluous data retention on your side, less state duplication, less state synchronization, less bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links docs/README.md.
 - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
   For every application frame your UI code will be called only once. This is in contrast to e.g. Unity's own implementation of an IMGUI,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin are on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - This codebase is also optimized to yield decent performances with typical "Debug" builds settings.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - C++: this is a very C-ish codebase: we don't rely on C++11, we don't include any C++ headers, and ImGui:: is a namespace.
 - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
   See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
   However, imgui_internal.h can optionally export math operators for ImVec2/ImVec4, which we use in this codebase.
 - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction (avoid using it in your code!).

 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI:

 - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - Try to keep your copy of dear imgui reasonably up to date.

 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE:

 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - Add the Dear ImGui source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and not as shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating imgui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering informatioe are stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the bindings and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.

 HOW A SIMPLE APPLICATION MAY LOOK LIKE:
 EXHIBIT 1: USING THE EXAMPLE BINDINGS (imgui_impl_XXX.cpp files from the examples/ folder).

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer bindings (here we are using imgui_impl_win32 and imgui_impl_dx11)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         ImGui::NewFrame();

         // Any application code here
         ImGui::Text("Hello, world!");

         // Render dear imgui into screen
         ImGui::Render();
         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }

     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     ImGui::DestroyContext();

 HOW A SIMPLE APPLICATION MAY LOOK LIKE:
 EXHIBIT 2: IMPLEMENTING CUSTOM BINDING / CUSTOM ENGINE.

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = NULL;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that your your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ below for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->TexID = (void*)texture;

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform bindings)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.MousePos = my_mouse_pos;             // set the mouse position
        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states
        io.MouseDown[1] = my_mouse_buttons[1];

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your mainloop to be able to use imgui everywhere)
        ImGui::NewFrame();

        // Most of your application code here
        ImGui::Text("Hello, world!");
        MyGameUpdate(); // may use any ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any ImGui functions as well!

        // Render imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use imgui in your own game rendering code)
        ImGui::EndFrame();
        ImGui::Render();
        ImDrawData* draw_data = ImGui::GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     ImGui::DestroyContext();

 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE:

    void void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawList* cmd_list = draw_data->CmdLists[n];
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // The texture for the draw call is specified by pcmd->TextureId.
                 // The vast majority of draw calls will use the imgui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd->TextureId);

                 // We are using scissoring to clip some objects. All low-level graphics API should supports it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in imgui coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)
                 //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.
                 //   However, in the interest of supporting multi-viewport applications in the future (see 'viewport' branch on github),
                 //   always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 ImVec2 pos = draw_data->DisplayPos;
                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits in imconfig.h if your engine doesn't support 16-bits indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
             }
             idx_buffer += pcmd->ElemCount;
          }
       }
    }

 - The examples/ folders contains many actual implementation of the pseudo-codes above.
 - When calling NewFrame(), the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags are updated.
   They tell you if Dear ImGui intends to use your inputs. When a flag is set you want to hide the corresponding inputs
   from the rest of your application. In every cases you need to pass on the inputs to imgui. Refer to the FAQ for more information.
 - Please read the FAQ below!. Amusingly, it is called a FAQ because people frequently run into the same issues!

 USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS

 - The gamepad/keyboard navigation is fairly functional and keeps being improved.
 - Gamepad support is particularly useful to use dear imgui on a console system (e.g. PS4, Switch, XB1) without a mouse!
 - You can ask questions and report issues at https://github.com/ocornut/imgui/issues/787
 - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.
 - Gamepad:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.
    - Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().
      Note that io.NavInputs[] is cleared by EndFrame().
    - See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:
         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
    - We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.
      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: http://goo.gl/9LgVZW.
    - If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo
      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
 - Keyboard:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.
      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
    - When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag
      will be set. For more advanced uses, you may want to read from:
       - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).
       - or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.
      Please reach out if you think the game vs navigation input sharing could be improved.
 - Mouse:
    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.
    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.
    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.
      Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.
      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
      When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.
      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse as moving back and forth!)
      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
       to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with a dummy small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Keep redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the imgui_impl_xxx files have been split to separate platform (Win32, Glfw, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
                       old binding will still work as is, however prefer using the separated bindings as they will be updated to be multi-viewport conformant.
                       when adopting new bindings follow the main.cpp code of your preferred examples/ folder to know which functions to call.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Keep redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Columns*** to ImGuiCol_Separator***. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_*** types and flags to ImGuiCond_***. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you.
                       If your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.
                           ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col)
                           {
                               float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;
                               return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);
                           }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
              (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       font init:  { const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); <..Upload texture to GPU..>; }
                       became:     { unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); <..Upload texture to GPU>; io.Fonts->TexId = YourTextureIdentifier; }
                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.
                       it is now recommended that you sample the font texture with bilinear interpolation.
              (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.
              (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
              (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
 ======================================

 Q: How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
 A: You can read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags from the ImGuiIO structure (e.g. if (ImGui::GetIO().WantCaptureMouse) { ... } )
    - When 'io.WantCaptureMouse' is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantCaptureKeyboard' is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).
    Note: you should always pass your mouse/keyboard inputs to imgui, even when the io.WantCaptureXXX flag are set false.
     This is because imgui needs to detect that you clicked in the void to unfocus its own windows.
    Note: The 'io.WantCaptureMouse' is more accurate that any attempt to "check if the mouse is hovering a window" (don't do that!).
     It handle mouse dragging correctly (both dragging that started over your application or over an imgui window) and handle e.g. modal windows blocking inputs.
     Those flags are updated by ImGui::NewFrame(). Preferably read the flags after calling NewFrame() if you can afford it, but reading them before is also
     perfectly fine, as the bool toggle fairly rarely. If you have on a touch device, you might find use for an early call to UpdateHoveredWindowAndCaptureFlags().
    Note: Text input widget releases focus on "Return KeyDown", so the subsequent "Return KeyUp" event that your application receive will typically
     have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs
     were targeted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)

 Q: How can I display an image? What is ImTextureID, how does it works?
 A: Short explanation:
    - You may use functions such as ImGui::Image(), ImGui::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures.
    - Actual textures are identified in a way that is up to the user/engine. Those identifiers are stored and passed as ImTextureID (void*) value.
    - Loading image files from the disk and turning them into a texture is not within the scope of Dear ImGui (for a good reason).
      Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward.

    Long explanation:
    - Dear ImGui's job is to create "meshes", defined in a renderer-agnostic format made of draw commands and vertices.
      At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code
      to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.).
    - Each rendering function decides on a data type to represent "textures". The concept of what is a "texture" is entirely tied to your underlying engine/graphics API.
      We carry the information to identify a "texture" in the ImTextureID type.
      ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice.
      Dear ImGui doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function.
    - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying
      an image from the end-user perspective. This is what the _examples_ rendering functions are using:

         OpenGL:     ImTextureID = GLuint                       (see ImGui_ImplGlfwGL3_RenderDrawData() function in imgui_impl_glfw_gl3.cpp)
         DirectX9:   ImTextureID = LPDIRECT3DTEXTURE9           (see ImGui_ImplDX9_RenderDrawData()     function in imgui_impl_dx9.cpp)
         DirectX11:  ImTextureID = ID3D11ShaderResourceView*    (see ImGui_ImplDX11_RenderDrawData()    function in imgui_impl_dx11.cpp)
         DirectX12:  ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE  (see ImGui_ImplDX12_RenderDrawData()    function in imgui_impl_dx12.cpp)

      For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID.
      Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure
      tying together both the texture and information about its format and how to read it.
    - If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about
      the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase
      is designed. If your engine has high-level data types for "textures" and "material" then you may want to use them.
      If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID
      representation suggested by the example bindings is probably the best choice.
      (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer)

    User code may do:

        // Cast our texture type to ImTextureID / void*
        MyTexture* texture = g_CoffeeTableTexture;
        ImGui::Image((void*)texture, ImVec2(texture->Width, texture->Height));

    The renderer function called after ImGui::Render() will receive that same value that the user code passed:

        // Cast ImTextureID / void* stored in the draw command as our texture type
        MyTexture* texture = (MyTexture*)pcmd->TextureId;
        MyEngineBindTexture2D(texture);

    Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear ImGui.
    This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them.
    If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using.

    Here's a simplified OpenGL example using stb_image.h:

        // Use stb_image.h to load a PNG from disk and turn it into raw RGBA pixel data:
        #define STB_IMAGE_IMPLEMENTATION
        #include <stb_image.h>
        [...]
        int my_image_width, my_image_height;
        unsigned char* my_image_data = stbi_load("my_image.png", &my_image_width, &my_image_height, NULL, 4);

        // Turn the RGBA pixel data into an OpenGL texture:
        GLuint my_opengl_texture;
        glGenTextures(1, &my_opengl_texture);
        glBindTexture(GL_TEXTURE_2D, my_opengl_texture);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);

        // Now that we have an OpenGL texture, assuming our imgui rendering function (imgui_impl_xxx.cpp file) takes GLuint as ImTextureID, we can display it:
        ImGui::Image((void*)(intptr_t)my_opengl_texture, ImVec2(my_image_width, my_image_height));

    C/C++ tip: a void* is pointer-sized storage. You may safely store any pointer or integer into it by casting your value to ImTexture / void*, and vice-versa.
    Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTexture / void*.
    Examples:

        GLuint my_tex = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)(intptr_t)my_tex;                  // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer)
        my_tex = (GLuint)(intptr_t)my_void_ptr;                 // cast a void* into a GLuint

        ID3D11ShaderResourceView* my_dx11_srv = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)my_dx11_srv;                       // cast a ID3D11ShaderResourceView* into an opaque void*
        my_dx11_srv = (ID3D11ShaderResourceView*)my_void_ptr;   // cast a void* into a ID3D11ShaderResourceView*

    Finally, you may call ImGui::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated.

 Q: How can I have multiple widgets with the same label or with an empty label?
 Q: I have multiple widgets with the same label, and only the first one works. Why is that?
 A: A primer on labels and the ID Stack...

    Dear ImGui internally need to uniquely identify UI elements.
    Elements that are typically not clickable (such as calls to the Text functions) don't need an ID.
    Interactive widgets (such as calls to Button buttons) need a unique ID.
    Unique ID are used internally to track active widgets and occasionally associate state to widgets.
    Unique ID are implicitly built from the hash of multiple elements that identify the "path" to the UI element.

   - Unique ID are often derived from a string label:

       Button("OK");          // Label = "OK",     ID = hash of (..., "OK")
       Button("Cancel");      // Label = "Cancel", ID = hash of (..., "Cancel")

   - ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having
     two buttons labeled "OK" in different windows or different tree locations is fine.
     We used "..." above to signify whatever was already pushed to the ID stack previously:

       Begin("MyWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyWindow", "OK")
       End();
       Begin("MyOtherWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyOtherWindow", "OK")
       End();

   - If you have a same ID twice in the same location, you'll have a conflict:

       Button("OK");
       Button("OK");          // ID collision! Interacting with either button will trigger the first one.

     Fear not! this is easy to solve and there are many ways to solve it!

   - Solving ID conflict in a simple/local context:
     When passing a label you can optionally specify extra ID information within string itself.
     Use "##" to pass a complement to the ID that won't be visible to the end-user.
     This helps solving the simple collision cases when you know e.g. at compilation time which items
     are going to be created:

       Begin("MyWindow");
       Button("Play");        // Label = "Play",   ID = hash of ("MyWindow", "Play")
       Button("Play##foo1");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo1")  // Different from above
       Button("Play##foo2");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo2")  // Different from above
       End();

   - If you want to completely hide the label, but still need an ID:

       Checkbox("##On", &b);  // Label = "",       ID = hash of (..., "##On")   // No visible label, just a checkbox!

   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows
     you to animate labels. For example you may want to include varying information in a window title bar,
     but windows are uniquely identified by their ID. Use "###" to pass a label that isn't part of ID:

       Button("Hello###ID");  // Label = "Hello",  ID = hash of (..., "###ID")
       Button("World###ID");  // Label = "World",  ID = hash of (..., "###ID")  // Same as above, even though the label looks different

       sprintf(buf, "My game (%f FPS)###MyGame", fps);
       Begin(buf);            // Variable title,   ID = hash of "MyGame"

   - Solving ID conflict in a more general manner:
     Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts
     within the same window. This is the most convenient way of distinguishing ID when iterating and
     creating many UI elements programmatically.
     You can push a pointer, a string or an integer value into the ID stack.
     Remember that ID are formed from the concatenation of _everything_ pushed into the ID stack.
     At each level of the stack we store the seed used for items at this level of the ID stack.

     Begin("Window");
       for (int i = 0; i < 100; i++)
       {
         PushID(i);           // Push i to the id tack
         Button("Click");     // Label = "Click",  ID = hash of ("Window", i, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj);
         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj pointer, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj->Name);
         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj->Name, "Click")
         PopID();
       }
       End();

   - You can stack multiple prefixes into the ID stack:

       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")
       PushID("node");
       Button("Click");       // Label = "Click",  ID = hash of (..., "node", "Click")
         PushID(my_ptr);
           Button("Click");   // Label = "Click",  ID = hash of (..., "node", my_ptr, "Click")
         PopID();
       PopID();

   - Tree nodes implicitly creates a scope for you by calling PushID().

       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")
       if (TreeNode("node"))  // <-- this function call will do a PushID() for you (unless instructed not to, with a special flag)
       {
         Button("Click");     // Label = "Click",  ID = hash of (..., "node", "Click")
         TreePop();
       }

   - When working with trees, ID are used to preserve the open/close state of each tree node.
     Depending on your use cases you may want to use strings, indices or pointers as ID.
      e.g. when following a single pointer that may change over time, using a static string as ID
       will preserve your node open/closed state when the targeted object change.
      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the
       node open/closed state differently. See what makes more sense in your situation!

 Q: How can I use my own math types instead of ImVec2/ImVec4?
 A: You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA/IM_VEC4_CLASS_EXTRA macros to add implicit type conversions.
    This way you'll be able to use your own types everywhere, e.g. passsing glm::vec2 to ImGui functions instead of ImVec2.

 Q: How can I load a different font than the default?
 A: Use the font atlas to load the TTF/OTF file you want:
      ImGuiIO& io = ImGui::GetIO();
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
    Default is ProggyClean.ttf, monospace, rendered at size 13, embedded in dear imgui's source code.
    (Tip: monospace fonts are convenient because they allow to facilitate horizontal alignment directly at the string level.)
    (Read the 'misc/fonts/README.txt' file for more details about font loading.)

    New programmers: remember that in C/C++ and most programming languages if you want to use a
    backslash \ within a string literal, you need to write it double backslash "\\":
      io.Fonts->AddFontFromFileTTF("MyDataFolder\MyFontFile.ttf", size_in_pixels);   // WRONG (you are escape the M here!)
      io.Fonts->AddFontFromFileTTF("MyDataFolder\\MyFontFile.ttf", size_in_pixels);  // CORRECT
      io.Fonts->AddFontFromFileTTF("MyDataFolder/MyFontFile.ttf", size_in_pixels);   // ALSO CORRECT

 Q: How can I easily use icons in my application?
 A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you
    main font. Then you can refer to icons within your strings.
    You may want to see ImFontConfig::GlyphMinAdvanceX to make your icon look monospace to facilitate alignment.
    (Read the 'misc/fonts/README.txt' file for more details about icons font loading.)

 Q: How can I load multiple fonts?
 A: Use the font atlas to pack them into a single texture:
    (Read the 'misc/fonts/README.txt' file and the code in ImFontAtlas for more details.)

      ImGuiIO& io = ImGui::GetIO();
      ImFont* font0 = io.Fonts->AddFontDefault();
      ImFont* font1 = io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      ImFont* font2 = io.Fonts->AddFontFromFileTTF("myfontfile2.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
      // the first loaded font gets used by default
      // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime

      // Options
      ImFontConfig config;
      config.OversampleH = 2;
      config.OversampleV = 1;
      config.GlyphOffset.y -= 1.0f;      // Move everything by 1 pixels up
      config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, &config);

      // Combine multiple fonts into one (e.g. for icon fonts)
      static ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };
      ImFontConfig config;
      config.MergeMode = true;
      io.Fonts->AddFontDefault();
      io.Fonts->AddFontFromFileTTF("fontawesome-webfont.ttf", 16.0f, &config, ranges); // Merge icon font
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs

 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 A: When loading a font, pass custom Unicode ranges to specify the glyphs to load.

      // Add default Japanese ranges
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());

      // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)
      ImVector<ImWchar> ranges;
      ImFontGlyphRangesBuilder builder;
      builder.AddText("Hello world");                        // Add a string (here "Hello world" contains 7 unique characters)
      builder.AddChar(0x7262);                               // Add a specific character
      builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges
      builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, ranges.Data);

    All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8
    by using the u8"hello" syntax. Specifying literal in your source code using a local code page
    (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work!
    Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.

    Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter().
    The applications in examples/ are doing that.
    Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode).
    You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state.
    Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for
    the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly.

 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 A: - Being highly portable (bindings for several languages, frameworks, programming style, obscure or older platforms/compilers),
      and aiming for compatibility & performance suitable for every modern real-time game engines, dear imgui does not use
      any of std C++ types. We use raw types (e.g. char* instead of std::string) because they adapt to more use cases.
    - To use ImGui::InputText() with a std::string or any resizable string class, see misc/cpp/imgui_stdlib.h.
    - To use combo boxes and list boxes with std::vector or any other data structure: the BeginCombo()/EndCombo() API
      lets you iterate and submit items yourself, so does the ListBoxHeader()/ListBoxFooter() API.
      Prefer using them over the old and awkward Combo()/ListBox() api.
    - Generally for most high-level types you should be able to access the underlying data type.
      You may write your own one-liner wrappers to facilitate user code (tip: add new functions in ImGui:: namespace from your code).
    - Dear ImGui applications often need to make intensive use of strings. It is expected that many of the strings you will pass
      to the API are raw literals (free in C/C++) or allocated in a manner that won't incur a large cost on your application.
      Please bear in mind that using std::string on applications with large amount of UI may incur unsatisfactory performances.
      Modern implementations of std::string often include small-string optimization (which is often a local buffer) but those
      are not configurable and not the same across implementations.
    - If you are finding your UI traversal cost to be too large, make sure your string usage is not leading to excessive amount
      of heap allocations. Consider using literals, statically sized buffers and your own helper functions. A common pattern
      is that you will need to build lots of strings on the fly, and their maximum length can be easily be scoped ahead.
      One possible implementation of a helper to facilitate printf-style building of strings: https://github.com/ocornut/Str
      This is a small helper where you can instance strings with configurable local buffers length. Many game engines will
      provide similar or better string helpers.

 Q: How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
 A: - You can create a dummy window. Call Begin() with the NoBackground | NoDecoration | NoSavedSettings | NoInputs flags.
      (The ImGuiWindowFlags_NoDecoration flag itself is a shortcut for NoTitleBar | NoResize | NoScrollbar | NoCollapse)
      Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.
    - You can call ImGui::GetOverlayDrawList() and use this draw list to display contents over every other imgui windows.
    - You can create your own ImDrawList instance. You'll need to initialize them ImGui::GetDrawListSharedData(), or create
      your own ImDrawListSharedData, and then call your rendered code with your own ImDrawList or ImDrawData data.

 Q: How can I use this without a mouse, without a keyboard or without a screen? (gamepad, input share, remote display)
 A: - You can control Dear ImGui with a gamepad. Read about navigation in "Using gamepad/keyboard navigation controls".
      (short version: map gamepad inputs into the io.NavInputs[] array + set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad)
    - You can share your computer mouse seamlessly with your console/tablet/phone using Synergy (https://symless.com/synergy)
      This is the preferred solution for developer productivity.
      In particular, the "micro-synergy-client" repository (https://github.com/symless/micro-synergy-client) has simple
      and portable source code (uSynergy.c/.h) for a small embeddable client that you can use on any platform to connect
      to your host computer, based on the Synergy 1.x protocol. Make sure you download the Synergy 1 server on your computer.
      Console SDK also sometimes provide equivalent tooling or wrapper for Synergy-like protocols.
    - You may also use a third party solution such as Remote ImGui (https://github.com/JordiRos/remoteimgui) which sends
      the vertices to render over the local network, allowing you to use Dear ImGui even on a screen-less machine.
    - For touch inputs, you can increase the hit box of widgets (via the style.TouchPadding setting) to accommodate
      for the lack of precision of touch inputs, but it is recommended you use a mouse or gamepad to allow optimizing
      for screen real-estate and precision.

 Q: I integrated Dear ImGui in my engine and the text or lines are blurry..
 A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).
    Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.

 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
 A: You are probably mishandling the clipping rectangles in your render function.
    Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).

 Q: How can I help?
 A: - If you are experienced with Dear ImGui and C++, look at the github issues, look at the Wiki, read docs/TODO.txt
      and see how you want to help and can help!
    - Businesses: convince your company to fund development via support contracts/sponsoring! This is among the most useful thing you can do for dear imgui.
    - Individuals: you can also become a Patron (http://www.patreon.com/imgui) or donate on PayPal! See README.
    - Disclose your usage of dear imgui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads (github.com/ocornut/imgui/issues/1902). Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).

 - tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window.
        this is also useful to set yourself in the context of another window (to get/set other settings)
 - tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called "Debug".
 - tip: the ImGuiOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle
        of a deep nested inner loop in your code.
 - tip: you can call Render() multiple times (e.g for VR renders).
 - tip: call and read the ShowDemoWindow() code in imgui_demo.cpp for more example of how to use ImGui!

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <ctype.h>      // toupper, isprint
#include <stdio.h>      // vsnprintf, sscanf, printf
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Debug options
#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
#define IMGUI_DEBUG_NAV_RECTS       0   // Display the reference navigation rectangle for each window

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wunknown-pragmas"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#pragma clang diagnostic ignored "-Wformat-pedantic"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"       // warning : cast to 'void *' from smaller integer type 'int'
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    // Time before the window list starts to appear

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by back-end)
static const float WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS = 4.0f;     // Extend outside and inside windows. Affect FindHoveredWindow().
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

static void             SetCurrentWindow(ImGuiWindow* window);
static void             FindHoveredWindow();
static ImGuiWindow*     CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);
static void             CheckStacksSize(ImGuiWindow* window, bool write);
static ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges);

static void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);
static void             AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);

static ImRect           GetViewportRect();

// Settings
static void*            SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);
static void             SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);
static void             SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf);

// Platform Dependents default implementation for IO functions
static const char*      GetClipboardTextFn_DefaultImpl(void* user_data);
static void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);
static void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);

namespace ImGui
{
static bool             BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags);

// Navigation
static void             NavUpdate();
static void             NavUpdateWindowing();
static void             NavUpdateWindowingList();
static void             NavUpdateMoveResult();
static float            NavUpdatePageUpPageDown(int allowed_dir_flags);
static inline void      NavUpdateAnyRequestFlag();
static void             NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id);
static ImVec2           NavCalcPreferredRefPos();
static void             NavSaveLastChildNavWindow(ImGuiWindow* nav_window);
static ImGuiWindow*     NavRestoreLastChildNavWindow(ImGuiWindow* window);

// Misc
static void             UpdateMouseInputs();
static void             UpdateMouseWheel();
static void             UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4]);
static void             RenderOuterBorders(ImGuiWindow* window);

}

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// ImGui::CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling ImGui::SetCurrentContext().
// 1) Important: globals are not shared across DLL boundaries! If you use DLLs or any form of hot-reloading: you will need to call
//    SetCurrentContext() (with the pointer you got from CreateContext) from each unique static/DLL boundary, and after each hot-reloading.
//    In your debugger, add GImGui to your watch window and notice how its value changes depending on which location you are currently stepping into.
// 2) Important: Dear ImGui functions are not thread-safe because of this pointer.
//    If you want thread-safety to allow N threads to access N different contexts, you can:
//    - Change this variable to use thread local storage so each thread can refer to a different context, in imconfig.h:
//          struct ImGuiContext;
//          extern thread_local ImGuiContext* MyImGuiTLS;
//          #define GImGui MyImGuiTLS
//      And then define MyImGuiTLS in one of your cpp file. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//    - Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
//    - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from different namespace.
#ifndef GImGui
ImGuiContext*   GImGui = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.
// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
#else
static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }
static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }
#endif

static void*  (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;
static void   (*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;
static void*    GImAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
//-----------------------------------------------------------------------------

ImGuiStyle::ImGuiStyle()
{
    Alpha                   = 1.0f;             // Global alpha applies to everything in ImGui
    WindowPadding           = ImVec2(8,8);      // Padding within a window
    WindowRounding          = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows
    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    WindowMinSize           = ImVec2(32,32);    // Minimum window size
    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text
    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns
    ScrollbarSize           = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar
    GrabMinSize             = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar
    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    TabRounding             = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    TabBorderSize           = 0.0f;             // Thickness of border around tabs.
    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
    SelectableTextAlign     = ImVec2(0.0f,0.0f);// Alignment of selectable text when button is larger than text.
    DisplayWindowPadding    = ImVec2(19,19);    // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    AntiAliasedLines        = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.
    AntiAliasedFill         = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

    // Default theme
    ImGui::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
void ImGuiStyle::ScaleAllSizes(float scale_factor)
{
    WindowPadding = ImFloor(WindowPadding * scale_factor);
    WindowRounding = ImFloor(WindowRounding * scale_factor);
    WindowMinSize = ImFloor(WindowMinSize * scale_factor);
    ChildRounding = ImFloor(ChildRounding * scale_factor);
    PopupRounding = ImFloor(PopupRounding * scale_factor);
    FramePadding = ImFloor(FramePadding * scale_factor);
    FrameRounding = ImFloor(FrameRounding * scale_factor);
    ItemSpacing = ImFloor(ItemSpacing * scale_factor);
    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);
    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);
    IndentSpacing = ImFloor(IndentSpacing * scale_factor);
    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);
    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);
    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);
    GrabMinSize = ImFloor(GrabMinSize * scale_factor);
    GrabRounding = ImFloor(GrabRounding * scale_factor);
    TabRounding = ImFloor(TabRounding * scale_factor);
    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);
    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);
    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);
}

ImGuiIO::ImGuiIO()
{
    // Most fields are initialized with zero
    memset(this, 0, sizeof(*this));

    // Settings
    ConfigFlags = ImGuiConfigFlags_None;
    BackendFlags = ImGuiBackendFlags_None;
    DisplaySize = ImVec2(-1.0f, -1.0f);
    DeltaTime = 1.0f/60.0f;
    IniSavingRate = 5.0f;
    IniFilename = "imgui.ini";
    LogFilename = "imgui_log.txt";
    MouseDoubleClickTime = 0.30f;
    MouseDoubleClickMaxDist = 6.0f;
    for (int i = 0; i < ImGuiKey_COUNT; i++)
        KeyMap[i] = -1;
    KeyRepeatDelay = 0.250f;
    KeyRepeatRate = 0.050f;
    UserData = NULL;

    Fonts = NULL;
    FontGlobalScale = 1.0f;
    FontDefault = NULL;
    FontAllowUserScaling = false;
    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);

    // Miscellaneous options
    MouseDrawCursor = false;
#ifdef __APPLE__
    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
    ConfigMacOSXBehaviors = false;
#endif
    ConfigInputTextCursorBlink = true;
    ConfigWindowsResizeFromEdges = true;
    ConfigWindowsMoveFromTitleBarOnly = false;

    // Platform Functions
    BackendPlatformName = BackendRendererName = NULL;
    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
    ClipboardUserData = NULL;
    ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;
    ImeWindowHandle = NULL;

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    RenderDrawListsFn = NULL;
#endif

    // Input (NB: we already have memset zero the entire structure!)
    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
    MouseDragThreshold = 6.0f;
    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i]  = KeysDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
void ImGuiIO::AddInputCharacter(ImWchar c)
{
    InputQueueCharacters.push_back(c);
}

void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
{
    while (*utf8_chars != 0)
    {
        unsigned int c = 0;
        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
        if (c > 0 && c <= 0xFFFF)
            InputQueueCharacters.push_back((ImWchar)c);
    }
}

void ImGuiIO::ClearInputCharacters()
{
    InputQueueCharacters.resize(0);
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Maths, String, Format, Hash, File functions)
//-----------------------------------------------------------------------------

ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)
{
    ImVec2 ap = p - a;
    ImVec2 ab_dir = b - a;
    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
    if (dot < 0.0f)
        return a;
    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    if (dot > ab_len_sqr)
        return b;
    return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
    return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)
{
    ImVec2 v0 = b - a;
    ImVec2 v1 = c - a;
    ImVec2 v2 = p - a;
    const float denom = v0.x * v1.y - v1.x * v0.y;
    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
    float dist2_ab = ImLengthSqr(p - proj_ab);
    float dist2_bc = ImLengthSqr(p - proj_bc);
    float dist2_ca = ImLengthSqr(p - proj_ca);
    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
    if (m == dist2_ab)
        return proj_ab;
    if (m == dist2_bc)
        return proj_bc;
    return proj_ca;
}

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
int ImStricmp(const char* str1, const char* str2)
{
    int d;
    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }
    return d;
}

int ImStrnicmp(const char* str1, const char* str2, size_t count)
{
    int d = 0;
    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
    return d;
}

void ImStrncpy(char* dst, const char* src, size_t count)
{
    if (count < 1) 
        return;
    if (count > 1)
        strncpy(dst, src, count - 1);
    dst[count - 1] = 0;
}

char* ImStrdup(const char* str)
{
    size_t len = strlen(str);
    void* buf = ImGui::MemAlloc(len + 1);
    return (char*)memcpy(buf, (const void*)str, len + 1);
}

char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)
{
    size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
    size_t src_size = strlen(src) + 1;
    if (dst_buf_size < src_size)
    {
        ImGui::MemFree(dst);
        dst = (char*)ImGui::MemAlloc(src_size);
        if (p_dst_size)
            *p_dst_size = src_size;
    }
    return (char*)memcpy(dst, (const void*)src, src_size);
}

const char* ImStrchrRange(const char* str, const char* str_end, char c)
{
    const char* p = (const char*)memchr(str, (int)c, str_end - str);
    return p;
}

int ImStrlenW(const ImWchar* str)
{
    //return (int)wcslen((const wchar_t*)str);	// FIXME-OPT: Could use this when wchar_t are 16-bits
    int n = 0;
    while (*str++) n++;
    return n;
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
const char* ImStreolRange(const char* str, const char* str_end)
{
    const char* p = (const char*)memchr(str, '\n', str_end - str);
    return p ? p : str_end;
}

const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line
{
    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
        buf_mid_line--;
    return buf_mid_line;
}

const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
{
    if (!needle_end)
        needle_end = needle + strlen(needle);

    const char un0 = (char)toupper(*needle);
    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
    {
        if (toupper(*haystack) == un0)
        {
            const char* b = needle + 1;
            for (const char* a = haystack + 1; b < needle_end; a++, b++)
                if (toupper(*a) != toupper(*b))
                    break;
            if (b == needle_end)
                return haystack;
        }
        haystack++;
    }
    return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
void ImStrTrimBlanks(char* buf)
{
    char* p = buf;
    while (p[0] == ' ' || p[0] == '\t')     // Leading blanks
        p++;
    char* p_start = p;
    while (*p != 0)                         // Find end of string
        p++;
    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks
        p--;
    if (p_start != buf)                     // Copy memory if we had leading blanks
        memmove(buf, p_start, p - p_start);
    buf[p - p_start] = 0;                   // Zero terminate
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

//#define IMGUI_USE_STB_SPRINTF
#ifdef IMGUI_USE_STB_SPRINTF
#define STB_SPRINTF_IMPLEMENTATION
#include "imstb_sprintf.h"
#endif

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
#ifdef IMGUI_USE_STB_SPRINTF
    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
    int w = vsnprintf(buf, buf_size, fmt, args);
#endif
    va_end(args);
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}

int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
{
#ifdef IMGUI_USE_STB_SPRINTF
    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
    int w = vsnprintf(buf, buf_size, fmt, args);
#endif
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}
#endif // #ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
static const ImU32 GCrc32LookupTable[256] = 
{
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
};

// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHashData(const void* data_p, size_t data_size, ImU32 seed)
{
    ImU32 crc = ~seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    while (data_size-- != 0)
        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
    return ~crc;
}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHashStr(const char* data, size_t data_size, ImU32 seed)
{
    seed = ~seed;
    ImU32 crc = seed;
    const unsigned char* src = (const unsigned char*)data;
    const ImU32* crc32_lut = GCrc32LookupTable;
    if (data_size != 0)
    {
        while (data_size-- != 0)
        {
            unsigned char c = *src++;
            if (c == '#' && src[0] == '#' && src[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    else
    {
        while (unsigned char c = *src++)
        {
            if (c == '#' && src[0] == '#' && src[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    return ~crc;
}

FILE* ImFileOpen(const char* filename, const char* mode)
{
#if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__GNUC__)
    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)
    const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;
    const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;
    ImVector<ImWchar> buf;
    buf.resize(filename_wsize + mode_wsize);
    ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);
    ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);
    return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);
#else
    return fopen(filename, mode);
#endif
}

// Load file content into memory
// Memory allocated with ImGui::MemAlloc(), must be freed by user using ImGui::MemFree()
void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size, int padding_bytes)
{
    IM_ASSERT(filename && file_open_mode);
    if (out_file_size)
        *out_file_size = 0;

    FILE* f;
    if ((f = ImFileOpen(filename, file_open_mode)) == NULL)
        return NULL;

    long file_size_signed;
    if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))
    {
        fclose(f);
        return NULL;
    }

    size_t file_size = (size_t)file_size_signed;
    void* file_data = ImGui::MemAlloc(file_size + padding_bytes);
    if (file_data == NULL)
    {
        fclose(f);
        return NULL;
    }
    if (fread(file_data, 1, file_size, f) != file_size)
    {
        fclose(f);
        ImGui::MemFree(file_data);
        return NULL;
    }
    if (padding_bytes > 0)
        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

    fclose(f);
    if (out_file_size)
        *out_file_size = file_size;

    return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------

// Convert UTF-8 to 32-bits character, process single character input.
// Based on stb_from_utf8() from github.com/nothings/stb/
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
{
    unsigned int c = (unsigned int)-1;
    const unsigned char* str = (const unsigned char*)in_text;
    if (!(*str & 0x80))
    {
        c = (unsigned int)(*str++);
        *out_char = c;
        return 1;
    }
    if ((*str & 0xe0) == 0xc0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 2) return 1;
        if (*str < 0xc2) return 2;
        c = (unsigned int)((*str++ & 0x1f) << 6);
        if ((*str & 0xc0) != 0x80) return 2;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 2;
    }
    if ((*str & 0xf0) == 0xe0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 3) return 1;
        if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;
        if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x0f) << 12);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 3;
    }
    if ((*str & 0xf8) == 0xf0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 4) return 1;
        if (*str > 0xf4) return 4;
        if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;
        if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x07) << 18);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 12);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (*str++ & 0x3f);
        // utf-8 encodings of values used in surrogate pairs are invalid
        if ((c & 0xFFFFF800) == 0xD800) return 4;
        *out_char = c;
        return 4;
    }
    *out_char = 0;
    return 0;
}

int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
{
    ImWchar* buf_out = buf;
    ImWchar* buf_end = buf + buf_size;
    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes
            *buf_out++ = (ImWchar)c;
    }
    *buf_out = 0;
    if (in_text_remaining)
        *in_text_remaining = in_text;
    return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
{
    int char_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)
            char_count++;
    }
    return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
    if (c < 0x80)
    {
        buf[0] = (char)c;
        return 1;
    }
    if (c < 0x800)
    {
        if (buf_size < 2) return 0;
        buf[0] = (char)(0xc0 + (c >> 6));
        buf[1] = (char)(0x80 + (c & 0x3f));
        return 2;
    }
    if (c >= 0xdc00 && c < 0xe000)
    {
        return 0;
    }
    if (c >= 0xd800 && c < 0xdc00)
    {
        if (buf_size < 4) return 0;
        buf[0] = (char)(0xf0 + (c >> 18));
        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[3] = (char)(0x80 + ((c ) & 0x3f));
        return 4;
    }
    //else if (c < 0x10000)
    {
        if (buf_size < 3) return 0;
        buf[0] = (char)(0xe0 + (c >> 12));
        buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));
        buf[2] = (char)(0x80 + ((c ) & 0x3f));
        return 3;
    }
}

// Not optimal but we very rarely use this function.
int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)
{
    unsigned int dummy = 0;
    return ImTextCharFromUtf8(&dummy, in_text, in_text_end);
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
{
    if (c < 0x80) return 1;
    if (c < 0x800) return 2;
    if (c >= 0xdc00 && c < 0xe000) return 0;
    if (c >= 0xd800 && c < 0xdc00) return 4;
    return 3;
}

int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
{
    char* buf_out = buf;
    const char* buf_end = buf + buf_size;
    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            *buf_out++ = (char)c;
        else
            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end-buf_out-1), c);
    }
    *buf_out = 0;
    return (int)(buf_out - buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)
{
    int bytes_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            bytes_count++;
        else
            bytes_count += ImTextCountUtf8BytesFromChar(c);
    }
    return bytes_count;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILTIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
{
    float s = 1.0f/255.0f;
    return ImVec4(
        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
}

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
{
    ImU32 out;
    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
    return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
{
    float K = 0.f;
    if (g < b)
    {
        ImSwap(g, b);
        K = -1.f;
    }
    if (r < g)
    {
        ImSwap(r, g);
        K = -2.f / 6.f - K;
    }

    const float chroma = r - (g < b ? g : b);
    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));
    out_s = chroma / (r + 1e-20f);
    out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
{
    if (s == 0.0f)
    {
        // gray
        out_r = out_g = out_b = v;
        return;
    }

    h = ImFmod(h, 1.0f) / (60.0f/360.0f);
    int   i = (int)h;
    float f = h - (float)i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));

    switch (i)
    {
    case 0: out_r = v; out_g = t; out_b = p; break;
    case 1: out_r = q; out_g = v; out_b = p; break;
    case 2: out_r = p; out_g = v; out_b = t; break;
    case 3: out_r = p; out_g = q; out_b = v; break;
    case 4: out_r = t; out_g = p; out_b = v; break;
    case 5: default: out_r = v; out_g = p; out_b = q; break;
    }
}

ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = style.Colors[idx];
    c.w *= style.Alpha * alpha_mul;
    return ColorConvertFloat4ToU32(c);
}

ImU32 ImGui::GetColorU32(const ImVec4& col)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = col;
    c.w *= style.Alpha;
    return ColorConvertFloat4ToU32(c);
}

const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)
{
    ImGuiStyle& style = GImGui->Style;
    return style.Colors[idx];
}

ImU32 ImGui::GetColorU32(ImU32 col)
{
    float style_alpha = GImGui->Style.Alpha;
    if (style_alpha >= 1.0f)
        return col;
    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
    a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.
    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static ImGuiStorage::Pair* LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)
{
    ImGuiStorage::Pair* first = data.Data;
    ImGuiStorage::Pair* last = data.Data + data.Size;
    size_t count = (size_t)(last - first);
    while (count > 0)
    {
        size_t count2 = count >> 1;
        ImGuiStorage::Pair* mid = first + count2;
        if (mid->key < key)
        {
            first = ++mid;
            count -= count2 + 1;
        }
        else
        {
            count = count2;
        }
    }
    return first;
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
void ImGuiStorage::BuildSortByKey()
{
    struct StaticFunc
    {
        static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)
        {
            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
            if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;
            if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;
            return 0;
        }
    };
    if (Data.Size > 1)
        ImQsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);
}

int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
{
    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_i;
}

bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
{
    return GetInt(key, default_val ? 1 : 0) != 0;
}

float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
{
    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_f;
}

void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
{
    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return NULL;
    return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_i;
}

bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
{
    return (bool*)GetIntRef(key, default_val ? 1 : 0);
}

float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_f;
}

void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void ImGuiStorage::SetInt(ImGuiID key, int val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_i = val;
}

void ImGuiStorage::SetBool(ImGuiID key, bool val)
{
    SetInt(key, val ? 1 : 0);
}

void ImGuiStorage::SetFloat(ImGuiID key, float val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_f = val;
}

void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_p = val;
}

void ImGuiStorage::SetAllInt(int v)
{
    for (int i = 0; i < Data.Size; i++)
        Data[i].val_i = v;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)
{
    if (default_filter)
    {
        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
        Build();
    }
    else
    {
        InputBuf[0] = 0;
        CountGrep = 0;
    }
}

bool ImGuiTextFilter::Draw(const char* label, float width)
{
    if (width != 0.0f)
        ImGui::PushItemWidth(width);
    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
    if (width != 0.0f)
        ImGui::PopItemWidth();
    if (value_changed)
        Build();
    return value_changed;
}

void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>* out) const
{
    out->resize(0);
    const char* wb = b;
    const char* we = wb;
    while (we < e)
    {
        if (*we == separator)
        {
            out->push_back(TextRange(wb, we));
            wb = we + 1;
        }
        we++;
    }
    if (wb != we)
        out->push_back(TextRange(wb, we));
}

void ImGuiTextFilter::Build()
{
    Filters.resize(0);
    TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));
    input_range.split(',', &Filters);

    CountGrep = 0;
    for (int i = 0; i != Filters.Size; i++)
    {
        TextRange& f = Filters[i];
        while (f.b < f.e && ImCharIsBlankA(f.b[0]))
            f.b++;
        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
            f.e--;
        if (f.empty())
            continue;
        if (Filters[i].b[0] != '-')
            CountGrep += 1;
    }
}

bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const
{
    if (Filters.empty())
        return true;

    if (text == NULL)
        text = "";

    for (int i = 0; i != Filters.Size; i++)
    {
        const TextRange& f = Filters[i];
        if (f.empty())
            continue;
        if (f.b[0] == '-')
        {
            // Subtract
            if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)
                return false;
        }
        else
        {
            // Grep
            if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)
                return true;
        }
    }

    // Implicit * grep
    if (CountGrep == 0)
        return true;

    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

char ImGuiTextBuffer::EmptyString[1] = { 0 };

void ImGuiTextBuffer::append(const char* str, const char* str_end)
{
    int len = str_end ? (int)(str_end - str) : (int)strlen(str);

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    memcpy(&Buf[write_off - 1], str, (size_t)len);
    Buf[write_off - 1 + len] = 0;
}

void ImGuiTextBuffer::appendf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    appendfv(fmt, args);
    va_end(args);
}

// Helper: Text buffer for logging/accumulating text
void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
{
    va_list args_copy;
    va_copy(args_copy, args);

    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
    if (len <= 0)
    {
        va_end(args_copy);
        return;
    }

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
    va_end(args_copy);
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
// This is currently not as flexible/powerful as it should be, needs some rework (see TODO)
//-----------------------------------------------------------------------------

static void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)
{
    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
    // The clipper should probably have a 4th step to display the last item in a regular manner.
    ImGui::SetCursorPosY(pos_y);
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
    window->DC.PrevLineSize.y = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
    if (window->DC.ColumnsSet)
        window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly
}

// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1
// Use case B: Begin() called from constructor with items_height>0
// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.
void ImGuiListClipper::Begin(int count, float items_height)
{
    StartPosY = ImGui::GetCursorPosY();
    ItemsHeight = items_height;
    ItemsCount = count;
    StepNo = 0;
    DisplayEnd = DisplayStart = -1;
    if (ItemsHeight > 0.0f)
    {
        ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display
        if (DisplayStart > 0)
            SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor
        StepNo = 2;
    }
}

void ImGuiListClipper::End()
{
    if (ItemsCount < 0)
        return;
    // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
    if (ItemsCount < INT_MAX)
        SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor
    ItemsCount = -1;
    StepNo = 3;
}

bool ImGuiListClipper::Step()
{
    if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)
    {
        ItemsCount = -1;
        return false;
    }
    if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.
    {
        DisplayStart = 0;
        DisplayEnd = 1;
        StartPosY = ImGui::GetCursorPosY();
        StepNo = 1;
        return true;
    }
    if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
    {
        if (ItemsCount == 1) { ItemsCount = -1; return false; }
        float items_height = ImGui::GetCursorPosY() - StartPosY;
        IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically
        Begin(ItemsCount-1, items_height);
        DisplayStart++;
        DisplayEnd++;
        StepNo = 3;
        return true;
    }
    if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.
    {
        IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);
        StepNo = 3;
        return true;
    }
    if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
        End();
    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Those (internal) functions are currently quite a legacy mess - their signature and behavior will change.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: state.
//-----------------------------------------------------------------------------

const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
{
    const char* text_display_end = text;
    if (!text_end)
        text_end = (const char*)-1;

    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
        text_display_end++;
    return text_display_end;
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // Hide anything after a '##' string
    const char* text_display_end;
    if (hide_text_after_hash)
    {
        text_display_end = FindRenderedTextEnd(text, text_end);
    }
    else
    {
        if (!text_end)
            text_end = text + strlen(text); // FIXME-OPT
        text_display_end = text_end;
    }

    if (text != text_display_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_display_end);
    }
}

void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = text + strlen(text); // FIXME-OPT

    if (text != text_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_end);
    }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Perform CPU side clipping for single clipped element to avoid using scissor state
    ImVec2 pos = pos_min;
    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

    // Render
    if (need_clipping)
    {
        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
    }
    else
    {
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
    }
}

void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Hide anything after a '##' string
    const char* text_display_end = FindRenderedTextEnd(text, text_end);
    const int text_len = (int)(text_display_end - text);
    if (text_len == 0)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
    if (g.LogEnabled)
        LogRenderedText(&pos_min, text, text_display_end);
}

// Render a rectangle shaped with optional rounding and borders
void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
    const float border_size = g.Style.FrameBorderSize;
    if (border && border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const float border_size = g.Style.FrameBorderSize;
    if (border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
void ImGui::RenderArrow(ImVec2 p_min, ImGuiDir dir, float scale)
{
    ImGuiContext& g = *GImGui;

    const float h = g.FontSize * 1.00f;
    float r = h * 0.40f * scale;
    ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);

    ImVec2 a, b, c;
    switch (dir)
    {
    case ImGuiDir_Up:
    case ImGuiDir_Down:
        if (dir == ImGuiDir_Up) r = -r;
        a = ImVec2(+0.000f,+0.750f) * r;
        b = ImVec2(-0.866f,-0.750f) * r;
        c = ImVec2(+0.866f,-0.750f) * r;
        break;
    case ImGuiDir_Left:
    case ImGuiDir_Right:
        if (dir == ImGuiDir_Left) r = -r;
        a = ImVec2(+0.750f,+0.000f) * r;
        b = ImVec2(-0.750f,+0.866f) * r;
        c = ImVec2(-0.750f,-0.866f) * r;
        break;
    case ImGuiDir_None:
    case ImGuiDir_COUNT:
        IM_ASSERT(0);
        break;
    }

    g.CurrentWindow->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Text));
}

void ImGui::RenderBullet(ImVec2 pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddCircleFilled(pos, g.FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);
}

void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    float thickness = ImMax(sz / 5.0f, 1.0f);
    sz -= thickness*0.5f;
    pos += ImVec2(thickness*0.25f, thickness*0.25f);

    float third = sz / 3.0f;
    float bx = pos.x + third;
    float by = pos.y + sz - third*0.5f;
    window->DrawList->PathLineTo(ImVec2(bx - third, by - third));
    window->DrawList->PathLineTo(ImVec2(bx, by));
    window->DrawList->PathLineTo(ImVec2(bx + third*2, by - third*2));
    window->DrawList->PathStroke(col, false, thickness);
}

void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (id != g.NavId)
        return;
    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
        return;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->DC.NavHideHighlightOneFrame)
        return;

    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
    ImRect display_rect = bb;
    display_rect.ClipWith(window->ClipRect);
    if (flags & ImGuiNavHighlightFlags_TypeDefault)
    {
        const float THICKNESS = 2.0f;
        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
        display_rect.Expand(ImVec2(DISTANCE,DISTANCE));
        bool fully_visible = window->ClipRect.Contains(display_rect);
        if (!fully_visible)
            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), display_rect.Max - ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);
        if (!fully_visible)
            window->DrawList->PopClipRect();
    }
    if (flags & ImGuiNavHighlightFlags_TypeThin)
    {
        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, ~0, 1.0f);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)
    : DrawListInst(&context->DrawListSharedData)
{
    Name = ImStrdup(name);
    ID = ImHashStr(name, 0);
    IDStack.push_back(ID);
    Flags = ImGuiWindowFlags_None;
    Pos = ImVec2(0.0f, 0.0f);
    Size = SizeFull = ImVec2(0.0f, 0.0f);
    SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);
    WindowPadding = ImVec2(0.0f, 0.0f);
    WindowRounding = 0.0f;
    WindowBorderSize = 0.0f;
    NameBufLen = (int)strlen(name) + 1;
    MoveId = GetID("#MOVE");
    ChildId = 0;
    Scroll = ImVec2(0.0f, 0.0f);
    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
    ScrollbarSizes = ImVec2(0.0f, 0.0f);
    ScrollbarX = ScrollbarY = false;
    Active = WasActive = false;
    WriteAccessed = false;
    Collapsed = false;
    WantCollapseToggle = false;
    SkipItems = false;
    Appearing = false;
    Hidden = false;
    HasCloseButton = false;
    ResizeBorderHeld = -1;
    BeginCount = 0;
    BeginOrderWithinParent = -1;
    BeginOrderWithinContext = -1;
    PopupId = 0;
    AutoFitFramesX = AutoFitFramesY = -1;
    AutoFitOnlyGrows = false;
    AutoFitChildAxises = 0x00;
    AutoPosLastDirection = ImGuiDir_None;
    HiddenFramesRegular = HiddenFramesForResize = 0;
    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);

    LastFrameActive = -1;
    ItemWidthDefault = 0.0f;
    FontWindowScale = 1.0f;
    SettingsIdx = -1;

    DrawList = &DrawListInst;
    DrawList->_OwnerName = Name;
    ParentWindow = NULL;
    RootWindow = NULL;
    RootWindowForTitleBarHighlight = NULL;
    RootWindowForNav = NULL;

    NavLastIds[0] = NavLastIds[1] = 0;
    NavRectRel[0] = NavRectRel[1] = ImRect();
    NavLastChildNavWindow = NULL;

    FocusIdxAllCounter = FocusIdxTabCounter = -1;
    FocusIdxAllRequestCurrent = FocusIdxTabRequestCurrent = INT_MAX;
    FocusIdxAllRequestNext = FocusIdxTabRequestNext = INT_MAX;
}

ImGuiWindow::~ImGuiWindow()
{
    IM_ASSERT(DrawList == &DrawListInst);
    IM_DELETE(Name);
    for (int i = 0; i != ColumnsStorage.Size; i++)
        ColumnsStorage[i].~ImGuiColumnsSet();
}

ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
    ImGui::KeepAliveID(id);
    return id;
}

ImGuiID ImGuiWindow::GetID(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);
    ImGui::KeepAliveID(id);
    return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    return ImHashStr(str, str_end ? (str_end - str) : 0, seed);
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    return ImHashData(&ptr, sizeof(void*), seed);
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)
{
    ImGuiID seed = IDStack.back();
    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };
    ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);
    ImGui::KeepAliveID(id);
    return id;
}

static void SetCurrentWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow = window;
    if (window)
        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::SetNavID(ImGuiID id, int nav_layer)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindow);
    IM_ASSERT(nav_layer == 0 || nav_layer == 1);
    g.NavId = id;
    g.NavWindow->NavLastIds[nav_layer] = id;
}

void ImGui::SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel)
{
    ImGuiContext& g = *GImGui;
    SetNavID(id, nav_layer);
    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
    g.NavMousePosDirty = true;
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = true;
}

void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.ActiveIdIsJustActivated = (g.ActiveId != id);
    if (g.ActiveIdIsJustActivated)
    {
        g.ActiveIdTimer = 0.0f;
        g.ActiveIdHasBeenPressed = false;
        g.ActiveIdHasBeenEdited = false;
        if (id != 0)
        {
            g.LastActiveId = id;
            g.LastActiveIdTimer = 0.0f;
        }
    }
    g.ActiveId = id;
    g.ActiveIdAllowNavDirFlags = 0;
    g.ActiveIdBlockNavInputFlags = 0;
    g.ActiveIdAllowOverlap = false;
    g.ActiveIdWindow = window;
    if (id)
    {
        g.ActiveIdIsAlive = id;
        g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
    }
}

// FIXME-NAV: The existence of SetNavID/SetNavIDWithRectRel/SetFocusID is incredibly messy and confusing and needs some explanation or refactoring.
void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(id != 0);

    // Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.
    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
    if (g.NavWindow != window)
        g.NavInitRequest = false;
    g.NavId = id;
    g.NavWindow = window;
    g.NavLayer = nav_layer;
    window->NavLastIds[nav_layer] = id;
    if (window->DC.LastItemId == id)
        window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);

    if (g.ActiveIdSource == ImGuiInputSource_Nav)
        g.NavDisableMouseHover = true;
    else
        g.NavDisableHighlight = true;
}

void ImGui::ClearActiveID()
{
    SetActiveID(0, NULL);
}

void ImGui::SetHoveredID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.HoveredId = id;
    g.HoveredIdAllowOverlap = false;
    if (id != 0 && g.HoveredIdPreviousFrame != id)
        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

ImGuiID ImGui::GetHoveredID()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void ImGui::KeepAliveID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
        g.ActiveIdIsAlive = id;
    if (g.ActiveIdPreviousFrame == id)
        g.ActiveIdPreviousFrameIsAlive = true;
}

void ImGui::MarkItemEdited(ImGuiID id)
{
    // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);
    IM_UNUSED(id); // Avoid unused variable warnings when asserts are compiled out.
    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
    g.ActiveIdHasBeenEdited = true;
    g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;
}

static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
{
    // An active popup disable hovering on other windows (apart from its own children)
    // FIXME-OPT: This could be cached/stored within the window.
    ImGuiContext& g = *GImGui;
    if (g.NavWindow)
        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)
            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)
            {
                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
                // NB: The order of those two tests is important because Modal windows are also Popups.
                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
                    return false;
                if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
                    return false;
            }

    return true;
}

// Advance cursor given item size for layout.
void ImGui::ItemSize(const ImVec2& size, float text_offset_y)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    // Always align ourselves on pixel boundaries
    const float line_height = ImMax(window->DC.CurrentLineSize.y, size.y);
    const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);
    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y);
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

    window->DC.PrevLineSize.y = line_height;
    window->DC.PrevLineTextBaseOffset = text_base_offset;
    window->DC.CurrentLineSize.y = window->DC.CurrentLineTextBaseOffset = 0.0f;

    // Horizontal layout mode
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
        SameLine();
}

void ImGui::ItemSize(const ImRect& bb, float text_offset_y)
{
    ItemSize(bb.GetSize(), text_offset_y);
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().
bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (id != 0)
    {
        // Navigation processing runs prior to clipping early-out
        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.
        //      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)
        window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;
        if (g.NavId == id || g.NavAnyRequest)
            if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
                if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
                    NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);
    }

    window->DC.LastItemId = id;
    window->DC.LastItemRect = bb;
    window->DC.LastItemStatusFlags = ImGuiItemStatusFlags_None;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    if (id != 0)
        ImGuiTestEngineHook_ItemAdd(&g, nav_bb_arg ? *nav_bb_arg : bb, id);
#endif

    // Clipping test
    const bool is_clipped = IsClippedEx(bb, id, false);
    if (is_clipped)
        return false;
    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]

    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
    if (IsMouseHoveringRect(bb.Min, bb.Max))
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    return true;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavDisableMouseHover && !g.NavDisableHighlight)
        return IsItemFocused();

    // Test for bounding box overlap, as updated as ItemAdd()
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function

    // Test if we are hovering the right window (our window could be behind another window)
    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.
    // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.
    //if (g.HoveredWindow != window)
    //    return false;
    if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))
        return false;

    // Test if another item is active (e.g. being dragged)
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)
            return false;

    // Test if interactions on this window are blocked by an active popup or modal
    if (!IsWindowContentHoverable(window, flags))
        return false;

    // Test if the item is disabled
    if ((window->DC.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
        return false;

    // Special handling for the dummy item after Begin() which represent the title bar or tab. 
    // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
    if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)
        return false;
    return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow != window)
        return false;
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        return false;
    if (!IsMouseHoveringRect(bb.Min, bb.Max))
        return false;
    if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
        return false;
    if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)
        return false;

    SetHoveredID(id);
    return true;
}

bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!bb.Overlaps(window->ClipRect))
        if (id == 0 || id != g.ActiveId)
            if (clip_even_when_logged || !g.LogEnabled)
                return true;
    return false;
}

bool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop)
{
    ImGuiContext& g = *GImGui;

    const bool is_tab_stop = (window->DC.ItemFlags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;
    window->FocusIdxAllCounter++;
    if (is_tab_stop)
        window->FocusIdxTabCounter++;

    // Process keyboard input at this point: TAB/Shift-TAB to tab out of the currently focused item.
    // Note that we can always TAB out of a widget that doesn't allow tabbing in.
    if (tab_stop && (g.ActiveId == id) && window->FocusIdxAllRequestNext == INT_MAX && window->FocusIdxTabRequestNext == INT_MAX && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab))
        window->FocusIdxTabRequestNext = window->FocusIdxTabCounter + (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.

    if (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent)
        return true;
    if (is_tab_stop && window->FocusIdxTabCounter == window->FocusIdxTabRequestCurrent)
    {
        g.NavJustTabbedId = id;
        return true;
    }

    return false;
}

void ImGui::FocusableItemUnregister(ImGuiWindow* window)
{
    window->FocusIdxAllCounter--;
    window->FocusIdxTabCounter--;
}

ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)
{
    ImGuiContext& g = *GImGui;
    ImVec2 content_max;
    if (size.x < 0.0f || size.y < 0.0f)
        content_max = g.CurrentWindow->Pos + GetContentRegionMax();
    if (size.x <= 0.0f)
        size.x = (size.x == 0.0f) ? default_x : ImMax(content_max.x - g.CurrentWindow->DC.CursorPos.x, 4.0f) + size.x;
    if (size.y <= 0.0f)
        size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;
    return size;
}

float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
{
    if (wrap_pos_x < 0.0f)
        return 0.0f;

    ImGuiWindow* window = GetCurrentWindowRead();
    if (wrap_pos_x == 0.0f)
        wrap_pos_x = GetContentRegionMax().x + window->Pos.x;
    else if (wrap_pos_x > 0.0f)
        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

    return ImMax(wrap_pos_x - pos.x, 1.0f);
}

void* ImGui::MemAlloc(size_t size)
{
    if (ImGuiContext* ctx = GImGui)
        ctx->IO.MetricsActiveAllocations++;
    return GImAllocatorAllocFunc(size, GImAllocatorUserData);
}

void ImGui::MemFree(void* ptr)
{
    if (ptr)
        if (ImGuiContext* ctx = GImGui)
            ctx->IO.MetricsActiveAllocations--;
    return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);
}

const char* ImGui::GetClipboardText()
{
    return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";
}

void ImGui::SetClipboardText(const char* text)
{
    if (GImGui->IO.SetClipboardTextFn)
        GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);
}

const char* ImGui::GetVersion()
{
    return IMGUI_VERSION;
}

// Internal state access - if you want to share ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
ImGuiContext* ImGui::GetCurrentContext()
{
    return GImGui;
}

void ImGui::SetCurrentContext(ImGuiContext* ctx)
{
#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
#else
    GImGui = ctx;
#endif
}

// Helper function to verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If the user has inconsistent compilation settings, imgui configuration #define, packing pragma, etc. you may see different structures from what imgui.cpp sees which is highly problematic.
bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert)
{
    bool error = false;
    if (strcmp(version, IMGUI_VERSION)!=0) { error = true; IM_ASSERT(strcmp(version,IMGUI_VERSION)==0 && "Mismatched version string!");  }
    if (sz_io    != sizeof(ImGuiIO))       { error = true; IM_ASSERT(sz_io    == sizeof(ImGuiIO)      && "Mismatched struct layout!"); }
    if (sz_style != sizeof(ImGuiStyle))    { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle)   && "Mismatched struct layout!"); }
    if (sz_vec2  != sizeof(ImVec2))        { error = true; IM_ASSERT(sz_vec2  == sizeof(ImVec2)       && "Mismatched struct layout!"); }
    if (sz_vec4  != sizeof(ImVec4))        { error = true; IM_ASSERT(sz_vec4  == sizeof(ImVec4)       && "Mismatched struct layout!"); }
    if (sz_vert  != sizeof(ImDrawVert))    { error = true; IM_ASSERT(sz_vert  == sizeof(ImDrawVert)   && "Mismatched struct layout!"); }
    return !error;
}

void ImGui::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data)
{
    GImAllocatorAllocFunc = alloc_func;
    GImAllocatorFreeFunc = free_func;
    GImAllocatorUserData = user_data;
}

ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
{
    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
    if (GImGui == NULL)
        SetCurrentContext(ctx);
    Initialize(ctx);
    return ctx;
}

void ImGui::DestroyContext(ImGuiContext* ctx)
{
    if (ctx == NULL)
        ctx = GImGui;
    Shutdown(ctx);
    if (GImGui == ctx)
        SetCurrentContext(NULL);
    IM_DELETE(ctx);
}

ImGuiIO& ImGui::GetIO()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    return GImGui->IO;
}

ImGuiStyle& ImGui::GetStyle()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    return GImGui->Style;
}

// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()
ImDrawData* ImGui::GetDrawData()
{
    ImGuiContext& g = *GImGui;
    return g.DrawData.Valid ? &g.DrawData : NULL;
}

double ImGui::GetTime()
{
    return GImGui->Time;
}

int ImGui::GetFrameCount()
{
    return GImGui->FrameCount;
}

static ImDrawList* GetOverlayDrawList(ImGuiWindow*)
{
    // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'viewport' branches.
    return &GImGui->OverlayDrawList;
}

ImDrawList* ImGui::GetOverlayDrawList()
{
    return &GImGui->OverlayDrawList;
}

ImDrawListSharedData* ImGui::GetDrawListSharedData()
{
    return &GImGui->DrawListSharedData;
}

void ImGui::StartMouseMovingWindow(ImGuiWindow* window)
{
    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
    // This is because we want ActiveId to be set even when the window is not permitted to move.
    ImGuiContext& g = *GImGui;
    FocusWindow(window);
    SetActiveID(window->MoveId, window);
    g.NavDisableHighlight = true;
    g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;

    bool can_move_window = true;
    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindow->Flags & ImGuiWindowFlags_NoMove))
        can_move_window = false;
    if (can_move_window)
        g.MovingWindow = window;
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
void ImGui::UpdateMouseMovingWindowNewFrame()
{
    ImGuiContext& g = *GImGui;
    if (g.MovingWindow != NULL)
    {
        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
        KeepAliveID(g.ActiveId);
        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
        ImGuiWindow* moving_window = g.MovingWindow->RootWindow;
        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))
        {
            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
            {
                MarkIniSettingsDirty(moving_window);
                SetWindowPos(moving_window, pos, ImGuiCond_Always);
            }
            FocusWindow(g.MovingWindow);
        }
        else
        {
            ClearActiveID();
            g.MovingWindow = NULL;
        }
    }
    else
    {
        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        {
            KeepAliveID(g.ActiveId);
            if (!g.IO.MouseDown[0])
                ClearActiveID();
        }
    }
}

// Initiate moving window, handle left-click and right-click focus
void ImGui::UpdateMouseMovingWindowEndFrame()
{
    // Initiate moving window
    ImGuiContext& g = *GImGui;
    if (g.ActiveId != 0 || g.HoveredId != 0)
        return;

    // Unless we just made a window/popup appear
    if (g.NavWindow && g.NavWindow->Appearing)
        return;

    // Click to focus window and start moving (after we're done with all our widgets)
    if (g.IO.MouseClicked[0])
    {
        if (g.HoveredRootWindow != NULL)
        {
            StartMouseMovingWindow(g.HoveredWindow);
            if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(g.HoveredRootWindow->Flags & ImGuiWindowFlags_NoTitleBar))
                if (!g.HoveredRootWindow->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
                    g.MovingWindow = NULL;
        }
        else if (g.NavWindow != NULL && GetFrontMostPopupModal() == NULL)
        {
            // Clicking on void disable focus
            FocusWindow(NULL);
        }
    }

    // With right mouse button we close popups without changing focus
    // (The left mouse button path calls FocusWindow which will lead NewFrame->ClosePopupsOverWindow to trigger)
    if (g.IO.MouseClicked[1])
    {
        // Find the top-most window between HoveredWindow and the front most Modal Window.
        // This is where we can trim the popup stack.
        ImGuiWindow* modal = GetFrontMostPopupModal();
        bool hovered_window_above_modal = false;
        if (modal == NULL)
            hovered_window_above_modal = true;
        for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)
        {
            ImGuiWindow* window = g.Windows[i];
            if (window == modal)
                break;
            if (window == g.HoveredWindow)
                hovered_window_above_modal = true;
        }
        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal);
    }
}

static bool IsWindowActiveAndVisible(ImGuiWindow* window)
{
    return (window->Active) && (!window->Hidden);
}

static void ImGui::UpdateMouseInputs()
{
    ImGuiContext& g = *GImGui;

    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
    if (IsMousePosValid(&g.IO.MousePos))
        g.IO.MousePos = g.LastValidMousePos = ImFloor(g.IO.MousePos);

    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))
        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;
    else
        g.IO.MouseDelta = ImVec2(0.0f, 0.0f);
    if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)
        g.NavDisableMouseHover = false;

    g.IO.MousePosPrev = g.IO.MousePos;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;
        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;
        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];
        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;
        g.IO.MouseDoubleClicked[i] = false;
        if (g.IO.MouseClicked[i])
        {
            if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)
            {
                ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
                if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)
                    g.IO.MouseDoubleClicked[i] = true;
                g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click
            }
            else
            {
                g.IO.MouseClickedTime[i] = g.Time;
            }
            g.IO.MouseClickedPos[i] = g.IO.MousePos;
            g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;
        }
        else if (g.IO.MouseDown[i])
        {
            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
            ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
        }
        if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
            g.NavDisableMouseHover = false;
    }
}

void ImGui::UpdateMouseWheel()
{
    ImGuiContext& g = *GImGui;
    if (!g.HoveredWindow || g.HoveredWindow->Collapsed)
        return;
    if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)
        return;

    // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).
    ImGuiWindow* window = g.HoveredWindow;
    ImGuiWindow* scroll_window = window;
    while ((scroll_window->Flags & ImGuiWindowFlags_ChildWindow) && (scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoScrollbar) && !(scroll_window->Flags & ImGuiWindowFlags_NoMouseInputs) && scroll_window->ParentWindow)
        scroll_window = scroll_window->ParentWindow;
    const bool scroll_allowed = !(scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoMouseInputs);

    if (g.IO.MouseWheel != 0.0f)
    {
        if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
        {
            // Zoom / Scale window
            const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
            const float scale = new_font_scale / window->FontWindowScale;
            window->FontWindowScale = new_font_scale;

            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
            window->Pos += offset;
            window->Size *= scale;
            window->SizeFull *= scale;
        }
        else if (!g.IO.KeyCtrl && scroll_allowed)
        {
            // Mouse wheel vertical scrolling
            float scroll_amount = 5 * scroll_window->CalcFontSize();
            scroll_amount = (float)(int)ImMin(scroll_amount, (scroll_window->ContentsRegionRect.GetHeight() + scroll_window->WindowPadding.y * 2.0f) * 0.67f);
            SetWindowScrollY(scroll_window, scroll_window->Scroll.y - g.IO.MouseWheel * scroll_amount);
        }
    }
    if (g.IO.MouseWheelH != 0.0f && scroll_allowed && !g.IO.KeyCtrl)
    {
        // Mouse wheel horizontal scrolling (for hardware that supports it)
        float scroll_amount = scroll_window->CalcFontSize();
        SetWindowScrollX(scroll_window, scroll_window->Scroll.x - g.IO.MouseWheelH * scroll_amount);
    }
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
void ImGui::UpdateHoveredWindowAndCaptureFlags()
{
    ImGuiContext& g = *GImGui;

    // Find the window hovered by mouse:
    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
    FindHoveredWindow();

    // Modal windows prevents cursor from hovering behind them.
    ImGuiWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window)
        if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))
            g.HoveredRootWindow = g.HoveredWindow = NULL;

    // Disabled mouse?
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
    int mouse_earliest_button_down = -1;
    bool mouse_any_down = false;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        if (g.IO.MouseClicked[i])
            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());
        mouse_any_down |= g.IO.MouseDown[i];
        if (g.IO.MouseDown[i])
            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])
                mouse_earliest_button_down = i;
    }
    const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
    if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to imgui + app)
    if (g.WantCaptureMouseNextFrame != -1)
        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);
    else
        g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());

    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to imgui + app)
    if (g.WantCaptureKeyboardNextFrame != -1)
        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    else
        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
    if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
        g.IO.WantCaptureKeyboard = true;

    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

void ImGui::NewFrame()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    ImGuiContext& g = *GImGui;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiTestEngineHook_PreNewFrame(&g);
#endif

    // Check user data
    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    IM_ASSERT(g.Initialized);
    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0                                && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded()                          && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)!");
    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    for (int n = 0; n < ImGuiKey_COUNT; n++)
        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");

    // Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)
        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");

    // Perform simple check: the beta io.ConfigWindowsResizeFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
        g.IO.ConfigWindowsResizeFromEdges = false;

    // Load settings on first frame (if not explicitly loaded manually before)
    if (!g.SettingsLoaded)
    {
        IM_ASSERT(g.SettingsWindows.empty());
        if (g.IO.IniFilename)
            LoadIniSettingsFromDisk(g.IO.IniFilename);
        g.SettingsLoaded = true;
    }

    // Save settings (with a delay after the last modification, so we don't spam disk too much)
    if (g.SettingsDirtyTimer > 0.0f)
    {
        g.SettingsDirtyTimer -= g.IO.DeltaTime;
        if (g.SettingsDirtyTimer <= 0.0f)
        {
            if (g.IO.IniFilename != NULL)
                SaveIniSettingsToDisk(g.IO.IniFilename);
            else
                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
            g.SettingsDirtyTimer = 0.0f;
        }
    }

    g.Time += g.IO.DeltaTime;
    g.FrameScopeActive = true;
    g.FrameCount += 1;
    g.TooltipOverrideCount = 0;
    g.WindowsActiveCount = 0;

    // Setup current font and draw list shared data
    g.IO.Fonts->Locked = true;
    SetCurrentFont(GetDefaultFont());
    IM_ASSERT(g.Font->IsLoaded());
    g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;

    g.OverlayDrawList.Clear();
    g.OverlayDrawList.PushTextureID(g.IO.Fonts->TexID);
    g.OverlayDrawList.PushClipRectFullScreen();
    g.OverlayDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
    g.DrawData.Clear();

    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        KeepAliveID(g.DragDropPayload.SourceId);

    // Clear reference to active widget if the widget isn't alive anymore
    if (!g.HoveredIdPreviousFrame)
        g.HoveredIdTimer = 0.0f;
    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
        g.HoveredIdNotActiveTimer = 0.0f;
    if (g.HoveredId)
        g.HoveredIdTimer += g.IO.DeltaTime;
    if (g.HoveredId && g.ActiveId != g.HoveredId)
        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
    g.HoveredIdPreviousFrame = g.HoveredId;
    g.HoveredId = 0;
    g.HoveredIdAllowOverlap = false;
    if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)
        ClearActiveID();
    if (g.ActiveId)
        g.ActiveIdTimer += g.IO.DeltaTime;
    g.LastActiveIdTimer += g.IO.DeltaTime;
    g.ActiveIdPreviousFrame = g.ActiveId;
    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;
    g.ActiveIdIsAlive = 0;
    g.ActiveIdPreviousFrameIsAlive = false;
    g.ActiveIdIsJustActivated = false;
    if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)
        g.ScalarAsInputTextId = 0;

    // Drag and drop
    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
    g.DragDropAcceptIdCurr = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropWithinSourceOrTarget = false;

    // Update keyboard input state
    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)
        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Update gamepad/keyboard directional navigation
    NavUpdate();

    // Update mouse input state
    UpdateMouseInputs();

    // Calculate frame-rate for the user, as a purely luxurious feature
    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;

    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
    UpdateMouseMovingWindowNewFrame();
    UpdateHoveredWindowAndCaptureFlags();

    // Background darkening/whitening
    if (GetFrontMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
    else
        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

    g.MouseCursor = ImGuiMouseCursor_Arrow;
    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
    g.PlatformImePos = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

    // Mouse wheel scrolling, scale
    UpdateMouseWheel();

    // Pressing TAB activate widget focus
    if (g.ActiveId == 0 && g.NavWindow != NULL && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab, false))
    {
        if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)
            g.NavWindow->FocusIdxTabRequestNext = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);
        else
            g.NavWindow->FocusIdxTabRequestNext = g.IO.KeyShift ? -1 : 0;
    }
    g.NavIdTabCounter = INT_MAX;

    // Mark all windows as not visible
    IM_ASSERT(g.WindowsFocusOrder.Size == g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        window->WasActive = window->Active;
        window->Active = false;
        window->WriteAccessed = false;
    }

    // Closing the focused window restore focus to the first active root window in descending z-order
    if (g.NavWindow && !g.NavWindow->WasActive)
        FocusPreviousWindowIgnoringOne(NULL);

    // No window should be open at the beginning of the frame.
    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
    g.CurrentWindowStack.resize(0);
    g.BeginPopupStack.resize(0);
    ClosePopupsOverWindow(g.NavWindow);

    // Create implicit/fallback window - which we will only render it if the user has added something to it.
    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
    // This fallback is particularly important as it avoid ImGui:: calls from crashing.
    SetNextWindowSize(ImVec2(400,400), ImGuiCond_FirstUseEver);
    Begin("Debug##Default");
    g.FrameScopePushedImplicitWindow = true;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiTestEngineHook_PostNewFrame(&g);
#endif
}

void ImGui::Initialize(ImGuiContext* context)
{
    ImGuiContext& g = *context;
    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);

    // Add .ini handle for ImGuiWindow type
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Window";
    ini_handler.TypeHash = ImHashStr("Window", 0);
    ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;
    ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;
    ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;
    g.SettingsHandlers.push_back(ini_handler);

    g.Initialized = true;
}

// This function is merely here to free heap allocations.
void ImGui::Shutdown(ImGuiContext* context)
{
    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
    ImGuiContext& g = *context;
    if (g.IO.Fonts && g.FontAtlasOwnedByContext)
    {
        g.IO.Fonts->Locked = false;
        IM_DELETE(g.IO.Fonts);
    }
    g.IO.Fonts = NULL;

    // Cleanup of other data are conditional on actually having initialized ImGui.
    if (!g.Initialized)
        return;

    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
    if (g.SettingsLoaded && g.IO.IniFilename != NULL)
    {
        ImGuiContext* backup_context = GImGui;
        SetCurrentContext(context);
        SaveIniSettingsToDisk(g.IO.IniFilename);
        SetCurrentContext(backup_context);
    }

    // Clear everything else
    for (int i = 0; i < g.Windows.Size; i++)
        IM_DELETE(g.Windows[i]);
    g.Windows.clear();
    g.WindowsFocusOrder.clear();
    g.WindowsSortBuffer.clear();
    g.CurrentWindow = NULL;
    g.CurrentWindowStack.clear();
    g.WindowsById.Clear();
    g.NavWindow = NULL;
    g.HoveredWindow = g.HoveredRootWindow = NULL;
    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
    g.MovingWindow = NULL;
    g.ColorModifiers.clear();
    g.StyleModifiers.clear();
    g.FontStack.clear();
    g.OpenPopupStack.clear();
    g.BeginPopupStack.clear();
    g.DrawDataBuilder.ClearFreeMemory();
    g.OverlayDrawList.ClearFreeMemory();
    g.PrivateClipboard.clear();
    g.InputTextState.ClearFreeMemory();

    for (int i = 0; i < g.SettingsWindows.Size; i++)
        IM_DELETE(g.SettingsWindows[i].Name);
    g.SettingsWindows.clear();
    g.SettingsHandlers.clear();

    if (g.LogFile && g.LogFile != stdout)
    {
        fclose(g.LogFile);
        g.LogFile = NULL;
    }
    g.LogClipboard.clear();

    g.Initialized = false;
}

// FIXME: Add a more explicit sort order in the window structure.
static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
{
    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
        return d;
    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
        return d;
    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
{
    out_sorted_windows->push_back(window);
    if (window->Active)
    {
        int count = window->DC.ChildWindows.Size;
        if (count > 1)
            ImQsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
        for (int i = 0; i < count; i++)
        {
            ImGuiWindow* child = window->DC.ChildWindows[i];
            if (child->Active)
                AddWindowToSortBuffer(out_sorted_windows, child);
        }
    }
}

static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
{
    if (draw_list->CmdBuffer.empty())
        return;

    // Remove trailing command if unused
    ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();
    if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)
    {
        draw_list->CmdBuffer.pop_back();
        if (draw_list->CmdBuffer.empty())
            return;
    }

    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.
    //IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    //IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
   
	// Commented this asserts because they dont like our custom drawlist
	
	IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
    // If this assert triggers because you are drawing lots of stuff manually:
    // A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.
    // B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.
    //    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:
    //      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
    //    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.
    // C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.
    if (sizeof(ImDrawIdx) == 2)
        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");

    out_list->push_back(draw_list);
}

static void AddWindowToDrawData(ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.IO.MetricsRenderWindows++;
    AddDrawListToDrawData(out_render_list, window->DrawList);
    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
    {
        ImGuiWindow* child = window->DC.ChildWindows[i];
        if (IsWindowActiveAndVisible(child)) // clipped children may have been marked not active
            AddWindowToDrawData(out_render_list, child);
    }
}

static void AddRootWindowToDrawData(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (window->Flags & ImGuiWindowFlags_Tooltip)
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);
    else
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
    int n = Layers[0].Size;
    int size = n;
    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
        size += Layers[i].Size;
    Layers[0].resize(size);
    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
    {
        ImVector<ImDrawList*>& layer = Layers[layer_n];
        if (layer.empty())
            continue;
        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
        n += layer.Size;
        layer.resize(0);
    }
}

static void SetupDrawData(ImVector<ImDrawList*>* draw_lists, ImDrawData* draw_data)
{
    ImGuiIO& io = ImGui::GetIO();
    draw_data->Valid = true;
    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
    draw_data->CmdListsCount = draw_lists->Size;
    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
    draw_data->DisplayPos = ImVec2(0.0f, 0.0f);
    draw_data->DisplaySize = io.DisplaySize;
    draw_data->FramebufferScale = io.DisplayFramebufferScale;
    for (int n = 0; n < draw_lists->Size; n++)
    {
        draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;
        draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;
    }
}

// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.
void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PopClipRect();
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void ImGui::EndFrame()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.
        return;
    IM_ASSERT(g.FrameScopeActive && "Forgot to call ImGui::NewFrame()?");

    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
    if (g.IO.ImeSetInputScreenPosFn && (g.PlatformImeLastPos.x == FLT_MAX || ImLengthSqr(g.PlatformImeLastPos - g.PlatformImePos) > 0.0001f))
    {
        g.IO.ImeSetInputScreenPosFn((int)g.PlatformImePos.x, (int)g.PlatformImePos.y);
        g.PlatformImeLastPos = g.PlatformImePos;
    }

    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
    if (g.CurrentWindowStack.Size != 1)
    {
        if (g.CurrentWindowStack.Size > 1)
        {
            IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
            while (g.CurrentWindowStack.Size > 1) // FIXME-ERRORHANDLING
                End();
        }
        else
        {
            IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
        }
    }

    // Hide implicit/fallback "Debug" window if it hasn't been used
    g.FrameScopePushedImplicitWindow = false;
    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
        g.CurrentWindow->Active = false;
    End();

    // Show CTRL+TAB list window
    if (g.NavWindowingTarget)
        NavUpdateWindowingList();

    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    if (g.DragDropActive)
    {
        bool is_delivered = g.DragDropPayload.Delivery;
        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        if (is_delivered || is_elapsed)
            ClearDragDrop();
    }

    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)
    {
        g.DragDropWithinSourceOrTarget = true;
        SetTooltip("...");
        g.DragDropWithinSourceOrTarget = false;
    }

    // End frame
    g.FrameScopeActive = false;
    g.FrameCountEnded = g.FrameCount;

    // Initiate moving window + handle left-click and right-click focus
    UpdateMouseMovingWindowEndFrame();

    // Sort the window list so that all child windows are after their parent
    // We cannot do that on FocusWindow() because childs may not exist yet
    g.WindowsSortBuffer.resize(0);
    g.WindowsSortBuffer.reserve(g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
            continue;
        AddWindowToSortBuffer(&g.WindowsSortBuffer, window);
    }

    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
    IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);
    g.Windows.swap(g.WindowsSortBuffer);
    g.IO.MetricsActiveWindows = g.WindowsActiveCount;

    // Unlock font atlas
    g.IO.Fonts->Locked = false;

    // Clear Input data for next frame
    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
    g.IO.InputQueueCharacters.resize(0);
    memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));
}

void ImGui::Render(ImDrawList* our_list)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);

    if (g.FrameCountEnded != g.FrameCount)
        EndFrame();
    g.FrameCountRendered = g.FrameCount;

    // Gather ImDrawList to render (for each active window)
    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsRenderWindows = 0;
    g.DrawDataBuilder.Clear();

	// Adding our custom drawlist to imgui's drawdata
	if (our_list && !our_list->VtxBuffer.empty())
		AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], our_list);

    ImGuiWindow* windows_to_render_front_most[2];
    windows_to_render_front_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;
    windows_to_render_front_most[1] = g.NavWindowingTarget ? g.NavWindowingList : NULL;
    for (int n = 0; n != g.Windows.Size; n++)
    {
        ImGuiWindow* window = g.Windows[n];
        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_front_most[0] && window != windows_to_render_front_most[1])
            AddRootWindowToDrawData(window);
    }
    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_front_most); n++)
        if (windows_to_render_front_most[n] && IsWindowActiveAndVisible(windows_to_render_front_most[n])) // NavWindowingTarget is always temporarily displayed as the front-most window
            AddRootWindowToDrawData(windows_to_render_front_most[n]);
    g.DrawDataBuilder.FlattenIntoSingleLayer();

    // Draw software mouse cursor if requested
    if (g.IO.MouseDrawCursor)
        RenderMouseCursor(&g.OverlayDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor);

    if (!g.OverlayDrawList.VtxBuffer.empty())
        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.OverlayDrawList);

    // Setup ImDrawData structure for end-user
    SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);
    g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;
    g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;

    // (Legacy) Call the Render callback function. The current prefer way is to let the user retrieve GetDrawData() and call the render function themselves.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)
        g.IO.RenderDrawListsFn(&g.DrawData);
#endif
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, GImGui->FontSize)
ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
{
    ImGuiContext& g = *GImGui;

    const char* text_display_end;
    if (hide_text_after_double_hash)
        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
    else
        text_display_end = text_end;

    ImFont* font = g.Font;
    const float font_size = g.FontSize;
    if (text == text_display_end)
        return ImVec2(0.0f, font_size);
    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

    // Round
    text_size.x = (float)(int)(text_size.x + 0.95f);

    return text_size;
}

// Helper to calculate coarse clipping of large list of evenly sized items.
// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.
// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX
void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.LogEnabled)
    {
        // If logging is active, do not perform any clipping
        *out_items_display_start = 0;
        *out_items_display_end = items_count;
        return;
    }
    if (window->SkipItems)
    {
        *out_items_display_start = *out_items_display_end = 0;
        return;
    }

    // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect
    ImRect unclipped_rect = window->ClipRect;
    if (g.NavMoveRequest)
        unclipped_rect.Add(g.NavScoringRectScreen);

    const ImVec2 pos = window->DC.CursorPos;
    int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);
    int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);

    // When performing a navigation request, ensure we have one item extra in the direction we are moving to
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up)
        start--;
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down)
        end++;

    start = ImClamp(start, 0, items_count);
    end = ImClamp(end + 1, start, items_count);
    *out_items_display_start = start;
    *out_items_display_end = end;
}

// Find window given position, search front-to-back
// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programatically
// with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
// called, aka before the next Begin(). Moving window isn't affected.
static void FindHoveredWindow()
{
    ImGuiContext& g = *GImGui;

    ImGuiWindow* hovered_window = NULL;
    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
        hovered_window = g.MovingWindow;

    ImVec2 padding_regular = g.Style.TouchExtraPadding;
    ImVec2 padding_for_resize_from_edges = g.IO.ConfigWindowsResizeFromEdges ? ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS)) : padding_regular;
    for (int i = g.Windows.Size - 1; i >= 0; i--)
    {
        ImGuiWindow* window = g.Windows[i];
        if (!window->Active || window->Hidden)
            continue;
        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
            continue;

        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
        ImRect bb(window->OuterRectClipped);
        if ((window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_NoResize))
            bb.Expand(padding_regular);
        else
            bb.Expand(padding_for_resize_from_edges);
        if (!bb.Contains(g.IO.MousePos))
            continue;

        // Those seemingly unnecessary extra tests are because the code here is a little different in viewport/docking branches.
        if (hovered_window == NULL)
            hovered_window = window;
        if (hovered_window)
            break;
    }

    g.HoveredWindow = hovered_window;
    g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;

}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
{
    ImGuiContext& g = *GImGui;

    // Clip
    ImRect rect_clipped(r_min, r_max);
    if (clip)
        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

    // Expand for touch input
    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
    if (!rect_for_touch.Contains(g.IO.MousePos))
        return false;
    return true;
}

int ImGui::GetKeyIndex(ImGuiKey imgui_key)
{
    IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);
    return GImGui->IO.KeyMap[imgui_key];
}

// Note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your back-end/engine stored them into io.KeysDown[]!
bool ImGui::IsKeyDown(int user_key_index)
{
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));
    return GImGui->IO.KeysDown[user_key_index];
}

int ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)
{
    if (t == 0.0f)
        return 1;
    if (t <= repeat_delay || repeat_rate <= 0.0f)
        return 0;
    const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);
    return (count > 0) ? count : 0;
}

int ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)
{
    ImGuiContext& g = *GImGui;
    if (key_index < 0) 
        return 0;
    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[key_index];
    return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);
}

bool ImGui::IsKeyPressed(int user_key_index, bool repeat)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0) 
        return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[user_key_index];
    if (t == 0.0f)
        return true;
    if (repeat && t > g.IO.KeyRepeatDelay)
        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
    return false;
}

bool ImGui::IsKeyReleased(int user_key_index)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];
}

bool ImGui::IsMouseDown(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDown[button];
}

bool ImGui::IsAnyMouseDown()
{
    ImGuiContext& g = *GImGui;
    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
        if (g.IO.MouseDown[n])
            return true;
    return false;
}

bool ImGui::IsMouseClicked(int button, bool repeat)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    const float t = g.IO.MouseDownDuration[button];
    if (t == 0.0f)
        return true;

    if (repeat && t > g.IO.KeyRepeatDelay)
    {
        float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;
        if ((ImFmod(t - delay, rate) > rate*0.5f) != (ImFmod(t - delay - g.IO.DeltaTime, rate) > rate*0.5f))
            return true;
    }

    return false;
}

bool ImGui::IsMouseReleased(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseReleased[button];
}

bool ImGui::IsMouseDoubleClicked(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDoubleClicked[button];
}

bool ImGui::IsMouseDragging(int button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (!g.IO.MouseDown[button])
        return false;
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

ImVec2 ImGui::GetMousePos()
{
    return GImGui->IO.MousePos;
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    if (g.BeginPopupStack.Size > 0)
        return g.OpenPopupStack[g.BeginPopupStack.Size-1].OpenMousePos;
    return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
{
    // The assert is only to silence a false-positive in XCode Static Analysis.
    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
    IM_ASSERT(GImGui != NULL);
    const float MOUSE_INVALID = -256000.0f;
    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}

// Return the delta from the initial clicking position.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.
ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    if (g.IO.MouseDown[button])
        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
            return g.IO.MousePos - g.IO.MouseClickedPos[button];     // Assume we can only get active with left-mouse button (at the moment).
    return ImVec2(0.0f, 0.0f);
}

void ImGui::ResetMouseDragDelta(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
    g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

ImGuiMouseCursor ImGui::GetMouseCursor()
{
    return GImGui->MouseCursor;
}

void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
{
    GImGui->MouseCursor = cursor_type;
}

void ImGui::CaptureKeyboardFromApp(bool capture)
{
    GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;
}

void ImGui::CaptureMouseFromApp(bool capture)
{
    GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;
}

bool ImGui::IsItemActive()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
    {
        ImGuiWindow* window = g.CurrentWindow;
        return g.ActiveId == window->DC.LastItemId;
    }
    return false;
}

bool ImGui::IsItemActivated()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
    {
        ImGuiWindow* window = g.CurrentWindow;
        if (g.ActiveId == window->DC.LastItemId && g.ActiveIdPreviousFrame != window->DC.LastItemId)
            return true;
    }
    return false;
}

bool ImGui::IsItemDeactivated()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);
}

bool ImGui::IsItemDeactivatedAfterEdit()
{
    ImGuiContext& g = *GImGui;
    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEdited || (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));
}

bool ImGui::IsItemFocused()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (g.NavId == 0 || g.NavDisableHighlight || g.NavId != window->DC.LastItemId)
        return false;
    return true;
}

bool ImGui::IsItemClicked(int mouse_button)
{
    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
}

bool ImGui::IsAnyItemHovered()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive()
{
    ImGuiContext& g = *GImGui;
    return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused()
{
    ImGuiContext& g = *GImGui;
    return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(window->DC.LastItemRect);
}

bool ImGui::IsItemEdited()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited) != 0;
}

// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
void ImGui::SetItemAllowOverlap()
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId == g.CurrentWindow->DC.LastItemId)
        g.HoveredIdAllowOverlap = true;
    if (g.ActiveId == g.CurrentWindow->DC.LastItemId)
        g.ActiveIdAllowOverlap = true;
}

ImVec2 ImGui::GetItemRectMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Min;
}

ImVec2 ImGui::GetItemRectMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Max;
}

ImVec2 ImGui::GetItemRectSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.GetSize();
}

static ImRect GetViewportRect()
{
    ImGuiContext& g = *GImGui;
    return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
}

static bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;

    flags |= ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_ChildWindow;
    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag

    // Size
    const ImVec2 content_avail = GetContentRegionAvail();
    ImVec2 size = ImFloor(size_arg);
    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
    if (size.x <= 0.0f)
        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    if (size.y <= 0.0f)
        size.y = ImMax(content_avail.y + size.y, 4.0f);
    SetNextWindowSize(size);

    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
    char title[256];
    if (name)
        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
    else
        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

    const float backup_border_size = g.Style.ChildBorderSize;
    if (!border)
        g.Style.ChildBorderSize = 0.0f;
    bool ret = Begin(title, NULL, flags);
    g.Style.ChildBorderSize = backup_border_size;

    ImGuiWindow* child_window = g.CurrentWindow;
    child_window->ChildId = id;
    child_window->AutoFitChildAxises = auto_fit_axises;

    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
    // While this is not really documented/defined, it seems that the expected thing to do.
    if (child_window->BeginCount == 1)
        parent_window->DC.CursorPos = child_window->Pos;

    // Process navigation-in immediately so NavInit can run on first frame
    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))
    {
        FocusWindow(child_window);
        NavInitWindow(child_window, false);
        SetActiveID(id+1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
        g.ActiveIdSource = ImGuiInputSource_Nav;
    }
    return ret;
}

bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    IM_ASSERT(id != 0);
    return BeginChildEx(NULL, id, size_arg, border, extra_flags);
}

void ImGui::EndChild()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
    if (window->BeginCount > 1)
    {
        End();
    }
    else
    {
        ImVec2 sz = window->Size;
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
            sz.x = ImMax(4.0f, sz.x);
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
            sz.y = ImMax(4.0f, sz.y);
        End();

        ImGuiWindow* parent_window = g.CurrentWindow;
        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
        ItemSize(sz);
        if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
        {
            ItemAdd(bb, window->ChildId);
            RenderNavHighlight(bb, window->ChildId);

            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child
            if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
                RenderNavHighlight(ImRect(bb.Min - ImVec2(2,2), bb.Max + ImVec2(2,2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
        }
        else
        {
            // Not navigable into
            ItemAdd(bb, 0);
        }
    }
}

// Helper to create a child window / scrolling region that looks like a normal widget frame.
bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);
    bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);
    PopStyleVar(3);
    PopStyleColor();
    return ret;
}

void ImGui::EndChildFrame()
{
    EndChild();
}

// Save and compare stack sizes on Begin()/End() to detect usage errors
static void CheckStacksSize(ImGuiWindow* window, bool write)
{
    // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
    ImGuiContext& g = *GImGui;
    short* p_backup = &window->DC.StackSizesBackup[0];
    { int current = window->IDStack.Size;       if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "PushID/PopID or TreeNode/TreePop Mismatch!");   p_backup++; }    // Too few or too many PopID()/TreePop()
    { int current = window->DC.GroupStack.Size; if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");                p_backup++; }    // Too few or too many EndGroup()
    { int current = g.BeginPopupStack.Size;     if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++;}// Too few or too many EndMenu()/EndPopup()
    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
    { int current = g.ColorModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleColor/PopStyleColor Mismatch!");       p_backup++; }    // Too few or too many PopStyleColor()
    { int current = g.StyleModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleVar/PopStyleVar Mismatch!");           p_backup++; }    // Too few or too many PopStyleVar()
    { int current = g.FontStack.Size;           if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushFont/PopFont Mismatch!");                   p_backup++; }    // Too few or too many PopFont()
    IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));
}

static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
{
    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
}

ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
}

ImGuiWindow* ImGui::FindWindowByName(const char* name)
{
    ImGuiID id = ImHashStr(name, 0);
    return FindWindowByID(id);
}

static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;

    // Create window the first time
    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
    window->Flags = flags;
    g.WindowsById.SetVoidPtr(window->ID, window);

    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
    window->Pos = ImVec2(60, 60);

    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
        {
            // Retrieve settings from .ini file
            window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);
            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
            window->Pos = ImFloor(settings->Pos);
            window->Collapsed = settings->Collapsed;
            if (ImLengthSqr(settings->Size) > 0.00001f)
                size = ImFloor(settings->Size);
        }
    window->Size = window->SizeFull = window->SizeFullAtLastBegin = ImFloor(size);
    window->DC.CursorMaxPos = window->Pos; // So first call to CalcSizeContents() doesn't return crazy values

    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
    {
        window->AutoFitFramesX = window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
    else
    {
        if (window->Size.x <= 0.0f)
            window->AutoFitFramesX = 2;
        if (window->Size.y <= 0.0f)
            window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
    }

    g.WindowsFocusOrder.push_back(window);
    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
        g.Windows.push_front(window); // Quite slow but rare and only once
    else
        g.Windows.push_back(window);
    return window;
}

static ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)
{
    ImGuiContext& g = *GImGui;
    if (g.NextWindowData.SizeConstraintCond != 0)
    {
        // Using -1,-1 on either X/Y axis to preserve the current size.
        ImRect cr = g.NextWindowData.SizeConstraintRect;
        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        if (g.NextWindowData.SizeCallback)
        {
            ImGuiSizeCallbackData data;
            data.UserData = g.NextWindowData.SizeCallbackUserData;
            data.Pos = window->Pos;
            data.CurrentSize = window->SizeFull;
            data.DesiredSize = new_size;
            g.NextWindowData.SizeCallback(&data);
            new_size = data.DesiredSize;
        }
    }

    // Minimum size
    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
    {
        new_size = ImMax(new_size, g.Style.WindowMinSize);
        new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows
    }
    return new_size;
}

static ImVec2 CalcSizeContents(ImGuiWindow* window)
{
    if (window->Collapsed)
        if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            return window->SizeContents;
    if (window->Hidden && window->HiddenFramesForResize == 0 && window->HiddenFramesRegular > 0)
        return window->SizeContents;

    ImVec2 sz;
    sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));
    sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));
    return sz + window->WindowPadding;
}

static ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Tooltip always resize
        return size_contents;
    }
    else
    {
        // Maximum window size is determined by the display size
        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
        ImVec2 size_min = style.WindowMinSize;
        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));
        ImVec2 size_auto_fit = ImClamp(size_contents, size_min, ImMax(size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f));

        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
        ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);
        if (size_auto_fit_after_constraint.x < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar))
            size_auto_fit.y += style.ScrollbarSize;
        if (size_auto_fit_after_constraint.y < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar))
            size_auto_fit.x += style.ScrollbarSize;
        return size_auto_fit;
    }
}

ImVec2 ImGui::CalcWindowExpectedSize(ImGuiWindow* window)
{
    ImVec2 size_contents = CalcSizeContents(window);
    return CalcSizeAfterConstraint(window, CalcSizeAutoFit(window, size_contents));
}

float ImGui::GetWindowScrollMaxX(ImGuiWindow* window)
{
    return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));
}

float ImGui::GetWindowScrollMaxY(ImGuiWindow* window)
{
    return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));
}

static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges)
{
    ImGuiContext& g = *GImGui;
    ImVec2 scroll = window->Scroll;
    if (window->ScrollTarget.x < FLT_MAX)
    {
        float cr_x = window->ScrollTargetCenterRatio.x;
        scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);
    }
    if (window->ScrollTarget.y < FLT_MAX)
    {
        // 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.
        float cr_y = window->ScrollTargetCenterRatio.y;
        float target_y = window->ScrollTarget.y;
        if (snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y)
            target_y = 0.0f;
        if (snap_on_edges && cr_y >= 1.0f && target_y >= window->SizeContents.y - window->WindowPadding.y + g.Style.ItemSpacing.y)
            target_y = window->SizeContents.y;
        scroll.y = target_y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);
    }
    scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));
    if (!window->Collapsed && !window->SkipItems)
    {
        scroll.x = ImMin(scroll.x, ImGui::GetWindowScrollMaxX(window));
        scroll.y = ImMin(scroll.y, ImGui::GetWindowScrollMaxY(window));
    }
    return scroll;
}

static ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)
{
    if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        return ImGuiCol_PopupBg;
    if (flags & ImGuiWindowFlags_ChildWindow)
        return ImGuiCol_ChildBg;
    return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
{
    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
    ImVec2 size_expected = pos_max - pos_min;
    ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);
    *out_pos = pos_min;
    if (corner_norm.x == 0.0f)
        out_pos->x -= (size_constrained.x - size_expected.x);
    if (corner_norm.y == 0.0f)
        out_pos->y -= (size_constrained.y - size_expected.y);
    *out_size = size_constrained;
}

struct ImGuiResizeGripDef
{
    ImVec2  CornerPosN;
    ImVec2  InnerDir;
    int     AngleMin12, AngleMax12;
};

static const ImGuiResizeGripDef resize_grip_def[4] =
{
    { ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right
    { ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left
    { ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left
    { ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right
};

static ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)
{
    ImRect rect = window->Rect();
    if (thickness == 0.0f) rect.Max -= ImVec2(1,1);
    if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);      // Top
    if (border_n == 1) return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding);   // Right
    if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);      // Bottom
    if (border_n == 3) return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding);   // Left
    IM_ASSERT(0);
    return ImRect();
}

// Handle resize for: Resize Grips, Borders, Gamepad
static void ImGui::UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])
{
    ImGuiContext& g = *GImGui;
    ImGuiWindowFlags flags = window->Flags;
    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        return;
    if (window->WasActive == false) // Early out to avoid running this code for e.g. an hidden implicit/fallback Debug window.
        return;

    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
    const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
    const float grip_hover_inner_size = (float)(int)(grip_draw_size * 0.75f);
    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS : 0.0f;

    ImVec2 pos_target(FLT_MAX, FLT_MAX);
    ImVec2 size_target(FLT_MAX, FLT_MAX);

    // Manual resize grips
    PushID("#RESIZE");
    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
    {
        const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);

        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
        ImRect resize_rect(corner - grip.InnerDir * grip_hover_outer_size, corner + grip.InnerDir * grip_hover_inner_size);
        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
        bool hovered, held;
        ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
        //GetOverlayDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
        if (hovered || held)
            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

        if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)
        {
            // Manual auto-fit when double-clicking
            size_target = CalcSizeAfterConstraint(window, size_auto_fit);
            ClearActiveID();
        }
        else if (held)
        {
            // Resize from any of the four corners
            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(grip.InnerDir * grip_hover_outer_size, grip.InnerDir * -grip_hover_inner_size, grip.CornerPosN); // Corner of the window corresponding to our corner grip
            CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPosN, &pos_target, &size_target);
        }
        if (resize_grip_n == 0 || held || hovered)
            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
    }
    for (int border_n = 0; border_n < resize_border_count; border_n++)
    {
        bool hovered, held;
        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS);
        ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);
        //GetOverlayDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
        {
            g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
            if (held) 
                *border_held = border_n;
        }
        if (held)
        {
            ImVec2 border_target = window->Pos;
            ImVec2 border_posn;
            if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Top
            if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Right
            if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Bottom
            if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Left
            CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);
        }
    }
    PopID();

    // Navigation resize (keyboard/gamepad)
    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)
    {
        ImVec2 nav_resize_delta;
        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_NavGamepad)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);
        if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)
        {
            const float NAV_RESIZE_SPEED = 600.0f;
            nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
            g.NavWindowingToggleLayer = false;
            g.NavDisableMouseHover = true;
            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
            // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
            size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);
        }
    }

    // Apply back modified position/size to window
    if (size_target.x != FLT_MAX)
    {
        window->SizeFull = size_target;
        MarkIniSettingsDirty(window);
    }
    if (pos_target.x != FLT_MAX)
    {
        window->Pos = ImFloor(pos_target);
        MarkIniSettingsDirty(window);
    }

    window->Size = window->SizeFull;
}

static void ImGui::RenderOuterBorders(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    float rounding = window->WindowRounding;
    float border_size = window->WindowBorderSize;
    if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))
        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);

    int border_held = window->ResizeBorderHeld;
    if (border_held != -1)
    {
        struct ImGuiResizeBorderDef
        {
            ImVec2 InnerDir;
            ImVec2 CornerPosN1, CornerPosN2;
            float  OuterAngle;
        };
        static const ImGuiResizeBorderDef resize_border_def[4] =
        {
            { ImVec2(0,+1), ImVec2(0,0), ImVec2(1,0), IM_PI*1.50f }, // Top
            { ImVec2(-1,0), ImVec2(1,0), ImVec2(1,1), IM_PI*0.00f }, // Right
            { ImVec2(0,-1), ImVec2(1,1), ImVec2(0,1), IM_PI*0.50f }, // Bottom
            { ImVec2(+1,0), ImVec2(0,1), ImVec2(0,0), IM_PI*1.00f }  // Left
        };
        const ImGuiResizeBorderDef& def = resize_border_def[border_held];
        ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI*0.25f, def.OuterAngle);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI*0.25f);
        window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), false, ImMax(2.0f, border_size)); // Thicker than usual
    }
    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar))
    {
        float y = window->Pos.y + window->TitleBarHeight() - 1;
        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);
    }
}

void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
{
    window->ParentWindow = parent_window;
    window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
        window->RootWindow = parent_window->RootWindow;
    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))
        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
    {
        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
    }
}

// Push a new ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
    IM_ASSERT(g.FrameScopeActive);                  // Forgot to call ImGui::NewFrame()
    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

    // Find or create
    ImGuiWindow* window = FindWindowByName(name);
    const bool window_just_created = (window == NULL);
    if (window_just_created)
    {
        ImVec2 size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
        window = CreateNewWindow(name, size_on_first_use, flags);
    }

    // Automatically disable manual moving/resizing when NoInputs is set
    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

    if (flags & ImGuiWindowFlags_NavFlattened)
        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);

    const int current_frame = g.FrameCount;
    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

    // Update Flags, LastFrameActive, BeginOrderXXX fields
    if (first_begin_of_the_frame)
        window->Flags = (ImGuiWindowFlags)flags;
    else
        flags = window->Flags;

    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
    window->HasCloseButton = (p_open != NULL);

    // Update the Appearing flag
    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesForResize > 0);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        window_just_activated_by_user |= (window != popup_ref.Window);
    }
    window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);

    // Add to stack
    g.CurrentWindowStack.push_back(window);
    SetCurrentWindow(window);
    CheckStacksSize(window, true);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        popup_ref.Window = window;
        g.BeginPopupStack.push_back(popup_ref);
        window->PopupId = popup_ref.PopupId;
    }

    if (window_just_appearing_after_hidden_for_resize && !(flags & ImGuiWindowFlags_ChildWindow))
        window->NavLastIds[0] = 0;

    // Process SetNextWindow***() calls
    bool window_pos_set_by_api = false;
    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    if (g.NextWindowData.PosCond)
    {
        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
        {
            // May be processed on the next frame if this is our first frame and we are measuring size
            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
            window->SetWindowPosVal = g.NextWindowData.PosVal;
            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        }
        else
        {
            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
        }
    }
    if (g.NextWindowData.SizeCond)
    {
        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    }
    if (g.NextWindowData.ContentSizeCond)
    {
        // Adjust passed "client size" to become a "window size"
        window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
        if (window->SizeContentsExplicit.y != 0.0f)
            window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
    }
    else if (first_begin_of_the_frame)
    {
        window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);
    }
    if (g.NextWindowData.CollapsedCond)
        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    if (g.NextWindowData.FocusCond)
        FocusWindow(window);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);

    // When reusing window again multiple times a frame, just append content (don't need to setup again)
    if (first_begin_of_the_frame)
    {
        // Initialize
        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
        UpdateWindowParentAndRootLinks(window, flags, parent_window);

        window->Active = true;
        window->BeginOrderWithinParent = 0;
        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
        window->BeginCount = 0;
        window->ClipRect = ImVec4(-FLT_MAX,-FLT_MAX,+FLT_MAX,+FLT_MAX);
        window->LastFrameActive = current_frame;
        window->IDStack.resize(1);

        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
        bool window_title_visible_elsewhere = false;
        if (g.NavWindowingList != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
            window_title_visible_elsewhere = true;
        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
        {
            size_t buf_len = (size_t)window->NameBufLen;
            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
            window->NameBufLen = (int)buf_len;
        }

        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

        // Update contents size from last frame for auto-fitting (or use explicit size)
        window->SizeContents = CalcSizeContents(window);
        if (window->HiddenFramesRegular > 0)
            window->HiddenFramesRegular--;
        if (window->HiddenFramesForResize > 0)
            window->HiddenFramesForResize--;

        // Hide new windows for one frame until they calculate their size
        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
            window->HiddenFramesForResize = 1;

        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        // We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
        {
            window->HiddenFramesForResize = 1;
            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
            {
                if (!window_size_x_set_by_api)
                    window->Size.x = window->SizeFull.x = 0.f;
                if (!window_size_y_set_by_api)
                    window->Size.y = window->SizeFull.y = 0.f;
                window->SizeContents = ImVec2(0.f, 0.f);
            }
        }

        SetCurrentWindow(window);

        // Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
        window->WindowBorderSize = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildBorderSize : ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
        window->WindowPadding = style.WindowPadding;
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

        // Collapse window by double-clicking on title bar
        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))
        {
            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
            ImRect title_bar_rect = window->TitleBarRect();
            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
                window->WantCollapseToggle = true;
            if (window->WantCollapseToggle)
            {
                window->Collapsed = !window->Collapsed;
                MarkIniSettingsDirty(window);
                FocusWindow(window);
            }
        }
        else
        {
            window->Collapsed = false;
        }
        window->WantCollapseToggle = false;

        // SIZE

        // Calculate auto-fit size, handle automatic resize
        const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
        ImVec2 size_full_modified(FLT_MAX, FLT_MAX);
        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        {
            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
            if (!window_size_x_set_by_api)
                window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
            if (!window_size_y_set_by_api)
                window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
        }
        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        {
            // Auto-fit may only grow window during the first few frames
            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
                window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
                window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
            if (!window->Collapsed)
                MarkIniSettingsDirty(window);
        }

        // Apply minimum/maximum window size constraints and final size
        window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

        // SCROLLBAR STATUS

        // Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
        if (!window->Collapsed)
        {
            // When reading the current size we need to read it after size constraints have been applied
            float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
            float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
            if (window->ScrollbarX && !window->ScrollbarY)
                window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);
            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
        }

        // POSITION

        // Popup latch its initial position, will position itself when it appears next frame
        if (window_just_activated_by_user)
        {
            window->AutoPosLastDirection = ImGuiDir_None;
            if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)
                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
        }

        // Position child window
        if (flags & ImGuiWindowFlags_ChildWindow)
        {
            IM_ASSERT(parent_window && parent_window->Active);
            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
            parent_window->DC.ChildWindows.push_back(window);
            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
                window->Pos = parent_window->DC.CursorPos;
        }

        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesForResize == 0);
        if (window_pos_with_pivot)
            SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
            window->Pos = FindBestWindowPosForPopup(window);

        // Clamp position so it stays visible
        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
        {
            if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
            {
                ImVec2 padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
                ImVec2 size_for_clamping = ((g.IO.ConfigWindowsMoveFromTitleBarOnly) && !(window->Flags & ImGuiWindowFlags_NoTitleBar)) ? ImVec2(window->Size.x, window->TitleBarHeight()) : window->Size;
                window->Pos = ImMax(window->Pos + size_for_clamping, padding) - size_for_clamping;
                window->Pos = ImMin(window->Pos, g.IO.DisplaySize - padding);
            }
        }
        window->Pos = ImFloor(window->Pos);

        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

        // Prepare for item focus requests
        window->FocusIdxAllRequestCurrent = (window->FocusIdxAllRequestNext == INT_MAX || window->FocusIdxAllCounter == -1) ? INT_MAX : (window->FocusIdxAllRequestNext + (window->FocusIdxAllCounter+1)) % (window->FocusIdxAllCounter+1);
        window->FocusIdxTabRequestCurrent = (window->FocusIdxTabRequestNext == INT_MAX || window->FocusIdxTabCounter == -1) ? INT_MAX : (window->FocusIdxTabRequestNext + (window->FocusIdxTabCounter+1)) % (window->FocusIdxTabCounter+1);
        window->FocusIdxAllCounter = window->FocusIdxTabCounter = -1;
        window->FocusIdxAllRequestNext = window->FocusIdxTabRequestNext = INT_MAX;

        // Apply scrolling
        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

        // Apply window focus (new and reactivated windows are moved to front)
        bool want_focus = false;
        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
        {
            if (flags & ImGuiWindowFlags_Popup)
                want_focus = true;
            else if ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) == 0)
                want_focus = true;
        }

        // Handle manual resize: Resize Grips, Borders, Gamepad
        int border_held = -1;
        ImU32 resize_grip_col[4] = { 0 };
        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
        const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
        if (!window->Collapsed)
            UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
        window->ResizeBorderHeld = (signed char)border_held;

        // Default item width. Make it proportional to window size if window manually resizes
        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
            window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
        else
            window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

        // DRAWING

        // Setup draw list and outer clipping rectangle
        window->DrawList->Clear();
        window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
        ImRect viewport_rect(GetViewportRect());
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
            PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
        else
            PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

        // Draw modal window background (darkens what is behind them, all viewports)
        const bool dim_bg_for_modal = (flags & ImGuiWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesForResize <= 0;
        const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
        if (dim_bg_for_modal || dim_bg_for_window_list)
        {
            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
            window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
        }

        // Draw navigation selection/windowing rectangle background
        if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
        {
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
                window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
        }

        // Draw window + handle manual resize
        // As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
        const float window_rounding = window->WindowRounding;
        const float window_border_size = window->WindowBorderSize;
        const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
        const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
        const ImRect title_bar_rect = window->TitleBarRect();
        if (window->Collapsed)
        {
            // Title bar only
            float backup_border_size = style.FrameBorderSize;
            g.Style.FrameBorderSize = window->WindowBorderSize;
            ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
            RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
            g.Style.FrameBorderSize = backup_border_size;
        }
        else
        {
            // Window background
            if (!(flags & ImGuiWindowFlags_NoBackground))
            {
                ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));
                float alpha = 1.0f;
                if (g.NextWindowData.BgAlphaCond != 0)
                    alpha = g.NextWindowData.BgAlphaVal;
                if (alpha != 1.0f)
                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
                window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);
            }
            g.NextWindowData.BgAlphaCond = 0;

            // Title bar
            if (!(flags & ImGuiWindowFlags_NoTitleBar))
            {
                ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
                window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
            }

            // Menu bar
            if (flags & ImGuiWindowFlags_MenuBar)
            {
                ImRect menu_bar_rect = window->MenuBarRect();
                menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
                window->DrawList->AddRectFilled(menu_bar_rect.Min, menu_bar_rect.Max, GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
                if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
                    window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
            }

            // Scrollbars
            if (window->ScrollbarX)
                Scrollbar(ImGuiAxis_X);
            if (window->ScrollbarY)
                Scrollbar(ImGuiAxis_Y);

            // Render resize grips (after their input handling so we don't have a frame of latency)
            if (!(flags & ImGuiWindowFlags_NoResize))
            {
                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
                {
                    const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
                    const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));
                    window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
                    window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
                }
            }

            // Borders
            RenderOuterBorders(window);
        }

        // Draw navigation selection/windowing rectangle border
        if (g.NavWindowingTargetAnim == window)
        {
            float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
            {
                bb.Expand(-g.FontSize - 1.0f);
                rounding = window->WindowRounding;
            }
            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
        }

        // Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
        window->SizeFullAtLastBegin = window->SizeFull;

        // Update various regions. Variables they depends on are set above in this function.
        // FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
        window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
        window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
        window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

        // Setup drawing context
        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
        window->DC.GroupOffset.x = 0.0f;
        window->DC.ColumnsOffset.x = 0.0f;
        window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
        window->DC.CursorPos = window->DC.CursorStartPos;
        window->DC.CursorPosPrevLine = window->DC.CursorPos;
        window->DC.CursorMaxPos = window->DC.CursorStartPos;
        window->DC.CurrentLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
        window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
        window->DC.NavHideHighlightOneFrame = false;
        window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
        window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
        window->DC.NavLayerActiveMaskNext = 0x00;
        window->DC.MenuBarAppending = false;
        window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;
        window->DC.ChildWindows.resize(0);
        window->DC.LayoutType = ImGuiLayoutType_Vertical;
        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
        window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : ImGuiItemFlags_Default_;
        window->DC.ItemWidth = window->ItemWidthDefault;
        window->DC.TextWrapPos = -1.0f; // disabled
        window->DC.ItemFlagsStack.resize(0);
        window->DC.ItemWidthStack.resize(0);
        window->DC.TextWrapPosStack.resize(0);
        window->DC.ColumnsSet = NULL;
        window->DC.TreeDepth = 0;
        window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
        window->DC.StateStorage = &window->StateStorage;
        window->DC.GroupStack.resize(0);
        window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

        if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
        {
            window->DC.ItemFlags = parent_window->DC.ItemFlags;
            window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
        }

        if (window->AutoFitFramesX > 0)
            window->AutoFitFramesX--;
        if (window->AutoFitFramesY > 0)
            window->AutoFitFramesY--;

        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        if (want_focus)
        {
            FocusWindow(window);
            NavInitWindow(window, false);
        }

        // Title bar
        if (!(flags & ImGuiWindowFlags_NoTitleBar))
        {
            // Close & collapse button are on layer 1 (same as menus) and don't default focus
            const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
            window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
            window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
            window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);

            // Collapse button
            if (!(flags & ImGuiWindowFlags_NoCollapse))
                if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
                    window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

            // Close button
            if (p_open != NULL)
            {
                const float pad = style.FramePadding.y;
                const float rad = g.FontSize * 0.5f;
                if (CloseButton(window->GetID("#CLOSE"), window->Rect().GetTR() + ImVec2(-pad - rad, pad + rad), rad + 1))
                    *p_open = false;
            }

            window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
            window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
            window->DC.ItemFlags = item_flags_backup;

            // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
            // FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
            const char* UNSAVED_DOCUMENT_MARKER = "*";
            float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
            ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
            ImRect text_r = title_bar_rect;
            float pad_left = (flags & ImGuiWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            float pad_right = (p_open == NULL)                     ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            if (style.WindowTitleAlign.x > 0.0f)
                pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
            text_r.Min.x += pad_left;
            text_r.Max.x -= pad_right;
            ImRect clip_rect = text_r;
            clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
            RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
            if (flags & ImGuiWindowFlags_UnsavedDocument)
            {
                ImVec2 marker_pos = ImVec2(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + ImVec2(2 - marker_size_x, 0.0f);
                ImVec2 off = ImVec2(0.0f, (float)(int)(-g.FontSize * 0.25f));
                RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, ImVec2(0, style.WindowTitleAlign.y), &clip_rect);
            }
        }

        // Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
        window->OuterRectClipped = window->Rect();
        window->OuterRectClipped.ClipWith(window->ClipRect);

        // Pressing CTRL+C while holding on a window copy its content to the clipboard
        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        // Maybe we can support CTRL+C on every element?
        /*
        if (g.ActiveId == move_id)
            if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))
                LogToClipboard();
        */

        // Inner rectangle
        // We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
        window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
        window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
        window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
        //window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

        // Inner clipping rectangle
        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

        // We fill last item data based on Title Bar, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
        // This is useful to allow creating context menus on title bar only, etc.
        window->DC.LastItemId = window->MoveId;
        window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0;
        window->DC.LastItemRect = title_bar_rect;
    }

    PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    if (first_begin_of_the_frame)
        window->WriteAccessed = false;

    window->BeginCount++;
    g.NextWindowData.Clear();

    if (flags & ImGuiWindowFlags_ChildWindow)
    {
        // Child window can be out of sight and have "negative" clip windows.
        // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
        IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);
        if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
                window->HiddenFramesRegular = 1;

        // Completely hide along with parent or if parent is collapsed
        if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
            window->HiddenFramesRegular = 1;
    }

    // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
    if (style.Alpha <= 0.0f)
        window->HiddenFramesRegular = 1;

    // Update the Hidden flag
    window->Hidden = (window->HiddenFramesRegular > 0) || (window->HiddenFramesForResize > 0);

    // Return false if we don't intend to display anything to allow user to perform an early out optimization
    window->SkipItems = (window->Collapsed || !window->Active || window->Hidden) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesForResize <= 0;

    return !window->SkipItems;
}

// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()/SetNextWindowBgAlpha() + Begin() instead.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)
{
    // Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.
    if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)
        SetNextWindowSize(size_first_use, ImGuiCond_FirstUseEver);

    // Old API feature: override the window background alpha with a parameter.
    if (bg_alpha_override >= 0.0f)
        SetNextWindowBgAlpha(bg_alpha_override);

    return Begin(name, p_open, flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

void ImGui::End()
{
    ImGuiContext& g = *GImGui;

    if (g.CurrentWindowStack.Size <= 1 && g.FrameScopePushedImplicitWindow)
    {
        IM_ASSERT(g.CurrentWindowStack.Size > 1 && "Calling End() too many times!");
        return; // FIXME-ERRORHANDLING
    }
    IM_ASSERT(g.CurrentWindowStack.Size > 0);

    ImGuiWindow* window = g.CurrentWindow;

    if (window->DC.ColumnsSet != NULL)
        EndColumns();
    PopClipRect();   // Inner window clip rectangle

    // Stop logging
    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
        LogFinish();

    // Pop from window stack
    g.CurrentWindowStack.pop_back();
    if (window->Flags & ImGuiWindowFlags_Popup)
        g.BeginPopupStack.pop_back();
    CheckStacksSize(window, false);
    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());
}

void ImGui::BringWindowToFocusFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.WindowsFocusOrder.back() == window)
        return;
    for (int i = g.WindowsFocusOrder.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.WindowsFocusOrder[i] == window)
        {
            memmove(&g.WindowsFocusOrder[i], &g.WindowsFocusOrder[i + 1], (size_t)(g.WindowsFocusOrder.Size - i - 1) * sizeof(ImGuiWindow*));
            g.WindowsFocusOrder[g.WindowsFocusOrder.Size - 1] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* current_front_window = g.Windows.back();
    if (current_front_window == window || current_front_window->RootWindow == window)
        return;
    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
            g.Windows[g.Windows.Size - 1] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.Windows[0] == window)
        return;
    for (int i = 0; i < g.Windows.Size; i++)
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));
            g.Windows[0] = window;
            break;
        }
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void ImGui::FocusWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    if (g.NavWindow != window)
    {
        g.NavWindow = window;
        if (window && g.NavDisableMouseHover)
            g.NavMousePosDirty = true;
        g.NavInitRequest = false;
        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
        g.NavIdIsAlive = false;
        g.NavLayer = ImGuiNavLayer_Main;
        //IMGUI_DEBUG_LOG("FocusWindow(\"%s\")\n", window ? window->Name : NULL);
    }

    // Passing NULL allow to disable keyboard focus
    if (!window)
        return;

    // Move the root window to the top of the pile
    if (window->RootWindow)
        window = window->RootWindow;

    // Steal focus on active widgets
    if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..
        if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)
            ClearActiveID();

    // Bring to front
    BringWindowToFocusFront(window);
    if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))
        BringWindowToDisplayFront(window);
}

void ImGui::FocusPreviousWindowIgnoringOne(ImGuiWindow* ignore_window)
{
    ImGuiContext& g = *GImGui;
    for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)
    {
        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
        ImGuiWindow* window = g.WindowsFocusOrder[i];
        if (window != ignore_window && window->WasActive && !(window->Flags & ImGuiWindowFlags_ChildWindow))
            if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))
            {
                ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(window);
                FocusWindow(focus_window);
                return;
            }
    }
}

void ImGui::PushItemWidth(float item_width)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
}

void ImGui::PushMultiItemsWidths(int components, float w_full)
{
    ImGuiWindow* window = GetCurrentWindow();
    const ImGuiStyle& style = GImGui->Style;
    if (w_full <= 0.0f)
        w_full = CalcItemWidth();
    const float w_item_one  = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));
    const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));
    window->DC.ItemWidthStack.push_back(w_item_last);
    for (int i = 0; i < components-1; i++)
        window->DC.ItemWidthStack.push_back(w_item_one);
    window->DC.ItemWidth = window->DC.ItemWidthStack.back();
}

void ImGui::PopItemWidth()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidthStack.pop_back();
    window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();
}

float ImGui::CalcItemWidth()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    float w = window->DC.ItemWidth;
    if (w < 0.0f)
    {
        // Align to a right-side limit. We include 1 frame padding in the calculation because this is how the width is always used (we add 2 frame padding to it), but we could move that responsibility to the widget as well.
        float width_to_right_edge = GetContentRegionAvail().x;
        w = ImMax(1.0f, width_to_right_edge + w);
    }
    w = (float)(int)w;
    return w;
}

void ImGui::SetCurrentFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    IM_ASSERT(font->Scale > 0.0f);
    g.Font = font;
    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

    ImFontAtlas* atlas = g.Font->ContainerAtlas;
    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    g.DrawListSharedData.Font = g.Font;
    g.DrawListSharedData.FontSize = g.FontSize;
}

void ImGui::PushFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    if (!font)
        font = GetDefaultFont();
    SetCurrentFont(font);
    g.FontStack.push_back(font);
    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

void  ImGui::PopFont()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DrawList->PopTextureID();
    g.FontStack.pop_back();
    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (enabled)
        window->DC.ItemFlags |= option;
    else
        window->DC.ItemFlags &= ~option;
    window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
}

void ImGui::PopItemFlag()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemFlagsStack.pop_back();
    window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();
}

// FIXME: Look into renaming this once we have settled the new Focus/Activation/TabStop system.
void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)
{
    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);
}

void ImGui::PopAllowKeyboardFocus()
{
    PopItemFlag();
}

void ImGui::PushButtonRepeat(bool repeat)
{
    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);
}

void ImGui::PopButtonRepeat()
{
    PopItemFlag();
}

void ImGui::PushTextWrapPos(float wrap_pos_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPos = wrap_pos_x;
    window->DC.TextWrapPosStack.push_back(wrap_pos_x);
}

void ImGui::PopTextWrapPos()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPosStack.pop_back();
    window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = col;
}

void ImGui::PopStyleColor(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        ImGuiColorMod& backup = g.ColorModifiers.back();
        g.Style.Colors[backup.Col] = backup.BackupValue;
        g.ColorModifiers.pop_back();
        count--;
    }
}

struct ImGuiStyleVarInfo
{
    ImGuiDataType   Type;
    ImU32           Count;
    ImU32           Offset;
    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImGuiStyleVarInfo GStyleVarInfo[] =
{
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },               // ImGuiStyleVar_Alpha
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },       // ImGuiStyleVar_WindowPadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },      // ImGuiStyleVar_WindowRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },    // ImGuiStyleVar_WindowBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },       // ImGuiStyleVar_WindowMinSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowTitleAlign) },    // ImGuiStyleVar_WindowTitleAlign
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },       // ImGuiStyleVar_ChildRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },     // ImGuiStyleVar_ChildBorderSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },       // ImGuiStyleVar_PopupRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },     // ImGuiStyleVar_PopupBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },        // ImGuiStyleVar_FramePadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },       // ImGuiStyleVar_FrameRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },     // ImGuiStyleVar_FrameBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },         // ImGuiStyleVar_ItemSpacing
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },    // ImGuiStyleVar_ItemInnerSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },       // ImGuiStyleVar_IndentSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarSize) },       // ImGuiStyleVar_ScrollbarSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarRounding) },   // ImGuiStyleVar_ScrollbarRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },         // ImGuiStyleVar_GrabMinSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabRounding) },        // ImGuiStyleVar_GrabRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, TabRounding) },         // ImGuiStyleVar_TabRounding
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },     // ImGuiStyleVar_ButtonTextAlign
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, SelectableTextAlign) }, // ImGuiStyleVar_SelectableTextAlign
};

static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)
{
    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
    return &GStyleVarInfo[idx];
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
    {
        ImGuiContext& g = *GImGui;
        float* pvar = (float*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
    {
        ImGuiContext& g = *GImGui;
        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.
}

void ImGui::PopStyleVar(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
        ImGuiStyleMod& backup = g.StyleModifiers.back();
        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
        void* data = info->GetVarPtr(&g.Style);
        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
        g.StyleModifiers.pop_back();
        count--;
    }
}

const char* ImGui::GetStyleColorName(ImGuiCol idx)
{
    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
    switch (idx)
    {
    case ImGuiCol_Text: return "Text";
    case ImGuiCol_TextDisabled: return "TextDisabled";
    case ImGuiCol_WindowBg: return "WindowBg";
    case ImGuiCol_ChildBg: return "ChildBg";
    case ImGuiCol_PopupBg: return "PopupBg";
    case ImGuiCol_Border: return "Border";
    case ImGuiCol_BorderShadow: return "BorderShadow";
    case ImGuiCol_FrameBg: return "FrameBg";
    case ImGuiCol_FrameBgHovered: return "FrameBgHovered";
    case ImGuiCol_FrameBgActive: return "FrameBgActive";
    case ImGuiCol_TitleBg: return "TitleBg";
    case ImGuiCol_TitleBgActive: return "TitleBgActive";
    case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";
    case ImGuiCol_MenuBarBg: return "MenuBarBg";
    case ImGuiCol_ScrollbarBg: return "ScrollbarBg";
    case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";
    case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
    case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
    case ImGuiCol_CheckMark: return "CheckMark";
    case ImGuiCol_SliderGrab: return "SliderGrab";
    case ImGuiCol_SliderGrabActive: return "SliderGrabActive";
    case ImGuiCol_Button: return "Button";
    case ImGuiCol_ButtonHovered: return "ButtonHovered";
    case ImGuiCol_ButtonActive: return "ButtonActive";
    case ImGuiCol_Header: return "Header";
    case ImGuiCol_HeaderHovered: return "HeaderHovered";
    case ImGuiCol_HeaderActive: return "HeaderActive";
    case ImGuiCol_Separator: return "Separator";
    case ImGuiCol_SeparatorHovered: return "SeparatorHovered";
    case ImGuiCol_SeparatorActive: return "SeparatorActive";
    case ImGuiCol_ResizeGrip: return "ResizeGrip";
    case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";
    case ImGuiCol_ResizeGripActive: return "ResizeGripActive";
    case ImGuiCol_Tab: return "Tab";
    case ImGuiCol_TabHovered: return "TabHovered";
    case ImGuiCol_TabActive: return "TabActive";
    case ImGuiCol_TabUnfocused: return "TabUnfocused";
    case ImGuiCol_TabUnfocusedActive: return "TabUnfocusedActive";
    case ImGuiCol_PlotLines: return "PlotLines";
    case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";
    case ImGuiCol_PlotHistogram: return "PlotHistogram";
    case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";
    case ImGuiCol_TextSelectedBg: return "TextSelectedBg";
    case ImGuiCol_DragDropTarget: return "DragDropTarget";
    case ImGuiCol_NavHighlight: return "NavHighlight";
    case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";
    case ImGuiCol_NavWindowingDimBg: return "NavWindowingDimBg";
    case ImGuiCol_ModalWindowDimBg: return "ModalWindowDimBg";
    }
    IM_ASSERT(0);
    return "Unknown";
}

bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
{
    if (window->RootWindow == potential_parent)
        return true;
    while (window != NULL)
    {
        if (window == potential_parent)
            return true;
        window = window->ParentWindow;
    }
    return false;
}

bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)
{
    IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function
    ImGuiContext& g = *GImGui;

    if (flags & ImGuiHoveredFlags_AnyWindow)
    {
        if (g.HoveredWindow == NULL)
            return false;
    }
    else
    {
        switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))
        {
        case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_RootWindow:
            if (g.HoveredWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))
                return false;
            break;
        default:
            if (g.HoveredWindow != g.CurrentWindow)
                return false;
            break;
        }
    }

    if (!IsWindowContentHoverable(g.HoveredRootWindow, flags))
        return false;
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)
            return false;
    return true;
}

bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)
{
    ImGuiContext& g = *GImGui;

    if (flags & ImGuiFocusedFlags_AnyWindow)
        return g.NavWindow != NULL;

    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()
    switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))
    {
    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_RootWindow:
        return g.NavWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);
    default:
        return g.NavWindow == g.CurrentWindow;
    }
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmaticaly.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)
{
    return window->Active && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
}

float ImGui::GetWindowWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.x;
}

float ImGui::GetWindowHeight()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.y;
}

ImVec2 ImGui::GetWindowPos()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return window->Pos;
}

void ImGui::SetWindowScrollX(ImGuiWindow* window, float new_scroll_x)
{
    window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.x = new_scroll_x;
    window->DC.CursorMaxPos.x -= window->Scroll.x;
}

void ImGui::SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)
{
    window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.y = new_scroll_y;
    window->DC.CursorMaxPos.y -= window->Scroll.y;
}

void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);

    // Set
    const ImVec2 old_pos = window->Pos;
    window->Pos = ImFloor(pos);
    window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
    window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.
}

void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    SetWindowPos(window, pos, cond);
}

void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowPos(window, pos, cond);
}

ImVec2 ImGui::GetWindowSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Size;
}

void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    if (size.x > 0.0f)
    {
        window->AutoFitFramesX = 0;
        window->SizeFull.x = ImFloor(size.x);
    }
    else
    {
        window->AutoFitFramesX = 2;
        window->AutoFitOnlyGrows = false;
    }
    if (size.y > 0.0f)
    {
        window->AutoFitFramesY = 0;
        window->SizeFull.y = ImFloor(size.y);
    }
    else
    {
        window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
}

void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
{
    SetWindowSize(GImGui->CurrentWindow, size, cond);
}

void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowSize(window, size, cond);
}

void ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
        return;
    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    window->Collapsed = collapsed;
}

void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
}

bool ImGui::IsWindowCollapsed()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Collapsed;
}

bool ImGui::IsWindowAppearing()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Appearing;
}

void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowCollapsed(window, collapsed, cond);
}

void ImGui::SetWindowFocus()
{
    FocusWindow(GImGui->CurrentWindow);
}

void ImGui::SetWindowFocus(const char* name)
{
    if (name)
    {
        if (ImGuiWindow* window = FindWindowByName(name))
            FocusWindow(window);
    }
    else
    {
        FocusWindow(NULL);
    }
}

void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.PosVal = pos;
    g.NextWindowData.PosPivotVal = pivot;
    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.SizeVal = size;
    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.SizeConstraintCond = ImGuiCond_Always;
    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
    g.NextWindowData.SizeCallback = custom_callback;
    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

void ImGui::SetNextWindowContentSize(const ImVec2& size)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.
    g.NextWindowData.ContentSizeCond = ImGuiCond_Always;
}

void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.CollapsedVal = collapsed;
    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.FocusCond = ImGuiCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

void ImGui::SetNextWindowBgAlpha(float alpha)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.BgAlphaVal = alpha;
    g.NextWindowData.BgAlphaCond = ImGuiCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

// FIXME: This is in window space (not screen space!)
ImVec2 ImGui::GetContentRegionMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImVec2 mx = window->ContentsRegionRect.Max - window->Pos;
    if (window->DC.ColumnsSet)
        mx.x = GetColumnOffset(window->DC.ColumnsSet->Current + 1) - window->WindowPadding.x;
    return mx;
}

ImVec2 ImGui::GetContentRegionAvail()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);
}

float ImGui::GetContentRegionAvailWidth()
{
    return GetContentRegionAvail().x;
}

// In window space (not screen space!)
ImVec2 ImGui::GetWindowContentRegionMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Min - window->Pos;
}

ImVec2 ImGui::GetWindowContentRegionMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Max - window->Pos;
}

float ImGui::GetWindowContentRegionWidth()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.GetWidth();
}

float ImGui::GetTextLineHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

ImDrawList* ImGui::GetWindowDrawList()
{
    ImGuiWindow* window = GetCurrentWindow();
    return window->DrawList;
}

ImFont* ImGui::GetFont()
{
    return GImGui->Font;
}

float ImGui::GetFontSize()
{
    return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel()
{
    return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale(float scale)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->FontWindowScale = scale;
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
ImVec2 ImGui::GetCursorPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos(const ImVec2& local_pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

void ImGui::SetCursorPosX(float x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
}

void ImGui::SetCursorPosY(float y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
}

ImVec2 ImGui::GetCursorStartPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorStartPos - window->Pos;
}

ImVec2 ImGui::GetCursorScreenPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos;
}

void ImGui::SetCursorScreenPos(const ImVec2& pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

float ImGui::GetScrollX()
{
    return GImGui->CurrentWindow->Scroll.x;
}

float ImGui::GetScrollY()
{
    return GImGui->CurrentWindow->Scroll.y;
}

float ImGui::GetScrollMaxX()
{
    return GetWindowScrollMaxX(GImGui->CurrentWindow);
}

float ImGui::GetScrollMaxY()
{
    return GetWindowScrollMaxY(GImGui->CurrentWindow);
}

void ImGui::SetScrollX(float scroll_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->ScrollTarget.x = scroll_x;
    window->ScrollTargetCenterRatio.x = 0.0f;
}

void ImGui::SetScrollY(float scroll_y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY
    window->ScrollTargetCenterRatio.y = 0.0f;
}

void ImGui::SetScrollFromPosY(float local_y, float center_y_ratio)
{
    // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
    window->ScrollTarget.y = (float)(int)(local_y + window->Scroll.y);
    window->ScrollTargetCenterRatio.y = center_y_ratio;
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void ImGui::SetScrollHereY(float center_y_ratio)
{
    ImGuiWindow* window = GetCurrentWindow();
    float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space
    target_y += (window->DC.PrevLineSize.y * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.
    SetScrollFromPosY(target_y, center_y_ratio);
}

void ImGui::ActivateItem(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.NavNextActivateId = id;
}

void ImGui::SetKeyboardFocusHere(int offset)
{
    IM_ASSERT(offset >= -1);    // -1 is allowed but not below
    ImGuiWindow* window = GetCurrentWindow();
    window->FocusIdxAllRequestNext = window->FocusIdxAllCounter + 1 + offset;
    window->FocusIdxTabRequestNext = INT_MAX;
}

void ImGui::SetItemDefaultFocus()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!window->Appearing)
        return;
    if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)
    {
        g.NavInitRequest = false;
        g.NavInitResultId = g.NavWindow->DC.LastItemId;
        g.NavInitResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);
        NavUpdateAnyRequestFlag();
        if (!IsItemVisible())
            SetScrollHereY();
    }
}

void ImGui::SetStateStorage(ImGuiStorage* tree)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage* ImGui::GetStateStorage()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->DC.StateStorage;
}

void ImGui::PushID(const char* str_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id));
}

void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id_begin, str_id_end));
}

void ImGui::PushID(const void* ptr_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void ImGui::PushID(int int_id)
{
    const void* ptr_id = (void*)(intptr_t)int_id;
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void ImGui::PopID()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.pop_back();
}

ImGuiID ImGui::GetID(const char* str_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(str_id);
}

ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(str_id_begin, str_id_end);
}

ImGuiID ImGui::GetID(const void* ptr_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(ptr_id);
}

bool ImGui::IsRectVisible(const ImVec2& size)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
}

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
void ImGui::BeginGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);
    ImGuiGroupData& group_data = window->DC.GroupStack.back();
    group_data.BackupCursorPos = window->DC.CursorPos;
    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    group_data.BackupIndent = window->DC.Indent;
    group_data.BackupGroupOffset = window->DC.GroupOffset;
    group_data.BackupCurrentLineSize = window->DC.CurrentLineSize;
    group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;
    group_data.BackupLogLinePosY = window->DC.LogLinePosY;
    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
    group_data.AdvanceCursor = true;

    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
    window->DC.Indent = window->DC.GroupOffset;
    window->DC.CursorMaxPos = window->DC.CursorPos;
    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);
    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return
}

void ImGui::EndGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(!window->DC.GroupStack.empty());    // Mismatched BeginGroup()/EndGroup() calls

    ImGuiGroupData& group_data = window->DC.GroupStack.back();

    ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);
    group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

    window->DC.CursorPos = group_data.BackupCursorPos;
    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
    window->DC.Indent = group_data.BackupIndent;
    window->DC.GroupOffset = group_data.BackupGroupOffset;
    window->DC.CurrentLineSize = group_data.BackupCurrentLineSize;
    window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;
    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return

    if (group_data.AdvanceCursor)
    {
        window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
        ItemSize(group_bb.GetSize(), 0.0f);
        ItemAdd(group_bb, 0);
    }

    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
    // (and if you grep for LastItemId you'll notice it is only used in that context.
    if ((group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveId;
    else if (!group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveIdPreviousFrame;
    window->DC.LastItemRect = group_bb;

    window->DC.GroupStack.pop_back();

    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
}

// Gets back to previous line and continue with horizontal layout
//      pos_x == 0      : follow right after previous item
//      pos_x != 0      : align to specified x position (relative to window/group left)
//      spacing_w < 0   : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing_w >= 0  : enforce spacing amount
void ImGui::SameLine(float pos_x, float spacing_w)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    if (pos_x != 0.0f)
    {
        if (spacing_w < 0.0f) spacing_w = 0.0f;
        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + pos_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    else
    {
        if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;
        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    window->DC.CurrentLineSize = window->DC.PrevLineSize;
    window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
}

void ImGui::Indent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::Unindent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

void ImGui::BeginTooltip()
{
    ImGuiContext& g = *GImGui;
    if (g.DragDropWithinSourceOrTarget)
    {
        // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)
        // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.
        // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.
        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
        ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);
        SetNextWindowPos(tooltip_pos);
        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);
        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
        BeginTooltipEx(0, true);
    }
    else
    {
        BeginTooltipEx(0, false);
    }
}

// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.
void ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)
{
    ImGuiContext& g = *GImGui;
    char window_name[16];
    ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);
    if (override_previous_tooltip)
        if (ImGuiWindow* window = FindWindowByName(window_name))
            if (window->Active)
            {
                // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
                window->Hidden = true;
                window->HiddenFramesRegular = 1;
                ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);
            }
    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip|ImGuiWindowFlags_NoInputs|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize;
    Begin(window_name, NULL, flags | extra_flags);
}

void ImGui::EndTooltip()
{
    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
    End();
}

void ImGui::SetTooltipV(const char* fmt, va_list args)
{
    ImGuiContext& g = *GImGui;
    if (g.DragDropWithinSourceOrTarget)
        BeginTooltip();
    else
        BeginTooltipEx(0, true);
    TextV(fmt, args);
    EndTooltip();
}

void ImGui::SetTooltip(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    SetTooltipV(fmt, args);
    va_end(args);
}

//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

bool ImGui::IsPopupOpen(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
}

bool ImGui::IsPopupOpen(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);
}

ImGuiWindow* ImGui::GetFrontMostPopupModal()
{
    ImGuiContext& g = *GImGui;
    for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)
        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
            if (popup->Flags & ImGuiWindowFlags_Modal)
                return popup;
    return NULL;
}

void ImGui::OpenPopup(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    OpenPopupEx(g.CurrentWindow->GetID(str_id));
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
void ImGui::OpenPopupEx(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;
    int current_stack_size = g.BeginPopupStack.Size;
    ImGuiPopupRef popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
    popup_ref.PopupId = id;
    popup_ref.Window = NULL;
    popup_ref.ParentWindow = parent_window;
    popup_ref.OpenFrameCount = g.FrameCount;
    popup_ref.OpenParentId = parent_window->IDStack.back();
    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

    //IMGUI_DEBUG_LOG("OpenPopupEx(0x%08X)\n", g.FrameCount, id);
    if (g.OpenPopupStack.Size < current_stack_size + 1)
    {
        g.OpenPopupStack.push_back(popup_ref);
    }
    else
    {
        // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
        // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
        // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
        {
            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
        }
        else
        {
            // Close child popups if any, then flag popup for open/reopen
            g.OpenPopupStack.resize(current_stack_size + 1);
            g.OpenPopupStack[current_stack_size] = popup_ref;
        }

        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
        // This is equivalent to what ClosePopupToLevel() does.
        //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        //    FocusWindow(parent_window);
    }
}

bool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    {
        ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
        IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
        OpenPopupEx(id);
        return true;
    }
    return false;
}

void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.empty())
        return;

    // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
    // Don't close our own child popup windows.
    int popup_count_to_keep = 0;
    if (ref_window)
    {
        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
        {
            ImGuiPopupRef& popup = g.OpenPopupStack[popup_count_to_keep];
            if (!popup.Window)
                continue;
            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
                continue;

            // Trim the stack if popups are not direct descendant of the reference window (which is often the NavWindow)
            bool popup_or_descendent_has_focus = false;
            for (int m = popup_count_to_keep; m < g.OpenPopupStack.Size && !popup_or_descendent_has_focus; m++)
                if (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == ref_window->RootWindow)
                    popup_or_descendent_has_focus = true;
            if (!popup_or_descendent_has_focus)
                break;
        }
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
    {
        //IMGUI_DEBUG_LOG("ClosePopupsOverWindow(%s) -> ClosePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);
        ClosePopupToLevel(popup_count_to_keep, false);
    }
}

void ImGui::ClosePopupToLevel(int remaining, bool apply_focus_to_window_under)
{
    IM_ASSERT(remaining >= 0);
    ImGuiContext& g = *GImGui;
    ImGuiWindow* focus_window = (remaining > 0) ? g.OpenPopupStack[remaining-1].Window : g.OpenPopupStack[0].ParentWindow;
    g.OpenPopupStack.resize(remaining);

    // FIXME: This code is faulty and we may want to eventually to replace or remove the 'apply_focus_to_window_under=true' path completely.
    // Instead of using g.OpenPopupStack[remaining-1].Window etc. we should find the highest root window that is behind the popups we are closing.
    // The current code will set focus to the parent of the popup window which is incorrect.
    // It rarely manifested until now because UpdateMouseMovingWindowNewFrame() would call FocusWindow() again on the clicked window,
    // leading to a chain of focusing A (clicked window) then B (parent window of the popup) then A again.
    // However if the clicked window has the _NoMove flag set we would be left with B focused.
    // For now, we have disabled this path when called from ClosePopupsOverWindow() because the users of ClosePopupsOverWindow() don't need to alter focus anyway,
    // but we should inspect and fix this properly.
    if (apply_focus_to_window_under)
    {
        if (g.NavLayer == 0)
            focus_window = NavRestoreLastChildNavWindow(focus_window);
        FocusWindow(focus_window);
    }
}

// Close the popup we have begin-ed into.
void ImGui::CloseCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    int popup_idx = g.BeginPopupStack.Size - 1;
    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
        return;

    // Closing a menu closes its top-most parent popup (unless a modal)
    while (popup_idx > 0)
    {
        ImGuiWindow* popup_window = g.OpenPopupStack[popup_idx].Window;
        ImGuiWindow* parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
        bool close_parent = false;
        if (popup_window && (popup_window->Flags & ImGuiWindowFlags_ChildMenu))
            if (parent_popup_window == NULL || !(parent_popup_window->Flags & ImGuiWindowFlags_Modal))
                close_parent = true;
        if (!close_parent)
            break;
        popup_idx--;
    }
    //IMGUI_DEBUG_LOG("CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);
    ClosePopupToLevel(popup_idx, true);

    // A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
    // To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
    // Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
    if (ImGuiWindow* window = g.NavWindow)
        window->DC.NavHideHighlightOneFrame = true;
}

bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    char name[20];
    if (extra_flags & ImGuiWindowFlags_ChildMenu)
        ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth
    else
        ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame

    bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);
    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
        EndPopup();

    return is_open;
}

bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }
    flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
    return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags);
}

// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by imgui (and manipulated with e.g. OpenPopup) so the actual value of *p_open is meaningless here.
bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiID id = window->GetID(name);
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    // Center modal windows by default
    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
    if (g.NextWindowData.PosCond == 0)
        SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings;
    const bool is_open = Begin(name, p_open, flags);
    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    {
        EndPopup();
        if (is_open)
            ClosePopupToLevel(g.BeginPopupStack.Size, true);
        return false;
    }
    return is_open;
}

void ImGui::EndPopup()
{
    ImGuiContext& g = *GImGui; 
    IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
    IM_ASSERT(g.BeginPopupStack.Size > 0);

    // Make all menus and popups wrap around for now, may need to expose that policy.
    NavMoveRequestTryWrapping(g.CurrentWindow, ImGuiNavMoveFlags_LoopY);

    End();
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
// You can pass a NULL str_id to use the identifier of the last item.
bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)
{
    if (!str_id)
        str_id = "window_context";
    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        if (also_over_items || !IsAnyItemHovered())
            OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)
{
    if (!str_id)
        str_id = "void_context";
    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
        OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

ImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow*)
{
    ImVec2 padding = GImGui->Style.DisplaySafeAreaPadding;
    ImRect r_screen = GetViewportRect();
    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
    return r_screen;
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)
{
    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
    //GImGui->OverlayDrawList.AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
    //GImGui->OverlayDrawList.AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

    // Combo Box policy (we want a connecting edge)
    if (policy == ImGuiPopupPositionPolicy_ComboBox)
    {
        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
        {
            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir) // Already tried this direction?
                continue;
            ImVec2 pos;
            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
            if (!r_outer.Contains(ImRect(pos, pos + size)))
                continue;
            *last_dir = dir;
            return pos;
        }
    }

    // Default popup policy
    const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
    for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
    {
        const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
        if (n != -1 && dir == *last_dir) // Already tried this direction?
            continue;
        float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
        float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);
        if (avail_w < size.x || avail_h < size.y)
            continue;
        ImVec2 pos;
        pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
        pos.y = (dir == ImGuiDir_Up)   ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down)  ? r_avoid.Max.y : base_pos_clamped.y;
        *last_dir = dir;
        return pos;
    }

    // Fallback, try to keep within display
    *last_dir = ImGuiDir_None;
    ImVec2 pos = ref_pos;
    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
    return pos;
}

ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    ImRect r_outer = GetWindowAllowedExtentRect(window);
    if (window->Flags & ImGuiWindowFlags_ChildMenu)
    {
        // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
        IM_ASSERT(g.CurrentWindow == window);
        ImGuiWindow* parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2];
        float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
        ImRect r_avoid;
        if (parent_window->DC.MenuBarAppending)
            r_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());
        else
            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & ImGuiWindowFlags_Popup)
    {
        ImRect r_avoid = ImRect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Position tooltip (always follows mouse)
        float sc = g.Style.MouseCursorScale;
        ImVec2 ref_pos = NavCalcPreferredRefPos();
        ImRect r_avoid;
        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
        else
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
        ImVec2 pos = FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
        if (window->AutoPosLastDirection == ImGuiDir_None)
            pos = ref_pos + ImVec2(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
        return pos;
    }
    IM_ASSERT(0);
    return window->Pos;
}

//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------

// (this section is filled in the 'viewport' and 'docking' branches)

//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)
{
    if (ImFabs(dx) > ImFabs(dy))
        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)
{
    if (a1 < b0)
        return a1 - b0;
    if (b1 < a0)
        return a0 - b1;
    return 0.0f;
}

static void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)
{
    if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
    {
        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);
        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);
    }
    else
    {
        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);
        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);
    }
}

// Scoring function for directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool NavScoreItem(ImGuiNavMoveResult* result, ImRect cand)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavLayer != window->DC.NavLayerCurrent)
        return false;

    const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
    g.NavScoringCount++;

    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
    if (window->ParentWindow == g.NavWindow)
    {
        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
        if (!window->ClipRect.Contains(cand))
            return false;
        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
    }

    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
    // For example, this ensure that items in one column are not reached when moving vertically from items in another column.
    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);

    // Compute distance between boxes
    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
    if (dby != 0.0f && dbx != 0.0f)
       dbx = (dbx/1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
    float dist_box = ImFabs(dbx) + ImFabs(dby);

    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
    ImGuiDir quadrant;
    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
    if (dbx != 0.0f || dby != 0.0f)
    {
        // For non-overlapping boxes, use distance between boxes
        dax = dbx;
        day = dby;
        dist_axial = dist_box;
        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
    }
    else if (dcx != 0.0f || dcy != 0.0f)
    {
        // For overlapping boxes with different centers, use distance between centers
        dax = dcx;
        day = dcy;
        dist_axial = dist_center;
        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
    }
    else
    {
        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
        quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
    }

#if IMGUI_DEBUG_NAV_SCORING
    char buf[128];
    if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))
    {
        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
        ImDrawList* draw_list = ImGui::GetOverlayDrawList(window);
        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));
        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));
        draw_list->AddRectFilled(cand.Max-ImVec2(4,4), cand.Max+ImGui::CalcTextSize(buf)+ImVec2(4,4), IM_COL32(40,0,0,150));
        draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);
    }
    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
    {
        if (ImGui::IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }
        if (quadrant == g.NavMoveDir)
        {
            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
            ImDrawList* draw_list = ImGui::GetOverlayDrawList(window);
            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
            draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);
        }
    }
 #endif

    // Is it in the quadrant we're interesting in moving to?
    bool new_best = false;
    if (quadrant == g.NavMoveDir)
    {
        // Does it beat the current best candidate?
        if (dist_box < result->DistBox)
        {
            result->DistBox = dist_box;
            result->DistCenter = dist_center;
            return true;
        }
        if (dist_box == result->DistBox)
        {
            // Try using distance between center points to break ties
            if (dist_center < result->DistCenter)
            {
                result->DistCenter = dist_center;
                new_best = true;
            }
            else if (dist_center == result->DistCenter)
            {
                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
                if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
                    new_best = true;
            }
        }
    }

    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
        if (g.NavLayer == 1 && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
            if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))
            {
                result->DistAxial = dist_axial;
                new_best = true;
            }

    return new_best;
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
static void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
    //    return;

    const ImGuiItemFlags item_flags = window->DC.ItemFlags;
    const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);

    // Process Init Request
    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)
    {
        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)
        {
            g.NavInitResultId = id;
            g.NavInitResultRectRel = nav_bb_rel;
        }
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))
        {
            g.NavInitRequest = false; // Found a match, clear request
            NavUpdateAnyRequestFlag();
        }
    }

    // Process Move Request (scoring for navigation)
    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)
    if ((g.NavId != id || (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & ImGuiItemFlags_NoNav))
    {
        ImGuiNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
#if IMGUI_DEBUG_NAV_SCORING
        // [DEBUG] Score all items in NavWindow at all times
        if (!g.NavMoveRequest)
            g.NavMoveDir = g.NavMoveDirLast;
        bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;
#else
        bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);
#endif
        if (new_best)
        {
            result->ID = id;
            result->SelectScopeId = g.MultiSelectScopeId;
            result->Window = window;
            result->RectRel = nav_bb_rel;
        }

        const float VISIBLE_RATIO = 0.70f;
        if ((g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
            if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
                if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))
                {
                    result = &g.NavMoveResultLocalVisibleSet;
                    result->ID = id;
                    result->SelectScopeId = g.MultiSelectScopeId;
                    result->Window = window;
                    result->RectRel = nav_bb_rel;
                }
    }

    // Update window-relative bounding box of navigated item
    if (g.NavId == id)
    {
        g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.
        g.NavLayer = window->DC.NavLayerCurrent;
        g.NavIdIsAlive = true;
        g.NavIdTabCounter = window->FocusIdxTabCounter;
        window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)
    }
}

bool ImGui::NavMoveRequestButNoResultYet()
{
    ImGuiContext& g = *GImGui;
    return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

void ImGui::NavMoveRequestCancel()
{
    ImGuiContext& g = *GImGui;
    g.NavMoveRequest = false;
    NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_None);
    ImGui::NavMoveRequestCancel();
    g.NavMoveDir = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
    g.NavMoveRequestFlags = move_flags;
    g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;
}

void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    if (g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != ImGuiNavForward_None || g.NavLayer != 0)
        return;
    IM_ASSERT(move_flags != 0); // No points calling this with no wrapping
    ImRect bb_rel = window->NavRectRel[0];

    ImGuiDir clip_dir = g.NavMoveDir;
    if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = ImMax(window->SizeFull.x, window->SizeContents.x) - window->Scroll.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(-bb_rel.GetHeight()); clip_dir = ImGuiDir_Up; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(+bb_rel.GetHeight()); clip_dir = ImGuiDir_Down; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = ImMax(window->SizeFull.y, window->SizeContents.y) - window->Scroll.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(-bb_rel.GetWidth()); clip_dir = ImGuiDir_Left; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(+bb_rel.GetWidth()); clip_dir = ImGuiDir_Right; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
}

static void ImGui::NavSaveLastChildNavWindow(ImGuiWindow* nav_window)
{
    ImGuiWindow* parent_window = nav_window;
    while (parent_window && (parent_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
        parent_window = parent_window->ParentWindow;
    if (parent_window && parent_window != nav_window)
        parent_window->NavLastChildNavWindow = nav_window;
}

// Call when we are expected to land on Layer 0 after FocusWindow()
static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)
{
    return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;
}

static void NavRestoreLayer(ImGuiNavLayer layer)
{
    ImGuiContext& g = *GImGui;
    g.NavLayer = layer;
    if (layer == 0)
        g.NavWindow = ImGui::NavRestoreLastChildNavWindow(g.NavWindow);
    if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)
        ImGui::SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);
    else
        ImGui::NavInitWindow(g.NavWindow, true);
}

static inline void ImGui::NavUpdateAnyRequestFlag()
{
    ImGuiContext& g = *GImGui;
    g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
    if (g.NavAnyRequest)
        IM_ASSERT(g.NavWindow != NULL);
}

// This needs to be called before we submit any widget (aka in or before Begin)
void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(window == g.NavWindow);
    bool init_for_nav = false;
    if (!(window->Flags & ImGuiWindowFlags_NoNavInputs))
        if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
            init_for_nav = true;
    if (init_for_nav)
    {
        SetNavID(0, g.NavLayer);
        g.NavInitRequest = true;
        g.NavInitRequestFromMove = false;
        g.NavInitResultId = 0;
        g.NavInitResultRectRel = ImRect();
        NavUpdateAnyRequestFlag();
    }
    else
    {
        g.NavId = window->NavLastIds[0];
    }
}

static ImVec2 ImGui::NavCalcPreferredRefPos()
{
    ImGuiContext& g = *GImGui;
    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)
    {
        // Mouse (we need a fallback in case the mouse becomes invalid after being used)
        if (IsMousePosValid(&g.IO.MousePos))
            return g.IO.MousePos;
        return g.LastValidMousePos;
    }
    else
    {
        // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.
        const ImRect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];
        ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
        ImRect visible_rect = GetViewportRect();
        return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.
    }
}

float ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)
{
    ImGuiContext& g = *GImGui;
    if (mode == ImGuiInputReadMode_Down)
        return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

    const float t = g.IO.NavInputsDownDuration[n];
    if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.
        return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);
    if (t < 0.0f)
        return 0.0f;
    if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.
        return (t == 0.0f) ? 1.0f : 0.0f;
    if (mode == ImGuiInputReadMode_Repeat)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);
    if (mode == ImGuiInputReadMode_RepeatSlow)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);
    if (mode == ImGuiInputReadMode_RepeatFast)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);
    return 0.0f;
}

ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)
{
    ImVec2 delta(0.0f, 0.0f);
    if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode)   - GetNavInputAmount(ImGuiNavInput_KeyLeft_,   mode), GetNavInputAmount(ImGuiNavInput_KeyDown_,   mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode)   - GetNavInputAmount(ImGuiNavInput_DpadLeft,   mode), GetNavInputAmount(ImGuiNavInput_DpadDown,   mode) - GetNavInputAmount(ImGuiNavInput_DpadUp,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));
    if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))
        delta *= slow_factor;
    if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))
        delta *= fast_factor;
    return delta;
}

// Scroll to keep newly navigated item fully into view
// NB: We modify rect_rel by the amount we scrolled for, so it is immediately updated.
static void NavScrollToBringItemIntoView(ImGuiWindow* window, const ImRect& item_rect)
{
    ImRect window_rect(window->InnerMainRect.Min - ImVec2(1, 1), window->InnerMainRect.Max + ImVec2(1, 1));
    //GetOverlayDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]
    if (window_rect.Contains(item_rect))
        return;

    ImGuiContext& g = *GImGui;
    if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)
    {
        window->ScrollTarget.x = item_rect.Min.x - window->Pos.x + window->Scroll.x - g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 0.0f;
    }
    else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)
    {
        window->ScrollTarget.x = item_rect.Max.x - window->Pos.x + window->Scroll.x + g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 1.0f;
    }
    if (item_rect.Min.y < window_rect.Min.y)
    {
        window->ScrollTarget.y = item_rect.Min.y - window->Pos.y + window->Scroll.y - g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 0.0f;
    }
    else if (item_rect.Max.y >= window_rect.Max.y)
    {
        window->ScrollTarget.y = item_rect.Max.y - window->Pos.y + window->Scroll.y + g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 1.0f;
    }
}

static void ImGui::NavUpdate()
{
    ImGuiContext& g = *GImGui;
    g.IO.WantSetMousePos = false;
#if 0
    if (g.NavScoringCount > 0) IMGUI_DEBUG_LOG("NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
#endif

    // Set input source as Gamepad when buttons are pressed before we map Keyboard (some features differs when used with Gamepad vs Keyboard)
    bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    if (nav_gamepad_active)
        if (g.IO.NavInputs[ImGuiNavInput_Activate] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Input] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Cancel] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Menu] > 0.0f)
            g.NavInputSource = ImGuiInputSource_NavGamepad;

    // Update Keyboard->Nav inputs mapping
    if (nav_keyboard_active)
    {
        #define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; }
        NAV_MAP_KEY(ImGuiKey_Space,     ImGuiNavInput_Activate );
        NAV_MAP_KEY(ImGuiKey_Enter,     ImGuiNavInput_Input    );
        NAV_MAP_KEY(ImGuiKey_Escape,    ImGuiNavInput_Cancel   );
        NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_ );
        NAV_MAP_KEY(ImGuiKey_RightArrow,ImGuiNavInput_KeyRight_);
        NAV_MAP_KEY(ImGuiKey_UpArrow,   ImGuiNavInput_KeyUp_   );
        NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_ );
        if (g.IO.KeyCtrl)   g.IO.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;
        if (g.IO.KeyShift)  g.IO.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;
        if (g.IO.KeyAlt)    g.IO.NavInputs[ImGuiNavInput_KeyMenu_]  = 1.0f;
        #undef NAV_MAP_KEY
    }
    memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)
        g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Process navigation init request (select first/default focus)
    if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))
    {
        // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
        IM_ASSERT(g.NavWindow);
        if (g.NavInitRequestFromMove)
            SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);
        else
            SetNavID(g.NavInitResultId, g.NavLayer);
        g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;
    }
    g.NavInitRequest = false;
    g.NavInitRequestFromMove = false;
    g.NavInitResultId = 0;
    g.NavJustMovedToId = 0;

    // Process navigation move request
    if (g.NavMoveRequest)
        NavUpdateMoveResult();

    // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
    if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)
    {
        IM_ASSERT(g.NavMoveRequest);
        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
            g.NavDisableHighlight = false;
        g.NavMoveRequestForward = ImGuiNavForward_None;
    }

    // Apply application mouse position movement, after we had a chance to process move request result.
    if (g.NavMousePosDirty && g.NavIdIsAlive)
    {
        // Set mouse position given our knowledge of the navigated item position from last frame
        if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
        {
            if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
            {
                g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();
                g.IO.WantSetMousePos = true;
            }
        }
        g.NavMousePosDirty = false;
    }
    g.NavIdIsAlive = false;
    g.NavJustTabbedId = 0;
    IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);

    // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
    if (g.NavWindow)
        NavSaveLastChildNavWindow(g.NavWindow);
    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)
        g.NavWindow->NavLastChildNavWindow = NULL;

    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
    NavUpdateWindowing();

    // Set output flags for user application
    g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
    g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);

    // Process NavCancel input (to close a popup, get back to parent, clear focus)
    if (IsNavInputPressed(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))
    {
        if (g.ActiveId != 0)
        {
            if (!(g.ActiveIdBlockNavInputFlags & (1 << ImGuiNavInput_Cancel)))
                ClearActiveID();
        }
        else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
        {
            // Exit child window
            ImGuiWindow* child_window = g.NavWindow;
            ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
            IM_ASSERT(child_window->ChildId != 0);
            FocusWindow(parent_window);
            SetNavID(child_window->ChildId, 0);
            g.NavIdIsAlive = false;
            if (g.NavDisableMouseHover)
                g.NavMousePosDirty = true;
        }
        else if (g.OpenPopupStack.Size > 0)
        {
            // Close open popup/menu
            if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
                ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
        }
        else if (g.NavLayer != 0)
        {
            // Leave the "menu" layer
            NavRestoreLayer(ImGuiNavLayer_Main);
        }
        else
        {
            // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
            if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
                g.NavWindow->NavLastIds[0] = 0;
            g.NavId = 0;
        }
    }

    // Process manual activation request
    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;
    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
    {
        bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);
        bool activate_pressed = activate_down && IsNavInputPressed(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);
        if (g.ActiveId == 0 && activate_pressed)
            g.NavActivateId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
            g.NavActivateDownId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
            g.NavActivatePressedId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))
            g.NavInputId = g.NavId;
    }
    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        g.NavDisableHighlight = true;
    if (g.NavActivateId != 0)
        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
    g.NavMoveRequest = false;

    // Process programmatic activation request
    if (g.NavNextActivateId != 0)
        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
    g.NavNextActivateId = 0;

    // Initiate directional inputs request
    const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;
    if (g.NavMoveRequestForward == ImGuiNavForward_None)
    {
        g.NavMoveDir = ImGuiDir_None;
        g.NavMoveRequestFlags = ImGuiNavMoveFlags_None;
        if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        {
            if ((allowed_dir_flags & (1<<ImGuiDir_Left))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadLeft, ImGuiNavInput_KeyLeft_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Left;
            if ((allowed_dir_flags & (1<<ImGuiDir_Right)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadRight,ImGuiNavInput_KeyRight_,ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Right;
            if ((allowed_dir_flags & (1<<ImGuiDir_Up))    && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadUp,   ImGuiNavInput_KeyUp_,   ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Up;
            if ((allowed_dir_flags & (1<<ImGuiDir_Down))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadDown, ImGuiNavInput_KeyDown_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Down;
        }
        g.NavMoveClipDir = g.NavMoveDir;
    }
    else
    {
        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)
        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
        IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);
        g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;
    }

    // Update PageUp/PageDown scroll
    float nav_scoring_rect_offset_y = 0.0f;
    if (nav_keyboard_active)
        nav_scoring_rect_offset_y = NavUpdatePageUpPageDown(allowed_dir_flags);

    // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
    if (g.NavMoveDir != ImGuiDir_None)
    {
        g.NavMoveRequest = true;
        g.NavMoveDirLast = g.NavMoveDir;
    }
    if (g.NavMoveRequest && g.NavId == 0)
    {
        g.NavInitRequest = g.NavInitRequestFromMove = true;
        g.NavInitResultId = 0;
        g.NavDisableHighlight = false;
    }
    NavUpdateAnyRequestFlag();

    // Scrolling
    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
    {
        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
        ImGuiWindow* window = g.NavWindow;
        const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
        if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)
        {
            if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)
                SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
            if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)
                SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        }

        // *Normal* Manual scroll with NavScrollXXX keys
        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
        ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f/10.0f, 10.0f);
        if (scroll_dir.x != 0.0f && window->ScrollbarX)
        {
            SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
        if (scroll_dir.y != 0.0f)
        {
            SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
    }

    // Reset search results
    g.NavMoveResultLocal.Clear();
    g.NavMoveResultLocalVisibleSet.Clear();
    g.NavMoveResultOther.Clear();

    // When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items
    if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)
    {
        ImGuiWindow* window = g.NavWindow;
        ImRect window_rect_rel(window->InnerMainRect.Min - window->Pos - ImVec2(1,1), window->InnerMainRect.Max - window->Pos + ImVec2(1,1));
        if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
        {
            float pad = window->CalcFontSize() * 0.5f;
            window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item
            window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);
            g.NavId = 0;
        }
        g.NavMoveFromClampedRefRect = false;
    }

    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
    ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0,0,0,0);
    g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();
    g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);
    g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);
    g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;
    IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().
    //g.OverlayDrawList.AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
    g.NavScoringCount = 0;
#if IMGUI_DEBUG_NAV_RECTS
    if (g.NavWindow) { for (int layer = 0; layer < 2; layer++) GetOverlayDrawList(g.NavWindow)->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255,200,0,255)); } // [DEBUG]
    if (g.NavWindow) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); GetOverlayDrawList(g.NavWindow)->AddCircleFilled(p, 3.0f, col); GetOverlayDrawList(g.NavWindow)->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
#endif
}

// Apply result from previous frame navigation directional move request
static void ImGui::NavUpdateMoveResult()
{
    ImGuiContext& g = *GImGui;
    if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
    {
        // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
        if (g.NavId != 0)
        {
            g.NavDisableHighlight = false;
            g.NavDisableMouseHover = true;
        }
        return;
    }

    // Select which result to use
    ImGuiNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
    if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
        if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)
            result = &g.NavMoveResultLocalVisibleSet;

    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
            result = &g.NavMoveResultOther;
    IM_ASSERT(g.NavWindow && result->Window);

    // Scroll to keep newly navigated item fully into view.
    if (g.NavLayer == 0)
    {
        ImRect rect_abs = ImRect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);
        NavScrollToBringItemIntoView(result->Window, rect_abs);

        // Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()
        ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(result->Window, false);
        ImVec2 delta_scroll = result->Window->Scroll - next_scroll;
        result->RectRel.Translate(delta_scroll);

        // Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).
        if (result->Window->Flags & ImGuiWindowFlags_ChildWindow)
            NavScrollToBringItemIntoView(result->Window->ParentWindow, ImRect(rect_abs.Min + delta_scroll, rect_abs.Max + delta_scroll));
    }

    ClearActiveID();
    g.NavWindow = result->Window;
    if (g.NavId != result->ID)
    {
        // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
        g.NavJustMovedToId = result->ID;
        g.NavJustMovedToSelectScopeId = result->SelectScopeId;
    }
    SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);
    g.NavMoveFromClampedRefRect = false;
}

static float ImGui::NavUpdatePageUpPageDown(int allowed_dir_flags)
{
    ImGuiContext& g = *GImGui;
    if (g.NavMoveDir == ImGuiDir_None && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget && g.NavLayer == 0)
    {
        ImGuiWindow* window = g.NavWindow;
        bool page_up_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageUp]) && (allowed_dir_flags & (1 << ImGuiDir_Up));
        bool page_down_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageDown]) && (allowed_dir_flags & (1 << ImGuiDir_Down));
        if (page_up_held != page_down_held) // If either (not both) are pressed
        {
            if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll)
            {
                // Fallback manual-scroll when window has no navigable item
                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))
                    SetWindowScrollY(window, window->Scroll.y - window->InnerClipRect.GetHeight());
                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))
                    SetWindowScrollY(window, window->Scroll.y + window->InnerClipRect.GetHeight());
            }
            else
            {
                const ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
                const float page_offset_y = ImMax(0.0f, window->InnerClipRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
                float nav_scoring_rect_offset_y = 0.0f;
                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))
                {
                    nav_scoring_rect_offset_y = -page_offset_y;
                    g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = ImGuiDir_Up;
                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
                }
                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))
                {
                    nav_scoring_rect_offset_y = +page_offset_y;
                    g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = ImGuiDir_Down;
                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
                }
                return nav_scoring_rect_offset_y;
            }
        }
    }
    return 0.0f;
}

static int FindWindowFocusIndex(ImGuiWindow* window) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = g.WindowsFocusOrder.Size-1; i >= 0; i--)
        if (g.WindowsFocusOrder[i] == window)
            return i;
    return -1;
}

static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
            return g.WindowsFocusOrder[i];
    return NULL;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget);
    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
        return;

    const int i_current = FindWindowFocusIndex(g.NavWindowingTarget);
    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
    if (!window_target)
        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
    if (window_target) // Don't reset windowing target if there's a single window in the list
        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
    g.NavWindowingToggleLayer = false;
}

// Window management mode (hold to: change focus/move/resize, tap to: toggle menu layer)
static void ImGui::NavUpdateWindowing()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* apply_focus_window = NULL;
    bool apply_toggle_layer = false;

    ImGuiWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window != NULL)
    {
        g.NavWindowingTarget = NULL;
        return;
    }

    // Fade out
    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
    {
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);
        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
            g.NavWindowingTargetAnim = NULL;
    }

    // Start CTRL-TAB or Square+L/R window selection
    bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);
    bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);
    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
        {
            g.NavWindowingTarget = g.NavWindowingTargetAnim = window;
            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
            g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;
        }

    // Gamepad update
    g.NavWindowingTimer += g.IO.DeltaTime;
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad)
    {
        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));

        // Select window to focus
        const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);
        if (focus_change_dir != 0)
        {
            NavUpdateWindowingHighlightWindow(focus_change_dir);
            g.NavWindowingHighlightAlpha = 1.0f;
        }

        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)
        if (!IsNavInputDown(ImGuiNavInput_Menu))
        {
            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
            if (g.NavWindowingToggleLayer && g.NavWindow)
                apply_toggle_layer = true;
            else if (!g.NavWindowingToggleLayer)
                apply_focus_window = g.NavWindowingTarget;
            g.NavWindowingTarget = NULL;
        }
    }

    // Keyboard: Focus
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard)
    {
        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
        if (IsKeyPressedMap(ImGuiKey_Tab, true))
            NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);
        if (!g.IO.KeyCtrl)
            apply_focus_window = g.NavWindowingTarget;
    }

    // Keyboard: Press and Release ALT to toggle menu layer
    // FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB
    if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))
        if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))
            apply_toggle_layer = true;

    // Move window
    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
    {
        ImVec2 move_delta;
        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_NavGamepad)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);
        if (move_delta.x != 0.0f || move_delta.y != 0.0f)
        {
            const float NAV_MOVE_SPEED = 800.0f;
            const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't code variable framerate very well
            g.NavWindowingTarget->RootWindow->Pos += move_delta * move_speed;
            g.NavDisableMouseHover = true;
            MarkIniSettingsDirty(g.NavWindowingTarget);
        }
    }

    // Apply final focus
    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
    {
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
        ClosePopupsOverWindow(apply_focus_window);
        FocusWindow(apply_focus_window);
        if (apply_focus_window->NavLastIds[0] == 0)
            NavInitWindow(apply_focus_window, false);

        // If the window only has a menu layer, select it directly
        if (apply_focus_window->DC.NavLayerActiveMask == (1 << ImGuiNavLayer_Menu))
            g.NavLayer = ImGuiNavLayer_Menu;
    }
    if (apply_focus_window)
        g.NavWindowingTarget = NULL;

    // Apply menu/layer toggle
    if (apply_toggle_layer && g.NavWindow)
    {
        // Move to parent menu if necessary
        ImGuiWindow* new_nav_window = g.NavWindow;
        while ((new_nav_window->DC.NavLayerActiveMask & (1 << 1)) == 0
            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
            new_nav_window = new_nav_window->ParentWindow;
        if (new_nav_window != g.NavWindow)
        {
            ImGuiWindow* old_nav_window = g.NavWindow;
            FocusWindow(new_nav_window);
            new_nav_window->NavLastChildNavWindow = old_nav_window;
        }
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        NavRestoreLayer((g.NavWindow->DC.NavLayerActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main);
    }
}

// Window has already passed the IsWindowNavFocusable()
static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)
{
    if (window->Flags & ImGuiWindowFlags_Popup)
        return "(Popup)";
    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
        return "(Main menu bar)";
    return "(Untitled)";
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void ImGui::NavUpdateWindowingList()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget != NULL);

    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
        return;

    if (g.NavWindowingList == NULL)
        g.NavWindowingList = FindWindowByName("###NavWindowingList");
    SetNextWindowSizeConstraints(ImVec2(g.IO.DisplaySize.x * 0.20f, g.IO.DisplaySize.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));
    SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Always, ImVec2(0.5f, 0.5f));
    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
    Begin("###NavWindowingList", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)
    {
        ImGuiWindow* window = g.WindowsFocusOrder[n];
        if (!IsWindowNavFocusable(window))
            continue;
        const char* label = window->Name;
        if (label == FindRenderedTextEnd(label))
            label = GetFallbackWindowNameForWindowingList(window);
        Selectable(label, g.NavWindowingTarget == window);
    }
    End();
    PopStyleVar();
}

//-----------------------------------------------------------------------------
// [SECTION] COLUMNS
// In the current version, Columns are very weak. Needs to be replaced with a more full-featured system.
//-----------------------------------------------------------------------------

void ImGui::NextColumn()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems || window->DC.ColumnsSet == NULL)
        return;

    ImGuiContext& g = *GImGui;
    PopItemWidth();
    PopClipRect();

    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    if (++columns->Current < columns->Count)
    {
        // Columns 1+ cancel out IndentX
        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + g.Style.ItemSpacing.x;
        window->DrawList->ChannelsSetCurrent(columns->Current);
    }
    else
    {
        window->DC.ColumnsOffset.x = 0.0f;
        window->DrawList->ChannelsSetCurrent(0);
        columns->Current = 0;
        columns->LineMinY = columns->LineMaxY;
    }
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = columns->LineMinY;
    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);
    window->DC.CurrentLineTextBaseOffset = 0.0f;

    PushColumnClipRect();
    PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME: Move on columns setup
}

int ImGui::GetColumnIndex()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Current : 0;
}

int ImGui::GetColumnsCount()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Count : 1;
}

static float OffsetNormToPixels(const ImGuiColumnsSet* columns, float offset_norm)
{
    return offset_norm * (columns->MaxX - columns->MinX);
}

static float PixelsToOffsetNorm(const ImGuiColumnsSet* columns, float offset)
{
    return offset / (columns->MaxX - columns->MinX);
}

static inline float GetColumnsRectHalfWidth() { return 4.0f; }

static float GetDraggedColumnOffset(ImGuiColumnsSet* columns, int column_index)
{
    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + GetColumnsRectHalfWidth() - window->Pos.x;
    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
    if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))
        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

    return x;
}

float ImGui::GetColumnOffset(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const float t = columns->Columns[column_index].OffsetNorm;
    const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);
    return x_offset;
}

static float GetColumnWidthEx(ImGuiColumnsSet* columns, int column_index, bool before_resize = false)
{
    if (column_index < 0)
        column_index = columns->Current;

    float offset_norm;
    if (before_resize)
        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    else
        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    return OffsetNormToPixels(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count-1);
    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

    if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))
        offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);

    if (preserve_width)
        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    if (column_index < 0)
        column_index = columns->Current;

    PushClipRect(columns->Columns[column_index].ClipRect.Min, columns->Columns[column_index].ClipRect.Max, false);
}

static ImGuiColumnsSet* FindOrAddColumnsSet(ImGuiWindow* window, ImGuiID id)
{
    for (int n = 0; n < window->ColumnsStorage.Size; n++)
        if (window->ColumnsStorage[n].ID == id)
            return &window->ColumnsStorage[n];

    window->ColumnsStorage.push_back(ImGuiColumnsSet());
    ImGuiColumnsSet* columns = &window->ColumnsStorage.back();
    columns->ID = id;
    return columns;
}

void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    IM_ASSERT(columns_count > 1);
    IM_ASSERT(window->DC.ColumnsSet == NULL); // Nested columns are currently not supported

    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    PushID(0x11223347 + (str_id ? 0 : columns_count));
    ImGuiID id = window->GetID(str_id ? str_id : "columns");
    PopID();

    // Acquire storage for the columns set
    ImGuiColumnsSet* columns = FindOrAddColumnsSet(window, id);
    IM_ASSERT(columns->ID == id);
    columns->Current = 0;
    columns->Count = columns_count;
    columns->Flags = flags;
    window->DC.ColumnsSet = columns;

    // Set state for first column
    const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);
    columns->MinX = window->DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range
    columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);
    columns->StartPosY = window->DC.CursorPos.y;
    columns->StartMaxPosX = window->DC.CursorMaxPos.x;
    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

    // Clear data if columns count changed
    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
        columns->Columns.resize(0);

    // Initialize defaults
    columns->IsFirstFrame = (columns->Columns.Size == 0);
    if (columns->Columns.Size == 0)
    {
        columns->Columns.reserve(columns_count + 1);
        for (int n = 0; n < columns_count + 1; n++)
        {
            ImGuiColumnData column;
            column.OffsetNorm = n / (float)columns_count;
            columns->Columns.push_back(column);
        }
    }

    for (int n = 0; n < columns_count; n++)
    {
        // Compute clipping rectangle
        ImGuiColumnData* column = &columns->Columns[n];
        float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n) - 1.0f);
        float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
        column->ClipRect.ClipWith(window->ClipRect);
    }

    window->DrawList->ChannelsSplit(columns->Count);
    PushColumnClipRect();
    PushItemWidth(GetColumnWidth() * 0.65f);
}

void ImGui::EndColumns()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    PopItemWidth();
    PopClipRect();
    window->DrawList->ChannelsMerge();

    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    window->DC.CursorPos.y = columns->LineMaxY;
    if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))
        window->DC.CursorMaxPos.x = columns->StartMaxPosX;  // Restore cursor max pos, as columns don't grow parent

    // Draw columns borders and handle resize
    bool is_being_resized = false;
    if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)
    {
        const float y1 = columns->StartPosY;
        const float y2 = window->DC.CursorPos.y;
        int dragging_column = -1;
        for (int n = 1; n < columns->Count; n++)
        {
            float x = window->Pos.x + GetColumnOffset(n);
            const ImGuiID column_id = columns->ID + ImGuiID(n);
            const float column_hw = GetColumnsRectHalfWidth(); // Half-width for interaction
            const ImRect column_rect(ImVec2(x - column_hw, y1), ImVec2(x + column_hw, y2));
            KeepAliveID(column_id);
            if (IsClippedEx(column_rect, column_id, false))
                continue;

            bool hovered = false, held = false;
            if (!(columns->Flags & ImGuiColumnsFlags_NoResize))
            {
                ButtonBehavior(column_rect, column_id, &hovered, &held);
                if (hovered || held)
                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;
                if (held && !(columns->Columns[n].Flags & ImGuiColumnsFlags_NoResize))
                    dragging_column = n;
            }

            // Draw column (we clip the Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.)
            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
            const float xi = (float)(int)x;
            window->DrawList->AddLine(ImVec2(xi, ImMax(y1 + 1.0f, window->ClipRect.Min.y)), ImVec2(xi, ImMin(y2, window->ClipRect.Max.y)), col);
        }

        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
        if (dragging_column != -1)
        {
            if (!columns->IsBeingResized)
                for (int n = 0; n < columns->Count + 1; n++)
                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
            columns->IsBeingResized = is_being_resized = true;
            float x = GetDraggedColumnOffset(columns, dragging_column);
            SetColumnOffset(dragging_column, x);
        }
    }
    columns->IsBeingResized = is_being_resized;

    window->DC.ColumnsSet = NULL;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
}

// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]
void ImGui::Columns(int columns_count, const char* id, bool border)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(columns_count >= 1);

    ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);
    //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
    if (window->DC.ColumnsSet != NULL && window->DC.ColumnsSet->Count == columns_count && window->DC.ColumnsSet->Flags == flags)
        return;

    if (window->DC.ColumnsSet != NULL)
        EndColumns();

    if (columns_count != 1)
        BeginColumns(id, columns_count, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

void ImGui::ClearDragDrop()
{
    ImGuiContext& g = *GImGui;
    g.DragDropActive = false;
    g.DragDropPayload.Clear();
    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropAcceptFrameCount = -1;

    g.DragDropPayloadBufHeap.clear();
    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}

// Call when current ID is active.
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    bool source_drag_active = false;
    ImGuiID source_id = 0;
    ImGuiID source_parent_id = 0;
    int mouse_button = 0;
    if (!(flags & ImGuiDragDropFlags_SourceExtern))
    {
        source_id = window->DC.LastItemId;
        if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case
            return false;
        if (g.IO.MouseDown[mouse_button] == false)
            return false;

        if (source_id == 0)
        {
            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
            {
                IM_ASSERT(0);
                return false;
            }

            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
            bool is_hovered = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) != 0;
            if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != window))
                return false;
            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);
            if (is_hovered)
                SetHoveredID(source_id);
            if (is_hovered && g.IO.MouseClicked[mouse_button])
            {
                SetActiveID(source_id, window);
                FocusWindow(window);
            }
            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
                g.ActiveIdAllowOverlap = is_hovered;
        }
        else
        {
            g.ActiveIdAllowOverlap = false;
        }
        if (g.ActiveId != source_id)
            return false;
        source_parent_id = window->IDStack.back();
        source_drag_active = IsMouseDragging(mouse_button);
    }
    else
    {
        window = NULL;
        source_id = ImHashStr("#SourceExtern", 0);
        source_drag_active = true;
    }

    if (source_drag_active)
    {
        if (!g.DragDropActive)
        {
            IM_ASSERT(source_id != 0);
            ClearDragDrop();
            ImGuiPayload& payload = g.DragDropPayload;
            payload.SourceId = source_id;
            payload.SourceParentId = source_parent_id;
            g.DragDropActive = true;
            g.DragDropSourceFlags = flags;
            g.DragDropMouseButton = mouse_button;
        }
        g.DragDropSourceFrameCount = g.FrameCount;
        g.DragDropWithinSourceOrTarget = true;

        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        {
            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
            BeginTooltip();
            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
            {
                ImGuiWindow* tooltip_window = g.CurrentWindow;
                tooltip_window->SkipItems = true;
                tooltip_window->HiddenFramesRegular = 1;
            }
        }

        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
            window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

        return true;
    }
    return false;
}

void ImGui::EndDragDropSource()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget && "Not after a BeginDragDropSource()?");

    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        EndTooltip();

    // Discard the drag if have not called SetDragDropPayload()
    if (g.DragDropPayload.DataFrameCount == -1)
        ClearDragDrop();
    g.DragDropWithinSourceOrTarget = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    ImGuiPayload& payload = g.DragDropPayload;
    if (cond == 0)
        cond = ImGuiCond_Always;

    IM_ASSERT(type != NULL);
    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()

    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
    {
        // Copy payload
        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
        g.DragDropPayloadBufHeap.resize(0);
        if (data_size > sizeof(g.DragDropPayloadBufLocal))
        {
            // Store in heap
            g.DragDropPayloadBufHeap.resize((int)data_size);
            payload.Data = g.DragDropPayloadBufHeap.Data;
            memcpy(payload.Data, data, data_size);
        }
        else if (data_size > 0)
        {
            // Store locally
            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
            payload.Data = g.DragDropPayloadBufLocal;
            memcpy(payload.Data, data, data_size);
        }
        else
        {
            payload.Data = NULL;
        }
        payload.DataSize = (int)data_size;
    }
    payload.DataFrameCount = g.FrameCount;

    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;
    IM_ASSERT(id != 0);
    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
        return false;
    if (window->SkipItems)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = bb;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool ImGui::BeginDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;

    const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;
    ImGuiID id = window->DC.LastItemId;
    if (id == 0)
        id = window->GetIDFromRectangle(display_rect);
    if (g.DragDropPayload.SourceId == id)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = display_rect;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiPayload& payload = g.DragDropPayload;
    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
    if (type != NULL && !payload.IsDataType(type))
        return NULL;

    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    ImRect r = g.DragDropTargetRect;
    float r_surface = r.GetWidth() * r.GetHeight();
    if (r_surface < g.DragDropAcceptIdCurrRectSurface)
    {
        g.DragDropAcceptFlags = flags;
        g.DragDropAcceptIdCurr = g.DragDropTargetId;
        g.DragDropAcceptIdCurrRectSurface = r_surface;
    }

    // Render default drop visuals
    payload.Preview = was_accepted_previously;
    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)
    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
    {
        // FIXME-DRAG: Settle on a proper default visuals for drop target.
        r.Expand(3.5f);
        bool push_clip_rect = !window->ClipRect.Contains(r);
        if (push_clip_rect) window->DrawList->PushClipRect(r.Min-ImVec2(1,1), r.Max+ImVec2(1,1));
        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);
        if (push_clip_rect) window->DrawList->PopClipRect();
    }

    g.DragDropAcceptFrameCount = g.FrameCount;
    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
        return NULL;

    return &payload;
}

const ImGuiPayload* ImGui::GetDragDropPayload()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive ? &g.DragDropPayload : NULL;
}

// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.
void ImGui::EndDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget);
    g.DragDropWithinSourceOrTarget = false;
}

//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard. 
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
void ImGui::LogText(const char* fmt, ...)
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    va_list args;
    va_start(args, fmt);
    if (g.LogFile)
        vfprintf(g.LogFile, fmt, args);
    else
        g.LogClipboard.appendfv(fmt, args);
    va_end(args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = FindRenderedTextEnd(text, text_end);

    const bool log_new_line = ref_pos && (ref_pos->y > window->DC.LogLinePosY + 1);
    if (ref_pos)
        window->DC.LogLinePosY = ref_pos->y;

    const char* text_remaining = text;
    if (g.LogStartDepth > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth
        g.LogStartDepth = window->DC.TreeDepth;
    const int tree_depth = (window->DC.TreeDepth - g.LogStartDepth);
    for (;;)
    {
        // Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.
        const char* line_start = text_remaining;
        const char* line_end = ImStreolRange(line_start, text_end);
        const bool is_first_line = (line_start == text);
        const bool is_last_line = (line_end == text_end);
        if (!is_last_line || (line_start != line_end))
        {
            const int char_count = (int)(line_end - line_start);
            if (log_new_line || !is_first_line)
                LogText(IM_NEWLINE "%*s%.*s", tree_depth*4, "", char_count, line_start);
            else
                LogText(" %.*s", char_count, line_start);
        }

        if (is_last_line)
            break;
        text_remaining = line_end + 1;
    }
}

// Start logging ImGui output to TTY
void ImGui::LogToTTY(int max_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = stdout;
    g.LogEnabled = true;
    g.LogStartDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

// Start logging ImGui output to given file
void ImGui::LogToFile(int max_depth, const char* filename)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    if (!filename)
    {
        filename = g.IO.LogFilename;
        if (!filename)
            return;
    }

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = ImFileOpen(filename, "ab");
    if (!g.LogFile)
    {
        IM_ASSERT(0);
        return;
    }
    g.LogEnabled = true;
    g.LogStartDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

// Start logging ImGui output to clipboard
void ImGui::LogToClipboard(int max_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = NULL;
    g.LogEnabled = true;
    g.LogStartDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

void ImGui::LogFinish()
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    LogText(IM_NEWLINE);
    if (g.LogFile != NULL)
    {
        if (g.LogFile == stdout)
            fflush(g.LogFile);
        else
            fclose(g.LogFile);
        g.LogFile = NULL;
    }
    if (g.LogClipboard.size() > 1)
    {
        SetClipboardText(g.LogClipboard.begin());
        g.LogClipboard.clear();
    }
    g.LogEnabled = false;
}

// Helper to display logging buttons
void ImGui::LogButtons()
{
    ImGuiContext& g = *GImGui;

    PushID("LogButtons");
    const bool log_to_tty = Button("Log To TTY"); SameLine();
    const bool log_to_file = Button("Log To File"); SameLine();
    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
    PushItemWidth(80.0f);
    PushAllowKeyboardFocus(false);
    SliderInt("Depth", &g.LogAutoExpandMaxDepth, 0, 9, NULL);
    PopAllowKeyboardFocus();
    PopItemWidth();
    PopID();

    // Start logging at the end of the function so that the buttons don't appear in the log
    if (log_to_tty)
        LogToTTY(g.LogAutoExpandMaxDepth);
    if (log_to_file)
        LogToFile(g.LogAutoExpandMaxDepth, g.IO.LogFilename);
    if (log_to_clipboard)
        LogToClipboard(g.LogAutoExpandMaxDepth);
}

//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------

void ImGui::MarkIniSettingsDirty()
{
    ImGuiContext& g = *GImGui;
    if (g.SettingsDirtyTimer <= 0.0f)
        g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
        if (g.SettingsDirtyTimer <= 0.0f)
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)
{
    ImGuiContext& g = *GImGui;
    g.SettingsWindows.push_back(ImGuiWindowSettings());
    ImGuiWindowSettings* settings = &g.SettingsWindows.back();
    settings->Name = ImStrdup(name);
    settings->ID = ImHashStr(name, 0);
    return settings;
}

ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    for (int i = 0; i != g.SettingsWindows.Size; i++)
        if (g.SettingsWindows[i].ID == id)
            return &g.SettingsWindows[i];
    return NULL;
}

ImGuiWindowSettings* ImGui::FindOrCreateWindowSettings(const char* name)
{
    if (ImGuiWindowSettings* settings = FindWindowSettings(ImHashStr(name, 0)))
        return settings;
    return CreateNewWindowSettings(name);
}

void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
{
    size_t file_data_size = 0;
    char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
    if (!file_data)
        return;
    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
    ImGui::MemFree(file_data);
}

ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
{
    ImGuiContext& g = *GImGui;
    const ImGuiID type_hash = ImHashStr(type_name, 0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
            return &g.SettingsHandlers[handler_n];
    return NULL;
}

// Zero-tolerance, no error reporting, cheap .ini parsing
void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
    if (ini_size == 0)
        ini_size = strlen(ini_data);
    char* buf = (char*)ImGui::MemAlloc(ini_size + 1);
    char* buf_end = buf + ini_size;
    memcpy(buf, ini_data, ini_size);
    buf[ini_size] = 0;

    void* entry_data = NULL;
    ImGuiSettingsHandler* entry_handler = NULL;

    char* line_end = NULL;
    for (char* line = buf; line < buf_end; line = line_end + 1)
    {
        // Skip new lines markers, then find end of the line
        while (*line == '\n' || *line == '\r')
            line++;
        line_end = line;
        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
            line_end++;
        line_end[0] = 0;
        if (line[0] == ';')
            continue;
        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        {
            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
            line_end[-1] = 0;
            const char* name_end = line_end - 1;
            const char* type_start = line + 1;
            char* type_end = (char*)(intptr_t)ImStrchrRange(type_start, name_end, ']');
            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
            if (!type_end || !name_start)
            {
                name_start = type_start; // Import legacy entries that have no type
                type_start = "Window";
            }
            else
            {
                *type_end = 0; // Overwrite first ']'
                name_start++;  // Skip second '['
            }
            entry_handler = FindSettingsHandler(type_start);
            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
        }
        else if (entry_handler != NULL && entry_data != NULL)
        {
            // Let type handler parse the line
            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
        }
    }
    ImGui::MemFree(buf);
    g.SettingsLoaded = true;
}

void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    if (!ini_filename)
        return;

    size_t ini_data_size = 0;
    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
    FILE* f = ImFileOpen(ini_filename, "wt");
    if (!f)
        return;
    fwrite(ini_data, sizeof(char), ini_data_size, f);
    fclose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    g.SettingsIniData.Buf.resize(0);
    g.SettingsIniData.Buf.push_back(0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
    {
        ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];
        handler->WriteAllFn(&g, handler, &g.SettingsIniData);
    }
    if (out_size)
        *out_size = (size_t)g.SettingsIniData.size();
    return g.SettingsIniData.c_str();
}

static void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiWindowSettings* settings = ImGui::FindWindowSettings(ImHashStr(name, 0));
    if (!settings)
        settings = ImGui::CreateNewWindowSettings(name);
    return (void*)settings;
}

static void SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
    float x, y;
    int i;
    if (sscanf(line, "Pos=%f,%f", &x, &y) == 2)         settings->Pos = ImVec2(x, y);
    else if (sscanf(line, "Size=%f,%f", &x, &y) == 2)   settings->Size = ImMax(ImVec2(x, y), GImGui->Style.WindowMinSize);
    else if (sscanf(line, "Collapsed=%d", &i) == 1)     settings->Collapsed = (i != 0);
}

static void SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    // Gather data from windows that were active during this session
    // (if a window wasn't opened in this session we preserve its settings)
    ImGuiContext& g = *imgui_ctx;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
            continue;

        ImGuiWindowSettings* settings = (window->SettingsIdx != -1) ? &g.SettingsWindows[window->SettingsIdx] : ImGui::FindWindowSettings(window->ID);
        if (!settings)
        {
            settings = ImGui::CreateNewWindowSettings(window->Name);
            window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);
        }
        IM_ASSERT(settings->ID == window->ID);
        settings->Pos = window->Pos;
        settings->Size = window->SizeFull;
        settings->Collapsed = window->Collapsed;
    }

    // Write to text buffer
    buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve
    for (int i = 0; i != g.SettingsWindows.Size; i++)
    {
        const ImGuiWindowSettings* settings = &g.SettingsWindows[i];
        if (settings->Pos.x == FLT_MAX)
            continue;
        const char* name = settings->Name;
        if (const char* p = strstr(name, "###"))  // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
            name = p;
        buf->appendf("[%s][%s]\n", handler->TypeName, name);
        buf->appendf("Pos=%d,%d\n", (int)settings->Pos.x, (int)settings->Pos.y);
        buf->appendf("Size=%d,%d\n", (int)settings->Size.x, (int)settings->Size.y);
        buf->appendf("Collapsed=%d\n", settings->Collapsed);
        buf->appendf("\n");
    }
}

//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(_WINDOWS_) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && (!defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef __MINGW32__
#include <Windows.h>
#else
#include <windows.h>
#endif
#endif

// Win32 API clipboard implementation
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#endif

static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    static ImVector<char> buf_local;
    buf_local.clear();
    if (!::OpenClipboard(NULL))
        return NULL;
    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return NULL;
    }
    if (ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle))
    {
        int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;
        buf_local.resize(buf_len);
        ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);
    }
    ::GlobalUnlock(wbuf_handle);
    ::CloseClipboard();
    return buf_local.Data;
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    if (!::OpenClipboard(NULL))
        return;
    const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;
    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return;
    }
    ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle);
    ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);
    ::GlobalUnlock(wbuf_handle);
    ::EmptyClipboard();
    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
        ::GlobalFree(wbuf_handle);
    ::CloseClipboard();
}

#else

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    ImGuiContext& g = *GImGui;
    return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();
}

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    ImGuiContext& g = *GImGui;
    g.PrivateClipboard.clear();
    const char* text_end = text + strlen(text);
    g.PrivateClipboard.resize((int)(text_end - text) + 1);
    memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));
    g.PrivateClipboard[(int)(text_end - text)] = 0;
}

#endif

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)
{
    // Notify OS Input Method Editor of text input position
    if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)
        if (HIMC himc = ::ImmGetContext(hwnd))
        {
            COMPOSITIONFORM cf;
            cf.ptCurrentPos.x = x;
            cf.ptCurrentPos.y = y;
            cf.dwStyle = CFS_FORCE_POSITION;
            ::ImmSetCompositionWindow(himc, &cf);
            ::ImmReleaseContext(hwnd, himc);
        }
}

#else

static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}

#endif

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUG WINDOW
//-----------------------------------------------------------------------------

void ImGui::ShowMetricsWindow(bool* p_open)
{
    if (!ImGui::Begin("ImGui Metrics", p_open))
    {
        ImGui::End();
        return;
    }

    static bool show_draw_cmd_clip_rects = true;
    static bool show_window_begin_order = false;
    ImGuiIO& io = ImGui::GetIO();
    ImGui::Text("Dear ImGui %s", ImGui::GetVersion());
    ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
    ImGui::Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
    ImGui::Text("%d active windows (%d visible)", io.MetricsActiveWindows, io.MetricsRenderWindows);
    ImGui::Text("%d allocations", io.MetricsActiveAllocations);
    ImGui::Checkbox("Show clipping rectangles when hovering draw commands", &show_draw_cmd_clip_rects);
    ImGui::Checkbox("Ctrl shows window begin order", &show_window_begin_order);
    ImGui::Separator();

    struct Funcs
    {
        static void NodeDrawList(ImGuiWindow* window, ImDrawList* draw_list, const char* label)
        {
            bool node_open = ImGui::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);
            if (draw_list == ImGui::GetWindowDrawList())
            {
                ImGui::SameLine();
                ImGui::TextColored(ImVec4(1.0f,0.4f,0.4f,1.0f), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
                if (node_open) ImGui::TreePop();
                return;
            }

            ImDrawList* overlay_draw_list = GetOverlayDrawList(window); // Render additional visuals into the top-most draw list
            if (window && IsItemHovered())
                overlay_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
            if (!node_open)
                return;

            int elem_offset = 0;
            for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)
            {
                if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)
                    continue;
                if (pcmd->UserCallback)
                {
                    ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
                    continue;
                }
                ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
                bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
                if (show_draw_cmd_clip_rects && ImGui::IsItemHovered())
                {
                    ImRect clip_rect = pcmd->ClipRect;
                    ImRect vtxs_rect;
                    for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)
                        vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);
                    clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));
                    vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));
                }
                if (!pcmd_node_open)
                    continue;

                // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
                ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
                while (clipper.Step())
                    for (int prim = clipper.DisplayStart, idx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)
                    {
                        char buf[300];
                        char *buf_p = buf, *buf_end = buf + IM_ARRAYSIZE(buf);
                        ImVec2 triangles_pos[3];
                        for (int n = 0; n < 3; n++, idx_i++)
                        {
                            int vtx_i = idx_buffer ? idx_buffer[idx_i] : idx_i;
                            ImDrawVert& v = draw_list->VtxBuffer[vtx_i];
                            triangles_pos[n] = v.pos;
                            buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",
                                (n == 0) ? "idx" : "   ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
                        }
                        ImGui::Selectable(buf, false);
                        if (ImGui::IsItemHovered())
                        {
                            ImDrawListFlags backup_flags = overlay_draw_list->Flags;
                            overlay_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.
                            overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f);
                            overlay_draw_list->Flags = backup_flags;
                        }
                    }
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }

        static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)
        {
            if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))
                return;
            for (int i = 0; i < windows.Size; i++)
                Funcs::NodeWindow(windows[i], "Window");
            ImGui::TreePop();
        }

        static void NodeWindow(ImGuiWindow* window, const char* label)
        {
            if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))
                return;
            ImGuiWindowFlags flags = window->Flags;
            NodeDrawList(window, window->DrawList, "DrawList");
            ImGui::BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);
            ImGui::BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
                (flags & ImGuiWindowFlags_ChildWindow)  ? "Child " : "",      (flags & ImGuiWindowFlags_Tooltip)     ? "Tooltip "   : "",  (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
                (flags & ImGuiWindowFlags_Modal)        ? "Modal " : "",      (flags & ImGuiWindowFlags_ChildMenu)   ? "ChildMenu " : "",  (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
                (flags & ImGuiWindowFlags_NoMouseInputs)? "NoMouseInputs":"", (flags & ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
            ImGui::BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f)", window->Scroll.x, GetWindowScrollMaxX(window), window->Scroll.y, GetWindowScrollMaxY(window));
            ImGui::BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
            ImGui::BulletText("Appearing: %d, Hidden: %d (Reg %d Resize %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesRegular, window->HiddenFramesForResize, window->SkipItems);
            ImGui::BulletText("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X", window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);
            ImGui::BulletText("NavLastChildNavWindow: %s", window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
            if (!window->NavRectRel[0].IsInverted())
                ImGui::BulletText("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)", window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);
            else
                ImGui::BulletText("NavRectRel[0]: <None>");
            if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");
            if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, "ParentWindow");
            if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");
            if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))
            {
                for (int n = 0; n < window->ColumnsStorage.Size; n++)
                {
                    const ImGuiColumnsSet* columns = &window->ColumnsStorage[n];
                    if (ImGui::TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
                    {
                        ImGui::BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);
                        for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
                            ImGui::BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));
                        ImGui::TreePop();
                    }
                }
                ImGui::TreePop();
            }
            ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));
            ImGui::TreePop();
        }

        static void NodeTabBar(ImGuiTabBar* tab_bar)
        {
            // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
            char buf[256];
            char* p = buf;
            const char* buf_end = buf + IM_ARRAYSIZE(buf);
            ImFormatString(p, buf_end - p, "TabBar (%d tabs)%s", tab_bar->Tabs.Size, (tab_bar->PrevFrameVisible < ImGui::GetFrameCount() - 2) ? " *Inactive*" : "");
            if (ImGui::TreeNode(tab_bar, "%s", buf))
            {
                for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
                {
                    const ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
                    ImGui::PushID(tab);
                    if (ImGui::SmallButton("<")) { TabBarQueueChangeTabOrder(tab_bar, tab, -1); } ImGui::SameLine(0, 2);
                    if (ImGui::SmallButton(">")) { TabBarQueueChangeTabOrder(tab_bar, tab, +1); } ImGui::SameLine();
                    ImGui::Text("%02d%c Tab 0x%08X", tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID);
                    ImGui::PopID();
                }
                ImGui::TreePop();
            }
        }
    };

    // Access private state, we are going to display the draw lists from last frame
    ImGuiContext& g = *GImGui;
    Funcs::NodeWindows(g.Windows, "Windows");
    if (ImGui::TreeNode("DrawList", "Active DrawLists (%d)", g.DrawDataBuilder.Layers[0].Size))
    {
        for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)
            Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], "DrawList");
        ImGui::TreePop();
    }
    if (ImGui::TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
    {
        for (int i = 0; i < g.OpenPopupStack.Size; i++)
        {
            ImGuiWindow* window = g.OpenPopupStack[i].Window;
            ImGui::BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");
        }
        ImGui::TreePop();
    }
    if (ImGui::TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.Data.Size))
    {
        for (int n = 0; n < g.TabBars.Data.Size; n++)
            Funcs::NodeTabBar(g.TabBars.GetByIndex(n));
        ImGui::TreePop();
    }
    if (ImGui::TreeNode("Internal state"))
    {
        const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);
        ImGui::Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
        ImGui::Text("HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL");
        ImGui::Text("HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not
        ImGui::Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);
        ImGui::Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
        ImGui::Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
        ImGui::Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
        ImGui::Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
        ImGui::Text("NavInputSource: %s", input_source_names[g.NavInputSource]);
        ImGui::Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
        ImGui::Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);
        ImGui::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
        ImGui::Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
        ImGui::Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
        ImGui::TreePop();
    }


    if (g.IO.KeyCtrl && show_window_begin_order)
    {
        for (int n = 0; n < g.Windows.Size; n++)
        {
            ImGuiWindow* window = g.Windows[n];
            if ((window->Flags & ImGuiWindowFlags_ChildWindow) || !window->WasActive)
                continue;
            char buf[32];
            ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);
            float font_size = ImGui::GetFontSize() * 2;
            ImDrawList* overlay_draw_list = GetOverlayDrawList(window);
            overlay_draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));
            overlay_draw_list->AddText(NULL, font_size, window->Pos, IM_COL32(255, 255, 255, 255), buf);
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------

// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
#include "imgui_user.inl"
#endif

//-----------------------------------------------------------------------------

```

`CSGOSimple/imgui/imgui.h`:

```h
// dear imgui, v1.69 WIP
// (headers)

// See imgui.cpp file for documentation.
// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui

/*

Index of this file:
// Header mess
// Forward declarations and basic types
// ImGui API (Dear ImGui end-user API)
// Flags & Enumerations
// ImVector<>
// ImGuiStyle
// ImGuiIO
// Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)
// Obsolete functions
// Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor)
// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)
// Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)

*/

#pragma once

// Configuration file (edit imconfig.h or define IMGUI_USER_CONFIG to your own filename)
#ifdef IMGUI_USER_CONFIG
#include IMGUI_USER_CONFIG
#endif
#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)
#include "imconfig.h"
#endif

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

#include <float.h>                  // FLT_MAX
#include <stdarg.h>                 // va_list
#include <stddef.h>                 // ptrdiff_t, NULL
#include <string.h>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp

// Version
// (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY00 then bounced up to XYY01 when release tagging happens)
#define IMGUI_VERSION               "1.69 WIP"
#define IMGUI_VERSION_NUM           16899
#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert))

// Define attributes of all API symbols declarations (e.g. for DLL under Windows)
// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h)
#ifndef IMGUI_API
#define IMGUI_API
#endif
#ifndef IMGUI_IMPL_API
#define IMGUI_IMPL_API              IMGUI_API
#endif

// Helper Macros
#ifndef IM_ASSERT
#include <assert.h>
#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h
#endif
#if defined(__clang__) || defined(__GNUC__)
#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // Apply printf-style warnings to user functions.
#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))
#else
#define IM_FMTARGS(FMT)
#define IM_FMTLIST(FMT)
#endif
#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR)/sizeof(*_ARR)))         // Size of a static C-style array. Don't use on pointers!
#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Standardized as offsetof() in modern C++.
#define IM_UNUSED(_VAR)             ((void)_VAR)                                // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.

// Warnings
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#elif defined(__GNUC__) && __GNUC__ >= 8
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wclass-memaccess"
#endif

//-----------------------------------------------------------------------------
// Forward declarations and basic types
//-----------------------------------------------------------------------------

struct ImDrawChannel;               // Temporary storage for ImDrawList ot output draw commands out of order, used by ImDrawList::ChannelsSplit()
struct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call, unless it is a callback)
struct ImDrawData;                  // All draw command lists required to render the frame + pos/size coordinates to use for the projection matrix.
struct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic "mesh" builder)
struct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
struct ImDrawVert;                  // A single vertex (pos + uv + col = 20 bytes by default. Override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
struct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas
struct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader
struct ImFontConfig;                // Configuration data when adding a font or merging fonts
struct ImFontGlyph;                 // A single font glyph (code point + coordinates within in ImFontAtlas + offset)
struct ImFontGlyphRangesBuilder;    // Helper to build glyph ranges from text/string data
struct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*OBSOLETE* please avoid using)
struct ImGuiContext;                // Dear ImGui context (opaque structure, unless including imgui_internal.h)
struct ImGuiIO;                     // Main configuration and I/O between your application and ImGui
struct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)
struct ImGuiListClipper;            // Helper to manually clip large list of items
struct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro
struct ImGuiPayload;                // User data payload for drag and drop operations
struct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)
struct ImGuiStorage;                // Helper for key->value storage
struct ImGuiStyle;                  // Runtime data for styling/colors
struct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)
struct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. "aaaaa[,bbbb][,ccccc]")

// Typedefs and Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)
// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
#ifndef ImTextureID
typedef void* ImTextureID;          // User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)
#endif
typedef unsigned int ImGuiID;       // Unique ID used by widgets (typically hashed from a stack of string)
typedef unsigned short ImWchar;     // A single U16 character for keyboard input/display. We encode them as multi bytes UTF-8 when used in strings.
typedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling
typedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for Set*()
typedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type
typedef int ImGuiDir;               // -> enum ImGuiDir_             // Enum: A cardinal direction
typedef int ImGuiKey;               // -> enum ImGuiKey_             // Enum: A key identifier (ImGui-side enum)
typedef int ImGuiNavInput;          // -> enum ImGuiNavInput_        // Enum: An input identifier for navigation
typedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor identifier
typedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling
typedef int ImDrawCornerFlags;      // -> enum ImDrawCornerFlags_    // Flags: for ImDrawList::AddRect*() etc.
typedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList
typedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas
typedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags
typedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit*(), ColorPicker*()
typedef int ImGuiColumnsFlags;      // -> enum ImGuiColumnsFlags_    // Flags: for Columns(), BeginColumns()
typedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags
typedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()
typedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for *DragDrop*()
typedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()
typedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.
typedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText*()
typedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()
typedef int ImGuiTabBarFlags;       // -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()
typedef int ImGuiTabItemFlags;      // -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()
typedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode*(),CollapsingHeader()
typedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin*()
typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);
typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);

// Scalar data types
typedef signed int          ImS32;  // 32-bit signed integer == int
typedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)
#if defined(_MSC_VER) && !defined(__clang__)
typedef signed   __int64    ImS64;  // 64-bit signed integer (pre and post C++11 with Visual Studio)
typedef unsigned __int64    ImU64;  // 64-bit unsigned integer (pre and post C++11 with Visual Studio)
#elif (defined(__clang__) || defined(__GNUC__)) && (__cplusplus < 201100)
#include <stdint.h>
typedef int64_t             ImS64;  // 64-bit signed integer (pre C++11)
typedef uint64_t            ImU64;  // 64-bit unsigned integer (pre C++11)
#else
typedef signed   long long  ImS64;  // 64-bit signed integer (post C++11)
typedef unsigned long long  ImU64;  // 64-bit unsigned integer (post C++11)
#endif

// 2D vector (often used to store positions, sizes, etc.)
struct ImVec2
{
    float     x, y;
    ImVec2()  { x = y = 0.0f; }
    ImVec2(float _x, float _y) { x = _x; y = _y; }
    float  operator[] (size_t idx) const { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
    float& operator[] (size_t idx)       { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
#ifdef IM_VEC2_CLASS_EXTRA
    IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.
#endif
};

// 4D vector (often used to store floating-point colors)
struct ImVec4
{
    float     x, y, z, w;
    ImVec4()  { x = y = z = w = 0.0f; }
    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }
#ifdef IM_VEC4_CLASS_EXTRA
    IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.
#endif
};

//-----------------------------------------------------------------------------
// ImGui: Dear ImGui end-user API
// (Inside a namespace so you can add extra functions in your own separate file. Please don't modify imgui.cpp/.h!)
//-----------------------------------------------------------------------------

namespace ImGui
{
    // Context creation and access
    // Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.
    // All those functions are not reliant on the current context.
    IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
    IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
    IMGUI_API ImGuiContext* GetCurrentContext();
    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
    IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert);

    // Main
    IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
    IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame.
    IMGUI_API void          NewFrame();                                 // start a new ImGui frame, you can submit any command from this point until Render()/EndFrame().
    IMGUI_API void          EndFrame();                                 // ends the ImGui frame. automatically called by Render(), you likely don't need to call that yourself directly. If you don't need to render data (skipping rendering) you may call EndFrame() but you'll have wasted CPU already! If you don't need to render, better to not create any imgui windows and not call NewFrame() at all!
    IMGUI_API void          Render(ImDrawList* our_list = NULL);        // ends the ImGui frame, finalize the draw data. (Obsolete: optionally call io.RenderDrawListsFn if set. Nowadays, prefer calling your render function yourself.)
    IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render. (Obsolete: this used to be passed to your io.RenderDrawListsFn() function.)

    // Demo, Debug, Information
    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
    IMGUI_API void          ShowAboutWindow(bool* p_open = NULL);       // create about window. display Dear ImGui version, credits and build/system information.
    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.
    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
    IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.
    IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.
    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).
    IMGUI_API const char*   GetVersion();                               // get the compiled version string e.g. "1.23"

    // Styles
    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)
    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style
    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font

    // Windows
    // - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
    // - You may append multiple times to the same window during the same frame.
    // - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
    //   which clicking will set the boolean to false when clicked.
    // - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
    //   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
    //   [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc.
    //    where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]
    // - Note that the bottom of window stack always contains a window called "Debug".
    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);
    IMGUI_API void          End();

    // Child Windows
    // - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
    // - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).
    // - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.
    //   Always call a matching EndChild() for each BeginChild() call, regardless of its return value [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]
    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);
    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);
    IMGUI_API void          EndChild();

    // Windows Utilities
    // - "current window" = the window we are appending into while inside a Begin()/End() block. "next window" = next window we will Begin() into.
    IMGUI_API bool          IsWindowAppearing();
    IMGUI_API bool          IsWindowCollapsed();
    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags=0); // is current window focused? or its root/child, depending on flags. see flags for options.
    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags=0); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!
    IMGUI_API ImDrawList*   GetWindowDrawList();                        // get draw list associated to the current window, to append your own drawing primitives

    IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)
    IMGUI_API ImVec2        GetWindowSize();                            // get current window size
    IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)
    IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)
    IMGUI_API ImVec2        GetContentRegionMax();                      // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
    IMGUI_API ImVec2        GetContentRegionAvail();                    // == GetContentRegionMax() - GetCursorPos()
    IMGUI_API float         GetContentRegionAvailWidth();               //
    IMGUI_API ImVec2        GetWindowContentRegionMin();                // content boundaries min (roughly (0,0)-Scroll), in window coordinates
    IMGUI_API ImVec2        GetWindowContentRegionMax();                // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates
    IMGUI_API float         GetWindowContentRegionWidth();              //

    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.
    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()
    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()
    IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / front-most. call before Begin()
    IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
    IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().
    IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows
    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.
    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.
    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state
    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.

    // Windows Scrolling
    IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()]
    IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()]
    IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X
    IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y
    IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0..GetScrollMaxX()]
    IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0..GetScrollMaxY()]
    IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                    // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
    IMGUI_API void          SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);  // adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.

    // Parameters stacks (shared)
    IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font
    IMGUI_API void          PopFont();
    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);
    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);
    IMGUI_API void          PopStyleColor(int count = 1);
    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);
    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
    IMGUI_API void          PopStyleVar(int count = 1);
    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
    IMGUI_API ImFont*       GetFont();                                                      // get current font
    IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied
    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier
    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                 // retrieve given color with style alpha applied
    IMGUI_API ImU32         GetColorU32(ImU32 col);                                         // retrieve given color with style alpha applied

    // Parameters stacks (current window)
    IMGUI_API void          PushItemWidth(float item_width);                                // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
    IMGUI_API void          PopItemWidth();
    IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position
    IMGUI_API void          PushTextWrapPos(float wrap_local_pos_x = 0.0f);                 // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
    IMGUI_API void          PopTextWrapPos();
    IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
    IMGUI_API void          PopAllowKeyboardFocus();
    IMGUI_API void          PushButtonRepeat(bool repeat);                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
    IMGUI_API void          PopButtonRepeat();

    // Cursor / Layout
    // - By "cursor" we mean the current output position.
    // - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.
    IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
    IMGUI_API void          SameLine(float local_pos_x = 0.0f, float spacing_w = -1.0f);    // call between widgets or groups to layout them horizontally. X position given in window coordinates.
    IMGUI_API void          NewLine();                                                      // undo a SameLine() or force a new line when in an horizontal-layout context.
    IMGUI_API void          Spacing();                                                      // add vertical spacing.
    IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.
    IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0
    IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0
    IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position
    IMGUI_API void          EndGroup();                                                     // unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
    IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position in window coordinates (relative to window position)
    IMGUI_API float         GetCursorPosX();                                                //   (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc.
    IMGUI_API float         GetCursorPosY();                                                //    other functions such as GetCursorScreenPos or everything in ImDrawList::
    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          //    are using the main, absolute coordinate system.
    IMGUI_API void          SetCursorPosX(float local_x);                                   //    GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.)
    IMGUI_API void          SetCursorPosY(float local_y);                                   //
    IMGUI_API ImVec2        GetCursorStartPos();                                            // initial cursor position in window coordinates
    IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)
    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                          // cursor position in absolute screen coordinates [0..io.DisplaySize]
    IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
    IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize
    IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
    IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2
    IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)

    // ID stack/scopes
    // - Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most
    //   likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
    // - The resulting ID are hashes of the entire stack.
    // - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
    // - In this header file we use the "label"/"name" terminology to denote a string that will be displayed and used as an ID,
    //   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
    IMGUI_API void          PushID(const char* str_id);                                     // push string into the ID stack (will hash string).
    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);       // push string into the ID stack (will hash string).
    IMGUI_API void          PushID(const void* ptr_id);                                     // push pointer into the ID stack (will hash pointer). 
    IMGUI_API void          PushID(int int_id);                                             // push integer into the ID stack (will hash integer).
    IMGUI_API void          PopID();                                                        // pop from the ID stack.
    IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);
    IMGUI_API ImGuiID       GetID(const void* ptr_id);

    // Widgets: Text
    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);                // raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
    IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // simple formatted text
    IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);
    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);
    IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);
    IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);
    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets
    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);
    IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()
    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);

    // Widgets: Main
    // - Most widgets return true when the value has been changed or when pressed/selected
    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));    // button
    IMGUI_API bool          SmallButton(const char* label);                                 // button with FramePadding=(0,0) to easily embed within text
    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);        // button behavior without the visuals, useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
    IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape
    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));
    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding
    IMGUI_API bool          Checkbox(const char* label, bool* v);
    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
    IMGUI_API bool          RadioButton(const char* label, bool active);                    // use with e.g. if (RadioButton("one", my_value==1)) { my_value = 1; }
    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);           // shortcut to handle the above pattern when value is an integer
    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);
    IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses

    // Widgets: Combo Box
    // - The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.
    // - The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.
    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
    IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!
    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
    IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);

    // Widgets: Drags
    // - CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
    // - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    // - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);     // If v_min >= v_max we have no bound
    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = NULL, float power = 1.0f);
    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");                                       // If v_min >= v_max we have no bound
    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = NULL);
    IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);

    // Widgets: Sliders
    // - CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders
    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg");
    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);

    // Widgets: Input with Keyboard
    // - If you want to use InputText() with a dynamic string type such as std::string or your own, see misc/cpp/imgui_stdlib.h
    // - Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc.
    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = "%.6f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);

    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)
    // - Note that in C++ a 'float v[X]' function argument is the _same_ as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can the pass the address of a first float element out of a contiguous structure, e.g. &myvector.x
    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);
    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.
    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.

    // Widgets: Trees
    // - TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.
    IMGUI_API bool          TreeNode(const char* label);
    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // helper variation to completely decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // "
    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);
    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);
    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
    IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.
    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                // "
    IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()
    IMGUI_API void          TreeAdvanceToLabelPos();                                            // advance cursor x position by GetTreeNodeToLabelSpacing()
    IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);              // set next TreeNode/CollapsingHeader open state.
    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header

    // Widgets: Selectables
    // - A selectable highlights when hovered, and can display another color when selected.
    // - Neighbors selectable extend their highlight bounds in order to leave no gap between them.
    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));       // "bool* p_selected" point to the selection state (read-write), as a convenient helper.

    // Widgets: List Boxes
    // - FIXME: To be consistent with all the newer API, ListBoxHeader/ListBoxFooter should in reality be called BeginListBox/EndListBox. Will rename them.
    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);
    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); // use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards.
    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // "
    IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true!

    // Widgets: Data Plotting
    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));
    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));

    // Widgets: Value() Helpers.
    // - Those are merely shortcut to calling Text() with a format string. Output single value in "name: value" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)
    IMGUI_API void          Value(const char* prefix, bool b);
    IMGUI_API void          Value(const char* prefix, int v);
    IMGUI_API void          Value(const char* prefix, unsigned int v);
    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);

    // Widgets: Menus
    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.
    IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!
    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
    IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!
    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!
    IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!
    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment
    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL

    // Tooltips
    IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of items).
    IMGUI_API void          EndTooltip();
    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set a text-only tooltip, typically use with ImGui::IsItemHovered(). overidde any previous call to SetTooltip().
    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);

    // Popups, Modals
    // The properties of popups windows are:
    // - They block normal mouse hovering detection outside them. (*)
    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.
    //   User can manipulate the visibility state by calling OpenPopup().
    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.
    // Those three properties are connected. The library needs to hold their visibility state because it can close popups at any time.
    IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
    IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true!
    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.
    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).
    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)
    IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true!
    IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors). return true when just opened.
    IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open at the current begin-ed level of the popup stack.
    IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.

    // Columns
    // - You can also use SameLine(pos_x) to mimic simplified columns.
    // - The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!)
    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);
    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished
    IMGUI_API int           GetColumnIndex();                                                   // get current column index
    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column
    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column
    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
    IMGUI_API int           GetColumnsCount();

    // Tab Bars, Tabs
    // [BETA API] API may evolve!
    IMGUI_API bool          BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);        // create and append into a TabBar
    IMGUI_API void          EndTabBar();                                                        // only call EndTabBar() if BeginTabBar() returns true!
    IMGUI_API bool          BeginTabItem(const char* label, bool* p_open = NULL, ImGuiTabItemFlags flags = 0);// create a Tab. Returns true if the Tab is selected.
    IMGUI_API void          EndTabItem();                                                       // only call EndTabItem() if BeginTabItem() returns true!
    IMGUI_API void          SetTabItemClosed(const char* tab_or_docked_window_label);           // notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.

    // Logging/Capture
    // - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.
    IMGUI_API void          LogToTTY(int max_depth = -1);                                       // start logging to tty (stdout)
    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         // start logging to file
    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 // start logging to OS clipboard
    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)
    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard
    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)

    // Drag and Drop
    // [BETA API] API may evolve!
    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()
    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t size, ImGuiCond cond = 0);// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.
    IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!
    IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
    IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
    IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!
    IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.

    // Clipping
    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
    IMGUI_API void          PopClipRect();

    // Focus, Activation
    // - Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing()) SetScrollHereY()" when applicable to signify "this is the default item"
    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window.
    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.

    // Item/Widgets Utilities
    // - Most of the functions are referring to the last/previous item we submitted.
    // - See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.
    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
    IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?
    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered()
    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)
    IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
    IMGUI_API bool          IsItemActivated();                                                  // was the last item just made active (item was previously inactive).
    IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.
    IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
    IMGUI_API bool          IsAnyItemHovered();
    IMGUI_API bool          IsAnyItemActive();
    IMGUI_API bool          IsAnyItemFocused();
    IMGUI_API ImVec2        GetItemRectMin();                                                   // get upper-left bounding rectangle of the last item (screen space)
    IMGUI_API ImVec2        GetItemRectMax();                                                   // get lower-right bounding rectangle of the last item (screen space)
    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item
    IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.

    // Miscellaneous Utilities
    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.
    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
    IMGUI_API double        GetTime();                                                          // get global imgui time. incremented by io.DeltaTime every frame.
    IMGUI_API int           GetFrameCount();                                                    // get global imgui frame count. incremented by 1 every frame.
    IMGUI_API ImDrawList*   GetOverlayDrawList();                                               // this draw list will be the last rendered one, useful to quickly draw overlays shapes/text
    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances
    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);
    IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
    IMGUI_API ImGuiStorage* GetStateStorage();
    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);
    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.
    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0); // helper to create a child window / scrolling region that looks like a normal widget frame
    IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)

    // Color Utilities
    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);
    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);
    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);

    // Inputs Utilities
    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]
    IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your backend/engine stored them into io.KeysDown[]!
    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..
    IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
    IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held (0=left, 1=right, 2=middle)
    IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held
    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down) (0=left, 1=right, 2=middle)
    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.
    IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)
    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    //
    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse position at the time of opening popup we have BeginPopup() into
    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // return the delta from the initial clicking position. This is locked and return 0.0f until the mouse moves past a distance threshold at least once. If lock_threshold < -1.0f uses io.MouseDraggingThreshold
    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //
    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type
    IMGUI_API void          CaptureKeyboardFromApp(bool want_capture_keyboard_value = true);    // attention: misleading name! manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard_value"; after the next NewFrame() call.
    IMGUI_API void          CaptureMouseFromApp(bool want_capture_mouse_value = true);          // attention: misleading name! manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse_value;" after the next NewFrame() call.

    // Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)
    IMGUI_API const char*   GetClipboardText();
    IMGUI_API void          SetClipboardText(const char* text);

    // Settings/.Ini Utilities
    // - The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").
    // - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.
    IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
    IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
    IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);
    IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.

    // Memory Utilities
    // - All those functions are not reliant on the current context.
    // - If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again.
    IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data = NULL);
    IMGUI_API void*         MemAlloc(size_t size);
    IMGUI_API void          MemFree(void* ptr);

} // namespace ImGui

//-----------------------------------------------------------------------------
// Flags & Enumerations
//-----------------------------------------------------------------------------

// Flags for ImGui::Begin()
enum ImGuiWindowFlags_
{
    ImGuiWindowFlags_None                   = 0,
    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar
    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip
    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window
    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)
    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it
    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame
    ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file
    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.
    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar
    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)
    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window
    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
    ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.
    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

    // [Internal]
    ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()
    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()
    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()
    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
    ImGuiWindowFlags_ChildMenu              = 1 << 28   // Don't use! For internal use by BeginMenu()

    // [Obsolete]
    //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // --> Set style.FrameBorderSize=1.0f / style.WindowBorderSize=1.0f to enable borders around windows and items
    //ImGuiWindowFlags_ResizeFromAnySide    = 1 << 17,  // --> Set io.ConfigWindowsResizeFromEdges and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)
};

// Flags for ImGui::InputText()
enum ImGuiInputTextFlags_
{
    ImGuiInputTextFlags_None                = 0,
    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/
    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef
    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z
    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs
    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus
    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)
    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Callback on pressing TAB (for completion handling)
    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)
    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.
    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\t' character into the text field
    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally
    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode
    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode
    ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'
    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
    // [Internal]
    ImGuiInputTextFlags_Multiline           = 1 << 20   // For internal use by InputTextMultiline()
};

// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
enum ImGuiTreeNodeFlags_
{
    ImGuiTreeNodeFlags_None                 = 0,
    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected
    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open
    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node
    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow
    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
    //ImGuITreeNodeFlags_SpanAllAvailWidth  = 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed
    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap
#endif
};

// Flags for ImGui::Selectable()
enum ImGuiSelectableFlags_
{
    ImGuiSelectableFlags_None               = 0,
    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window
    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too
    ImGuiSelectableFlags_Disabled           = 1 << 3    // Cannot be selected, display greyed out text
};

// Flags for ImGui::BeginCombo()
enum ImGuiComboFlags_
{
    ImGuiComboFlags_None                    = 0,
    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default
    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)
    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible
    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible
    ImGuiComboFlags_NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button
    ImGuiComboFlags_NoPreview               = 1 << 6,   // Display only a square arrow button
    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest
};

// Flags for ImGui::BeginTabBar()
enum ImGuiTabBarFlags_
{
    ImGuiTabBarFlags_None                           = 0,
    ImGuiTabBarFlags_Reorderable                    = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
    ImGuiTabBarFlags_AutoSelectNewTabs              = 1 << 1,   // Automatically select new tabs when they appear
    ImGuiTabBarFlags_TabListPopupButton             = 1 << 2,
    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 1 << 3,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    ImGuiTabBarFlags_NoTabListScrollingButtons      = 1 << 4,
    ImGuiTabBarFlags_NoTooltip                      = 1 << 5,   // Disable tooltips when hovering a tab
    ImGuiTabBarFlags_FittingPolicyResizeDown        = 1 << 6,   // Resize tabs when they don't fit
    ImGuiTabBarFlags_FittingPolicyScroll            = 1 << 7,   // Add scroll buttons when tabs don't fit
    ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
    ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown
};

// Flags for ImGui::BeginTabItem()
enum ImGuiTabItemFlags_
{
    ImGuiTabItemFlags_None                          = 0,
    ImGuiTabItemFlags_UnsavedDocument               = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.
    ImGuiTabItemFlags_SetSelected                   = 1 << 1,   // Trigger flag to programatically make the tab selected when calling BeginTabItem()
    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    ImGuiTabItemFlags_NoPushId                      = 1 << 3    // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
};

// Flags for ImGui::IsWindowFocused()
enum ImGuiFocusedFlags_
{
    ImGuiFocusedFlags_None                          = 0,
    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.
    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows
};

// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ!
// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.
enum ImGuiHoveredFlags_
{
    ImGuiHoveredFlags_None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   // Return true even if the position is overlapped by another window
    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   // Return true even if the item is disabled
    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows
};

// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
enum ImGuiDragDropFlags_
{
    ImGuiDragDropFlags_None                         = 0,
    // BeginDragDropSource() flags
    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
    // AcceptDragDropPayload() flags
    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.
    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.
};

// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.
#define IMGUI_PAYLOAD_TYPE_COLOR_3F     "_COL3F"    // float[3]: Standard type for colors, without alpha. User code may use this type.
#define IMGUI_PAYLOAD_TYPE_COLOR_4F     "_COL4F"    // float[4]: Standard type for colors. User code may use this type.

// A primary data type
enum ImGuiDataType_
{
    ImGuiDataType_S32,      // int
    ImGuiDataType_U32,      // unsigned int
    ImGuiDataType_S64,      // long long, __int64
    ImGuiDataType_U64,      // unsigned long long, unsigned __int64
    ImGuiDataType_Float,    // float
    ImGuiDataType_Double,   // double
    ImGuiDataType_COUNT
};

// A cardinal direction
enum ImGuiDir_
{
    ImGuiDir_None    = -1,
    ImGuiDir_Left    = 0,
    ImGuiDir_Right   = 1,
    ImGuiDir_Up      = 2,
    ImGuiDir_Down    = 3,
    ImGuiDir_COUNT
};

// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
enum ImGuiKey_
{
    ImGuiKey_Tab,
    ImGuiKey_LeftArrow,
    ImGuiKey_RightArrow,
    ImGuiKey_UpArrow,
    ImGuiKey_DownArrow,
    ImGuiKey_PageUp,
    ImGuiKey_PageDown,
    ImGuiKey_Home,
    ImGuiKey_End,
    ImGuiKey_Insert,
    ImGuiKey_Delete,
    ImGuiKey_Backspace,
    ImGuiKey_Space,
    ImGuiKey_Enter,
    ImGuiKey_Escape,
    ImGuiKey_A,         // for text edit CTRL+A: select all
    ImGuiKey_C,         // for text edit CTRL+C: copy
    ImGuiKey_V,         // for text edit CTRL+V: paste
    ImGuiKey_X,         // for text edit CTRL+X: cut
    ImGuiKey_Y,         // for text edit CTRL+Y: redo
    ImGuiKey_Z,         // for text edit CTRL+Z: undo
    ImGuiKey_COUNT
};

// Gamepad/Keyboard directional navigation
// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().
// Read instructions in imgui.cpp for more details. Download PNG/PSD at http://goo.gl/9LgVZW.
enum ImGuiNavInput_
{
    // Gamepad Mapping
    ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)
    ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)
    ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
    ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
    ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
    ImGuiNavInput_DpadRight,     //
    ImGuiNavInput_DpadUp,        //
    ImGuiNavInput_DpadDown,      //
    ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
    ImGuiNavInput_LStickRight,   //
    ImGuiNavInput_LStickUp,      //
    ImGuiNavInput_LStickDown,    //
    ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
    ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)

    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].
    ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt
    ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys
    ImGuiNavInput_KeyRight_,     // move right
    ImGuiNavInput_KeyUp_,        // move up
    ImGuiNavInput_KeyDown_,      // move down
    ImGuiNavInput_COUNT,
    ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_
};

// Configuration flags stored in io.ConfigFlags. Set by user/application.
enum ImGuiConfigFlags_
{
    ImGuiConfigFlags_None                   = 0,
    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].
    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.
    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.
    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.
    ImGuiConfigFlags_NoMouse                = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.
    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.

    // User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core ImGui)
    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  // Application is SRGB-aware.
    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   // Application is using a touch screen instead of a mouse.
};

// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.
enum ImGuiBackendFlags_
{
    ImGuiBackendFlags_None                  = 0,
    ImGuiBackendFlags_HasGamepad            = 1 << 0,   // Back-end supports gamepad and currently has one connected.
    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   // Back-end supports honoring GetMouseCursor() value to change the OS cursor shape.
    ImGuiBackendFlags_HasSetMousePos        = 1 << 2    // Back-end supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
};

// Enumeration for PushStyleColor() / PopStyleColor()
enum ImGuiCol_
{
    ImGuiCol_Text,
    ImGuiCol_TextDisabled,
    ImGuiCol_WindowBg,              // Background of normal windows
    ImGuiCol_ChildBg,               // Background of child windows
    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows
    ImGuiCol_Border,
    ImGuiCol_BorderShadow,
    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input
    ImGuiCol_FrameBgHovered,
    ImGuiCol_FrameBgActive,
    ImGuiCol_TitleBg,
    ImGuiCol_TitleBgActive,
    ImGuiCol_TitleBgCollapsed,
    ImGuiCol_MenuBarBg,
    ImGuiCol_ScrollbarBg,
    ImGuiCol_ScrollbarGrab,
    ImGuiCol_ScrollbarGrabHovered,
    ImGuiCol_ScrollbarGrabActive,
    ImGuiCol_CheckMark,
    ImGuiCol_SliderGrab,
    ImGuiCol_SliderGrabActive,
    ImGuiCol_Button,
    ImGuiCol_ButtonHovered,
    ImGuiCol_ButtonActive,
    ImGuiCol_Header,
    ImGuiCol_HeaderHovered,
    ImGuiCol_HeaderActive,
    ImGuiCol_Separator,
    ImGuiCol_SeparatorHovered,
    ImGuiCol_SeparatorActive,
    ImGuiCol_ResizeGrip,
    ImGuiCol_ResizeGripHovered,
    ImGuiCol_ResizeGripActive,
    ImGuiCol_Tab,
    ImGuiCol_TabHovered,
    ImGuiCol_TabActive,
    ImGuiCol_TabUnfocused,
    ImGuiCol_TabUnfocusedActive,
    ImGuiCol_PlotLines,
    ImGuiCol_PlotLinesHovered,
    ImGuiCol_PlotHistogram,
    ImGuiCol_PlotHistogramHovered,
    ImGuiCol_TextSelectedBg,
    ImGuiCol_DragDropTarget,
    ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item
    ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB
    ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active
    ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active
    ImGuiCol_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg                      // [renamed in 1.63]
    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg                                      // [renamed in 1.53]
    , ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive  // [renamed in 1.51]
    //ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered, // [unused since 1.60+] the close button now uses regular button colors.
    //ImGuiCol_ComboBg,                                                              // [unused since 1.53+] ComboBg has been merged with PopupBg, so a redirect isn't accurate.
#endif
};

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.
// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
enum ImGuiStyleVar_
{
    // Enum name ......................// Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
    ImGuiStyleVar_Alpha,               // float     Alpha
    ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding
    ImGuiStyleVar_WindowRounding,      // float     WindowRounding
    ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize
    ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize
    ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign
    ImGuiStyleVar_ChildRounding,       // float     ChildRounding
    ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize
    ImGuiStyleVar_PopupRounding,       // float     PopupRounding
    ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize
    ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding
    ImGuiStyleVar_FrameRounding,       // float     FrameRounding
    ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize
    ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing
    ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
    ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing
    ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize
    ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding
    ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize
    ImGuiStyleVar_GrabRounding,        // float     GrabRounding
    ImGuiStyleVar_TabRounding,         // float     TabRounding
    ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign
    ImGuiStyleVar_SelectableTextAlign, // ImVec2    SelectableTextAlign
    ImGuiStyleVar_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT, ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding
#endif
};

// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
enum ImGuiColorEditFlags_
{
    ImGuiColorEditFlags_None            = 0,
    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (read 3 components from the input pointer).
    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.
    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.

    // User Options (right-click on widget to change some of them). You can set application defaults using SetColorEditOptions(). The idea is that you probably don't want to override them in most of your calls, let the user choose and/or call SetColorEditOptions() during startup.
    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
    ImGuiColorEditFlags_HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
    ImGuiColorEditFlags_RGB             = 1 << 20,  // [Inputs]     // ColorEdit: choose one among RGB/HSV/HEX. ColorPicker: choose any combination using RGB/HSV/HEX.
    ImGuiColorEditFlags_HSV             = 1 << 21,  // [Inputs]     // "
    ImGuiColorEditFlags_HEX             = 1 << 22,  // [Inputs]     // "
    ImGuiColorEditFlags_Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
    ImGuiColorEditFlags_Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  // [PickerMode] // ColorPicker: bar for Hue, rectangle for Sat/Value.
    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  // [PickerMode] // ColorPicker: wheel for Hue, triangle for Sat/Value.

    // [Internal] Masks
    ImGuiColorEditFlags__InputsMask     = ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_HSV|ImGuiColorEditFlags_HEX,
    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,
    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,
    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_PickerHueBar    // Change application default using SetColorEditOptions()
};

// Enumeration for GetMouseCursor()
// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here
enum ImGuiMouseCursor_
{
    ImGuiMouseCursor_None = -1,
    ImGuiMouseCursor_Arrow = 0,
    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.
    ImGuiMouseCursor_ResizeAll,         // (Unused by imgui functions)
    ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border
    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column
    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window
    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window
    ImGuiMouseCursor_Hand,              // (Unused by imgui functions. Use for e.g. hyperlinks)
    ImGuiMouseCursor_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT
#endif
};

// Enumateration for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions
// Represent a condition.
// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.
enum ImGuiCond_
{
    ImGuiCond_Always        = 1 << 0,   // Set the variable
    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)
    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)
    ImGuiCond_Appearing     = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing
#endif
};

//-----------------------------------------------------------------------------
// Helper: ImVector<>
// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).
// You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our data structures are relying on it.
// Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.
// Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that,
// do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.
//-----------------------------------------------------------------------------

template<typename T>
struct ImVector
{
    int                 Size;
    int                 Capacity;
    T*                  Data;

    // Provide standard typedefs but we don't use them ourselves.
    typedef T                   value_type;
    typedef value_type*         iterator;
    typedef const value_type*   const_iterator;

    // Constructors, destructor
    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
    inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }
    inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }
    inline ~ImVector()                                      { if (Data) ImGui::MemFree(Data); }

    inline bool         empty() const                       { return Size == 0; }
    inline int          size() const                        { return Size; }
    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
    inline int          capacity() const                    { return Capacity; }
    inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }
    inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }

    inline void         clear()                             { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }
    inline T*           begin()                             { return Data; }
    inline const T*     begin() const                       { return Data; }
    inline T*           end()                               { return Data + Size; }
    inline const T*     end() const                         { return Data + Size; }
    inline T&           front()                             { IM_ASSERT(Size > 0); return Data[0]; }
    inline const T&     front() const                       { IM_ASSERT(Size > 0); return Data[0]; }
    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    inline const T&     back() const                        { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }
    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

    // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.
    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
    inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }
    inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }
    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(T)); Size -= (int)count; return Data + off; }
    inline T*           erase_unsorted(const T* it)         { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }
    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
    inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; return (int)off; }
};

//-----------------------------------------------------------------------------
// ImGuiStyle
// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().
// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values,
// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.
//-----------------------------------------------------------------------------

struct ImGuiStyle
{
    float       Alpha;                      // Global alpha applies to everything in ImGui.
    ImVec2      WindowPadding;              // Padding within a window.
    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.
    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().
    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
    float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).
    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.
    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns.
    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.
    float       ScrollbarRounding;          // Radius of grab corners for scrollbar.
    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.
    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    float       TabRounding;                // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    float       TabBorderSize;              // Thickness of border around tabs.
    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
    ImVec2      SelectableTextAlign;        // Alignment of selectable text when selectable is larger than text. Defaults to (0.0f, 0.0f) (top-left aligned).
    ImVec2      DisplayWindowPadding;       // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
    ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!
    float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
    bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
    ImVec4      Colors[ImGuiCol_COUNT];

    IMGUI_API ImGuiStyle();
    IMGUI_API void ScaleAllSizes(float scale_factor);
};

//-----------------------------------------------------------------------------
// ImGuiIO
// Communicate most settings and inputs/outputs to Dear ImGui using this structure.
// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.
//-----------------------------------------------------------------------------

struct ImGuiIO
{
    //------------------------------------------------------------------
    // Configuration (fill once)                // Default value
    //------------------------------------------------------------------

    ImGuiConfigFlags   ConfigFlags;             // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
    ImGuiBackendFlags  BackendFlags;            // = 0              // See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.
    ImVec2      DisplaySize;                    // <unset>          // Main display size, in pixels.
    float       DeltaTime;                      // = 1.0f/60.0f     // Time elapsed since last frame, in seconds.
    float       IniSavingRate;                  // = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
    const char* IniFilename;                    // = "imgui.ini"    // Path to .ini file. Set NULL to disable automatic .ini loading/saving, if e.g. you want to manually load/save from memory.
    const char* LogFilename;                    // = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    float       MouseDoubleClickTime;           // = 0.30f          // Time for a double-click, in seconds.
    float       MouseDoubleClickMaxDist;        // = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
    float       MouseDragThreshold;             // = 6.0f           // Distance threshold before considering we are dragging.
    int         KeyMap[ImGuiKey_COUNT];         // <unset>          // Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.
    float       KeyRepeatDelay;                 // = 0.250f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    float       KeyRepeatRate;                  // = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
    void*       UserData;                       // = NULL           // Store your own data for retrieval by callbacks.

    ImFontAtlas*Fonts;                          // <auto>           // Load, rasterize and pack one or more fonts into a single texture.
    float       FontGlobalScale;                // = 1.0f           // Global scale all fonts
    bool        FontAllowUserScaling;           // = false          // Allow user scaling text of individual window with CTRL+Wheel.
    ImFont*     FontDefault;                    // = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
    ImVec2      DisplayFramebufferScale;        // = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.

    // Miscellaneous options
    bool        MouseDrawCursor;                // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.
    bool        ConfigMacOSXBehaviors;          // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)
    bool        ConfigInputTextCursorBlink;     // = true           // Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)
    bool        ConfigWindowsResizeFromEdges;   // = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
    bool        ConfigWindowsMoveFromTitleBarOnly; // = false       // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.

    //------------------------------------------------------------------
    // Platform Functions
    // (the imgui_impl_xxxx back-end files are setting those up for you)
    //------------------------------------------------------------------

    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.
    const char* BackendPlatformName;            // = NULL
    const char* BackendRendererName;            // = NULL
    void*       BackendPlatformUserData;        // = NULL
    void*       BackendRendererUserData;        // = NULL
    void*       BackendLanguageUserData;        // = NULL

    // Optional: Access OS clipboard
    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
    const char* (*GetClipboardTextFn)(void* user_data);
    void        (*SetClipboardTextFn)(void* user_data, const char* text);
    void*       ClipboardUserData;

    // Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)
    // (default to use native imm32 api on Windows)
    void        (*ImeSetInputScreenPosFn)(int x, int y);
    void*       ImeWindowHandle;                // = NULL           // (Windows) Set this to your HWND to get automatic IME cursor positioning.

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // [OBSOLETE since 1.60+] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now!
    // You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render(). See example applications if you are unsure of how to implement this.
    void        (*RenderDrawListsFn)(ImDrawData* data);
#else
    // This is only here to keep ImGuiIO the same size/layout, so that IMGUI_DISABLE_OBSOLETE_FUNCTIONS can exceptionally be used outside of imconfig.h.
    void*       RenderDrawListsFnUnused;
#endif

    //------------------------------------------------------------------
    // Input - Fill before calling NewFrame()
    //------------------------------------------------------------------

    ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
    bool        MouseDown[5];                   // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    float       MouseWheel;                     // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.
    float       MouseWheelH;                    // Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
    bool        KeyCtrl;                        // Keyboard modifier pressed: Control
    bool        KeyShift;                       // Keyboard modifier pressed: Shift
    bool        KeyAlt;                         // Keyboard modifier pressed: Alt
    bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows
    bool        KeysDown[512];                  // Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).
    float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs. Cleared back to zero by EndFrame(). Keyboard keys will be auto-mapped and be written here by NewFrame().

    // Functions
    IMGUI_API void  AddInputCharacter(ImWchar c);               // Queue new character input
    IMGUI_API void  AddInputCharactersUTF8(const char* str);    // Queue new characters input from an UTF-8 string
    IMGUI_API void  ClearInputCharacters();                     // Clear the text input buffer manually

    //------------------------------------------------------------------
    // Output - Retrieve after calling NewFrame()
    //------------------------------------------------------------------

    bool        WantCaptureMouse;               // When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
    bool        WantCaptureKeyboard;            // When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
    bool        WantTextInput;                  // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
    bool        WantSetMousePos;                // MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.
    bool        WantSaveIniSettings;            // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.
    bool        NavActive;                      // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
    bool        NavVisible;                     // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
    float       Framerate;                      // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
    int         MetricsRenderVertices;          // Vertices output during last call to Render()
    int         MetricsRenderIndices;           // Indices output during last call to Render() = number of triangles * 3
    int         MetricsRenderWindows;           // Number of visible windows
    int         MetricsActiveWindows;           // Number of active windows
    int         MetricsActiveAllocations;       // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
    ImVec2      MouseDelta;                     // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.

    //------------------------------------------------------------------
    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
    //------------------------------------------------------------------

    ImVec2      MousePosPrev;                   // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
    ImVec2      MouseClickedPos[5];             // Position at time of clicking
    double      MouseClickedTime[5];            // Time of last click (used to figure out double-click)
    bool        MouseClicked[5];                // Mouse button went from !Down to Down
    bool        MouseDoubleClicked[5];          // Has mouse button been double-clicked?
    bool        MouseReleased[5];               // Mouse button went from Down to !Down
    bool        MouseDownOwned[5];              // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.
    float       MouseDownDuration[5];           // Duration the mouse button has been down (0.0f == just clicked)
    float       MouseDownDurationPrev[5];       // Previous time the mouse button has been down
    ImVec2      MouseDragMaxDistanceAbs[5];     // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
    float       MouseDragMaxDistanceSqr[5];     // Squared maximum distance of how much mouse has traveled from the clicking point
    float       KeysDownDuration[512];          // Duration the keyboard key has been down (0.0f == just pressed)
    float       KeysDownDurationPrev[512];      // Previous duration the key has been down
    float       NavInputsDownDuration[ImGuiNavInput_COUNT];
    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];
    ImVector<ImWchar> InputQueueCharacters;     // Queue of _characters_ input (obtained by platform back-end). Fill using AddInputCharacter() helper.

    IMGUI_API   ImGuiIO();
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
struct ImGuiInputTextCallbackData
{
    ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only
    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only
    void*               UserData;       // What user passed to InputText()      // Read-only

    // Arguments for the different callback events
    // - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
    // - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
    ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
    char*               Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
    int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
    int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
    bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
    int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always]
    int                 SelectionStart; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
    int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always]

    // Helper functions for text manipulation.
    // Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.
    IMGUI_API ImGuiInputTextCallbackData();
    IMGUI_API void      DeleteChars(int pos, int bytes_count);
    IMGUI_API void      InsertChars(int pos, const char* text, const char* text_end = NULL);
    bool                HasSelection() const { return SelectionStart != SelectionEnd; }
};

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
struct ImGuiSizeCallbackData
{
    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()
    ImVec2  Pos;            // Read-only.   Window position, for reference.
    ImVec2  CurrentSize;    // Read-only.   Current window size.
    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
};

// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
struct ImGuiPayload
{
    // Members
    void*           Data;               // Data (copied and owned by dear imgui)
    int             DataSize;           // Data size

    // [Internal]
    ImGuiID         SourceId;           // Source item id
    ImGuiID         SourceParentId;     // Source parent id (if available)
    int             DataFrameCount;     // Data timestamp
    char            DataType[32+1];     // Data type tag (short user-supplied string, 32 characters max)
    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.

    ImGuiPayload()  { Clear(); }
    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
    bool IsPreview() const                  { return Preview; }
    bool IsDelivery() const                 { return Delivery; }
};

//-----------------------------------------------------------------------------
// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)
// Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead.
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
namespace ImGui
{
    // OBSOLETED in 1.66 (from Sep 2018)
    static inline void  SetScrollHere(float center_ratio=0.5f){ SetScrollHereY(center_ratio); }
    // OBSOLETED in 1.63 (between Aug 2018 and Sept 2018)
    static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }
    // OBSOLETED in 1.61 (between Apr 2018 and Aug 2018)
    IMGUI_API bool      InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags = 0); // Use the 'const char* format' version instead of 'decimal_precision'!
    IMGUI_API bool      InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool      InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool      InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags flags = 0);
    // OBSOLETED in 1.60 (between Dec 2017 and Apr 2018)
    static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }
    static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
    static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { IM_UNUSED(on_edge); IM_UNUSED(outward); IM_ASSERT(0); return pos; }
    // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)
    static inline void  ShowTestWindow()                      { return ShowDemoWindow(); }
    static inline bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }
    static inline bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }
    static inline void  SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(ImVec2(w, 0.0f)); }
    static inline float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }
    // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)
    IMGUI_API bool      Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); // Use SetNextWindowSize(size, ImGuiCond_FirstUseEver) + SetNextWindowBgAlpha() instead.
    static inline bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }
    static inline void  AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); }
    static inline void  SetNextWindowPosCenter(ImGuiCond c=0) { ImGuiIO& io = GetIO(); SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), c, ImVec2(0.5f, 0.5f)); }
    // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)
    static inline bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }
    static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; } // This was misleading and partly broken. You probably want to use the ImGui::GetIO().WantCaptureMouse flag instead.
    static inline bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
    static inline bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }
}
typedef ImGuiInputTextCallback      ImGuiTextEditCallback;    // OBSOLETE in 1.63 (from Aug 2018): made the names consistent
typedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;
#endif

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

// Helper: IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE() macros to call MemAlloc + Placement New, Placement Delete + MemFree
// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
struct ImNewDummy {};
inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }
inline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symetrical new()
#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)
#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
struct ImGuiOnceUponAFrame
{
    ImGuiOnceUponAFrame() { RefFrame = -1; }
    mutable int RefFrame;
    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};

// Helper: Macro for ImGuiOnceUponAFrame. Attention: The macro expands into 2 statement so make sure you don't use it within e.g. an if() statement without curly braces.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
#define IMGUI_ONCE_UPON_A_FRAME     static ImGuiOnceUponAFrame imgui_oaf; if (imgui_oaf)    // OBSOLETED in 1.51, will remove!
#endif

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
struct ImGuiTextFilter
{
    IMGUI_API           ImGuiTextFilter(const char* default_filter = "");
    IMGUI_API bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);  // Helper calling InputText+Build
    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;
    IMGUI_API void      Build();
    void                Clear()          { InputBuf[0] = 0; Build(); }
    bool                IsActive() const { return !Filters.empty(); }

    // [Internal]
    struct TextRange
    {
        const char* b;
        const char* e;

        TextRange() { b = e = NULL; }
        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }
        const char*     begin() const   { return b; }
        const char*     end () const    { return e; }
        bool            empty() const   { return b == e; }
        IMGUI_API void  split(char separator, ImVector<TextRange>* out) const;
    };
    char                InputBuf[256];
    ImVector<TextRange> Filters;
    int                 CountGrep;
};

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
struct ImGuiTextBuffer
{
    ImVector<char>      Buf;
    static char         EmptyString[1];

    ImGuiTextBuffer()   { }
    inline char         operator[](int i)       { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }
    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }
    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator
    int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }
    bool                empty()                 { return Buf.Size <= 1; }
    void                clear()                 { Buf.clear(); }
    void                reserve(int capacity)   { Buf.reserve(capacity); }
    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }
    IMGUI_API void      append(const char* str, const char* str_end = NULL);
    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);
    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);
};

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
struct ImGuiStorage
{
    struct Pair
    {
        ImGuiID key;
        union { int val_i; float val_f; void* val_p; };
        Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }
        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
    };
    ImVector<Pair>      Data;

    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
    // - Set***() functions find pair, insertion on demand if missing.
    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
    void                Clear() { Data.clear(); }
    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
    IMGUI_API void      SetInt(ImGuiID key, int val);
    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
    IMGUI_API void      SetBool(ImGuiID key, bool val);
    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
    IMGUI_API void      SetFloat(ImGuiID key, float val);
    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL
    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);

    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);
    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);
    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);
    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);

    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)
    IMGUI_API void      SetAllInt(int val);

    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
    IMGUI_API void      BuildSortByKey();
};

// Helper: Manually clip large list of items.
// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.
// Usage:
//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.
//     while (clipper.Step())
//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//             ImGui::Text("line number %d", i);
// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).
// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)
// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
struct ImGuiListClipper
{
    float   StartPosY;
    float   ItemsHeight;
    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;

    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
};

// Helpers macros to generate 32-bits encoded colors
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IM_COL32_R_SHIFT    16
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    0
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#else
#define IM_COL32_R_SHIFT    0
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    16
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#endif
#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000

// Helper: ImColor() implicity converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.
struct ImColor
{
    ImVec4              Value;

    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }
    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }
    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }
    ImColor(const ImVec4& col)                                      { Value = col; }
    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }
    inline operator ImVec4() const                                  { return Value; }

    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }
};

//-----------------------------------------------------------------------------
// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)
// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.
//-----------------------------------------------------------------------------

// Draw callbacks for advanced uses.
// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,
// you can poke into the draw list for that! Draw callback may be useful for example to: A) Change your GPU render state,
// B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'
typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
struct ImDrawCmd
{
    unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
    ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
    ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    void*           UserCallbackData;       // The draw callback code can access this.

    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = (ImTextureID)NULL; UserCallback = NULL; UserCallbackData = NULL; }
};

// Vertex index (override with '#define ImDrawIdx unsigned int' in imconfig.h)
#ifndef ImDrawIdx
typedef unsigned short ImDrawIdx;
#endif

// Vertex layout
#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
struct ImDrawVert
{
    ImVec2  pos;
    ImVec2  uv;
    ImU32   col;
};
#else
// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the struct or use a typedef)
// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
#endif

// Draw channels are used by the Columns API to "split" the render list into different channels while building, so items of each column can be batched together.
// You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.
struct ImDrawChannel
{
    ImVector<ImDrawCmd>     CmdBuffer;
    ImVector<ImDrawIdx>     IdxBuffer;
};

enum ImDrawCornerFlags_
{
    ImDrawCornerFlags_TopLeft   = 1 << 0, // 0x1
    ImDrawCornerFlags_TopRight  = 1 << 1, // 0x2
    ImDrawCornerFlags_BotLeft   = 1 << 2, // 0x4
    ImDrawCornerFlags_BotRight  = 1 << 3, // 0x8
    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3
    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC
    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5
    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA
    ImDrawCornerFlags_All       = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience
};

enum ImDrawListFlags_
{
    ImDrawListFlags_None             = 0,
    ImDrawListFlags_AntiAliasedLines = 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)
    ImDrawListFlags_AntiAliasedFill  = 1 << 1   // Filled shapes have anti-aliased edges (*2 the number of vertices)
};

// Draw command list
// This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each ImGui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
struct ImDrawList
{
    // This is what you have to render
    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

    // [Internal, used while building lists]
    const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    const char*             _OwnerName;         // Pointer to owner window's name for debugging
    unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size
    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    ImVector<ImVec4>        _ClipRectStack;     // [Internal]
    ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
    ImVector<ImVec2>        _Path;              // [Internal] current path building
    int                     _ChannelsCurrent;   // [Internal] current channel number (0)
    int                     _ChannelsCount;     // [Internal] number of active channels (1+)
    ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)

    // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)
    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
    ~ImDrawList() { ClearFreeMemory(); }
    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
    IMGUI_API void  PushClipRectFullScreen();
    IMGUI_API void  PopClipRect();
    IMGUI_API void  PushTextureID(ImTextureID texture_id);
    IMGUI_API void  PopTextureID();
    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }

    // Primitives
    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round
    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right
    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);
    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);
    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);
    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);
    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);
    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col); // Note: Anti-aliased filling requires points to be in clockwise order.
    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);

    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()
    inline    void  PathClear()                                                 { _Path.Size = 0; }
    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.
    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }
    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                            // Use precomputed angles for a 12 steps circle
    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);

    // Channels
    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
    IMGUI_API void  ChannelsSplit(int channels_count);
    IMGUI_API void  ChannelsMerge();
    IMGUI_API void  ChannelsSetCurrent(int channel_index);

    // Advanced
    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
    IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.

    // Internal helpers
    // NB: all primitives needs to be reserved via PrimReserve() beforehand!
    IMGUI_API void  Clear();
    IMGUI_API void  ClearFreeMemory();
    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
    IMGUI_API void  UpdateClipRect();
    IMGUI_API void  UpdateTextureID();
};

// All draw data to render an ImGui frame
// (NB: the style and the naming convention here is a little inconsistent but we preserve them for backward compatibility purpose)
struct ImDrawData
{
    bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
    ImDrawList**    CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.
    int             CmdListsCount;          // Number of ImDrawList* to render
    int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size
    int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size
    ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
    ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)
    ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.

    // Functions
    ImDrawData()    { Valid = false; Clear(); }
    ~ImDrawData()   { Clear(); }
    void Clear()    { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.f, 0.f); } // The ImDrawList are owned by ImGuiContext!
    IMGUI_API void  DeIndexAllBuffers();                    // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
    IMGUI_API void  ScaleClipRects(const ImVec2& fb_scale); // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
};

//-----------------------------------------------------------------------------
// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)
//-----------------------------------------------------------------------------

struct ImFontConfig
{
    void*           FontData;               //          // TTF/OTF data
    int             FontDataSize;           //          // TTF/OTF data size
    bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    int             FontNo;                 // 0        // Index of font within TTF/OTF file
    float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).
    int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
    int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis. 
    bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
    ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.
    const ImWchar*  GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
    float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
    float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs
    bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
    float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.

    // [Internal]
    char            Name[40];               // Name (strictly to ease debugging)
    ImFont*         DstFont;

    IMGUI_API ImFontConfig();
};

struct ImFontGlyph
{
    ImWchar         Codepoint;          // 0x0000..0xFFFF
    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
    float           X0, Y0, X1, Y1;     // Glyph corners
    float           U0, V0, U1, V1;     // Texture coordinates
};

// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
struct ImFontGlyphRangesBuilder
{
    ImVector<int> UsedChars;            // Store 1-bit per Unicode code point (0=unused, 1=used)

    ImFontGlyphRangesBuilder()          { UsedChars.resize(0x10000 / sizeof(int)); memset(UsedChars.Data, 0, 0x10000 / sizeof(int)); }
    bool            GetBit(int n) const { int off = (n >> 5); int mask = 1 << (n & 31); return (UsedChars[off] & mask) != 0; }  // Get bit n in the array
    void            SetBit(int n)       { int off = (n >> 5); int mask = 1 << (n & 31); UsedChars[off] |= mask; }               // Set bit n in the array
    void            AddChar(ImWchar c)  { SetBit(c); }                          // Add character
    IMGUI_API void  AddText(const char* text, const char* text_end = NULL);     // Add string (each character of the UTF-8 string are added)
    IMGUI_API void  AddRanges(const ImWchar* ranges);                           // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
    IMGUI_API void  BuildRanges(ImVector<ImWchar>* out_ranges);                 // Output new ranges
};

enum ImFontAtlasFlags_
{
    ImFontAtlasFlags_None               = 0,
    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
    ImFontAtlasFlags_NoMouseCursors     = 1 << 1    // Don't build software mouse cursors into the atlas
};

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//  - One or more fonts.
//  - Custom graphics data needed to render the shapes needed by Dear ImGui.
//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
// Common pitfalls:
// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
// - This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future!
struct ImFontAtlas
{
    IMGUI_API ImFontAtlas();
    IMGUI_API ~ImFontAtlas();
    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);
    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);
    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
    IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
    IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
    IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).
    IMGUI_API void              Clear();                    // Clear all input and output.

    // Build atlas, retrieve pixel data.
    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
    // The pitch is always = Width * BytesPerPixels (1 or 4)
    // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into
    // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.
    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
    bool                        IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }
    void                        SetTexID(ImTextureID id)    { TexID = id; }

    //-------------------------------------------
    // Glyph Ranges
    //-------------------------------------------

    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
    // NB: Consider using ImFontGlyphRangesBuilder to build glyph ranges from textual data.
    IMGUI_API const ImWchar*    GetGlyphRangesDefault();                // Basic Latin, Extended Latin
    IMGUI_API const ImWchar*    GetGlyphRangesKorean();                 // Default + Korean characters
    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
    IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
    IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters
    IMGUI_API const ImWchar*    GetGlyphRangesThai();                   // Default + Thai characters

    //-------------------------------------------
    // Custom Rectangles/Glyphs API
    //-------------------------------------------

    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.
    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.
    struct CustomRect
    {
        unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.
        unsigned short  Width, Height;  // Input    // Desired rectangle dimension
        unsigned short  X, Y;           // Output   // Packed position in Atlas
        float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance
        ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset
        ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font
        CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }
        bool IsPacked() const   { return X != 0xFFFF; }
    };

    IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
    IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.
    const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }

    // [Internal]
    IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
    IMGUI_API bool      GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);

    //-------------------------------------------
    // Members
    //-------------------------------------------

    bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
    ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
    int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0.

    // [Internal]
    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
    int                         TexWidth;           // Texture width calculated during Build().
    int                         TexHeight;          // Texture height calculated during Build().
    ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
    ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.
    ImVector<ImFontConfig>      ConfigData;         // Internal data
    int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETE 1.67+
#endif
};

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
struct ImFont
{
    // Members: Hot ~20/24 bytes (for CalcTextSize)
    ImVector<float>             IndexAdvanceX;      // 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).
    float                       FallbackAdvanceX;   // 4     // out // = FallbackGlyph->AdvanceX
    float                       FontSize;           // 4     // in  //            // Height of characters/line, set during loading (don't change after loading)

    // Members: Hot ~36/48 bytes (for CalcTextSize + render loop)
    ImVector<ImWchar>           IndexLookup;        // 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
    ImVector<ImFontGlyph>       Glyphs;             // 12-16 // out //            // All glyphs.
    const ImFontGlyph*          FallbackGlyph;      // 4-8   // out // = FindGlyph(FontFallbackChar)
    ImVec2                      DisplayOffset;      // 8     // in  // = (0,0)    // Offset font rendering by xx pixels

    // Members: Cold ~32/40 bytes
    ImFontAtlas*                ContainerAtlas;     // 4-8   // out //            // What we has been loaded into
    const ImFontConfig*         ConfigData;         // 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData
    short                       ConfigDataCount;    // 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
    ImWchar                     FallbackChar;       // 2     // in  // = '?'      // Replacement glyph if one isn't found. Only set via SetFallbackChar()
    float                       Scale;              // 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
    float                       Ascent, Descent;    // 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
    int                         MetricsTotalSurface;// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
    bool                        DirtyLookupTables;  // 1     // out //

    // Methods
    IMGUI_API ImFont();
    IMGUI_API ~ImFont();
    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
    IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }

    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const;
    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;

    // [Internal] Don't use!
    IMGUI_API void              BuildLookupTable();
    IMGUI_API void              ClearOutputData();
    IMGUI_API void              GrowIndex(int new_size);
    IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
    IMGUI_API void              SetFallbackChar(ImWchar c);

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    typedef ImFontGlyph Glyph; // OBSOLETE 1.52+
#endif
};

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) && __GNUC__ >= 8
#pragma GCC diagnostic pop
#endif

// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)
#ifdef IMGUI_INCLUDE_IMGUI_USER_H
#include "imgui_user.h"
#endif

```

`CSGOSimple/imgui/imgui_draw.cpp`:

```cpp
// dear imgui, v1.69 WIP
// (drawing and font code)

/*

Index of this file:

// [SECTION] STB libraries implementation
// [SECTION] Style functions
// [SECTION] ImDrawList
// [SECTION] ImDrawData
// [SECTION] Helpers ShadeVertsXXX functions
// [SECTION] ImFontConfig
// [SECTION] ImFontAtlas
// [SECTION] ImFontAtlas glyph ranges helpers
// [SECTION] ImFontGlyphRangesBuilder
// [SECTION] ImFont
// [SECTION] Internal Render Helpers
// [SECTION] Decompression code
// [SECTION] Default font data (ProggyClean.ttf)

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <stdio.h>      // vsnprintf, sscanf, printf
#if !defined(alloca)
#if defined(__GLIBC__) || defined(__sun) || defined(__CYGWIN__) || defined(__APPLE__)
#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)
#elif defined(_WIN32)
#include <malloc.h>     // alloca
#if !defined(alloca)
#define alloca _alloca  // for clang with MS Codegen
#endif
#else
#include <stdlib.h>     // alloca
#endif
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wcomma")
#pragma clang diagnostic ignored "-Wcomma"                  // warning : possible misuse of comma operator here             //
#endif
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic ignored "-Wreserved-id-macro"      // warning : macro name is a reserved identifier                //
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries implementation
//-------------------------------------------------------------------------

// Compile time options:
//#define IMGUI_STB_NAMESPACE           ImStb
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

#ifdef IMGUI_STB_NAMESPACE
namespace IMGUI_STB_NAMESPACE
{
#endif

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wcast-qual"              // warning : cast from 'const xxxx *' to 'xxx *' drops const qualifier //
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]
#pragma GCC diagnostic ignored "-Wcast-qual"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
#endif

#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION
#define STBRP_STATIC
#define STBRP_ASSERT(x)     IM_ASSERT(x)
#define STBRP_SORT          ImQsort
#define STB_RECT_PACK_IMPLEMENTATION
#endif
#ifdef IMGUI_STB_RECT_PACK_FILENAME
#include IMGUI_STB_RECT_PACK_FILENAME
#else
#include "imstb_rectpack.h"
#endif
#endif

#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
#define STBTT_malloc(x,u)   ((void)(u), ImGui::MemAlloc(x))
#define STBTT_free(x,u)     ((void)(u), ImGui::MemFree(x))
#define STBTT_assert(x)     IM_ASSERT(x)
#define STBTT_fmod(x,y)     ImFmod(x,y)
#define STBTT_sqrt(x)       ImSqrt(x)
#define STBTT_pow(x,y)      ImPow(x,y)
#define STBTT_fabs(x)       ImFabs(x)
#define STBTT_ifloor(x)     ((int)ImFloorStd(x))
#define STBTT_iceil(x)      ((int)ImCeil(x))
#define STBTT_STATIC
#define STB_TRUETYPE_IMPLEMENTATION
#else
#define STBTT_DEF extern
#endif
#ifdef IMGUI_STB_TRUETYPE_FILENAME
#include IMGUI_STB_TRUETYPE_FILENAME
#else
#include "imstb_truetype.h"
#endif
#endif

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

#ifdef IMGUI_STB_NAMESPACE
} // namespace ImStb
using namespace IMGUI_STB_NAMESPACE;
#endif

//-----------------------------------------------------------------------------
// [SECTION] Style functions
//-----------------------------------------------------------------------------

void ImGui::StyleColorsDark(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
}

void ImGui::StyleColorsClassic(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);
    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);
    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

// Those light colors are better suited with a thicker font than the default one + FrameBorder
void ImGui::StyleColorsLight(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);
    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);
    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.90f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

//-----------------------------------------------------------------------------
// ImDrawList
//-----------------------------------------------------------------------------

ImDrawListSharedData::ImDrawListSharedData()
{
    Font = NULL;
    FontSize = 0.0f;
    CurveTessellationTol = 0.0f;
    ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);

    // Const data
    for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)
    {
        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);
        CircleVtx12[i] = ImVec2(ImCos(a), ImSin(a));
    }
}

void ImDrawList::Clear()
{
    CmdBuffer.resize(0);
    IdxBuffer.resize(0);
    VtxBuffer.resize(0);
    Flags = ImDrawListFlags_AntiAliasedLines | ImDrawListFlags_AntiAliasedFill;
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.resize(0);
    _TextureIdStack.resize(0);
    _Path.resize(0);
    _ChannelsCurrent = 0;
    _ChannelsCount = 1;
    // NB: Do not clear channels so our allocations are re-used after the first frame.
}

void ImDrawList::ClearFreeMemory()
{
    CmdBuffer.clear();
    IdxBuffer.clear();
    VtxBuffer.clear();
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.clear();
    _TextureIdStack.clear();
    _Path.clear();
    _ChannelsCurrent = 0;
    _ChannelsCount = 1;
    for (int i = 0; i < _Channels.Size; i++)
    {
        if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again
        _Channels[i].CmdBuffer.clear();
        _Channels[i].IdxBuffer.clear();
    }
    _Channels.clear();
}

ImDrawList* ImDrawList::CloneOutput() const
{
    ImDrawList* dst = IM_NEW(ImDrawList(NULL));
    dst->CmdBuffer = CmdBuffer;
    dst->IdxBuffer = IdxBuffer;
    dst->VtxBuffer = VtxBuffer;
    dst->Flags = Flags;
    return dst;
}

// Using macros because C++ is a terrible language, we want guaranteed inline, no code in header, and no overhead in Debug builds
#define GetCurrentClipRect()    (_ClipRectStack.Size ? _ClipRectStack.Data[_ClipRectStack.Size-1]  : _Data->ClipRectFullscreen)
#define GetCurrentTextureId()   (_TextureIdStack.Size ? _TextureIdStack.Data[_TextureIdStack.Size-1] : NULL)

void ImDrawList::AddDrawCmd()
{
    ImDrawCmd draw_cmd;
    draw_cmd.ClipRect = GetCurrentClipRect();
    draw_cmd.TextureId = GetCurrentTextureId();

    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
    CmdBuffer.push_back(draw_cmd);
}

void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)
{
    ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
    if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        current_cmd = &CmdBuffer.back();
    }
    current_cmd->UserCallback = callback;
    current_cmd->UserCallbackData = callback_data;

    AddDrawCmd(); // Force a new command after us (see comment below)
}

// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
void ImDrawList::UpdateClipRect()
{
    // If current command is used with different settings we need to add a new command
    const ImVec4 curr_clip_rect = GetCurrentClipRect();
    ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size-1] : NULL;
    if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        return;
    }

    // Try to merge with previous command if it matches, else use current command
    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
    if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)
        CmdBuffer.pop_back();
    else
        curr_cmd->ClipRect = curr_clip_rect;
}

void ImDrawList::UpdateTextureID()
{
    // If current command is used with different settings we need to add a new command
    const ImTextureID curr_texture_id = GetCurrentTextureId();
    ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
    if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        return;
    }

    // Try to merge with previous command if it matches, else use current command
    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
    if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)
        CmdBuffer.pop_back();
    else
        curr_cmd->TextureId = curr_texture_id;
}

#undef GetCurrentClipRect
#undef GetCurrentTextureId

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
void ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)
{
    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
    if (intersect_with_current_clip_rect && _ClipRectStack.Size)
    {
        ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size-1];
        if (cr.x < current.x) cr.x = current.x;
        if (cr.y < current.y) cr.y = current.y;
        if (cr.z > current.z) cr.z = current.z;
        if (cr.w > current.w) cr.w = current.w;
    }
    cr.z = ImMax(cr.x, cr.z);
    cr.w = ImMax(cr.y, cr.w);

    _ClipRectStack.push_back(cr);
    UpdateClipRect();
}

void ImDrawList::PushClipRectFullScreen()
{
    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
}

void ImDrawList::PopClipRect()
{
    IM_ASSERT(_ClipRectStack.Size > 0);
    _ClipRectStack.pop_back();
    UpdateClipRect();
}

void ImDrawList::PushTextureID(ImTextureID texture_id)
{
    _TextureIdStack.push_back(texture_id);
    UpdateTextureID();
}

void ImDrawList::PopTextureID()
{
    IM_ASSERT(_TextureIdStack.Size > 0);
    _TextureIdStack.pop_back();
    UpdateTextureID();
}

void ImDrawList::ChannelsSplit(int channels_count)
{
    IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);
    int old_channels_count = _Channels.Size;
    if (old_channels_count < channels_count)
        _Channels.resize(channels_count);
    _ChannelsCount = channels_count;

    // _Channels[] (24/32 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer
    // The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
    // When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer
    memset(&_Channels[0], 0, sizeof(ImDrawChannel));
    for (int i = 1; i < channels_count; i++)
    {
        if (i >= old_channels_count)
        {
            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();
        }
        else
        {
            _Channels[i].CmdBuffer.resize(0);
            _Channels[i].IdxBuffer.resize(0);
        }
        if (_Channels[i].CmdBuffer.Size == 0)
        {
            ImDrawCmd draw_cmd;
            draw_cmd.ClipRect = _ClipRectStack.back();
            draw_cmd.TextureId = _TextureIdStack.back();
            _Channels[i].CmdBuffer.push_back(draw_cmd);
        }
    }
}

void ImDrawList::ChannelsMerge()
{
    // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
    if (_ChannelsCount <= 1)
        return;

    ChannelsSetCurrent(0);
    if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)
        CmdBuffer.pop_back();

    int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;
    for (int i = 1; i < _ChannelsCount; i++)
    {
        ImDrawChannel& ch = _Channels[i];
        if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)
            ch.CmdBuffer.pop_back();
        new_cmd_buffer_count += ch.CmdBuffer.Size;
        new_idx_buffer_count += ch.IdxBuffer.Size;
    }
    CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);
    IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);

    ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;
    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;
    for (int i = 1; i < _ChannelsCount; i++)
    {
        ImDrawChannel& ch = _Channels[i];
        if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }
        if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }
    }
    UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.
    _ChannelsCount = 1;
}

void ImDrawList::ChannelsSetCurrent(int idx)
{
    IM_ASSERT(idx < _ChannelsCount);
    if (_ChannelsCurrent == idx) return;
    memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times
    memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));
    _ChannelsCurrent = idx;
    memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));
    memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));
    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;
}

// NB: this can be called with negative count for removing primitives (as long as the result does not underflow)
void ImDrawList::PrimReserve(int idx_count, int vtx_count)
{
    ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size-1];
    draw_cmd.ElemCount += idx_count;

    int vtx_buffer_old_size = VtxBuffer.Size;
    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

    int idx_buffer_old_size = IdxBuffer.Size;
    IdxBuffer.resize(idx_buffer_old_size + idx_count);
    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
}

// Fully unrolled with inline call to keep our debug builds decently fast.
void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)
{
    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
{
    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superflous function calls to optimize debug/non-inlined builds.
// Those macros expects l-values.
#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)                         { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = 1.0f / ImSqrt(d2); VX *= inv_len; VY *= inv_len; } }
#define IM_NORMALIZE2F_OVER_EPSILON_CLAMP(VX,VY,EPS,INVLENMAX)  { float d2 = VX*VX + VY*VY; if (d2 > EPS)  { float inv_len = 1.0f / ImSqrt(d2); if (inv_len > INVLENMAX) inv_len = INVLENMAX; VX *= inv_len; VY *= inv_len; } }

// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness)
{
    if (points_count < 2)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;

    int count = points_count;
    if (!closed)
        count = points_count-1;

    const bool thick_line = thickness > 1.0f;
    if (Flags & ImDrawListFlags_AntiAliasedLines)
    {
        // Anti-aliased stroke
        const float AA_SIZE = 1.0f;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;

        const int idx_count = thick_line ? count*18 : count*12;
        const int vtx_count = thick_line ? points_count*4 : points_count*3;
        PrimReserve(idx_count, vtx_count);

        // Temporary buffer
        ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2)); //-V630
        ImVec2* temp_points = temp_normals + points_count;

        for (int i1 = 0; i1 < count; i1++)
        {
            const int i2 = (i1+1) == points_count ? 0 : i1+1;
            float dx = points[i2].x - points[i1].x;
            float dy = points[i2].y - points[i1].y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            temp_normals[i1].x = dy;
            temp_normals[i1].y = -dx;
        }
        if (!closed)
            temp_normals[points_count-1] = temp_normals[points_count-2];

        if (!thick_line)
        {
            if (!closed)
            {
                temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;
                temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;
                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;
                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;
            }

            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
            unsigned int idx1 = _VtxCurrentIdx;
            for (int i1 = 0; i1 < count; i1++)
            {
                const int i2 = (i1+1) == points_count ? 0 : i1+1;
                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+3;

                // Average normals
                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
                IM_NORMALIZE2F_OVER_EPSILON_CLAMP(dm_x, dm_y, 0.000001f, 100.0f)
                dm_x *= AA_SIZE;
                dm_y *= AA_SIZE;

                // Add temporary vertexes
                ImVec2* out_vtx = &temp_points[i2*2];
                out_vtx[0].x = points[i2].x + dm_x;
                out_vtx[0].y = points[i2].y + dm_y;
                out_vtx[1].x = points[i2].x - dm_x;
                out_vtx[1].y = points[i2].y - dm_y;

                // Add indexes
                _IdxWritePtr[0] = (ImDrawIdx)(idx2+0); _IdxWritePtr[1] = (ImDrawIdx)(idx1+0); _IdxWritePtr[2] = (ImDrawIdx)(idx1+2);
                _IdxWritePtr[3] = (ImDrawIdx)(idx1+2); _IdxWritePtr[4] = (ImDrawIdx)(idx2+2); _IdxWritePtr[5] = (ImDrawIdx)(idx2+0);
                _IdxWritePtr[6] = (ImDrawIdx)(idx2+1); _IdxWritePtr[7] = (ImDrawIdx)(idx1+1); _IdxWritePtr[8] = (ImDrawIdx)(idx1+0);
                _IdxWritePtr[9] = (ImDrawIdx)(idx1+0); _IdxWritePtr[10]= (ImDrawIdx)(idx2+0); _IdxWritePtr[11]= (ImDrawIdx)(idx2+1);
                _IdxWritePtr += 12;

                idx1 = idx2;
            }

            // Add vertexes
            for (int i = 0; i < points_count; i++)
            {
                _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
                _VtxWritePtr[1].pos = temp_points[i*2+0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;
                _VtxWritePtr[2].pos = temp_points[i*2+1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;
                _VtxWritePtr += 3;
            }
        }
        else
        {
            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
            if (!closed)
            {
                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
                temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);
                temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);
                temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);
                temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);
            }

            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
            unsigned int idx1 = _VtxCurrentIdx;
            for (int i1 = 0; i1 < count; i1++)
            {
                const int i2 = (i1+1) == points_count ? 0 : i1+1;
                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;

                // Average normals
                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
                IM_NORMALIZE2F_OVER_EPSILON_CLAMP(dm_x, dm_y, 0.000001f, 100.0f);
                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
                float dm_in_x = dm_x * half_inner_thickness;
                float dm_in_y = dm_y * half_inner_thickness;

                // Add temporary vertexes
                ImVec2* out_vtx = &temp_points[i2*4];
                out_vtx[0].x = points[i2].x + dm_out_x;
                out_vtx[0].y = points[i2].y + dm_out_y;
                out_vtx[1].x = points[i2].x + dm_in_x;
                out_vtx[1].y = points[i2].y + dm_in_y;
                out_vtx[2].x = points[i2].x - dm_in_x;
                out_vtx[2].y = points[i2].y - dm_in_y;
                out_vtx[3].x = points[i2].x - dm_out_x;
                out_vtx[3].y = points[i2].y - dm_out_y;

                // Add indexes
                _IdxWritePtr[0]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1+2);
                _IdxWritePtr[3]  = (ImDrawIdx)(idx1+2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2+2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2+1);
                _IdxWritePtr[6]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1+0);
                _IdxWritePtr[9]  = (ImDrawIdx)(idx1+0); _IdxWritePtr[10] = (ImDrawIdx)(idx2+0); _IdxWritePtr[11] = (ImDrawIdx)(idx2+1);
                _IdxWritePtr[12] = (ImDrawIdx)(idx2+2); _IdxWritePtr[13] = (ImDrawIdx)(idx1+2); _IdxWritePtr[14] = (ImDrawIdx)(idx1+3);
                _IdxWritePtr[15] = (ImDrawIdx)(idx1+3); _IdxWritePtr[16] = (ImDrawIdx)(idx2+3); _IdxWritePtr[17] = (ImDrawIdx)(idx2+2);
                _IdxWritePtr += 18;

                idx1 = idx2;
            }

            // Add vertexes
            for (int i = 0; i < points_count; i++)
            {
                _VtxWritePtr[0].pos = temp_points[i*4+0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;
                _VtxWritePtr[1].pos = temp_points[i*4+1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
                _VtxWritePtr[2].pos = temp_points[i*4+2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
                _VtxWritePtr[3].pos = temp_points[i*4+3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;
                _VtxWritePtr += 4;
            }
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Stroke
        const int idx_count = count*6;
        const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges
        PrimReserve(idx_count, vtx_count);

        for (int i1 = 0; i1 < count; i1++)
        {
            const int i2 = (i1+1) == points_count ? 0 : i1+1;
            const ImVec2& p1 = points[i1];
            const ImVec2& p2 = points[i2];

            float dx = p2.x - p1.x;
            float dy = p2.y - p1.y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            dx *= (thickness * 0.5f);
            dy *= (thickness * 0.5f);

            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
            _VtxWritePtr += 4;

            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+2);
            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);
            _IdxWritePtr += 6;
            _VtxCurrentIdx += 4;
        }
    }
}

// We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
{
    if (points_count < 3)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;

    if (Flags & ImDrawListFlags_AntiAliasedFill)
    {
        // Anti-aliased Fill
        const float AA_SIZE = 1.0f;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
        const int idx_count = (points_count-2)*3 + points_count*6;
        const int vtx_count = (points_count*2);
        PrimReserve(idx_count, vtx_count);

        // Add indexes for fill
        unsigned int vtx_inner_idx = _VtxCurrentIdx;
        unsigned int vtx_outer_idx = _VtxCurrentIdx+1;
        for (int i = 2; i < points_count; i++)
        {
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+((i-1)<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx+(i<<1));
            _IdxWritePtr += 3;
        }

        // Compute normals
        ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2)); //-V630
        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            const ImVec2& p0 = points[i0];
            const ImVec2& p1 = points[i1];
            float dx = p1.x - p0.x;
            float dy = p1.y - p0.y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            temp_normals[i0].x = dy;
            temp_normals[i0].y = -dx;
        }

        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            // Average normals
            const ImVec2& n0 = temp_normals[i0];
            const ImVec2& n1 = temp_normals[i1];
            float dm_x = (n0.x + n1.x) * 0.5f;
            float dm_y = (n0.y + n1.y) * 0.5f;
            IM_NORMALIZE2F_OVER_EPSILON_CLAMP(dm_x, dm_y, 0.000001f, 100.0f);
            dm_x *= AA_SIZE * 0.5f;
            dm_y *= AA_SIZE * 0.5f;

            // Add vertices
            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
            _VtxWritePtr += 2;

            // Add indexes for fringes
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx+(i1<<1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+(i0<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx+(i0<<1));
            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx+(i0<<1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx+(i1<<1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx+(i1<<1));
            _IdxWritePtr += 6;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Fill
        const int idx_count = (points_count-2)*3;
        const int vtx_count = points_count;
        PrimReserve(idx_count, vtx_count);
        for (int i = 0; i < vtx_count; i++)
        {
            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr++;
        }
        for (int i = 2; i < points_count; i++)
        {
            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+i-1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+i);
            _IdxWritePtr += 3;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
}

void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)
{
    if (radius == 0.0f || a_min_of_12 > a_max_of_12)
    {
        _Path.push_back(centre);
        return;
    }
    _Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));
    for (int a = a_min_of_12; a <= a_max_of_12; a++)
    {
        const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];
        _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));
    }
}

void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments)
{
    if (radius == 0.0f)
    {
        _Path.push_back(centre);
        return;
    }

    // Note that we are adding a point at both a_min and a_max.
    // If you are trying to draw a full closed circle you don't want the overlapping points!
    _Path.reserve(_Path.Size + (num_segments + 1));
    for (int i = 0; i <= num_segments; i++)
    {
        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
        _Path.push_back(ImVec2(centre.x + ImCos(a) * radius, centre.y + ImSin(a) * radius));
    }
}

static void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
{
    float dx = x4 - x1;
    float dy = y4 - y1;
    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
    d2 = (d2 >= 0) ? d2 : -d2;
    d3 = (d3 >= 0) ? d3 : -d3;
    if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))
    {
        path->push_back(ImVec2(x4, y4));
    }
    else if (level < 10)
    {
        float x12 = (x1+x2)*0.5f,       y12 = (y1+y2)*0.5f;
        float x23 = (x2+x3)*0.5f,       y23 = (y2+y3)*0.5f;
        float x34 = (x3+x4)*0.5f,       y34 = (y3+y4)*0.5f;
        float x123 = (x12+x23)*0.5f,    y123 = (y12+y23)*0.5f;
        float x234 = (x23+x34)*0.5f,    y234 = (y23+y34)*0.5f;
        float x1234 = (x123+x234)*0.5f, y1234 = (y123+y234)*0.5f;

        PathBezierToCasteljau(path, x1,y1,        x12,y12,    x123,y123,  x1234,y1234, tess_tol, level+1);
        PathBezierToCasteljau(path, x1234,y1234,  x234,y234,  x34,y34,    x4,y4,       tess_tol, level+1);
    }
}

void ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)
{
    ImVec2 p1 = _Path.back();
    if (num_segments == 0)
    {
        // Auto-tessellated
        PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);
    }
    else
    {
        float t_step = 1.0f / (float)num_segments;
        for (int i_step = 1; i_step <= num_segments; i_step++)
        {
            float t = t_step * i_step;
            float u = 1.0f - t;
            float w1 = u*u*u;
            float w2 = 3*u*u*t;
            float w3 = 3*u*t*t;
            float w4 = t*t*t;
            _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));
        }
    }
}

void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)
{
    rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((rounding_corners & ImDrawCornerFlags_Top)  == ImDrawCornerFlags_Top)  || ((rounding_corners & ImDrawCornerFlags_Bot)   == ImDrawCornerFlags_Bot)   ? 0.5f : 1.0f ) - 1.0f);
    rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f ) - 1.0f);

    if (rounding <= 0.0f || rounding_corners == 0)
    {
        PathLineTo(a);
        PathLineTo(ImVec2(b.x, a.y));
        PathLineTo(b);
        PathLineTo(ImVec2(a.x, b.y));
    }
    else
    {
        const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;
        const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;
        const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;
        const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;
        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
    }
}

void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    PathLineTo(a + ImVec2(0.5f,0.5f));
    PathLineTo(b + ImVec2(0.5f,0.5f));
    PathStroke(col, false, thickness);
}

// a: upper-left, b: lower-right. we don't render 1 px sized rectangles properly.
void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    if (Flags & ImDrawListFlags_AntiAliasedLines)
        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.50f,0.50f), rounding, rounding_corners_flags);
    else
        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.49f,0.49f), rounding, rounding_corners_flags); // Better looking lower-right corner and rounded non-AA shapes.
    PathStroke(col, true, thickness);
}

void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    if (rounding > 0.0f)
    {
        PathRect(a, b, rounding, rounding_corners_flags);
        PathFillConvex(col);
    }
    else
    {
        PrimReserve(6, 4);
        PrimRect(a, b, col);
    }
}

void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
{
    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;
    PrimReserve(6, 4);
    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));
    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));
    PrimWriteVtx(a, uv, col_upr_left);
    PrimWriteVtx(ImVec2(c.x, a.y), uv, col_upr_right);
    PrimWriteVtx(c, uv, col_bot_right);
    PrimWriteVtx(ImVec2(a.x, c.y), uv, col_bot_left);
}

void ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathLineTo(d);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathLineTo(d);
    PathFillConvex(col);
}

void ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathFillConvex(col);
}

void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
        return;

    // Because we are filling a closed shape we remove 1 from the count of segments/points
    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(centre, radius-0.5f, 0.0f, a_max, num_segments - 1);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
        return;

    // Because we are filling a closed shape we remove 1 from the count of segments/points
    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(centre, radius, 0.0f, a_max, num_segments - 1);
    PathFillConvex(col);
}

void ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(pos0);
    PathBezierCurveTo(cp0, cp1, pos1, num_segments);
    PathStroke(col, false, thickness);
}

void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    if (text_end == NULL)
        text_end = text_begin + strlen(text_begin);
    if (text_begin == text_end)
        return;

    // Pull default font/size from the shared ImDrawListSharedData instance
    if (font == NULL)
        font = _Data->Font;
    if (font_size == 0.0f)
        font_size = _Data->FontSize;

    IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

    ImVec4 clip_rect = _ClipRectStack.back();
    if (cpu_fine_clip_rect)
    {
        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
    }
    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
}

void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
{
    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
}

void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimRectUV(a, b, uv_a, uv_b, col);

    if (push_texture_id)
        PopTextureID();
}

void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);

    if (push_texture_id)
        PopTextureID();
}

void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)
    {
        AddImage(user_texture_id, a, b, uv_a, uv_b, col);
        return;
    }

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    int vert_start_idx = VtxBuffer.Size;
    PathRect(a, b, rounding, rounding_corners);
    PathFillConvex(col);
    int vert_end_idx = VtxBuffer.Size;
    ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b, true);

    if (push_texture_id)
        PopTextureID();
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawData
//-----------------------------------------------------------------------------

// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
void ImDrawData::DeIndexAllBuffers()
{
    ImVector<ImDrawVert> new_vtx_buffer;
    TotalVtxCount = TotalIdxCount = 0;
    for (int i = 0; i < CmdListsCount; i++)
    {
        ImDrawList* cmd_list = CmdLists[i];
        if (cmd_list->IdxBuffer.empty())
            continue;
        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);
        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)
            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];
        cmd_list->VtxBuffer.swap(new_vtx_buffer);
        cmd_list->IdxBuffer.resize(0);
        TotalVtxCount += cmd_list->VtxBuffer.Size;
    }
}

// Helper to scale the ClipRect field of each ImDrawCmd. 
// Use if your final output buffer is at a different scale than draw_data->DisplaySize, 
// or if there is a difference between your window resolution and framebuffer resolution.
void ImDrawData::ScaleClipRects(const ImVec2& fb_scale)
{
    for (int i = 0; i < CmdListsCount; i++)
    {
        ImDrawList* cmd_list = CmdLists[i];
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];
            cmd->ClipRect = ImVec4(cmd->ClipRect.x * fb_scale.x, cmd->ClipRect.y * fb_scale.y, cmd->ClipRect.z * fb_scale.x, cmd->ClipRect.w * fb_scale.y);
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers ShadeVertsXXX functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)
{
    ImVec2 gradient_extent = gradient_p1 - gradient_p0;
    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);
    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)
    {
        float d = ImDot(vert->pos - gradient_p0, gradient_extent);
        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);
        int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);
        int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);
        int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);
        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);
    }
}

// Distribute UV over (a, b) rectangle
void ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)
{
    const ImVec2 size = b - a;
    const ImVec2 uv_size = uv_b - uv_a;
    const ImVec2 scale = ImVec2(
        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);

    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    if (clamp)
    {
        const ImVec2 min = ImMin(uv_a, uv_b);
        const ImVec2 max = ImMax(uv_a, uv_b);
        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);
    }
    else
    {
        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontConfig
//-----------------------------------------------------------------------------

ImFontConfig::ImFontConfig()
{
    FontData = NULL;
    FontDataSize = 0;
    FontDataOwnedByAtlas = true;
    FontNo = 0;
    SizePixels = 0.0f;
    OversampleH = 3; // FIXME: 2 may be a better default?
    OversampleV = 1;
    PixelSnapH = false;
    GlyphExtraSpacing = ImVec2(0.0f, 0.0f);
    GlyphOffset = ImVec2(0.0f, 0.0f);
    GlyphRanges = NULL;
    GlyphMinAdvanceX = 0.0f;
    GlyphMaxAdvanceX = FLT_MAX;
    MergeMode = false;
    RasterizerFlags = 0x00;
    RasterizerMultiply = 1.0f;
    memset(Name, 0, sizeof(Name));
    DstFont = NULL;
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
// The white texels on the top left are the ones we'll use everywhere in ImGui to render filled shapes.
const int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 108;
const int FONT_ATLAS_DEFAULT_TEX_DATA_H      = 27;
const unsigned int FONT_ATLAS_DEFAULT_TEX_DATA_ID = 0x80000000;
static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =
{
    "..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          "
    "..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         "
    "---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         "
    "X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         "
    "XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         "
    "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       "
    "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    "
    "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  "
    "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X "
    "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X"
    "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X"
    "X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X"
    "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X"
    "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X"
    "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X"
    "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X"
    "X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X "
    "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X "
    "X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X "
    "XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  "
    "      X..X          -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  "
    "       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  "
    "------------        -    X    -           X           -X.....................X-           ------------------"
    "                    ----------------------------------- X...XXXXXXXXXXXXX...X -                             "
    "                                                      -  X..X           X..X  -                             "
    "                                                      -   X.X           X.X   -                             "
    "                                                      -    XX           XX    -                             "
};

static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =
{
    // Pos ........ Size ......... Offset ......
    { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow
    { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput
    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll
    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS
    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW
    { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW
    { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE
    { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand
};

ImFontAtlas::ImFontAtlas()
{
    Locked = false;
    Flags = ImFontAtlasFlags_None;
    TexID = (ImTextureID)NULL;
    TexDesiredWidth = 0;
    TexGlyphPadding = 1;

    TexPixelsAlpha8 = NULL;
    TexPixelsRGBA32 = NULL;
    TexWidth = TexHeight = 0;
    TexUvScale = ImVec2(0.0f, 0.0f);
    TexUvWhitePixel = ImVec2(0.0f, 0.0f);
    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)
        CustomRectIds[n] = -1;
}

ImFontAtlas::~ImFontAtlas()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    Clear();
}

void    ImFontAtlas::ClearInputData()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    for (int i = 0; i < ConfigData.Size; i++)
        if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)
        {
            ImGui::MemFree(ConfigData[i].FontData);
            ConfigData[i].FontData = NULL;
        }

    // When clearing this we lose access to the font name and other information used to build the font.
    for (int i = 0; i < Fonts.Size; i++)
        if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)
        {
            Fonts[i]->ConfigData = NULL;
            Fonts[i]->ConfigDataCount = 0;
        }
    ConfigData.clear();
    CustomRects.clear();
    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)
        CustomRectIds[n] = -1;
}

void    ImFontAtlas::ClearTexData()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    if (TexPixelsAlpha8)
        ImGui::MemFree(TexPixelsAlpha8);
    if (TexPixelsRGBA32)
        ImGui::MemFree(TexPixelsRGBA32);
    TexPixelsAlpha8 = NULL;
    TexPixelsRGBA32 = NULL;
}

void    ImFontAtlas::ClearFonts()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    for (int i = 0; i < Fonts.Size; i++)
        IM_DELETE(Fonts[i]);
    Fonts.clear();
}

void    ImFontAtlas::Clear()
{
    ClearInputData();
    ClearTexData();
    ClearFonts();
}

void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
    // Build atlas on demand
    if (TexPixelsAlpha8 == NULL)
    {
        if (ConfigData.empty())
            AddFontDefault();
        Build();
    }

    *out_pixels = TexPixelsAlpha8;
    if (out_width) *out_width = TexWidth;
    if (out_height) *out_height = TexHeight;
    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
}

void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
    // Convert to RGBA32 format on demand
    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
    if (!TexPixelsRGBA32)
    {
        unsigned char* pixels = NULL;
        GetTexDataAsAlpha8(&pixels, NULL, NULL);
        if (pixels)
        {
            TexPixelsRGBA32 = (unsigned int*)ImGui::MemAlloc((size_t)TexWidth * (size_t)TexHeight * 4);
            const unsigned char* src = pixels;
            unsigned int* dst = TexPixelsRGBA32;
            for (int n = TexWidth * TexHeight; n > 0; n--)
                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
        }
    }

    *out_pixels = (unsigned char*)TexPixelsRGBA32;
    if (out_width) *out_width = TexWidth;
    if (out_height) *out_height = TexHeight;
    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
}

ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
    IM_ASSERT(font_cfg->SizePixels > 0.0f);

    // Create new font
    if (!font_cfg->MergeMode)
        Fonts.push_back(IM_NEW(ImFont));
    else
        IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

    ConfigData.push_back(*font_cfg);
    ImFontConfig& new_font_cfg = ConfigData.back();
    if (new_font_cfg.DstFont == NULL)
        new_font_cfg.DstFont = Fonts.back();
    if (!new_font_cfg.FontDataOwnedByAtlas)
    {
        new_font_cfg.FontData = ImGui::MemAlloc(new_font_cfg.FontDataSize);
        new_font_cfg.FontDataOwnedByAtlas = true;
        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
    }

    // Invalidate texture
    ClearTexData();
    return new_font_cfg.DstFont;
}

// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
static unsigned int stb_decompress_length(const unsigned char *input);
static unsigned int stb_decompress(unsigned char *output, const unsigned char *input, unsigned int length);
static const char*  GetDefaultCompressedFontDataTTFBase85();
static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
static void         Decode85(const unsigned char* src, unsigned char* dst)
{
    while (*src)
    {
        unsigned int tmp = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4]))));
        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
        src += 5;
        dst += 4;
    }
}

// Load embedded ProggyClean.ttf at size 13, disable oversampling
ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)
{
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    if (!font_cfg_template)
    {
        font_cfg.OversampleH = font_cfg.OversampleV = 1;
        font_cfg.PixelSnapH = true;
    }
    if (font_cfg.SizePixels <= 0.0f) 
        font_cfg.SizePixels = 13.0f * 1.0f;
    if (font_cfg.Name[0] == '\0') 
        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
    font->DisplayOffset.y = 1.0f;
    return font;
}

ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    size_t data_size = 0;
    void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);
    if (!data)
    {
        IM_ASSERT(0); // Could not load file.
        return NULL;
    }
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    if (font_cfg.Name[0] == '\0')
    {
        // Store a short copy of filename into into the font name for convenience
        const char* p;
        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}
        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);
    }
    return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);
}

// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    IM_ASSERT(font_cfg.FontData == NULL);
    font_cfg.FontData = ttf_data;
    font_cfg.FontDataSize = ttf_size;
    font_cfg.SizePixels = size_pixels;
    if (glyph_ranges)
        font_cfg.GlyphRanges = glyph_ranges;
    return AddFont(&font_cfg);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
    unsigned char* buf_decompressed_data = (unsigned char *)ImGui::MemAlloc(buf_decompressed_size);
    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);

    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    IM_ASSERT(font_cfg.FontData == NULL);
    font_cfg.FontDataOwnedByAtlas = true;
    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
{
    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
    void* compressed_ttf = ImGui::MemAlloc((size_t)compressed_ttf_size);
    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
    ImGui::MemFree(compressed_ttf);
    return font;
}

int ImFontAtlas::AddCustomRectRegular(unsigned int id, int width, int height)
{
    IM_ASSERT(id >= 0x10000);
    IM_ASSERT(width > 0 && width <= 0xFFFF);
    IM_ASSERT(height > 0 && height <= 0xFFFF);
    CustomRect r;
    r.ID = id;
    r.Width = (unsigned short)width;
    r.Height = (unsigned short)height;
    CustomRects.push_back(r);
    return CustomRects.Size - 1; // Return index
}

int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
{
    IM_ASSERT(font != NULL);
    IM_ASSERT(width > 0 && width <= 0xFFFF);
    IM_ASSERT(height > 0 && height <= 0xFFFF);
    CustomRect r;
    r.ID = id;
    r.Width = (unsigned short)width;
    r.Height = (unsigned short)height;
    r.GlyphAdvanceX = advance_x;
    r.GlyphOffset = offset;
    r.Font = font;
    CustomRects.push_back(r);
    return CustomRects.Size - 1; // Return index
}

void ImFontAtlas::CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max)
{
    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
    *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);
    *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);
}

bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])
{
    if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)
        return false;
    if (Flags & ImFontAtlasFlags_NoMouseCursors)
        return false;

    IM_ASSERT(CustomRectIds[0] != -1);
    ImFontAtlas::CustomRect& r = CustomRects[CustomRectIds[0]];
    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
    ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r.X, (float)r.Y);
    ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
    *out_size = size;
    *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
    out_uv_border[0] = (pos) * TexUvScale;
    out_uv_border[1] = (pos + size) * TexUvScale;
    pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
    out_uv_fill[0] = (pos) * TexUvScale;
    out_uv_fill[1] = (pos + size) * TexUvScale;
    return true;
}

bool    ImFontAtlas::Build()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    return ImFontAtlasBuildWithStbTruetype(this);
}

void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
{
    for (unsigned int i = 0; i < 256; i++)
    {
        unsigned int value = (unsigned int)(i * in_brighten_factor);
        out_table[i] = value > 255 ? 255 : (value & 0xFF);
    }
}

void    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)
{
    unsigned char* data = pixels + x + y * stride;
    for (int j = h; j > 0; j--, data += stride)
        for (int i = 0; i < w; i++)
            data[i] = table[data[i]];
}

// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)
// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)
struct ImFontBuildSrcData
{
    stbtt_fontinfo      FontInfo;
    stbtt_pack_range    PackRange;          // Hold the list of codepoints to pack (essentially points to Codepoints.Data)
    stbrp_rect*         Rects;              // Rectangle to pack. We first fill in their size and the packer will give us their position.
    stbtt_packedchar*   PackedChars;        // Output glyphs
    const ImWchar*      SrcRanges;          // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)
    int                 DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[]
    int                 GlyphsHighest;      // Highest requested codepoint
    int                 GlyphsCount;        // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)
    ImBoolVector        GlyphsSet;          // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)
    ImVector<int>       GlyphsList;         // Glyph codepoints list (flattened version of GlyphsMap)
};

// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)
struct ImFontBuildDstData
{
    int                 SrcCount;           // Number of source fonts targeting this destination font.
    int                 GlyphsHighest;
    int                 GlyphsCount;
    ImBoolVector        GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.
};

static void UnpackBoolVectorToFlatIndexList(const ImBoolVector* in, ImVector<int>* out)
{
    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
    const int* it_begin = in->Storage.begin();
    const int* it_end = in->Storage.end();
    for (const int* it = it_begin; it < it_end; it++)
        if (int entries_32 = *it)
            for (int bit_n = 0; bit_n < 32; bit_n++)
                if (entries_32 & (1 << bit_n))
                    out->push_back((int)((it - it_begin) << 5) + bit_n);
}

bool    ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)
{
    IM_ASSERT(atlas->ConfigData.Size > 0);

    ImFontAtlasBuildRegisterDefaultCustomRects(atlas);

    // Clear atlas
    atlas->TexID = (ImTextureID)NULL;
    atlas->TexWidth = atlas->TexHeight = 0;
    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
    atlas->ClearTexData();

    // Temporary storage for building
    ImVector<ImFontBuildSrcData> src_tmp_array;
    ImVector<ImFontBuildDstData> dst_tmp_array;
    src_tmp_array.resize(atlas->ConfigData.Size);
    dst_tmp_array.resize(atlas->Fonts.Size);
    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

    // 1. Initialize font loading structure, check font data validity
    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
        src_tmp.DstIndex = -1;
        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
            if (cfg.DstFont == atlas->Fonts[output_i])
                src_tmp.DstIndex = output_i;
        IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
        if (src_tmp.DstIndex == -1)
            return false;

        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
            return false;

        // Measure highest codepoints
        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
        dst_tmp.SrcCount++;
        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
    }

    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
    int total_glyphs_count = 0;
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
        src_tmp.GlyphsSet.Resize(src_tmp.GlyphsHighest + 1);
        if (dst_tmp.GlyphsSet.Storage.empty())
            dst_tmp.GlyphsSet.Resize(dst_tmp.GlyphsHighest + 1);

        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
            for (int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
            {
                if (dst_tmp.GlyphsSet.GetBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
                    continue;
                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
                    continue;

                // Add to avail set/counters
                src_tmp.GlyphsCount++;
                dst_tmp.GlyphsCount++;
                src_tmp.GlyphsSet.SetBit(codepoint, true);
                dst_tmp.GlyphsSet.SetBit(codepoint, true);
                total_glyphs_count++;
            }
    }

    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
        UnpackBoolVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
        src_tmp.GlyphsSet.Clear();
        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
    }
    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
        dst_tmp_array[dst_i].GlyphsSet.Clear();
    dst_tmp_array.clear();

    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
    ImVector<stbrp_rect> buf_rects;
    ImVector<stbtt_packedchar> buf_packedchars;
    buf_rects.resize(total_glyphs_count);
    buf_packedchars.resize(total_glyphs_count);
    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
    int total_surface = 0;
    int buf_rects_out_n = 0;
    int buf_packedchars_out_n = 0;
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        src_tmp.Rects = &buf_rects[buf_rects_out_n];
        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
        buf_rects_out_n += src_tmp.GlyphsCount;
        buf_packedchars_out_n += src_tmp.GlyphsCount;

        // Convert our ranges in the format stb_truetype wants
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        src_tmp.PackRange.font_size = cfg.SizePixels;
        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;

        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
        const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);
        const int padding = atlas->TexGlyphPadding;
        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
        {
            int x0, y0, x1, y1;
            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
            IM_ASSERT(glyph_index_in_font != 0);
            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
        }
    }

    // We need a width for the skyline algorithm, any width!
    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
    atlas->TexHeight = 0;
    if (atlas->TexDesiredWidth > 0)
        atlas->TexWidth = atlas->TexDesiredWidth;
    else
        atlas->TexWidth = (surface_sqrt >= 4096*0.7f) ? 4096 : (surface_sqrt >= 2048*0.7f) ? 2048 : (surface_sqrt >= 1024*0.7f) ? 1024 : 512;

    // 5. Start packing
    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
    const int TEX_HEIGHT_MAX = 1024 * 32;
    stbtt_pack_context spc = {};
    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

        // Extend texture height and mark missing glyphs as non-packed so we won't render them.
        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
            if (src_tmp.Rects[glyph_i].was_packed)
                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
    }

    // 7. Allocate texture
    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
    atlas->TexPixelsAlpha8 = (unsigned char*)ImGui::MemAlloc(atlas->TexWidth * atlas->TexHeight);
    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
    spc.pixels = atlas->TexPixelsAlpha8;
    spc.height = atlas->TexHeight;

    // 8. Render/rasterize font characters into the texture
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);

        // Apply multiply operator
        if (cfg.RasterizerMultiply != 1.0f)
        {
            unsigned char multiply_table[256];
            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
            stbrp_rect* r = &src_tmp.Rects[0];
            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
                if (r->was_packed)
                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
        }
        src_tmp.Rects = NULL;
    }

    // End packing
    stbtt_PackEnd(&spc);
    buf_rects.clear();

    // 9. Setup ImFont and glyphs for runtime
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        ImFontConfig& cfg = atlas->ConfigData[src_i];
        ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)

        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

        const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));
        const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));
        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
        const float font_off_x = cfg.GlyphOffset.x;
        const float font_off_y = cfg.GlyphOffset.y + (float)(int)(dst_font->Ascent + 0.5f);

        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
        {
            const int codepoint = src_tmp.GlyphsList[glyph_i];
            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];

            const float char_advance_x_org = pc.xadvance;
            const float char_advance_x_mod = ImClamp(char_advance_x_org, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX);
            float char_off_x = font_off_x;
            if (char_advance_x_org != char_advance_x_mod)
                char_off_x += cfg.PixelSnapH ? (float)(int)((char_advance_x_mod - char_advance_x_org) * 0.5f) : (char_advance_x_mod - char_advance_x_org) * 0.5f;

            // Register glyph
            stbtt_aligned_quad q;
            float dummy_x = 0.0f, dummy_y = 0.0f;
            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &dummy_x, &dummy_y, &q, 0);
            dst_font->AddGlyph((ImWchar)codepoint, q.x0 + char_off_x, q.y0 + font_off_y, q.x1 + char_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, char_advance_x_mod);
        }
    }

    // Cleanup temporary (ImVector doesn't honor destructor)
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        src_tmp_array[src_i].~ImFontBuildSrcData();

    ImFontAtlasBuildFinish(atlas);
    return true;
}

void ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas)
{
    if (atlas->CustomRectIds[0] >= 0)
        return;
    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF*2+1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
    else
        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, 2, 2);
}

void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)
{
    if (!font_config->MergeMode)
    {
        font->ClearOutputData();
        font->FontSize = font_config->SizePixels;
        font->ConfigData = font_config;
        font->ContainerAtlas = atlas;
        font->Ascent = ascent;
        font->Descent = descent;
    }
    font->ConfigDataCount++;
}

void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)
{
    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
    IM_ASSERT(pack_context != NULL);

    ImVector<ImFontAtlas::CustomRect>& user_rects = atlas->CustomRects;
    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.

    ImVector<stbrp_rect> pack_rects;
    pack_rects.resize(user_rects.Size);
    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
    for (int i = 0; i < user_rects.Size; i++)
    {
        pack_rects[i].w = user_rects[i].Width;
        pack_rects[i].h = user_rects[i].Height;
    }
    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
    for (int i = 0; i < pack_rects.Size; i++)
        if (pack_rects[i].was_packed)
        {
            user_rects[i].X = pack_rects[i].x;
            user_rects[i].Y = pack_rects[i].y;
            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
        }
}

static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)
{
    IM_ASSERT(atlas->CustomRectIds[0] >= 0);
    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);
    ImFontAtlas::CustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];
    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
    IM_ASSERT(r.IsPacked());

    const int w = atlas->TexWidth;
    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
    {
        // Render/copy pixels
        IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
        for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)
            for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)
            {
                const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * w;
                const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
                atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;
                atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;
            }
    }
    else
    {
        IM_ASSERT(r.Width == 2 && r.Height == 2);
        const int offset = (int)(r.X) + (int)(r.Y) * w;
        atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
    }
    atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * atlas->TexUvScale.x, (r.Y + 0.5f) * atlas->TexUvScale.y);
}

void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
{
    // Render into our custom data block
    ImFontAtlasBuildRenderDefaultTexData(atlas);

    // Register custom rectangle glyphs
    for (int i = 0; i < atlas->CustomRects.Size; i++)
    {
        const ImFontAtlas::CustomRect& r = atlas->CustomRects[i];
        if (r.Font == NULL || r.ID > 0x10000)
            continue;

        IM_ASSERT(r.Font->ContainerAtlas == atlas);
        ImVec2 uv0, uv1;
        atlas->CalcCustomRectUV(&r, &uv0, &uv1);
        r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);
    }

    // Build all fonts lookup tables
    for (int i = 0; i < atlas->Fonts.Size; i++)
        if (atlas->Fonts[i]->DirtyLookupTables)
            atlas->Fonts[i]->BuildLookupTable();
}

// Retrieve list of range (2 int per range, values are inclusive)
const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3131, 0x3163, // Korean alphabets
        0xAC00, 0xD79D, // Korean characters
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x2000, 0x206F, // General Punctuation
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
        0x4e00, 0x9FAF, // CJK Ideograms
        0,
    };
    return &ranges[0];
}

static void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)
{
    for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)
    {
        out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);
        base_codepoint += accumulative_offsets[n];
    }
    out_ranges[0] = 0;
}

//-------------------------------------------------------------------------
// [SECTION] ImFontAtlas glyph ranges helpers
//-------------------------------------------------------------------------

const ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()
{
    // Store 2500 regularly used characters for Simplified Chinese.
    // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
    // This table covers 97.97% of all characters used during the month in July, 1987.
    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
    static const short accumulative_offsets_from_0x4E00[] =
    {
        0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,
        1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,
        2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,
        1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,
        3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,
        1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,
        1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,
        2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,
        27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,
        3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,
        1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,
        176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,
        5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,
        1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,
        6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,
        2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,
        2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,
        2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,
        3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,
        3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,
        3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,
        1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,
        140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,
        5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,
        2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,
        4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,
        2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,
        4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,
        3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,
        3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,
        2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,
        5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,
        3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,
        1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,
        4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,
        4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,
        26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,
        3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,
        2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,
        10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6
    };
    static ImWchar base_ranges[] = // not zero-terminated
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x2000, 0x206F, // General Punctuation
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF  // Half-width characters
    };
    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
    if (!full_ranges[0])
    {
        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    }
    return &full_ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()
{
    // 1946 common ideograms code points for Japanese
    // Sourced from http://theinstructionlimit.com/common-kanji-character-ranges-for-xna-spritefont-rendering
    // FIXME: Source a list of the revised 2136 Joyo Kanji list from 2010 and rebuild this.
    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
    static const short accumulative_offsets_from_0x4E00[] =
    {
        0,1,2,4,1,1,1,1,2,1,6,2,2,1,8,5,7,11,1,2,10,10,8,2,4,20,2,11,8,2,1,2,1,6,2,1,7,5,3,7,1,1,13,7,9,1,4,6,1,2,1,10,1,1,9,2,2,4,5,6,14,1,1,9,3,18,
        5,4,2,2,10,7,1,1,1,3,2,4,3,23,2,10,12,2,14,2,4,13,1,6,10,3,1,7,13,6,4,13,5,2,3,17,2,2,5,7,6,4,1,7,14,16,6,13,9,15,1,1,7,16,4,7,1,19,9,2,7,15,
        2,6,5,13,25,4,14,13,11,25,1,1,1,2,1,2,2,3,10,11,3,3,1,1,4,4,2,1,4,9,1,4,3,5,5,2,7,12,11,15,7,16,4,5,16,2,1,1,6,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,
        2,1,12,3,3,9,5,8,1,11,1,2,3,18,20,4,1,3,6,1,7,3,5,5,7,2,2,12,3,1,4,2,3,2,3,11,8,7,4,17,1,9,25,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,6,16,1,2,1,1,3,12,
        20,2,5,20,8,7,6,2,1,1,1,1,6,2,1,2,10,1,1,6,1,3,1,2,1,4,1,12,4,1,3,1,1,1,1,1,10,4,7,5,13,1,15,1,1,30,11,9,1,15,38,14,1,32,17,20,1,9,31,2,21,9,
        4,49,22,2,1,13,1,11,45,35,43,55,12,19,83,1,3,2,3,13,2,1,7,3,18,3,13,8,1,8,18,5,3,7,25,24,9,24,40,3,17,24,2,1,6,2,3,16,15,6,7,3,12,1,9,7,3,3,
        3,15,21,5,16,4,5,12,11,11,3,6,3,2,31,3,2,1,1,23,6,6,1,4,2,6,5,2,1,1,3,3,22,2,6,2,3,17,3,2,4,5,1,9,5,1,1,6,15,12,3,17,2,14,2,8,1,23,16,4,2,23,
        8,15,23,20,12,25,19,47,11,21,65,46,4,3,1,5,6,1,2,5,26,2,1,1,3,11,1,1,1,2,1,2,3,1,1,10,2,3,1,1,1,3,6,3,2,2,6,6,9,2,2,2,6,2,5,10,2,4,1,2,1,2,2,
        3,1,1,3,1,2,9,23,9,2,1,1,1,1,5,3,2,1,10,9,6,1,10,2,31,25,3,7,5,40,1,15,6,17,7,27,180,1,3,2,2,1,1,1,6,3,10,7,1,3,6,17,8,6,2,2,1,3,5,5,8,16,14,
        15,1,1,4,1,2,1,1,1,3,2,7,5,6,2,5,10,1,4,2,9,1,1,11,6,1,44,1,3,7,9,5,1,3,1,1,10,7,1,10,4,2,7,21,15,7,2,5,1,8,3,4,1,3,1,6,1,4,2,1,4,10,8,1,4,5,
        1,5,10,2,7,1,10,1,1,3,4,11,10,29,4,7,3,5,2,3,33,5,2,19,3,1,4,2,6,31,11,1,3,3,3,1,8,10,9,12,11,12,8,3,14,8,6,11,1,4,41,3,1,2,7,13,1,5,6,2,6,12,
        12,22,5,9,4,8,9,9,34,6,24,1,1,20,9,9,3,4,1,7,2,2,2,6,2,28,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,8,8,3,2,1,5,1,2,2,3,1,11,11,7,3,6,10,8,6,16,16,
        22,7,12,6,21,5,4,6,6,3,6,1,3,2,1,2,8,29,1,10,1,6,13,6,6,19,31,1,13,4,4,22,17,26,33,10,4,15,12,25,6,67,10,2,3,1,6,10,2,6,2,9,1,9,4,4,1,2,16,2,
        5,9,2,3,8,1,8,3,9,4,8,6,4,8,11,3,2,1,1,3,26,1,7,5,1,11,1,5,3,5,2,13,6,39,5,1,5,2,11,6,10,5,1,15,5,3,6,19,21,22,2,4,1,6,1,8,1,4,8,2,4,2,2,9,2,
        1,1,1,4,3,6,3,12,7,1,14,2,4,10,2,13,1,17,7,3,2,1,3,2,13,7,14,12,3,1,29,2,8,9,15,14,9,14,1,3,1,6,5,9,11,3,38,43,20,7,7,8,5,15,12,19,15,81,8,7,
        1,5,73,13,37,28,8,8,1,15,18,20,165,28,1,6,11,8,4,14,7,15,1,3,3,6,4,1,7,14,1,1,11,30,1,5,1,4,14,1,4,2,7,52,2,6,29,3,1,9,1,21,3,5,1,26,3,11,14,
        11,1,17,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,7,7,5,17,3,3,3,1,23,10,4,4,6,3,1,16,17,22,3,10,21,16,16,6,4,10,2,1,1,2,8,8,6,5,3,3,3,39,25,
        15,1,1,16,6,7,25,15,6,6,12,1,22,13,1,4,9,5,12,2,9,1,12,28,8,3,5,10,22,60,1,2,40,4,61,63,4,1,13,12,1,4,31,12,1,14,89,5,16,6,29,14,2,5,49,18,18,
        5,29,33,47,1,17,1,19,12,2,9,7,39,12,3,7,12,39,3,1,46,4,12,3,8,9,5,31,15,18,3,2,2,66,19,13,17,5,3,46,124,13,57,34,2,5,4,5,8,1,1,1,4,3,1,17,5,
        3,5,3,1,8,5,6,3,27,3,26,7,12,7,2,17,3,7,18,78,16,4,36,1,2,1,6,2,1,39,17,7,4,13,4,4,4,1,10,4,2,4,6,3,10,1,19,1,26,2,4,33,2,73,47,7,3,8,2,4,15,
        18,1,29,2,41,14,1,21,16,41,7,39,25,13,44,2,2,10,1,13,7,1,7,3,5,20,4,8,2,49,1,10,6,1,6,7,10,7,11,16,3,12,20,4,10,3,1,2,11,2,28,9,2,4,7,2,15,1,
        27,1,28,17,4,5,10,7,3,24,10,11,6,26,3,2,7,2,2,49,16,10,16,15,4,5,27,61,30,14,38,22,2,7,5,1,3,12,23,24,17,17,3,3,2,4,1,6,2,7,5,1,1,5,1,1,9,4,
        1,3,6,1,8,2,8,4,14,3,5,11,4,1,3,32,1,19,4,1,13,11,5,2,1,8,6,8,1,6,5,13,3,23,11,5,3,16,3,9,10,1,24,3,198,52,4,2,2,5,14,5,4,22,5,20,4,11,6,41,
        1,5,2,2,11,5,2,28,35,8,22,3,18,3,10,7,5,3,4,1,5,3,8,9,3,6,2,16,22,4,5,5,3,3,18,23,2,6,23,5,27,8,1,33,2,12,43,16,5,2,3,6,1,20,4,2,9,7,1,11,2,
        10,3,14,31,9,3,25,18,20,2,5,5,26,14,1,11,17,12,40,19,9,6,31,83,2,7,9,19,78,12,14,21,76,12,113,79,34,4,1,1,61,18,85,10,2,2,13,31,11,50,6,33,159,
        179,6,6,7,4,4,2,4,2,5,8,7,20,32,22,1,3,10,6,7,28,5,10,9,2,77,19,13,2,5,1,4,4,7,4,13,3,9,31,17,3,26,2,6,6,5,4,1,7,11,3,4,2,1,6,2,20,4,1,9,2,6,
        3,7,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,5,13,8,4,11,23,1,10,6,2,1,3,21,2,2,4,24,31,4,10,10,2,5,192,15,4,16,7,9,51,1,2,1,1,5,1,1,2,1,3,5,3,1,3,4,1,
        3,1,3,3,9,8,1,2,2,2,4,4,18,12,92,2,10,4,3,14,5,25,16,42,4,14,4,2,21,5,126,30,31,2,1,5,13,3,22,5,6,6,20,12,1,14,12,87,3,19,1,8,2,9,9,3,3,23,2,
        3,7,6,3,1,2,3,9,1,3,1,6,3,2,1,3,11,3,1,6,10,3,2,3,1,2,1,5,1,1,11,3,6,4,1,7,2,1,2,5,5,34,4,14,18,4,19,7,5,8,2,6,79,1,5,2,14,8,2,9,2,1,36,28,16,
        4,1,1,1,2,12,6,42,39,16,23,7,15,15,3,2,12,7,21,64,6,9,28,8,12,3,3,41,59,24,51,55,57,294,9,9,2,6,2,15,1,2,13,38,90,9,9,9,3,11,7,1,1,1,5,6,3,2,
        1,2,2,3,8,1,4,4,1,5,7,1,4,3,20,4,9,1,1,1,5,5,17,1,5,2,6,2,4,1,4,5,7,3,18,11,11,32,7,5,4,7,11,127,8,4,3,3,1,10,1,1,6,21,14,1,16,1,7,1,3,6,9,65,
        51,4,3,13,3,10,1,1,12,9,21,110,3,19,24,1,1,10,62,4,1,29,42,78,28,20,18,82,6,3,15,6,84,58,253,15,155,264,15,21,9,14,7,58,40,39,
    };
    static ImWchar base_ranges[] = // not zero-terminated
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF  // Half-width characters
    };
    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };
    if (!full_ranges[0])
    {
        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    }
    return &full_ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
        0x2DE0, 0x2DFF, // Cyrillic Extended-A
        0xA640, 0xA69F, // Cyrillic Extended-B
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesThai()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin
        0x2010, 0x205E, // Punctuations
        0x0E00, 0x0E7F, // Thai
        0,
    };
    return &ranges[0];
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontGlyphRangesBuilder
//-----------------------------------------------------------------------------

void ImFontGlyphRangesBuilder::AddText(const char* text, const char* text_end)
{
    while (text_end ? (text < text_end) : *text)
    {
        unsigned int c = 0;
        int c_len = ImTextCharFromUtf8(&c, text, text_end);
        text += c_len;
        if (c_len == 0)
            break;
        if (c < 0x10000)
            AddChar((ImWchar)c);
    }
}

void ImFontGlyphRangesBuilder::AddRanges(const ImWchar* ranges)
{
    for (; ranges[0]; ranges += 2)
        for (ImWchar c = ranges[0]; c <= ranges[1]; c++)
            AddChar(c);
}

void ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)
{
    for (int n = 0; n < 0x10000; n++)
        if (GetBit(n))
        {
            out_ranges->push_back((ImWchar)n);
            while (n < 0x10000 && GetBit(n + 1))
                n++;
            out_ranges->push_back((ImWchar)n);
        }
    out_ranges->push_back(0);
}

//-----------------------------------------------------------------------------
// [SECTION] ImFont
//-----------------------------------------------------------------------------

ImFont::ImFont()
{
    FontSize = 0.0f;
    FallbackAdvanceX = 0.0f;
    FallbackChar = (ImWchar)'?';
    DisplayOffset = ImVec2(0.0f, 0.0f);
    FallbackGlyph = NULL;
    ContainerAtlas = NULL;
    ConfigData = NULL;
    ConfigDataCount = 0;
    DirtyLookupTables = false;
    Scale = 1.0f;
    Ascent = Descent = 0.0f;
    MetricsTotalSurface = 0;
}

ImFont::~ImFont()
{
    ClearOutputData();
}

void    ImFont::ClearOutputData()
{
    FontSize = 0.0f;
    FallbackAdvanceX = 0.0f;
    Glyphs.clear();
    IndexAdvanceX.clear();
    IndexLookup.clear();
    FallbackGlyph = NULL;
    ContainerAtlas = NULL;
    DirtyLookupTables = true;
    Ascent = Descent = 0.0f;
    MetricsTotalSurface = 0;
}

void ImFont::BuildLookupTable()
{
    int max_codepoint = 0;
    for (int i = 0; i != Glyphs.Size; i++)
        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
    IndexAdvanceX.clear();
    IndexLookup.clear();
    DirtyLookupTables = false;
    GrowIndex(max_codepoint + 1);
    for (int i = 0; i < Glyphs.Size; i++)
    {
        int codepoint = (int)Glyphs[i].Codepoint;
        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
        IndexLookup[codepoint] = (ImWchar)i;
    }

    // Create a glyph to handle TAB
    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
    if (FindGlyph((ImWchar)' '))
    {
        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times
            Glyphs.resize(Glyphs.Size + 1);
        ImFontGlyph& tab_glyph = Glyphs.back();
        tab_glyph = *FindGlyph((ImWchar)' ');
        tab_glyph.Codepoint = '\t';
        tab_glyph.AdvanceX *= 4;
        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size-1);
    }

    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
    FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;
    for (int i = 0; i < max_codepoint + 1; i++)
        if (IndexAdvanceX[i] < 0.0f)
            IndexAdvanceX[i] = FallbackAdvanceX;
}

void ImFont::SetFallbackChar(ImWchar c)
{
    FallbackChar = c;
    BuildLookupTable();
}

void ImFont::GrowIndex(int new_size)
{
    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
    if (new_size <= IndexLookup.Size)
        return;
    IndexAdvanceX.resize(new_size, -1.0f);
    IndexLookup.resize(new_size, (ImWchar)-1);
}

// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
void ImFont::AddGlyph(ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
{
    Glyphs.resize(Glyphs.Size + 1);
    ImFontGlyph& glyph = Glyphs.back();
    glyph.Codepoint = (ImWchar)codepoint;
    glyph.X0 = x0;
    glyph.Y0 = y0;
    glyph.X1 = x1;
    glyph.Y1 = y1;
    glyph.U0 = u0;
    glyph.V0 = v0;
    glyph.U1 = u1;
    glyph.V1 = v1;
    glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX

    if (ConfigData->PixelSnapH)
        glyph.AdvanceX = (float)(int)(glyph.AdvanceX + 0.5f);

    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
    DirtyLookupTables = true;
    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);
}

void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)
{
    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
    int index_size = IndexLookup.Size;

    if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists
        return;
    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op
        return;

    GrowIndex(dst + 1);
    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;
    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
}

const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const
{
    if (c >= IndexLookup.Size)
        return FallbackGlyph;
    const ImWchar i = IndexLookup.Data[c];
    if (i == (ImWchar)-1)
        return FallbackGlyph;
    return &Glyphs.Data[i];
}

const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const
{
    if (c >= IndexLookup.Size)
        return NULL;
    const ImWchar i = IndexLookup.Data[c];
    if (i == (ImWchar)-1)
        return NULL;
    return &Glyphs.Data[i];
}

const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const
{
    // Simple word-wrapping for English, not full-featured. Please submit failing cases!
    // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)

    // For references, possible wrap point marked with ^
    //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
    //      ^    ^    ^   ^   ^__    ^    ^

    // List of hardcoded separators: .,;!?'"

    // Skip extra blanks after a line returns (that includes not counting them in width computation)
    // e.g. "Hello    world" --> "Hello" "World"

    // Cut words that cannot possibly fit within one line.
    // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"

    float line_width = 0.0f;
    float word_width = 0.0f;
    float blank_width = 0.0f;
    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

    const char* word_end = text;
    const char* prev_word_end = NULL;
    bool inside_word = true;

    const char* s = text;
    while (s < text_end)
    {
        unsigned int c = (unsigned int)*s;
        const char* next_s;
        if (c < 0x80)
            next_s = s + 1;
        else
            next_s = s + ImTextCharFromUtf8(&c, s, text_end);
        if (c == 0)
            break;

        if (c < 32)
        {
            if (c == '\n')
            {
                line_width = word_width = blank_width = 0.0f;
                inside_word = true;
                s = next_s;
                continue;
            }
            if (c == '\r')
            {
                s = next_s;
                continue;
            }
        }

        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);
        if (ImCharIsBlankW(c))
        {
            if (inside_word)
            {
                line_width += blank_width;
                blank_width = 0.0f;
                word_end = s;
            }
            blank_width += char_width;
            inside_word = false;
        }
        else
        {
            word_width += char_width;
            if (inside_word)
            {
                word_end = next_s;
            }
            else
            {
                prev_word_end = word_end;
                line_width += word_width + blank_width;
                word_width = blank_width = 0.0f;
            }

            // Allow wrapping after punctuation.
            inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"');
        }

        // We ignore blank width at the end of the line (they can be skipped)
        if (line_width + word_width >= wrap_width)
        {
            // Words that cannot possibly fit within an entire line will be cut anywhere.
            if (word_width < wrap_width)
                s = prev_word_end ? prev_word_end : word_end;
            break;
        }

        s = next_s;
    }

    return s;
}

ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
{
    if (!text_end)
        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

    const float line_height = size;
    const float scale = size / FontSize;

    ImVec2 text_size = ImVec2(0,0);
    float line_width = 0.0f;

    const bool word_wrap_enabled = (wrap_width > 0.0f);
    const char* word_wrap_eol = NULL;

    const char* s = text_begin;
    while (s < text_end)
    {
        if (word_wrap_enabled)
        {
            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
            if (!word_wrap_eol)
            {
                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
            }

            if (s >= word_wrap_eol)
            {
                if (text_size.x < line_width)
                    text_size.x = line_width;
                text_size.y += line_height;
                line_width = 0.0f;
                word_wrap_eol = NULL;

                // Wrapping skips upcoming blanks
                while (s < text_end)
                {
                    const char c = *s;
                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }
                }
                continue;
            }
        }

        // Decode and advance source
        const char* prev_s = s;
        unsigned int c = (unsigned int)*s;
        if (c < 0x80)
        {
            s += 1;
        }
        else
        {
            s += ImTextCharFromUtf8(&c, s, text_end);
            if (c == 0) // Malformed UTF-8?
                break;
        }

        if (c < 32)
        {
            if (c == '\n')
            {
                text_size.x = ImMax(text_size.x, line_width);
                text_size.y += line_height;
                line_width = 0.0f;
                continue;
            }
            if (c == '\r')
                continue;
        }

        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
        if (line_width + char_width >= max_width)
        {
            s = prev_s;
            break;
        }

        line_width += char_width;
    }

    if (text_size.x < line_width)
        text_size.x = line_width;

    if (line_width > 0 || text_size.y == 0.0f)
        text_size.y += line_height;

    if (remaining)
        *remaining = s;

    return text_size;
}

void ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const
{
    if (c == ' ' || c == '\t' || c == '\n' || c == '\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.
        return;
    if (const ImFontGlyph* glyph = FindGlyph(c))
    {
        float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;
        pos.x = (float)(int)pos.x + DisplayOffset.x;
        pos.y = (float)(int)pos.y + DisplayOffset.y;
        draw_list->PrimReserve(6, 4);
        draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
    }
}

void ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
{
    if (!text_end)
        text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.

    // Align to be pixel perfect
    pos.x = (float)(int)pos.x + DisplayOffset.x;
    pos.y = (float)(int)pos.y + DisplayOffset.y;
    float x = pos.x;
    float y = pos.y;
    if (y > clip_rect.w)
        return;

    const float scale = size / FontSize;
    const float line_height = FontSize * scale;
    const bool word_wrap_enabled = (wrap_width > 0.0f);
    const char* word_wrap_eol = NULL;

    // Fast-forward to first visible line
    const char* s = text_begin;
    if (y + line_height < clip_rect.y && !word_wrap_enabled)
        while (y + line_height < clip_rect.y && s < text_end)
        {
            s = (const char*)memchr(s, '\n', text_end - s);
            s = s ? s + 1 : text_end;
            y += line_height;
        }

    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
    if (text_end - s > 10000 && !word_wrap_enabled)
    {
        const char* s_end = s;
        float y_end = y;
        while (y_end < clip_rect.w && s_end < text_end)
        {
            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
            s_end = s_end ? s_end + 1 : text_end;
            y_end += line_height;
        }
        text_end = s_end;
    }
    if (s == text_end)
        return;

    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
    const int vtx_count_max = (int)(text_end - s) * 4;
    const int idx_count_max = (int)(text_end - s) * 6;
    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
    draw_list->PrimReserve(idx_count_max, vtx_count_max);

    ImDrawVert* vtx_write = draw_list->_VtxWritePtr;
    ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
    unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;

    while (s < text_end)
    {
        if (word_wrap_enabled)
        {
            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
            if (!word_wrap_eol)
            {
                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));
                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
            }

            if (s >= word_wrap_eol)
            {
                x = pos.x;
                y += line_height;
                word_wrap_eol = NULL;

                // Wrapping skips upcoming blanks
                while (s < text_end)
                {
                    const char c = *s;
                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }
                }
                continue;
            }
        }

        // Decode and advance source
        unsigned int c = (unsigned int)*s;
        if (c < 0x80)
        {
            s += 1;
        }
        else
        {
            s += ImTextCharFromUtf8(&c, s, text_end);
            if (c == 0) // Malformed UTF-8?
                break;
        }

        if (c < 32)
        {
            if (c == '\n')
            {
                x = pos.x;
                y += line_height;
                if (y > clip_rect.w)
                    break; // break out of main loop
                continue;
            }
            if (c == '\r')
                continue;
        }

        float char_width = 0.0f;
        if (const ImFontGlyph* glyph = FindGlyph((ImWchar)c))
        {
            char_width = glyph->AdvanceX * scale;

            // Arbitrarily assume that both space and tabs are empty glyphs as an optimization
            if (c != ' ' && c != '\t')
            {
                // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
                float x1 = x + glyph->X0 * scale;
                float x2 = x + glyph->X1 * scale;
                float y1 = y + glyph->Y0 * scale;
                float y2 = y + glyph->Y1 * scale;
                if (x1 <= clip_rect.z && x2 >= clip_rect.x)
                {
                    // Render a character
                    float u1 = glyph->U0;
                    float v1 = glyph->V0;
                    float u2 = glyph->U1;
                    float v2 = glyph->V1;

                    // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
                    if (cpu_fine_clip)
                    {
                        if (x1 < clip_rect.x)
                        {
                            u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
                            x1 = clip_rect.x;
                        }
                        if (y1 < clip_rect.y)
                        {
                            v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
                            y1 = clip_rect.y;
                        }
                        if (x2 > clip_rect.z)
                        {
                            u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
                            x2 = clip_rect.z;
                        }
                        if (y2 > clip_rect.w)
                        {
                            v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
                            y2 = clip_rect.w;
                        }
                        if (y1 >= y2)
                        {
                            x += char_width;
                            continue;
                        }
                    }

                    // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
                    {
                        idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);
                        idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);
                        vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
                        vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
                        vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
                        vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
                        vtx_write += 4;
                        vtx_current_idx += 4;
                        idx_write += 6;
                    }
                }
            }
        }

        x += char_width;
    }

    // Give back unused vertices
    draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));
    draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));
    draw_list->CmdBuffer[draw_list->CmdBuffer.Size-1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
    draw_list->_VtxWritePtr = vtx_write;
    draw_list->_IdxWritePtr = idx_write;
    draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;
}

//-----------------------------------------------------------------------------
// [SECTION] Internal Render Helpers
// (progressively moved from imgui.cpp to here when they are redesigned to stop accessing ImGui global state)
//-----------------------------------------------------------------------------
// - RenderMouseCursor()
// - RenderArrowPointingAt()
// - RenderRectFilledRangeH()
// - RenderPixelEllipsis()
//-----------------------------------------------------------------------------

void ImGui::RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor)
{
    if (mouse_cursor == ImGuiMouseCursor_None)
        return;
    IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);

    const ImU32 col_shadow = IM_COL32(0, 0, 0, 48);
    const ImU32 col_border = IM_COL32(0, 0, 0, 255);          // Black
    const ImU32 col_fill   = IM_COL32(255, 255, 255, 255);    // White

    ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;
    ImVec2 offset, size, uv[4];
    if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))
    {
        pos -= offset;
        const ImTextureID tex_id = font_atlas->TexID;
        draw_list->PushTextureID(tex_id);
        draw_list->AddImage(tex_id, pos + ImVec2(1,0)*scale, pos + ImVec2(1,0)*scale + size*scale, uv[2], uv[3], col_shadow);
        draw_list->AddImage(tex_id, pos + ImVec2(2,0)*scale, pos + ImVec2(2,0)*scale + size*scale, uv[2], uv[3], col_shadow);
        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[2], uv[3], col_border);
        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[0], uv[1], col_fill);
        draw_list->PopTextureID();
    }
}

// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
void ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)
{
    switch (direction)
    {
    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;
    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;
    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;
    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;
    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
    }
}

static inline float ImAcos01(float x)
{
    if (x <= 0.0f) return IM_PI * 0.5f;
    if (x >= 1.0f) return 0.0f;
    return ImAcos(x);
    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
}

// FIXME: Cleanup and move code to ImDrawList.
void ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)
{
    if (x_end_norm == x_start_norm)
        return;
    if (x_start_norm > x_end_norm)
        ImSwap(x_start_norm, x_end_norm);

    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
    if (rounding == 0.0f)
    {
        draw_list->AddRectFilled(p0, p1, col, 0.0f);
        return;
    }

    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);
    const float inv_rounding = 1.0f / rounding;
    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);
    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);
    const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.
    const float x0 = ImMax(p0.x, rect.Min.x + rounding);
    if (arc0_b == arc0_e)
    {
        draw_list->PathLineTo(ImVec2(x0, p1.y));
        draw_list->PathLineTo(ImVec2(x0, p0.y));
    }
    else if (arc0_b == 0.0f && arc0_e == half_pi)
    {
        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL
        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR
    }
    else
    {
        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL
        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR
    }
    if (p1.x > rect.Min.x + rounding)
    {
        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);
        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);
        const float x1 = ImMin(p1.x, rect.Max.x - rounding);
        if (arc1_b == arc1_e)
        {
            draw_list->PathLineTo(ImVec2(x1, p0.y));
            draw_list->PathLineTo(ImVec2(x1, p1.y));
        }
        else if (arc1_b == 0.0f && arc1_e == half_pi)
        {
            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR
            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR
        }
        else
        {
            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR
            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR
        }
    }
    draw_list->PathFillConvex(col);
}

// FIXME: Rendering an ellipsis "..." is a surprisingly tricky problem for us... we cannot rely on font glyph having it,
// and regular dot are typically too wide. If we render a dot/shape ourselves it comes with the risk that it wouldn't match
// the boldness or positioning of what the font uses...
void ImGui::RenderPixelEllipsis(ImDrawList* draw_list, ImVec2 pos, int count, ImU32 col)
{
    ImFont* font = draw_list->_Data->Font;
    const float font_scale = draw_list->_Data->FontSize / font->FontSize;
    pos.y += (float)(int)(font->DisplayOffset.y + font->Ascent * font_scale + 0.5f - 1.0f);
    for (int dot_n = 0; dot_n < count; dot_n++)
        draw_list->AddRectFilled(ImVec2(pos.x + dot_n * 2.0f, pos.y), ImVec2(pos.x + dot_n * 2.0f + 1.0f, pos.y + 1.0f), col);
}

//-----------------------------------------------------------------------------
// [SECTION] Decompression code
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array and encoded as base85.
// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

static unsigned int stb_decompress_length(const unsigned char *input)
{
    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
}

static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
static const unsigned char *stb__barrier_in_b;
static unsigned char *stb__dout;
static void stb__match(const unsigned char *data, unsigned int length)
{
    // INVERSE of memmove... write each byte before copying the next...
    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
    while (length--) *stb__dout++ = *data++;
}

static void stb__lit(const unsigned char *data, unsigned int length)
{
    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
    memcpy(stb__dout, data, length);
    stb__dout += length;
}

#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))

static const unsigned char *stb_decompress_token(const unsigned char *i)
{
    if (*i >= 0x20) { // use fewer if's for cases that expand small
        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
    } else { // more ifs for cases that expand large, since overhead is amortized
        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
    }
    return i;
}

static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
{
    const unsigned long ADLER_MOD = 65521;
    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
    unsigned long blocklen, i;

    blocklen = buflen % 5552;
    while (buflen) {
        for (i=0; i + 7 < blocklen; i += 8) {
            s1 += buffer[0], s2 += s1;
            s1 += buffer[1], s2 += s1;
            s1 += buffer[2], s2 += s1;
            s1 += buffer[3], s2 += s1;
            s1 += buffer[4], s2 += s1;
            s1 += buffer[5], s2 += s1;
            s1 += buffer[6], s2 += s1;
            s1 += buffer[7], s2 += s1;

            buffer += 8;
        }

        for (; i < blocklen; ++i)
            s1 += *buffer++, s2 += s1;

        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
        buflen -= blocklen;
        blocklen = 5552;
    }
    return (unsigned int)(s2 << 16) + (unsigned int)s1;
}

static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)
{
    unsigned int olen;
    if (stb__in4(0) != 0x57bC0000) return 0;
    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
    olen = stb_decompress_length(i);
    stb__barrier_in_b = i;
    stb__barrier_out_e = output + olen;
    stb__barrier_out_b = output;
    i += 16;

    stb__dout = output;
    for (;;) {
        const unsigned char *old_i = i;
        i = stb_decompress_token(i);
        if (i == old_i) {
            if (*i == 0x05 && i[1] == 0xfa) {
                IM_ASSERT(stb__dout == output + olen);
                if (stb__dout != output + olen) return 0;
                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
                    return 0;
                return olen;
            } else {
                IM_ASSERT(0); /* NOTREACHED */
                return 0;
            }
        }
        IM_ASSERT(stb__dout <= output + olen);
        if (stb__dout > output + olen)
            return 0;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Default font data (ProggyClean.ttf)
//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)
// Download and more information at http://upperbounds.net
//-----------------------------------------------------------------------------
// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression + base85 string encoding).
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
//-----------------------------------------------------------------------------
static const char proggy_clean_ttf_compressed_data_base85[11980+1] =
    "7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
    "2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
    "`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
    "i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
    "kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
    "*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
    "tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
    "ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
    "x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
    "CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
    "U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
    "'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
    "_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
    "Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
    "/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
    "%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
    "OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
    "h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
    "o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
    "j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
    "sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
    "eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
    "M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
    "LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
    "%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
    "Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
    "a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
    "$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
    "nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
    "7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
    ")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
    "D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
    "P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
    "bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
    "h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
    "V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
    "sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
    ".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
    "$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
    "hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
    "@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
    "w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
    "u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
    "d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
    "6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
    "b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
    ":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
    "tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
    "$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
    ":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
    "7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
    "u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
    "LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
    ":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
    "_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
    "hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
    "^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
    "+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
    "9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
    "CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
    "hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
    "8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
    "S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
    "0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
    "+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
    "M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
    "?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
    "Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
    ">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
    "[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
    "wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
    "Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
    "MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
    "i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
    "1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
    "iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
    "URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
    ";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
    "w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
    "d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
    "A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
    "/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
    "m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
    "TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
    "GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
    "O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";

static const char* GetDefaultCompressedFontDataTTFBase85()
{
    return proggy_clean_ttf_compressed_data_base85;
}

```

`CSGOSimple/imgui/imgui_internal.h`:

```h
// dear imgui, v1.69 WIP
// (internal structures/api)

// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!
// Set:
//   #define IMGUI_DEFINE_MATH_OPERATORS
// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)

/*

Index of this file:
// Header mess
// Forward declarations
// STB libraries includes
// Context pointer
// Generic helpers
// Misc data structures
// Main imgui context
// Tab bar, tab item
// Internal API

*/

#pragma once

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

#ifndef IMGUI_VERSION
#error Must include imgui.h before imgui_internal.h
#endif

#include <stdio.h>      // FILE*
#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof
#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <limits.h>     // INT_MIN, INT_MAX

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"                // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes"             // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"
#endif
#endif

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------

struct ImRect;                      // An axis-aligned rectangle (2 points)
struct ImDrawDataBuilder;           // Helper to build a ImDrawData instance
struct ImDrawListSharedData;        // Data shared between all ImDrawList instances
struct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColumnData;             // Storage data for a single column
struct ImGuiColumnsSet;             // Storage data for a columns set
struct ImGuiContext;                // Main imgui context
struct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box
struct ImGuiItemHoveredDataBackup;  // Backup and restore IsItemHovered() internal data
struct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only
struct ImGuiNavMoveResult;          // Result of a directional navigation move query result
struct ImGuiNextWindowData;         // Storage for SetNexWindow** functions
struct ImGuiPopupRef;               // Storage for current popup stack
struct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file
struct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it
struct ImGuiTabBar;                 // Storage for a tab bar
struct ImGuiTabItem;                // Storage for a tab item (within a tab bar)
struct ImGuiWindow;                 // Storage for one window
struct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame)
struct ImGuiWindowSettings;         // Storage for window settings stored in .ini file (we keep one of those even if the actual window wasn't instanced during this session)

// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
typedef int ImGuiLayoutType;        // -> enum ImGuiLayoutType_        // Enum: Horizontal or vertical
typedef int ImGuiButtonFlags;       // -> enum ImGuiButtonFlags_       // Flags: for ButtonEx(), ButtonBehavior()
typedef int ImGuiItemFlags;         // -> enum ImGuiItemFlags_         // Flags: for PushItemFlag()
typedef int ImGuiItemStatusFlags;   // -> enum ImGuiItemStatusFlags_   // Flags: for DC.LastItemStatusFlags
typedef int ImGuiNavHighlightFlags; // -> enum ImGuiNavHighlightFlags_ // Flags: for RenderNavHighlight()
typedef int ImGuiNavDirSourceFlags; // -> enum ImGuiNavDirSourceFlags_ // Flags: for GetNavInputAmount2d()
typedef int ImGuiNavMoveFlags;      // -> enum ImGuiNavMoveFlags_      // Flags: for navigation requests
typedef int ImGuiSeparatorFlags;    // -> enum ImGuiSeparatorFlags_    // Flags: for Separator() - internal
typedef int ImGuiSliderFlags;       // -> enum ImGuiSliderFlags_       // Flags: for SliderBehavior()
typedef int ImGuiDragFlags;         // -> enum ImGuiDragFlags_         // Flags: for DragBehavior()

//-------------------------------------------------------------------------
// STB libraries includes
//-------------------------------------------------------------------------

namespace ImStb
{

#undef STB_TEXTEDIT_STRING
#undef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_STRING             ImGuiInputTextState
#define STB_TEXTEDIT_CHARTYPE           ImWchar
#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f
#include "imstb_textedit.h"

} // namespace ImStb

//-----------------------------------------------------------------------------
// Context pointer
//-----------------------------------------------------------------------------

#ifndef GImGui
extern IMGUI_API ImGuiContext* GImGui;  // Current implicit ImGui context pointer
#endif

//-----------------------------------------------------------------------------
// Generic helpers
//-----------------------------------------------------------------------------

#define IM_PI           3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE      "\r\n"   // Play it nice with Windows users (2018/05 news: Microsoft announced that Notepad will finally display Unix-style carriage returns!)
#else
#define IM_NEWLINE      "\n"
#endif

#define IMGUI_DEBUG_LOG(_FMT,...)       printf("[%05d] " _FMT, GImGui->FrameCount, __VA_ARGS__)
#define IM_STATIC_ASSERT(_COND)         typedef char static_assertion_##__line__[(_COND)?1:-1]
#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif

// Helpers: UTF-8 <> wchar
IMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      // return output UTF-8 bytes count
IMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          // read one character. return input UTF-8 bytes count
IMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count
IMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            // return number of UTF-8 code-points (NOT bytes count)
IMGUI_API int           ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                        // return number of bytes to express one char in UTF-8
IMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   // return number of bytes to express string in UTF-8

// Helpers: Misc
IMGUI_API ImU32         ImHashData(const void* data, size_t data_size, ImU32 seed = 0);
IMGUI_API ImU32         ImHashStr(const char* data, size_t data_size, ImU32 seed = 0);
IMGUI_API void*         ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size = NULL, int padding_bytes = 0);
IMGUI_API FILE*         ImFileOpen(const char* filename, const char* file_open_mode);
static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }
static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }
static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }
#define ImQsort         qsort
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
static inline ImU32     ImHash(const void* data, int size, ImU32 seed = 0) { return size ? ImHashData(data, (size_t)size, seed) : ImHashStr((const char*)data, 0, seed); } // [moved to ImHashStr/ImHashData in 1.68]
#endif

// Helpers: Geometry
IMGUI_API ImVec2        ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);
IMGUI_API bool          ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API ImVec2        ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API void          ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);
IMGUI_API ImGuiDir      ImGetDirQuadrantFromDelta(float dx, float dy);

// Helpers: String
IMGUI_API int           ImStricmp(const char* str1, const char* str2);
IMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);
IMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);
IMGUI_API char*         ImStrdup(const char* str);
IMGUI_API char*         ImStrdupcpy(char* dst, size_t* p_dst_size, const char* str);
IMGUI_API const char*   ImStrchrRange(const char* str_begin, const char* str_end, char c);
IMGUI_API int           ImStrlenW(const ImWchar* str);
IMGUI_API const char*   ImStreolRange(const char* str, const char* str_end);                // End end-of-line
IMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);   // Find beginning-of-line
IMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);
IMGUI_API void          ImStrTrimBlanks(char* str);
IMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);
IMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);
IMGUI_API const char*   ImParseFormatFindStart(const char* format);
IMGUI_API const char*   ImParseFormatFindEnd(const char* format);
IMGUI_API const char*   ImParseFormatTrimDecorations(const char* format, char* buf, size_t buf_size);
IMGUI_API int           ImParseFormatPrecision(const char* format, int default_value);

// Helpers: ImVec2/ImVec4 operators
// We are keeping those disabled by default so they don't leak in user space, to allow user enabling implicit cast operators between ImVec2 and their own types (using IM_VEC2_CLASS_EXTRA etc.)
// We unfortunately don't have a unary- operator for ImVec2 because this would needs to be defined inside the class itself.
#ifdef IMGUI_DEFINE_MATH_OPERATORS
static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }
static inline ImVec2 operator/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x/rhs, lhs.y/rhs); }
static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }
static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }
static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }
static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }
static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }
static inline ImVec2& operator/=(ImVec2& lhs, const float rhs)                  { lhs.x /= rhs; lhs.y /= rhs; return lhs; }
static inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x+rhs.x, lhs.y+rhs.y, lhs.z+rhs.z, lhs.w+rhs.w); }
static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }
static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z, lhs.w*rhs.w); }
#endif

// Helpers: Maths
// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
#ifndef IMGUI_DISABLE_MATH_FUNCTIONS
static inline float  ImFabs(float x)                                            { return fabsf(x); }
static inline float  ImSqrt(float x)                                            { return sqrtf(x); }
static inline float  ImPow(float x, float y)                                    { return powf(x, y); }
static inline double ImPow(double x, double y)                                  { return pow(x, y); }
static inline float  ImFmod(float x, float y)                                   { return fmodf(x, y); }
static inline double ImFmod(double x, double y)                                 { return fmod(x, y); }
static inline float  ImCos(float x)                                             { return cosf(x); }
static inline float  ImSin(float x)                                             { return sinf(x); }
static inline float  ImAcos(float x)                                            { return acosf(x); }
static inline float  ImAtan2(float y, float x)                                  { return atan2f(y, x); }
static inline double ImAtof(const char* s)                                      { return atof(s); }
static inline float  ImFloorStd(float x)                                        { return floorf(x); }   // we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)
static inline float  ImCeil(float x)                                            { return ceilf(x); }
#endif
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support for variety of types: signed/unsigned int/long long float/double, using templates here but we could also redefine them 6 times
template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }
template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
// - Misc maths helpers
static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }
static inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }
static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / ImSqrt(d); return fail_value; }
static inline float  ImFloor(float f)                                           { return (float)(int)f; }
static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)v.x, (float)(int)v.y); }
static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }
static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }
static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }
static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

// Helper: ImBoolVector. Store 1-bit per value.
// Note that Resize() currently clears the whole vector.
struct ImBoolVector
{
    ImVector<int>   Storage;
    ImBoolVector()  { }
    void            Resize(int sz)          { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
    void            Clear()                 { Storage.clear(); }
    bool            GetBit(int n) const     { int off = (n >> 5); int mask = 1 << (n & 31); return (Storage[off] & mask) != 0; }
    void            SetBit(int n, bool v)   { int off = (n >> 5); int mask = 1 << (n & 31); if (v) Storage[off] |= mask; else Storage[off] &= ~mask; }
};

// Helper: ImPool<>. Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
typedef int ImPoolIdx;
template<typename T>
struct IMGUI_API ImPool
{
    ImVector<T>     Data;       // Contiguous data
    ImGuiStorage    Map;        // ID->Index
    ImPoolIdx       FreeIdx;    // Next free idx to use

    ImPool()    { FreeIdx = 0; }
    ~ImPool()   { Clear(); }
    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Data[idx] : NULL; }
    T*          GetByIndex(ImPoolIdx n)             { return &Data[n]; }
    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Data.Data && p < Data.Data + Data.Size); return (ImPoolIdx)(p - Data.Data); }
    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Data[*p_idx]; *p_idx = FreeIdx; return Add(); }
    bool        Contains(const T* p) const          { return (p >= Data.Data && p < Data.Data + Data.Size); }
    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Data[idx].~T(); } Map.Clear(); Data.clear(); FreeIdx = 0; }
    T*          Add()                               { int idx = FreeIdx; if (idx == Data.Size) { Data.resize(Data.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Data[idx]; } IM_PLACEMENT_NEW(&Data[idx]) T(); return &Data[idx]; }
    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }
    void        Remove(ImGuiID key, ImPoolIdx idx)  { Data[idx].~T(); *(int*)&Data[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); }
    void        Reserve(int capacity)               { Data.reserve(capacity); Map.Data.reserve(capacity); }
    int         GetSize() const                     { return Data.Size; }
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

enum ImGuiButtonFlags_
{
    ImGuiButtonFlags_None                   = 0,
    ImGuiButtonFlags_Repeat                 = 1 << 0,   // hold to repeat
    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   // return true on click + release on same item [DEFAULT if no PressedOn* flag is set]
    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   // return true on click (default requires click+release)
    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   // return true on release (default requires click+release)
    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   // return true on double-click (default requires click+release)
    ImGuiButtonFlags_FlattenChildren        = 1 << 5,   // allow interactions even if a child window is overlapping
    ImGuiButtonFlags_AllowItemOverlap       = 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
    ImGuiButtonFlags_DontClosePopups        = 1 << 7,   // disable automatically closing parent popup on press // [UNUSED]
    ImGuiButtonFlags_Disabled               = 1 << 8,   // disable interactions
    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
    ImGuiButtonFlags_NoKeyModifiers         = 1 << 10,  // disable interaction if a key modifier is held
    ImGuiButtonFlags_NoHoldingActiveID      = 1 << 11,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 12,  // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
    ImGuiButtonFlags_NoNavFocus             = 1 << 13   // don't override navigation focus when activated
};

enum ImGuiSliderFlags_
{
    ImGuiSliderFlags_None                   = 0,
    ImGuiSliderFlags_Vertical               = 1 << 0
};

enum ImGuiDragFlags_
{
    ImGuiDragFlags_None                     = 0,
    ImGuiDragFlags_Vertical                 = 1 << 0
};

enum ImGuiColumnsFlags_
{
    // Default: 0
    ImGuiColumnsFlags_None                  = 0,
    ImGuiColumnsFlags_NoBorder              = 1 << 0,   // Disable column dividers
    ImGuiColumnsFlags_NoResize              = 1 << 1,   // Disable resizing columns when clicking on the dividers
    ImGuiColumnsFlags_NoPreserveWidths      = 1 << 2,   // Disable column width preservation when adjusting columns
    ImGuiColumnsFlags_NoForceWithinWindow   = 1 << 3,   // Disable forcing columns to fit within window
    ImGuiColumnsFlags_GrowParentContentsSize= 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
};

enum ImGuiSelectableFlagsPrivate_
{
    // NB: need to be in sync with last value of ImGuiSelectableFlags_
    ImGuiSelectableFlags_NoHoldingActiveID  = 1 << 10,
    ImGuiSelectableFlags_PressedOnClick     = 1 << 11,
    ImGuiSelectableFlags_PressedOnRelease   = 1 << 12,
    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 13
};

enum ImGuiSeparatorFlags_
{
    ImGuiSeparatorFlags_None                = 0,
    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
    ImGuiSeparatorFlags_Vertical            = 1 << 1
};

// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().
// This is going to be exposed in imgui.h when stabilized enough.
enum ImGuiItemFlags_
{
    ImGuiItemFlags_NoTabStop                = 1 << 0,  // false
    ImGuiItemFlags_ButtonRepeat             = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
    ImGuiItemFlags_Disabled                 = 1 << 2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211
    ImGuiItemFlags_NoNav                    = 1 << 3,  // false
    ImGuiItemFlags_NoNavDefaultFocus        = 1 << 4,  // false
    ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window
    ImGuiItemFlags_Default_                 = 0
};

// Storage for LastItem data
enum ImGuiItemStatusFlags_
{
    ImGuiItemStatusFlags_None               = 0,
    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,
    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,
    ImGuiItemStatusFlags_Edited             = 1 << 2    // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)

#ifdef IMGUI_ENABLE_TEST_ENGINE
    , // [imgui-test only]
    ImGuiItemStatusFlags_Openable           = 1 << 10,  //
    ImGuiItemStatusFlags_Opened             = 1 << 11,  //
    ImGuiItemStatusFlags_Checkable          = 1 << 12,  //
    ImGuiItemStatusFlags_Checked            = 1 << 13   //
#endif
};

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiLayoutType_
{
    ImGuiLayoutType_Horizontal = 0,
    ImGuiLayoutType_Vertical = 1
};

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiAxis
{
    ImGuiAxis_None = -1,
    ImGuiAxis_X = 0,
    ImGuiAxis_Y = 1
};

enum ImGuiPlotType
{
    ImGuiPlotType_Lines,
    ImGuiPlotType_Histogram
};

enum ImGuiInputSource
{
    ImGuiInputSource_None = 0,
    ImGuiInputSource_Mouse,
    ImGuiInputSource_Nav,
    ImGuiInputSource_NavKeyboard,   // Only used occasionally for storage, not tested/handled by most code
    ImGuiInputSource_NavGamepad,    // "
    ImGuiInputSource_COUNT
};

// FIXME-NAV: Clarify/expose various repeat delay/rate
enum ImGuiInputReadMode
{
    ImGuiInputReadMode_Down,
    ImGuiInputReadMode_Pressed,
    ImGuiInputReadMode_Released,
    ImGuiInputReadMode_Repeat,
    ImGuiInputReadMode_RepeatSlow,
    ImGuiInputReadMode_RepeatFast
};

enum ImGuiNavHighlightFlags_
{
    ImGuiNavHighlightFlags_None         = 0,
    ImGuiNavHighlightFlags_TypeDefault  = 1 << 0,
    ImGuiNavHighlightFlags_TypeThin     = 1 << 1,
    ImGuiNavHighlightFlags_AlwaysDraw   = 1 << 2,       // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.
    ImGuiNavHighlightFlags_NoRounding   = 1 << 3
};

enum ImGuiNavDirSourceFlags_
{
    ImGuiNavDirSourceFlags_None         = 0,
    ImGuiNavDirSourceFlags_Keyboard     = 1 << 0,
    ImGuiNavDirSourceFlags_PadDPad      = 1 << 1,
    ImGuiNavDirSourceFlags_PadLStick    = 1 << 2
};

enum ImGuiNavMoveFlags_
{
    ImGuiNavMoveFlags_None                  = 0,
    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   // On failed request, restart from opposite side
    ImGuiNavMoveFlags_LoopY                 = 1 << 1,
    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   // This is not super useful for provided for completeness
    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5    // Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.
};

enum ImGuiNavForward
{
    ImGuiNavForward_None,
    ImGuiNavForward_ForwardQueued,
    ImGuiNavForward_ForwardActive
};

enum ImGuiNavLayer
{
    ImGuiNavLayer_Main  = 0,    // Main scrolling layer
    ImGuiNavLayer_Menu  = 1,    // Menu layer (access with Alt/ImGuiNavInput_Menu)
    ImGuiNavLayer_COUNT
};

enum ImGuiPopupPositionPolicy
{
    ImGuiPopupPositionPolicy_Default,
    ImGuiPopupPositionPolicy_ComboBox
};

// 1D vector (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)
struct ImVec1
{
    float   x;
    ImVec1()         { x = 0.0f; }
    ImVec1(float _x) { x = _x; }
};


// 2D axis aligned bounding-box
// NB: we can't rely on ImVec2 math operators being available here
struct IMGUI_API ImRect
{
    ImVec2      Min;    // Upper-left
    ImVec2      Max;    // Lower-right

    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}
    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}
    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}
    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
    float       GetWidth() const                    { return Max.x - Min.x; }
    float       GetHeight() const                   { return Max.y - Min.y; }
    ImVec2      GetTL() const                       { return Min; }                   // Top-left
    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right
    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left
    ImVec2      GetBR() const                       { return Max; }                   // Bottom-right
    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }
    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }
    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }
    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }
    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
    void        Floor()                             { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }
    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
};

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColorMod
{
    ImGuiCol    Col;
    ImVec4      BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod
{
    ImGuiStyleVar   VarIdx;
    union           { int BackupInt[2]; float BackupFloat[2]; };
    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
};

// Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiGroupData
{
    ImVec2      BackupCursorPos;
    ImVec2      BackupCursorMaxPos;
    ImVec1      BackupIndent;
    ImVec1      BackupGroupOffset;
    ImVec2      BackupCurrentLineSize;
    float       BackupCurrentLineTextBaseOffset;
    float       BackupLogLinePosY;
    ImGuiID     BackupActiveIdIsAlive;
    bool        BackupActiveIdPreviousFrameIsAlive;
    bool        AdvanceCursor;
};

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
struct IMGUI_API ImGuiMenuColumns
{
    int         Count;
    float       Spacing;
    float       Width, NextWidth;
    float       Pos[4], NextWidths[4];

    ImGuiMenuColumns();
    void        Update(int count, float spacing, bool clear);
    float       DeclColumns(float w0, float w1, float w2);
    float       CalcExtraSpace(float avail_w);
};

// Internal state of the currently focused/edited text input box
struct IMGUI_API ImGuiInputTextState
{
    ImGuiID                 ID;                     // widget id owning the text state
    int                     CurLenW, CurLenA;       // we need to maintain our buffer length in both UTF-8 and wchar format.
    ImVector<ImWchar>       TextW;                  // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
    ImVector<char>          TextA;                  // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.
    ImVector<char>          InitialTextA;           // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
    int                     BufCapacityA;           // end-user buffer capacity
    float                   ScrollX;                // horizontal scrolling/offset
    ImStb::STB_TexteditState Stb;                   // state for stb_textedit.h
    float                   CursorAnim;             // timer for cursor blink, reset on every user action so the cursor reappears immediately
    bool                    CursorFollow;           // set when we want scrolling to follow the current cursor position (not always!)
    bool                    SelectedAllMouseLock;   // after a double-click to select all, we ignore further mouse drags to update selection

    // Temporarily set when active
    ImGuiInputTextFlags     UserFlags;
    ImGuiInputTextCallback  UserCallback;
    void*                   UserCallbackData;

    ImGuiInputTextState()                           { memset(this, 0, sizeof(*this)); }
    void                ClearFreeMemory()           { TextW.clear(); TextA.clear(); InitialTextA.clear(); }
    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking
    void                CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }
    bool                HasSelection() const        { return Stb.select_start != Stb.select_end; }
    void                ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }
    void                SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }
    void                OnKeyPressed(int key);      // Cannot be inline because we call in code in stb_textedit.h implementation
};

// Windows data saved in imgui.ini file
struct ImGuiWindowSettings
{
    char*       Name;
    ImGuiID     ID;
    ImVec2      Pos;
    ImVec2      Size;
    bool        Collapsed;

    ImGuiWindowSettings() { Name = NULL; ID = 0; Pos = Size = ImVec2(0,0); Collapsed = false; }
};

struct ImGuiSettingsHandler
{
    const char* TypeName;       // Short description stored in .ini file. Disallowed characters: '[' ']'
    ImGuiID     TypeHash;       // == ImHashStr(TypeName, 0, 0)
    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); // Read: Called for every line of text within an ini entry
    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      // Write: Output every entries into 'out_buf'
    void*       UserData;

    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
};

// Storage for current popup stack
struct ImGuiPopupRef
{
    ImGuiID             PopupId;        // Set on OpenPopup()
    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
    ImGuiWindow*        ParentWindow;   // Set on OpenPopup()
    int                 OpenFrameCount; // Set on OpenPopup()
    ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differenciate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
    ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
    ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup
};

struct ImGuiColumnData
{
    float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
    float               OffsetNormBeforeResize;
    ImGuiColumnsFlags   Flags;              // Not exposed
    ImRect              ClipRect;

    ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = 0; }
};

struct ImGuiColumnsSet
{
    ImGuiID             ID;
    ImGuiColumnsFlags   Flags;
    bool                IsFirstFrame;
    bool                IsBeingResized;
    int                 Current;
    int                 Count;
    float               MinX, MaxX;
    float               LineMinY, LineMaxY;
    float               StartPosY;          // Copy of CursorPos
    float               StartMaxPosX;       // Copy of CursorMaxPos
    ImVector<ImGuiColumnData> Columns;

    ImGuiColumnsSet()   { Clear(); }
    void Clear()
    {
        ID = 0;
        Flags = 0;
        IsFirstFrame = false;
        IsBeingResized = false;
        Current = 0;
        Count = 1;
        MinX = MaxX = 0.0f;
        LineMinY = LineMaxY = 0.0f;
        StartPosY = 0.0f;
        StartMaxPosX = 0.0f;
        Columns.clear();
    }
};

// Data shared between all ImDrawList instances
struct IMGUI_API ImDrawListSharedData
{
    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas
    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)
    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)
    float           CurveTessellationTol;
    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()

    // Const data
    // FIXME: Bake rounded corners fill/borders in atlas
    ImVec2          CircleVtx12[12];

    ImDrawListSharedData();
};

struct ImDrawDataBuilder
{
    ImVector<ImDrawList*>   Layers[2];           // Global layers for: regular, tooltip

    void Clear()            { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }
    void ClearFreeMemory()  { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }
    IMGUI_API void FlattenIntoSingleLayer();
};

struct ImGuiNavMoveResult
{
    ImGuiID       ID;           // Best candidate
    ImGuiID       SelectScopeId;// Best candidate window current selectable group ID
    ImGuiWindow*  Window;       // Best candidate window
    float         DistBox;      // Best candidate box distance to current NavId
    float         DistCenter;   // Best candidate center distance to current NavId
    float         DistAxial;
    ImRect        RectRel;      // Best candidate bounding box in window relative space

    ImGuiNavMoveResult() { Clear(); }
    void Clear()         { ID = SelectScopeId = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }
};

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData
{
    ImGuiCond               PosCond;
    ImGuiCond               SizeCond;
    ImGuiCond               ContentSizeCond;
    ImGuiCond               CollapsedCond;
    ImGuiCond               SizeConstraintCond;
    ImGuiCond               FocusCond;
    ImGuiCond               BgAlphaCond;
    ImVec2                  PosVal;
    ImVec2                  PosPivotVal;
    ImVec2                  SizeVal;
    ImVec2                  ContentSizeVal;
    bool                    CollapsedVal;
    ImRect                  SizeConstraintRect;
    ImGuiSizeCallback       SizeCallback;
    void*                   SizeCallbackUserData;
    float                   BgAlphaVal;
    ImVec2                  MenuBarOffsetMinVal;                // This is not exposed publicly, so we don't clear it.

    ImGuiNextWindowData()
    {
        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;
        PosVal = PosPivotVal = SizeVal = ImVec2(0.0f, 0.0f);
        ContentSizeVal = ImVec2(0.0f, 0.0f);
        CollapsedVal = false;
        SizeConstraintRect = ImRect();
        SizeCallback = NULL;
        SizeCallbackUserData = NULL;
        BgAlphaVal = FLT_MAX;
        MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);
    }

    void    Clear()
    {
        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;
    }
};

//-----------------------------------------------------------------------------
// Tabs
//-----------------------------------------------------------------------------

struct ImGuiTabBarSortItem
{
    int             Index;
    float           Width;
};

struct ImGuiTabBarRef
{
    ImGuiTabBar*    Ptr;                    // Either field can be set, not both. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
    int             IndexInMainPool;

    ImGuiTabBarRef(ImGuiTabBar* ptr)        { Ptr = ptr; IndexInMainPool = -1; }
    ImGuiTabBarRef(int index_in_main_pool)  { Ptr = NULL; IndexInMainPool = index_in_main_pool; }
};

//-----------------------------------------------------------------------------
// Main imgui context
//-----------------------------------------------------------------------------

struct ImGuiContext
{
    bool                    Initialized;
    bool                    FrameScopeActive;                   // Set by NewFrame(), cleared by EndFrame()
    bool                    FrameScopePushedImplicitWindow;     // Set by NewFrame(), cleared by EndFrame()
    bool                    FontAtlasOwnedByContext;            // Io.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
    ImGuiIO                 IO;
    ImGuiStyle              Style;
    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
    ImDrawListSharedData    DrawListSharedData;

    double                  Time;
    int                     FrameCount;
    int                     FrameCountEnded;
    int                     FrameCountRendered;
    ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front
    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Windows, sorted in focus order, back to front
    ImVector<ImGuiWindow*>  WindowsSortBuffer;
    ImVector<ImGuiWindow*>  CurrentWindowStack;
    ImGuiStorage            WindowsById;
    int                     WindowsActiveCount;
    ImGuiWindow*            CurrentWindow;                      // Being drawn into
    ImGuiWindow*            HoveredWindow;                      // Will catch mouse inputs
    ImGuiWindow*            HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)
    ImGuiID                 HoveredId;                          // Hovered widget
    bool                    HoveredIdAllowOverlap;
    ImGuiID                 HoveredIdPreviousFrame;
    float                   HoveredIdTimer;                     // Measure contiguous hovering time
    float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active
    ImGuiID                 ActiveId;                           // Active widget
    ImGuiID                 ActiveIdPreviousFrame;
    ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
    float                   ActiveIdTimer;
    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame
    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
    bool                    ActiveIdHasBeenPressed;             // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
    bool                    ActiveIdHasBeenEdited;              // Was the value associated to the widget Edited over the course of the Active state.
    bool                    ActiveIdPreviousFrameIsAlive;
    bool                    ActiveIdPreviousFrameHasBeenEdited;
    int                     ActiveIdAllowNavDirFlags;           // Active widget allows using directional navigation (e.g. can activate a button and move away from it)
    int                     ActiveIdBlockNavInputFlags;
    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
    ImGuiWindow*            ActiveIdWindow;
    ImGuiWindow*            ActiveIdPreviousFrameWindow;
    ImGuiInputSource        ActiveIdSource;                     // Activating with mouse or nav (gamepad/keyboard)
    ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.
    float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.
    ImVec2                  LastValidMousePos;
    ImGuiWindow*            MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.
    ImVector<ImGuiColorMod> ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()
    ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()
    ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()
    ImVector<ImGuiPopupRef> OpenPopupStack;                     // Which popups are open (persistent)
    ImVector<ImGuiPopupRef> BeginPopupStack;                    // Which level of BeginPopup() we are in (reset every frame)
    ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions
    bool                    NextTreeNodeOpenVal;                // Storage for SetNextTreeNode** functions
    ImGuiCond               NextTreeNodeOpenCond;

    // Navigation data (for gamepad/keyboard)
    ImGuiWindow*            NavWindow;                          // Focused window for navigation. Could be called 'FocusWindow'
    ImGuiID                 NavId;                              // Focused item for navigation
    ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()
    ImGuiID                 NavActivateDownId;                  // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                 NavActivatePressedId;               // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                 NavInputId;                         // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0
    ImGuiID                 NavJustTabbedId;                    // Just tabbed to this id.
    ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest).
    ImGuiID                 NavJustMovedToSelectScopeId;        // Just navigated to this select scope id (result of a successfully MoveRequest).
    ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame.
    ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.
    ImRect                  NavScoringRectScreen;               // Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.
    int                     NavScoringCount;                    // Metrics for debugging
    ImGuiWindow*            NavWindowingTarget;                 // When selecting a window (holding Menu+FocusPrev/Next, or equivalent of CTRL-TAB) this window is temporarily displayed front-most.
    ImGuiWindow*            NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f
    ImGuiWindow*            NavWindowingList;
    float                   NavWindowingTimer;
    float                   NavWindowingHighlightAlpha;
    bool                    NavWindowingToggleLayer;
    ImGuiNavLayer           NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.
    int                     NavIdTabCounter;                    // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing
    bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRefRectRel is valid
    bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
    bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
    bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.
    bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest
    bool                    NavInitRequest;                     // Init request for appearing window to select first item
    bool                    NavInitRequestFromMove;
    ImGuiID                 NavInitResultId;
    ImRect                  NavInitResultRectRel;
    bool                    NavMoveFromClampedRefRect;          // Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items
    bool                    NavMoveRequest;                     // Move request for this frame
    ImGuiNavMoveFlags       NavMoveRequestFlags;
    ImGuiNavForward         NavMoveRequestForward;              // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)
    ImGuiDir                NavMoveDir, NavMoveDirLast;         // Direction of the move request (left/right/up/down), direction of the previous move request
    ImGuiDir                NavMoveClipDir;
    ImGuiNavMoveResult      NavMoveResultLocal;                 // Best move request candidate within NavWindow
    ImGuiNavMoveResult      NavMoveResultLocalVisibleSet;       // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
    ImGuiNavMoveResult      NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)

    // Render
    ImDrawData              DrawData;                           // Main ImDrawData instance to pass render information to the user
    ImDrawDataBuilder       DrawDataBuilder;
    float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
    ImDrawList              OverlayDrawList;                    // Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays
    ImGuiMouseCursor        MouseCursor;

    // Drag and Drop
    bool                    DragDropActive;
    bool                    DragDropWithinSourceOrTarget;
    ImGuiDragDropFlags      DragDropSourceFlags;
    int                     DragDropSourceFrameCount;
    int                     DragDropMouseButton;
    ImGuiPayload            DragDropPayload;
    ImRect                  DragDropTargetRect;
    ImGuiID                 DragDropTargetId;
    ImGuiDragDropFlags      DragDropAcceptFlags;
    float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)
    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source
    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly
    unsigned char           DragDropPayloadBufLocal[8];         // Local buffer for small payloads

    // Tab bars
    ImPool<ImGuiTabBar>             TabBars;
    ImGuiTabBar*                    CurrentTabBar;
    ImVector<ImGuiTabBarRef>        CurrentTabBarStack;
    ImVector<ImGuiTabBarSortItem>   TabSortByWidthBuffer;

    // Widget state
    ImGuiInputTextState     InputTextState;
    ImFont                  InputTextPasswordFont;
    ImGuiID                 ScalarAsInputTextId;                // Temporary text input when CTRL+clicking on a slider, etc.
    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets
    ImVec4                  ColorPickerRef;
    bool                    DragCurrentAccumDirty;
    float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
    ImVec2                  ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?
    int                     TooltipOverrideCount;
    ImVector<char>          PrivateClipboard;                   // If no custom clipboard handler is defined

    // Range-Select/Multi-Select
    // [This is unused in this branch, but left here to facilitate merging/syncing multiple branches]
    ImGuiID                 MultiSelectScopeId;

    // Platform support
    ImVec2                  PlatformImePos;                     // Cursor position request & last passed to the OS Input Method Editor
    ImVec2                  PlatformImeLastPos;

    // Settings
    bool                           SettingsLoaded;
    float                          SettingsDirtyTimer;          // Save .ini Settings to memory when time reaches zero
    ImGuiTextBuffer                SettingsIniData;             // In memory .ini settings
    ImVector<ImGuiSettingsHandler> SettingsHandlers;            // List of .ini settings handlers
    ImVector<ImGuiWindowSettings>  SettingsWindows;             // ImGuiWindow .ini settings entries (parsed from the last loaded .ini file and maintained on saving)

    // Logging
    bool                    LogEnabled;
    FILE*                   LogFile;                            // If != NULL log to stdout/ file
    ImGuiTextBuffer         LogClipboard;                       // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
    int                     LogStartDepth;
    int                     LogAutoExpandMaxDepth;

    // Misc
    float                   FramerateSecPerFrame[120];          // Calculate estimate of framerate for user over the last 2 seconds.
    int                     FramerateSecPerFrameIdx;
    float                   FramerateSecPerFrameAccum;
    int                     WantCaptureMouseNextFrame;          // Explicit capture via CaptureKeyboardFromApp()/CaptureMouseFromApp() sets those flags
    int                     WantCaptureKeyboardNextFrame;
    int                     WantTextInputNextFrame;
    char                    TempBuffer[1024*3+1];               // Temporary text buffer

    ImGuiContext(ImFontAtlas* shared_font_atlas) : OverlayDrawList(NULL)
    {
        Initialized = false;
        FrameScopeActive = FrameScopePushedImplicitWindow = false;
        Font = NULL;
        FontSize = FontBaseSize = 0.0f;
        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();

        Time = 0.0f;
        FrameCount = 0;
        FrameCountEnded = FrameCountRendered = -1;
        WindowsActiveCount = 0;
        CurrentWindow = NULL;
        HoveredWindow = NULL;
        HoveredRootWindow = NULL;
        HoveredId = 0;
        HoveredIdAllowOverlap = false;
        HoveredIdPreviousFrame = 0;
        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
        ActiveId = 0;
        ActiveIdPreviousFrame = 0;
        ActiveIdIsAlive = 0;
        ActiveIdTimer = 0.0f;
        ActiveIdIsJustActivated = false;
        ActiveIdAllowOverlap = false;
        ActiveIdHasBeenPressed = false;
        ActiveIdHasBeenEdited = false;
        ActiveIdPreviousFrameIsAlive = false;
        ActiveIdPreviousFrameHasBeenEdited = false;
        ActiveIdAllowNavDirFlags = 0x00;
        ActiveIdBlockNavInputFlags = 0x00;
        ActiveIdClickOffset = ImVec2(-1,-1);
        ActiveIdWindow = ActiveIdPreviousFrameWindow = NULL;
        ActiveIdSource = ImGuiInputSource_None;
        LastActiveId = 0;
        LastActiveIdTimer = 0.0f;
        LastValidMousePos = ImVec2(0.0f, 0.0f);
        MovingWindow = NULL;
        NextTreeNodeOpenVal = false;
        NextTreeNodeOpenCond = 0;

        NavWindow = NULL;
        NavId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;
        NavJustTabbedId = NavJustMovedToId = NavJustMovedToSelectScopeId = NavNextActivateId = 0;
        NavInputSource = ImGuiInputSource_None;
        NavScoringRectScreen = ImRect();
        NavScoringCount = 0;
        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingList = NULL;
        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
        NavWindowingToggleLayer = false;
        NavLayer = ImGuiNavLayer_Main;
        NavIdTabCounter = INT_MAX;
        NavIdIsAlive = false;
        NavMousePosDirty = false;
        NavDisableHighlight = true;
        NavDisableMouseHover = false;
        NavAnyRequest = false;
        NavInitRequest = false;
        NavInitRequestFromMove = false;
        NavInitResultId = 0;
        NavMoveFromClampedRefRect = false;
        NavMoveRequest = false;
        NavMoveRequestFlags = 0;
        NavMoveRequestForward = ImGuiNavForward_None;
        NavMoveDir = NavMoveDirLast = NavMoveClipDir = ImGuiDir_None;

        DimBgRatio = 0.0f;
        OverlayDrawList._Data = &DrawListSharedData;
        OverlayDrawList._OwnerName = "##Overlay"; // Give it a name for debugging
        MouseCursor = ImGuiMouseCursor_Arrow;

        DragDropActive = DragDropWithinSourceOrTarget = false;
        DragDropSourceFlags = 0;
        DragDropSourceFrameCount = -1;
        DragDropMouseButton = -1;
        DragDropTargetId = 0;
        DragDropAcceptFlags = 0;
        DragDropAcceptIdCurrRectSurface = 0.0f;
        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
        DragDropAcceptFrameCount = -1;
        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

        ScalarAsInputTextId = 0;
        ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;
        DragCurrentAccumDirty = false;
        DragCurrentAccum = 0.0f;
        DragSpeedDefaultRatio = 1.0f / 100.0f;
        ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);
        TooltipOverrideCount = 0;

        MultiSelectScopeId = 0;

        PlatformImePos = PlatformImeLastPos = ImVec2(FLT_MAX, FLT_MAX);

        SettingsLoaded = false;
        SettingsDirtyTimer = 0.0f;

        LogEnabled = false;
        LogFile = NULL;
        LogStartDepth = 0;
        LogAutoExpandMaxDepth = 2;

        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
        FramerateSecPerFrameIdx = 0;
        FramerateSecPerFrameAccum = 0.0f;
        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
        memset(TempBuffer, 0, sizeof(TempBuffer));
    }
};

//-----------------------------------------------------------------------------
// ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered.
struct IMGUI_API ImGuiWindowTempData
{
    ImVec2                  CursorPos;
    ImVec2                  CursorPosPrevLine;
    ImVec2                  CursorStartPos;         // Initial position in client area with padding
    ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Turned into window->SizeContents at the beginning of next frame
    ImVec2                  CurrentLineSize;
    float                   CurrentLineTextBaseOffset;
    ImVec2                  PrevLineSize;
    float                   PrevLineTextBaseOffset;
    float                   LogLinePosY;
    int                     TreeDepth;
    ImU32                   TreeDepthMayJumpToParentOnPop; // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31
    ImGuiID                 LastItemId;
    ImGuiItemStatusFlags    LastItemStatusFlags;
    ImRect                  LastItemRect;           // Interaction rect
    ImRect                  LastItemDisplayRect;    // End-user display rect (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)
    ImGuiNavLayer           NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)
    int                     NavLayerCurrentMask;    // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.
    int                     NavLayerActiveMask;     // Which layer have been written to (result from previous frame)
    int                     NavLayerActiveMaskNext; // Which layer have been written to (buffer for current frame)
    bool                    NavHideHighlightOneFrame;
    bool                    NavHasScroll;           // Set when scrolling can be used (ScrollMax > 0.0f)
    bool                    MenuBarAppending;       // FIXME: Remove this
    ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
    ImVector<ImGuiWindow*>  ChildWindows;
    ImGuiStorage*           StateStorage;
    ImGuiLayoutType         LayoutType;
    ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()

    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
    ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]
    float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window
    float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f]
    ImVector<ImGuiItemFlags>ItemFlagsStack;
    ImVector<float>         ItemWidthStack;
    ImVector<float>         TextWrapPosStack;
    ImVector<ImGuiGroupData>GroupStack;
    short                   StackSizesBackup[6];    // Store size of various stacks for asserting

    ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
    ImVec1                  GroupOffset;
    ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
    ImGuiColumnsSet*        ColumnsSet;             // Current columns set

    ImGuiWindowTempData()
    {
        CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);
        CurrentLineSize = PrevLineSize = ImVec2(0.0f, 0.0f);
        CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;
        LogLinePosY = -1.0f;
        TreeDepth = 0;
        TreeDepthMayJumpToParentOnPop = 0x00;
        LastItemId = 0;
        LastItemStatusFlags = 0;
        LastItemRect = LastItemDisplayRect = ImRect();
        NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;
        NavLayerCurrent = ImGuiNavLayer_Main;
        NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
        NavHideHighlightOneFrame = false;
        NavHasScroll = false;
        MenuBarAppending = false;
        MenuBarOffset = ImVec2(0.0f, 0.0f);
        StateStorage = NULL;
        LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;
        ItemWidth = 0.0f;
        ItemFlags = ImGuiItemFlags_Default_;
        TextWrapPos = -1.0f;
        memset(StackSizesBackup, 0, sizeof(StackSizesBackup));

        Indent = ImVec1(0.0f);
        GroupOffset = ImVec1(0.0f);
        ColumnsOffset = ImVec1(0.0f);
        ColumnsSet = NULL;
    }
};

// Storage for one window
struct IMGUI_API ImGuiWindow
{
    char*                   Name;
    ImGuiID                 ID;                                 // == ImHash(Name)
    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_
    ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)
    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)
    ImVec2                  SizeFull;                           // Size when non collapsed
    ImVec2                  SizeFullAtLastBegin;                // Copy of SizeFull at the end of Begin. This is the reference value we'll use on the next frame to decide if we need scrollbars.
    ImVec2                  SizeContents;                       // Size of contents (== extents reach of the drawing cursor) from previous frame. Include decoration, window title, border, menu, etc.
    ImVec2                  SizeContentsExplicit;               // Size of contents explicitly set by the user via SetNextWindowContentSize()
    ImVec2                  WindowPadding;                      // Window padding at the time of begin.
    float                   WindowRounding;                     // Window rounding at the time of begin.
    float                   WindowBorderSize;                   // Window border size at the time of begin.
    int                     NameBufLen;                         // Size of buffer storing Name. May be larger than strlen(Name)!
    ImGuiID                 MoveId;                             // == window->GetID("#MOVE")
    ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)
    ImVec2                  Scroll;
    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
    ImVec2                  ScrollbarSizes;                     // Size taken by scrollbars on each axis
    bool                    ScrollbarX, ScrollbarY;
    bool                    Active;                             // Set to true on Begin(), unless Collapsed
    bool                    WasActive;
    bool                    WriteAccessed;                      // Set to true when any widget access the current window
    bool                    Collapsed;                          // Set when collapsing window to become only title-bar
    bool                    WantCollapseToggle;
    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)
    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)
    bool                    Hidden;                             // Do not display (== (HiddenFramesForResize > 0) ||
    bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)
    signed char             ResizeBorderHeld;                   // Current border being held for resize (-1: none, otherwise 0-3)
    short                   BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
    short                   BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.
    short                   BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.
    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
    int                     AutoFitFramesX, AutoFitFramesY;
    bool                    AutoFitOnlyGrows;
    int                     AutoFitChildAxises;
    ImGuiDir                AutoPosLastDirection;
    int                     HiddenFramesRegular;                // Hide the window for N frames
    int                     HiddenFramesForResize;              // Hide the window for N frames while allowing items to be submitted so we can measure their size
    ImGuiCond               SetWindowPosAllowFlags;             // store acceptable condition flags for SetNextWindowPos() use.
    ImGuiCond               SetWindowSizeAllowFlags;            // store acceptable condition flags for SetNextWindowSize() use.
    ImGuiCond               SetWindowCollapsedAllowFlags;       // store acceptable condition flags for SetNextWindowCollapsed() use.
    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.

    ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.
    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack
    ImRect                  ClipRect;                           // Current clipping rectangle. = DrawList->clip_rect_stack.back(). Scissoring / clipping rectangle. x1, y1, x2, y2.
    ImRect                  OuterRectClipped;                   // = WindowRect just after setup in Begin(). == window->Rect() for root window.
    ImRect                  InnerMainRect, InnerClipRect;
    ImRect                  ContentsRegionRect;                 // FIXME: This is currently confusing/misleading. Maximum visible content position ~~ Pos + (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis
    int                     LastFrameActive;                    // Last frame number the window was Active.
    float                   ItemWidthDefault;
    ImGuiMenuColumns        MenuColumns;                        // Simplified columns storage for menu items
    ImGuiStorage            StateStorage;
    ImVector<ImGuiColumnsSet> ColumnsStorage;
    float                   FontWindowScale;                    // User scale multiplier per-window
    int                     SettingsIdx;                        // Index into SettingsWindow[] (indices are always valid as we only grow the array from the back)

    ImDrawList*             DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
    ImDrawList              DrawListInst;
    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.
    ImGuiWindow*            RootWindow;                         // Point to ourself or first ancestor that is not a child window.
    ImGuiWindow*            RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
    ImGuiWindow*            RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.

    ImGuiWindow*            NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    // Last known NavId for this window, per layer (0/1)
    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    // Reference rectangle, in window relative space

    // Navigation / Focus
    // FIXME-NAV: Merge all this with the new Nav system, at least the request variables should be moved to ImGuiContext
    int                     FocusIdxAllCounter;                 // Start at -1 and increase as assigned via FocusItemRegister()
    int                     FocusIdxTabCounter;                 // (same, but only count widgets which you can Tab through)
    int                     FocusIdxAllRequestCurrent;          // Item being requested for focus
    int                     FocusIdxTabRequestCurrent;          // Tab-able item being requested for focus
    int                     FocusIdxAllRequestNext;             // Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)
    int                     FocusIdxTabRequestNext;             // "

public:
    ImGuiWindow(ImGuiContext* context, const char* name);
    ~ImGuiWindow();

    ImGuiID     GetID(const char* str, const char* str_end = NULL);
    ImGuiID     GetID(const void* ptr);
    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);
    ImGuiID     GetIDNoKeepAlive(const void* ptr);
    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);

    // We don't use g.FontSize because the window may be != g.CurrentWidow.
    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }
    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }
    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }
    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }
    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }
};

// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.
struct ImGuiItemHoveredDataBackup
{
    ImGuiID                 LastItemId;
    ImGuiItemStatusFlags    LastItemStatusFlags;
    ImRect                  LastItemRect;
    ImRect                  LastItemDisplayRect;

    ImGuiItemHoveredDataBackup() { Backup(); }
    void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }
    void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }
};

//-----------------------------------------------------------------------------
// Tab bar, tab item
//-----------------------------------------------------------------------------

enum ImGuiTabBarFlagsPrivate_
{
    ImGuiTabBarFlags_DockNode                   = 1 << 20,  // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
    ImGuiTabBarFlags_IsFocused                  = 1 << 21,
    ImGuiTabBarFlags_SaveSettings               = 1 << 22   // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
};

enum ImGuiTabItemFlagsPrivate_
{
    ImGuiTabItemFlags_NoCloseButton             = 1 << 20   // Store whether p_open is set or not, which we need to recompute WidthContents during layout.
};

// Storage for one active tab item (sizeof() 26~32 bytes)
struct ImGuiTabItem
{
    ImGuiID             ID;
    ImGuiTabItemFlags   Flags;
    int                 LastFrameVisible;
    int                 LastFrameSelected;      // This allows us to infer an ordered list of the last activated tabs with little maintenance
    int                 NameOffset;             // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
    float               Offset;                 // Position relative to beginning of tab
    float               Width;                  // Width currently displayed
    float               WidthContents;          // Width of actual contents, stored during BeginTabItem() call

    ImGuiTabItem()      { ID = Flags = 0; LastFrameVisible = LastFrameSelected = -1; NameOffset = -1; Offset = Width = WidthContents = 0.0f; }
};

// Storage for a tab bar (sizeof() 92~96 bytes)
struct ImGuiTabBar
{
    ImVector<ImGuiTabItem> Tabs;
    ImGuiID             ID;                     // Zero for tab-bars used by docking
    ImGuiID             SelectedTabId;          // Selected tab
    ImGuiID             NextSelectedTabId;
    ImGuiID             VisibleTabId;           // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
    int                 CurrFrameVisible;
    int                 PrevFrameVisible;
    ImRect              BarRect;
    float               ContentsHeight;
    float               OffsetMax;              // Distance from BarRect.Min.x, locked during layout
    float               OffsetNextTab;          // Distance from BarRect.Min.x, incremented with each BeginTabItem() call, not used if ImGuiTabBarFlags_Reorderable if set.
    float               ScrollingAnim;
    float               ScrollingTarget;
    ImGuiTabBarFlags    Flags;
    ImGuiID             ReorderRequestTabId;
    int                 ReorderRequestDir;
    bool                WantLayout;
    bool                VisibleTabWasSubmitted;
    short               LastTabItemIdx;         // For BeginTabItem()/EndTabItem()
    ImVec2              FramePadding;           // style.FramePadding locked at the time of BeginTabBar()
    ImGuiTextBuffer     TabsNames;              // For non-docking tab bar we re-append names in a contiguous buffer. 

    ImGuiTabBar();
    int                 GetTabOrder(const ImGuiTabItem* tab) const  { return Tabs.index_from_ptr(tab); }
    const char*         GetTabName(const ImGuiTabItem* tab) const 
    {
        IM_ASSERT(tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size); 
        return TabsNames.Buf.Data + tab->NameOffset;
    }
};

//-----------------------------------------------------------------------------
// Internal API
// No guarantee of forward compatibility here.
//-----------------------------------------------------------------------------

namespace ImGui
{
    // We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
    // If this ever crash because g.CurrentWindow is NULL it means that either
    // - ImGui::NewFrame() has never been called, which is illegal.
    // - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
    IMGUI_API ImGuiWindow*  FindWindowByID(ImGuiID id);
    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);
    IMGUI_API void          FocusWindow(ImGuiWindow* window);
    IMGUI_API void          FocusPreviousWindowIgnoringOne(ImGuiWindow* ignore_window);
    IMGUI_API void          BringWindowToFocusFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayBack(ImGuiWindow* window);
    IMGUI_API void          UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);
    IMGUI_API ImVec2        CalcWindowExpectedSize(ImGuiWindow* window);
    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);
    IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);
    IMGUI_API void          SetWindowScrollX(ImGuiWindow* window, float new_scroll_x);
    IMGUI_API void          SetWindowScrollY(ImGuiWindow* window, float new_scroll_y);
    IMGUI_API float         GetWindowScrollMaxX(ImGuiWindow* window);
    IMGUI_API float         GetWindowScrollMaxY(ImGuiWindow* window);
    IMGUI_API ImRect        GetWindowAllowedExtentRect(ImGuiWindow* window);
    IMGUI_API void          SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond);
    IMGUI_API void          SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond);
    IMGUI_API void          SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond);

    IMGUI_API void          SetCurrentFont(ImFont* font);
    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }

    // Init
    IMGUI_API void          Initialize(ImGuiContext* context);
    IMGUI_API void          Shutdown(ImGuiContext* context);    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

    // NewFrame
    IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();
    IMGUI_API void          StartMouseMovingWindow(ImGuiWindow* window);
    IMGUI_API void          UpdateMouseMovingWindowNewFrame();
    IMGUI_API void          UpdateMouseMovingWindowEndFrame();

    // Settings
    IMGUI_API void                  MarkIniSettingsDirty();
    IMGUI_API void                  MarkIniSettingsDirty(ImGuiWindow* window);
    IMGUI_API ImGuiWindowSettings*  CreateNewWindowSettings(const char* name);
    IMGUI_API ImGuiWindowSettings*  FindWindowSettings(ImGuiID id);
    IMGUI_API ImGuiWindowSettings*  FindOrCreateWindowSettings(const char* name);
    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);

    // Basic Accessors
    inline ImGuiID          GetItemID()     { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId; }
    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }
    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }
    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          ClearActiveID();
    IMGUI_API ImGuiID       GetHoveredID();
    IMGUI_API void          SetHoveredID(ImGuiID id);
    IMGUI_API void          KeepAliveID(ImGuiID id);
    IMGUI_API void          MarkItemEdited(ImGuiID id);

    // Basic Helpers for widget code
    IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);
    IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);
    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL);
    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);
    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged);
    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop = true);   // Return true if focus is requested
    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);
    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_x, float default_y);
    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);
    IMGUI_API void          PushMultiItemsWidths(int components, float width_full = 0.0f);
    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);
    IMGUI_API void          PopItemFlag();

    // Popups, Modals, Tooltips
    IMGUI_API void          OpenPopupEx(ImGuiID id);
    IMGUI_API void          ClosePopupToLevel(int remaining, bool apply_focus_to_window_under);
    IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window);
    IMGUI_API bool          IsPopupOpen(ImGuiID id); // Test for id within current popup stack level (currently begin-ed into); this doesn't scan the whole popup stack!
    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);
    IMGUI_API void          BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip = true);
    IMGUI_API ImGuiWindow*  GetFrontMostPopupModal();
    IMGUI_API ImVec2        FindBestWindowPosForPopup(ImGuiWindow* window);
    IMGUI_API ImVec2        FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default);

    // Navigation
    IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);
    IMGUI_API bool          NavMoveRequestButNoResultYet();
    IMGUI_API void          NavMoveRequestCancel();
    IMGUI_API void          NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags);
    IMGUI_API void          NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);
    IMGUI_API float         GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);
    IMGUI_API ImVec2        GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0.0f, float fast_factor = 0.0f);
    IMGUI_API int           CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate);
    IMGUI_API void          ActivateItem(ImGuiID id);   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.
    IMGUI_API void          SetNavID(ImGuiID id, int nav_layer);
    IMGUI_API void          SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel);

    // Inputs
    inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { const int key_index = GImGui->IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }
    inline bool             IsNavInputDown(ImGuiNavInput n)                             { return GImGui->IO.NavInputs[n] > 0.0f; }
    inline bool             IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode) { return GetNavInputAmount(n, mode) > 0.0f; }
    inline bool             IsNavInputPressedAnyOfTwo(ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode) { return (GetNavInputAmount(n1, mode) + GetNavInputAmount(n2, mode)) > 0.0f; }

    // Drag and Drop
    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);
    IMGUI_API void          ClearDragDrop();
    IMGUI_API bool          IsDragDropPayloadBeingAccepted();

    // New Columns API (FIXME-WIP)
    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiColumnsFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
    IMGUI_API void          EndColumns();                                                             // close columns
    IMGUI_API void          PushColumnClipRect(int column_index = -1);

    // Tab Bars
    IMGUI_API bool          BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags);
    IMGUI_API ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    IMGUI_API void          TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir);
    IMGUI_API bool          TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags);
    IMGUI_API ImVec2        TabItemCalcSize(const char* label, bool has_close_button);
    IMGUI_API void          TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col);
    IMGUI_API bool          TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id);

    // Render helpers
    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
    // NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);
    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);
    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);
    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);
    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0);
    IMGUI_API void          RenderArrow(ImVec2 pos, ImGuiDir dir, float scale = 1.0f);
    IMGUI_API void          RenderBullet(ImVec2 pos);
    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col, float sz);
    IMGUI_API void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault); // Navigation highlight
    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.
    IMGUI_API void          LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL);

    // Render helpers (those functions don't access any ImGui state!)
    IMGUI_API void          RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor = ImGuiMouseCursor_Arrow);
    IMGUI_API void          RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);
    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);
    IMGUI_API void          RenderPixelEllipsis(ImDrawList* draw_list, ImVec2 pos, int count, ImU32 col);

    // Widgets
    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);
    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);
    IMGUI_API bool          CollapseButton(ImGuiID id, const ImVec2& pos);
    IMGUI_API bool          ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags);
    IMGUI_API void          Scrollbar(ImGuiAxis axis);
    IMGUI_API ImGuiID       GetScrollbarID(ImGuiWindow* window, ImGuiAxis axis);
    IMGUI_API void          VerticalSeparator();        // Vertical separator, for menu bars (use current line height). Not exposed because it is misleading and it doesn't have an effect on regular layout.

    // Widgets low-level behaviors
    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);
    IMGUI_API bool          DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags);
    IMGUI_API bool          SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    IMGUI_API bool          SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f);
    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);
    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     // Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging
    IMGUI_API void          TreePushRawID(ImGuiID id);

    // Template functions are instantiated in imgui_widgets.cpp for a finite number of types.
    // To use them externally (for custom widget) you may need an "extern template" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).
    // e.g. " extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); "
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, const T v_min, const T v_max, const char* format, float power, ImGuiDragFlags flags);
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, const T v_min, const T v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    template<typename T, typename FLOAT_T>                      IMGUI_API float SliderCalcRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, float power, float linear_zero_pos);
    template<typename T, typename SIGNED_T>                     IMGUI_API T     RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);

    // InputText
    IMGUI_API bool          InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputScalarAsWidgetReplacement(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format);

    // Color
    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);

    // Plot
    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size);

    // Shade functions (write over already created vertices)
    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
    IMGUI_API void          ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);

} // namespace ImGui

// ImFontAtlas internals
IMGUI_API bool              ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);
IMGUI_API void              ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);
IMGUI_API void              ImFontAtlasBuildFinish(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
IMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);

// Test engine hooks (imgui-test)
//#define IMGUI_ENABLE_TEST_ENGINE
#ifdef IMGUI_ENABLE_TEST_ENGINE
extern void                 ImGuiTestEngineHook_PreNewFrame(ImGuiContext* ctx);
extern void                 ImGuiTestEngineHook_PostNewFrame(ImGuiContext* ctx);
extern void                 ImGuiTestEngineHook_ItemAdd(ImGuiContext* ctx, const ImRect& bb, ImGuiID id);
extern void                 ImGuiTestEngineHook_ItemInfo(ImGuiContext* ctx, ImGuiID id, const char* label, ImGuiItemStatusFlags flags);
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)  ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS)   // Register status flags
#else
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)  do { } while (0)
#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

```

`CSGOSimple/imgui/imgui_widgets.cpp`:

```cpp
// dear imgui, v1.69 WIP
// (widgets code)

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Widgets: Text, etc.
// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)
// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)
// [SECTION] Widgets: ComboBox
// [SECTION] Data Type and Data Formatting Helpers
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
// [SECTION] Widgets: InputText, InputTextMultiline
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
// [SECTION] Widgets: Selectable
// [SECTION] Widgets: ListBox
// [SECTION] Widgets: PlotLines, PlotHistogram
// [SECTION] Widgets: Value helpers
// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <ctype.h>      // toupper, isprint
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127) // condition expression is constant
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

//-------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------

// Those MIN/MAX values are not define because we need to point to them
static const ImS32  IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);
static const ImS32  IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)
static const ImU32  IM_U32_MIN = 0;
static const ImU32  IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)
#ifdef LLONG_MIN
static const ImS64  IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);
static const ImS64  IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);
#else
static const ImS64  IM_S64_MIN = -9223372036854775807LL - 1;
static const ImS64  IM_S64_MAX = 9223372036854775807LL;
#endif
static const ImU64  IM_U64_MIN = 0;
#ifdef ULLONG_MAX
static const ImU64  IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
#else
static const ImU64  IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);
#endif

//-------------------------------------------------------------------------
// [SECTION] Forward Declarations
//-------------------------------------------------------------------------

// Data Type helpers
static inline int       DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format);
static void             DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2);
static bool             DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format);

// For InputTextEx()
static bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data);
static int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);
static ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

void ImGui::TextUnformatted(const char* text, const char* text_end)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    IM_ASSERT(text != NULL);
    const char* text_begin = text;
    if (text_end == NULL)
        text_end = text + strlen(text); // FIXME-OPT

    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);
    const float wrap_pos_x = window->DC.TextWrapPos;
    const bool wrap_enabled = wrap_pos_x >= 0.0f;
    if (text_end - text > 2000 && !wrap_enabled)
    {
        // Long text!
        // Perform manual coarse clipping to optimize for long multi-line text
        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
        const char* line = text;
        const float line_height = GetTextLineHeight();
        const ImRect clip_rect = window->ClipRect;
        ImVec2 text_size(0,0);

        if (text_pos.y <= clip_rect.Max.y)
        {
            ImVec2 pos = text_pos;

            // Lines to skip (can't skip when logging text)
            if (!g.LogEnabled)
            {
                int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);
                if (lines_skippable > 0)
                {
                    int lines_skipped = 0;
                    while (line < text_end && lines_skipped < lines_skippable)
                    {
                        const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                        if (!line_end)
                            line_end = text_end;
                        line = line_end + 1;
                        lines_skipped++;
                    }
                    pos.y += lines_skipped * line_height;
                }
            }

            // Lines to render
            if (line < text_end)
            {
                ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
                while (line < text_end)
                {
                    if (IsClippedEx(line_rect, 0, false))
                        break;

                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                    if (!line_end)
                        line_end = text_end;
                    const ImVec2 line_size = CalcTextSize(line, line_end, false);
                    text_size.x = ImMax(text_size.x, line_size.x);
                    RenderText(pos, line, line_end, false);
                    line = line_end + 1;
                    line_rect.Min.y += line_height;
                    line_rect.Max.y += line_height;
                    pos.y += line_height;
                }

                // Count remaining lines
                int lines_skipped = 0;
                while (line < text_end)
                {
                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                    if (!line_end)
                        line_end = text_end;
                    line = line_end + 1;
                    lines_skipped++;
                }
                pos.y += lines_skipped * line_height;
            }

            text_size.y += (pos - text_pos).y;
        }

        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(text_size);
        ItemAdd(bb, 0);
    }
    else
    {
        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;
        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

        // Account of baseline offset
        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(text_size);
        if (!ItemAdd(bb, 0))
            return;

        // Render (we don't hide text after ## in this end-user function)
        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
    }
}

void ImGui::Text(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextV(fmt, args);
    va_end(args);
}

void ImGui::TextV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    TextUnformatted(g.TempBuffer, text_end);
}

void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextColoredV(col, fmt, args);
    va_end(args);
}

void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)
{
    PushStyleColor(ImGuiCol_Text, col);
    TextV(fmt, args);
    PopStyleColor();
}

void ImGui::TextDisabled(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextDisabledV(fmt, args);
    va_end(args);
}

void ImGui::TextDisabledV(const char* fmt, va_list args)
{
    PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);
    TextV(fmt, args);
    PopStyleColor();
}

void ImGui::TextWrapped(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextWrappedV(fmt, args);
    va_end(args);
}

void ImGui::TextWrappedV(const char* fmt, va_list args)
{
    bool need_backup = (GImGui->CurrentWindow->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set
    if (need_backup)
        PushTextWrapPos(0.0f);
    TextV(fmt, args);
    if (need_backup)
        PopTextWrapPos();
}

void ImGui::LabelText(const char* label, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    LabelTextV(label, fmt, args);
    va_end(args);
}

// Add a label+text combo aligned to other label+value widgets
void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));
    const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0))
        return;

    // Render
    const char* value_text_begin = &g.TempBuffer[0];
    const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));
    if (label_size.x > 0.0f)
        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);
}

void ImGui::BulletText(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    BulletTextV(fmt, args);
    va_end(args);
}

// Text with a little bullet aligned to the typical tree node.
void ImGui::BulletTextV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const char* text_begin = g.TempBuffer;
    const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);
    const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x*2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;

    // Render
    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));
    RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - Scrollbar() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()
//-------------------------------------------------------------------------

bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    if (flags & ImGuiButtonFlags_Disabled)
    {
        if (out_hovered) *out_hovered = false;
        if (out_held) *out_held = false;
        if (g.ActiveId == id) ClearActiveID();
        return false;
    }

    // Default behavior requires click+release on same spot
    if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)
        flags |= ImGuiButtonFlags_PressedOnClickRelease;

    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
        g.HoveredWindow = window;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    if (id != 0 && window->DC.LastItemId != id)
        ImGuiTestEngineHook_ItemAdd(&g, bb, id);
#endif

    bool pressed = false;
    bool hovered = ItemHoverable(bb, id);

    // Drag source doesn't report as hovered
    if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
        hovered = false;

    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        {
            hovered = true;
            SetHoveredID(id);
            if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy
            {
                pressed = true;
                FocusWindow(window);
            }
        }

    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
        g.HoveredWindow = backup_hovered_window;

    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))
        hovered = false;

    // Mouse
    if (hovered)
    {
        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
        {
            //                        | CLICKING        | HOLDING with ImGuiButtonFlags_Repeat
            // PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds
            // PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..
            // PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)
            // PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..
            // FIXME-NAV: We don't honor those different behaviors.
            if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])
            {
                SetActiveID(id, window);
                if (!(flags & ImGuiButtonFlags_NoNavFocus))
                    SetFocusID(id, window);
                FocusWindow(window);
            }
            if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))
            {
                pressed = true;
                if (flags & ImGuiButtonFlags_NoHoldingActiveID)
                    ClearActiveID();
                else
                    SetActiveID(id, window); // Hold on ID
                FocusWindow(window);
            }
            if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])
            {
                if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
                    pressed = true;
                ClearActiveID();
            }

            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
            if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))
                pressed = true;
        }

        if (pressed)
            g.NavDisableHighlight = true;
    }

    // Gamepad/Keyboard navigation
    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
        hovered = true;

    if (g.NavActivateDownId == id)
    {
        bool nav_activated_by_code = (g.NavActivateId == id);
        bool nav_activated_by_inputs = IsNavInputPressed(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);
        if (nav_activated_by_code || nav_activated_by_inputs)
            pressed = true;
        if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)
        {
            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
            g.NavActivateId = id; // This is so SetActiveId assign a Nav source
            SetActiveID(id, window);
            if ((nav_activated_by_code || nav_activated_by_inputs) && !(flags & ImGuiButtonFlags_NoNavFocus))
                SetFocusID(id, window);
            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right) | (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        }
    }

    bool held = false;
    if (g.ActiveId == id)
    {
        if (pressed)
            g.ActiveIdHasBeenPressed = true;
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (g.ActiveIdIsJustActivated)
                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
            if (g.IO.MouseDown[0])
            {
                held = true;
            }
            else
            {
                if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease))
                    if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
                        if (!g.DragDropActive)
                            pressed = true;
                ClearActiveID();
            }
            if (!(flags & ImGuiButtonFlags_NoNavFocus))
                g.NavDisableHighlight = true;
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
        {
            if (g.NavActivateDownId != id)
                ClearActiveID();
        }
    }

    if (out_hovered) *out_hovered = hovered;
    if (out_held) *out_held = held;

    return pressed;
}

bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    ImVec2 pos = window->DC.CursorPos;
    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
        pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;
    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

    const ImRect bb(pos, pos + size);
    ItemSize(size, style.FramePadding.y);
    if (!ItemAdd(bb, id))
        return false;

    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);
    if (pressed)
        MarkItemEdited(id);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);
    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

    // Automatically close popups
    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
    //    CloseCurrentPopup();

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.LastItemStatusFlags);
    return pressed;
}

bool ImGui::Button(const char* label, const ImVec2& size_arg)
{
    return ButtonEx(label, size_arg, 0);
}

// Small buttons fits within text without additional vertical spacing.
bool ImGui::SmallButton(const char* label)
{
    ImGuiContext& g = *GImGui;
    float backup_padding_y = g.Style.FramePadding.y;
    g.Style.FramePadding.y = 0.0f;
    bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);
    g.Style.FramePadding.y = backup_padding_y;
    return pressed;
}

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
    IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);

    const ImGuiID id = window->GetID(str_id);
    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(size);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    return pressed;
}

bool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiID id = window->GetID(str_id);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const float default_size = GetFrameHeight();
    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;

    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, g.Style.FrameRounding);
    RenderArrow(bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), dir);

    return pressed;
}

bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)
{
    float sz = GetFrameHeight();
    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), 0);
}

// Button to close a window
bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.
    // (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
    const ImRect bb(pos - ImVec2(radius,radius), pos + ImVec2(radius,radius));
    bool is_clipped = !ItemAdd(bb, id);

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);
    if (is_clipped)
        return pressed;

    // Render
    ImVec2 center = bb.GetCenter();
    if (hovered)
        window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered), 9);

    float cross_extent = (radius * 0.7071f) - 1.0f;
    ImU32 cross_col = GetColorU32(ImGuiCol_Text);
    center -= ImVec2(0.5f, 0.5f);
    window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), cross_col, 1.0f);
    window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), cross_col, 1.0f);

    return pressed;
}

bool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);
    ItemAdd(bb, id);
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);

    ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    if (hovered || held)
        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, col, 9);
    RenderArrow(bb.Min + g.Style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);

    // Switch to moving the window after mouse is moved beyond the initial drag threshold
    if (IsItemActive() && IsMouseDragging())
        StartMouseMovingWindow(window);

    return pressed;
}

ImGuiID ImGui::GetScrollbarID(ImGuiWindow* window, ImGuiAxis axis)
{
    return window->GetIDNoKeepAlive(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
}

// Vertical/Horizontal scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
void ImGui::Scrollbar(ImGuiAxis axis)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const bool horizontal = (axis == ImGuiAxis_X);
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = GetScrollbarID(window, axis);
    KeepAliveID(id);

    // Render background
    bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);
    float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;
    const ImRect window_rect = window->Rect();
    const float border_size = window->WindowBorderSize;
    ImRect bb = horizontal
        ? ImRect(window->Pos.x + border_size, window_rect.Max.y - style.ScrollbarSize, window_rect.Max.x - other_scrollbar_size_w - border_size, window_rect.Max.y - border_size)
        : ImRect(window_rect.Max.x - style.ScrollbarSize, window->Pos.y + border_size, window_rect.Max.x - border_size, window_rect.Max.y - other_scrollbar_size_w - border_size);
    if (!horizontal)
        bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);

    const float bb_height = bb.GetHeight();
    if (bb.GetWidth() <= 0.0f || bb_height <= 0.0f)
        return;

    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the resize grab)
    float alpha = 1.0f;
    if ((axis == ImGuiAxis_Y) && bb_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
    {
        alpha = ImSaturate((bb_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));
        if (alpha <= 0.0f)
            return;
    }
    const bool allow_interaction = (alpha >= 1.0f);

    int window_rounding_corners;
    if (horizontal)
        window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
    else
        window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);
    bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
    float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();
    float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;
    float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;
    float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;

    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
    IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
    const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);
    const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);
    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
    bool held = false;
    bool hovered = false;
    const bool previously_held = (g.ActiveId == id);
    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

    float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);
    float scroll_ratio = ImSaturate(scroll_v / scroll_max);
    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
    if (held && allow_interaction && grab_h_norm < 1.0f)
    {
        float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;
        float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
        float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;

        // Click position in scrollbar normalized space (0.0f->1.0f)
        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
        SetHoveredID(id);

        bool seek_absolute = false;
        if (!previously_held)
        {
            // On initial click calculate the distance between mouse and the center of the grab
            if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)
            {
                *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;
            }
            else
            {
                seek_absolute = true;
                *click_delta_to_grab_center_v = 0.0f;
            }
        }

        // Apply scroll
        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position
        const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm*0.5f) / (1.0f - grab_h_norm));
        scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));
        if (horizontal)
            window->Scroll.x = scroll_v;
        else
            window->Scroll.y = scroll_v;

        // Update values for rendering
        scroll_ratio = ImSaturate(scroll_v / scroll_max);
        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

        // Update distance to grab now that we have seeked and saturated
        if (seek_absolute)
            *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;
    }

    // Render grab
    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);
    ImRect grab_rect;
    if (horizontal)
        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, window_rect.Max.x), bb.Max.y);
    else
        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, window_rect.Max.y));
    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
}

void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    if (border_col.w > 0.0f)
        bb.Max += ImVec2(2, 2);
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;

    if (border_col.w > 0.0f)
    {
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);
        window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));
    }
    else
    {
        window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));
    }
}

// frame_padding < 0: uses FramePadding from style (default)
// frame_padding = 0: no framing
// frame_padding > 0: set framing size
// The color used are the button colors.
bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    // Default to using texture ID as ID. User can still push string/integer prefixes.
    // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
    PushID((void*)(intptr_t)user_texture_id);
    const ImGuiID id = window->GetID("#image");
    PopID();

    const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding * 2);
    const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);
    ItemSize(bb);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));
    if (bg_col.w > 0.0f)
        window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));
    window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));

    return pressed;
}

bool ImGui::Checkbox(const char* label, bool* v)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    const float square_sz = GetFrameHeight();
    const ImVec2 pos = window->DC.CursorPos;
    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    if (pressed)
    {
        *v = !(*v);
        MarkItemEdited(id);
    }

    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
    RenderNavHighlight(total_bb, id);
    RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);
    if (*v)
    {
        const float pad = ImMax(1.0f, (float)(int)(square_sz / 6.0f));
        RenderCheckMark(check_bb.Min + ImVec2(pad, pad), GetColorU32(ImGuiCol_CheckMark), square_sz - pad*2.0f);
    }

    if (g.LogEnabled)
        LogRenderedText(&total_bb.Min, *v ? "[x]" : "[ ]");
    if (label_size.x > 0.0f)
        RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
    return pressed;
}

bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)
{
    bool v = ((*flags & flags_value) == flags_value);
    bool pressed = Checkbox(label, &v);
    if (pressed)
    {
        if (v)
            *flags |= flags_value;
        else
            *flags &= ~flags_value;
    }

    return pressed;
}

bool ImGui::RadioButton(const char* label, bool active)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    const float square_sz = GetFrameHeight();
    const ImVec2 pos = window->DC.CursorPos;
    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id))
        return false;

    ImVec2 center = check_bb.GetCenter();
    center.x = (float)(int)center.x + 0.5f;
    center.y = (float)(int)center.y + 0.5f;
    const float radius = (square_sz - 1.0f) * 0.5f;

    bool hovered, held;
    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    if (pressed)
        MarkItemEdited(id);

    RenderNavHighlight(total_bb, id);
    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);
    if (active)
    {
        const float pad = ImMax(1.0f, (float)(int)(square_sz / 6.0f));
        window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark), 16);
    }

    if (style.FrameBorderSize > 0.0f)
    {
        window->DrawList->AddCircle(center + ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);
        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);
    }

    if (g.LogEnabled)
        LogRenderedText(&total_bb.Min, active ? "(x)" : "( )");
    if (label_size.x > 0.0f)
        RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

    return pressed;
}

bool ImGui::RadioButton(const char* label, int* v, int v_button)
{
    const bool pressed = RadioButton(label, *v == v_button);
    if (pressed)
        *v = v_button;
    return pressed;
}

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    ImVec2 pos = window->DC.CursorPos;
    ImRect bb(pos, pos + CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y*2.0f));
    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(bb, 0))
        return;

    // Render
    fraction = ImSaturate(fraction);
    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));
    const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);
    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);

    // Default displaying the fraction as percentage string, but user can override it
    char overlay_buf[32];
    if (!overlay)
    {
        ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction*100+0.01f);
        overlay = overlay_buf;
    }

    ImVec2 overlay_size = CalcTextSize(overlay, NULL);
    if (overlay_size.x > 0.0f)
        RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);
}

void ImGui::Bullet()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
    {
        SameLine(0, style.FramePadding.x*2);
        return;
    }

    // Render and stay on same line
    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));
    SameLine(0, style.FramePadding.x*2);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - Separator()
// - VerticalSeparator() [Internal]
// - SplitterBehavior() [Internal]
//-------------------------------------------------------------------------

void ImGui::Spacing()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ItemSize(ImVec2(0,0));
}

void ImGui::Dummy(const ImVec2& size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb);
    ItemAdd(bb, 0);
}

void ImGui::NewLine()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    if (window->DC.CurrentLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
        ItemSize(ImVec2(0,0));
    else
        ItemSize(ImVec2(0.0f, g.FontSize));
    window->DC.LayoutType = backup_layout_type;
}

void ImGui::AlignTextToFramePadding()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    window->DC.CurrentLineSize.y = ImMax(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);
    window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);
}

// Horizontal/vertical separating line
void ImGui::Separator()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    // Those flags should eventually be overridable by the user
    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical))));   // Check that only 1 option is selected
    if (flags & ImGuiSeparatorFlags_Vertical)
    {
        VerticalSeparator();
        return;
    }

    // Horizontal Separator
    if (window->DC.ColumnsSet)
        PopClipRect();

    float x1 = window->Pos.x;
    float x2 = window->Pos.x + window->Size.x;
    if (!window->DC.GroupStack.empty())
        x1 += window->DC.Indent.x;

    const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));
    ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.
    if (!ItemAdd(bb, 0))
    {
        if (window->DC.ColumnsSet)
            PushColumnClipRect();
        return;
    }

    window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Separator));

    if (g.LogEnabled)
        LogRenderedText(&bb.Min, "--------------------------------");

    if (window->DC.ColumnsSet)
    {
        PushColumnClipRect();
        window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;
    }
}

void ImGui::VerticalSeparator()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    float y1 = window->DC.CursorPos.y;
    float y2 = window->DC.CursorPos.y + window->DC.CurrentLineSize.y;
    const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));
    ItemSize(ImVec2(bb.GetWidth(), 0.0f));
    if (!ItemAdd(bb, 0))
        return;

    window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));
    if (g.LogEnabled)
        LogText(" |");
}

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
bool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
    window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;
    bool item_add = ItemAdd(bb, id);
    window->DC.ItemFlags = item_flags_backup;
    if (!item_add)
        return false;

    bool hovered, held;
    ImRect bb_interact = bb;
    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));
    ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);
    if (g.ActiveId != id)
        SetItemAllowOverlap();

    if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))
        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

    ImRect bb_render = bb;
    if (held)
    {
        ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;
        float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

        // Minimum pane size
        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);
        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);
        if (mouse_delta < -size_1_maximum_delta)
            mouse_delta = -size_1_maximum_delta;
        if (mouse_delta > size_2_maximum_delta)
            mouse_delta = size_2_maximum_delta;

        // Apply resize
        if (mouse_delta != 0.0f)
        {
            if (mouse_delta < 0.0f)
                IM_ASSERT(*size1 + mouse_delta >= min_size1);
            if (mouse_delta > 0.0f)
                IM_ASSERT(*size2 - mouse_delta >= min_size2);
            *size1 += mouse_delta;
            *size2 -= mouse_delta;
            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));
            MarkItemEdited(id);
        }
    }

    // Render
    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);

    return held;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ComboBox
//-------------------------------------------------------------------------
// - BeginCombo()
// - EndCombo()
// - Combo()
//-------------------------------------------------------------------------

static float CalcMaxPopupHeightFromItemCount(int items_count)
{
    ImGuiContext& g = *GImGui;
    if (items_count <= 0)
        return FLT_MAX;
    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
{
    // Always consume the SetNextWindowSizeConstraint() call in our early return paths
    ImGuiContext& g = *GImGui;
    ImGuiCond backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;
    g.NextWindowData.SizeConstraintCond = 0;

    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);
    bool popup_open = IsPopupOpen(id);

    const ImRect value_bb(frame_bb.Min, frame_bb.Max - ImVec2(arrow_size, 0.0f));
    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    if (!(flags & ImGuiComboFlags_NoPreview))
        window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Max.y), frame_col, style.FrameRounding, ImDrawCornerFlags_Left);
    if (!(flags & ImGuiComboFlags_NoArrowButton))
    {
        window->DrawList->AddRectFilled(ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Min.y), frame_bb.Max, GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button), style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);
        RenderArrow(ImVec2(frame_bb.Max.x - arrow_size + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), ImGuiDir_Down);
    }
    RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);
    if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))
        RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, preview_value, NULL, NULL, ImVec2(0.0f,0.0f));
    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    if ((pressed || g.NavActivateId == id) && !popup_open)
    {
        if (window->DC.NavLayerCurrent == 0)
            window->NavLastIds[0] = id;
        OpenPopupEx(id);
        popup_open = true;
    }

    if (!popup_open)
        return false;

    if (backup_next_window_size_constraint)
    {
        g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;
        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
    }
    else
    {
        if ((flags & ImGuiComboFlags_HeightMask_) == 0)
            flags |= ImGuiComboFlags_HeightRegular;
        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one
        int popup_max_height_in_items = -1;
        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;
        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;
        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
    }

    char name[16];
    ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth

    // Peak into expected window size so we can position it
    if (ImGuiWindow* popup_window = FindWindowByName(name))
        if (popup_window->WasActive)
        {
            ImVec2 size_expected = CalcWindowExpectedSize(popup_window);
            if (flags & ImGuiComboFlags_PopupAlignLeft)
                popup_window->AutoPosLastDirection = ImGuiDir_Left;
            ImRect r_outer = GetWindowAllowedExtentRect(popup_window);
            ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);
            SetNextWindowPos(pos);
        }

    // Horizontally align ourselves with the framed text
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;
    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));
    bool ret = Begin(name, NULL, window_flags);
    PopStyleVar();
    if (!ret)
    {
        EndPopup();
        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
        return false;
    }
    return true;
}

void ImGui::EndCombo()
{
    EndPopup();
}

// Getter for the old Combo() API: const char*[]
static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
    const char* const* items = (const char* const*)data;
    if (out_text)
        *out_text = items[idx];
    return true;
}

// Getter for the old Combo() API: "item1\0item2\0item3\0"
static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)
{
    // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
    const char* items_separated_by_zeros = (const char*)data;
    int items_count = 0;
    const char* p = items_separated_by_zeros;
    while (*p)
    {
        if (idx == items_count)
            break;
        p += strlen(p) + 1;
        items_count++;
    }
    if (!*p)
        return false;
    if (out_text)
        *out_text = p;
    return true;
}

// Old API, prefer using BeginCombo() nowadays if you can.
bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)
{
    ImGuiContext& g = *GImGui;

    // Call the getter to obtain the preview string which is a parameter to BeginCombo()
    const char* preview_value = NULL;
    if (*current_item >= 0 && *current_item < items_count)
        items_getter(data, *current_item, &preview_value);

    // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
    if (popup_max_height_in_items != -1 && !g.NextWindowData.SizeConstraintCond)
        SetNextWindowSizeConstraints(ImVec2(0,0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
        return false;

    // Display items
    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
    bool value_changed = false;
    for (int i = 0; i < items_count; i++)
    {
        PushID((void*)(intptr_t)i);
        const bool item_selected = (i == *current_item);
        const char* item_text;
        if (!items_getter(data, i, &item_text))
            item_text = "*Unknown item*";
        if (Selectable(item_text, item_selected))
        {
            value_changed = true;
            *current_item = i;
        }
        if (item_selected)
            SetItemDefaultFocus();
        PopID();
    }

    EndCombo();
    return value_changed;
}

// Combo box helper allowing to pass an array of strings.
bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)
{
    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);
    return value_changed;
}

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"
bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
{
    int items_count = 0;
    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
    while (*p)
    {
        p += strlen(p) + 1;
        items_count++;
    }
    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);
    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - PatchFormatStringFloatToInt()
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyOpFromText()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat<>()
//-------------------------------------------------------------------------

struct ImGuiDataTypeInfo
{
    size_t      Size;
    const char* PrintFmt;   // Unused
    const char* ScanFmt;
};

static const ImGuiDataTypeInfo GDataTypeInfo[] =
{
    { sizeof(int),          "%d",   "%d"    },
    { sizeof(unsigned int), "%u",   "%u"    },
#ifdef _MSC_VER
    { sizeof(ImS64),        "%I64d","%I64d" },
    { sizeof(ImU64),        "%I64u","%I64u" },
#else
    { sizeof(ImS64),        "%lld", "%lld"  },
    { sizeof(ImU64),        "%llu", "%llu"  },
#endif
    { sizeof(float),        "%f",   "%f"    },  // float are promoted to double in va_arg
    { sizeof(double),       "%f",   "%lf"   },
};
IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);

// FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats and because of this the compile-time default value for format was "%.0f".
// Even though we changed the compile-time default, we expect users to have carried %f around, which would break the display of DragInt() calls.
// To honor backward compatibility we are rewriting the format string, unless IMGUI_DISABLE_OBSOLETE_FUNCTIONS is enabled. What could possibly go wrong?!
static const char* PatchFormatStringFloatToInt(const char* fmt)
{
    if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.
        return "%d";
    const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).
    if (fmt_end > fmt_start && fmt_end[-1] == 'f')
    {
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        if (fmt_start == fmt && fmt_end[0] == 0)
            return "%d";
        ImGuiContext& g = *GImGui;
        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%.*s%%d%s", (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.
        return g.TempBuffer;
#else
        IM_ASSERT(0 && "DragInt(): Invalid format string!"); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"
#endif
    }
    return fmt;
}

static inline int DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format)
{
    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)   // Signedness doesn't matter when pushing the argument
        return ImFormatString(buf, buf_size, format, *(const ImU32*)data_ptr);
    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)   // Signedness doesn't matter when pushing the argument
        return ImFormatString(buf, buf_size, format, *(const ImU64*)data_ptr);
    if (data_type == ImGuiDataType_Float)
        return ImFormatString(buf, buf_size, format, *(const float*)data_ptr);
    if (data_type == ImGuiDataType_Double)
        return ImFormatString(buf, buf_size, format, *(const double*)data_ptr);
    IM_ASSERT(0);
    return 0;
}

// FIXME: Adding support for clamping on boundaries of the data type would be nice.
static void DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2)
{
    IM_ASSERT(op == '+' || op == '-');
    switch (data_type)
    {
        case ImGuiDataType_S32:
            if (op == '+')      *(int*)output = *(const int*)arg1 + *(const int*)arg2;
            else if (op == '-') *(int*)output = *(const int*)arg1 - *(const int*)arg2;
            return;
        case ImGuiDataType_U32:
            if (op == '+')      *(unsigned int*)output = *(const unsigned int*)arg1 + *(const ImU32*)arg2;
            else if (op == '-') *(unsigned int*)output = *(const unsigned int*)arg1 - *(const ImU32*)arg2;
            return;
        case ImGuiDataType_S64:
            if (op == '+')      *(ImS64*)output = *(const ImS64*)arg1 + *(const ImS64*)arg2;
            else if (op == '-') *(ImS64*)output = *(const ImS64*)arg1 - *(const ImS64*)arg2;
            return;
        case ImGuiDataType_U64:
            if (op == '+')      *(ImU64*)output = *(const ImU64*)arg1 + *(const ImU64*)arg2;
            else if (op == '-') *(ImU64*)output = *(const ImU64*)arg1 - *(const ImU64*)arg2;
            return;
        case ImGuiDataType_Float:
            if (op == '+')      *(float*)output = *(const float*)arg1 + *(const float*)arg2;
            else if (op == '-') *(float*)output = *(const float*)arg1 - *(const float*)arg2;
            return;
        case ImGuiDataType_Double:
            if (op == '+')      *(double*)output = *(const double*)arg1 + *(const double*)arg2;
            else if (op == '-') *(double*)output = *(const double*)arg1 - *(const double*)arg2;
            return;
        case ImGuiDataType_COUNT: break;
    }
    IM_ASSERT(0);
}

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
static bool DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format)
{
    while (ImCharIsBlankA(*buf))
        buf++;

    // We don't support '-' op because it would conflict with inputing negative value.
    // Instead you can use +-100 to subtract from an existing value
    char op = buf[0];
    if (op == '+' || op == '*' || op == '/')
    {
        buf++;
        while (ImCharIsBlankA(*buf))
            buf++;
    }
    else
    {
        op = 0;
    }
    if (!buf[0])
        return false;

    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
    IM_ASSERT(data_type < ImGuiDataType_COUNT);
    int data_backup[2];
    IM_ASSERT(GDataTypeInfo[data_type].Size <= sizeof(data_backup));
    memcpy(data_backup, data_ptr, GDataTypeInfo[data_type].Size);

    if (format == NULL)
        format = GDataTypeInfo[data_type].ScanFmt;

    int arg1i = 0;
    if (data_type == ImGuiDataType_S32)
    {
        int* v = (int*)data_ptr;
        int arg0i = *v;
        float arg1f = 0.0f;
        if (op && sscanf(initial_value_buf, format, &arg0i) < 1)
            return false;
        // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
        if (op == '+')      { if (sscanf(buf, "%d", &arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use "+-" to subtract)
        else if (op == '*') { if (sscanf(buf, "%f", &arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply
        else if (op == '/') { if (sscanf(buf, "%f", &arg1f) && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide
        else                { if (sscanf(buf, format, &arg1i) == 1) *v = arg1i; }                           // Assign constant
    }
    else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)
    {
        // Assign constant
        // FIXME: We don't bother handling support for legacy operators since they are a little too crappy. Instead we may implement a proper expression evaluator in the future.
        sscanf(buf, format, data_ptr);
    }
    else if (data_type == ImGuiDataType_Float)
    {
        // For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
        format = "%f";
        float* v = (float*)data_ptr;
        float arg0f = *v, arg1f = 0.0f;
        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)
            return false;
        if (sscanf(buf, format, &arg1f) < 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    else if (data_type == ImGuiDataType_Double)
    {
        format = "%lf"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis
        double* v = (double*)data_ptr;
        double arg0f = *v, arg1f = 0.0;
        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)
            return false;
        if (sscanf(buf, format, &arg1f) < 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    return memcmp(data_backup, data_ptr, GDataTypeInfo[data_type].Size) != 0;
}

static float GetMinimumStepAtDecimalPrecision(int decimal_precision)
{
    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
    if (decimal_precision < 0)
        return FLT_MIN;
    return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);
}

template<typename TYPE>
static const char* ImAtoi(const char* src, TYPE* output)
{
    int negative = 0;
    if (*src == '-') { negative = 1; src++; }
    if (*src == '+') { src++; }
    TYPE v = 0;
    while (*src >= '0' && *src <= '9')
        v = (v * 10) + (*src++ - '0');
    *output = negative ? -v : v;
    return src;
}

template<typename TYPE, typename SIGNEDTYPE>
TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
{
    const char* fmt_start = ImParseFormatFindStart(format);
    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
        return v;
    char v_str[64];
    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
    const char* p = v_str;
    while (*p == ' ')
        p++;
    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)
        v = (TYPE)ImAtof(p);
    else
        ImAtoi(p, (SIGNEDTYPE*)&v);
    return v;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
//-------------------------------------------------------------------------
// - DragBehaviorT<>() [Internal]
// - DragBehavior() [Internal]
// - DragScalar()
// - DragScalarN()
// - DragFloat()
// - DragFloat2()
// - DragFloat3()
// - DragFloat4()
// - DragFloatRange2()
// - DragInt()
// - DragInt2()
// - DragInt3()
// - DragInt4()
// - DragIntRange2()
//-------------------------------------------------------------------------

// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiDragFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    const bool has_min_max = (v_min != v_max);
    const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));

    // Default tweak speed
    if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))
        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    float adjust_delta = 0.0f;
    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)
    {
        adjust_delta = g.IO.MouseDelta[axis];
        if (g.IO.KeyAlt)
            adjust_delta *= 1.0f / 100.0f;
        if (g.IO.KeyShift)
            adjust_delta *= 10.0f;
    }
    else if (g.ActiveIdSource == ImGuiInputSource_Nav)
    {
        int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;
        adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];
        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
    }
    adjust_delta *= v_speed;

    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    if (axis == ImGuiAxis_Y)
        adjust_delta = -adjust_delta;

    // Clear current value on activation
    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    bool is_just_activated = g.ActiveIdIsJustActivated;
    bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));
    if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)
    {
        g.DragCurrentAccum = 0.0f;
        g.DragCurrentAccumDirty = false;
    }
    else if (adjust_delta != 0.0f)
    {
        g.DragCurrentAccum += adjust_delta;
        g.DragCurrentAccumDirty = true;
    }

    if (!g.DragCurrentAccumDirty)
        return false;

    TYPE v_cur = *v;
    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

    if (is_power)
    {
        // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
        FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);
        FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));
        v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);
        v_old_ref_for_accum_remainder = v_old_norm_curved;
    }
    else
    {
        v_cur += (TYPE)g.DragCurrentAccum;
    }

    // Round to user desired precision based on format string
    v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    g.DragCurrentAccumDirty = false;
    if (is_power)
    {
        FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);
        g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);
    }
    else
    {
        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    }

    // Lose zero sign for float/double
    if (v_cur == (TYPE)-0)
        v_cur = (TYPE)0;

    // Clamp values (+ handle overflow/wrap-around for integer types)
    if (*v != v_cur && has_min_max)
    {
        if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))
            v_cur = v_min;
        if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))
            v_cur = v_max;
    }

    // Apply result
    if (*v == v_cur)
        return false;
    *v = v_cur;
    return true;
}

bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
    {
        if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])
            ClearActiveID();
        else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
            ClearActiveID();
    }
    if (g.ActiveId != id)
        return false;

    switch (data_type)
    {
    case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)v,  v_speed, v_min ? *(const ImS32* )v_min : IM_S32_MIN, v_max ? *(const ImS32* )v_max : IM_S32_MAX, format, power, flags);
    case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)v,  v_speed, v_min ? *(const ImU32* )v_min : IM_U32_MIN, v_max ? *(const ImU32* )v_max : IM_U32_MAX, format, power, flags);
    case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)v,  v_speed, v_min ? *(const ImS64* )v_min : IM_S64_MIN, v_max ? *(const ImS64* )v_max : IM_S64_MAX, format, power, flags);
    case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)v,  v_speed, v_min ? *(const ImU64* )v_min : IM_U64_MIN, v_max ? *(const ImU64* )v_max : IM_U64_MAX, format, power, flags);
    case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)v,  v_speed, v_min ? *(const float* )v_min : -FLT_MAX,   v_max ? *(const float* )v_max : FLT_MAX,    format, power, flags);
    case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)v, v_speed, v_min ? *(const double*)v_min : -DBL_MAX,   v_max ? *(const double*)v_max : DBL_MAX,    format, power, flags);
    case ImGuiDataType_COUNT:  break;
    }
    IM_ASSERT(0);
    return false;
}

bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    if (power != 1.0f)
        IM_ASSERT(v_min != NULL && v_max != NULL); // When using a power curve the drag needs to have known bounds

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb))
        return false;

    const bool hovered = ItemHoverable(frame_bb, id);

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    // Tabbing or CTRL-clicking on Drag turns it into an input box
    bool start_text_input = false;
    const bool tab_focus_requested = FocusableItemRegister(window, id);
    if (tab_focus_requested || (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        if (tab_focus_requested || g.IO.KeyCtrl || g.IO.MouseDoubleClicked[0] || g.NavInputId == id)
        {
            start_text_input = true;
            g.ScalarAsInputTextId = 0;
        }
    }
    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
    {
        window->DC.CursorPos = frame_bb.Min;
        FocusableItemUnregister(window);
        return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);
    }

    // Actual drag behavior
    const bool value_changed = DragBehavior(id, data_type, v, v_speed, v_min, v_max, format, power, ImGuiDragFlags_None);
    if (value_changed)
        MarkItemEdited(id);

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
    return value_changed;
}

bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= DragScalar("", data_type, v, v_speed, v_min, v_max, format, power);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2);

    bool value_changed = DragFloat("##min", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format, power);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |= DragFloat("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, format_max ? format_max : format, power);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();
    return value_changed;
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2);

    bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, format_max ? format_max : format);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();

    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - SliderBehaviorT<>() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()
//-------------------------------------------------------------------------

template<typename TYPE, typename FLOATTYPE>
float ImGui::SliderCalcRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, float power, float linear_zero_pos)
{
    if (v_min == v_max)
        return 0.0f;

    const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    if (is_power)
    {
        if (v_clamped < 0.0f)
        {
            const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));
            return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;
        }
        else
        {
            const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));
            return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);
        }
    }

    // Linear slider
    return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));
}

// FIXME: Move some of the code into SliderBehavior(). Current responsability is larger than what the equivalent DragBehaviorT<> does, we also do some rendering, etc.
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    const bool is_power = (power != 1.0f) && is_decimal;

    const float grab_padding = 2.0f;
    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    float grab_sz = style.GrabMinSize;
    SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);
    if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows
        grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit
    grab_sz = ImMin(grab_sz, slider_sz);
    const float slider_usable_sz = slider_sz - grab_sz;
    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz*0.5f;
    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz*0.5f;

    // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
    float linear_zero_pos;   // 0.0->1.0f
    if (is_power && v_min * v_max < 0.0f)
    {
        // Different sign
        const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f/power);
        const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f/power);
        linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));
    }
    else
    {
        // Same sign
        linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;
    }

    // Process interacting with the slider
    bool value_changed = false;
    if (g.ActiveId == id)
    {
        bool set_new_value = false;
        float clicked_t = 0.0f;
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (!g.IO.MouseDown[0])
            {
                ClearActiveID();
            }
            else
            {
                const float mouse_abs_pos = g.IO.MousePos[axis];
                clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;
                if (axis == ImGuiAxis_Y)
                    clicked_t = 1.0f - clicked_t;
                set_new_value = true;
            }
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
        {
            const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);
            float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;
            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
            {
                ClearActiveID();
            }
            else if (delta != 0.0f)
            {
                clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);
                const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;
                if ((decimal_precision > 0) || is_power)
                {
                    delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds
                    if (IsNavInputDown(ImGuiNavInput_TweakSlow))
                        delta /= 10.0f;
                }
                else
                {
                    if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))
                        delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps
                    else
                        delta /= 100.0f;
                }
                if (IsNavInputDown(ImGuiNavInput_TweakFast))
                    delta *= 10.0f;
                set_new_value = true;
                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
                    set_new_value = false;
                else
                    clicked_t = ImSaturate(clicked_t + delta);
            }
        }

        if (set_new_value)
        {
            TYPE v_new;
            if (is_power)
            {
                // Account for power curve scale on both sides of the zero
                if (clicked_t < linear_zero_pos)
                {
                    // Negative: rescale to the negative range before powering
                    float a = 1.0f - (clicked_t / linear_zero_pos);
                    a = ImPow(a, power);
                    v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);
                }
                else
                {
                    // Positive: rescale to the positive range before powering
                    float a;
                    if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)
                        a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);
                    else
                        a = clicked_t;
                    a = ImPow(a, power);
                    v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);
                }
            }
            else
            {
                // Linear slider
                if (is_decimal)
                {
                    v_new = ImLerp(v_min, v_max, clicked_t);
                }
                else
                {
                    // For integer values we want the clicking position to match the grab box so we round above
                    // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
                    FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;
                    TYPE v_new_off_floor = (TYPE)(v_new_off_f);
                    TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);
                    if (!is_decimal && v_new_off_floor < v_new_off_round)
                        v_new = v_min + v_new_off_round;
                    else
                        v_new = v_min + v_new_off_floor;
                }
            }

            // Round to user desired precision based on format string
            v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

            // Apply result
            if (*v != v_new)
            {
                *v = v_new;
                value_changed = true;
            }
        }
    }

    // Output grab position so it can be displayed by the caller
    float grab_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);
    if (axis == ImGuiAxis_Y)
        grab_t = 1.0f - grab_t;
    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    if (axis == ImGuiAxis_X)
        *out_grab_bb = ImRect(grab_pos - grab_sz*0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz*0.5f, bb.Max.y - grab_padding);
    else
        *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f);

    return value_changed;
}

// For 32-bits and larger types, slider bounds are limited to half the natural type range.
// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
bool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)
{
    switch (data_type)
    {
    case ImGuiDataType_S32:
        IM_ASSERT(*(const ImS32*)v_min >= IM_S32_MIN/2 && *(const ImS32*)v_max <= IM_S32_MAX/2);
        return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)v,  *(const ImS32*)v_min,  *(const ImS32*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_U32:
        IM_ASSERT(*(const ImU32*)v_min <= IM_U32_MAX/2);
        return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)v,  *(const ImU32*)v_min,  *(const ImU32*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_S64:
        IM_ASSERT(*(const ImS64*)v_min >= IM_S64_MIN/2 && *(const ImS64*)v_max <= IM_S64_MAX/2);
        return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)v,  *(const ImS64*)v_min,  *(const ImS64*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_U64:
        IM_ASSERT(*(const ImU64*)v_min <= IM_U64_MAX/2);
        return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)v,  *(const ImU64*)v_min,  *(const ImU64*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_Float:
        IM_ASSERT(*(const float*)v_min >= -FLT_MAX/2.0f && *(const float*)v_max <= FLT_MAX/2.0f);
        return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)v,  *(const float*)v_min,  *(const float*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_Double:
        IM_ASSERT(*(const double*)v_min >= -DBL_MAX/2.0f && *(const double*)v_max <= DBL_MAX/2.0f);
        return SliderBehaviorT<double,double,double>(bb, id, data_type, (double*)v, *(const double*)v_min, *(const double*)v_max, format, power, flags, out_grab_bb);
    case ImGuiDataType_COUNT: break;
    }
    IM_ASSERT(0);
    return false;
}

bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb))
        return false;

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    // Tabbing or CTRL-clicking on Slider turns it into an input box
    bool start_text_input = false;
    const bool tab_focus_requested = FocusableItemRegister(window, id);
    const bool hovered = ItemHoverable(frame_bb, id);
    if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)
        {
            start_text_input = true;
            g.ScalarAsInputTextId = 0;
        }
    }
    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
    {
        window->DC.CursorPos = frame_bb.Min;
        FocusableItemUnregister(window);
        return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);
    }

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_None, &grab_bb);
    if (value_changed)
        MarkItemEdited(id);

    // Render grab
    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
    return value_changed;
}

// Add multiple sliders on 1 line for compact edition of multiple components
bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, power);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power)
{
    return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power);
}

bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format)
{
    if (format == NULL)
        format = "%.0f deg";
    float v_deg = (*v_rad) * 360.0f / (2*IM_PI);
    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, 1.0f);
    *v_rad = v_deg * (2*IM_PI) / 360.0f;
    return value_changed;
}

bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format)
{
    return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format);
}

bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format);
}

bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format);
}

bool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(frame_bb, id))
        return false;

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    const bool hovered = ItemHoverable(frame_bb, id);
    if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    }

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb);
    if (value_changed)
        MarkItemEdited(id);

    // Render grab
    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    // For the vertical slider we allow centered text to overlap the frame padding
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));
    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    return value_changed;
}

bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, float power)
{
    return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power);
}

bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format)
{
    return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
//-------------------------------------------------------------------------
// - ImParseFormatFindStart() [Internal]
// - ImParseFormatFindEnd() [Internal]
// - ImParseFormatTrimDecorations() [Internal]
// - ImParseFormatPrecision() [Internal]
// - InputScalarAsWidgetReplacement() [Internal]
// - InputScalar()
// - InputScalarN()
// - InputFloat()
// - InputFloat2()
// - InputFloat3()
// - InputFloat4()
// - InputInt()
// - InputInt2()
// - InputInt3()
// - InputInt4()
// - InputDouble()
//-------------------------------------------------------------------------

// We don't use strchr() because our strings are usually very short and often start with '%'
const char* ImParseFormatFindStart(const char* fmt)
{
    while (char c = fmt[0])
    {
        if (c == '%' && fmt[1] != '%')
            return fmt;
        else if (c == '%')
            fmt++;
        fmt++;
    }
    return fmt;
}

const char* ImParseFormatFindEnd(const char* fmt)
{
    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
    if (fmt[0] != '%')
        return fmt;
    const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));
    const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));
    for (char c; (c = *fmt) != 0; fmt++)
    {
        if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)
            return fmt + 1;
        if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)
            return fmt + 1;
    }
    return fmt;
}

// Extract the format out of a format string with leading or trailing decorations
//  fmt = "blah blah"  -> return fmt
//  fmt = "%.3f"       -> return fmt
//  fmt = "hello %.3f" -> return fmt + 6
//  fmt = "%.3f hello" -> return buf written with "%.3f"
const char* ImParseFormatTrimDecorations(const char* fmt, char* buf, size_t buf_size)
{
    const char* fmt_start = ImParseFormatFindStart(fmt);
    if (fmt_start[0] != '%')
        return fmt;
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);
    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.
        return fmt_start;
    ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));
    return buf;
}

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
int ImParseFormatPrecision(const char* fmt, int default_precision)
{
    fmt = ImParseFormatFindStart(fmt);
    if (fmt[0] != '%')
        return default_precision;
    fmt++;
    while (*fmt >= '0' && *fmt <= '9')
        fmt++;
    int precision = INT_MAX;
    if (*fmt == '.')
    {
        fmt = ImAtoi<int>(fmt + 1, &precision);
        if (precision < 0 || precision > 99)
            precision = default_precision;
    }
    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
        precision = -1;
    if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)
        precision = -1;
    return (precision == INT_MAX) ? default_precision : precision;
}

// Create text input in place of an active drag/slider (used when doing a CTRL+Click on drag/slider widgets)
// FIXME: Facilitate using this in variety of other situations.
bool ImGui::InputScalarAsWidgetReplacement(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format)
{
    IM_UNUSED(id);
    ImGuiContext& g = *GImGui;

    // On the first frame, g.ScalarAsInputTextId == 0, then on subsequent frames it becomes == id.
    // We clear ActiveID on the first frame to allow the InputText() taking it back.
    if (g.ScalarAsInputTextId == 0)
        ClearActiveID();

    char fmt_buf[32];
    char data_buf[32];
    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));
    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, data_ptr, format);
    ImStrTrimBlanks(data_buf);
    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);
    bool value_changed = InputTextEx(label, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);
    if (g.ScalarAsInputTextId == 0)
    {
        // First frame we started displaying the InputText widget, we expect it to take the active id.
        IM_ASSERT(g.ActiveId == id);
        g.ScalarAsInputTextId = g.ActiveId;
    }
    if (value_changed)
        return DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, NULL);
    return false;
}

bool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* data_ptr, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;

    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;

    char buf[64];
    DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, data_ptr, format);

    bool value_changed = false;
    if ((flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)
        flags |= ImGuiInputTextFlags_CharsDecimal;
    flags |= ImGuiInputTextFlags_AutoSelectAll;

    if (step != NULL)
    {
        const float button_size = GetFrameHeight();

        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
        PushID(label);
        PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
        if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, format);
        PopItemWidth();

        // Step buttons
        const ImVec2 backup_frame_padding = style.FramePadding;
        style.FramePadding.x = style.FramePadding.y;
        ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;
        if (flags & ImGuiInputTextFlags_ReadOnly)
            button_flags |= ImGuiButtonFlags_Disabled;
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))
        {
            DataTypeApplyOp(data_type, '-', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);
            value_changed = true;
        }
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))
        {
            DataTypeApplyOp(data_type, '+', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);
            value_changed = true;
        }
        SameLine(0, style.ItemInnerSpacing.x);
        TextUnformatted(label, FindRenderedTextEnd(label));
        style.FramePadding = backup_frame_padding;

        PopID();
        EndGroup();
    }
    else
    {
        if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, format);
    }

    return value_changed;
}

bool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= InputScalar("", data_type, v, step, step_fast, format, flags);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags)
{
    flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), format, flags);
}

bool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);
}

// Prefer using "const char* format" directly, which is more flexible and consistent with other API.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputFloat(label, v, step, step_fast, format, flags);
}

bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags)
{
    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
    const char* format = (flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step>0 ? &step : NULL), (void*)(step_fast>0 ? &step_fast : NULL), format, flags);
}

bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", flags);
}

bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", flags);
}

bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", flags);
}

bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags)
{
    flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step>0.0 ? &step : NULL), (void*)(step_fast>0.0 ? &step_fast : NULL), format, flags);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputText, InputTextMultiline
//-------------------------------------------------------------------------
// - InputText()
// - InputTextMultiline()
// - InputTextEx() [Internal]
//-------------------------------------------------------------------------

bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
    return InputTextEx(label, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);
}

bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);
}

static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)
{
    int line_count = 0;
    const char* s = text_begin;
    while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding
        if (c == '\n')
            line_count++;
    s--;
    if (s[0] != '\n' && s[0] != '\r')
        line_count++;
    *out_text_end = s;
    return line_count;
}

static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)
{
    ImGuiContext& g = *GImGui;
    ImFont* font = g.Font;
    const float line_height = g.FontSize;
    const float scale = line_height / font->FontSize;

    ImVec2 text_size = ImVec2(0,0);
    float line_width = 0.0f;

    const ImWchar* s = text_begin;
    while (s < text_end)
    {
        unsigned int c = (unsigned int)(*s++);
        if (c == '\n')
        {
            text_size.x = ImMax(text_size.x, line_width);
            text_size.y += line_height;
            line_width = 0.0f;
            if (stop_on_new_line)
                break;
            continue;
        }
        if (c == '\r')
            continue;

        const float char_width = font->GetCharAdvance((ImWchar)c) * scale;
        line_width += char_width;
    }

    if (text_size.x < line_width)
        text_size.x = line_width;

    if (out_offset)
        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n
        text_size.y += line_height;

    if (remaining)
        *remaining = s;

    return text_size;
}

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
namespace ImStb
{

static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }
static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }
static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }
static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }
static ImWchar STB_TEXTEDIT_NEWLINE = '\n';
static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)
{
    const ImWchar* text = obj->TextW.Data;
    const ImWchar* text_remaining = NULL;
    const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);
    r->x0 = 0.0f;
    r->x1 = size.x;
    r->baseline_y_delta = size.y;
    r->ymin = 0.0f;
    r->ymax = size.y;
    r->num_chars = (int)(text_remaining - (text + line_start_idx));
}

static bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }
static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->TextW[idx-1] ) && !is_separator( obj->TextW[idx] ) ) : 1; }
static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }
#ifdef __APPLE__    // FIXME: Move setting to IO structure
static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->TextW[idx-1] ) && is_separator( obj->TextW[idx] ) ) : 1; }
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }
#else
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }
#endif
#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h
#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)
{
    ImWchar* dst = obj->TextW.Data + pos;

    // We maintain our buffer length in both UTF-8 and wchar formats
    obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);
    obj->CurLenW -= n;

    // Offset remaining text (FIXME-OPT: Use memmove)
    const ImWchar* src = obj->TextW.Data + pos + n;
    while (ImWchar c = *src++)
        *dst++ = c;
    *dst = '\0';
}

static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)
{
    const bool is_resizable = (obj->UserFlags & ImGuiInputTextFlags_CallbackResize) != 0;
    const int text_len = obj->CurLenW;
    IM_ASSERT(pos <= text_len);

    const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);
    if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))
        return false;

    // Grow internal buffer if needed
    if (new_text_len + text_len + 1 > obj->TextW.Size)
    {
        if (!is_resizable)
            return false;
        IM_ASSERT(text_len < obj->TextW.Size);
        obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);
    }

    ImWchar* text = obj->TextW.Data;
    if (pos != text_len)
        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));
    memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

    obj->CurLenW += new_text_len;
    obj->CurLenA += new_text_len_utf8;
    obj->TextW[obj->CurLenW] = '\0';

    return true;
}

// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT         0x10000 // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT        0x10001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP           0x10002 // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN         0x10003 // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART    0x10004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND      0x10005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART    0x10006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND      0x10007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE       0x10008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE    0x10009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO         0x1000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO         0x1000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT     0x1000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT    0x1000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_SHIFT        0x20000

#define STB_TEXTEDIT_IMPLEMENTATION
#include "imstb_textedit.h"

}

void ImGuiInputTextState::OnKeyPressed(int key)
{
    stb_textedit_key(this, &Stb, key);
    CursorFollow = true;
    CursorAnimReset();
}

ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()
{
    memset(this, 0, sizeof(*this));
}

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)
{
    IM_ASSERT(pos + bytes_count <= BufTextLen);
    char* dst = Buf + pos;
    const char* src = Buf + pos + bytes_count;
    while (char c = *src++)
        *dst++ = c;
    *dst = '\0';

    if (CursorPos + bytes_count >= pos)
        CursorPos -= bytes_count;
    else if (CursorPos >= pos)
        CursorPos = pos;
    SelectionStart = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen -= bytes_count;
}

void ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)
{
    const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;
    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
    if (new_text_len + BufTextLen >= BufSize)
    {
        if (!is_resizable)
            return;

        // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the midly similar code (until we remove the U16 buffer alltogether!)
        ImGuiContext& g = *GImGui;
        ImGuiInputTextState* edit_state = &g.InputTextState;
        IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);
        IM_ASSERT(Buf == edit_state->TextA.Data);
        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;
        edit_state->TextA.reserve(new_buf_size + 1);
        Buf = edit_state->TextA.Data;
        BufSize = edit_state->BufCapacityA = new_buf_size;
    }

    if (BufTextLen != pos)
        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
    Buf[BufTextLen + new_text_len] = '\0';

    if (CursorPos >= pos)
        CursorPos += new_text_len;
    SelectionStart = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen += new_text_len;
}

// Return false to discard a character.
static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    unsigned int c = *p_char;

    if (c < 128 && c != ' ' && !isprint((int)(c & 0xFF)))
    {
        bool pass = false;
        pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));
        pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));
        if (!pass)
            return false;
    }

    if (c >= 0xE000 && c <= 0xF8FF) // Filter private Unicode range. I don't imagine anybody would want to input them. GLFW on OSX seems to send private characters for special keys like arrow keys.
        return false;

    if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))
    {
        if (flags & ImGuiInputTextFlags_CharsDecimal)
            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsScientific)
            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsHexadecimal)
            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsUppercase)
            if (c >= 'a' && c <= 'z')
                *p_char = (c += (unsigned int)('A'-'a'));

        if (flags & ImGuiInputTextFlags_CharsNoBlank)
            if (ImCharIsBlankW(c))
                return false;
    }

    if (flags & ImGuiInputTextFlags_CallbackCharFilter)
    {
        ImGuiInputTextCallbackData callback_data;
        memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));
        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
        callback_data.EventChar = (ImWchar)c;
        callback_data.Flags = flags;
        callback_data.UserData = user_data;
        if (callback(&callback_data) != 0)
            return false;
        *p_char = callback_data.EventChar;
        if (!callback_data.EventChar)
            return false;
    }

    return true;
}

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match
//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h
// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are
//  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
bool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)
    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)

    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;
    const ImGuiStyle& style = g.Style;

    const bool RENDER_SELECTION_WHEN_INACTIVE = true;
    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;
    const bool is_readonly = (flags & ImGuiInputTextFlags_ReadOnly) != 0;
    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;
    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;
    const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;
    if (is_resizable)
        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!

    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope,
        BeginGroup();
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

    ImGuiWindow* draw_window = window;
    if (is_multiline)
    {
        if (!ItemAdd(total_bb, id, &frame_bb))
        {
            ItemSize(total_bb, style.FramePadding.y);
            EndGroup();
            return false;
        }
        if (!BeginChildFrame(id, frame_bb.GetSize()))
        {
            EndChildFrame();
            EndGroup();
            return false;
        }
        draw_window = GetCurrentWindow();
        draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight
        size.x -= draw_window->ScrollbarSizes.x;
    }
    else
    {
        ItemSize(total_bb, style.FramePadding.y);
        if (!ItemAdd(total_bb, id, &frame_bb))
            return false;
    }
    const bool hovered = ItemHoverable(frame_bb, id);
    if (hovered)
        g.MouseCursor = ImGuiMouseCursor_TextInput;

    // Password pushes a temporary font with only a fallback glyph
    if (is_password)
    {
        const ImFontGlyph* glyph = g.Font->FindGlyph('*');
        ImFont* password_font = &g.InputTextPasswordFont;
        password_font->FontSize = g.Font->FontSize;
        password_font->Scale = g.Font->Scale;
        password_font->DisplayOffset = g.Font->DisplayOffset;
        password_font->Ascent = g.Font->Ascent;
        password_font->Descent = g.Font->Descent;
        password_font->ContainerAtlas = g.Font->ContainerAtlas;
        password_font->FallbackGlyph = glyph;
        password_font->FallbackAdvanceX = glyph->AdvanceX;
        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
        PushFont(password_font);
    }

    // NB: we are only allowed to access 'edit_state' if we are the active widget.
    ImGuiInputTextState* state = NULL;
    if (g.InputTextState.ID == id)
        state = &g.InputTextState;

    const bool focus_requested = FocusableItemRegister(window, id, (flags & (ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_AllowTabInput)) == 0);    // Using completion callback disable keyboard tabbing
    const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);
    const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

    const bool user_clicked = hovered && io.MouseClicked[0];
    const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));
    const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetScrollbarID(draw_window, ImGuiAxis_Y);
    const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetScrollbarID(draw_window, ImGuiAxis_Y);

    bool clear_active_id = false;
    bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);

    const bool init_make_active = (focus_requested || user_clicked || user_scroll_finish || user_nav_input_start);
    if (init_make_active && g.ActiveId != id)
    {
        // Access state even if we don't own it yet.
        state = &g.InputTextState;
        state->CursorAnimReset();

        // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
        // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
        const int buf_len = (int)strlen(buf);
        state->InitialTextA.resize(buf_len + 1);    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.
        memcpy(state->InitialTextA.Data, buf, buf_len + 1);

        // Start edition
        const int prev_len_w = state->CurLenW;
        const char* buf_end = NULL;
        state->TextW.resize(buf_size + 1);          // wchar count <= UTF-8 count. we use +1 to make sure that .Data is always pointing to at least an empty string.
        state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, buf_size, buf, NULL, &buf_end);
        state->CurLenA = (int)(buf_end - buf);      // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.

        // Preserve cursor position and undo/redo stack if we come back to same widget
        // FIXME: We should probably compare the whole buffer to be on the safety side. Comparing buf (utf8) and edit_state.Text (wchar).
        const bool recycle_state = (state->ID == id) && (prev_len_w == state->CurLenW);
        if (recycle_state)
        {
            // Recycle existing cursor/selection/undo stack but clamp position
            // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
            state->CursorClamp();
        }
        else
        {
            state->ID = id;
            state->ScrollX = 0.0f;
            stb_textedit_initialize_state(&state->Stb, !is_multiline);
            if (!is_multiline && focus_requested_by_code)
                select_all = true;
        }
        if (flags & ImGuiInputTextFlags_AlwaysInsertMode)
            state->Stb.insert_mode = 1;
        if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))
            select_all = true;
    }

    if (init_make_active)
    {
        IM_ASSERT(state && state->ID == id);
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdBlockNavInputFlags = (1 << ImGuiNavInput_Cancel);
        if (!is_multiline && !(flags & ImGuiInputTextFlags_CallbackHistory))
            g.ActiveIdAllowNavDirFlags = ((1 << ImGuiDir_Up) | (1 << ImGuiDir_Down));
    }

    // Release focus when we click outside
    if (!init_make_active && io.MouseClicked[0])
        clear_active_id = true;

    // We have an edge case if ActiveId was set through another widget (e.g. widget being swapped)
    if (g.ActiveId == id && state == NULL)
        ClearActiveID();

    bool value_changed = false;
    bool enter_pressed = false;
    int backup_current_text_length = 0;

    // Process mouse inputs and character inputs
    if (g.ActiveId == id)
    {
        IM_ASSERT(state != NULL);
        if (is_readonly && !g.ActiveIdIsJustActivated)
        {
            // When read-only we always use the live data passed to the function
            const char* buf_end = NULL;
            state->TextW.resize(buf_size+1);
            state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, buf, NULL, &buf_end);
            state->CurLenA = (int)(buf_end - buf);
            state->CursorClamp();
        }

        backup_current_text_length = state->CurLenA;
        state->BufCapacityA = buf_size;
        state->UserFlags = flags;
        state->UserCallback = callback;
        state->UserCallbackData = callback_user_data;

        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
        // Down the line we should have a cleaner library-wide concept of Selected vs Active.
        g.ActiveIdAllowOverlap = !io.MouseDown[0];
        g.WantTextInputNextFrame = 1;

        // Edit in progress
        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state->ScrollX;
        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));

        const bool is_osx = io.ConfigMacOSXBehaviors;
        if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))
        {
            state->SelectAll();
            state->SelectedAllMouseLock = true;
        }
        else if (hovered && is_osx && io.MouseDoubleClicked[0])
        {
            // Double-click select a word only, OS X style (by simulating keystrokes)
            state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);
            state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
        }
        else if (io.MouseClicked[0] && !state->SelectedAllMouseLock)
        {
            if (hovered)
            {
                stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);
                state->CursorAnimReset();
            }
        }
        else if (io.MouseDown[0] && !state->SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))
        {
            stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);
            state->CursorAnimReset();
            state->CursorFollow = true;
        }
        if (state->SelectedAllMouseLock && !io.MouseDown[0])
            state->SelectedAllMouseLock = false;

        if (io.InputQueueCharacters.Size > 0)
        {
            // Process text input (before we check for Return because using some IME will effectively send a Return?)
            // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
            bool ignore_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);
            if (!ignore_inputs && !is_readonly && !user_nav_input_start)
                for (int n = 0; n < io.InputQueueCharacters.Size; n++)
                {
                    // Insert character if they pass filtering
                    unsigned int c = (unsigned int)io.InputQueueCharacters[n];
                    if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                        state->OnKeyPressed((int)c);
                }

            // Consume characters
            io.InputQueueCharacters.resize(0);
        }
    }

    // Process other shortcuts/key-presses
    bool cancel_edit = false;
    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)
    {
        IM_ASSERT(state != NULL);
        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
        const bool is_osx = io.ConfigMacOSXBehaviors;
        const bool is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl
        const bool is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift && !io.KeyCtrl && !io.KeyAlt;
        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl
        const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End
        const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;
        const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;

        const bool is_cut   = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());
        const bool is_copy  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only  && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || state->HasSelection());
        const bool is_paste = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && !is_readonly;
        const bool is_undo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Z)) && !is_readonly && is_undoable);
        const bool is_redo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut && IsKeyPressedMap(ImGuiKey_Z))) && !is_readonly && is_undoable;

        if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Home))                        { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_End))                         { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Delete) && !is_readonly)      { state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Backspace) && !is_readonly)
        {
            if (!state->HasSelection())
            {
                if (is_wordmove_key_down) 
                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);
                else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl) 
                    state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);
            }
            state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
        }
        else if (IsKeyPressedMap(ImGuiKey_Enter))
        {
            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;
            if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))
            {
                enter_pressed = clear_active_id = true;
            }
            else if (!is_readonly)
            {
                unsigned int c = '\n'; // Insert new line
                if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                    state->OnKeyPressed((int)c);
            }
        }
        else if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !is_readonly)
        {
            unsigned int c = '\t'; // Insert TAB
            if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                state->OnKeyPressed((int)c);
        }
        else if (IsKeyPressedMap(ImGuiKey_Escape))
        {
            clear_active_id = cancel_edit = true;
        }
        else if (is_undo || is_redo)
        {
            state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);
            state->ClearSelection();
        }
        else if (is_shortcut_key && IsKeyPressedMap(ImGuiKey_A))
        {
            state->SelectAll();
            state->CursorFollow = true;
        }
        else if (is_cut || is_copy)
        {
            // Cut, Copy
            if (io.SetClipboardTextFn)
            {
                const int ib = state->HasSelection() ? ImMin(state->Stb.select_start, state->Stb.select_end) : 0;
                const int ie = state->HasSelection() ? ImMax(state->Stb.select_start, state->Stb.select_end) : state->CurLenW;
                const int clipboard_data_len = ImTextCountUtf8BytesFromStr(state->TextW.Data + ib, state->TextW.Data + ie) + 1;
                char* clipboard_data = (char*)MemAlloc(clipboard_data_len * sizeof(char));
                ImTextStrToUtf8(clipboard_data, clipboard_data_len, state->TextW.Data + ib, state->TextW.Data + ie);
                SetClipboardText(clipboard_data);
                MemFree(clipboard_data);
            }
            if (is_cut)
            {
                if (!state->HasSelection())
                    state->SelectAll();
                state->CursorFollow = true;
                stb_textedit_cut(state, &state->Stb);
            }
        }
        else if (is_paste)
        {
            if (const char* clipboard = GetClipboardText())
            {
                // Filter pasted buffer
                const int clipboard_len = (int)strlen(clipboard);
                ImWchar* clipboard_filtered = (ImWchar*)MemAlloc((clipboard_len+1) * sizeof(ImWchar));
                int clipboard_filtered_len = 0;
                for (const char* s = clipboard; *s; )
                {
                    unsigned int c;
                    s += ImTextCharFromUtf8(&c, s, NULL);
                    if (c == 0)
                        break;
                    if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                        continue;
                    clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;
                }
                clipboard_filtered[clipboard_filtered_len] = 0;
                if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation
                {
                    stb_textedit_paste(state, &state->Stb, clipboard_filtered, clipboard_filtered_len);
                    state->CursorFollow = true;
                }
                MemFree(clipboard_filtered);
            }
        }
    }

    // Process callbacks and apply result back to user's buffer.
    if (g.ActiveId == id)
    {
        IM_ASSERT(state != NULL);
        const char* apply_new_text = NULL;
        int apply_new_text_length = 0;
        if (cancel_edit)
        {
            // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
            if (!is_readonly && strcmp(buf, state->InitialTextA.Data) != 0)
            {
                apply_new_text = state->InitialTextA.Data;
                apply_new_text_length = state->InitialTextA.Size - 1;
            }
        }

        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.
        bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);
        if (apply_edit_back_to_user_buffer)
        {
            // Apply new value immediately - copy modified buffer back
            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
            if (!is_readonly)
            {
                state->TextA.resize(state->TextW.Size * 4 + 1);
                ImTextStrToUtf8(state->TextA.Data, state->TextA.Size, state->TextW.Data, NULL);
            }

            // User callback
            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)
            {
                IM_ASSERT(callback != NULL);

                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
                ImGuiInputTextFlags event_flag = 0;
                ImGuiKey event_key = ImGuiKey_COUNT;
                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))
                {
                    event_flag = ImGuiInputTextFlags_CallbackCompletion;
                    event_key = ImGuiKey_Tab;
                }
                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))
                {
                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_UpArrow;
                }
                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))
                {
                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_DownArrow;
                }
                else if (flags & ImGuiInputTextFlags_CallbackAlways)
                    event_flag = ImGuiInputTextFlags_CallbackAlways;

                if (event_flag)
                {
                    ImGuiInputTextCallbackData callback_data;
                    memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));
                    callback_data.EventFlag = event_flag;
                    callback_data.Flags = flags;
                    callback_data.UserData = callback_user_data;

                    callback_data.EventKey = event_key;
                    callback_data.Buf = state->TextA.Data;
                    callback_data.BufTextLen = state->CurLenA;
                    callback_data.BufSize = state->BufCapacityA;
                    callback_data.BufDirty = false;

                    // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
                    ImWchar* text = state->TextW.Data;
                    const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + state->Stb.cursor);
                    const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_start);
                    const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_end);

                    // Call user code
                    callback(&callback_data);

                    // Read back what user may have modified
                    IM_ASSERT(callback_data.Buf == state->TextA.Data);  // Invalid to modify those fields
                    IM_ASSERT(callback_data.BufSize == state->BufCapacityA);
                    IM_ASSERT(callback_data.Flags == flags);
                    if (callback_data.CursorPos != utf8_cursor_pos)            { state->Stb.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); state->CursorFollow = true; }
                    if (callback_data.SelectionStart != utf8_selection_start)  { state->Stb.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }
                    if (callback_data.SelectionEnd != utf8_selection_end)      { state->Stb.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }
                    if (callback_data.BufDirty)
                    {
                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
                        if (callback_data.BufTextLen > backup_current_text_length && is_resizable)
                            state->TextW.resize(state->TextW.Size + (callback_data.BufTextLen - backup_current_text_length));
                        state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, callback_data.Buf, NULL);
                        state->CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
                        state->CursorAnimReset();
                    }
                }
            }

            // Will copy result string if modified
            if (!is_readonly && strcmp(state->TextA.Data, buf) != 0)
            {
                apply_new_text = state->TextA.Data;
                apply_new_text_length = state->CurLenA;
            }
        }

        // Copy result to user buffer
        if (apply_new_text)
        {
            IM_ASSERT(apply_new_text_length >= 0);
            if (backup_current_text_length != apply_new_text_length && is_resizable)
            {
                ImGuiInputTextCallbackData callback_data;
                callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;
                callback_data.Flags = flags;
                callback_data.Buf = buf;
                callback_data.BufTextLen = apply_new_text_length;
                callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);
                callback_data.UserData = callback_user_data;
                callback(&callback_data);
                buf = callback_data.Buf;
                buf_size = callback_data.BufSize;
                apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);
                IM_ASSERT(apply_new_text_length <= buf_size);
            }

            // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
            ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));
            value_changed = true;
        }

        // Clear temporary user storage
        state->UserFlags = 0;
        state->UserCallback = NULL;
        state->UserCallbackData = NULL;
    }

    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
    if (clear_active_id && g.ActiveId == id)
        ClearActiveID();

    // Render frame
    if (!is_multiline)
    {
        RenderNavHighlight(frame_bb, id);
        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    }

    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size
    ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;
    ImVec2 text_size(0.0f, 0.0f);

    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
    const int buf_display_max_length = 2 * 1024 * 1024;

    // Select which buffer we are going to display. We set buf to NULL to prevent accidental usage from now on.
    const char* buf_display = (state != NULL && !is_readonly) ? state->TextA.Data : buf;
    IM_ASSERT(buf_display);
    buf = NULL;

    // Render text. We currently only render selection when the widget is active or while scrolling.
    // FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.
    const bool render_cursor = (g.ActiveId == id) || user_scroll_active;
    const bool render_selection = state && state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
    if (render_cursor || render_selection)
    {
        // Render text (with cursor and selection)
        // This is going to be messy. We need to:
        // - Display the text (this alone can be more easily clipped)
        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
        // - Measure text height (for scrollbar)
        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
        IM_ASSERT(state != NULL);
        const ImWchar* text_begin = state->TextW.Data;
        ImVec2 cursor_offset, select_start_offset;

        {
            // Find lines numbers straddling 'cursor' (slot 0) and 'select_start' (slot 1) positions.
            const ImWchar* searches_input_ptr[2] = { NULL, NULL };
            int searches_result_line_no[2] = { -1000, -1000 };
            int searches_remaining = 0;
            if (render_cursor)
            {
                searches_input_ptr[0] = text_begin + state->Stb.cursor;
                searches_result_line_no[0] = -1;
                searches_remaining++;
            }
            if (render_selection)
            {
                searches_input_ptr[1] = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);
                searches_result_line_no[1] = -1;
                searches_remaining++;
            }

            // Iterate all lines to find our line numbers
            // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
            searches_remaining += is_multiline ? 1 : 0;
            int line_count = 0;
            //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bits
            for (const ImWchar* s = text_begin; *s != 0; s++)
                if (*s == '\n')
                {
                    line_count++;
                    if (searches_result_line_no[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_no[0] = line_count; if (--searches_remaining <= 0) break; }
                    if (searches_result_line_no[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_no[1] = line_count; if (--searches_remaining <= 0) break; }
                }
            line_count++;
            if (searches_result_line_no[0] == -1) 
                searches_result_line_no[0] = line_count;
            if (searches_result_line_no[1] == -1) 
                searches_result_line_no[1] = line_count;

            // Calculate 2d position by finding the beginning of the line and measuring distance
            cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;
            cursor_offset.y = searches_result_line_no[0] * g.FontSize;
            if (searches_result_line_no[1] >= 0)
            {
                select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;
                select_start_offset.y = searches_result_line_no[1] * g.FontSize;
            }

            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
            if (is_multiline)
                text_size = ImVec2(size.x, line_count * g.FontSize);
        }

        // Scroll
        if (render_cursor && state->CursorFollow)
        {
            // Horizontal scroll in chunks of quarter width
            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))
            {
                const float scroll_increment_x = size.x * 0.25f;
                if (cursor_offset.x < state->ScrollX)
                    state->ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);
                else if (cursor_offset.x - size.x >= state->ScrollX)
                    state->ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);
            }
            else
            {
                state->ScrollX = 0.0f;
            }

            // Vertical scroll
            if (is_multiline)
            {
                float scroll_y = draw_window->Scroll.y;
                if (cursor_offset.y - g.FontSize < scroll_y)
                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);
                else if (cursor_offset.y - size.y >= scroll_y)
                    scroll_y = cursor_offset.y - size.y;
                draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag
                draw_window->Scroll.y = scroll_y;
                draw_pos.y = draw_window->DC.CursorPos.y;
            }

            state->CursorFollow = false;
        }

        // Draw selection
        const ImVec2 draw_scroll = ImVec2(state->ScrollX, 0.0f);
        if (render_selection)
        {
            const ImWchar* text_selected_begin = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);
            const ImWchar* text_selected_end = text_begin + ImMax(state->Stb.select_start, state->Stb.select_end);

            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.
            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
            ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;
            for (const ImWchar* p = text_selected_begin; p < text_selected_end; )
            {
                if (rect_pos.y > clip_rect.w + g.FontSize)
                    break;
                if (rect_pos.y < clip_rect.y)
                {
                    //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bits
                    //p = p ? p + 1 : text_selected_end;
                    while (p < text_selected_end)
                        if (*p++ == '\n')
                            break;
                }
                else
                {
                    ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);
                    if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines
                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));
                    rect.ClipWith(clip_rect);
                    if (rect.Overlaps(clip_rect))
                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);
                }
                rect_pos.x = draw_pos.x - draw_scroll.x;
                rect_pos.y += g.FontSize;
            }
        }

        // We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
        const int buf_display_len = state->CurLenA;
        if (is_multiline || buf_display_len < buf_display_max_length)
            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + buf_display_len, 0.0f, is_multiline ? NULL : &clip_rect);

        // Draw blinking cursor
        if (render_cursor)
        {
            state->CursorAnim += io.DeltaTime;
            bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state->CursorAnim <= 0.0f) || ImFmod(state->CursorAnim, 1.20f) <= 0.80f;
            ImVec2 cursor_screen_pos = draw_pos + cursor_offset - draw_scroll;
            ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);
            if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
                draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

            // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
            if (!is_readonly)
                g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);
        }
    }
    else
    {
        // Render text only (no selection, no cursor)
        const char* buf_end = NULL;
        if (is_multiline)
            text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width
        else
            buf_end = buf_display + strlen(buf_display);
        if (is_multiline || (buf_end - buf_display) < buf_display_max_length)
            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos, GetColorU32(ImGuiCol_Text), buf_display, buf_end, 0.0f, is_multiline ? NULL : &clip_rect);
    }

    if (is_multiline)
    {
        Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line
        EndChildFrame();
        EndGroup();
    }

    if (is_password)
        PopFont();

    // Log as text
    if (g.LogEnabled && !is_password)
        LogRenderedText(&draw_pos, buf_display, NULL);

    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    if (value_changed)
        MarkItemEdited(id);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)
        return enter_pressed;
    else
        return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorPicker3()
// - RenderColorRectWithAlphaCheckerboard() [Internal]
// - ColorPicker4()
// - ColorButton()
// - SetColorEditOptions()
// - ColorTooltip() [Internal]
// - ColorEditOptionsPopup() [Internal]
// - ColorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------

bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float square_sz = GetFrameHeight();
    const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);
    const float w_items_all = CalcItemWidth() - w_extra;
    const char* label_display_end = FindRenderedTextEnd(label);

    BeginGroup();
    PushID(label);

    // If we're not showing any slider there's no point in doing any HSV conversions
    const ImGuiColorEditFlags flags_untouched = flags;
    if (flags & ImGuiColorEditFlags_NoInputs)
        flags = (flags & (~ImGuiColorEditFlags__InputsMask)) | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_NoOptions;

    // Context menu: display and modify options (before defaults are applied)
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        ColorEditOptionsPopup(col, flags);

    // Read stored options
    if (!(flags & ImGuiColorEditFlags__InputsMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputsMask);
    if (!(flags & ImGuiColorEditFlags__DataTypeMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);
    if (!(flags & ImGuiColorEditFlags__PickerMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);
    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask));

    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;
    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;
    const int components = alpha ? 4 : 3;

    // Convert to the formats we need
    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };
    if (flags & ImGuiColorEditFlags_HSV)
        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

    bool value_changed = false;
    bool value_changed_as_float = false;

    if ((flags & (ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_HSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        // RGB/HSV 0..255 Sliders
        const float w_item_one  = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));
        const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));

        const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);
        const char* ids[4] = { "##X", "##Y", "##Z", "##W" };
        const char* fmt_table_int[3][4] =
        {
            {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display
            { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
            { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA
        };
        const char* fmt_table_float[3][4] =
        {
            {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
            { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
            { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
        };
        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_HSV) ? 2 : 1;

        PushItemWidth(w_item_one);
        for (int n = 0; n < components; n++)
        {
            if (n > 0)
                SameLine(0, style.ItemInnerSpacing.x);
            if (n + 1 == components)
                PushItemWidth(w_item_last);
            if (flags & ImGuiColorEditFlags_Float)
            {
                value_changed |= DragFloat(ids[n], &f[n], 1.0f/255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);
                value_changed_as_float |= value_changed;
            }
            else
            {
                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);
            }
            if (!(flags & ImGuiColorEditFlags_NoOptions))
                OpenPopupOnItemClick("context");
        }
        PopItemWidth();
        PopItemWidth();
    }
    else if ((flags & ImGuiColorEditFlags_HEX) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        // RGB Hexadecimal Input
        char buf[64];
        if (alpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255), ImClamp(i[3],0,255));
        else
            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255));
        PushItemWidth(w_items_all);
        if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))
        {
            value_changed = true;
            char* p = buf;
            while (*p == '#' || ImCharIsBlankA(*p))
                p++;
            i[0] = i[1] = i[2] = i[3] = 0;
            if (alpha)
                sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)
            else
                sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");
        PopItemWidth();
    }

    ImGuiWindow* picker_active_window = NULL;
    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))
    {
        if (!(flags & ImGuiColorEditFlags_NoInputs))
            SameLine(0, style.ItemInnerSpacing.x);

        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
        if (ColorButton("##ColorButton", col_v4, flags))
        {
            if (!(flags & ImGuiColorEditFlags_NoPicker))
            {
                // Store current color and open a picker
                g.ColorPickerRef = col_v4;
                OpenPopup("picker");
                SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1,style.ItemSpacing.y));
            }
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");

        if (BeginPopup("picker"))
        {
            picker_active_window = g.CurrentWindow;
            if (label != label_display_end)
            {
                TextUnformatted(label, label_display_end);
                Spacing();
            }
            ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
            ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
            PushItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
            value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);
            PopItemWidth();
            EndPopup();
        }
    }

    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))
    {
        SameLine(0, style.ItemInnerSpacing.x);
        TextUnformatted(label, label_display_end);
    }

    // Convert back
    if (picker_active_window == NULL)
    {
        if (!value_changed_as_float)
            for (int n = 0; n < 4; n++)
                f[n] = i[n] / 255.0f;
        if (flags & ImGuiColorEditFlags_HSV)
            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
        if (value_changed)
        {
            col[0] = f[0];
            col[1] = f[1];
            col[2] = f[2];
            if (alpha)
                col[3] = f[3];
        }
    }

    PopID();
    EndGroup();

    // Drag and Drop Target
    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
    if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())
    {
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
        {
            memcpy((float*)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512
            value_changed = true;
        }
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
        {
            memcpy((float*)col, payload->Data, sizeof(float) * components);
            value_changed = true;
        }
        EndDragDropTarget();
    }

    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)
        window->DC.LastItemId = g.ActiveId;

    if (value_changed)
        MarkItemEdited(window->DC.LastItemId);

    return value_changed;
}

bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
    float col4[4] = { col[0], col[1], col[2], 1.0f };
    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))
        return false;
    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];
    return true;
}

static inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)
{
    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;
    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
    return IM_COL32(r, g, b, 0xFF);
}

// Helper for ColorPicker4()
// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// I spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding alltogether.
void ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)
    {
        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204,204,204,255), col));
        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128,128,128,255), col));
        window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);

        int yi = 0;
        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)
        {
            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);
            if (y2 <= y1)
                continue;
            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)
            {
                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);
                if (x2 <= x1)
                    continue;
                int rounding_corners_flags_cell = 0;
                if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }
                if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }
                rounding_corners_flags_cell &= rounding_corners_flags;
                window->DrawList->AddRectFilled(ImVec2(x1,y1), ImVec2(x2,y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);
            }
        }
    }
    else
    {
        window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);
    }
}

// Helper for ColorPicker4()
static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)
{
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32_WHITE);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32_BLACK);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32_WHITE);
}

// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImDrawList* draw_list = window->DrawList;

    ImGuiStyle& style = g.Style;
    ImGuiIO& io = g.IO;

    PushID(label);
    BeginGroup();

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
        flags |= ImGuiColorEditFlags_NoSmallPreview;

    // Context menu: display and store options.
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        ColorPickerOptionsPopup(col, flags);

    // Read stored options
    if (!(flags & ImGuiColorEditFlags__PickerMask))
        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))); // Check that only 1 is selected
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

    // Setup
    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;
    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);
    ImVec2 picker_pos = window->DC.CursorPos;
    float square_sz = GetFrameHeight();
    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
    float sv_picker_size = ImMax(bars_width * 1, CalcItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
    float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);

    float backup_initial_col[4];
    memcpy(backup_initial_col, col, components * sizeof(float));

    float wheel_thickness = sv_picker_size * 0.08f;
    float wheel_r_outer = sv_picker_size * 0.50f;
    float wheel_r_inner = wheel_r_outer - wheel_thickness;
    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size*0.5f);

    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.
    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

    float H,S,V;
    ColorConvertRGBtoHSV(col[0], col[1], col[2], H, S, V);

    bool value_changed = false, value_changed_h = false, value_changed_sv = false;

    PushItemFlag(ImGuiItemFlags_NoNav, true);
    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    {
        // Hue wheel + SV triangle logic
        InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));
        if (IsItemActive())
        {
            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;
            ImVec2 current_off = g.IO.MousePos - wheel_center;
            float initial_dist2 = ImLengthSqr(initial_off);
            if (initial_dist2 >= (wheel_r_inner-1)*(wheel_r_inner-1) && initial_dist2 <= (wheel_r_outer+1)*(wheel_r_outer+1))
            {
                // Interactive with Hue wheel
                H = ImAtan2(current_off.y, current_off.x) / IM_PI*0.5f;
                if (H < 0.0f)
                    H += 1.0f;
                value_changed = value_changed_h = true;
            }
            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);
            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);
            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))
            {
                // Interacting with SV triangle
                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);
                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))
                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);
                float uu, vv, ww;
                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);
                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);
                S = ImClamp(uu / V, 0.0001f, 1.0f);
                value_changed = value_changed_sv = true;
            }
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");
    }
    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    {
        // SV rectangle logic
        InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));
        if (IsItemActive())
        {
            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));
            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = value_changed_sv = true;
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");

        // Hue bar logic
        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));
        InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())
        {
            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = value_changed_h = true;
        }
    }

    // Alpha bar logic
    if (alpha_bar)
    {
        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));
        InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())
        {
            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = true;
        }
    }
    PopItemFlag(); // ImGuiItemFlags_NoNav

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    {
        SameLine(0, style.ItemInnerSpacing.x);
        BeginGroup();
    }

    if (!(flags & ImGuiColorEditFlags_NoLabel))
    {
        const char* label_display_end = FindRenderedTextEnd(label);
        if (label != label_display_end)
        {
            if ((flags & ImGuiColorEditFlags_NoSidePreview))
                SameLine(0, style.ItemInnerSpacing.x);
            TextUnformatted(label, label_display_end);
        }
    }

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    {
        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if ((flags & ImGuiColorEditFlags_NoLabel))
            Text("Current");
        ColorButton("##current", col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2));
        if (ref_col != NULL)
        {
            Text("Original");
            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
            if (ColorButton("##original", ref_col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2)))
            {
                memcpy(col, ref_col, components * sizeof(float));
                value_changed = true;
            }
        }
        PopItemFlag();
        EndGroup();
    }

    // Convert back color to RGB
    if (value_changed_h || value_changed_sv)
        ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10*1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);

    // R,G,B and H,S,V slider color editor
    bool value_changed_fix_hue_wrap = false;
    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;
        if (flags & ImGuiColorEditFlags_RGB || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_RGB))
            {
                // FIXME: Hackily differenciating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
                value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);
                value_changed = true;
            }
        if (flags & ImGuiColorEditFlags_HSV || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_HSV);
        if (flags & ImGuiColorEditFlags_HEX || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_HEX);
        PopItemWidth();
    }

    // Try to cancel hue wrap (after ColorEdit4 call), if any
    if (value_changed_fix_hue_wrap)
    {
        float new_H, new_S, new_V;
        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
        if (new_H <= 0 && H > 0)
        {
            if (new_V <= 0 && V != new_V)
                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);
            else if (new_S <= 0)
                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);
        }
    }

    ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
    ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 1.0f));

    const ImU32 hue_colors[6+1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };
    ImVec2 sv_cursor_pos;

    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    {
        // Render Hue Wheel
        const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);
        for (int n = 0; n < 6; n++)
        {
            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;
            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;
            const int vert_start_idx = draw_list->VtxBuffer.Size;
            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);
            draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);
            const int vert_end_idx = draw_list->VtxBuffer.Size;

            // Paint colors over existing vertices
            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);
            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);
            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n+1]);
        }

        // Render Cursor + preview on Hue Wheel
        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);
        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);
        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f);
        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
        int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);
        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);
        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad+1, IM_COL32(128,128,128,255), hue_cursor_segments);
        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);

        // Render SV triangle (rotated according to hue)
        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);
        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);
        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);
        ImVec2 uv_white = GetFontTexUvWhitePixel();
        draw_list->PrimReserve(6, 6);
        draw_list->PrimVtx(tra, uv_white, hue_color32);
        draw_list->PrimVtx(trb, uv_white, hue_color32);
        draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);
        draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);
        draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);
        draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);
        draw_list->AddTriangle(tra, trb, trc, IM_COL32(128,128,128,255), 1.5f);
        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));
    }
    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    {
        // Render SV Square
        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);
        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);
        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), 0.0f);
        sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S)     * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
        sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

        // Render Hue Bar
        for (int i = 0; i < 6; ++i)
            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);
        float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);
        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
    }

    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;
    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);
    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad+1, IM_COL32(128,128,128,255), 12);
    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);

    // Render alpha bar
    if (alpha_bar)
    {
        float alpha = ImSaturate(col[3]);
        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);
        RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0,0,0,0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));
        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);
        float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);
        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
    }

    EndGroup();

    if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)
        value_changed = false;
    if (value_changed)
        MarkItemEdited(window->DC.LastItemId);

    PopID();

    return value_changed;
}

// A little colored square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
bool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiID id = window->GetID(desc_id);
    float default_size = GetFrameHeight();
    if (size.x == 0.0f)
        size.x = default_size;
    if (size.y == 0.0f)
        size.y = default_size;
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    if (flags & ImGuiColorEditFlags_NoAlpha)
        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

    ImVec4 col_without_alpha(col.x, col.y, col.z, 1.0f);
    float grid_step = ImMin(size.x, size.y) / 2.99f;
    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
    ImRect bb_inner = bb;
    float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
    bb_inner.Expand(off);
    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col.w < 1.0f)
    {
        float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);
        RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight| ImDrawCornerFlags_BotRight);
        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_without_alpha), rounding, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotLeft);
    }
    else
    {
        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col : col_without_alpha;
        if (col_source.w < 1.0f)
            RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);
        else
            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);
    }
    RenderNavHighlight(bb, id);
    if (g.Style.FrameBorderSize > 0.0f)
        RenderFrameBorder(bb.Min, bb.Max, rounding);
    else
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border

    // Drag and Drop Source
    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
    if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())
    {
        if (flags & ImGuiColorEditFlags_NoAlpha)
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col, sizeof(float) * 3, ImGuiCond_Once);
        else
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col, sizeof(float) * 4, ImGuiCond_Once);
        ColorButton(desc_id, col, flags);
        SameLine();
        TextUnformatted("Color");
        EndDragDropSource();
    }

    // Tooltip
    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)
        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

    if (pressed)
        MarkItemEdited(id);

    return pressed;
}

void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)
{
    ImGuiContext& g = *GImGui;
    if ((flags & ImGuiColorEditFlags__InputsMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputsMask;
    if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;
    if ((flags & ImGuiColorEditFlags__PickerMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__InputsMask)));   // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__DataTypeMask))); // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask)));   // Check only 1 option is selected
    g.ColorEditOptions = flags;
}

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)
{
    ImGuiContext& g = *GImGui;

    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
    BeginTooltipEx(0, true);

    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;
    if (text_end > text)
    {
        TextUnformatted(text, text_end);
        Separator();
    }

    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);
    ColorButton("##preview", ImVec4(col[0], col[1], col[2], col[3]), (flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);
    SameLine();
    if (flags & ImGuiColorEditFlags_NoAlpha)
        Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);
    else
        Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
    EndTooltip();
}

void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)
{
    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__InputsMask);
    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);
    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))
        return;
    ImGuiContext& g = *GImGui;
    ImGuiColorEditFlags opts = g.ColorEditOptions;
    if (allow_opt_inputs)
    {
        if (RadioButton("RGB", (opts & ImGuiColorEditFlags_RGB) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_RGB;
        if (RadioButton("HSV", (opts & ImGuiColorEditFlags_HSV) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HSV;
        if (RadioButton("HEX", (opts & ImGuiColorEditFlags_HEX) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HEX;
    }
    if (allow_opt_datatype)
    {
        if (allow_opt_inputs) Separator();
        if (RadioButton("0..255",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;
        if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;
    }

    if (allow_opt_inputs || allow_opt_datatype)
        Separator();
    if (Button("Copy as..", ImVec2(-1,0)))
        OpenPopup("Copy");
    if (BeginPopup("Copy"))
    {
        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
        char buf[64];
        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if (Selectable(buf))
            SetClipboardText(buf);
        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        if (flags & ImGuiColorEditFlags_NoAlpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X", cr, cg, cb);
        else
            ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X%02X", cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        EndPopup();
    }

    g.ColorEditOptions = opts;
    EndPopup();
}

void ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)
{
    bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);
    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);
    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))
        return;
    ImGuiContext& g = *GImGui;
    if (allow_opt_picker)
    {
        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function
        PushItemWidth(picker_size.x);
        for (int picker_type = 0; picker_type < 2; picker_type++)
        {
            // Draw small/thumbnail version of each picker type (over an invisible button for selection)
            if (picker_type > 0) Separator();
            PushID(picker_type);
            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs|ImGuiColorEditFlags_NoOptions|ImGuiColorEditFlags_NoLabel|ImGuiColorEditFlags_NoSidePreview|(flags & ImGuiColorEditFlags_NoAlpha);
            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
            ImVec2 backup_pos = GetCursorScreenPos();
            if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup
                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);
            SetCursorScreenPos(backup_pos);
            ImVec4 dummy_ref_col;
            memcpy(&dummy_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));
            ColorPicker4("##dummypicker", &dummy_ref_col.x, picker_flags);
            PopID();
        }
        PopItemWidth();
    }
    if (allow_opt_alpha_bar)
    {
        if (allow_opt_picker) Separator();
        CheckboxFlags("Alpha Bar", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);
    }
    EndPopup();
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - TreeNodeBehavior() [Internal]
// - TreePush()
// - TreePop()
// - TreeAdvanceToLabelPos()
// - GetTreeNodeToLabelSpacing()
// - SetNextTreeNodeOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, 0, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const char* label)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;
    return TreeNodeBehavior(window->GetID(label), 0, label, NULL);
}

bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)
{
    return TreeNodeExV(str_id, 0, fmt, args);
}

bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)
{
    return TreeNodeExV(ptr_id, 0, fmt, args);
}

bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    return TreeNodeBehavior(window->GetID(label), flags, label, NULL);
}

bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, flags, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)
{
    if (flags & ImGuiTreeNodeFlags_Leaf)
        return true;

    // We only write to the tree storage if the user clicks (or explicitly use SetNextTreeNode*** functions)
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiStorage* storage = window->DC.StateStorage;

    bool is_open;
    if (g.NextTreeNodeOpenCond != 0)
    {
        if (g.NextTreeNodeOpenCond & ImGuiCond_Always)
        {
            is_open = g.NextTreeNodeOpenVal;
            storage->SetInt(id, is_open);
        }
        else
        {
            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
            const int stored_value = storage->GetInt(id, -1);
            if (stored_value == -1)
            {
                is_open = g.NextTreeNodeOpenVal;
                storage->SetInt(id, is_open);
            }
            else
            {
                is_open = stored_value != 0;
            }
        }
        g.NextTreeNodeOpenCond = 0;
    }
    else
    {
        is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;
    }

    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
    // NB- If we are above max depth we still allow manually opened nodes to be logged.
    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && window->DC.TreeDepth < g.LogAutoExpandMaxDepth)
        is_open = true;

    return is_open;
}

bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;
    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);

    if (!label_end)
        label_end = FindRenderedTextEnd(label);
    const ImVec2 label_size = CalcTextSize(label, label_end, false);

    // We vertically grow up to current line height up the typical widget height.
    const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
    const float frame_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + style.FramePadding.y*2), label_size.y + padding.y*2);
    ImRect frame_bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));
    if (display_frame)
    {
        // Framed header expand a little outside the default padding
        frame_bb.Min.x -= (float)(int)(window->WindowPadding.x*0.5f) - 1;
        frame_bb.Max.x += (float)(int)(window->WindowPadding.x*0.5f) - 1;
    }

    const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing
    const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);   // Include collapser
    ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);

    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
    // (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)
    const ImRect interact_bb = display_frame ? frame_bb : ImRect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + text_width + style.ItemSpacing.x*2, frame_bb.Max.y);
    bool is_open = TreeNodeBehaviorIsOpen(id, flags);
    bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;

    // Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
    // This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.
    if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
        window->DC.TreeDepthMayJumpToParentOnPop |= (1 << window->DC.TreeDepth);

    bool item_add = ItemAdd(interact_bb, id);
    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
    window->DC.LastItemDisplayRect = frame_bb;

    if (!item_add)
    {
        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
            TreePushRawID(id);
        IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
        return is_open;
    }

    // Flags that affects opening behavior:
    // - 0 (default) .................... single-click anywhere to open
    // - OpenOnDoubleClick .............. double-click anywhere to open
    // - OpenOnArrow .................... single-click on arrow to open
    // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
    ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers;
    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)
        button_flags |= ImGuiButtonFlags_AllowItemOverlap;
    if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
        button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);
    if (!is_leaf)
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

    bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;
    bool hovered, held;
    bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);
    bool toggled = false;
    if (!is_leaf)
    {
        if (pressed)
        {
            toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);
            if (flags & ImGuiTreeNodeFlags_OpenOnArrow)
                toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);
            if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
                toggled |= g.IO.MouseDoubleClicked[0];
            if (g.DragDropActive && is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
                toggled = false;
        }

        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)
        {
            toggled = true;
            NavMoveRequestCancel();
        }
        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?
        {
            toggled = true;
            NavMoveRequestCancel();
        }

        if (toggled)
        {
            is_open = !is_open;
            window->DC.StateStorage->SetInt(id, is_open);
        }
    }
    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)
        SetItemAllowOverlap();

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
    const ImVec2 text_pos = frame_bb.Min + ImVec2(text_offset_x, text_base_offset_y);
    ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_TypeThin;
    if (display_frame)
    {
        // Framed type
        RenderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);
        RenderNavHighlight(frame_bb, id, nav_highlight_flags);
        RenderArrow(frame_bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);
        if (g.LogEnabled)
        {
            // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
            const char log_prefix[] = "\n##";
            const char log_suffix[] = "##";
            LogRenderedText(&text_pos, log_prefix, log_prefix+3);
            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
            LogRenderedText(&text_pos, log_suffix+1, log_suffix+3);
        }
        else
        {
            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
        }
    }
    else
    {
        // Unframed typed for tree nodes
        if (hovered || selected)
        {
            RenderFrame(frame_bb.Min, frame_bb.Max, col, false);
            RenderNavHighlight(frame_bb, id, nav_highlight_flags);
        }

        if (flags & ImGuiTreeNodeFlags_Bullet)
            RenderBullet(frame_bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));
        else if (!is_leaf)
            RenderArrow(frame_bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);
        if (g.LogEnabled)
            LogRenderedText(&text_pos, ">");
        RenderText(text_pos, label, label_end, false);
    }

    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
        TreePushRawID(id);
    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
    return is_open;
}

void ImGui::TreePush(const char* str_id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    PushID(str_id ? str_id : "#TreePush");
}

void ImGui::TreePush(const void* ptr_id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    PushID(ptr_id ? ptr_id : (const void*)"#TreePush");
}

void ImGui::TreePushRawID(ImGuiID id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    window->IDStack.push_back(id);
}

void ImGui::TreePop()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    Unindent();

    window->DC.TreeDepth--;
    if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
        if (g.NavIdIsAlive && (window->DC.TreeDepthMayJumpToParentOnPop & (1 << window->DC.TreeDepth)))
        {
            SetNavID(window->IDStack.back(), g.NavLayer);
            NavMoveRequestCancel();
        }
    window->DC.TreeDepthMayJumpToParentOnPop &= (1 << window->DC.TreeDepth) - 1;

    IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
    PopID();
}

void ImGui::TreeAdvanceToLabelPos()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
float ImGui::GetTreeNodeToLabelSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + (g.Style.FramePadding.x * 2.0f);
}

void ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow->SkipItems)
        return;
    g.NextTreeNodeOpenVal = is_open;
    g.NextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;
}

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);
}

bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    if (p_open && !*p_open)
        return false;

    ImGuiID id = window->GetID(label);
    bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);
    if (p_open)
    {
        // Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
        ImGuiContext& g = *GImGui;
        ImGuiItemHoveredDataBackup last_item_backup;
        float button_radius = g.FontSize * 0.5f;
        ImVec2 button_center = ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_radius, window->DC.LastItemRect.GetCenter().y);
        if (CloseButton(window->GetID((void*)((intptr_t)id+1)), button_center, button_radius))
            *p_open = false;
        last_item_backup.Restore();
    }

    return is_open;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Selectable
//-------------------------------------------------------------------------
// - Selectable()
//-------------------------------------------------------------------------

// Tip: pass a non-visible label (e.g. "##dummy") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet) // FIXME-OPT: Avoid if vertically clipped.
        PopClipRect();

    ImGuiID id = window->GetID(label);
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
    ImVec2 pos = window->DC.CursorPos;
    pos.y += window->DC.CurrentLineTextBaseOffset;
    ImRect bb_inner(pos, pos + size);
    ItemSize(bb_inner);

    // Fill horizontal space.
    ImVec2 window_padding = window->WindowPadding;
    float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;
    float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - pos.x);
    ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);
    ImRect bb(pos, pos + size_draw);
    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))
        bb.Max.x += window_padding.x;

    // Selectables are tightly packed together, we extend the box to cover spacing between selectable.
    float spacing_L = (float)(int)(style.ItemSpacing.x * 0.5f);
    float spacing_U = (float)(int)(style.ItemSpacing.y * 0.5f);
    float spacing_R = style.ItemSpacing.x - spacing_L;
    float spacing_D = style.ItemSpacing.y - spacing_U;
    bb.Min.x -= spacing_L;
    bb.Min.y -= spacing_U;
    bb.Max.x += spacing_R;
    bb.Max.y += spacing_D;
    if (!ItemAdd(bb, id))
    {
        if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)
            PushColumnClipRect();
        return false;
    }

    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
    ImGuiButtonFlags button_flags = 0;
    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) button_flags |= ImGuiButtonFlags_NoHoldingActiveID;
    if (flags & ImGuiSelectableFlags_PressedOnClick) button_flags |= ImGuiButtonFlags_PressedOnClick;
    if (flags & ImGuiSelectableFlags_PressedOnRelease) button_flags |= ImGuiButtonFlags_PressedOnRelease;
    if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;
    if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
    if (flags & ImGuiSelectableFlags_Disabled)
        selected = false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
    // Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)
    if (pressed || hovered)
        if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)
        {
            g.NavDisableHighlight = true;
            SetNavID(id, window->DC.NavLayerCurrent);
        }
    if (pressed)
        MarkItemEdited(id);

    // Render
    if (hovered || selected)
    {
        const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
        RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);
    }

    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)
    {
        PushColumnClipRect();
        bb.Max.x -= (GetContentRegionMax().x - max_x);
    }

    if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
    RenderTextClipped(bb_inner.Min, bb_inner.Max, label, NULL, &label_size, style.SelectableTextAlign, &bb);
    if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();

    // Automatically close popups
    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))
        CloseCurrentPopup();
    return pressed;
}

bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
    if (Selectable(label, *p_selected, flags, size_arg))
    {
        *p_selected = !*p_selected;
        return true;
    }
    return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ListBox
//-------------------------------------------------------------------------
// - ListBox()
// - ListBoxHeader()
// - ListBoxFooter()
//-------------------------------------------------------------------------

// FIXME: In principle this function should be called BeginListBox(). We should rename it after re-evaluating if we want to keep the same signature.
// Helper to calculate the size of a listbox and display a label on the right.
// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an non-visible label e.g. "##empty"
bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    const ImGuiStyle& style = GetStyle();
    const ImGuiID id = GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);
    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));
    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.

    if (!IsRectVisible(bb.Min, bb.Max))
    {
        ItemSize(bb.GetSize(), style.FramePadding.y);
        ItemAdd(bb, 0, &frame_bb);
        return false;
    }

    BeginGroup();
    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    BeginChildFrame(id, frame_bb.GetSize());
    return true;
}

// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.
bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)
{
    // Size default to hold ~7.25 items.
    // We add +25% worth of item height to allow the user to see at a glance if there are more items up/down, without looking at the scrollbar.
    // We don't add this extra bit if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
    // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
    if (height_in_items < 0)
        height_in_items = ImMin(items_count, 7);
    const ImGuiStyle& style = GetStyle();
    float height_in_items_f = (height_in_items < items_count) ? (height_in_items + 0.25f) : (height_in_items + 0.00f);

    // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
    ImVec2 size;
    size.x = 0.0f;
    size.y = GetTextLineHeightWithSpacing() * height_in_items_f + style.FramePadding.y * 2.0f;
    return ListBoxHeader(label, size);
}

// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.
void ImGui::ListBoxFooter()
{
    ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;
    const ImRect bb = parent_window->DC.LastItemRect;
    const ImGuiStyle& style = GetStyle();

    EndChildFrame();

    // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
    // We call SameLine() to restore DC.CurrentLine* data
    SameLine();
    parent_window->DC.CursorPos = bb.Min;
    ItemSize(bb, style.FramePadding.y);
    EndGroup();
}

bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)
{
    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);
    return value_changed;
}

bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
{
    if (!ListBoxHeader(label, items_count, height_in_items))
        return false;

    // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
    while (clipper.Step())
        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
        {
            const bool item_selected = (i == *current_item);
            const char* item_text;
            if (!items_getter(data, i, &item_text))
                item_text = "*Unknown item*";

            PushID(i);
            if (Selectable(item_text, item_selected))
            {
                *current_item = i;
                value_changed = true;
            }
            if (item_selected)
                SetItemDefaultFocus();
            PopID();
        }
    ListBoxFooter();
    if (value_changed)
        MarkItemEdited(g.CurrentWindow->DC.LastItemId);

    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: PlotLines, PlotHistogram
//-------------------------------------------------------------------------
// - PlotEx() [Internal]
// - PlotLines()
// - PlotHistogram()
//-------------------------------------------------------------------------

void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    if (frame_size.x == 0.0f)
        frame_size.x = CalcItemWidth();
    if (frame_size.y == 0.0f)
        frame_size.y = label_size.y + (style.FramePadding.y * 2);

    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0, &frame_bb))
        return;
    const bool hovered = ItemHoverable(frame_bb, id);

    // Determine scale from values if not specified
    if (scale_min == FLT_MAX || scale_max == FLT_MAX)
    {
        float v_min = FLT_MAX;
        float v_max = -FLT_MAX;
        for (int i = 0; i < values_count; i++)
        {
            const float v = values_getter(data, i);
            v_min = ImMin(v_min, v);
            v_max = ImMax(v_max, v);
        }
        if (scale_min == FLT_MAX)
            scale_min = v_min;
        if (scale_max == FLT_MAX)
            scale_max = v_max;
    }

    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

    if (values_count > 0)
    {
        int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

        // Tooltip on hover
        int v_hovered = -1;
        if (hovered && inner_bb.Contains(g.IO.MousePos))
        {
            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);
            const int v_idx = (int)(t * item_count);
            IM_ASSERT(v_idx >= 0 && v_idx < values_count);

            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);
            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);
            if (plot_type == ImGuiPlotType_Lines)
                SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx+1, v1);
            else if (plot_type == ImGuiPlotType_Histogram)
                SetTooltip("%d: %8.4g", v_idx, v0);
            v_hovered = v_idx;
        }

        const float t_step = 1.0f / (float)res_w;
        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

        float v0 = values_getter(data, (0 + values_offset) % values_count);
        float t0 = 0.0f;
        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle
        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands

        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);
        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

        for (int n = 0; n < res_w; n++)
        {
            const float t1 = t0 + t_step;
            const int v1_idx = (int)(t0 * item_count + 0.5f);
            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);
            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );

            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);
            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));
            if (plot_type == ImGuiPlotType_Lines)
            {
                window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
            }
            else if (plot_type == ImGuiPlotType_Histogram)
            {
                if (pos1.x >= pos0.x + 2.0f)
                    pos1.x -= 1.0f;
                window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
            }

            t0 = t1;
            tp0 = tp1;
        }
    }

    // Text overlay
    if (overlay_text)
        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);
}

struct ImGuiPlotArrayGetterData
{
    const float* Values;
    int Stride;

    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }
};

static float Plot_ArrayGetter(void* data, int idx)
{
    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
    const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);
    return v;
}

void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Value helpers
// Those is not very useful, legacy API.
//-------------------------------------------------------------------------
// - Value()
//-------------------------------------------------------------------------

void ImGui::Value(const char* prefix, bool b)
{
    Text("%s: %s", prefix, (b ? "true" : "false"));
}

void ImGui::Value(const char* prefix, int v)
{
    Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, unsigned int v)
{
    Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, float v, const char* float_format)
{
    if (float_format)
    {
        char fmt[64];
        ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);
        Text(fmt, prefix, v);
    }
    else
    {
        Text("%s: %.3f", prefix, v);
    }
}

//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - ImGuiMenuColumns [Internal]
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItem()
//-------------------------------------------------------------------------

// Helpers for internal use
ImGuiMenuColumns::ImGuiMenuColumns()
{
    Count = 0;
    Spacing = Width = NextWidth = 0.0f;
    memset(Pos, 0, sizeof(Pos));
    memset(NextWidths, 0, sizeof(NextWidths));
}

void ImGuiMenuColumns::Update(int count, float spacing, bool clear)
{
    IM_ASSERT(Count <= IM_ARRAYSIZE(Pos));
    Count = count;
    Width = NextWidth = 0.0f;
    Spacing = spacing;
    if (clear) memset(NextWidths, 0, sizeof(NextWidths));
    for (int i = 0; i < Count; i++)
    {
        if (i > 0 && NextWidths[i] > 0.0f)
            Width += Spacing;
        Pos[i] = (float)(int)Width;
        Width += NextWidths[i];
        NextWidths[i] = 0.0f;
    }
}

float ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) // not using va_arg because they promote float to double
{
    NextWidth = 0.0f;
    NextWidths[0] = ImMax(NextWidths[0], w0);
    NextWidths[1] = ImMax(NextWidths[1], w1);
    NextWidths[2] = ImMax(NextWidths[2], w2);
    for (int i = 0; i < 3; i++)
        NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);
    return ImMax(Width, NextWidth);
}

float ImGuiMenuColumns::CalcExtraSpace(float avail_w)
{
    return ImMax(0.0f, avail_w - Width);
}

// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
bool ImGui::BeginMainMenuBar()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));
    SetNextWindowPos(ImVec2(0.0f, 0.0f));
    SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));
    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
    bool is_open = Begin("##MainMenuBar", NULL, window_flags) && BeginMenuBar();
    PopStyleVar(2);
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);
    if (!is_open)
    {
        End();
        return false;
    }
    return true; //-V1020
}

void ImGui::EndMainMenuBar()
{
    EndMenuBar();

    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)
        FocusPreviousWindowIgnoringOne(g.NavWindow);

    End();
}

bool ImGui::BeginMenuBar()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;
    if (!(window->Flags & ImGuiWindowFlags_MenuBar))
        return false;

    IM_ASSERT(!window->DC.MenuBarAppending);
    BeginGroup(); // Backup position on layer 0
    PushID("##menubar");

    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
    ImRect bar_rect = window->MenuBarRect();
    ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));
    clip_rect.ClipWith(window->OuterRectClipped);
    PushClipRect(clip_rect.Min, clip_rect.Max, false);

    window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);
    window->DC.LayoutType = ImGuiLayoutType_Horizontal;
    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);
    window->DC.MenuBarAppending = true;
    AlignTextToFramePadding();
    return true;
}

void ImGui::EndMenuBar()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
    if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
    {
        ImGuiWindow* nav_earliest_child = g.NavWindow;
        while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))
            nav_earliest_child = nav_earliest_child->ParentWindow;
        if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)
        {
            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)
            IM_ASSERT(window->DC.NavLayerActiveMaskNext & 0x02); // Sanity check
            FocusWindow(window);
            SetNavIDWithRectRel(window->NavLastIds[1], 1, window->NavRectRel[1]);
            g.NavLayer = ImGuiNavLayer_Menu;
            g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.
            g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
            NavMoveRequestCancel();
        }
    }

    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
    IM_ASSERT(window->DC.MenuBarAppending);
    PopClipRect();
    PopID();
    window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.
    window->DC.GroupStack.back().AdvanceCursor = false;
    EndGroup(); // Restore position on layer 0
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
    window->DC.MenuBarAppending = false;
}

bool ImGui::BeginMenu(const char* label, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    ImVec2 label_size = CalcTextSize(label, NULL, true);

    bool pressed;
    bool menu_is_open = IsPopupOpen(id);
    bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].OpenParentId == window->IDStack.back());
    ImGuiWindow* backed_nav_window = g.NavWindow;
    if (menuset_is_open)
        g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
    // However the final position is going to be different! It is choosen by FindBestWindowPosForPopup().
    // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
    ImVec2 popup_pos, pos = window->DC.CursorPos;
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    {
        // Menu inside an horizontal menu bar
        // Selectable extend their highlight by half ItemSpacing in each direction.
        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
        popup_pos = ImVec2(pos.x - 1.0f - (float)(int)(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight());
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);
        float w = label_size.x;
        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
        PopStyleVar();
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }
    else
    {
        // Menu inside a menu
        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
        float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
        if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
        RenderArrow(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);
        if (!enabled) PopStyleColor();
    }

    const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);
    if (menuset_is_open)
        g.NavWindow = backed_nav_window;

    bool want_open = false, want_close = false;
    if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
    {
        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
        bool moving_within_opened_triangle = false;
        if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].ParentWindow == window && !(window->Flags & ImGuiWindowFlags_MenuBar))
        {
            if (ImGuiWindow* next_window = g.OpenPopupStack[g.BeginPopupStack.Size].Window)
            {
                // FIXME-DPI: Values should be derived from a master "scale" factor.
                ImRect next_window_rect = next_window->Rect();
                ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;
                ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();
                ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();
                float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.
                ta.x += (window->Pos.x < next_window->Pos.x) ? -0.5f : +0.5f;    // to avoid numerical issues
                tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);             // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?
                tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);
                moving_within_opened_triangle = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
                //window->DrawList->PushClipRectFullScreen(); window->DrawList->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); window->DrawList->PopClipRect(); // Debug
            }
        }

        want_close = (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_within_opened_triangle);
        want_open = (!menu_is_open && hovered && !moving_within_opened_triangle) || (!menu_is_open && hovered && pressed);

        if (g.NavActivateId == id)
        {
            want_close = menu_is_open;
            want_open = !menu_is_open;
        }
        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open
        {
            want_open = true;
            NavMoveRequestCancel();
        }
    }
    else
    {
        // Menu bar
        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it
        {
            want_close = true;
            want_open = menu_is_open = false;
        }
        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others
        {
            want_open = true;
        }
        else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open
        {
            want_open = true;
            NavMoveRequestCancel();
        }
    }

    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
        want_close = true;
    if (want_close && IsPopupOpen(id))
        ClosePopupToLevel(g.BeginPopupStack.Size, true);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));

    if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)
    {
        // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
        OpenPopup(label);
        return false;
    }

    menu_is_open |= want_open;
    if (want_open)
        OpenPopup(label);

    if (menu_is_open)
    {
        // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
        SetNextWindowPos(popup_pos, ImGuiCond_Always);
        ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;
        if (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
            flags |= ImGuiWindowFlags_ChildWindow;
        menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    }

    return menu_is_open;
}

void ImGui::EndMenu()
{
    // Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).
    // A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
    // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)
    {
        ClosePopupToLevel(g.BeginPopupStack.Size, true);
        NavMoveRequestCancel();
    }

    EndPopup();
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImVec2 pos = window->DC.CursorPos;
    ImVec2 label_size = CalcTextSize(label, NULL, true);

    ImGuiSelectableFlags flags = ImGuiSelectableFlags_PressedOnRelease | (enabled ? 0 : ImGuiSelectableFlags_Disabled);
    bool pressed;
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    {
        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
        // Note that in this situation we render neither the shortcut neither the selected tick mark
        float w = label_size.x;
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);
        pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));
        PopStyleVar();
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }
    else
    {
        ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);
        float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
        pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));
        if (shortcut_size.x > 0.0f)
        {
            PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
            RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);
            PopStyleColor();
        }
        if (selected)
            RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize  * 0.866f);
    }

    IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));
    return pressed;
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)
{
    if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))
    {
        if (p_selected)
            *p_selected = !*p_selected;
        return true;
    }
    return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// [BETA API] API may evolve! This code has been extracted out of the Docking branch,
// and some of the construct which are not used in Master may be left here to facilitate merging.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - BeginTabBarEx() [Internal]
// - EndTabBar()
// - TabBarLayout() [Internal]
// - TabBarCalcTabID() [Internal]
// - TabBarCalcMaxTabWidth() [Internal]
// - TabBarFindTabById() [Internal]
// - TabBarRemoveTab() [Internal]
// - TabBarCloseTab() [Internal]
// - TabBarScrollClamp()v
// - TabBarScrollToTab() [Internal]
// - TabBarQueueChangeTabOrder() [Internal]
// - TabBarScrollingButtons() [Internal]
// - TabBarTabListPopupButton() [Internal]
//-------------------------------------------------------------------------

namespace ImGui
{
    static void             TabBarLayout(ImGuiTabBar* tab_bar);
    static ImU32            TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label);
    static float            TabBarCalcMaxTabWidth();
    static float            TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling);
    static void             TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    static ImGuiTabItem*    TabBarScrollingButtons(ImGuiTabBar* tab_bar);
    static ImGuiTabItem*    TabBarTabListPopupButton(ImGuiTabBar* tab_bar);
}

ImGuiTabBar::ImGuiTabBar()
{
    ID = 0;
    SelectedTabId = NextSelectedTabId = VisibleTabId = 0;
    CurrFrameVisible = PrevFrameVisible = -1;
    ContentsHeight = 0.0f;
    OffsetMax = OffsetNextTab = 0.0f;
    ScrollingAnim = ScrollingTarget = 0.0f;
    Flags = ImGuiTabBarFlags_None;
    ReorderRequestTabId = 0;
    ReorderRequestDir = 0;
    WantLayout = VisibleTabWasSubmitted = false;
    LastTabItemIdx = -1;
}

static int IMGUI_CDECL TabItemComparerByVisibleOffset(const void* lhs, const void* rhs)
{
    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
    return (int)(a->Offset - b->Offset);
}

static int IMGUI_CDECL TabBarSortItemComparer(const void* lhs, const void* rhs)
{
    const ImGuiTabBarSortItem* a = (const ImGuiTabBarSortItem*)lhs;
    const ImGuiTabBarSortItem* b = (const ImGuiTabBarSortItem*)rhs;
    if (int d = (int)(b->Width - a->Width))
        return d;
    return (b->Index - a->Index);
}

static ImGuiTabBar* GetTabBarFromTabBarRef(const ImGuiTabBarRef& ref)
{
    ImGuiContext& g = *GImGui;
    return ref.Ptr ? ref.Ptr : g.TabBars.GetByIndex(ref.IndexInMainPool);
}

static ImGuiTabBarRef GetTabBarRefFromTabBar(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    if (g.TabBars.Contains(tab_bar))
        return ImGuiTabBarRef(g.TabBars.GetIndex(tab_bar));
    return ImGuiTabBarRef(tab_bar);
}

bool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    ImGuiID id = window->GetID(str_id);
    ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);
    ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->InnerClipRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);
    tab_bar->ID = id;
    return BeginTabBarEx(tab_bar, tab_bar_bb, flags | ImGuiTabBarFlags_IsFocused);
}

bool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    if ((flags & ImGuiTabBarFlags_DockNode) == 0)
        window->IDStack.push_back(tab_bar->ID);

    // Add to stack
    g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));
    g.CurrentTabBar = tab_bar;

    if (tab_bar->CurrFrameVisible == g.FrameCount)
    {
        //IMGUI_DEBUG_LOG("BeginTabBarEx already called this frame\n", g.FrameCount);
        IM_ASSERT(0);
        return true;
    }

    // When toggling back from ordered to manually-reorderable, shuffle tabs to enforce the last visible order.
    // Otherwise, the most recently inserted tabs would move at the end of visible list which can be a little too confusing or magic for the user.
    if ((flags & ImGuiTabBarFlags_Reorderable) && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable) && tab_bar->Tabs.Size > 1 && tab_bar->PrevFrameVisible != -1)
        ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByVisibleOffset);

    // Flags
    if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
        flags |= ImGuiTabBarFlags_FittingPolicyDefault_;

    tab_bar->Flags = flags;
    tab_bar->BarRect = tab_bar_bb;
    tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()
    tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;
    tab_bar->CurrFrameVisible = g.FrameCount;
    tab_bar->FramePadding = g.Style.FramePadding;

    // Layout
    ItemSize(ImVec2(tab_bar->OffsetMax, tab_bar->BarRect.GetHeight()));
    window->DC.CursorPos.x = tab_bar->BarRect.Min.x;

    // Draw separator
    const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_Tab);
    const float y = tab_bar->BarRect.Max.y - 1.0f;
    {
        const float separator_min_x = tab_bar->BarRect.Min.x - window->WindowPadding.x;
        const float separator_max_x = tab_bar->BarRect.Max.x + window->WindowPadding.x;
        window->DrawList->AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);
    }
    return true;
}

void    ImGui::EndTabBar()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)
    {
        IM_ASSERT(tab_bar != NULL && "Mismatched BeginTabBar()/EndTabBar()!");
        return; // FIXME-ERRORHANDLING
    }
    if (tab_bar->WantLayout)
        TabBarLayout(tab_bar);

    // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
    if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)
        tab_bar->ContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, 0.0f);
    else
        window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->ContentsHeight;

    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)
        PopID();

    g.CurrentTabBarStack.pop_back();
    g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());
}

// This is called only once a frame before by the first call to ItemTab()
// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.
static void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    tab_bar->WantLayout = false;

    // Garbage collect
    int tab_dst_n = 0;
    for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_src_n];
        if (tab->LastFrameVisible < tab_bar->PrevFrameVisible)
        {
            if (tab->ID == tab_bar->SelectedTabId)
                tab_bar->SelectedTabId = 0;
            continue;
        }
        if (tab_dst_n != tab_src_n)
            tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];
        tab_dst_n++;
    }
    if (tab_bar->Tabs.Size != tab_dst_n)
        tab_bar->Tabs.resize(tab_dst_n);

    // Setup next selected tab
    ImGuiID scroll_track_selected_tab_id = 0;
    if (tab_bar->NextSelectedTabId)
    {
        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;
        tab_bar->NextSelectedTabId = 0;
        scroll_track_selected_tab_id = tab_bar->SelectedTabId;
    }

    // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
    if (tab_bar->ReorderRequestTabId != 0)
    {
        if (ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId))
        {
            //IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
            int tab2_order = tab_bar->GetTabOrder(tab1) + tab_bar->ReorderRequestDir;
            if (tab2_order >= 0 && tab2_order < tab_bar->Tabs.Size)
            {
                ImGuiTabItem* tab2 = &tab_bar->Tabs[tab2_order];
                ImGuiTabItem item_tmp = *tab1;
                *tab1 = *tab2;
                *tab2 = item_tmp;
                if (tab2->ID == tab_bar->SelectedTabId)
                    scroll_track_selected_tab_id = tab2->ID;
                tab1 = tab2 = NULL;
            }
            if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)
                MarkIniSettingsDirty();
        }
        tab_bar->ReorderRequestTabId = 0;
    }

    // Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
    const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;
    if (tab_list_popup_button)
        if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Max.x!
            scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

    ImVector<ImGuiTabBarSortItem>& width_sort_buffer = g.TabSortByWidthBuffer;
    width_sort_buffer.resize(tab_bar->Tabs.Size);

    // Compute ideal widths
    float width_total_contents = 0.0f;
    ImGuiTabItem* most_recently_selected_tab = NULL;
    bool found_selected_tab_id = false;
    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);

        if (most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected)
            most_recently_selected_tab = tab;
        if (tab->ID == tab_bar->SelectedTabId)
            found_selected_tab_id = true;

        // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
        // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
        // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
        const char* tab_name = tab_bar->GetTabName(tab);
        tab->WidthContents = TabItemCalcSize(tab_name, (tab->Flags & ImGuiTabItemFlags_NoCloseButton) ? false : true).x;

        width_total_contents += (tab_n > 0 ? g.Style.ItemInnerSpacing.x : 0.0f) + tab->WidthContents;

        // Store data so we can build an array sorted by width if we need to shrink tabs down
        width_sort_buffer[tab_n].Index = tab_n;
        width_sort_buffer[tab_n].Width = tab->WidthContents;
    }

    // Compute width
    const float width_avail = tab_bar->BarRect.GetWidth();
    float width_excess = (width_avail < width_total_contents) ? (width_total_contents - width_avail) : 0.0f;
    if (width_excess > 0.0f && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown))
    {
        // If we don't have enough room, resize down the largest tabs first
        if (tab_bar->Tabs.Size > 1)
            ImQsort(width_sort_buffer.Data, (size_t)width_sort_buffer.Size, sizeof(ImGuiTabBarSortItem), TabBarSortItemComparer);
        int tab_count_same_width = 1;
        while (width_excess > 0.0f && tab_count_same_width < tab_bar->Tabs.Size)
        {
            while (tab_count_same_width < tab_bar->Tabs.Size && width_sort_buffer[0].Width == width_sort_buffer[tab_count_same_width].Width)
                tab_count_same_width++;
            float width_to_remove_per_tab_max = (tab_count_same_width < tab_bar->Tabs.Size) ? (width_sort_buffer[0].Width - width_sort_buffer[tab_count_same_width].Width) : (width_sort_buffer[0].Width - 1.0f);
            float width_to_remove_per_tab = ImMin(width_excess / tab_count_same_width, width_to_remove_per_tab_max);
            for (int tab_n = 0; tab_n < tab_count_same_width; tab_n++)
                width_sort_buffer[tab_n].Width -= width_to_remove_per_tab;
            width_excess -= width_to_remove_per_tab * tab_count_same_width;
        }
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
            tab_bar->Tabs[width_sort_buffer[tab_n].Index].Width = (float)(int)width_sort_buffer[tab_n].Width;
    }
    else
    {
        const float tab_max_width = TabBarCalcMaxTabWidth();
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
        {
            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
            tab->Width = ImMin(tab->WidthContents, tab_max_width);
        }
    }

    // Layout all active tabs
    float offset_x = 0.0f;
    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        tab->Offset = offset_x;
        if (scroll_track_selected_tab_id == 0 && g.NavJustMovedToId == tab->ID)
            scroll_track_selected_tab_id = tab->ID;
        offset_x += tab->Width + g.Style.ItemInnerSpacing.x;
    }
    tab_bar->OffsetMax = ImMax(offset_x - g.Style.ItemInnerSpacing.x, 0.0f);
    tab_bar->OffsetNextTab = 0.0f;

    // Horizontal scrolling buttons
    const bool scrolling_buttons = (tab_bar->OffsetMax > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll);
    if (scrolling_buttons)
        if (ImGuiTabItem* tab_to_select = TabBarScrollingButtons(tab_bar)) // NB: Will alter BarRect.Max.x!
            scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

    // If we have lost the selected tab, select the next most recently active one
    if (found_selected_tab_id == false)
        tab_bar->SelectedTabId = 0;
    if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)
        scroll_track_selected_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

    // Lock in visible tab
    tab_bar->VisibleTabId = tab_bar->SelectedTabId;
    tab_bar->VisibleTabWasSubmitted = false;

    // Update scrolling
    if (scroll_track_selected_tab_id)
        if (ImGuiTabItem* scroll_track_selected_tab = TabBarFindTabByID(tab_bar, scroll_track_selected_tab_id))
            TabBarScrollToTab(tab_bar, scroll_track_selected_tab);
    tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);
    tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);
    const float scrolling_speed = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) ? FLT_MAX : (g.IO.DeltaTime * g.FontSize * 70.0f);
    if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)
        tab_bar->ScrollingAnim = ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, scrolling_speed);

    // Clear name buffers
    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)
        tab_bar->TabsNames.Buf.resize(0);
}

// Dockables uses Name/ID in the global namespace. Non-dockable items use the ID stack.
static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label)
{
    if (tab_bar->Flags & ImGuiTabBarFlags_DockNode)
    {
        ImGuiID id = ImHashStr(label, 0);
        KeepAliveID(id);
        return id;
    }
    else
    {
        ImGuiWindow* window = GImGui->CurrentWindow;
        return window->GetID(label);
    }
}

static float ImGui::TabBarCalcMaxTabWidth()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize * 20.0f;
}

ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)
{
    if (tab_id != 0)
        for (int n = 0; n < tab_bar->Tabs.Size; n++)
            if (tab_bar->Tabs[n].ID == tab_id)
                return &tab_bar->Tabs[n];
    return NULL;
}

// The *TabId fields be already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.
void ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)
{
    if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))
        tab_bar->Tabs.erase(tab);
    if (tab_bar->VisibleTabId == tab_id)      { tab_bar->VisibleTabId = 0; }
    if (tab_bar->SelectedTabId == tab_id)     { tab_bar->SelectedTabId = 0; }
    if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }
}

// Called on manual closure attempt
void ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
{
    if ((tab_bar->VisibleTabId == tab->ID) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument))
    {
        // This will remove a frame of lag for selecting another tab on closure.
        // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
        tab->LastFrameVisible = -1;
        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;
    }
    else if ((tab_bar->VisibleTabId != tab->ID) && (tab->Flags & ImGuiTabItemFlags_UnsavedDocument))
    {
        // Actually select before expecting closure
        tab_bar->NextSelectedTabId = tab->ID;
    }
}

static float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)
{
    scrolling = ImMin(scrolling, tab_bar->OffsetMax - tab_bar->BarRect.GetWidth());
    return ImMax(scrolling, 0.0f);
}

static void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
{
    ImGuiContext& g = *GImGui;
    float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)
    int order = tab_bar->GetTabOrder(tab);
    float tab_x1 = tab->Offset + (order > 0 ? -margin : 0.0f);
    float tab_x2 = tab->Offset + tab->Width + (order + 1 < tab_bar->Tabs.Size ? margin : 1.0f);
    if (tab_bar->ScrollingTarget > tab_x1)
        tab_bar->ScrollingTarget = tab_x1;
    if (tab_bar->ScrollingTarget + tab_bar->BarRect.GetWidth() < tab_x2)
        tab_bar->ScrollingTarget = tab_x2 - tab_bar->BarRect.GetWidth();
}

void ImGui::TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir)
{
    IM_ASSERT(dir == -1 || dir == +1);
    IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
    tab_bar->ReorderRequestTabId = tab->ID;
    tab_bar->ReorderRequestDir = dir;
}

static ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);
    const float scrolling_buttons_width = arrow_button_size.x * 2.0f;

    const ImVec2 backup_cursor_pos = window->DC.CursorPos;
    //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));

    const ImRect avail_bar_rect = tab_bar->BarRect;
    bool want_clip_rect = !avail_bar_rect.Contains(ImRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(scrolling_buttons_width, 0.0f)));
    if (want_clip_rect)
        PushClipRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max + ImVec2(g.Style.ItemInnerSpacing.x, 0.0f), true);

    ImGuiTabItem* tab_to_select = NULL;

    int select_dir = 0;
    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    arrow_col.w *= 0.5f;

    PushStyleColor(ImGuiCol_Text, arrow_col);
    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    const float backup_repeat_delay = g.IO.KeyRepeatDelay;
    const float backup_repeat_rate = g.IO.KeyRepeatRate;
    g.IO.KeyRepeatDelay = 0.250f;
    g.IO.KeyRepeatRate = 0.200f;
    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y);
    if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
        select_dir = -1;
    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width + arrow_button_size.x, tab_bar->BarRect.Min.y);
    if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
        select_dir = +1;
    PopStyleColor(2);
    g.IO.KeyRepeatRate = backup_repeat_rate;
    g.IO.KeyRepeatDelay = backup_repeat_delay;

    if (want_clip_rect)
        PopClipRect();

    if (select_dir != 0)
        if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))
        {
            int selected_order = tab_bar->GetTabOrder(tab_item);
            int target_order = selected_order + select_dir;
            tab_to_select = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order]; // If we are at the end of the list, still scroll to make our tab visible
        }
    window->DC.CursorPos = backup_cursor_pos;
    tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

    return tab_to_select;
}

static ImGuiTabItem* ImGui::TabBarTabListPopupButton(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // We use g.Style.FramePadding.y to match the square ArrowButton size
    const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;
    const ImVec2 backup_cursor_pos = window->DC.CursorPos;
    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);
    tab_bar->BarRect.Min.x += tab_list_popup_button_width;

    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    arrow_col.w *= 0.5f;
    PushStyleColor(ImGuiCol_Text, arrow_col);
    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview);
    PopStyleColor(2);

    ImGuiTabItem* tab_to_select = NULL;
    if (open)
    {
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
        {
            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
            const char* tab_name = tab_bar->GetTabName(tab);
            if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))
                tab_to_select = tab;
        }
        EndCombo();
    }

    window->DC.CursorPos = backup_cursor_pos;
    return tab_to_select;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
//-------------------------------------------------------------------------
// [BETA API] API may evolve! This code has been extracted out of the Docking branch,
// and some of the construct which are not used in Master may be left here to facilitate merging.
//-------------------------------------------------------------------------
// - BeginTabItem()
// - EndTabItem()
// - TabItemEx() [Internal]
// - SetTabItemClosed()
// - TabItemCalcSize() [Internal]
// - TabItemBackground() [Internal]
// - TabItemLabelAndCloseButton() [Internal]
//-------------------------------------------------------------------------

bool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow->SkipItems)
        return false;

    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)
    {
        IM_ASSERT(tab_bar && "Needs to be called between BeginTabBar() and EndTabBar()!");
        return false; // FIXME-ERRORHANDLING
    }
    bool ret = TabItemEx(tab_bar, label, p_open, flags);
    if (ret && !(flags & ImGuiTabItemFlags_NoPushId))
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
        g.CurrentWindow->IDStack.push_back(tab->ID);    // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)
    }
    return ret;
}

void    ImGui::EndTabItem()
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow->SkipItems)
        return;

    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)
    {
        IM_ASSERT(tab_bar != NULL && "Needs to be called between BeginTabBar() and EndTabBar()!");
        return;
    }
    IM_ASSERT(tab_bar->LastTabItemIdx >= 0);
    ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
    if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))
        g.CurrentWindow->IDStack.pop_back();
}

bool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags)
{
    // Layout whole tab bar if not already done
    if (tab_bar->WantLayout)
        TabBarLayout(tab_bar);

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    const ImGuiStyle& style = g.Style;
    const ImGuiID id = TabBarCalcTabID(tab_bar, label);

    // If the user called us with *p_open == false, we early out and don't render. We make a dummy call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
    if (p_open && !*p_open)
    {
        PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);
        ItemAdd(ImRect(), id);
        PopItemFlag();
        return false;
    }

    // Calculate tab contents size
    ImVec2 size = TabItemCalcSize(label, p_open != NULL);

    // Acquire tab data
    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);
    bool tab_is_new = false;
    if (tab == NULL)
    {
        tab_bar->Tabs.push_back(ImGuiTabItem());
        tab = &tab_bar->Tabs.back();
        tab->ID = id;
        tab->Width = size.x;
        tab_is_new = true;
    }
    tab_bar->LastTabItemIdx = (short)tab_bar->Tabs.index_from_ptr(tab);
    tab->WidthContents = size.x;

    if (p_open == NULL)
        flags |= ImGuiTabItemFlags_NoCloseButton;

    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
    const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;
    const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);
    tab->LastFrameVisible = g.FrameCount;
    tab->Flags = flags;

    // Append name with zero-terminator
    tab->NameOffset = tab_bar->TabsNames.size();
    tab_bar->TabsNames.append(label, label + strlen(label) + 1);

    // If we are not reorderable, always reset offset based on submission order.
    // (We already handled layout and sizing using the previous known order, but sizing is not affected by order!)
    if (!tab_appearing && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable))
    {
        tab->Offset = tab_bar->OffsetNextTab;
        tab_bar->OffsetNextTab += tab->Width + g.Style.ItemInnerSpacing.x;
    }

    // Update selected tab
    if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)
        if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)
            tab_bar->NextSelectedTabId = id;  // New tabs gets activated

    // Lock visibility
    bool tab_contents_visible = (tab_bar->VisibleTabId == id);
    if (tab_contents_visible)
        tab_bar->VisibleTabWasSubmitted = true;

    // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
    if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)
        if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))
            tab_contents_visible = true;

    if (tab_appearing && !(tab_bar_appearing && !tab_is_new))
    {
        PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);
        ItemAdd(ImRect(), id);
        PopItemFlag();
        return tab_contents_visible;
    }

    if (tab_bar->SelectedTabId == id)
        tab->LastFrameSelected = g.FrameCount;

    // Backup current layout position
    const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;

    // Layout
    size.x = tab->Width;
    window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2((float)(int)tab->Offset - tab_bar->ScrollingAnim, 0.0f);
    ImVec2 pos = window->DC.CursorPos;
    ImRect bb(pos, pos + size);

    // We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
    bool want_clip_rect = (bb.Min.x < tab_bar->BarRect.Min.x) || (bb.Max.x >= tab_bar->BarRect.Max.x);
    if (want_clip_rect)
        PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->BarRect.Min.x), bb.Min.y - 1), ImVec2(tab_bar->BarRect.Max.x, bb.Max.y), true);

    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(bb, id))
    {
        if (want_clip_rect)
            PopClipRect();
        window->DC.CursorPos = backup_main_cursor_pos;
        return tab_contents_visible;
    }

    // Click to Select a tab
    ImGuiButtonFlags button_flags = (ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_AllowItemOverlap);
    if (g.DragDropActive)
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
    hovered |= (g.HoveredId == id);
    if (pressed || ((flags & ImGuiTabItemFlags_SetSelected) && !tab_contents_visible)) // SetSelected can only be passed on explicit tab bar
        tab_bar->NextSelectedTabId = id;

    // Allow the close button to overlap unless we are dragging (in which case we don't want any overlapping tabs to be hovered)
    if (!held)
        SetItemAllowOverlap();

    // Drag and drop: re-order tabs
    if (held && !tab_appearing && IsMouseDragging(0))
    {
        if (!g.DragDropActive && (tab_bar->Flags & ImGuiTabBarFlags_Reorderable))
        {
            // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
            if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)
            {
                if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)
                    TabBarQueueChangeTabOrder(tab_bar, tab, -1);
            }
            else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)
            {
                if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)
                    TabBarQueueChangeTabOrder(tab_bar, tab, +1);
            }
        }
    }

#if 0
    if (hovered && g.HoveredIdNotActiveTimer > 0.50f && bb.GetWidth() < tab->WidthContents)
    {
        // Enlarge tab display when hovering
        bb.Max.x = bb.Min.x + (float)(int)ImLerp(bb.GetWidth(), tab->WidthContents, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f));
        display_draw_list = GetOverlayDrawList(window);
        TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));
    }
#endif

    // Render tab shape
    ImDrawList* display_draw_list = window->DrawList;
    const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused));
    TabItemBackground(display_draw_list, bb, flags, tab_col);
    RenderNavHighlight(bb, id);

    // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
    const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);
    if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)))
        tab_bar->NextSelectedTabId = id;

    if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)
        flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

    // Render tab label, process close button
    const ImGuiID close_button_id = p_open ? window->GetID((void*)((intptr_t)id + 1)) : 0;
    bool just_closed = TabItemLabelAndCloseButton(display_draw_list, bb, flags, tab_bar->FramePadding, label, id, close_button_id);
    if (just_closed && p_open != NULL)
    {
        *p_open = false;
        TabBarCloseTab(tab_bar, tab);
    }

    // Restore main window position so user can draw there
    if (want_clip_rect)
        PopClipRect();
    window->DC.CursorPos = backup_main_cursor_pos;

    // Tooltip (FIXME: Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer)
    if (g.HoveredId == id && !held && g.HoveredIdNotActiveTimer > 0.50f)
        if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip))
            SetTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);

    return tab_contents_visible;
}

// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.
// To use it to need to call the function SetTabItemClosed() after BeginTabBar() and before any call to BeginTabItem()
void    ImGui::SetTabItemClosed(const char* label)
{
    ImGuiContext& g = *GImGui;
    bool is_within_manual_tab_bar = g.CurrentTabBar && !(g.CurrentTabBar->Flags & ImGuiTabBarFlags_DockNode);
    if (is_within_manual_tab_bar)
    {
        ImGuiTabBar* tab_bar = g.CurrentTabBar;
        IM_ASSERT(tab_bar->WantLayout);         // Needs to be called AFTER BeginTabBar() and BEFORE the first call to BeginTabItem()
        ImGuiID tab_id = TabBarCalcTabID(tab_bar, label);
        TabBarRemoveTab(tab_bar, tab_id);
    }
}

ImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button)
{
    ImGuiContext& g = *GImGui;
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);
    if (has_close_button)
        size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.
    else
        size.x += g.Style.FramePadding.x + 1.0f;
    return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);
}

void ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col)
{
    // While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
    ImGuiContext& g = *GImGui;
    const float width = bb.GetWidth();
    IM_UNUSED(flags);
    IM_ASSERT(width > 0.0f);
    const float rounding = ImMax(0.0f, ImMin(g.Style.TabRounding, width * 0.5f - 1.0f));
    const float y1 = bb.Min.y + 1.0f;
    const float y2 = bb.Max.y - 1.0f;
    draw_list->PathLineTo(ImVec2(bb.Min.x, y2));
    draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);
    draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);
    draw_list->PathLineTo(ImVec2(bb.Max.x, y2));
    draw_list->PathFillConvex(col);
    if (g.Style.TabBorderSize > 0.0f)
    {
        draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));
        draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);
        draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);
        draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));
        draw_list->PathStroke(GetColorU32(ImGuiCol_Border), false, g.Style.TabBorderSize);
    }
}

// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.
bool ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id)
{
    ImGuiContext& g = *GImGui;
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    if (bb.GetWidth() <= 1.0f)
        return false;

    // Render text label (with clipping + alpha gradient) + unsaved marker
    const char* TAB_UNSAVED_MARKER = "*";
    ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);
    if (flags & ImGuiTabItemFlags_UnsavedDocument)
    {
        text_pixel_clip_bb.Max.x -= CalcTextSize(TAB_UNSAVED_MARKER, NULL, false).x;
        ImVec2 unsaved_marker_pos(ImMin(bb.Min.x + frame_padding.x + label_size.x + 2, text_pixel_clip_bb.Max.x), bb.Min.y + frame_padding.y + (float)(int)(-g.FontSize * 0.25f));
        RenderTextClippedEx(draw_list, unsaved_marker_pos, bb.Max - frame_padding, TAB_UNSAVED_MARKER, NULL, NULL);
    }
    ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;

    // Close Button
    // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
    //  'hovered' will be true when hovering the Tab but NOT when hovering the close button
    //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
    //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
    bool close_button_pressed = false;
    bool close_button_visible = false;
    if (close_button_id != 0)
        if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == close_button_id)
            close_button_visible = true;
    if (close_button_visible)
    {
        ImGuiItemHoveredDataBackup last_item_backup;
        const float close_button_sz = g.FontSize * 0.5f;
        if (CloseButton(close_button_id, ImVec2(bb.Max.x - frame_padding.x - close_button_sz, bb.Min.y + frame_padding.y + close_button_sz), close_button_sz))
            close_button_pressed = true;
        last_item_backup.Restore();

        // Close with middle mouse button
        if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))
            close_button_pressed = true;

        text_pixel_clip_bb.Max.x -= close_button_sz * 2.0f;
    }

    // Label with ellipsis
    // FIXME: This should be extracted into a helper but the use of text_pixel_clip_bb and !close_button_visible makes it tricky to abstract at the moment
    const char* label_display_end = FindRenderedTextEnd(label);
    if (label_size.x > text_ellipsis_clip_bb.GetWidth())
    {
        const int ellipsis_dot_count = 3;
        const float ellipsis_width = (1.0f + 1.0f) * ellipsis_dot_count - 1.0f;
        const char* label_end = NULL;
        float label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, text_ellipsis_clip_bb.GetWidth() - ellipsis_width + 1.0f, 0.0f, label, label_display_end, &label_end).x;
        if (label_end == label && label_end < label_display_end)    // Always display at least 1 character if there's no room for character + ellipsis
        {
            label_end = label + ImTextCountUtf8BytesFromChar(label, label_display_end);
            label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label, label_end).x;
        }
        while (label_end > label && ImCharIsBlankA(label_end[-1])) // Trim trailing space
        {
            label_end--;
            label_size_clipped_x -= g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label_end, label_end + 1).x; // Ascii blanks are always 1 byte
        }
        RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_end, &label_size, ImVec2(0.0f, 0.0f));

        const float ellipsis_x = text_pixel_clip_bb.Min.x + label_size_clipped_x + 1.0f;
        if (!close_button_visible && ellipsis_x + ellipsis_width <= bb.Max.x)
            RenderPixelEllipsis(draw_list, ImVec2(ellipsis_x, text_pixel_clip_bb.Min.y), ellipsis_dot_count, GetColorU32(ImGuiCol_Text));
    }
    else
    {
        RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_display_end, &label_size, ImVec2(0.0f, 0.0f));
    }

    return close_button_pressed;
}

```

`CSGOSimple/imgui/impl/imgui_impl_dx9.cpp`:

```cpp
// dear imgui: Renderer for DirectX9
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2019-01-16: Misc: Disabled fog before drawing UI's. Fixes issue #2288.
//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
//  2018-06-08: Misc: Extracted imgui_impl_dx9.cpp/.h away from the old combined DX9+Win32 example.
//  2018-06-08: DirectX9: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
//  2018-05-07: Render: Saving/restoring Transform because they don't seem to be included in the StateBlock. Setting shading mode to Gouraud.
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX9_RenderDrawData() in the .h file so you can call it yourself.
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.

#include "../imgui.h"
#include "imgui_impl_dx9.h"

// DirectX
#include <d3d9.h>
#define DIRECTINPUT_VERSION 0x0800
#include <dinput.h>

// DirectX data
static LPDIRECT3DDEVICE9        g_pd3dDevice = NULL;
static LPDIRECT3DVERTEXBUFFER9  g_pVB = NULL;
static LPDIRECT3DINDEXBUFFER9   g_pIB = NULL;
static LPDIRECT3DTEXTURE9       g_FontTexture = NULL;
static int                      g_VertexBufferSize = 5000, g_IndexBufferSize = 10000;

struct CUSTOMVERTEX
{
    float    pos[3];
    D3DCOLOR col;
    float    uv[2];
};
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

// Render function.
// (this used to be set in io.RenderDrawListsFn and called by ImGui::Render(), but you can now call this directly from your main loop)
void ImGui_ImplDX9_RenderDrawData(ImDrawData* draw_data)
{
    // Avoid rendering when minimized
    if (draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f)
        return;

    // Create and grow buffers if needed
    if (!g_pVB || g_VertexBufferSize < draw_data->TotalVtxCount)
    {
        if (g_pVB) { g_pVB->Release(); g_pVB = NULL; }
        g_VertexBufferSize = draw_data->TotalVtxCount + 5000;
        if (g_pd3dDevice->CreateVertexBuffer(g_VertexBufferSize * sizeof(CUSTOMVERTEX), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &g_pVB, NULL) < 0)
            return;
    }
    if (!g_pIB || g_IndexBufferSize < draw_data->TotalIdxCount)
    {
        if (g_pIB) { g_pIB->Release(); g_pIB = NULL; }
        g_IndexBufferSize = draw_data->TotalIdxCount + 10000;
        if (g_pd3dDevice->CreateIndexBuffer(g_IndexBufferSize * sizeof(ImDrawIdx), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, sizeof(ImDrawIdx) == 2 ? D3DFMT_INDEX16 : D3DFMT_INDEX32, D3DPOOL_DEFAULT, &g_pIB, NULL) < 0)
            return;
    }

    // Backup the DX9 state
    IDirect3DStateBlock9* d3d9_state_block = NULL;
    if (g_pd3dDevice->CreateStateBlock(D3DSBT_PIXELSTATE, &d3d9_state_block) < 0)
        return;

    // Backup the DX9 transform (DX9 documentation suggests that it is included in the StateBlock but it doesn't appear to)
    D3DMATRIX last_world, last_view, last_projection;
    g_pd3dDevice->GetTransform(D3DTS_WORLD, &last_world);
    g_pd3dDevice->GetTransform(D3DTS_VIEW, &last_view);
    g_pd3dDevice->GetTransform(D3DTS_PROJECTION, &last_projection);

    // Copy and convert all vertices into a single contiguous buffer, convert colors to DX9 default format.
    // FIXME-OPT: This is a waste of resource, the ideal is to use imconfig.h and
    //  1) to avoid repacking colors:   #define IMGUI_USE_BGRA_PACKED_COLOR
    //  2) to avoid repacking vertices: #define IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT struct ImDrawVert { ImVec2 pos; float z; ImU32 col; ImVec2 uv; }
    CUSTOMVERTEX* vtx_dst;
    ImDrawIdx* idx_dst;
    if (g_pVB->Lock(0, (UINT)(draw_data->TotalVtxCount * sizeof(CUSTOMVERTEX)), (void**)&vtx_dst, D3DLOCK_DISCARD) < 0)
        return;
    if (g_pIB->Lock(0, (UINT)(draw_data->TotalIdxCount * sizeof(ImDrawIdx)), (void**)&idx_dst, D3DLOCK_DISCARD) < 0)
        return;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        const ImDrawVert* vtx_src = cmd_list->VtxBuffer.Data;
        for (int i = 0; i < cmd_list->VtxBuffer.Size; i++)
        {
            vtx_dst->pos[0] = vtx_src->pos.x;
            vtx_dst->pos[1] = vtx_src->pos.y;
            vtx_dst->pos[2] = 0.0f;
            vtx_dst->col = (vtx_src->col & 0xFF00FF00) | ((vtx_src->col & 0xFF0000) >> 16) | ((vtx_src->col & 0xFF) << 16);     // RGBA --> ARGB for DirectX9
            vtx_dst->uv[0] = vtx_src->uv.x;
            vtx_dst->uv[1] = vtx_src->uv.y;
            vtx_dst++;
            vtx_src++;
        }
        memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
        idx_dst += cmd_list->IdxBuffer.Size;
    }
    g_pVB->Unlock();
    g_pIB->Unlock();
    g_pd3dDevice->SetStreamSource(0, g_pVB, 0, sizeof(CUSTOMVERTEX));
    g_pd3dDevice->SetIndices(g_pIB);
    g_pd3dDevice->SetFVF(D3DFVF_CUSTOMVERTEX);

    // Setup viewport
    D3DVIEWPORT9 vp;
    vp.X = vp.Y = 0;
    vp.Width = (DWORD)draw_data->DisplaySize.x;
    vp.Height = (DWORD)draw_data->DisplaySize.y;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    g_pd3dDevice->SetViewport(&vp);

    // Setup render state: fixed-pipeline, alpha-blending, no face culling, no depth testing, shade mode (for gradient)
    g_pd3dDevice->SetPixelShader(NULL);
    g_pd3dDevice->SetVertexShader(NULL);
    g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, false);
    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, false);
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
    g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, false);
    g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
    g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, true);
    g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
    g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, false);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
    g_pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);

    // Setup orthographic projection matrix
    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right).
    // Being agnostic of whether <d3dx9.h> or <DirectXMath.h> can be used, we aren't relying on D3DXMatrixIdentity()/D3DXMatrixOrthoOffCenterLH() or DirectX::XMMatrixIdentity()/DirectX::XMMatrixOrthographicOffCenterLH()
    {
        float L = draw_data->DisplayPos.x + 0.5f;
        float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x + 0.5f;
        float T = draw_data->DisplayPos.y + 0.5f;
        float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y + 0.5f;
        D3DMATRIX mat_identity = { { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } } };
        D3DMATRIX mat_projection =
        { { {
            2.0f/(R-L),   0.0f,         0.0f,  0.0f,
            0.0f,         2.0f/(T-B),   0.0f,  0.0f,
            0.0f,         0.0f,         0.5f,  0.0f,
            (L+R)/(L-R),  (T+B)/(B-T),  0.5f,  1.0f
        } } };
        g_pd3dDevice->SetTransform(D3DTS_WORLD, &mat_identity);
        g_pd3dDevice->SetTransform(D3DTS_VIEW, &mat_identity);
        g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &mat_projection);
    }

    // Render command lists
    int vtx_offset = 0;
    int idx_offset = 0;
    ImVec2 clip_off = draw_data->DisplayPos;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback)
            {
                pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                const RECT r = { (LONG)(pcmd->ClipRect.x - clip_off.x), (LONG)(pcmd->ClipRect.y - clip_off.y), (LONG)(pcmd->ClipRect.z - clip_off.x), (LONG)(pcmd->ClipRect.w - clip_off.y) };
                const LPDIRECT3DTEXTURE9 texture = (LPDIRECT3DTEXTURE9)pcmd->TextureId;
                g_pd3dDevice->SetTexture(0, texture);
                g_pd3dDevice->SetScissorRect(&r);
                g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, vtx_offset, 0, (UINT)cmd_list->VtxBuffer.Size, idx_offset, pcmd->ElemCount/3);
            }
            idx_offset += pcmd->ElemCount;
        }
        vtx_offset += cmd_list->VtxBuffer.Size;
    }

    // Restore the DX9 transform
    g_pd3dDevice->SetTransform(D3DTS_WORLD, &last_world);
    g_pd3dDevice->SetTransform(D3DTS_VIEW, &last_view);
    g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &last_projection);

    // Restore the DX9 state
    d3d9_state_block->Apply();
    d3d9_state_block->Release();
}

bool ImGui_ImplDX9_Init(IDirect3DDevice9* device)
{
    ImGuiIO& io = ImGui::GetIO();
    io.BackendRendererName = "imgui_impl_dx9";

    g_pd3dDevice = device;
    return true;
}

void ImGui_ImplDX9_Shutdown()
{
    ImGui_ImplDX9_InvalidateDeviceObjects();
    g_pd3dDevice = NULL;
}

static bool ImGui_ImplDX9_CreateFontsTexture()
{
    // Build texture atlas
    ImGuiIO& io = ImGui::GetIO();
    unsigned char* pixels;
    int width, height, bytes_per_pixel;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height, &bytes_per_pixel);

    // Upload texture to graphics system
    g_FontTexture = NULL;
    if (g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &g_FontTexture, NULL) < 0)
        return false;
    D3DLOCKED_RECT tex_locked_rect;
    if (g_FontTexture->LockRect(0, &tex_locked_rect, NULL, 0) != D3D_OK)
        return false;
    for (int y = 0; y < height; y++)
        memcpy((unsigned char *)tex_locked_rect.pBits + tex_locked_rect.Pitch * y, pixels + (width * bytes_per_pixel) * y, (width * bytes_per_pixel));
    g_FontTexture->UnlockRect(0);

    // Store our identifier
    io.Fonts->TexID = (ImTextureID)g_FontTexture;

    return true;
}

bool ImGui_ImplDX9_CreateDeviceObjects()
{
    if (!g_pd3dDevice)
        return false;
    if (!ImGui_ImplDX9_CreateFontsTexture())
        return false;
    return true;
}

void ImGui_ImplDX9_InvalidateDeviceObjects()
{
    if (!g_pd3dDevice)
        return;
    if (g_pVB)
    {
        g_pVB->Release();
        g_pVB = NULL;
    }
    if (g_pIB)
    {
        g_pIB->Release();
        g_pIB = NULL;
    }

    // At this point note that we set ImGui::GetIO().Fonts->TexID to be == g_FontTexture, so clear both.
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(g_FontTexture == io.Fonts->TexID);
    if (g_FontTexture)
        g_FontTexture->Release();
    g_FontTexture = NULL;
    io.Fonts->TexID = NULL;
}

void ImGui_ImplDX9_NewFrame()
{
    if (!g_FontTexture)
        ImGui_ImplDX9_CreateDeviceObjects();
}

```

`CSGOSimple/imgui/impl/imgui_impl_dx9.h`:

```h
// dear imgui: Renderer for DirectX9
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

#pragma once

struct IDirect3DDevice9;

IMGUI_IMPL_API bool     ImGui_ImplDX9_Init(IDirect3DDevice9* device);
IMGUI_IMPL_API void     ImGui_ImplDX9_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplDX9_NewFrame();
IMGUI_IMPL_API void     ImGui_ImplDX9_RenderDrawData(ImDrawData* draw_data);

// Use if you want to reset your rendering device without losing ImGui state.
IMGUI_IMPL_API void     ImGui_ImplDX9_InvalidateDeviceObjects();
IMGUI_IMPL_API bool     ImGui_ImplDX9_CreateDeviceObjects();

```

`CSGOSimple/imgui/impl/imgui_impl_win32.cpp`:

```cpp
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.

#include "../imgui.h"
#include "imgui_impl_win32.h"
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <XInput.h>
#include <tchar.h>

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.
//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.
//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).
//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.
//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.
//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.
//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging.
//  2016-11-12: Inputs: Only call Win32 ::SetCursor(NULL) when io.MouseDrawCursor is set.

// Win32 Data
static HWND                 g_hWnd = 0;
static INT64                g_Time = 0;
static INT64                g_TicksPerSecond = 0;
static ImGuiMouseCursor     g_LastMouseCursor = ImGuiMouseCursor_COUNT;
static bool                 g_HasGamepad = false;
static bool                 g_WantUpdateHasGamepad = true;

// Functions
bool    ImGui_ImplWin32_Init(void* hwnd)
{
    if (!::QueryPerformanceFrequency((LARGE_INTEGER *)&g_TicksPerSecond))
        return false;
    if (!::QueryPerformanceCounter((LARGE_INTEGER *)&g_Time))
        return false;

    // Setup back-end capabilities flags
    g_hWnd = (HWND)hwnd;
    ImGuiIO& io = ImGui::GetIO();
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
    io.BackendPlatformName = "imgui_impl_win32";
    io.ImeWindowHandle = hwnd;

    // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.
    io.KeyMap[ImGuiKey_Tab] = VK_TAB;
    io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;
    io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;
    io.KeyMap[ImGuiKey_UpArrow] = VK_UP;
    io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;
    io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;
    io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;
    io.KeyMap[ImGuiKey_Home] = VK_HOME;
    io.KeyMap[ImGuiKey_End] = VK_END;
    io.KeyMap[ImGuiKey_Insert] = VK_INSERT;
    io.KeyMap[ImGuiKey_Delete] = VK_DELETE;
    io.KeyMap[ImGuiKey_Backspace] = VK_BACK;
    io.KeyMap[ImGuiKey_Space] = VK_SPACE;
    io.KeyMap[ImGuiKey_Enter] = VK_RETURN;
    io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;
    io.KeyMap[ImGuiKey_A] = 'A';
    io.KeyMap[ImGuiKey_C] = 'C';
    io.KeyMap[ImGuiKey_V] = 'V';
    io.KeyMap[ImGuiKey_X] = 'X';
    io.KeyMap[ImGuiKey_Y] = 'Y';
    io.KeyMap[ImGuiKey_Z] = 'Z';

    return true;
}

void    ImGui_ImplWin32_Shutdown()
{
    g_hWnd = (HWND)0;
}

static bool ImGui_ImplWin32_UpdateMouseCursor()
{
    ImGuiIO& io = ImGui::GetIO();
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return false;

    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        ::SetCursor(NULL);
    }
    else
    {
        // Show OS mouse cursor
        LPTSTR win32_cursor = IDC_ARROW;
        switch (imgui_cursor)
        {
        case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
        case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
        case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
        case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
        case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
        case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
        case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
        case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;
        }
        ::SetCursor(::LoadCursor(NULL, win32_cursor));
    }
    return true;
}

static void ImGui_ImplWin32_UpdateMousePos()
{
    ImGuiIO& io = ImGui::GetIO();

    // Set OS mouse position if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
    if (io.WantSetMousePos)
    {
        POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
        ::ClientToScreen(g_hWnd, &pos);
        ::SetCursorPos(pos.x, pos.y);
    }

    // Set mouse position
    io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    POINT pos;
    if (HWND active_window = ::GetForegroundWindow())
        if (active_window == g_hWnd || ::IsChild(active_window, g_hWnd))
            if (::GetCursorPos(&pos) && ::ScreenToClient(g_hWnd, &pos))
                io.MousePos = ImVec2((float)pos.x, (float)pos.y);
}

#ifdef _MSC_VER
#pragma comment(lib, "xinput")
#endif

// Gamepad navigation mapping
static void ImGui_ImplWin32_UpdateGamepads()
{
    ImGuiIO& io = ImGui::GetIO();
    memset(io.NavInputs, 0, sizeof(io.NavInputs));
    if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0)
        return;

    // Calling XInputGetState() every frame on disconnected gamepads is unfortunately too slow.
    // Instead we refresh gamepad availability by calling XInputGetCapabilities() _only_ after receiving WM_DEVICECHANGE.
    if (g_WantUpdateHasGamepad)
    {
        XINPUT_CAPABILITIES caps;
        g_HasGamepad = (XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &caps) == ERROR_SUCCESS);
        g_WantUpdateHasGamepad = false;
    }

    XINPUT_STATE xinput_state;
    io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;
    if (g_HasGamepad && XInputGetState(0, &xinput_state) == ERROR_SUCCESS)
    {
        const XINPUT_GAMEPAD& gamepad = xinput_state.Gamepad;
        io.BackendFlags |= ImGuiBackendFlags_HasGamepad;

        #define MAP_BUTTON(NAV_NO, BUTTON_ENUM)     { io.NavInputs[NAV_NO] = (gamepad.wButtons & BUTTON_ENUM) ? 1.0f : 0.0f; }
        #define MAP_ANALOG(NAV_NO, VALUE, V0, V1)   { float vn = (float)(VALUE - V0) / (float)(V1 - V0); if (vn > 1.0f) vn = 1.0f; if (vn > 0.0f && io.NavInputs[NAV_NO] < vn) io.NavInputs[NAV_NO] = vn; }
        MAP_BUTTON(ImGuiNavInput_Activate,      XINPUT_GAMEPAD_A);              // Cross / A
        MAP_BUTTON(ImGuiNavInput_Cancel,        XINPUT_GAMEPAD_B);              // Circle / B
        MAP_BUTTON(ImGuiNavInput_Menu,          XINPUT_GAMEPAD_X);              // Square / X
        MAP_BUTTON(ImGuiNavInput_Input,         XINPUT_GAMEPAD_Y);              // Triangle / Y
        MAP_BUTTON(ImGuiNavInput_DpadLeft,      XINPUT_GAMEPAD_DPAD_LEFT);      // D-Pad Left
        MAP_BUTTON(ImGuiNavInput_DpadRight,     XINPUT_GAMEPAD_DPAD_RIGHT);     // D-Pad Right
        MAP_BUTTON(ImGuiNavInput_DpadUp,        XINPUT_GAMEPAD_DPAD_UP);        // D-Pad Up
        MAP_BUTTON(ImGuiNavInput_DpadDown,      XINPUT_GAMEPAD_DPAD_DOWN);      // D-Pad Down
        MAP_BUTTON(ImGuiNavInput_FocusPrev,     XINPUT_GAMEPAD_LEFT_SHOULDER);  // L1 / LB
        MAP_BUTTON(ImGuiNavInput_FocusNext,     XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1 / RB
        MAP_BUTTON(ImGuiNavInput_TweakSlow,     XINPUT_GAMEPAD_LEFT_SHOULDER);  // L1 / LB
        MAP_BUTTON(ImGuiNavInput_TweakFast,     XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1 / RB
        MAP_ANALOG(ImGuiNavInput_LStickLeft,    gamepad.sThumbLX,  -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
        MAP_ANALOG(ImGuiNavInput_LStickRight,   gamepad.sThumbLX,  +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
        MAP_ANALOG(ImGuiNavInput_LStickUp,      gamepad.sThumbLY,  +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
        MAP_ANALOG(ImGuiNavInput_LStickDown,    gamepad.sThumbLY,  -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32767);
        #undef MAP_BUTTON
        #undef MAP_ANALOG
    }
}

void    ImGui_ImplWin32_NewFrame()
{
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer back-end. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame().");

    // Setup display size (every frame to accommodate for window resizing)
    RECT rect;
    ::GetClientRect(g_hWnd, &rect);
    io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

    // Setup time step
    INT64 current_time;
    ::QueryPerformanceCounter((LARGE_INTEGER *)&current_time);
    io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;
    g_Time = current_time;

    // Read keyboard modifiers inputs
    io.KeyCtrl = (::GetKeyState(VK_CONTROL) & 0x8000) != 0;
    io.KeyShift = (::GetKeyState(VK_SHIFT) & 0x8000) != 0;
    io.KeyAlt = (::GetKeyState(VK_MENU) & 0x8000) != 0;
    io.KeySuper = false;
    // io.KeysDown[], io.MousePos, io.MouseDown[], io.MouseWheel: filled by the WndProc handler below.

    // Update OS mouse position
    ImGui_ImplWin32_UpdateMousePos();

    // Update OS mouse cursor with the cursor requested by imgui
    ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
    if (g_LastMouseCursor != mouse_cursor)
    {
        g_LastMouseCursor = mouse_cursor;
        ImGui_ImplWin32_UpdateMouseCursor();
    }

    // Update game controllers (if available)
    ImGui_ImplWin32_UpdateGamepads();
}

// Allow compilation with old Windows SDK. MinGW doesn't have default _WIN32_WINNT/WINVER versions.
#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif
#ifndef DBT_DEVNODES_CHANGED
#define DBT_DEVNODES_CHANGED 0x0007
#endif

// Process Win32 mouse/keyboard inputs.
// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
// PS: In this Win32 handler, we use the capture API (GetCapture/SetCapture/ReleaseCapture) to be able to read mouse coordinations when dragging mouse outside of our window bounds.
// PS: We treat DBLCLK messages as regular mouse down messages, so this code will work on windows classes that have the CS_DBLCLKS flag set. Our own example app code doesn't set this flag.
IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui::GetCurrentContext() == NULL)
        return false;

	ImGuiIO& io = ImGui::GetIO();
	switch (msg)
	{
	case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
	case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
	case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK:
	{
		int button = 0;
		if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) button = 0;
		if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) button = 1;
		if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) button = 2;
		if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) button = (HIWORD(wParam) == XBUTTON1) ? 3 : 4;
		if (!ImGui::IsAnyMouseDown() && GetCapture() == nullptr)
			SetCapture(hwnd);
		io.MouseDown[button] = true;
		return true;
	}
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_XBUTTONUP:
	{
		int button = 0;
		if (msg == WM_LBUTTONUP) button = 0;
		if (msg == WM_RBUTTONUP) button = 1;
		if (msg == WM_MBUTTONUP) button = 2;
		if (msg == WM_XBUTTONUP) button = (HIWORD(wParam) == XBUTTON1) ? 3 : 4;
		io.MouseDown[button] = false;
		if (!ImGui::IsAnyMouseDown() && GetCapture() == hwnd)
			ReleaseCapture();
		return true;
	}
	case WM_MOUSEWHEEL:
		io.MouseWheel += GET_WHEEL_DELTA_WPARAM(wParam) > 0 ? +1.0f : -1.0f;
		return true;
	case WM_MOUSEMOVE:
		io.MousePos.x = (signed short)(lParam);
		io.MousePos.y = (signed short)(lParam >> 16);
		return true;
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		if (wParam < 256)
			io.KeysDown[wParam] = true;
		return true;
	case WM_KEYUP:
	case WM_SYSKEYUP:
		if (wParam < 256)
			io.KeysDown[wParam] = false;
		return true;
	case WM_CHAR:
		// You can also use ToAscii()+GetKeyboardState() to retrieve characters.
		if (wParam > 0 && wParam < 0x10000)
			io.AddInputCharacter((unsigned short)wParam);
		return true;
	}
	return 0;
}


```

`CSGOSimple/imgui/impl/imgui_impl_win32.h`:

```h
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.

#pragma once

#include <Windows.h>

IMGUI_IMPL_API bool     ImGui_ImplWin32_Init(void* hwnd);
IMGUI_IMPL_API void     ImGui_ImplWin32_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplWin32_NewFrame();

// Handler for Win32 messages, update mouse/keyboard data.
// You may or not need this for your implementation, but it can serve as reference for handling inputs.
// Intentionally commented out to avoid dragging dependencies on <windows.h> types. You can COPY this line into your .cpp code instead.

IMGUI_IMPL_API LRESULT  ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);


```

`CSGOSimple/imgui/imstb_rectpack.h`:

```h
// [DEAR IMGUI] 
// This is a slightly modified version of stb_rect_pack.h 0.99. 
// Those changes would need to be pushed into nothings/stb:
// - Added STBRP__CDECL
// Grep for [DEAR IMGUI] to find the changes.

// stb_rect_pack.h - v0.99 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//    github:IntellectualKitty
//    
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//
// Version history:
//
//     0.99  (2019-02-07)  warning fixes
//     0.11  (2017-03-03)  return packing success/fail result
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   See end of file for license information.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct stbrp_context stbrp_context;
typedef struct stbrp_node    stbrp_node;
typedef struct stbrp_rect    stbrp_rect;

#ifdef STBRP_LARGE_RECTS
typedef int            stbrp_coord;
#else
typedef unsigned short stbrp_coord;
#endif

STBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);
// Assign packed locations to rectangles. The rectangles are of type
// 'stbrp_rect' defined below, stored in the array 'rects', and there
// are 'num_rects' many of them.
//
// Rectangles which are successfully packed have the 'was_packed' flag
// set to a non-zero value and 'x' and 'y' store the minimum location
// on each axis (i.e. bottom-left in cartesian coordinates, top-left
// if you imagine y increasing downwards). Rectangles which do not fit
// have the 'was_packed' flag set to 0.
//
// You should not try to access the 'rects' array from another thread
// while this function is running, as the function temporarily reorders
// the array while it executes.
//
// To pack into another rectangle, you need to call stbrp_init_target
// again. To continue packing into the same rectangle, you can call
// this function again. Calling this multiple times with multiple rect
// arrays will probably produce worse packing results than calling it
// a single time with the full rectangle array, but the option is
// available.
//
// The function returns 1 if all of the rectangles were successfully
// packed and 0 otherwise.

struct stbrp_rect
{
   // reserved for your use:
   int            id;

   // input:
   stbrp_coord    w, h;

   // output:
   stbrp_coord    x, y;
   int            was_packed;  // non-zero if valid packing

}; // 16 bytes, nominally


STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);
// Initialize a rectangle packer to:
//    pack a rectangle that is 'width' by 'height' in dimensions
//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
//
// You must call this function every time you start packing into a new target.
//
// There is no "shutdown" function. The 'nodes' memory must stay valid for
// the following stbrp_pack_rects() call (or calls), but can be freed after
// the call (or calls) finish.
//
// Note: to guarantee best results, either:
//       1. make sure 'num_nodes' >= 'width'
//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
//
// If you don't do either of the above things, widths will be quantized to multiples
// of small integers to guarantee the algorithm doesn't run out of temporary storage.
//
// If you do #2, then the non-quantized algorithm will be used, but the algorithm
// may run out of temporary storage and be unable to pack some rectangles.

STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);
// Optionally call this function after init but before doing any packing to
// change the handling of the out-of-temp-memory scenario, described above.
// If you call init again, this will be reset to the default (false).


STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);
// Optionally select which packing heuristic the library should use. Different
// heuristics will produce better/worse results for different data sets.
// If you call init again, this will be reset to the default.

enum
{
   STBRP_HEURISTIC_Skyline_default=0,
   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
   STBRP_HEURISTIC_Skyline_BF_sortHeight
};


//////////////////////////////////////////////////////////////////////////////
//
// the details of the following structures don't matter to you, but they must
// be visible so you can handle the memory allocations for them

struct stbrp_node
{
   stbrp_coord  x,y;
   stbrp_node  *next;
};

struct stbrp_context
{
   int width;
   int height;
   int align;
   int init_mode;
   int heuristic;
   int num_nodes;
   stbrp_node *active_head;
   stbrp_node *free_head;
   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

// [DEAR IMGUI] Added STBRP__CDECL
#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#define STBRP__CDECL __cdecl
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#define STBRP__CDECL
#endif

enum
{
   STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)
{
   switch (context->init_mode) {
      case STBRP__INIT_skyline:
         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);
         context->heuristic = heuristic;
         break;
      default:
         STBRP_ASSERT(0);
   }
}

STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)
{
   if (allow_out_of_mem)
      // if it's ok to run out of memory, then don't bother aligning them;
      // this gives better packing, but may fail due to OOM (even though
      // the rectangles easily fit). @TODO a smarter approach would be to only
      // quantize once we've hit OOM, then we could get rid of this parameter.
      context->align = 1;
   else {
      // if it's not ok to run out of memory, then quantize the widths
      // so that num_nodes is always enough nodes.
      //
      // I.e. num_nodes * align >= width
      //                  align >= width / num_nodes
      //                  align = ceil(width/num_nodes)

      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
   }
}

STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
{
   int i;
#ifndef STBRP_LARGE_RECTS
   STBRP_ASSERT(width <= 0xffff && height <= 0xffff);
#endif

   for (i=0; i < num_nodes-1; ++i)
      nodes[i].next = &nodes[i+1];
   nodes[i].next = NULL;
   context->init_mode = STBRP__INIT_skyline;
   context->heuristic = STBRP_HEURISTIC_Skyline_default;
   context->free_head = &nodes[0];
   context->active_head = &context->extra[0];
   context->width = width;
   context->height = height;
   context->num_nodes = num_nodes;
   stbrp_setup_allow_out_of_mem(context, 0);

   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
   context->extra[0].x = 0;
   context->extra[0].y = 0;
   context->extra[0].next = &context->extra[1];
   context->extra[1].x = (stbrp_coord) width;
#ifdef STBRP_LARGE_RECTS
   context->extra[1].y = (1<<30);
#else
   context->extra[1].y = 65535;
#endif
   context->extra[1].next = NULL;
}

// find minimum y position if it starts at x1
static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
{
   stbrp_node *node = first;
   int x1 = x0 + width;
   int min_y, visited_width, waste_area;

   STBRP__NOTUSED(c);

   STBRP_ASSERT(first->x <= x0);

   #if 0
   // skip in case we're past the node
   while (node->next->x <= x0)
      ++node;
   #else
   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
   #endif

   STBRP_ASSERT(node->x <= x0);

   min_y = 0;
   waste_area = 0;
   visited_width = 0;
   while (node->x < x1) {
      if (node->y > min_y) {
         // raise min_y higher.
         // we've accounted for all waste up to min_y,
         // but we'll now add more waste for everything we've visted
         waste_area += visited_width * (node->y - min_y);
         min_y = node->y;
         // the first time through, visited_width might be reduced
         if (node->x < x0)
            visited_width += node->next->x - x0;
         else
            visited_width += node->next->x - node->x;
      } else {
         // add waste area
         int under_width = node->next->x - node->x;
         if (under_width + visited_width > width)
            under_width = width - visited_width;
         waste_area += under_width * (min_y - node->y);
         visited_width += under_width;
      }
      node = node->next;
   }

   *pwaste = waste_area;
   return min_y;
}

typedef struct
{
   int x,y;
   stbrp_node **prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)
{
   int best_waste = (1<<30), best_x, best_y = (1 << 30);
   stbrp__findresult fr;
   stbrp_node **prev, *node, *tail, **best = NULL;

   // align to multiple of c->align
   width = (width + c->align - 1);
   width -= width % c->align;
   STBRP_ASSERT(width % c->align == 0);

   node = c->active_head;
   prev = &c->active_head;
   while (node->x + width <= c->width) {
      int y,waste;
      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
         // bottom left
         if (y < best_y) {
            best_y = y;
            best = prev;
         }
      } else {
         // best-fit
         if (y + height <= c->height) {
            // can only use it if it first vertically
            if (y < best_y || (y == best_y && waste < best_waste)) {
               best_y = y;
               best_waste = waste;
               best = prev;
            }
         }
      }
      prev = &node->next;
      node = node->next;
   }

   best_x = (best == NULL) ? 0 : (*best)->x;

   // if doing best-fit (BF), we also have to try aligning right edge to each node position
   //
   // e.g, if fitting
   //
   //     ____________________
   //    |____________________|
   //
   //            into
   //
   //   |                         |
   //   |             ____________|
   //   |____________|
   //
   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
   //
   // This makes BF take about 2x the time

   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
      tail = c->active_head;
      node = c->active_head;
      prev = &c->active_head;
      // find first node that's admissible
      while (tail->x < width)
         tail = tail->next;
      while (tail) {
         int xpos = tail->x - width;
         int y,waste;
         STBRP_ASSERT(xpos >= 0);
         // find the left position that matches this
         while (node->next->x <= xpos) {
            prev = &node->next;
            node = node->next;
         }
         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
         if (y + height < c->height) {
            if (y <= best_y) {
               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
                  best_x = xpos;
                  STBRP_ASSERT(y <= best_y);
                  best_y = y;
                  best_waste = waste;
                  best = prev;
               }
            }
         }
         tail = tail->next;
      }         
   }

   fr.prev_link = best;
   fr.x = best_x;
   fr.y = best_y;
   return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)
{
   // find best position according to heuristic
   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
   stbrp_node *node, *cur;

   // bail if:
   //    1. it failed
   //    2. the best node doesn't fit (we don't always check this)
   //    3. we're out of memory
   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
      res.prev_link = NULL;
      return res;
   }

   // on success, create new node
   node = context->free_head;
   node->x = (stbrp_coord) res.x;
   node->y = (stbrp_coord) (res.y + height);

   context->free_head = node->next;

   // insert the new node into the right starting point, and
   // let 'cur' point to the remaining nodes needing to be
   // stiched back in

   cur = *res.prev_link;
   if (cur->x < res.x) {
      // preserve the existing one, so start testing with the next one
      stbrp_node *next = cur->next;
      cur->next = node;
      cur = next;
   } else {
      *res.prev_link = node;
   }

   // from here, traverse cur and free the nodes, until we get to one
   // that shouldn't be freed
   while (cur->next && cur->next->x <= res.x + width) {
      stbrp_node *next = cur->next;
      // move the current node to the free list
      cur->next = context->free_head;
      context->free_head = cur;
      cur = next;
   }

   // stitch the list back in
   node->next = cur;

   if (cur->x < res.x + width)
      cur->x = (stbrp_coord) (res.x + width);

#ifdef _DEBUG
   cur = context->active_head;
   while (cur->x < context->width) {
      STBRP_ASSERT(cur->x < cur->next->x);
      cur = cur->next;
   }
   STBRP_ASSERT(cur->next == NULL);

   {
      int count=0;
      cur = context->active_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      cur = context->free_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      STBRP_ASSERT(count == context->num_nodes+2);
   }
#endif

   return res;
}

// [DEAR IMGUI] Added STBRP__CDECL
static int STBRP__CDECL rect_height_compare(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   if (p->h > q->h)
      return -1;
   if (p->h < q->h)
      return  1;
   return (p->w > q->w) ? -1 : (p->w < q->w);
}

// [DEAR IMGUI] Added STBRP__CDECL
static int STBRP__CDECL rect_original_order(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}

#ifdef STBRP_LARGE_RECTS
#define STBRP__MAXVAL  0xffffffff
#else
#define STBRP__MAXVAL  0xffff
#endif

STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)
{
   int i, all_rects_packed = 1;

   // we use the 'was_packed' field internally to allow sorting/unsorting
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = i;
   }

   // sort according to heuristic
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

   for (i=0; i < num_rects; ++i) {
      if (rects[i].w == 0 || rects[i].h == 0) {
         rects[i].x = rects[i].y = 0;  // empty rect needs no space
      } else {
         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
         if (fr.prev_link) {
            rects[i].x = (stbrp_coord) fr.x;
            rects[i].y = (stbrp_coord) fr.y;
         } else {
            rects[i].x = rects[i].y = STBRP__MAXVAL;
         }
      }
   }

   // unsort
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

   // set was_packed flags and all_rects_packed status
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
      if (!rects[i].was_packed)
         all_rects_packed = 0;
   }

   // return the all_rects_packed status
   return all_rects_packed;
}
#endif

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`CSGOSimple/imgui/imstb_textedit.h`:

```h
// [DEAR IMGUI] 
// This is a slightly modified version of stb_textedit.h 1.13. 
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// Grep for [DEAR IMGUI] to find the changes.

// stb_textedit.h - v1.13  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
// 
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining STB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATE_COUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHAR_COUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Todo:
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTED_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//     
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//     
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//     
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//     
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//     
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_STB_TEXTEDIT_H
#define INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef STB_TEXTEDIT_UNDOSTATECOUNT
#define STB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef STB_TEXTEDIT_UNDOCHARCOUNT
#define STB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef STB_TEXTEDIT_POSITIONTYPE
#define STB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
   // private data
   STB_TEXTEDIT_POSITIONTYPE  where;
   STB_TEXTEDIT_POSITIONTYPE  insert_length;
   STB_TEXTEDIT_POSITIONTYPE  delete_length;
   int                        char_storage;
} StbUndoRecord;

typedef struct
{
   // private data
   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];
   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];
   short undo_point, redo_point;
   int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
   /////////////////////
   //
   // public data
   //

   int cursor;
   // position of the text cursor within the string

   int select_start;          // selection start point
   int select_end;
   // selection start and end point in characters; if equal, no selection.
   // note that start may be less than or greater than end (e.g. when
   // dragging the mouse, start is where the initial click was, and you
   // can drag in either direction)

   unsigned char insert_mode;
   // each textfield keeps its own insert mode state. to keep an app-wide
   // insert mode, copy this value in/out of the app state

   /////////////////////
   //
   // private data
   //
   unsigned char cursor_at_end_of_line; // not implemented yet
   unsigned char initialized;
   unsigned char has_preferred_x;
   unsigned char single_line;
   unsigned char padding1, padding2, padding3;
   float preferred_x; // this determines where the cursor up/down tries to seek to along x
   StbUndoState undostate;
} STB_TexteditState;


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
   float x0,x1;             // starting x location, end x location (allows for align=right, etc)
   float baseline_y_delta;  // position of baseline relative to previous row's baseline
   float ymin,ymax;         // height of row above and below baseline
   int num_chars;
} StbTexteditRow;
#endif //INCLUDE_STB_TEXTEDIT_H


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////


// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef STB_TEXTEDIT_IMPLEMENTATION

#ifndef STB_TEXTEDIT_memmove
#include <string.h>
#define STB_TEXTEDIT_memmove memmove
#endif


/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)
{
   StbTexteditRow r;
   int n = STB_TEXTEDIT_STRINGLEN(str);
   float base_y = 0, prev_x;
   int i=0, k;

   r.x0 = r.x1 = 0;
   r.ymin = r.ymax = 0;
   r.num_chars = 0;

   // search rows to find one that straddles 'y'
   while (i < n) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (r.num_chars <= 0)
         return n;

      if (i==0 && y < base_y + r.ymin)
         return 0;

      if (y < base_y + r.ymax)
         break;

      i += r.num_chars;
      base_y += r.baseline_y_delta;
   }

   // below all text, return 'after' last character
   if (i >= n)
      return n;

   // check if it's before the beginning of the line
   if (x < r.x0)
      return i;

   // check if it's before the end of the line
   if (x < r.x1) {
      // search characters in row for one that straddles 'x'
      prev_x = r.x0;
      for (k=0; k < r.num_chars; ++k) {
         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
         if (x < prev_x+w) {
            if (x < prev_x+w/2)
               return k+i;
            else
               return k+i+1;
         }
         prev_x += w;
      }
      // shouldn't happen, but if it does, fall through to end-of-line case
   }

   // if the last character is a newline, return that. otherwise return 'after' the last character
   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)
      return i+r.num_chars-1;
   else
      return i+r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   state->cursor = stb_text_locate_coord(str, x, y);
   state->select_start = state->cursor;
   state->select_end = state->cursor;
   state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   int p = 0;

   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   if (state->select_start == state->select_end)
      state->select_start = state->cursor;

   p = stb_text_locate_coord(str, x, y);
   state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
   float x,y;    // position of n'th character
   float height; // height of line
   int first_char, length; // first char of row, and length
   int prev_first;  // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)
{
   StbTexteditRow r;
   int prev_start = 0;
   int z = STB_TEXTEDIT_STRINGLEN(str);
   int i=0, first;

   if (n == z) {
      // if it's at the end, then find the last line -- simpler than trying to
      // explicitly handle this case in the regular code
      if (single_line) {
         STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
         find->y = 0;
         find->first_char = 0;
         find->length = z;
         find->height = r.ymax - r.ymin;
         find->x = r.x1;
      } else {
         find->y = 0;
         find->x = 0;
         find->height = 1;
         while (i < z) {
            STB_TEXTEDIT_LAYOUTROW(&r, str, i);
            prev_start = i;
            i += r.num_chars;
         }
         find->first_char = i;
         find->length = 0;
         find->prev_first = prev_start;
      }
      return;
   }

   // search rows to find the one that straddles character n
   find->y = 0;

   for(;;) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (n < i + r.num_chars)
         break;
      prev_start = i;
      i += r.num_chars;
      find->y += r.baseline_y_delta;
   }

   find->first_char = first = i;
   find->length = r.num_chars;
   find->height = r.ymax - r.ymin;
   find->prev_first = prev_start;

   // now scan to find xpos
   find->x = r.x0;
   for (i=0; first+i < n; ++i)
      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   int n = STB_TEXTEDIT_STRINGLEN(str);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start > n) state->select_start = n;
      if (state->select_end   > n) state->select_end = n;
      // if clamping forced them to be equal, move the cursor to match
      if (state->select_start == state->select_end)
         state->cursor = state->select_start;
   }
   if (state->cursor > n) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
{
   stb_text_makeundo_delete(str, state, where, len);
   STB_TEXTEDIT_DELETECHARS(str, where, len);
   state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   stb_textedit_clamp(str, state);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start < state->select_end) {
         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
         state->select_end = state->cursor = state->select_start;
      } else {
         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
         state->select_start = state->cursor = state->select_end;
      }
      state->has_preferred_x = 0;
   }
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state)
{
   if (state->select_end < state->select_start) {
      int temp = state->select_end;
      state->select_end = state->select_start;
      state->select_start = temp;
   }
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      state->cursor = state->select_start;
      state->select_end = state->select_start;
      state->has_preferred_x = 0;
   }
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      stb_textedit_clamp(str, state);
      state->cursor = state->select_end;
      state->select_start = state->select_end;
      state->has_preferred_x = 0;
   }
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )
{
   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )
{
   --c; // always move at least one character
   while( c >= 0 && !is_word_boundary( str, c ) )
      --c;

   if( c < 0 )
      c = 0;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )
{
   const int len = STB_TEXTEDIT_STRINGLEN(str);
   ++c; // always move at least one character
   while( c < len && !is_word_boundary( str, c ) )
      ++c;

   if( c > len )
      c = len;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)
{
   if (!STB_TEXT_HAS_SELECTION(state))
      state->select_start = state->select_end = state->cursor;
   else
      state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_delete_selection(str,state); // implicitly clamps
      state->has_preferred_x = 0;
      return 1;
   }
   return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
{
   // if there's a selection, the paste should delete it
   stb_textedit_clamp(str, state);
   stb_textedit_delete_selection(str,state);
   // try to insert the characters
   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
      stb_text_makeundo_insert(state, state->cursor, len);
      state->cursor += len;
      state->has_preferred_x = 0;
      return 1;
   }
   // remove the undo since we didn't actually insert the characters
   if (state->undostate.undo_point)
      --state->undostate.undo_point;
   return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)
{
retry:
   switch (key) {
      default: {
         int c = STB_TEXTEDIT_KEYTOTEXT(key);
         if (c > 0) {
            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

            // can't add newline in single-line mode
            if (c == '\n' && state->single_line)
               break;

            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            } else {
               stb_textedit_delete_selection(str,state); // implicitly clamps
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  stb_text_makeundo_insert(state, state->cursor, 1);
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            }
         }
         break;
      }

#ifdef STB_TEXTEDIT_K_INSERT
      case STB_TEXTEDIT_K_INSERT:
         state->insert_mode = !state->insert_mode;
         break;
#endif
         
      case STB_TEXTEDIT_K_UNDO:
         stb_text_undo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_REDO:
         stb_text_redo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT:
         // if currently there's a selection, move cursor to start of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else 
            if (state->cursor > 0)
               --state->cursor;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_RIGHT:
         // if currently there's a selection, move cursor to end of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else
            ++state->cursor;
         stb_textedit_clamp(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         // move selection left
         if (state->select_end > 0)
            --state->select_end;
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
      case STB_TEXTEDIT_K_WORDLEFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
      case STB_TEXTEDIT_K_WORDRIGHT:
         if (STB_TEXT_HAS_SELECTION(state)) 
            stb_textedit_move_to_last(str, state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         // move selection right
         ++state->select_end;
         stb_textedit_clamp(str, state);
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_DOWN:
      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

         if (state->single_line) {
            // on windows, up&down in single-line behave like left&right
            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str,state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         // now find character position down a row
         if (find.length) {
            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            float x;
            int start = find.first_char + find.length;
            state->cursor = start;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;
         }
         break;
      }
         
      case STB_TEXTEDIT_K_UP:
      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

         if (state->single_line) {
            // on windows, up&down become left&right
            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         // can only go up if there's a previous row
         if (find.prev_first != find.first_char) {
            // now find character position up a row
            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            float x;
            state->cursor = find.prev_first;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;
         }
         break;
      }

      case STB_TEXTEDIT_K_DELETE:
      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            int n = STB_TEXTEDIT_STRINGLEN(str);
            if (state->cursor < n)
               stb_textedit_delete(str, state, state->cursor, 1);
         }
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_BACKSPACE:
      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            stb_textedit_clamp(str, state);
            if (state->cursor > 0) {
               stb_textedit_delete(str, state, state->cursor-1, 1);
               --state->cursor;
            }
         }
         state->has_preferred_x = 0;
         break;
         
#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2:
#endif
      case STB_TEXTEDIT_K_TEXTSTART:
         state->cursor = state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2:
#endif
      case STB_TEXTEDIT_K_TEXTEND:
         state->cursor = STB_TEXTEDIT_STRINGLEN(str);
         state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;
        
#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
         state->has_preferred_x = 0;
         break;


#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2:
#endif
      case STB_TEXTEDIT_K_LINESTART:
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2:
#endif
      case STB_TEXTEDIT_K_LINEEND: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
             ++state->cursor;
         state->has_preferred_x = 0;
         break;
      }

#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
            ++state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;
      }

// @TODO:
//    STB_TEXTEDIT_K_PGUP      - move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
   }
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state)
{
   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state)
{
   if (state->undo_point > 0) {
      // if the 0th undo state has characters, clean those up
      if (state->undo_rec[0].char_storage >= 0) {
         int n = state->undo_rec[0].insert_length, i;
         // delete n characters from all other records
         state->undo_char_point -= n;
         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));
         for (i=0; i < state->undo_point; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
      }
      --state->undo_point;
      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));
   }
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state)
{
   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;

   if (state->redo_point <= k) {
      // if the k'th undo state has characters, clean those up
      if (state->undo_rec[k].char_storage >= 0) {
         int n = state->undo_rec[k].insert_length, i;
         // move the remaining redo character data to the end of the buffer
         state->redo_char_point += n;
         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));
         // adjust the position of all the other records to account for above memmove
         for (i=state->redo_point; i < k; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage += n;
      }
      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
      // {DEAR IMGUI]
      size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));
      const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;
      const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);

      // now move redo_point to point to the new one
      ++state->redo_point;
   }
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)
{
   // any time we create a new undo record, we discard redo
   stb_textedit_flush_redo(state);

   // if we have no free records, we have to make room, by sliding the
   // existing records down
   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      stb_textedit_discard_undo(state);

   // if the characters to store won't possibly fit in the buffer, we can't undo
   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {
      state->undo_point = 0;
      state->undo_char_point = 0;
      return NULL;
   }

   // if we don't have enough free characters in the buffer, we have to make room
   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)
      stb_textedit_discard_undo(state);

   return &state->undo_rec[state->undo_point++];
}

static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)
{
   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
   if (r == NULL)
      return NULL;

   r->where = pos;
   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;
   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;

   if (insert_len == 0) {
      r->char_storage = -1;
      return NULL;
   } else {
      r->char_storage = state->undo_char_point;
      state->undo_char_point += insert_len;
      return &state->undo_char[r->char_storage];
   }
}

static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord u, *r;
   if (s->undo_point == 0)
      return;

   // we need to do two things: apply the undo record, and create a redo record
   u = s->undo_rec[s->undo_point-1];
   r = &s->undo_rec[s->redo_point-1];
   r->char_storage = -1;

   r->insert_length = u.delete_length;
   r->delete_length = u.insert_length;
   r->where = u.where;

   if (u.delete_length) {
      // if the undo record says to delete characters, then the redo record will
      // need to re-insert the characters that get deleted, so we need to store
      // them.

      // there are three cases:
      //    there's enough room to store the characters
      //    characters stored for *redoing* don't leave room for redo
      //    characters stored for *undoing* don't leave room for redo
      // if the last is true, we have to bail

      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {
         // the undo records take up too much character space; there's no space to store the redo characters
         r->insert_length = 0;
      } else {
         int i;

         // there's definitely room to store the characters eventually
         while (s->undo_char_point + u.delete_length > s->redo_char_point) {
            // should never happen:
            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
               return;
            // there's currently not enough room, so discard a redo record
            stb_textedit_discard_redo(s);
         }
         r = &s->undo_rec[s->redo_point-1];

         r->char_storage = s->redo_char_point - u.delete_length;
         s->redo_char_point = s->redo_char_point - u.delete_length;

         // now save the characters
         for (i=0; i < u.delete_length; ++i)
            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
      }

      // now we can carry out the deletion
      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
   }

   // check type of recorded action:
   if (u.insert_length) {
      // easy case: was a deletion, so we need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
      s->undo_char_point -= u.insert_length;
   }

   state->cursor = u.where + u.insert_length;

   s->undo_point--;
   s->redo_point--;
}

static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord *u, r;
   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      return;

   // we need to do two things: apply the redo record, and create an undo record
   u = &s->undo_rec[s->undo_point];
   r = s->undo_rec[s->redo_point];

   // we KNOW there must be room for the undo record, because the redo record
   // was derived from an undo record

   u->delete_length = r.insert_length;
   u->insert_length = r.delete_length;
   u->where = r.where;
   u->char_storage = -1;

   if (r.delete_length) {
      // the redo record requires us to delete characters, so the undo record
      // needs to store the characters

      if (s->undo_char_point + u->insert_length > s->redo_char_point) {
         u->insert_length = 0;
         u->delete_length = 0;
      } else {
         int i;
         u->char_storage = s->undo_char_point;
         s->undo_char_point = s->undo_char_point + u->insert_length;

         // now save the characters
         for (i=0; i < u->insert_length; ++i)
            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
      }

      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
   }

   if (r.insert_length) {
      // easy case: need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
      s->redo_char_point += r.insert_length;
   }

   state->cursor = r.where + r.insert_length;

   s->undo_point++;
   s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)
{
   stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
   if (p) {
      for (i=0; i < length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
   if (p) {
      for (i=0; i < old_length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)
{
   state->undostate.undo_point = 0;
   state->undostate.undo_char_point = 0;
   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
   state->select_end = state->select_start = 0;
   state->cursor = 0;
   state->has_preferred_x = 0;
   state->preferred_x = 0;
   state->cursor_at_end_of_line = 0;
   state->initialized = 1;
   state->single_line = (unsigned char) is_single_line;
   state->insert_mode = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
{
   stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)
{
   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif//STB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`CSGOSimple/imgui/imstb_truetype.h`:

```h
// [DEAR IMGUI] 
// This is a slightly modified version of stb_truetype.h 1.20.
// Mostly fixing for compiler and static analyzer warnings.
// Grep for [DEAR IMGUI] to find the changes.

// stb_truetype.h - v1.20 - public domain
// authored from 2009-2016 by Sean Barrett / RAD Game Tools
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//   Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//       Imanol Celaya
//       Daniel Ribeiro Maciel
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket       Fabian "ryg" Giesen
//       Cass Everitt               Martins Mozeiko
//       stoiko (Haemimont Games)   Cap Petschulat
//       Brian Hook                 Omar Cornut
//       Walter van Niftrik         github:aloucks
//       David Gow                  Peter LaValle
//       David Given                Sergey Popov
//       Ivan-Assen Ivanov          Giumo X. Clanjor
//       Anthony Pesch              Higor Euripedes
//       Johan Duparc               Thomas Fields
//       Hou Qiming                 Derek Vinyard
//       Rob Loach                  Cort Stratton
//       Kenney Phillis Jr.         github:oyvindjam
//       Brian Costabile            github:vassvik
//       
// VERSION HISTORY
//
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   See end of file for license information.
//
// USAGE
//
//   Include this file in whatever places need to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversampling()          -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetFontVMetricsOS2()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// DETAILED USAGE:
//
//  Scale:
//    Select how high you want the font to be, in points or pixels.
//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//    a scale factor SF that will be used by all other functions.
//
//  Baseline:
//    You need to select a y-coordinate that is the baseline of where
//    your text will appear. Call GetFontBoundingBox to get the baseline-relative
//    bounding box for all characters. SF*-y0 will be the distance in pixels
//    that the worst-case character could extend above the baseline, so if
//    you want the top edge of characters to appear at the top of the
//    screen where y=0, then you would set the baseline to SF*-y0.
//
//  Current point:
//    Set the current point where the first character will appear. The
//    first character could extend left of the current point; this is font
//    dependent. You can either choose a current point that is the leftmost
//    point and hope, or add some padding, or check the bounding box or
//    left-side-bearing of the first character to be displayed and set
//    the current point based on that.
//
//  Displaying a character:
//    Compute the bounding box of the character. It will contain signed values
//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//    then the character should be displayed in the rectangle from
//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//  Advancing for the next character:
//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
// 
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// SOURCE STATISTICS (based on v0.6c, 2050 LOC)
//
//   Documentation & header file        520 LOC  \___ 660 LOC documentation
//   Sample code                        140 LOC  /
//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType
//   Software rasterization             240 LOC  \.
//   Curve tessellation                 120 LOC   \__ 550 LOC Bitmap creation
//   Bitmap management                  100 LOC   /
//   Baked bitmap interface              70 LOC  /
//   Font name matching & access        150 LOC  ---- 150 
//   C runtime library abstraction       60 LOC  ----  60
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless
//
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1<<20];
unsigned char temp_bitmap[512*512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!
   // can free ttf_buffer at this point
   glGenTextures(1, &ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
   // can free temp_bitmap at this point
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
   // assume orthographic projection with units = screen pixels, origin at top left
   glEnable(GL_TEXTURE_2D);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glBegin(GL_QUADS);
   while (*text) {
      if (*text >= 32 && *text < 128) {
         stbtt_aligned_quad q;
         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9
         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y0);
         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y0);
         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y1);
         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y1);
      }
      ++text;
   }
   glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1<<25];

int main(int argc, char **argv)
{
   stbtt_fontinfo font;
   unsigned char *bitmap;
   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);

   for (j=0; j < h; ++j) {
      for (i=0; i < w; ++i)
         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
      putchar('\n');
   }
   return 0;
}
#endif 
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//  
//////////////////////////////////////////////////////////////////////////////
// 
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24<<20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
   stbtt_fontinfo font;
   int i,j,ascent,baseline,ch=0;
   float scale, xpos=2; // leave a little padding in case the character extends left
   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
   stbtt_InitFont(&font, buffer, 0);

   scale = stbtt_ScaleForPixelHeight(&font, 15);
   stbtt_GetFontVMetrics(&font, &ascent,0,0);
   baseline = (int) (ascent*scale);

   while (text[ch]) {
      int advance,lsb,x0,y0,x1,y1;
      float x_shift = xpos - (float) floor(xpos);
      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
      // because this API is really for baking character bitmaps into textures. if you want to render
      // a sequence of characters, you really need to render each bitmap to a temp buffer, then
      // "alpha blend" that into the working buffer
      xpos += (advance * scale);
      if (text[ch+1])
         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
      ++ch;
   }

   for (j=0; j < 20; ++j) {
      for (i=0; i < 78; ++i)
         putchar(" .:ioVM@"[screen[j][i]>>5]);
      putchar('\n');
   }

   return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype, e.g. if you don't
////   link with the C runtime library.

#ifdef STB_TRUETYPE_IMPLEMENTATION
   // #define your own (u)stbtt_int8/16/32 before including to override this
   #ifndef stbtt_uint8
   typedef unsigned char   stbtt_uint8;
   typedef signed   char   stbtt_int8;
   typedef unsigned short  stbtt_uint16;
   typedef signed   short  stbtt_int16;
   typedef unsigned int    stbtt_uint32;
   typedef signed   int    stbtt_int32;
   #endif

   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];

   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
   #ifndef STBTT_ifloor
   #include <math.h>
   #define STBTT_ifloor(x)   ((int) floor(x))
   #define STBTT_iceil(x)    ((int) ceil(x))
   #endif

   #ifndef STBTT_sqrt
   #include <math.h>
   #define STBTT_sqrt(x)      sqrt(x)
   #define STBTT_pow(x,y)     pow(x,y)
   #endif

   #ifndef STBTT_fmod
   #include <math.h>
   #define STBTT_fmod(x,y)    fmod(x,y)
   #endif

   #ifndef STBTT_cos
   #include <math.h>
   #define STBTT_cos(x)       cos(x)
   #define STBTT_acos(x)      acos(x)
   #endif

   #ifndef STBTT_fabs
   #include <math.h>
   #define STBTT_fabs(x)      fabs(x)
   #endif

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #include <stdlib.h>
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

   #ifndef STBTT_assert
   #include <assert.h>
   #define STBTT_assert(x)    assert(x)
   #endif

   #ifndef STBTT_strlen
   #include <string.h>
   #define STBTT_strlen(x)    strlen(x)
   #endif

   #ifndef STBTT_memcpy
   #include <string.h>
   #define STBTT_memcpy       memcpy
   #define STBTT_memset       memset
   #endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

//////////////////////////////////////////////////////////////////////////////
//
// TEXTURE BAKING API
//
// If you use this API, you only have to call two functions ever.
//

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
} stbtt_bakedchar;

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
// if return is positive, the first unused row of the bitmap
// if return is negative, returns the negative of the number of characters that fit
// if return is 0, no characters fit and no rows were used
// This uses a very crappy packing.

typedef struct
{
   float x0,y0,s0,t0; // top-left
   float x1,y1,s1,t1; // bottom-right
} stbtt_aligned_quad;

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
// Call GetBakedQuad with char_index = 'character - first_char', and it
// creates the quad you need to draw and advances the current position.
//
// The coordinate system used assumes y increases downwards.
//
// Characters will extend both above and below the current position;
// see discussion of "BASELINE" above.
//
// It's inefficient; you might want to c&p it and optimize it.

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);
// Query the font vertical metrics without having to create a font first.


//////////////////////////////////////////////////////////////////////////////
//
// NEW TEXTURE BAKING API
//
// This provides options for packing multiple fonts into one atlas, not
// perfectly but better than nothing.

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
   float xoff2,yoff2;
} stbtt_packedchar;

typedef struct stbtt_pack_context stbtt_pack_context;
typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
typedef struct stbrp_rect stbrp_rect;
#endif

STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
// Initializes a packing context stored in the passed-in stbtt_pack_context.
// Future calls using this context will pack characters into the bitmap passed
// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
// the distance from one row to the next (or 0 to mean they are packed tightly
// together). "padding" is the amount of padding to leave between each
// character (normally you want '1' for bitmaps you'll use as textures with
// bilinear filtering).
//
// Returns 0 on failure, 1 on success.

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
// Creates character bitmaps from the font_index'th font found in fontdata (use
// font_index=0 if you don't know what that is). It creates num_chars_in_range
// bitmaps for characters with unicode values starting at first_unicode_char_in_range
// and increasing. Data for how to render them is stored in chardata_for_range;
// pass these to stbtt_GetPackedQuad to get back renderable quads.
//
// font_size is the full height of the character from ascender to descender,
// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
// and pass that result as 'font_size':
//       ...,                  20 , ... // font max minus min y is 20 pixels tall
//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

typedef struct
{
   float font_size;
   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
   int num_chars;
   stbtt_packedchar *chardata_for_range; // output
   unsigned char h_oversample, v_oversample; // don't set these, they're used internally
} stbtt_pack_range;

STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
// Creates character bitmaps from multiple ranges of characters stored in
// ranges. This will usually create a better-packed bitmap than multiple
// calls to stbtt_PackFontRange. Note that you can call this multiple
// times within a single PackBegin/PackEnd.

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
// Oversampling a font increases the quality by allowing higher-quality subpixel
// positioning, and is especially valuable at smaller text sizes.
//
// This function sets the amount of oversampling for all following calls to
// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
// pack context. The default (no oversampling) is achieved by h_oversample=1
// and v_oversample=1. The total number of pixels required is
// h_oversample*v_oversample larger than the default; for example, 2x2
// oversampling requires 4x the storage of 1x1. For best results, render
// oversampled textures with bilinear filtering. Look at the readme in
// stb/tests/oversample for information about oversampled fonts
//
// To use with PackFontRangesGather etc., you must set it before calls
// call to PackFontRangesGatherRects.

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);
// If skip != 0, this tells stb_truetype to skip any codepoints for which
// there is no corresponding glyph. If skip=0, which is the default, then
// codepoints without a glyph recived the font's "missing character" glyph,
// typically an empty box by convention.

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int align_to_integer);

STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
// Calling these functions in sequence is roughly equivalent to calling
// stbtt_PackFontRanges(). If you more control over the packing of multiple
// fonts, or if you want to pack custom data into a font texture, take a look
// at the source to of stbtt_PackFontRanges() and create a custom version 
// using these functions, e.g. call GatherRects multiple times,
// building up a single array of rects, then call PackRects once,
// then call RenderIntoRects repeatedly. This may result in a
// better packing than calling PackFontRanges multiple times
// (or it may not).

// this is an opaque structure that you shouldn't mess with which holds
// all the context needed from PackBegin to PackEnd.
struct stbtt_pack_context {
   void *user_allocator_context;
   void *pack_info;
   int   width;
   int   height;
   int   stride_in_bytes;
   int   padding;
   int   skip_missing;
   unsigned int   h_oversample, v_oversample;
   unsigned char *pixels;
   void  *nodes;
};

//////////////////////////////////////////////////////////////////////////////
//
// FONT LOADING
//
//

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
// This function will determine the number of fonts in a font file.  TrueType
// collection (.ttc) files may contain multiple fonts, while TrueType font
// (.ttf) files only contain one font. The number of fonts can be used for
// indexing with the previous function where the index is between zero and one
// less than the total fonts. If an error occurs, -1 is returned.

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
// Each .ttf/.ttc file may have more than one font. Each font has a sequential
// index number starting from 0. Call this function to get the font offset for
// a given index; it returns -1 if the index is out of range. A regular .ttf
// file will only define one font and it always be at offset 0, so it will
// return '0' for index 0, and -1 for all other indices.

// The following structure is defined publicly so you can declare one on
// the stack or as a global or etc, but you should treat it as opaque.
struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
// Given an offset into the file that defines a font, this function builds
// the necessary cached info for the rest of the system. You must allocate
// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
// need to do anything special to free it, because the contents are pure
// value data with no additional data structures. Returns 0 on failure.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER TO GLYPH-INDEX CONVERSIOn

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
// If you're going to perform multiple operations on the same character
// and you want a speed-up, call this function with the character you're
// going to process, then use glyph-based functions instead of the
// codepoint-based functions.
// Returns 0 if the character codepoint is not defined in the font.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER PROPERTIES
//

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose "height" is 'pixels' tall.
// Height is measured as the distance from the highest ascender to the lowest
// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
// and computing:
//       scale = pixels / (ascent - descent)
// so if you prefer to measure height by the ascent only, use a similar calculation.

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose EM size is mapped to
// 'pixels' tall. This is probably what traditional APIs compute, but
// I'm not positive.

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
// ascent is the coordinate above the baseline the font extends; descent
// is the coordinate below the baseline the font extends (i.e. it is typically negative)
// lineGap is the spacing between one row's descent and the next row's ascent...
// so you should advance the vertical position by "*ascent - *descent + *lineGap"
//   these are expressed in unscaled coordinates, so you must multiply by
//   the scale factor for a given size

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
// table (specific to MS/Windows TTF files).
//
// Returns 1 on success (table present), 0 on failure.

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
// the bounding box around all possible characters

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
// leftSideBearing is the offset from the current horizontal position to the left edge of the character
// advanceWidth is the offset from the current horizontal position to the next horizontal position
//   these are expressed in unscaled coordinates

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
// an additional amount to add to the 'advance' value between ch1 and ch2

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
// as above, but takes one or more glyph indices for greater efficiency


//////////////////////////////////////////////////////////////////////////////
//
// GLYPH SHAPES (you probably don't need these, but they have to go before
// the bitmaps for C declaration-order reasons)
//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
// returns non-zero if nothing is drawn for this glyph

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
// returns # of vertices and fills *vertices with the pointer to them
//   these are expressed in "unscaled" coordinates
//
// The shape is a series of contours. Each one starts with
// a STBTT_moveto, then consists of a series of mixed
// STBTT_lineto and STBTT_curveto segments. A lineto
// draws a line from previous endpoint to its x,y; a curveto
// draws a quadratic bezier from previous endpoint to
// its x,y, using cx,cy as the bezier control point.

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
// frees the data allocated above

//////////////////////////////////////////////////////////////////////////////
//
// BITMAP RENDERING
//

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
// frees the bitmap allocated below

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// allocates a large-enough single-channel 8bpp bitmap and renders the
// specified character/glyph at the specified scale into it, with
// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
// *width & *height are filled out with the width & height of the bitmap,
// which is stored left-to-right, top-to-bottom.
//
// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
// width and height and positioning info for it first.

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
// is performed (see stbtt_PackSetOversampling)

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
// get the bbox of the bitmap centered around the glyph origin; so the
// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
// the bitmap top left is (leftSideBearing*scale,iy0).
// (Note that the bitmap uses y-increases-down, but the shape uses
// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
// shift for the character

// the following functions are equivalent to the above functions, but operate
// on glyph indices instead of Unicode codepoints (for efficiency)
STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

//////////////////////////////////////////////////////////////////////////////
//
// Signed Distance Function (or Field) rendering

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
// frees the SDF bitmap allocated below

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
// These functions compute a discretized SDF field for a single character, suitable for storing
// in a single-channel texture, sampling with bilinear filtering, and testing against
// larger than some threshold to produce scalable fonts.
//        info              --  the font
//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
//        glyph/codepoint   --  the character to generate the SDF for
//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
//                                 which allows effects like bit outlines
//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
//        width,height      --  output height & width of the SDF bitmap (including padding)
//        xoff,yoff         --  output origin of the character
//        return value      --  a 2D array of bytes 0..255, width*height in size
//
// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
// optimal use of the limited 0..255 for your application, trading off precision
// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
//
// Example:
//      scale = stbtt_ScaleForPixelHeight(22)
//      padding = 5
//      onedge_value = 180
//      pixel_dist_scale = 180/5.0 = 36.0
//
//      This will create an SDF bitmap in which the character is about 22 pixels
//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
//      shape, sample the SDF at each pixel and fill the pixel if the SDF value
//      is greater than or equal to 180/255. (You'll actually want to antialias,
//      which is beyond the scope of this example.) Additionally, you can compute
//      offset outlines (e.g. to stroke the character border inside & outside,
//      or only outside). For example, to fill outside the character up to 3 SDF
//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
//      choice of variables maps a range from 5 pixels outside the shape to
//      2 pixels inside the shape to 0..255; this is intended primarily for apply
//      outside effects only (the interior range is needed to allow proper
//      antialiasing of the font at *smaller* sizes)
//
// The function computes the SDF analytically at each SDF pixel, not by e.g.
// building a higher-res bitmap and approximating it. In theory the quality
// should be as high as possible for an SDF of this size & representation, but
// unclear if this is true in practice (perhaps building a higher-res bitmap
// and computing from that can allow drop-out prevention).
//
// The algorithm has not been optimized at all, so expect it to be slow
// if computing lots of characters or very large sizes. 



//////////////////////////////////////////////////////////////////////////////
//
// Finding the right font...
//
// You should really just solve this offline, keep your own tables
// of what font is what, and don't try to get it out of the .ttf file.
// That's because getting it out of the .ttf file is really hard, because
// the names in the file can appear in many possible encodings, in many
// possible languages, and e.g. if you need a case-insensitive comparison,
// the details of that depend on the encoding & language in a complex way
// (actually underspecified in truetype, but also gigantic).
//
// But you can use the provided functions in two possible ways:
//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
//             unicode-encoded names to try to find the font you want;
//             you can run this before calling stbtt_InitFont()
//
//     stbtt_GetFontNameString() lets you get any of the various strings
//             from the file yourself and do your own comparisons on them.
//             You have to have called stbtt_InitFont() first.


STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
// returns the offset (not index) of the font that matches, or -1 if none
//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
//   if you use any other flag, use a font name like "Arial"; this checks
//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
// returns 1/0 whether the first string interpreted as utf8 is identical to
// the second string interpreted as big-endian utf16... useful for strings from next func

STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
// returns the string (which may be big-endian double byte, e.g. for unicode)
// and puts the length in bytes in *length.
//
// some of the values for the IDs are below; for more see the truetype spec:
//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
//     http://www.microsoft.com/typography/otspec/name.htm

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf *b, int o)
{
   STBTT_assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
{
   stbtt_uint32 v = 0;
   int i;
   STBTT_assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

static stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   STBTT_assert(size < 0x40000000);
   r.data = (stbtt_uint8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      STBTT_assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   STBTT_assert(0);
   return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   STBTT_assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   STBTT_assert(i >= 0 && i < count);
   STBTT_assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8 *font)
{
   // check the version number
   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
   return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
   stbtt_uint32 tabledir = fontstart + 12;
   stbtt_int32 i;
   for (i=0; i < num_tables; ++i) {
      stbtt_uint32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
{
   // if it's just a font, there's only one valid index
   if (stbtt__isfont(font_collection))
      return index == 0 ? 0 : -1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         stbtt_int32 n = ttLONG(font_collection+8);
         if (index >= n)
            return -1;
         return ttULONG(font_collection+12+index*4);
      }
   }
   return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
{
   // if it's just a font, there's only one valid font
   if (stbtt__isfont(font_collection))
      return 1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         return ttLONG(font_collection+8);
      }
   }
   return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
{
   stbtt_uint32 cmap, t;
   stbtt_int32 i,numTables;

   info->data = data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      stbtt_uint32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   // find a cmap encoding table we understand *now* to avoid searching
   // later. (todo: could make this installable)
   // the same regardless of glyph.
   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint32 index_map = info->index_map;

   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      stbtt_uint32 endCount = index_map + 14;
      stbtt_uint32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         stbtt_uint16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         stbtt_uint16 offset, start;
         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

         STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         if (unicode_codepoint < start)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      stbtt_int32 low,high;
      low = 0; high = (stbtt_int32)ngroups;
      // Binary search the right group.
      while (low < high) {
         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((stbtt_uint32) unicode_codepoint < start_char)
            high = mid;
         else if ((stbtt_uint32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   STBTT_assert(0);
   return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
   v->type = type;
   v->x = (stbtt_int16) x;
   v->y = (stbtt_int16) y;
   v->cx = (stbtt_int16) cx;
   v->cy = (stbtt_int16) cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   STBTT_assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt_int16 numberOfContours;
   int g;
   if (info->cff.size)
      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
   g = stbtt__GetGlyfOffset(info, glyph_index);
   if (g < 0) return 1;
   numberOfContours = ttSHORT(info->data + g);
   return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   stbtt_int16 numberOfContours;
   stbtt_uint8 *endPtsOfContours;
   stbtt_uint8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      stbtt_uint8 flags=0,flagcount;
      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      stbtt_uint8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      // in first pass, we load uninterpreted data into the allocated array
      // above, shifted to the end of the array so we won't overwrite it when
      // we create our final data starting from the front

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            stbtt_int16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (stbtt_int16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            stbtt_int16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (stbtt_int16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (stbtt_int16) vertices[off+i].x;
         y     = (stbtt_int16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one               
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (stbtt_int32) vertices[off+i+1].x;
                  sy = (stbtt_int32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours == -1) {
      // Compound shapes.
      int more = 1;
      stbtt_uint8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         stbtt_uint16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;
         
         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            STBTT_assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }
         
         // Find transformation scales.
         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex)); //-V595
            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else if (numberOfContours < 0) {
      // @TODO other compound variations?
      STBTT_assert(0);
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   stbtt_int32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
   }
   c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) stbtt__new_buf(NULL, 0);
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // fallthrough
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (STBTT_fabs(dx) > STBTT_fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254)) //-V560
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(stbtt_int16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   if (glyph_index < numOfLongHorMetrics) {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   } else {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
   }
}

static int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint8 *data = info->data + info->kern;
   stbtt_uint32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

static stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
{
    stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
    switch(coverageFormat) {
        case 1: {
            stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

            // Binary search.
            stbtt_int32 l=0, r=glyphCount-1, m;
            int straw, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *glyphArray = coverageTable + 4;
                stbtt_uint16 glyphID;
                m = (l + r) >> 1;
                glyphID = ttUSHORT(glyphArray + 2 * m);
                straw = glyphID;
                if (needle < straw)
                    r = m - 1;
                else if (needle > straw)
                    l = m + 1;
                else {
                     return m;
                }
            }
        } break;

        case 2: {
            stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
            stbtt_uint8 *rangeArray = coverageTable + 4;

            // Binary search.
            stbtt_int32 l=0, r=rangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *rangeRecord;
                m = (l + r) >> 1;
                rangeRecord = rangeArray + 6 * m;
                strawStart = ttUSHORT(rangeRecord);
                strawEnd = ttUSHORT(rangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else {
                    stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
                    return startCoverageIndex + glyph - strawStart;
                }
            }
        } break;

        default: {
            // There are no other cases.
            STBTT_assert(0);
        } break;
    }

    return -1;
}

static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
{
    stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
    switch(classDefFormat)
    {
        case 1: {
            stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
            stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
            stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
                return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

            // [DEAR IMGUI] Commented to fix static analyzer warning
            //classDefTable = classDef1ValueArray + 2 * glyphCount;
        } break;

        case 2: {
            stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
            stbtt_uint8 *classRangeRecords = classDefTable + 4;

            // Binary search.
            stbtt_int32 l=0, r=classRangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *classRangeRecord;
                m = (l + r) >> 1;
                classRangeRecord = classRangeRecords + 6 * m;
                strawStart = ttUSHORT(classRangeRecord);
                strawEnd = ttUSHORT(classRangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else
                    return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
            }

            // [DEAR IMGUI] Commented to fix static analyzer warning
            //classDefTable = classRangeRecords + 6 * classRangeCount;
        } break;

        default: {
            // There are no other cases.
            STBTT_assert(0);
        } break;
    }

    return -1;
}

// Define to STBTT_assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
    stbtt_uint16 lookupListOffset;
    stbtt_uint8 *lookupList;
    stbtt_uint16 lookupCount;
    stbtt_uint8 *data;
    stbtt_int32 i;

    if (!info->gpos) return 0;

    data = info->data + info->gpos;

    if (ttUSHORT(data+0) != 1) return 0; // Major version 1
    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

    lookupListOffset = ttUSHORT(data+8);
    lookupList = data + lookupListOffset;
    lookupCount = ttUSHORT(lookupList);

    for (i=0; i<lookupCount; ++i) {
        stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
        stbtt_uint8 *lookupTable = lookupList + lookupOffset;

        stbtt_uint16 lookupType = ttUSHORT(lookupTable);
        stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
        stbtt_uint8 *subTableOffsets = lookupTable + 6;
        switch(lookupType) {
            case 2: { // Pair Adjustment Positioning Subtable
                stbtt_int32 sti;
                for (sti=0; sti<subTableCount; sti++) {
                    stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
                    stbtt_uint8 *table = lookupTable + subtableOffset;
                    stbtt_uint16 posFormat = ttUSHORT(table);
                    stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
                    stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
                    if (coverageIndex == -1) continue;

                    switch (posFormat) {
                        case 1: {
                            stbtt_int32 l, r, m;
                            int straw, needle;
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
                            stbtt_int32 valueRecordPairSizeInBytes = 2;
                            stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
                            stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                            stbtt_uint8 *pairValueTable = table + pairPosOffset;
                            stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
                            stbtt_uint8 *pairValueArray = pairValueTable + 2;
                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            STBTT_assert(coverageIndex < pairSetCount);
                            STBTT__NOTUSED(pairSetCount);

                            needle=glyph2;
                            r=pairValueCount-1;
                            l=0;

                            // Binary search.
                            while (l <= r) {
                                stbtt_uint16 secondGlyph;
                                stbtt_uint8 *pairValue;
                                m = (l + r) >> 1;
                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                                secondGlyph = ttUSHORT(pairValue);
                                straw = secondGlyph;
                                if (needle < straw)
                                    r = m - 1;
                                else if (needle > straw)
                                    l = m + 1;
                                else {
                                    stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
                                    return xAdvance;
                                }
                            }
                        } break;

                        case 2: {
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);

                            stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
                            stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                            stbtt_uint16 class1Count = ttUSHORT(table + 12);
                            stbtt_uint16 class2Count = ttUSHORT(table + 14);
                            STBTT_assert(glyph1class < class1Count);
                            STBTT_assert(glyph2class < class2Count);

                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
                                stbtt_uint8 *class1Records = table + 16;
                                stbtt_uint8 *class2Records = class1Records + 2 * (glyph1class * class2Count);
                                stbtt_int16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                                return xAdvance;
                            }
                        } break;

                        default: {
                            // There are no other cases.
                            STBTT_assert(0);
                            break;
                        };
                    }
                }
                break;
            };

            default:
                // TODO: Implement other stuff.
                break;
        }
    }

    return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);

   if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
      return 0;
   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
{
   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
   if (!tab)
      return 0;
   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
   return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
   *x0 = ttSHORT(info->data + info->head + 36);
   *y0 = ttSHORT(info->data + info->head + 38);
   *x1 = ttSHORT(info->data + info->head + 40);
   *y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
   return (float) height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
   return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
   STBTT_free(v, info->userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   if (!z) return z;
   
   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
   else
      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   //STBTT_assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
               }
            }
         }
      }
      
      e = e->next;
   }
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      STBTT_memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               STBTT_assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   STBTT_assert(y0 < y1);
   STBTT_assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      STBTT_assert(x1 <= x+1);
   else if (x0 == x+1)
      STBTT_assert(x1 >= x);
   else if (x0 <= x)
      STBTT_assert(x1 <= x);
   else if (x0 >= x+1)
      STBTT_assert(x1 >= x+1);
   else
      STBTT_assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      STBTT_assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

         // compute endpoints of line segment clipped to this scanline (if the
         // line segment starts on this scanline. x0 is the intersection of the
         // line with y_top, but that may be off the line segment.
         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = sy1 - sy0;
               STBTT_assert(x >= 0 && x < len);
               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;
               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
                  // [DEAR IMGUI] Fix static analyzer warning
                  (void)dx; // [ImGui: fix static analyzer warning]
               }

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = (x1+1 - x0) * dy + y_top;

               sign = e->direction;
               // area of the rectangle covered from y0..y_crossing
               area = sign * (y_crossing-sy0);
               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

               step = sign * dy;
               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2;
                  area += step;
               }
               y_crossing += dy * (x2 - (x1+1));

               STBTT_assert(STBTT_fabs(area) <= 1.01f);

               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            // if edge goes outside of box we're drawing, we require
            // clipping logic. since this does not match the intended use
            // of this library, we use a different, very slow brute
            // force implementation
            int x;
            for (x=0; x < len; ++x) {
               // cases:
               //
               // there can be up to two intersections with the pixel. any intersection
               // with left or right edges can be handled by splitting into two (or three)
               // regions. intersections with top & bottom do not necessitate case-wise logic.
               //
               // the old way of doing this found the intersections with the left & right edges,
               // then used some simple logic to produce up to three segments in sorted order
               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
               // across the x border, then the corresponding y position might not be distinct
               // from the other y segment, and it might ignored as an empty segment. to avoid
               // that, we need to explicitly produce segments based on x positions.

               // rename variables to clearly-defined pairs
               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               // x = e->x + e->dx * (y-y_top)
               // (y-y_top) = (x - e->x) / e->dx
               // y = (x - e->x) / e->dx + y_top
               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            STBTT_assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               if (j == 0 && off_y != 0) {
                  if (z->ey < scan_y_top) {
                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
                     z->ey = scan_y_top;
                  }
               }
               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) STBTT_fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;   
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;
   
   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}   

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
   int ix0,iy0;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
   stbtt__bitmap gbm;   

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
   gbm.pixels = output;
   gbm.w = out_w;
   gbm.h = out_h;
   gbm.stride = out_stride;

   if (gbm.w && gbm.h)
      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

   STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
}   

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
}   

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata)
{
   float scale;
   int x,y,bottom_y, i;
   stbtt_fontinfo f;
   f.userdata = NULL;
   if (!stbtt_InitFont(&f, data, offset))
      return -1;
   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
   x=y=1;
   bottom_y = 1;

   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

   for (i=0; i < num_chars; ++i) {
      int advance, lsb, x0,y0,x1,y1,gw,gh;
      int g = stbtt_FindGlyphIndex(&f, first_char + i);
      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
      gw = x1-x0;
      gh = y1-y0;
      if (x + gw + 1 >= pw)
         y = bottom_y, x = 1; // advance to next row
      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
         return -i;
      STBTT_assert(x+gw < pw);
      STBTT_assert(y+gh < ph);
      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
      chardata[i].x0 = (stbtt_int16) x;
      chardata[i].y0 = (stbtt_int16) y;
      chardata[i].x1 = (stbtt_int16) (x + gw);
      chardata[i].y1 = (stbtt_int16) (y + gh);
      chardata[i].xadvance = scale * advance;
      chardata[i].xoff     = (float) x0;
      chardata[i].yoff     = (float) y0;
      x = x + gw + 1;
      if (y+gh+1 > bottom_y)
         bottom_y = y+gh+1;
   }
   return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_bakedchar *b = chardata + char_index;
   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

   q->x0 = round_x + d3d_bias;
   q->y0 = round_y + d3d_bias;
   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
   int width,height;
   int x,y,bottom_y;
} stbrp_context;

typedef struct
{
   unsigned char x;
} stbrp_node;

struct stbrp_rect
{
   stbrp_coord x,y;
   int id,w,h,was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
   con->width  = pw;
   con->height = ph;
   con->x = 0;
   con->y = 0;
   con->bottom_y = 0;
   STBTT__NOTUSED(nodes);
   STBTT__NOTUSED(num_nodes);   
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
   int i;
   for (i=0; i < num_rects; ++i) {
      if (con->x + rects[i].w > con->width) {
         con->x = 0;
         con->y = con->bottom_y;
      }
      if (con->y + rects[i].h > con->height)
         break;
      rects[i].x = con->x;
      rects[i].y = con->y;
      rects[i].was_packed = 1;
      con->x += rects[i].w;
      if (con->y + rects[i].h > con->bottom_y)
         con->bottom_y = con->y + rects[i].h;
   }
   for (   ; i < num_rects; ++i)
      rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) STBTT_free(context, alloc_context);
      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
   spc->h_oversample = 1;
   spc->v_oversample = 1;
   spc->skip_missing = 0;

   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

   if (pixels)
      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

   return 1;
}

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
{
   STBTT_free(spc->nodes    , spc->user_allocator_context);
   STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->h_oversample = h_oversample;
   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->v_oversample = v_oversample;
}

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)
{
   spc->skip_missing = skip;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_w = w - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < h; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < w; ++i) {
         STBTT_assert(pixels[i] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i] = (unsigned char) (total / kernel_width);
      }

      pixels += stride_in_bytes;
   }
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_h = h - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < w; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < h; ++i) {
         STBTT_assert(pixels[i*stride_in_bytes] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
      }

      pixels += 1;
   }
}

static float stbtt__oversample_shift(int oversample)
{
   if (!oversample)
      return 0.0f;

   // The prefilter is a box filter of width "oversample",
   // which shifts phase by (oversample - 1)/2 pixels in
   // oversampled space. We want to shift in the opposite
   // direction to counter this.
   return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k;

   k=0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
      for (j=0; j < ranges[i].num_chars; ++j) {
         int x0,y0,x1,y1;
         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
         int glyph = stbtt_FindGlyphIndex(info, codepoint);
         if (glyph == 0 && spc->skip_missing) {
            rects[k].w = rects[k].h = 0;
         } else {
            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
                                            scale * spc->h_oversample,
                                            scale * spc->v_oversample,
                                            0,0,
                                            &x0,&y0,&x1,&y1);
            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
         }
         ++k;
      }
   }

   return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info,
                                 output,
                                 out_w - (prefilter_x - 1),
                                 out_h - (prefilter_y - 1),
                                 out_stride,
                                 scale_x,
                                 scale_y,
                                 shift_x,
                                 shift_y,
                                 glyph);

   if (prefilter_x > 1)
      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

   if (prefilter_y > 1)
      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

   *sub_x = stbtt__oversample_shift(prefilter_x);
   *sub_y = stbtt__oversample_shift(prefilter_y);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k, return_value = 1;

   // save current values
   int old_h_over = spc->h_oversample;
   int old_v_over = spc->v_oversample;

   k = 0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      float recip_h,recip_v,sub_x,sub_y;
      spc->h_oversample = ranges[i].h_oversample;
      spc->v_oversample = ranges[i].v_oversample;
      recip_h = 1.0f / spc->h_oversample;
      recip_v = 1.0f / spc->v_oversample;
      sub_x = stbtt__oversample_shift(spc->h_oversample);
      sub_y = stbtt__oversample_shift(spc->v_oversample);
      for (j=0; j < ranges[i].num_chars; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed && r->w != 0 && r->h != 0) {
            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
            int advance, lsb, x0,y0,x1,y1;
            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
            int glyph = stbtt_FindGlyphIndex(info, codepoint);
            stbrp_coord pad = (stbrp_coord) spc->padding;

            // pad on left and top
            r->x += pad;
            r->y += pad;
            r->w -= pad;
            r->h -= pad;
            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
            stbtt_GetGlyphBitmapBox(info, glyph,
                                    scale * spc->h_oversample,
                                    scale * spc->v_oversample,
                                    &x0,&y0,&x1,&y1);
            stbtt_MakeGlyphBitmapSubpixel(info,
                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                          r->w - spc->h_oversample+1,
                                          r->h - spc->v_oversample+1,
                                          spc->stride_in_bytes,
                                          scale * spc->h_oversample,
                                          scale * spc->v_oversample,
                                          0,0,
                                          glyph);

            if (spc->h_oversample > 1)
               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->h_oversample);

            if (spc->v_oversample > 1)
               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->v_oversample);

            bc->x0       = (stbtt_int16)  r->x;
            bc->y0       = (stbtt_int16)  r->y;
            bc->x1       = (stbtt_int16) (r->x + r->w);
            bc->y1       = (stbtt_int16) (r->y + r->h);
            bc->xadvance =                scale * advance;
            bc->xoff     =       (float)  x0 * recip_h + sub_x;
            bc->yoff     =       (float)  y0 * recip_v + sub_y;
            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
         } else {
            return_value = 0; // if any fail, report failure
         }

         ++k;
      }
   }

   // restore original values
   spc->h_oversample = old_h_over;
   spc->v_oversample = old_v_over;

   return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
   stbtt_fontinfo info;
   int i,j,n, return_value = 1;
   //stbrp_context *context = (stbrp_context *) spc->pack_info;
   stbrp_rect    *rects;

   // flag all characters as NOT packed
   for (i=0; i < num_ranges; ++i)
      for (j=0; j < ranges[i].num_chars; ++j)
         ranges[i].chardata_for_range[j].x0 =
         ranges[i].chardata_for_range[j].y0 =
         ranges[i].chardata_for_range[j].x1 =
         ranges[i].chardata_for_range[j].y1 = 0;

   n = 0;
   for (i=0; i < num_ranges; ++i)
      n += ranges[i].num_chars;
         
   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
   if (rects == NULL)
      return 0;

   info.userdata = spc->user_allocator_context;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

   stbtt_PackFontRangesPackRects(spc, rects, n);
  
   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

   STBTT_free(rects, spc->user_allocator_context);
   return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
   stbtt_pack_range range;
   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
   range.array_of_unicode_codepoints = NULL;
   range.num_chars                   = num_chars_in_range;
   range.chardata_for_range          = chardata_for_range;
   range.font_size                   = font_size;
   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)
{
   int i_ascent, i_descent, i_lineGap;
   float scale;
   stbtt_fontinfo info;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));
   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);
   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);
   *ascent  = (float) i_ascent  * scale;
   *descent = (float) i_descent * scale;
   *lineGap = (float) i_lineGap * scale;
}

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_packedchar *b = chardata + char_index;

   if (align_to_integer) {
      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      q->x0 = x;
      q->y0 = y;
      q->x1 = x + b->xoff2 - b->xoff;
      q->y1 = y + b->yoff2 - b->yoff;
   } else {
      q->x0 = *xpos + b->xoff;
      q->y0 = *ypos + b->yoff;
      q->x1 = *xpos + b->xoff2;
      q->y1 = *ypos + b->yoff2;
   }

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// sdf computation
//

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
{
   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
   float roperp = orig[1]*ray[0] - orig[0]*ray[1];

   float a = q0perp - 2*q1perp + q2perp;
   float b = q1perp - q0perp;
   float c = q0perp - roperp;

   float s0 = 0., s1 = 0.;
   int num_s = 0;

   if (a != 0.0) {
      float discr = b*b - a*c;
      if (discr > 0.0) {
         float rcpna = -1 / a;
         float d = (float) STBTT_sqrt(discr);
         s0 = (b+d) * rcpna;
         s1 = (b-d) * rcpna;
         if (s0 >= 0.0 && s0 <= 1.0)
            num_s = 1;
         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
            if (num_s == 0) s0 = s1;
            ++num_s;
         }
      }
   } else {
      // 2*b*s + c = 0
      // s = -c / (2*b)
      s0 = c / (-2 * b);
      if (s0 >= 0.0 && s0 <= 1.0)
         num_s = 1;
   }

   if (num_s == 0)
      return 0;
   else {
      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
      float rod = orig[0]*rayn_x + orig[1]*rayn_y;

      float q10d = q1d - q0d;
      float q20d = q2d - q0d;
      float q0rd = q0d - rod;

      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
      hits[0][1] = a*s0+b;

      if (num_s > 1) {
         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
         hits[1][1] = a*s1+b;
         return 2;
      } else {
         return 1;
      }
   }
}

static int equal(float *a, float *b)
{
   return (a[0] == b[0] && a[1] == b[1]);
}

static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
{
   int i;
   float orig[2], ray[2] = { 1, 0 };
   float y_frac;
   int winding = 0;

   orig[0] = x;
   //orig[1] = y; // [DEAR IMGUI] commmented double assignment

   // make sure y never passes through a vertex of the shape
   y_frac = (float) STBTT_fmod(y, 1.0f);
   if (y_frac < 0.01f)
      y += 0.01f;
   else if (y_frac > 0.99f)
      y -= 0.01f;
   orig[1] = y;

   // test a ray from (-infinity,y) to (x,y)
   for (i=0; i < nverts; ++i) {
      if (verts[i].type == STBTT_vline) {
         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
            if (x_inter < x)  
               winding += (y0 < y1) ? 1 : -1;
         }
      }
      if (verts[i].type == STBTT_vcurve) {
         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
         int by = STBTT_max(y0,STBTT_max(y1,y2));
         if (y > ay && y < by && x > ax) {
            float q0[2],q1[2],q2[2];
            float hits[2][2];
            q0[0] = (float)x0;
            q0[1] = (float)y0;
            q1[0] = (float)x1;
            q1[1] = (float)y1;
            q2[0] = (float)x2;
            q2[1] = (float)y2;
            if (equal(q0,q1) || equal(q1,q2)) {
               x0 = (int)verts[i-1].x;
               y0 = (int)verts[i-1].y;
               x1 = (int)verts[i  ].x;
               y1 = (int)verts[i  ].y;
               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
                  if (x_inter < x)  
                     winding += (y0 < y1) ? 1 : -1;
               }
            } else {
               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
               if (num_hits >= 1)
                  if (hits[0][0] < 0)
                     winding += (hits[0][1] < 0 ? -1 : 1);
               if (num_hits >= 2)
                  if (hits[1][0] < 0)
                     winding += (hits[1][1] < 0 ? -1 : 1);
            }
         } 
      }
   }
   return winding;
}

static float stbtt__cuberoot( float x )
{
   if (x<0)
      return -(float) STBTT_pow(-x,1.0f/3.0f);
   else
      return  (float) STBTT_pow( x,1.0f/3.0f);
}

// x^3 + c*x^2 + b*x + a = 0
static int stbtt__solve_cubic(float a, float b, float c, float* r)
{
	float s = -a / 3;
	float p = b - a*a / 3;
	float q = a * (2*a*a - 9*b) / 27 + c;
   float p3 = p*p*p;
	float d = q*q + 4*p3 / 27;
	if (d >= 0) {
		float z = (float) STBTT_sqrt(d);
		float u = (-q + z) / 2;
		float v = (-q - z) / 2;
		u = stbtt__cuberoot(u);
		v = stbtt__cuberoot(v);
		r[0] = s + u + v;
		return 1;
	} else {
	   float u = (float) STBTT_sqrt(-p/3);
	   float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative
	   float m = (float) STBTT_cos(v);
      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
	   r[0] = s + u * 2 * m;
	   r[1] = s - u * (m + n);
	   r[2] = s - u * (m - n);

      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
   	return 3;
   }
}

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   float scale_x = scale, scale_y = scale;
   int ix0,iy0,ix1,iy1;
   int w,h;
   unsigned char *data;

   // if one scale is 0, use same scale for both
   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) return NULL;  // if both scales are 0, return NULL
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

   // if empty, return NULL
   if (ix0 == ix1 || iy0 == iy1)
      return NULL;

   ix0 -= padding;
   iy0 -= padding;
   ix1 += padding;
   iy1 += padding;

   w = (ix1 - ix0);
   h = (iy1 - iy0);

   if (width ) *width  = w;
   if (height) *height = h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   // invert for y-downwards bitmaps
   scale_y = -scale_y;
      
   {
      int x,y,i,j;
      float *precompute;
      stbtt_vertex *verts;
      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
         if (verts[i].type == STBTT_vline) {
            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
         } else if (verts[i].type == STBTT_vcurve) {
            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
            float len2 = bx*bx + by*by;
            if (len2 != 0.0f)
               precompute[i] = 1.0f / (bx*bx + by*by);
            else
               precompute[i] = 0.0f;
         } else
            precompute[i] = 0.0f;
      }

      for (y=iy0; y < iy1; ++y) {
         for (x=ix0; x < ix1; ++x) {
            float val;
            float min_dist = 999999.0f;
            float sx = (float) x + 0.5f;
            float sy = (float) y + 0.5f;
            float x_gspace = (sx / scale_x);
            float y_gspace = (sy / scale_y);

            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

            for (i=0; i < num_verts; ++i) {
               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

               // check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve
               float dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
               if (dist2 < min_dist*min_dist)
                  min_dist = (float) STBTT_sqrt(dist2);

               if (verts[i].type == STBTT_vline) {
                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

                  // coarse culling against bbox
                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
                  float dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
                  STBTT_assert(i != 0);
                  if (dist < min_dist) {
                     // check position along line
                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
                     float dx = x1-x0, dy = y1-y0;
                     float px = x0-sx, py = y0-sy;
                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
                     if (t >= 0.0f && t <= 1.0f)
                        min_dist = dist;
                  }
               } else if (verts[i].type == STBTT_vcurve) {
                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
                  // coarse culling against bbox to avoid computing cubic unnecessarily
                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
                     int num=0;
                     float ax = x1-x0, ay = y1-y0;
                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
                     float mx = x0 - sx, my = y0 - sy;
                     float res[3],px,py,t,it;
                     float a_inv = precompute[i];
                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula
                        float a = 3*(ax*bx + ay*by);
                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
                        float c = mx*ax+my*ay;
                        if (a == 0.0) { // if a is 0, it's linear
                           if (b != 0.0) {
                              res[num++] = -c/b;
                           }
                        } else {
                           float discriminant = b*b - 4*a*c;
                           if (discriminant < 0)
                              num = 0;
                           else {
                              float root = (float) STBTT_sqrt(discriminant);
                              res[0] = (-b - root)/(2*a);
                              res[1] = (-b + root)/(2*a);
                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work
                           }
                        }
                     } else {
                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point
                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
                        float d = (mx*ax+my*ay) * a_inv;
                        num = stbtt__solve_cubic(b, c, d, res);
                     }
                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
                        t = res[0], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
                        t = res[1], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
                        t = res[2], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                  }
               }
            }
            if (winding == 0)
               min_dist = -min_dist;  // if outside the shape, value is negative
            val = onedge_value + pixel_dist_scale * min_dist;
            if (val < 0)
               val = 0;
            else if (val > 255)
               val = 255;
            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
         }
      }
      STBTT_free(precompute, info->userdata);
      STBTT_free(verts, info->userdata);
   }
   return data;
}   

STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2) 
{
   stbtt_int32 i=0;

   // convert utf16 to utf8 and compare the results while converting
   while (len2) {
      stbtt_uint16 ch = s2[0]*256 + s2[1];
      if (ch < 0x80) {
         if (i >= len1) return -1;
         if (s1[i++] != ch) return -1;
      } else if (ch < 0x800) {
         if (i+1 >= len1) return -1;
         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
      } else if (ch >= 0xd800 && ch < 0xdc00) {
         stbtt_uint32 c;
         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
         if (i+3 >= len1) return -1;
         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
         s2 += 2; // plus another 2 below
         len2 -= 2;
      } else if (ch >= 0xdc00 && ch < 0xe000) {
         return -1;
      } else {
         if (i+2 >= len1) return -1;
         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
      }
      s2 += 2;
      len2 -= 2;
   }
   return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2) 
{
   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
   stbtt_int32 i,count,stringOffset;
   stbtt_uint8 *fc = font->data;
   stbtt_uint32 offset = font->fontstart;
   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return NULL;

   count = ttUSHORT(fc+nm+2);
   stringOffset = nm + ttUSHORT(fc+nm+4);
   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
         *length = ttUSHORT(fc+loc+8);
         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
      }
   }
   return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
   stbtt_int32 i;
   stbtt_int32 count = ttUSHORT(fc+nm+2);
   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      stbtt_int32 id = ttUSHORT(fc+loc+6);
      if (id == target_id) {
         // find the encoding
         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

         // is this a Unicode encoding?
         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
            stbtt_int32 slen = ttUSHORT(fc+loc+8);
            stbtt_int32 off = ttUSHORT(fc+loc+10);

            // check if there's a prefix match
            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
            if (matchlen >= 0) {
               // check for target_id+1 immediately following, with same encoding & language
               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
                  slen = ttUSHORT(fc+loc+12+8);
                  off = ttUSHORT(fc+loc+12+10);
                  if (slen == 0) {
                     if (matchlen == nlen)
                        return 1;
                  } else if (matchlen < nlen && name[matchlen] == ' ') {
                     ++matchlen;
                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
                        return 1;
                  }
               } else {
                  // if nothing immediately following
                  if (matchlen == nlen)
                     return 1;
               }
            }
         }

         // @TODO handle other encodings
      }
   }
   return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
   stbtt_uint32 nm,hd;
   if (!stbtt__isfont(fc+offset)) return 0;

   // check italics/bold/underline flags in macStyle...
   if (flags) {
      hd = stbtt__find_table(fc, offset, "head");
      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
   }

   nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return 0;

   if (flags) {
      // if we checked the macStyle flags, then just check the family and ignore the subfamily
      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   } else {
      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   }

   return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
{
   stbtt_int32 i;
   for (i=0;;++i) {
      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
      if (off < 0) return off;
      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
         return off;
   }
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
                                float pixel_height, unsigned char *pixels, int pw, int ph,
                                int first_char, int num_chars, stbtt_bakedchar *chardata)
{
   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
{
   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);   
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
{
   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
{
   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
{
   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`CSGOSimple/main.cpp`:

```cpp
#define NOMINMAX
#include <Windows.h>

#include "valve_sdk/sdk.hpp"
#include "helpers/utils.hpp"
#include "helpers/input.hpp"

#include "hooks.hpp"
#include "menu.hpp"
#include "options.hpp"
#include "render.hpp"

DWORD WINAPI OnDllAttach(LPVOID base)
{
	while (!GetModuleHandleA("serverbrowser.dll"))
		Sleep(1000);

#ifdef _DEBUG
    Utils::AttachConsole();
#endif

    try {
        Utils::ConsolePrint("Initializing...\n");

        Interfaces::Initialize();
        Interfaces::Dump();

        NetvarSys::Get().Initialize();
        InputSys::Get().Initialize();
		Render::Get().Initialize();
        Menu::Get().Initialize();

        Hooks::Initialize();

        // Register some hotkeys.
        // - Note:  The function that is called when the hotkey is pressed
        //          is called from the WndProc thread, not this thread.
        // 

        // Panic button
        InputSys::Get().RegisterHotkey(VK_DELETE, [base]() {
            g_Unload = true;
        });

        // Menu Toggle
        InputSys::Get().RegisterHotkey(VK_INSERT, [base]() {
            Menu::Get().Toggle();
        });

        Utils::ConsolePrint("Finished.\n");
		Utils::ConsolePrint("Built on: %s %s\n", __DATE__, __TIME__);

        while(!g_Unload)
            Sleep(1000);

        g_CVar->FindVar("crosshair")->SetValue(true);

        FreeLibraryAndExitThread(static_cast<HMODULE>(base), 1);

    } catch(const std::exception& ex) {
        Utils::ConsolePrint("An error occured during initialization:\n");
        Utils::ConsolePrint("%s\n", ex.what());
        Utils::ConsolePrint("Press any key to exit.\n");
        Utils::ConsoleReadKey();
        Utils::DetachConsole();

        FreeLibraryAndExitThread(static_cast<HMODULE>(base), 1);
    }

    // unreachable
    //return TRUE;
}

BOOL WINAPI OnDllDetach()
{
#ifdef _DEBUG
    Utils::DetachConsole();
#endif

    Hooks::Shutdown();

    Menu::Get().Shutdown();
    return TRUE;
}

BOOL WINAPI DllMain(
    _In_      HINSTANCE hinstDll,
    _In_      DWORD     fdwReason,
    _In_opt_  LPVOID    lpvReserved
)
{
    switch(fdwReason) {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hinstDll);
            CreateThread(nullptr, 0, OnDllAttach, hinstDll, 0, nullptr);
            return TRUE;
        case DLL_PROCESS_DETACH:
            if(lpvReserved == nullptr)
                return OnDllDetach();
            return TRUE;
        default:
            return TRUE;
    }
}

```

`CSGOSimple/menu.cpp`:

```cpp
#include "Menu.hpp"
#define NOMINMAX
#include <Windows.h>
#include <chrono>

#include "valve_sdk/csgostructs.hpp"
#include "helpers/input.hpp"
#include "options.hpp"
#include "ui.hpp"
#include "config.hpp"

#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui/imgui_internal.h"
#include "imgui/impl/imgui_impl_dx9.h"
#include "imgui/impl/imgui_impl_win32.h"


// =========================================================
// 
// These are the tabs on the sidebar
// 
// =========================================================
static char* sidebar_tabs[] = {
    "ESP",
    "AIM",
    "MISC",
    "CONFIG"
};

constexpr static float get_sidebar_item_width() { return 150.0f; }
constexpr static float get_sidebar_item_height() { return  50.0f; }

enum {
	TAB_ESP,
	TAB_AIMBOT,
	TAB_MISC,
	TAB_CONFIG
};

namespace ImGuiEx
{
    inline bool ColorEdit4(const char* label, Color* v, bool show_alpha = true)
    {
        auto clr = ImVec4{
            v->r() / 255.0f,
            v->g() / 255.0f,
            v->b() / 255.0f,
            v->a() / 255.0f
        };

        if(ImGui::ColorEdit4(label, &clr.x, show_alpha)) {
            v->SetColor(clr.x, clr.y, clr.z, clr.w);
            return true;
        }
        return false;
    }
    inline bool ColorEdit3(const char* label, Color* v)
    {
        return ColorEdit4(label, v, false);
    }
}

template<size_t N>
void render_tabs(char* (&names)[N], int& activetab, float w, float h, bool sameline)
{
    bool values[N] = { false };

    values[activetab] = true;

    for(auto i = 0; i < N; ++i) {
        if(ImGui::ToggleButton(names[i], &values[i], ImVec2{ w, h })) {
            activetab = i;
        }
        if(sameline && i < N - 1)
            ImGui::SameLine();
    }
}

ImVec2 get_sidebar_size()
{
    constexpr float padding = 10.0f;
    constexpr auto size_w = padding * 2.0f + get_sidebar_item_width();
    constexpr auto size_h = padding * 2.0f + (sizeof(sidebar_tabs) / sizeof(char*)) * get_sidebar_item_height();

    return ImVec2{ size_w, ImMax(325.0f, size_h) };
}

int get_fps()
{
    using namespace std::chrono;
    static int count = 0;
    static auto last = high_resolution_clock::now();
    auto now = high_resolution_clock::now();
    static int fps = 0;

    count++;

    if(duration_cast<milliseconds>(now - last).count() > 1000) {
        fps = count;
        count = 0;
        last = now;
    }

    return fps;
}

void RenderEspTab()
{
    static char* esp_tab_names[] = { "ESP", "GLOW", "CHAMS" };
    static int   active_esp_tab = 0;

    bool placeholder_true = true;

    auto& style = ImGui::GetStyle();
    float group_w = ImGui::GetCurrentWindow()->Size.x - style.WindowPadding.x * 2;
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
    {
        render_tabs(esp_tab_names, active_esp_tab, group_w / _countof(esp_tab_names), 25.0f, true);
    }
    ImGui::PopStyleVar();
    ImGui::BeginGroupBox("##body_content");
    {
        if(active_esp_tab == 0) {
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2{ style.WindowPadding.x, style.ItemSpacing.y });
            ImGui::Columns(3, nullptr, false);
            ImGui::SetColumnOffset(1, group_w / 3.0f);
            ImGui::SetColumnOffset(2, 2 * group_w / 3.0f);
            ImGui::SetColumnOffset(3, group_w);

            ImGui::Checkbox("Enabled", g_Options.esp_enabled);
            ImGui::Checkbox("Team check", g_Options.esp_enemies_only);
            ImGui::Checkbox("Boxes", g_Options.esp_player_boxes);
            ImGui::Checkbox("Names", g_Options.esp_player_names);
            ImGui::Checkbox("Health", g_Options.esp_player_health);
            ImGui::Checkbox("Armour", g_Options.esp_player_armour);
            ImGui::Checkbox("Weapon", g_Options.esp_player_weapons);
            ImGui::Checkbox("Snaplines", g_Options.esp_player_snaplines);

            ImGui::NextColumn();

            ImGui::Checkbox("Crosshair", g_Options.esp_crosshair);
            ImGui::Checkbox("Dropped Weapons", g_Options.esp_dropped_weapons);
            ImGui::Checkbox("Defuse Kit", g_Options.esp_defuse_kit);
            ImGui::Checkbox("Planted C4", g_Options.esp_planted_c4);
			ImGui::Checkbox("Item Esp", g_Options.esp_items);

            ImGui::NextColumn();

            ImGui::PushItemWidth(100);
            ImGuiEx::ColorEdit3("Allies Visible", g_Options.color_esp_ally_visible);
            ImGuiEx::ColorEdit3("Enemies Visible", g_Options.color_esp_enemy_visible);
            ImGuiEx::ColorEdit3("Allies Occluded", g_Options.color_esp_ally_occluded);
            ImGuiEx::ColorEdit3("Enemies Occluded", g_Options.color_esp_enemy_occluded);
            ImGuiEx::ColorEdit3("Crosshair", g_Options.color_esp_crosshair);
            ImGuiEx::ColorEdit3("Dropped Weapons", g_Options.color_esp_weapons);
            ImGuiEx::ColorEdit3("Defuse Kit", g_Options.color_esp_defuse);
            ImGuiEx::ColorEdit3("Planted C4", g_Options.color_esp_c4);
			ImGuiEx::ColorEdit3("Item Esp", g_Options.color_esp_item);
            ImGui::PopItemWidth();

            ImGui::Columns(1, nullptr, false);
            ImGui::PopStyleVar();
        } else if(active_esp_tab == 1) {
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2{ style.WindowPadding.x, style.ItemSpacing.y });
            ImGui::Columns(3, nullptr, false);
            ImGui::SetColumnOffset(1, group_w / 3.0f);
            ImGui::SetColumnOffset(2, 2 * group_w / 3.0f);
            ImGui::SetColumnOffset(3, group_w);

            ImGui::Checkbox("Enabled", g_Options.glow_enabled);
            ImGui::Checkbox("Team check", g_Options.glow_enemies_only);
            ImGui::Checkbox("Players", g_Options.glow_players);
            ImGui::Checkbox("Chickens", g_Options.glow_chickens);
            ImGui::Checkbox("C4 Carrier", g_Options.glow_c4_carrier);
            ImGui::Checkbox("Planted C4", g_Options.glow_planted_c4);
            ImGui::Checkbox("Defuse Kits", g_Options.glow_defuse_kits);
            ImGui::Checkbox("Weapons", g_Options.glow_weapons);

            ImGui::NextColumn();

            ImGui::PushItemWidth(100);
            ImGuiEx::ColorEdit3("Ally", g_Options.color_glow_ally);
            ImGuiEx::ColorEdit3("Enemy", g_Options.color_glow_enemy);
            ImGuiEx::ColorEdit3("Chickens", g_Options.color_glow_chickens);
            ImGuiEx::ColorEdit3("C4 Carrier", g_Options.color_glow_c4_carrier);
            ImGuiEx::ColorEdit3("Planted C4", g_Options.color_glow_planted_c4);
            ImGuiEx::ColorEdit3("Defuse Kits", g_Options.color_glow_defuse);
            ImGuiEx::ColorEdit3("Weapons", g_Options.color_glow_weapons);
            ImGui::PopItemWidth();

            ImGui::NextColumn();

            ImGui::Columns(1, nullptr, false);
            ImGui::PopStyleVar();
        } else if(active_esp_tab == 2) {
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2{ style.WindowPadding.x, style.ItemSpacing.y });
            ImGui::Columns(3, nullptr, false);
            ImGui::SetColumnOffset(1, group_w / 3.0f);
            ImGui::SetColumnOffset(2, 2 * group_w / 2.9f);
            ImGui::SetColumnOffset(3, group_w);

            ImGui::BeginGroupBox("Players");
            {
                ImGui::Checkbox("Enabled", g_Options.chams_player_enabled); ImGui::SameLine();
                ImGui::Checkbox("Team Check", g_Options.chams_player_enemies_only);
                ImGui::Checkbox("Wireframe", g_Options.chams_player_wireframe);
                ImGui::Checkbox("Flat", g_Options.chams_player_flat);
                ImGui::Checkbox("Ignore-Z", g_Options.chams_player_ignorez); ImGui::SameLine();
                ImGui::Checkbox("Glass", g_Options.chams_player_glass);
                ImGui::PushItemWidth(110);
                ImGuiEx::ColorEdit4("Ally (Visible)", g_Options.color_chams_player_ally_visible);
                ImGuiEx::ColorEdit4("Ally (Occluded)", g_Options.color_chams_player_ally_occluded);
                ImGuiEx::ColorEdit4("Enemy (Visible)", g_Options.color_chams_player_enemy_visible);
                ImGuiEx::ColorEdit4("Enemy (Occluded)", g_Options.color_chams_player_enemy_occluded);
                ImGui::PopItemWidth();
            }
            ImGui::EndGroupBox();

            ImGui::NextColumn();

            ImGui::BeginGroupBox("Arms");
            {
                ImGui::Checkbox("Enabled", g_Options.chams_arms_enabled);
                ImGui::Checkbox("Wireframe", g_Options.chams_arms_wireframe);
                ImGui::Checkbox("Flat", g_Options.chams_arms_flat);
                ImGui::Checkbox("Ignore-Z", g_Options.chams_arms_ignorez);
                ImGui::Checkbox("Glass", g_Options.chams_arms_glass);
                ImGui::PushItemWidth(110);
                ImGuiEx::ColorEdit4("Color (Visible)", g_Options.color_chams_arms_visible);
                ImGuiEx::ColorEdit4("Color (Occluded)", g_Options.color_chams_arms_occluded);
                ImGui::PopItemWidth();
            }
            ImGui::EndGroupBox();

            ImGui::Columns(1, nullptr, false);
            ImGui::PopStyleVar();
        }
    }
    ImGui::EndGroupBox();
}

void RenderMiscTab()
{
    bool placeholder_true = true;

    auto& style = ImGui::GetStyle();
    float group_w = ImGui::GetCurrentWindow()->Size.x - style.WindowPadding.x * 2;

    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
    ImGui::ToggleButton("MISC", &placeholder_true, ImVec2{ group_w, 25.0f });
    ImGui::PopStyleVar();

    ImGui::BeginGroupBox("##body_content");
    {
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2{ style.WindowPadding.x, style.ItemSpacing.y });
        ImGui::Columns(3, nullptr, false);
        ImGui::SetColumnOffset(1, group_w / 3.0f);
        ImGui::SetColumnOffset(2, 2 * group_w / 3.0f);
        ImGui::SetColumnOffset(3, group_w);

        ImGui::Checkbox("Bunny hop", g_Options.misc_bhop);
		ImGui::Checkbox("Third Person", g_Options.misc_thirdperson);
		if(g_Options.misc_thirdperson)
			ImGui::SliderFloat("Distance", g_Options.misc_thirdperson_dist, 0.f, 150.f);
        ImGui::Checkbox("No hands", g_Options.misc_no_hands);
		ImGui::Checkbox("Rank reveal", g_Options.misc_showranks);
		ImGui::Checkbox("Watermark##hc", g_Options.misc_watermark);
        //ImGui::PushItemWidth(-1.0f);
		ImGui::NextColumn();
        ImGui::SliderInt("viewmodel_fov:", g_Options.viewmodel_fov, 68, 120);
		ImGui::Text("Postprocessing:");
        ImGui::SliderFloat("Red", g_Options.mat_ambient_light_r, 0, 1);
        ImGui::SliderFloat("Green", g_Options.mat_ambient_light_g, 0, 1);
        ImGui::SliderFloat("Blue", g_Options.mat_ambient_light_b, 0, 1);
        //ImGui::PopItemWidth();

        ImGui::Columns(1, nullptr, false);
        ImGui::PopStyleVar();
    }
    ImGui::EndGroupBox();
}

void RenderEmptyTab()
{
	auto& style = ImGui::GetStyle();
	float group_w = ImGui::GetCurrentWindow()->Size.x - style.WindowPadding.x * 2;

	bool placeholder_true = true;

	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
	ImGui::ToggleButton("AIM", &placeholder_true, ImVec2{ group_w, 25.0f });
	ImGui::PopStyleVar();

	ImGui::BeginGroupBox("##body_content");
	{
		auto message = "There's nothing here. Add something you want!";

		 auto pos = ImGui::GetCurrentWindow()->Pos;
		 auto wsize = ImGui::GetCurrentWindow()->Size;

		 pos = pos + wsize / 2.0f;

		 ImGui::RenderText(pos - ImGui::CalcTextSize(message) / 2.0f, message);
	}
	ImGui::EndGroupBox();
}

void RenderConfigTab()
{
    auto& style = ImGui::GetStyle();
    float group_w = ImGui::GetCurrentWindow()->Size.x - style.WindowPadding.x * 2;

    bool placeholder_true = true;

    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
    ImGui::ToggleButton("CONFIG", &placeholder_true, ImVec2{ group_w, 25.0f });
    ImGui::PopStyleVar();

    ImGui::BeginGroupBox("##body_content");
    {
		if (ImGui::Button("Save cfg")) {
			Config::Get().Save();
		}
		if (ImGui::Button("Load cfg")) {
			Config::Get().Load();
		}
    }
    ImGui::EndGroupBox();
}

void Menu::Initialize()
{
	CreateStyle();

    _visible = true;
}

void Menu::Shutdown()
{
    ImGui_ImplDX9_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();
}

void Menu::OnDeviceLost()
{
    ImGui_ImplDX9_InvalidateDeviceObjects();
}

void Menu::OnDeviceReset()
{
    ImGui_ImplDX9_CreateDeviceObjects();
}

void Menu::Render()
{
	ImGui::GetIO().MouseDrawCursor = _visible;

    if(!_visible)
        return;

    const auto sidebar_size = get_sidebar_size();
    static int active_sidebar_tab = 0;

    //ImGui::PushStyle(_style);

    ImGui::SetNextWindowPos(ImVec2{ 0, 0 }, ImGuiSetCond_Once);
    ImGui::SetNextWindowSize(ImVec2{ 1000, 400 }, ImGuiSetCond_Once);
	// https://github.com/spirthack/CSGOSimple/issues/63
	// quick fix

	if (ImGui::Begin("CSGOSimple",
		&_visible,
		ImGuiWindowFlags_NoCollapse |
		ImGuiWindowFlags_NoResize |
		ImGuiWindowFlags_NoTitleBar)) {

		//auto& style = ImGui::GetStyle();
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
        {
            ImGui::BeginGroupBox("##sidebar", sidebar_size);
            {
				//ImGui::GetCurrentWindow()->Flags &= ~ImGuiWindowFlags_ShowBorders;

                render_tabs(sidebar_tabs, active_sidebar_tab, get_sidebar_item_width(), get_sidebar_item_height(), false);
            }
            ImGui::EndGroupBox();
        }
        ImGui::PopStyleVar();
        ImGui::SameLine();

        // Make the body the same vertical size as the sidebar
        // except for the width, which we will set to auto
        auto size = ImVec2{ 0.0f, sidebar_size.y };

		ImGui::BeginGroupBox("##body", size);
        if(active_sidebar_tab == TAB_ESP) {
            RenderEspTab();
        } else if(active_sidebar_tab == TAB_AIMBOT) {
            RenderEmptyTab();
        } else if(active_sidebar_tab == TAB_MISC) {
            RenderMiscTab();
        } else if(active_sidebar_tab == TAB_CONFIG) {
            RenderConfigTab();
        }
        ImGui::EndGroupBox();

        ImGui::TextColored(ImVec4{ 0.0f, 0.5f, 0.0f, 1.0f }, "FPS: %03d", get_fps());
        ImGui::SameLine(ImGui::GetWindowWidth() - 150 - ImGui::GetStyle().WindowPadding.x);
        if(ImGui::Button("Unload", ImVec2{ 150, 25 })) {
            g_Unload = true;
        }
        ImGui::End();
    }
}

void Menu::Toggle()
{
    _visible = !_visible;
}

void Menu::CreateStyle()
{
	ImGui::StyleColorsDark();
	ImGui::SetColorEditOptions(ImGuiColorEditFlags_HEX);
	_style.FrameRounding = 0.f;
	_style.WindowRounding = 0.f;
	_style.ChildRounding = 0.f;
	_style.Colors[ImGuiCol_Button] = ImVec4(0.260f, 0.590f, 0.980f, 0.670f);
	_style.Colors[ImGuiCol_Header] = ImVec4(0.260f, 0.590f, 0.980f, 0.670f);
	_style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.260f, 0.590f, 0.980f, 1.000f);
	//_style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.000f, 0.545f, 1.000f, 1.000f);
	//_style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.060f, 0.416f, 0.980f, 1.000f);
	_style.Colors[ImGuiCol_FrameBg] = ImVec4(0.20f, 0.25f, 0.30f, 1.0f);
	_style.Colors[ImGuiCol_WindowBg] = ImVec4(0.000f, 0.009f, 0.120f, 0.940f);
	_style.Colors[ImGuiCol_PopupBg] = ImVec4(0.076f, 0.143f, 0.209f, 1.000f);
	ImGui::GetStyle() = _style;
}


```

`CSGOSimple/menu.hpp`:

```hpp
#pragma once

#include <string>
#include "singleton.hpp"
#include "imgui/imgui.h"

struct IDirect3DDevice9;

class Menu
    : public Singleton<Menu>
{
public:
    void Initialize();
    void Shutdown();

    void OnDeviceLost();
    void OnDeviceReset();

    void Render();

    void Toggle();

    bool IsVisible() const { return _visible; }

private:
    void CreateStyle();

    ImGuiStyle        _style;
    bool              _visible;
};
```

`CSGOSimple/options.hpp`:

```hpp
#pragma once

#include <string>
#include <memory>
#include <unordered_map>
#include <vector>
#include "valve_sdk/Misc/Color.hpp"

#define A( s ) #s
#define OPTION(type, var, val) Var<type> var = {A(var), val}

template <typename T = bool>
class Var {
public:
	std::string name;
	std::shared_ptr<T> value;
	int32_t size;
	Var(std::string name, T v) : name(name) {
		value = std::make_shared<T>(v);
		size = sizeof(T);
	}
	operator T() { return *value; }
	operator T*() { return &*value; }
	operator T() const { return *value; }
	//operator T*() const { return value; }
};

class Options
{
public:
		// 
		// ESP
		// 
		OPTION(bool, esp_enabled, false);
		OPTION(bool, esp_enemies_only, false);
		OPTION(bool, esp_player_boxes, false);
		OPTION(bool, esp_player_names, false);
		OPTION(bool, esp_player_health, false);
		OPTION(bool, esp_player_armour, false);
		OPTION(bool, esp_player_weapons, false);
		OPTION(bool, esp_player_snaplines, false);
		OPTION(bool, esp_crosshair, false);
		OPTION(bool, esp_dropped_weapons, false);
		OPTION(bool, esp_defuse_kit, false);
		OPTION(bool, esp_planted_c4, false);
		OPTION(bool, esp_items, false);

		// 
		// GLOW
		// 
		OPTION(bool, glow_enabled, false);
		OPTION(bool, glow_enemies_only, false);
		OPTION(bool, glow_players, false);
		OPTION(bool, glow_chickens, false);
		OPTION(bool, glow_c4_carrier, false);
		OPTION(bool, glow_planted_c4, false);
		OPTION(bool, glow_defuse_kits, false);
		OPTION(bool, glow_weapons, false);

		//
		// CHAMS
		//
		OPTION(bool, chams_player_enabled, false);
		OPTION(bool, chams_player_enemies_only, false);
		OPTION(bool, chams_player_wireframe, false);
		OPTION(bool, chams_player_flat, false);
		OPTION(bool, chams_player_ignorez, false);
		OPTION(bool, chams_player_glass, false);
		OPTION(bool, chams_arms_enabled, false);
		OPTION(bool, chams_arms_wireframe, false);
		OPTION(bool, chams_arms_flat, false);
		OPTION(bool, chams_arms_ignorez, false);
		OPTION(bool, chams_arms_glass, false);

		//
		// MISC
		//
		OPTION(bool, misc_bhop, false);
		OPTION(bool, misc_no_hands, false);
		OPTION(bool, misc_thirdperson, false);
		OPTION(bool, misc_showranks, true);
		OPTION(bool, misc_watermark, true);
		OPTION(float, misc_thirdperson_dist, 50.f);
		OPTION(int, viewmodel_fov, 68);
		OPTION(float, mat_ambient_light_r, 0.0f);
		OPTION(float, mat_ambient_light_g, 0.0f);
		OPTION(float, mat_ambient_light_b, 0.0f);

		// 
		// COLORS
		// 
		OPTION(Color, color_esp_ally_visible, Color(0, 128, 255));
		OPTION(Color, color_esp_enemy_visible, Color(255, 0, 0));
		OPTION(Color, color_esp_ally_occluded, Color(0, 128, 255));
		OPTION(Color, color_esp_enemy_occluded, Color(255, 0, 0));
		OPTION(Color, color_esp_crosshair, Color(255, 255, 255));
		OPTION(Color, color_esp_weapons, Color(128, 0, 128));
		OPTION(Color, color_esp_defuse, Color(0, 128, 255));
		OPTION(Color, color_esp_c4, Color(255, 255, 0));
		OPTION(Color, color_esp_item, Color(255, 255, 255));

		OPTION(Color, color_glow_ally, Color(0, 128, 255));
		OPTION(Color, color_glow_enemy, Color(255, 0, 0));
		OPTION(Color, color_glow_chickens, Color(0, 128, 0));
		OPTION(Color, color_glow_c4_carrier, Color(255, 255, 0));
		OPTION(Color, color_glow_planted_c4, Color(128, 0, 128));
		OPTION(Color, color_glow_defuse, Color(255, 255, 255));
		OPTION(Color, color_glow_weapons, Color(255, 128, 0));

		OPTION(Color, color_chams_player_ally_visible, Color(0, 128, 255));
		OPTION(Color, color_chams_player_ally_occluded, Color(0, 255, 128));
		OPTION(Color, color_chams_player_enemy_visible, Color(255, 0, 0));
		OPTION(Color, color_chams_player_enemy_occluded, Color(255, 128, 0));
		OPTION(Color, color_chams_arms_visible, Color(0, 128, 255));
		OPTION(Color, color_chams_arms_occluded, Color(0, 128, 255));
		OPTION(Color, color_watermark, Color(0, 128, 255)); // no menu config cuz its useless
};

inline Options g_Options;
inline bool   g_Unload;

```

`CSGOSimple/render.cpp`:

```cpp
#include "render.hpp"

#include <mutex>

#include "features/visuals.hpp"
#include "valve_sdk/csgostructs.hpp"
#include "helpers/input.hpp"
#include "menu.hpp"
#include "options.hpp"
#include "fonts/fonts.hpp"
#include "helpers/math.hpp"

ImFont* g_pDefaultFont;
ImFont* g_pSecondFont;

ImDrawListSharedData _data;

std::mutex render_mutex;

void Render::Initialize()
{
	ImGui::CreateContext();


	ImGui_ImplWin32_Init(InputSys::Get().GetMainWindow());
	ImGui_ImplDX9_Init(g_D3DDevice9);

	draw_list = new ImDrawList(ImGui::GetDrawListSharedData());
	draw_list_act = new ImDrawList(ImGui::GetDrawListSharedData());
	draw_list_rendering = new ImDrawList(ImGui::GetDrawListSharedData());

	GetFonts();
}

void Render::GetFonts() {

	// menu font
	ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(
		Fonts::Droid_compressed_data,
		Fonts::Droid_compressed_size,
		14.f);
	
	// esp font
	g_pDefaultFont = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(
		Fonts::Droid_compressed_data,
		Fonts::Droid_compressed_size,
		18.f);
	

	// font for watermark; just example
	g_pSecondFont = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(
		Fonts::Cousine_compressed_data,
		Fonts::Cousine_compressed_size,
		18.f); 
}

void Render::ClearDrawList() {
	render_mutex.lock();
	draw_list_act->Clear();
	render_mutex.unlock();
}

void Render::BeginScene() {
	draw_list->Clear();
	draw_list->PushClipRectFullScreen();


	if (g_Options.misc_watermark)
		Render::Get().RenderText("CSGOSimple", 10, 5, 18.f, g_Options.color_watermark, false, true, g_pSecondFont);

	if (g_EngineClient->IsInGame() && g_LocalPlayer && g_Options.esp_enabled)
		Visuals::Get().AddToDrawList();


	render_mutex.lock();
	*draw_list_act = *draw_list;
	render_mutex.unlock();
}

ImDrawList* Render::RenderScene() {

	if (render_mutex.try_lock()) {
		*draw_list_rendering = *draw_list_act;
		render_mutex.unlock();
	}

	return draw_list_rendering;
}


float Render::RenderText(const std::string& text, ImVec2 pos, float size, Color color, bool center, bool outline, ImFont* pFont)
{
	ImVec2 textSize = pFont->CalcTextSizeA(size, FLT_MAX, 0.0f, text.c_str());
	if (!pFont->ContainerAtlas) return 0.f;
	draw_list->PushTextureID(pFont->ContainerAtlas->TexID);

	if (center)
		pos.x -= textSize.x / 2.0f;

	if (outline) {
		draw_list->AddText(pFont, size, ImVec2(pos.x + 1, pos.y + 1), GetU32(Color(0, 0, 0, color.a())), text.c_str());
		draw_list->AddText(pFont, size, ImVec2(pos.x - 1, pos.y - 1), GetU32(Color(0, 0, 0, color.a())), text.c_str());
		draw_list->AddText(pFont, size, ImVec2(pos.x + 1, pos.y - 1), GetU32(Color(0, 0, 0, color.a())), text.c_str());
		draw_list->AddText(pFont, size, ImVec2(pos.x - 1, pos.y + 1), GetU32(Color(0, 0, 0, color.a())), text.c_str());
	}

	draw_list->AddText(pFont, size, pos, GetU32(color), text.c_str());

	draw_list->PopTextureID();

	return pos.y + textSize.y;
}

void Render::RenderCircle3D(Vector position, float points, float radius, Color color)
{
	float step = (float)M_PI * 2.0f / points;

	for (float a = 0; a < (M_PI * 2.0f); a += step)
	{
		Vector start(radius * cosf(a) + position.x, radius * sinf(a) + position.y, position.z);
		Vector end(radius * cosf(a + step) + position.x, radius * sinf(a + step) + position.y, position.z);

		Vector start2d, end2d;
		if (g_DebugOverlay->ScreenPosition(start, start2d) || g_DebugOverlay->ScreenPosition(end, end2d))
			return;

		RenderLine(start2d.x, start2d.y, end2d.x, end2d.y, color);
	}
}

```

`CSGOSimple/render.hpp`:

```hpp
#pragma once
#include <string>
#include <sstream>
#include <stdint.h>
#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib,"d3d9.lib")
#pragma comment(lib,"d3dx9.lib")

#include "singleton.hpp"
#include "imgui/imgui.h"
#include "imgui/imgui_internal.h"
#include "imgui/impl/imgui_impl_dx9.h"
#include "imgui/impl/imgui_impl_win32.h"

#include "valve_sdk/misc/Color.hpp"

extern ImFont* g_pDefaultFont;
extern ImFont* g_pSecondFont;


class Vector;

class Render
	: public Singleton<Render>
{
	friend class Singleton<Render>;

private:
	ImDrawList * draw_list_act;
	ImDrawList * draw_list_rendering;
	ImDrawList* draw_list;
	ImDrawData draw_data;

	ImU32 GetU32(Color _color)
	{
		return ((_color[3] & 0xff) << 24) + ((_color[2] & 0xff) << 16) + ((_color[1] & 0xff) << 8)
			+ (_color[0] & 0xff);
	}
public:
	void Initialize();
	void GetFonts();
	void ClearDrawList();
	void BeginScene();
	ImDrawList* RenderScene();

	float RenderText(const std::string& text, ImVec2 position, float size, Color color, bool center = false, bool outline = true, ImFont* pFont = g_pDefaultFont);

	void RenderCircle3D(Vector position, float points, float radius, Color color);

	void RenderImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0, 0), const ImVec2& uv_b = ImVec2(1, 1), ImU32 col = 0xFFFFFFFF) {
		draw_list->AddImage(user_texture_id, a, b, uv_a, uv_b, col);
	}

	template <class T>
	inline void RenderBoxByType(T x1, T y1, T x2, T y2, Color color, float thickness = 1.f, int type = 0) {
		if (type == 0)
			RenderBox(x1, y1, x2, y2, color, thickness);
		else if (type == 1)
			RenderCoalBox(x1, y1, x2, y2, color);
		else if (type == 2)
			RenderBox(x1, y1, x2, y2, color, thickness, 8.f);
	}

	template <class T>
	inline void RenderBoxFilledByType(T x1, T y1, T x2, T y2, Color color, float thickness = 1.f, int type = 0) {
		if (type == 0 || type == 1)
			RenderBoxFilled(x1, y1, x2, y2, color, thickness);
		else if (type == 2)
			RenderBoxFilled(x1, y1, x2, y2, color, thickness, 8.f);
	}

	template <class T>
	inline void RenderCoalBox(T x1, T y1, T x2, T y2, Color color, float th = 1.f) {
		int w = x2 - x1;
		int h = y2 - y1;

		int iw = w / 4;
		int ih = h / 4;
		// top
		RenderLine(x1, y1, x1 + iw, y1, color, th);					// left
		RenderLine(x1 + w - iw, y1, x1 + w, y1, color, th);			// right
		RenderLine(x1, y1, x1, y1 + ih, color, th);					// top left
		RenderLine(x1 + w - 1, y1, x1 + w - 1, y1 + ih, color, th);	// top right
																	// bottom
		RenderLine(x1, y1 + h, x1 + iw, y1 + h, color, th);			// left
		RenderLine(x1 + w - iw, y1 + h, x1 + w, y1 + h, color, th);	// right
		RenderLine(x1, y1 + h - ih, x1, y1 + h, color, th);			// bottom left
		RenderLine(x1 + w - 1, y1 + h - ih, x1 + w - 1, y1 + h, color, th);	// bottom right
	}

	template <class T>
	inline void RenderBox(T x1, T y1, T x2, T y2, Color color, float thickness = 1.f, float rounding = 0.f) {
		draw_list->AddRect(ImVec2(x1, y1), ImVec2(x2, y2), GetU32(color), rounding, 15, thickness);
	}
	inline void RenderBox(RECT r, Color color,float thickness = 1.f, float rounding = 0.f) {
		RenderBox(r.left, r.top, r.right, r.bottom, color, thickness, rounding);
	}
	template <class T>
	inline void RenderBoxFilled(T x1, T y1, T x2, T y2, Color color, float thickness = 1.f, float rounding = 0.f) {
		draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), GetU32(color), rounding, 15);
	}
	template <class T>
	inline void RenderLine(T x1, T y1, T x2, T y2, Color color, float thickness = 1.f) {
		draw_list->AddLine(ImVec2(x1, y1), ImVec2(x2, y2), GetU32(color), thickness);
	}
	template <class T>
	inline float RenderText(const std::string& text, T x, T y, float size, Color clr, bool center = false, bool outline = true, ImFont* pFont = g_pDefaultFont) {
		return RenderText(text, ImVec2(x, y), size, clr, center, outline, pFont);
	}
	template <class T>
	inline void RenderCircle(T x, T y, float radius, int points, Color color, float thickness = 1.f) {
		draw_list->AddCircle(ImVec2(x, y), radius, GetU32(color), points, thickness);
	}
	template <class T>
	inline void RenderCircleFilled(T x, T y, float radius, int points, Color color) {
		draw_list->AddCircleFilled(ImVec2(x, y), radius, GetU32(color), points);
	}
};
```

`CSGOSimple/singleton.hpp`:

```hpp
#pragma once

template<typename T>
class Singleton
{
protected:
    Singleton() {}
    ~Singleton() {}

    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    Singleton(Singleton&&) = delete;
    Singleton& operator=(Singleton&&) = delete;

public:
    static T& Get()
    {
        static T inst{};
        return inst;
    }
};

```

`CSGOSimple/ui.hpp`:

```hpp
#pragma once
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS
#include "imgui/imgui.h"
#define IMGUI_DEFINE_MATH_OPERATORS
//#define IMGUI_DEFINE_PLACEMENT_NEW
#include "imgui/imgui_internal.h"
//#include "imgui/directx9/imgui_impl_dx9.h"
#include <Windows.h>
#include <string>
#include <functional>
#include <vector>

namespace ImGui {
	bool ToggleButton(const char * label, bool * v, const ImVec2 & size_arg = ImVec2(0, 0));
	// Combo box helper allowing to pass an array of strings.
	bool Combo(const char * label, int * currIndex, std::vector<std::string>& values);
	bool BeginGroupBox(const char * name, const ImVec2 & size_arg = ImVec2(0, 0));
	void EndGroupBox();
	bool Hotkey(const char * label, int * k, const ImVec2 & size_arg = ImVec2(0, 0));
	bool ListBox(const char * label, int * current_item, std::string items[], int items_count, int height_items);
	bool ListBox(const char * label, int * current_item, std::function<const char*(int)> lambda, int items_count, int height_in_items);
	bool Combo(const char * label, int * current_item, std::function<const char*(int)> lambda, int items_count, int height_in_items);
}
```

`CSGOSimple/valve_sdk/csgostructs.cpp`:

```cpp
#include "csgostructs.hpp"
#include "../Helpers/Math.hpp"
#include "../Helpers/Utils.hpp"

//increase it if valve added some funcs to baseentity :lillulmoa:
constexpr auto VALVE_ADDED_FUNCS = 0ull;

bool C_BaseEntity::IsPlayer()
{
	//index: 152
	//ref: "effects/nightvision"
	//sig: 8B 92 ? ? ? ? FF D2 84 C0 0F 45 F7 85 F6
	return CallVFunction<bool(__thiscall*)(C_BaseEntity*)>(this, 157 + VALVE_ADDED_FUNCS)(this);
}

bool C_BaseEntity::IsLoot() {
	return GetClientClass()->m_ClassID == ClassId_CPhysPropAmmoBox ||
		GetClientClass()->m_ClassID == ClassId_CPhysPropLootCrate ||
		GetClientClass()->m_ClassID == ClassId_CPhysPropRadarJammer ||
		GetClientClass()->m_ClassID == ClassId_CPhysPropWeaponUpgrade ||
		GetClientClass()->m_ClassID == ClassId_CDrone ||
		GetClientClass()->m_ClassID == ClassId_CDronegun ||
		GetClientClass()->m_ClassID == ClassId_CItem_Healthshot ||
		GetClientClass()->m_ClassID == ClassId_CItemCash || 
		GetClientClass()->m_ClassID == ClassId_CBumpMine;
}

bool C_BaseEntity::IsWeapon()
{
	//index: 160
	//ref: "CNewParticleEffect::DrawModel"
	//sig: 8B 80 ? ? ? ? FF D0 84 C0 74 6F 8B 4D A4
	return CallVFunction<bool(__thiscall*)(C_BaseEntity*)>(this, 165 + VALVE_ADDED_FUNCS)(this);
}


bool C_BaseEntity::IsPlantedC4()
{
	return GetClientClass()->m_ClassID == ClassId_CPlantedC4;
}

bool C_BaseEntity::IsDefuseKit()
{
	return GetClientClass()->m_ClassID == ClassId_CBaseAnimating;
}

CCSWeaponInfo* C_BaseCombatWeapon::GetCSWeaponData()
{
	return g_WeaponSystem->GetWpnData(this->m_Item().m_iItemDefinitionIndex());
}

bool C_BaseCombatWeapon::HasBullets()
{
	return !IsReloading() && m_iClip1() > 0;
}

bool C_BaseCombatWeapon::CanFire()
{
	auto owner = this->m_hOwnerEntity().Get();
	if (!owner)
		return false;

	if (IsReloading() || m_iClip1() <= 0)
		return false;

	auto flServerTime = owner->m_nTickBase() * g_GlobalVars->interval_per_tick;

	if (owner->m_flNextAttack() > flServerTime)
		return false;


	return m_flNextPrimaryAttack() <= flServerTime;
}

bool C_BaseCombatWeapon::IsGrenade()
{
	return GetCSWeaponData()->iWeaponType == WEAPONTYPE_GRENADE;
}

bool C_BaseCombatWeapon::IsGun()
{
	switch (GetCSWeaponData()->iWeaponType)
	{
	case WEAPONTYPE_C4:
		return false;
	case WEAPONTYPE_GRENADE:
		return false;
	case WEAPONTYPE_KNIFE:
		return false;
	case WEAPONTYPE_UNKNOWN:
		return false;
	default:
		return true;
	}
}

bool C_BaseCombatWeapon::IsKnife()
{
	if (this->m_Item().m_iItemDefinitionIndex() == WEAPON_TASER) return false;
	return GetCSWeaponData()->iWeaponType == WEAPONTYPE_KNIFE;
}

bool C_BaseCombatWeapon::IsRifle()
{
	switch (GetCSWeaponData()->iWeaponType)
	{
	case WEAPONTYPE_RIFLE:
		return true;
	case WEAPONTYPE_SUBMACHINEGUN:
		return true;
	case WEAPONTYPE_SHOTGUN:
		return true;
	case WEAPONTYPE_MACHINEGUN:
		return true;
	default:
		return false;
	}
}

bool C_BaseCombatWeapon::IsPistol()
{
	switch (GetCSWeaponData()->iWeaponType)
	{
	case WEAPONTYPE_PISTOL:
		return true;
	default:
		return false;
	}
}

bool C_BaseCombatWeapon::IsSniper()
{
	switch (GetCSWeaponData()->iWeaponType)
	{
	case WEAPONTYPE_SNIPER_RIFLE:
		return true;
	default:
		return false;
	}
}

bool C_BaseCombatWeapon::IsReloading()
{
	static auto inReload = *(uint32_t*)(Utils::PatternScan(GetModuleHandleW(L"client.dll"), "C6 87 ? ? ? ? ? 8B 06 8B CE FF 90") + 2);
	return *(bool*)((uintptr_t)this + inReload);
}

float C_BaseCombatWeapon::GetInaccuracy()
{
	return CallVFunction<float(__thiscall*)(void*)>(this, 482 + VALVE_ADDED_FUNCS)(this);
}

float C_BaseCombatWeapon::GetSpread()
{
	return CallVFunction<float(__thiscall*)(void*)>(this, 452 + VALVE_ADDED_FUNCS)(this);
}

void C_BaseCombatWeapon::UpdateAccuracyPenalty()
{
	CallVFunction<void(__thiscall*)(void*)>(this, 483 + VALVE_ADDED_FUNCS)(this);
}

CUtlVector<IRefCounted*>& C_BaseCombatWeapon::m_CustomMaterials()
{	static auto inReload = *(uint32_t*)(Utils::PatternScan(GetModuleHandleW(L"client.dll"), "83 BE ? ? ? ? ? 7F 67") + 2) - 12;
	return *(CUtlVector<IRefCounted*>*)((uintptr_t)this + inReload);
}

bool* C_BaseCombatWeapon::m_bCustomMaterialInitialized()
{
	static auto currentCommand = *(uint32_t*)(Utils::PatternScan(GetModuleHandleW(L"client.dll"), "C6 86 ? ? ? ? ? FF 50 04") + 2);
	return (bool*)((uintptr_t)this + currentCommand);
}

CUserCmd*& C_BasePlayer::m_pCurrentCommand()
{
	static auto currentCommand = *(uint32_t*)(Utils::PatternScan(GetModuleHandleW(L"client.dll"), "89 BE ? ? ? ? E8 ? ? ? ? 85 FF") + 2);
	return *(CUserCmd**)((uintptr_t)this + currentCommand);
}

int C_BasePlayer::GetNumAnimOverlays()
{
	return *(int*)((DWORD)this + 0x298C);
}

AnimationLayer *C_BasePlayer::GetAnimOverlays()
{
	return *(AnimationLayer**)((DWORD)this + 0x2980);
}

AnimationLayer *C_BasePlayer::GetAnimOverlay(int i)
{
	if (i < 15)
		return &GetAnimOverlays()[i];
	return nullptr;
}

int C_BasePlayer::GetSequenceActivity(int sequence)
{
	auto hdr = g_MdlInfo->GetStudiomodel(this->GetModel());

	if (!hdr)
		return -1;

	// sig for stuidohdr_t version: 53 56 8B F1 8B DA 85 F6 74 55
	// sig for C_BaseAnimating version: 55 8B EC 83 7D 08 FF 56 8B F1 74 3D
	// c_csplayer vfunc 242, follow calls to find the function.
	// Thanks @Kron1Q for merge request
	static auto get_sequence_activity = reinterpret_cast<int(__fastcall*)(void*, studiohdr_t*, int)>(Utils::PatternScan(GetModuleHandle(L"client.dll"), "55 8B EC 53 8B 5D 08 56 8B F1 83"));

	return get_sequence_activity(this, hdr, sequence);
}

CCSGOPlayerAnimState *C_BasePlayer::GetPlayerAnimState()
{
	return *(CCSGOPlayerAnimState**)((DWORD)this + 0x3914);
}

void C_BasePlayer::UpdateAnimationState(CCSGOPlayerAnimState *state, QAngle angle)
{
	static auto UpdateAnimState = Utils::PatternScan(
		GetModuleHandleA("client.dll"), "55 8B EC 83 E4 F8 83 EC 18 56 57 8B F9 F3 0F 11 54 24");

	if (!UpdateAnimState)
		return;

	__asm {
		push 0
	}

	__asm
	{
		mov ecx, state

		movss xmm1, dword ptr[angle + 4]
		movss xmm2, dword ptr[angle]

		call UpdateAnimState
	}
}

void C_BasePlayer::ResetAnimationState(CCSGOPlayerAnimState *state)
{
	using ResetAnimState_t = void(__thiscall*)(CCSGOPlayerAnimState*);
	static auto ResetAnimState = (ResetAnimState_t)Utils::PatternScan(GetModuleHandleA("client.dll"), "56 6A 01 68 ? ? ? ? 8B F1");
	if (!ResetAnimState)
		return;

	ResetAnimState(state);
}

void C_BasePlayer::CreateAnimationState(CCSGOPlayerAnimState *state)
{
	using CreateAnimState_t = void(__thiscall*)(CCSGOPlayerAnimState*, C_BasePlayer*);
	static auto CreateAnimState = (CreateAnimState_t)Utils::PatternScan(GetModuleHandleA("client.dll"), "55 8B EC 56 8B F1 B9 ? ? ? ? C7 46");
	if (!CreateAnimState)
		return;

	CreateAnimState(state, this);
}

Vector C_BasePlayer::GetEyePos()
{
	return m_vecOrigin() + m_vecViewOffset();
}

player_info_t C_BasePlayer::GetPlayerInfo()
{
	player_info_t info;
	g_EngineClient->GetPlayerInfo(EntIndex(), &info);
	return info;
}

bool C_BasePlayer::IsAlive()
{
	return m_lifeState() == LIFE_ALIVE;
}

bool C_BasePlayer::IsFlashed()
{
	static auto m_flFlashMaxAlpha = NetvarSys::Get().GetOffset("DT_CSPlayer", "m_flFlashMaxAlpha");
	return *(float*)((uintptr_t)this + m_flFlashMaxAlpha - 0x8) > 200.0;
}

bool C_BasePlayer::HasC4()
{
	static auto fnHasC4
		= reinterpret_cast<bool(__thiscall*)(void*)>(
			Utils::PatternScan(GetModuleHandleW(L"client.dll"), "56 8B F1 85 F6 74 31")
			);

	return fnHasC4(this);
}

Vector C_BasePlayer::GetHitboxPos(int hitbox_id)
{
	matrix3x4_t boneMatrix[MAXSTUDIOBONES];

	if (SetupBones(boneMatrix, MAXSTUDIOBONES, BONE_USED_BY_HITBOX, 0.0f)) {
		auto studio_model = g_MdlInfo->GetStudiomodel(GetModel());
		if (studio_model) {
			auto hitbox = studio_model->GetHitboxSet(0)->GetHitbox(hitbox_id);
			if (hitbox) {
				auto
					min = Vector{},
					max = Vector{};

				Math::VectorTransform(hitbox->bbmin, boneMatrix[hitbox->bone], min);
				Math::VectorTransform(hitbox->bbmax, boneMatrix[hitbox->bone], max);

				return (min + max) / 2.0f;
			}
		}
	}
	return Vector{};
}

mstudiobbox_t* C_BasePlayer::GetHitbox(int hitbox_id)
{
	matrix3x4_t boneMatrix[MAXSTUDIOBONES];

	if (SetupBones(boneMatrix, MAXSTUDIOBONES, BONE_USED_BY_HITBOX, 0.0f)) {
		auto studio_model = g_MdlInfo->GetStudiomodel(GetModel());
		if (studio_model) {
			auto hitbox = studio_model->GetHitboxSet(0)->GetHitbox(hitbox_id);
			if (hitbox) {
				return hitbox;
			}
		}
	}
	return nullptr;
}

bool C_BasePlayer::GetHitboxPos(int hitbox, Vector &output)
{
	if (hitbox >= HITBOX_MAX)
		return false;

	const model_t *model = this->GetModel();
	if (!model)
		return false;

	studiohdr_t *studioHdr = g_MdlInfo->GetStudiomodel(model);
	if (!studioHdr)
		return false;

	matrix3x4_t matrix[MAXSTUDIOBONES];
	if (!this->SetupBones(matrix, MAXSTUDIOBONES, 0x100, 0))
		return false;

	mstudiobbox_t *studioBox = studioHdr->GetHitboxSet(0)->GetHitbox(hitbox);
	if (!studioBox)
		return false;

	Vector min, max;

	Math::VectorTransform(studioBox->bbmin, matrix[studioBox->bone], min);
	Math::VectorTransform(studioBox->bbmax, matrix[studioBox->bone], max);

	output = (min + max) * 0.5f;

	return true;
}

Vector C_BasePlayer::GetBonePos(int bone)
{
	matrix3x4_t boneMatrix[MAXSTUDIOBONES];
	if (SetupBones(boneMatrix, MAXSTUDIOBONES, BONE_USED_BY_ANYTHING, 0.0f)) {
		return boneMatrix[bone].at(3);
	}
	return Vector{};
}

bool C_BasePlayer::CanSeePlayer(C_BasePlayer* player, int hitbox)
{
	CGameTrace tr;
	Ray_t ray;
	CTraceFilter filter;
	filter.pSkip = this;

	auto endpos = player->GetHitboxPos(hitbox);

	ray.Init(GetEyePos(), endpos);
	g_EngineTrace->TraceRay(ray, MASK_SHOT | CONTENTS_GRATE, &filter, &tr);

	return tr.hit_entity == player || tr.fraction > 0.97f;
}

bool C_BasePlayer::CanSeePlayer(C_BasePlayer* player, const Vector& pos)
{
	CGameTrace tr;
	Ray_t ray;
	CTraceFilter filter;
	filter.pSkip = this;

	ray.Init(GetEyePos(), pos);
	g_EngineTrace->TraceRay(ray, MASK_SHOT | CONTENTS_GRATE, &filter, &tr);

	return tr.hit_entity == player || tr.fraction > 0.97f;
}

void C_BasePlayer::UpdateClientSideAnimation()
{
	return CallVFunction<void(__thiscall*)(void*)>(this, 223 + VALVE_ADDED_FUNCS)(this);
}

void C_BasePlayer::InvalidateBoneCache()
{
	static DWORD addr = (DWORD)Utils::PatternScan(GetModuleHandleA("client.dll"), "80 3D ? ? ? ? ? 74 16 A1 ? ? ? ? 48 C7 81");

	*(int*)((uintptr_t)this + 0xA30) = g_GlobalVars->framecount; //we'll skip occlusion checks now
	*(int*)((uintptr_t)this + 0xA28) = 0;//clear occlusion flags

	unsigned long g_iModelBoneCounter = **(unsigned long**)(addr + 10);
	*(unsigned int*)((DWORD)this + 0x2924) = 0xFF7FFFFF; // m_flLastBoneSetupTime = -FLT_MAX;
	*(unsigned int*)((DWORD)this + 0x2690) = (g_iModelBoneCounter - 1); // m_iMostRecentModelBoneCounter = g_iModelBoneCounter - 1;
}

int C_BasePlayer::m_nMoveType()
{
	return *(int*)((uintptr_t)this + 0x25C);
}

QAngle* C_BasePlayer::GetVAngles()
{
	static auto deadflag = NetvarSys::Get().GetOffset("DT_BasePlayer", "deadflag");
	return (QAngle*)((uintptr_t)this + deadflag + 0x4);
}

void C_BaseAttributableItem::SetGloveModelIndex(int modelIndex)
{
	return CallVFunction<void(__thiscall*)(void*, int)>(this, 75)(this, modelIndex);
}

void C_BaseViewModel::SendViewModelMatchingSequence(int sequence)
{
	return CallVFunction<void(__thiscall*)(void*, int)>(this, 246 + VALVE_ADDED_FUNCS)(this, sequence);
}

float_t C_BasePlayer::m_flSpawnTime()
{
	return *(float_t*)((uintptr_t)this + 0xA370);
}

```

`CSGOSimple/valve_sdk/csgostructs.hpp`:

```hpp
#pragma once

#include "sdk.hpp"
#include <array>
#include "../helpers/utils.hpp"

#define NETVAR(type, name, table, netvar)                           \
    type& name##() const {                                          \
        static int _##name = NetvarSys::Get().GetOffset(table, netvar);     \
        return *(type*)((uintptr_t)this + _##name);                 \
    }

#define PNETVAR(type, name, table, netvar)                           \
    type* name##() const {                                          \
        static int _##name = NetvarSys::Get().GetOffset(table, netvar);     \
        return (type*)((uintptr_t)this + _##name);                 \
    }

#define NETPROP(name, table, netvar) static RecvProp* name() \
{ \
	static auto prop_ptr = NetvarSys::Get().GetNetvarProp(table,netvar); \
	return prop_ptr; \
}

struct datamap_t;
class AnimationLayer;
class CBasePlayerAnimState;
class CCSGOPlayerAnimState;
class C_BaseEntity;

enum CSWeaponType
{
	WEAPONTYPE_KNIFE = 0,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_PLACEHOLDER,
	WEAPONTYPE_GRENADE,
	WEAPONTYPE_UNKNOWN
};

class C_BaseEntity;


// Created with ReClass.NET by KN4CK3R
class CHudTexture
{
public:
	char szShortName[64];    //0x0000
	char szTextureFile[64];  //0x0040
	bool bRenderUsingFont;   //0x0080
	bool bPrecached;         //0x0081
	int8_t cCharacterInFont; //0x0082
	uint8_t pad_0083[1];     //0x0083
	uint32_t hFont;          //0x0084
	int32_t iTextureId;      //0x0088
	float afTexCoords[4];    //0x008C
	uint8_t pad_009C[16];    //0x009C
};

class C_EconItemView
{
private:
	using str_32 = char[32];
public:
	NETVAR(int32_t, m_bInitialized, "DT_BaseAttributableItem", "m_bInitialized");
	NETVAR(int16_t, m_iItemDefinitionIndex, "DT_BaseAttributableItem", "m_iItemDefinitionIndex");
	NETVAR(int32_t, m_iEntityLevel, "DT_BaseAttributableItem", "m_iEntityLevel");
	NETVAR(int32_t, m_iAccountID, "DT_BaseAttributableItem", "m_iAccountID");
	NETVAR(int32_t, m_iItemIDLow, "DT_BaseAttributableItem", "m_iItemIDLow");
	NETVAR(int32_t, m_iItemIDHigh, "DT_BaseAttributableItem", "m_iItemIDHigh");
	NETVAR(int32_t, m_iEntityQuality, "DT_BaseAttributableItem", "m_iEntityQuality");
	NETVAR(str_32, m_iCustomName, "DT_BaseAttributableItem", "m_szCustomName");
};

class C_BaseEntity : public IClientEntity
{
public:
	datamap_t * GetDataDescMap() {
		typedef datamap_t*(__thiscall *o_GetPredDescMap)(void*);
		return CallVFunction<o_GetPredDescMap>(this, 15)(this);
	}

	datamap_t *GetPredDescMap() {
		typedef datamap_t*(__thiscall *o_GetPredDescMap)(void*);
		return CallVFunction<o_GetPredDescMap>(this, 17)(this);
	}
	static __forceinline C_BaseEntity* GetEntityByIndex(int index) {
		return static_cast<C_BaseEntity*>(g_EntityList->GetClientEntity(index));
	}
	static __forceinline C_BaseEntity* get_entity_from_handle(CBaseHandle h) {
		return static_cast<C_BaseEntity*>(g_EntityList->GetClientEntityFromHandle(h));
	}

	NETVAR(int32_t, m_nModelIndex, "DT_BaseEntity", "m_nModelIndex");
	NETVAR(int32_t, m_iTeamNum, "DT_BaseEntity", "m_iTeamNum");
	NETVAR(Vector, m_vecOrigin, "DT_BaseEntity", "m_vecOrigin");
	NETVAR(Vector, m_vecAngles, "DT_BaseEntity", "m_vecAngles");
	NETVAR(bool, m_bShouldGlow, "DT_DynamicProp", "m_bShouldGlow");
	NETVAR(CHandle<C_BasePlayer>, m_hOwnerEntity, "DT_BaseEntity", "m_hOwnerEntity");
	NETVAR(bool, m_bSpotted, "DT_BaseEntity", "m_bSpotted");
	NETVAR(float_t, m_flC4Blow, "DT_PlantedC4", "m_flC4Blow");


	const matrix3x4_t& m_rgflCoordinateFrame()
	{
		static auto _m_rgflCoordinateFrame = NetvarSys::Get().GetOffset("DT_BaseEntity", "m_CollisionGroup") - 0x30;
		return *(matrix3x4_t*)((uintptr_t)this + _m_rgflCoordinateFrame);
	}

	bool IsPlayer();
	bool IsLoot();
	bool IsWeapon();
	bool IsPlantedC4();
	bool IsDefuseKit();
	//bool isSpotted();
};

class C_PlantedC4
{
public:
	NETVAR(bool, m_bBombTicking, "DT_PlantedC4", "m_bBombTicking");
	NETVAR(bool, m_bBombDefused, "DT_PlantedC4", "m_bBombDefused");
	NETVAR(float, m_flC4Blow, "DT_PlantedC4", "m_flC4Blow");
	NETVAR(float, m_flTimerLength, "DT_PlantedC4", "m_flTimerLength");
	NETVAR(float, m_flDefuseLength, "DT_PlantedC4", "m_flDefuseLength");
	NETVAR(float, m_flDefuseCountDown, "DT_PlantedC4", "m_flDefuseCountDown");
	NETVAR(CHandle<C_BasePlayer>, m_hBombDefuser, "DT_PlantedC4", "m_hBombDefuser");
};

class C_BaseAttributableItem : public C_BaseEntity
{
public:
	NETVAR(uint64_t, m_OriginalOwnerXuid, "DT_BaseAttributableItem", "m_OriginalOwnerXuidLow");
	NETVAR(int32_t, m_OriginalOwnerXuidLow, "DT_BaseAttributableItem", "m_OriginalOwnerXuidLow");
	NETVAR(int32_t, m_OriginalOwnerXuidHigh, "DT_BaseAttributableItem", "m_OriginalOwnerXuidHigh");
	NETVAR(int32_t, m_nFallbackStatTrak, "DT_BaseAttributableItem", "m_nFallbackStatTrak");
	NETVAR(int32_t, m_nFallbackPaintKit, "DT_BaseAttributableItem", "m_nFallbackPaintKit");
	NETVAR(int32_t, m_nFallbackSeed, "DT_BaseAttributableItem", "m_nFallbackSeed");
	NETVAR(float_t, m_flFallbackWear, "DT_BaseAttributableItem", "m_flFallbackWear");

	NETVAR(C_EconItemView, m_Item2, "DT_BaseAttributableItem", "m_Item");

	C_EconItemView& m_Item()
	{
		// Cheating. It should be this + m_Item netvar but then the netvars inside C_EconItemView wont work properly.
		// A real fix for this requires a rewrite of the netvar manager
		return *(C_EconItemView*)this;
	}
	void SetGloveModelIndex(int modelIndex);

};

class C_BaseWeaponWorldModel : public C_BaseEntity
{
public:
	NETVAR(int32_t, m_nModelIndex, "DT_BaseWeaponWorldModel", "m_nModelIndex");
};

class C_BaseCombatWeapon : public C_BaseAttributableItem
{
public:
	NETVAR(float_t, m_flNextPrimaryAttack, "DT_BaseCombatWeapon", "m_flNextPrimaryAttack");
	NETVAR(float_t, m_flNextSecondaryAttack, "DT_BaseCombatWeapon", "m_flNextSecondaryAttack");
	NETVAR(int32_t, m_iClip1, "DT_BaseCombatWeapon", "m_iClip1");
	NETVAR(int32_t, m_iClip2, "DT_BaseCombatWeapon", "m_iClip2");
	NETVAR(float_t, m_flRecoilIndex, "DT_WeaponCSBase", "m_flRecoilIndex");
	NETVAR(int32_t, m_iViewModelIndex, "DT_BaseCombatWeapon", "m_iViewModelIndex");
	NETVAR(int32_t, m_iWorldModelIndex, "DT_BaseCombatWeapon", "m_iWorldModelIndex");
	NETVAR(int32_t, m_iWorldDroppedModelIndex, "DT_BaseCombatWeapon", "m_iWorldDroppedModelIndex");
	NETVAR(bool, m_bPinPulled, "DT_BaseCSGrenade", "m_bPinPulled");
	NETVAR(float_t, m_fThrowTime, "DT_BaseCSGrenade", "m_fThrowTime");
	NETVAR(float_t, m_flPostponeFireReadyTime, "DT_BaseCombatWeapon", "m_flPostponeFireReadyTime");
	NETVAR(CHandle<C_BaseWeaponWorldModel>, m_hWeaponWorldModel, "DT_BaseCombatWeapon", "m_hWeaponWorldModel");


	CCSWeaponInfo* GetCSWeaponData();
	bool HasBullets();
	bool CanFire();
	bool IsGrenade();
	bool IsKnife();
	bool IsReloading();
	bool IsRifle();
	bool IsPistol();
	bool IsSniper();
	bool IsGun();
	float GetInaccuracy();
	float GetSpread();
	void UpdateAccuracyPenalty();
	CUtlVector<IRefCounted*>& m_CustomMaterials();
	bool* m_bCustomMaterialInitialized();

};

class C_BasePlayer : public C_BaseEntity
{
public:
	static __forceinline C_BasePlayer* GetPlayerByUserId(int id)
	{
		return static_cast<C_BasePlayer*>(GetEntityByIndex(g_EngineClient->GetPlayerForUserID(id)));
	}
	static __forceinline C_BasePlayer* GetPlayerByIndex(int i)
	{
		return static_cast<C_BasePlayer*>(GetEntityByIndex(i));
	}

	NETVAR(bool, m_bHasDefuser, "DT_CSPlayer", "m_bHasDefuser");
	NETVAR(bool, m_bGunGameImmunity, "DT_CSPlayer", "m_bGunGameImmunity");
	NETVAR(int32_t, m_iShotsFired, "DT_CSPlayer", "m_iShotsFired");
	NETVAR(QAngle, m_angEyeAngles, "DT_CSPlayer", "m_angEyeAngles[0]");
	NETVAR(int, m_ArmorValue, "DT_CSPlayer", "m_ArmorValue");
	NETVAR(bool, m_bHasHeavyArmor, "DT_CSPlayer", "m_bHasHeavyArmor");
	NETVAR(bool, m_bHasHelmet, "DT_CSPlayer", "m_bHasHelmet");
	NETVAR(bool, m_bIsScoped, "DT_CSPlayer", "m_bIsScoped");;
	NETVAR(float, m_flLowerBodyYawTarget, "DT_CSPlayer", "m_flLowerBodyYawTarget");
	NETVAR(int32_t, m_iHealth, "DT_BasePlayer", "m_iHealth");
	NETVAR(int32_t, m_lifeState, "DT_BasePlayer", "m_lifeState");
	NETVAR(int32_t, m_fFlags, "DT_BasePlayer", "m_fFlags");
	NETVAR(int32_t, m_nTickBase, "DT_BasePlayer", "m_nTickBase");
	NETVAR(Vector, m_vecViewOffset, "DT_BasePlayer", "m_vecViewOffset[0]");
	NETVAR(QAngle, m_viewPunchAngle, "DT_BasePlayer", "m_viewPunchAngle");
	NETVAR(QAngle, m_aimPunchAngle, "DT_BasePlayer", "m_aimPunchAngle");
	NETVAR(CHandle<C_BaseViewModel>, m_hViewModel, "DT_BasePlayer", "m_hViewModel[0]");
	NETVAR(Vector, m_vecVelocity, "DT_BasePlayer", "m_vecVelocity[0]");
	NETVAR(float, m_flMaxspeed, "DT_BasePlayer", "m_flMaxspeed");
	NETVAR(CHandle<C_BasePlayer>, m_hObserverTarget, "DT_BasePlayer", "m_hObserverTarget");
	NETVAR(float, m_flFlashMaxAlpha, "DT_CSPlayer", "m_flFlashMaxAlpha");
	NETVAR(int32_t, m_nHitboxSet, "DT_BaseAnimating", "m_nHitboxSet");
	NETVAR(CHandle<C_BaseCombatWeapon>, m_hActiveWeapon, "DT_BaseCombatCharacter", "m_hActiveWeapon");
	NETVAR(int32_t, m_iAccount, "DT_CSPlayer", "m_iAccount");
	NETVAR(float, m_flFlashDuration, "DT_CSPlayer", "m_flFlashDuration");
	NETVAR(float, m_flSimulationTime, "DT_BaseEntity", "m_flSimulationTime");
	NETVAR(float, m_flCycle, "DT_BaseAnimating", "m_flCycle");
	NETVAR(int, m_nSequence, "DT_BaseViewModel", "m_nSequence");
	NETVAR(float, m_flNextAttack, "DT_BaseCombatCharacter", "m_flNextAttack");

	//NETVAR(int, m_iAccount, "DT_CSPlayer", "m_iAccount");


	NETVAR(QAngle, m_angAbsAngles, "DT_BaseEntity", "m_angAbsAngles");
	NETVAR(Vector, m_angAbsOrigin, "DT_BaseEntity", "m_angAbsOrigin");
	NETVAR(float, m_flDuckSpeed, "DT_BasePlayer", "m_flDuckSpeed");
	NETVAR(float, m_flDuckAmount, "DT_BasePlayer", "m_flDuckAmount");
	std::array<float, 24> &m_flPoseParameter() const {
		static int _m_flPoseParameter = NetvarSys::Get().GetOffset("DT_BaseAnimating", "m_flPoseParameter");
		return *(std::array<float, 24>*)((uintptr_t)this + _m_flPoseParameter);
	}


	PNETVAR(CHandle<C_BaseCombatWeapon>, m_hMyWeapons, "DT_BaseCombatCharacter", "m_hMyWeapons");
	PNETVAR(CHandle<C_BaseAttributableItem>, m_hMyWearables, "DT_BaseCombatCharacter", "m_hMyWearables");
	PNETVAR(char, m_szLastPlaceName, "DT_BasePlayer", "m_szLastPlaceName");


	NETPROP(m_flLowerBodyYawTargetProp, "DT_CSPlayer", "m_flLowerBodyYawTarget");
	CUserCmd*& m_pCurrentCommand();

	/*gladiator v2*/
	void InvalidateBoneCache();
	int GetNumAnimOverlays();
	AnimationLayer *GetAnimOverlays();
	AnimationLayer *GetAnimOverlay(int i);
	int GetSequenceActivity(int sequence);
	CCSGOPlayerAnimState *GetPlayerAnimState();

	static void UpdateAnimationState(CCSGOPlayerAnimState *state, QAngle angle);
	static void ResetAnimationState(CCSGOPlayerAnimState *state);
	void CreateAnimationState(CCSGOPlayerAnimState *state);

	float_t &m_surfaceFriction()
	{
		static unsigned int _m_surfaceFriction = Utils::FindInDataMap(GetPredDescMap(), "m_surfaceFriction");
		return *(float_t*)((uintptr_t)this + _m_surfaceFriction);
	}
	Vector &m_vecBaseVelocity()
	{
		static unsigned int _m_vecBaseVelocity = Utils::FindInDataMap(GetPredDescMap(), "m_vecBaseVelocity");
		return *(Vector*)((uintptr_t)this + _m_vecBaseVelocity);
	}

	float_t &m_flMaxspeed()
	{
		static unsigned int _m_flMaxspeed = Utils::FindInDataMap(GetPredDescMap(), "m_flMaxspeed");
		return *(float_t*)((uintptr_t)this + _m_flMaxspeed);
	}



	Vector        GetEyePos();
	player_info_t GetPlayerInfo();
	bool          IsAlive();
	bool		  IsFlashed();
	bool          HasC4();
	Vector        GetHitboxPos(int hitbox_id);
	mstudiobbox_t * GetHitbox(int hitbox_id);
	bool          GetHitboxPos(int hitbox, Vector &output);
	Vector        GetBonePos(int bone);
	bool          CanSeePlayer(C_BasePlayer* player, int hitbox);
	bool          CanSeePlayer(C_BasePlayer* player, const Vector& pos);
	void UpdateClientSideAnimation();

	int m_nMoveType();
	QAngle * GetVAngles();
	float_t m_flSpawnTime();

};

class C_BaseViewModel : public C_BaseEntity
{
public:
	NETVAR(int32_t, m_nModelIndex, "DT_BaseViewModel", "m_nModelIndex");
	NETVAR(int32_t, m_nViewModelIndex, "DT_BaseViewModel", "m_nViewModelIndex");
	NETVAR(CHandle<C_BaseCombatWeapon>, m_hWeapon, "DT_BaseViewModel", "m_hWeapon");
	NETVAR(CHandle<C_BasePlayer>, m_hOwner, "DT_BaseViewModel", "m_hOwner");
	NETPROP(m_nSequence, "DT_BaseViewModel", "m_nSequence");
	void SendViewModelMatchingSequence(int sequence);
};

class AnimationLayer
{
public:
	char  pad_0000[20];
	// These should also be present in the padding, don't see the use for it though
	//float	m_flLayerAnimtime;
	//float	m_flLayerFadeOuttime;
	uint32_t m_nOrder; //0x0014
	uint32_t m_nSequence; //0x0018
	float_t m_flPrevCycle; //0x001C
	float_t m_flWeight; //0x0020
	float_t m_flWeightDeltaRate; //0x0024
	float_t m_flPlaybackRate; //0x0028
	float_t m_flCycle; //0x002C
	void *m_pOwner; //0x0030 // player's thisptr
	char  pad_0038[4]; //0x0034
}; //Size: 0x0038

class CCSGOPlayerAnimState
{
public:
	void* pThis;
	char pad2[91];
	void* pBaseEntity; //0x60
	void* pActiveWeapon; //0x64
	void* pLastActiveWeapon; //0x68
	float m_flLastClientSideAnimationUpdateTime; //0x6C
	int m_iLastClientSideAnimationUpdateFramecount; //0x70
	float m_flEyePitch; //0x74
	float m_flEyeYaw; //0x78
	float m_flPitch; //0x7C
	float m_flGoalFeetYaw; //0x80
	float m_flCurrentFeetYaw; //0x84
	float m_flCurrentTorsoYaw; //0x88
	float m_flUnknownVelocityLean; //0x8C //changes when moving/jumping/hitting ground
	float m_flLeanAmount; //0x90
	char pad4[4]; //NaN
	float m_flFeetCycle; //0x98 0 to 1
	float m_flFeetYawRate; //0x9C 0 to 1
	float m_fUnknown2;
	float m_fDuckAmount; //0xA4
	float m_fLandingDuckAdditiveSomething; //0xA8
	float m_fUnknown3; //0xAC
	Vector m_vOrigin; //0xB0, 0xB4, 0xB8
	Vector m_vLastOrigin; //0xBC, 0xC0, 0xC4
	float m_vVelocityX; //0xC8
	float m_vVelocityY; //0xCC
	char pad5[4];
	float m_flUnknownFloat1; //0xD4 Affected by movement and direction
	char pad6[8];
	float m_flUnknownFloat2; //0xE0 //from -1 to 1 when moving and affected by direction
	float m_flUnknownFloat3; //0xE4 //from -1 to 1 when moving and affected by direction
	float m_unknown; //0xE8
	float speed_2d; //0xEC
	float flUpVelocity; //0xF0
	float m_flSpeedNormalized; //0xF4 //from 0 to 1
	float m_flFeetSpeedForwardsOrSideWays; //0xF8 //from 0 to 2. something  is 1 when walking, 2.something when running, 0.653 when crouch walking
	float m_flFeetSpeedUnknownForwardOrSideways; //0xFC //from 0 to 3. something
	float m_flTimeSinceStartedMoving; //0x100
	float m_flTimeSinceStoppedMoving; //0x104
	unsigned char m_bOnGround; //0x108
	unsigned char m_bInHitGroundAnimation; //0x109
	char pad7[10];
	float m_flLastOriginZ; //0x114
	float m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x118 from 0 to 1, is 1 when standing
	float m_flStopToFullRunningFraction; //0x11C from 0 to 1, doesnt change when walking or crouching, only running
	char pad8[4]; //NaN
	float m_flUnknownFraction; //0x124 affected while jumping and running, or when just jumping, 0 to 1
	char pad9[4]; //NaN
	float m_flUnknown3;
	char pad10[528];
}; //Size=0x344

class DT_CSPlayerResource
{
public:
	PNETVAR(int32_t, m_nActiveCoinRank, "DT_CSPlayerResource", "m_nActiveCoinRank");
	PNETVAR(int32_t, m_nMusicID, "DT_CSPlayerResource", "m_nMusicID");
	PNETVAR(int32_t, m_nPersonaDataPublicLevel, "DT_CSPlayerResource", "m_nPersonaDataPublicLevel");
	PNETVAR(int32_t, m_nPersonaDataPublicCommendsLeader, "DT_CSPlayerResource", "m_nPersonaDataPublicCommendsLeader");
	PNETVAR(int32_t, m_nPersonaDataPublicCommendsTeacher, "DT_CSPlayerResource", "m_nPersonaDataPublicCommendsTeacher");
	PNETVAR(int32_t, m_nPersonaDataPublicCommendsFriendly, "DT_CSPlayerResource", "m_nPersonaDataPublicCommendsFriendly");
	PNETVAR(int32_t, m_iCompetitiveRanking, "DT_CSPlayerResource", "m_iCompetitiveRanking");
	PNETVAR(int32_t, m_iCompetitiveWins, "DT_CSPlayerResource", "m_iCompetitiveWins");
	PNETVAR(int32_t, m_iPlayerVIP, "DT_CSPlayerResource", "m_iPlayerVIP");
	PNETVAR(int32_t, m_iMVPs, "DT_CSPlayerResource", "m_iMVPs");
	PNETVAR(int32_t, m_iScore, "DT_CSPlayerResource", "m_iScore");
};

```

`CSGOSimple/valve_sdk/interfaces/CClientState.hpp`:

```hpp
#pragma once

#include <cstdint>

// Created with ReClass.NET by KN4CK3R
#pragma pack(push, 1)
class INetChannel
{
public:
    char pad_0000[20];           //0x0000
    bool m_bProcessingMessages;  //0x0014
    bool m_bShouldDelete;        //0x0015
    char pad_0016[2];            //0x0016
    int32_t m_nOutSequenceNr;    //0x0018 last send outgoing sequence number
    int32_t m_nInSequenceNr;     //0x001C last received incoming sequnec number
    int32_t m_nOutSequenceNrAck; //0x0020 last received acknowledge outgoing sequnce number
    int32_t m_nOutReliableState; //0x0024 state of outgoing reliable data (0/1) flip flop used for loss detection
    int32_t m_nInReliableState;  //0x0028 state of incoming reliable data
    int32_t m_nChokedPackets;    //0x002C number of choked packets
    char pad_0030[1044];         //0x0030
}; //Size: 0x0444

class CClockDriftMgr
{
public:
    float m_ClockOffsets[16];   //0x0000
    uint32_t m_iCurClockOffset; //0x0044
    uint32_t m_nServerTick;     //0x0048
    uint32_t m_nClientTick;     //0x004C
}; //Size: 0x0050

class CEventInfo
{
public:
    enum
    {
        EVENT_INDEX_BITS = 8,
        EVENT_DATA_LEN_BITS = 11,
        MAX_EVENT_DATA = 192,  // ( 1<<8 bits == 256, but only using 192 below )
    };

    inline CEventInfo()
    {
        classID = 0;
        fire_delay = 0.0f;
        flags = 0;
        pSendTable = NULL;
        pClientClass = NULL;
        m_Packed = 0;
    }

    short classID;
    short pad;
    float fire_delay;
    const void* pSendTable;
    const ClientClass* pClientClass;
    int m_Packed;
    int		flags;
    int filter[8];
    CEventInfo* next;
};

// Thanks soufiw 
class CClientState
{
public:
	void ForceFullUpdate()
	{
		m_nDeltaTick = -1;
	}

	char pad_0000[156];
	INetChannel* m_NetChannel;
	int m_nChallengeNr;
	char pad_00A4[100];
	int m_nSignonState;
	int signon_pads[2];
	float m_flNextCmdTime;
	int m_nServerCount;
	int m_nCurrentSequence;
	int musor_pads[2];
	CClockDriftMgr m_ClockDriftMgr;
	int m_nDeltaTick;
	bool m_bPaused;
	char paused_align[3];
	int m_nViewEntity;
	int m_nPlayerSlot;
	int bruh;
	char m_szLevelName[260];
	char m_szLevelNameShort[80];
	char m_szGroupName[80];
	char pad_032[92];
	int m_nMaxClients;
	char pad_0314[18828];
	float m_nLastServerTickTime;
	bool m_bInSimulation;
	char pad_4C9D[3];
	int m_nOldTickCount;
	float m_flTickReminder;
	float m_flFrametime;
	int m_nLastOutgoingCommand;
	int m_nChokedCommands;
	int m_nLastCommandAck;
	int m_nPacketEndTickUpdate;
	int m_nCommandAck;
	int m_nSoundSequence;
	char pad_4CCD[76];
	QAngle viewangles;
	int pads[54];
	CEventInfo* m_pEvents;
};

#pragma pack(pop)

static_assert(FIELD_OFFSET(CClientState, m_NetChannel)       == 0x009C, "Wrong struct offset");
static_assert(FIELD_OFFSET(CClientState, m_nCurrentSequence) == 0x011C, "Wrong struct offset");
static_assert(FIELD_OFFSET(CClientState, m_nDeltaTick)       == 0x0174, "Wrong struct offset");
static_assert(FIELD_OFFSET(CClientState, m_nMaxClients)      == 0x0388, "Wrong struct offset");
static_assert(FIELD_OFFSET(CClientState, viewangles)         == 0x4D90, "Wrong struct offset");
```

`CSGOSimple/valve_sdk/interfaces/CInput.hpp`:

```hpp
#pragma once

#include "../Misc/CUserCmd.hpp"

#define MULTIPLAYER_BACKUP 150

class bf_write;
class bf_read;

class CInput
{
public:
	char                pad_0x00[0x0C];  
	bool                m_trackir_available;  
	bool                m_mouse_initiated;  
	bool                m_mouse_active;  
	bool                m_fJoystickAdvancedInit;       
	char                pad_0x08[0x2C];                
	void*               m_pKeys;                       
	char                pad_0x38[0x6C];                
	bool                m_fCameraInterceptingMouse;    
	bool                m_fCameraInThirdPerson;        
	bool                m_fCameraMovingWithMouse;      
	Vector		    m_vecCameraOffset;             
	bool                m_fCameraDistanceMove;         
	int                 m_nCameraOldX;                 
	int                 m_nCameraOldY;                 
	int                 m_nCameraX;                    
	int                 m_nCameraY;                    
	bool                m_CameraIsOrthographic;        
	Vector              m_angPreviousViewAngles;       
	Vector              m_angPreviousViewAnglesTilt;   
	float               m_flLastForwardMove;           
	int                 m_nClearInputState;            
	char                pad_0xE4[0x8];                 
	CUserCmd*           m_pCommands;                   
	CVerifiedUserCmd*   m_pVerifiedCommands;           

	inline CUserCmd* GetUserCmd(int sequence_number);
	inline CUserCmd * GetUserCmd(int nSlot, int sequence_number);
	inline CVerifiedUserCmd* GetVerifiedCmd(int sequence_number);
};

CUserCmd* CInput::GetUserCmd(int sequence_number)
{
	using OriginalFn = CUserCmd * (__thiscall *)(void *, int, int);
	return CallVFunction<OriginalFn>(this, 8)(this, 0, sequence_number);
}

CUserCmd *CInput::GetUserCmd(int nSlot, int sequence_number)
{
	typedef CUserCmd*(__thiscall *GetUserCmd_t)(void*, int, int);
	return CallVFunction<GetUserCmd_t>(this, 8)(this, nSlot, sequence_number);
}

CVerifiedUserCmd* CInput::GetVerifiedCmd(int sequence_number)
{
	auto verifiedCommands = *(CVerifiedUserCmd **)(reinterpret_cast<uint32_t>(this) + 0xF8);
	return &verifiedCommands[sequence_number % MULTIPLAYER_BACKUP];
}

```

`CSGOSimple/valve_sdk/interfaces/IAppSystem.hpp`:

```hpp
#pragma once

typedef void* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);
typedef void* (*InstantiateInterfaceFn)();

class IAppSystem
{
public:
    virtual bool                            Connect(CreateInterfaceFn factory) = 0;                                     // 0
    virtual void                            Disconnect() = 0;                                                           // 1
    virtual void*                           QueryInterface(const char *pInterfaceName) = 0;                             // 2
    virtual int /*InitReturnVal_t*/         Init() = 0;                                                                 // 3
    virtual void                            Shutdown() = 0;                                                             // 4
    virtual const void* /*AppSystemInfo_t*/ GetDependencies() = 0;                                                      // 5
    virtual int /*AppSystemTier_t*/         GetTier() = 0;                                                              // 6
    virtual void                            Reconnect(CreateInterfaceFn factory, const char *pInterfaceName) = 0;       // 7
    virtual void                            UnkFunc() = 0;                                                              // 8
};
```

`CSGOSimple/valve_sdk/interfaces/IBaseClientDll.hpp`:

```hpp
#pragma once

#include "../Misc/GlobalVars.hpp"
#include "../Misc/ClientClass.hpp"

enum ClientFrameStage_t
{
    FRAME_UNDEFINED = -1,
    FRAME_START,
    FRAME_NET_UPDATE_START,
    FRAME_NET_UPDATE_POSTDATAUPDATE_START,
    FRAME_NET_UPDATE_POSTDATAUPDATE_END,
    FRAME_NET_UPDATE_END,
    FRAME_RENDER_START,
    FRAME_RENDER_END
};

// Used by RenderView
enum RenderViewInfo_t
{
    RENDERVIEW_UNSPECIFIED = 0,
    RENDERVIEW_DRAWVIEWMODEL = (1 << 0),
    RENDERVIEW_DRAWHUD = (1 << 1),
    RENDERVIEW_SUPPRESSMONITORRENDERING = (1 << 2),
};

class IBaseClientDLL
{
public:
    virtual int              Connect(CreateInterfaceFn appSystemFactory, CGlobalVarsBase *pGlobals) = 0;
    virtual int              Disconnect(void) = 0;
    virtual int              Init(CreateInterfaceFn appSystemFactory, CGlobalVarsBase *pGlobals) = 0;
    virtual void             PostInit() = 0;
    virtual void             Shutdown(void) = 0;
    virtual void             LevelInitPreEntity(char const* pMapName) = 0;
    virtual void             LevelInitPostEntity() = 0;
    virtual void             LevelShutdown(void) = 0;
    virtual ClientClass*     GetAllClasses(void) = 0;
    
    bool DispatchUserMessage(int messageType, int arg, int arg1, void* data)
	{
		using DispatchUserMessage_t = bool* (__thiscall*)(void*, int, int, int, void*);
		return CallVFunction<DispatchUserMessage_t>(this, 38)(this, messageType, arg, arg1, data);
	}
};

```

`CSGOSimple/valve_sdk/interfaces/IClientEntity.hpp`:

```hpp
#pragma once 

#include "IClientNetworkable.hpp"
#include "IClientRenderable.hpp"
#include "IClientUnknown.hpp"
#include "IClientThinkable.hpp"

struct SpatializationInfo_t;

class IClientEntity : public IClientUnknown, public IClientRenderable, public IClientNetworkable, public IClientThinkable
{
public:
	virtual void Release(void) = 0;
};

#pragma pack(push, 1)
class CCSWeaponInfo { //xSeeker
public:
	int8_t pad0[20];
	int32_t iMaxClip1;
	int8_t pad1[12];
	int32_t iMaxReservedAmmo;
	int8_t pad2[96];
	char* szHudName;
	char* szWeaponName;
	int8_t pad3[56];
	int32_t iWeaponType;
	int8_t pad4[4];
	int32_t iWeaponPrice;
	int32_t iKillAward;
	int8_t pad5[20];
	uint8_t bFullAuto;
	int8_t pad6[3];
	int32_t iDamage;
	float_t flArmorRatio;
	int32_t iBullets;
	float_t flPenetration;
	int8_t pad7[8];
	float_t flRange;
	float_t flRangeModifier;
	int8_t pad8[16];
	uint8_t bHasSilencer;
	int8_t pad9[15];
	float_t flSpread;
	float_t flSpreadAlt;
	int8_t pad10[76];
	int32_t iRecoilSeed;
	int8_t pad11[32];
};
#pragma pack(pop)

class IWeaponSystem
{
	virtual void unused0() = 0;
	virtual void unused1() = 0;
public:
	virtual CCSWeaponInfo* GetWpnData(unsigned ItemDefinitionIndex) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IClientEntityList.hpp`:

```hpp
#pragma once

#include "../Misc/IHandleEntity.hpp"

class IClientNetworkable;
class IClientEntity;

class IClientEntityList
{
public:
    virtual IClientNetworkable*   GetClientNetworkable(int entnum) = 0;
    virtual void*                 vtablepad0x1(void) = 0;
    virtual void*                 vtablepad0x2(void) = 0;
    virtual IClientEntity*        GetClientEntity(int entNum) = 0;
    virtual IClientEntity*        GetClientEntityFromHandle(CBaseHandle hEnt) = 0;
    virtual int                   NumberOfEntities(bool bIncludeNonNetworkable) = 0;
    virtual int                   GetHighestEntityIndex(void) = 0;
    virtual void                  SetMaxEntities(int maxEnts) = 0;
    virtual int                   GetMaxEntities() = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IClientMode.hpp`:

```hpp
#pragma once

#include "../Math/VMatrix.hpp"

class IPanel;
class C_BaseEntity;

enum class ClearFlags_t
{
    VIEW_CLEAR_COLOR = 0x1,
    VIEW_CLEAR_DEPTH = 0x2,
    VIEW_CLEAR_FULL_TARGET = 0x4,
    VIEW_NO_DRAW = 0x8,
    VIEW_CLEAR_OBEY_STENCIL = 0x10,
    VIEW_CLEAR_STENCIL = 0x20,
};


enum class MotionBlurMode_t
{
    MOTION_BLUR_DISABLE = 1,
    MOTION_BLUR_GAME = 2,
    MOTION_BLUR_SFM = 3
};

class CViewSetup
{
public:
    __int32   x;                  //0x0000 
    __int32   x_old;              //0x0004 
    __int32   y;                  //0x0008 
    __int32   y_old;              //0x000C 
    __int32   width;              //0x0010 
    __int32   width_old;          //0x0014 
    __int32   height;             //0x0018 
    __int32   height_old;         //0x001C 
    char      pad_0x0020[0x90];   //0x0020
    float     fov;                //0x00B0 
    float     viewmodel_fov;      //0x00B4 
    Vector    origin;             //0x00B8 
    Vector    angles;             //0x00C4 
    char      pad_0x00D0[0x7C];   //0x00D0

};//Size=0x014C

class IClientMode
{
public:
    virtual             ~IClientMode() {}
    virtual int         ClientModeCSNormal(void *) = 0;
    virtual void        Init() = 0;
    virtual void        InitViewport() = 0;
    virtual void        Shutdown() = 0;
    virtual void        Enable() = 0;
    virtual void        Disable() = 0;
    virtual void        Layout() = 0;
    virtual IPanel*     GetViewport() = 0;
    virtual void*       GetViewportAnimationController() = 0;
    virtual void        ProcessInput(bool bActive) = 0;
    virtual bool        ShouldDrawDetailObjects() = 0;
    virtual bool        ShouldDrawEntity(C_BaseEntity *pEnt) = 0;
    virtual bool        ShouldDrawLocalPlayer(C_BaseEntity *pPlayer) = 0;
    virtual bool        ShouldDrawParticles() = 0;
    virtual bool        ShouldDrawFog(void) = 0;
    virtual void        OverrideView(CViewSetup *pSetup) = 0;
    virtual int         KeyInput(int down, int keynum, const char *pszCurrentBinding) = 0;
    virtual void        StartMessageMode(int iMessageModeType) = 0;
    virtual IPanel*     GetMessagePanel() = 0;
    virtual void        OverrideMouseInput(float *x, float *y) = 0;
    virtual bool        CreateMove(float flInputSampleTime, void* usercmd) = 0;
    virtual void        LevelInit(const char *newmap) = 0;
    virtual void        LevelShutdown(void) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IClientNetworkable.hpp`:

```hpp
#pragma once

class IClientUnknown;
class ClientClass;
class bf_read;

class IClientNetworkable
{
public:
    virtual IClientUnknown*  GetIClientUnknown() = 0;
    virtual void             Release() = 0;
    virtual ClientClass*     GetClientClass() = 0;
    virtual void             NotifyShouldTransmit(int state) = 0;
    virtual void             OnPreDataChanged(int updateType) = 0;
    virtual void             OnDataChanged(int updateType) = 0;
    virtual void             PreDataUpdate(int updateType) = 0;
    virtual void             PostDataUpdate(int updateType) = 0;
    virtual void             __unkn(void) = 0;
    virtual bool             IsDormant(void) = 0;
    virtual int              EntIndex(void) const = 0;
    virtual void             ReceiveMessage(int classID, bf_read& msg) = 0;
    virtual void*            GetDataTableBasePtr() = 0;
    virtual void             SetDestroyedOnRecreateEntities(void) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IClientRenderable.hpp`:

```hpp
#pragma once

#include "../math/Vector.hpp"
#include "../math/QAngle.hpp"

typedef unsigned short ClientShadowHandle_t;
typedef unsigned short ClientRenderHandle_t;
typedef unsigned short ModelInstanceHandle_t;
typedef unsigned char uint8_t;

class matrix3x4_t;
class IClientUnknown;
struct model_t;

class IClientRenderable
{
public:
	virtual IClientUnknown*            GetIClientUnknown() = 0;
	virtual Vector const&              GetRenderOrigin(void) = 0;
	virtual QAngle const&              GetRenderAngles(void) = 0;
	virtual bool                       ShouldDraw(void) = 0;
	virtual int                        GetRenderFlags(void) = 0; // ERENDERFLAGS_xxx
	virtual void                       Unused(void) const {}
	virtual ClientShadowHandle_t       GetShadowHandle() const = 0;
	virtual ClientRenderHandle_t&      RenderHandle() = 0;
	virtual const model_t*             GetModel() const = 0;
	virtual int                        DrawModel(int flags, const int /*RenderableInstance_t*/ &instance) = 0;
	virtual int                        GetBody() = 0;
	virtual void                       GetColorModulation(float* color) = 0;
	virtual bool                       LODTest() = 0;
	virtual bool                       SetupBones(matrix3x4_t *pBoneToWorldOut, int nMaxBones, int boneMask, float currentTime) = 0;
	virtual void                       SetupWeights(const matrix3x4_t *pBoneToWorld, int nFlexWeightCount, float *pFlexWeights, float *pFlexDelayedWeights) = 0;
	virtual void                       DoAnimationEvents(void) = 0;
	virtual void* /*IPVSNotify*/       GetPVSNotifyInterface() = 0;
	virtual void                       GetRenderBounds(Vector& mins, Vector& maxs) = 0;
	virtual void                       GetRenderBoundsWorldspace(Vector& mins, Vector& maxs) = 0;
	virtual void                       GetShadowRenderBounds(Vector &mins, Vector &maxs, int /*ShadowType_t*/ shadowType) = 0;
	virtual bool                       ShouldReceiveProjectedTextures(int flags) = 0;
	virtual bool                       GetShadowCastDistance(float *pDist, int /*ShadowType_t*/ shadowType) const = 0;
	virtual bool                       GetShadowCastDirection(Vector *pDirection, int /*ShadowType_t*/ shadowType) const = 0;
	virtual bool                       IsShadowDirty() = 0;
	virtual void                       MarkShadowDirty(bool bDirty) = 0;
	virtual IClientRenderable*         GetShadowParent() = 0;
	virtual IClientRenderable*         FirstShadowChild() = 0;
	virtual IClientRenderable*         NextShadowPeer() = 0;
	virtual int /*ShadowType_t*/       ShadowCastType() = 0;
	virtual void                       CreateModelInstance() = 0;
	virtual ModelInstanceHandle_t      GetModelInstance() = 0;
	virtual const matrix3x4_t&         RenderableToWorldTransform() = 0;
	virtual int                        LookupAttachment(const char *pAttachmentName) = 0;
	virtual   bool                     GetAttachment(int number, Vector &origin, QAngle &angles) = 0;
	virtual bool                       GetAttachment(int number, matrix3x4_t &matrix) = 0;
	virtual float*                     GetRenderClipPlane(void) = 0;
	virtual int                        GetSkin() = 0;
	virtual void                       OnThreadedDrawSetup() = 0;
	virtual bool                       UsesFlexDelayedWeights() = 0;
	virtual void                       RecordToolMessage() = 0;
	virtual bool                       ShouldDrawForSplitScreenUser(int nSlot) = 0;
	virtual uint8_t                      OverrideAlphaModulation(uint8_t nAlpha) = 0;
	virtual uint8_t                      OverrideShadowAlphaModulation(uint8_t nAlpha) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IClientThinkable.hpp`:

```hpp
#pragma once

class IClientUnknown;
class CClientThinkHandlePtr;
typedef CClientThinkHandlePtr* ClientThinkHandle_t;

class IClientThinkable
{
public:
    virtual IClientUnknown*     GetIClientUnknown() = 0;
    virtual void                ClientThink() = 0;
    virtual ClientThinkHandle_t GetThinkHandle() = 0;
    virtual void                SetThinkHandle(ClientThinkHandle_t hThink) = 0;
    virtual void                Release() = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IClientUnknown.hpp`:

```hpp
#pragma once

#include "../Misc/IHandleEntity.hpp"
#include "ICollideable.hpp"

//class ICollideable;
class IClientNetworkable;
class IClientRenderable;
class IClientEntity;
class C_BaseEntity;
class IClientThinkable;
class IClientAlphaProperty;

class IClientUnknown : public IHandleEntity
{
public:
    virtual ICollideable*              GetCollideable() = 0;
    virtual IClientNetworkable*        GetClientNetworkable() = 0;
    virtual IClientRenderable*         GetClientRenderable() = 0;
    virtual IClientEntity*             GetIClientEntity() = 0;
    virtual C_BaseEntity*              GetBaseEntity() = 0;
    virtual IClientThinkable*          GetClientThinkable() = 0;
    //virtual IClientModelRenderable*  GetClientModelRenderable() = 0;
    virtual IClientAlphaProperty*      GetClientAlphaProperty() = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/ICollideable.hpp`:

```hpp
#pragma once

enum SolidType_t;
class IHandleEntity;
struct Ray_t;
struct model_t;
class CGameTrace;
typedef CGameTrace trace_t;
class IClientUnknown;
class matrix3x4_t;

class ICollideable
{
public:
    virtual IHandleEntity*      GetEntityHandle() = 0;
    virtual const Vector&       OBBMins() const = 0;
    virtual const Vector&       OBBMaxs() const = 0;
    virtual void                WorldSpaceTriggerBounds(Vector *pVecWorldMins, Vector *pVecWorldMaxs) const = 0;
    virtual bool                TestCollision(const Ray_t &ray, unsigned int fContentsMask, trace_t& tr) = 0;
    virtual bool                TestHitboxes(const Ray_t &ray, unsigned int fContentsMask, trace_t& tr) = 0;
    virtual int                 GetCollisionModelIndex() = 0;
    virtual const model_t*      GetCollisionModel() = 0;
    virtual const Vector&       GetCollisionOrigin() const = 0;
    virtual const QAngle&       GetCollisionAngles() const = 0;
    virtual const matrix3x4_t&  CollisionToWorldTransform() const = 0;
    virtual SolidType_t         GetSolid() const = 0;
    virtual int                 GetSolidFlags() const = 0;
    virtual IClientUnknown*     GetIClientUnknown() = 0;
    virtual int                 GetCollisionGroup() const = 0;
    virtual void                WorldSpaceSurroundingBounds(Vector *pVecMins, Vector *pVecMaxs) = 0;
    virtual bool                ShouldTouchTrigger(int triggerSolidFlags) const = 0;
    virtual const matrix3x4_t*  GetRootParentToWorldTransform() const = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IConVar.hpp`:

```hpp
#pragma once

#include "../Misc/Color.hpp"

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class IConVar;
class CCommand;


//-----------------------------------------------------------------------------
// ConVar flags
//-----------------------------------------------------------------------------
// The default, no flags at all
#define FCVAR_NONE                0 

// Command to ConVars and ConCommands
// ConVar Systems
#define FCVAR_UNREGISTERED              (1<<0)  // If this is Set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY           (1<<1)  // Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
#define FCVAR_GAMEDLL                   (1<<2)  // defined by the game DLL
#define FCVAR_CLIENTDLL                 (1<<3)  // defined by the client DLL
#define FCVAR_HIDDEN                    (1<<4)  // Hidden. Doesn't appear in GetOffset or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.

// ConVar only                                  
#define FCVAR_PROTECTED                 (1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY                    (1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_ARCHIVE                   (1<<7)  // Set to cause it to be saved to vars.rc
#define FCVAR_NOTIFY                    (1<<8)  // notifies players when changed
#define FCVAR_USERINFO                  (1<<9)  // changes the client's info string

#define FCVAR_PRINTABLEONLY             (1<<10) // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED                  (1<<11) // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING           (1<<12) // never try to print that cvar
#define FCVAR_REPLICATED                (1<<13) // server setting enforced on clients, TODO rename to FCAR_SERVER at some time
#define FCVAR_CHEAT                     (1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats
#define FCVAR_SS                        (1<<15) // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
#define FCVAR_DEMO                      (1<<16) // record this cvar when starting a demo file
#define FCVAR_DONTRECORD                (1<<17) // don't record these command in demofiles
#define FCVAR_SS_ADDED                  (1<<18) // This is one of the "added" FCVAR_SS variables for the splitscreen players
#define FCVAR_RELEASE                   (1<<19) // Cvars tagged with this are the only cvars avaliable to customers
#define FCVAR_RELOAD_MATERIALS          (1<<20) // If this cvar changes, it forces a material reload
#define FCVAR_RELOAD_TEXTURES           (1<<21) // If this cvar changes, if forces a texture reload
#define FCVAR_NOT_CONNECTED             (1<<22) // cvar cannot be changed by a client that is connected to a server
#define FCVAR_MATERIAL_SYSTEM_THREAD    (1<<23) // Indicates this cvar is read from the material system thread
#define FCVAR_ARCHIVE_XBOX              (1<<24) // cvar written to config.cfg on the Xbox
#define FCVAR_ACCESSIBLE_FROM_THREADS   (1<<25) // used as a debugging tool necessary to check material system thread convars
//#define FCVAR_AVAILABLE               (1<<26)
//#define FCVAR_AVAILABLE               (1<<27)
#define FCVAR_SERVER_CAN_EXECUTE        (1<<28) // the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
#define FCVAR_SERVER_CANNOT_QUERY       (1<<29) // If this is Set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE     (1<<30) // IVEngineClient::ClientCmd is allowed to execute this command. 
#define FCVAR_MEME_DLL                  (1<<31)

#define FCVAR_MATERIAL_THREAD_MASK ( FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD )    

//-----------------------------------------------------------------------------
// Called when a ConVar changes value
// NOTE: For FCVAR_NEVER_AS_STRING ConVars, pOldValue == NULL
//-----------------------------------------------------------------------------
typedef void(*FnChangeCallback_t)(IConVar *var, const char *pOldValue, float flOldValue);


//-----------------------------------------------------------------------------
// Abstract interface for ConVars
//-----------------------------------------------------------------------------
class IConVar
{
public:
    virtual void SetValue(const char *pValue) = 0;
    virtual void SetValue(float flValue) = 0;
    virtual void SetValue(int nValue) = 0;
    virtual void SetValue(Color value) = 0;
    virtual const char *GetName(void) const = 0;
    virtual const char *GetBaseName(void) const = 0;
    virtual bool IsFlagSet(int nFlag) const = 0;
    virtual int GetSplitScreenPlayerSlot() const = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/ICvar.hpp`:

```hpp
#pragma once

#include "IAppSystem.hpp"
#include "IConVar.hpp"

class ConCommandBase;
class ConCommand;
class ConVar;

typedef int CVarDLLIdentifier_t;

class IConsoleDisplayFunc
{
public:
    virtual void ColorPrint(const uint8_t* clr, const char *pMessage) = 0;
    virtual void Print(const char *pMessage) = 0;
    virtual void DPrint(const char *pMessage) = 0;
};

class ICvar : public IAppSystem
{
public:
    virtual CVarDLLIdentifier_t        AllocateDLLIdentifier() = 0; // 9
    virtual void                       RegisterConCommand(ConCommandBase *pCommandBase) = 0; //10
    virtual void                       UnregisterConCommand(ConCommandBase *pCommandBase) = 0;
    virtual void                       UnregisterConCommands(CVarDLLIdentifier_t id) = 0;
    virtual const char*                GetCommandLineValue(const char *pVariableName) = 0;
    virtual ConCommandBase*            FindCommandBase(const char *name) = 0;
    virtual const ConCommandBase*      FindCommandBase(const char *name) const = 0;
    virtual ConVar*                    FindVar(const char *var_name) = 0; //16
    virtual const ConVar*              FindVar(const char *var_name) const = 0;
    virtual ConCommand*                FindCommand(const char *name) = 0;
    virtual const ConCommand*          FindCommand(const char *name) const = 0;
    virtual void                       InstallGlobalChangeCallback(FnChangeCallback_t callback) = 0;
    virtual void                       RemoveGlobalChangeCallback(FnChangeCallback_t callback) = 0;
    virtual void                       CallGlobalChangeCallbacks(ConVar *var, const char *pOldString, float flOldValue) = 0;
    virtual void                       InstallConsoleDisplayFunc(IConsoleDisplayFunc* pDisplayFunc) = 0;
    virtual void                       RemoveConsoleDisplayFunc(IConsoleDisplayFunc* pDisplayFunc) = 0;
    virtual void                       ConsoleColorPrintf(const uint8_t* clr, const char *pFormat, ...) const = 0;
    virtual void                       ConsolePrintf(const char *pFormat, ...) const = 0;
    virtual void                       ConsoleDPrintf(const char *pFormat, ...) const = 0;
    virtual void                       RevertFlaggedConVars(int nFlag) = 0;
};

```

`CSGOSimple/valve_sdk/interfaces/IEngineSound.hpp`:

```hpp
#pragma once

#include "../Math/Vector.hpp"
#include "../Misc/UtlVector.hpp"

struct SndInfo_t;
class IRecipientFilter;

enum soundlevel_t
{
    SNDLVL_NONE = 0,
    SNDLVL_20dB = 20,		// rustling leaves
    SNDLVL_25dB = 25,		// whispering
    SNDLVL_30dB = 30,		// library
    SNDLVL_35dB = 35,
    SNDLVL_40dB = 40,
    SNDLVL_45dB = 45,		// refrigerator
    SNDLVL_50dB = 50,	    // 3.9    // average home
    SNDLVL_55dB = 55,	    // 3.0
    SNDLVL_IDLE = 60,	    // 2.0	
    SNDLVL_60dB = 60,	    // 2.0	// normal conversation, clothes dryer
    SNDLVL_65dB = 65,	    // 1.5	// washing machine, dishwasher
    SNDLVL_STATIC = 66,	    // 1.25
    SNDLVL_70dB = 70,	    // 1.0	// car, vacuum cleaner, mixer, electric sewing machine
    SNDLVL_NORM = 75,
    SNDLVL_75dB = 75,	    // 0.8	// busy traffic
    SNDLVL_80dB = 80,	    // 0.7	// mini-bike, alarm clock, noisy restaurant, office tabulator, outboard motor, passing snowmobile
    SNDLVL_TALKING = 80,    // 0.7
    SNDLVL_85dB = 85,	    // 0.6	// average factory, electric shaver
    SNDLVL_90dB = 90,	    // 0.5	// screaming child, passing motorcycle, convertible ride on frw
    SNDLVL_95dB = 95,
    SNDLVL_100dB = 100,	    // 0.4	// subway train, diesel truck, woodworking shop, pneumatic drill, boiler shop, jackhammer
    SNDLVL_105dB = 105,     // helicopter, power mower
    SNDLVL_110dB = 110,     // snowmobile drvrs seat, inboard motorboat, sandblasting
    SNDLVL_120dB = 120,     // auto horn, propeller aircraft
    SNDLVL_130dB = 130,     // air raid siren
    SNDLVL_GUNFIRE = 140,	// 0.27	// THRESHOLD OF PAIN, gunshot, jet engine
    SNDLVL_140dB = 140,	    // 0.2
    SNDLVL_150dB = 150,	    // 0.2
    SNDLVL_180dB = 180,		// rocket launching

                            // NOTE: Valid soundlevel_t values are 0-255.
                            //       256-511 are reserved for sounds using goldsrc compatibility attenuation.
};

//-----------------------------------------------------------------------------
// common pitch values
//-----------------------------------------------------------------------------
#define	PITCH_NORM		100			  // non-pitch shifted
#define PITCH_LOW		95			    // other values are possible - 0-255, where 255 is very high
#define PITCH_HIGH		120

class IEngineSound
{
public:
	// Precache a particular sample
	virtual bool PrecacheSound(const char *pSample, bool bPreload = false, bool bIsUISound = false) = 0;
	virtual bool IsSoundPrecached(const char *pSample) = 0;
	virtual void PrefetchSound(const char *pSample) = 0;
	virtual bool IsLoopingSound(const char *pSample) = 0;

	// Just loads the file header and checks for duration (not hooked up for .mp3's yet)
	// Is accessible to server and client though
	virtual float GetSoundDuration(const char *pSample) = 0;

	// Pitch of 100 is no pitch shift.  Pitch > 100 up to 255 is a higher pitch, pitch < 100
	// down to 1 is a lower pitch.   150 to 70 is the realistic range.
	// EmitSound with pitch != 100 should be used sparingly, as it's not quite as
	// fast (the pitchshift mixer is not native coded).

	// NOTE: setting iEntIndex to -1 will cause the sound to be emitted from the local
	// player (client-side only)
	virtual int EmitSound(IRecipientFilter& filter, int iEntIndex, int iChannel, const char *pSoundEntry, unsigned int nSoundEntryHash, const char *pSample,
		float flVolume, float flAttenuation, int nSeed, int iFlags = 0, int iPitch = PITCH_NORM,
		const Vector *pOrigin = NULL, const Vector *pDirection = NULL, CUtlVector< Vector >* pUtlVecOrigins = NULL, bool bUpdatePositions = true, float soundtime = 0.0f, int speakerentity = -1) = 0;

	virtual int EmitSound(IRecipientFilter& filter, int iEntIndex, int iChannel, const char *pSoundEntry, unsigned int nSoundEntryHash, const char *pSample,
		float flVolume, soundlevel_t iSoundlevel, int nSeed, int iFlags = 0, int iPitch = PITCH_NORM,
		const Vector *pOrigin = NULL, const Vector *pDirection = NULL, CUtlVector< Vector >* pUtlVecOrigins = NULL, bool bUpdatePositions = true, float soundtime = 0.0f, int speakerentity = -1) = 0;

	virtual void EmitSentenceByIndex(IRecipientFilter& filter, int iEntIndex, int iChannel, int iSentenceIndex,
		float flVolume, soundlevel_t iSoundlevel, int nSeed, int iFlags = 0, int iPitch = PITCH_NORM,
		const Vector *pOrigin = NULL, const Vector *pDirection = NULL, CUtlVector< Vector >* pUtlVecOrigins = NULL, bool bUpdatePositions = true, float soundtime = 0.0f, int speakerentity = -1) = 0;

	virtual void    StopSound(int iEntIndex, int iChannel, const char *pSample, unsigned int nSoundEntryHash) = 0;
	virtual void    StopAllSounds(bool bClearBuffers) = 0;
	virtual void    SetRoomType(IRecipientFilter& filter, int roomType) = 0;
	virtual void    SetPlayerDSP(IRecipientFilter& filter, int dspType, bool fastReset) = 0;
	virtual int     EmitAmbientSound(const char *pSample, float flVolume, int iPitch = PITCH_NORM, int flags = 0, float soundtime = 0.0f) = 0;
	virtual float   GetDistGainFromSoundLevel(soundlevel_t soundlevel, float dist) = 0;
	virtual int		GetGuidForLastSoundEmitted() = 0;
	virtual bool	IsSoundStillPlaying(int guid) = 0;
	virtual void	StopSoundByGuid(int guid, bool bForceSync) = 0;
	virtual void	SetVolumeByGuid(int guid, float fvol) = 0;
	virtual void    unk() = 0;
	virtual void	GetActiveSounds(CUtlVector<SndInfo_t>& sndlist) = 0;
	virtual void	PrecacheSentenceGroup(const char *pGroupName) = 0;
	virtual void	NotifyBeginMoviePlayback() = 0;
	virtual void	NotifyEndMoviePlayback() = 0;
	virtual bool	GetSoundChannelVolume(const char* sound, float &flVolumeLeft, float &flVolumeRight) = 0;
	virtual float	GetElapsedTimeByGuid(int guid) = 0;
};

```

`CSGOSimple/valve_sdk/interfaces/IEngineTrace.hpp`:

```hpp
#pragma once

#include "../Math/Vector4D.hpp"

#pragma region MASKS

#define   DISPSURF_FLAG_SURFACE           (1<<0)
#define   DISPSURF_FLAG_WALKABLE          (1<<1)
#define   DISPSURF_FLAG_BUILDABLE         (1<<2)
#define   DISPSURF_FLAG_SURFPROP1         (1<<3)
#define   DISPSURF_FLAG_SURFPROP2         (1<<4)

#define   CONTENTS_EMPTY                0

#define   CONTENTS_SOLID                0x1       
#define   CONTENTS_WINDOW               0x2
#define   CONTENTS_AUX                  0x4
#define   CONTENTS_GRATE                0x8
#define   CONTENTS_SLIME                0x10
#define   CONTENTS_WATER                0x20
#define   CONTENTS_BLOCKLOS             0x40 
#define   CONTENTS_OPAQUE               0x80 
#define   LAST_VISIBLE_CONTENTS         CONTENTS_OPAQUE

#define   ALL_VISIBLE_CONTENTS            (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))

#define   CONTENTS_TESTFOGVOLUME        0x100
#define   CONTENTS_UNUSED               0x200     
#define   CONTENTS_BLOCKLIGHT           0x400
#define   CONTENTS_TEAM1                0x800 
#define   CONTENTS_TEAM2                0x1000 
#define   CONTENTS_IGNORE_NODRAW_OPAQUE 0x2000
#define   CONTENTS_MOVEABLE             0x4000
#define   CONTENTS_AREAPORTAL           0x8000
#define   CONTENTS_PLAYERCLIP           0x10000
#define   CONTENTS_MONSTERCLIP          0x20000
#define   CONTENTS_CURRENT_0            0x40000
#define   CONTENTS_CURRENT_90           0x80000
#define   CONTENTS_CURRENT_180          0x100000
#define   CONTENTS_CURRENT_270          0x200000
#define   CONTENTS_CURRENT_UP           0x400000
#define   CONTENTS_CURRENT_DOWN         0x800000

#define   CONTENTS_ORIGIN               0x1000000 

#define   CONTENTS_MONSTER              0x2000000 
#define   CONTENTS_DEBRIS               0x4000000
#define   CONTENTS_DETAIL               0x8000000 
#define   CONTENTS_TRANSLUCENT          0x10000000
#define   CONTENTS_LADDER               0x20000000
#define   CONTENTS_HITBOX               0x40000000

#define   SURF_LIGHT                    0x0001 
#define   SURF_SKY2D                    0x0002 
#define   SURF_SKY                      0x0004 
#define   SURF_WARP                     0x0008 
#define   SURF_TRANS                    0x0010
#define   SURF_NOPORTAL                 0x0020 
#define   SURF_TRIGGER                  0x0040 
#define   SURF_NODRAW                   0x0080 

#define   SURF_HINT                     0x0100 

#define   SURF_SKIP                     0x0200   
#define   SURF_NOLIGHT                  0x0400   
#define   SURF_BUMPLIGHT                0x0800   
#define   SURF_NOSHADOWS                0x1000   
#define   SURF_NODECALS                 0x2000   
#define   SURF_NOPAINT                  SURF_NODECALS
#define   SURF_NOCHOP                   0x4000   
#define   SURF_HITBOX                   0x8000   

// -----------------------------------------------------
// spatial content masks - used for spatial queries (traceline,etc.)
// -----------------------------------------------------
#define   MASK_ALL                      (0xFFFFFFFF)
#define   MASK_SOLID                    (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_PLAYERSOLID              (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_NPCSOLID                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_NPCFLUID                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define   MASK_WATER                    (CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
#define   MASK_OPAQUE                   (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
#define   MASK_OPAQUE_AND_NPCS          (MASK_OPAQUE|CONTENTS_MONSTER)
#define   MASK_BLOCKLOS                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
#define   MASK_BLOCKLOS_AND_NPCS        (MASK_BLOCKLOS|CONTENTS_MONSTER)
#define   MASK_VISIBLE                  (MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define   MASK_VISIBLE_AND_NPCS         (MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define   MASK_SHOT                     (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
#define   MASK_SHOT_BRUSHONLY           (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_DEBRIS)
#define   MASK_SHOT_HULL                (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
#define   MASK_SHOT_PORTAL              (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define   MASK_SOLID_BRUSHONLY          (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
#define   MASK_PLAYERSOLID_BRUSHONLY    (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
#define   MASK_NPCSOLID_BRUSHONLY       (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define   MASK_NPCWORLDSTATIC           (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define   MASK_NPCWORLDSTATIC_FLUID     (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP)
#define   MASK_SPLITAREAPORTAL          (CONTENTS_WATER|CONTENTS_SLIME)
#define   MASK_CURRENT                  (CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)
#define   MASK_DEADSOLID                (CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)
#pragma endregion

class IHandleEntity;
struct Ray_t;
class CGameTrace;
typedef CGameTrace trace_t;
class ICollideable;
class ITraceListData;
class CPhysCollide;
struct cplane_t;
struct virtualmeshlist_t;

enum class TraceType
{
    TRACE_EVERYTHING = 0,
    TRACE_WORLD_ONLY,
    TRACE_ENTITIES_ONLY,
    TRACE_EVERYTHING_FILTER_PROPS,
};

class ITraceFilter
{
public:
    virtual bool ShouldHitEntity(IHandleEntity *pEntity, int contentsMask) = 0;
    virtual TraceType GetTraceType() const = 0;
};


//-----------------------------------------------------------------------------
// Classes are expected to inherit these + implement the ShouldHitEntity method
//-----------------------------------------------------------------------------

// This is the one most normal traces will inherit from
class CTraceFilter : public ITraceFilter
{
public:
    bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
    {
        return !(pEntityHandle == pSkip);
    }
    virtual TraceType GetTraceType() const
    {
        return TraceType::TRACE_EVERYTHING;
    }
    void* pSkip;
};

class CTraceFilterSkipEntity : public ITraceFilter
{
public:
    CTraceFilterSkipEntity(IHandleEntity* pEntityHandle)
    {
        pSkip = pEntityHandle;
    }

    bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
    {
        return !(pEntityHandle == pSkip);
    }
    virtual TraceType GetTraceType() const
    {
        return TraceType::TRACE_EVERYTHING;
    }
    void* pSkip;
};

class CTraceFilterEntitiesOnly : public ITraceFilter
{
public:
    bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
    {
        return true;
    }
    virtual TraceType GetTraceType() const
    {
        return TraceType::TRACE_ENTITIES_ONLY;
    }
};


//-----------------------------------------------------------------------------
// Classes need not inherit from these
//-----------------------------------------------------------------------------
class CTraceFilterWorldOnly : public ITraceFilter
{
public:
    bool ShouldHitEntity(IHandleEntity* /*pServerEntity*/, int /*contentsMask*/)
    {
        return false;
    }
    virtual TraceType GetTraceType() const
    {
        return TraceType::TRACE_WORLD_ONLY;
    }
};

class CTraceFilterWorldAndPropsOnly : public ITraceFilter
{
public:
    bool ShouldHitEntity(IHandleEntity* /*pServerEntity*/, int /*contentsMask*/)
    {
        return false;
    }
    virtual TraceType GetTraceType() const
    {
        return TraceType::TRACE_EVERYTHING;
    }
};

class CTraceFilterPlayersOnlySkipOne : public ITraceFilter
{
public:
    CTraceFilterPlayersOnlySkipOne(IClientEntity* ent)
    {
        pEnt = ent;
    }
    bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
    {
        return pEntityHandle != pEnt && ((IClientEntity*)pEntityHandle)->GetClientClass()->m_ClassID == ClassId_CCSPlayer;
    }
    virtual TraceType GetTraceType() const
    {
        return TraceType::TRACE_ENTITIES_ONLY;
    }

private:
    IClientEntity* pEnt;
};

class CTraceFilterSkipTwoEntities : public ITraceFilter
{
public:
    CTraceFilterSkipTwoEntities(IClientEntity* ent1, IClientEntity* ent2)
    {
        pEnt1 = ent1;
        pEnt2 = ent2;
    }
    bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
    {
        return !(pEntityHandle == pEnt1 || pEntityHandle == pEnt2);
    }
    virtual TraceType GetTraceType() const
    {
        return TraceType::TRACE_EVERYTHING;
    }

private:
    IClientEntity* pEnt1;
    IClientEntity* pEnt2;
};

class CTraceFilterHitAll : public CTraceFilter
{
public:
    virtual bool ShouldHitEntity(IHandleEntity* /*pServerEntity*/, int /*contentsMask*/)
    {
        return true;
    }
};


enum class DebugTraceCounterBehavior_t
{
    kTRACE_COUNTER_SET = 0,
    kTRACE_COUNTER_INC,
};

//-----------------------------------------------------------------------------
// Enumeration interface for EnumerateLinkEntities
//-----------------------------------------------------------------------------
class IEntityEnumerator
{
public:
    // This gets called with each handle
    virtual bool EnumEntity(IHandleEntity *pHandleEntity) = 0;
};


struct BrushSideInfo_t
{
    Vector4D plane;               // The plane of the brush side
    unsigned short bevel;    // Bevel plane?
    unsigned short thin;     // Thin?
};

class CPhysCollide;

struct vcollide_t
{
    unsigned short solidCount : 15;
    unsigned short isPacked : 1;
    unsigned short descSize;
    // VPhysicsSolids
    CPhysCollide   **solids;
    char           *pKeyValues;
    void           *pUserData;
};

struct cmodel_t
{
    Vector         mins, maxs;
    Vector         origin;        // for sounds or lights
    int            headnode;
    vcollide_t     vcollisionData;
};

struct csurface_t
{
    const char     *name;
    short          surfaceProps;
    unsigned short flags;         // BUGBUG: These are declared per surface, not per material, but this database is per-material now
};

//-----------------------------------------------------------------------------
// A ray...
//-----------------------------------------------------------------------------
struct Ray_t
{
    VectorAligned  m_Start;  // starting point, centered within the extents
    VectorAligned  m_Delta;  // direction + length of the ray
    VectorAligned  m_StartOffset; // Add this to m_Start to Get the actual ray start
    VectorAligned  m_Extents;     // Describes an axis aligned box extruded along a ray
    const matrix3x4_t *m_pWorldAxisTransform;
    bool m_IsRay;  // are the extents zero?
    bool m_IsSwept;     // is delta != 0?

    Ray_t() : m_pWorldAxisTransform(NULL) {}

    void Init(Vector const& start, Vector const& end)
    {
        m_Delta = end - start;

        m_IsSwept = (m_Delta.LengthSqr() != 0);

        m_Extents.Init();

        m_pWorldAxisTransform = NULL;
        m_IsRay = true;

        // Offset m_Start to be in the center of the box...
        m_StartOffset.Init();
        m_Start = start;
    }

    void Init(Vector const& start, Vector const& end, Vector const& mins, Vector const& maxs)
    {
        m_Delta = end - start;

        m_pWorldAxisTransform = NULL;
        m_IsSwept = (m_Delta.LengthSqr() != 0);

        m_Extents = maxs - mins;
        m_Extents *= 0.5f;
        m_IsRay = (m_Extents.LengthSqr() < 1e-6);

        // Offset m_Start to be in the center of the box...
        m_StartOffset = maxs + mins;
        m_StartOffset *= 0.5f;
        m_Start = start + m_StartOffset;
        m_StartOffset *= -1.0f;
    }
    Vector InvDelta() const
    {
        Vector vecInvDelta;
        for(int iAxis = 0; iAxis < 3; ++iAxis) {
            if(m_Delta[iAxis] != 0.0f) {
                vecInvDelta[iAxis] = 1.0f / m_Delta[iAxis];
            } else {
                vecInvDelta[iAxis] = FLT_MAX;
            }
        }
        return vecInvDelta;
    }

private:
};

class CBaseTrace
{
public:
    bool IsDispSurface(void) { return ((dispFlags & DISPSURF_FLAG_SURFACE) != 0); }
    bool IsDispSurfaceWalkable(void) { return ((dispFlags & DISPSURF_FLAG_WALKABLE) != 0); }
    bool IsDispSurfaceBuildable(void) { return ((dispFlags & DISPSURF_FLAG_BUILDABLE) != 0); }
    bool IsDispSurfaceProp1(void) { return ((dispFlags & DISPSURF_FLAG_SURFPROP1) != 0); }
    bool IsDispSurfaceProp2(void) { return ((dispFlags & DISPSURF_FLAG_SURFPROP2) != 0); }

public:

    // these members are aligned!!
    Vector         startpos;            // start position
    Vector         endpos;              // final position
    cplane_t       plane;               // surface normal at impact

    float          fraction;            // time completed, 1.0 = didn't hit anything

    int            contents;            // contents on other side of surface hit
    unsigned short dispFlags;           // displacement flags for marking surfaces with data

    bool           allsolid;            // if true, plane is not valid
    bool           startsolid;          // if true, the initial point was in a solid area

    CBaseTrace() {}

};

class CGameTrace : public CBaseTrace
{
public:
    bool DidHitWorld() const;
    bool DidHitNonWorldEntity() const;
    int GetEntityIndex() const;
    bool DidHit() const;
    bool IsVisible() const;

public:

    float               fractionleftsolid;  // time we left a solid, only valid if we started in solid
    csurface_t          surface;            // surface hit (impact surface)
    int                 hitgroup;           // 0 == generic, non-zero is specific body part
    short               physicsbone;        // physics bone hit by trace in studio
    unsigned short      worldSurfaceIndex;  // Index of the msurface2_t, if applicable
    IClientEntity*      hit_entity;
    int                 hitbox;                       // box hit by trace in studio

    CGameTrace() {}

private:
    // No copy constructors allowed
    CGameTrace(const CGameTrace& other) :
        fractionleftsolid(other.fractionleftsolid),
        surface(other.surface),
        hitgroup(other.hitgroup),
        physicsbone(other.physicsbone),
        worldSurfaceIndex(other.worldSurfaceIndex),
        hit_entity(other.hit_entity),
        hitbox(other.hitbox)
    {
        startpos = other.startpos;
        endpos = other.endpos;
        plane = other.plane;
        fraction = other.fraction;
        contents = other.contents;
        dispFlags = other.dispFlags;
        allsolid = other.allsolid;
        startsolid = other.startsolid;
    }

    CGameTrace& CGameTrace::operator=(const CGameTrace& other)
    {
        startpos = other.startpos;
        endpos = other.endpos;
        plane = other.plane;
        fraction = other.fraction;
        contents = other.contents;
        dispFlags = other.dispFlags;
        allsolid = other.allsolid;
        startsolid = other.startsolid;
        fractionleftsolid = other.fractionleftsolid;
        surface = other.surface;
        hitgroup = other.hitgroup;
        physicsbone = other.physicsbone;
        worldSurfaceIndex = other.worldSurfaceIndex;
        hit_entity = other.hit_entity;
        hitbox = other.hitbox;
        return *this;
    }
};

inline bool CGameTrace::DidHit() const
{
    return fraction < 1 || allsolid || startsolid;
}

inline bool CGameTrace::IsVisible() const
{
    return fraction > 0.97f;
}

class IEngineTrace
{
public:
    virtual int   GetPointContents(const Vector &vecAbsPosition, int contentsMask = MASK_ALL, IHandleEntity** ppEntity = nullptr) = 0;
    virtual int   GetPointContents_WorldOnly(const Vector &vecAbsPosition, int contentsMask = MASK_ALL) = 0;
    virtual int   GetPointContents_Collideable(ICollideable *pCollide, const Vector &vecAbsPosition) = 0;
    virtual void  ClipRayToEntity(const Ray_t &ray, unsigned int fMask, IHandleEntity *pEnt, CGameTrace *pTrace) = 0;
    virtual void  ClipRayToCollideable(const Ray_t &ray, unsigned int fMask, ICollideable *pCollide, CGameTrace *pTrace) = 0;
    virtual void  TraceRay(const Ray_t &ray, unsigned int fMask, ITraceFilter *pTraceFilter, CGameTrace *pTrace) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IGameEventmanager.hpp`:

```hpp
#pragma once

#include <cstdint>

#define EVENT_DEBUG_ID_INIT 42 
#define EVENT_DEBUG_ID_SHUTDOWN 13  

class bf_write;
class bf_read;
class IGameEvent
{
public:
    virtual ~IGameEvent() = 0;
    virtual const char*     GetName() const = 0;

    virtual bool            IsReliable() const = 0;
    virtual bool            IsLocal() const = 0;
    virtual bool            IsEmpty(const char *keyName = nullptr) = 0;

    virtual bool            GetBool(const char *keyName = nullptr, bool defaultValue = false) = 0;
    virtual int             GetInt(const char *keyName = nullptr, int defaultValue = 0) = 0;
    virtual uint64_t        GetUint64(const char *keyName = nullptr, unsigned long defaultValue = 0) = 0;
    virtual float           GetFloat(const char *keyName = nullptr, float defaultValue = 0.0f) = 0;
    virtual const char*     GetString(const char *keyName = nullptr, const char *defaultValue = "") = 0;
    virtual const wchar_t*  GetWString(const char *keyName, const wchar_t *defaultValue = L"") = 0;

    virtual void            SetBool(const char *keyName, bool value) = 0;
    virtual void            SetInt(const char *keyName, int value) = 0;
    virtual void            SetUint64(const char *keyName, unsigned long value) = 0;
    virtual void            SetFloat(const char *keyName, float value) = 0;
    virtual void            SetString(const char *keyName, const char *value) = 0;
    virtual void            SetWString(const char *keyName, const wchar_t *value) = 0;
};

class IGameEventListener2
{
public:
    virtual ~IGameEventListener2(void) {}

    virtual void FireGameEvent(IGameEvent *event) = 0;
    virtual int  GetEventDebugID(void) = 0;

public:
    int m_iDebugId;
};

class IGameEventManager2
{
public:
    virtual             ~IGameEventManager2() = 0;
    virtual int         LoadEventsFromFile(const char *filename) = 0;
    virtual void        Reset() = 0;
    virtual bool        AddListener(IGameEventListener2 *listener, const char *name, bool bServerSide) = 0;
    virtual bool        FindListener(IGameEventListener2 *listener, const char *name) = 0;
    virtual int         RemoveListener(IGameEventListener2 *listener) = 0;
    virtual IGameEvent* CreateEvent(const char *name, bool bForce, unsigned int dwUnknown) = 0;
    virtual bool        FireEvent(IGameEvent *event, bool bDontBroadcast = false) = 0;
    virtual bool        FireEventClientSide(IGameEvent *event) = 0;
    virtual IGameEvent* DuplicateEvent(IGameEvent *event) = 0;
    virtual void        FreeEvent(IGameEvent *event) = 0;
    virtual bool        SerializeEvent(IGameEvent *event, bf_write *buf) = 0;
    virtual IGameEvent* UnserializeEvent(bf_read *buf) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IInputSystem.hpp`:

```hpp
#pragma once
#include "IAppSystem.hpp"

#define MAX_SPLITSCREEN_CLIENT_BITS 2
// this should == MAX_JOYSTICKS in InputEnums.h
#define MAX_SPLITSCREEN_CLIENTS	( 1 << MAX_SPLITSCREEN_CLIENT_BITS ) // 4

enum
{
	MAX_JOYSTICKS = MAX_SPLITSCREEN_CLIENTS,
	MOUSE_BUTTON_COUNT = 5,
};

enum JoystickAxis_t
{
	JOY_AXIS_X = 0,
	JOY_AXIS_Y,
	JOY_AXIS_Z,
	JOY_AXIS_R,
	JOY_AXIS_U,
	JOY_AXIS_V,
	MAX_JOYSTICK_AXES,
};

enum
{
	JOYSTICK_MAX_BUTTON_COUNT = 32,
	JOYSTICK_POV_BUTTON_COUNT = 4,
	JOYSTICK_AXIS_BUTTON_COUNT = MAX_JOYSTICK_AXES * 2,
};

#define JOYSTICK_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_BUTTON + ((_joystick) * JOYSTICK_MAX_BUTTON_COUNT) + (_button) )
#define JOYSTICK_POV_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_POV_BUTTON + ((_joystick) * JOYSTICK_POV_BUTTON_COUNT) + (_button) )
#define JOYSTICK_AXIS_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_AXIS_BUTTON + ((_joystick) * JOYSTICK_AXIS_BUTTON_COUNT) + (_button) )

#define JOYSTICK_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_BUTTON_INTERNAL( _joystick, _button ) )
#define JOYSTICK_POV_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_POV_BUTTON_INTERNAL( _joystick, _button ) )
#define JOYSTICK_AXIS_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_AXIS_BUTTON_INTERNAL( _joystick, _button ) )

enum ButtonCode_t
{
	BUTTON_CODE_INVALID = -1,
	BUTTON_CODE_NONE = 0,

	KEY_FIRST = 0,

	KEY_NONE = KEY_FIRST,
	KEY_0,
	KEY_1,
	KEY_2,
	KEY_3,
	KEY_4,
	KEY_5,
	KEY_6,
	KEY_7,
	KEY_8,
	KEY_9,
	KEY_A,
	KEY_B,
	KEY_C,
	KEY_D,
	KEY_E,
	KEY_F,
	KEY_G,
	KEY_H,
	KEY_I,
	KEY_J,
	KEY_K,
	KEY_L,
	KEY_M,
	KEY_N,
	KEY_O,
	KEY_P,
	KEY_Q,
	KEY_R,
	KEY_S,
	KEY_T,
	KEY_U,
	KEY_V,
	KEY_W,
	KEY_X,
	KEY_Y,
	KEY_Z,
	KEY_PAD_0,
	KEY_PAD_1,
	KEY_PAD_2,
	KEY_PAD_3,
	KEY_PAD_4,
	KEY_PAD_5,
	KEY_PAD_6,
	KEY_PAD_7,
	KEY_PAD_8,
	KEY_PAD_9,
	KEY_PAD_DIVIDE,
	KEY_PAD_MULTIPLY,
	KEY_PAD_MINUS,
	KEY_PAD_PLUS,
	KEY_PAD_ENTER,
	KEY_PAD_DECIMAL,
	KEY_LBRACKET,
	KEY_RBRACKET,
	KEY_SEMICOLON,
	KEY_APOSTROPHE,
	KEY_BACKQUOTE,
	KEY_COMMA,
	KEY_PERIOD,
	KEY_SLASH,
	KEY_BACKSLASH,
	KEY_MINUS,
	KEY_EQUAL,
	KEY_ENTER,
	KEY_SPACE,
	KEY_BACKSPACE,
	KEY_TAB,
	KEY_CAPSLOCK,
	KEY_NUMLOCK,
	KEY_ESCAPE,
	KEY_SCROLLLOCK,
	KEY_INSERT,
	KEY_DELETE,
	KEY_HOME,
	KEY_END,
	KEY_PAGEUP,
	KEY_PAGEDOWN,
	KEY_BREAK,
	KEY_LSHIFT,
	KEY_RSHIFT,
	KEY_LALT,
	KEY_RALT,
	KEY_LCONTROL,
	KEY_RCONTROL,
	KEY_LWIN,
	KEY_RWIN,
	KEY_APP,
	KEY_UP,
	KEY_LEFT,
	KEY_DOWN,
	KEY_RIGHT,
	KEY_F1,
	KEY_F2,
	KEY_F3,
	KEY_F4,
	KEY_F5,
	KEY_F6,
	KEY_F7,
	KEY_F8,
	KEY_F9,
	KEY_F10,
	KEY_F11,
	KEY_F12,
	KEY_CAPSLOCKTOGGLE,
	KEY_NUMLOCKTOGGLE,
	KEY_SCROLLLOCKTOGGLE,

	KEY_LAST = KEY_SCROLLLOCKTOGGLE,
	KEY_COUNT = KEY_LAST - KEY_FIRST + 1,

	// Mouse
	MOUSE_FIRST = KEY_LAST + 1,

	MOUSE_LEFT = MOUSE_FIRST,
	MOUSE_RIGHT,
	MOUSE_MIDDLE,
	MOUSE_4,
	MOUSE_5,
	MOUSE_WHEEL_UP,		// A fake button which is 'pressed' and 'released' when the wheel is moved up 
	MOUSE_WHEEL_DOWN,	// A fake button which is 'pressed' and 'released' when the wheel is moved down

	MOUSE_LAST = MOUSE_WHEEL_DOWN,
	MOUSE_COUNT = MOUSE_LAST - MOUSE_FIRST + 1,

	// Joystick
	JOYSTICK_FIRST = MOUSE_LAST + 1,

	JOYSTICK_FIRST_BUTTON = JOYSTICK_FIRST,
	JOYSTICK_LAST_BUTTON = JOYSTICK_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_MAX_BUTTON_COUNT - 1),
	JOYSTICK_FIRST_POV_BUTTON,
	JOYSTICK_LAST_POV_BUTTON = JOYSTICK_POV_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_POV_BUTTON_COUNT - 1),
	JOYSTICK_FIRST_AXIS_BUTTON,
	JOYSTICK_LAST_AXIS_BUTTON = JOYSTICK_AXIS_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_AXIS_BUTTON_COUNT - 1),

	JOYSTICK_LAST = JOYSTICK_LAST_AXIS_BUTTON,

	BUTTON_CODE_LAST,
	BUTTON_CODE_COUNT = BUTTON_CODE_LAST - KEY_FIRST + 1,

	// Helpers for XBox 360
	KEY_XBUTTON_UP = JOYSTICK_FIRST_POV_BUTTON,	// POV buttons
	KEY_XBUTTON_RIGHT,
	KEY_XBUTTON_DOWN,
	KEY_XBUTTON_LEFT,

	KEY_XBUTTON_A = JOYSTICK_FIRST_BUTTON,		// Buttons
	KEY_XBUTTON_B,
	KEY_XBUTTON_X,
	KEY_XBUTTON_Y,
	KEY_XBUTTON_LEFT_SHOULDER,
	KEY_XBUTTON_RIGHT_SHOULDER,
	KEY_XBUTTON_BACK,
	KEY_XBUTTON_START,
	KEY_XBUTTON_STICK1,
	KEY_XBUTTON_STICK2,
	KEY_XBUTTON_INACTIVE_START,

	KEY_XSTICK1_RIGHT = JOYSTICK_FIRST_AXIS_BUTTON,	// XAXIS POSITIVE
	KEY_XSTICK1_LEFT,							// XAXIS NEGATIVE
	KEY_XSTICK1_DOWN,							// YAXIS POSITIVE
	KEY_XSTICK1_UP,								// YAXIS NEGATIVE
	KEY_XBUTTON_LTRIGGER,						// ZAXIS POSITIVE
	KEY_XBUTTON_RTRIGGER,						// ZAXIS NEGATIVE
	KEY_XSTICK2_RIGHT,							// UAXIS POSITIVE
	KEY_XSTICK2_LEFT,							// UAXIS NEGATIVE
	KEY_XSTICK2_DOWN,							// VAXIS POSITIVE
	KEY_XSTICK2_UP,								// VAXIS NEGATIVE
};

class IInputSystem : IAppSystem
{
public:
	void EnableInput(bool bEnable)
	{
		typedef void(__thiscall* OriginalFn)(void*, bool);
		return CallVFunction< OriginalFn >(this, 11)(this, bEnable);
	}

	void ResetInputState()
	{
		typedef void(__thiscall* OriginalFn)(void*);
		return CallVFunction< OriginalFn >(this, 39)(this);
	}

	bool IsButtonDown(ButtonCode_t code)
	{
		typedef bool(__thiscall* OriginalFn)(void*, ButtonCode_t);
		return CallVFunction< OriginalFn >(this, 15)(this, code);
	}

	void GetCursorPosition(int* m_pX, int* m_pY)
	{
		typedef void(__thiscall* OriginalFn)(void*, int*, int*);
		return CallVFunction< OriginalFn >(this, 56)(this, m_pX, m_pY);
	}

	ButtonCode_t VirtualKeyToButtonCode(int nVirtualKey)
	{
		typedef ButtonCode_t(__thiscall* OriginalFn)(void*, int);
		return CallVFunction< OriginalFn >(this, 45)(this, nVirtualKey);
	}

	int ButtonCodeToVirtualKey(ButtonCode_t code)
	{
		typedef int(__thiscall* OriginalFn)(void*, ButtonCode_t);
		return CallVFunction< OriginalFn >(this, 46)(this, code);
	}
};

```

`CSGOSimple/valve_sdk/interfaces/IMDLCache.hpp`:

```hpp
#pragma once

#include "IAppSystem.hpp"
#include "../Misc/Studio.hpp"

class studiohdr_t;
struct studiohwdata_t;
struct vcollide_t;
struct virtualmodel_t;
struct vertexFileHeader_t;

enum MDLCacheDataType_t
{
    // Callbacks to Get called when data is loaded or unloaded for these:
    MDLCACHE_STUDIOHDR = 0,
    MDLCACHE_STUDIOHWDATA,
    MDLCACHE_VCOLLIDE,

    // Callbacks NOT called when data is loaded or unloaded for these:
    MDLCACHE_ANIMBLOCK,
    MDLCACHE_VIRTUALMODEL,
    MDLCACHE_VERTEXES,
    MDLCACHE_DECODEDANIMBLOCK
};

enum MDLCacheFlush_t
{
    MDLCACHE_FLUSH_STUDIOHDR = 0x01,
    MDLCACHE_FLUSH_STUDIOHWDATA = 0x02,
    MDLCACHE_FLUSH_VCOLLIDE = 0x04,
    MDLCACHE_FLUSH_ANIMBLOCK = 0x08,
    MDLCACHE_FLUSH_VIRTUALMODEL = 0x10,
    MDLCACHE_FLUSH_AUTOPLAY = 0x20,
    MDLCACHE_FLUSH_VERTEXES = 0x40,

    MDLCACHE_FLUSH_IGNORELOCK = 0x80000000,
    MDLCACHE_FLUSH_ALL = 0xFFFFFFFF
};

class IMDLCacheNotify
{
public:
    virtual void OnDataLoaded(MDLCacheDataType_t type, MDLHandle_t handle) = 0;
    virtual void OnDataUnloaded(MDLCacheDataType_t type, MDLHandle_t handle) = 0;
};

class IMDLCache : public IAppSystem
{
public:
    virtual void                SetCacheNotify(IMDLCacheNotify *pNotify) = 0;
    virtual MDLHandle_t         FindMDL(const char *pMDLRelativePath) = 0;
    virtual int                 AddRef(MDLHandle_t handle) = 0;
    virtual int                 Release(MDLHandle_t handle) = 0;
    virtual int                 GetRef(MDLHandle_t handle) = 0;
    virtual studiohdr_t*        GetStudioHdr(MDLHandle_t handle) = 0;
    virtual studiohwdata_t*     GetHardwareData(MDLHandle_t handle) = 0;
    virtual vcollide_t*         GetVCollide(MDLHandle_t handle) = 0;
    virtual unsigned char*      GetAnimBlock(MDLHandle_t handle, int nBlock) = 0;
    virtual virtualmodel_t*     GetVirtualModel(MDLHandle_t handle) = 0;
    virtual int                 GetAutoplayList(MDLHandle_t handle, unsigned short **pOut) = 0;
    virtual vertexFileHeader_t* GetVertexData(MDLHandle_t handle) = 0;
    virtual void                TouchAllData(MDLHandle_t handle) = 0;
    virtual void                SetUserData(MDLHandle_t handle, void* pData) = 0;
    virtual void*               GetUserData(MDLHandle_t handle) = 0;
    virtual bool                IsErrorModel(MDLHandle_t handle) = 0;
    virtual void                Flush(MDLCacheFlush_t nFlushFlags = MDLCACHE_FLUSH_ALL) = 0;
    virtual void                Flush(MDLHandle_t handle, int nFlushFlags = MDLCACHE_FLUSH_ALL) = 0;
    virtual const char*         GetModelName(MDLHandle_t handle) = 0;
    virtual virtualmodel_t*     GetVirtualModelFast(const studiohdr_t *pStudioHdr, MDLHandle_t handle) = 0;
    virtual void                BeginLock() = 0;
    virtual void                EndLock() = 0;
    virtual int*                GetFrameUnlockCounterPtrOLD() = 0;
    virtual void                FinishPendingLoads() = 0;
    virtual vcollide_t*         GetVCollideEx(MDLHandle_t handle, bool synchronousLoad = true) = 0;
    virtual bool                GetVCollideSize(MDLHandle_t handle, int *pVCollideSize) = 0;
    virtual bool                GetAsyncLoad(MDLCacheDataType_t type) = 0;
    virtual bool                SetAsyncLoad(MDLCacheDataType_t type, bool bAsync) = 0;
    virtual void                BeginMapLoad() = 0;
    virtual void                EndMapLoad() = 0;
    virtual void                MarkAsLoaded(MDLHandle_t handle) = 0;
    virtual void                InitPreloadData(bool rebuild) = 0;
    virtual void                ShutdownPreloadData() = 0;
    virtual bool                IsDataLoaded(MDLHandle_t handle, MDLCacheDataType_t type) = 0;
    virtual int*                GetFrameUnlockCounterPtr(MDLCacheDataType_t type) = 0;
    virtual studiohdr_t*        LockStudioHdr(MDLHandle_t handle) = 0;
    virtual void                UnlockStudioHdr(MDLHandle_t handle) = 0;
    virtual bool                PreloadModel(MDLHandle_t handle) = 0;
    virtual void                ResetErrorModelStatus(MDLHandle_t handle) = 0;
    virtual void                MarkFrame() = 0;
    virtual void                BeginCoarseLock() = 0;
    virtual void                EndCoarseLock() = 0;
    virtual void                ReloadVCollide(MDLHandle_t handle) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IMaterialSystem.hpp`:

```hpp
#pragma once

#include "IAppSystem.hpp"

#define DECLARE_POINTER_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#define MAXSTUDIOSKINS		32

// These are given to FindMaterial to reference the texture groups that Show up on the 
#define TEXTURE_GROUP_LIGHTMAP						        "Lightmaps"
#define TEXTURE_GROUP_WORLD							          "World textures"
#define TEXTURE_GROUP_MODEL							          "Model textures"
#define TEXTURE_GROUP_VGUI							          "VGUI textures"
#define TEXTURE_GROUP_PARTICLE						        "Particle textures"
#define TEXTURE_GROUP_DECAL							          "Decal textures"
#define TEXTURE_GROUP_SKYBOX						          "SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS				      "ClientEffect textures"
#define TEXTURE_GROUP_OTHER							          "Other textures"
#define TEXTURE_GROUP_PRECACHED						        "Precached"
#define TEXTURE_GROUP_CUBE_MAP						        "CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET					      "RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED					        "Unaccounted textures"
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		  "Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER			    "Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER			  "Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER			  "Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER					      "DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL					        "ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS					      "Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS				      "Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE			  "RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS					      "Morph Targets"

//-----------------------------------------------------------------------------
// forward declarations
//-----------------------------------------------------------------------------
class IMaterial;
class IMesh;
class IVertexBuffer;
class IIndexBuffer;
struct MaterialSystem_Config_t;
class VMatrix;
class matrix3x4_t;
class ITexture;
struct MaterialSystemHWID_t;
class KeyValues;
class IShader;
class IVertexTexture;
class IMorph;
class IMatRenderContext;
class ICallQueue;
struct MorphWeight_t;
class IFileList;
struct VertexStreamSpec_t;
struct ShaderStencilState_t;
struct MeshInstanceData_t;
class IClientMaterialSystem;
class CPaintMaterial;
class IPaintMapDataManager;
class IPaintMapTextureManager;
class GPUMemoryStats;
struct AspectRatioInfo_t;
struct CascadedShadowMappingState_t;

class IMaterialProxyFactory;
class ITexture;
class IMaterialSystemHardwareConfig;
class CShadowMgr;

enum CompiledVtfFlags
{
    TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
    TEXTUREFLAGS_TRILINEAR = 0x00000002,
    TEXTUREFLAGS_CLAMPS = 0x00000004,
    TEXTUREFLAGS_CLAMPT = 0x00000008,
    TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
    TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
    TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
    TEXTUREFLAGS_NORMAL = 0x00000080,
    TEXTUREFLAGS_NOMIP = 0x00000100,
    TEXTUREFLAGS_NOLOD = 0x00000200,
    TEXTUREFLAGS_ALL_MIPS = 0x00000400,
    TEXTUREFLAGS_PROCEDURAL = 0x00000800,
    TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
    TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,
    TEXTUREFLAGS_ENVMAP = 0x00004000,
    TEXTUREFLAGS_RENDERTARGET = 0x00008000,
    TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
    TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
    TEXTUREFLAGS_SINGLECOPY = 0x00040000,
    TEXTUREFLAGS_PRE_SRGB = 0x00080000,
    TEXTUREFLAGS_UNUSED_00100000 = 0x00100000,
    TEXTUREFLAGS_UNUSED_00200000 = 0x00200000,
    TEXTUREFLAGS_UNUSED_00400000 = 0x00400000,
    TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,
    TEXTUREFLAGS_UNUSED_01000000 = 0x01000000,
    TEXTUREFLAGS_CLAMPU = 0x02000000,
    TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,
    TEXTUREFLAGS_SSBUMP = 0x08000000,
    TEXTUREFLAGS_UNUSED_10000000 = 0x10000000,
    TEXTUREFLAGS_BORDER = 0x20000000,
    TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
    TEXTUREFLAGS_UNUSED_80000000 = 0x80000000
};

enum StandardLightmap_t
{
    MATERIAL_SYSTEM_LIGHTMAP_PAGE_WHITE = -1,
    MATERIAL_SYSTEM_LIGHTMAP_PAGE_WHITE_BUMP = -2,
    MATERIAL_SYSTEM_LIGHTMAP_PAGE_USER_DEFINED = -3
};


struct MaterialSystem_SortInfo_t
{
    IMaterial	*material;
    int			lightmapPageID;
};

enum MaterialThreadMode_t
{
    MATERIAL_SINGLE_THREADED,
    MATERIAL_QUEUED_SINGLE_THREADED,
    MATERIAL_QUEUED_THREADED
};

enum MaterialContextType_t
{
    MATERIAL_HARDWARE_CONTEXT,
    MATERIAL_QUEUED_CONTEXT,
    MATERIAL_NULL_CONTEXT
};

enum
{
    MATERIAL_ADAPTER_NAME_LENGTH = 512
};

struct MaterialTextureInfo_t
{
    int iExcludeInformation;
};

struct ApplicationPerformanceCountersInfo_t
{
    float msMain;
    float msMST;
    float msGPU;
    float msFlip;
    float msTotal;
};

struct ApplicationInstantCountersInfo_t
{
    uint32_t m_nCpuActivityMask;
    uint32_t m_nDeferredWordsAllocated;
};
struct MaterialAdapterInfo_t
{
    char m_pDriverName[MATERIAL_ADAPTER_NAME_LENGTH];
    unsigned int m_VendorID;
    unsigned int m_DeviceID;
    unsigned int m_SubSysID;
    unsigned int m_Revision;
    int m_nDXSupportLevel;			// This is the *preferred* dx support level
    int m_nMinDXSupportLevel;
    int m_nMaxDXSupportLevel;
    unsigned int m_nDriverVersionHigh;
    unsigned int m_nDriverVersionLow;
};

struct MaterialVideoMode_t
{
    int m_Width;			// if width and height are 0 and you select 
    int m_Height;			// windowed mode, it'll use the window size
    ImageFormat m_Format;	// use ImageFormats (ignored for windowed mode)
    int m_RefreshRate;		// 0 == default (ignored for windowed mode)
};
enum HDRType_t
{
    HDR_TYPE_NONE,
    HDR_TYPE_INTEGER,
    HDR_TYPE_FLOAT,
};

enum RestoreChangeFlags_t
{
    MATERIAL_RESTORE_VERTEX_FORMAT_CHANGED = 0x1,
    MATERIAL_RESTORE_RELEASE_MANAGED_RESOURCES = 0x2,
};

enum RenderTargetSizeMode_t
{
    RT_SIZE_NO_CHANGE = 0,
    RT_SIZE_DEFAULT = 1,
    RT_SIZE_PICMIP = 2,
    RT_SIZE_HDR = 3,
    RT_SIZE_FULL_FRAME_BUFFER = 4,
    RT_SIZE_OFFSCREEN = 5,
    RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6
};

enum MaterialRenderTargetDepth_t
{
    MATERIAL_RT_DEPTH_SHARED = 0x0,
    MATERIAL_RT_DEPTH_SEPARATE = 0x1,
    MATERIAL_RT_DEPTH_NONE = 0x2,
    MATERIAL_RT_DEPTH_ONLY = 0x3,
};

typedef void(*MaterialBufferReleaseFunc_t)(int nChangeFlags);	// see RestoreChangeFlags_t
typedef void(*MaterialBufferRestoreFunc_t)(int nChangeFlags);	// see RestoreChangeFlags_t
typedef void(*ModeChangeCallbackFunc_t)(void);
typedef void(*EndFrameCleanupFunc_t)(void);
typedef bool(*EndFramePriorToNextContextFunc_t)(void);
typedef void(*OnLevelShutdownFunc_t)(void *pUserData);

typedef unsigned short MaterialHandle_t;
DECLARE_POINTER_HANDLE(MaterialLock_t);

class IMaterialSystem : public IAppSystem
{
public:

    virtual CreateInterfaceFn               Init(char const* pShaderAPIDLL, IMaterialProxyFactory *pMaterialProxyFactory, CreateInterfaceFn fileSystemFactory, CreateInterfaceFn cvarFactory = NULL) = 0;
    virtual void                            SetShaderAPI(char const *pShaderAPIDLL) = 0;
    virtual void                            SetAdapter(int nAdapter, int nFlags) = 0;
    virtual void                            ModInit() = 0;
    virtual void                            ModShutdown() = 0;
    virtual void                            SetThreadMode(MaterialThreadMode_t mode, int nServiceThread = -1) = 0;
    virtual MaterialThreadMode_t            GetThreadMode() = 0;
    virtual void                            ExecuteQueued() = 0;
    virtual void                            OnDebugEvent(const char *pEvent) = 0;
    virtual IMaterialSystemHardwareConfig*  GetHardwareConfig(const char *pVersion, int *returnCode) = 0;
    virtual void                            __unknown() = 0;
    virtual bool                            UpdateConfig(bool bForceUpdate) = 0; //20
    virtual bool                            OverrideConfig(const MaterialSystem_Config_t &config, bool bForceUpdate) = 0;
    virtual const MaterialSystem_Config_t&  GetCurrentConfigForVideoCard() const = 0;
    virtual bool                            GetRecommendedConfigurationInfo(int nDXLevel, KeyValues * pKeyValues) = 0;
    virtual int                             GetDisplayAdapterCount() const = 0;
    virtual int                             GetCurrentAdapter() const = 0;
    virtual void                            GetDisplayAdapterInfo(int adapter, MaterialAdapterInfo_t& info) const = 0;
    virtual int                             GetModeCount(int adapter) const = 0;
    virtual void                            GetModeInfo(int adapter, int mode, MaterialVideoMode_t& info) const = 0;
    virtual void                            AddModeChangeCallBack(ModeChangeCallbackFunc_t func) = 0;
    virtual void                            GetDisplayMode(MaterialVideoMode_t& mode) const = 0; //30
    virtual bool                            SetMode(void* hwnd, const MaterialSystem_Config_t &config) = 0;
    virtual bool                            SupportsMSAAMode(int nMSAAMode) = 0;
    virtual const MaterialSystemHWID_t&     GetVideoCardIdentifier(void) const = 0;
    virtual void                            SpewDriverInfo() const = 0;
    virtual void                            GetBackBufferDimensions(int &width, int &height) const = 0;
    virtual ImageFormat                     GetBackBufferFormat() const = 0;
    virtual const AspectRatioInfo_t&        GetAspectRatioInfo() const = 0;
    virtual bool                            SupportsHDRMode(HDRType_t nHDRModede) = 0;
    virtual bool                            AddView(void* hwnd) = 0;
    virtual void                            RemoveView(void* hwnd) = 0; //40
    virtual void                            SetView(void* hwnd) = 0;
    virtual void                            BeginFrame(float frameTime) = 0;
    virtual void                            EndFrame() = 0;
    virtual void                            Flush(bool flushHardware = false) = 0;
    virtual unsigned int                    GetCurrentFrameCount() = 0;
    virtual void                            SwapBuffers() = 0;
    virtual void                            EvictManagedResources() = 0;
    virtual void                            ReleaseResources(void) = 0;
    virtual void                            ReacquireResources(void) = 0;
    virtual void                            AddReleaseFunc(MaterialBufferReleaseFunc_t func) = 0; //50
    virtual void                            RemoveReleaseFunc(MaterialBufferReleaseFunc_t func) = 0;
    virtual void                            AddRestoreFunc(MaterialBufferRestoreFunc_t func) = 0;
    virtual void                            RemoveRestoreFunc(MaterialBufferRestoreFunc_t func) = 0;
    virtual void                            AddEndFrameCleanupFunc(EndFrameCleanupFunc_t func) = 0;
    virtual void                            RemoveEndFrameCleanupFunc(EndFrameCleanupFunc_t func) = 0;
    virtual void                            OnLevelShutdown() = 0;
    virtual bool                            AddOnLevelShutdownFunc(OnLevelShutdownFunc_t func, void *pUserData) = 0;
    virtual bool                            RemoveOnLevelShutdownFunc(OnLevelShutdownFunc_t func, void *pUserData) = 0;
    virtual void                            OnLevelLoadingComplete() = 0;
    virtual void                            ResetTempHWMemory(bool bExitingLevel = false) = 0; //60
    virtual void                            HandleDeviceLost() = 0;
    virtual int                             ShaderCount() const = 0;
    virtual int                             GetShaders(int nFirstShader, int nMaxCount, IShader **ppShaderList) const = 0;
    virtual int                             ShaderFlagCount() const = 0;
    virtual const char*                     ShaderFlagName(int nIndex) const = 0;
    virtual void                            GetShaderFallback(const char *pShaderName, char *pFallbackShader, int nFallbackLength) = 0;
    virtual IMaterialProxyFactory*          GetMaterialProxyFactory() = 0;
    virtual void                            SetMaterialProxyFactory(IMaterialProxyFactory* pFactory) = 0;
    virtual void                            EnableEditorMaterials() = 0;
    virtual void                            EnableGBuffers() = 0; //70
    virtual void                            SetInStubMode(bool bInStubMode) = 0;
    virtual void                            DebugPrintUsedMaterials(const char *pSearchSubString, bool bVerbose) = 0;
    virtual void                            DebugPrintUsedTextures(void) = 0;
    virtual void                            ToggleSuppressMaterial(char const* pMaterialName) = 0;
    virtual void                            ToggleDebugMaterial(char const* pMaterialName) = 0;
    virtual bool                            UsingFastClipping(void) = 0;
    virtual int                             StencilBufferBits(void) = 0; //number of bits per pixel in the stencil buffer
    virtual void                            UncacheAllMaterials() = 0;
    virtual void                            UncacheUnusedMaterials(bool bRecomputeStateSnapshots = false) = 0;
    virtual void                            CacheUsedMaterials() = 0; //80
    virtual void                            ReloadTextures() = 0;
    virtual void                            ReloadMaterials(const char *pSubString = NULL) = 0;
    virtual IMaterial*                      CreateMaterial(const char *pMaterialName, KeyValues *pVMTKeyValues) = 0;
    virtual IMaterial*                      FindMaterial(char const* pMaterialName, const char *pTextureGroupName = nullptr, bool complain = true, const char *pComplainPrefix = NULL) = 0;
   	virtual void							unk0() = 0;
    virtual MaterialHandle_t                FirstMaterial() const = 0;
    virtual MaterialHandle_t                NextMaterial(MaterialHandle_t h) const = 0;
    virtual MaterialHandle_t                InvalidMaterial() const = 0;
    virtual IMaterial*                      GetMaterial(MaterialHandle_t h) const = 0;
    virtual int                             GetNumMaterials() const = 0;
    virtual ITexture*                       FindTexture(char const* pTextureName, const char *pTextureGroupName, bool complain = true) = 0;
    virtual bool                            IsTextureLoaded(char const* pTextureName) const = 0;
    virtual ITexture*                       CreateProceduralTexture(const char	*pTextureName, const char *pTextureGroupName, int w, int h, ImageFormat fmt, int nFlags) = 0;
    virtual void                            BeginRenderTargetAllocation() = 0;
    virtual void                            EndRenderTargetAllocation() = 0; // Simulate an Alt-Tab in here, which causes a release/restore of all resources
    virtual ITexture*                       CreateRenderTargetTexture(int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat	format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED) = 0;
    virtual ITexture*                       CreateNamedRenderTargetTextureEx(const char *pRTName, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED, unsigned int textureFlags = TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT, unsigned int renderTargetFlags = 0) = 0;
    virtual ITexture*                       CreateNamedRenderTargetTexture(const char *pRTName, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED, bool bClampTexCoords = true, bool bAutoMipMap = false) = 0;
    virtual ITexture*                       CreateNamedRenderTargetTextureEx2(const char *pRTName, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED, unsigned int textureFlags = TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT, unsigned int renderTargetFlags = 0) = 0;

};

```

`CSGOSimple/valve_sdk/interfaces/IMoveHelper.hpp`:

```hpp
#pragma once

class IClientEntity;

class IMoveHelper
{
public:
    virtual	void _vpad() = 0;
    virtual void SetHost(IClientEntity* host) = 0;
};

```

`CSGOSimple/valve_sdk/interfaces/IPanel.hpp`:

```hpp
#pragma once

class IPanel
{
public:
    const char *GetName(unsigned int vguiPanel)
    {
        typedef const char *(__thiscall* tGetName)(void*, unsigned int);
        return CallVFunction<tGetName>(this, 36)(this, vguiPanel);
    }
#ifdef GetClassName
#undef GetClassName
#endif
    const char *GetClassName(unsigned int vguiPanel)
    {
        typedef const char *(__thiscall* tGetClassName)(void*, unsigned int);
        return CallVFunction<tGetClassName>(this, 37)(this, vguiPanel);
    }
};

```

`CSGOSimple/valve_sdk/interfaces/IPhysics.hpp`:

```hpp

#pragma once

struct surfacephysicsparams_t
{
	float friction;
	float elasticity;
	float density;
	float thickness;
	float dampening;
};

struct surfaceaudioparams_t
{
	float reflectivity; // like elasticity, but how much sound should be reflected by this surface
	float hardnessFactor; // like elasticity, but only affects impact sound choices
	float roughnessFactor; // like friction, but only affects scrape sound choices
	float roughThreshold; // surface roughness > this causes "rough" scrapes, < this causes "smooth" scrapes
	float hardThreshold; // surface hardness > this causes "hard" impacts, < this causes "soft" impacts
	float hardVelocityThreshold; // collision velocity > this causes "hard" impacts, < this causes "soft" impacts
	float highPitchOcclusion; //a value betweeen 0 and 100 where 0 is not occluded at all and 100 is silent (except for any additional reflected sound)
	float midPitchOcclusion;
	float lowPitchOcclusion;
};

struct surfacesoundnames_t
{
	unsigned short walkStepLeft;
	unsigned short walkStepRight;
	unsigned short	runStepLeft;
	unsigned short	runStepRight;
	unsigned short impactSoft;
	unsigned short impactHard;
	unsigned short scrapeSmooth;
	unsigned short scrapeRough;
	unsigned short bulletImpact;
	unsigned short rolling;
	unsigned short breakSound;
	unsigned short strainSound;
};

struct surfacegameprops_t
{
public:
	float maxSpeedFactor;
	float jumpFactor;
	float flPenetrationModifier;
	float flDamageModifier;
	unsigned short material;
	byte climbable;
};

struct surfacedata_t
{
	surfacephysicsparams_t physics;
	surfaceaudioparams_t audio;
	surfacesoundnames_t sounds;
	surfacegameprops_t game;
};

class IPhysicsSurfaceProps
{
public:
	virtual ~IPhysicsSurfaceProps(void) {}
	virtual int ParseSurfaceData(const char *pFilename, const char *pTextfile) = 0;
	virtual int SurfacePropCount(void) const = 0;
	virtual int GetSurfaceIndex(const char *pSurfacePropName) const = 0;
	virtual void GetPhysicsProperties(int surfaceDataIndex, float *density, float thickness, float friction, float elasticity) const = 0;
	virtual surfacedata_t* GetSurfaceData(int surfaceDataIndex) = 0;
	virtual const char GetString(unsigned short stringTableIndex) const = 0;
	virtual const char GetPropName(int surfaceDataIndex) const = 0;
	virtual void SetWorldMaterialIndexTable(int *pMapArray, int mapSize) = 0;
	virtual void GetPhysicsParameters(int surfaceDataIndex, surfacephysicsparams_t *pParamsOut) const = 0;
};

```

`CSGOSimple/valve_sdk/interfaces/IPrediction.hpp`:

```hpp
#pragma once

#include "../Math/QAngle.hpp"
#include "../Misc/CUserCmd.hpp"
#include "IMoveHelper.hpp"

class CMoveData
{
public:
    bool    m_bFirstRunOfFunctions : 1;
    bool    m_bGameCodeMovedPlayer : 1;
    int     m_nPlayerHandle;        // edict index on server, client entity handle on client=
    int     m_nImpulseCommand;      // Impulse command issued.
    Vector  m_vecViewAngles;        // Command view angles (local space)
    Vector  m_vecAbsViewAngles;     // Command view angles (world space)
    int     m_nButtons;             // Attack buttons.
    int     m_nOldButtons;          // From host_client->oldbuttons;
    float   m_flForwardMove;
    float   m_flSideMove;
    float   m_flUpMove;
    float   m_flMaxSpeed;
    float   m_flClientMaxSpeed;
    Vector  m_vecVelocity;          // edict::velocity        // Current movement direction.
    Vector  m_vecAngles;            // edict::angles
    Vector  m_vecOldAngles;
    float   m_outStepHeight;        // how much you climbed this move
    Vector  m_outWishVel;           // This is where you tried 
    Vector  m_outJumpVel;           // This is your jump velocity
    Vector  m_vecConstraintCenter;
    float   m_flConstraintRadius;
    float   m_flConstraintWidth;
    float   m_flConstraintSpeedFactor;
    float   m_flUnknown[5];
    Vector  m_vecAbsOrigin;
};

class C_BasePlayer;

class IGameMovement
{
public:
    virtual			~IGameMovement(void) {}

    virtual void	          ProcessMovement(C_BasePlayer *pPlayer, CMoveData *pMove) = 0;
    virtual void	          Reset(void) = 0;
    virtual void	          StartTrackPredictionErrors(C_BasePlayer *pPlayer) = 0;
    virtual void	          FinishTrackPredictionErrors(C_BasePlayer *pPlayer) = 0;
    virtual void	          DiffPrint(char const *fmt, ...) = 0;
    virtual Vector const&	  GetPlayerMins(bool ducked) const = 0;
    virtual Vector const&	  GetPlayerMaxs(bool ducked) const = 0;
    virtual Vector const&   GetPlayerViewOffset(bool ducked) const = 0;
    virtual bool		        IsMovingPlayerStuck(void) const = 0;
    virtual C_BasePlayer*   GetMovingPlayer(void) const = 0;
    virtual void		        UnblockPusher(C_BasePlayer *pPlayer, C_BasePlayer *pPusher) = 0;
    virtual void            SetupMovementBounds(CMoveData *pMove) = 0;
};

class CGameMovement
    : public IGameMovement
{
public:
    virtual ~CGameMovement(void) {}
};

class IPrediction
{
public:
    bool InPrediction()
    {
        typedef bool(__thiscall* oInPrediction)(void*);
        return CallVFunction<oInPrediction>(this, 14)(this);
    }

    void RunCommand(C_BasePlayer *player, CUserCmd *ucmd, IMoveHelper *moveHelper)
    {
        typedef void(__thiscall* oRunCommand)(void*, C_BasePlayer*, CUserCmd*, IMoveHelper*);
        return CallVFunction<oRunCommand>(this, 19)(this, player, ucmd, moveHelper);
    }

    void SetupMove(C_BasePlayer *player, CUserCmd *ucmd, IMoveHelper *moveHelper, void* pMoveData)
    {
        typedef void(__thiscall* oSetupMove)(void*, C_BasePlayer*, CUserCmd*, IMoveHelper*, void*);
        return CallVFunction<oSetupMove>(this, 20)(this, player, ucmd, moveHelper, pMoveData);
    }

    void FinishMove(C_BasePlayer *player, CUserCmd *ucmd, void*pMoveData)
    {
        typedef void(__thiscall* oFinishMove)(void*, C_BasePlayer*, CUserCmd*, void*);
        return CallVFunction<oFinishMove>(this, 21)(this, player, ucmd, pMoveData);
    }
};
```

`CSGOSimple/valve_sdk/interfaces/IRefCounted.hpp`:

```hpp
#pragma once
class IRefCounted {
private:
	volatile long refCount;

public:
	virtual void destructor(char bDelete) = 0;
	virtual bool OnFinalRelease() = 0;

	void unreference() {
		if (InterlockedDecrement(&refCount) == 0 && OnFinalRelease()) {
			destructor(1);
		}
	}
};
```

`CSGOSimple/valve_sdk/interfaces/IRenderView.hpp`:

```hpp
#pragma once

#include "../Math/QAngle.hpp"
#include "../Math/Vector2D.hpp"
#include "../Math/Vector4D.hpp"
#include "../Math/VMatrix.hpp"

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class CViewSetup;
class CEngineSprite;
class IClientEntity;
class IMaterial;
struct model_t;
class IClientRenderable;
class ITexture;


//-----------------------------------------------------------------------------
// Flags used by DrawWorldLists
//-----------------------------------------------------------------------------
enum
{
    DRAWWORLDLISTS_DRAW_STRICTLYABOVEWATER = 0x001,
    DRAWWORLDLISTS_DRAW_STRICTLYUNDERWATER = 0x002,
    DRAWWORLDLISTS_DRAW_INTERSECTSWATER = 0x004,
    DRAWWORLDLISTS_DRAW_WATERSURFACE = 0x008,
    DRAWWORLDLISTS_DRAW_SKYBOX = 0x010,
    DRAWWORLDLISTS_DRAW_CLIPSKYBOX = 0x020,
    DRAWWORLDLISTS_DRAW_SHADOWDEPTH = 0x040,
    DRAWWORLDLISTS_DRAW_REFRACTION = 0x080,
    DRAWWORLDLISTS_DRAW_REFLECTION = 0x100,
    DRAWWORLDLISTS_DRAW_WORLD_GEOMETRY = 0x200,
    DRAWWORLDLISTS_DRAW_DECALS_AND_OVERLAYS = 0x400,
};

enum
{
    MAT_SORT_GROUP_STRICTLY_ABOVEWATER = 0,
    MAT_SORT_GROUP_STRICTLY_UNDERWATER,
    MAT_SORT_GROUP_INTERSECTS_WATER_SURFACE,
    MAT_SORT_GROUP_WATERSURFACE,

    MAX_MAT_SORT_GROUPS
};

//-----------------------------------------------------------------------------
// Leaf index
//-----------------------------------------------------------------------------
typedef unsigned short LeafIndex_t;
enum
{
    INVALID_LEAF_INDEX = (LeafIndex_t)~0
};

struct WorldListLeafData_t
{
    LeafIndex_t     leafIndex;    // 16 bits
    int16_t         waterData;
    uint16_t        firstTranslucentSurface;    // engine-internal list index
    uint16_t        translucentSurfaceCount;    // count of translucent surfaces+disps
};

struct WorldListInfo_t
{
    int                     m_ViewFogVolume;
    int                     m_LeafCount;
    bool                    m_bHasWater;
    WorldListLeafData_t*    m_pLeafDataList;
};

class IWorldRenderList /*: public IRefCounted*/
{
};

//-----------------------------------------------------------------------------
// Describes the fog volume for a particular point
//-----------------------------------------------------------------------------
struct VisibleFogVolumeInfo_t
{
    int            m_nVisibleFogVolume;
    int            m_nVisibleFogVolumeLeaf;
    bool        m_bEyeInFogVolume;
    float       m_flDistanceToWater;
    float       m_flWaterHeight;
    IMaterial*  m_pFogVolumeMaterial;
};

struct VPlane
{
    Vector        m_Normal;
    vec_t        m_Dist;
};
#define FRUSTUM_NUMPLANES    6
typedef VPlane Frustum[FRUSTUM_NUMPLANES];
//-----------------------------------------------------------------------------
// Vertex format for brush models
//-----------------------------------------------------------------------------
struct BrushVertex_t
{
    Vector        m_Pos;
    Vector        m_Normal;
    Vector        m_TangentS;
    Vector        m_TangentT;
    Vector2D    m_TexCoord;
    Vector2D    m_LightmapCoord;

private:
    BrushVertex_t(const BrushVertex_t& src);
};

//-----------------------------------------------------------------------------
// Visibility data for area portal culling
//-----------------------------------------------------------------------------
struct VisOverrideData_t
{
    Vector        m_vecVisOrigin;                    // The point to to use as the viewpoint for area portal backface cull checks.
    float        m_fDistToAreaPortalTolerance;    // The distance from an area portal before using the full screen as the viewable portion.
};


//-----------------------------------------------------------------------------
// interface for asking about the Brush surfaces from the client DLL
//-----------------------------------------------------------------------------

class IBrushSurface
{
public:
    // Computes texture coordinates + lightmap coordinates given a world position
    virtual void ComputeTextureCoordinate(Vector const& worldPos, Vector2D& texCoord) = 0;
    virtual void ComputeLightmapCoordinate(Vector const& worldPos, Vector2D& lightmapCoord) = 0;

    // Gets the vertex data for this surface
    virtual int  GetVertexCount() const = 0;
    virtual void GetVertexData(BrushVertex_t* pVerts) = 0;

    // Gets at the material properties for this surface
    virtual IMaterial* GetMaterial() = 0;
};


//-----------------------------------------------------------------------------
// interface for installing a new renderer for brush surfaces
//-----------------------------------------------------------------------------

class IBrushRenderer
{
public:
    // Draws the surface; returns true if decals should be rendered on this surface
    virtual bool RenderBrushModelSurface(IClientEntity* pBaseEntity, IBrushSurface* pBrushSurface) = 0;
};

#define MAX_VIS_LEAVES    32
#define MAX_AREA_STATE_BYTES        32
#define MAX_AREA_PORTAL_STATE_BYTES 24

class IVRenderView
{
    enum
    {
        VIEW_SETUP_VIS_EX_RETURN_FLAGS_USES_RADIAL_VIS = 0x00000001
    };
public:
    virtual void                DrawBrushModel(IClientEntity *baseentity, model_t *model, const Vector& origin, const QAngle& angles, bool sort) = 0;
    virtual void                DrawIdentityBrushModel(IWorldRenderList *pList, model_t *model) = 0;
    virtual void                TouchLight(struct dlight_t *light) = 0;
    virtual void                Draw3DDebugOverlays(void) = 0;
    virtual void                SetBlend(float blend) = 0;
    virtual float               GetBlend(void) = 0;
    virtual void                SetColorModulation(float const* blend) = 0;
    inline void                 SetColorModulation(float r, float g, float b)
    {
        float clr[3] = { r, g, b };
        SetColorModulation(clr);
    }
    virtual void                GetColorModulation(float* blend) = 0;
    virtual void                SceneBegin(void) = 0;
    virtual void                SceneEnd(void) = 0;
    virtual void                GetVisibleFogVolume(const Vector& eyePoint, VisibleFogVolumeInfo_t *pInfo) = 0;
    virtual IWorldRenderList*   CreateWorldList() = 0;
    virtual void                BuildWorldLists(IWorldRenderList *pList, WorldListInfo_t* pInfo, int iForceFViewLeaf, const VisOverrideData_t* pVisData = NULL, bool bShadowDepth = false, float *pReflectionWaterHeight = NULL) = 0;
    virtual void                DrawWorldLists(IWorldRenderList *pList, unsigned long flags, float waterZAdjust) = 0;
    virtual int                 GetNumIndicesForWorldLists(IWorldRenderList *pList, unsigned long nFlags) = 0;
    virtual void                DrawTopView(bool enable) = 0;
    virtual void                TopViewBounds(Vector2D const& mins, Vector2D const& maxs) = 0;
    virtual void                DrawLights(void) = 0;
    virtual void                DrawMaskEntities(void) = 0;
    virtual void                DrawTranslucentSurfaces(IWorldRenderList *pList, int *pSortList, int sortCount, unsigned long flags) = 0;
    virtual void                DrawLineFile(void) = 0;
    virtual void                DrawLightmaps(IWorldRenderList *pList, int pageId) = 0;
    virtual void                ViewSetupVis(bool novis, int numorigins, const Vector origin[]) = 0;
    virtual bool                AreAnyLeavesVisible(int *leafList, int nLeaves) = 0;
    virtual    void             VguiPaint(void) = 0;
    virtual void                ViewDrawFade(uint8_t *color, IMaterial *pMaterial) = 0;
    virtual void                OLD_SetProjectionMatrix(float fov, float zNear, float zFar) = 0;
    virtual unsigned long       GetLightAtPoint(Vector& pos) = 0;
    virtual int                 GetViewEntity(void) = 0;
    virtual bool                IsViewEntity(int entindex) = 0;
    virtual float               GetFieldOfView(void) = 0;
    virtual unsigned char**     GetAreaBits(void) = 0;
    virtual void                SetFogVolumeState(int nVisibleFogVolume, bool bUseHeightFog) = 0;
    virtual void                InstallBrushSurfaceRenderer(IBrushRenderer* pBrushRenderer) = 0;
    virtual void                DrawBrushModelShadow(IClientRenderable *pRenderable) = 0;
    virtual    bool             LeafContainsTranslucentSurfaces(IWorldRenderList *pList, int sortIndex, unsigned long flags) = 0;
    virtual bool                DoesBoxIntersectWaterVolume(const Vector &mins, const Vector &maxs, int leafWaterDataID) = 0;
    virtual void                SetAreaState(unsigned char chAreaBits[MAX_AREA_STATE_BYTES], unsigned char chAreaPortalBits[MAX_AREA_PORTAL_STATE_BYTES]) = 0;
    virtual void                VGui_Paint(int mode) = 0;
    virtual void                Push3DView(const CViewSetup &view, int nFlags, ITexture* pRenderTarget, Frustum frustumPlanes) = 0;
    virtual void                Push2DView(const CViewSetup &view, int nFlags, ITexture* pRenderTarget, Frustum frustumPlanes) = 0;
    virtual void                PopView(Frustum frustumPlanes) = 0;
    virtual void                SetMainView(const Vector &vecOrigin, const QAngle &angles) = 0;
    virtual void                ViewSetupVisEx(bool novis, int numorigins, const Vector origin[], unsigned int &returnFlags) = 0;
    virtual void                OverrideViewFrustum(Frustum custom) = 0;
    virtual void                DrawBrushModelShadowDepth(IClientEntity *baseentity, model_t *model, const Vector& origin, const QAngle& angles, bool bSort) = 0;
    virtual void                UpdateBrushModelLightmap(model_t *model, IClientRenderable *pRenderable) = 0;
    virtual void                BeginUpdateLightmaps(void) = 0;
    virtual void                EndUpdateLightmaps(void) = 0;
    virtual void                OLD_SetOffCenterProjectionMatrix(float fov, float zNear, float zFar, float flAspectRatio, float flBottom, float flTop, float flLeft, float flRight) = 0;
    virtual void                OLD_SetProjectionMatrixOrtho(float left, float top, float right, float bottom, float zNear, float zFar) = 0;
    virtual void                Push3DView(const CViewSetup &view, int nFlags, ITexture* pRenderTarget, Frustum frustumPlanes, ITexture* pDepthTexture) = 0;
    virtual void                GetMatricesForView(const CViewSetup &view, VMatrix *pWorldToView, VMatrix *pViewToProjection, VMatrix *pWorldToProjection, VMatrix *pWorldToPixels) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/ISurface.hpp`:

```hpp
#pragma once

#include "IAppSystem.hpp"
#include "../Math/Vector2D.hpp"

namespace vgui
{
    typedef unsigned long HFont;
    typedef unsigned int VPANEL;
};

enum FontFeature
{
    FONT_FEATURE_ANTIALIASED_FONTS = 1,
    FONT_FEATURE_DROPSHADOW_FONTS = 2,
    FONT_FEATURE_OUTLINE_FONTS = 6,
};

enum FontDrawType
{
    FONT_DRAW_DEFAULT = 0,
    FONT_DRAW_NONADDITIVE,
    FONT_DRAW_ADDITIVE,
    FONT_DRAW_TYPE_COUNT = 2,
};

enum FontFlags
{
    FONTFLAG_NONE,
    FONTFLAG_ITALIC = 0x001,
    FONTFLAG_UNDERLINE = 0x002,
    FONTFLAG_STRIKEOUT = 0x004,
    FONTFLAG_SYMBOL = 0x008,
    FONTFLAG_ANTIALIAS = 0x010,
    FONTFLAG_GAUSSIANBLUR = 0x020,
    FONTFLAG_ROTARY = 0x040,
    FONTFLAG_DROPSHADOW = 0x080,
    FONTFLAG_ADDITIVE = 0x100,
    FONTFLAG_OUTLINE = 0x200,
    FONTFLAG_CUSTOM = 0x400,
    FONTFLAG_BITMAP = 0x800,
};

struct IntRect
{
    int x0;
    int y0;
    int x1;
    int y1;
};

struct Vertex_t
{
    Vertex_t() {}
    Vertex_t(const Vector2D &pos, const Vector2D &coord = Vector2D(0, 0))
    {
        m_Position = pos;
        m_TexCoord = coord;
    }
    void Init(const Vector2D &pos, const Vector2D &coord = Vector2D(0, 0))
    {
        m_Position = pos;
        m_TexCoord = coord;
    }

    Vector2D m_Position;
    Vector2D m_TexCoord;
};

//-----------------------------------------------------------------------------
// Purpose: Wraps contextless windows system functions
//-----------------------------------------------------------------------------
class ISurface : public IAppSystem
{
public:
    virtual void          RunFrame() = 0;
    virtual vgui::VPANEL  GetEmbeddedPanel() = 0;
    virtual void          SetEmbeddedPanel(vgui::VPANEL pPanel) = 0;
    virtual void          PushMakeCurrent(vgui::VPANEL panel, bool useInsets) = 0;
    virtual void          PopMakeCurrent(vgui::VPANEL panel) = 0;
    virtual void          DrawSetColor(int r, int g, int b, int a) = 0;
    virtual void          DrawSetColor(Color col) = 0;
    virtual void          DrawFilledRect(int x0, int y0, int x1, int y1) = 0;
    virtual void          DrawFilledRectArray(IntRect *pRects, int numRects) = 0;
    virtual void          DrawOutlinedRect(int x0, int y0, int x1, int y1) = 0;
    virtual void          DrawLine(int x0, int y0, int x1, int y1) = 0;
    virtual void          DrawPolyLine(int *px, int *py, int numPoints) = 0;
    virtual void          DrawSetApparentDepth(float f) = 0;
    virtual void          DrawClearApparentDepth(void) = 0;
    virtual void          DrawSetTextFont(vgui::HFont font) = 0;
    virtual void          DrawSetTextColor(int r, int g, int b, int a) = 0;
    virtual void          DrawSetTextColor(Color col) = 0;
    virtual void          DrawSetTextPos(int x, int y) = 0;
    virtual void          DrawGetTextPos(int& x, int& y) = 0;
    virtual void          DrawPrintText(const wchar_t *text, int textLen, FontDrawType drawType = FontDrawType::FONT_DRAW_DEFAULT) = 0;
    virtual void          DrawUnicodeChar(wchar_t wch, FontDrawType drawType = FontDrawType::FONT_DRAW_DEFAULT) = 0;
    virtual void          DrawFlushText() = 0;
    virtual void*         CreateHTMLWindow(void *events, vgui::VPANEL context) = 0;
    virtual void          PaintHTMLWindow(void *htmlwin) = 0;
    virtual void          DeleteHTMLWindow(void *htmlwin) = 0;
    virtual int           DrawGetTextureId(char const *filename) = 0;
    virtual bool          DrawGetTextureFile(int id, char *filename, int maxlen) = 0;
    virtual void          DrawSetTextureFile(int id, const char *filename, int hardwareFilter, bool forceReload) = 0;
    virtual void          DrawSetTextureRGBA(int id, const unsigned char *rgba, int wide, int tall) = 0;
    virtual void          DrawSetTexture(int id) = 0;
    virtual void          DeleteTextureByID(int id) = 0;
    virtual void          DrawGetTextureSize(int id, int &wide, int &tall) = 0;
    virtual void          DrawTexturedRect(int x0, int y0, int x1, int y1) = 0;
    virtual bool          IsTextureIDValid(int id) = 0;
    virtual int           CreateNewTextureID(bool procedural = false) = 0;
    virtual void          GetScreenSize(int &wide, int &tall) = 0;
    virtual void          SetAsTopMost(vgui::VPANEL panel, bool state) = 0;
    virtual void          BringToFront(vgui::VPANEL panel) = 0;
    virtual void          SetForegroundWindow(vgui::VPANEL panel) = 0;
    virtual void          SetPanelVisible(vgui::VPANEL panel, bool state) = 0;
    virtual void          SetMinimized(vgui::VPANEL panel, bool state) = 0;
    virtual bool          IsMinimized(vgui::VPANEL panel) = 0;
    virtual void          FlashWindow(vgui::VPANEL panel, bool state) = 0;
    virtual void          SetTitle(vgui::VPANEL panel, const wchar_t *title) = 0;
    virtual void          SetAsToolBar(vgui::VPANEL panel, bool state) = 0;
    virtual void          CreatePopup(vgui::VPANEL panel, bool minimised, bool showTaskbarIcon = true, bool disabled = false, bool mouseInput = true, bool kbInput = true) = 0;
    virtual void          SwapBuffers(vgui::VPANEL panel) = 0;
    virtual void          Invalidate(vgui::VPANEL panel) = 0;
    virtual void          SetCursor(unsigned long cursor) = 0;
    virtual bool          IsCursorVisible() = 0;
    virtual void          ApplyChanges() = 0;
    virtual bool          IsWithin(int x, int y) = 0;
    virtual bool          HasFocus() = 0;
    virtual bool          SupportsFeature(int /*SurfaceFeature_t*/ feature) = 0;
    virtual void          RestrictPaintToSinglePanel(vgui::VPANEL panel, bool bForceAllowNonModalSurface = false) = 0;
    virtual void          SetModalPanel(vgui::VPANEL) = 0;
    virtual vgui::VPANEL  GetModalPanel() = 0;
    virtual void          UnlockCursor() = 0;
    virtual void          LockCursor() = 0;
    virtual void          SetTranslateExtendedKeys(bool state) = 0;
    virtual vgui::VPANEL  GetTopmostPopup() = 0;
    virtual void          SetTopLevelFocus(vgui::VPANEL panel) = 0;
    virtual vgui::HFont   CreateFont_() = 0;
    virtual bool          SetFontGlyphSet(vgui::HFont font, const char *windowsFontName, int tall, int weight, int blur, int scanlines, int flags, int nRangeMin = 0, int nRangeMax = 0) = 0;
    virtual bool          AddCustomFontFile(const char *fontFileName) = 0;
    virtual int           GetFontTall(vgui::HFont font) = 0;
    virtual int           GetFontAscent(vgui::HFont font, wchar_t wch) = 0;
    virtual bool          IsFontAdditive(vgui::HFont font) = 0;
    virtual void          GetCharABCwide(vgui::HFont font, int ch, int &a, int &b, int &c) = 0;
    virtual int           GetCharacterWidth(vgui::HFont font, int ch) = 0;
    virtual void          GetTextSize(vgui::HFont font, const wchar_t *text, int &wide, int &tall) = 0;
    virtual vgui::VPANEL  GetNotifyPanel() = 0;
    virtual void          SetNotifyIcon(vgui::VPANEL context, unsigned long icon, vgui::VPANEL panelToReceiveMessages, const char *text) = 0;
    virtual void          PlaySound_(const char *fileName) = 0;
    virtual int           GetPopupCount() = 0;
    virtual vgui::VPANEL  GetPopup(int index) = 0;
    virtual bool          ShouldPaintChildPanel(vgui::VPANEL childPanel) = 0;
    virtual bool          RecreateContext(vgui::VPANEL panel) = 0;
    virtual void          AddPanel(vgui::VPANEL panel) = 0;
    virtual void          ReleasePanel(vgui::VPANEL panel) = 0;
    virtual void          MovePopupToFront(vgui::VPANEL panel) = 0;
    virtual void          MovePopupToBack(vgui::VPANEL panel) = 0;
    virtual void          SolveTraverse(vgui::VPANEL panel, bool forceApplySchemeSettings = false) = 0;
    virtual void          PaintTraverse(vgui::VPANEL panel) = 0;
    virtual void          EnableMouseCapture(vgui::VPANEL panel, bool state) = 0;
    virtual void          GetWorkspaceBounds(int &x, int &y, int &wide, int &tall) = 0;
    virtual void          GetAbsoluteWindowBounds(int &x, int &y, int &wide, int &tall) = 0;
    virtual void          GetProportionalBase(int &width, int &height) = 0;
    virtual void          CalculateMouseVisible() = 0;
    virtual bool          NeedKBInput() = 0;
    virtual bool          HasCursorPosFunctions() = 0;
    virtual void          SurfaceGetCursorPos(int &x, int &y) = 0;
    virtual void          SurfaceSetCursorPos(int x, int y) = 0;
    virtual void          DrawTexturedLine(const Vertex_t &a, const Vertex_t &b) = 0;
    virtual void          DrawOutlinedCircle(int x, int y, int radius, int segments) = 0;
    virtual void          DrawTexturedPolyLine(const Vertex_t *p, int n) = 0;
    virtual void          DrawTexturedSubRect(int x0, int y0, int x1, int y1, float texs0, float text0, float texs1, float text1) = 0;
    virtual void          DrawTexturedPolygon(int n, Vertex_t *pVertice, bool bClipVertices = true) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IVDebugOverlay.hpp`:

```hpp
#pragma once

#include "../Math/Vector.hpp"
#include "../Math/QAngle.hpp"
#include "../Math/VMatrix.hpp"

class OverlayText_t;

class IVDebugOverlay
{
public:
    virtual void            __unkn() = 0;
    virtual void            AddEntityTextOverlay(int ent_index, int line_offset, float duration, int r, int g, int b, int a, const char *format, ...) = 0;
    virtual void            AddBoxOverlay(const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, int r, int g, int b, int a, float duration) = 0;
    virtual void            AddSphereOverlay(const Vector& vOrigin, float flRadius, int nTheta, int nPhi, int r, int g, int b, int a, float flDuration) = 0;
    virtual void            AddTriangleOverlay(const Vector& p1, const Vector& p2, const Vector& p3, int r, int g, int b, int a, bool noDepthTest, float duration) = 0;
    virtual void            AddLineOverlay(const Vector& origin, const Vector& dest, int r, int g, int b, bool noDepthTest, float duration) = 0;
    virtual void            AddTextOverlay(const Vector& origin, float duration, const char *format, ...) = 0;
    virtual void            AddTextOverlay(const Vector& origin, int line_offset, float duration, const char *format, ...) = 0;
    virtual void            AddScreenTextOverlay(float flXPos, float flYPos, float flDuration, int r, int g, int b, int a, const char *text) = 0;
    virtual void            AddSweptBoxOverlay(const Vector& start, const Vector& end, const Vector& mins, const Vector& max, const QAngle & angles, int r, int g, int b, int a, float flDuration) = 0;
    virtual void            AddGridOverlay(const Vector& origin) = 0;
    virtual void            AddCoordFrameOverlay(const matrix3x4_t& frame, float flScale, int vColorTable[3][3] = NULL) = 0;
    virtual int             ScreenPosition(const Vector& point, Vector& screen) = 0;
    virtual int             ScreenPosition(float flXPos, float flYPos, Vector& screen) = 0;
    virtual OverlayText_t*  GetFirst(void) = 0;
    virtual OverlayText_t*  GetNext(OverlayText_t *current) = 0;
    virtual void            ClearDeadOverlays(void) = 0;
    virtual void            ClearAllOverlays() = 0;
    virtual void            AddTextOverlayRGB(const Vector& origin, int line_offset, float duration, float r, float g, float b, float alpha, const char *format, ...) = 0;
    virtual void            AddTextOverlayRGB(const Vector& origin, int line_offset, float duration, int r, int g, int b, int a, const char *format, ...) = 0;
    virtual void            AddLineOverlayAlpha(const Vector& origin, const Vector& dest, int r, int g, int b, int a, bool noDepthTest, float duration) = 0;
    virtual void            AddBoxOverlay2(const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, const uint8_t* faceColor, const uint8_t* edgeColor, float duration) = 0;
    virtual void            PurgeTextOverlays() = 0;
    virtual void            DrawPill(const Vector& mins, const Vector& max, float& diameter, int r, int g, int b, int a, float duration) = 0;
};
```

`CSGOSimple/valve_sdk/interfaces/IVEngineClient.hpp`:

```hpp
#pragma once

#include "../math/Vector.hpp"
#include "../math/QAngle.hpp"
#include "../math/VMatrix.hpp"

#define SIGNONSTATE_NONE		0	// no state yet, about to connect
#define SIGNONSTATE_CHALLENGE	1	// client challenging server, all OOB packets
#define SIGNONSTATE_CONNECTED	2	// client is connected to server, netchans ready
#define SIGNONSTATE_NEW			3	// just got serverinfo and string tables
#define SIGNONSTATE_PRESPAWN	4	// received signon buffers
#define SIGNONSTATE_SPAWN		5	// ready to receive entity packets
#define SIGNONSTATE_FULL		6	// we are fully connected, first non-delta packet received
#define SIGNONSTATE_CHANGELEVEL	7	// server is changing level, please wait

typedef struct InputContextHandle_t__ *InputContextHandle_t;
struct client_textmessage_t;
struct model_t;
class SurfInfo;
class IMaterial;
class CSentence;
class CAudioSource;
class AudioState_t;
class ISpatialQuery;
class IMaterialSystem;
class CPhysCollide;
class IAchievementMgr;
#define FLOW_OUTGOING	0		
#define FLOW_INCOMING	1
#define MAX_FLOWS		2		// in & out

class INetChannelInfo
{
public:

	enum {
		GENERIC = 0,	// must be first and is default group
		LOCALPLAYER,	// bytes for local player entity update
		OTHERPLAYERS,	// bytes for other players update
		ENTITIES,		// all other entity bytes
		SOUNDS,			// game sounds
		EVENTS,			// event messages
		USERMESSAGES,	// user messages
		ENTMESSAGES,	// entity messages
		VOICE,			// voice data
		STRINGTABLE,	// a stringtable update
		MOVE,			// client move cmds
		STRINGCMD,		// string command
		SIGNON,			// various signondata
		TOTAL,			// must be last and is not a real group
	};

	virtual const char  *GetName(void) const = 0;	// get channel name
	virtual const char  *GetAddress(void) const = 0; // get channel IP address as string
	virtual float		GetTime(void) const = 0;	// current net time
	virtual float		GetTimeConnected(void) const = 0;	// get connection time in seconds
	virtual int			GetBufferSize(void) const = 0;	// netchannel packet history size
	virtual int			GetDataRate(void) const = 0; // send data rate in byte/sec

	virtual bool		IsLoopback(void) const = 0;	// true if loopback channel
	virtual bool		IsTimingOut(void) const = 0;	// true if timing out
	virtual bool		IsPlayback(void) const = 0;	// true if demo playback

	virtual float		GetLatency(int flow) const = 0;	 // current latency (RTT), more accurate but jittering
	virtual float		GetAvgLatency(int flow) const = 0; // average packet latency in seconds
	virtual float		GetAvgLoss(int flow) const = 0;	 // avg packet loss[0..1]
	virtual float		GetAvgChoke(int flow) const = 0;	 // avg packet choke[0..1]
	virtual float		GetAvgData(int flow) const = 0;	 // data flow in bytes/sec
	virtual float		GetAvgPackets(int flow) const = 0; // avg packets/sec
	virtual int			GetTotalData(int flow) const = 0;	 // total flow in/out in bytes
	virtual int			GetSequenceNr(int flow) const = 0;	// last send seq number
	virtual bool		IsValidPacket(int flow, int frame_number) const = 0; // true if packet was not lost/dropped/chocked/flushed
	virtual float		GetPacketTime(int flow, int frame_number) const = 0; // time when packet was send
	virtual int			GetPacketBytes(int flow, int frame_number, int group) const = 0; // group size of this packet
	virtual bool		GetStreamProgress(int flow, int *received, int *total) const = 0;  // TCP progress if transmitting
	virtual float		GetTimeSinceLastReceived(void) const = 0;	// get time since last recieved packet in seconds
	virtual	float		GetCommandInterpolationAmount(int flow, int frame_number) const = 0;
	virtual void		GetPacketResponseLatency(int flow, int frame_number, int *pnLatencyMsecs, int *pnChoke) const = 0;
	virtual void		GetRemoteFramerate(float *pflFrameTime, float *pflFrameTimeStdDeviation) const = 0;

	virtual float		GetTimeoutSeconds() const = 0;
};

class ISPSharedMemory;
class CGamestatsData;
class KeyValues;
class CSteamAPIContext;
struct Frustum_t;

typedef void(*pfnDemoCustomDataCallback)(uint8_t *pData, size_t iSize);


typedef struct player_info_s
{
	__int64         unknown;            //0x0000 
	union
	{
		__int64       steamID64;          //0x0008 - SteamID64
		struct
		{
			__int32     xuid_low;
			__int32     xuid_high;
		};
	};
	char            szName[128];        //0x0010 - Player Name
	int             userId;             //0x0090 - Unique Server Identifier
	char            szSteamID[20];      //0x0094 - STEAM_X:Y:Z
	char            pad_0x00A8[0x10];   //0x00A8
	unsigned long   iSteamID;           //0x00B8 - SteamID 
	char            szFriendsName[128];
	bool            fakeplayer;
	bool            ishltv;
	unsigned int    customfiles[4];
	unsigned char   filesdownloaded;
} player_info_t;

#include "../math/Vector2D.hpp"

class IMapOverview // : public IBaseInterface
{
public:
	virtual	~IMapOverview(void) {};

	virtual	void SetVisible(bool state) = 0;	// set map panel visible
	virtual void SetBounds(int x, int y, int wide, int tall) = 0; // set pos & size
	virtual void SetZoom(float zoom) = 0; // set zoom
	virtual void SetTime(float time) = 0; // set game time
	virtual void SetAngle(float angle) = 0; // set map orientation
	virtual void SetFollowAngle(bool state) = 0; // if true, map rotates with spectators view
	virtual void SetCenter(Vector2D &mappos) = 0; // set map pos in center of panel
	virtual void SetPlayerPositions(int index, const Vector &position, const QAngle &angle) = 0; // update player position
	virtual Vector2D WorldToMap(Vector &worldpos) = 0; // convert 3d world to 2d map pos

	virtual bool  IsVisible(void) = 0;	// true if MapOverview is visible
	virtual void  GetBounds(int& x, int& y, int& wide, int& tall) = 0; // get current pos & size
	virtual float GetZoom(void) = 0;

	// deatils properties
	virtual	void ShowPlayerNames(bool state) = 0;	// show player names under icons
	virtual	void ShowTracers(bool state) = 0;	// show shooting traces as lines
	virtual	void ShowExplosions(bool state) = 0;	// show, smoke, flash & HE grenades
	virtual	void ShowHealth(bool state) = 0;		// show player health under icon
	virtual	void ShowHurts(bool state) = 0;	// show player icon flashing if player is hurt
	virtual	void ShowTracks(float seconds) = 0; // show player trails for n seconds
};


class IVEngineClient
{
public:
	virtual int                   GetIntersectingSurfaces(const model_t *model, const Vector &vCenter, const float radius, const bool bOnlyVisibleSurfaces, SurfInfo *pInfos, const int nMaxInfos) = 0;
	virtual Vector                GetLightForPoint(const Vector &pos, bool bClamp) = 0;
	virtual IMaterial*            TraceLineMaterialAndLighting(const Vector &start, const Vector &end, Vector &diffuseLightColor, Vector& baseColor) = 0;
	virtual const char*           ParseFile(const char *data, char *token, int maxlen) = 0;
	virtual bool                  CopyFile(const char *source, const char *destination) = 0;
	virtual void                  GetScreenSize(int& width, int& height) = 0;
	virtual void                  ServerCmd(const char *szCmdString, bool bReliable = true) = 0;
	virtual void                  ClientCmd(const char *szCmdString) = 0;
	virtual bool                  GetPlayerInfo(int ent_num, player_info_t *pinfo) = 0;
	virtual int                   GetPlayerForUserID(int userID) = 0;
	virtual client_textmessage_t* TextMessageGet(const char *pName) = 0; // 10
	virtual bool                  Con_IsVisible(void) = 0;
	virtual int                   GetLocalPlayer(void) = 0;
	virtual const model_t*        LoadModel(const char *pName, bool bProp = false) = 0;
	virtual float                 GetLastTimeStamp(void) = 0;
	virtual CSentence*            GetSentence(CAudioSource *pAudioSource) = 0; // 15
	virtual float                 GetSentenceLength(CAudioSource *pAudioSource) = 0;
	virtual bool                  IsStreaming(CAudioSource *pAudioSource) const = 0;
	virtual void                  GetViewAngles(QAngle* va) = 0;
	virtual void                  SetViewAngles(QAngle* va) = 0;
	virtual int                   GetMaxClients(void) = 0; // 20
	virtual const char*           Key_LookupBinding(const char *pBinding) = 0;
	virtual const char*           Key_BindingForKey(int &code) = 0;
	virtual void                  Key_SetBinding(int, char const*) = 0;
	virtual void                  StartKeyTrapMode(void) = 0;
	virtual bool                  CheckDoneKeyTrapping(int &code) = 0;
	virtual bool                  IsInGame(void) = 0;
	virtual bool                  IsConnected(void) = 0;
	virtual bool                  IsDrawingLoadingImage(void) = 0;
	virtual void                  HideLoadingPlaque(void) = 0;
	virtual void                  Con_NPrintf(int pos, const char *fmt, ...) = 0; // 30
	virtual void                  Con_NXPrintf(const struct con_nprint_s *info, const char *fmt, ...) = 0;
	virtual int                   IsBoxVisible(const Vector& mins, const Vector& maxs) = 0;
	virtual int                   IsBoxInViewCluster(const Vector& mins, const Vector& maxs) = 0;
	virtual bool                  CullBox(const Vector& mins, const Vector& maxs) = 0;
	virtual void                  Sound_ExtraUpdate(void) = 0;
	virtual const char*           GetGameDirectory(void) = 0;
	virtual const VMatrix&        WorldToScreenMatrix() = 0;
	virtual const VMatrix&        WorldToViewMatrix() = 0;
	virtual int                   GameLumpVersion(int lumpId) const = 0;
	virtual int                   GameLumpSize(int lumpId) const = 0; // 40
	virtual bool                  LoadGameLump(int lumpId, void* pBuffer, int size) = 0;
	virtual int                   LevelLeafCount() const = 0;
	virtual ISpatialQuery*        GetBSPTreeQuery() = 0;
	virtual void                  LinearToGamma(float* linear, float* gamma) = 0;
	virtual float                 LightStyleValue(int style) = 0; // 45
	virtual void                  ComputeDynamicLighting(const Vector& pt, const Vector* pNormal, Vector& color) = 0;
	virtual void                  GetAmbientLightColor(Vector& color) = 0;
	virtual int                   GetDXSupportLevel() = 0;
	virtual bool                  SupportsHDR() = 0;
	virtual void                  Mat_Stub(IMaterialSystem *pMatSys) = 0; // 50
	virtual void                  GetChapterName(char *pchBuff, int iMaxLength) = 0;
	virtual char const*           GetLevelName(void) = 0;
	virtual char const*           GetLevelNameShort(void) = 0;
	virtual char const*           GetMapGroupName(void) = 0;
	virtual struct IVoiceTweak_s* GetVoiceTweakAPI(void) = 0;
	virtual void                  SetVoiceCasterID(unsigned int someint) = 0; // 56
	virtual void                  EngineStats_BeginFrame(void) = 0;
	virtual void                  EngineStats_EndFrame(void) = 0;
	virtual void                  FireEvents() = 0;
	virtual int                   GetLeavesArea(unsigned short *pLeaves, int nLeaves) = 0;
	virtual bool                  DoesBoxTouchAreaFrustum(const Vector &mins, const Vector &maxs, int iArea) = 0; // 60
	virtual int                   GetFrustumList(Frustum_t **pList, int listMax) = 0;
	virtual bool                  ShouldUseAreaFrustum(int i) = 0;
	virtual void                  SetAudioState(const AudioState_t& state) = 0;
	virtual int                   SentenceGroupPick(int groupIndex, char *name, int nameBufLen) = 0;
	virtual int                   SentenceGroupPickSequential(int groupIndex, char *name, int nameBufLen, int sentenceIndex, int reset) = 0;
	virtual int                   SentenceIndexFromName(const char *pSentenceName) = 0;
	virtual const char*           SentenceNameFromIndex(int sentenceIndex) = 0;
	virtual int                   SentenceGroupIndexFromName(const char *pGroupName) = 0;
	virtual const char*           SentenceGroupNameFromIndex(int groupIndex) = 0;
	virtual float                 SentenceLength(int sentenceIndex) = 0;
	virtual void                  ComputeLighting(const Vector& pt, const Vector* pNormal, bool bClamp, Vector& color, Vector *pBoxColors = NULL) = 0;
	virtual void                  ActivateOccluder(int nOccluderIndex, bool bActive) = 0;
	virtual bool                  IsOccluded(const Vector &vecAbsMins, const Vector &vecAbsMaxs) = 0; // 74
	virtual int                   GetOcclusionViewId(void) = 0;
	virtual void*                 SaveAllocMemory(size_t num, size_t size) = 0;
	virtual void                  SaveFreeMemory(void *pSaveMem) = 0;
	virtual INetChannelInfo*      GetNetChannelInfo(void) = 0;
	virtual void                  DebugDrawPhysCollide(const CPhysCollide *pCollide, IMaterial *pMaterial, const matrix3x4_t& transform, const uint8_t* color) = 0; //79
	virtual void                  CheckPoint(const char *pName) = 0; // 80
	virtual void                  DrawPortals() = 0;
	virtual bool                  IsPlayingDemo(void) = 0;
	virtual bool                  IsRecordingDemo(void) = 0;
	virtual bool                  IsPlayingTimeDemo(void) = 0;
	virtual int                   GetDemoRecordingTick(void) = 0;
	virtual int                   GetDemoPlaybackTick(void) = 0;
	virtual int                   GetDemoPlaybackStartTick(void) = 0;
	virtual float                 GetDemoPlaybackTimeScale(void) = 0;
	virtual int                   GetDemoPlaybackTotalTicks(void) = 0;
	virtual bool                  IsPaused(void) = 0; // 90
	virtual float                 GetTimescale(void) const = 0;
	virtual bool                  IsTakingScreenshot(void) = 0;
	virtual bool                  IsHLTV(void) = 0;
	virtual bool                  IsLevelMainMenuBackground(void) = 0;
	virtual void                  GetMainMenuBackgroundName(char *dest, int destlen) = 0;
	virtual void                  SetOcclusionParameters(const int /*OcclusionParams_t*/ &params) = 0; // 96
	virtual void                  GetUILanguage(char *dest, int destlen) = 0;
	virtual int                   IsSkyboxVisibleFromPoint(const Vector &vecPoint) = 0;
	virtual const char*           GetMapEntitiesString() = 0;
	virtual bool                  IsInEditMode(void) = 0; // 100
	virtual float                 GetScreenAspectRatio(int viewportWidth, int viewportHeight) = 0;
	virtual bool                  REMOVED_SteamRefreshLogin(const char *password, bool isSecure) = 0;
	virtual bool                  REMOVED_SteamProcessCall(bool & finished) = 0;
	virtual unsigned int          GetEngineBuildNumber() = 0; // engines build
	virtual const char *          GetProductVersionString() = 0; // mods version number (steam.inf)
	virtual void                  GrabPreColorCorrectedFrame(int x, int y, int width, int height) = 0;
	virtual bool                  IsHammerRunning() const = 0;
	virtual void                  ExecuteClientCmd(const char *szCmdString) = 0; //108
	virtual bool                  MapHasHDRLighting(void) = 0;
	virtual bool                  MapHasLightMapAlphaData(void) = 0;
	virtual int                   GetAppID() = 0;
	virtual Vector                GetLightForPointFast(const Vector &pos, bool bClamp) = 0;
	virtual void                  ClientCmd_Unrestricted(char  const*, int, bool) = 0;
	virtual void                  ClientCmd_Unrestricted(const char *szCmdString) = 0; // 114
	virtual void                  SetRestrictServerCommands(bool bRestrict) = 0;
	virtual void                  SetRestrictClientCommands(bool bRestrict) = 0;
	virtual void                  SetOverlayBindProxy(int iOverlayID, void *pBindProxy) = 0;
	virtual bool                  CopyFrameBufferToMaterial(const char *pMaterialName) = 0;
	virtual void                  ReadConfiguration(const int iController, const bool readDefault) = 0;
	virtual void                  SetAchievementMgr(IAchievementMgr *pAchievementMgr) = 0;
	virtual IAchievementMgr*      GetAchievementMgr() = 0;
	virtual bool                  MapLoadFailed(void) = 0;
	virtual void                  SetMapLoadFailed(bool bState) = 0;
	virtual bool                  IsLowViolence() = 0;
	virtual const char*           GetMostRecentSaveGame(void) = 0;
	virtual void                  SetMostRecentSaveGame(const char *lpszFilename) = 0;
	virtual void                  StartXboxExitingProcess() = 0;
	virtual bool                  IsSaveInProgress() = 0;
	virtual bool                  IsAutoSaveDangerousInProgress(void) = 0;
	virtual unsigned int          OnStorageDeviceAttached(int iController) = 0;
	virtual void                  OnStorageDeviceDetached(int iController) = 0;
	virtual const char*           GetSaveDirName(void) = 0;
	virtual void                  WriteScreenshot(const char *pFilename) = 0;
	virtual void                  ResetDemoInterpolation(void) = 0;
	virtual int                   GetActiveSplitScreenPlayerSlot() = 0;
	virtual int                   SetActiveSplitScreenPlayerSlot(int slot) = 0;
	virtual bool                  SetLocalPlayerIsResolvable(char const *pchContext, int nLine, bool bResolvable) = 0;
	virtual bool                  IsLocalPlayerResolvable() = 0;
	virtual int                   GetSplitScreenPlayer(int nSlot) = 0;
	virtual bool                  IsSplitScreenActive() = 0;
	virtual bool                  IsValidSplitScreenSlot(int nSlot) = 0;
	virtual int                   FirstValidSplitScreenSlot() = 0; // -1 == invalid
	virtual int                   NextValidSplitScreenSlot(int nPreviousSlot) = 0; // -1 == invalid
	virtual ISPSharedMemory*      GetSinglePlayerSharedMemorySpace(const char *szName, int ent_num = (1 << 11)) = 0;
	virtual void                  ComputeLightingCube(const Vector& pt, bool bClamp, Vector *pBoxColors) = 0;
	virtual void                  RegisterDemoCustomDataCallback(const char* szCallbackSaveID, pfnDemoCustomDataCallback pCallback) = 0;
	virtual void                  RecordDemoCustomData(pfnDemoCustomDataCallback pCallback, const void *pData, size_t iDataLength) = 0;
	virtual void                  SetPitchScale(float flPitchScale) = 0;
	virtual float                 GetPitchScale(void) = 0;
	virtual bool                  LoadFilmmaker() = 0;
	virtual void                  UnloadFilmmaker() = 0;
	virtual void                  SetLeafFlag(int nLeafIndex, int nFlagBits) = 0;
	virtual void                  RecalculateBSPLeafFlags(void) = 0;
	virtual bool                  DSPGetCurrentDASRoomNew(void) = 0;
	virtual bool                  DSPGetCurrentDASRoomChanged(void) = 0;
	virtual bool                  DSPGetCurrentDASRoomSkyAbove(void) = 0;
	virtual float                 DSPGetCurrentDASRoomSkyPercent(void) = 0;
	virtual void                  SetMixGroupOfCurrentMixer(const char *szgroupname, const char *szparam, float val, int setMixerType) = 0;
	virtual int                   GetMixLayerIndex(const char *szmixlayername) = 0;
	virtual void                  SetMixLayerLevel(int index, float level) = 0;
	virtual int                   GetMixGroupIndex(char  const* groupname) = 0;
	virtual void                  SetMixLayerTriggerFactor(int i1, int i2, float fl) = 0;
	virtual void                  SetMixLayerTriggerFactor(char  const* char1, char  const* char2, float fl) = 0;
	virtual bool                  IsCreatingReslist() = 0;
	virtual bool                  IsCreatingXboxReslist() = 0;
	virtual void                  SetTimescale(float flTimescale) = 0;
	virtual void                  SetGamestatsData(CGamestatsData *pGamestatsData) = 0;
	virtual CGamestatsData*       GetGamestatsData() = 0;
	virtual void                  GetMouseDelta(int &dx, int &dy, bool b) = 0; // unknown
	virtual   const char*         Key_LookupBindingEx(const char *pBinding, int iUserId = -1, int iStartCount = 0, int iAllowJoystick = -1) = 0;
	virtual int                   Key_CodeForBinding(char  const*, int, int, int) = 0;
	virtual void                  UpdateDAndELights(void) = 0;
	virtual int                   GetBugSubmissionCount() const = 0;
	virtual void                  ClearBugSubmissionCount() = 0;
	virtual bool                  DoesLevelContainWater() const = 0;
	virtual float                 GetServerSimulationFrameTime() const = 0;
	virtual void                  SolidMoved(class IClientEntity *pSolidEnt, class ICollideable *pSolidCollide, const Vector* pPrevAbsOrigin, bool accurateBboxTriggerChecks) = 0;
	virtual void                  TriggerMoved(class IClientEntity *pTriggerEnt, bool accurateBboxTriggerChecks) = 0;
	virtual void                  ComputeLeavesConnected(const Vector &vecOrigin, int nCount, const int *pLeafIndices, bool *pIsConnected) = 0;
	virtual bool                  IsInCommentaryMode(void) = 0;
	virtual void                  SetBlurFade(float amount) = 0;
	virtual bool                  IsTransitioningToLoad() = 0;
	virtual void                  SearchPathsChangedAfterInstall() = 0;
	virtual void                  ConfigureSystemLevel(int nCPULevel, int nGPULevel) = 0;
	virtual void                  SetConnectionPassword(char const *pchCurrentPW) = 0;
	virtual CSteamAPIContext*     GetSteamAPIContext() = 0;
	virtual void                  SubmitStatRecord(char const *szMapName, unsigned int uiBlobVersion, unsigned int uiBlobSize, const void *pvBlob) = 0;
	virtual void                  ServerCmdKeyValues(KeyValues *pKeyValues) = 0; // 203
	virtual void                  SpherePaintSurface(const model_t* model, const Vector& location, unsigned char chr, float fl1, float fl2) = 0;
	virtual bool                  HasPaintmap(void) = 0;
	virtual void                  EnablePaintmapRender() = 0;
	//virtual void                TracePaintSurface( const model_t *model, const Vector& position, float radius, CUtlVector<Color>& surfColors ) = 0;
	virtual void                  SphereTracePaintSurface(const model_t* model, const Vector& position, const Vector &vec2, float radius, /*CUtlVector<unsigned char, CUtlMemory<unsigned char, int>>*/ int& utilVecShit) = 0;
	virtual void                  RemoveAllPaint() = 0;
	virtual void                  PaintAllSurfaces(unsigned char uchr) = 0;
	virtual void                  RemovePaint(const model_t* model) = 0;
	virtual bool                  IsActiveApp() = 0;
	virtual bool                  IsClientLocalToActiveServer() = 0;
	virtual void                  TickProgressBar() = 0;
	virtual InputContextHandle_t  GetInputContext(int /*EngineInputContextId_t*/ id) = 0;
	virtual void                  GetStartupImage(char* filename, int size) = 0;
	virtual bool                  IsUsingLocalNetworkBackdoor(void) = 0;
	virtual void                  SaveGame(const char*, bool, char*, int, char*, int) = 0;
	virtual void                  GetGenericMemoryStats(/* GenericMemoryStat_t */ void **) = 0;
	virtual bool                  GameHasShutdownAndFlushedMemory(void) = 0;
	virtual int                   GetLastAcknowledgedCommand(void) = 0;
	virtual void                  FinishContainerWrites(int i) = 0;
	virtual void                  FinishAsyncSave(void) = 0;
	virtual int                   GetServerTick(void) = 0;
	virtual const char*           GetModDirectory(void) = 0;
	virtual bool                  AudioLanguageChanged(void) = 0;
	virtual bool                  IsAutoSaveInProgress(void) = 0;
	virtual void                  StartLoadingScreenForCommand(const char* command) = 0;
	virtual void                  StartLoadingScreenForKeyValues(KeyValues* values) = 0;
	virtual void                  SOSSetOpvarFloat(const char*, float) = 0;
	virtual void                  SOSGetOpvarFloat(const char*, float &) = 0;
	virtual bool                  IsSubscribedMap(const char*, bool) = 0;
	virtual bool                  IsFeaturedMap(const char*, bool) = 0;
	virtual void                  GetDemoPlaybackParameters(void) = 0;
	virtual int                   GetClientVersion(void) = 0;
	virtual bool                  IsDemoSkipping(void) = 0;
	virtual void                  SetDemoImportantEventData(const KeyValues* values) = 0;
	virtual void                  ClearEvents(void) = 0;
	virtual int                   GetSafeZoneXMin(void) = 0;
	virtual bool                  IsVoiceRecording(void) = 0;
	virtual void                  ForceVoiceRecordOn(void) = 0;
	virtual bool                  IsReplay(void) = 0;
};

```

`CSGOSimple/valve_sdk/interfaces/IVModelInfoClient.hpp`:

```hpp
#pragma once

#include "../math/QAngle.hpp"
#include "../misc/Studio.hpp"
#include "IEngineTrace.hpp" //Has some structs we need here

class CPhysCollide;
class CUtlBuffer;
class IClientRenderable;
class CStudioHdr;
struct virtualmodel_t;

enum RenderableTranslucencyType_t
{
	RENDERABLE_IS_OPAQUE = 0,
	RENDERABLE_IS_TRANSLUCENT,
	RENDERABLE_IS_TWO_PASS,    // has both translucent and opaque sub-partsa
};

class IVModelInfo
{
public:
	virtual                                 ~IVModelInfo(void) {}
	virtual const model_t*                  GetModel(int modelindex) const = 0;
	virtual int                             GetModelIndex(const char *name) const = 0;
	virtual const char*                     GetModelName(const model_t *model) const = 0;
	virtual vcollide_t*                     GetVCollide(const model_t *model) const = 0;
	virtual vcollide_t*                     GetVCollide(int modelindex) const = 0;
	virtual void                            GetModelBounds(const model_t *model, Vector& mins, Vector& maxs) const = 0;
	virtual void                            GetModelRenderBounds(const model_t *model, Vector& mins, Vector& maxs) const = 0;
	virtual int                             GetModelFrameCount(const model_t *model) const = 0;
	virtual int                             GetModelType(const model_t *model) const = 0;
	virtual void*                           GetModelExtraData(const model_t *model) = 0;
	virtual bool                            ModelHasMaterialProxy(const model_t *model) const = 0;
	virtual bool                            IsTranslucent(model_t const* model) const = 0;
	virtual bool                            IsTranslucentTwoPass(const model_t *model) const = 0;
	virtual void                            Unused0() {};
	virtual void UNUSED() = 0;
	virtual void UNUSE11D() = 0;
	virtual RenderableTranslucencyType_t    ComputeTranslucencyType(const model_t *model, int nSkin, int nBody) = 0;
	virtual int                             GetModelMaterialCount(const model_t* model) const = 0;
	virtual void                            GetModelMaterials(const model_t *model, int count, IMaterial** ppMaterial) = 0;
	virtual bool                            IsModelVertexLit(const model_t *model) const = 0;
	virtual const char*                     GetModelKeyValueText(const model_t *model) = 0;
	virtual bool                            GetModelKeyValue(const model_t *model, CUtlBuffer &buf) = 0;
	virtual float                           GetModelRadius(const model_t *model) = 0;
	virtual CStudioHdr*                     GetStudioHdr(MDLHandle_t handle) = 0;
	virtual const studiohdr_t*              FindModel(const studiohdr_t *pStudioHdr, void **cache, const char *modelname) const = 0;
	virtual const studiohdr_t*              FindModel(void *cache) const = 0;
	virtual virtualmodel_t*                 GetVirtualModel(const studiohdr_t *pStudioHdr) const = 0;
	virtual uint8_t*                        GetAnimBlock(const studiohdr_t *pStudioHdr, int iBlock) const = 0;
	virtual void                            GetModelMaterialColorAndLighting(const model_t *model, Vector const& origin, QAngle const& angles, trace_t* pTrace, Vector& lighting, Vector& matColor) = 0;
	virtual void                            GetIlluminationPoint(const model_t *model, IClientRenderable *pRenderable, Vector const& origin, QAngle const& angles, Vector* pLightingCenter) = 0;
	virtual int                             GetModelContents(int modelIndex) const = 0;
	virtual studiohdr_t*                    GetStudiomodel(const model_t *mod) = 0;
	virtual int                             GetModelSpriteWidth(const model_t *model) const = 0;
	virtual int                             GetModelSpriteHeight(const model_t *model) const = 0;
	virtual void                            SetLevelScreenFadeRange(float flMinSize, float flMaxSize) = 0;
	virtual void                            GetLevelScreenFadeRange(float *pMinArea, float *pMaxArea) const = 0;
	virtual void                            SetViewScreenFadeRange(float flMinSize, float flMaxSize) = 0;
	virtual unsigned char                   ComputeLevelScreenFade(const Vector &vecAbsOrigin, float flRadius, float flFadeScale) const = 0;
	virtual unsigned char                   ComputeViewScreenFade(const Vector &vecAbsOrigin, float flRadius, float flFadeScale) const = 0;
	virtual int                             GetAutoplayList(const studiohdr_t *pStudioHdr, unsigned short **pAutoplayList) const = 0;
	virtual CPhysCollide*                   GetCollideForVirtualTerrain(int index) = 0;
	virtual bool                            IsUsingFBTexture(const model_t *model, int nSkin, int nBody, IClientRenderable* *pClientRenderable) const = 0;
	virtual const model_t*                  FindOrLoadModel(const char *name) const = 0;
	virtual MDLHandle_t                     GetCacheHandle(const model_t *model) const = 0;
	virtual int                             GetBrushModelPlaneCount(const model_t *model) const = 0;
	virtual void                            GetBrushModelPlane(const model_t *model, int nIndex, cplane_t &plane, Vector *pOrigin) const = 0;
	virtual int                             GetSurfacepropsForVirtualTerrain(int index) = 0;
	virtual bool                            UsesEnvCubemap(const model_t *model) const = 0;
	virtual bool                            UsesStaticLighting(const model_t *model) const = 0;
};

class IVModelInfoClient : public IVModelInfo
{
public:
};

```

`CSGOSimple/valve_sdk/interfaces/IVModelRender.hpp`:

```hpp
#pragma once

#include "../Math/QAngle.hpp"
#include "../Math/VMatrix.hpp"

enum PreviewImageRetVal_t
{
    MATERIAL_PREVIEW_IMAGE_BAD = 0,
    MATERIAL_PREVIEW_IMAGE_OK,
    MATERIAL_NO_PREVIEW_IMAGE,
};

enum MaterialVarFlags_t
{
    MATERIAL_VAR_DEBUG = (1 << 0),
    MATERIAL_VAR_NO_DEBUG_OVERRIDE = (1 << 1),
    MATERIAL_VAR_NO_DRAW = (1 << 2),
    MATERIAL_VAR_USE_IN_FILLRATE_MODE = (1 << 3),
    MATERIAL_VAR_VERTEXCOLOR = (1 << 4),
    MATERIAL_VAR_VERTEXALPHA = (1 << 5),
    MATERIAL_VAR_SELFILLUM = (1 << 6),
    MATERIAL_VAR_ADDITIVE = (1 << 7),
    MATERIAL_VAR_ALPHATEST = (1 << 8),
    //MATERIAL_VAR_UNUSED = (1 << 9),
    MATERIAL_VAR_ZNEARER = (1 << 10),
    MATERIAL_VAR_MODEL = (1 << 11),
    MATERIAL_VAR_FLAT = (1 << 12),
    MATERIAL_VAR_NOCULL = (1 << 13),
    MATERIAL_VAR_NOFOG = (1 << 14),
    MATERIAL_VAR_IGNOREZ = (1 << 15),
    MATERIAL_VAR_DECAL = (1 << 16),
    MATERIAL_VAR_ENVMAPSPHERE = (1 << 17), // OBSOLETE
    MATERIAL_VAR_UNUSED = (1 << 18), // UNUSED
    MATERIAL_VAR_ENVMAPCAMERASPACE = (1 << 19), // OBSOLETE
    MATERIAL_VAR_BASEALPHAENVMAPMASK = (1 << 20),
    MATERIAL_VAR_TRANSLUCENT = (1 << 21),
    MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = (1 << 22),
    MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING = (1 << 23), // OBSOLETE
    MATERIAL_VAR_OPAQUETEXTURE = (1 << 24),
    MATERIAL_VAR_ENVMAPMODE = (1 << 25), // OBSOLETE
    MATERIAL_VAR_SUPPRESS_DECALS = (1 << 26),
    MATERIAL_VAR_HALFLAMBERT = (1 << 27),
    MATERIAL_VAR_WIREFRAME = (1 << 28),
    MATERIAL_VAR_ALLOWALPHATOCOVERAGE = (1 << 29),
    MATERIAL_VAR_ALPHA_MODIFIED_BY_PROXY = (1 << 30),
    MATERIAL_VAR_VERTEXFOG = (1 << 31),
};

typedef unsigned short ModelInstanceHandle_t;
typedef void* LightCacheHandle_t;
typedef void* StudioDecalHandle_t;
typedef int OverrideType_t;
typedef int ImageFormat;
typedef int VertexFormat_t;
typedef int MaterialPropertyTypes_t;

class IClientRenderable;
class IMaterial;
class CStudioHdr;
class IMatRenderContext;
class DataCacheHandle_t;
class ITexture;
class IMaterialVar;
class KeyValues;
struct model_t;
struct mstudioanimdesc_t;
struct mstudioseqdesc_t;
struct Ray_t;
struct DrawModelInfo_t;
struct studiohwdata_t;
struct MaterialLightingState_t;
struct ColorMeshInfo_t;

struct DrawModelState_t
{
    studiohdr_t*            m_pStudioHdr;
    studiohwdata_t*         m_pStudioHWData;
    IClientRenderable*      m_pRenderable;
    const matrix3x4_t*      m_pModelToWorld;
    StudioDecalHandle_t     m_decals;
    int                     m_drawFlags;
    int                     m_lod;
};

struct StaticPropRenderInfo_t
{
    const matrix3x4_t*      pModelToWorld;
    const model_t*          pModel;
    IClientRenderable*      pRenderable;
    Vector*                 pLightingOrigin;
    short                   skin;
    ModelInstanceHandle_t   instance;
};

struct ModelRenderInfo_t
{
    Vector                  origin;
    QAngle                  angles;
	char                    pad[4];
    IClientRenderable*      pRenderable;
    const model_t*          pModel;
    const matrix3x4_t*      pModelToWorld;
    const matrix3x4_t*      pLightingOffset;
    const Vector*           pLightingOrigin;
    int                     flags;
    int                     entity_index;
    int                     skin;
    int                     body;
    int                     hitboxset;
    ModelInstanceHandle_t   instance;

    ModelRenderInfo_t()
    {
        pModelToWorld = NULL;
        pLightingOffset = NULL;
        pLightingOrigin = NULL;
    }
};

struct LightingQuery_t
{
    Vector                  m_LightingOrigin;
    ModelInstanceHandle_t   m_InstanceHandle;
    bool                    m_bAmbientBoost;
};

struct StaticLightingQuery_t : public LightingQuery_t
{
    IClientRenderable*        m_pRenderable;
};

class IMaterial
{
public:
    virtual const char*             GetName() const = 0;
    virtual const char*             GetTextureGroupName() const = 0;
    virtual PreviewImageRetVal_t    GetPreviewImageProperties(int *width, int *height, ImageFormat *imageFormat, bool* isTranslucent) const = 0;
    virtual PreviewImageRetVal_t    GetPreviewImage(unsigned char *data, int width, int height, ImageFormat imageFormat) const = 0;
    virtual int                     GetMappingWidth() = 0;
    virtual int                     GetMappingHeight() = 0;
    virtual int                     GetNumAnimationFrames() = 0;
    virtual bool                    InMaterialPage(void) = 0;
    virtual    void                 GetMaterialOffset(float *pOffset) = 0;
    virtual void                    GetMaterialScale(float *pScale) = 0;
    virtual IMaterial*              GetMaterialPage(void) = 0;
    virtual IMaterialVar*           FindVar(const char *varName, bool *found, bool complain = true) = 0;
    virtual void                    IncrementReferenceCount(void) = 0;
    virtual void                    DecrementReferenceCount(void) = 0;
    inline void                     AddRef() { IncrementReferenceCount(); }
    inline void                     Release() { DecrementReferenceCount(); }
    virtual int                     GetEnumerationID(void) const = 0;
    virtual void                    GetLowResColorSample(float s, float t, float *color) const = 0;
    virtual void                    RecomputeStateSnapshots() = 0;
    virtual bool                    IsTranslucent() = 0;
    virtual bool                    IsAlphaTested() = 0;
    virtual bool                    IsVertexLit() = 0;
    virtual VertexFormat_t          GetVertexFormat() const = 0;
    virtual bool                    HasProxy(void) const = 0;
    virtual bool                    UsesEnvCubemap(void) = 0;
    virtual bool                    NeedsTangentSpace(void) = 0;
    virtual bool                    NeedsPowerOfTwoFrameBufferTexture(bool bCheckSpecificToThisFrame = true) = 0;
    virtual bool                    NeedsFullFrameBufferTexture(bool bCheckSpecificToThisFrame = true) = 0;
    virtual bool                    NeedsSoftwareSkinning(void) = 0;
    virtual void                    AlphaModulate(float alpha) = 0;
    virtual void                    ColorModulate(float r, float g, float b) = 0;
    virtual void                    SetMaterialVarFlag(MaterialVarFlags_t flag, bool on) = 0;
    virtual bool                    GetMaterialVarFlag(MaterialVarFlags_t flag) const = 0;
    virtual void                    GetReflectivity(Vector& reflect) = 0;
    virtual bool                    GetPropertyFlag(MaterialPropertyTypes_t type) = 0;
    virtual bool                    IsTwoSided() = 0;
    virtual void                    SetShader(const char *pShaderName) = 0;
    virtual int                     GetNumPasses(void) = 0;
    virtual int                     GetTextureMemoryBytes(void) = 0;
    virtual void                    Refresh() = 0;
    virtual bool                    NeedsLightmapBlendAlpha(void) = 0;
    virtual bool                    NeedsSoftwareLighting(void) = 0;
    virtual int                     ShaderParamCount() const = 0;
    virtual IMaterialVar**          GetShaderParams(void) = 0;
    virtual bool                    IsErrorMaterial() const = 0;
    virtual void                    Unused() = 0;
    virtual float                   GetAlphaModulation() = 0;
    virtual void                    GetColorModulation(float *r, float *g, float *b) = 0;
    virtual bool                    IsTranslucentUnderModulation(float fAlphaModulation = 1.0f) const = 0;
    virtual IMaterialVar*           FindVarFast(char const *pVarName, unsigned int *pToken) = 0;
    virtual void                    SetShaderAndParams(KeyValues *pKeyValues) = 0;
    virtual const char*             GetShaderName() const = 0;
    virtual void                    DeleteIfUnreferenced() = 0;
    virtual bool                    IsSpriteCard() = 0;
    virtual void                    CallBindProxy(void *proxyData) = 0;
    virtual void                    RefreshPreservingMaterialVars() = 0;
    virtual bool                    WasReloadedFromWhitelist() = 0;
    virtual bool                    SetTempExcluded(bool bSet, int nExcludedDimensionLimit) = 0;
    virtual int                     GetReferenceCount() const = 0;
};

class IVModelRender
{
public:
    virtual int                     DrawModel(int flags, IClientRenderable *pRenderable, ModelInstanceHandle_t instance, int entity_index, const model_t *model, Vector const& origin, QAngle const& angles, int skin, int body, int hitboxset, const matrix3x4_t *modelToWorld = NULL, const matrix3x4_t *pLightingOffset = NULL) = 0;
    virtual void                    ForcedMaterialOverride(IMaterial *newMaterial, OverrideType_t nOverrideType = 0, int nOverrides = 0) = 0;
    virtual bool                    IsForcedMaterialOverride(void) = 0;
    virtual void                    SetViewTarget(const CStudioHdr *pStudioHdr, int nBodyIndex, const Vector& target) = 0;
    virtual ModelInstanceHandle_t   CreateInstance(IClientRenderable *pRenderable, LightCacheHandle_t *pCache = NULL) = 0;
    virtual void                    DestroyInstance(ModelInstanceHandle_t handle) = 0;
    virtual void                    SetStaticLighting(ModelInstanceHandle_t handle, LightCacheHandle_t* pHandle) = 0;
    virtual LightCacheHandle_t      GetStaticLighting(ModelInstanceHandle_t handle) = 0;
    virtual bool                    ChangeInstance(ModelInstanceHandle_t handle, IClientRenderable *pRenderable) = 0;
    virtual void                    AddDecal(ModelInstanceHandle_t handle, Ray_t const& ray, Vector const& decalUp, int decalIndex, int body, bool noPokeThru, int maxLODToDecal) = 0;
    virtual void                    RemoveAllDecals(ModelInstanceHandle_t handle) = 0;
    virtual bool                    ModelHasDecals(ModelInstanceHandle_t handle) = 0;
    virtual void                    RemoveAllDecalsFromAllModels() = 0;
    virtual matrix3x4_t*            DrawModelShadowSetup(IClientRenderable *pRenderable, int body, int skin, DrawModelInfo_t *pInfo, matrix3x4_t *pCustomBoneToWorld = NULL) = 0;
    virtual void                    DrawModelShadow(IClientRenderable *pRenderable, const DrawModelInfo_t &info, matrix3x4_t *pCustomBoneToWorld = NULL) = 0;
    virtual bool                    RecomputeStaticLighting(ModelInstanceHandle_t handle) = 0;
    virtual void                    ReleaseAllStaticPropColorData(void) = 0;
    virtual void                    RestoreAllStaticPropColorData(void) = 0;
    virtual int                     DrawModelEx(ModelRenderInfo_t &pInfo) = 0;
    virtual int                     DrawModelExStaticProp(ModelRenderInfo_t &pInfo) = 0;
    virtual bool                    DrawModelSetup(ModelRenderInfo_t &pInfo, DrawModelState_t *pState, matrix3x4_t **ppBoneToWorldOut) = 0;
    virtual void                    DrawModelExecute(IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& pInfo, matrix3x4_t* pCustomBoneToWorld = NULL) = 0;
    virtual void                    SetupLighting(const Vector &vecCenter) = 0;
    virtual int                     DrawStaticPropArrayFast(StaticPropRenderInfo_t *pProps, int count, bool bShadowDepth) = 0;
    virtual void                    SuppressEngineLighting(bool bSuppress) = 0;
    virtual void                    SetupColorMeshes(int nTotalVerts) = 0;
    virtual void                    SetupLightingEx(const Vector &vecCenter, ModelInstanceHandle_t handle) = 0;
    virtual bool                    GetBrightestShadowingLightSource(const Vector &vecCenter, Vector& lightPos, Vector& lightBrightness, bool bAllowNonTaggedLights) = 0;
    virtual void                    ComputeLightingState(int nCount, const LightingQuery_t *pQuery, MaterialLightingState_t *pState, ITexture **ppEnvCubemapTexture) = 0;
    virtual void                    GetModelDecalHandles(StudioDecalHandle_t *pDecals, int nDecalStride, int nCount, const ModelInstanceHandle_t *pHandles) = 0;
    virtual void                    ComputeStaticLightingState(int nCount, const StaticLightingQuery_t *pQuery, MaterialLightingState_t *pState, MaterialLightingState_t *pDecalState, ColorMeshInfo_t **ppStaticLighting, ITexture **ppEnvCubemapTexture, DataCacheHandle_t *pColorMeshHandles) = 0;
    virtual void                    CleanupStaticLightingState(int nCount, DataCacheHandle_t *pColorMeshHandles) = 0;
};

```

`CSGOSimple/valve_sdk/interfaces/IViewRender.hpp`:

```hpp
#pragma once

enum DrawFlags_t
{
    DF_RENDER_REFRACTION = 0x1,
    DF_RENDER_REFLECTION = 0x2,
    DF_CLIP_Z = 0x4,
    DF_CLIP_BELOW = 0x8,
    DF_RENDER_UNDERWATER = 0x10,
    DF_RENDER_ABOVEWATER = 0x20,
    DF_RENDER_WATER = 0x40,
    DF_UNUSED1 = 0x100,
    DF_WATERHEIGHT = 0x200,
    DF_UNUSED2 = 0x400,
    DF_DRAWSKYBOX = 0x800,
    DF_FUDGE_UP = 0x1000,
    DF_DRAW_ENTITITES = 0x2000,
    DF_UNUSED3 = 0x4000,
    DF_UNUSED4 = 0x8000,
    DF_UNUSED5 = 0x10000,
    DF_SAVEGAMESCREENSHOT = 0x20000,
    DF_CLIP_SKYBOX = 0x40000,
    DF_SHADOW_DEPTH_MAP = 0x100000	// Currently rendering a shadow depth map
};


//-----------------------------------------------------------------------------
// Purpose: View setup and rendering
//-----------------------------------------------------------------------------
class CViewSetup;
class C_BaseEntity;
struct vrect_t;
class C_BaseViewModel;
class IMaterial;

class IViewRender
{
public:
    virtual void                Init(void) = 0;
    virtual void                LevelInit(void) = 0;
    virtual void                LevelShutdown(void) = 0;
    virtual void                Shutdown(void) = 0;
    virtual void                OnRenderStart() = 0;
    virtual	void                Render(vrect_t *rect) = 0;
    virtual void                RenderView(const CViewSetup &view, int nClearFlags, int whatToDraw) = 0;
    virtual int                 GetDrawFlags() = 0;
    virtual void                StartPitchDrift(void) = 0;
    virtual void                StopPitchDrift(void) = 0;
    virtual void*               GetFrustum() = 0;
    virtual bool                ShouldDrawBrushModels(void) = 0;
    virtual const CViewSetup*   GetPlayerViewSetup(void) const = 0;
    virtual const CViewSetup*   GetViewSetup(void) const = 0;
    virtual void                DisableVis(void) = 0;
    virtual int                 BuildWorldListsNumber() const = 0;
    virtual void                SetCheapWaterStartDistance(float flCheapWaterStartDistance) = 0;
    virtual void                SetCheapWaterEndDistance(float flCheapWaterEndDistance) = 0;
    virtual void                GetWaterLODParams(float &flCheapWaterStartDistance, float &flCheapWaterEndDistance) = 0;
    virtual void                DriftPitch(void) = 0;
    virtual void                SetScreenOverlayMaterial(IMaterial *pMaterial) = 0;
    virtual IMaterial*          GetScreenOverlayMaterial() = 0;
    virtual void                WriteSaveGameScreenshot(const char *pFilename) = 0;
    virtual void                WriteSaveGameScreenshotOfSize(const char *pFilename, int width, int height) = 0;
    virtual void                QueueOverlayRenderView(const CViewSetup &view, int nClearFlags, int whatToDraw) = 0;
    virtual float               GetZNear() = 0;
    virtual float               GetZFar() = 0;
    virtual void                GetScreenFadeDistances(float *min, float *max) = 0;
    virtual C_BaseEntity*       GetCurrentlyDrawingEntity() = 0;
    virtual void                SetCurrentlyDrawingEntity(C_BaseEntity *pEnt) = 0;
};
```

`CSGOSimple/valve_sdk/math/QAngle.hpp`:

```hpp
#pragma once

class QAngle
{
public:
    QAngle(void)
    {
        Init();
    }
    QAngle(float X, float Y, float Z)
    {
        Init(X, Y, Z);
    }
    QAngle(const float* clr)
    {
        Init(clr[0], clr[1], clr[2]);
    }

    void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f)
    {
        pitch = ix;
        yaw = iy;
        roll = iz;
    }

    float operator[](int i) const
    {
        return ((float*)this)[i];
    }
    float& operator[](int i)
    {
        return ((float*)this)[i];
    }

    QAngle& operator+=(const QAngle& v)
    {
        pitch += v.pitch; yaw += v.yaw; roll += v.roll;
        return *this;
    }
    QAngle& operator-=(const QAngle& v)
    {
        pitch -= v.pitch; yaw -= v.yaw; roll -= v.roll;
        return *this;
    }
    QAngle& operator*=(float fl)
    {
        pitch *= fl;
        yaw *= fl;
        roll *= fl;
        return *this;
    }
    QAngle& operator*=(const QAngle& v)
    {
        pitch *= v.pitch;
        yaw *= v.yaw;
        roll *= v.roll;
        return *this;
    }
    QAngle& operator/=(const QAngle& v)
    {
        pitch /= v.pitch;
        yaw /= v.yaw;
        roll /= v.roll;
        return *this;
    }
    QAngle& operator+=(float fl)
    {
        pitch += fl;
        yaw += fl;
        roll += fl;
        return *this;
    }
    QAngle& operator/=(float fl)
    {
        pitch /= fl;
        yaw /= fl;
        roll /= fl;
        return *this;
    }
    QAngle& operator-=(float fl)
    {
        pitch -= fl;
        yaw -= fl;
        roll -= fl;
        return *this;
    }

    QAngle& operator=(const QAngle &vOther)
    {
        pitch = vOther.pitch; yaw = vOther.yaw; roll = vOther.roll;
        return *this;
    }

    QAngle operator-(void) const
    {
        return QAngle(-pitch, -yaw, -roll);
    }
    QAngle operator+(const QAngle& v) const
    {
        return QAngle(pitch + v.pitch, yaw + v.yaw, roll + v.roll);
    }
    QAngle operator-(const QAngle& v) const
    {
        return QAngle(pitch - v.pitch, yaw - v.yaw, roll - v.roll);
    }
    QAngle operator*(float fl) const
    {
        return QAngle(pitch * fl, yaw * fl, roll * fl);
    }
    QAngle operator*(const QAngle& v) const
    {
        return QAngle(pitch * v.pitch, yaw * v.yaw, roll * v.roll);
    }
    QAngle operator/(float fl) const
    {
        return QAngle(pitch / fl, yaw / fl, roll / fl);
    }
    QAngle operator/(const QAngle& v) const
    {
        return QAngle(pitch / v.pitch, yaw / v.yaw, roll / v.roll);
    }

    float Length() const
    {
        return sqrt(pitch*pitch + yaw*yaw + roll*roll);
    }
    float LengthSqr(void) const
    {
        return (pitch*pitch + yaw*yaw + roll*roll);
    }
    bool IsZero(float tolerance = 0.01f) const
    {
        return (pitch > -tolerance && pitch < tolerance &&
            yaw > -tolerance && yaw < tolerance &&
            roll > -tolerance && roll < tolerance);
    }

	float Normalize() const
	{
		QAngle res = *this;
		float l = res.Length();
		if (l != 0.0f)
		{
			res /= l;
		}
		else
		{
			res[0] = res[1] = res[2] = 0.0f;
		}
		return l;
	}

    float pitch;
    float yaw;
    float roll;
};

inline QAngle operator*(float lhs, const QAngle& rhs)
{
    return rhs * lhs;
}
inline QAngle operator/(float lhs, const QAngle& rhs)
{
    return rhs / lhs;
}

```

`CSGOSimple/valve_sdk/math/VMatrix.cpp`:

```cpp
#include "VMatrix.hpp"

//-----------------------------------------------------------------------------
// VMatrix inlines.
//-----------------------------------------------------------------------------
inline VMatrix::VMatrix()
{
}

inline VMatrix::VMatrix(
    float m00, float m01, float m02, float m03,
    float m10, float m11, float m12, float m13,
    float m20, float m21, float m22, float m23,
    float m30, float m31, float m32, float m33)
{
    Init(
        m00, m01, m02, m03,
        m10, m11, m12, m13,
        m20, m21, m22, m23,
        m30, m31, m32, m33
    );
}


inline VMatrix::VMatrix(const matrix3x4_t& matrix3x4)
{
    Init(matrix3x4);
}


//-----------------------------------------------------------------------------
// Creates a matrix where the X axis = forward
// the Y axis = left, and the Z axis = up
//-----------------------------------------------------------------------------
inline VMatrix::VMatrix(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis)
{
    Init(
        xAxis.x, yAxis.x, zAxis.x, 0.0f,
        xAxis.y, yAxis.y, zAxis.y, 0.0f,
        xAxis.z, yAxis.z, zAxis.z, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
    );
}


inline void VMatrix::Init(
    float m00, float m01, float m02, float m03,
    float m10, float m11, float m12, float m13,
    float m20, float m21, float m22, float m23,
    float m30, float m31, float m32, float m33
)
{
    m[0][0] = m00;
    m[0][1] = m01;
    m[0][2] = m02;
    m[0][3] = m03;

    m[1][0] = m10;
    m[1][1] = m11;
    m[1][2] = m12;
    m[1][3] = m13;

    m[2][0] = m20;
    m[2][1] = m21;
    m[2][2] = m22;
    m[2][3] = m23;

    m[3][0] = m30;
    m[3][1] = m31;
    m[3][2] = m32;
    m[3][3] = m33;
}


//-----------------------------------------------------------------------------
// Initialize from a 3x4
//-----------------------------------------------------------------------------
inline void VMatrix::Init(const matrix3x4_t& matrix3x4)
{
    memcpy(m, matrix3x4.Base(), sizeof(matrix3x4_t));

    m[3][0] = 0.0f;
    m[3][1] = 0.0f;
    m[3][2] = 0.0f;
    m[3][3] = 1.0f;
}

//-----------------------------------------------------------------------------
// Vector3DMultiplyPosition treats src2 as if it's a point (adds the translation)
//-----------------------------------------------------------------------------
// NJS: src2 is passed in as a full vector rather than a reference to prevent the need
// for 2 branches and a potential copy in the body.  (ie, handling the case when the src2
// reference is the same as the dst reference ).
inline void Vector3DMultiplyPosition(const VMatrix& src1, const Vector& src2, Vector& dst)
{
    dst[0] = src1[0][0] * src2.x + src1[0][1] * src2.y + src1[0][2] * src2.z + src1[0][3];
    dst[1] = src1[1][0] * src2.x + src1[1][1] * src2.y + src1[1][2] * src2.z + src1[1][3];
    dst[2] = src1[2][0] * src2.x + src1[2][1] * src2.y + src1[2][2] * src2.z + src1[2][3];
}

//-----------------------------------------------------------------------------
// Methods related to the basis vectors of the matrix
//-----------------------------------------------------------------------------

inline Vector VMatrix::GetForward() const
{
    return Vector(m[0][0], m[1][0], m[2][0]);
}

inline Vector VMatrix::GetLeft() const
{
    return Vector(m[0][1], m[1][1], m[2][1]);
}

inline Vector VMatrix::GetUp() const
{
    return Vector(m[0][2], m[1][2], m[2][2]);
}

inline void VMatrix::SetForward(const Vector &vForward)
{
    m[0][0] = vForward.x;
    m[1][0] = vForward.y;
    m[2][0] = vForward.z;
}

inline void VMatrix::SetLeft(const Vector &vLeft)
{
    m[0][1] = vLeft.x;
    m[1][1] = vLeft.y;
    m[2][1] = vLeft.z;
}

inline void VMatrix::SetUp(const Vector &vUp)
{
    m[0][2] = vUp.x;
    m[1][2] = vUp.y;
    m[2][2] = vUp.z;
}

inline void VMatrix::GetBasisVectors(Vector &vForward, Vector &vLeft, Vector &vUp) const
{
    vForward.Init(m[0][0], m[1][0], m[2][0]);
    vLeft.Init(m[0][1], m[1][1], m[2][1]);
    vUp.Init(m[0][2], m[1][2], m[2][2]);
}

inline void VMatrix::SetBasisVectors(const Vector &vForward, const Vector &vLeft, const Vector &vUp)
{
    SetForward(vForward);
    SetLeft(vLeft);
    SetUp(vUp);
}


//-----------------------------------------------------------------------------
// Methods related to the translation component of the matrix
//-----------------------------------------------------------------------------

inline Vector VMatrix::GetTranslation() const
{
    return Vector(m[0][3], m[1][3], m[2][3]);
}

inline Vector& VMatrix::GetTranslation(Vector &vTrans) const
{
    vTrans.x = m[0][3];
    vTrans.y = m[1][3];
    vTrans.z = m[2][3];
    return vTrans;
}

inline void VMatrix::SetTranslation(const Vector &vTrans)
{
    m[0][3] = vTrans.x;
    m[1][3] = vTrans.y;
    m[2][3] = vTrans.z;
}


//-----------------------------------------------------------------------------
// appply translation to this matrix in the input space
//-----------------------------------------------------------------------------
inline void VMatrix::PreTranslate(const Vector &vTrans)
{
    Vector tmp;
    Vector3DMultiplyPosition(*this, vTrans, tmp);
    m[0][3] = tmp.x;
    m[1][3] = tmp.y;
    m[2][3] = tmp.z;
}


//-----------------------------------------------------------------------------
// appply translation to this matrix in the output space
//-----------------------------------------------------------------------------
inline void VMatrix::PostTranslate(const Vector &vTrans)
{
    m[0][3] += vTrans.x;
    m[1][3] += vTrans.y;
    m[2][3] += vTrans.z;
}

inline const matrix3x4_t& VMatrix::As3x4() const
{
    return *((const matrix3x4_t*)this);
}

inline matrix3x4_t& VMatrix::As3x4()
{
    return *((matrix3x4_t*)this);
}

inline void VMatrix::CopyFrom3x4(const matrix3x4_t &m3x4)
{
    memcpy(m, m3x4.Base(), sizeof(matrix3x4_t));
    m[3][0] = m[3][1] = m[3][2] = 0;
    m[3][3] = 1;
}

inline void VMatrix::Set3x4(matrix3x4_t& matrix3x4) const
{
    memcpy(matrix3x4.Base(), m, sizeof(matrix3x4_t));
}


//-----------------------------------------------------------------------------
// Matrix Math operations
//-----------------------------------------------------------------------------
inline const VMatrix& VMatrix::operator+=(const VMatrix &other)
{
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            m[i][j] += other.m[i][j];
        }
    }

    return *this;
}

inline VMatrix VMatrix::operator+(const VMatrix &other) const
{
    VMatrix ret;
    for(int i = 0; i < 16; i++) {
        ((float*)ret.m)[i] = ((float*)m)[i] + ((float*)other.m)[i];
    }
    return ret;
}

inline VMatrix VMatrix::operator-(const VMatrix &other) const
{
    VMatrix ret;

    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            ret.m[i][j] = m[i][j] - other.m[i][j];
        }
    }

    return ret;
}

inline VMatrix VMatrix::operator-() const
{
    VMatrix ret;
    for(int i = 0; i < 16; i++) {
        ((float*)ret.m)[i] = -((float*)m)[i];
    }
    return ret;
}

//-----------------------------------------------------------------------------
// Vector transformation
//-----------------------------------------------------------------------------


inline Vector VMatrix::operator*(const Vector &vVec) const
{
    Vector vRet;
    vRet.x = m[0][0] * vVec.x + m[0][1] * vVec.y + m[0][2] * vVec.z + m[0][3];
    vRet.y = m[1][0] * vVec.x + m[1][1] * vVec.y + m[1][2] * vVec.z + m[1][3];
    vRet.z = m[2][0] * vVec.x + m[2][1] * vVec.y + m[2][2] * vVec.z + m[2][3];

    return vRet;
}

inline Vector VMatrix::VMul4x3(const Vector &vVec) const
{
    Vector vResult;
    Vector3DMultiplyPosition(*this, vVec, vResult);
    return vResult;
}


inline Vector VMatrix::VMul4x3Transpose(const Vector &vVec) const
{
    Vector tmp = vVec;
    tmp.x -= m[0][3];
    tmp.y -= m[1][3];
    tmp.z -= m[2][3];

    return Vector(
        m[0][0] * tmp.x + m[1][0] * tmp.y + m[2][0] * tmp.z,
        m[0][1] * tmp.x + m[1][1] * tmp.y + m[2][1] * tmp.z,
        m[0][2] * tmp.x + m[1][2] * tmp.y + m[2][2] * tmp.z
    );
}

inline Vector VMatrix::VMul3x3(const Vector &vVec) const
{
    return Vector(
        m[0][0] * vVec.x + m[0][1] * vVec.y + m[0][2] * vVec.z,
        m[1][0] * vVec.x + m[1][1] * vVec.y + m[1][2] * vVec.z,
        m[2][0] * vVec.x + m[2][1] * vVec.y + m[2][2] * vVec.z
    );
}

inline Vector VMatrix::VMul3x3Transpose(const Vector &vVec) const
{
    return Vector(
        m[0][0] * vVec.x + m[1][0] * vVec.y + m[2][0] * vVec.z,
        m[0][1] * vVec.x + m[1][1] * vVec.y + m[2][1] * vVec.z,
        m[0][2] * vVec.x + m[1][2] * vVec.y + m[2][2] * vVec.z
    );
}


inline void VMatrix::V3Mul(const Vector &vIn, Vector &vOut) const
{
    float rw;

    rw = 1.0f / (m[3][0] * vIn.x + m[3][1] * vIn.y + m[3][2] * vIn.z + m[3][3]);
    vOut.x = (m[0][0] * vIn.x + m[0][1] * vIn.y + m[0][2] * vIn.z + m[0][3]) * rw;
    vOut.y = (m[1][0] * vIn.x + m[1][1] * vIn.y + m[1][2] * vIn.z + m[1][3]) * rw;
    vOut.z = (m[2][0] * vIn.x + m[2][1] * vIn.y + m[2][2] * vIn.z + m[2][3]) * rw;
}

//-----------------------------------------------------------------------------
// Other random stuff
//-----------------------------------------------------------------------------
inline void VMatrix::Identity()
{
    m[0][0] = 1.0f; m[0][1] = 0.0f; m[0][2] = 0.0f; m[0][3] = 0.0f;
    m[1][0] = 0.0f; m[1][1] = 1.0f; m[1][2] = 0.0f; m[1][3] = 0.0f;
    m[2][0] = 0.0f; m[2][1] = 0.0f; m[2][2] = 1.0f; m[2][3] = 0.0f;
    m[3][0] = 0.0f; m[3][1] = 0.0f; m[3][2] = 0.0f; m[3][3] = 1.0f;
}


inline bool VMatrix::IsIdentity() const
{
    return
        m[0][0] == 1.0f && m[0][1] == 0.0f && m[0][2] == 0.0f && m[0][3] == 0.0f &&
        m[1][0] == 0.0f && m[1][1] == 1.0f && m[1][2] == 0.0f && m[1][3] == 0.0f &&
        m[2][0] == 0.0f && m[2][1] == 0.0f && m[2][2] == 1.0f && m[2][3] == 0.0f &&
        m[3][0] == 0.0f && m[3][1] == 0.0f && m[3][2] == 0.0f && m[3][3] == 1.0f;
}

inline Vector VMatrix::ApplyRotation(const Vector &vVec) const
{
    return VMul3x3(vVec);
}

```

`CSGOSimple/valve_sdk/math/VMatrix.hpp`:

```hpp
#pragma once

#include <limits>

#include "Vector.hpp"
#include "QAngle.hpp"

struct cplane_t
{
    Vector normal;
    float dist;
    uint8_t type;   // for fast side tests
    uint8_t signbits;  // signx + (signy<<1) + (signz<<1)
    uint8_t pad[2];

};

class matrix3x4_t
{
public:
    matrix3x4_t() {}
    matrix3x4_t(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23)
    {
        m_flMatVal[0][0] = m00; m_flMatVal[0][1] = m01; m_flMatVal[0][2] = m02; m_flMatVal[0][3] = m03;
        m_flMatVal[1][0] = m10; m_flMatVal[1][1] = m11; m_flMatVal[1][2] = m12; m_flMatVal[1][3] = m13;
        m_flMatVal[2][0] = m20; m_flMatVal[2][1] = m21; m_flMatVal[2][2] = m22; m_flMatVal[2][3] = m23;
    }
    //-----------------------------------------------------------------------------
    // Creates a matrix where the X axis = forward
    // the Y axis = left, and the Z axis = up
    //-----------------------------------------------------------------------------
    void Init(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector &vecOrigin)
    {
        m_flMatVal[0][0] = xAxis.x; m_flMatVal[0][1] = yAxis.x; m_flMatVal[0][2] = zAxis.x; m_flMatVal[0][3] = vecOrigin.x;
        m_flMatVal[1][0] = xAxis.y; m_flMatVal[1][1] = yAxis.y; m_flMatVal[1][2] = zAxis.y; m_flMatVal[1][3] = vecOrigin.y;
        m_flMatVal[2][0] = xAxis.z; m_flMatVal[2][1] = yAxis.z; m_flMatVal[2][2] = zAxis.z; m_flMatVal[2][3] = vecOrigin.z;
    }

    //-----------------------------------------------------------------------------
    // Creates a matrix where the X axis = forward
    // the Y axis = left, and the Z axis = up
    //-----------------------------------------------------------------------------
    matrix3x4_t(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector &vecOrigin)
    {
        Init(xAxis, yAxis, zAxis, vecOrigin);
    }

    inline void SetOrigin(Vector const & p)
    {
        m_flMatVal[0][3] = p.x;
        m_flMatVal[1][3] = p.y;
        m_flMatVal[2][3] = p.z;
    }

    inline void Invalidate(void)
    {
        for(int i = 0; i < 3; i++) {
            for(int j = 0; j < 4; j++) {
                m_flMatVal[i][j] = std::numeric_limits<float>::infinity();;
            }
        }
    }

    Vector GetXAxis()  const { return at(0); }
    Vector GetYAxis()  const { return at(1); }
    Vector GetZAxis()  const { return at(2); }
    Vector GetOrigin() const { return at(3); }

    Vector at(int i) const { return Vector{ m_flMatVal[0][i], m_flMatVal[1][i], m_flMatVal[2][i] }; }

    float *operator[](int i) { return m_flMatVal[i]; }
    const float *operator[](int i) const { return m_flMatVal[i]; }
    float *Base() { return &m_flMatVal[0][0]; }
    const float *Base() const { return &m_flMatVal[0][0]; }

    float m_flMatVal[3][4];
};
class VMatrix
{
public:

    VMatrix();
    VMatrix(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    );

    // Creates a matrix where the X axis = forward
    // the Y axis = left, and the Z axis = up
    VMatrix(const Vector& forward, const Vector& left, const Vector& up);

    // Construct from a 3x4 matrix
    VMatrix(const matrix3x4_t& matrix3x4);

    // Set the values in the matrix.
    void  Init(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    );


    // Initialize from a 3x4
    void  Init(const matrix3x4_t& matrix3x4);

    // array access
    inline float* operator[](int i)
    {
        return m[i];
    }

    inline const float* operator[](int i) const
    {
        return m[i];
    }

    // Get a pointer to m[0][0]
    inline float *Base()
    {
        return &m[0][0];
    }

    inline const float *Base() const
    {
        return &m[0][0];
    }

    void  SetLeft(const Vector &vLeft);
    void  SetUp(const Vector &vUp);
    void  SetForward(const Vector &vForward);

    void  GetBasisVectors(Vector &vForward, Vector &vLeft, Vector &vUp) const;
    void  SetBasisVectors(const Vector &vForward, const Vector &vLeft, const Vector &vUp);

    // Get/Set the translation.
    Vector & GetTranslation(Vector &vTrans) const;
    void  SetTranslation(const Vector &vTrans);

    void  PreTranslate(const Vector &vTrans);
    void  PostTranslate(const Vector &vTrans);

    matrix3x4_t& As3x4();
    const matrix3x4_t& As3x4() const;
    void  CopyFrom3x4(const matrix3x4_t &m3x4);
    void  Set3x4(matrix3x4_t& matrix3x4) const;

    bool  operator==(const VMatrix& src) const;
    bool  operator!=(const VMatrix& src) const { return !(*this == src); }

    // Access the basis vectors.
    Vector  GetLeft() const;
    Vector  GetUp() const;
    Vector  GetForward() const;
    Vector  GetTranslation() const;


    // Matrix->vector operations.
public:
    // Multiply by a 3D vector (same as operator*).
    void  V3Mul(const Vector &vIn, Vector &vOut) const;

    // Multiply by a 4D vector.
    //void  V4Mul( const Vector4D &vIn, Vector4D &vOut ) const;

    // Applies the rotation (ignores translation in the matrix). (This just calls VMul3x3).
    Vector  ApplyRotation(const Vector &vVec) const;

    // Multiply by a vector (divides by w, assumes input w is 1).
    Vector  operator*(const Vector &vVec) const;

    // Multiply by the upper 3x3 part of the matrix (ie: only apply rotation).
    Vector  VMul3x3(const Vector &vVec) const;

    // Apply the inverse (transposed) rotation (only works on pure rotation matrix)
    Vector  VMul3x3Transpose(const Vector &vVec) const;

    // Multiply by the upper 3 rows.
    Vector  VMul4x3(const Vector &vVec) const;

    // Apply the inverse (transposed) transformation (only works on pure rotation/translation)
    Vector  VMul4x3Transpose(const Vector &vVec) const;


    // Matrix->plane operations.
    //public:
    // Transform the plane. The matrix can only contain translation and rotation.
    //void  TransformPlane( const VPlane &inPlane, VPlane &outPlane ) const;

    // Just calls TransformPlane and returns the result.
    //VPlane  operator*(const VPlane &thePlane) const;

    // Matrix->matrix operations.
public:

    VMatrix& operator=(const VMatrix &mOther);

    // Add two matrices.
    const VMatrix& operator+=(const VMatrix &other);

    // Add/Subtract two matrices.
    VMatrix  operator+(const VMatrix &other) const;
    VMatrix  operator-(const VMatrix &other) const;

    // Negation.
    VMatrix  operator-() const;

    // Return inverse matrix. Be careful because the results are undefined 
    // if the matrix doesn't have an inverse (ie: InverseGeneral returns false).
    VMatrix  operator~() const;

    // Matrix operations.
public:
    // Set to identity.
    void  Identity();
    bool  IsIdentity() const;
public:
    // The matrix.
    float  m[4][4];
};

inline void MatrixGetColumn(const matrix3x4_t &src, int nCol, Vector& pColumn)
{
    pColumn.x = src[0][nCol];
    pColumn.y = src[1][nCol];
    pColumn.z = src[2][nCol];
}

inline void MatrixPosition(const matrix3x4_t &matrix, Vector &position)
{
    MatrixGetColumn(matrix, 3, position);
}
```

`CSGOSimple/valve_sdk/math/Vector.hpp`:

```hpp
#pragma once

#include <sstream>

class Vector
{
public:
    Vector(void)
    {
        Invalidate();
    }
    Vector(float X, float Y, float Z)
    {
        x = X;
        y = Y;
        z = Z;
    }
    Vector(const float* clr)
    {
        x = clr[0];
        y = clr[1];
        z = clr[2];
    }

    void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f)
    {
        x = ix; y = iy; z = iz;
    }
    bool IsValid() const
    {
        return std::isfinite(x) && std::isfinite(y) && std::isfinite(z);
    }
    void Invalidate()
    {
        x = y = z = std::numeric_limits<float>::infinity();
    }

    float& operator[](int i)
    {
        return ((float*)this)[i];
    }
    float operator[](int i) const
    {
        return ((float*)this)[i];
    }

    void Zero()
    {
        x = y = z = 0.0f;
    }

    bool operator==(const Vector& src) const
    {
        return (src.x == x) && (src.y == y) && (src.z == z);
    }
    bool operator!=(const Vector& src) const
    {
        return (src.x != x) || (src.y != y) || (src.z != z);
    }

    Vector& operator+=(const Vector& v)
    {
        x += v.x; y += v.y; z += v.z;
        return *this;
    }
    Vector& operator-=(const Vector& v)
    {
        x -= v.x; y -= v.y; z -= v.z;
        return *this;
    }
    Vector& operator*=(float fl)
    {
        x *= fl;
        y *= fl;
        z *= fl;
        return *this;
    }
    Vector& operator*=(const Vector& v)
    {
        x *= v.x;
        y *= v.y;
        z *= v.z;
        return *this;
    }
    Vector& operator/=(const Vector& v)
    {
        x /= v.x;
        y /= v.y;
        z /= v.z;
        return *this;
    }
    Vector& operator+=(float fl)
    {
        x += fl;
        y += fl;
        z += fl;
        return *this;
    }
    Vector& operator/=(float fl)
    {
        x /= fl;
        y /= fl;
        z /= fl;
        return *this;
    }
    Vector& operator-=(float fl)
    {
        x -= fl;
        y -= fl;
        z -= fl;
        return *this;
    }

    void NormalizeInPlace()
    {
        *this = Normalized();
    }
    Vector Normalized() const
    {
        Vector res = *this;
        float l = res.Length();
        if(l != 0.0f) {
            res /= l;
        } else {
            res.x = res.y = res.z = 0.0f;
        }
        return res;
    }

    float DistTo(const Vector &vOther) const
    {
        Vector delta;

        delta.x = x - vOther.x;
        delta.y = y - vOther.y;
        delta.z = z - vOther.z;

        return delta.Length();
    }
    float DistToSqr(const Vector &vOther) const
    {
        Vector delta;

        delta.x = x - vOther.x;
        delta.y = y - vOther.y;
        delta.z = z - vOther.z;

        return delta.LengthSqr();
    }
    float Dot(const Vector& vOther) const
    {
        return (x*vOther.x + y*vOther.y + z*vOther.z);
    }
    float Length() const
    {
        return sqrt(x*x + y*y + z*z);
    }
    float LengthSqr(void) const
    {
        return (x*x + y*y + z*z);
    }
    float Length2D() const
    {
        return sqrt(x*x + y*y);
    }

    Vector& operator=(const Vector &vOther)
    {
        x = vOther.x; y = vOther.y; z = vOther.z;
        return *this;
    }

    Vector Vector::operator-(void) const
    {
        return Vector(-x, -y, -z);
    }
    Vector Vector::operator+(const Vector& v) const
    {
        return Vector(x + v.x, y + v.y, z + v.z);
    }
    Vector Vector::operator-(const Vector& v) const
    {
        return Vector(x - v.x, y - v.y, z - v.z);
    }
    Vector Vector::operator*(float fl) const
    {
        return Vector(x * fl, y * fl, z * fl);
    }
    Vector Vector::operator*(const Vector& v) const
    {
        return Vector(x * v.x, y * v.y, z * v.z);
    }
    Vector Vector::operator/(float fl) const
    {
        return Vector(x / fl, y / fl, z / fl);
    }
    Vector Vector::operator/(const Vector& v) const
    {
        return Vector(x / v.x, y / v.y, z / v.z);
    }

    float x, y, z;
};

inline Vector operator*(float lhs, const Vector& rhs)
{
    return rhs * lhs;
}
inline Vector operator/(float lhs, const Vector& rhs)
{
    return rhs / lhs;
}

class __declspec(align(16)) VectorAligned : public Vector
{
public:
    inline VectorAligned(void) {};
    inline VectorAligned(float X, float Y, float Z)
    {
        Init(X, Y, Z);
    }

public:
    explicit VectorAligned(const Vector &vOther)
    {
        Init(vOther.x, vOther.y, vOther.z);
    }

    VectorAligned& operator=(const Vector &vOther)
    {
        Init(vOther.x, vOther.y, vOther.z);
        return *this;
    }

    VectorAligned& operator=(const VectorAligned &vOther)
    {
        Init(vOther.x, vOther.y, vOther.z);
        return *this;
    }

    float w;
};
```

`CSGOSimple/valve_sdk/math/Vector2D.cpp`:

```cpp
#include <cmath>

#include "Vector2D.hpp"

Vector2D::Vector2D(void)
{
}

Vector2D::Vector2D(vec_t X, vec_t Y)
{
    x = X; y = Y;
}

Vector2D::Vector2D(vec_t* clr)
{
    x = clr[0]; y = clr[1];
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------

void Vector2D::Init(vec_t ix, vec_t iy)
{
    x = ix; y = iy;
}

void Vector2D::Random(float minVal, float maxVal)
{
    x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
    y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
}

void Vector2DClear(Vector2D& a)
{
    a.x = a.y = 0.0f;
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

Vector2D& Vector2D::operator=(const Vector2D &vOther)
{
    x = vOther.x; y = vOther.y;
    return *this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------

vec_t& Vector2D::operator[](int i)
{
    return ((vec_t*)this)[i];
}

vec_t Vector2D::operator[](int i) const
{
    return ((vec_t*)this)[i];
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------

vec_t* Vector2D::Base()
{
    return (vec_t*)this;
}

vec_t const* Vector2D::Base() const
{
    return (vec_t const*)this;
}

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

bool Vector2D::IsValid() const
{
    return !isinf(x) && !isinf(y);
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

bool Vector2D::operator==(const Vector2D& src) const
{
    return (src.x == x) && (src.y == y);
}

bool Vector2D::operator!=(const Vector2D& src) const
{
    return (src.x != x) || (src.y != y);
}


//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------

void Vector2DCopy(const Vector2D& src, Vector2D& dst)
{
    dst.x = src.x;
    dst.y = src.y;
}

void Vector2D::CopyToArray(float* rgfl) const
{
    rgfl[0] = x; rgfl[1] = y;
}

//-----------------------------------------------------------------------------
// standard Math operations
//-----------------------------------------------------------------------------

void Vector2D::Negate()
{
    x = -x; y = -y;
}

void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
    c.x = a.x + b.x;
    c.y = a.y + b.y;
}

void Vector2DSubtract(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
    c.x = a.x - b.x;
    c.y = a.y - b.y;
}

void Vector2DMultiply(const Vector2D& a, vec_t b, Vector2D& c)
{
    c.x = a.x * b;
    c.y = a.y * b;
}

void Vector2DMultiply(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
    c.x = a.x * b.x;
    c.y = a.y * b.y;
}


void Vector2DDivide(const Vector2D& a, vec_t b, Vector2D& c)
{
    vec_t oob = 1.0f / b;
    c.x = a.x * oob;
    c.y = a.y * oob;
}

void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
    c.x = a.x / b.x;
    c.y = a.y / b.y;
}

void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir, Vector2D& result)
{
    result.x = start.x + s*dir.x;
    result.y = start.y + s*dir.y;
}

// FIXME: Remove
// For backwards compatability
void Vector2D::MulAdd(const Vector2D& a, const Vector2D& b, float scalar)
{
    x = a.x + b.x * scalar;
    y = a.y + b.y * scalar;
}

void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, vec_t t, Vector2D& dest)
{
    dest[0] = src1[0] + (src2[0] - src1[0]) * t;
    dest[1] = src1[1] + (src2[1] - src1[1]) * t;
}

//-----------------------------------------------------------------------------
// dot, cross
//-----------------------------------------------------------------------------
vec_t DotProduct2D(const Vector2D& a, const Vector2D& b)
{
    return(a.x*b.x + a.y*b.y);
}

// for backwards compatability
vec_t Vector2D::Dot(const Vector2D& vOther) const
{
    return DotProduct2D(*this, vOther);
}

vec_t Vector2DNormalize(Vector2D& v)
{
    vec_t l = v.Length();
    if(l != 0.0f) {
        v /= l;
    } else {
        v.x = v.y = 0.0f;
    }
    return l;
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
vec_t Vector2DLength(const Vector2D& v)
{
    return (vec_t)sqrt(v.x*v.x + v.y*v.y);
}

vec_t Vector2D::NormalizeInPlace()
{
    return Vector2DNormalize(*this);
}

bool Vector2D::IsLengthGreaterThan(float val) const
{
    return LengthSqr() > val*val;
}

bool Vector2D::IsLengthLessThan(float val) const
{
    return LengthSqr() < val*val;
}

vec_t Vector2D::Length(void) const
{
    return Vector2DLength(*this);
}


void Vector2DMin(const Vector2D &a, const Vector2D &b, Vector2D &result)
{
    result.x = (a.x < b.x) ? a.x : b.x;
    result.y = (a.y < b.y) ? a.y : b.y;
}


void Vector2DMax(const Vector2D &a, const Vector2D &b, Vector2D &result)
{
    result.x = (a.x > b.x) ? a.x : b.x;
    result.y = (a.y > b.y) ? a.y : b.y;
}

//-----------------------------------------------------------------------------
// Computes the closest point to vecTarget no farther than flMaxDist from vecStart
//-----------------------------------------------------------------------------
void ComputeClosestPoint2D(const Vector2D& vecStart, float flMaxDist, const Vector2D& vecTarget, Vector2D *pResult)
{
    Vector2D vecDelta;
    Vector2DSubtract(vecTarget, vecStart, vecDelta);
    float flDistSqr = vecDelta.LengthSqr();
    if(flDistSqr <= flMaxDist * flMaxDist) {
        *pResult = vecTarget;
    } else {
        vecDelta /= sqrt(flDistSqr);
        Vector2DMA(vecStart, flMaxDist, vecDelta, *pResult);
    }
}

//-----------------------------------------------------------------------------
// Returns a Vector2D with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------

Vector2D Vector2D::Min(const Vector2D &vOther) const
{
    return Vector2D(x < vOther.x ? x : vOther.x, y < vOther.y ? y : vOther.y);
}

Vector2D Vector2D::Max(const Vector2D &vOther) const
{
    return Vector2D(x > vOther.x ? x : vOther.x, y > vOther.y ? y : vOther.y);
}


//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

Vector2D Vector2D::operator-(void) const
{
    return Vector2D(-x, -y);
}

Vector2D Vector2D::operator+(const Vector2D& v) const
{
    Vector2D res;
    Vector2DAdd(*this, v, res);
    return res;
}

Vector2D Vector2D::operator-(const Vector2D& v) const
{
    Vector2D res;
    Vector2DSubtract(*this, v, res);
    return res;
}

Vector2D Vector2D::operator*(float fl) const
{
    Vector2D res;
    Vector2DMultiply(*this, fl, res);
    return res;
}

Vector2D Vector2D::operator*(const Vector2D& v) const
{
    Vector2D res;
    Vector2DMultiply(*this, v, res);
    return res;
}

Vector2D Vector2D::operator/(float fl) const
{
    Vector2D res;
    Vector2DDivide(*this, fl, res);
    return res;
}

Vector2D Vector2D::operator/(const Vector2D& v) const
{
    Vector2D res;
    Vector2DDivide(*this, v, res);
    return res;
}

Vector2D operator*(float fl, const Vector2D& v)
{
    return v * fl;
}
```

`CSGOSimple/valve_sdk/math/Vector2D.hpp`:

```hpp
#pragma once

typedef float vec_t;
// 2D Vector
class Vector2D
{
public:
    // Members
    vec_t x, y;

    // Construction/destruction:
    Vector2D(void);
    Vector2D(vec_t X, vec_t Y);
    Vector2D(vec_t* clr);

    Vector2D::Vector2D(const Vector2D &vOther)
    {
        x = vOther.x; y = vOther.y;
    }

    // Initialization
    void Init(vec_t ix = 0.0f, vec_t iy = 0.0f);
    // TODO (Ilya): Should there be an init that takes a single float for consistency?

    // Got any nasty NAN's?
    bool IsValid() const;
    void Invalidate();

    // array access...
    vec_t operator[](int i) const;
    vec_t& operator[](int i);

    // Base address...
    vec_t* Base();
    vec_t const* Base() const;

    // Initialization methods
    void Random(vec_t minVal, vec_t maxVal);
    void Zero(); ///< zero out a vector

                 // equality
    bool operator==(const Vector2D& v) const;
    bool operator!=(const Vector2D& v) const;

    // arithmetic operations
    Vector2D& operator+=(const Vector2D& v)
    {
        x += v.x; y += v.y;
        return *this;
    }

    Vector2D& operator-=(const Vector2D& v)
    {
        x -= v.x; y -= v.y;
        return *this;
    }

    Vector2D& operator*=(float fl)
    {
        x *= fl;
        y *= fl;
        return *this;
    }

    Vector2D& operator*=(const Vector2D& v)
    {
        x *= v.x;
        y *= v.y;
        return *this;
    }

    Vector2D& operator/=(const Vector2D& v)
    {
        x /= v.x;
        y /= v.y;
        return *this;
    }

    // this ought to be an opcode.
    Vector2D& operator+=(float fl)
    {
        x += fl;
        y += fl;
        return *this;
    }

    // this ought to be an opcode.
    Vector2D& operator/=(float fl)
    {
        x /= fl;
        y /= fl;
        return *this;
    }
    Vector2D& operator-=(float fl)
    {
        x -= fl;
        y -= fl;
        return *this;
    }

    // negate the vector components
    void Negate();

    // Get the vector's magnitude.
    vec_t Length() const;

    // Get the vector's magnitude squared.
    vec_t LengthSqr(void) const
    {
        return (x*x + y*y);
    }

    // return true if this vector is (0,0,0) within tolerance
    bool IsZero(float tolerance = 0.01f) const
    {
        return (x > -tolerance && x < tolerance &&
            y > -tolerance && y < tolerance);
    }

    vec_t NormalizeInPlace();
    Vector2D Normalized() const;
    bool IsLengthGreaterThan(float val) const;
    bool IsLengthLessThan(float val) const;

    // check if a vector is within the box defined by two other vectors
    bool WithinAABox(Vector2D const &boxmin, Vector2D const &boxmax);

    // Get the distance from this vector to the other one.
    vec_t DistTo(const Vector2D &vOther) const;

    // Get the distance from this vector to the other one squared.
    // NJS: note, VC wasn't inlining it correctly in several deeply nested inlines due to being an 'out of line' .  
    // may be able to tidy this up after switching to VC7
    vec_t DistToSqr(const Vector2D &vOther) const
    {
        Vector2D delta;

        delta.x = x - vOther.x;
        delta.y = y - vOther.y;

        return delta.LengthSqr();
    }

    // Copy
    void CopyToArray(float* rgfl) const;

    // Multiply, add, and assign to this (ie: *this = a + b * scalar). This
    // is about 12% faster than the actual vector equation (because it's done per-component
    // rather than per-vector).
    void MulAdd(const Vector2D& a, const Vector2D& b, float scalar);

    // Dot product.
    vec_t Dot(const Vector2D& vOther) const;

    // assignment
    Vector2D& operator=(const Vector2D &vOther);

    // 2d
    vec_t Length2D(void) const;
    vec_t Length2DSqr(void) const;

    /// Get the component of this vector parallel to some other given vector
    Vector2D  ProjectOnto(const Vector2D& onto);

    // copy constructors
    // Vector2D(const Vector2D &vOther);

    // arithmetic operations
    Vector2D operator-(void) const;

    Vector2D operator+(const Vector2D& v) const;
    Vector2D operator-(const Vector2D& v) const;
    Vector2D operator*(const Vector2D& v) const;
    Vector2D operator/(const Vector2D& v) const;
    Vector2D operator*(float fl) const;
    Vector2D operator/(float fl) const;

    // Cross product between two vectors.
    Vector2D Cross(const Vector2D &vOther) const;

    // Returns a vector with the min or max in X, Y, and Z.
    Vector2D Min(const Vector2D &vOther) const;
    Vector2D Max(const Vector2D &vOther) const;
};
```

`CSGOSimple/valve_sdk/math/Vector4D.cpp`:

```cpp
#include "Vector4D.hpp"

#include <cmath>
#include <limits>

void VectorCopy(const Vector4D& src, Vector4D& dst)
{
    dst.x = src.x;
    dst.y = src.y;
    dst.z = src.z;
    dst.w = src.w;
}
void VectorLerp(const Vector4D& src1, const Vector4D& src2, vec_t t, Vector4D& dest)
{
    dest.x = src1.x + (src2.x - src1.x) * t;
    dest.y = src1.y + (src2.y - src1.y) * t;
    dest.z = src1.z + (src2.z - src1.z) * t;
    dest.w = src1.w + (src2.w - src1.w) * t;
}
float VectorLength(const Vector4D& v)
{
    return sqrt(v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w);
}

vec_t NormalizeVector(Vector4D& v)
{
    vec_t l = v.Length();
    if(l != 0.0f) {
        v /= l;
    } else {
        v.x = v.y = v.z = v.w = 0.0f;
    }
    return l;
}

Vector4D::Vector4D(void)
{
    Invalidate();
}
Vector4D::Vector4D(vec_t X, vec_t Y, vec_t Z, vec_t W)
{
    x = X;
    y = Y;
    z = Z;
    w = W;
}
Vector4D::Vector4D(vec_t* clr)
{
    x = clr[0];
    y = clr[1];
    z = clr[2];
    w = clr[3];
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------

void Vector4D::Init(vec_t ix, vec_t iy, vec_t iz, vec_t iw)
{
    x = ix; y = iy; z = iz; w = iw;
}

void Vector4D::Random(vec_t minVal, vec_t maxVal)
{
    x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
    y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
    z = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
    w = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
}

// This should really be a single opcode on the PowerPC (move r0 onto the vec reg)
void Vector4D::Zero()
{
    x = y = z = w = 0.0f;
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

Vector4D& Vector4D::operator=(const Vector4D &vOther)
{
    x = vOther.x; y = vOther.y; z = vOther.z; w = vOther.w;
    return *this;
}


//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------
vec_t& Vector4D::operator[](int i)
{
    return ((vec_t*)this)[i];
}

vec_t Vector4D::operator[](int i) const
{
    return ((vec_t*)this)[i];
}


//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
vec_t* Vector4D::Base()
{
    return (vec_t*)this;
}

vec_t const* Vector4D::Base() const
{
    return (vec_t const*)this;
}

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

bool Vector4D::IsValid() const
{
    return !isinf(x) && !isinf(y) && !isinf(z) && !isinf(w);
}

//-----------------------------------------------------------------------------
// Invalidate
//-----------------------------------------------------------------------------

void Vector4D::Invalidate()
{
    //#ifdef _DEBUG
    //#ifdef VECTOR_PARANOIA
    x = y = z = w = std::numeric_limits<float>::infinity();
    //#endif
    //#endif
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

bool Vector4D::operator==(const Vector4D& src) const
{
    return (src.x == x) && (src.y == y) && (src.z == z) && (src.w == w);
}

bool Vector4D::operator!=(const Vector4D& src) const
{
    return (src.x != x) || (src.y != y) || (src.z != z) || (src.w != w);
}


//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------
void Vector4D::CopyToArray(float* rgfl) const
{
    rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; rgfl[3] = w;
}

//-----------------------------------------------------------------------------
// standard Math operations
//-----------------------------------------------------------------------------
// #pragma message("TODO: these should be SSE")

void Vector4D::Negate()
{
    x = -x; y = -y; z = -z; w = -w;
}

// Get the component of this vector parallel to some other given vector
Vector4D Vector4D::ProjectOnto(const Vector4D& onto)
{
    return onto * (this->Dot(onto) / (onto.LengthSqr()));
}

// FIXME: Remove
// For backwards compatability
void Vector4D::MulAdd(const Vector4D& a, const Vector4D& b, float scalar)
{
    x = a.x + b.x * scalar;
    y = a.y + b.y * scalar;
    z = a.z + b.z * scalar;
    w = a.w + b.w * scalar;
}

Vector4D VectorLerp(const Vector4D& src1, const Vector4D& src2, vec_t t)
{
    Vector4D result;
    VectorLerp(src1, src2, t, result);
    return result;
}

vec_t Vector4D::Dot(const Vector4D& b) const
{
    return (x*b.x + y*b.y + z*b.z + w*b.w);
}
void VectorClear(Vector4D& a)
{
    a.x = a.y = a.z = a.w = 0.0f;
}

vec_t Vector4D::Length(void) const
{
    return sqrt(x*x + y*y + z*z + w*w);
}

// check a point against a box
bool Vector4D::WithinAABox(Vector4D const &boxmin, Vector4D const &boxmax)
{
    return (
        (x >= boxmin.x) && (x <= boxmax.x) &&
        (y >= boxmin.y) && (y <= boxmax.y) &&
        (z >= boxmin.z) && (z <= boxmax.z) &&
        (w >= boxmin.w) && (w <= boxmax.w)
        );
}

//-----------------------------------------------------------------------------
// Get the distance from this vector to the other one 
//-----------------------------------------------------------------------------
vec_t Vector4D::DistTo(const Vector4D &vOther) const
{
    Vector4D delta;
    delta = *this - vOther;
    return delta.Length();
}

//-----------------------------------------------------------------------------
// Returns a vector with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------
Vector4D Vector4D::Min(const Vector4D &vOther) const
{
    return Vector4D(x < vOther.x ? x : vOther.x,
        y < vOther.y ? y : vOther.y,
        z < vOther.z ? z : vOther.z,
        w < vOther.w ? w : vOther.w);
}

Vector4D Vector4D::Max(const Vector4D &vOther) const
{
    return Vector4D(x > vOther.x ? x : vOther.x,
        y > vOther.y ? y : vOther.y,
        z > vOther.z ? z : vOther.z,
        w > vOther.w ? w : vOther.w);
}


//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

Vector4D Vector4D::operator-(void) const
{
    return Vector4D(-x, -y, -z, -w);
}

Vector4D Vector4D::operator+(const Vector4D& v) const
{
    return Vector4D(x + v.x, y + v.y, z + v.z, w + v.w);
}

Vector4D Vector4D::operator-(const Vector4D& v) const
{
    return Vector4D(x - v.x, y - v.y, z - v.z, w - v.w);
}

Vector4D Vector4D::operator*(float fl) const
{
    return Vector4D(x * fl, y * fl, z * fl, w * fl);
}

Vector4D Vector4D::operator*(const Vector4D& v) const
{
    return Vector4D(x * v.x, y * v.y, z * v.z, w * v.w);
}

Vector4D Vector4D::operator/(float fl) const
{
    return Vector4D(x / fl, y / fl, z / fl, w / fl);
}

Vector4D Vector4D::operator/(const Vector4D& v) const
{
    return Vector4D(x / v.x, y / v.y, z / v.z, w / v.w);
}

Vector4D operator*(float fl, const Vector4D& v)
{
    return v * fl;
}
```

`CSGOSimple/valve_sdk/math/Vector4D.hpp`:

```hpp
#pragma once

typedef float vec_t;
// 3D Vector4D
class Vector4D
{
public:
    // Members
    vec_t x, y, z, w;

    // Construction/destruction:
    Vector4D(void);
    Vector4D(vec_t X, vec_t Y, vec_t Z, vec_t W);
    Vector4D(vec_t* clr);

    // Initialization
    void Init(vec_t ix = 0.0f, vec_t iy = 0.0f, vec_t iz = 0.0f, vec_t iw = 0.0f);
    // TODO (Ilya): Should there be an init that takes a single float for consistency?

    // Got any nasty NAN's?
    bool IsValid() const;
    void Invalidate();

    // array access...
    vec_t operator[](int i) const;
    vec_t& operator[](int i);

    // Base address...
    vec_t* Base();
    vec_t const* Base() const;

    // Initialization methods
    void Random(vec_t minVal, vec_t maxVal);
    void Zero(); ///< zero out a vector

                 // equality
    bool operator==(const Vector4D& v) const;
    bool operator!=(const Vector4D& v) const;

    // arithmetic operations
    Vector4D& operator+=(const Vector4D& v)
    {
        x += v.x; y += v.y; z += v.z; w += v.w;
        return *this;
    }

    Vector4D& operator-=(const Vector4D& v)
    {
        x -= v.x; y -= v.y; z -= v.z; w -= v.w;
        return *this;
    }

    Vector4D& operator*=(float fl)
    {
        x *= fl;
        y *= fl;
        z *= fl;
        w *= fl;
        return *this;
    }

    Vector4D& operator*=(const Vector4D& v)
    {
        x *= v.x;
        y *= v.y;
        z *= v.z;
        w *= v.w;
        return *this;
    }

    Vector4D& operator/=(const Vector4D& v)
    {
        x /= v.x;
        y /= v.y;
        z /= v.z;
        w /= v.w;
        return *this;
    }

    // this ought to be an opcode.
    Vector4D& operator+=(float fl)
    {
        x += fl;
        y += fl;
        z += fl;
        w += fl;
        return *this;
    }

    // this ought to be an opcode.
    Vector4D& operator/=(float fl)
    {
        x /= fl;
        y /= fl;
        z /= fl;
        w /= fl;
        return *this;
    }
    Vector4D& operator-=(float fl)
    {
        x -= fl;
        y -= fl;
        z -= fl;
        w -= fl;
        return *this;
    }

    // negate the vector components
    void Negate();

    // Get the vector's magnitude.
    vec_t Length() const;

    // Get the vector's magnitude squared.
    vec_t LengthSqr(void) const
    {
        return (x*x + y*y + z*z);
    }

    // return true if this vector is (0,0,0) within tolerance
    bool IsZero(float tolerance = 0.01f) const
    {
        return (x > -tolerance && x < tolerance &&
            y > -tolerance && y < tolerance &&
            z > -tolerance && z < tolerance &&
            w > -tolerance && w < tolerance);
    }

    vec_t NormalizeInPlace();
    Vector4D Normalized() const;
    bool IsLengthGreaterThan(float val) const;
    bool IsLengthLessThan(float val) const;

    // check if a vector is within the box defined by two other vectors
    bool WithinAABox(Vector4D const &boxmin, Vector4D const &boxmax);

    // Get the distance from this vector to the other one.
    vec_t DistTo(const Vector4D &vOther) const;

    // Get the distance from this vector to the other one squared.
    // NJS: note, VC wasn't inlining it correctly in several deeply nested inlines due to being an 'out of line' .  
    // may be able to tidy this up after switching to VC7
    vec_t DistToSqr(const Vector4D &vOther) const
    {
        Vector4D delta;

        delta.x = x - vOther.x;
        delta.y = y - vOther.y;
        delta.z = z - vOther.z;
        delta.w = w - vOther.w;

        return delta.LengthSqr();
    }

    // Copy
    void CopyToArray(float* rgfl) const;

    // Multiply, add, and assign to this (ie: *this = a + b * scalar). This
    // is about 12% faster than the actual vector equation (because it's done per-component
    // rather than per-vector).
    void MulAdd(const Vector4D& a, const Vector4D& b, float scalar);

    // Dot product.
    vec_t Dot(const Vector4D& vOther) const;

    // assignment
    Vector4D& operator=(const Vector4D &vOther);

    // 2d
    vec_t Length2D(void) const;
    vec_t Length2DSqr(void) const;

    /// Get the component of this vector parallel to some other given vector
    Vector4D  ProjectOnto(const Vector4D& onto);

    // copy constructors
    // Vector4D(const Vector4D &vOther);

    // arithmetic operations
    Vector4D operator-(void) const;

    Vector4D operator+(const Vector4D& v) const;
    Vector4D operator-(const Vector4D& v) const;
    Vector4D operator*(const Vector4D& v) const;
    Vector4D operator/(const Vector4D& v) const;
    Vector4D operator*(float fl) const;
    Vector4D operator/(float fl) const;

    // Returns a vector with the min or max in X, Y, and Z.
    Vector4D Min(const Vector4D &vOther) const;
    Vector4D Max(const Vector4D &vOther) const;
};
```

`CSGOSimple/valve_sdk/misc/BaseHandle.hpp`:

```hpp
#pragma once

#include "IHandleEntity.hpp"

#define NUM_ENT_ENTRY_BITS         (11 + 2)
#define NUM_ENT_ENTRIES            (1 << NUM_ENT_ENTRY_BITS)
#define INVALID_EHANDLE_INDEX       0xFFFFFFFF
#define NUM_SERIAL_NUM_BITS        16 // (32 - NUM_ENT_ENTRY_BITS)
#define NUM_SERIAL_NUM_SHIFT_BITS (32 - NUM_SERIAL_NUM_BITS)
#define ENT_ENTRY_MASK             (( 1 << NUM_SERIAL_NUM_BITS) - 1)

class IHandleEntity;

class CBaseHandle
{
public:
    CBaseHandle();
    CBaseHandle(const CBaseHandle &other);
    CBaseHandle(unsigned long value);
    CBaseHandle(int iEntry, int iSerialNumber);

    void Init(int iEntry, int iSerialNumber);
    void Term();

    // Even if this returns true, Get() still can return return a non-null value.
    // This just tells if the handle has been initted with any values.
    bool IsValid() const;

    int GetEntryIndex() const;
    int GetSerialNumber() const;

    int ToInt() const;
    bool operator !=(const CBaseHandle &other) const;
    bool operator ==(const CBaseHandle &other) const;
    bool operator ==(const IHandleEntity* pEnt) const;
    bool operator !=(const IHandleEntity* pEnt) const;
    bool operator <(const CBaseHandle &other) const;
    bool operator <(const IHandleEntity* pEnt) const;

    // Assign a value to the handle.
    const CBaseHandle& operator=(const IHandleEntity *pEntity);
    const CBaseHandle& Set(const IHandleEntity *pEntity);

    // Use this to dereference the handle.
    // Note: this is implemented in game code (ehandle.h)
    IHandleEntity* Get() const;

protected:
    // The low NUM_SERIAL_BITS hold the index. If this value is less than MAX_EDICTS, then the entity is networkable.
    // The high NUM_SERIAL_NUM_BITS bits are the serial number.
    unsigned long	m_Index;
};

inline CBaseHandle::CBaseHandle()
{
    m_Index = INVALID_EHANDLE_INDEX;
}

inline CBaseHandle::CBaseHandle(const CBaseHandle &other)
{
    m_Index = other.m_Index;
}

inline CBaseHandle::CBaseHandle(unsigned long value)
{
    m_Index = value;
}

inline CBaseHandle::CBaseHandle(int iEntry, int iSerialNumber)
{
    Init(iEntry, iSerialNumber);
}

inline void CBaseHandle::Init(int iEntry, int iSerialNumber)
{
    m_Index = iEntry | (iSerialNumber << NUM_ENT_ENTRY_BITS);
}

inline void CBaseHandle::Term()
{
    m_Index = INVALID_EHANDLE_INDEX;
}

inline bool CBaseHandle::IsValid() const
{
    return m_Index != INVALID_EHANDLE_INDEX;
}

inline int CBaseHandle::GetEntryIndex() const
{
    return m_Index & ENT_ENTRY_MASK;
}

inline int CBaseHandle::GetSerialNumber() const
{
    return m_Index >> NUM_ENT_ENTRY_BITS;
}

inline int CBaseHandle::ToInt() const
{
    return (int)m_Index;
}

inline bool CBaseHandle::operator !=(const CBaseHandle &other) const
{
    return m_Index != other.m_Index;
}

inline bool CBaseHandle::operator ==(const CBaseHandle &other) const
{
    return m_Index == other.m_Index;
}

inline bool CBaseHandle::operator ==(const IHandleEntity* pEnt) const
{
    return Get() == pEnt;
}

inline bool CBaseHandle::operator !=(const IHandleEntity* pEnt) const
{
    return Get() != pEnt;
}

inline bool CBaseHandle::operator <(const CBaseHandle &other) const
{
    return m_Index < other.m_Index;
}

inline bool CBaseHandle::operator <(const IHandleEntity *pEntity) const
{
    unsigned long otherIndex = (pEntity) ? pEntity->GetRefEHandle().m_Index : INVALID_EHANDLE_INDEX;
    return m_Index < otherIndex;
}

inline const CBaseHandle& CBaseHandle::operator=(const IHandleEntity *pEntity)
{
    return Set(pEntity);
}

inline const CBaseHandle& CBaseHandle::Set(const IHandleEntity *pEntity)
{
    if(pEntity) {
        *this = pEntity->GetRefEHandle();
    } else {
        m_Index = INVALID_EHANDLE_INDEX;
    }

    return *this;
}
```

`CSGOSimple/valve_sdk/misc/CUserCmd.hpp`:

```hpp
#pragma once

#include "checksum_crc.hpp"
#include "checksum_md5.hpp"
#include "../Math/QAngle.hpp"

#define IN_ATTACK  (1 << 0)
#define IN_JUMP   (1 << 1)
#define IN_DUCK   (1 << 2)
#define IN_FORWARD  (1 << 3)
#define IN_BACK   (1 << 4)
#define IN_USE   (1 << 5)
#define IN_CANCEL  (1 << 6)
#define IN_LEFT   (1 << 7)
#define IN_RIGHT  (1 << 8)
#define IN_MOVELEFT  (1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2  (1 << 11)
#define IN_RUN   (1 << 12)
#define IN_RELOAD  (1 << 13)
#define IN_ALT1   (1 << 14)
#define IN_ALT2   (1 << 15)
#define IN_SCORE  (1 << 16)   // Used by client.dll for when scoreboard is held down
#define IN_SPEED  (1 << 17) // Player is holding the speed key
#define IN_WALK   (1 << 18) // Player holding walk key
#define IN_ZOOM   (1 << 19) // Zoom key for HUD zoom
#define IN_WEAPON1  (1 << 20) // weapon defines these bits
#define IN_WEAPON2  (1 << 21) // weapon defines these bits
#define IN_BULLRUSH  (1 << 22)
#define IN_GRENADE1  (1 << 23) // grenade 1
#define IN_GRENADE2  (1 << 24) // grenade 2
#define IN_LOOKSPIN  (1 << 25)

class CUserCmd
{
public:
    CUserCmd()
    {
        memset(this, 0, sizeof(*this));
    };
    virtual ~CUserCmd() {};

    CRC32_t GetChecksum(void) const
    {
        CRC32_t crc;
        CRC32_Init(&crc);

        CRC32_ProcessBuffer(&crc, &command_number, sizeof(command_number));
        CRC32_ProcessBuffer(&crc, &tick_count, sizeof(tick_count));
        CRC32_ProcessBuffer(&crc, &viewangles, sizeof(viewangles));
        CRC32_ProcessBuffer(&crc, &aimdirection, sizeof(aimdirection));
        CRC32_ProcessBuffer(&crc, &forwardmove, sizeof(forwardmove));
        CRC32_ProcessBuffer(&crc, &sidemove, sizeof(sidemove));
        CRC32_ProcessBuffer(&crc, &upmove, sizeof(upmove));
        CRC32_ProcessBuffer(&crc, &buttons, sizeof(buttons));
        CRC32_ProcessBuffer(&crc, &impulse, sizeof(impulse));
        CRC32_ProcessBuffer(&crc, &weaponselect, sizeof(weaponselect));
        CRC32_ProcessBuffer(&crc, &weaponsubtype, sizeof(weaponsubtype));
        CRC32_ProcessBuffer(&crc, &random_seed, sizeof(random_seed));
        CRC32_ProcessBuffer(&crc, &mousedx, sizeof(mousedx));
        CRC32_ProcessBuffer(&crc, &mousedy, sizeof(mousedy));

        CRC32_Final(&crc);
        return crc;
    }

    int     command_number;     // 0x04 For matching server and client commands for debugging
    int     tick_count;         // 0x08 the tick the client created this command
    QAngle  viewangles;         // 0x0C Player instantaneous view angles.
    Vector  aimdirection;       // 0x18
    float   forwardmove;        // 0x24
    float   sidemove;           // 0x28
    float   upmove;             // 0x2C
    int     buttons;            // 0x30 Attack button states
    char    impulse;            // 0x34
    int     weaponselect;       // 0x38 Current weapon id
    int     weaponsubtype;      // 0x3C
    int     random_seed;        // 0x40 For shared random functions
    short   mousedx;            // 0x44 mouse accum in x from create move
    short   mousedy;            // 0x46 mouse accum in y from create move
    bool    hasbeenpredicted;   // 0x48 Client only, tracks whether we've predicted this command at least once
    char    pad_0x4C[0x18];     // 0x4C Current sizeof( usercmd ) =  100  = 0x64
};

class CVerifiedUserCmd
{
public:
    CUserCmd m_cmd;
    CRC32_t  m_crc;
};

```

`CSGOSimple/valve_sdk/misc/ClientClass.hpp`:

```hpp
#pragma once

#include "Recv.hpp"

class ClientClass;
class IClientNetworkable;

typedef IClientNetworkable* (*CreateClientClassFn)(int entnum, int serialNum);
typedef IClientNetworkable* (*CreateEventFn)();

class ClientClass
{
public:
    CreateClientClassFn      m_pCreateFn;
    CreateEventFn            m_pCreateEventFn;
    char*                    m_pNetworkName;
    RecvTable*               m_pRecvTable;
    ClientClass*             m_pNext;
    ClassId                  m_ClassID;
};
```

`CSGOSimple/valve_sdk/misc/Color.cpp`:

```cpp
#include "Color.hpp"

Color Color::Black(0, 0, 0, 255);
Color Color::White(255, 255, 255, 255);
Color Color::Red(255, 0, 0, 255);
Color Color::Green(0, 128, 0, 255);
Color Color::Blue(0, 0, 255, 255);

Color::Color()
{
    *((int *)this) = 0;
}
Color::Color(int _r, int _g, int _b)
{
    SetColor(_r, _g, _b, 255);
}
Color::Color(int _r, int _g, int _b, int _a)
{
    SetColor(_r, _g, _b, _a);
}
void Color::SetRawColor(int color32)
{
    *((int *)this) = color32;
}
int Color::GetRawColor() const
{
    return *((int *)this);
}
void Color::SetColor(int _r, int _g, int _b, int _a)
{
    _CColor[0] = (unsigned char)_r;
    _CColor[1] = (unsigned char)_g;
    _CColor[2] = (unsigned char)_b;
    _CColor[3] = (unsigned char)_a;
}
void Color::SetColor(float _r, float _g, float _b, float _a)
{
    _CColor[0] = static_cast<unsigned char>(_r * 255.0f);
    _CColor[1] = static_cast<unsigned char>(_g * 255.0f);
    _CColor[2] = static_cast<unsigned char>(_b * 255.0f);
    _CColor[3] = static_cast<unsigned char>(_a * 255.0f);
}
void Color::GetColor(int &_r, int &_g, int &_b, int &_a) const
{
    _r = _CColor[0];
    _g = _CColor[1];
    _b = _CColor[2];
    _a = _CColor[3];
}
bool Color::operator== (const Color &rhs) const
{
    return (*((int *)this) == *((int *)&rhs));
}
bool Color::operator!= (const Color &rhs) const
{
    return !(operator==(rhs));
}
Color& Color::operator=(const Color &rhs)
{
    SetRawColor(rhs.GetRawColor());
    return *this;
}

```

`CSGOSimple/valve_sdk/misc/Color.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

class Color
{
public:
	Color();
	Color(int _r, int _g, int _b);
	Color(int _r, int _g, int _b, int _a);
	Color(float _r, float _g, float _b) : Color(_r, _g, _b, 1.0f) {}
	Color(float _r, float _g, float _b, float _a)
		: Color(
			static_cast<int>(_r * 255.0f),
			static_cast<int>(_g * 255.0f),
			static_cast<int>(_b * 255.0f),
			static_cast<int>(_a * 255.0f))
	{
	}
	explicit Color(float* rgb) : Color(rgb[0], rgb[1], rgb[2], 1.0f) {}
	explicit Color(unsigned long argb)
	{
		_CColor[2] = (unsigned char)((argb & 0x000000FF) >> (0 * 8));
		_CColor[1] = (unsigned char)((argb & 0x0000FF00) >> (1 * 8));
		_CColor[0] = (unsigned char)((argb & 0x00FF0000) >> (2 * 8));
		_CColor[3] = (unsigned char)((argb & 0xFF000000) >> (3 * 8));
	}

	void    SetRawColor(int color32);
	int     GetRawColor() const;
	void    SetColor(int _r, int _g, int _b, int _a = 0);
	void    SetColor(float _r, float _g, float _b, float _a = 0);
	void    GetColor(int &_r, int &_g, int &_b, int &_a) const;

	std::string GetNormalnijHexColor() const;

	int r() const { return _CColor[0]; }
	int g() const { return _CColor[1]; }
	int b() const { return _CColor[2]; }
	int a() const { return _CColor[3]; }

	unsigned char &operator[](int index)
	{
		return _CColor[index];
	}
	const unsigned char &operator[](int index) const
	{
		return _CColor[index];
	}

	bool operator==(const Color &rhs) const;
	bool operator!=(const Color &rhs) const;
	Color &operator=(const Color &rhs);

	static Color FromHSB(float hue, float saturation, float brightness)
	{
		float h = hue == 1.0f ? 0 : hue * 6.0f;
		float f = h - (int)h;
		float p = brightness * (1.0f - saturation);
		float q = brightness * (1.0f - saturation * f);
		float t = brightness * (1.0f - (saturation * (1.0f - f)));

		if (h < 1)
		{
			return Color(
				(unsigned char)(brightness * 255),
				(unsigned char)(t * 255),
				(unsigned char)(p * 255)
			);
		}
		else if (h < 2)
		{
			return Color(
				(unsigned char)(q * 255),
				(unsigned char)(brightness * 255),
				(unsigned char)(p * 255)
			);
		}
		else if (h < 3)
		{
			return Color(
				(unsigned char)(p * 255),
				(unsigned char)(brightness * 255),
				(unsigned char)(t * 255)
			);
		}
		else if (h < 4)
		{
			return Color(
				(unsigned char)(p * 255),
				(unsigned char)(q * 255),
				(unsigned char)(brightness * 255)
			);
		}
		else if (h < 5)
		{
			return Color(
				(unsigned char)(t * 255),
				(unsigned char)(p * 255),
				(unsigned char)(brightness * 255)
			);
		}
		else
		{
			return Color(
				(unsigned char)(brightness * 255),
				(unsigned char)(p * 255),
				(unsigned char)(q * 255)
			);
		}
	}

	static Color Black;
	static Color White;
	static Color Red;
	static Color Green;
	static Color Blue;

private:
	unsigned char _CColor[4];
};
```

`CSGOSimple/valve_sdk/misc/Convar.cpp`:

```cpp
#include "Convar.hpp"

#include "../sdk.hpp"

#include "characterset.hpp"
#include "UtlBuffer.hpp"

#define ALIGN_VALUE( val, alignment ) ( ( val + alignment - 1 ) & ~( alignment - 1 ) ) 
#define stackalloc( _size )		_alloca( ALIGN_VALUE( _size, 16 ) )

ConCommandBase *ConCommandBase::s_pConCommandBases = NULL;
ConCommandBase *ConCommandBase::s_pRegisteredCommands = NULL;
IConCommandBaseAccessor	*ConCommandBase::s_pAccessor = NULL;
static int s_nDLLIdentifier = -1;
static int s_nCVarFlag = 0;
static bool s_bRegistered = false;

class CDefaultAccessor : public IConCommandBaseAccessor
{
public:
    virtual bool RegisterConCommandBase(ConCommandBase *pVar)
    {
        // Link to engine's list instead
        g_CVar->RegisterConCommand(pVar);
        return true;
    }
};

static CDefaultAccessor s_DefaultAccessor;

//-----------------------------------------------------------------------------
// Called by the framework to register ConCommandBases with the ICVar
//-----------------------------------------------------------------------------
void ConVar_Register(int nCVarFlag, IConCommandBaseAccessor *pAccessor)
{
    if(!g_CVar || s_bRegistered)
        return;

    assert(s_nDLLIdentifier < 0);
    s_bRegistered = true;
    s_nCVarFlag = nCVarFlag;
    s_nDLLIdentifier = g_CVar->AllocateDLLIdentifier();

    ConCommandBase *pCur, *pNext;

    ConCommandBase::s_pAccessor = pAccessor ? pAccessor : &s_DefaultAccessor;
    pCur = ConCommandBase::s_pConCommandBases;

    while(pCur) {
        pNext = pCur->m_pNext;
        pCur->AddFlags(s_nCVarFlag);
        pCur->Init();

        ConCommandBase::s_pRegisteredCommands = pCur;

        pCur = pNext;
    }

    ConCommandBase::s_pConCommandBases = NULL;
}

void ConVar_Unregister()
{
    if(!g_CVar || !s_bRegistered)
        return;

    assert(s_nDLLIdentifier >= 0);
    g_CVar->UnregisterConCommands(s_nDLLIdentifier);
    s_nDLLIdentifier = -1;
    s_bRegistered = false;
}

ConCommandBase::ConCommandBase(void)
{
    m_bRegistered = false;
    m_pszName = NULL;
    m_pszHelpString = NULL;

    m_nFlags = 0;
    m_pNext = NULL;
}

ConCommandBase::ConCommandBase(const char *pName, const char *pHelpString /*=0*/, int flags /*= 0*/)
{
    Create(pName, pHelpString, flags);
}

ConCommandBase::~ConCommandBase(void)
{
}

bool ConCommandBase::IsCommand(void) const
{
    //	assert( 0 ); This can't assert. . causes a recursive assert in Sys_Printf, etc.
    return true;
}

CVarDLLIdentifier_t ConCommandBase::GetDLLIdentifier() const
{
    return s_nDLLIdentifier;
}

void ConCommandBase::Create(const char *pName, const char *pHelpString /*= 0*/, int flags /*= 0*/)
{
    static const char *empty_string = "";

    m_bRegistered = false;

    // Name should be static data
    m_pszName = pName;
    m_pszHelpString = pHelpString ? pHelpString : empty_string;

    m_nFlags = flags;

    if(!(m_nFlags & FCVAR_UNREGISTERED)) {
        m_pNext = s_pConCommandBases;
        s_pConCommandBases = this;
    } else {
        m_pNext = NULL;
    }
}

void ConCommandBase::Init()
{
    if(s_pAccessor) {
        s_pAccessor->RegisterConCommandBase(this);
    }
}

void ConCommandBase::Shutdown()
{
    if(g_CVar) {
        g_CVar->UnregisterConCommand(this);
    }
}

const char *ConCommandBase::GetName(void) const
{
    return m_pszName;
}

bool ConCommandBase::IsFlagSet(int flag) const
{
    return (flag & m_nFlags) ? true : false;
}

void ConCommandBase::AddFlags(int flags)
{
    m_nFlags |= flags;
}

void ConCommandBase::RemoveFlags(int flags)
{
    m_nFlags &= ~flags;
}

int ConCommandBase::GetFlags(void) const
{
    return m_nFlags;
}

const ConCommandBase *ConCommandBase::GetNext(void) const
{
    return m_pNext;
}

ConCommandBase *ConCommandBase::GetNext(void)
{
    return m_pNext;
}

char *ConCommandBase::CopyString(const char *from)
{
    int		len;
    char	*to;

    len = strlen(from);
    if(len <= 0) {
        to = new char[1];
        to[0] = 0;
    } else {
        to = new char[len + 1];
        strncpy_s(to, len + 1, from, len + 1);
    }
    return to;
}

const char *ConCommandBase::GetHelpText(void) const
{
    return m_pszHelpString;
}

bool ConCommandBase::IsRegistered(void) const
{
    return m_bRegistered;
}

static characterset_t s_BreakSet;
static bool s_bBuiltBreakSet = false;

CCommand::CCommand()
{
    if(!s_bBuiltBreakSet) {
        s_bBuiltBreakSet = true;
        CharacterSetBuild(&s_BreakSet, "{}()':");
    }

    Reset();
}

CCommand::CCommand(int nArgC, const char **ppArgV)
{
    assert(nArgC > 0);

    if(!s_bBuiltBreakSet) {
        s_bBuiltBreakSet = true;
        CharacterSetBuild(&s_BreakSet, "{}()':");
    }

    Reset();

    char *pBuf = m_pArgvBuffer;
    char *pSBuf = m_pArgSBuffer;
    m_nArgc = nArgC;
    for(int i = 0; i < nArgC; ++i) {
        m_ppArgv[i] = pBuf;
        int nLen = strlen(ppArgV[i]);
        memcpy(pBuf, ppArgV[i], nLen + 1);
        if(i == 0) {
            m_nArgv0Size = nLen;
        }
        pBuf += nLen + 1;

        bool bContainsSpace = strchr(ppArgV[i], ' ') != NULL;
        if(bContainsSpace) {
            *pSBuf++ = '\"';
        }
        memcpy(pSBuf, ppArgV[i], nLen);
        pSBuf += nLen;
        if(bContainsSpace) {
            *pSBuf++ = '\"';
        }

        if(i != nArgC - 1) {
            *pSBuf++ = ' ';
        }
    }
}

void CCommand::Reset()
{
    m_nArgc = 0;
    m_nArgv0Size = 0;
    m_pArgSBuffer[0] = 0;
}

characterset_t* CCommand::DefaultBreakSet()
{
    return &s_BreakSet;
}

bool CCommand::Tokenize(const char *pCommand, characterset_t *pBreakSet)
{
    Reset();
    if(!pCommand)
        return false;

    // Use default break Set
    if(!pBreakSet) {
        pBreakSet = &s_BreakSet;
    }

    // Copy the current command into a temp buffer
    // NOTE: This is here to avoid the pointers returned by DequeueNextCommand
    // to become invalid by calling AddText. Is there a way we can avoid the memcpy?
    int nLen = strlen(pCommand);
    if(nLen >= COMMAND_MAX_LENGTH - 1) {
        //Warning("CCommand::Tokenize: Encountered command which overflows the tokenizer buffer.. Skipping!\n");
        return false;
    }

    memcpy(m_pArgSBuffer, pCommand, nLen + 1);

    // Parse the current command into the current command buffer
    CUtlBuffer bufParse(m_pArgSBuffer, nLen, CUtlBuffer::TEXT_BUFFER | CUtlBuffer::READ_ONLY);
    int nArgvBufferSize = 0;
    while(bufParse.IsValid() && (m_nArgc < COMMAND_MAX_ARGC)) {
        char *pArgvBuf = &m_pArgvBuffer[nArgvBufferSize];
        int nMaxLen = COMMAND_MAX_LENGTH - nArgvBufferSize;
        int nStartGet = bufParse.TellGet();
        int	nSize = bufParse.ParseToken(pBreakSet, pArgvBuf, nMaxLen);
        if(nSize < 0)
            break;

        // Check for overflow condition
        if(nMaxLen == nSize) {
            Reset();
            return false;
        }

        if(m_nArgc == 1) {
            // Deal with the case where the arguments were quoted
            m_nArgv0Size = bufParse.TellGet();
            bool bFoundEndQuote = m_pArgSBuffer[m_nArgv0Size - 1] == '\"';
            if(bFoundEndQuote) {
                --m_nArgv0Size;
            }
            m_nArgv0Size -= nSize;
            assert(m_nArgv0Size != 0);

            // The StartGet check is to handle this case: "foo"bar
            // which will parse into 2 different args. ArgS should point to bar.
            bool bFoundStartQuote = (m_nArgv0Size > nStartGet) && (m_pArgSBuffer[m_nArgv0Size - 1] == '\"');
            assert(bFoundEndQuote == bFoundStartQuote);
            if(bFoundStartQuote) {
                --m_nArgv0Size;
            }
        }

        m_ppArgv[m_nArgc++] = pArgvBuf;
        if(m_nArgc >= COMMAND_MAX_ARGC) {
            //Warning("CCommand::Tokenize: Encountered command which overflows the argument buffer.. Clamped!\n");
        }

        nArgvBufferSize += nSize + 1;
        assert(nArgvBufferSize <= COMMAND_MAX_LENGTH);
    }

    return true;
}

const char* CCommand::FindArg(const char *pName) const
{
    int nArgC = ArgC();
    for(int i = 1; i < nArgC; i++) {
        if(!_stricmp(Arg(i), pName))
            return (i + 1) < nArgC ? Arg(i + 1) : "";
    }
    return 0;
}

int CCommand::FindArgInt(const char *pName, int nDefaultVal) const
{
    const char *pVal = FindArg(pName);
    if(pVal)
        return atoi(pVal);
    else
        return nDefaultVal;
}

int DefaultCompletionFunc(const char *partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH])
{
    return 0;
}

ConCommand::ConCommand(const char *pName, FnCommandCallbackV1_t callback, const char *pHelpString /*= 0*/, int flags /*= 0*/, FnCommandCompletionCallback completionFunc /*= 0*/)
{
    // Set the callback
    m_fnCommandCallbackV1 = callback;
    m_bUsingNewCommandCallback = false;
    m_bUsingCommandCallbackInterface = false;
    m_fnCompletionCallback = completionFunc ? completionFunc : DefaultCompletionFunc;
    m_bHasCompletionCallback = completionFunc != 0 ? true : false;

    // Setup the rest
    BaseClass::Create(pName, pHelpString, flags);
}

ConCommand::ConCommand(const char *pName, FnCommandCallback_t callback, const char *pHelpString /*= 0*/, int flags /*= 0*/, FnCommandCompletionCallback completionFunc /*= 0*/)
{
    // Set the callback
    m_fnCommandCallback = callback;
    m_bUsingNewCommandCallback = true;
    m_fnCompletionCallback = completionFunc ? completionFunc : DefaultCompletionFunc;
    m_bHasCompletionCallback = completionFunc != 0 ? true : false;
    m_bUsingCommandCallbackInterface = false;

    // Setup the rest
    BaseClass::Create(pName, pHelpString, flags);
}

ConCommand::ConCommand(const char *pName, ICommandCallback *pCallback, const char *pHelpString /*= 0*/, int flags /*= 0*/, ICommandCompletionCallback *pCompletionCallback /*= 0*/)
{
    // Set the callback
    m_pCommandCallback = pCallback;
    m_bUsingNewCommandCallback = false;
    m_pCommandCompletionCallback = pCompletionCallback;
    m_bHasCompletionCallback = (pCompletionCallback != 0);
    m_bUsingCommandCallbackInterface = true;

    // Setup the rest
    BaseClass::Create(pName, pHelpString, flags);
}

ConCommand::~ConCommand(void)
{
}

bool ConCommand::IsCommand(void) const
{
    return true;
}

void ConCommand::Dispatch(const CCommand &command)
{
    if(m_bUsingNewCommandCallback) {
        if(m_fnCommandCallback) {
            (*m_fnCommandCallback)(command);
            return;
        }
    } else if(m_bUsingCommandCallbackInterface) {
        if(m_pCommandCallback) {
            m_pCommandCallback->CommandCallback(command);
            return;
        }
    } else {
        if(m_fnCommandCallbackV1) {
            (*m_fnCommandCallbackV1)();
            return;
        }
    }

    // Command without callback!!!
    //AssertMsg(0, ("Encountered ConCommand without a callback!\n"));
}

int	ConCommand::AutoCompleteSuggest(const char *partial, CUtlVector< CUtlString > &commands)
{
    if(m_bUsingCommandCallbackInterface) {
        if(!m_pCommandCompletionCallback)
            return 0;
        return m_pCommandCompletionCallback->CommandCompletionCallback(partial, commands);
    }

    if(!m_fnCompletionCallback)
        return 0;

    char rgpchCommands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH];
    int iret = (m_fnCompletionCallback)(partial, rgpchCommands);
    for(int i = 0; i < iret; ++i) {
        CUtlString str = rgpchCommands[i];
        commands.AddToTail(str);
    }
    return iret;
}

bool ConCommand::CanAutoComplete(void)
{
    return m_bHasCompletionCallback;
}

ConVar::ConVar(const char *pName, const char *pDefaultValue, int flags /* = 0 */)
{
    Create(pName, pDefaultValue, flags);
}

ConVar::ConVar(const char *pName, const char *pDefaultValue, int flags, const char *pHelpString)
{
    Create(pName, pDefaultValue, flags, pHelpString);
}

ConVar::ConVar(const char *pName, const char *pDefaultValue, int flags, const char *pHelpString, bool bMin, float fMin, bool bMax, float fMax)
{
    Create(pName, pDefaultValue, flags, pHelpString, bMin, fMin, bMax, fMax);
}

ConVar::ConVar(const char *pName, const char *pDefaultValue, int flags, const char *pHelpString, FnChangeCallback_t callback)
{
    Create(pName, pDefaultValue, flags, pHelpString, false, 0.0, false, 0.0, callback);
}

ConVar::ConVar(const char *pName, const char *pDefaultValue, int flags, const char *pHelpString, bool bMin, float fMin, bool bMax, float fMax, FnChangeCallback_t callback)
{
    Create(pName, pDefaultValue, flags, pHelpString, bMin, fMin, bMax, fMax, callback);
}

ConVar::~ConVar(void)
{
    //if(IsRegistered())
    //    convar->UnregisterConCommand(this);
    if(m_Value.m_pszString) {
        delete[] m_Value.m_pszString;
        m_Value.m_pszString = NULL;
    }
}

void ConVar::InstallChangeCallback(FnChangeCallback_t callback, bool bInvoke)
{
    if(callback) {
        if(m_fnChangeCallbacks.GetOffset(callback) != -1) {
            m_fnChangeCallbacks.AddToTail(callback);
            if(bInvoke)
                callback(this, m_Value.m_pszString, m_Value.m_fValue);
        } else {
            //Warning("InstallChangeCallback ignoring duplicate change callback!!!\n");
        }
    } else {
        //Warning("InstallChangeCallback called with NULL callback, ignoring!!!\n");
    }
}

bool ConVar::IsFlagSet(int flag) const
{
    return (flag & m_pParent->m_nFlags) ? true : false;
}

const char *ConVar::GetHelpText(void) const
{
    return m_pParent->m_pszHelpString;
}

void ConVar::AddFlags(int flags)
{
    m_pParent->m_nFlags |= flags;

#ifdef ALLOW_DEVELOPMENT_CVARS
    m_pParent->m_nFlags &= ~FCVAR_DEVELOPMENTONLY;
#endif
}

int ConVar::GetFlags(void) const
{
    return m_pParent->m_nFlags;
}

bool ConVar::IsRegistered(void) const
{
    return m_pParent->m_bRegistered;
}

const char *ConVar::GetName(void) const
{
    return m_pParent->m_pszName;
}

bool ConVar::IsCommand(void) const
{
    return false;
}

void ConVar::Init()
{
    BaseClass::Init();
}

const char *ConVar::GetBaseName(void) const
{
    return m_pParent->m_pszName;
}

int ConVar::GetSplitScreenPlayerSlot(void) const
{
    return 0;
}

void ConVar::InternalSetValue(const char *value)
{
    float fNewValue;
    char  tempVal[32];
    char  *val;

    auto temp = *(uint32_t*)&m_Value.m_fValue ^ (uint32_t)this;
    float flOldValue = *(float*)(&temp);

    val = (char *)value;
    fNewValue = (float)atof(value);

    if(ClampValue(fNewValue)) {
        snprintf(tempVal, sizeof(tempVal), "%f", fNewValue);
        val = tempVal;
    }

    // Redetermine value
    *(uint32_t*)&m_Value.m_fValue = *(uint32_t*)&fNewValue ^ (uint32_t)this;
    *(uint32_t*)&m_Value.m_nValue = (uint32_t)fNewValue ^ (uint32_t)this;

    if(!(m_nFlags & FCVAR_NEVER_AS_STRING)) {
        ChangeStringValue(val, flOldValue);
    }
}

void ConVar::ChangeStringValue(const char *tempVal, float flOldValue)
{
    char* pszOldValue = (char*)stackalloc(m_Value.m_StringLength);
    memcpy(pszOldValue, m_Value.m_pszString, m_Value.m_StringLength);

    int len = strlen(tempVal) + 1;

    if(len > m_Value.m_StringLength) {
        if(m_Value.m_pszString) {
            delete[] m_Value.m_pszString;
        }

        m_Value.m_pszString = new char[len];
        m_Value.m_StringLength = len;
    }

	memcpy(m_Value.m_pszString, std::to_string(this->GetFloat()).c_str(), len);

    // Invoke any necessary callback function
    for(int i = 0; i < m_fnChangeCallbacks.Count(); i++) {
        m_fnChangeCallbacks[i](this, pszOldValue, flOldValue);
    }

    if(g_CVar)
        g_CVar->CallGlobalChangeCallbacks(this, pszOldValue, flOldValue);
}

bool ConVar::ClampValue(float& value)
{
    if(m_bHasMin && (value < m_fMinVal)) {
        value = m_fMinVal;
        return true;
    }

    if(m_bHasMax && (value > m_fMaxVal)) {
        value = m_fMaxVal;
        return true;
    }

    return false;
}

void ConVar::InternalSetFloatValue(float fNewValue)
{
    if(fNewValue == m_Value.m_fValue)
        return;

    ClampValue(fNewValue);

    // Redetermine value
    float flOldValue = m_Value.m_fValue;
    *(uint32_t*)&m_Value.m_fValue = *(uint32_t*)&fNewValue ^ (uint32_t)this;
    *(uint32_t*)&m_Value.m_nValue = (uint32_t)fNewValue ^ (uint32_t)this;

    if(!(m_nFlags & FCVAR_NEVER_AS_STRING)) {
        char tempVal[32];
        snprintf(tempVal, sizeof(tempVal), "%f", m_Value.m_fValue);
        ChangeStringValue(tempVal, flOldValue);
    } else {
        //assert(m_fnChangeCallbacks.Count() == 0);
    }
}

void ConVar::InternalSetIntValue(int nValue)
{
    if(nValue == ((int)m_Value.m_nValue ^ (int)this))
        return;

    float fValue = (float)nValue;
    if(ClampValue(fValue)) {
        nValue = (int)(fValue);
    }

    // Redetermine value
    float flOldValue = m_Value.m_fValue;
    *(uint32_t*)&m_Value.m_fValue = *(uint32_t*)&fValue ^ (uint32_t)this;
    *(uint32_t*)&m_Value.m_nValue = *(uint32_t*)&nValue ^ (uint32_t)this;

    if(!(m_nFlags & FCVAR_NEVER_AS_STRING)) {
        char tempVal[32];
        snprintf(tempVal, sizeof(tempVal), "%d", m_Value.m_nValue);
        ChangeStringValue(tempVal, flOldValue);
    } else {
        //assert(m_fnChangeCallbacks.Count() == 0);
    }
}

void ConVar::InternalSetColorValue(Color cValue)
{
    int color = (int)cValue.GetRawColor();
    InternalSetIntValue(color);
}

void ConVar::Create(const char *pName, const char *pDefaultValue, int flags /*= 0*/,
    const char *pHelpString /*= NULL*/, bool bMin /*= false*/, float fMin /*= 0.0*/,
    bool bMax /*= false*/, float fMax /*= false*/, FnChangeCallback_t callback /*= NULL*/)
{
    static const char *empty_string = "";

    m_pParent = this;

    // Name should be static data
    m_pszDefaultValue = pDefaultValue ? pDefaultValue : empty_string;

    m_Value.m_StringLength = strlen(m_pszDefaultValue) + 1;
    m_Value.m_pszString = new char[m_Value.m_StringLength];
    memcpy(m_Value.m_pszString, m_pszDefaultValue, m_Value.m_StringLength);

    m_bHasMin = bMin;
    m_fMinVal = fMin;
    m_bHasMax = bMax;
    m_fMaxVal = fMax;

    if(callback)
        m_fnChangeCallbacks.AddToTail(callback);

    float value = (float)atof(m_Value.m_pszString);

    *(uint32_t*)&m_Value.m_fValue = *(uint32_t*)&value ^ (uint32_t)this;
    *(uint32_t*)&m_Value.m_nValue = *(uint32_t*)&value ^ (uint32_t)this;

    BaseClass::Create(pName, pHelpString, flags);
}

void ConVar::SetValue(const char *value)
{
    ConVar *var = (ConVar *)m_pParent;
    var->InternalSetValue(value);
}

void ConVar::SetValue(float value)
{
    ConVar *var = (ConVar *)m_pParent;
    var->InternalSetFloatValue(value);
}

void ConVar::SetValue(int value)
{
    ConVar *var = (ConVar *)m_pParent;
    var->InternalSetIntValue(value);
}

void ConVar::SetValue(Color value)
{
    ConVar *var = (ConVar *)m_pParent;
    var->InternalSetColorValue(value);
}

void ConVar::Revert(void)
{
    // Force default value again
    ConVar *var = (ConVar *)m_pParent;
    var->SetValue(var->m_pszDefaultValue);
}

bool ConVar::GetMin(float& minVal) const
{
    minVal = m_pParent->m_fMinVal;
    return m_pParent->m_bHasMin;
}

bool ConVar::GetMax(float& maxVal) const
{
    maxVal = m_pParent->m_fMaxVal;
    return m_pParent->m_bHasMax;
}

const char *ConVar::GetDefault(void) const
{
    return m_pParent->m_pszDefaultValue;
}

```

`CSGOSimple/valve_sdk/misc/Convar.hpp`:

```hpp
#pragma once

#include <cstdint>
#include "../Interfaces/ICvar.hpp"
#include "UtlVector.hpp"
#include "UtlString.hpp"

#define FORCEINLINE_CVAR inline
//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class ConVar;
class CCommand;
class ConCommand;
class ConCommandBase;
struct characterset_t;

class CCommand
{
public:
    CCommand();
    CCommand(int nArgC, const char **ppArgV);
    bool Tokenize(const char *pCommand, characterset_t *pBreakSet = NULL);
    void Reset();

    int ArgC() const;
    const char** ArgV() const;
    const char*  ArgS() const;					        // All args that occur after the 0th arg, in string form
    const char*  GetCommandString() const;		  // The entire command in string form, including the 0th arg
    const char*  operator[](int nIndex) const;	// Gets at arguments
    const char*  Arg(int nIndex) const;		      // Gets at arguments

                                                  // Helper functions to parse arguments to commands.
    const char* FindArg(const char *pName) const;
    int FindArgInt(const char *pName, int nDefaultVal) const;

    static int MaxCommandLength();
    static characterset_t* DefaultBreakSet();

private:
    enum
    {
        COMMAND_MAX_ARGC = 64,
        COMMAND_MAX_LENGTH = 512,
    };

    int		m_nArgc;
    int		m_nArgv0Size;
    char	m_pArgSBuffer[COMMAND_MAX_LENGTH];
    char	m_pArgvBuffer[COMMAND_MAX_LENGTH];
    const char*	m_ppArgv[COMMAND_MAX_ARGC];
};

inline int CCommand::MaxCommandLength()
{
    return COMMAND_MAX_LENGTH - 1;
}

inline int CCommand::ArgC() const
{
    return m_nArgc;
}

inline const char **CCommand::ArgV() const
{
    return m_nArgc ? (const char**)m_ppArgv : NULL;
}

inline const char *CCommand::ArgS() const
{
    return m_nArgv0Size ? &m_pArgSBuffer[m_nArgv0Size] : "";
}

inline const char *CCommand::GetCommandString() const
{
    return m_nArgc ? m_pArgSBuffer : "";
}

inline const char *CCommand::Arg(int nIndex) const
{
    // FIXME: Many command handlers appear to not be particularly careful
    // about checking for valid argc range. For now, we're going to
    // do the extra check and return an empty string if it's out of range
    if(nIndex < 0 || nIndex >= m_nArgc)
        return "";
    return m_ppArgv[nIndex];
}

inline const char *CCommand::operator[](int nIndex) const
{
    return Arg(nIndex);
}

//-----------------------------------------------------------------------------
// Any executable that wants to use ConVars need to implement one of
// these to hook up access to console variables.
//-----------------------------------------------------------------------------
class IConCommandBaseAccessor
{
public:
    // Flags is a combination of FCVAR flags in cvar.h.
    // hOut is filled in with a handle to the variable.
    virtual bool RegisterConCommandBase(ConCommandBase *pVar) = 0;
};

//-----------------------------------------------------------------------------
// Called when a ConCommand needs to execute
//-----------------------------------------------------------------------------
typedef void(*FnCommandCallbackV1_t)(void);
typedef void(*FnCommandCallback_t)(const CCommand &command);

#define COMMAND_COMPLETION_MAXITEMS       64
#define COMMAND_COMPLETION_ITEM_LENGTH    64

//-----------------------------------------------------------------------------
// Returns 0 to COMMAND_COMPLETION_MAXITEMS worth of completion strings
//-----------------------------------------------------------------------------
typedef int(*FnCommandCompletionCallback)(const char *partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH]);


//-----------------------------------------------------------------------------
// Interface version
//-----------------------------------------------------------------------------
class ICommandCallback
{
public:
    virtual void CommandCallback(const CCommand &command) = 0;
};

class ICommandCompletionCallback
{
public:
    virtual int  CommandCompletionCallback(const char *pPartial, CUtlVector<CUtlString> &commands) = 0;
};

//-----------------------------------------------------------------------------
// Purpose: The base console invoked command/cvar interface
//-----------------------------------------------------------------------------
class ConCommandBase
{
    friend class CCvar;
    friend class ConVar;
    friend class ConCommand;
    friend void ConVar_Register(int nCVarFlag, IConCommandBaseAccessor *pAccessor);

    // FIXME: Remove when ConVar changes are done
    friend class CDefaultCvar;

public:
    ConCommandBase(void);
    ConCommandBase(const char *pName, const char *pHelpString = 0, int flags = 0);

    virtual                     ~ConCommandBase(void);
    virtual bool                IsCommand(void) const;
    virtual bool                IsFlagSet(int flag) const;
    virtual void                AddFlags(int flags);
    virtual void                RemoveFlags(int flags);
    virtual int                 GetFlags() const;
    virtual const char*         GetName(void) const;
    virtual const char*         GetHelpText(void) const;
    const ConCommandBase*       GetNext(void) const;
    ConCommandBase*             GetNext(void);
    virtual bool                IsRegistered(void) const;
    virtual CVarDLLIdentifier_t GetDLLIdentifier() const;

    //protected:
    virtual void                Create(const char *pName, const char *pHelpString = 0, int flags = 0);
    virtual void                Init();
    void                        Shutdown();
    char*                       CopyString(const char *from);

    //private:
    // Next ConVar in chain
    // Prior to register, it points to the next convar in the DLL.
    // Once registered, though, m_pNext is reset to point to the next
    // convar in the global list
    ConCommandBase*             m_pNext;
    bool                        m_bRegistered;
    const char*                 m_pszName;
    const char*                 m_pszHelpString;
    int                         m_nFlags;

protected:
    // ConVars add themselves to this list for the executable. 
    // Then ConVar_Register runs through  all the console variables 
    // and registers them into a global list stored in vstdlib.dll
    static ConCommandBase* s_pConCommandBases;

    // ConVars in this executable use this 'global' to access values.
    static IConCommandBaseAccessor* s_pAccessor;

public:
    // This list will hold all the registered commands.
    // It is not from the official SDK. I've added this so that
    // we can parse all convars we have created if we want to
    // save them to a file later on, for example.
    static ConCommandBase* s_pRegisteredCommands;
};

//-----------------------------------------------------------------------------
// Purpose: The console invoked command
//-----------------------------------------------------------------------------
class ConCommand : public ConCommandBase
{
    friend class CCvar;

public:
    typedef ConCommandBase BaseClass;

    ConCommand(const char *pName, FnCommandCallbackV1_t callback,
        const char *pHelpString = 0, int flags = 0, FnCommandCompletionCallback completionFunc = 0);
    ConCommand(const char *pName, FnCommandCallback_t callback,
        const char *pHelpString = 0, int flags = 0, FnCommandCompletionCallback completionFunc = 0);
    ConCommand(const char *pName, ICommandCallback *pCallback,
        const char *pHelpString = 0, int flags = 0, ICommandCompletionCallback *pCommandCompletionCallback = 0);

    virtual         ~ConCommand(void);
    virtual bool    IsCommand(void) const;
    virtual int     AutoCompleteSuggest(const char *partial, CUtlVector<CUtlString> &commands);
    virtual bool    CanAutoComplete(void);
    virtual void    Dispatch(const CCommand &command);

    //private:
    // NOTE: To maintain backward compat, we have to be very careful:
    // All public virtual methods must appear in the same order always
    // since engine code will be calling into this code, which *does not match*
    // in the mod code; it's using slightly different, but compatible versions
    // of this class. Also: Be very careful about adding new fields to this class.
    // Those fields will not exist in the version of this class that is instanced
    // in mod code.

    // Call this function when executing the command
    union
    {
        FnCommandCallbackV1_t       m_fnCommandCallbackV1;
        FnCommandCallback_t         m_fnCommandCallback;
        ICommandCallback*           m_pCommandCallback;
    };

    union
    {
        FnCommandCompletionCallback m_fnCompletionCallback;
        ICommandCompletionCallback* m_pCommandCompletionCallback;
    };

    bool m_bHasCompletionCallback : 1;
    bool m_bUsingNewCommandCallback : 1;
    bool m_bUsingCommandCallbackInterface : 1;
};


//-----------------------------------------------------------------------------
// Purpose: A console variable
//-----------------------------------------------------------------------------
class ConVar : public ConCommandBase, public IConVar
{
    friend class CCvar;
    friend class ConVarRef;
    friend class SplitScreenConVarRef;

public:
    typedef ConCommandBase BaseClass;

    ConVar(const char *pName, const char *pDefaultValue, int flags = 0);

    ConVar(const char *pName, const char *pDefaultValue, int flags, const char *pHelpString);
    ConVar(const char *pName, const char *pDefaultValue, int flags, const char *pHelpString, bool bMin, float fMin, bool bMax, float fMax);
    ConVar(const char *pName, const char *pDefaultValue, int flags, const char *pHelpString, FnChangeCallback_t callback);
    ConVar(const char *pName, const char *pDefaultValue, int flags, const char *pHelpString, bool bMin, float fMin, bool bMax, float fMax, FnChangeCallback_t callback);

    virtual                     ~ConVar(void);
    virtual bool                IsFlagSet(int flag) const;
    virtual const char*         GetHelpText(void) const;
    virtual bool                IsRegistered(void) const;
    virtual const char*         GetName(void) const;
    virtual const char*         GetBaseName(void) const;
    virtual int                 GetSplitScreenPlayerSlot() const;

    virtual void                AddFlags(int flags);
    virtual int                 GetFlags() const;
    virtual bool                IsCommand(void) const;

    // Install a change callback (there shouldn't already be one....)
    void InstallChangeCallback(FnChangeCallback_t callback, bool bInvoke = true);
    void RemoveChangeCallback(FnChangeCallback_t callbackToRemove);

    int GetChangeCallbackCount() const { return m_pParent->m_fnChangeCallbacks.Count(); }
    FnChangeCallback_t GetChangeCallback(int slot) const { return m_pParent->m_fnChangeCallbacks[slot]; }

    // Retrieve value
    virtual float                   GetFloat(void) const;
    virtual int                     GetInt(void) const;
    FORCEINLINE_CVAR Color          GetColor(void) const;
    FORCEINLINE_CVAR bool           GetBool() const { return !!GetInt(); }
    FORCEINLINE_CVAR char const*    GetString(void) const;

    // Compiler driven selection for template use
    template <typename T> T Get(void) const;
    template <typename T> T Get(T *) const;

    // Any function that allocates/frees memory needs to be virtual or else you'll have crashes
    //  from alloc/free across dll/exe boundaries.

    // These just call into the IConCommandBaseAccessor to check flags and Set the var (which ends up calling InternalSetValue).
    virtual void                    SetValue(const char *value);
    virtual void                    SetValue(float value);
    virtual void                    SetValue(int value);
    virtual void                    SetValue(Color value);

    // Reset to default value
    void                            Revert(void);
    bool                            HasMin() const;
    bool                            HasMax() const;
    bool                            GetMin(float& minVal) const;
    bool                            GetMax(float& maxVal) const;
    float                           GetMinValue() const;
    float                           GetMaxValue() const;
    const char*                     GetDefault(void) const;

    struct CVValue_t
    {
        char*   m_pszString;
        int     m_StringLength;
        float   m_fValue;
        int     m_nValue;
    };

    FORCEINLINE_CVAR CVValue_t &GetRawValue()
    {
        return m_Value;
    }
    FORCEINLINE_CVAR const CVValue_t &GetRawValue() const
    {
        return m_Value;
    }

    //private:
    bool                        InternalSetColorFromString(const char *value);
    virtual void                InternalSetValue(const char *value);
    virtual void                InternalSetFloatValue(float fNewValue);
    virtual void                InternalSetIntValue(int nValue);
    virtual void                InternalSetColorValue(Color value);
    virtual bool                ClampValue(float& value);
    virtual void                ChangeStringValue(const char *tempVal, float flOldValue);
    virtual void                Create(const char *pName, const char *pDefaultValue, int flags = 0, const char *pHelpString = 0, bool bMin = false, float fMin = 0.0, bool bMax = false, float fMax = false, FnChangeCallback_t callback = 0);

    // Used internally by OneTimeInit to Initialize.
    virtual void                Init();

    //protected:
    ConVar*                     m_pParent;
    const char*                 m_pszDefaultValue;
    CVValue_t                   m_Value;
    bool                        m_bHasMin;
    float                       m_fMinVal;
    bool                        m_bHasMax;
    float                       m_fMaxVal;

    // Call this function when ConVar changes
    CUtlVector<FnChangeCallback_t> m_fnChangeCallbacks;
};


//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as a float
// Output : float
//-----------------------------------------------------------------------------
FORCEINLINE_CVAR float ConVar::GetFloat(void) const
{
    uint32_t xored = *(uint32_t*)&m_pParent->m_Value.m_fValue ^ (uint32_t)this;
    return *(float*)&xored;
}

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as an int
// Output : int
//-----------------------------------------------------------------------------
FORCEINLINE_CVAR int ConVar::GetInt(void) const
{
    return (int)(m_pParent->m_Value.m_nValue ^ (int)this);
}

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as a color
// Output : Color
//-----------------------------------------------------------------------------
FORCEINLINE_CVAR Color ConVar::GetColor(void) const
{
    int value = GetInt();
    unsigned char *pColorElement = ((unsigned char *)&value);
    return Color(pColorElement[0], pColorElement[1], pColorElement[2], pColorElement[3]);
}


//-----------------------------------------------------------------------------

template <> FORCEINLINE_CVAR float          ConVar::Get<float>(void) const { return GetFloat(); }
template <> FORCEINLINE_CVAR int            ConVar::Get<int>(void) const { return GetInt(); }
template <> FORCEINLINE_CVAR bool           ConVar::Get<bool>(void) const { return GetBool(); }
template <> FORCEINLINE_CVAR const char*    ConVar::Get<const char *>(void) const { return GetString(); }
template <> FORCEINLINE_CVAR float          ConVar::Get<float>(float *p) const { return (*p = GetFloat()); }
template <> FORCEINLINE_CVAR int            ConVar::Get<int>(int *p) const { return (*p = GetInt()); }
template <> FORCEINLINE_CVAR bool           ConVar::Get<bool>(bool *p) const { return (*p = GetBool()); }
template <> FORCEINLINE_CVAR const char*    ConVar::Get<const char *>(char const **p) const { return (*p = GetString()); }

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as a string, return "" for bogus string pointer, etc.
// Output : const char *
//-----------------------------------------------------------------------------
FORCEINLINE_CVAR const char *ConVar::GetString(void) const
{
    if(m_nFlags & FCVAR_NEVER_AS_STRING)
        return "FCVAR_NEVER_AS_STRING";
    char const *str = m_pParent->m_Value.m_pszString;
    return str ? str : "";
}

//-----------------------------------------------------------------------------
// Called by the framework to register ConCommands with the ICVar
//-----------------------------------------------------------------------------
void ConVar_Register(int nCVarFlag = 0, IConCommandBaseAccessor *pAccessor = NULL);
void ConVar_Unregister();
```

`CSGOSimple/valve_sdk/misc/EHandle.hpp`:

```hpp
#pragma once

#include "BaseHandle.hpp"
#include "../sdk.hpp"

// -------------------------------------------------------------------------------------------------- //
// Game-code CBaseHandle implementation.
// -------------------------------------------------------------------------------------------------- //

inline IHandleEntity* CBaseHandle::Get() const
{
    return g_EntityList->GetClientEntityFromHandle(*this);
}


// -------------------------------------------------------------------------------------------------- //
// CHandle.
// -------------------------------------------------------------------------------------------------- //
template< class T >
class CHandle : public CBaseHandle
{
public:

    CHandle();
    CHandle(int iEntry, int iSerialNumber);
    CHandle(const CBaseHandle &handle);
    CHandle(T *pVal);

    // The index should have come from a call to ToInt(). If it hasn't, you're in trouble.
    static CHandle<T> FromIndex(int index);

    T*		Get() const;
    void	Set(const T* pVal);

    operator T*();
    operator T*() const;

    bool	operator !() const;
    bool	operator==(T *val) const;
    bool	operator!=(T *val) const;
    const CBaseHandle& operator=(const T *val);

    T*		operator->() const;
};


// ----------------------------------------------------------------------- //
// Inlines.
// ----------------------------------------------------------------------- //

template<class T>
CHandle<T>::CHandle()
{
}


template<class T>
CHandle<T>::CHandle(int iEntry, int iSerialNumber)
{
    Init(iEntry, iSerialNumber);
}


template<class T>
CHandle<T>::CHandle(const CBaseHandle &handle)
    : CBaseHandle(handle)
{
}


template<class T>
CHandle<T>::CHandle(T *pObj)
{
    Term();
    Set(pObj);
}


template<class T>
inline CHandle<T> CHandle<T>::FromIndex(int index)
{
    CHandle<T> ret;
    ret.m_Index = index;
    return ret;
}


template<class T>
inline T* CHandle<T>::Get() const
{
    return (T*)CBaseHandle::Get();
}


template<class T>
inline CHandle<T>::operator T *()
{
    return Get();
}

template<class T>
inline CHandle<T>::operator T *() const
{
    return Get();
}


template<class T>
inline bool CHandle<T>::operator !() const
{
    return !Get();
}

template<class T>
inline bool CHandle<T>::operator==(T *val) const
{
    return Get() == val;
}

template<class T>
inline bool CHandle<T>::operator!=(T *val) const
{
    return Get() != val;
}

template<class T>
void CHandle<T>::Set(const T* pVal)
{
    CBaseHandle::Set(reinterpret_cast<const IHandleEntity*>(pVal));
}

template<class T>
inline const CBaseHandle& CHandle<T>::operator=(const T *val)
{
    Set(val);
    return *this;
}

template<class T>
T* CHandle<T>::operator -> () const
{
    return Get();
}
```

`CSGOSimple/valve_sdk/misc/Enums.hpp`:

```hpp
#pragma once

enum ECstrike15UserMessages
{
    CS_UM_VGUIMenu = 1,
    CS_UM_Geiger = 2,
    CS_UM_Train = 3,
    CS_UM_HudText = 4,
    CS_UM_SayText = 5,
    CS_UM_SayText2 = 6,
    CS_UM_TextMsg = 7,
    CS_UM_HudMsg = 8,
    CS_UM_ResetHud = 9,
    CS_UM_GameTitle = 10,
    CS_UM_Shake = 12,
    CS_UM_Fade = 13,
    CS_UM_Rumble = 14,
    CS_UM_CloseCaption = 15,
    CS_UM_CloseCaptionDirect = 16,
    CS_UM_SendAudio = 17,
    CS_UM_RawAudio = 18,
    CS_UM_VoiceMask = 19,
    CS_UM_RequestState = 20,
    CS_UM_Damage = 21,
    CS_UM_RadioText = 22,
    CS_UM_HintText = 23,
    CS_UM_KeyHintText = 24,
    CS_UM_ProcessSpottedEntityUpdate = 25,
    CS_UM_ReloadEffect = 26,
    CS_UM_AdjustMoney = 27,
    CS_UM_UpdateTeamMoney = 28,
    CS_UM_StopSpectatorMode = 29,
    CS_UM_KillCam = 30,
    CS_UM_DesiredTimescale = 31,
    CS_UM_CurrentTimescale = 32,
    CS_UM_AchievementEvent = 33,
    CS_UM_MatchEndConditions = 34,
    CS_UM_DisconnectToLobby = 35,
    CS_UM_PlayerStatsUpdate = 36,
    CS_UM_DisplayInventory = 37,
    CS_UM_WarmupHasEnded = 38,
    CS_UM_ClientInfo = 39,
    CS_UM_XRankGet = 40,
    CS_UM_XRankUpd = 41,
    CS_UM_CallVoteFailed = 45,
    CS_UM_VoteStart = 46,
    CS_UM_VotePass = 47,
    CS_UM_VoteFailed = 48,
    CS_UM_VoteSetup = 49,
    CS_UM_ServerRankRevealAll = 50,
    CS_UM_SendLastKillerDamageToClient = 51,
    CS_UM_ServerRankUpdate = 52,
    CS_UM_ItemPickup = 53,
    CS_UM_ShowMenu = 54,
    CS_UM_BarTime = 55,
    CS_UM_AmmoDenied = 56,
    CS_UM_MarkAchievement = 57,
    CS_UM_MatchStatsUpdate = 58,
    CS_UM_ItemDrop = 59,
    CS_UM_GlowPropTurnOff = 60,
    CS_UM_SendPlayerItemDrops = 61,
    CS_UM_RoundBackupFilenames = 62,
    CS_UM_SendPlayerItemFound = 63,
    CS_UM_ReportHit = 64,
    CS_UM_XpUpdate = 65,
    CS_UM_QuestProgress = 66,
    CS_UM_ScoreLeaderboardData = 67,
    CS_UM_PlayerDecalDigitalSignature = 68,
    MAX_ECSTRIKE15USERMESSAGES
};


enum ItemDefinitionIndex
{
	WEAPON_INVALID = -1,
	WEAPON_DEAGLE = 1,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_GLOCK,
	WEAPON_AK47 = 7,
	WEAPON_AUG,
	WEAPON_AWP,
	WEAPON_FAMAS,
	WEAPON_G3SG1,
	WEAPON_GALILAR = 13,
	WEAPON_M249,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10,
	WEAPON_P90 = 19,
	WEAPON_MP5 = 23,
	WEAPON_UMP45,
	WEAPON_XM1014,
	WEAPON_BIZON,
	WEAPON_MAG7,
	WEAPON_NEGEV,
	WEAPON_SAWEDOFF,
	WEAPON_TEC9,
	WEAPON_TASER,
	WEAPON_HKP2000,
	WEAPON_MP7,
	WEAPON_MP9,
	WEAPON_NOVA,
	WEAPON_P250,
	WEAPON_SHIELD,
	WEAPON_SCAR20,
	WEAPON_SG556,
	WEAPON_SSG08,
	WEAPON_KNIFEGG,
	WEAPON_KNIFE,
	WEAPON_FLASHBANG,
	WEAPON_HEGRENADE,
	WEAPON_SMOKEGRENADE,
	WEAPON_MOLOTOV,
	WEAPON_DECOY,
	WEAPON_INCGRENADE,
	WEAPON_C4,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER,
	WEAPON_USP_SILENCER,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS,
	WEAPON_BREACHCHARGE,
	WEAPON_TABLET = 72,
	WEAPON_MELEE = 74,
	WEAPON_AXE,
	WEAPON_HAMMER,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB,
	WEAPON_DIVERSION,
	WEAPON_FRAG_GRENADE,
	WEAPON_SNOWBALL,
	WEAPON_BUMPMINE,
	WEAPON_BAYONET = 500,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT,
	WEAPON_KNIFE_KARAMBIT,
	WEAPON_KNIFE_M9_BAYONET,
	WEAPON_KNIFE_TACTICAL,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY,
	WEAPON_KNIFE_PUSH,
	WEAPON_KNIFE_URSUS = 519,
	WEAPON_KNIFE_GYPSY_JACKKNIFE,
	WEAPON_KNIFE_STILETTO = 522,
	WEAPON_KNIFE_WIDOWMAKER,
	GLOVE_STUDDED_BLOODHOUND = 5027,
	GLOVE_T_SIDE = 5028,
	GLOVE_CT_SIDE = 5029,
	GLOVE_SPORTY = 5030,
	GLOVE_SLICK = 5031,
	GLOVE_LEATHER_WRAP = 5032,
	GLOVE_MOTORCYCLE = 5033,
	GLOVE_SPECIALIST = 5034,
	GLOVE_HYDRA = 5035
};

enum ClassId {
	ClassId_CAI_BaseNPC = 0,
	ClassId_CAK47,
	ClassId_CBaseAnimating,
	ClassId_CBaseAnimatingOverlay,
	ClassId_CBaseAttributableItem,
	ClassId_CBaseButton,
	ClassId_CBaseCombatCharacter,
	ClassId_CBaseCombatWeapon,
	ClassId_CBaseCSGrenade,
	ClassId_CBaseCSGrenadeProjectile,
	ClassId_CBaseDoor,
	ClassId_CBaseEntity,
	ClassId_CBaseFlex,
	ClassId_CBaseGrenade,
	ClassId_CBaseParticleEntity,
	ClassId_CBasePlayer,
	ClassId_CBasePropDoor,
	ClassId_CBaseTeamObjectiveResource,
	ClassId_CBaseTempEntity,
	ClassId_CBaseToggle,
	ClassId_CBaseTrigger,
	ClassId_CBaseViewModel,
	ClassId_CBaseVPhysicsTrigger,
	ClassId_CBaseWeaponWorldModel,
	ClassId_CBeam,
	ClassId_CBeamSpotlight,
	ClassId_CBoneFollower,
	ClassId_CBRC4Target,
	ClassId_CBreachCharge,
	ClassId_CBreachChargeProjectile,
	ClassId_CBreakableProp,
	ClassId_CBreakableSurface,
	ClassId_CBumpMine,
	ClassId_CBumpMineProjectile,
	ClassId_CC4,
	ClassId_CCascadeLight,
	ClassId_CChicken,
	ClassId_CColorCorrection,
	ClassId_CColorCorrectionVolume,
	ClassId_CCSGameRulesProxy,
	ClassId_CCSPlayer,
	ClassId_CCSPlayerResource,
	ClassId_CCSRagdoll,
	ClassId_CCSTeam,
	ClassId_CDangerZone,
	ClassId_CDangerZoneController,
	ClassId_CDEagle,
	ClassId_CDecoyGrenade,
	ClassId_CDecoyProjectile,
	ClassId_CDrone,
	ClassId_CDronegun,
	ClassId_CDynamicLight,
	ClassId_CDynamicProp,
	ClassId_CEconEntity,
	ClassId_CEconWearable,
	ClassId_CEmbers,
	ClassId_CEntityDissolve,
	ClassId_CEntityFlame,
	ClassId_CEntityFreezing,
	ClassId_CEntityParticleTrail,
	ClassId_CEnvAmbientLight,
	ClassId_CEnvDetailController,
	ClassId_CEnvDOFController,
	ClassId_CEnvGasCanister,
	ClassId_CEnvParticleScript,
	ClassId_CEnvProjectedTexture,
	ClassId_CEnvQuadraticBeam,
	ClassId_CEnvScreenEffect,
	ClassId_CEnvScreenOverlay,
	ClassId_CEnvTonemapController,
	ClassId_CEnvWind,
	ClassId_CFEPlayerDecal,
	ClassId_CFireCrackerBlast,
	ClassId_CFireSmoke,
	ClassId_CFireTrail,
	ClassId_CFish,
	ClassId_CFists,
	ClassId_CFlashbang,
	ClassId_CFogController,
	ClassId_CFootstepControl,
	ClassId_CFunc_Dust,
	ClassId_CFunc_LOD,
	ClassId_CFuncAreaPortalWindow,
	ClassId_CFuncBrush,
	ClassId_CFuncConveyor,
	ClassId_CFuncLadder,
	ClassId_CFuncMonitor,
	ClassId_CFuncMoveLinear,
	ClassId_CFuncOccluder,
	ClassId_CFuncReflectiveGlass,
	ClassId_CFuncRotating,
	ClassId_CFuncSmokeVolume,
	ClassId_CFuncTrackTrain,
	ClassId_CGameRulesProxy,
	ClassId_CGrassBurn,
	ClassId_CHandleTest,
	ClassId_CHEGrenade,
	ClassId_CHostage,
	ClassId_CHostageCarriableProp,
	ClassId_CIncendiaryGrenade,
	ClassId_CInferno,
	ClassId_CInfoLadderDismount,
	ClassId_CInfoMapRegion,
	ClassId_CInfoOverlayAccessor,
	ClassId_CItem_Healthshot,
	ClassId_CItemCash,
	ClassId_CItemDogtags,
	ClassId_CKnife,
	ClassId_CKnifeGG,
	ClassId_CLightGlow,
	ClassId_CMaterialModifyControl,
	ClassId_CMelee,
	ClassId_CMolotovGrenade,
	ClassId_CMolotovProjectile,
	ClassId_CMovieDisplay,
	ClassId_CParadropChopper,
	ClassId_CParticleFire,
	ClassId_CParticlePerformanceMonitor,
	ClassId_CParticleSystem,
	ClassId_CPhysBox,
	ClassId_CPhysBoxMultiplayer,
	ClassId_CPhysicsProp,
	ClassId_CPhysicsPropMultiplayer,
	ClassId_CPhysMagnet,
	ClassId_CPhysPropAmmoBox,
	ClassId_CPhysPropLootCrate,
	ClassId_CPhysPropRadarJammer,
	ClassId_CPhysPropWeaponUpgrade,
	ClassId_CPlantedC4,
	ClassId_CPlasma,
	ClassId_CPlayerPing,
	ClassId_CPlayerResource,
	ClassId_CPointCamera,
	ClassId_CPointCommentaryNode,
	ClassId_CPointWorldText,
	ClassId_CPoseController,
	ClassId_CPostProcessController,
	ClassId_CPrecipitation,
	ClassId_CPrecipitationBlocker,
	ClassId_CPredictedViewModel,
	ClassId_CProp_Hallucination,
	ClassId_CPropCounter,
	ClassId_CPropDoorRotating,
	ClassId_CPropJeep,
	ClassId_CPropVehicleDriveable,
	ClassId_CRagdollManager,
	ClassId_CRagdollProp,
	ClassId_CRagdollPropAttached,
	ClassId_CRopeKeyframe,
	ClassId_CSCAR17,
	ClassId_CSceneEntity,
	ClassId_CSensorGrenade,
	ClassId_CSensorGrenadeProjectile,
	ClassId_CShadowControl,
	ClassId_CSlideshowDisplay,
	ClassId_CSmokeGrenade,
	ClassId_CSmokeGrenadeProjectile,
	ClassId_CSmokeStack,
	ClassId_CSnowball,
	ClassId_CSnowballPile,
	ClassId_CSnowballProjectile,
	ClassId_CSpatialEntity,
	ClassId_CSpotlightEnd,
	ClassId_CSprite,
	ClassId_CSpriteOriented,
	ClassId_CSpriteTrail,
	ClassId_CStatueProp,
	ClassId_CSteamJet,
	ClassId_CSun,
	ClassId_CSunlightShadowControl,
	ClassId_CSurvivalSpawnChopper,
	ClassId_CTablet,
	ClassId_CTeam,
	ClassId_CTeamplayRoundBasedRulesProxy,
	ClassId_CTEArmorRicochet,
	ClassId_CTEBaseBeam,
	ClassId_CTEBeamEntPoint,
	ClassId_CTEBeamEnts,
	ClassId_CTEBeamFollow,
	ClassId_CTEBeamLaser,
	ClassId_CTEBeamPoints,
	ClassId_CTEBeamRing,
	ClassId_CTEBeamRingPoint,
	ClassId_CTEBeamSpline,
	ClassId_CTEBloodSprite,
	ClassId_CTEBloodStream,
	ClassId_CTEBreakModel,
	ClassId_CTEBSPDecal,
	ClassId_CTEBubbles,
	ClassId_CTEBubbleTrail,
	ClassId_CTEClientProjectile,
	ClassId_CTEDecal,
	ClassId_CTEDust,
	ClassId_CTEDynamicLight,
	ClassId_CTEEffectDispatch,
	ClassId_CTEEnergySplash,
	ClassId_CTEExplosion,
	ClassId_CTEFireBullets,
	ClassId_CTEFizz,
	ClassId_CTEFootprintDecal,
	ClassId_CTEFoundryHelpers,
	ClassId_CTEGaussExplosion,
	ClassId_CTEGlowSprite,
	ClassId_CTEImpact,
	ClassId_CTEKillPlayerAttachments,
	ClassId_CTELargeFunnel,
	ClassId_CTEMetalSparks,
	ClassId_CTEMuzzleFlash,
	ClassId_CTEParticleSystem,
	ClassId_CTEPhysicsProp,
	ClassId_CTEPlantBomb,
	ClassId_CTEPlayerAnimEvent,
	ClassId_CTEPlayerDecal,
	ClassId_CTEProjectedDecal,
	ClassId_CTERadioIcon,
	ClassId_CTEShatterSurface,
	ClassId_CTEShowLine,
	ClassId_CTesla,
	ClassId_CTESmoke,
	ClassId_CTESparks,
	ClassId_CTESprite,
	ClassId_CTESpriteSpray,
	ClassId_CTest_ProxyToggle_Networkable,
	ClassId_CTestTraceline,
	ClassId_CTEWorldDecal,
	ClassId_CTriggerPlayerMovement,
	ClassId_CTriggerSoundOperator,
	ClassId_CVGuiScreen,
	ClassId_CVoteController,
	ClassId_CWaterBullet,
	ClassId_CWaterLODControl,
	ClassId_CWeaponAug,
	ClassId_CWeaponAWP,
	ClassId_CWeaponBaseItem,
	ClassId_CWeaponBizon,
	ClassId_CWeaponCSBase,
	ClassId_CWeaponCSBaseGun,
	ClassId_CWeaponCycler,
	ClassId_CWeaponElite,
	ClassId_CWeaponFamas,
	ClassId_CWeaponFiveSeven,
	ClassId_CWeaponG3SG1,
	ClassId_CWeaponGalil,
	ClassId_CWeaponGalilAR,
	ClassId_CWeaponGlock,
	ClassId_CWeaponHKP2000,
	ClassId_CWeaponM249,
	ClassId_CWeaponM3,
	ClassId_CWeaponM4A1,
	ClassId_CWeaponMAC10,
	ClassId_CWeaponMag7,
	ClassId_CWeaponMP5Navy,
	ClassId_CWeaponMP7,
	ClassId_CWeaponMP9,
	ClassId_CWeaponNegev,
	ClassId_CWeaponNOVA,
	ClassId_CWeaponP228,
	ClassId_CWeaponP250,
	ClassId_CWeaponP90,
	ClassId_CWeaponSawedoff,
	ClassId_CWeaponSCAR20,
	ClassId_CWeaponScout,
	ClassId_CWeaponSG550,
	ClassId_CWeaponSG552,
	ClassId_CWeaponSG556,
	ClassId_CWeaponShield,
	ClassId_CWeaponSSG08,
	ClassId_CWeaponTaser,
	ClassId_CWeaponTec9,
	ClassId_CWeaponTMP,
	ClassId_CWeaponUMP45,
	ClassId_CWeaponUSP,
	ClassId_CWeaponXM1014,
	ClassId_CWorld,
	ClassId_CWorldVguiText,
	ClassId_DustTrail,
	ClassId_MovieExplosion,
	ClassId_ParticleSmokeGrenade,
	ClassId_RocketTrail,
	ClassId_SmokeTrail,
	ClassId_SporeExplosion,
	ClassId_SporeTrail,
};


enum ECSPlayerBones
{
    PELVIS = 0,
    SPINE_0,
    SPINE_1,
    SPINE_2,
    SPINE_3,
    NECK_0,
    HEAD_0,
    CLAVICLE_L,
    ARM_UPPER_L,
    ARM_LOWER_L,
    HAND_L,
    FINGER_MIDDLE_META_L,
    FINGER_MIDDLE_0_L,
    FINGER_MIDDLE_1_L,
    FINGER_MIDDLE_2_L,
    FINGER_PINKY_META_L,
    FINGER_PINKY_0_L,
    FINGER_PINKY_1_L,
    FINGER_PINKY_2_L,
    FINGER_INDEX_META_L,
    FINGER_INDEX_0_L,
    FINGER_INDEX_1_L,
    FINGER_INDEX_2_L,
    FINGER_THUMB_0_L,
    FINGER_THUMB_1_L,
    FINGER_THUMB_2_L,
    FINGER_RING_META_L,
    FINGER_RING_0_L,
    FINGER_RING_1_L,
    FINGER_RING_2_L,
    WEAPON_HAND_L,
    ARM_LOWER_L_TWIST,
    ARM_LOWER_L_TWIST1,
    ARM_UPPER_L_TWIST,
    ARM_UPPER_L_TWIST1,
    CLAVICLE_R,
    ARM_UPPER_R,
    ARM_LOWER_R,
    HAND_R,
    FINGER_MIDDLE_META_R,
    FINGER_MIDDLE_0_R,
    FINGER_MIDDLE_1_R,
    FINGER_MIDDLE_2_R,
    FINGER_PINKY_META_R,
    FINGER_PINKY_0_R,
    FINGER_PINKY_1_R,
    FINGER_PINKY_2_R,
    FINGER_INDEX_META_R,
    FINGER_INDEX_0_R,
    FINGER_INDEX_1_R,
    FINGER_INDEX_2_R,
    FINGER_THUMB_0_R,
    FINGER_THUMB_1_R,
    FINGER_THUMB_2_R,
    FINGER_RING_META_R,
    FINGER_RING_0_R,
    FINGER_RING_1_R,
    FINGER_RING_2_R,
    WEAPON_HAND_R,
    ARM_LOWER_R_TWIST,
    ARM_LOWER_R_TWIST1,
    ARM_UPPER_R_TWIST,
    ARM_UPPER_R_TWIST1,
    LEG_UPPER_L,
    LEG_LOWER_L,
    ANKLE_L,
    BALL_L,
    LFOOT_LOCK,
    LEG_UPPER_L_TWIST,
    LEG_UPPER_L_TWIST1,
    LEG_UPPER_R,
    LEG_LOWER_R,
    ANKLE_R,
    BALL_R,
    RFOOT_LOCK,
    LEG_UPPER_R_TWIST,
    LEG_UPPER_R_TWIST1,
    FINGER_PINKY_L_END,
    FINGER_PINKY_R_END,
    VALVEBIPED_WEAPON_BONE,
    LH_IK_DRIVER,
    PRIMARY_JIGGLE_JNT,
    MAX_ECSPLAYERBONES
};

enum EntityFlags
{
	FL_ONGROUND = (1 << 0), 	// At rest / on the ground
	FL_DUCKING = (1 << 1),		// Player flag -- Player is fully crouched
	FL_WATERJUMP = (1 << 2),	// player jumping out of water
	FL_ONTRAIN = (1 << 3),		// Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
	FL_INRAIN = (1 << 4),		// Indicates the entity is standing in rain
	FL_FROZEN = (1 << 5),		// Player is frozen for 3rd person camera
	FL_ATCONTROLS = (1 << 6),	// Player can't move, but keeps key inputs for controlling another entity
	FL_CLIENT = (1 << 7),		// Is a player
	FL_FAKECLIENT = (1 << 8),	// Fake client, simulated server side; don't send network messages to them
	FL_INWATER = (1 << 10),		// In water
};

enum LifeState : unsigned char
{
    LIFE_ALIVE = 0,// alive
    LIFE_DYING = 1, // playing death animation or still falling off of a ledge waiting to hit ground
    LIFE_DEAD = 2, // dead. lying still.
    MAX_LIFESTATE
};

enum WeaponSound_t
{
    EMPTY,
    SINGLE,
    SINGLE_NPC,
    WPN_DOUBLE, // Can't be "DOUBLE" because windows.h uses it.
    DOUBLE_NPC,
    BURST,
    RELOAD,
    RELOAD_NPC,
    MELEE_MISS,
    MELEE_HIT,
    MELEE_HIT_WORLD,
    SPECIAL1,
    SPECIAL2,
    SPECIAL3,
    TAUNT,
    FAST_RELOAD,
    // Add new shoot sound types here
    REVERSE_THE_NEW_SOUND,
    NUM_SHOOT_SOUND_TYPES,
    MAX_WEAPONSOUND
};

enum MoveType_t
{
    MOVETYPE_NONE = 0,
    MOVETYPE_ISOMETRIC,
    MOVETYPE_WALK,
    MOVETYPE_STEP,
    MOVETYPE_FLY,
    MOVETYPE_FLYGRAVITY,
    MOVETYPE_VPHYSICS,
    MOVETYPE_PUSH,
    MOVETYPE_NOCLIP,
    MOVETYPE_LADDER,
    MOVETYPE_OBSERVER,
    MOVETYPE_CUSTOM,
    MOVETYPE_LAST = MOVETYPE_CUSTOM,
    MOVETYPE_MAX_BITS = 4,
    MAX_MOVETYPE
};

```

`CSGOSimple/valve_sdk/misc/GlobalVars.hpp`:

```hpp
#pragma once

class CGlobalVarsBase
{
public:
    float     realtime;                     // 0x0000
    int       framecount;                   // 0x0004
    float     absoluteframetime;            // 0x0008
    float     absoluteframestarttimestddev; // 0x000C
    float     curtime;                      // 0x0010
    float     frametime;                    // 0x0014
    int       maxClients;                   // 0x0018
    int       tickcount;                    // 0x001C
    float     interval_per_tick;            // 0x0020
    float     interpolation_amount;         // 0x0024
    int       simTicksThisFrame;            // 0x0028
    int       network_protocol;             // 0x002C
    void*     pSaveData;                    // 0x0030
    bool      m_bClient;                    // 0x0031
    bool      m_bRemoteClient;              // 0x0032

private:
    // 100 (i.e., tickcount is rounded down to this base and then the "delta" from this base is networked
    int       nTimestampNetworkingBase;
    // 32 (entindex() % nTimestampRandomizeWindow ) is subtracted from gpGlobals->tickcount to Set the networking basis, prevents
    //  all of the entities from forcing a new PackedEntity on the same tick (i.e., prevents them from getting lockstepped on this)
    int       nTimestampRandomizeWindow;
};
```

`CSGOSimple/valve_sdk/misc/IHandleEntity.hpp`:

```hpp
#pragma once

class CBaseHandle;

class IHandleEntity
{
public:
    virtual ~IHandleEntity() {}
    virtual void SetRefEHandle(const CBaseHandle &handle) = 0;
    virtual const CBaseHandle& GetRefEHandle() const = 0;
};
```

`CSGOSimple/valve_sdk/misc/Recv.hpp`:

```hpp
#pragma once

#include <string>

enum SendPropType
{
    DPT_Int = 0,
    DPT_Float,
    DPT_Vector,
    DPT_VectorXY,
    DPT_String,
    DPT_Array,
    DPT_DataTable,
    DPT_Int64,
    DPT_NUMSendPropTypes
};

class DVariant
{
public:
    union
    {
        float	   m_Float;
        long	   m_Int;
        char*    m_pString;
        void*    m_pData;
        float	   m_Vector[3];
        __int64  m_Int64;
    };
    SendPropType  m_Type;
};

class RecvTable;
class RecvProp;

class CRecvProxyData
{
public:
    const RecvProp*     m_pRecvProp;        // The property it's receiving.
    DVariant		    m_Value;            // The value given to you to store.
    int				    m_iElement;         // Which array element you're getting.
    int				    m_ObjectID;         // The object being referred to.
};

//-----------------------------------------------------------------------------
// pStruct = the base structure of the datatable this variable is in (like C_BaseEntity)
// pOut    = the variable that this this proxy represents (like C_BaseEntity::m_SomeValue).
//
// Convert the network-standard-type value in m_Value into your own format in pStruct/pOut.
//-----------------------------------------------------------------------------
typedef void(*RecvVarProxyFn)(const CRecvProxyData *pData, void *pStruct, void *pOut);

// ------------------------------------------------------------------------ //
// ArrayLengthRecvProxies are optionally used to Get the length of the 
// incoming array when it changes.
// ------------------------------------------------------------------------ //
typedef void(*ArrayLengthRecvProxyFn)(void *pStruct, int objectID, int currentArrayLength);

// NOTE: DataTable receive proxies work differently than the other proxies.
// pData points at the object + the recv table's offset.
// pOut should be Set to the location of the object to unpack the data table into.
// If the parent object just contains the child object, the default proxy just does *pOut = pData.
// If the parent object points at the child object, you need to dereference the pointer here.
// NOTE: don't ever return null from a DataTable receive proxy function. Bad things will happen.
typedef void(*DataTableRecvVarProxyFn)(const RecvProp *pProp, void **pOut, void *pData, int objectID);

class RecvProp
{
public:
    char*                   m_pVarName;
    SendPropType            m_RecvType;
    int                     m_Flags;
    int                     m_StringBufferSize;
    int                     m_bInsideArray;
    const void*             m_pExtraData;
    RecvProp*               m_pArrayProp;
    ArrayLengthRecvProxyFn  m_ArrayLengthProxy;
    RecvVarProxyFn          m_ProxyFn;
    DataTableRecvVarProxyFn m_DataTableProxyFn;
    RecvTable*              m_pDataTable;
    int                     m_Offset;
    int                     m_ElementStride;
    int                     m_nElements;
    const char*             m_pParentArrayPropName;

    RecvVarProxyFn			GetProxyFn() const;
    void					SetProxyFn(RecvVarProxyFn fn);
    DataTableRecvVarProxyFn	GetDataTableProxyFn() const;
    void					SetDataTableProxyFn(DataTableRecvVarProxyFn fn);

};

class RecvTable
{
public:
    RecvProp*               m_pProps;
    int                     m_nProps;
    void*                   m_pDecoder;
    char*                   m_pNetTableName;
    bool                    m_bInitialized;
    bool                    m_bInMainList;
};

inline RecvVarProxyFn RecvProp::GetProxyFn() const
{
    return m_ProxyFn;
}

inline void RecvProp::SetProxyFn(RecvVarProxyFn fn)
{
    m_ProxyFn = fn;
}

inline DataTableRecvVarProxyFn RecvProp::GetDataTableProxyFn() const
{
    return m_DataTableProxyFn;
}

inline void RecvProp::SetDataTableProxyFn(DataTableRecvVarProxyFn fn)
{
    m_DataTableProxyFn = fn;
}
```

`CSGOSimple/valve_sdk/misc/Studio.hpp`:

```hpp
#pragma once

#include "../math/Vector.hpp"

typedef float Quaternion[4];
typedef float RadianEuler[3];

#define MAX_QPATH  260

#define BONE_CALCULATE_MASK             0x1F
#define BONE_PHYSICALLY_SIMULATED       0x01    // bone is physically simulated when physics are active
#define BONE_PHYSICS_PROCEDURAL         0x02    // procedural when physics is active
#define BONE_ALWAYS_PROCEDURAL          0x04    // bone is always procedurally animated
#define BONE_SCREEN_ALIGN_SPHERE        0x08    // bone aligns to the screen, not constrained in motion.
#define BONE_SCREEN_ALIGN_CYLINDER      0x10    // bone aligns to the screen, constrained by it's own axis.

#define BONE_USED_MASK                  0x0007FF00
#define BONE_USED_BY_ANYTHING           0x0007FF00
#define BONE_USED_BY_HITBOX             0x00000100    // bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT         0x00000200    // bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK        0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0        0x00000400    // bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1        0x00000800    
#define BONE_USED_BY_VERTEX_LOD2        0x00001000  
#define BONE_USED_BY_VERTEX_LOD3        0x00002000
#define BONE_USED_BY_VERTEX_LOD4        0x00004000
#define BONE_USED_BY_VERTEX_LOD5        0x00008000
#define BONE_USED_BY_VERTEX_LOD6        0x00010000
#define BONE_USED_BY_VERTEX_LOD7        0x00020000
#define BONE_USED_BY_BONE_MERGE         0x00040000    // bone is available for bone merge to occur against it

#define BONE_USED_BY_VERTEX_AT_LOD(lod) ( BONE_USED_BY_VERTEX_LOD0 << (lod) )
#define BONE_USED_BY_ANYTHING_AT_LOD(lod) ( ( BONE_USED_BY_ANYTHING & ~BONE_USED_BY_VERTEX_MASK ) | BONE_USED_BY_VERTEX_AT_LOD(lod) )

#define MAX_NUM_LODS 8
#define MAXSTUDIOBONES		128		// total bones actually used

#define BONE_TYPE_MASK                  0x00F00000
#define BONE_FIXED_ALIGNMENT            0x00100000    // bone can't spin 360 degrees, all interpolation is normalized around a fixed orientation

#define BONE_HAS_SAVEFRAME_POS          0x00200000    // Vector48
#define BONE_HAS_SAVEFRAME_ROT64        0x00400000    // Quaternion64
#define BONE_HAS_SAVEFRAME_ROT32        0x00800000    // Quaternion32


#define HITGROUP_GENERIC 0
#define HITGROUP_HEAD 1
#define HITGROUP_CHEST 2
#define HITGROUP_STOMACH 3
#define HITGROUP_LEFTARM 4    
#define HITGROUP_RIGHTARM 5
#define HITGROUP_LEFTLEG 6
#define HITGROUP_RIGHTLEG 7
#define HITGROUP_GEAR 10

enum modtype_t
{
    mod_bad = 0,
    mod_brush,
    mod_sprite,
    mod_studio
};

enum Hitboxes
{
	HITBOX_HEAD,
	HITBOX_NECK,
	HITBOX_PELVIS,
	HITBOX_STOMACH,
	HITBOX_LOWER_CHEST,
	HITBOX_CHEST,
	HITBOX_UPPER_CHEST,
	HITBOX_RIGHT_THIGH,
	HITBOX_LEFT_THIGH,
	HITBOX_RIGHT_CALF,
	HITBOX_LEFT_CALF,
	HITBOX_RIGHT_FOOT,
	HITBOX_LEFT_FOOT,
	HITBOX_RIGHT_HAND,
	HITBOX_LEFT_HAND,
	HITBOX_RIGHT_UPPER_ARM,
	HITBOX_RIGHT_FOREARM,
	HITBOX_LEFT_UPPER_ARM,
	HITBOX_LEFT_FOREARM,
	HITBOX_MAX
};


typedef unsigned short MDLHandle_t;


struct mstudiobone_t
{
	int                    sznameindex;
	inline char * const    pszName(void) const { return ((char *)this) + sznameindex; }
	int                    parent;
	int                    bonecontroller[6];    // bone controller index, -1 == none
	Vector                 pos;
	Quaternion             quat;
	RadianEuler            rot;
	// compression scale
	Vector                 posscale;
	Vector                 rotscale;

	matrix3x4_t            poseToBone;
	Quaternion             qAlignment;
	int                    flags;
	int                    proctype;
	int                    procindex;
	mutable int            physicsbone;
	inline void *          pProcedure() const { if (procindex == 0) return NULL; else return  (void *)(((byte *)this) + procindex); };
	int                    surfacepropidx;
	inline char * const    pszSurfaceProp(void) const { return ((char *)this) + surfacepropidx; }
	inline int             GetSurfaceProp(void) const { return surfacepropLookup; }

	int                    contents;
	int                    surfacepropLookup;
	int                    m_iPad01[7];

	mstudiobone_t() {}
private:
	// No copy constructors allowed
	mstudiobone_t(const mstudiobone_t& vOther);
};


struct mstudiobbox_t
{
    int         bone;
    int         group;
    Vector      bbmin;
    Vector      bbmax;
    int         szhitboxnameindex;
    int32_t     m_iPad01[3];
    float       m_flRadius;
    int32_t     m_iPad02[4];

    const char* GetName()
    {
        if(!szhitboxnameindex) return nullptr;
        return (const char*)((uint8_t*)this + szhitboxnameindex);
    }
};

struct mstudiohitboxset_t
{
    int    sznameindex;
    int    numhitboxes;
    int    hitboxindex;

    const char* GetName()
    {
        if(!sznameindex) return nullptr;
        return (const char*)((uint8_t*)this + sznameindex);
    }

    mstudiobbox_t* GetHitbox(int i)
    {
        if(i > numhitboxes) return nullptr;
        return (mstudiobbox_t*)((uint8_t*)this + hitboxindex) + i;
    }
};

struct model_t
{
    void*   fnHandle;               //0x0000 
    char    szName[260];            //0x0004 
    __int32 nLoadFlags;             //0x0108 
    __int32 nServerCount;           //0x010C 
    __int32 type;                   //0x0110 
    __int32 flags;                  //0x0114 
    Vector  vecMins;                //0x0118 
    Vector  vecMaxs;                //0x0124 
    float   radius;                 //0x0130 
    char    pad[0x1C];              //0x0134
};//Size=0x0150

class studiohdr_t
{
public:
    __int32 id;                     //0x0000 
    __int32 version;                //0x0004 
    long    checksum;               //0x0008 
    char    szName[64];             //0x000C 
    __int32 length;                 //0x004C 
    Vector  vecEyePos;              //0x0050 
    Vector  vecIllumPos;            //0x005C 
    Vector  vecHullMin;             //0x0068 
    Vector  vecHullMax;             //0x0074 
    Vector  vecBBMin;               //0x0080 
    Vector  vecBBMax;               //0x008C 
    __int32 flags;                  //0x0098 
    __int32 numbones;               //0x009C 
    __int32 boneindex;              //0x00A0 
    __int32 numbonecontrollers;     //0x00A4 
    __int32 bonecontrollerindex;    //0x00A8 
    __int32 numhitboxsets;          //0x00AC 
    __int32 hitboxsetindex;         //0x00B0 
    __int32 numlocalanim;           //0x00B4 
    __int32 localanimindex;         //0x00B8 
    __int32 numlocalseq;            //0x00BC 
    __int32 localseqindex;          //0x00C0 
    __int32 activitylistversion;    //0x00C4 
    __int32 eventsindexed;          //0x00C8 
    __int32 numtextures;            //0x00CC 
    __int32 textureindex;           //0x00D0

    mstudiohitboxset_t* GetHitboxSet(int i)
    {
        if(i > numhitboxsets) return nullptr;
        return (mstudiohitboxset_t*)((uint8_t*)this + hitboxsetindex) + i;
    }
    mstudiobone_t* GetBone(int i)
    {
        if(i > numbones) return nullptr;
        return (mstudiobone_t*)((uint8_t*)this + boneindex) + i;
    }

};//Size=0x00D4
```

`CSGOSimple/valve_sdk/misc/UtlBuffer.hpp`:

```hpp
//====== Copyright © 1996-2005, Valve Corporation, All rights reserved. =======//
//
// Purpose: 
//
// $NoKeywords: $
//
// Serialization/unserialization buffer
//=============================================================================//
#pragma once

#include <stdarg.h>
#include "../Math/Vector.hpp"
#include "../Math/Vector2D.hpp"
#include "UtlMemory.hpp"

#pragma warning(disable:4127) //conditional operation is constant
#define IsX360() (0)

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
struct characterset_t;
struct typedescription_t;
struct datamap_t;

class CByteswap
{
public:
    CByteswap()
    {
        // Default behavior sets the target endian to match the machine native endian (no swap).
        SetTargetBigEndian(IsMachineBigEndian());
    }

    //-----------------------------------------------------------------------------
    // Write a single field.
    //-----------------------------------------------------------------------------
    void SwapFieldToTargetEndian(void* pOutputBuffer, void *pData, typedescription_t *pField);

    //-----------------------------------------------------------------------------
    // Write a block of fields.  Works a bit like the saverestore code.  
    //-----------------------------------------------------------------------------
    void SwapFieldsToTargetEndian(void *pOutputBuffer, void *pBaseData, datamap_t *pDataMap);

    // Swaps fields for the templated type to the output buffer.
    template<typename T> inline void SwapFieldsToTargetEndian(T* pOutputBuffer, void *pBaseData, unsigned int objectCount = 1)
    {
        for(unsigned int i = 0; i < objectCount; ++i, ++pOutputBuffer) {
            SwapFieldsToTargetEndian((void*)pOutputBuffer, pBaseData, &T::m_DataMap);
            pBaseData = (uint8_t*)pBaseData + sizeof(T);
        }
    }

    // Swaps fields for the templated type in place.
    template<typename T> inline void SwapFieldsToTargetEndian(T* pOutputBuffer, unsigned int objectCount = 1)
    {
        SwapFieldsToTargetEndian<T>(pOutputBuffer, (void*)pOutputBuffer, objectCount);
    }

    //-----------------------------------------------------------------------------
    // True if the current machine is detected as big endian. 
    // (Endienness is effectively detected at compile time when optimizations are
    // enabled)
    //-----------------------------------------------------------------------------
    static bool IsMachineBigEndian()
    {
        short nIsBigEndian = 1;

        // if we are big endian, the first uint8_t will be a 0, if little endian, it will be a one.
        return (bool)(0 == *(char *)&nIsBigEndian);
    }

    //-----------------------------------------------------------------------------
    // Sets the target uint8_t ordering we are swapping to or from.
    //
    // Braindead Endian Reference:
    //		x86 is LITTLE Endian
    //		PowerPC is BIG Endian
    //-----------------------------------------------------------------------------
    inline void SetTargetBigEndian(bool bigEndian)
    {
        m_bBigEndian = bigEndian;
        m_bSwapBytes = IsMachineBigEndian() != bigEndian;
    }

    // Changes target endian
    inline void FlipTargetEndian(void)
    {
        m_bSwapBytes = !m_bSwapBytes;
        m_bBigEndian = !m_bBigEndian;
    }

    // Forces uint8_t swapping state, regardless of endianess
    inline void ActivateByteSwapping(bool bActivate)
    {
        SetTargetBigEndian(IsMachineBigEndian() != bActivate);
    }

    //-----------------------------------------------------------------------------
    // Returns true if the target machine is the same as this one in endianness.
    //
    // Used to determine when a byteswap needs to take place.
    //-----------------------------------------------------------------------------
    inline bool IsSwappingBytes(void)	// Are bytes being swapped?
    {
        return m_bSwapBytes;
    }

    inline bool IsTargetBigEndian(void)	// What is the current target endian?
    {
        return m_bBigEndian;
    }

    //-----------------------------------------------------------------------------
    // IsByteSwapped()
    //
    // When supplied with a chunk of input data and a constant or magic number
    // (in native format) determines the endienness of the current machine in
    // relation to the given input data.
    //
    // Returns:
    //		1  if input is the same as nativeConstant.
    //		0  if input is byteswapped relative to nativeConstant.
    //		-1 if input is not the same as nativeConstant and not byteswapped either.
    //
    // ( This is useful for detecting byteswapping in magic numbers in structure 
    // headers for example. )
    //-----------------------------------------------------------------------------
    template<typename T> inline int SourceIsNativeEndian(T input, T nativeConstant)
    {
        // If it's the same, it isn't byteswapped:
        if(input == nativeConstant)
            return 1;

        int output;
        LowLevelByteSwap<T>(&output, &input);
        if(output == nativeConstant)
            return 0;

        assert(0);		// if we Get here, input is neither a swapped nor unswapped version of nativeConstant.
        return -1;
    }

    //-----------------------------------------------------------------------------
    // Swaps an input buffer full of type T into the given output buffer.
    //
    // Swaps [count] items from the inputBuffer to the outputBuffer.
    // If inputBuffer is omitted or NULL, then it is assumed to be the same as
    // outputBuffer - effectively swapping the contents of the buffer in place.
    //-----------------------------------------------------------------------------
    template<typename T> inline void SwapBuffer(T* outputBuffer, T* inputBuffer = NULL, int count = 1)
    {
        assert(count >= 0);
        assert(outputBuffer);

        // Fail gracefully in release:
        if(count <= 0 || !outputBuffer)
            return;

        // Optimization for the case when we are swapping in place.
        if(inputBuffer == NULL) {
            inputBuffer = outputBuffer;
        }

        // Swap everything in the buffer:
        for(int i = 0; i < count; i++) {
            LowLevelByteSwap<T>(&outputBuffer[i], &inputBuffer[i]);
        }
    }

    //-----------------------------------------------------------------------------
    // Swaps an input buffer full of type T into the given output buffer.
    //
    // Swaps [count] items from the inputBuffer to the outputBuffer.
    // If inputBuffer is omitted or NULL, then it is assumed to be the same as
    // outputBuffer - effectively swapping the contents of the buffer in place.
    //-----------------------------------------------------------------------------
    template<typename T> inline void SwapBufferToTargetEndian(T* outputBuffer, T* inputBuffer = NULL, int count = 1)
    {
        assert(count >= 0);
        assert(outputBuffer);

        // Fail gracefully in release:
        if(count <= 0 || !outputBuffer)
            return;

        // Optimization for the case when we are swapping in place.
        if(inputBuffer == NULL) {
            inputBuffer = outputBuffer;
        }

        // Are we already the correct endienness? ( or are we swapping 1 uint8_t items? )
        if(!m_bSwapBytes || (sizeof(T) == 1)) {
            // If we were just going to swap in place then return.
            if(!inputBuffer)
                return;

            // Otherwise copy the inputBuffer to the outputBuffer:
            memcpy(outputBuffer, inputBuffer, count * sizeof(T));
            return;

        }

        // Swap everything in the buffer:
        for(int i = 0; i < count; i++) {
            LowLevelByteSwap<T>(&outputBuffer[i], &inputBuffer[i]);
        }
    }

private:
    //-----------------------------------------------------------------------------
    // The lowest level uint8_t swapping workhorse of doom.  output always contains the 
    // swapped version of input.  ( Doesn't compare machine to target endianness )
    //-----------------------------------------------------------------------------
    template<typename T> static void LowLevelByteSwap(T *output, T *input)
    {
        T temp = *output;
#if defined( _X360 )
        // Intrinsics need the source type to be fixed-point
        DWORD* word = (DWORD*)input;
        switch(sizeof(T)) {
            case 8:
            {
                __storewordbytereverse(*word, 0, &temp);
                __storewordbytereverse(*(word + 1), 4, &temp);
            }
            break;

            case 4:
                __storewordbytereverse(*word, 0, &temp);
                break;

            case 2:
                __storeshortbytereverse(*input, 0, &temp);
                break;

            default:
                assert("Invalid size in CByteswap::LowLevelByteSwap" && 0);
        }
#else
        for(int i = 0; i < sizeof(T); i++) {
            ((unsigned char*)&temp)[i] = ((unsigned char*)input)[sizeof(T) - (i + 1)];
        }
#endif
        memcpy(output, &temp, sizeof(T));
    }

    unsigned int m_bSwapBytes : 1;
    unsigned int m_bBigEndian : 1;
};

//-----------------------------------------------------------------------------
// Description of character conversions for string output
// Here's an example of how to use the macros to define a character conversion
// BEGIN_CHAR_CONVERSION( CStringConversion, '\\' )
//	{ '\n', "n" },
//	{ '\t', "t" }
// END_CHAR_CONVERSION( CStringConversion, '\\' )
//-----------------------------------------------------------------------------
class CUtlCharConversion
{
public:
    struct ConversionArray_t
    {
        char m_nActualChar;
        char *m_pReplacementString;
    };

    CUtlCharConversion(char nEscapeChar, const char *pDelimiter, int nCount, ConversionArray_t *pArray);
    char GetEscapeChar() const;
    const char *GetDelimiter() const;
    int GetDelimiterLength() const;

    const char *GetConversionString(char c) const;
    int GetConversionLength(char c) const;
    int MaxConversionLength() const;

    // Finds a conversion for the passed-in string, returns length
    virtual char FindConversion(const char *pString, int *pLength);

protected:
    struct ConversionInfo_t
    {
        int m_nLength;
        char *m_pReplacementString;
    };

    char m_nEscapeChar;
    const char *m_pDelimiter;
    int m_nDelimiterLength;
    int m_nCount;
    int m_nMaxConversionLength;
    char m_pList[255];
    ConversionInfo_t m_pReplacements[255];
};

#define BEGIN_CHAR_CONVERSION( _name, _delimiter, _escapeChar )	\
	static CUtlCharConversion::ConversionArray_t s_pConversionArray ## _name[] = {

#define END_CHAR_CONVERSION( _name, _delimiter, _escapeChar ) \
	}; \
	CUtlCharConversion _name( _escapeChar, _delimiter, sizeof( s_pConversionArray ## _name ) / sizeof( CUtlCharConversion::ConversionArray_t ), s_pConversionArray ## _name )

#define BEGIN_CUSTOM_CHAR_CONVERSION( _className, _name, _delimiter, _escapeChar ) \
	static CUtlCharConversion::ConversionArray_t s_pConversionArray ## _name[] = {

#define END_CUSTOM_CHAR_CONVERSION( _className, _name, _delimiter, _escapeChar ) \
	}; \
	_className _name( _escapeChar, _delimiter, sizeof( s_pConversionArray ## _name ) / sizeof( CUtlCharConversion::ConversionArray_t ), s_pConversionArray ## _name )

//-----------------------------------------------------------------------------
// Character conversions for C strings
//-----------------------------------------------------------------------------
CUtlCharConversion *GetCStringCharConversion();

//-----------------------------------------------------------------------------
// Character conversions for quoted strings, with no escape sequences
//-----------------------------------------------------------------------------
CUtlCharConversion *GetNoEscCharConversion();


//-----------------------------------------------------------------------------
// Macro to Set overflow functions easily
//-----------------------------------------------------------------------------
#define SetUtlBufferOverflowFuncs( _get, _put )	\
	SetOverflowFuncs( static_cast <UtlBufferOverflowFunc_t>( _get ), static_cast <UtlBufferOverflowFunc_t>( _put ) )


//-----------------------------------------------------------------------------
// Command parsing..
//-----------------------------------------------------------------------------
class CUtlBuffer
{
public:
    enum SeekType_t
    {
        SEEK_HEAD = 0,
        SEEK_CURRENT,
        SEEK_TAIL
    };

    // flags
    enum BufferFlags_t
    {
        TEXT_BUFFER = 0x1,			// Describes how Get + put work (as strings, or binary)
        EXTERNAL_GROWABLE = 0x2,	// This is used w/ external buffers and causes the utlbuf to switch to reallocatable memory if an overflow happens when Putting.
        CONTAINS_CRLF = 0x4,		// For text buffers only, does this contain \n or \n\r?
        READ_ONLY = 0x8,			// For external buffers; prevents null termination from happening.
        AUTO_TABS_DISABLED = 0x10,	// Used to disable/enable push/pop tabs
    };

    // Overflow functions when a Get or put overflows
    typedef bool (CUtlBuffer::*UtlBufferOverflowFunc_t)(int nSize);

    // Constructors for growable + external buffers for serialization/unserialization
    CUtlBuffer(int growSize = 0, int initSize = 0, int nFlags = 0);
    CUtlBuffer(const void* pBuffer, int size, int nFlags = 0);
    // This one isn't actually defined so that we catch contructors that are trying to pass a bool in as the third param.
    CUtlBuffer(const void *pBuffer, int size, bool crap);

    unsigned char	GetFlags() const;

    // NOTE: This will assert if you attempt to recast it in a way that
    // is not compatible. The only valid conversion is binary-> text w/CRLF
    void			SetBufferType(bool bIsText, bool bContainsCRLF);

    // Makes sure we've got at least this much memory
    void			EnsureCapacity(int num);

    // Attaches the buffer to external memory....
    void			SetExternalBuffer(void* pMemory, int nSize, int nInitialPut, int nFlags = 0);
    bool			IsExternallyAllocated() const;
    void			AssumeMemory(void *pMemory, int nSize, int nInitialPut, int nFlags = 0);

    __forceinline void ActivateByteSwappingIfBigEndian(void)
    {
        if(IsX360())
            ActivateByteSwapping(true);
    }


    // Controls endian-ness of binary utlbufs - default matches the current platform
    void			ActivateByteSwapping(bool bActivate);
    void			SetBigEndian(bool bigEndian);
    bool			IsBigEndian(void);

    // Resets the buffer; but doesn't free memory
    void			Clear();

    // Clears out the buffer; frees memory
    void			Purge();

    // Read stuff out.
    // Binary mode: it'll just read the bits directly in, and characters will be
    //		read for strings until a null character is reached.
    // Text mode: it'll parse the file, turning text #s into real numbers.
    //		GetString will read a string until a space is reached
    char			GetChar();
    unsigned char	GetUnsignedChar();
    short			GetShort();
    unsigned short	GetUnsignedShort();
    int				GetInt();
    int				GetIntHex();
    unsigned int	GetUnsignedInt();
    float			GetFloat();
    double			GetDouble();
    void			GetString(char* pString, int nMaxChars = 0);
    void			Get(void* pMem, int size);
    void			GetLine(char* pLine, int nMaxChars = 0);

    // Used for getting objects that have a byteswap datadesc defined
    template <typename T> void GetObjects(T *dest, int count = 1);

    // This will Get at least 1 uint8_t and up to nSize bytes. 
    // It will return the number of bytes actually read.
    int				GetUpTo(void *pMem, int nSize);

    // This version of GetString converts \" to \\ and " to \, etc.
    // It also reads a " at the beginning and end of the string
    void			GetDelimitedString(CUtlCharConversion *pConv, char *pString, int nMaxChars = 0);
    char			GetDelimitedChar(CUtlCharConversion *pConv);

    // This will return the # of characters of the string about to be read out
    // NOTE: The count will *include* the terminating 0!!
    // In binary mode, it's the number of characters until the next 0
    // In text mode, it's the number of characters until the next space.
    int				PeekStringLength();

    // This version of PeekStringLength converts \" to \\ and " to \, etc.
    // It also reads a " at the beginning and end of the string
    // NOTE: The count will *include* the terminating 0!!
    // In binary mode, it's the number of characters until the next 0
    // In text mode, it's the number of characters between "s (checking for \")
    // Specifying false for bActualSize will return the pre-translated number of characters
    // including the delimiters and the escape characters. So, \n counts as 2 characters when bActualSize == false
    // and only 1 character when bActualSize == true
    int				PeekDelimitedStringLength(CUtlCharConversion *pConv, bool bActualSize = true);

    // Just like scanf, but doesn't work in binary mode
    int				Scanf(const char* pFmt, ...);
    int				VaScanf(const char* pFmt, va_list list);

    // Eats white space, advances Get index
    void			EatWhiteSpace();

    // Eats C++ style comments
    bool			EatCPPComment();

    // (For text buffers only)
    // Parse a token from the buffer:
    // Grab all text that lies between a starting delimiter + ending delimiter
    // (skipping whitespace that leads + trails both delimiters).
    // If successful, the Get index is advanced and the function returns true,
    // otherwise the index is not advanced and the function returns false.
    bool			ParseToken(const char *pStartingDelim, const char *pEndingDelim, char* pString, int nMaxLen);

    // Advance the Get index until after the particular string is found
    // Do not eat whitespace before starting. Return false if it failed
    // String test is case-insensitive.
    bool			GetToken(const char *pToken);

    // Parses the next token, given a Set of character breaks to stop at
    // Returns the length of the token parsed in bytes (-1 if none parsed)
    int				ParseToken(characterset_t *pBreaks, char *pTokenBuf, int nMaxLen, bool bParseComments = true);

    // Write stuff in
    // Binary mode: it'll just write the bits directly in, and strings will be
    //		written with a null terminating character
    // Text mode: it'll convert the numbers to text versions
    //		PutString will not write a terminating character
    void			PutChar(char c);
    void			PutUnsignedChar(unsigned char uc);
    void			PutShort(short s);
    void			PutUnsignedShort(unsigned short us);
    void			PutInt(int i);
    void			PutUnsignedInt(unsigned int u);
    void			PutFloat(float f);
    void			PutDouble(double d);
    void			PutString(const char* pString);
    void			Put(const void* pMem, int size);

    // Used for putting objects that have a byteswap datadesc defined
    template <typename T> void PutObjects(T *src, int count = 1);

    // This version of PutString converts \ to \\ and " to \", etc.
    // It also places " at the beginning and end of the string
    void			PutDelimitedString(CUtlCharConversion *pConv, const char *pString);
    void			PutDelimitedChar(CUtlCharConversion *pConv, char c);

    // Just like printf, writes a terminating zero in binary mode
    void			Printf(const char* pFmt, ...);
    void			VaPrintf(const char* pFmt, va_list list);

    // What am I writing (put)/reading (Get)?
    void* PeekPut(int offset = 0);
    const void* PeekGet(int offset = 0) const;
    const void* PeekGet(int nMaxSize, int nOffset);

    // Where am I writing (put)/reading (Get)?
    int TellPut() const;
    int TellGet() const;

    // What's the most I've ever written?
    int TellMaxPut() const;

    // How many bytes remain to be read?
    // NOTE: This is not accurate for streaming text files; it overshoots
    int GetBytesRemaining() const;

    // Change where I'm writing (put)/reading (Get)
    void SeekPut(SeekType_t type, int offset);
    void SeekGet(SeekType_t type, int offset);

    // Buffer base
    const void* Base() const;
    void* Base();

    // memory allocation size, does *not* reflect size written or read,
    //	use TellPut or TellGet for that
    int Size() const;

    // Am I a text buffer?
    bool IsText() const;

    // Can I grow if I'm externally allocated?
    bool IsGrowable() const;

    // Am I valid? (overflow or underflow error), Once invalid it stays invalid
    bool IsValid() const;

    // Do I contain carriage return/linefeeds? 
    bool ContainsCRLF() const;

    // Am I read-only
    bool IsReadOnly() const;

    // Converts a buffer from a CRLF buffer to a CR buffer (and back)
    // Returns false if no conversion was necessary (and outBuf is left untouched)
    // If the conversion occurs, outBuf will be cleared.
    bool ConvertCRLF(CUtlBuffer &outBuf);

    // Push/pop pretty-printing tabs
    void PushTab();
    void PopTab();

    // Temporarily disables pretty print
    void EnableTabs(bool bEnable);

protected:
    // error flags
    enum
    {
        PUT_OVERFLOW = 0x1,
        GET_OVERFLOW = 0x2,
        MAX_ERROR_FLAG = GET_OVERFLOW,
    };

    void SetOverflowFuncs(UtlBufferOverflowFunc_t getFunc, UtlBufferOverflowFunc_t putFunc);

    bool OnPutOverflow(int nSize);
    bool OnGetOverflow(int nSize);

protected:
    // Checks if a Get/put is ok
    bool CheckPut(int size);
    bool CheckGet(int size);

    void AddNullTermination();

    // Methods to help with pretty-printing
    bool WasLastCharacterCR();
    void PutTabs();

    // Help with delimited stuff
    char GetDelimitedCharInternal(CUtlCharConversion *pConv);
    void PutDelimitedCharInternal(CUtlCharConversion *pConv, char c);

    // Default overflow funcs
    bool PutOverflow(int nSize);
    bool GetOverflow(int nSize);

    // Does the next bytes of the buffer match a pattern?
    bool PeekStringMatch(int nOffset, const char *pString, int nLen);

    // Peek size of line to come, check memory bound
    int	PeekLineLength();

    // How much whitespace should I skip?
    int PeekWhiteSpace(int nOffset);

    // Checks if a peek Get is ok
    bool CheckPeekGet(int nOffset, int nSize);

    // Call this to peek arbitrarily long into memory. It doesn't fail unless
    // it can't read *anything* new
    bool CheckArbitraryPeekGet(int nOffset, int &nIncrement);

    template <typename T> void GetType(T& dest, const char *pszFmt);
    template <typename T> void GetTypeBin(T& dest);
    template <typename T> void GetObject(T *src);

    template <typename T> void PutType(T src, const char *pszFmt);
    template <typename T> void PutTypeBin(T src);
    template <typename T> void PutObject(T *src);

    CUtlMemory<unsigned char> m_Memory;
    int m_Get;
    int m_Put;

    unsigned char m_Error;
    unsigned char m_Flags;
    unsigned char m_Reserved;
#if defined( _X360 )
    unsigned char pad;
#endif

    int m_nTab;
    int m_nMaxPut;
    int m_nOffset;

    UtlBufferOverflowFunc_t m_GetOverflowFunc;
    UtlBufferOverflowFunc_t m_PutOverflowFunc;

    CByteswap	m_Byteswap;
};


// Stream style output operators for CUtlBuffer
inline CUtlBuffer &operator<<(CUtlBuffer &b, char v)
{
    b.PutChar(v);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, unsigned char v)
{
    b.PutUnsignedChar(v);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, short v)
{
    b.PutShort(v);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, unsigned short v)
{
    b.PutUnsignedShort(v);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, int v)
{
    b.PutInt(v);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, unsigned int v)
{
    b.PutUnsignedInt(v);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, float v)
{
    b.PutFloat(v);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, double v)
{
    b.PutDouble(v);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, const char *pv)
{
    b.PutString(pv);
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, const Vector &v)
{
    b << v.x << " " << v.y << " " << v.z;
    return b;
}

inline CUtlBuffer &operator<<(CUtlBuffer &b, const Vector2D &v)
{
    b << v.x << " " << v.y;
    return b;
}


class CUtlInplaceBuffer : public CUtlBuffer
{
public:
    CUtlInplaceBuffer(int growSize = 0, int initSize = 0, int nFlags = 0);

    //
    // Routines returning buffer-inplace-pointers
    //
public:
    //
    // Upon success, determines the line length, fills out the pointer to the
    // beginning of the line and the line length, advances the "Get" pointer
    // offset by the line length and returns "true".
    //
    // If end of file is reached or upon error returns "false".
    //
    // Note:	the returned length of the line is at least one character because the
    //			trailing newline characters are also included as part of the line.
    //
    // Note:	the pointer returned points into the local memory of this buffer, in
    //			case the buffer gets relocated or destroyed the pointer becomes invalid.
    //
    // e.g.:	-------------
    //
    //			char *pszLine;
    //			int nLineLen;
    //			while ( pUtlInplaceBuffer->InplaceGetLinePtr( &pszLine, &nLineLen ) )
    //			{
    //				...
    //			}
    //
    //			-------------
    //
    // @param	ppszInBufferPtr		on return points into this buffer at start of line
    // @param	pnLineLength		on return holds num bytes accessible via (*ppszInBufferPtr)
    //
    // @returns	true				if line was successfully read
    //			false				when EOF is reached or error occurs
    //
    bool InplaceGetLinePtr( /* out */ char **ppszInBufferPtr, /* out */ int *pnLineLength);

    //
    // Determines the line length, advances the "Get" pointer offset by the line length,
    // replaces the newline character with null-terminator and returns the initial pointer
    // to now null-terminated line.
    //
    // If end of file is reached or upon error returns NULL.
    //
    // Note:	the pointer returned points into the local memory of this buffer, in
    //			case the buffer gets relocated or destroyed the pointer becomes invalid.
    //
    // e.g.:	-------------
    //
    //			while ( char *pszLine = pUtlInplaceBuffer->InplaceGetLinePtr() )
    //			{
    //				...
    //			}
    //
    //			-------------
    //
    // @returns	ptr-to-zero-terminated-line		if line was successfully read and buffer modified
    //			NULL							when EOF is reached or error occurs
    //
    char * InplaceGetLinePtr(void);
};


//-----------------------------------------------------------------------------
// Where am I reading?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellGet() const
{
    return m_Get;
}


//-----------------------------------------------------------------------------
// How many bytes remain to be read?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::GetBytesRemaining() const
{
    return m_nMaxPut - TellGet();
}


//-----------------------------------------------------------------------------
// What am I reading?
//-----------------------------------------------------------------------------
inline const void* CUtlBuffer::PeekGet(int offset) const
{
    return &m_Memory[m_Get + offset - m_nOffset];
}


//-----------------------------------------------------------------------------
// Unserialization
//-----------------------------------------------------------------------------

template <typename T>
inline void CUtlBuffer::GetObject(T *dest)
{
    if(CheckGet(sizeof(T))) {
        if(!m_Byteswap.IsSwappingBytes() || (sizeof(T) == 1)) {
            *dest = *(T *)PeekGet();
        } else {
            m_Byteswap.SwapFieldsToTargetEndian<T>(dest, (T*)PeekGet());
        }
        m_Get += sizeof(T);
    } else {
        Q_memset(&dest, 0, sizeof(T));
    }
}


template <typename T>
inline void CUtlBuffer::GetObjects(T *dest, int count)
{
    for(int i = 0; i < count; ++i, ++dest) {
        GetObject<T>(dest);
    }
}


template <typename T>
inline void CUtlBuffer::GetTypeBin(T &dest)
{
    if(CheckGet(sizeof(T))) {
        if(!m_Byteswap.IsSwappingBytes() || (sizeof(T) == 1)) {
            dest = *(T *)PeekGet();
        } else {
            m_Byteswap.SwapBufferToTargetEndian<T>(&dest, (T*)PeekGet());
        }
        m_Get += sizeof(T);
    } else {
        dest = 0;
    }
}

template <>
inline void CUtlBuffer::GetTypeBin< float >(float &dest)
{
    if(CheckGet(sizeof(float))) {
        unsigned int pData = (unsigned int)PeekGet();
        if(IsX360() && (pData & 0x03)) {
            // handle unaligned read
            ((unsigned char*)&dest)[0] = ((unsigned char*)pData)[0];
            ((unsigned char*)&dest)[1] = ((unsigned char*)pData)[1];
            ((unsigned char*)&dest)[2] = ((unsigned char*)pData)[2];
            ((unsigned char*)&dest)[3] = ((unsigned char*)pData)[3];
        } else {
            // aligned read
            dest = *(float *)pData;
        }
        if(m_Byteswap.IsSwappingBytes()) {
            m_Byteswap.SwapBufferToTargetEndian< float >(&dest, &dest);
        }
        m_Get += sizeof(float);
    } else {
        dest = 0;
    }
}

template <typename T>
inline void CUtlBuffer::GetType(T &dest, const char *pszFmt)
{
    if(!IsText()) {
        GetTypeBin(dest);
    } else {
        dest = 0;
        Scanf(pszFmt, &dest);
    }
}

inline char CUtlBuffer::GetChar()
{
    char c;
    GetType(c, "%c");
    return c;
}

inline unsigned char CUtlBuffer::GetUnsignedChar()
{
    unsigned char c;
    GetType(c, "%u");
    return c;
}

inline short CUtlBuffer::GetShort()
{
    short s;
    GetType(s, "%d");
    return s;
}

inline unsigned short CUtlBuffer::GetUnsignedShort()
{
    unsigned short s;
    GetType(s, "%u");
    return s;
}

inline int CUtlBuffer::GetInt()
{
    int i;
    GetType(i, "%d");
    return i;
}

inline int CUtlBuffer::GetIntHex()
{
    int i;
    GetType(i, "%x");
    return i;
}

inline unsigned int CUtlBuffer::GetUnsignedInt()
{
    unsigned int u;
    GetType(u, "%u");
    return u;
}

inline float CUtlBuffer::GetFloat()
{
    float f;
    GetType(f, "%f");
    return f;
}

inline double CUtlBuffer::GetDouble()
{
    double d;
    GetType(d, "%f");
    return d;
}


//-----------------------------------------------------------------------------
// Where am I writing?
//-----------------------------------------------------------------------------
inline unsigned char CUtlBuffer::GetFlags() const
{
    return m_Flags;
}


//-----------------------------------------------------------------------------
// 
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsExternallyAllocated() const
{
    return m_Memory.IsExternallyAllocated();
}


//-----------------------------------------------------------------------------
// Where am I writing?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellPut() const
{
    return m_Put;
}


//-----------------------------------------------------------------------------
// What's the most I've ever written?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellMaxPut() const
{
    return m_nMaxPut;
}


//-----------------------------------------------------------------------------
// What am I reading?
//-----------------------------------------------------------------------------
inline void* CUtlBuffer::PeekPut(int offset)
{
    return &m_Memory[m_Put + offset - m_nOffset];
}


//-----------------------------------------------------------------------------
// Various put methods
//-----------------------------------------------------------------------------

template <typename T>
inline void CUtlBuffer::PutObject(T *src)
{
    if(CheckPut(sizeof(T))) {
        if(!m_Byteswap.IsSwappingBytes() || (sizeof(T) == 1)) {
            *(T *)PeekPut() = *src;
        } else {
            m_Byteswap.SwapFieldsToTargetEndian<T>((T*)PeekPut(), src);
        }
        m_Put += sizeof(T);
        AddNullTermination();
    }
}


template <typename T>
inline void CUtlBuffer::PutObjects(T *src, int count)
{
    for(int i = 0; i < count; ++i, ++src) {
        PutObject<T>(src);
    }
}


template <typename T>
inline void CUtlBuffer::PutTypeBin(T src)
{
    if(CheckPut(sizeof(T))) {
        if(!m_Byteswap.IsSwappingBytes() || (sizeof(T) == 1)) {
            *(T *)PeekPut() = src;
        } else {
            m_Byteswap.SwapBufferToTargetEndian<T>((T*)PeekPut(), &src);
        }
        m_Put += sizeof(T);
        AddNullTermination();
    }
}

template <typename T>
inline void CUtlBuffer::PutType(T src, const char *pszFmt)
{
    if(!IsText()) {
        PutTypeBin(src);
    } else {
        Printf(pszFmt, src);
    }
}

//-----------------------------------------------------------------------------
// Methods to help with pretty-printing
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::WasLastCharacterCR()
{
    if(!IsText() || (TellPut() == 0))
        return false;
    return (*(const char *)PeekPut(-1) == '\n');
}

inline void CUtlBuffer::PutTabs()
{
    int nTabCount = (m_Flags & AUTO_TABS_DISABLED) ? 0 : m_nTab;
    for(int i = nTabCount; --i >= 0; ) {
        PutTypeBin<char>('\t');
    }
}


//-----------------------------------------------------------------------------
// Push/pop pretty-printing tabs
//-----------------------------------------------------------------------------
inline void CUtlBuffer::PushTab()
{
    ++m_nTab;
}

inline void CUtlBuffer::PopTab()
{
    if(--m_nTab < 0) {
        m_nTab = 0;
    }
}


//-----------------------------------------------------------------------------
// Temporarily disables pretty print
//-----------------------------------------------------------------------------
inline void CUtlBuffer::EnableTabs(bool bEnable)
{
    if(bEnable) {
        m_Flags &= ~AUTO_TABS_DISABLED;
    } else {
        m_Flags |= AUTO_TABS_DISABLED;
    }
}

inline void CUtlBuffer::PutChar(char c)
{
    if(WasLastCharacterCR()) {
        PutTabs();
    }

    PutTypeBin(c);
}

inline void CUtlBuffer::PutUnsignedChar(unsigned char c)
{
    PutType(c, "%u");
}

inline void  CUtlBuffer::PutShort(short s)
{
    PutType(s, "%d");
}

inline void CUtlBuffer::PutUnsignedShort(unsigned short s)
{
    PutType(s, "%u");
}

inline void CUtlBuffer::PutInt(int i)
{
    PutType(i, "%d");
}

inline void CUtlBuffer::PutUnsignedInt(unsigned int u)
{
    PutType(u, "%u");
}

inline void CUtlBuffer::PutFloat(float f)
{
    PutType(f, "%f");
}

inline void CUtlBuffer::PutDouble(double d)
{
    PutType(d, "%f");
}


//-----------------------------------------------------------------------------
// Am I a text buffer?
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsText() const
{
    return (m_Flags & TEXT_BUFFER) != 0;
}


//-----------------------------------------------------------------------------
// Can I grow if I'm externally allocated?
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsGrowable() const
{
    return (m_Flags & EXTERNAL_GROWABLE) != 0;
}


//-----------------------------------------------------------------------------
// Am I valid? (overflow or underflow error), Once invalid it stays invalid
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsValid() const
{
    return m_Error == 0;
}


//-----------------------------------------------------------------------------
// Do I contain carriage return/linefeeds? 
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::ContainsCRLF() const
{
    return IsText() && ((m_Flags & CONTAINS_CRLF) != 0);
}


//-----------------------------------------------------------------------------
// Am I read-only
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsReadOnly() const
{
    return (m_Flags & READ_ONLY) != 0;
}


//-----------------------------------------------------------------------------
// Buffer base and size
//-----------------------------------------------------------------------------
inline const void* CUtlBuffer::Base() const
{
    return m_Memory.Base();
}

inline void* CUtlBuffer::Base()
{
    return m_Memory.Base();
}

inline int CUtlBuffer::Size() const
{
    return m_Memory.NumAllocated();
}


//-----------------------------------------------------------------------------
// Clears out the buffer; frees memory
//-----------------------------------------------------------------------------
inline void CUtlBuffer::Clear()
{
    m_Get = 0;
    m_Put = 0;
    m_Error = 0;
    m_nOffset = 0;
    m_nMaxPut = -1;
    AddNullTermination();
}

inline void CUtlBuffer::Purge()
{
    m_Get = 0;
    m_Put = 0;
    m_nOffset = 0;
    m_nMaxPut = 0;
    m_Error = 0;
    m_Memory.Purge();
}
#pragma warning(default:4127) //conditional operation is constant
```

`CSGOSimple/valve_sdk/misc/UtlMemory.hpp`:

```hpp
#pragma once

#include <assert.h>
#include "platform.hpp"

template< class T, class I = int >
class CUtlMemory
{
public:
    // constructor, destructor
    CUtlMemory(int nGrowSize = 0, int nInitSize = 0);
    CUtlMemory(T* pMemory, int numElements);
    CUtlMemory(const T* pMemory, int numElements);
    ~CUtlMemory();

    // Set the size by which the memory grows
    void Init(int nGrowSize = 0, int nInitSize = 0);

    class Iterator_t
    {
    public:
        Iterator_t(I i) : index(i) {}
        I index;

        bool operator==(const Iterator_t it) const { return index == it.index; }
        bool operator!=(const Iterator_t it) const { return index != it.index; }
    };
    Iterator_t First() const { return Iterator_t(IsIdxValid(0) ? 0 : InvalidIndex()); }
    Iterator_t Next(const Iterator_t &it) const { return Iterator_t(IsIdxValid(it.index + 1) ? it.index + 1 : InvalidIndex()); }
    I GetIndex(const Iterator_t &it) const { return it.index; }
    bool IsIdxAfter(I i, const Iterator_t &it) const { return i > it.index; }
    bool IsValidIterator(const Iterator_t &it) const { return IsIdxValid(it.index); }
    Iterator_t InvalidIterator() const { return Iterator_t(InvalidIndex()); }

    // element access
    T& operator[](I i);
    const T& operator[](I i) const;
    T& Element(I i);
    const T& Element(I i) const;

    bool IsIdxValid(I i) const;

    static const I INVALID_INDEX = (I)-1; // For use with COMPILE_TIME_ASSERT
    static I InvalidIndex() { return INVALID_INDEX; }

    T* Base();
    const T* Base() const;

    void SetExternalBuffer(T* pMemory, int numElements);
    void SetExternalBuffer(const T* pMemory, int numElements);
    void AssumeMemory(T *pMemory, int nSize);
    T* Detach();
    void *DetachMemory();

    void Swap(CUtlMemory< T, I > &mem);
    void ConvertToGrowableMemory(int nGrowSize);
    int NumAllocated() const;
    int Count() const;
    void Grow(int num = 1);
    void EnsureCapacity(int num);
    void Purge();
    void Purge(int numElements);
    bool IsExternallyAllocated() const;
    bool IsReadOnly() const;
    void SetGrowSize(int size);

protected:
    void ValidateGrowSize()
    {

    }

    enum
    {
        EXTERNAL_BUFFER_MARKER = -1,
        EXTERNAL_CONST_BUFFER_MARKER = -2,
    };

    T* m_pMemory;
    int m_nAllocationCount;
    int m_nGrowSize;
};

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template< class T, class I >
CUtlMemory<T, I>::CUtlMemory(int nGrowSize, int nInitAllocationCount) : m_pMemory(0),
m_nAllocationCount(nInitAllocationCount), m_nGrowSize(nGrowSize)
{
    ValidateGrowSize();
    assert(nGrowSize >= 0);
    if(m_nAllocationCount) {
        m_pMemory = (T*)new unsigned char[m_nAllocationCount * sizeof(T)];
        //m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
    }
}

template< class T, class I >
CUtlMemory<T, I>::CUtlMemory(T* pMemory, int numElements) : m_pMemory(pMemory),
m_nAllocationCount(numElements)
{
    // Special marker indicating externally supplied modifyable memory
    m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template< class T, class I >
CUtlMemory<T, I>::CUtlMemory(const T* pMemory, int numElements) : m_pMemory((T*)pMemory),
m_nAllocationCount(numElements)
{
    // Special marker indicating externally supplied modifyable memory
    m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template< class T, class I >
CUtlMemory<T, I>::~CUtlMemory()
{
    Purge();
}

template< class T, class I >
void CUtlMemory<T, I>::Init(int nGrowSize /*= 0*/, int nInitSize /*= 0*/)
{
    Purge();

    m_nGrowSize = nGrowSize;
    m_nAllocationCount = nInitSize;
    ValidateGrowSize();
    assert(nGrowSize >= 0);
    if(m_nAllocationCount) {
        UTLMEMORY_TRACK_ALLOC();
        MEM_ALLOC_CREDIT_CLASS();
        m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
    }
}

//-----------------------------------------------------------------------------
// Fast swap
//-----------------------------------------------------------------------------
template< class T, class I >
void CUtlMemory<T, I>::Swap(CUtlMemory<T, I> &mem)
{
    V_swap(m_nGrowSize, mem.m_nGrowSize);
    V_swap(m_pMemory, mem.m_pMemory);
    V_swap(m_nAllocationCount, mem.m_nAllocationCount);
}


//-----------------------------------------------------------------------------
// Switches the buffer from an external memory buffer to a reallocatable buffer
//-----------------------------------------------------------------------------
template< class T, class I >
void CUtlMemory<T, I>::ConvertToGrowableMemory(int nGrowSize)
{
    if(!IsExternallyAllocated())
        return;

    m_nGrowSize = nGrowSize;
    if(m_nAllocationCount) {
        int nNumBytes = m_nAllocationCount * sizeof(T);
        T *pMemory = (T*)malloc(nNumBytes);
        memcpy(pMemory, m_pMemory, nNumBytes);
        m_pMemory = pMemory;
    } else {
        m_pMemory = NULL;
    }
}


//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template< class T, class I >
void CUtlMemory<T, I>::SetExternalBuffer(T* pMemory, int numElements)
{
    // Blow away any existing allocated memory
    Purge();

    m_pMemory = pMemory;
    m_nAllocationCount = numElements;

    // Indicate that we don't own the memory
    m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template< class T, class I >
void CUtlMemory<T, I>::SetExternalBuffer(const T* pMemory, int numElements)
{
    // Blow away any existing allocated memory
    Purge();

    m_pMemory = const_cast<T*>(pMemory);
    m_nAllocationCount = numElements;

    // Indicate that we don't own the memory
    m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template< class T, class I >
void CUtlMemory<T, I>::AssumeMemory(T* pMemory, int numElements)
{
    // Blow away any existing allocated memory
    Purge();

    // Simply take the pointer but don't mark us as external
    m_pMemory = pMemory;
    m_nAllocationCount = numElements;
}

template< class T, class I >
void *CUtlMemory<T, I>::DetachMemory()
{
    if(IsExternallyAllocated())
        return NULL;

    void *pMemory = m_pMemory;
    m_pMemory = 0;
    m_nAllocationCount = 0;
    return pMemory;
}

template< class T, class I >
inline T* CUtlMemory<T, I>::Detach()
{
    return (T*)DetachMemory();
}


//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template< class T, class I >
inline T& CUtlMemory<T, I>::operator[](I i)
{
    assert(!IsReadOnly());
    assert(IsIdxValid(i));
    return m_pMemory[i];
}

template< class T, class I >
inline const T& CUtlMemory<T, I>::operator[](I i) const
{
    assert(IsIdxValid(i));
    return m_pMemory[i];
}

template< class T, class I >
inline T& CUtlMemory<T, I>::Element(I i)
{
    assert(!IsReadOnly());
    assert(IsIdxValid(i));
    return m_pMemory[i];
}

template< class T, class I >
inline const T& CUtlMemory<T, I>::Element(I i) const
{
    assert(IsIdxValid(i));
    return m_pMemory[i];
}


//-----------------------------------------------------------------------------
// is the memory externally allocated?
//-----------------------------------------------------------------------------
template< class T, class I >
bool CUtlMemory<T, I>::IsExternallyAllocated() const
{
    return (m_nGrowSize < 0);
}


//-----------------------------------------------------------------------------
// is the memory read only?
//-----------------------------------------------------------------------------
template< class T, class I >
bool CUtlMemory<T, I>::IsReadOnly() const
{
    return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);
}


template< class T, class I >
void CUtlMemory<T, I>::SetGrowSize(int nSize)
{
    assert(!IsExternallyAllocated());
    assert(nSize >= 0);
    m_nGrowSize = nSize;
    ValidateGrowSize();
}


//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------
template< class T, class I >
inline T* CUtlMemory<T, I>::Base()
{
    assert(!IsReadOnly());
    return m_pMemory;
}

template< class T, class I >
inline const T *CUtlMemory<T, I>::Base() const
{
    return m_pMemory;
}


//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------
template< class T, class I >
inline int CUtlMemory<T, I>::NumAllocated() const
{
    return m_nAllocationCount;
}

template< class T, class I >
inline int CUtlMemory<T, I>::Count() const
{
    return m_nAllocationCount;
}


//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template< class T, class I >
inline bool CUtlMemory<T, I>::IsIdxValid(I i) const
{
    // GCC warns if I is an unsigned type and we do a ">= 0" against it (since the comparison is always 0).
    // We Get the warning even if we cast inside the expression. It only goes away if we assign to another variable.
    long x = i;
    return (x >= 0) && (x < m_nAllocationCount);
}

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
inline int UtlMemory_CalcNewAllocationCount(int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem)
{
    if(nGrowSize) {
        nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);
    } else {
        if(!nAllocationCount) {
            // Compute an allocation which is at least as big as a cache line...
            nAllocationCount = (31 + nBytesItem) / nBytesItem;
        }

        while(nAllocationCount < nNewSize) {
#ifndef _X360
            nAllocationCount *= 2;
#else
            int nNewAllocationCount = (nAllocationCount * 9) / 8; // 12.5 %
            if(nNewAllocationCount > nAllocationCount)
                nAllocationCount = nNewAllocationCount;
            else
                nAllocationCount *= 2;
#endif
        }
    }

    return nAllocationCount;
}

template< class T, class I >
void CUtlMemory<T, I>::Grow(int num)
{
    assert(num > 0);

    if(IsExternallyAllocated()) {
        // Can't grow a buffer whose memory was externally allocated 
        assert(0);
        return;
    }


    auto oldAllocationCount = m_nAllocationCount;
    // Make sure we have at least numallocated + num allocations.
    // Use the grow rules specified for this memory (in m_nGrowSize)
    int nAllocationRequested = m_nAllocationCount + num;

    int nNewAllocationCount = UtlMemory_CalcNewAllocationCount(m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T));

    // if m_nAllocationRequested wraps index type I, recalculate
    if((int)(I)nNewAllocationCount < nAllocationRequested) {
        if((int)(I)nNewAllocationCount == 0 && (int)(I)(nNewAllocationCount - 1) >= nAllocationRequested) {
            --nNewAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1
        } else {
            if((int)(I)nAllocationRequested != nAllocationRequested) {
                // we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
                assert(0);
                return;
            }
            while((int)(I)nNewAllocationCount < nAllocationRequested) {
                nNewAllocationCount = (nNewAllocationCount + nAllocationRequested) / 2;
            }
        }
    }

    m_nAllocationCount = nNewAllocationCount;

    if(m_pMemory) {
        auto ptr = new unsigned char[m_nAllocationCount * sizeof(T)];

        memcpy(ptr, m_pMemory, oldAllocationCount * sizeof(T));
        m_pMemory = (T*)ptr;
    } else {
        m_pMemory = (T*)new unsigned char[m_nAllocationCount * sizeof(T)];
    }
}


//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template< class T, class I >
inline void CUtlMemory<T, I>::EnsureCapacity(int num)
{
    if(m_nAllocationCount >= num)
        return;

    if(IsExternallyAllocated()) {
        // Can't grow a buffer whose memory was externally allocated 
        assert(0);
        return;
    }
    m_nAllocationCount = num;

    if(m_pMemory) {
        m_pMemory = (T*)realloc(m_pMemory, m_nAllocationCount * sizeof(T));
    } else {
        m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
    }
}


//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template< class T, class I >
void CUtlMemory<T, I>::Purge()
{
    if(!IsExternallyAllocated()) {
        if(m_pMemory) {
            free((void*)m_pMemory);
            m_pMemory = 0;
        }
        m_nAllocationCount = 0;
    }
}

template< class T, class I >
void CUtlMemory<T, I>::Purge(int numElements)
{
    assert(numElements >= 0);

    if(numElements > m_nAllocationCount) {
        // Ensure this isn't a grow request in disguise.
        assert(numElements <= m_nAllocationCount);
        return;
    }

    // If we have zero elements, simply do a purge:
    if(numElements == 0) {
        Purge();
        return;
    }

    if(IsExternallyAllocated()) {
        // Can't shrink a buffer whose memory was externally allocated, fail silently like purge 
        return;
    }

    // If the number of elements is the same as the allocation count, we are done.
    if(numElements == m_nAllocationCount) {
        return;
    }


    if(!m_pMemory) {
        // Allocation count is non zero, but memory is null.
        assert(m_pMemory);
        return;
    }
    m_nAllocationCount = numElements;
    m_pMemory = (T*)realloc(m_pMemory, m_nAllocationCount * sizeof(T));
}

//-----------------------------------------------------------------------------
// The CUtlMemory class:
// A growable memory class which doubles in size by default.
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
class CUtlMemoryAligned : public CUtlMemory<T>
{
public:
    // constructor, destructor
    CUtlMemoryAligned(int nGrowSize = 0, int nInitSize = 0);
    CUtlMemoryAligned(T* pMemory, int numElements);
    CUtlMemoryAligned(const T* pMemory, int numElements);
    ~CUtlMemoryAligned();

    // Attaches the buffer to external memory....
    void SetExternalBuffer(T* pMemory, int numElements);
    void SetExternalBuffer(const T* pMemory, int numElements);

    // Grows the memory, so that at least allocated + num elements are allocated
    void Grow(int num = 1);

    // Makes sure we've got at least this much memory
    void EnsureCapacity(int num);

    // Memory deallocation
    void Purge();

    // Purge all but the given number of elements (NOT IMPLEMENTED IN CUtlMemoryAligned)
    void Purge(int numElements) { assert(0); }

private:
    void *Align(const void *pAddr);
};


//-----------------------------------------------------------------------------
// Aligns a pointer
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
void *CUtlMemoryAligned<T, nAlignment>::Align(const void *pAddr)
{
    size_t nAlignmentMask = nAlignment - 1;
    return (void*)(((size_t)pAddr + nAlignmentMask) & (~nAlignmentMask));
}


//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned(int nGrowSize, int nInitAllocationCount)
{
    CUtlMemory<T>::m_pMemory = 0;
    CUtlMemory<T>::m_nAllocationCount = nInitAllocationCount;
    CUtlMemory<T>::m_nGrowSize = nGrowSize;
    this->ValidateGrowSize();

    // Alignment must be a power of two
    COMPILE_TIME_ASSERT((nAlignment & (nAlignment - 1)) == 0);
    assert((nGrowSize >= 0) && (nGrowSize != CUtlMemory<T>::EXTERNAL_BUFFER_MARKER));
    if(CUtlMemory<T>::m_nAllocationCount) {
        UTLMEMORY_TRACK_ALLOC();
        MEM_ALLOC_CREDIT_CLASS();
        CUtlMemory<T>::m_pMemory = (T*)_aligned_malloc(nInitAllocationCount * sizeof(T), nAlignment);
    }
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned(T* pMemory, int numElements)
{
    // Special marker indicating externally supplied memory
    CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_BUFFER_MARKER;

    CUtlMemory<T>::m_pMemory = (T*)Align(pMemory);
    CUtlMemory<T>::m_nAllocationCount = ((int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory) / sizeof(T);
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned(const T* pMemory, int numElements)
{
    // Special marker indicating externally supplied memory
    CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_CONST_BUFFER_MARKER;

    CUtlMemory<T>::m_pMemory = (T*)Align(pMemory);
    CUtlMemory<T>::m_nAllocationCount = ((int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory) / sizeof(T);
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::~CUtlMemoryAligned()
{
    Purge();
}


//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::SetExternalBuffer(T* pMemory, int numElements)
{
    // Blow away any existing allocated memory
    Purge();

    CUtlMemory<T>::m_pMemory = (T*)Align(pMemory);
    CUtlMemory<T>::m_nAllocationCount = ((int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory) / sizeof(T);

    // Indicate that we don't own the memory
    CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_BUFFER_MARKER;
}

template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::SetExternalBuffer(const T* pMemory, int numElements)
{
    // Blow away any existing allocated memory
    Purge();

    CUtlMemory<T>::m_pMemory = (T*)Align(pMemory);
    CUtlMemory<T>::m_nAllocationCount = ((int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory) / sizeof(T);

    // Indicate that we don't own the memory
    CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_CONST_BUFFER_MARKER;
}


//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::Grow(int num)
{
    assert(num > 0);

    if(this->IsExternallyAllocated()) {
        // Can't grow a buffer whose memory was externally allocated 
        assert(0);
        return;
    }

    UTLMEMORY_TRACK_FREE();

    // Make sure we have at least numallocated + num allocations.
    // Use the grow rules specified for this memory (in m_nGrowSize)
    int nAllocationRequested = CUtlMemory<T>::m_nAllocationCount + num;

    CUtlMemory<T>::m_nAllocationCount = UtlMemory_CalcNewAllocationCount(CUtlMemory<T>::m_nAllocationCount, CUtlMemory<T>::m_nGrowSize, nAllocationRequested, sizeof(T));

    UTLMEMORY_TRACK_ALLOC();

    if(CUtlMemory<T>::m_pMemory) {
        MEM_ALLOC_CREDIT_CLASS();
        CUtlMemory<T>::m_pMemory = (T*)MemAlloc_ReallocAligned(CUtlMemory<T>::m_pMemory, CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment);
        assert(CUtlMemory<T>::m_pMemory);
    } else {
        MEM_ALLOC_CREDIT_CLASS();
        CUtlMemory<T>::m_pMemory = (T*)MemAlloc_AllocAligned(CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment);
        assert(CUtlMemory<T>::m_pMemory);
    }
}


//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
inline void CUtlMemoryAligned<T, nAlignment>::EnsureCapacity(int num)
{
    if(CUtlMemory<T>::m_nAllocationCount >= num)
        return;

    if(this->IsExternallyAllocated()) {
        // Can't grow a buffer whose memory was externally allocated 
        assert(0);
        return;
    }

    UTLMEMORY_TRACK_FREE();

    CUtlMemory<T>::m_nAllocationCount = num;

    UTLMEMORY_TRACK_ALLOC();

    if(CUtlMemory<T>::m_pMemory) {
        MEM_ALLOC_CREDIT_CLASS();
        CUtlMemory<T>::m_pMemory = (T*)MemAlloc_ReallocAligned(CUtlMemory<T>::m_pMemory, CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment);
    } else {
        MEM_ALLOC_CREDIT_CLASS();
        CUtlMemory<T>::m_pMemory = (T*)MemAlloc_AllocAligned(CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment);
    }
}


//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::Purge()
{
    if(!this->IsExternallyAllocated()) {
        if(CUtlMemory<T>::m_pMemory) {
            UTLMEMORY_TRACK_FREE();
            MemAlloc_FreeAligned(CUtlMemory<T>::m_pMemory);
            CUtlMemory<T>::m_pMemory = 0;
        }
        CUtlMemory<T>::m_nAllocationCount = 0;
    }
}
```

`CSGOSimple/valve_sdk/misc/UtlString.cpp`:

```cpp
#include "UtlString.hpp"

#define NOMINMAX
#include <Windows.h>
#include <stdio.h>

//-----------------------------------------------------------------------------
// Base class, containing simple memory management
//-----------------------------------------------------------------------------
CUtlBinaryBlock::CUtlBinaryBlock(int growSize, int initSize) : m_Memory(growSize, initSize)
{
    m_nActualLength = 0;
}

CUtlBinaryBlock::CUtlBinaryBlock(void* pMemory, int nSizeInBytes, int nInitialLength) : m_Memory((unsigned char*)pMemory, nSizeInBytes)
{
    m_nActualLength = nInitialLength;
}

CUtlBinaryBlock::CUtlBinaryBlock(const void* pMemory, int nSizeInBytes) : m_Memory((const unsigned char*)pMemory, nSizeInBytes)
{
    m_nActualLength = nSizeInBytes;
}

CUtlBinaryBlock::CUtlBinaryBlock(const CUtlBinaryBlock& src)
{
    Set(src.Get(), src.Length());
}

void CUtlBinaryBlock::Get(void *pValue, int nLen) const
{
    assert(nLen > 0);
    if(m_nActualLength < nLen) {
        nLen = m_nActualLength;
    }

    if(nLen > 0) {
        memcpy(pValue, m_Memory.Base(), nLen);
    }
}

void CUtlBinaryBlock::SetLength(int nLength)
{
    assert(!m_Memory.IsReadOnly());

    m_nActualLength = nLength;
    if(nLength > m_Memory.NumAllocated()) {
        int nOverFlow = nLength - m_Memory.NumAllocated();
        m_Memory.Grow(nOverFlow);

        // If the reallocation failed, clamp length
        if(nLength > m_Memory.NumAllocated()) {
            m_nActualLength = m_Memory.NumAllocated();
        }
    }

#ifdef _DEBUG
    if(m_Memory.NumAllocated() > m_nActualLength) {
        memset(((char *)m_Memory.Base()) + m_nActualLength, 0xEB, m_Memory.NumAllocated() - m_nActualLength);
    }
#endif
}

void CUtlBinaryBlock::Set(const void *pValue, int nLen)
{
    assert(!m_Memory.IsReadOnly());

    if(!pValue) {
        nLen = 0;
    }

    SetLength(nLen);

    if(m_nActualLength) {
        if(((const char *)m_Memory.Base()) >= ((const char *)pValue) + nLen ||
            ((const char *)m_Memory.Base()) + m_nActualLength <= ((const char *)pValue)) {
            memcpy(m_Memory.Base(), pValue, m_nActualLength);
        } else {
            memmove(m_Memory.Base(), pValue, m_nActualLength);
        }
    }
}


CUtlBinaryBlock &CUtlBinaryBlock::operator=(const CUtlBinaryBlock &src)
{
    assert(!m_Memory.IsReadOnly());
    Set(src.Get(), src.Length());
    return *this;
}


bool CUtlBinaryBlock::operator==(const CUtlBinaryBlock &src) const
{
    if(src.Length() != Length())
        return false;

    return !memcmp(src.Get(), Get(), Length());
}


//-----------------------------------------------------------------------------
// Simple string class. 
//-----------------------------------------------------------------------------
CUtlString::CUtlString()
{
}

CUtlString::CUtlString(const char *pString)
{
    Set(pString);
}

CUtlString::CUtlString(const CUtlString& string)
{
    Set(string.Get());
}

// Attaches the string to external memory. Useful for avoiding a copy
CUtlString::CUtlString(void* pMemory, int nSizeInBytes, int nInitialLength) : m_Storage(pMemory, nSizeInBytes, nInitialLength)
{
}

CUtlString::CUtlString(const void* pMemory, int nSizeInBytes) : m_Storage(pMemory, nSizeInBytes)
{
}

void CUtlString::Set(const char *pValue)
{
    assert(!m_Storage.IsReadOnly());
    int nLen = pValue ? strlen(pValue) + 1 : 0;
    m_Storage.Set(pValue, nLen);
}

// Returns strlen
int CUtlString::Length() const
{
    return m_Storage.Length() ? m_Storage.Length() - 1 : 0;
}

// Sets the length (used to serialize into the buffer )
void CUtlString::SetLength(int nLen)
{
    assert(!m_Storage.IsReadOnly());

    // Add 1 to account for the NULL
    m_Storage.SetLength(nLen > 0 ? nLen + 1 : 0);
}

const char *CUtlString::Get() const
{
    if(m_Storage.Length() == 0) {
        return "";
    }

    return reinterpret_cast<const char*>(m_Storage.Get());
}

// Converts to c-strings
CUtlString::operator const char*() const
{
    return Get();
}

char *CUtlString::Get()
{
    assert(!m_Storage.IsReadOnly());

    if(m_Storage.Length() == 0) {
        // In general, we optimise away small mallocs for empty strings
        // but if you ask for the non-const bytes, they must be writable
        // so we can't return "" here, like we do for the const version - jd
        m_Storage.SetLength(1);
        m_Storage[0] = '\0';
    }

    return reinterpret_cast<char*>(m_Storage.Get());
}

CUtlString &CUtlString::operator=(const CUtlString &src)
{
    assert(!m_Storage.IsReadOnly());
    m_Storage = src.m_Storage;
    return *this;
}

CUtlString &CUtlString::operator=(const char *src)
{
    assert(!m_Storage.IsReadOnly());
    Set(src);
    return *this;
}

bool CUtlString::operator==(const CUtlString &src) const
{
    return m_Storage == src.m_Storage;
}

bool CUtlString::operator==(const char *src) const
{
    return (strcmp(Get(), src) == 0);
}

CUtlString &CUtlString::operator+=(const CUtlString &rhs)
{
    assert(!m_Storage.IsReadOnly());

    const int lhsLength(Length());
    const int rhsLength(rhs.Length());
    const int requestedLength(lhsLength + rhsLength);

    SetLength(requestedLength);
    const int allocatedLength(Length());
    const int copyLength(allocatedLength - lhsLength < rhsLength ? allocatedLength - lhsLength : rhsLength);
    memcpy(Get() + lhsLength, rhs.Get(), copyLength);
    m_Storage[allocatedLength] = '\0';

    return *this;
}

CUtlString &CUtlString::operator+=(const char *rhs)
{
    assert(!m_Storage.IsReadOnly());

    const int lhsLength(Length());
    const int rhsLength(strlen(rhs));
    const int requestedLength(lhsLength + rhsLength);

    SetLength(requestedLength);
    const int allocatedLength(Length());
    const int copyLength(allocatedLength - lhsLength < rhsLength ? allocatedLength - lhsLength : rhsLength);
    memcpy(Get() + lhsLength, rhs, copyLength);
    m_Storage[allocatedLength] = '\0';

    return *this;
}

CUtlString &CUtlString::operator+=(char c)
{
    assert(!m_Storage.IsReadOnly());

    int nLength = Length();
    SetLength(nLength + 1);
    m_Storage[nLength] = c;
    m_Storage[nLength + 1] = '\0';
    return *this;
}

CUtlString &CUtlString::operator+=(int rhs)
{
    assert(!m_Storage.IsReadOnly());
    assert(sizeof(rhs) == 4);

    char tmpBuf[12];	// Sufficient for a signed 32 bit integer [ -2147483648 to +2147483647 ]
    snprintf(tmpBuf, sizeof(tmpBuf), "%d", rhs);
    tmpBuf[sizeof(tmpBuf) - 1] = '\0';

    return operator+=(tmpBuf);
}

CUtlString &CUtlString::operator+=(double rhs)
{
    assert(!m_Storage.IsReadOnly());

    char tmpBuf[256];	// How big can doubles be???  Dunno.
    snprintf(tmpBuf, sizeof(tmpBuf), "%lg", rhs);
    tmpBuf[sizeof(tmpBuf) - 1] = '\0';

    return operator+=(tmpBuf);
}

int CUtlString::Format(const char *pFormat, ...)
{
    assert(!m_Storage.IsReadOnly());

    char tmpBuf[4096];	//< Nice big 4k buffer, as much memory as my first computer had, a Radio Shack Color Computer

    va_list marker;

    va_start(marker, pFormat);
    int len = _vsnprintf_s(tmpBuf, 4096, sizeof(tmpBuf) - 1, pFormat, marker);
    va_end(marker);

    // Len < 0 represents an overflow
    if(len < 0) {
        len = sizeof(tmpBuf) - 1;
        tmpBuf[sizeof(tmpBuf) - 1] = 0;
    }

    Set(tmpBuf);

    return len;
}

//-----------------------------------------------------------------------------
// Strips the trailing slash
//-----------------------------------------------------------------------------
void CUtlString::StripTrailingSlash()
{
    if(IsEmpty())
        return;

    int nLastChar = Length() - 1;
    char c = m_Storage[nLastChar];
    if(c == '\\' || c == '/') {
        m_Storage[nLastChar] = 0;
        m_Storage.SetLength(m_Storage.Length() - 1);
    }
}
```

`CSGOSimple/valve_sdk/misc/UtlString.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstring>

#include "UtlMemory.hpp"

class CUtlBinaryBlock
{
public:
    CUtlBinaryBlock(int growSize = 0, int initSize = 0);

    // NOTE: nInitialLength indicates how much of the buffer starts full
    CUtlBinaryBlock(void* pMemory, int nSizeInBytes, int nInitialLength);
    CUtlBinaryBlock(const void* pMemory, int nSizeInBytes);
    CUtlBinaryBlock(const CUtlBinaryBlock& src);

    void        Get(void *pValue, int nMaxLen) const;
    void        Set(const void *pValue, int nLen);
    const void  *Get() const;
    void        *Get();

    unsigned char& operator[](int i);
    const unsigned char& operator[](int i) const;

    int         Length() const;
    void        SetLength(int nLength);    // Undefined memory will result
    bool        IsEmpty() const;
    void        Clear();
    void        Purge();

    bool        IsReadOnly() const;

    CUtlBinaryBlock &operator=(const CUtlBinaryBlock &src);

    // Test for equality
    bool operator==(const CUtlBinaryBlock &src) const;

private:
    CUtlMemory<unsigned char> m_Memory;
    int m_nActualLength;
};


//-----------------------------------------------------------------------------
// class inlines
//-----------------------------------------------------------------------------
inline const void *CUtlBinaryBlock::Get() const
{
    return m_Memory.Base();
}

inline void *CUtlBinaryBlock::Get()
{
    return m_Memory.Base();
}

inline int CUtlBinaryBlock::Length() const
{
    return m_nActualLength;
}

inline unsigned char& CUtlBinaryBlock::operator[](int i)
{
    return m_Memory[i];
}

inline const unsigned char& CUtlBinaryBlock::operator[](int i) const
{
    return m_Memory[i];
}

inline bool CUtlBinaryBlock::IsReadOnly() const
{
    return m_Memory.IsReadOnly();
}

inline bool CUtlBinaryBlock::IsEmpty() const
{
    return Length() == 0;
}

inline void CUtlBinaryBlock::Clear()
{
    SetLength(0);
}

inline void CUtlBinaryBlock::Purge()
{
    SetLength(0);
    m_Memory.Purge();
}

//-----------------------------------------------------------------------------
// Simple string class. 
// NOTE: This is *not* optimal! Use in tools, but not runtime code
//-----------------------------------------------------------------------------
class CUtlString
{
public:
    CUtlString();
    CUtlString(const char *pString);
    CUtlString(const CUtlString& string);

    // Attaches the string to external memory. Useful for avoiding a copy
    CUtlString(void* pMemory, int nSizeInBytes, int nInitialLength);
    CUtlString(const void* pMemory, int nSizeInBytes);

    const char    *Get() const;
    void        Set(const char *pValue);

    // Set directly and don't look for a null terminator in pValue.
    void        SetDirect(const char *pValue, int nChars);

    // Converts to c-strings
    operator const char*() const;

    // for compatibility switching items from UtlSymbol
    const char  *String() const { return Get(); }

    // Returns strlen
    int            Length() const;
    bool        IsEmpty() const;

    // Sets the length (used to serialize into the buffer )
    // Note: If nLen != 0, then this adds an extra uint8_t for a null-terminator.    
    void        SetLength(int nLen);
    char        *Get();
    void        Clear();
    void        Purge();

    // Strips the trailing slash
    void        StripTrailingSlash();

    CUtlString &operator=(const CUtlString &src);
    CUtlString &operator=(const char *src);

    // Test for equality
    bool operator==(const CUtlString &src) const;
    bool operator==(const char *src) const;
    bool operator!=(const CUtlString &src) const { return !operator==(src); }
    bool operator!=(const char *src) const { return !operator==(src); }

    CUtlString &operator+=(const CUtlString &rhs);
    CUtlString &operator+=(const char *rhs);
    CUtlString &operator+=(char c);
    CUtlString &operator+=(int rhs);
    CUtlString &operator+=(double rhs);

    CUtlString operator+(const char *pOther);
    CUtlString operator+(int rhs);

    int Format(const char *pFormat, ...);

    // Take a piece out of the string.
    // If you only specify nStart, it'll go from nStart to the end.
    // You can use negative numbers and it'll wrap around to the start.
    CUtlString Slice(int32_t nStart = 0, int32_t nEnd = INT32_MAX);

    // Grab a substring starting from the left or the right side.
    CUtlString Left(int32_t nChars);
    CUtlString Right(int32_t nChars);

    // Replace all instances of one character with another.
    CUtlString Replace(char cFrom, char cTo);

    // Calls right through to V_MakeAbsolutePath.
    CUtlString AbsPath(const char *pStartingDir = NULL);

    // Gets the filename (everything except the path.. c:\a\b\c\somefile.txt -> somefile.txt).
    CUtlString UnqualifiedFilename();

    // Strips off one directory. Uses V_StripLastDir but strips the last slash also!
    CUtlString DirName();

    // Works like V_ComposeFileName.
    static CUtlString PathJoin(const char *pStr1, const char *pStr2);

    // These can be used for utlvector sorts.
    static int __cdecl SortCaseInsensitive(const CUtlString *pString1, const CUtlString *pString2);
    static int __cdecl SortCaseSensitive(const CUtlString *pString1, const CUtlString *pString2);

private:
    CUtlBinaryBlock m_Storage;
};


//-----------------------------------------------------------------------------
// Inline methods
//-----------------------------------------------------------------------------
inline bool CUtlString::IsEmpty() const
{
    return Length() == 0;
}

inline int __cdecl CUtlString::SortCaseInsensitive(const CUtlString *pString1, const CUtlString *pString2)
{
    return _stricmp(pString1->String(), pString2->String());
}

inline int __cdecl CUtlString::SortCaseSensitive(const CUtlString *pString1, const CUtlString *pString2)
{
    return strcmp(pString1->String(), pString2->String());
}

```

`CSGOSimple/valve_sdk/misc/UtlVector.hpp`:

```hpp
#pragma once

#include <cstring>
#include "UtlMemory.hpp"

template< class T, class A = CUtlMemory<T> >
class CUtlVector
{
    typedef A CAllocator;
public:
    typedef T ElemType_t;

    // constructor, destructor
    CUtlVector(int growSize = 0, int initSize = 0);
    CUtlVector(T* pMemory, int allocationCount, int numElements = 0);
    ~CUtlVector();

    // Copy the array.
    CUtlVector<T, A>& operator=(const CUtlVector<T, A> &other);

    // element access
    T& operator[](int i);
    const T& operator[](int i) const;
    T& Element(int i);
    const T& Element(int i) const;
    T& Head();
    const T& Head() const;
    T& Tail();
    const T& Tail() const;

    // Gets the base address (can change when adding elements!)
    T* Base() { return m_Memory.Base(); }
    const T* Base() const { return m_Memory.Base(); }
    // Returns the number of elements in the vector
    int Count() const;
    // Is element index valid?
    bool IsValidIndex(int i) const;
    static int InvalidIndex();
    // Adds an element, uses default constructor
    int AddToHead();
    int AddToTail();
    int InsertBefore(int elem);
    int InsertAfter(int elem);
    // Adds an element, uses copy constructor
    int AddToHead(const T& src);
    int AddToTail(const T& src);
    int InsertBefore(int elem, const T& src);
    int InsertAfter(int elem, const T& src);
    // Adds multiple elements, uses default constructor
    int AddMultipleToHead(int num);
    int AddMultipleToTail(int num);
    int AddMultipleToTail(int num, const T *pToCopy);
    int InsertMultipleBefore(int elem, int num);
    int InsertMultipleBefore(int elem, int num, const T *pToCopy);
    int InsertMultipleAfter(int elem, int num);
    // Calls RemoveAll() then AddMultipleToTail.
    void SetSize(int size);
    void SetCount(int count);
    void SetCountNonDestructively(int count); //sets count by adding or removing elements to tail TODO: This should probably be the default behavior for SetCount
    void CopyArray(const T *pArray, int size); //Calls SetSize and copies each element.
                                               // Fast swap
    void Swap(CUtlVector< T, A > &vec);
    // Add the specified array to the tail.
    int AddVectorToTail(CUtlVector<T, A> const &src);
    // Finds an element (element needs operator== defined)
    int GetOffset(const T& src) const;
    void FillWithValue(const T& src);
    bool HasElement(const T& src) const;
    // Makes sure we have enough memory allocated to store a requested # of elements
    void EnsureCapacity(int num);
    // Makes sure we have at least this many elements
    void EnsureCount(int num);
    // Element removal
    void FastRemove(int elem);    // doesn't preserve order
    void Remove(int elem);        // preserves order, shifts elements
    bool FindAndRemove(const T& src);    // removes first occurrence of src, preserves order, shifts elements
    bool FindAndFastRemove(const T& src);    // removes first occurrence of src, doesn't preserve order
    void RemoveMultiple(int elem, int num);    // preserves order, shifts elements
    void RemoveMultipleFromHead(int num); // removes num elements from tail
    void RemoveMultipleFromTail(int num); // removes num elements from tail
    void RemoveAll();                // doesn't deallocate memory
    void Purge(); // Memory deallocation
                  // Purges the list and calls delete on each element in it.
    void PurgeAndDeleteElements();
    // Compacts the vector to the number of elements actually in use 
    void Compact();
    // Set the size by which it grows when it needs to allocate more memory.
    void SetGrowSize(int size) { m_Memory.SetGrowSize(size); }
    int NumAllocated() const;    // Only use this if you really know what you're doing!
    void Sort(int(__cdecl *pfnCompare)(const T *, const T *));

protected:
    // Can't copy this unless we explicitly do it!
    CUtlVector(CUtlVector const& vec) { assert(0); }

    // Grows the vector
    void GrowVector(int num = 1);

    // Shifts elements....
    void ShiftElementsRight(int elem, int num = 1);
    void ShiftElementsLeft(int elem, int num = 1);

public:
    CAllocator m_Memory;
    int m_Size;

    // For easier access to the elements through the debugger
    // it's in release builds so this can be used in libraries correctly
    T *m_pElements;

    inline void ResetDbgInfo()
    {
        m_pElements = Base();
    }
};


//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template< typename T, class A >
inline CUtlVector<T, A>::CUtlVector(int growSize, int initSize) :
    m_Memory(growSize, initSize), m_Size(0)
{
    ResetDbgInfo();
}

template< typename T, class A >
inline CUtlVector<T, A>::CUtlVector(T* pMemory, int allocationCount, int numElements) :
    m_Memory(pMemory, allocationCount), m_Size(numElements)
{
    ResetDbgInfo();
}

template< typename T, class A >
inline CUtlVector<T, A>::~CUtlVector()
{
    Purge();
}

template< typename T, class A >
inline CUtlVector<T, A>& CUtlVector<T, A>::operator=(const CUtlVector<T, A> &other)
{
    int nCount = other.Count();
    SetSize(nCount);
    for(int i = 0; i < nCount; i++) {
        (*this)[i] = other[i];
    }
    return *this;
}


//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template< typename T, class A >
inline T& CUtlVector<T, A>::operator[](int i)
{
    assert(i < m_Size);
    return m_Memory[i];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::operator[](int i) const
{
    assert(i < m_Size);
    return m_Memory[i];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Element(int i)
{
    assert(i < m_Size);
    return m_Memory[i];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Element(int i) const
{
    assert(i < m_Size);
    return m_Memory[i];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Head()
{
    assert(m_Size > 0);
    return m_Memory[0];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Head() const
{
    assert(m_Size > 0);
    return m_Memory[0];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Tail()
{
    assert(m_Size > 0);
    return m_Memory[m_Size - 1];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Tail() const
{
    assert(m_Size > 0);
    return m_Memory[m_Size - 1];
}


//-----------------------------------------------------------------------------
// Count
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::Count() const
{
    return m_Size;
}


//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template< typename T, class A >
inline bool CUtlVector<T, A>::IsValidIndex(int i) const
{
    return (i >= 0) && (i < m_Size);
}


//-----------------------------------------------------------------------------
// Returns in invalid index
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::InvalidIndex()
{
    return -1;
}


//-----------------------------------------------------------------------------
// Grows the vector
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::GrowVector(int num)
{
    if(m_Size + num > m_Memory.NumAllocated()) {
        m_Memory.Grow(m_Size + num - m_Memory.NumAllocated());
    }

    m_Size += num;
    ResetDbgInfo();
}


//-----------------------------------------------------------------------------
// Sorts the vector
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::Sort(int(__cdecl *pfnCompare)(const T *, const T *))
{
    typedef int(__cdecl *QSortCompareFunc_t)(const void *, const void *);
    if(Count() <= 1)
        return;

    if(Base()) {
        qsort(Base(), Count(), sizeof(T), (QSortCompareFunc_t)(pfnCompare));
    } else {
        assert(0);
        // this path is untested
        // if you want to sort vectors that use a non-sequential memory allocator,
        // you'll probably want to patch in a quicksort algorithm here
        // I just threw in this bubble sort to have something just in case...

        for(int i = m_Size - 1; i >= 0; --i) {
            for(int j = 1; j <= i; ++j) {
                if(pfnCompare(&Element(j - 1), &Element(j)) < 0) {
                    V_swap(Element(j - 1), Element(j));
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Makes sure we have enough memory allocated to store a requested # of elements
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::EnsureCapacity(int num)
{
    MEM_ALLOC_CREDIT_CLASS();
    m_Memory.EnsureCapacity(num);
    ResetDbgInfo();
}


//-----------------------------------------------------------------------------
// Makes sure we have at least this many elements
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::EnsureCount(int num)
{
    if(Count() < num) {
        AddMultipleToTail(num - Count());
    }
}


//-----------------------------------------------------------------------------
// Shifts elements
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::ShiftElementsRight(int elem, int num)
{
    assert(IsValidIndex(elem) || (m_Size == 0) || (num == 0));
    int numToMove = m_Size - elem - num;
    if((numToMove > 0) && (num > 0))
        memmove(&Element(elem + num), &Element(elem), numToMove * sizeof(T));
}

template< typename T, class A >
void CUtlVector<T, A>::ShiftElementsLeft(int elem, int num)
{
    assert(IsValidIndex(elem) || (m_Size == 0) || (num == 0));
    int numToMove = m_Size - elem - num;
    if((numToMove > 0) && (num > 0)) {
        memmove(&Element(elem), &Element(elem + num), numToMove * sizeof(T));

#ifdef _DEBUG
        memset(&Element(m_Size - num), 0xDD, num * sizeof(T));
#endif
    }
}


//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::AddToHead()
{
    return InsertBefore(0);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddToTail()
{
    return InsertBefore(m_Size);
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertAfter(int elem)
{
    return InsertBefore(elem + 1);
}

template< typename T, class A >
int CUtlVector<T, A>::InsertBefore(int elem)
{
    // Can insert at the end
    assert((elem == Count()) || IsValidIndex(elem));

    GrowVector();
    ShiftElementsRight(elem);
    Construct(&Element(elem));
    return elem;
}


//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::AddToHead(const T& src)
{
    // Can't insert something that's in the list... reallocation may hose us
    assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
    return InsertBefore(0, src);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddToTail(const T& src)
{
    // Can't insert something that's in the list... reallocation may hose us
    assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
    return InsertBefore(m_Size, src);
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertAfter(int elem, const T& src)
{
    // Can't insert something that's in the list... reallocation may hose us
    assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
    return InsertBefore(elem + 1, src);
}

template< typename T, class A >
int CUtlVector<T, A>::InsertBefore(int elem, const T& src)
{
    // Can't insert something that's in the list... reallocation may hose us
    assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));

    // Can insert at the end
    assert((elem == Count()) || IsValidIndex(elem));

    GrowVector();
    ShiftElementsRight(elem);
    CopyConstruct(&Element(elem), src);
    return elem;
}


//-----------------------------------------------------------------------------
// Adds multiple elements, uses default constructor
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::AddMultipleToHead(int num)
{
    return InsertMultipleBefore(0, num);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddMultipleToTail(int num)
{
    return InsertMultipleBefore(m_Size, num);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddMultipleToTail(int num, const T *pToCopy)
{
    // Can't insert something that's in the list... reallocation may hose us
    assert((Base() == NULL) || !pToCopy || (pToCopy + num <= Base()) || (pToCopy >= (Base() + Count())));

    return InsertMultipleBefore(m_Size, num, pToCopy);
}

template< typename T, class A >
int CUtlVector<T, A>::InsertMultipleAfter(int elem, int num)
{
    return InsertMultipleBefore(elem + 1, num);
}


template< typename T, class A >
void CUtlVector<T, A>::SetCount(int count)
{
    RemoveAll();
    AddMultipleToTail(count);
}

template< typename T, class A >
inline void CUtlVector<T, A>::SetSize(int size)
{
    SetCount(size);
}

template< typename T, class A >
void CUtlVector<T, A>::SetCountNonDestructively(int count)
{
    int delta = count - m_Size;
    if(delta > 0) AddMultipleToTail(delta);
    else if(delta < 0) RemoveMultipleFromTail(-delta);
}

template< typename T, class A >
void CUtlVector<T, A>::CopyArray(const T *pArray, int size)
{
    // Can't insert something that's in the list... reallocation may hose us
    assert((Base() == NULL) || !pArray || (Base() >= (pArray + size)) || (pArray >= (Base() + Count())));

    SetSize(size);
    for(int i = 0; i < size; i++) {
        (*this)[i] = pArray[i];
    }
}

template< typename T, class A >
void CUtlVector<T, A>::Swap(CUtlVector< T, A > &vec)
{
    m_Memory.Swap(vec.m_Memory);
    V_swap(m_Size, vec.m_Size);
#ifndef _X360
    V_swap(m_pElements, vec.m_pElements);
#endif
}

template< typename T, class A >
int CUtlVector<T, A>::AddVectorToTail(CUtlVector const &src)
{
    assert(&src != this);

    int base = Count();

    // Make space.
    int nSrcCount = src.Count();
    EnsureCapacity(base + nSrcCount);

    // Copy the elements.	
    m_Size += nSrcCount;
    for(int i = 0; i < nSrcCount; i++) {
        CopyConstruct(&Element(base + i), src[i]);
    }
    return base;
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertMultipleBefore(int elem, int num)
{
    if(num == 0)
        return elem;

    // Can insert at the end
    assert((elem == Count()) || IsValidIndex(elem));

    GrowVector(num);
    ShiftElementsRight(elem, num);

    // Invoke default constructors
    for(int i = 0; i < num; ++i) {
        Construct(&Element(elem + i));
    }

    return elem;
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertMultipleBefore(int elem, int num, const T *pToInsert)
{
    if(num == 0)
        return elem;

    // Can insert at the end
    assert((elem == Count()) || IsValidIndex(elem));

    GrowVector(num);
    ShiftElementsRight(elem, num);

    // Invoke default constructors
    if(!pToInsert) {
        for(int i = 0; i < num; ++i) {
            Construct(&Element(elem + i));
        }
    } else {
        for(int i = 0; i < num; i++) {
            CopyConstruct(&Element(elem + i), pToInsert[i]);
        }
    }

    return elem;
}


//-----------------------------------------------------------------------------
// Finds an element (element needs operator== defined)
//-----------------------------------------------------------------------------
template< typename T, class A >
int CUtlVector<T, A>::GetOffset(const T& src) const
{
    for(int i = 0; i < Count(); ++i) {
        if(Element(i) == src)
            return i;
    }
    return -1;
}

template< typename T, class A >
void CUtlVector<T, A>::FillWithValue(const T& src)
{
    for(int i = 0; i < Count(); i++) {
        Element(i) = src;
    }
}

template< typename T, class A >
bool CUtlVector<T, A>::HasElement(const T& src) const
{
    return (GetOffset(src) >= 0);
}


//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::FastRemove(int elem)
{
    assert(IsValidIndex(elem));

    Destruct(&Element(elem));
    if(m_Size > 0) {
        if(elem != m_Size - 1)
            memcpy(&Element(elem), &Element(m_Size - 1), sizeof(T));
        --m_Size;
    }
}

template< typename T, class A >
void CUtlVector<T, A>::Remove(int elem)
{
    Destruct(&Element(elem));
    ShiftElementsLeft(elem);
    --m_Size;
}

template< typename T, class A >
bool CUtlVector<T, A>::FindAndRemove(const T& src)
{
    int elem = GetOffset(src);
    if(elem != -1) {
        Remove(elem);
        return true;
    }
    return false;
}

template< typename T, class A >
bool CUtlVector<T, A>::FindAndFastRemove(const T& src)
{
    int elem = GetOffset(src);
    if(elem != -1) {
        FastRemove(elem);
        return true;
    }
    return false;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveMultiple(int elem, int num)
{
    assert(elem >= 0);
    assert(elem + num <= Count());

    for(int i = elem + num; --i >= elem; )
        Destruct(&Element(i));

    ShiftElementsLeft(elem, num);
    m_Size -= num;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveMultipleFromHead(int num)
{
    assert(num <= Count());

    for(int i = num; --i >= 0; )
        Destruct(&Element(i));

    ShiftElementsLeft(0, num);
    m_Size -= num;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveMultipleFromTail(int num)
{
    assert(num <= Count());

    for(int i = m_Size - num; i < m_Size; i++)
        Destruct(&Element(i));

    m_Size -= num;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveAll()
{
    for(int i = m_Size; --i >= 0; ) {
        Destruct(&Element(i));
    }

    m_Size = 0;
}


//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------

template< typename T, class A >
inline void CUtlVector<T, A>::Purge()
{
    RemoveAll();
    m_Memory.Purge();
    ResetDbgInfo();
}


template< typename T, class A >
inline void CUtlVector<T, A>::PurgeAndDeleteElements()
{
    for(int i = 0; i < m_Size; i++) {
        delete Element(i);
    }
    Purge();
}

template< typename T, class A >
inline void CUtlVector<T, A>::Compact()
{
    m_Memory.Purge(m_Size);
}

template< typename T, class A >
inline int CUtlVector<T, A>::NumAllocated() const
{
    return m_Memory.NumAllocated();
}


//-----------------------------------------------------------------------------
// Data and memory validation
//-----------------------------------------------------------------------------
#ifdef DBGFLAG_VALIDATE
template< typename T, class A >
void CUtlVector<T, A>::Validate(CValidator &validator, char *pchName)
{
    validator.Push(typeid(*this).name(), this, pchName);

    m_Memory.Validate(validator, "m_Memory");

    validator.Pop();
}
#endif // DBGFLAG_VALIDATE

// A vector class for storing pointers, so that the elements pointed to by the pointers are deleted
// on exit.
template<class T> class CUtlVectorAutoPurge : public CUtlVector< T, CUtlMemory< T, int> >
{
public:
    ~CUtlVectorAutoPurge(void)
    {
        this->PurgeAndDeleteElements();
    }
};

// easy string list class with dynamically allocated strings. For use with V_SplitString, etc.
// Frees the dynamic strings in destructor.
class CUtlStringList : public CUtlVectorAutoPurge< char *>
{
public:
    void CopyAndAddToTail(char const *pString)			// clone the string and add to the end
    {
        char *pNewStr = new char[1 + strlen(pString)];
        strcpy_s(pNewStr, 1 + strlen(pString), pString);
        AddToTail(pNewStr);
    }

    static int __cdecl SortFunc(char * const * sz1, char * const * sz2)
    {
        return strcmp(*sz1, *sz2);
    }

};
```

`CSGOSimple/valve_sdk/misc/characterset.cpp`:

```cpp
//========= Copyright © 1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
// $Workfile:     $
// $Date:         $
//
//-----------------------------------------------------------------------------
// $Log: $
//
// $NoKeywords: $
//=============================================================================

#include <string.h>
#include "characterset.hpp"

//-----------------------------------------------------------------------------
// Purpose: builds a simple lookup table of a group of important characters
// Input  : *pParseGroup - pointer to the buffer for the group
//			*pGroupString - null terminated list of characters to flag
//-----------------------------------------------------------------------------
void CharacterSetBuild(characterset_t *pSetBuffer, const char *pszSetString)
{
    int i = 0;

    // Test our pointers
    if(!pSetBuffer || !pszSetString)
        return;

    memset(pSetBuffer->Set, 0, sizeof(pSetBuffer->Set));

    while(pszSetString[i]) {
        pSetBuffer->Set[pszSetString[i]] = 1;
        i++;
    }

}
```

`CSGOSimple/valve_sdk/misc/checksum_crc.cpp`:

```cpp
#include "checksum_crc.hpp"

#define BigShort( val )    WordSwap( val )
#define BigWord( val )    WordSwap( val )
#define BigLong( val )    DWordSwap( val )
#define BigDWord( val )    DWordSwap( val )
#define LittleShort( val )   ( val )
#define LittleWord( val )   ( val )
#define LittleLong( val )   ( val )
#define LittleDWord( val )   ( val )
#define SwapShort( val )   BigShort( val )
#define SwapWord( val )    BigWord( val )
#define SwapLong( val )    BigLong( val )
#define SwapDWord( val )   BigDWord( val )

#define CRC32_INIT_VALUE 0xFFFFFFFFUL
#define CRC32_XOR_VALUE  0xFFFFFFFFUL

#define NUM_BYTES 256
static const CRC32_t pulCRCTable[NUM_BYTES] =
{
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
    0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
    0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
    0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
    0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
    0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
    0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
    0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
    0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
    0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
    0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
    0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
    0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
    0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
    0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
    0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
    0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

void CRC32_Init(CRC32_t *pulCRC)
{
    *pulCRC = CRC32_INIT_VALUE;
}

void CRC32_Final(CRC32_t *pulCRC)
{
    *pulCRC ^= CRC32_XOR_VALUE;
}

CRC32_t CRC32_GetTableEntry(unsigned int slot)
{
    return pulCRCTable[(unsigned char)slot];
}

void CRC32_ProcessBuffer(CRC32_t *pulCRC, const void *pBuffer, int nBuffer)
{
    CRC32_t ulCrc = *pulCRC;
    unsigned char *pb = (unsigned char *)pBuffer;
    unsigned int nFront;
    int nMain;

JustAfew:

    switch(nBuffer) {
        case 7:
            ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

        case 6:
            ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

        case 5:
            ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

        case 4:
            ulCrc ^= LittleLong(*(CRC32_t *)pb);
            ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
            ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
            ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
            ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
            *pulCRC = ulCrc;
            return;

        case 3:
            ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

        case 2:
            ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

        case 1:
            ulCrc = pulCRCTable[*pb ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

        case 0:
            *pulCRC = ulCrc;
            return;
    }

    // We may need to do some alignment work up front, and at the end, so that
    // the main loop is aligned and only has to worry about 8 uint8_t at a time.
    //
    // The low-order two bits of pb and nBuffer in total control the
    // upfront work.
    //
    nFront = ((unsigned int)pb) & 3;
    nBuffer -= nFront;
    switch(nFront) {
        case 3:
            ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
        case 2:
            ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
        case 1:
            ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
    }

    nMain = nBuffer >> 3;
    while(nMain--) {
        ulCrc ^= LittleLong(*(CRC32_t *)pb);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc ^= LittleLong(*(CRC32_t *)(pb + 4));
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        pb += 8;
    }

    nBuffer &= 7;
    goto JustAfew;
}

```

`CSGOSimple/valve_sdk/misc/checksum_crc.hpp`:

```hpp
#pragma once

typedef unsigned long CRC32_t;

void CRC32_Init(CRC32_t *pulCRC);
void CRC32_ProcessBuffer(CRC32_t *pulCRC, const void *p, int len);
void CRC32_Final(CRC32_t *pulCRC);
CRC32_t CRC32_GetTableEntry(unsigned int slot);

inline CRC32_t CRC32_ProcessSingleBuffer(const void *p, int len)
{
    CRC32_t crc;

    CRC32_Init(&crc);
    CRC32_ProcessBuffer(&crc, p, len);
    CRC32_Final(&crc);

    return crc;
}

```

`CSGOSimple/valve_sdk/misc/checksum_md5.cpp`:

```cpp
#include "checksum_md5.hpp"

#include <windows.h>
#include <stdio.h>

// The four core functions - F1 is optimized somewhat
// #define F1(x, y, z) (x & y | ~x & z)
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

// This is the central step in the MD5 algorithm.
#define MD5STEP(f, w, x, y, z, data, s) \
        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

//-----------------------------------------------------------------------------
// Purpose: The core of the MD5 algorithm, this alters an existing MD5 hash to
//  reflect the addition of 16 longwords of new data.  MD5Update blocks
//  the data and converts bytes into longwords for this routine.
// Input  : buf[4] - 
//			in[16] - 
// Output : static void
//-----------------------------------------------------------------------------
static void MD5Transform(unsigned int buf[4], unsigned int const in[16])
{
    register unsigned int a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}

//-----------------------------------------------------------------------------
// Purpose: Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious initialization constants.

// Input  : *ctx - 
//-----------------------------------------------------------------------------
void MD5Init(MD5Context_t *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

//-----------------------------------------------------------------------------
// Purpose: Update context to reflect the concatenation of another buffer full of bytes.
// Input  : *ctx - 
//			*buf - 
//			len - 
//-----------------------------------------------------------------------------
void MD5Update(MD5Context_t *ctx, unsigned char const *buf, unsigned int len)
{
    unsigned int t;

    /* Update bitcount */

    t = ctx->bits[0];
    if((ctx->bits[0] = t + ((unsigned int)len << 3)) < t)
        ctx->bits[1]++;         /* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */

                                /* Handle any leading odd-sized chunks */

    if(t) {
        unsigned char *p = (unsigned char *)ctx->in + t;

        t = 64 - t;
        if(len < t) {
            memcpy(p, buf, len);
            return;
        }
        memcpy(p, buf, t);
        //byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (unsigned int *)ctx->in);
        buf += t;
        len -= t;
    }
    /* Process data in 64-uint8_t chunks */

    while(len >= 64) {
        memcpy(ctx->in, buf, 64);
        //byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (unsigned int *)ctx->in);
        buf += 64;
        len -= 64;
    }

    /* Handle any remaining bytes of data. */
    memcpy(ctx->in, buf, len);
}

//-----------------------------------------------------------------------------
// Purpose: Final wrapup - pad to 64-uint8_t boundary with the bit pattern 
// 1 0* (64-bit count of bits processed, MSB-first)
// Input  : digest[MD5_DIGEST_LENGTH] - 
//			*ctx - 
//-----------------------------------------------------------------------------
void MD5Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5Context_t *ctx)
{
    unsigned count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
    always at least one uint8_t free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if(count < 8) {
        /* Two lots of padding:  Pad the first block to 64 bytes */
        memset(p, 0, count);
        //byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (unsigned int *)ctx->in);

        /* Now fill the next block with 56 bytes */
        memset(ctx->in, 0, 56);
    } else {
        /* Pad block to 56 bytes */
        memset(p, 0, count - 8);
    }
    //byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((unsigned int *)ctx->in)[14] = ctx->bits[0];
    ((unsigned int *)ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    //byteReverse((unsigned char *) ctx->buf, 4);
    memcpy(digest, ctx->buf, MD5_DIGEST_LENGTH);
    memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */
}

//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *hash - 
//			hashlen - 
// Output : char
//-----------------------------------------------------------------------------
char *MD5_Print(unsigned char *hash, int hashlen)
{
    static char szReturn[64] = "";
    return szReturn;
}

//-----------------------------------------------------------------------------
// Purpose: generate pseudo random number from a seed number
// Input  : seed number
// Output : pseudo random number
//-----------------------------------------------------------------------------
unsigned int MD5_PseudoRandom(unsigned int nSeed)
{
    MD5Context_t ctx;
    unsigned char digest[MD5_DIGEST_LENGTH]; // The MD5 Hash

    memset(&ctx, 0, sizeof(ctx));

    MD5Init(&ctx);
    MD5Update(&ctx, (unsigned char*)&nSeed, sizeof(nSeed));
    MD5Final(digest, &ctx);

    return *(unsigned int*)(digest + 6);	// use 4 middle bytes for random value
}
```

`CSGOSimple/valve_sdk/misc/checksum_md5.hpp`:

```hpp
#pragma once

// 16 bytes == 128 bit digest
#define MD5_DIGEST_LENGTH 16  

// MD5 Hash
typedef struct
{
    unsigned int	buf[4];
    unsigned int	bits[2];
    unsigned char	in[64];
} MD5Context_t;

void MD5Init(MD5Context_t *context);
void MD5Update(MD5Context_t *context, unsigned char const *buf, unsigned int len);
void MD5Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5Context_t *context);

char *MD5_Print(unsigned char *digest, int hashlen);

unsigned int MD5_PseudoRandom(unsigned int nSeed);
```

`CSGOSimple/valve_sdk/misc/datamap.hpp`:

```hpp
#pragma once
#include <iostream>

struct inputdata_t;
typedef enum _fieldtypes
{
	FIELD_VOID = 0,			// No type or value
	FIELD_FLOAT,			// Any floating point value
	FIELD_STRING,			// A string ID (return from ALLOC_STRING)
	FIELD_VECTOR,			// Any vector, QAngle, or AngularImpulse
	FIELD_QUATERNION,		// A quaternion
	FIELD_INTEGER,			// Any integer or enum
	FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,			// 2 byte integer
	FIELD_CHARACTER,		// a byte
	FIELD_COLOR32,			// 8-bit per channel r,g,b,a (32bit color)
	FIELD_EMBEDDED,			// an embedded object with a datadesc, recursively traverse and embedded class/structure based on an additional typedescription
	FIELD_CUSTOM,			// special type that contains function pointers to it's read/write/parse functions

	FIELD_CLASSPTR,			// CBaseEntity *
	FIELD_EHANDLE,			// Entity handle
	FIELD_EDICT,			// edict_t *

	FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
	FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
	FIELD_TICK,				// an integer tick count( fixed up similarly to time)
	FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)

	FIELD_INPUT,			// a list of inputed data fields (all derived from CMultiInputVar)
	FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)

	FIELD_VMATRIX,			// a vmatrix (output coords are NOT worldspace)

							// NOTE: Use float arrays for local transformations that don't need to be fixed up.
							FIELD_VMATRIX_WORLDSPACE,// A VMatrix that maps some local space to world space (translation is fixed up on level transitions)
							FIELD_MATRIX3X4_WORLDSPACE,	// matrix3x4_t that maps some local space to world space (translation is fixed up on level transitions)

							FIELD_INTERVAL,			// a start and range floating point interval ( e.g., 3.2->3.6 == 3.2 and 0.4 )
							FIELD_MODELINDEX,		// a model index
							FIELD_MATERIALINDEX,	// a material index (using the material precache string table)

							FIELD_VECTOR2D,			// 2 floats

							FIELD_TYPECOUNT,		// MUST BE LAST
} fieldtype_t;

class ISaveRestoreOps;
class C_BaseEntity;
//
// Function prototype for all input handlers.
//
typedef void (C_BaseEntity::*inputfunc_t)(inputdata_t &data);

struct datamap_t;
struct typedescription_t;

enum
{
	TD_OFFSET_NORMAL = 0,
	TD_OFFSET_PACKED = 1,

	// Must be last
	TD_OFFSET_COUNT,
};

struct typedescription_t
{
	int32_t fieldType; //0x0000
	char* fieldName; //0x0004
	int fieldOffset[TD_OFFSET_COUNT]; //0x0008
	int16_t fieldSize_UNKNWN; //0x0010
	int16_t flags_UNKWN; //0x0012
	char pad_0014[12]; //0x0014
	datamap_t* td; //0x0020
	char pad_0024[24]; //0x0024
}; //Size: 0x003C


   //-----------------------------------------------------------------------------
   // Purpose: stores the list of objects in the hierarchy
   //            used to iterate through an object's data descriptions
   //-----------------------------------------------------------------------------
struct datamap_t
{
	typedescription_t    *dataDesc;
	int                    dataNumFields;
	char const            *dataClassName;
	datamap_t            *baseMap;

	bool                chains_validated;
	// Have the "packed" offsets been computed
	bool                packed_offsets_computed;
	int                    packed_size;
};
```

`CSGOSimple/valve_sdk/misc/glow_outline_effect.hpp`:

```hpp
#pragma once

#include "UtlVector.hpp"
#include "../Interfaces/IClientEntity.hpp"

class GlowObjectDefinition_t
{
public:
    GlowObjectDefinition_t() { memset(this, 0, sizeof(*this)); }
   
    int32_t m_nNextFreeSlot;           //0x0000
    class IClientEntity* m_pEntity;    //0x0004
    union
    {
        Vector m_vGlowColor;           //0x0008
        struct
        {
            float   m_flRed;           //0x0012
            float   m_flGreen;         //0x000C
            float   m_flBlue;          //0x0010
        };
    };
    float   m_flAlpha;                 //0x0014
    uint8_t pad_0014[4];               //0x0018
    float   m_flSomeFloat;             //0x001C
    uint8_t pad_001C[4];               //0x0020
    float   m_flAnotherFloat;          //0x0024
    bool    m_bRenderWhenOccluded;     //0x0025
    bool    m_bRenderWhenUnoccluded;   //0x0026
    bool    m_bFullBloomRender;        //0x0027
    uint8_t pad_0027[5];               //0x002C
    int32_t m_nGlowStyle;              //0x0030
    int32_t m_nSplitScreenSlot;        //0x0034

    bool IsUnused() const { return m_nNextFreeSlot != GlowObjectDefinition_t::ENTRY_IN_USE; }

    static const int END_OF_FREE_LIST = -1;
    static const int ENTRY_IN_USE = -2;
}; //Size: 0x0038 (56)

class CGlowObjectManager
{
public:
    int RegisterGlowObject(IClientEntity *pEntity, const Vector &vGlowColor, float flGlowAlpha, bool bRenderWhenOccluded, bool bRenderWhenUnoccluded, int nSplitScreenSlot)
    {
        int nIndex;
        if(m_nFirstFreeSlot == GlowObjectDefinition_t::END_OF_FREE_LIST) {
            nIndex = m_GlowObjectDefinitions.AddToTail();
        } else {
            nIndex = m_nFirstFreeSlot;
            m_nFirstFreeSlot = m_GlowObjectDefinitions[nIndex].m_nNextFreeSlot;
        }

        m_GlowObjectDefinitions[nIndex].m_pEntity = pEntity;
        m_GlowObjectDefinitions[nIndex].m_vGlowColor = vGlowColor;
        m_GlowObjectDefinitions[nIndex].m_flAlpha = flGlowAlpha;
        m_GlowObjectDefinitions[nIndex].m_bRenderWhenOccluded = bRenderWhenOccluded;
        m_GlowObjectDefinitions[nIndex].m_bRenderWhenUnoccluded = bRenderWhenUnoccluded;
        m_GlowObjectDefinitions[nIndex].m_nSplitScreenSlot = nSplitScreenSlot;
        m_GlowObjectDefinitions[nIndex].m_nNextFreeSlot = GlowObjectDefinition_t::ENTRY_IN_USE;

        return nIndex;
    }

    void UnregisterGlowObject(int nGlowObjectHandle)
    {
        m_GlowObjectDefinitions[nGlowObjectHandle].m_nNextFreeSlot = m_nFirstFreeSlot;
        m_GlowObjectDefinitions[nGlowObjectHandle].m_pEntity = NULL;
        m_nFirstFreeSlot = nGlowObjectHandle;
    }

    void SetEntity(int nGlowObjectHandle, IClientEntity *pEntity)
    {
        m_GlowObjectDefinitions[nGlowObjectHandle].m_pEntity = pEntity;
    }

    void SetColor(int nGlowObjectHandle, const Vector &vGlowColor)
    {
        m_GlowObjectDefinitions[nGlowObjectHandle].m_vGlowColor = vGlowColor;
    }

    void SetAlpha(int nGlowObjectHandle, float flAlpha)
    {
        m_GlowObjectDefinitions[nGlowObjectHandle].m_flAlpha = flAlpha;
    }

    void SetRenderFlags(int nGlowObjectHandle, bool bRenderWhenOccluded, bool bRenderWhenUnoccluded)
    {
        m_GlowObjectDefinitions[nGlowObjectHandle].m_bRenderWhenOccluded = bRenderWhenOccluded;
        m_GlowObjectDefinitions[nGlowObjectHandle].m_bRenderWhenUnoccluded = bRenderWhenUnoccluded;
    }

    bool IsRenderingWhenOccluded(int nGlowObjectHandle) const
    {
        return m_GlowObjectDefinitions[nGlowObjectHandle].m_bRenderWhenOccluded;
    }

    bool IsRenderingWhenUnoccluded(int nGlowObjectHandle) const
    {
        return m_GlowObjectDefinitions[nGlowObjectHandle].m_bRenderWhenUnoccluded;
    }

    bool HasGlowEffect(IClientEntity *pEntity) const
    {
        for(int i = 0; i < m_GlowObjectDefinitions.Count(); ++i) {
            if(!m_GlowObjectDefinitions[i].IsUnused() && m_GlowObjectDefinitions[i].m_pEntity == pEntity) {
                return true;
            }
        }

        return false;
    }


    CUtlVector<GlowObjectDefinition_t> m_GlowObjectDefinitions; //0x0000
    int m_nFirstFreeSlot;                                       //0x000C
};
```

`CSGOSimple/valve_sdk/misc/vfunc.hpp`:

```hpp
#pragma once

template<typename FuncType>
__forceinline static FuncType CallVFunction(void* ppClass, int index)
{
    int* pVTable = *(int**)ppClass;
    int dwAddress = pVTable[index];
    return (FuncType)(dwAddress);
}

```

`CSGOSimple/valve_sdk/netvars.cpp`:

```cpp
#include "netvars.hpp"

#include <fstream>
#include <utility>

#include "sdk.hpp"

void NetvarSys::Initialize()
{
    database.clear();

    for(auto clientclass = g_CHLClient->GetAllClasses();
        clientclass != nullptr;
        clientclass = clientclass->m_pNext) {
        if(clientclass->m_pRecvTable) {
            database.emplace_back(LoadTable(clientclass->m_pRecvTable));
        }
    }
}

NetvarSys::netvar_table NetvarSys::LoadTable(RecvTable* recvTable)
{
    auto table = netvar_table{};

    table.offset = 0;
    table.name = recvTable->m_pNetTableName;

    for(auto i = 0; i < recvTable->m_nProps; ++i) {
        auto prop = &recvTable->m_pProps[i];

        if(!prop || isdigit(prop->m_pVarName[0]))
            continue;
        if(strcmp("baseclass", prop->m_pVarName) == 0)
            continue;

        if(prop->m_RecvType == DPT_DataTable && prop->m_pDataTable) {
            table.child_tables.emplace_back(LoadTable(prop->m_pDataTable));
            table.child_tables.back().offset = prop->m_Offset;
            table.child_tables.back().prop = prop;
        } else {
            table.child_props.emplace_back(prop);
        }
    }
    return table;
}

void NetvarSys::Dump()
{
    auto outfile = std::ofstream("netvar_dump.txt");

    Dump(outfile);
}

void NetvarSys::Dump(std::ostream& stream)
{
    for(const auto& table : database) {
        if(table.child_props.empty() && table.child_tables.empty())
            continue;
        stream << table.name << '\n';
        DumpTable(stream, table, 1);
        stream << '\n';
    }

    stream << std::endl;
}

void NetvarSys::DumpTable(std::ostream& stream, const netvar_table& table, uint32_t indentation)
{
    char line_buffer[1024];

    for(const auto& prop : table.child_props) {
        sprintf_s(line_buffer, "%*c%*s: 0x%08X", indentation * 4, ' ', -(50 - (int)indentation * 4), prop->m_pVarName, table.offset + prop->m_Offset);
        stream << line_buffer << '\n';
    }
    for(const auto& child : table.child_tables) {
        sprintf_s(line_buffer, "%*c%*s: 0x%08X", indentation * 4, ' ', -(50 - (int)indentation * 4), child.prop->m_pVarName, table.offset + child.offset);
        stream << line_buffer << '\n';
        DumpTable(stream, child, indentation + 1);
    }
}

uint32_t NetvarSys::GetOffset(const std::string& tableName, const std::string& propName)
{
    auto result = 0u;
    for(const auto& table : database) {
        if(table.name == tableName) {
            result = GetOffset(table, propName);
            if(result != 0)
                return result;
        }
    }
    return 0;
}

uint32_t NetvarSys::GetOffset(const NetvarSys::netvar_table& table, const std::string& propName)
{
    for(const auto& prop : table.child_props) {
        if(strncmp(prop->m_pVarName, propName.data(), propName.size()) == 0) {
            return table.offset + prop->m_Offset;
        }
    }
    for(const auto& child : table.child_tables) {
        auto prop_offset = GetOffset(child, propName);
        if(prop_offset != 0)
            return table.offset + prop_offset;
    }
    for(const auto& child : table.child_tables) {
        if(strncmp(child.prop->m_pVarName, propName.data(), propName.size()) == 0) {
            return table.offset + child.offset;
        }
    }
    return 0;
}

RecvProp* NetvarSys::GetNetvarProp(const std::string& tableName, const std::string& propName)
{
    RecvProp* result = nullptr;
    for(const auto& table : database) {
        if(table.name == tableName) {
            result = GetNetvarProp(table, propName);
        }
    }
    return result;
}

RecvProp* NetvarSys::GetNetvarProp(const NetvarSys::netvar_table& table, const std::string& propName)
{
    for(const auto& prop : table.child_props) {
        if(strncmp(prop->m_pVarName, propName.data(), propName.size()) == 0) {
            return prop;
        }
    }
    for(const auto& child : table.child_tables) {
        auto prop = GetNetvarProp(child, propName);
        if(prop != 0)
            return prop;
    }
    for(const auto& child : table.child_tables) {
        if(strncmp(child.prop->m_pVarName, propName.data(), propName.size()) == 0) {
            return child.prop;
        }
    }
    return nullptr;
}
```

`CSGOSimple/valve_sdk/netvars.hpp`:

```hpp
#pragma once

#include <memory>
#include <iostream>
#include <unordered_map>

#include "Misc/Recv.hpp"
#include "../Singleton.hpp"

class NetvarSys
    : public Singleton<NetvarSys>
{
    struct netvar_table
    {
        std::string               name;
        RecvProp*                 prop;
        uint32_t                  offset;
        std::vector<RecvProp*>    child_props;
        std::vector<netvar_table> child_tables;
    };
public:
    void Initialize();

    void Dump();
    void Dump(std::ostream& stream);

    uint32_t      GetOffset(const std::string& tableName, const std::string& propName);
    RecvProp*     GetNetvarProp(const std::string& tableName, const std::string& propName);

private:
    static netvar_table  LoadTable(RecvTable* clientClass);
    static void          DumpTable(std::ostream& stream, const netvar_table& table, uint32_t indentation);
    static uint32_t      GetOffset(const netvar_table& table, const std::string& propName);
    static RecvProp*     GetNetvarProp(const netvar_table& table, const std::string& propName);

private:
    std::vector<netvar_table>  database;
};
```

`CSGOSimple/valve_sdk/sdk.cpp`:

```cpp
#include "sdk.hpp"

#include "../Helpers/Utils.hpp"

namespace Interfaces
{
    CreateInterfaceFn get_module_factory(HMODULE module)
    {
        return reinterpret_cast<CreateInterfaceFn>(GetProcAddress(module, "CreateInterface"));
    }

    template<typename T>
    T* get_interface(CreateInterfaceFn f, const char* szInterfaceVersion)
    {
        auto result = reinterpret_cast<T*>(f(szInterfaceVersion, nullptr));

        if(!result) {
            throw std::runtime_error(std::string("[get_interface] Failed to GetOffset interface: ") + szInterfaceVersion);
        }

        return result;
    }

    void Initialize()
    {
        auto engineFactory    = get_module_factory(GetModuleHandleW(L"engine.dll"));
        auto clientFactory    = get_module_factory(GetModuleHandleW(L"client.dll"));
        auto valveStdFactory  = get_module_factory(GetModuleHandleW(L"vstdlib.dll"));
        auto vguiFactory      = get_module_factory(GetModuleHandleW(L"vguimatsurface.dll"));
        auto vgui2Factory     = get_module_factory(GetModuleHandleW(L"vgui2.dll"));
        auto matSysFactory    = get_module_factory(GetModuleHandleW(L"materialsystem.dll"));
        auto dataCacheFactory = get_module_factory(GetModuleHandleW(L"datacache.dll"));
        auto vphysicsFactory  = get_module_factory(GetModuleHandleW(L"vphysics.dll"));
        auto inputSysFactory  = get_module_factory(GetModuleHandleW(L"inputsystem.dll"));
        
        g_CHLClient           = get_interface<IBaseClientDLL>      (clientFactory   , "VClient018");
        g_EntityList          = get_interface<IClientEntityList>   (clientFactory   , "VClientEntityList003");
        g_Prediction          = get_interface<IPrediction>         (clientFactory   , "VClientPrediction001");
        g_GameMovement        = get_interface<CGameMovement>       (clientFactory   , "GameMovement001");
        g_MdlCache            = get_interface<IMDLCache>           (dataCacheFactory, "MDLCache004");
        g_EngineClient        = get_interface<IVEngineClient>      (engineFactory   , "VEngineClient014");
        g_MdlInfo             = get_interface<IVModelInfoClient>   (engineFactory   , "VModelInfoClient004");
        g_MdlRender           = get_interface<IVModelRender>       (engineFactory   , "VEngineModel016");
        g_RenderView          = get_interface<IVRenderView>        (engineFactory   , "VEngineRenderView014");
        g_EngineTrace         = get_interface<IEngineTrace>        (engineFactory   , "EngineTraceClient004");
        g_DebugOverlay        = get_interface<IVDebugOverlay>      (engineFactory   , "VDebugOverlay004");
        g_GameEvents          = get_interface<IGameEventManager2>  (engineFactory   , "GAMEEVENTSMANAGER002");
        g_EngineSound         = get_interface<IEngineSound>        (engineFactory   , "IEngineSoundClient003");
        g_MatSystem           = get_interface<IMaterialSystem>     (matSysFactory   , "VMaterialSystem080");
        g_CVar                = get_interface<ICvar>               (valveStdFactory , "VEngineCvar007");
        g_VGuiPanel           = get_interface<IPanel>              (vgui2Factory    , "VGUI_Panel009");
        g_VGuiSurface         = get_interface<ISurface>            (vguiFactory     , "VGUI_Surface031");
        g_PhysSurface         = get_interface<IPhysicsSurfaceProps>(vphysicsFactory , "VPhysicsSurfaceProps001");
        g_InputSystem         = get_interface<IInputSystem>        (inputSysFactory , "InputSystemVersion001");

        auto client = GetModuleHandleW(L"client.dll");
        auto engine = GetModuleHandleW(L"engine.dll");
        auto dx9api = GetModuleHandleW(L"shaderapidx9.dll");
		do {
			g_ClientMode  =      **(IClientMode***)((*(uintptr_t**)g_CHLClient)[10] + 0x5);
		} while (!g_ClientMode);
                g_GlobalVars      =  **(CGlobalVarsBase***)(Utils::PatternScan(client, "A1 ? ? ? ? 5E 8B 40 10") + 1);
		g_Input           =             *(CInput**)(Utils::PatternScan(client, "B9 ? ? ? ? F3 0F 11 04 24 FF 50 10") + 1);
		g_MoveHelper      =      **(IMoveHelper***)(Utils::PatternScan(client, "8B 0D ? ? ? ? 8B 45 ? 51 8B D4 89 02 8B 01") + 2);
		g_GlowObjManager  = *(CGlowObjectManager**)(Utils::PatternScan(client, "0F 11 05 ? ? ? ? 83 C8 01") + 3);
		g_ViewRender      =        *(IViewRender**)(Utils::PatternScan(client, "A1 ? ? ? ? B9 ? ? ? ? C7 05 ? ? ? ? ? ? ? ? FF 10") + 1);
		g_D3DDevice9      = **(IDirect3DDevice9***)(Utils::PatternScan(dx9api, "A1 ? ? ? ? 50 8B 08 FF 51 0C") + 1);
		g_ClientState     =     **(CClientState***)(Utils::PatternScan(engine, "A1 ? ? ? ? 8B 80 ? ? ? ? C3") + 1);
		g_LocalPlayer     =       *(C_LocalPlayer*)(Utils::PatternScan(client, "8B 0D ? ? ? ? 83 FF FF 74 07") + 2);
		g_WeaponSystem    = *(IWeaponSystem * *)(Utils::PatternScan(client, "8B 35 ? ? ? ? FF 10 0F B7 C0") + 2);
    }

    void Dump()
    {
        // Ugly macros ugh
        #define STRINGIFY_IMPL(s) #s
        #define STRINGIFY(s)      STRINGIFY_IMPL(s)
        #define PRINT_INTERFACE(name) Utils::ConsolePrint("%-20s: %p\n", STRINGIFY(name), name)

        PRINT_INTERFACE(g_CHLClient   );
        PRINT_INTERFACE(g_EntityList  );
        PRINT_INTERFACE(g_Prediction  );
        PRINT_INTERFACE(g_GameMovement);
        PRINT_INTERFACE(g_MdlCache    );
        PRINT_INTERFACE(g_EngineClient);
        PRINT_INTERFACE(g_MdlInfo     );
        PRINT_INTERFACE(g_MdlRender   );
        PRINT_INTERFACE(g_RenderView  );
        PRINT_INTERFACE(g_EngineTrace );
        PRINT_INTERFACE(g_DebugOverlay);
        PRINT_INTERFACE(g_GameEvents  );
        PRINT_INTERFACE(g_EngineSound );
        PRINT_INTERFACE(g_MatSystem   );
        PRINT_INTERFACE(g_CVar        );
        PRINT_INTERFACE(g_VGuiPanel   );
        PRINT_INTERFACE(g_VGuiSurface );
        PRINT_INTERFACE(g_PhysSurface );
        PRINT_INTERFACE(g_InputSystem );
    }
}

```

`CSGOSimple/valve_sdk/sdk.hpp`:

```hpp
#pragma once

#define NOMINMAX
#include <Windows.h>

#include "Misc/Enums.hpp"
#include "Misc/vfunc.hpp"

#include "Math/VMatrix.hpp"
#include "Math/QAngle.hpp"
#include "Math/Vector.hpp"
#include "Misc/Studio.hpp"

#include "Interfaces/IAppSystem.hpp"
#include "Interfaces/IBaseClientDll.hpp"
#include "Interfaces/IClientEntity.hpp"
#include "Interfaces/IClientEntityList.hpp"
#include "Interfaces/IClientMode.hpp"
#include "Interfaces/IConVar.hpp"
#include "Interfaces/ICvar.hpp"
#include "Interfaces/IEngineTrace.hpp"
#include "Interfaces/IVEngineClient.hpp"
#include "Interfaces/IVDebugOverlay.hpp"
#include "Interfaces/ISurface.hpp"
#include "Interfaces/CInput.hpp"
#include "Interfaces/IVModelInfoClient.hpp"
#include "Interfaces/IVModelRender.hpp"
#include "Interfaces/IRenderView.hpp"
#include "Interfaces/IGameEventmanager.hpp"
#include "Interfaces/IMaterialSystem.hpp"
#include "Interfaces/IMoveHelper.hpp"
#include "Interfaces/IMDLCache.hpp"
#include "Interfaces/IPrediction.hpp"
#include "Interfaces/IPanel.hpp"
#include "Interfaces/IEngineSound.hpp"
#include "Interfaces/IViewRender.hpp"
#include "Interfaces/CClientState.hpp"
#include "Interfaces/IPhysics.hpp"
#include "Interfaces/IInputSystem.hpp"
#include "interfaces/IRefCounted.hpp"

#include "Misc/Convar.hpp"
#include "Misc/CUserCmd.hpp"
#include "Misc/glow_outline_effect.hpp"
#include "Misc/datamap.hpp"

#include "netvars.hpp"

struct IDirect3DDevice9;

namespace Interfaces
{
    void Initialize();
    void Dump();
}

inline IVEngineClient*       g_EngineClient   = nullptr;
inline IBaseClientDLL*       g_CHLClient      = nullptr;
inline IClientEntityList*    g_EntityList     = nullptr;
inline CGlobalVarsBase*      g_GlobalVars     = nullptr;
inline IEngineTrace*         g_EngineTrace    = nullptr;
inline ICvar*                g_CVar           = nullptr;
inline IPanel*               g_VGuiPanel      = nullptr;
inline IClientMode*          g_ClientMode     = nullptr;
inline IVDebugOverlay*       g_DebugOverlay   = nullptr;
inline ISurface*             g_VGuiSurface    = nullptr;
inline CInput*               g_Input          = nullptr;
inline IVModelInfoClient*    g_MdlInfo        = nullptr;
inline IVModelRender*        g_MdlRender      = nullptr;
inline IVRenderView*         g_RenderView     = nullptr;
inline IMaterialSystem*      g_MatSystem      = nullptr;
inline IGameEventManager2*   g_GameEvents     = nullptr;
inline IMoveHelper*          g_MoveHelper     = nullptr;
inline IMDLCache*            g_MdlCache       = nullptr;
inline IPrediction*          g_Prediction     = nullptr;
inline CGameMovement*        g_GameMovement   = nullptr;
inline IEngineSound*         g_EngineSound    = nullptr;
inline CGlowObjectManager*   g_GlowObjManager = nullptr;
inline IViewRender*          g_ViewRender     = nullptr;
inline IDirect3DDevice9*     g_D3DDevice9     = nullptr;
inline CClientState*         g_ClientState    = nullptr;
inline IPhysicsSurfaceProps* g_PhysSurface    = nullptr;
inline IInputSystem*         g_InputSystem    = nullptr;
inline IWeaponSystem*        g_WeaponSystem   = nullptr;

template<typename... Args>
void ConMsg(const char* pMsg, Args... args)
{
    static auto import = (void(*)(const char*, ...))GetProcAddress(GetModuleHandleW(L"tier0.dll"), "?ConMsg@@YAXPBDZZ");
    return import(pMsg, args...);
}
template<typename... Args>
void ConColorMsg(const Color& clr, const char* pMsg, Args... args)
{
    static auto import = (void(*)(const Color&, const char*, ...))GetProcAddress(GetModuleHandleW(L"tier0.dll"), "?ConColorMsg@@YAXABVColor@@PBDZZ");
    return import(clr, pMsg, args...);
}

#include "Misc/EHandle.hpp"

class C_LocalPlayer
{
    friend bool operator==(const C_LocalPlayer& lhs, void* rhs);
public:
    C_LocalPlayer() : m_local(nullptr) {}

    operator bool() const { return *m_local != nullptr; }
    operator C_BasePlayer*() const { return *m_local; }

    C_BasePlayer* operator->() { return *m_local; }

private:
    C_BasePlayer** m_local;
};

inline C_LocalPlayer g_LocalPlayer;


```

`LICENSE`:

```
MIT License

Copyright (c) 2017 Mark H C
Copyright (c) 2018 spirthack

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# CSGOSimple
CSGOSimple is an internal cheat base. This fork was created after MarkHC stops working on this project

## Repositories:
    Gitlab: https://gitlab.com/spirt/csgosimple
    Github: https://github.com/spirthack/csgosimple

# features ahead MarkHC/CSGOSimple:
    It exists :trollface:
    ImGui updated to newer version, you always can update it manually later
    Latest structs/interfaces updated after CSGO update
    Fixed some bugs, like vfunc hooker
    ImGui Renderer(improved)
    Panorama support


![Menu Screenshot after ImGui update](https://i.imgur.com/pYgCja5.png)


Thanks all original(MarkHC's) CSGOSimple devs.



![ESP Screenshot](https://i.imgur.com/NRJ4e2n.png)
![ESP Screenshot](https://i.imgur.com/KWO0bsw.png)
![ESP Screenshot](https://i.imgur.com/17iVttS.png)

```

`SimpleInjector/README.md`:

```md
# SimpleInjector
This is a very simple LoadLibrary injector for the main project.

*You may use your own injector if you desire.*

## Usage:
1. The DLL must be on the same folder as the injector.
2. Run CSGO.
3. Run the injector.

```

`SimpleInjector/SimpleInjector.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D6A5475A-A3D9-4971-B971-A94520CB0354}</ProjectGuid>
    <RootNamespace>SimpleInjector</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\$(Configuration)\</IntDir>
    <TargetName>injector</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\$(Configuration)\</IntDir>
    <TargetName>injector</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\$(Configuration)\</IntDir>
    <TargetName>injector</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\$(Configuration)\</IntDir>
    <TargetName>injector</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SimpleInjector/SimpleInjector.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`SimpleInjector/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <TlHelp32.h>
#include <string>

bool file_exists(const wchar_t* name)
{
    std::ifstream infile{ name };
    return infile.good();
}

bool process_exists(const wchar_t* name, uint32_t& pid)
{
    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if(snapshot == INVALID_HANDLE_VALUE)
        return false;

    auto entry = PROCESSENTRY32{ sizeof(PROCESSENTRY32) };

    if(Process32First(snapshot, &entry)) {
        do {
            if(!wcscmp(entry.szExeFile, name)) {
                pid = entry.th32ProcessID;
                CloseHandle(snapshot);
                return true;
            }
        } while(Process32Next(snapshot, &entry));
    }
    CloseHandle(snapshot);
    return false;
}

bool enable_debug_privilege(HANDLE process)
{
    LUID luid;
    HANDLE token;
    TOKEN_PRIVILEGES newPrivileges;

    if(!OpenProcessToken(process, TOKEN_ADJUST_PRIVILEGES, &token))
        return false;

    if(!LookupPrivilegeValue(nullptr, SE_DEBUG_NAME, &luid))
        return false;

    newPrivileges.PrivilegeCount = 1;
    newPrivileges.Privileges[0].Luid = luid;
    newPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    return AdjustTokenPrivileges(
        token,                     // TokenHandle
        FALSE,                     // DisableAllPrivileges
        &newPrivileges,            // NewPrivileges
        sizeof(newPrivileges),     // BufferLength
        nullptr,                   // PreviousState (OPTIONAL)
        nullptr                    // ReturnLength (OPTIONAL)
    );
}

bool process_open(uint32_t pid, HANDLE& handle)
{
    handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | 
                         PROCESS_VM_READ | PROCESS_VM_WRITE | 
                         PROCESS_CREATE_THREAD, FALSE, pid);

    return handle != nullptr;
}

bool inject(HANDLE process, const wchar_t* dll)
{
    auto thread = HANDLE{ nullptr };
    auto exit_code = 0;
    auto dllpath = VirtualAllocEx(process, nullptr, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    if(!dllpath)
        goto fail;

    auto success = WriteProcessMemory(process, dllpath, dll, (wcslen(dll) + 1) * sizeof(wchar_t), nullptr);

    if(!success)
        goto fail;

    thread = CreateRemoteThread(process, nullptr, 0,
        (LPTHREAD_START_ROUTINE)LoadLibraryW, dllpath, 0, nullptr);

    if(!thread) {
        goto fail;
    }

    if(WaitForSingleObject(thread, 4000) == WAIT_OBJECT_0) {
        exit_code = 0;
        GetExitCodeThread(thread, (DWORD*)&exit_code);
    }

fail:
    if(thread)
        CloseHandle(thread);
    if(dllpath)
        VirtualFreeEx(process, dllpath, 0, MEM_RELEASE);

    return exit_code != 0;
}

int main()
{
    constexpr auto TARGET_FILE      = L"csgosimple.dll";
    constexpr auto TARGET_PROCESS   = L"csgo.exe";

    wchar_t fullpath[MAX_PATH] = { 0 };
    auto    proc_id = 0u;
    auto    proc_handle = HANDLE{ nullptr };

    enable_debug_privilege(GetCurrentProcess());

    try {
        if(!file_exists(TARGET_FILE))
            throw std::runtime_error{ "DLL not found." };

        if(!process_exists(TARGET_PROCESS, proc_id))
            throw std::runtime_error{ "Process is not running." };

        if(!process_open(proc_id, proc_handle)) {
            throw std::runtime_error{ "Failed to open process." };
        }

        _wfullpath(fullpath, TARGET_FILE, MAX_PATH);

        if(!inject(proc_handle, fullpath)) {
            throw std::runtime_error{ "Failed to inject DLL." };
        }
    } catch(const std::exception& ex) {
        std::cout << "[ERROR] " << ex.what() << '\n';
        std::cout << "Press any key to exit..." << '\n';
        std::cin.get();
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

```