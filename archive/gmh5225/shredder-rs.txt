Project Path: arc_gmh5225_shredder-rs_i5x4f9qh

Source Tree:

```txt
arc_gmh5225_shredder-rs_i5x4f9qh
‚îú‚îÄ‚îÄ ARCHITECTURE.md
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ error.rs
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs
‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îú‚îÄ‚îÄ pe_parser.rs
‚îÇ   ‚îú‚îÄ‚îÄ pe_rebuilder.rs
‚îÇ   ‚îî‚îÄ‚îÄ shredder.rs
‚îî‚îÄ‚îÄ test
    ‚îú‚îÄ‚îÄ target_logic.c
    ‚îú‚îÄ‚îÄ test_target.0786lfmst5gj4fuzkfu3lnfjf.rcgu.o
    ‚îú‚îÄ‚îÄ test_target.rs
    ‚îî‚îÄ‚îÄ test_target.test_target.df1eb9edcc32bb26-cgu.0.rcgu.o

```

`ARCHITECTURE.md`:

```md
# Shredder Engine v2 - Technical Specification

Shredder is a post-compilation polymorphic engine for x86_64. It implements instruction-level fragmentation to break linear control-flow analysis, transforming standard execution into a non-linear graph of jump-linked nodes.

---

## üèóÔ∏è Internal Architecture

The engine operates as a multi-stage pipeline, treating the binary as a malleable stream of instructions rather than a static file.

### 1. PE Forensic Parser (`src/pe_parser.rs`)
Handles target image acquisition and structural validation.
- **ISA Enforcement:** Validates NT headers to ensure x86_64 compatibility (PE32+).
- **RVA Resolution:** Locates the EntryPoint and maps its physical offset within the primary code container (usually `.text`).
- **Boundary Analysis:** Calculates available slack space and alignment requirements for the injection stage.

### 2. Mutation Core (`src/shredder.rs`)
The engine's orchestrator. It uses `iced-x86` for high-fidelity decoding and encoding.
1. **Instruction Decomposition:** Each mnemonic is treated as an independent **Mutation Node**.
2. **Context Preservation:** Injects opaque predicates and junk code that strictly preserve `EFLAGS` and volatile registers to maintain execution integrity.
3. **Control-Flow Linking:** Appends relative JMPs to each node to reconstruct the logical path across a randomized physical layout.
4. **Physical Shuffle:** Implements a non-linear layout strategy. Node `n` and node `n+1` are never adjacent in the final binary, defeating linear sweep disassemblers.

### 3. Image Rebuilder (`src/pe_rebuilder.rs`)
Performs a surgical injection of the mutated payload.
- **Section Injection:** Creates and maps a new `.shred` section. 
- **NT Header Orchestration:** Patches the `AddressOfEntryPoint` and updates `SizeOfImage`.
- **Checksum Invalidation:** Resets the PE checksum to 0, ensuring the OS loader doesn't reject the modified binary.
- **Padding & Alignment:** Uses `0xCC` (INT3) padding for unmapped space, facilitating debugging and identifying illegal execution flows.

---

## üîÑ Execution Flow (Mutation Pipeline)

1. **Loader Hand-off:** The OS maps the PE and transfers control to the new RVA in `.shred`.
2. **The Labyrinth:** Execution enters a sequence of:
    - **Prologue:** Opaque junk (XOR/ROL/LEA) + state backup.
    - **Payload:** The original instruction (with IP-relative fixups).
    - **Epilogue:** State restore + JMP to the next randomized node.
3. **Logic Preservation:** Despite the physical chaos, the logical state remains 100% consistent with the original binary.

---

## üõ†Ô∏è Usage & Integration

### CLI Access
```powershell
# Basic usage for PE transformation
cargo run -- <input.exe> <output.exe>
```

## Transformation Modes
**Linear:** Minimal fragmentation for performance testing.

**Stealth:** Full polymorphic mutation with context protection (recommended for evasion).

## ‚ö†Ô∏è Research Status & Roadmap
**Relocation Handling:** Current focus is on implementing a relocation engine for arbitrary .bin blobs (e.g., CobaltStrike beacons).

**RIP-Relative Fixups:** Improving the handling of data-dependent instructions when moved to external sections.

**CFG Recovery Resistance:** Exploring indirect JMP tables to further obfuscate the control-flow graph.
```

`Cargo.toml`:

```toml
[package]
name = "shredder_demo"
version = "0.1.0"
edition = "2021"

[dependencies]
# Para desensamblar y re-ensamblar c√≥digo x64
iced-x86 = "1.21.0"
# Para leer/escribir archivos PE (.exe)
exe = "0.5"
# Error handling
thiserror = "1"
rand = "0.9.2"

```

`README.md`:

```md
# Shredder-RS

A polymorphic mutation engine for x86_64 binaries.

## Overview
Shredder-RS implements instruction-level shredding to defeat static analysis. By breaking the linear flow of the code and injecting randomized junk nodes, it forces disassemblers to follow a complex graph of JMP-linked instructions.

## Key Features
- **Context-Aware Mutation:** Preserves EFLAGS and volatile registers.
- **Non-Linear Layout:** Randomized physical instruction placement.
- **PE Support:** Automated section injection and EntryPoint hijacking.

## Documentation
For deep technical details, see [ARCHITECTURE.md](./ARCHITECTURE.md).

```

`src/error.rs`:

```rs
//! Error types for the Shredder Engine

use thiserror::Error;

#[derive(Error, Debug)]
pub enum ShredderError {
    #[error("Failed to read file: {0}")]
    FileRead(#[from] std::io::Error),

    #[error("Invalid PE file: {0}")]
    InvalidPE(String),

    #[error("Section not found: {0}")]
    SectionNotFound(String),

    #[error("Failed to encode instructions: {0}")]
    EncodingError(String),

    #[error("PE rebuild failed: {0}")]
    RebuildError(String),
}

```

`src/lib.rs`:

```rs
//! Shredder Engine - Obfuscador de c√≥digo x86_64
//!
//! Este m√≥dulo provee herramientas para:
//! - Parsear archivos PE (.exe)
//! - Ofuscar c√≥digo mediante shredding (fragmentaci√≥n + junk insertion)
//! - Reconstruir PEs con c√≥digo ofuscado

pub mod error;
pub mod pe_parser;
pub mod pe_rebuilder;
pub mod shredder;

pub use error::ShredderError;
pub use pe_parser::ParsedPE;
pub use pe_rebuilder::rebuild_pe;
pub use shredder::{shred, ShreddedCode, ShredderConfig};

```

`src/main.rs`:

```rs
use std::env;
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use std::process;

use shredder_demo::{
    pe_parser::parse_pe,
    pe_rebuilder::rebuild_pe,
    shredder::{shred, ShredderConfig},
};

/// Engine entry point.
/// Handles target acquisition and orchestration of the mutation pipeline.
fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        print_usage();
        process::exit(1);
    }

    let input_path = PathBuf::from(&args[1]);
    let output_path = args
        .get(2)
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("mutated_bin.exe"));

    // Validation check before heavy lifting
    if !input_path.exists() {
        eprintln!("[!] Error: Target file not found: {:?}", input_path);
        process::exit(1);
    }

    println!("[*] Initializing Shredder Engine...");

    // Mutation mode selection
    let use_junk = select_payload_mode();

    if let Err(e) = execute_shredding_pipeline(&input_path, &output_path, use_junk) {
        eprintln!("[!] Pipeline failure: {}", e);
        process::exit(1);
    }
}

fn print_usage() {
    println!("Usage: shredder <input.exe> [output.exe]");
    println!("Mutation engine for instruction-level polymorphism.");
}

fn select_payload_mode() -> bool {
    println!("\nTransformation Modes:");
    println!("  [1] Linear: Basic instruction fragmentation.");
    println!("  [2] Stealth: Advanced mutation with EFLAGS/Context preservation.");
    print!("\nSelect mode > ");
    io::stdout().flush().ok();

    let mut input = String::new();
    io::stdin().read_line(&mut input).ok();
    input.trim() == "2"
}

fn execute_shredding_pipeline(
    input: &Path,
    output: &Path,
    stealth_mode: bool,
) -> Result<(), Box<dyn std::error::Error>> {
    // 1. Target Parsing
    let parsed = parse_pe(input)?;

    // 2. Code Acquisition
    // CAMBIO: Usamos get_local_entry_offset en lugar de entry_offset_in_text
    let entry_offset = parsed
        .get_local_entry_offset()
        .ok_or("Failed to resolve entry point offset within .text")?;

    // CAMBIO: Usamos section_data en lugar de text_section_bytes
    let code_limit = (entry_offset + 512).min(parsed.section_data.len());
    let code_to_shred = &parsed.section_data[entry_offset..code_limit];

    // 3. Environment Preparation
    let new_section_rva = parsed.next_available_rva();
    let target_base_ip = parsed.image_base + new_section_rva as u64;

    let config = ShredderConfig {
        base_ip: target_base_ip,
        block_separation: 0x100,
        junk_count: if stealth_mode { 4 } else { 0 },
        use_junk: stealth_mode,
    };

    println!("[+] Target RVA resolved: 0x{:X}", new_section_rva);
    println!(
        "[*] Applying {} transformation...",
        if stealth_mode { "stealth" } else { "linear" }
    );

    // 4. Mutation Execution
    // CAMBIO: Usamos get_code_base_va en lugar de code_start_va
    let shredded = shred(
        code_to_shred,
        parsed.get_code_base_va() + entry_offset as u64,
        config.clone(),
    )?;

    // 5. Binary Reconstruction
    rebuild_pe(&parsed, &shredded, config.base_ip, output)?;

    println!("[+] Build successful: {:?}", output);
    Ok(())
}

```

`src/pe_parser.rs`:

```rs
//! PE Forensic Parser - Extraction and validation of executable images.
use crate::error::ShredderError;
use exe::pe::{VecPE, PE};
use exe::{Buffer, SectionCharacteristics};
use std::path::Path;

pub struct ParsedPE {
    pub image_buffer: Vec<u8>,
    pub section_data: Vec<u8>,
    pub section_rva: u32,
    pub file_offset: u32,
    pub entry_rva: u32,
    pub image_base: u64,
    pub raw_instance: VecPE,
    pub section_name: String,
}

impl ParsedPE {
    /// Returns the Absolute Virtual Address of the code base.
    pub fn get_code_base_va(&self) -> u64 {
        self.image_base + self.section_rva as u64
    }

    /// Resolves the local offset of the EntryPoint relative to the target section.
    pub fn get_local_entry_offset(&self) -> Option<usize> {
        if self.entry_rva >= self.section_rva {
            let diff = (self.entry_rva - self.section_rva) as usize;
            if diff < self.section_data.len() {
                return Some(diff);
            }
        }
        None
    }

    /// Calculates the next aligned Virtual Address (PAGE_SIZE alignment).
    pub fn next_available_rva(&self) -> u32 {
        let sections = self.raw_instance.get_section_table().unwrap();
        let max_rva = sections
            .iter()
            .map(|s| s.virtual_address.0 + s.virtual_size)
            .max()
            .unwrap_or(0);

        (max_rva + 0xFFF) & !0xFFF // 4KB Alignment
    }

    /// Calculates the next aligned File Offset (Sector alignment).
    pub fn next_available_file_offset(&self) -> u32 {
        let sections = self.raw_instance.get_section_table().unwrap();
        let max_off = sections
            .iter()
            .map(|s| s.pointer_to_raw_data.0 + s.size_of_raw_data)
            .max()
            .unwrap_or(0);

        (max_off + 0x1FF) & !0x1FF // 512b Alignment
    }
}

pub fn parse_pe(target: &Path) -> Result<ParsedPE, ShredderError> {
    let pe = VecPE::from_disk_file(target)
        .map_err(|_| ShredderError::InvalidPE("FileSystem I/O error or invalid access".into()))?;

    // ISA Enforcement
    let arch = pe
        .get_arch()
        .map_err(|_| ShredderError::InvalidPE("Corrupt NT Headers".into()))?;
    if arch != exe::Arch::X64 {
        return Err(ShredderError::InvalidPE(
            "Unsupported ISA: Engine requires x86_64 target".into(),
        ));
    }

    let image_base = pe.get_image_base().unwrap_or(0x140000000);
    let entry_rva = pe
        .get_entrypoint()
        .map_err(|_| ShredderError::InvalidPE("EP resolution failed".into()))?
        .0;

    // Locate the primary executable container (usually .text)
    let section_table = pe
        .get_section_table()
        .map_err(|_| ShredderError::InvalidPE("Section table missing".into()))?;

    let target_section = section_table
        .iter()
        .find(|s| {
            s.characteristics.contains(SectionCharacteristics::CNT_CODE)
                || s.characteristics
                    .contains(SectionCharacteristics::MEM_EXECUTE)
        })
        .ok_or_else(|| ShredderError::SectionNotFound("No executable payload found".into()))?;

    let rva = target_section.virtual_address.0;
    let offset = target_section.pointer_to_raw_data.0 as usize;
    let size = target_section.size_of_raw_data as usize;

    // Boundary check for malformed images
    if offset + size > pe.as_slice().len() {
        return Err(ShredderError::InvalidPE(
            "Section mapping exceeds physical file size".into(),
        ));
    }

    let name = String::from_utf8_lossy(
        &target_section
            .name
            .iter()
            .map(|c| c.0)
            .take_while(|&b| b != 0)
            .collect::<Vec<u8>>(),
    )
    .into_owned();

    println!("[+] PE Image Base: 0x{:X}", image_base);
    println!("[+] EntryPoint RVA: 0x{:X}", entry_rva);
    println!("[+] Mapping section: {} [Offset: 0x{:X}]", name, offset);

    Ok(ParsedPE {
        image_buffer: pe.as_slice().to_vec(),
        section_data: pe.as_slice()[offset..offset + size].to_vec(),
        section_rva: rva,
        file_offset: offset as u32,
        entry_rva,
        image_base,
        raw_instance: pe,
        section_name: name,
    })
}

```

`src/pe_rebuilder.rs`:

```rs
//! PE Rebuilder - Section injection and NT Header orchestration.
use crate::error::ShredderError;
use crate::pe_parser::ParsedPE;
use crate::shredder::{assemble_mutated_flow, ShreddedCode};
use exe::pe::PE;
use exe::types::{CChar, Offset, RVA};
use exe::Buffer;
use exe::{ImageSectionHeader, SectionCharacteristics};
use std::path::Path;

/// Reconstructs the binary by injecting a new execution node (.shred).
pub fn rebuild_pe(
    source: &ParsedPE,
    shredded: &ShreddedCode,
    target_base_va: u64,
    out_path: &Path,
) -> Result<(), ShredderError> {
    let mut pe = source.raw_instance.clone();

    // 1. Generate payload for the new Virtual Address
    let payload = assemble_mutated_flow(shredded, target_base_va);

    println!("[*] Patching NT Headers and expanding section table...");

    // 2. Metadata calculation for the new segment
    let new_rva = (target_base_va - source.image_base) as u32;
    let raw_offset = source.next_available_file_offset();
    let file_alignment = 0x200; // Standard PE file alignment
    let aligned_raw_size = (payload.len() as u32 + (file_alignment - 1)) & !(file_alignment - 1);

    // 3. Header Construction (.shred)
    let mut hdr = ImageSectionHeader::default();
    let mut name_buf = [CChar(0); 8];
    for (i, b) in ".shred".as_bytes().iter().enumerate().take(8) {
        name_buf[i] = CChar(*b);
    }

    hdr.name = name_buf;
    hdr.virtual_size = payload.len() as u32;
    hdr.virtual_address = RVA(new_rva);
    hdr.size_of_raw_data = aligned_raw_size;
    hdr.pointer_to_raw_data = Offset(raw_offset);
    hdr.characteristics = SectionCharacteristics::CNT_CODE
        | SectionCharacteristics::MEM_EXECUTE
        | SectionCharacteristics::MEM_READ;

    // 4. Update Image State
    let new_entry_rva = (shredded.entry_point - source.image_base) as u32;

    {
        let nt = pe.get_valid_mut_nt_headers_64().map_err(|e| {
            ShredderError::RebuildError(format!("NT Header access denied: {:?}", e))
        })?;

        nt.file_header.number_of_sections += 1;

        // Recalculate SizeOfImage based on new section bounds
        let section_align = nt.optional_header.section_alignment;
        nt.optional_header.size_of_image =
            (new_rva + payload.len() as u32 + section_align - 1) & !(section_align - 1);

        // Redirect EntryPoint to our mutated entry node
        nt.optional_header.address_of_entry_point = RVA(new_entry_rva);

        // Invalidate Checksum (Commonly required for modified binaries)
        nt.optional_header.checksum = 0;
    }

    // 5. Buffer Assembly
    let mut final_bin = pe.as_slice().to_vec();
    let required_size = raw_offset as usize + aligned_raw_size as usize;
    if final_bin.len() < required_size {
        final_bin.resize(required_size, 0);
    }

    // Write the new section header into the table
    let section_table_off = pe.get_section_table_offset().unwrap().0 as usize;
    let section_count = (source.raw_instance.get_section_table().unwrap().len() + 1) as usize;
    let hdr_pos =
        section_table_off + (section_count - 1) * std::mem::size_of::<ImageSectionHeader>();

    let hdr_slice: &[u8] = unsafe {
        std::slice::from_raw_parts(
            (&hdr as *const _) as *const u8,
            std::mem::size_of::<ImageSectionHeader>(),
        )
    };

    final_bin[hdr_pos..hdr_pos + hdr_slice.len()].copy_from_slice(hdr_slice);

    // Commit mutated code to disk offset
    final_bin[raw_offset as usize..raw_offset as usize + payload.len()].copy_from_slice(&payload);

    std::fs::write(out_path, &final_bin)
        .map_err(|e| ShredderError::RebuildError(format!("Disk write failed: {:?}", e)))?;

    println!(
        "[+] Injection successful: .shred section mapped at RVA 0x{:X}",
        new_rva
    );
    Ok(())
}

```

`src/shredder.rs`:

```rs
//! Core Mutation Engine - Polymorphic instruction shredding & context preservation.
use crate::error::ShredderError;
use iced_x86::{
    BlockEncoder, BlockEncoderOptions, Code, Decoder, DecoderOptions, Instruction,
    InstructionBlock, Register,
};
use rand::seq::SliceRandom;
use rand::Rng;

#[derive(Clone)]
pub struct ShredderConfig {
    pub base_ip: u64,
    pub block_separation: u64,
    pub junk_count: usize,
    pub use_junk: bool,
}

impl Default for ShredderConfig {
    fn default() -> Self {
        Self {
            base_ip: 0x10000,
            block_separation: 0x80, // Tighter packing for shellcode targets
            junk_count: 3,
            use_junk: false,
        }
    }
}

pub struct ShreddedCode {
    pub nodes: Vec<MutationNode>,
    pub entry_point: u64,
    pub total_size: usize,
}

pub struct MutationNode {
    pub id: usize,
    pub rip: u64,
    pub raw_bytes: Vec<u8>,
}

/// Generates opaque predicates and junk instructions.
/// Focuses on preserving EFLAGS to avoid breaking conditional jumps.
fn generate_opaque_junk(count: usize) -> Vec<Instruction> {
    let mut rng = rand::rng();
    let mut junk = Vec::with_capacity(count * 4);

    // Using scratch registers that are less likely to hold critical pointers in small blocks
    let volatile_regs = [Register::R10, Register::R11, Register::R12];

    for _ in 0..count {
        let reg = volatile_regs[rng.random_range(0..volatile_regs.len())];

        // Context sandwich: Save state
        junk.push(Instruction::with1(Code::Push_r64, reg).unwrap());
        junk.push(Instruction::with(Code::Pushfq));

        // Polymorphic junk variety
        match rng.random_range(0..4) {
            0 => junk.push(Instruction::with2(Code::Xor_rm64_r64, reg, reg).unwrap()),
            1 => junk.push(
                Instruction::with2(
                    Code::Lea_r64_m,
                    reg,
                    iced_x86::MemoryOperand::with_base(reg),
                )
                .unwrap(),
            ),
            2 => junk.push(Instruction::with2(Code::Btr_rm64_imm8, reg, 1).unwrap()),
            _ => junk.push(
                Instruction::with2(Code::Rol_rm64_imm8, reg, rng.random_range(1..4)).unwrap(),
            ),
        }

        // Restore state
        junk.push(Instruction::with(Code::Popfq));
        junk.push(Instruction::with1(Code::Pop_r64, reg).unwrap());
    }
    junk
}

pub fn shred(
    payload: &[u8],
    original_rip: u64,
    config: ShredderConfig,
) -> Result<ShreddedCode, ShredderError> {
    let decoder = Decoder::with_ip(64, payload, original_rip, DecoderOptions::NONE);
    let instructions: Vec<Instruction> = decoder.into_iter().filter(|i| !i.is_invalid()).collect();

    if instructions.is_empty() {
        return Err(ShredderError::EncodingError(
            "Zero valid instructions decoded".into(),
        ));
    }

    let n = instructions.len();
    let mut rng = rand::rng();

    // Non-linear physical layout generation
    let mut physical_map: Vec<usize> = (0..n).collect();
    physical_map.shuffle(&mut rng);

    let mut virtual_to_physical_rip = vec![0u64; n];
    for (pos, &idx) in physical_map.iter().enumerate() {
        virtual_to_physical_rip[idx] = config.base_ip + (pos as u64 * config.block_separation);
    }

    let mut logical_nodes = Vec::new();
    for (idx, ins) in instructions.iter().enumerate() {
        let mut node_ins = Vec::new();

        // 1. Prologue Junk
        if config.use_junk {
            node_ins.extend(generate_opaque_junk(config.junk_count));
        }

        // 2. Real Instruction (with IP-relative fixups)
        let mut patched_ins = *ins;
        if patched_ins.is_call_near()
            || patched_ins.is_jmp_near()
            || patched_ins.is_ip_rel_memory_operand()
        {
            let target = ins.near_branch_target();
            if target != 0 {
                patched_ins.set_near_branch64(target);
            }
        }
        node_ins.push(patched_ins);

        // 3. Epilogue / Control Flow Linker
        if idx < n - 1 {
            let next_rip = virtual_to_physical_rip[idx + 1];
            node_ins.push(Instruction::with_branch(Code::Jmp_rel32_64, next_rip).unwrap());
        }
        logical_nodes.push(node_ins);
    }

    // Encoding phase
    let mut blocks = Vec::new();
    for (pos, &idx) in physical_map.iter().enumerate() {
        let rip = config.base_ip + (pos as u64 * config.block_separation);
        blocks.push(InstructionBlock::new(&logical_nodes[idx], rip));
    }

    let encoded = BlockEncoder::encode_slice(64, &blocks, BlockEncoderOptions::NONE)
        .map_err(|e| ShredderError::EncodingError(e.to_string()))?;

    let final_nodes = encoded
        .iter()
        .enumerate()
        .map(|(i, r)| MutationNode {
            id: physical_map[i],
            rip: r.rip,
            raw_bytes: r.code_buffer.clone(),
        })
        .collect();

    Ok(ShreddedCode {
        nodes: final_nodes,
        entry_point: virtual_to_physical_rip[0],
        total_size: encoded.iter().map(|r| r.code_buffer.len()).sum(),
    })
}

pub fn assemble_mutated_flow(shredded: &ShreddedCode, base_rva: u64) -> Vec<u8> {
    let stream_end = shredded
        .nodes
        .iter()
        .map(|n| (n.rip - base_rva) as usize + n.raw_bytes.len())
        .max()
        .unwrap_or(0);

    let mut stream = vec![0xCCu8; stream_end]; // Using INT3 (0xCC) for padding, more common in debug/research
    for node in &shredded.nodes {
        let offset = (node.rip - base_rva) as usize;
        stream[offset..offset + node.raw_bytes.len()].copy_from_slice(&node.raw_bytes);
    }
    stream
}

```

`test/target_logic.c`:

```c
// Compilar con: cl /Fe:test/test_target.exe test/target_logic.c /link /DYNAMICBASE:NO /FIXED
// Este c√≥digo no usa la librer√≠a est√°ndar para evitar problemas de RIP-relative en strings.
int main() {
    int a = 5;
    int b = 10;
    int result = 0;

    // Un bucle a√±ade complejidad al Control Flow Graph
    for(int i = 0; i < 5; i++) {
        result += (a * i) + b;
    }

    // Resultado esperado: 
    // i=0: 0+10 = 10
    // i=1: 5+10 = 15
    // i=2: 10+10 = 20
    // i=3: 15+10 = 25
    // i=4: 20+10 = 30
    // Total: 10+15+20+25+30 = 100
    return result; 
}
```

`test/test_target.rs`:

```rs
fn main() {
    println!("Hello from shredded code!");
}

```