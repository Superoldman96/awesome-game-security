Project Path: arc_gmh5225_windows-kernel-pagehook_43_uvezb

Source Tree:

```txt
arc_gmh5225_windows-kernel-pagehook_43_uvezb
├── README.md
├── images
│   ├── image-20221025141707943.png
│   ├── image-20221025142021143.png
│   ├── image-20221025142542299.png
│   └── image-20221025142600028.png
├── windows-kernel-pagehook
│   ├── DriverMain.cpp
│   ├── DriverMain.h
│   ├── DriverTool.cpp
│   ├── DriverTool.h
│   ├── InlineHook.cpp
│   ├── InlineHook.h
│   ├── MemoryManage.cpp
│   ├── MemoryManage.h
│   ├── PageStuct.h
│   ├── windows-kernel-pagehook.inf
│   ├── windows-kernel-pagehook.vcxproj
│   ├── windows-kernel-pagehook.vcxproj.filters
│   └── windows-kernel-pagehook.vcxproj.user
└── windows-kernel-pagehook.sln

```

`README.md`:

```md
# windows kernel pagehook

## Introduction

Windows kernel pagehook is a driver that leverages the Windows kernel paging mechanism to hook process page table entries

## Description

Under the Windows kernel, the kernel address is shared, but since the cr3 of each process is different.

The purpose of pagehook can be achieved by replacing the cr3 under a process and the page table entry in it.

So that only the hooked process will go through the hooking process, and other processes will keep the original process unchanged.

The process to which PatchGuard generally belongs belongs to the system process, but since we are replacing the page table entries of other processes, we cannot scan it and achieve the purpose of hiding.

## Limits

Currently only supports windows 64 bit system.

1. Windows 7 x64 sp1 (test passed)
2. Windows 10 x64  1909 18363.418 (test passed)

## Feature

1. Supports hooking multiple kernel functions in the same process
2. Support for hooking multiple processes at the same time

## Build

Visual Studio 2017 

WDK version 10.0.17763.0

Open windows-kernel-pagehook.sln with Visual Studio

Build project as x64/Release or x64/Debug.(No x86 support for now)

## Snapshots

### windows 7 x64 sp1

![image-20221025142021143](images/image-20221025142021143.png)

![image-20221025141707943](images/image-20221025141707943.png)

### windows 10 x64 1909

![image-20221025142542299](images/image-20221025142542299.png)

![image-20221025142600028](images/image-20221025142600028.png)


```

`windows-kernel-pagehook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.1082
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "windows-kernel-pagehook", "windows-kernel-pagehook\windows-kernel-pagehook.vcxproj", "{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|ARM.ActiveCfg = Debug|ARM
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|ARM.Build.0 = Debug|ARM
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|ARM.Deploy.0 = Debug|ARM
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|ARM64.Build.0 = Debug|ARM64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|x64.ActiveCfg = Debug|x64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|x64.Build.0 = Debug|x64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|x64.Deploy.0 = Debug|x64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|x86.ActiveCfg = Debug|Win32
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|x86.Build.0 = Debug|Win32
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Debug|x86.Deploy.0 = Debug|Win32
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|ARM.ActiveCfg = Release|ARM
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|ARM.Build.0 = Release|ARM
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|ARM.Deploy.0 = Release|ARM
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|ARM64.ActiveCfg = Release|ARM64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|ARM64.Build.0 = Release|ARM64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|ARM64.Deploy.0 = Release|ARM64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|x64.ActiveCfg = Release|x64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|x64.Build.0 = Release|x64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|x64.Deploy.0 = Release|x64
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|x86.ActiveCfg = Release|Win32
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|x86.Build.0 = Release|Win32
		{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {33E0283A-259E-4350-8BB3-2E79D0B83DCD}
	EndGlobalSection
EndGlobal

```

`windows-kernel-pagehook/DriverMain.cpp`:

```cpp
#include "DriverMain.h"

SLIST_ENTRY InlineHook::processListHeadNode;
InlineHook pageHook;

void NtOpenProcessEntry(ULONG64 retAddress, PHookRegs pHookRegs)
{
	DbgPrintEx(77, 0, "NtOpenProcess\n");
}

void NtAllocateVirtualMemoryEntry(ULONG64 retAddress, PHookRegs pHookRegs)
{
	DbgPrintEx(77, 0, "NtAllocateVirtualMemory\n");
}

extern "C"
void DriverUnload(PDRIVER_OBJECT pDriver)
{
	pageHook.UninstallInlineHook();
}

extern "C"
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pRegPath)
{
	NTSTATUS status = STATUS_SUCCESS;

	pageHook.InitInlineHook(L"test.exe");
	UNICODE_STRING funcName = { 0 };
	RtlInitUnicodeString(&funcName, L"NtOpenProcess");
	ULONG64 NtOpenProcessAddress = reinterpret_cast<ULONG64>(MmGetSystemRoutineAddress(&funcName));

	RtlInitUnicodeString(&funcName, L"NtAllocateVirtualMemory");
	ULONG64 NtAllocateVirtualMemoryAddress = reinterpret_cast<ULONG64>(MmGetSystemRoutineAddress(&funcName));

	pageHook.AddInlineHook(NtOpenProcessAddress, reinterpret_cast<ULONG64>(NtOpenProcessEntry));
	pageHook.AddInlineHook(NtAllocateVirtualMemoryAddress, reinterpret_cast<ULONG64>(NtAllocateVirtualMemoryEntry));
	status = pageHook.InstallInlineHook();
	if (!NT_SUCCESS(status))
	{
		pageHook.UninstallInlineHook();
	}

	pDriver->DriverUnload = DriverUnload;
	return status;
}

```

`windows-kernel-pagehook/DriverMain.h`:

```h
#include <ntifs.h>
#include <intrin.h>


#include "PageStuct.h"
#include "DriverTool.h"
#include "MemoryManage.h"
#include "InlineHook.h"
```

`windows-kernel-pagehook/DriverTool.cpp`:

```cpp
#include "DriverMain.h"


NTSTATUS DriverTool::GetProcessByName(PEPROCESS* Process, PWCH ProcessName)
{
	NTSTATUS nStatus = STATUS_SUCCESS;
	PEPROCESS tmpProcess = NULL;

	for (int i = 4; i < 100000; i += 4) {

		nStatus = PsLookupProcessByProcessId(reinterpret_cast<HANDLE>(i), &tmpProcess);
		if (!NT_SUCCESS(nStatus)) {
			continue;
		}

		PUNICODE_STRING tmpProcessName = NULL;
		nStatus = SeLocateProcessImageName(tmpProcess, &tmpProcessName);
		if (!NT_SUCCESS(nStatus)) {
			ObDereferenceObject(tmpProcess);
			continue;
		}

		if (tmpProcessName->Length) {
			if (wcsstr(tmpProcessName->Buffer, ProcessName)) {
				*Process = tmpProcess;
				ExFreePool(tmpProcessName);
				return STATUS_SUCCESS;
			}
		}

		ObDereferenceObject(tmpProcess);
		ExFreePool(tmpProcessName);

	}

	return STATUS_UNSUCCESSFUL;
}

PVOID DriverTool::GetVirtualAddressByPhysical(ULONG64 physicalAddress)
{
	PHYSICAL_ADDRESS pdePhysicalAddress = { 0 };
	pdePhysicalAddress.QuadPart = physicalAddress;
	return MmGetVirtualForPhysical(pdePhysicalAddress);
}

VOID DriverTool::Sleep(LONG msec)
{
	LARGE_INTEGER li;
	li.QuadPart = -10000 * 1;
	li.QuadPart *= msec;
	KeDelayExecutionThread(KernelMode, 0, &li);
}

int DriverTool::insn_len_x86_32(void *insn)
{
	return insn_len_x86(insn, __b32);
}

int DriverTool::insn_len_x86_64(void *insn)
{
	return insn_len_x86(insn, __b64);
}

int DriverTool::insn_len_x86(void *insn, enum __bits bits)
{
	int len = 0, twobytes = 0, has_modrm = 0;
	enum __bits operand_bits = __b32, addr_bits = bits;
	unsigned char *c = (unsigned char*)insn, modrm, opcode;

	/* prefixes
	 *
	 * 0xf0, 0xf2, 0xf3, 0x2e, 0x36
	 * 0x3e, 0x26, 0x64, 0x65, 0x66, 0x67
	 */

	 // skip prefixes
	while (*c == 0xf0 || *c == 0xf2 || *c == 0xf3 ||
		*c == 0x2e || *c == 0x36 || *c == 0x3e || *c == 0x26 ||
		(*c & 0xfc) == 0x64) {
		if (*c == 0x66) // 16bits operands
			operand_bits = __b16;
		if (*c == 0x67) // 16bits addressing (x86-32), 32bits addressing (x86-64)
			addr_bits = bits == __b32 ? __b16 : __b32;
		c++;
		len++;
	}

	if (bits == __b64 && (*c & 0xf0) == 0x40) { // x86-64 && REX byte
		if (*c & REX_W)
			operand_bits = __b64;
		c++;
		len++;
	}

	/* 0x9b prefix is used only by the following 1byte opcodes
	 *
	 * 0xd9 Mod != 11 Reg/Op = 110 or 111
	 * 0xdb ModR/M = 0xe2 or 0xe3
	 * 0xdd Reg/Op = 110 or 111
	 * 0xdf ModR/M = 0xe0
	 */

	 // check for 2bytes opcodes (0x0f prefix)
	if (*c == 0x0f) {
		twobytes = 1;
		c++;
		len++;
	}
	else if (*c == 0x9b && // check 0x9b prefix
		((c[1] == 0xd9 && (c[2] & Mod_M) != Mod_M && (c[2] & 0x30) == 0x30) ||
		(c[1] == 0xdb && (c[2] == 0xe2 || c[2] == 0xe3)) ||
			(c[1] == 0xdd && (c[2] & 0x30) == 0x30) ||
			(c[1] == 0xdf && c[2] == 0xe0)
			)) {
		c++;
		len++;
	}

	opcode = *c++;
	len++;

	/* 1byte opcodes that use ModR/M byte:
	 *
	 * 0x00 - 0x03, 0x08 - 0x0b,
	 * 0x10 - 0x13, 0x18 - 0x1b,
	 * 0x20 - 0x23, 0x28 - 0x2b,
	 * 0x30 - 0x33, 0x38 - 0x3b,
	 * 0x62, 0x63, 0x69, 0x6b,
	 * 0x80 - 0x8f, 0xc0, 0xc1,
	 * 0xc4 - 0xc7,
	 * 0xd0 - 0xd3, 0xd8 - 0xdf
	 * 0xf6, 0xf7, 0xfe, 0xff
	 */

	if (!twobytes &&
		((opcode & 0xf4) == 0 || (opcode & 0xf4) == 0x10 ||
		(opcode & 0xf4) == 0x20 || (opcode & 0xf4) == 0x30 ||
			opcode == 0x62 || opcode == 0x63 || opcode == 0x69 || opcode == 0x6b ||
			(opcode & 0xf0) == 0x80 || opcode == 0xc0 || opcode == 0xc1 ||
			(opcode & 0xfc) == 0xc4 || (opcode & 0xfc) == 0xd0 ||
			(opcode & 0xf8) == 0xd8 || opcode == 0xf6 || opcode == 0xf7 ||
			opcode == 0xfe || opcode == 0xff))
		has_modrm = 1;

	/* 2bytes opcodes that they *don't* use ModR/M byte:
	 *
	 * 0x05 - 0x09, 0x0b, 0x0e,
	 * 0x30 - 0x37, 0x77, 0x80 - 0x8f,
	 * 0xa0 - 0xa2, 0xa8 - 0xaa, 0xb9
	 * 0xc8 - 0xcf
	 */

	if (twobytes) {
		if (!((opcode >= 0x05 && opcode <= 0x09) || opcode == 0x0b ||
			opcode == 0x0e || (opcode & 0xf8) == 0x30 || opcode == 0x77 ||
			(opcode & 0xf0) == 0x80 || (opcode >= 0xa0 && opcode <= 0xa2) ||
			(opcode >= 0xa8 && opcode <= 0xaa) || (opcode & 0xf8) == 0xc8 ||
			opcode == 0xb9))
			has_modrm = 1;

		// 3bytes opcodes
		if (opcode == 0x38 || opcode == 0x3a) {
			c++;
			len++;
		}

		// 3DNow! opcode
		if (opcode == 0x0f)
			len++;
	}

	if (has_modrm) {
		len++;
		modrm = *c++;
		if (addr_bits != __b16 && (modrm & (Mod_M | RM_M)) == 5) // Mod = 00 R/M = 101
			len += 4;
		if (addr_bits == __b16 && (modrm & (Mod_M | RM_M)) == 6) // Mod = 00 R/M = 110 and 16bits addressing
			len += 2;
		if ((modrm & Mod_M) == 0x40) // Mod = 01
			len += 1;
		if ((modrm & Mod_M) == 0x80) // Mod = 10
			len += addr_bits == __b16 ? 2 : 4;

		// check SIB byte
		if (addr_bits != __b16 && (modrm & Mod_M) != Mod_M && (modrm & RM_M) == 4) { // if it has SIB
			len++;
			if ((modrm & Mod_M) == 0 && (*c & Base_M) == 5) // Mod = 00   SIB Base = 101
				len += 4;
			c++;
		}
	}

	/* Immediate operands
	 *
	 * 1byte opcode list:
	 *
	 * imm8 (1 byte)
	 *
	 * 0x04, 0x0c, 0x14, 0x1c, 0x24, 0x2c, 0x34, 0x3c, 0x6a, 0x6b, 0x70 - 0x7f,
	 * 0x80, 0x82, 0x83, 0xa8, 0xb0 - 0xb7, 0xc0, 0xc1, 0xc6, 0xcd, 0xd4,
	 * 0xd5, 0xe0 - 0xe7, 0xeb, 0xf6 (Reg/Op = 000 or Reg/Op = 001)
	 *
	 * imm16 (2 bytes)
	 *
	 * 0xc2, 0xca
	 *
	 * imm16/32 (2 bytes if operand_bits == __b16 else 4 bytes)
	 *
	 * 0x05, 0x0d, 0x15, 0x1d, 0x25, 0x2d, 0x35, 0x3d, 0x68, 0x69, 0x81, 0xa9
	 * 0xc7, 0xe8, 0xe9
	 *
	 * imm16/32/64 (2 bytes if operand_bits == __b16, 4 bytes if __b32, 8 bytes if __b64)
	 *
	 * 0xb8 - 0xbf, 0xf7 (Reg/Op = 000 or Reg/Op = 001)
	 *
	 * moffs (2 bytes if addr_bits == __b16, 4 bytes if __b32, 8 bytes if __b64)
	 *
	 * 0xa0, 0xa1, 0xa2, 0xa3
	 *
	 * others
	 *
	 * 0xea, 0x9a: imm16 + imm16/32
	 * 0xc8: imm16 + imm8
	 *
	 *
	 * 2bytes opcode list:
	 *
	 * imm8 (1 byte)
	 *
	 * 0x70 - 0x73, 0xa4, 0xac, 0xba, 0xc2, 0xc4 - 0xc6
	 *
	 * imm16/32 (2 bytes if operand_bits == __b16 else 4 bytes)
	 *
	 * 0x80 - 0x8f
	 *
	 *
	 * all 3bytes opcodes with 0x3a prefix have imm8
	 */
	if (!twobytes) { // 1byte opcodes
		// imm8
		if (((opcode & 7) == 4 && (opcode & 0xf0) <= 0x30) ||
			opcode == 0x6a || opcode == 0x6b || (opcode & 0xf0) == 0x70 ||
			opcode == 0x80 || opcode == 0x82 || opcode == 0x83 ||
			opcode == 0xa8 || (opcode & 0xf8) == 0xb0 || opcode == 0xc0 ||
			opcode == 0xc1 || opcode == 0xc6 || opcode == 0xcd ||
			opcode == 0xd4 || opcode == 0xd5 || (opcode & 0xf8) == 0xe0 ||
			opcode == 0xeb || (opcode == 0xf6 && (modrm & 0x30) == 0))
			len += 1;

		// imm16
		if (opcode == 0xc2 || opcode == 0xca)
			len += 2;

		// imm16/32
		if (((opcode & 7) == 5 && (opcode & 0xf0) <= 0x30) ||
			opcode == 0x68 || opcode == 0x69 || opcode == 0x81 ||
			opcode == 0xa9 || opcode == 0xc7 || opcode == 0xe8 ||
			opcode == 0xe9)
			len += operand_bits == __b16 ? 2 : 4;

		// imm16/32/64
		if ((opcode & 0xf8) == 0xb8 || (opcode == 0xf7 && (modrm & 0x30) == 0))
			len += operand_bits == __b16 ? 2 : operand_bits == __b32 ? 4 : 8;

		// moffs
		if ((opcode & 0xfc) == 0xa0)
			len += addr_bits == __b16 ? 2 : addr_bits == __b32 ? 4 : 8;

		// others
		if (opcode == 0xea || opcode == 0x9a)
			len += 2 + (operand_bits == __b16 ? 2 : 4);
		if (opcode == 0xc8)
			len += 3;
	}
	else { // 2bytes opcodes
	 // imm8
		if ((opcode & 0xfc) == 0x70 || opcode == 0xa4 ||
			opcode == 0xac || opcode == 0xba || opcode == 0xc2 ||
			(opcode >= 0xc4 && opcode <= 0xc6))
			len += 1;

		// imm16/32
		if ((opcode & 0xf0) == 0x80)
			len += operand_bits == __b16 ? 2 : 4;

		// 3bytes opcodes with 0x3a prefix
		if (opcode == 0x3a)
			len += 1;
	}

	// wrong length
	if (len > MAX_INSN_LEN_x86)
		len = 1;

	return len;
}

DriverTool& DriverTool::Instance()
{
	static DriverTool inst;
	return inst;
}
```

`windows-kernel-pagehook/DriverTool.h`:

```h
#pragma once

#define Mod_M       0xc0
#define RM_M        0x7
#define Base_M      0x7
#define REX_W       0x8

#define MAX_INSN_LEN_x86    15
#define MAX_INSN_LEN_x86_32 MAX_INSN_LEN_x86
#define MAX_INSN_LEN_x86_64 MAX_INSN_LEN_x86

#ifdef __i386__
#define insn_len(insn)  insn_len_x86_32(insn)
#define MAX_INSN_LEN    MAX_INSN_LEN_x86_32
#elif defined(__x86_64__)
#define insn_len(insn)  insn_len_x86_64(insn)
#define MAX_INSN_LEN    MAX_INSN_LEN_x86_64
#endif

enum __bits { __b16, __b32, __b64 };

class DriverTool
{
public:
	NTSTATUS GetProcessByName(PEPROCESS* Process,PWCH ProcessName);
	PVOID GetVirtualAddressByPhysical(ULONG64 physicalAddress);
	VOID Sleep(LONG msec);

	int insn_len_x86_32(void *insn);
	int insn_len_x86_64(void *insn);

	static DriverTool& Instance();
private:
	int insn_len_x86(void *insn, enum __bits bits);
};
```

`windows-kernel-pagehook/InlineHook.cpp`:

```cpp
#include "DriverMain.h"

#define LARGE_PAGE_SIZE 0x200000
#define LARGE_PAGE_SHFIT 21
#define CR3_OFFSET 0x28

VOID InlineHook::ProcessCallBack(_In_ HANDLE ParentId, _In_ HANDLE ProcessId, _In_ BOOLEAN Create)
{
	PEPROCESS targetProcess = NULL;
	NTSTATUS status = PsLookupProcessByProcessId(ProcessId, &targetProcess);

	if (NT_SUCCESS(status) && !Create)
	{
		PSLIST_ENTRY tmpListLinks = processListHeadNode.Next;
		PSLIST_ENTRY preListLinks = &processListHeadNode;
		while (tmpListLinks)
		{
			PProcessListNode pProcessListNode = CONTAINING_RECORD(tmpListLinks, ProcessListNode, ProcessNodeLinks);
			if (pProcessListNode->Process == targetProcess)
			{
				*reinterpret_cast<PULONG64>((reinterpret_cast<ULONG64>(targetProcess) + CR3_OFFSET)) = pProcessListNode->ProcessCr3;
				preListLinks->Next = tmpListLinks->Next;
				tmpListLinks->Next = NULL;
				ExFreePool(pProcessListNode);
				ObDereferenceObject(targetProcess);
				return;
			}
			tmpListLinks = tmpListLinks->Next;
			preListLinks = preListLinks->Next;
		}

		ObDereferenceObject(targetProcess);
	}
}

VOID InlineHook::InitInlineHook(PWCH processName)
{
	hookListHeadNode.Next = NULL;
	memoryListHeadNode.Next = NULL;
	processListHeadNode.Next = NULL;
	currentProcess = NULL;
	hookNums = 0;
	unsigned char tmpCode[] =
	{
		0xF0, 0xFF, 0x05, 0xB9, 0xFF, 0xFF, 0xFF, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x41,
		0x53, 0x41, 0x52, 0x41, 0x51, 0x41, 0x50, 0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50, 0x48,
		0x83, 0xEC, 0x40, 0x48, 0x8B, 0x8C, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x40,
		0x48, 0xB8, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x40,
		0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x41, 0x5B,
		0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xF0, 0xFF, 0x0D, 0x61, 0xFF, 0xFF, 0xFF, 0xE9,
		0x6C, 0xFF, 0xFF, 0xFF
	};
	RtlZeroMemory(stubHookCode, sizeof(stubHookCode));
	memcpy(stubHookCode, tmpCode, sizeof(tmpCode));

	NTSTATUS status=DriverTool::Instance().GetProcessByName(&currentProcess, processName);
	if (!NT_SUCCESS(status))
	{
		DbgPrintEx(77, 0, "get target process failed please init again\n");
		return;
	}

	PProcessListNode pProcessListNode= reinterpret_cast<PProcessListNode>(ExAllocatePool(NonPagedPool, sizeof(ProcessListNode)));
	if (!pProcessListNode)
	{
		DbgPrintEx(77, 0, "allocate processListNode failed please init again\n");
		return;
	}
	pProcessListNode->Process = currentProcess;
	pProcessListNode->ProcessCr3 = *reinterpret_cast<PULONG64>((reinterpret_cast<ULONG64>(currentProcess) + CR3_OFFSET));

	pProcessListNode->ProcessNodeLinks.Next = processListHeadNode.Next;
	processListHeadNode.Next = &pProcessListNode->ProcessNodeLinks;

	PsSetCreateProcessNotifyRoutine(ProcessCallBack, FALSE);
}

PHookListNode InlineHook::GetHookListNode(PULONG64 pHardwarePml4e,PULONG64 pHardwarePdpte,PULONG64 pHardwarePde, PULONG64 pHardwarePte,ULONG64 funcAddress)
{
	PSLIST_ENTRY tmpListLinks = hookListHeadNode.Next;
	PHookListNode pHookListNode = NULL;
	bool flag = false;

	PHookListNode pNewHookListNode = static_cast<PHookListNode>(ExAllocatePool(NonPagedPool, sizeof(HookListNode)));
	if (!pNewHookListNode) return NULL;
	RtlZeroMemory(pNewHookListNode, sizeof(HookListNode));

	while (tmpListLinks)
	{
		pHookListNode=CONTAINING_RECORD(tmpListLinks, HookListNode, HookNodeLinks);
		
		pNewHookListNode->NewCr3 = pHookListNode->NewCr3;
		pNewHookListNode->OldCr3 = pHookListNode->OldCr3;
		
		if (pHookListNode->OriPml4e == *pHardwarePml4e)
		{
			pNewHookListNode->NewPdpttAddress = pHookListNode->NewPdpttAddress;
		}

		if (pHookListNode->OriPdpte == *pHardwarePdpte)
		{
			pNewHookListNode->NewPdtAddress = pHookListNode->NewPdtAddress;
		}

		if (pHookListNode->OriPde == *pHardwarePde)
		{
			pNewHookListNode->NewPttAddress = pHookListNode->NewPttAddress;
		}

		if ((pHookListNode->OriPde & 0x80) == 0x80 && pHookListNode->OriPde == *pHardwarePde)
		{
			ULONG currentPteIndex = (funcAddress & (LARGE_PAGE_SIZE - 1)) / PAGE_SIZE;
			ULONG targetPteIndex = (pHookListNode->HookFuncAddress & (LARGE_PAGE_SIZE - 1)) / PAGE_SIZE;
			if (targetPteIndex == currentPteIndex) pNewHookListNode->NewPteContent = pHookListNode->NewPteContent;
			else
			{
				PCHAR pteContent= reinterpret_cast<PCHAR>(ExAllocatePool(NonPagedPool, PAGE_SIZE));
				while(!pteContent) pteContent = reinterpret_cast<PCHAR>(ExAllocatePool(NonPagedPool, PAGE_SIZE));

				AddPageMemoryNode(pteContent);

				PCHAR pttAddress = reinterpret_cast<PCHAR>(pHookListNode->NewPttAddress);
				ULONG64 oriPte = *reinterpret_cast<PULONG64>(pttAddress + currentPteIndex * 8);
				PCHAR oriPteContent= reinterpret_cast<PCHAR>(DriverTool::Instance().GetVirtualAddressByPhysical(oriPte & (~(PAGE_SIZE-1))));
				memcpy(pteContent, oriPteContent, PAGE_SIZE);

				*reinterpret_cast<PULONG64>(pttAddress + currentPteIndex * 8) = MmGetPhysicalAddress(pteContent).QuadPart | (oriPte & 0xFFF);
				pNewHookListNode->NewPteContent = pteContent;
			}

		}
		else if(pHookListNode->OriPte == *pHardwarePte)
		{
			pNewHookListNode->NewPteContent = pHookListNode->NewPteContent;
		}

		tmpListLinks = tmpListLinks->Next;
	}

	pNewHookListNode->OriPml4e = *pHardwarePml4e;
	pNewHookListNode->OriPdpte = *pHardwarePdpte;
	pNewHookListNode->OriPde = *pHardwarePde;
	pNewHookListNode->OriPte = *pHardwarePte;

	pNewHookListNode->HookNodeLinks.Next = hookListHeadNode.Next;
	hookListHeadNode.Next = &pNewHookListNode->HookNodeLinks;

	return pNewHookListNode;
}

NTSTATUS InlineHook::SpliteLargePage(PHardwareHugePde pHardwareHugePde, PHookListNode pHookListNode,ULONG64 funcAddress)
{
	PHardwarePte pHardwarePte = NULL;
	PUCHAR pteContent = NULL;

	pHardwarePte= reinterpret_cast<PHardwarePte>(ExAllocatePool(NonPagedPool, PAGE_SIZE));
	if (!pHardwarePte) goto free_memory;

	AddPageMemoryNode(pHardwarePte);

	pteContent = reinterpret_cast<PUCHAR>(ExAllocatePool(NonPagedPool, PAGE_SIZE));
	if (!pteContent) goto free_memory;

	AddPageMemoryNode(pteContent);

	ULONG pteIndex= (funcAddress & (LARGE_PAGE_SIZE - 1)) / PAGE_SIZE;

	PCHAR pdeVirtualAddress = reinterpret_cast<PCHAR>(DriverTool::Instance().GetVirtualAddressByPhysical(pHardwareHugePde->PageFrameNumber << LARGE_PAGE_SHFIT));
	if (!MmIsAddressValid(pdeVirtualAddress)) goto free_memory;
	memcpy(pteContent, pdeVirtualAddress + pteIndex * PAGE_SIZE, PAGE_SIZE);

	for (ULONG i = 0; i < 512; i++)
	{
		memcpy(&pHardwarePte[i], pHardwareHugePde, sizeof(HardwarePte));
		pHardwarePte[i].IsPageValid = 0;
		if (pteIndex == i) pHardwarePte[i].PageFrameNumber = MmGetPhysicalAddress(pteContent).QuadPart / PAGE_SIZE;
		else pHardwarePte[i].PageFrameNumber = (pHardwareHugePde->PageFrameNumber << 9) + i; 
	}

	pHookListNode->NewPttAddress = pHardwarePte;
	pHookListNode->NewPteContent = pteContent;

	return STATUS_SUCCESS;

free_memory:
	if (pHardwarePte) ExFreePool(pHardwarePte);
	if (pteContent) ExFreePool(pteContent);

	return STATUS_UNSUCCESSFUL;
}

NTSTATUS InlineHook::ReplacePageItem(PULONG64 pageArray, ULONG64 targetValue,ULONG64 newValue)
{
	ULONG pageItemIndex = -1;
	for (int i = 0; i < 512; i++)
	{
		if (pageArray[i] == targetValue)
		{
			pageItemIndex = i;
			break;
		}
	}

	if (pageItemIndex == -1) return STATUS_UNSUCCESSFUL;
	
	pageArray[pageItemIndex] = newValue;
	return STATUS_SUCCESS;
}

VOID InlineHook::AddPageMemoryNode(PVOID allocateMemory)
{
	PSLIST_ENTRY tmpListLinks = memoryListHeadNode.Next;
	while (tmpListLinks)
	{
		PPageMemoryListNode pMemoryListNode= CONTAINING_RECORD(tmpListLinks, PageMemoryListNode, MemoryNodeLinks);
		if (pMemoryListNode->MemoryAddress == allocateMemory) return;
		tmpListLinks = tmpListLinks->Next;
	}

	PPageMemoryListNode pMemoryListNode = reinterpret_cast<PPageMemoryListNode>(ExAllocatePool(NonPagedPool, sizeof(PageMemoryListNode)));
	while(!pMemoryListNode) pMemoryListNode = reinterpret_cast<PPageMemoryListNode>(ExAllocatePool(NonPagedPool, sizeof(PageMemoryListNode)));

	pMemoryListNode->MemoryAddress = allocateMemory;
	pMemoryListNode->MemoryNodeLinks.Next = memoryListHeadNode.Next;
	memoryListHeadNode.Next = &pMemoryListNode->MemoryNodeLinks;
}


NTSTATUS InlineHook::AddInlineHook(ULONG64 funcAddress,ULONG64 callBack)
{
	if (!currentProcess || !MmIsAddressValid(reinterpret_cast<PVOID>(funcAddress)) || !MmIsAddressValid(reinterpret_cast<PVOID>(callBack)))
	{
		return STATUS_UNSUCCESSFUL;
	}

	KAPC_STATE kApc = { 0 };
	KeStackAttachProcess(currentProcess, &kApc);

	NTSTATUS status = STATUS_UNSUCCESSFUL;
	BOOLEAN isLargePage = false;
	PHardwarePde pHardwarePde = reinterpret_cast<PHardwarePde>(MemoryManage::Instance().GetPde(funcAddress));
	PHardwarePte pHardwarePte = NULL;
	PHardwarePdpte pHardwarePdpte = NULL;
	PHardwarePml4e pHardwarePml4e = NULL;

	if (!MmIsAddressValid(pHardwarePde)) return status;

	if (pHardwarePde->LargePage) isLargePage = true;
	
	pHardwarePml4e = reinterpret_cast<PHardwarePml4e>(MemoryManage::Instance().GetPml4e(funcAddress));
	pHardwarePdpte = reinterpret_cast<PHardwarePdpte>(MemoryManage::Instance().GetPdpte(funcAddress));
	pHardwarePte = reinterpret_cast<PHardwarePte>(MemoryManage::Instance().GetPte(funcAddress));
	
	if (!MmIsAddressValid(pHardwarePml4e) || !MmIsAddressValid(pHardwarePdpte) || !MmIsAddressValid(pHardwarePde) || (!isLargePage && !MmIsAddressValid(pHardwarePte)))
	{
		KeUnstackDetachProcess(&kApc);
		return status;
	}

	PHookListNode pHookListNode=GetHookListNode(reinterpret_cast<PULONG64>(pHardwarePml4e),
		reinterpret_cast<PULONG64>(pHardwarePdpte),
		reinterpret_cast<PULONG64>(pHardwarePde), 
		reinterpret_cast<PULONG64>(pHardwarePte),
		funcAddress);

	if (!pHookListNode) return status;
	if (isLargePage) pHookListNode->OriPte = 0;

	if (!pHookListNode->NewCr3)
	{
		PVOID newCr3 = ExAllocatePool(NonPagedPool, PAGE_SIZE);
		if (!newCr3) goto free_memory;

		AddPageMemoryNode(newCr3);

		ULONG64 targetCr3 = __readcr3();

		PVOID cr3VirtualAddress = DriverTool::Instance().GetVirtualAddressByPhysical(targetCr3&(~(PAGE_SIZE - 1)));
		if (!MmIsAddressValid(cr3VirtualAddress)) return status;
		memcpy(newCr3, cr3VirtualAddress, PAGE_SIZE);

		pHookListNode->NewCr3 = newCr3;
		pHookListNode->OldCr3 = targetCr3;
	}

	if (!pHookListNode->NewPdpttAddress)
	{
		PVOID newPdpttAddress = ExAllocatePool(NonPagedPool, PAGE_SIZE);
		if (!newPdpttAddress) goto free_memory;

		AddPageMemoryNode(newPdpttAddress);

		PVOID pdpttVirtualAddress = DriverTool::Instance().GetVirtualAddressByPhysical(pHardwarePml4e->PageFrameNumber << PAGE_SHIFT);
		
		if (!MmIsAddressValid(pdpttVirtualAddress)) return status;
		memcpy(newPdpttAddress, pdpttVirtualAddress, PAGE_SIZE);

		pHookListNode->NewPdpttAddress = newPdpttAddress;

		status = ReplacePageItem(reinterpret_cast<PULONG64>(pHookListNode->NewCr3), pHookListNode->OriPml4e, MmGetPhysicalAddress(newPdpttAddress).QuadPart | (pHookListNode->OriPml4e & 0xFFF));
		if (!NT_SUCCESS(status)) goto free_memory;
	}

	if (!pHookListNode->NewPdtAddress)
	{
		PVOID newPdtAddress = ExAllocatePool(NonPagedPool, PAGE_SIZE);
		if (!newPdtAddress) goto free_memory;

		AddPageMemoryNode(newPdtAddress);

		PVOID pdtVirtualAddress = DriverTool::Instance().GetVirtualAddressByPhysical(pHardwarePdpte->PageFrameNumber << PAGE_SHIFT);

		if (!MmIsAddressValid(pdtVirtualAddress)) return status;
		memcpy(newPdtAddress, pdtVirtualAddress, PAGE_SIZE);

		pHookListNode->NewPdtAddress = newPdtAddress;

		status = ReplacePageItem(reinterpret_cast<PULONG64>(pHookListNode->NewPdpttAddress), pHookListNode->OriPdpte, MmGetPhysicalAddress(newPdtAddress).QuadPart | (pHookListNode->OriPdpte & 0xFFF));
		if (!NT_SUCCESS(status)) goto free_memory;
	}

	if (!pHookListNode->NewPttAddress)
	{
		if (isLargePage)
		{
			status = SpliteLargePage(reinterpret_cast<PHardwareHugePde>(pHardwarePde), pHookListNode,funcAddress);
			if (!NT_SUCCESS(status)) goto free_memory;
		}
		else
		{
			PVOID newPttAddress = ExAllocatePool(NonPagedPool, PAGE_SIZE);
			if (!newPttAddress) goto free_memory;

			AddPageMemoryNode(newPttAddress);

			PVOID pttVirtualAddress = DriverTool::Instance().GetVirtualAddressByPhysical(pHardwarePde->PageFrameNumber << PAGE_SHIFT);
			if (!MmIsAddressValid(pttVirtualAddress)) return status;

			memcpy(newPttAddress, pttVirtualAddress, PAGE_SIZE);

			pHookListNode->NewPttAddress = newPttAddress;
		}

		if (isLargePage)
		{
			HardwarePde hardwarePde = { 0 };
			memcpy(&hardwarePde, pHardwarePde, sizeof(HardwarePde));
			hardwarePde.LargePage = 0;
			hardwarePde.PageFrameNumber = MmGetPhysicalAddress(pHookListNode->NewPttAddress).QuadPart / PAGE_SIZE;

			status = ReplacePageItem(reinterpret_cast<PULONG64>(pHookListNode->NewPdtAddress), pHookListNode->OriPde, *reinterpret_cast<PULONG64>(&hardwarePde));
			if (!NT_SUCCESS(status)) goto free_memory;
		}
		else
		{
			status = ReplacePageItem(reinterpret_cast<PULONG64>(pHookListNode->NewPdtAddress), pHookListNode->OriPde, MmGetPhysicalAddress(pHookListNode->NewPttAddress).QuadPart | (pHookListNode->OriPde & 0xFFF));
			if (!NT_SUCCESS(status)) goto free_memory;
		}
		
	}

	if (!pHookListNode->NewPteContent)
	{
		PVOID newPteContent = ExAllocatePool(NonPagedPool, PAGE_SIZE);
		if (!newPteContent) goto free_memory;

		AddPageMemoryNode(newPteContent);

		PVOID pteVirtualAddress = DriverTool::Instance().GetVirtualAddressByPhysical(pHardwarePte->PageFrameNumber << PAGE_SHIFT);
		if (!MmIsAddressValid(pteVirtualAddress)) return status;

		memcpy(newPteContent, pteVirtualAddress, PAGE_SIZE);

		pHookListNode->NewPttAddress = newPteContent;

		status = ReplacePageItem(reinterpret_cast<PULONG64>(pHookListNode->NewPttAddress), pHookListNode->OriPte, MmGetPhysicalAddress(newPteContent).QuadPart | (pHookListNode->OriPte & 0xFFF));
		if (!NT_SUCCESS(status)) goto free_memory;
	}

	PHookStub pHookStub = reinterpret_cast<PHookStub>(ExAllocatePool(NonPagedPool, sizeof(HookStub)));
	if (!pHookStub) goto free_memory;
	RtlZeroMemory(pHookStub, sizeof(HookStub));

	memset(pHookStub->OriCode, 0x90, sizeof(pHookStub->OriCode) + sizeof(pHookStub->HookShellCode));
	memcpy(pHookStub->HookShellCode, stubHookCode, sizeof(stubHookCode));
	//repair shellcode
	for (int i = 0; i < sizeof(stubHookCode); i++)
	{
		unsigned char * current = pHookStub->HookShellCode + i;
		if (*reinterpret_cast<int*>(current) == 0xCACACACA)
		{
			*reinterpret_cast<PULONG64>(current) = callBack;
			break;
		}
	}

	pHookListNode->HookCode = pHookStub;
	pHookListNode->HookFuncAddress = funcAddress;
	pHookListNode->CallBack = callBack;
	pHookListNode->LargePage = isLargePage;

	KeUnstackDetachProcess(&kApc);
	return STATUS_SUCCESS;

free_memory:
	KeUnstackDetachProcess(&kApc);
	if (pHookListNode->NewCr3 && MmIsAddressValid(pHookListNode->NewCr3))
	{
		ExFreePool(pHookListNode->NewCr3);
	}

	if (pHookListNode->NewPdpttAddress && MmIsAddressValid(pHookListNode->NewPdpttAddress))
	{
		ExFreePool(pHookListNode->NewPdpttAddress);
	}

	if (pHookListNode->NewPdtAddress && MmIsAddressValid(pHookListNode->NewPdtAddress))
	{
		ExFreePool(pHookListNode->NewPdtAddress);
	}

	if (pHookListNode->NewPttAddress && MmIsAddressValid(pHookListNode->NewPttAddress))
	{
		ExFreePool(pHookListNode->NewPttAddress);
	}

	if (pHookListNode->NewPteContent && MmIsAddressValid(pHookListNode->NewPteContent))
	{
		ExFreePool(pHookListNode->NewPteContent);
	}

	hookListHeadNode.Next = pHookListNode->HookNodeLinks.Next;
	pHookListNode->HookNodeLinks.Next = NULL;
	ExFreePool(pHookListNode);

	return status;
}

NTSTATUS InlineHook::InstallInlineHook()
{
	PSLIST_ENTRY tmpListLinks = hookListHeadNode.Next;
	NTSTATUS status = STATUS_SUCCESS;
	if (!currentProcess) return STATUS_UNSUCCESSFUL;
	if (!tmpListLinks) return status;

	while (tmpListLinks)
	{
		PHookListNode pHookListNode = CONTAINING_RECORD(tmpListLinks, HookListNode, HookNodeLinks);
		if (!pHookListNode->flag)
		{
			UCHAR jmpCode[] = "\xFF\x25\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
			UCHAR jmpOriFuncCode[] = "\xFF\x25\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";

			int offset = 0;
			offset = pHookListNode->HookFuncAddress & (PAGE_SIZE - 1);

			int insnLength = 0;
			while (insnLength < sizeof(jmpCode))
				insnLength += DriverTool::Instance().insn_len_x86_64(reinterpret_cast<PVOID>(pHookListNode->HookFuncAddress + insnLength));

			ULONG64 retAddress = pHookListNode->HookFuncAddress + insnLength;
			memcpy(&jmpOriFuncCode[6], &retAddress, sizeof(ULONG64));

			PHookStub pHookStub = reinterpret_cast<PHookStub>(pHookListNode->HookCode);
			memcpy(pHookStub->OriCode, reinterpret_cast<PVOID>(pHookListNode->HookFuncAddress), insnLength);
			memcpy(pHookStub->OriCode + insnLength, jmpOriFuncCode, sizeof(jmpOriFuncCode));

			retAddress = reinterpret_cast<ULONG64>(pHookStub->HookShellCode);
			memcpy(&jmpCode[6], &retAddress, sizeof(ULONG64));

			ULONG64 targetAddress = reinterpret_cast<ULONG64>(pHookListNode->NewPteContent) + offset;
			memset(reinterpret_cast<PVOID>(targetAddress), 0x90, insnLength);
			memcpy(reinterpret_cast<PVOID>(targetAddress), jmpCode, sizeof(jmpCode));
			
			pHookListNode->flag = true;
			hookNums++;

			DbgPrintEx(77, 0, "page hook success func:%llx stub:%llx\n", pHookListNode->HookFuncAddress, pHookStub);
		}

		tmpListLinks = tmpListLinks->Next;
	}

	PHookListNode pHookListNode = CONTAINING_RECORD(hookListHeadNode.Next, HookListNode, HookNodeLinks);
	*reinterpret_cast<PULONG64>((reinterpret_cast<ULONG64>(currentProcess) + CR3_OFFSET)) = MmGetPhysicalAddress(pHookListNode->NewCr3).QuadPart | (pHookListNode->OldCr3 & (PAGE_SIZE-1));

	return status;
}

NTSTATUS InlineHook::UninstallInlineHook()
{
	NTSTATUS status = STATUS_SUCCESS;
	PSLIST_ENTRY tmpListLinks = NULL;
	ULONG index = 0;
	PULONG64 pHookStubArray = NULL;
	BOOLEAN isExit = false;

	
	if (!currentProcess) return status;
	if (!hookListHeadNode.Next) return status;

	tmpListLinks = processListHeadNode.Next;
	while (tmpListLinks)
	{
		PProcessListNode pProcessListNode = CONTAINING_RECORD(tmpListLinks, ProcessListNode, ProcessNodeLinks);
		if (pProcessListNode->Process == currentProcess)
		{
			isExit = true;
			break;
		}
		tmpListLinks = tmpListLinks->Next;
	}
	
	if (hookNums)
	{
		pHookStubArray = reinterpret_cast<PULONG64>(ExAllocatePool(NonPagedPool, hookNums * sizeof(ULONG64)));
		while (!pHookStubArray) pHookStubArray = reinterpret_cast<PULONG64>(ExAllocatePool(NonPagedPool, hookNums * sizeof(ULONG64)));
	}

	tmpListLinks = hookListHeadNode.Next;
	while (tmpListLinks)
	{
		PHookListNode pHookListNode = CONTAINING_RECORD(tmpListLinks, HookListNode, HookNodeLinks);
		if (pHookListNode->flag) pHookStubArray[index++] = reinterpret_cast<ULONG64>(pHookListNode->HookCode);

		tmpListLinks = tmpListLinks->Next;
	}
	
	if (isExit)
	{
		PHookListNode pHookListNode = CONTAINING_RECORD(hookListHeadNode.Next, HookListNode, HookNodeLinks);
		*reinterpret_cast<PULONG64>((reinterpret_cast<ULONG64>(currentProcess) + CR3_OFFSET)) = pHookListNode->OldCr3;
		for (int i = 0; i < hookNums; i++)
		{
			PHookStub pHookStub = reinterpret_cast<PHookStub>(pHookStubArray[i]);
			while (InterlockedAnd(reinterpret_cast<volatile long *>(pHookStub->UseCount), (~0)))
			{
				DbgPrintEx(77, 0, "waiting for %lx\n", pHookStub->HookShellCode);
				DriverTool::Instance().Sleep(1000);
			}
		}
	}
	
	tmpListLinks = hookListHeadNode.Next;
	while (tmpListLinks)
	{
		PHookListNode pHookListNode = CONTAINING_RECORD(tmpListLinks, HookListNode, HookNodeLinks);
		ExFreePool(pHookListNode->HookCode);
		tmpListLinks = tmpListLinks->Next;
		ExFreePool(pHookListNode);
	}

	tmpListLinks = memoryListHeadNode.Next;
	while (tmpListLinks)
	{
		PPageMemoryListNode pPageMemoryListNode= CONTAINING_RECORD(tmpListLinks, PageMemoryListNode, MemoryNodeLinks);
		ExFreePool(pPageMemoryListNode->MemoryAddress);
		tmpListLinks = tmpListLinks->Next;
		ExFreePool(pPageMemoryListNode);
	}

	hookListHeadNode.Next = NULL;
	memoryListHeadNode.Next = NULL;
	hookNums = 0;
	if (pHookStubArray) ExFreePool(pHookStubArray);
	ObDereferenceObject(currentProcess);
	currentProcess=NULL;

	PsSetCreateProcessNotifyRoutine(ProcessCallBack, TRUE);
	return status;
}












```

`windows-kernel-pagehook/InlineHook.h`:

```h
#pragma once

typedef struct _HookListNode
{
	ULONG64 OldCr3;
	ULONG64 OriPml4e;
	ULONG64 OriPdpte; 
	ULONG64 OriPde; 
	ULONG64 OriPte; 
	PVOID NewCr3;			
	PVOID NewPdpttAddress;
	PVOID NewPdtAddress; 
	PVOID NewPttAddress; 
	PVOID NewPteContent; 
	PVOID HookCode; 
	ULONG64 HookFuncAddress; 
	ULONG64 CallBack;
	SLIST_ENTRY HookNodeLinks;
	BOOLEAN flag;
	BOOLEAN LargePage;
}HookListNode, *PHookListNode;

typedef struct _ProcessListNode
{
	PEPROCESS Process;
	ULONG64 ProcessCr3;
	SLIST_ENTRY ProcessNodeLinks;
}ProcessListNode,*PProcessListNode;

typedef struct _PageMemoryListNode
{
	PVOID MemoryAddress;
	SLIST_ENTRY MemoryNodeLinks;
}PageMemoryListNode,*PPageMemoryListNode;

typedef struct _HookRegs {
	ULONG64 ax;
	ULONG64 cx;
	ULONG64 dx;
	ULONG64 bx;
	ULONG64 sp;
	ULONG64 bp;
	ULONG64 si;
	ULONG64 di;
	ULONG64 r8;
	ULONG64 r9;
	ULONG64 r10;
	ULONG64 r11;
	ULONG64 r12;
	ULONG64 r13;
	ULONG64 r14;
	ULONG64 r15;
}HookRegs,*PHookRegs;

#pragma pack(push,1)
typedef struct _HookStub
{
	volatile unsigned char UseCount[0x10];
	unsigned char OriCode[0x30];
	unsigned char HookShellCode[0x70];

}HookStub,*PHookStub;
#pragma pack(pop)

class InlineHook
{
public:
	VOID InitInlineHook(PWCH processName);
	NTSTATUS AddInlineHook(ULONG64 funcAddress, ULONG64 callBack);
	NTSTATUS InstallInlineHook();
	NTSTATUS UninstallInlineHook();
	
	static SLIST_ENTRY processListHeadNode;

private:
	int hookNums;
	PEPROCESS currentProcess;
	unsigned char stubHookCode[0x64];
	SLIST_ENTRY hookListHeadNode; 
	SLIST_ENTRY memoryListHeadNode; 
	
	static VOID ProcessCallBack(_In_ HANDLE ParentId,_In_ HANDLE ProcessId,_In_ BOOLEAN Create);
	VOID AddPageMemoryNode(PVOID allocateMemory);
	NTSTATUS ReplacePageItem(PULONG64 pageArray, ULONG64 targetValue, ULONG64 newValue);
	NTSTATUS SpliteLargePage(PHardwareHugePde pHardwareHugePde, PHookListNode pHookListNode, ULONG64 funcAddress);
	PHookListNode GetHookListNode(PULONG64 pHardwarePml4e, PULONG64 pHardwarePdpte, PULONG64 pHardwarePde, PULONG64 pHardwarePte, ULONG64 funcAddress);
};
```

`windows-kernel-pagehook/MemoryManage.cpp`:

```cpp
#include "DriverMain.h"
#define PTE_BASE 0xFFFFF68000000000
#define PTE_SHIFT 39
#define PAGE_MASK 0xFFFF000000000000

ULONG64 MemoryManage::GetPteBase()
{
	static ULONG64 pteBase = 0;
	if (pteBase) return pteBase;

	RTL_OSVERSIONINFOW systemVersion = { 0 };
	RtlGetVersion(&systemVersion);

	if (systemVersion.dwBuildNumber == 7600 || systemVersion.dwBuildNumber == 7601 || systemVersion.dwBuildNumber < 14316) {
		pteBase = PTE_BASE;
	}
	else {
		PHYSICAL_ADDRESS pageDirectoryPA = { 0 };
		pageDirectoryPA.QuadPart = __readcr3() & (~(PAGE_SIZE - 1));

		PHardwarePml4e pageDirectoryVA = reinterpret_cast<PHardwarePml4e>(MmGetVirtualForPhysical(pageDirectoryPA));
		if (pageDirectoryVA == nullptr) {
			return 0;
		}

		for (int index = 0; index < 512; index++) {
			if (pageDirectoryVA[index].PageFrameNumber == (pageDirectoryPA.QuadPart >> PAGE_SHIFT)) {
				pteBase = (static_cast<ULONG64>(index) << PTE_SHIFT) | PAGE_MASK;
				break;
			}
		}
	}

	DbgPrintEx(77, 0, "[+] pte_base:%llx\n", pteBase);

	return pteBase;
}

ULONG64 MemoryManage::GetPte(ULONG64 virtualAddress)
{
	ULONG64 pteBase = GetPteBase();
	return ((virtualAddress >> 9) & 0x7FFFFFFFF8) + pteBase;
}

ULONG64 MemoryManage::GetPde(ULONG64 virtualAddress)
{
	ULONG64 pteBase = GetPteBase();
	ULONG64 pte = GetPte(virtualAddress);
	return ((pte >> 9) & 0x7FFFFFFFF8) + pteBase;
}

ULONG64 MemoryManage::GetPdpte(ULONG64 virtualAddress)
{
	ULONG64 pteBase = GetPteBase();
	ULONG64 pde = GetPde(virtualAddress);
	return ((pde >> 9) & 0x7FFFFFFFF8) + pteBase;
}

ULONG64 MemoryManage::GetPml4e(ULONG64 virtualAddress)
{
	ULONG64 pteBase = GetPteBase();
	ULONG64 pdpte = GetPdpte(virtualAddress);
	return ((pdpte >> 9) & 0x7FFFFFFFF8) + pteBase;
}

MemoryManage& MemoryManage::Instance()
{
	static MemoryManage inst;
	return inst;
}
```

`windows-kernel-pagehook/MemoryManage.h`:

```h
#pragma once

class MemoryManage
{
public:
	ULONG64 GetPteBase();

	ULONG64 GetPte(ULONG64 virtualAddress);
	ULONG64 GetPde(ULONG64 virtualAddress);
	ULONG64 GetPdpte(ULONG64 virtualAddress);
	ULONG64 GetPml4e(ULONG64 virtualAddress);

	static MemoryManage& Instance();
};
```

`windows-kernel-pagehook/PageStuct.h`:

```h
#pragma once

//PML4E
typedef struct _HardwarePml4e
{
	ULONG64 Valid : 1;               
	ULONG64 WriteAndRead : 1;        
	ULONG64 UserAccess : 1;          
	ULONG64 WriteThrough : 1;        
	ULONG64 CacheDisable : 1;        
	ULONG64 Accessed : 1;            
	ULONG64 Dirty : 1;               
	ULONG64 IsPageValid : 1;         
	ULONG64 Global : 1;              
	ULONG64 Ignored0 : 3;			 
	ULONG64 PageFrameNumber : 36;	 
	ULONG64 reserved0 : 4;           
	ULONG64 Ignored1 : 11;			 
	ULONG64 NoExecute : 1;           
}HardwarePml4e, *PHardwarePml4e;

//PDPTE
typedef struct _HardwarePdpte
{
	ULONG64 Valid : 1;               
	ULONG64 WriteAndRead : 1;        
	ULONG64 UserAccess : 1;          
	ULONG64 WriteThrough : 1;        
	ULONG64 CacheDisable : 1;        
	ULONG64 Accessed : 1;            
	ULONG64 Dirty : 1;               
	ULONG64 LargePage : 1;           
	ULONG64 Global : 1;              
	ULONG64 Ignored0 : 3;			 
	ULONG64 PageFrameNumber : 36;	 
	ULONG64 reserved0 : 4;           
	ULONG64 Ignored1 : 11;			 
	ULONG64 NoExecute : 1;           
}HardwarePdpte,*PHardwarePdpte;

//Pde
typedef struct _HardwarePde
{
	ULONG64 Valid : 1;               
	ULONG64 WriteAndRead : 1;        
	ULONG64 UserAccess : 1;          
	ULONG64 WriteThrough : 1;        
	ULONG64 CacheDisable : 1;        
	ULONG64 Accessed : 1;            
	ULONG64 Dirty : 1;               
	ULONG64 LargePage : 1;           
	ULONG64 Global : 1;              
	ULONG64 Ignored0 : 3;			 
	ULONG64 PageFrameNumber : 36;	 
	ULONG64 reserved0 : 4;           
	ULONG64 Ignored1 : 11;			 
	ULONG64 NoExecute : 1;           
}HardwarePde, *PHardwarePde;

//2MB PDE
typedef struct _HardwareHugePde
{
	ULONG64 Valid : 1;               
	ULONG64 WriteAndRead : 1;        
	ULONG64 UserAccess : 1;          
	ULONG64 WriteThrough : 1;        
	ULONG64 CacheDisable : 1;        
	ULONG64 Accessed : 1;            
	ULONG64 Dirty : 1;               
	ULONG64 LargePage : 1;           
	ULONG64 Global : 1;              
	ULONG64 Ignored0 : 3;			 
	ULONG64 IsPageValid : 1;		 
	ULONG64 reserved0 : 8;		     
	ULONG64 PageFrameNumber : 27;	 
	ULONG64 reserved1 : 4;           
	ULONG64 Ignored1 : 11;			 
	ULONG64 NoExecute : 1;           
}HardwareHugePde,*PHardwareHugePde;

//PTE
typedef struct _HardwarePte
{
	ULONG64 Valid : 1;               
	ULONG64 WriteAndRead : 1;        
	ULONG64 UserAccess : 1;          
	ULONG64 WriteThrough : 1;        
	ULONG64 CacheDisable : 1;        
	ULONG64 Accessed : 1;            
	ULONG64 Dirty : 1;               
	ULONG64 IsPageValid : 1;         
	ULONG64 Global : 1;              
	ULONG64 Ignored0 : 3;			 
	ULONG64 PageFrameNumber : 36;	 
	ULONG64 reserved0 : 4;           
	ULONG64 Ignored1 : 11;			 
	ULONG64 NoExecute : 1;           
}HardwarePte,*PHardwarePte;

```

`windows-kernel-pagehook/windows-kernel-pagehook.inf`:

```inf
;
; windows-kernel-pagehook.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=windows-kernel-pagehook.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="windows-kernel-pagehook Source Disk"

```

`windows-kernel-pagehook/windows-kernel-pagehook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DE4170F2-A133-4F83-BAFD-2981F3BD40B4}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>windows_kernel_pagehook</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverMain.cpp" />
    <ClCompile Include="DriverTool.cpp" />
    <ClCompile Include="InlineHook.cpp" />
    <ClCompile Include="MemoryManage.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverMain.h" />
    <ClInclude Include="DriverTool.h" />
    <ClInclude Include="InlineHook.h" />
    <ClInclude Include="MemoryManage.h" />
    <ClInclude Include="PageStuct.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`windows-kernel-pagehook/windows-kernel-pagehook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverTool.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="InlineHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemoryManage.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverMain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverTool.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="InlineHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemoryManage.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PageStuct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`windows-kernel-pagehook/windows-kernel-pagehook.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```