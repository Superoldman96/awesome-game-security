Project Path: arc_gmh5225_EAC-CR3-BYPASS_q6gpsvaf

Source Tree:

```txt
arc_gmh5225_EAC-CR3-BYPASS_q6gpsvaf
├── EAC-CR3-BYPASS (KM)
│   ├── DirbaseBypass.c
│   ├── DirbaseBypass.h
│   ├── EAC-CR3-BYPASS.sln
│   ├── EAC-CR3-BYPASS.vcxproj
│   ├── EAC-CR3-BYPASS.vcxproj.filters
│   ├── EAC-CR3-BYPASS.vcxproj.user
│   ├── communication.c
│   ├── communication.h
│   ├── defines.h
│   ├── driverEntry.c
│   ├── driverEntry.h
│   ├── ioctl.h
│   ├── structure.h
│   └── structure2.h
├── EAC-CR3-BYPASS (UM)
│   ├── EAC-CR3-BYPASS (UM).vcxproj
│   ├── EAC-CR3-BYPASS (UM).vcxproj.filters
│   ├── EAC-CR3-BYPASS (UM).vcxproj.user
│   ├── driver.h
│   ├── imports.h
│   ├── ioctl.h
│   ├── main.cpp
│   └── structure.h
└── EAC-CR3-BYPASS.sln

```

`EAC-CR3-BYPASS (KM)/DirbaseBypass.c`:

```c
#include <ntifs.h>
#include <ntimage.h>
#include "defines.h"

// Global variables for storing base addresses
volatile uint64_t g_MmPfnDatabase = 0;
volatile uint64_t g_PXE_BASE = 0;
volatile uint64_t g_idx = 0;

// Initialize definitions and global variables
void initDefinesCR3() {
    KDDEBUGGER_DATA64 kdBlock = { 0 };
    CONTEXT context = { 0 };
    context.ContextFlags = CONTEXT_FULL;
    RtlCaptureContext(&context);

    PDUMP_HEADER dumpHeader = ExAllocatePool(NonPagedPool, DUMP_BLOCK_SIZE);
    if (dumpHeader) {
        KeCapturePersistentThreadState(&context, NULL, 0, 0, 0, 0, 0, dumpHeader);
        RtlCopyMemory(&kdBlock, (PUCHAR)dumpHeader + KDDEBUGGER_DATA_OFFSET, sizeof(kdBlock));

        ExFreePool(dumpHeader);

        g_MmPfnDatabase = *(ULONG64*)(kdBlock.MmPfnDatabase);

        // Calculate base addresses for page table entries
        ULONG64 g_PTE_BASE = kdBlock.PteBase;
        ULONG64 g_PDE_BASE = g_PTE_BASE + ((g_PTE_BASE & 0xffffffffffff) >> 9);
        ULONG64 g_PPE_BASE = g_PTE_BASE + ((g_PDE_BASE & 0xffffffffffff) >> 9);
        g_PXE_BASE = g_PTE_BASE + ((g_PPE_BASE & 0xffffffffffff) >> 9);
        g_idx = (g_PTE_BASE >> 39) - 0x1FFFE00;
    }
}

// Retrieve the Directory Base address of a specific process
uintptr_t GetDirBase(uint32_t pid) {

    // In case your dumb as fuck and forgot to start CR3
    if (g_MmPfnDatabase == 0 && g_PXE_BASE == 0 && g_idx == 0) {
        initDefinesCR3();
    }

    PHYSICAL_MEMORY_RANGE* memRange = MmGetPhysicalMemoryRanges();
    if (!memRange) {
        // Error: Failed to get physical memory ranges
        return 0;
    }

    // First, obtain the PEPROCESS from the PID
    PEPROCESS pProcess = NULL;
    if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)pid, &pProcess))) {
        // Failed to get the process
        ExFreePool(memRange);
        return 0;
    }

    // Now, obtain the process name
    char* targetProcessName = PsGetProcessImageFileName((uintptr_t)pProcess);
    ObDereferenceObject(pProcess); // We no longer need this

    uintptr_t dirBase = 0;
    const uint64_t cr3PteBase = g_idx * 8 + g_PXE_BASE;

    // Scan through the physical memory ranges
    for (int i = 0; memRange[i].BaseAddress.QuadPart != 0 || memRange[i].NumberOfBytes.QuadPart != 0; ++i) {
        uint64_t startPfn = memRange[i].BaseAddress.QuadPart >> 12;
        uint64_t endPfn = startPfn + (memRange[i].NumberOfBytes.QuadPart >> 12);

        for (uint64_t pfn = startPfn; pfn < endPfn; ++pfn) {
            _MMPFN* currentMmpfn = (_MMPFN*)(g_MmPfnDatabase + 0x30 * pfn);

            if (currentMmpfn->flags && currentMmpfn->flags != 1 && currentMmpfn->pte_address == cr3PteBase) {
                uintptr_t decryptedEprocess = ((currentMmpfn->flags | 0xF000000000000000) >> 0xd) | 0xFFFF000000000000;

                if (MmIsAddressValid((void*)decryptedEprocess)) {
                    char* processName = PsGetProcessImageFileName((uintptr_t)decryptedEprocess);
                    if (_stricmp(processName, targetProcessName) == 0) {
                        dirBase = pfn << 12;
                        goto cleanup;
                    }
                }
            }
        }
    }

cleanup:
    ExFreePool(memRange);
    return dirBase;
}
```

`EAC-CR3-BYPASS (KM)/DirbaseBypass.h`:

```h
#pragma once

void initDefinesCR3();
uintptr_t GetDirBase(uint32_t pid);

```

`EAC-CR3-BYPASS (KM)/EAC-CR3-BYPASS.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34607.119
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EAC-CR3-BYPASS (KM)", "EAC-CR3-BYPASS.vcxproj", "{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EAC-CR3-BYPASS (UM)", "..\EAC-CR3-BYPASS (UM)\EAC-CR3-BYPASS (UM).vcxproj", "{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|ARM64.Build.0 = Debug|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x64.ActiveCfg = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x64.Build.0 = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x64.Deploy.0 = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x86.ActiveCfg = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x86.Build.0 = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x86.Deploy.0 = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|ARM64.ActiveCfg = Release|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|ARM64.Build.0 = Release|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|ARM64.Deploy.0 = Release|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x64.ActiveCfg = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x64.Build.0 = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x64.Deploy.0 = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x86.ActiveCfg = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x86.Build.0 = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x86.Deploy.0 = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|ARM64.ActiveCfg = Debug|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|ARM64.Build.0 = Debug|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|x64.ActiveCfg = Debug|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|x64.Build.0 = Debug|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|x86.ActiveCfg = Debug|Win32
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|x86.Build.0 = Debug|Win32
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|ARM64.ActiveCfg = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|ARM64.Build.0 = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|x64.ActiveCfg = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|x64.Build.0 = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|x86.ActiveCfg = Release|Win32
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0F5B35E4-923E-4E56-9950-2EE972930A92}
	EndGlobalSection
EndGlobal

```

`EAC-CR3-BYPASS (KM)/EAC-CR3-BYPASS.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>EAC_CR3_BYPASS</RootNamespace>
    <ProjectName>EAC-CR3-BYPASS (KM)</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="communication.h" />
    <ClInclude Include="defines.h" />
    <ClInclude Include="DirbaseBypass.h" />
    <ClInclude Include="driverEntry.h" />
    <ClInclude Include="ioctl.h" />
    <ClInclude Include="structure.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="communication.c" />
    <ClCompile Include="DirbaseBypass.c" />
    <ClCompile Include="driverEntry.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EAC-CR3-BYPASS (KM)/EAC-CR3-BYPASS.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="DirbaseBypass">
      <UniqueIdentifier>{4a528202-297f-4da5-bf02-bbd102cc58c5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Communication">
      <UniqueIdentifier>{73aa4e4b-c7bf-49ef-92c0-9fa5f197950a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Structure/Defines">
      <UniqueIdentifier>{c4034de1-2ba7-40aa-95b6-89792b407730}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DirbaseBypass.h">
      <Filter>DirbaseBypass</Filter>
    </ClInclude>
    <ClInclude Include="communication.h">
      <Filter>Communication</Filter>
    </ClInclude>
    <ClInclude Include="ioctl.h">
      <Filter>Communication</Filter>
    </ClInclude>
    <ClInclude Include="defines.h">
      <Filter>Structure/Defines</Filter>
    </ClInclude>
    <ClInclude Include="driverEntry.h" />
    <ClInclude Include="structure.h">
      <Filter>Structure/Defines</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DirbaseBypass.c">
      <Filter>DirbaseBypass</Filter>
    </ClCompile>
    <ClCompile Include="driverEntry.c" />
    <ClCompile Include="communication.c">
      <Filter>Communication</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`EAC-CR3-BYPASS (KM)/EAC-CR3-BYPASS.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`EAC-CR3-BYPASS (KM)/communication.c`:

```c
#include <ntifs.h>
#include <ntddk.h>
#include "defines.h"
#include "DirbaseBypass.h"
#include "structure.h"
#include "communication.h"

NTSTATUS IoctlDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp) 
{
    ///////////////////////////////
    UNREFERENCED_PARAMETER(DeviceObject);
    ///////////////////////////////

    ///////////////////////////////
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    
    PVOID ioBuffer = Irp->AssociatedIrp.SystemBuffer;
    
    ULONGLONG* ioInformation = &Irp->IoStatus.Information;

    NTSTATUS* IOStatus = &Irp->IoStatus.Status;
    ///////////////////////////////

    ///////////////////////////////
    NTSTATUS status = STATUS_SUCCESS;
    ///////////////////////////////

    ///////////////////////////////
    VERIFY_BUFFER(ioBuffer, STATUS_INVALID_PARAMETER);
    ///////////////////////////////

    if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
            ///////////////////////////////
            // findGuardedRegion
            case IOCTL_GET_PROCESS_CR3:
                ((PMEMORY_OPERATION_DATA)ioBuffer)->cr3 = GetDirBase(((PMEMORY_OPERATION_DATA)ioBuffer)->src_pid);
                *ioInformation = sizeof(MEMORY_OPERATION_DATA);
                break;
            ///////////////////////////////

            ///////////////////////////////
            // initDefinesCR3
            case IOCTL_INIT_DEFINES_CR3:
                initDefinesCR3();
                *ioInformation = 0;
                break;
            ///////////////////////////////
            
            ///////////////////////////////
            // default
            default:
                status = STATUS_INVALID_DEVICE_REQUEST;
                *ioInformation = 0;
                break;
            ///////////////////////////////
        }
    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    ///////////////////////////////
    *IOStatus = status;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    ///////////////////////////////

    return status;
}
```

`EAC-CR3-BYPASS (KM)/communication.h`:

```h
#pragma once
#include <ntifs.h>
#include "ioctl.h"
#include <stddef.h>

/* ################ */
/* FUNCTION HANDLER */
/* ################ */

NTSTATUS IoctlDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp);

/* ################## */
/* VERIFY NULL BUFFER */
/* ################## */

#define VERIFY_BUFFER(buf, failStatus) \
    if ((buf) == NULL) { \
        *IOStatus = (failStatus); \
        IoCompleteRequest(Irp, IO_NO_INCREMENT); \
        return (failStatus); \
    }
```

`EAC-CR3-BYPASS (KM)/defines.h`:

```h
#pragma once

/* ############## */
/* PRAGMA WARNING */
/* ############## */

#pragma warning(disable : 4996)

/* ################# */
/* TYPES DEFINITIONS */
/* ################# */

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef int					BOOL;
typedef unsigned int		DWORD;
typedef						ULONGLONG QWORD;
typedef unsigned char       BYTE;
typedef						ULONG KEPROCESSORINDEX;

/* ############## */
/* DIRBASE BYPASS */
/* ############## */

typedef struct _MMPFN {
	uintptr_t flags;
	uintptr_t pte_address;
	uintptr_t Unused_1;
	uintptr_t Unused_2;
	uintptr_t Unused_3;
	uintptr_t Unused_4;
} _MMPFN;

typedef struct _DBGKD_DEBUG_DATA_HEADER64 {
    LIST_ENTRY64 List;
    ULONG           OwnerTag;
    ULONG           Size;
} DBGKD_DEBUG_DATA_HEADER64, * PDBGKD_DEBUG_DATA_HEADER64;

typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled : 1;
    USHORT  KiBugCheckRecoveryActive : 1; // Windows 10 Manganese Addition
    USHORT  PagingLevels : 4;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;

    // NT 5.1 Addition

    ULONG64   NtBuildLab;
    ULONG64   KiNormalSystemCall;

    // NT 5.0 hotfix addition

    ULONG64   KiProcessorBlock;
    ULONG64   MmUnloadedDrivers;
    ULONG64   MmLastUnloadedDriver;
    ULONG64   MmTriageActionTaken;
    ULONG64   MmSpecialPoolTag;
    ULONG64   KernelVerifier;
    ULONG64   MmVerifierData;
    ULONG64   MmAllocatedNonPagedPool;
    ULONG64   MmPeakCommitment;
    ULONG64   MmTotalCommitLimitMaximum;
    ULONG64   CmNtCSDVersion;

    // NT 5.1 Addition

    ULONG64   MmPhysicalMemoryBlock;
    ULONG64   MmSessionBase;
    ULONG64   MmSessionSize;
    ULONG64   MmSystemParentTablePage;

    // Server 2003 addition

    ULONG64   MmVirtualTranslationBase;

    USHORT    OffsetKThreadNextProcessor;
    USHORT    OffsetKThreadTeb;
    USHORT    OffsetKThreadKernelStack;
    USHORT    OffsetKThreadInitialStack;

    USHORT    OffsetKThreadApcProcess;
    USHORT    OffsetKThreadState;
    USHORT    OffsetKThreadBStore;
    USHORT    OffsetKThreadBStoreLimit;

    USHORT    SizeEProcess;
    USHORT    OffsetEprocessPeb;
    USHORT    OffsetEprocessParentCID;
    USHORT    OffsetEprocessDirectoryTableBase;

    USHORT    SizePrcb;
    USHORT    OffsetPrcbDpcRoutine;
    USHORT    OffsetPrcbCurrentThread;
    USHORT    OffsetPrcbMhz;

    USHORT    OffsetPrcbCpuType;
    USHORT    OffsetPrcbVendorString;
    USHORT    OffsetPrcbProcStateContext;
    USHORT    OffsetPrcbNumber;

    USHORT    SizeEThread;

    UCHAR     L1tfHighPhysicalBitIndex;  // Windows 10 19H1 Addition
    UCHAR     L1tfSwizzleBitIndex;       // Windows 10 19H1 Addition

    ULONG     Padding0;

    ULONG64   KdPrintCircularBufferPtr;
    ULONG64   KdPrintBufferSize;

    ULONG64   KeLoaderBlock;

    USHORT    SizePcr;
    USHORT    OffsetPcrSelfPcr;
    USHORT    OffsetPcrCurrentPrcb;
    USHORT    OffsetPcrContainedPrcb;

    USHORT    OffsetPcrInitialBStore;
    USHORT    OffsetPcrBStoreLimit;
    USHORT    OffsetPcrInitialStack;
    USHORT    OffsetPcrStackLimit;

    USHORT    OffsetPrcbPcrPage;
    USHORT    OffsetPrcbProcStateSpecialReg;
    USHORT    GdtR0Code;
    USHORT    GdtR0Data;

    USHORT    GdtR0Pcr;
    USHORT    GdtR3Code;
    USHORT    GdtR3Data;
    USHORT    GdtR3Teb;

    USHORT    GdtLdt;
    USHORT    GdtTss;
    USHORT    Gdt64R3CmCode;
    USHORT    Gdt64R3CmTeb;

    ULONG64   IopNumTriageDumpDataBlocks;
    ULONG64   IopTriageDumpDataBlocks;

    // Longhorn addition

    ULONG64   VfCrashDataBlock;
    ULONG64   MmBadPagesDetected;
    ULONG64   MmZeroedPageSingleBitErrorsDetected;

    // Windows 7 addition

    ULONG64   EtwpDebuggerData;
    USHORT    OffsetPrcbContext;

    // Windows 8 addition

    USHORT    OffsetPrcbMaxBreakpoints;
    USHORT    OffsetPrcbMaxWatchpoints;

    ULONG     OffsetKThreadStackLimit;
    ULONG     OffsetKThreadStackBase;
    ULONG     OffsetKThreadQueueListEntry;
    ULONG     OffsetEThreadIrpList;

    USHORT    OffsetPrcbIdleThread;
    USHORT    OffsetPrcbNormalDpcState;
    USHORT    OffsetPrcbDpcStack;
    USHORT    OffsetPrcbIsrStack;

    USHORT    SizeKDPC_STACK_FRAME;

    // Windows 8.1 Addition

    USHORT    OffsetKPriQueueThreadListHead;
    USHORT    OffsetKThreadWaitReason;

    // Windows 10 RS1 Addition

    USHORT    Padding1;
    ULONG64   PteBase;

    // Windows 10 RS5 Addition

    ULONG64   RetpolineStubFunctionTable;
    ULONG     RetpolineStubFunctionTableSize;
    ULONG     RetpolineStubOffset;
    ULONG     RetpolineStubSize;

    // Windows 10 Iron Addition

    USHORT OffsetEProcessMmHotPatchContext;

    // Windows 11 Cobalt Addition

    ULONG   OffsetKThreadShadowStackLimit;
    ULONG   OffsetKThreadShadowStackBase;
    ULONG64 ShadowStackEnabled;

    // Windows 11 Nickel Addition

    ULONG64 PointerAuthMask;
    USHORT  OffsetPrcbExceptionStack;

} KDDEBUGGER_DATA64, * PKDDEBUGGER_DATA64;

typedef struct _DUMP_HEADER
{
    ULONG Signature;
    ULONG ValidDump;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG_PTR DirectoryTableBase;
    ULONG_PTR PfnDataBase;
    PLIST_ENTRY PsLoadedModuleList;
    PLIST_ENTRY PsActiveProcessHead;
    ULONG MachineImageType;
    ULONG NumberProcessors;
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParameter1;
    ULONG_PTR BugCheckParameter2;
    ULONG_PTR BugCheckParameter3;
    ULONG_PTR BugCheckParameter4;
    CHAR VersionUser[32];
    struct _KDDEBUGGER_DATA64* KdDebuggerDataBlock;
} DUMP_HEADER, * PDUMP_HEADER;

#ifndef _WIN64
#define KDDEBUGGER_DATA_OFFSET 0x1068
#else
#define KDDEBUGGER_DATA_OFFSET 0x2080
#endif

#ifndef _WIN64
#define DUMP_BLOCK_SIZE 0x20000
#else
#define DUMP_BLOCK_SIZE 0x40000
#endif


/* ########## */
/*  FUNCTION  */
/* ########## */

__declspec(dllimport) NTSTATUS ZwWaitForMultipleObjects(
	unsigned long Count,
	HANDLE Handles[],
	WAIT_TYPE WaitType,
	BOOLEAN Alertable,
	PLARGE_INTEGER Timeout
);

NTSYSAPI CHAR* PsGetProcessImageFileName(
	__in uintptr_t Process
);

ULONG NTAPI KeCapturePersistentThreadState(
	IN PCONTEXT Context,
	IN PKTHREAD Thread,
	IN ULONG BugCheckCode,
	IN ULONG BugCheckParameter1,
	IN ULONG BugCheckParameter2,
	IN ULONG BugCheckParameter3,
	IN ULONG BugCheckParameter4,
	OUT PVOID VirtualAddress
);
```

`EAC-CR3-BYPASS (KM)/driverEntry.c`:

```c
#include <ntifs.h>
#include "communication.h"
#include "driverEntry.h"

/* ############ */
/* DRIVER ENTRY */
/* ############ */

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    ///////////////////////////////
    UNREFERENCED_PARAMETER(RegistryPath);
    ///////////////////////////////    

    ///////////////////////////////
    NTSTATUS status;
    ///////////////////////////////

    ///////////////////////////////
    status = IoCreateDevice(&driverName, &ntName);
    // status = IoCreateDevice(DriverObject, 0, &ntName, FILE_DEVICE_UNKNOWN, 0, FALSE, &gDeviceObject);
    if (!NT_SUCCESS(status))
    {
        return status;
    }
    ///////////////////////////////

    ///////////////////////////////
    status = IoCreateSymbolicLink(&symbolicLinkName, &ntName);
    if (!NT_SUCCESS(status))
    {
        IoDeleteDevice(gDeviceObject);
        return status;
    }
    ///////////////////////////////

    ///////////////////////////////
    DriverObject->MajorFunction[IRP_MJ_CREATE] = DeviceCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = DeviceClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoctlDispatch;
    DriverObject->DriverUnload = DriverUnload;
    ///////////////////////////////

    return STATUS_SUCCESS;
}

/* ############# */
/* CREATE DEVICE */
/* ############# */

NTSTATUS DeviceCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    ///////////////////////////////
    UNREFERENCED_PARAMETER(DeviceObject);
    ///////////////////////////////

    ///////////////////////////////
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    ///////////////////////////////

    ///////////////////////////////
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    ///////////////////////////////

    return STATUS_SUCCESS;
}

/* ############# */
/* DRIVER UNLOAD */
/* ############# */

NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject)
{
    ///////////////////////////////
    UNREFERENCED_PARAMETER(DriverObject);
    ///////////////////////////////

    ///////////////////////////////
    IoDeleteSymbolicLink(&symbolicLinkName);
    IoDeleteDevice(DriverObject->DeviceObject);
    ///////////////////////////////

    return STATUS_SUCCESS;
}

/* ############ */
/* CLOSE DEVICE */
/* ############ */

NTSTATUS DeviceClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    ///////////////////////////////
    UNREFERENCED_PARAMETER(DeviceObject);
    ///////////////////////////////

    ///////////////////////////////
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    ///////////////////////////////

    ///////////////////////////////
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    ///////////////////////////////

    return STATUS_SUCCESS;
}

/* ############## */
/* UNSUPPORTED IO */
/* ############## */

NTSTATUS UnSupportedIO(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IofCompleteRequest(Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}
```

`EAC-CR3-BYPASS (KM)/driverEntry.h`:

```h
#pragma once

/* ############# */
/* IOCTL DEFINES */
/* ############# */

#define DEVICE_NAME L"cr3Bypass"

UNICODE_STRING driverName;
UNICODE_STRING ntName = RTL_CONSTANT_STRING(L"\\Device\\" DEVICE_NAME);
UNICODE_STRING symbolicLinkName = RTL_CONSTANT_STRING(L"\\DosDevices\\" DEVICE_NAME);
PDEVICE_OBJECT gDeviceObject = NULL;


/* ############ */
/* DRIVER ENTRY */
/* ############ */

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);

/* ############# */
/* CREATE DEVICE */
/* ############# */

NTSTATUS DeviceCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp);

/* ############# */
/* DRIVER UNLOAD */
/* ############# */

NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject);

/* ############ */
/* CLOSE DEVICE */
/* ############ */

NTSTATUS DeviceClose(PDEVICE_OBJECT DeviceObject, PIRP Irp);


/* ############## */
/* UNSUPPORTED IO */
/* ############## */

NTSTATUS UnSupportedIO(PDEVICE_OBJECT DeviceObject, PIRP Irp);

```

`EAC-CR3-BYPASS (KM)/ioctl.h`:

```h
#pragma once

/* ############### */
/* IOCTL FUNCTIONS */
/* ############### */

// Define IOCTL Macro/Shortcut
#define BASE_IOCTL_CODE(code) CTL_CODE(FILE_DEVICE_UNKNOWN, (code), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Define IOCTL commands
#define IOCTL_INIT_DEFINES_CR3 BASE_IOCTL_CODE(0x665fa1f0)
#define IOCTL_GET_PROCESS_CR3 BASE_IOCTL_CODE(0x3e2d6701)

```

`EAC-CR3-BYPASS (KM)/structure.h`:

```h
#pragma once

/* ################# */
/* MEMORY OPERATIONS */
/* ################# */

typedef struct _MEMORY_OPERATION_DATA {
    uint32_t        src_pid;
    uintptr_t       cr3;
} MEMORY_OPERATION_DATA, * PMEMORY_OPERATION_DATA;

```

`EAC-CR3-BYPASS (KM)/structure2.h`:

```h
#pragma once

/* ################# */
/* MEMORY OPERATIONS */
/* ################# */

typedef struct _MEMORY_OPERATION_DATA {
    uint32_t        src_pid;
    uintptr_t       cr3;
} MEMORY_OPERATION_DATA, * PMEMORY_OPERATION_DATA;

```

`EAC-CR3-BYPASS (UM)/EAC-CR3-BYPASS (UM).vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f7443cd5-b54f-4bfb-95b0-92102bf86d8a}</ProjectGuid>
    <RootNamespace>EACCR3BYPASSUM</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="ioctl.h" />
    <ClInclude Include="structure.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EAC-CR3-BYPASS (UM)/EAC-CR3-BYPASS (UM).vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ioctl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="structure.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EAC-CR3-BYPASS (UM)/EAC-CR3-BYPASS (UM).vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`EAC-CR3-BYPASS (UM)/driver.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <cstdint>
#include <string>

#include "ioctl.h"
#include "structure.h"

class _driver {
    HANDLE driverHandler = nullptr; // Handle to the driver.

public:
    uint32_t _processid = 0;

    // Default constructor.
    _driver() = default;

    // Constructor with process ID.
    explicit _driver(uint32_t processid) : _processid(processid) {
        initdriver(processid);
    }

    // Destructor to ensure proper resource release.
    ~_driver() {
        if (driverHandler != INVALID_HANDLE_VALUE) {
            CloseHandle(driverHandler);
        }
    }

    // Prevent copy construction and assignment.
    _driver(const _driver&) = delete;
    _driver& operator=(const _driver&) = delete;

    // Allow move semantics for efficient resource management.
    _driver(_driver&& other) noexcept : driverHandler(std::exchange(other.driverHandler, nullptr)) {}

    _driver& operator=(_driver&& other) noexcept {
        if (this != &other) {
            if (driverHandler != INVALID_HANDLE_VALUE) {
                CloseHandle(driverHandler);
            }
            driverHandler = std::exchange(other.driverHandler, nullptr);
        }
        return *this;
    }

    // Initialize the driver with a given process ID.
    void initdriver(int processid) {
        driverHandler = CreateFileA(
            "\\\\.\\cr3Bypass",
            GENERIC_READ | GENERIC_WRITE,
            0,
            nullptr,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            nullptr
        );

        _processid = processid;
    }

    auto initDefinesCR3() {

        MEMORY_OPERATION_DATA requestData = {};

        DeviceIoControl(
            driverHandler,                  // Device handle
            IOCTL_INIT_DEFINES_CR3,         // Control code
            &requestData,                   // Input buffer
            sizeof(requestData),            // Input buffer size
            &requestData,                   // Output buffer (reuse input buffer for output)
            sizeof(requestData),            // Output buffer size
            nullptr,                        // Bytes returned
            nullptr                         // Overlapped structure (not using overlapped I/O in this example)
        );

    }

    auto getCR3() -> uintptr_t
    {
        MEMORY_OPERATION_DATA requestData = { _processid };

        DeviceIoControl(
            driverHandler,                  // Device handle
            IOCTL_GET_PROCESS_CR3,          // Control code
            &requestData,                   // Input buffer
            sizeof(requestData),            // Input buffer size
            &requestData,                   // Output buffer (reuse input buffer for output)
            sizeof(requestData),            // Output buffer size
            nullptr,                        // Bytes returned
            nullptr                         // Overlapped structure (not using overlapped I/O in this example)
        );

        return requestData.cr3;
    }
};

_driver driver;

```

`EAC-CR3-BYPASS (UM)/imports.h`:

```h
#include <Windows.h>
#include <TlHelp32.h>
#include "driver.h"
```

`EAC-CR3-BYPASS (UM)/ioctl.h`:

```h
#pragma once

/* ############### */
/* IOCTL FUNCTIONS */
/* ############### */

// Define IOCTL Macro/Shortcut
#define BASE_IOCTL_CODE(code) CTL_CODE(FILE_DEVICE_UNKNOWN, (code), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Define IOCTL commands
#define IOCTL_INIT_DEFINES_CR3 BASE_IOCTL_CODE(0x665fa1f0)
#define IOCTL_GET_PROCESS_CR3 BASE_IOCTL_CODE(0x3e2d6701)

```

`EAC-CR3-BYPASS (UM)/main.cpp`:

```cpp
#include "imports.h"
#include <iostream>

auto getprocessid(std::wstring processname) -> uintptr_t
{
	auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32W entry;
	entry.dwSize = sizeof(entry);
	if (!Process32First(snapshot, &entry)) {
		return 0;
	}
	while (Process32Next(snapshot, &entry)) {
		if (std::wstring(entry.szExeFile) == processname) {
			return entry.th32ProcessID;
		}
	}
	return 0;
}

auto main() -> const NTSTATUS
{
	auto process = getprocessid(L"FortniteClient-Win64-Shipping.exe");
	printf("PID: %i \n", process);

	if (process != 0)
	{
		driver.initdriver(process);

		driver.initDefinesCR3();

		auto cr3 = driver.getCR3();
		printf("[+] CR3: 0x%p\n", cr3);

	}

	getchar();
	exit(0);
	return 0;
}

```

`EAC-CR3-BYPASS (UM)/structure.h`:

```h
#pragma once

/* ################# */
/* MEMORY OPERATIONS */
/* ################# */

typedef struct _MEMORY_OPERATION_DATA {
    uint32_t        src_pid;
    uintptr_t       cr3;
} MEMORY_OPERATION_DATA, * PMEMORY_OPERATION_DATA;

```

`EAC-CR3-BYPASS.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34607.119
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EAC-CR3-BYPASS (KM)", "EAC-CR3-BYPASS (KM)\EAC-CR3-BYPASS.vcxproj", "{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EAC-CR3-BYPASS (UM)", "EAC-CR3-BYPASS (UM)\EAC-CR3-BYPASS (UM).vcxproj", "{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|ARM64.Build.0 = Debug|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x64.ActiveCfg = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x64.Build.0 = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x64.Deploy.0 = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x86.ActiveCfg = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x86.Build.0 = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Debug|x86.Deploy.0 = Debug|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|ARM64.ActiveCfg = Release|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|ARM64.Build.0 = Release|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|ARM64.Deploy.0 = Release|ARM64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x64.ActiveCfg = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x64.Build.0 = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x64.Deploy.0 = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x86.ActiveCfg = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x86.Build.0 = Release|x64
		{1D2AEF3B-816E-413C-9C20-DE004EE7B6F9}.Release|x86.Deploy.0 = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|ARM64.ActiveCfg = Debug|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|ARM64.Build.0 = Debug|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|x64.ActiveCfg = Debug|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|x64.Build.0 = Debug|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|x86.ActiveCfg = Debug|Win32
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Debug|x86.Build.0 = Debug|Win32
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|ARM64.ActiveCfg = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|ARM64.Build.0 = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|x64.ActiveCfg = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|x64.Build.0 = Release|x64
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|x86.ActiveCfg = Release|Win32
		{F7443CD5-B54F-4BFB-95B0-92102BF86D8A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EA1F42C6-FC7E-4C1E-A2E9-E95C2FD36219}
	EndGlobalSection
EndGlobal

```