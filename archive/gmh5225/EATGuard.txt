Project Path: arc_gmh5225_EATGuard_ncc6atbo

Source Tree:

```txt
arc_gmh5225_EATGuard_ncc6atbo
├── EATGuard.sln
├── EATGuardApplication
│   ├── Defs.h
│   ├── EATGuardApplication.vcxproj
│   ├── EATGuardApplication.vcxproj.filters
│   └── Main.cpp
├── EATGuardDll
│   ├── Defs.h
│   ├── EATGuardDll.vcxproj
│   ├── EATGuardDll.vcxproj.filters
│   ├── EATGuardDll.vcxproj.user
│   ├── dllmain.cpp
│   ├── framework.h
│   ├── pch.cpp
│   └── pch.h
├── EATGuardDriver
│   ├── Defs.h
│   ├── EATGuardDriver.inf
│   ├── EATGuardDriver.vcxproj
│   ├── EATGuardDriver.vcxproj.filters
│   ├── EATGuardDriver.vcxproj.user
│   ├── EATGuardFuncs.cpp
│   ├── IrpHandlers.cpp
│   ├── Main.cpp
│   └── Shared.h
└── README.md

```

`EATGuard.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32328.378
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EATGuardApplication", "EATGuardApplication\EATGuardApplication.vcxproj", "{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EATGuardDriver", "EATGuardDriver\EATGuardDriver.vcxproj", "{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EATGuardDll", "EATGuardDll\EATGuardDll.vcxproj", "{304A7087-511A-4E00-8032-736D5BCDE8B1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Debug|ARM.ActiveCfg = Debug|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Debug|ARM.Build.0 = Debug|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Debug|ARM64.ActiveCfg = Debug|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Debug|ARM64.Build.0 = Debug|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Debug|x64.ActiveCfg = Debug|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Debug|x64.Build.0 = Debug|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Debug|x86.ActiveCfg = Debug|Win32
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Debug|x86.Build.0 = Debug|Win32
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Release|ARM.ActiveCfg = Release|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Release|ARM.Build.0 = Release|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Release|ARM64.ActiveCfg = Release|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Release|ARM64.Build.0 = Release|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Release|x64.ActiveCfg = Release|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Release|x64.Build.0 = Release|x64
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Release|x86.ActiveCfg = Release|Win32
		{AD5CC79C-9729-4F73-B07D-7FC1A7FB11ED}.Release|x86.Build.0 = Release|Win32
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|ARM.ActiveCfg = Debug|ARM
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|ARM.Build.0 = Debug|ARM
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|ARM.Deploy.0 = Debug|ARM
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|ARM64.Build.0 = Debug|ARM64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|x64.ActiveCfg = Debug|x64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|x64.Build.0 = Debug|x64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|x64.Deploy.0 = Debug|x64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|x86.ActiveCfg = Debug|Win32
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|x86.Build.0 = Debug|Win32
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Debug|x86.Deploy.0 = Debug|Win32
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|ARM.ActiveCfg = Release|ARM
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|ARM.Build.0 = Release|ARM
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|ARM.Deploy.0 = Release|ARM
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|ARM64.ActiveCfg = Release|ARM64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|ARM64.Build.0 = Release|ARM64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|ARM64.Deploy.0 = Release|ARM64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|x64.ActiveCfg = Release|x64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|x64.Build.0 = Release|x64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|x64.Deploy.0 = Release|x64
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|x86.ActiveCfg = Release|Win32
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|x86.Build.0 = Release|Win32
		{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}.Release|x86.Deploy.0 = Release|Win32
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Debug|ARM.ActiveCfg = Debug|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Debug|ARM.Build.0 = Debug|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Debug|ARM64.ActiveCfg = Debug|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Debug|ARM64.Build.0 = Debug|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Debug|x64.ActiveCfg = Debug|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Debug|x64.Build.0 = Debug|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Debug|x86.ActiveCfg = Debug|Win32
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Debug|x86.Build.0 = Debug|Win32
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Release|ARM.ActiveCfg = Release|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Release|ARM.Build.0 = Release|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Release|ARM64.ActiveCfg = Release|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Release|ARM64.Build.0 = Release|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Release|x64.ActiveCfg = Release|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Release|x64.Build.0 = Release|x64
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Release|x86.ActiveCfg = Release|Win32
		{304A7087-511A-4E00-8032-736D5BCDE8B1}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {105E332A-ABE0-4285-8A4A-6B23CD376D5C}
	EndGlobalSection
EndGlobal

```

`EATGuardApplication/Defs.h`:

```h
/*++
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuard/Defs.h
*
* @summary:   Various EATGuard "malicious application" definitions.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#pragma once
#include <Windows.h>
#include <stdio.h>
#include <assert.h>

//
// Macros.
//
#define ASSERT assert
```

`EATGuardApplication/EATGuardApplication.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ad5cc79c-9729-4f73-b07d-7fc1a7fb11ed}</ProjectGuid>
    <RootNamespace>EATGuard</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>EATGuardApplication</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\bin</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Defs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EATGuardApplication/EATGuardApplication.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EATGuardApplication/Main.cpp`:

```cpp
/*++
* 
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuard/Main.cpp
*
* @summary:   Entry point for the EATGuard "malicious" application.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#include "Defs.h"

/**
* 
* @brief        EATGuard entry point.
* @param[in]    argc - Number of arguments.
* @param[in]    argv - Array of arguments.
* @return       0 on success, otherwise 1.
* 
*/
INT
wmain (
    INT argc,
    WCHAR* argv[]
    )
{
    HMODULE eatGuardDllAddress;
    PVOID shellcodeAddress;

    unsigned char shellcode[] =
        "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
        "\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
        "\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
        "\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
        "\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
        "\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
        "\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
        "\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
        "\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
        "\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
        "\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
        "\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
        "\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
        "\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
        "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
        "\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff"
        "\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
        "\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x4e\x6f\x74"
        "\x65\x70\x61\x64\x2e\x65\x78\x65\x00";

    //
    // Load EATGuardDll.dll.
    //
    eatGuardDllAddress = LoadLibraryW(L"EATGuardDll.dll");

    //
    // Error handling.
    //
    if (eatGuardDllAddress == NULL)
    {
        //
        // Print update.
        //
        wprintf(L"[-] Error! Unable to load EATGuardDll.dll! Error: 0x%I32x\n", GetLastError());

        return 1;
    }

    //
    // Call VirtualAlloc.
    //
    shellcodeAddress = VirtualAlloc(NULL,
                                    sizeof(shellcode),
                                    MEM_COMMIT | MEM_RESERVE,
                                    PAGE_EXECUTE_READWRITE);

    //
    // Error handling.
    //
    if (shellcodeAddress == NULL)
    {
        //
        // Print update.
        //
        wprintf(L"[-] Error! Unable to allocate RWX for shellcode! Error: 0x%I32X\n", GetLastError());

        return 1;
    }

    //
    // Write the shellcode to the allocation.
    //
    RtlCopyMemory(shellcodeAddress, shellcode, sizeof(shellcode));

    //
    // Invoke the shellcode as if it were a function pointer.
    //
    ((VOID(*)())shellcodeAddress)();

    return 0;
}
```

`EATGuardDll/Defs.h`:

```h
/*++
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuardDll/Defs.h
*
* @summary:   Various EATGuardDll definitions.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#pragma once
#include <Windows.h>
#include <stdio.h>
#include <assert.h>
#include "..\EATGuardDriver\Shared.h"

//
// Constants from ntddk.h needed
// to generate the IOCTL via CTL_CODE.
//
#define FILE_DEVICE_UNKNOWN 0x00000022
#define METHOD_NEITHER 3
#define FILE_ANY_ACCESS 0

//
// Macros.
//
#define ASSERT assert

//
// From ntddk.h
// 
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// See: EATGuardDriver/Defs.h
// 
// IOCTL_VERIFY_EAT_ACCESS - Used to verify the address which caused the
//                           guard page violation.
#define IOCTL_VERIFY_EAT_ACCESS \
        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Structure defintions.
//
typedef struct _EAT_INFORMATION
{
    PVOID EatAddress;
    DWORD NumberOfFunctions;
} EAT_INFORMATION, * PEAT_INFORMATION;

//
// Function definitions.
//
BOOLEAN
LocateExportAddressTableKernel32 (
    _Out_ PEAT_INFORMATION EatAddress
    );

BOOLEAN
EnableEatGuardPage (
    _In_ PEAT_INFORMATION EatInformation,
    _Out_ DWORD OldProtect
    );

_Function_class_(PVECTORED_EXCEPTION_HANDLER)
LONG EatGuardVectoredExceptionHandler (
    _In_ _EXCEPTION_POINTERS* ExceptionInfo
    );

VOID
HandleGuardPageViolation (
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord
    );

VOID
CreateEatGuardDriverHandle ();

BOOLEAN
SendEatInformationToEatGuardDriver (
    _In_ PEAT_GUARD_INPUT_DATA InputData
    );
```

`EATGuardDll/EATGuardDll.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{304a7087-511a-4e00-8032-736d5bcde8b1}</ProjectGuid>
    <RootNamespace>EATGuardDll</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\bin</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;EATGUARDDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;EATGUARDDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;EATGUARDDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;EATGUARDDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Defs.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EATGuardDll/EATGuardDll.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`EATGuardDll/EATGuardDll.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`EATGuardDll/dllmain.cpp`:

```cpp
/*++
*
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuardDll/dllmain.cpp
*
* @summary:   Entry point for EATGuardDLL.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#include "pch.h"
#include "Defs.h"
#include <malloc.h>

//
// Global variable to maintain the EAT_INFORMATION
// strucutre for KERNEL32.dll.
//
EAT_INFORMATION g_kernel32EatInformation;

//
// Global variable holding 
// the handle to the EATGuardDriver.
// 
// From EATGuardDll/Defs.h
//
HANDLE g_EatGuardDriverHandle;

/**
*
* @brief         Open a handle to the EATGuardDriver.
* @return        VOID
*
*/
VOID
CreateEatGuardDriverHandle ()
{
    HANDLE driverHandle;

    //
    // Call CreateFileW to get a handle.
    //
    driverHandle = CreateFileW(L"\\\\.\\EATGuard",
                               GENERIC_READ | GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL);

    //
    // Error handling.
    //
    if (driverHandle == INVALID_HANDLE_VALUE)
    {
        wprintf(L"[-] Error! GLE: 0x%I32x\n", GetLastError());

        //
        // Set the global variable to NULL.
        //
        g_EatGuardDriverHandle = nullptr;
    }

    //
    // Set the global variable.
    //
    g_EatGuardDriverHandle = driverHandle;
}

/**
*
* @brief         Send the specified EAT information to the EATGuardDriver.
* @param[in]     InputData - A pointer to the corresponding PEAT_GUARD_INPUT_DATA
* @return        VOID
*
*/
BOOLEAN
SendEatInformationToEatGuardDriver (
    _In_ PEAT_GUARD_INPUT_DATA InputData
    )
{
    DWORD bytesReturned;
    EAT_GUARD_OUTPUT_DATA outputData;

    bytesReturned = 0;

    //
    // We need the handle.
    //
    ASSERT(g_EatGuardDriverHandle != nullptr);

    //
    // Call DeviceIoControl.
    //
    if (!DeviceIoControl(g_EatGuardDriverHandle,
                         IOCTL_VERIFY_EAT_ACCESS,
                         InputData,
                         sizeof(EAT_GUARD_INPUT_DATA),
                         &outputData,
                         sizeof(outputData),
                         &bytesReturned,
                         NULL))
    {
        //
        // Error handling.
        //
        wprintf(L"[-] Error! Unable to interact with the EATGuardDriver! Error: 0x%I32X\n", GetLastError());

        return FALSE;
    }

    //
    // Check if there was an error.
    //
    if (outputData.AnalysisResult == EatGuardMemoryAnalysisFailed)
    {
        //
        // Print update.
        //
        wprintf(L"[-] Error! EATGuard analysis failed!\n");

        return FALSE;
    }

    //
    // Print update based on analysis.
    //
    wprintf(L"[+] EATGuard analysis complete!\n");
    wprintf(L"    [+] Target address: 0x%I64X\n", InputData->ContextRecord->Rip);

    //
    // RWX memory.
    //
    if (outputData.IsRipRwxMemory == TRUE)
    {
        wprintf(L"        [>] IsRipRwxMemory: TRUE\n");
    }
    else
    {
        wprintf(L"        [>] IsRipRwxMemory: FALSE\n");
    }

    //
    // Mapped via section.
    //
    if (outputData.IsRipMappedSection == TRUE)
    {
        wprintf(L"        [>] IsRipMappedSection: TRUE\n");
    }
    else
    {
        wprintf(L"        [>] IsRipMappedSection: FALSE\n");
    }

    //
    // Memory backed by image.
    //
    if (outputData.IsRipBackedByImage == TRUE)
    {
        wprintf(L"        [>] IsRipBackedByImage: TRUE\n");
    }
    else
    {
        wprintf(L"        [>] IsRipBackedByImage: FALSE\n");
    }

    //
    // From the time of allocation to time of the check,
    // did the permissions change?
    //
    if (outputData.HasPageProtectionChanged == TRUE)
    {
        wprintf(L"        [>] HasPageProtectionChanged: TRUE\n");
    }
    else
    {
        wprintf(L"        [>] HasPageProtectionChanged: FALSE\n");
    }

    //
    // Print everything else.
    //
    wprintf(L"        [>] RegionBaseAddress: 0x%I64X\n", reinterpret_cast<ULONG64>(outputData.RegionBaseAddress));
    wprintf(L"        [>] MemoryRegionSize: 0x%I64X\n", outputData.MemoryRegionSize);
    wprintf(L"        [>] MemoryCommtSize: 0x%I64X\n", outputData.MemoryCommtSize);

    return TRUE;
}

/**
*
* @brief         Handle a guard page violation.
* @param[in]     ExceptionRecord - A pointer to the corresponding EXCEPTION_RECORD
* @param[in]     ContextRecord - The CONTEXT of the exception.
* @return        VOID
*
*/
VOID
HandleGuardPageViolation (
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord
    )
{
    PEAT_GUARD_INPUT_DATA inputData = nullptr;

    //
    // Ensure we have valid input.
    //
    if ((ExceptionRecord == nullptr) || (ContextRecord == nullptr))
    {
        return;
    }

    //
    // Allocate our buffer we are sending to the EATGuardDriver on the heap.
    //
    inputData = reinterpret_cast<PEAT_GUARD_INPUT_DATA>(malloc(sizeof(EAT_GUARD_INPUT_DATA)));

    if (inputData == nullptr)
    {
        //
        // If we can't allocate memory, there is nothing we can do anyways
        // since we will exhaust the stack.
        //
        return;
    }

    //
    // inputData is made up of two very large structures.
    // Using it as a stack variable and copying memory into it
    // mashes the stack.
    // Instead, allocate the records on the heap. We will free them
    // at the end of this function.
    //
    inputData->ContextRecord = reinterpret_cast<PCONTEXT>(malloc(sizeof(CONTEXT)));
    inputData->ExceptionRecord = reinterpret_cast<PEXCEPTION_RECORD>(malloc(sizeof(EXCEPTION_RECORD)));

    //
    // Error handling.
    //
    if ((inputData->ContextRecord == nullptr) || (inputData->ExceptionRecord == nullptr))
    {
        //
        // If we can't allocate memory, there is nothing we can do anyways
        // since we will exhaust the stack.
        //
        return;
    }

    //
    // Copy the information into the input buffer.
    //
    RtlCopyMemory(inputData->ExceptionRecord, ExceptionRecord, sizeof(EXCEPTION_RECORD));
    RtlCopyMemory(inputData->ContextRecord, ContextRecord, sizeof(CONTEXT));

    //
    // Send this information off to be validated by the EATGuardDriver.
    //
    if (!SendEatInformationToEatGuardDriver(inputData))
    {
        //
        // For now, do nothing since we want to continue execution through
        // the single-step exception.
        //
    }

    //
    // By calling SendEatInformationToEatGuard, we blowup
    // the stack and ExceptionRecord and ContextRecord are no
    // longer in-scope. Set their contents back to normal.
    //
    RtlCopyMemory(ExceptionRecord, inputData->ExceptionRecord, sizeof(EXCEPTION_RECORD));
    RtlCopyMemory(ContextRecord, inputData->ContextRecord, sizeof(CONTEXT));

    //
    // Cause a single-step exception to occur after we
    // are done handling this guard page violation so
    // we can re-enable the guard page on the EAT. We
    // use the single-step violation to cause an exception
    // we know will occur later and we handle it via VEH
    // and checking for the code.
    // 
    // This is done by setting the Trap Flag (bit 8).
    //
    ContextRecord->EFlags = ContextRecord->EFlags | 0x100;
}

/**
*
* @brief         VEH function to handle guard page and single-step violations.
* @param[in]     ExceptionInfo- A pointer to an EXCEPTION_POINTERS structure that receives the exception record.
* @return        EXCEPTION_CONTINUE_EXECUTION if this is our guard page violation,
*                otherwise EXCEPTION_CONTINUE_SEARCH.
*
*/
_Function_class_(PVECTORED_EXCEPTION_HANDLER)
LONG EatGuardVectoredExceptionHandler (
    _In_ _EXCEPTION_POINTERS* ExceptionInfo
    )
{
    DWORD oldProtect;

    oldProtect = 0;

    //
    // If this is a guard page violation, perform EATGuard checks.
    // If this is a single-step violation, re-enable the guard page
    // on the EAT.
    //
    if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_GUARD_PAGE_VIOLATION)
    {
        HandleGuardPageViolation(ExceptionInfo->ExceptionRecord, ExceptionInfo->ContextRecord);

        return EXCEPTION_CONTINUE_EXECUTION;
    }
    else if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)
    {
        EnableEatGuardPage(&g_kernel32EatInformation, oldProtect);

        return EXCEPTION_CONTINUE_EXECUTION;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

/**
*
* @brief         Place a guard page on the specified EAT address.
* @param[in]     EatInformation - A pointer to information about the specified EAT.
* @param[out]    OldProtect - The old memory permissions of the EAT.
* @return        TRUE on success, FALSE on failure.
*
*/
BOOLEAN
EnableEatGuardPage (
    _In_ PEAT_INFORMATION EatInformation,
    _Out_ DWORD OldProtect
    )
{
    DWORD size;
    DWORD oldProtect;

    //
    // If we have no address, we are toast anyways.
    //
    ASSERT(EatInformation->EatAddress != nullptr);

    //
    // Take the number of functions found in the EAT
    // and multiply that by the size of a DWORD. Every 
    // entry in the EAT is just 1 DWORD which is added
    // to the base address of the image the EAT is in.
    // This means every "entry" in the EAT takes up
    // 4 bytes (1 DWORD)
    //
    size = (EatInformation->NumberOfFunctions * sizeof(DWORD));

    //
    // Turn the EAT into a guard page.
    //
    if (!VirtualProtect(EatInformation->EatAddress,
                        size,
                        PAGE_READONLY | PAGE_GUARD,
                        &oldProtect))
    {
        return FALSE;
    }

    OldProtect = oldProtect;

    return TRUE;
}

/**
*
* @brief         Locate's the address of the export address table (EAT) for KERNEL32.dll.
* @param[out]    EatInformation - A pointer to receive information about the KERNEL32.dll EAT.
* @return        TRUE if successful, FALSE otherwise.
*
*/
BOOLEAN
LocateExportAddressTableKernel32 (
    _Out_ PEAT_INFORMATION EatInformation
    )
{
    PIMAGE_DOS_HEADER dosHeader;
    PIMAGE_NT_HEADERS ntHeaders;
    PIMAGE_EXPORT_DIRECTORY exportDirectory;
    ULONG_PTR baseAddress;

    baseAddress = reinterpret_cast<ULONG_PTR>(GetModuleHandleW(L"KERNEL32.dll"));

    //
    // Error handling.
    //
    if (baseAddress == NULL)
    {
        EatInformation->EatAddress = nullptr;
        EatInformation->NumberOfFunctions = 0;

        return FALSE;
    }

    //
    // This (obviously) is found at the very beginning
    // of the image. GetModuleHandleW returns the base
    // address of the current image (EATGuard.exe).
    dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(baseAddress);

    //
    // e_lfanew is the offset to the IMAGE_NT_HEADERS from the base
    // address of the IMAGE_DOS_HEADERS.
    //
    ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(baseAddress + dosHeader->e_lfanew);

    //
    // Determine if we actually found the NT headers.
    //
    if (ntHeaders->Signature != IMAGE_NT_SIGNATURE)
    {
        EatInformation->EatAddress = nullptr;
        EatInformation->NumberOfFunctions = 0;

        return FALSE;
    }

    //
    // DataDirectory contains an array of structures. Each structure
    // can be found at a different index into an array. The first index
    // into the array is the export directory. We use & to capture the address
    // of this array index, which is the actual address of the export
    // directory.
    // 
    // The VirtualAddress member of the PIMAGE_EXPORT_DIRECTORY structure
    // is an offset from the base of the image. Which is why we add it here.
    // 
    // Better research is to look at how shellcode resolves Windows APIs
    // (AddressOfFunctions or AddressOfNameOrdinals) versus how legitimate
    // GetProcAddress callers do this. Maybe can just guard one of these
    // instead of the entire EAT.
    //
    exportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(baseAddress + ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    //
    // From the export directory, retrieve the AddressOfFunctions
    // (which is the export address table).
    //
    EatInformation->EatAddress = reinterpret_cast<PVOID>(baseAddress + exportDirectory->AddressOfFunctions);

    //
    // From the export directory, retrieve the number of functions
    // in the EAT.
    //
    EatInformation->NumberOfFunctions = exportDirectory->NumberOfFunctions;

    //
    // Assign the EatInformation structure to the global
    // variable.
    //
    g_kernel32EatInformation.EatAddress = EatInformation->EatAddress;
    g_kernel32EatInformation.NumberOfFunctions = EatInformation->NumberOfFunctions;

    return TRUE;
}

/**
*
* @brief        EATGuardDll Entry point.
* @param[in]    hModule - A handle to the DLL module.
* @param[in]    ul_reason_for_call - The reason code that indicates why the DLL entry-point function is being called.
* @param[in]    lpReserved - Reserved.
* @return       TRUE if successful, FALSE otherwise.
*
*/
BOOL
APIENTRY
DllMain (
    HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
    )
{
    EAT_INFORMATION kernel32EatInformation;
    DWORD eatOldMemoryProtection;
    PVOID vehHandle;

    eatOldMemoryProtection = 0;

    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            //
            // First thing we need to do is get the EATGuardDriver handle.
            //
            CreateEatGuardDriverHandle();

            //
            // Register our exception handler to handle guard page
            // violations. The first parameter here, if non-zero,
            // means this is the first handler registered.
            //
            vehHandle = AddVectoredExceptionHandler(1, EatGuardVectoredExceptionHandler);

            //
            // Error handling.
            //
            if (vehHandle == nullptr)
            {
                //
                // Print update.
                //
                wprintf(L"[-] Error! Unable to register to exception handler! Error: 0xI%32x\n", GetLastError());

                break;
            }

            //
            // Find the EAT address for KERNEL32.dll.
            //
            if (!LocateExportAddressTableKernel32(&kernel32EatInformation))
            {

                //
                // Print update.
                //
                wprintf(L"[-] Error! Unable to resolve the EAT address for KERNEL32.dll!\n");

                break;
            }

            //
            // Print update.
            //
            wprintf(L"[+] KERNEL32.dll EAT: 0x%p\n", kernel32EatInformation.EatAddress);
            wprintf(L"[+] Number of functions in the KERNEL32.dll EAT: %d\n", kernel32EatInformation.NumberOfFunctions);

            //
            // Enable the guard page.
            //
            if (!EnableEatGuardPage(&kernel32EatInformation, eatOldMemoryProtection))
            {
                //
                // Print update.
                //
                wprintf(L"[-] Error! Unable to create the guard page! 0x%I32x\n", GetLastError());

                break;

            }

        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
        }

    return TRUE;
}
```

`EATGuardDll/framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>

```

`EATGuardDll/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`EATGuardDll/pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#include "framework.h"

#endif //PCH_H

```

`EATGuardDriver/Defs.h`:

```h
/*++
*
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuardDriver/Defs.h
*
* @summary:   Various definitions for the EATGuard driver.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include "Shared.h"

//
// PAGED_PASSIVE macro.
// See: https://github.com/winsiderss/systeminformer/blob/2afc1ecc36eb2c7d844ed83960efe30e2a6fbf72/KSystemInformer/include/kph.h#L32
#define PAGED_PASSIVE()\
        PAGED_CODE()\
        NT_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL)

//
// Device name.
//
#define EAT_GUARD_DEVICE_NAME L"\\Device\\EATGuard"

//
// DosDevices name.
//
#define EAT_GUARD_DOS_DEVICES_NAME L"\\DosDevices\\EATGuard"

//
// Pool tag.
//
#define EAT_GUARD_POOL_TAG 0x67746145

//
// Undocumented enum values for ZwQueryVirtualMemory.
// See: https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntmmapi.h#L83
//
#define MemoryBasicInformation 0x0
#define MemoryWorkingSetInformation 0x1
#define MemoryMappedFilenameInformation 0x2
#define MemoryRegionInformation 0x3
#define MemoryWorkingSetExInformation 0x4
#define MemorySharedCommitInformation 0x5
#define MemoryImageInformation 0x6
#define MemoryRegionInformationEx 0x7
#define MemoryPrivilegedBasicInformation 0x8
#define MemoryEnclaveImageInformation 0x9
#define MemoryBasicInformationCapped 0xA
#define MemoryPhysicalContiguityInformation 0xB
#define MemoryBadInformation 0xC
#define MemoryBadInformationAllProcesses 0xD

//
// Undocumented MEMORY_REGION_INFORMATION structure.
// See: https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntmmapi.h#L138
//
#pragma warning( push )
#pragma warning( disable : 4201 )
typedef struct _MEMORY_REGION_INFORMATION
{
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // REDSTONE3
            ULONG PageSize64K : 1;
            ULONG PlaceholderReservation : 1; // REDSTONE4
            ULONG MappedAwe : 1; // 21H1
            ULONG MappedWriteWatch : 1;
            ULONG PageSizeLarge : 1;
            ULONG PageSizeHuge : 1;
            ULONG Reserved : 19;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
    ULONG_PTR NodePreference; // 20H1
} MEMORY_REGION_INFORMATION, * PMEMORY_REGION_INFORMATION;
#pragma warning( pop )

//
// Define valid IOCTLs for this driver.
//

//
// IOCTL_VERIFY_EAT_ACCESS - Used to verify the address which caused the
//                           guard page violation.
#define IOCTL_VERIFY_EAT_ACCESS \
        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Function definitions.
//
_IRQL_requires_(PASSIVE_LEVEL)
_Function_class_(DRIVER_DISPATCH)
NTSTATUS
HandleMajorFunctionNotSupported (
    _Inout_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
    );

_IRQL_requires_(PASSIVE_LEVEL)
_Function_class_(DRIVER_DISPATCH)
NTSTATUS
HandleCreateMajorFunction (
    _Inout_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
    );

_IRQL_requires_(PASSIVE_LEVEL)
_Function_class_(DRIVER_DISPATCH)
NTSTATUS
HandleCloseMajorFunction (
    _Inout_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
    );

_IRQL_requires_(PASSIVE_LEVEL)
_Function_class_(DRIVER_DISPATCH)
NTSTATUS
HandleIoctlMajorFunciton (
    _Inout_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
    );

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
PerformEatGuardAnalysis (
    _In_ PEAT_GUARD_INPUT_DATA EatGuardInfo,
    _Out_ PEAT_GUARD_OUTPUT_DATA EatGuardOutput
    );
```

`EATGuardDriver/EATGuardDriver.inf`:

```inf
;
; EATGuardDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider="Connor McGarr"
DriverVer=
CatalogFile=EATGuardDriver.cat
PnpLockdown=1

;This template is supported for OS version 17763 (Windows 10 version 1809) and after.
;For Windows OS prior to Windows 10 1809 set DefaultDestDir = 12
[DestinationDirs]
DefaultDestDir = 13


[SourceDisksNames]
1 = %DiskName%,,,""

[Manufacturer]

[SourceDisksFiles]

[Strings]
DiskName="EATGuardDriver Source Disk"

```

`EATGuardDriver/EATGuardDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D9C1391B-9E18-4656-ABD3-44A277ACCF4D}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>EATGuardDriver</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <TargetName>$(TargetName.Replace(' ',''))</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <TargetName>$(TargetName.Replace(' ',''))</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="EATGuardDriver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Defs.h" />
    <ClInclude Include="Shared.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EATGuardFuncs.cpp" />
    <ClCompile Include="IrpHandlers.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EATGuardDriver/EATGuardDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="EATGuardDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Shared.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IrpHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EATGuardFuncs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`EATGuardDriver/EATGuardDriver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`EATGuardDriver/EATGuardFuncs.cpp`:

```cpp
/*++
*
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuardDriver/EATGuardFuncs.cpp
*
* @summary:   Functions that implement the actual functionality of the EATGuard driver.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#include "Defs.h"

/**
*
* @brief        Perform analysis on the target address.
* @param[in]    EatGuardInfo - Information about the EAT guard page violation.
* @param[in]	EatGuardOutput - Output to send to the EATGuardDll.
* @return       STATUS_SUCCESS on success, otherwise appropriate NTSTATUS code.
*
*/
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
PerformEatGuardAnalysis (
    _In_ PEAT_GUARD_INPUT_DATA EatGuardInfo,
    _Out_ PEAT_GUARD_OUTPUT_DATA EatGuardOutput
    )
{
    NTSTATUS status;
    MEMORY_BASIC_INFORMATION memoryBasicInfo;
    MEMORY_REGION_INFORMATION memoryRegionInfo;
    PVOID rip;

    PAGED_PASSIVE();

    status = STATUS_SUCCESS;

    //
    // Extract what RIP was pointing to at the time of the exception.
    //
    rip = reinterpret_cast<PVOID>(EatGuardInfo->ContextRecord->Rip);

    //
    // Determine if RIP is RWX.
    //
    status = ZwQueryVirtualMemory(ZwCurrentProcess(),
                                  rip,
                                  static_cast<MEMORY_INFORMATION_CLASS>(MemoryBasicInformation),
                                  &memoryBasicInfo,
                                  sizeof(memoryBasicInfo),
                                  NULL);

    //
    // Error handling.
    //
    if (!NT_SUCCESS(status))
    {
        EatGuardOutput->AnalysisResult = EatGuardMemoryAnalysisFailed;

        goto Exit;
    }

    //
    // Has the page protection changed since the allocation was made?
    //
    if (memoryBasicInfo.Protect != memoryBasicInfo.AllocationProtect)
    {
        EatGuardOutput->HasPageProtectionChanged = TRUE;
    }
    else
    {
        EatGuardOutput->HasPageProtectionChanged = FALSE;
    }

    //
    // Was RIP pointing to RWX memory?
    //
    if (memoryBasicInfo.Protect & PAGE_EXECUTE_READWRITE)
    {
        EatGuardOutput->IsRipRwxMemory = TRUE;
    }
    else
    {
        EatGuardOutput->IsRipRwxMemory = FALSE;
    }

    //
    // Grab the base of the allocation of this memory,
    // the region size, and the commit size.
    //
    EatGuardOutput->RegionBaseAddress = memoryBasicInfo.AllocationBase;
    EatGuardOutput->MemoryRegionSize = memoryBasicInfo.RegionSize;

    //
    // Make another ZwQueryVirtualMemory call to determine if
    // RIP is backed by an image or if it is a private allocation.
    //
    status = ZwQueryVirtualMemory(ZwCurrentProcess(),
                                  rip,
                                  static_cast<MEMORY_INFORMATION_CLASS>(MemoryRegionInformationEx),
                                  &memoryRegionInfo,
                                  sizeof(memoryRegionInfo),
                                  NULL);

    //
    // Error handling.
    //
    if (!NT_SUCCESS(status))
    {
        EatGuardOutput->AnalysisResult = EatGuardMemoryAnalysisPartialFail;

        goto Exit;
    }

    //
    // Determine the type of allocation.
    //
    if (memoryRegionInfo.MappedImage)
    {
        EatGuardOutput->IsRipBackedByImage = TRUE;
    }
    else if (memoryRegionInfo.MappedDataFile)
    {
        EatGuardOutput->IsRipBackedByImage = TRUE;
    }
    else if (memoryRegionInfo.Private)
    {
        EatGuardOutput->IsRipBackedByImage = FALSE;
    }

    if (memoryRegionInfo.DirectMapped)
    {
        EatGuardOutput->IsRipMappedSection = TRUE;
    }

    //
    // Grab the commit size.
    //
    EatGuardOutput->MemoryCommtSize = memoryRegionInfo.CommitSize;

    //
    // Let the EATGuardDll know we succeeded in our analysis.
    //
    EatGuardOutput->AnalysisResult = EatGuardMemoryAnalysisSucceeded;

Exit:
    return status;
}
```

`EATGuardDriver/IrpHandlers.cpp`:

```cpp
/*++
*
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuardDriver/IrpHandlers.cpp
*
* @summary:   IRP handlers for the EATGuard driver.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#include "Defs.h"

/**
*
* @brief        Handle non-supported major functions.
* @param[in]    DriverObject - EATGuardDriver DEVICE_OBJECT.
* @param[in]	Irp - Associated IRP.
* @return       STATUS_SUCCESS on success, otherwise appropriate NTSTATUS code.
*
*/
_IRQL_requires_(PASSIVE_LEVEL)
_Function_class_(DRIVER_DISPATCH)
NTSTATUS
HandleMajorFunctionNotSupported (
    _Inout_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
    )
{
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    PAGED_PASSIVE();

    UNREFERENCED_PARAMETER(DeviceObject);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_NOT_SUPPORTED;
}

/**
*
* @brief        Handle IRP_MJ_CREATE.
* @param[in]    DriverObject - EATGuardDriver DEVICE_OBJECT.
* @param[in]	Irp - Associated IRP.
* @return       STATUS_SUCCESS on success, otherwise appropriate NTSTATUS code.
*
*/
_IRQL_requires_(PASSIVE_LEVEL)
_Function_class_(DRIVER_DISPATCH)
NTSTATUS
HandleCreateMajorFunction (
    _Inout_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
    )
{
    PAGED_PASSIVE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    UNREFERENCED_PARAMETER(DeviceObject);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

/**
*
* @brief        Handle IRP_MJ_CLOSE.
* @param[in]    DriverObject - EATGuardDriver DEVICE_OBJECT.
* @param[in]	Irp - Associated IRP.
* @return       STATUS_SUCCESS on success, otherwise appropriate NTSTATUS code.
*
*/
_IRQL_requires_(PASSIVE_LEVEL)
_Function_class_(DRIVER_DISPATCH)
NTSTATUS
HandleCloseMajorFunction (
    _Inout_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
    )
{
    PAGED_PASSIVE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    UNREFERENCED_PARAMETER(DeviceObject);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

/**
*
* @brief        Handle IRP_MJ_DEVICE_CONTROL.
* @param[in]    DriverObject - EATGuardDriver DEVICE_OBJECT.
* @param[in]	Irp - Associated IRP.
* @return       STATUS_SUCCESS on success, otherwise appropriate NTSTATUS code.
*
*/
_IRQL_requires_(PASSIVE_LEVEL)
_Function_class_(DRIVER_DISPATCH)
NTSTATUS
HandleIoctlMajorFunciton (
    _Inout_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStackLocation;
    ULONG ioctlCode;
    PEAT_GUARD_INPUT_DATA inputBuffer;
    SIZE_T inputBufferLength;
    PEAT_GUARD_INPUT_DATA kernelEatGuardInputData;
    EAT_GUARD_OUTPUT_DATA kernelEatGuardOutputData;
    PEAT_GUARD_OUTPUT_DATA userSuppliedOutputBuffer;
    SIZE_T userSuppliedOutputBufferSize;

    PAGED_PASSIVE();

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Default to unsuccessful in case we have to bail.
    //
    status = STATUS_UNSUCCESSFUL;

    //
    // Allocate memory for the copy of the EAT_GUARD_INPUT_DATA.
    //
    kernelEatGuardInputData = (PEAT_GUARD_INPUT_DATA)ExAllocatePool2(POOL_FLAG_PAGED,
                                                                     sizeof(EAT_GUARD_INPUT_DATA),
                                                                     EAT_GUARD_POOL_TAG);

    //
    // Error handling.
    //
    if (kernelEatGuardInputData == NULL)
    {
        goto Exit;
    }

    //
    // IoGetCurrentIrpStackLocation doesn't return an
    // error code.
    //
    irpStackLocation = IoGetCurrentIrpStackLocation(Irp);

    //
    // Cast the buffer to our expected input.
    //
    inputBuffer = (PEAT_GUARD_INPUT_DATA)irpStackLocation->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // Get the input buffer size.
    //
    inputBufferLength = irpStackLocation->Parameters.DeviceIoControl.InputBufferLength;

    //
    // If the buffer isn't the size of our EAT_GUARD_INPUT_DATA
    // we know this isn't valid input and we can bail early.
    //
    if (inputBufferLength != sizeof(EAT_GUARD_INPUT_DATA))
    {
        goto Exit;
    }

    //
    // Get the IOCTL.
    //
    ioctlCode = irpStackLocation->Parameters.DeviceIoControl.IoControlCode;

    //
    // Get the output buffer supplied by the client.
    //
    userSuppliedOutputBuffer = reinterpret_cast<PEAT_GUARD_OUTPUT_DATA>(Irp->UserBuffer);

    //
    // Get the size of the output buffer specified by the client.
    //
    userSuppliedOutputBufferSize = irpStackLocation->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the IOCTL.
    //
    switch (ioctlCode)
    {
        case IOCTL_VERIFY_EAT_ACCESS:

            //
            // Ensure that the input buffer resides in user-mode.
            // We also need to verify that the underlying sub-structures
            // reside in user-mode.
            //
            __try
            {
                //
                // Verify the first "main" structure.
                //
                ProbeForRead(inputBuffer, inputBufferLength, sizeof(PVOID));

                //
                // Verify the exception records.
                //
                ProbeForRead(inputBuffer->ExceptionRecord, sizeof(EXCEPTION_RECORD), sizeof(PVOID));
                
                //
                // Verify more sub-structures.
                //
                ProbeForRead(inputBuffer->ExceptionRecord->ExceptionRecord, sizeof(EXCEPTION_RECORD), sizeof(PVOID));

                //
                // Verify the context record.
                //
                ProbeForRead(inputBuffer->ContextRecord, sizeof(CONTEXT), sizeof(PVOID));

                //
                // If we made it this far, go ahead and copy the memory to our kernel-mode copy.
                //
                RtlCopyMemory(kernelEatGuardInputData, inputBuffer, sizeof(EAT_GUARD_INPUT_DATA));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                goto Exit;
            }

            //
            // Perform the actual EATGuard analysis.
            //
            status = PerformEatGuardAnalysis(kernelEatGuardInputData, &kernelEatGuardOutputData);

            //
            // Ensure that these output buffer resides in user-mode.
            // We also need to verify that the underlying sub-structures
            // reside in user-mode.
            //
            __try
            {
                //
                // Probe the output buffer to ensure its in user mode.
                //
                ProbeForWrite(userSuppliedOutputBuffer, sizeof(EAT_GUARD_OUTPUT_DATA), sizeof(PVOID));

                //
                // Copy the output from PerformEatGuardAnalysis to the user-supplied output buffer.
                //
                RtlCopyMemory(userSuppliedOutputBuffer, &kernelEatGuardOutputData, sizeof(EAT_GUARD_OUTPUT_DATA));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                goto Exit;
            }

            break;

        default:
            break;
    }

Exit:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
```

`EATGuardDriver/Main.cpp`:

```cpp
/*++
*
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuardDriver/Main.cpp
*
* @summary:   Entry point for the EATGuard driver.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#include "Defs.h"

/**
*
* @brief        DriverUnload routine for driver unloads.
* @param[in]    DriverObject - EATGuardDriver DRIVER_OBJECT.
* @return       VOID
*
*/
_Function_class_(DRIVER_UNLOAD)
_IRQL_requires_(PASSIVE_LEVEL)
VOID
DriverUnload (
    _In_ PDRIVER_OBJECT DriverObject
    )
{
    UNICODE_STRING dosDevicesName;

    PAGED_PASSIVE();

    if (DriverObject->DeviceObject)
    {
        //
        // Create a copy of the DosDevices name
        // in order to delete the symbolic link.
        //
        RtlInitUnicodeString(&dosDevicesName, EAT_GUARD_DOS_DEVICES_NAME);

        //
        // Delete the symbolic link.
        //
        IoDeleteSymbolicLink(&dosDevicesName);

        //
        // Delete the device object.
        //
        IoDeleteDevice(DriverObject->DeviceObject);
    }
    else
    {
        return;
    }
}

/**
* 
* @brief        EATGuardDriver entry point.
* @param[in]    DriverObject - EATGuardDriver DRIVER_OBJECT.
* @param[in]	RegistryPath - Pointer to string with driver registry key.
* @return       STATUS_SUCCESS on success, otherwise appropriate NTSTATUS code.
* 
*/
_Function_class_(DRIVER_INITIALIZE)
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
DriverEntry (
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    UNICODE_STRING deviceName;
    UNICODE_STRING dosDevicesName;

    PAGED_PASSIVE();

    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // Set the driver unload routine.
    //
    DriverObject->DriverUnload = DriverUnload;

    //
    // Create the device name.
    //
    RtlInitUnicodeString(&deviceName, EAT_GUARD_DEVICE_NAME);

    //
    // Create the DosDevices name.
    //
    RtlInitUnicodeString(&dosDevicesName, EAT_GUARD_DOS_DEVICES_NAME);

    //
    // Create the device object.
    //
    status = IoCreateDevice(DriverObject,
                            0,
                            &deviceName,
                            FILE_DEVICE_UNKNOWN,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);

    //
    // Error handling.
    //
    if (!NT_SUCCESS(status))
    {
        goto Exit;
    }

    //
    // Create the symbolic link.
    //
    status = IoCreateSymbolicLink(&dosDevicesName, &deviceName);

    //
    // Error handling.
    //
    if (!NT_SUCCESS(status))
    {
        goto Exit;
    }

    //
    // Default all IRP handlers to HandleMajorFunctionNotSupported.
    //
    for (ULONG i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DriverObject->MajorFunction[i] = HandleMajorFunctionNotSupported;
    }

    //
    // Explicitly set the IRP_MJ_CREATE, IRP_MJ_CLOSE, and IRP_MJ_DEVICE_CONTROL
    // IRP handlers.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE] = HandleCreateMajorFunction;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = HandleCloseMajorFunction;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = HandleIoctlMajorFunciton;

    //
    // IRP_MJ_READ/IRP_MJ_WRITE will method neither.
    // Therefore, do _not_ set the DO_BUFFERED_IO or DO_DIRECT_IO
    // bits in DeviceObject->Flags.
    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    // See: https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_device_object#do_device_initializing
    //
    deviceObject->Flags &= DO_DEVICE_INITIALIZING;

    return status;

Exit:
    return status;
}
```

`EATGuardDriver/Shared.h`:

```h
/*++
*
* Copyright (c) Connor McGarr. All rights reserved.
*
* @file:      EATGuardDriver/Shared.h
*
* @summary:   Shared data between user-mode client and EATGuardDriver.
*
* @author:    Connor McGarr (@33y0re)
*
* @copyright  Use of this source code is governed by a MIT-style license that
*             can be found in the LICENSE file.
*
--*/
#pragma once

//
// Enum of possible analysis results.
//
typedef enum _EAT_GUARD_ANALYSIS_RESULTS
{
    EatGuardMemoryAnalysisSucceeded = 0,
    EatGuardMemoryAnalysisFailed,
    EatGuardMemoryAnalysisPartialFail
} EAT_GUARD_ANALYSIS_RESULTS;

//
// Input buffer sent by user-mode client.
// This already will be pointer-sized aligned
// because the first member is a pointer.
//
typedef struct _EAT_GUARD_INPUT_DATA
{
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EAT_GUARD_INPUT_DATA, *PEAT_GUARD_INPUT_DATA;

//
// Output buffer received by user-mode client.
//
__declspec(align(sizeof(PVOID)))
typedef struct _EAT_GUARD_OUTPUT_DATA
{
    EAT_GUARD_ANALYSIS_RESULTS AnalysisResult;  // Was the analysis successuful?
    BOOLEAN IsRipRwxMemory;                     // IS RIP RWX memory?
    BOOLEAN IsRipBackedByImage;                 // Is RIP backed by an image?
    BOOLEAN IsRipMappedSection;                 // Is RIP part of a mapped section?
    BOOLEAN HasPageProtectionChanged;           // Did the page protection get updated since allocation?
    PVOID RegionBaseAddress;                    // The actual base address of the page
    SIZE_T MemoryRegionSize;                    // The size of the region.
    SIZE_T MemoryCommtSize;                     // Size of the commit.
} EAT_GUARD_OUTPUT_DATA, *PEAT_GUARD_OUTPUT_DATA;
```

`README.md`:

```md
# EATGuard
Implementation of an export address table protection mitigation, like Export Address Filtering (EAF)

## How It Works
This project is composed of three binaries that, when compiled, can be found in `EATGuard\bin\`. They are:
1. `EATGuardApplication.exe` - "Malicious" application that loads `EATGuardDll.dll` into the process and then executes some executable code (shellcode) which executes `notepad.exe`.
2. `EATGuardDll.dll` - DLL that provides a "bridge" between user-mode and kernel-mode. This DLL registers a Vectored Exception Handler (VEH) which sends detections of access to the `kernel32.dll` Export Address Table (EAT) to the `EATGuardDriver.sys` driver. This DLL allocates a guard page on the `kernel32.dll` EAT which causes an exception when the EAT is accessed within the `EATGuardApplication.exe` process space. This routes execution to the registered VEH which processes these exceptions and is responsible for continuing execution after analysis is completed.
3. `EATGuardDriver.sys` - Kernel-mode device driver which verifies access to the `kernel32.dll` EAT. Currently, as a POC, it checks if the memory which accesses `kernel32.dll` is backed by disk.

## How To Use
Please note that `EATGuardApplication.exe` loads `EATGuardDll.dll` from the relative path of `EATGuardApplication.exe`. This means both the `.exe` and `.dll` need to be in the same directory when executing. Please note also _do not_ run this project on a machine that has kernel debugging enabled. This can cause issues, as the `EATGuardDll.dll` uses a single-step exception for continuation of execution. Here is an example usage of the project:

```
C:\Users\ANON\Desktop>sc create EATGUARD type= kernel binPath= C:\Users\ANON\Desktop\EATGuardDriver.sys
[SC] CreateService SUCCESS

C:\Users\ANON\Desktop>sc start EATGUARD

SERVICE_NAME: EATGUARD
        TYPE               : 1  KERNEL_DRIVER
        STATE              : 4  RUNNING
                                (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
        PID                : 0
        FLAGS              :

C:\Users\ANON\Desktop>EATGuardApplication.exe
[+] KERNEL32.dll EAT: 0x00007FFB1D83F898
[+] Number of functions in the KERNEL32.dll EAT: 1678
[+] EATGuard analysis complete!
    [+] Target address: 0x24AA138005C
        [>] IsRipRwxMemory: TRUE
        [>] IsRipMappedSection: FALSE
        [>] IsRipBackedByImage: FALSE
        [>] HasPageProtectionChanged: FALSE
        [>] RegionBaseAddress: 0x24AA1380000
        [>] MemoryRegionSize: 0x1000
        [>] MemoryCommtSize: 0x1000
[+] EATGuard analysis complete!
    [+] Target address: 0x24AA138005F
        [>] IsRipRwxMemory: TRUE
        [>] IsRipMappedSection: FALSE
        [>] IsRipBackedByImage: FALSE
        [>] HasPageProtectionChanged: FALSE
        [>] RegionBaseAddress: 0x24AA1380000
        [>] MemoryRegionSize: 0x1000
        [>] MemoryCommtSize: 0x1000
[+] EATGuard analysis complete!
    [+] Target address: 0x24AA138008F
        [>] IsRipRwxMemory: TRUE
        [>] IsRipMappedSection: FALSE
        [>] IsRipBackedByImage: FALSE
        [>] HasPageProtectionChanged: FALSE
        [>] RegionBaseAddress: 0x24AA1380000
        [>] MemoryRegionSize: 0x1000
        [>] MemoryCommtSize: 0x1000
[+] EATGuard analysis complete!
    [+] Target address: 0x24AA138009B
        [>] IsRipRwxMemory: TRUE
        [>] IsRipMappedSection: FALSE
        [>] IsRipBackedByImage: FALSE
        [>] HasPageProtectionChanged: FALSE
        [>] RegionBaseAddress: 0x24AA1380000
        [>] MemoryRegionSize: 0x1000
        [>] MemoryCommtSize: 0x1000
[+] EATGuard analysis complete!
    [+] Target address: 0x24AA13800A2
        [>] IsRipRwxMemory: TRUE
        [>] IsRipMappedSection: FALSE
        [>] IsRipBackedByImage: FALSE
        [>] HasPageProtectionChanged: FALSE
        [>] RegionBaseAddress: 0x24AA1380000
        [>] MemoryRegionSize: 0x1000
        [>] MemoryCommtSize: 0x1000

(...)TRUNCATED(...)
```

This project is a POC which mimics the functionality of [Export Address Filtering](https://windows-internals.com/an-exercise-in-dynamic-analysis/).
```