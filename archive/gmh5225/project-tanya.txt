Project Path: arc_gmh5225_project-tanya_np5fxwn6

Source Tree:

```txt
arc_gmh5225_project-tanya_np5fxwn6
├── README.md
├── service-build.sh
├── service-run.sh
└── src
    ├── Tanya
    │   ├── Logging
    │   │   ├── Logger.cs
    │   │   ├── LoggerProvider.cs
    │   │   └── LoggerWriter.cs
    │   ├── Program.cs
    │   ├── Startup.cs
    │   ├── Tanya.csproj
    │   └── appsettings.json
    ├── Tanya.Core
    │   ├── Access.cs
    │   ├── Extensions
    │   │   ├── ConfigurationExtensions.cs
    │   │   └── DriverExtensions.cs
    │   ├── Interfaces
    │   │   └── IType.cs
    │   ├── Limiter.cs
    │   ├── Looper.cs
    │   ├── Models
    │   │   └── Vector.cs
    │   ├── Reuse.cs
    │   ├── Tanya.Core.csproj
    │   └── Types
    │       ├── ByteType.cs
    │       ├── DoubleType.cs
    │       ├── SingleType.cs
    │       ├── StringType.cs
    │       ├── UInt16Type.cs
    │       ├── UInt32Type.cs
    │       ├── UInt64Type.cs
    │       └── VectorType.cs
    ├── Tanya.Driver
    │   ├── EmptyDriver.cs
    │   ├── Interfaces
    │   │   └── IDriver.cs
    │   └── Tanya.Driver.csproj
    ├── Tanya.Driver.Linux
    │   ├── Interop
    │   │   ├── Iovec.cs
    │   │   └── Libc.cs
    │   ├── Linux.cs
    │   ├── LinuxDriver.cs
    │   ├── Models
    │   │   ├── MapEntry.cs
    │   │   ├── MapEntryPermissions.cs
    │   │   └── ProcessEntry.cs
    │   ├── Tanya.Driver.Linux.csproj
    │   └── Utilities
    │       ├── MapEntryParser.cs
    │       └── ProcessEntryParser.cs
    ├── Tanya.Game.Apex
    │   ├── Bootstrap.cs
    │   ├── Config.cs
    │   ├── Models
    │   │   ├── Ini.cs
    │   │   ├── IniOffsets.cs
    │   │   └── IniOffsetsSerializer.cs
    │   ├── Runner.cs
    │   ├── Services
    │   │   ├── DataService.cs
    │   │   ├── LinuxService.cs
    │   │   └── WindowsService.cs
    │   └── Tanya.Game.Apex.csproj
    ├── Tanya.Game.Apex.Core
    │   ├── Constants.cs
    │   ├── Context.cs
    │   ├── Interfaces
    │   │   ├── IFeature.cs
    │   │   ├── IOffsets.cs
    │   │   └── IUpdatable.cs
    │   ├── Models
    │   │   ├── ButtonList.cs
    │   │   ├── Entity.cs
    │   │   ├── EntityList.cs
    │   │   ├── EntityListFilter.cs
    │   │   ├── LevelName.cs
    │   │   ├── LocalPlayer.cs
    │   │   ├── Npc.cs
    │   │   ├── NpcList.cs
    │   │   ├── Player.cs
    │   │   ├── PlayerList.cs
    │   │   ├── Signifier.cs
    │   │   └── SignifierList.cs
    │   ├── State.cs
    │   ├── Tanya.Game.Apex.Core.csproj
    │   └── Utilities
    │       └── LastVisibleTime.cs
    ├── Tanya.Game.Apex.Feature.Aim
    │   ├── Bootstrap.cs
    │   ├── Config.cs
    │   ├── Enums
    │   │   └── TargetType.cs
    │   ├── Extensions
    │   │   ├── ConfigExtensions.cs
    │   │   ├── StateExtensions.cs
    │   │   └── VectorExtensions.cs
    │   ├── Feature.cs
    │   ├── Interfaces
    │   │   └── ITarget.cs
    │   ├── Models
    │   │   ├── NpcTarget.cs
    │   │   └── PlayerTarget.cs
    │   ├── Tanya.Game.Apex.Feature.Aim.csproj
    │   └── Utilities
    │       ├── Deadzone.cs
    │       └── Normalize.cs
    ├── Tanya.Game.Apex.Feature.Sense
    │   ├── Bootstrap.cs
    │   ├── Config.cs
    │   ├── Feature.cs
    │   └── Tanya.Game.Apex.Feature.Sense.csproj
    ├── Tanya.sln
    └── Tanya.sln.DotSettings

```

`README.md`:

```md
# Tanya

"Victory. Such a tempting thing. Naturally, everyone wants to savor a taste." - Tanya von Degurechaff

# Installation

This guide is written for *Ubuntu*. For other Linux flavors, adapt commands where needed.

## (1) Allow Root Login

We'll ensure that the `root` user can login.

1. Configure your `root` user password:

```
sudo passwd
```

See [this page for more information](https://www.cyberciti.biz/faq/how-can-i-log-in-as-root/) on the root user.

## (2) Enable Process Isolation

We'll ensure that non-root users are unable to see the `project-tanya` service.

1. Switch to the `root` user:

```
su
```

2. Install dependencies:

```
apt install -y vim
```

3. Open `/etc/fstab` with *vim*:

```
vim /etc/fstab
```

4. Add the following line:

```
proc /proc proc defaults,nosuid,nodev,noexec,relatime,hidepid=2 0 0
```

5. Reboot your system:

```
reboot
```

6. Check that your non-root user cannot see root processes:

```
ps aux
```

See [this page for more information](https://www.kernel.org/doc/Documentation/filesystems/proc.txt) on process isolation.

## (3) Disable Process Tracing

We'll ensure that non-root users cannot use `ptrace` capabilities.

1. Switch to the `root` user:

```
su
```

2. Open `/etc/sysctl.d/10-ptrace.conf` with *vim*:

```
vim /etc/sysctl.d/10-ptrace.conf
```

3. Change the `kernel.yama.ptrace_scope` value to `2`:

```
kernel.yama.ptrace_scope = 2
```

4. Reboot your system:

```
reboot
```

5. Check that the `ptrace_scope` is set to `2`:

```
sysctl kernel.yama.ptrace_scope
```

See [this page for more information](https://www.kernel.org/doc/Documentation/security/Yama.txt) on process tracing.

## (4) Install .NET

We'll ensure that `project-tanya` can be compiled with *.NET*.

1. Switch to the `root` user:

```
su
```

2. Add the *Microsoft* package repositories:

* See https://docs.microsoft.com/en-us/dotnet/core/install/linux.
* Be sure to carefully follow instructions for your Linux flavor.

3. Install *.NET 6.0*:

```
apt update && apt install -y dotnet-sdk-6.0
```

## (5) Build Service

We'll build `project-tanya`, so we can register it as a service:

1. Switch to `root` user:

```
su
```

2. Open the `/root` directory: 

```
cd ~
```

3. Install dependencies:

```
apt install -y git
```

4. Clone this repository:

```
git clone https://github.com/XRadius/project-tanya
```

5. Open the `project-tanya` directory:

```
cd ~/project-tanya
```

6. Enable execution of the *build script*:

```
chmod +x service-build.sh
```

8. Run the *build script*:

```
./service-build.sh
```

## (6) Install Service

We'll install `project-tanya` as a service:

1. Open the `bin` directory:

```
cd ~/project-tanya/bin
```

2. Run the *installation script* and follow the instructions:

```
./service-install.sh
```

Once you've followed these instructions, `project-tanya` is ready for use!

```

`service-build.sh`:

```sh
#!/bin/bash
rm -rf "bin"

# ====================
# 
# ====================
dotnet publish "src/Tanya/Tanya.csproj" --no-self-contained --output "bin" --runtime linux-x64 \
  "-p:Configuration=Release" \
  "-p:DebugType=None" \
  "-p:GenerateRuntimeConfigurationFiles=true" \
  "-p:PublishSingleFile=true"

# ====================
# 
# ====================
cat > "bin/service-install.sh" << INSTALLER
#!/bin/bash
echo "================================================================================"
echo "This installation script will register a system service. When finished, the name"
echo "of this service is readable by any user. To make sure that it cannot be used for"
echo "detection purposes, you have to enter a random service name. Ensure that it does"
echo "not exist already, and only use characters in [0-9A-Z-]."
echo "================================================================================"
read -p "ServiceName: " serviceName

# ====================
# 
# ====================
rootPath=\$(realpath .)
execPath=\$(realpath "Tanya")
servPath="/etc/systemd/system/\${serviceName}.service"

# ====================
# 
# ====================
cat > \$servPath << EOF
[Unit]
Description=\${serviceName}

[Service]
Type=simple
WorkingDirectory=\${rootPath}
ExecStart=\${execPath}

[Install]
WantedBy=multi-user.target
EOF

# ====================
# 
# ====================
chmod 770 "\$servPath"

# ====================
# 
# ====================
systemctl daemon-reload
systemctl start \${serviceName}
systemctl enable \${serviceName}
INSTALLER

cat > "bin/service-uninstall.sh" << UNINSTALLER
#!/bin/bash
read -p "ServiceName: " serviceName

# ====================
#
# ====================
systemctl disable \${serviceName}
systemctl stop \${serviceName}

# ====================
#
# ====================
rm -rf "/etc/systemd/system/\${serviceName}.service"
UNINSTALLER

# ====================
#
# ====================
chmod +x "bin/service-install.sh"
chmod +x "bin/service-uninstall.sh"

```

`service-run.sh`:

```sh
#!/bin/bash
serviceName="project-tanya"

# ====================
# 
# ====================
dotnet publish "src/Tanya/Tanya.csproj" --output "bin" --runtime linux-x64 --self-contained \
  "-p:Configuration=Release" \
  "-p:DebugType=None" \
  "-p:GenerateRuntimeConfigurationFiles=true" \
  "-p:PublishSingleFile=true"

# ====================
# 
# ====================
if [ $serviceName != "Tanya" ]; then
  mv "bin/Tanya" "bin/${serviceName}"
fi

# ====================
# 
# ====================
"bin/${serviceName}"

```

`src/Tanya.Core/Access.cs`:

```cs
using Tanya.Core.Interfaces;
using Tanya.Driver.Interfaces;

namespace Tanya.Core
{
    public class Access<T>
    {
        private readonly ulong _address;
        private readonly IDriver _driver;
        private readonly Limiter? _limiter;
        private readonly IType<T> _type;
        private T? _value;

        #region Constructors

        public Access(IDriver driver, ulong address, IType<T> type)
        {
            _address = address;
            _driver = driver;
            _type = type;
        }

        public Access(IDriver driver, ulong address, IType<T> type, uint interval)
        {
            _address = address;
            _driver = driver;
            _limiter = new Limiter(interval);
            _type = type;
        }

        #endregion

        #region Methods

        public T Get()
        {
            return _value ?? throw new InvalidDataException();
        }

        public void Set(T value)
        {
            if (_value != null && _value.Equals(value)) return;
            var bufferSize = _type.Size();
            var buffer = Reuse.GetBuffer(bufferSize);
            _type.Set(buffer, value);
            _driver.Write(_address, buffer, bufferSize);
            _value = value;
        }

        public bool Update(DateTime frameTime)
        {
            if (_limiter != null && !_limiter.Update(frameTime)) return false;
            var bufferSize = _type.Size();
            var buffer = Reuse.GetBuffer(bufferSize);
            _driver.Read(_address, buffer, bufferSize);
            _value = _type.Get(buffer);
            return true;
        }

        #endregion
    }
}
```

`src/Tanya.Core/Extensions/ConfigurationExtensions.cs`:

```cs
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Configuration;

namespace Tanya.Core.Extensions
{
    public static class ConfigurationExtensions
    {
        #region Statics

        public static T GetProperty<T>(this IConfiguration config, [CallerMemberName] string? key = null)
        {
            return config.GetValue<T>(key);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Extensions/DriverExtensions.cs`:

```cs
using Tanya.Core.Interfaces;
using Tanya.Driver.Interfaces;

namespace Tanya.Core.Extensions
{
    public static class DriverExtensions
    {
        #region Statics

        public static Access<T> Access<T>(this IDriver driver, ulong address, IType<T> type)
        {
            return new Access<T>(driver, address, type);
        }

        public static Access<T> Access<T>(this IDriver driver, ulong address, IType<T> type, uint interval)
        {
            return new Access<T>(driver, address, type, interval);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Interfaces/IType.cs`:

```cs
namespace Tanya.Core.Interfaces
{
    public interface IType<T>
    {
        #region Methods

        T Get(byte[] buffer);

        void Set(byte[] buffer, T value);

        int Size();

        #endregion
    }
}
```

`src/Tanya.Core/Limiter.cs`:

```cs
namespace Tanya.Core
{
    public class Limiter
    {
        private readonly TimeSpan _interval;
        private DateTime _nextTime;

        #region Constructors

        public Limiter(uint interval)
        {
            _interval = TimeSpan.FromMilliseconds(interval);
        }

        #endregion

        #region Methods

        public bool Update(DateTime frameTime)
        {
            if (frameTime < _nextTime) return false;
            SetNextTime(frameTime);
            return true;
        }

        private void SetNextTime(DateTime frameTime)
        {
            if (_interval.Ticks == 0) return;
            var currentTicks = frameTime.Ticks;
            var intervalTicks = _interval.Ticks;
            _nextTime = new DateTime(currentTicks - currentTicks % intervalTicks + intervalTicks);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Looper.cs`:

```cs
namespace Tanya.Core
{
    public class Looper : EventWaitHandle
    {
        private readonly Timer _timer;

        #region Constructors

        private Looper() : base(false, EventResetMode.AutoReset)
        {
            _timer = new Timer(_ => Set());
        }

        public static Looper Create(TimeSpan interval)
        {
            var looper = new Looper();
            looper.SetInterval(interval);
            return looper;
        }

        #endregion

        #region Methods

        private void SetInterval(TimeSpan duration)
        {
            _timer.Change(0, (int)duration.TotalMilliseconds);
        }

        #endregion

        #region Overrides of WaitHandle

        protected override void Dispose(bool explicitDisposing)
        {
            if (explicitDisposing)
            {
                _timer.Dispose();
            }

            base.Dispose(explicitDisposing);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Models/Vector.cs`:

```cs
using System.Text.Json.Serialization;

namespace Tanya.Core.Models
{
    public record Vector
    {
        public static Vector Origin = new(0, 0, 0);

        #region Constructors

        public Vector(float x, float y, float z)
        {
            X = x;
            Y = y;
            Z = z;
        }

        #endregion

        #region Methods

        public float Distance(Vector otherVector)
        {
            var x = X - otherVector.X;
            var y = Y - otherVector.Y;
            return MathF.Sqrt(x * x + y * y);
        }

        #endregion

        #region Properties

        [JsonPropertyName("x")]
        public float X { get; }

        [JsonPropertyName("y")]
        public float Y { get; }

        [JsonPropertyName("z")]
        public float Z { get; }

        #endregion

        #region Statics

        public static Vector operator +(Vector a, Vector b)
        {
            var x = a.X + b.X;
            var y = a.Y + b.Y;
            var z = a.Z + b.Z;
            return new Vector(x, y, z);
        }

        public static Vector operator +(Vector a, float b)
        {
            var x = a.X + b;
            var y = a.Y + b;
            var z = a.Z + b;
            return new Vector(x, y, z);
        }

        public static Vector operator /(Vector a, Vector b)
        {
            var x = a.X / b.X;
            var y = a.Y / b.Y;
            var z = a.Z / b.Z;
            return new Vector(x, y, z);
        }

        public static Vector operator /(Vector a, float b)
        {
            var x = a.X / b;
            var y = a.Y / b;
            var z = a.Z / b;
            return new Vector(x, y, z);
        }

        public static Vector operator *(Vector a, Vector b)
        {
            var x = a.X * b.X;
            var y = a.Y * b.Y;
            var z = a.Z * b.Z;
            return new Vector(x, y, z);
        }

        public static Vector operator *(Vector a, float b)
        {
            var x = a.X * b;
            var y = a.Y * b;
            var z = a.Z * b;
            return new Vector(x, y, z);
        }

        public static Vector operator -(Vector a, Vector b)
        {
            var x = a.X - b.X;
            var y = a.Y - b.Y;
            var z = a.Z - b.Z;
            return new Vector(x, y, z);
        }

        public static Vector operator -(Vector a, float b)
        {
            var x = a.X - b;
            var y = a.Y - b;
            var z = a.Z - b;
            return new Vector(x, y, z);
        }

        #endregion

        #region Overrides of object

        public override string ToString()
        {
            return $"({X:F},{Y:F},{Z:F})";
        }

        #endregion
    }
}
```

`src/Tanya.Core/Reuse.cs`:

```cs
namespace Tanya.Core
{
    public static class Reuse
    {
        private static byte[] _buffer;
        private static int _bufferSize;

        #region Constructors

        static Reuse()
        {
            _bufferSize = 1024;
            _buffer = new byte[_bufferSize];
        }

        #endregion

        #region Statics

        public static byte[] GetBuffer(int count)
        {
            if (_bufferSize >= count) return _buffer;
            _bufferSize = count;
            _buffer = new byte[_bufferSize];
            return _buffer;
        }

        #endregion
    }
}
```

`src/Tanya.Core/Tanya.Core.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="6.0.1" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Tanya.Driver\Tanya.Driver.csproj" />
  </ItemGroup>
</Project>
```

`src/Tanya.Core/Types/ByteType.cs`:

```cs
using Tanya.Core.Interfaces;

namespace Tanya.Core.Types
{
    public class ByteType : IType<byte>
    {
        public static readonly ByteType Instance = new();

        #region Constructors

        private ByteType()
        {
        }

        #endregion

        #region Implementation of IType<byte>

        public byte Get(byte[] buffer)
        {
            return buffer[0];
        }

        public void Set(byte[] buffer, byte value)
        {
            buffer[0] = value;
        }

        public int Size()
        {
            return sizeof(byte);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Types/DoubleType.cs`:

```cs
using System.Runtime.CompilerServices;
using Tanya.Core.Interfaces;

namespace Tanya.Core.Types
{
    public class DoubleType : IType<double>
    {
        public static readonly DoubleType Instance = new();

        #region Constructors

        private DoubleType()
        {
        }

        #endregion

        #region Implementation of IType<double>

        public double Get(byte[] buffer)
        {
            return Unsafe.ReadUnaligned<double>(ref buffer[0]);
        }

        public void Set(byte[] buffer, double value)
        {
            Unsafe.As<byte, double>(ref buffer[0]) = value;
        }

        public int Size()
        {
            return sizeof(double);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Types/SingleType.cs`:

```cs
using System.Runtime.CompilerServices;
using Tanya.Core.Interfaces;

namespace Tanya.Core.Types
{
    public class SingleType : IType<float>
    {
        public static readonly SingleType Instance = new();

        #region Constructors

        private SingleType()
        {
        }

        #endregion

        #region Implementation of IType<float>

        public float Get(byte[] buffer)
        {
            return Unsafe.ReadUnaligned<float>(ref buffer[0]);
        }

        public void Set(byte[] buffer, float value)
        {
            Unsafe.As<byte, float>(ref buffer[0]) = value;
        }

        public int Size()
        {
            return sizeof(float);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Types/StringType.cs`:

```cs
using System.Text;
using Tanya.Core.Interfaces;

namespace Tanya.Core.Types
{
    public class StringType : IType<string>
    {
        private readonly int _count;
        private readonly Encoding _encoding;

        #region Constructors

        public StringType(int count, Encoding encoding)
        {
            _count = count;
            _encoding = encoding;
        }

        #endregion

        #region Implementation of IType<string>

        public string Get(byte[] buffer)
        {
            var value = _encoding.GetString(buffer, 0, _count);
            var terminator = value.IndexOf('\0');
            return terminator != -1 ? value[..terminator] : value;
        }

        public void Set(byte[] buffer, string value)
        {
            var count = _encoding.GetBytes(value, buffer);
            for (var i = _count - 1; i >= count; i--) buffer[i] = 0;
        }

        public int Size()
        {
            return _count;
        }

        #endregion
    }
}
```

`src/Tanya.Core/Types/UInt16Type.cs`:

```cs
using System.Runtime.CompilerServices;
using Tanya.Core.Interfaces;

namespace Tanya.Core.Types
{
    public class UInt16Type : IType<ushort>
    {
        public static readonly UInt16Type Instance = new();

        #region Constructors

        private UInt16Type()
        {
        }

        #endregion

        #region Implementation of IType<ushort>

        public ushort Get(byte[] buffer)
        {
            return Unsafe.ReadUnaligned<ushort>(ref buffer[0]);
        }

        public void Set(byte[] buffer, ushort value)
        {
            Unsafe.As<byte, ushort>(ref buffer[0]) = value;
        }

        public int Size()
        {
            return sizeof(ushort);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Types/UInt32Type.cs`:

```cs
using System.Runtime.CompilerServices;
using Tanya.Core.Interfaces;

namespace Tanya.Core.Types
{
    public class UInt32Type : IType<uint>
    {
        public static readonly UInt32Type Instance = new();

        #region Constructors

        private UInt32Type()
        {
        }

        #endregion

        #region Implementation of IType<uint>

        public uint Get(byte[] buffer)
        {
            return Unsafe.ReadUnaligned<uint>(ref buffer[0]);
        }

        public void Set(byte[] buffer, uint value)
        {
            Unsafe.As<byte, uint>(ref buffer[0]) = value;
        }

        public int Size()
        {
            return sizeof(uint);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Types/UInt64Type.cs`:

```cs
using System.Runtime.CompilerServices;
using Tanya.Core.Interfaces;

namespace Tanya.Core.Types
{
    public class UInt64Type : IType<ulong>
    {
        public static readonly UInt64Type Instance = new();

        #region Constructors

        private UInt64Type()
        {
        }

        #endregion

        #region Implementation of IType<ulong>

        public ulong Get(byte[] buffer)
        {
            return Unsafe.ReadUnaligned<ulong>(ref buffer[0]);
        }

        public void Set(byte[] buffer, ulong value)
        {
            Unsafe.As<byte, ulong>(ref buffer[0]) = value;
        }

        public int Size()
        {
            return sizeof(ulong);
        }

        #endregion
    }
}
```

`src/Tanya.Core/Types/VectorType.cs`:

```cs
using System.Runtime.CompilerServices;
using Tanya.Core.Interfaces;
using Tanya.Core.Models;

namespace Tanya.Core.Types
{
    public class VectorType : IType<Vector>
    {
        public static readonly VectorType Instance = new();

        #region Constructors

        private VectorType()
        {
        }

        #endregion

        #region Implementation of IType<Vector>

        public Vector Get(byte[] buffer)
        {
            var x = Unsafe.ReadUnaligned<float>(ref buffer[0]);
            var y = Unsafe.ReadUnaligned<float>(ref buffer[4]);
            var z = Unsafe.ReadUnaligned<float>(ref buffer[8]);
            return new Vector(x, y, z);
        }

        public void Set(byte[] buffer, Vector value)
        {
            Unsafe.As<byte, float>(ref buffer[0]) = value.X;
            Unsafe.As<byte, float>(ref buffer[4]) = value.Y;
            Unsafe.As<byte, float>(ref buffer[8]) = value.Z;
        }

        public int Size()
        {
            return sizeof(float) * 3;
        }

        #endregion
    }
}
```

`src/Tanya.Driver.Linux/Interop/Iovec.cs`:

```cs
using System.Runtime.InteropServices;

namespace Tanya.Driver.Linux.Interop
{
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct Iovec
    {
        public void* iov_base;
        public int iov_len;
    }
}
```

`src/Tanya.Driver.Linux/Interop/Libc.cs`:

```cs
using System.Runtime.InteropServices;

namespace Tanya.Driver.Linux.Interop
{
    public static class Libc
    {
        #region Statics

        [DllImport("libc")]
        public static extern unsafe int process_vm_readv(int pid,
            Iovec* localIov, ulong liovcnt,
            Iovec* remoteIov, ulong riovcnt,
            ulong flags);

        [DllImport("libc")]
        public static extern unsafe int process_vm_writev(int pid,
            Iovec* localIov, ulong liovcnt,
            Iovec* remoteIov, ulong riovcnt,
            ulong flags);

        #endregion
    }
}
```

`src/Tanya.Driver.Linux/Linux.cs`:

```cs
using Tanya.Driver.Linux.Models;
using Tanya.Driver.Linux.Utilities;

namespace Tanya.Driver.Linux
{
    public class Linux
    {
        #region Methods

        public async IAsyncEnumerable<MapEntry> MapsAsync(int pid)
        {
            var value = await SafeReadTextAsync($"/proc/{pid}/maps")
                .ContinueWith(x => x.Result.Split(Environment.NewLine))
                .ConfigureAwait(false);
            foreach (var entry in value)
            {
                var map = MapEntryParser.Parse(entry);
                if (map == null) continue;
                yield return map;
            }
        }

        public async IAsyncEnumerable<ProcessEntry> ProcessesAsync()
        {
            foreach (var path in SafeEnumerateDirectories("/proc"))
            {
                if (int.TryParse(Path.GetFileName(path), out var pid))
                {
                    var process = ProcessEntryParser.Parse(await SafeReadTextAsync($"/proc/{pid}/cmdline").ConfigureAwait(false), pid);
                    if (process == null) continue;
                    yield return process;
                }
            }
        }

        #endregion

        #region Statics

        private static IEnumerable<string> SafeEnumerateDirectories(string path)
        {
            try
            {
                return Directory.EnumerateDirectories(path);
            }
            catch (Exception)
            {
                return Enumerable.Empty<string>();
            }
        }

        private static async Task<string> SafeReadTextAsync(string path)
        {
            try
            {
                return await File.ReadAllTextAsync(path).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return string.Empty;
            }
        }

        #endregion
    }
}
```

`src/Tanya.Driver.Linux/LinuxDriver.cs`:

```cs
using Tanya.Driver.Interfaces;
using Tanya.Driver.Linux.Interop;

namespace Tanya.Driver.Linux
{
    public class LinuxDriver : IDriver
    {
        private readonly int _pid;

        #region Constructors

        public LinuxDriver(int pid)
        {
            _pid = pid;
        }

        #endregion

        #region Implementation of IDriver

        public unsafe bool Read(ulong address, byte[] buffer, int count)
        {
            fixed (void* pointer = buffer)
            {
                var localIo = new Iovec { iov_base = pointer, iov_len = count };
                var remoteIo = new Iovec { iov_base = (void*)address, iov_len = count };
                return Libc.process_vm_readv(_pid, &localIo, 1, &remoteIo, 1, 0) == count;
            }
        }

        public unsafe bool Write(ulong address, byte[] buffer, int count)
        {
            fixed (void* pointer = buffer)
            {
                var localIo = new Iovec { iov_base = pointer, iov_len = count };
                var remoteIo = new Iovec { iov_base = (void*)address, iov_len = count };
                return Libc.process_vm_writev(_pid, &localIo, 1, &remoteIo, 1, 0) == count;
            }
        }

        #endregion
    }
}
```

`src/Tanya.Driver.Linux/Models/MapEntry.cs`:

```cs
using System.Text.Json.Serialization;

namespace Tanya.Driver.Linux.Models
{
    public class MapEntry
    {
        #region Constructors

        public MapEntry(ushort devMajor, ushort devMinor, ulong end, ulong inode, ulong offset, string pathname, MapEntryPermissions perms, ulong start)
        {
            DevMajor = devMajor;
            DevMinor = devMinor;
            End = end;
            Inode = inode;
            Offset = offset;
            Pathname = pathname;
            Perms = perms;
            Start = start;
        }

        #endregion

        #region Properties

        [JsonPropertyName("devMajor")]
        public ushort DevMajor { get; }

        [JsonPropertyName("devMinor")]
        public ushort DevMinor { get; }

        [JsonPropertyName("end")]
        public ulong End { get; }

        [JsonPropertyName("inode")]
        public ulong Inode { get; }

        [JsonPropertyName("offset")]
        public ulong Offset { get; }

        [JsonPropertyName("pathname")]
        public string Pathname { get; }

        [JsonPropertyName("perms")]
        public MapEntryPermissions Perms { get; }

        [JsonPropertyName("start")]
        public ulong Start { get; }

        #endregion
    }
}
```

`src/Tanya.Driver.Linux/Models/MapEntryPermissions.cs`:

```cs
namespace Tanya.Driver.Linux.Models
{
    [Flags]
    public enum MapEntryPermissions
    {
        None,
        Read,
        Write,
        Execute,
        Shared
    }
}
```

`src/Tanya.Driver.Linux/Models/ProcessEntry.cs`:

```cs
using System.Text.Json.Serialization;

namespace Tanya.Driver.Linux.Models
{
    public class ProcessEntry
    {
        #region Constructors

        public ProcessEntry(IEnumerable<string> args, string command, int pid)
        {
            Args = args;
            Command = command;
            Pid = pid;
        }

        #endregion

        #region Properties

        [JsonPropertyName("args")]
        public IEnumerable<string> Args { get; }

        [JsonPropertyName("command")]
        public string Command { get; }

        [JsonPropertyName("pid")]
        public int Pid { get; }

        #endregion
    }
}
```

`src/Tanya.Driver.Linux/Tanya.Driver.Linux.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\Tanya.Driver\Tanya.Driver.csproj" />
  </ItemGroup>
</Project>
```

`src/Tanya.Driver.Linux/Utilities/MapEntryParser.cs`:

```cs
using System.Globalization;
using System.Text.RegularExpressions;
using Tanya.Driver.Linux.Models;

namespace Tanya.Driver.Linux.Utilities
{
    public static class MapEntryParser
    {
        private static readonly Regex Me = new(
            @"^([0-9A-F]+)-([0-9A-F]+)\s+(r|-)(w|-)(x|-)(p|s)\s+([0-9A-F]+)\s+([0-9A-F]+):([0-9A-F]+)\s+([0-9]+)\s+(.*)$",
            RegexOptions.IgnoreCase);

        #region Statics

        public static MapEntry? Parse(string value)
        {
            var match = Me.Match(value);
            if (match.Success) return Map(match);
            return null;
        }

        private static MapEntry Map(Match match)
        {
            var start = ulong.Parse(match.Groups[1].Value, NumberStyles.HexNumber);
            var end = ulong.Parse(match.Groups[2].Value, NumberStyles.HexNumber);
            var perms = Permissions(match);
            var offset = ulong.Parse(match.Groups[7].Value, NumberStyles.HexNumber);
            var devMajor = ushort.Parse(match.Groups[8].Value, NumberStyles.HexNumber);
            var devMinor = ushort.Parse(match.Groups[9].Value, NumberStyles.HexNumber);
            var inode = ulong.Parse(match.Groups[10].Value);
            var pathname = match.Groups[11].Value;
            return new MapEntry(devMajor, devMinor, end, inode, offset, pathname, perms, start);
        }

        private static MapEntryPermissions Permissions(Match match)
        {
            var result = MapEntryPermissions.None;
            if (match.Groups[3].Value == "r") result |= MapEntryPermissions.Read;
            if (match.Groups[4].Value == "w") result |= MapEntryPermissions.Write;
            if (match.Groups[5].Value == "x") result |= MapEntryPermissions.Execute;
            if (match.Groups[6].Value == "s") result |= MapEntryPermissions.Shared;
            return result;
        }

        #endregion
    }
}
```

`src/Tanya.Driver.Linux/Utilities/ProcessEntryParser.cs`:

```cs
using Tanya.Driver.Linux.Models;

namespace Tanya.Driver.Linux.Utilities
{
    public static class ProcessEntryParser
    {
        #region Statics

        public static ProcessEntry? Parse(string value, int pid)
        {
            var pieces = value.Split('\0', StringSplitOptions.RemoveEmptyEntries);
            if (pieces.Length != 0) return new ProcessEntry(pieces.Skip(1), pieces[0], pid);
            return null;
        }

        #endregion
    }
}
```

`src/Tanya.Driver/EmptyDriver.cs`:

```cs
using Tanya.Driver.Interfaces;

namespace Tanya.Driver
{
    public class EmptyDriver : IDriver
    {
        public static EmptyDriver Instance = new();

        #region Constructors

        private EmptyDriver()
        {
        }

        #endregion

        #region Implementation of IDriver

        public bool Read(ulong address, byte[] buffer, int count)
        {
            return true;
        }

        public bool Write(ulong address, byte[] buffer, int count)
        {
            return true;
        }

        #endregion
    }
}
```

`src/Tanya.Driver/Interfaces/IDriver.cs`:

```cs
namespace Tanya.Driver.Interfaces
{
    public interface IDriver
    {
        #region Methods

        bool Read(ulong address, byte[] buffer, int count);

        bool Write(ulong address, byte[] buffer, int count);

        #endregion
    }
}
```

`src/Tanya.Driver/Tanya.Driver.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
</Project>
```

`src/Tanya.Game.Apex.Core/Constants.cs`:

```cs
namespace Tanya.Game.Apex.Core
{
    public static class Constants
    {
        public const int EntityListInterval = 1000;
        public const int EntityListSizeFull = 65536 * 32;
        public const int EntityListSizePlayer = 64 * 32;
        public const float UnitToMeter = 0.0254f;
        public const int VisibilityTicks = (int)(TimeSpan.TicksPerMillisecond * 100);
    }
}
```

`src/Tanya.Game.Apex.Core/Context.cs`:

```cs
using Microsoft.Extensions.Logging;
using Tanya.Driver.Interfaces;

namespace Tanya.Game.Apex.Core
{
    public abstract class Context : IDriver, ILogger
    {
        private readonly IDriver _driver;
        private readonly ILogger _logger;

        #region Constructors

        protected Context(IDriver driver, ILogger logger)
        {
            _driver = driver;
            _logger = logger;
        }

        #endregion

        #region Implementation of IDriver

        public bool Read(ulong address, byte[] buffer, int count)
        {
            return _driver.Read(address, buffer, count);
        }

        public bool Write(ulong address, byte[] buffer, int count)
        {
            return _driver.Write(address, buffer, count);
        }

        #endregion

        #region Implementation of ILogger

        public IDisposable BeginScope<TState>(TState state)
        {
            return _logger.BeginScope(state);
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return _logger.IsEnabled(logLevel);
        }

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
        {
            _logger.Log(logLevel, eventId, state, exception, formatter);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Interfaces/IFeature.cs`:

```cs
namespace Tanya.Game.Apex.Core.Interfaces
{
    public interface IFeature
    {
        #region Methods

        void Tick(DateTime frameTime, State state);

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Interfaces/IOffsets.cs`:

```cs
namespace Tanya.Game.Apex.Core.Interfaces
{
    public interface IOffsets
    {
        #region Properties

        uint ButtonInAttack { get; }
        uint ButtonInSpeed { get; }
        uint ButtonInZoom { get; }
        uint CoreEntityList { get; }
        uint CoreLevelName { get; }
        uint CoreLocalPlayer { get; }
        uint EntityLastVisibleTime { get; }
        uint EntityLocalOrigin { get; }
        uint EntitySignifierName { get; }
        uint PlayerBleedoutState { get; }
        uint PlayerDuckState { get; }
        uint PlayerGlowEnable { get; }
        uint PlayerGlowThroughWall { get; }
        uint PlayerLifeState { get; }
        uint PlayerName { get; }
        uint PlayerTeamNum { get; }
        uint PlayerVecPunchWeaponAngle { get; }
        uint PlayerViewAngle { get; }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Interfaces/IUpdatable.cs`:

```cs
namespace Tanya.Game.Apex.Core.Interfaces
{
    public interface IUpdatable
    {
        #region Methods

        void Update(DateTime frameTime);

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/ButtonList.cs`:

```cs
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Core.Extensions;
using Tanya.Core.Types;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class ButtonList : IUpdatable
    {
        private readonly Access<byte> _inAttack;
        private readonly Access<byte> _inSpeed;
        private readonly Access<byte> _inZoom;

        #region Constructors

        public ButtonList(IDriver driver, IOffsets offsets, ulong address)
        {
            _inAttack = driver.Access(address + offsets.ButtonInAttack, ByteType.Instance);
            _inSpeed = driver.Access(address + offsets.ButtonInSpeed, ByteType.Instance);
            _inZoom = driver.Access(address + offsets.ButtonInZoom, ByteType.Instance);
        }

        #endregion

        #region Properties

        [JsonPropertyName("inAttack")]
        public byte InAttack
        {
            get => _inAttack.Get();
            set => _inAttack.Set(value);
        }

        [JsonPropertyName("inSpeed")]
        public byte InSpeed
        {
            get => _inSpeed.Get();
            set => _inSpeed.Set(value);
        }

        [JsonPropertyName("inZoom")]
        public byte InZoom
        {
            get => _inZoom.Get();
            set => _inZoom.Set(value);
        }

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            _inAttack.Update(frameTime);
            _inSpeed.Update(frameTime);
            _inZoom.Update(frameTime);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/Entity.cs`:

```cs
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Core.Extensions;
using Tanya.Core.Types;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class Entity : IUpdatable
    {
        private readonly Access<ulong> _signifierName;

        #region Constructors

        public Entity(IDriver driver, IOffsets offsets, ulong address)
        {
            _signifierName = driver.Access(address + offsets.EntitySignifierName, UInt64Type.Instance, 60000);
        }

        #endregion

        #region Properties

        [JsonPropertyName("signifierName")]
        public ulong SignifierName
        {
            get => _signifierName.Get();
            set => _signifierName.Set(value);
        }

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            _signifierName.Update(frameTime);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/EntityList.cs`:

```cs
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class EntityList : IUpdatable
    {
        private readonly ulong _address;
        private readonly IDriver _driver;
        private readonly LevelName _levelName;
        private readonly Limiter _limiter;
        private readonly IOffsets _offsets;
        private readonly ConcurrentDictionary<ulong, Entity> _value;

        #region Constructors

        public EntityList(IDriver driver, IOffsets offsets, LevelName levelName, ulong address)
        {
            _address = address + offsets.CoreEntityList;
            _driver = driver;
            _offsets = offsets;
            _levelName = levelName;
            _limiter = new Limiter(Constants.EntityListInterval);
            _value = new ConcurrentDictionary<ulong, Entity>();
        }

        #endregion

        #region Methods

        private void Synchronize()
        {
            var bufferSize = _levelName.Value == "mp_rr_canyonlands_staging"
                ? Constants.EntityListSizeFull
                : Constants.EntityListSizePlayer;
            var buffer = Reuse.GetBuffer(bufferSize);
            var knownSet = new HashSet<ulong>();

            if (_driver.Read(_address, buffer, bufferSize))
            {
                for (var i = 0; i < bufferSize; i += 32)
                {
                    var address = Unsafe.ReadUnaligned<ulong>(ref buffer[i]);
                    if (address == 0) continue;
                    knownSet.Add(address);
                }

                foreach (var address in knownSet)
                {
                    if (_value.ContainsKey(address)) continue;
                    _value.TryAdd(address, new Entity(_driver, _offsets, address));
                }

                foreach (var (address, _) in _value)
                {
                    if (knownSet.Contains(address)) continue;
                    _value.TryRemove(address, out _);
                }
            }
        }

        #endregion

        #region Properties

        [JsonPropertyName("value")]
        public IReadOnlyDictionary<ulong, Entity> Value => _value;

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            if (_limiter.Update(frameTime))
            {
                Synchronize();
            }

            foreach (var (_, entity) in _value)
            {
                entity.Update(frameTime);
            }
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/EntityListFilter.cs`:

```cs
using System.Collections.Concurrent;
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public abstract class EntityListFilter<T> : IUpdatable where T : IUpdatable
    {
        private readonly IDriver _driver;
        private readonly EntityList _entities;
        private readonly Limiter _limiter;
        private readonly SignifierList _signifiers;
        private readonly string _target;
        private readonly ConcurrentDictionary<ulong, T> _value;

        #region Abstracts

        protected abstract T Create(IDriver driver, ulong address);

        #endregion

        #region Constructors

        protected EntityListFilter(IDriver driver, EntityList entities, SignifierList signifiers, string target)
        {
            _driver = driver;
            _entities = entities;
            _limiter = new Limiter(Constants.EntityListInterval);
            _signifiers = signifiers;
            _target = target;
            _value = new ConcurrentDictionary<ulong, T>();
        }

        #endregion

        #region Methods

        private void Synchronize()
        {
            var knownSet = new HashSet<ulong>();

            foreach (var (address, entity) in _entities.Value)
            {
                var signifier = _signifiers.GetOrAdd(entity.SignifierName);
                if (signifier.Value != _target) continue;
                knownSet.Add(address);
            }

            foreach (var address in knownSet)
            {
                if (_value.ContainsKey(address)) continue;
                _value.TryAdd(address, Create(_driver, address));
            }

            foreach (var (address, _) in _value)
            {
                if (knownSet.Contains(address)) continue;
                _value.TryRemove(address, out _);
            }
        }

        #endregion

        #region Properties

        [JsonPropertyName("value")]
        public IReadOnlyDictionary<ulong, T> Value => _value;

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            if (_limiter.Update(frameTime))
            {
                Synchronize();
            }

            foreach (var (_, player) in _value)
            {
                player.Update(frameTime);
            }
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/LevelName.cs`:

```cs
using System.Text;
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Core.Extensions;
using Tanya.Core.Types;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class LevelName : IUpdatable
    {
        private readonly Access<string> _value;

        #region Constructors

        public LevelName(IDriver driver, IOffsets offsets, ulong address)
        {
            _value = driver.Access(address + offsets.CoreLevelName, new StringType(32, Encoding.ASCII), 5000);
        }

        #endregion

        #region Properties

        [JsonPropertyName("value")]
        public string Value => _value.Get();

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            _value.Update(frameTime);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/LocalPlayer.cs`:

```cs
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Core.Extensions;
using Tanya.Core.Types;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class LocalPlayer : IUpdatable
    {
        private readonly Access<ulong> _value;

        #region Constructors

        public LocalPlayer(IDriver driver, IOffsets offsets, ulong address)
        {
            _value = driver.Access(address + offsets.CoreLocalPlayer, UInt64Type.Instance, 1000);
        }

        #endregion

        #region Properties

        [JsonPropertyName("value")]
        public ulong Value => _value.Get();

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            _value.Update(frameTime);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/Npc.cs`:

```cs
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Core.Extensions;
using Tanya.Core.Models;
using Tanya.Core.Types;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;
using Tanya.Game.Apex.Core.Utilities;

namespace Tanya.Game.Apex.Core.Models
{
    public class Npc : IUpdatable
    {
        private readonly LastVisibleTime _lastVisibleTime;
        private readonly Access<Vector> _localOrigin;

        #region Constructors

        public Npc(IDriver driver, IOffsets offsets, ulong address)
        {
            _lastVisibleTime = new LastVisibleTime(driver.Access(address + offsets.EntityLastVisibleTime, SingleType.Instance));
            _localOrigin = driver.Access(address + offsets.EntityLocalOrigin, VectorType.Instance);
        }

        #endregion

        #region Properties

        [JsonPropertyName("localOrigin")]
        public Vector LocalOrigin
        {
            get => _localOrigin.Get();
            set => _localOrigin.Set(value);
        }

        [JsonPropertyName("visible")]
        public bool Visible => _lastVisibleTime.Visible;

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            _lastVisibleTime.Update(frameTime);
            _localOrigin.Update(frameTime);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/NpcList.cs`:

```cs
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class NpcList : EntityListFilter<Npc>
    {
        private readonly IOffsets _offsets;

        #region Constructors

        public NpcList(IDriver driver, IOffsets offsets, EntityList entities, SignifierList signifiers) : base(driver, entities, signifiers, "npc_dummie")
        {
            _offsets = offsets;
        }

        #endregion

        #region Overrides of EntityListFilter<Npc>

        protected override Npc Create(IDriver driver, ulong address)
        {
            return new Npc(driver, _offsets, address);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/Player.cs`:

```cs
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Core.Extensions;
using Tanya.Core.Models;
using Tanya.Core.Types;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;
using Tanya.Game.Apex.Core.Utilities;

namespace Tanya.Game.Apex.Core.Models
{
    public class Player : IUpdatable
    {
        private readonly Access<byte> _bleedoutState;
        private readonly Access<byte> _duckState;
        private readonly Access<byte> _glowEnable;
        private readonly Access<byte> _glowThroughWalls;
        private readonly LastVisibleTime _lastVisibleTime;
        private readonly Access<byte> _lifeState;
        private readonly Access<Vector> _localOrigin;
        private readonly Access<ulong> _name;
        private readonly Access<byte> _teamNum;
        private readonly Access<Vector> _vecPunchWeaponAngle;
        private readonly Access<Vector> _viewAngle;

        #region Constructors

        public Player(IDriver driver, IOffsets offsets, ulong address)
        {
            _bleedoutState = driver.Access(address + offsets.PlayerBleedoutState, ByteType.Instance);
            _duckState = driver.Access(address + offsets.PlayerDuckState, ByteType.Instance);
            _glowEnable = driver.Access(address + offsets.PlayerGlowEnable, ByteType.Instance);
            _glowThroughWalls = driver.Access(address + offsets.PlayerGlowThroughWall, ByteType.Instance);
            _lastVisibleTime = new LastVisibleTime(driver.Access(address + offsets.EntityLastVisibleTime, SingleType.Instance));
            _lifeState = driver.Access(address + offsets.PlayerLifeState, ByteType.Instance);
            _localOrigin = driver.Access(address + offsets.EntityLocalOrigin, VectorType.Instance);
            _name = driver.Access(address + offsets.PlayerName, UInt64Type.Instance);
            _teamNum = driver.Access(address + offsets.PlayerTeamNum, ByteType.Instance, 1000);
            _vecPunchWeaponAngle = driver.Access(address + offsets.PlayerVecPunchWeaponAngle, VectorType.Instance);
            _viewAngle = driver.Access(address + offsets.PlayerViewAngle, VectorType.Instance);
        }

        #endregion

        #region Methods

        public bool IsSameTeam(Player otherPlayer)
        {
            return TeamNum == otherPlayer.TeamNum;
        }

        public bool IsValid()
        {
            return GlowEnable != 0 && GlowEnable != 255 && LifeState == 0 && LocalOrigin != Vector.Origin && Name != 0;
        }

        #endregion

        #region Properties

        [JsonPropertyName("bleedoutState")]
        public byte BleedoutState
        {
            get => _bleedoutState.Get();
            set => _bleedoutState.Set(value);
        }

        [JsonPropertyName("duckState")]
        public byte DuckState
        {
            get => _duckState.Get();
            set => _duckState.Set(value);
        }

        [JsonPropertyName("glowEnable")]
        public byte GlowEnable
        {
            get => _glowEnable.Get();
            set => _glowEnable.Set(value);
        }

        [JsonPropertyName("glowThroughWalls")]
        public byte GlowThroughWalls
        {
            get => _glowThroughWalls.Get();
            set => _glowThroughWalls.Set(value);
        }

        [JsonPropertyName("lifeState")]
        public byte LifeState
        {
            get => _lifeState.Get();
            set => _lifeState.Set(value);
        }

        [JsonPropertyName("localOrigin")]
        public Vector LocalOrigin
        {
            get => _localOrigin.Get();
            set => _localOrigin.Set(value);
        }

        [JsonPropertyName("name")]
        public ulong Name
        {
            get => _name.Get();
            set => _name.Set(value);
        }

        [JsonPropertyName("teamNum")]
        public byte TeamNum
        {
            get => _teamNum.Get();
            set => _teamNum.Set(value);
        }

        [JsonPropertyName("vecPunchWeaponAngle")]
        public Vector VecPunchWeaponAngle
        {
            get => _vecPunchWeaponAngle.Get();
            set => _vecPunchWeaponAngle.Set(value);
        }

        [JsonPropertyName("viewAngle")]
        public Vector ViewAngle
        {
            get => _viewAngle.Get();
            set => _viewAngle.Set(value);
        }

        [JsonPropertyName("visible")]
        public bool Visible => _lastVisibleTime.Visible;

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            _bleedoutState.Update(frameTime);
            _duckState.Update(frameTime);
            _glowEnable.Update(frameTime);
            _glowThroughWalls.Update(frameTime);
            _lastVisibleTime.Update(frameTime);
            _lifeState.Update(frameTime);
            _localOrigin.Update(frameTime);
            _name.Update(frameTime);
            _teamNum.Update(frameTime);
            _vecPunchWeaponAngle.Update(frameTime);
            _viewAngle.Update(frameTime);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/PlayerList.cs`:

```cs
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class PlayerList : EntityListFilter<Player>
    {
        private readonly IOffsets _offsets;

        #region Constructors

        public PlayerList(IDriver driver, IOffsets offsets, EntityList entities, SignifierList signifiers) : base(driver, entities, signifiers, "player")
        {
            _offsets = offsets;
        }

        #endregion

        #region Overrides of EntityListFilter<Player>

        protected override Player Create(IDriver driver, ulong address)
        {
            return new Player(driver, _offsets, address);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/Signifier.cs`:

```cs
using System.Text;
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Core.Extensions;
using Tanya.Core.Types;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class Signifier : IUpdatable
    {
        private readonly Access<string> _value;

        #region Constructors

        public Signifier(IDriver driver, ulong address)
        {
            _value = driver.Access(address, new StringType(32, Encoding.ASCII), 60000);
        }

        #endregion

        #region Properties

        [JsonPropertyName("name")]
        public string Value
        {
            get => _value.Get();
            set => _value.Set(value);
        }

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            _value.Update(frameTime);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Models/SignifierList.cs`:

```cs
using System.Collections.Concurrent;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Models
{
    public class SignifierList : IUpdatable
    {
        private readonly IDriver _driver;
        private readonly ConcurrentDictionary<ulong, Signifier> _value;

        #region Constructors

        public SignifierList(IDriver driver)
        {
            _driver = driver;
            _value = new ConcurrentDictionary<ulong, Signifier>();
        }

        #endregion

        #region Methods

        public Signifier GetOrAdd(ulong address)
        {
            return _value.GetOrAdd(address, _ =>
            {
                var signifier = new Signifier(_driver, address);
                signifier.Update(DateTime.UtcNow);
                return signifier;
            });
        }

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            foreach (var (_, signifier) in _value)
            {
                signifier.Update(frameTime);
            }
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/State.cs`:

```cs
using System.Text.Json.Serialization;
using Microsoft.Extensions.Logging;
using Tanya.Driver.Interfaces;
using Tanya.Game.Apex.Core.Interfaces;
using Tanya.Game.Apex.Core.Models;

namespace Tanya.Game.Apex.Core
{
    public class State : Context, IUpdatable
    {
        private readonly ButtonList _buttons;
        private readonly EntityList _entities;
        private readonly LevelName _levelName;
        private readonly LocalPlayer _localPlayer;
        private readonly NpcList _npcs;
        private readonly PlayerList _players;
        private readonly SignifierList _signifiers;

        #region Constructors

        public State(IDriver driver, ILogger logger, IOffsets offsets, ulong address) : base(driver, logger)
        {
            _buttons = new ButtonList(driver, offsets, address);
            _levelName = new LevelName(driver, offsets, address);
            _localPlayer = new LocalPlayer(driver, offsets, address);
            _signifiers = new SignifierList(driver);
            _entities = new EntityList(driver, offsets, _levelName, address);
            _npcs = new NpcList(driver, offsets, _entities, _signifiers);
            _players = new PlayerList(driver, offsets, _entities, _signifiers);
        }

        #endregion

        #region Properties

        [JsonPropertyName("buttons")]
        public ButtonList Buttons => _buttons;

        [JsonPropertyName("levelName")]
        public string LevelName => _levelName.Value;

        [JsonPropertyName("localPlayer")]
        public ulong LocalPlayer => _localPlayer.Value;

        [JsonPropertyName("npcs")]
        public IReadOnlyDictionary<ulong, Npc> Npcs => _npcs.Value;

        [JsonPropertyName("players")]
        public IReadOnlyDictionary<ulong, Player> Players => _players.Value;

        #endregion

        #region Implementation of IUpdatable

        public void Update(DateTime frameTime)
        {
            _buttons.Update(frameTime);
            _levelName.Update(frameTime);
            _localPlayer.Update(frameTime);
            _entities.Update(frameTime);
            _npcs.Update(frameTime);
            _players.Update(frameTime);
            _signifiers.Update(frameTime);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Core/Tanya.Game.Apex.Core.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="6.0.1" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Tanya.Core\Tanya.Core.csproj" />
    <ProjectReference Include="..\Tanya.Driver\Tanya.Driver.csproj" />
  </ItemGroup>
</Project>
```

`src/Tanya.Game.Apex.Core/Utilities/LastVisibleTime.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;
using Tanya.Core;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Core.Utilities
{
    public class LastVisibleTime : IUpdatable
    {
        private readonly Access<float> _value;
        private long _previousTicks;
        private float _previousValue;

        #region Constructors

        public LastVisibleTime(Access<float> value)
        {
            _value = value;
        }

        #endregion

        #region Properties

        [JsonPropertyName("isVisible")]
        public bool Visible { get; private set; }

        #endregion

        #region Implementation of IUpdatable

        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        public void Update(DateTime frameTime)
        {
            if (_value.Update(frameTime))
            {
                var currentValue = _value.Get();

                if (currentValue != _previousValue)
                {
                    _previousTicks = frameTime.Ticks;
                    _previousValue = currentValue;
                    Visible = true;
                }
                else if (Visible && _previousTicks + Constants.VisibilityTicks < frameTime.Ticks)
                {
                    Visible = false;
                }
            }
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Bootstrap.cs`:

```cs
using Microsoft.Extensions.DependencyInjection;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Feature.Aim
{
    public static class Bootstrap
    {
        #region Statics

        public static void ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton<Config>();
            services.AddTransient<IFeature, Feature>();
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Config.cs`:

```cs
using System.Text.Json.Serialization;
using Microsoft.Extensions.Configuration;
using Tanya.Core.Extensions;

namespace Tanya.Game.Apex.Feature.Aim
{
    public class Config
    {
        private readonly IConfigurationSection _config;

        #region Constructors

        public Config(IConfiguration config)
        {
            _config = config.GetSection(typeof(Config).Namespace);
        }

        #endregion

        #region Properties

        [JsonPropertyName("distance")]
        public int Distance => _config.GetProperty<int>();

        [JsonPropertyName("lockTime")]
        public int LockTime => _config.GetProperty<int>();

        [JsonPropertyName("pitchAngle")]
        public int PitchAngle => _config.GetProperty<int>();

        [JsonPropertyName("pitchDeadzone")]
        public float PitchDeadzone => _config.GetProperty<float>();

        [JsonPropertyName("pitchSpeed")]
        public float PitchSpeed => _config.GetProperty<float>();

        [JsonPropertyName("recoil")]
        public float Recoil => _config.GetProperty<float>();

        [JsonPropertyName("releaseTime")]
        public int ReleaseTime => _config.GetProperty<int>();

        [JsonPropertyName("yawAngle")]
        public int YawAngle => _config.GetProperty<int>();

        [JsonPropertyName("yawDeadzone")]
        public float YawDeadzone => _config.GetProperty<float>();

        [JsonPropertyName("yawSpeed")]
        public float YawSpeed => _config.GetProperty<float>();

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Enums/TargetType.cs`:

```cs
namespace Tanya.Game.Apex.Feature.Aim.Enums
{
    public enum TargetType
    {
        None,
        Enemy,
        All
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Extensions/ConfigExtensions.cs`:

```cs
using Tanya.Core.Models;
using Tanya.Game.Apex.Feature.Aim.Utilities;

namespace Tanya.Game.Apex.Feature.Aim.Extensions
{
    public static class ConfigExtensions
    {
        #region Statics

        public static Vector GetSmoothAngle(this Config config, Vector a, Vector b, float p)
        {
            var dx = Normalize.X(a.X - b.X);
            var dy = Normalize.Y(a.Y - b.Y);
            var sx = a.X - dx * p * config.PitchSpeed;
            var sy = a.Y - dy * p * config.YawSpeed;
            return new Vector(Normalize.X(sx), Normalize.Y(sy), 0);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Extensions/StateExtensions.cs`:

```cs
using Tanya.Game.Apex.Core;
using Tanya.Game.Apex.Core.Models;
using Tanya.Game.Apex.Feature.Aim.Enums;
using Tanya.Game.Apex.Feature.Aim.Interfaces;
using Tanya.Game.Apex.Feature.Aim.Models;

namespace Tanya.Game.Apex.Feature.Aim.Extensions
{
    public static class StateExtensions
    {
        #region Statics

        public static TargetType GetTargetType(this State state, Player localPlayer)
        {
            if (localPlayer.BleedoutState != 0)
            {
                return TargetType.None;
            }

            if (state.Buttons.InSpeed != 0)
            {
                return TargetType.All;
            }

            if (state.Buttons.InAttack != 0 && (state.Buttons.InZoom != 0 || localPlayer.VecPunchWeaponAngle.X != 0 || localPlayer.VecPunchWeaponAngle.Y != 0))
            {
                return TargetType.Enemy;
            }

            return TargetType.None;
        }

        public static IEnumerable<ITarget> IterateTargets(this State state)
        {
            foreach (var (_, npc) in state.Npcs)
            {
                yield return new NpcTarget(npc);
            }

            foreach (var (_, player) in state.Players)
            {
                yield return new PlayerTarget(player);
            }
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Extensions/VectorExtensions.cs`:

```cs
using Tanya.Core.Models;
using Tanya.Game.Apex.Feature.Aim.Utilities;

namespace Tanya.Game.Apex.Feature.Aim.Extensions
{
    public static class VectorExtensions
    {
        #region Statics

        public static Vector GetDesiredAngle(this Vector a, Vector b)
        {
            var d = b - a;
            var h = MathF.Sqrt(d.Y * d.Y + d.X * d.X);
            var x = MathF.Atan2(d.Z, h) * 180 / MathF.PI * -1;
            var y = MathF.Atan2(d.Y, d.X) * 180 / MathF.PI;
            return new Vector(Normalize.X(x), Normalize.Y(y), 0);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Feature.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using Tanya.Core.Models;
using Tanya.Game.Apex.Core;
using Tanya.Game.Apex.Core.Interfaces;
using Tanya.Game.Apex.Core.Models;
using Tanya.Game.Apex.Feature.Aim.Enums;
using Tanya.Game.Apex.Feature.Aim.Extensions;
using Tanya.Game.Apex.Feature.Aim.Interfaces;
using Tanya.Game.Apex.Feature.Aim.Utilities;

namespace Tanya.Game.Apex.Feature.Aim
{
    public class Feature : IFeature
    {
        private readonly Config _config;
        private ITarget? _target;
        private long _targetLockTicks;
        private Vector? _targetPreviousOrigin;
        private long _targetPreviousTicks;
        private Vector? _targetPreviousVecPunchWeaponAngle;

        #region Constructors

        public Feature(Config config)
        {
            _config = config;
        }

        #endregion

        #region Methods

        private ITarget? Find(State state, Player localPlayer, bool scanSameTeam)
        {
            var bestEnemyScore = float.MaxValue;
            var bestEnemyTarget = null as ITarget;
            var bestTeamScore = float.MaxValue;
            var bestTeamTarget = null as ITarget;

            foreach (var target in state.IterateTargets().Where(x => x.IsValid(localPlayer) && x.Visible))
            {
                // Calculate the distance.
                var distance = localPlayer.LocalOrigin.Distance(target.LocalOrigin) * Constants.UnitToMeter;
                if (distance >= _config.Distance) continue;

                // Calculate the view angle delta.
                var desiredAngle = AdjustSelf(localPlayer).GetDesiredAngle(AdjustTarget(target));
                var deltaX = MathF.Abs(localPlayer.ViewAngle.X - desiredAngle.X);
                var deltaY = MathF.Abs(localPlayer.ViewAngle.Y - desiredAngle.Y);
                if (deltaX >= _config.PitchAngle || deltaY >= _config.YawAngle) continue;
                var targetScore = deltaX + deltaY + (target.BleedoutState != 0 ? 1000 : 0);

                // Prioritize the target.
                if (target.IsSameTeam(localPlayer))
                {
                    if (!scanSameTeam || targetScore >= bestTeamScore) continue;
                    bestTeamScore = targetScore;
                    bestTeamTarget = target;
                }
                else if (targetScore < bestEnemyScore)
                {
                    bestEnemyScore = targetScore;
                    bestEnemyTarget = target;
                }
            }

            return bestEnemyTarget ?? bestTeamTarget;
        }

        private float GetPercentage(DateTime frameTime)
        {
            var ticks = (float)(frameTime.Ticks - _targetLockTicks);
            var percentage = ticks / TimeSpan.TicksPerMillisecond / _config.LockTime;
            return MathF.Min(percentage, 1);
        }

        private void Target(DateTime frameTime, Player localPlayer, ITarget target)
        {
            var correctAngle = AdjustSelf(localPlayer).GetDesiredAngle(AdjustTarget(target));
            var currentAngle = localPlayer.ViewAngle + (_targetPreviousVecPunchWeaponAngle ?? Vector.Origin);
            var distance = localPlayer.LocalOrigin.Distance(target.LocalOrigin) * Constants.UnitToMeter;
            var deadzoneAngle = new Deadzone(correctAngle, _config.PitchDeadzone / distance, _config.YawDeadzone / distance).ToVector(currentAngle);
            var smoothAngle = _config.GetSmoothAngle(currentAngle, deadzoneAngle, GetPercentage(frameTime));
            localPlayer.ViewAngle = smoothAngle - localPlayer.VecPunchWeaponAngle * _config.Recoil;
        }

        #endregion

        #region Statics

        private static Vector AdjustSelf(Player localPlayer)
        {
            return localPlayer.DuckState != 0
                ? new Vector(localPlayer.LocalOrigin.X, localPlayer.LocalOrigin.Y, localPlayer.LocalOrigin.Z - 27)
                : new Vector(localPlayer.LocalOrigin.X, localPlayer.LocalOrigin.Y, localPlayer.LocalOrigin.Z);
        }

        private static Vector AdjustTarget(ITarget target)
        {
            return target.DuckState != 0 || target.BleedoutState != 0
                ? new Vector(target.LocalOrigin.X, target.LocalOrigin.Y, target.LocalOrigin.Z - 18)
                : new Vector(target.LocalOrigin.X, target.LocalOrigin.Y, target.LocalOrigin.Z - 10);
        }

        private static bool Validate(Player localPlayer, ITarget target, Vector targetPreviousOrigin)
        {
            return target.IsValid(localPlayer)
                   && target.Visible
                   && target.LocalOrigin.Distance(targetPreviousOrigin) * Constants.UnitToMeter < 5;
        }

        #endregion

        #region Implementation of IFeature

        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        public void Tick(DateTime frameTime, State state)
        {
            if (state.Players.TryGetValue(state.LocalPlayer, out var localPlayer))
            {
                var targetType = state.GetTargetType(localPlayer);
                if (targetType == TargetType.None)
                {
                    _target = null;
                    _targetLockTicks = 0;
                    _targetPreviousOrigin = null;
                    _targetPreviousTicks = 0;
                    _targetPreviousVecPunchWeaponAngle = null;
                }
                else if (_target == null || _targetPreviousOrigin == null)
                {
                    var target = Find(state, localPlayer, targetType == TargetType.All);
                    if (target == null) return;
                    _target = target;
                    _targetLockTicks = frameTime.Ticks;
                    _targetPreviousOrigin = target.LocalOrigin;
                    _targetPreviousTicks = frameTime.Ticks;
                    _targetPreviousVecPunchWeaponAngle = localPlayer.VecPunchWeaponAngle;
                }
                else if (!Validate(localPlayer, _target, _targetPreviousOrigin))
                {
                    if (_targetPreviousTicks + _config.ReleaseTime * TimeSpan.TicksPerMillisecond >= frameTime.Ticks) return;
                    _target = null;
                    _targetLockTicks = 0;
                    _targetPreviousOrigin = null;
                    _targetPreviousTicks = 0;
                    _targetPreviousVecPunchWeaponAngle = null;
                }
                else
                {
                    Target(frameTime, localPlayer, _target);
                    _targetPreviousOrigin = _target.LocalOrigin;
                    _targetPreviousTicks = frameTime.Ticks;
                    _targetPreviousVecPunchWeaponAngle = localPlayer.VecPunchWeaponAngle;
                }
            }
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Interfaces/ITarget.cs`:

```cs
using Tanya.Core.Models;
using Tanya.Game.Apex.Core.Models;

namespace Tanya.Game.Apex.Feature.Aim.Interfaces
{
    public interface ITarget
    {
        #region Methods

        bool IsSameTeam(Player localPlayer);

        bool IsValid(Player localPlayer);

        #endregion

        #region Properties

        byte BleedoutState { get; }

        byte DuckState { get; }

        Vector LocalOrigin { get; }

        bool Visible { get; }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Models/NpcTarget.cs`:

```cs
using System.Text.Json.Serialization;
using Tanya.Core.Models;
using Tanya.Game.Apex.Core.Models;
using Tanya.Game.Apex.Feature.Aim.Interfaces;

namespace Tanya.Game.Apex.Feature.Aim.Models
{
    public class NpcTarget : ITarget
    {
        private readonly Npc _npc;

        #region Constructors

        public NpcTarget(Npc npc)
        {
            _npc = npc;
        }

        #endregion

        #region Implementation of ITarget

        public bool IsSameTeam(Player localPlayer)
        {
            return false;
        }

        public bool IsValid(Player localPlayer)
        {
            return true;
        }

        #endregion

        #region Implementation of ITarget Properties

        [JsonPropertyName("bleedoutState")]
        public byte BleedoutState => 0;

        [JsonPropertyName("duckState")]
        public byte DuckState => 0;

        [JsonPropertyName("localOrigin")]
        public Vector LocalOrigin => _npc.LocalOrigin;

        [JsonPropertyName("visible")]
        public bool Visible => _npc.Visible;

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Models/PlayerTarget.cs`:

```cs
using System.Text.Json.Serialization;
using Tanya.Core.Models;
using Tanya.Game.Apex.Core.Models;
using Tanya.Game.Apex.Feature.Aim.Interfaces;

namespace Tanya.Game.Apex.Feature.Aim.Models
{
    public class PlayerTarget : ITarget
    {
        private readonly Player _player;

        #region Constructors

        public PlayerTarget(Player player)
        {
            _player = player;
        }

        #endregion

        #region Implementation of ITarget

        public bool IsSameTeam(Player localPlayer)
        {
            return _player.IsSameTeam(localPlayer);
        }

        public bool IsValid(Player localPlayer)
        {
            return _player.IsValid() && _player != localPlayer;
        }

        #endregion

        #region Implementation of ITarget Properties

        [JsonPropertyName("bleedoutState")]
        public byte BleedoutState => _player.BleedoutState;

        [JsonPropertyName("duckState")]
        public byte DuckState => _player.DuckState;

        [JsonPropertyName("localOrigin")]
        public Vector LocalOrigin => _player.LocalOrigin;

        [JsonPropertyName("visible")]
        public bool Visible => _player.Visible;

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Tanya.Game.Apex.Feature.Aim.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\Tanya.Game.Apex.Core\Tanya.Game.Apex.Core.csproj" />
  </ItemGroup>
</Project>
```

`src/Tanya.Game.Apex.Feature.Aim/Utilities/Deadzone.cs`:

```cs
using System.Text.Json.Serialization;
using Tanya.Core.Models;

namespace Tanya.Game.Apex.Feature.Aim.Utilities
{
    public class Deadzone
    {
        #region Constructors

        public Deadzone(Vector desiredAngle, float x, float y)
        {
            MinX = Normalize.X(desiredAngle.X - x);
            MinY = Normalize.Y(desiredAngle.Y - y);
            MaxX = Normalize.X(desiredAngle.X + x);
            MaxY = Normalize.Y(desiredAngle.Y + y);
        }

        #endregion

        #region Methods

        public Vector ToVector(Vector viewAngle)
        {
            var xa = Normalize.X(MinX - viewAngle.X);
            var xb = Normalize.X(MaxX - viewAngle.X);
            var ya = Normalize.Y(MinY - viewAngle.Y);
            var yb = Normalize.Y(MaxY - viewAngle.Y);
            var x = xa * xb < 0 && MathF.Abs(xa - xb) < 89 ? viewAngle.X : MathF.Abs(xa) < MathF.Abs(xb) ? MinX : MaxX;
            var y = ya * yb < 0 && MathF.Abs(ya - yb) < 180 ? viewAngle.Y : MathF.Abs(ya) < MathF.Abs(yb) ? MinY : MaxY;
            return new Vector(x, y, 0);
        }

        #endregion

        #region Properties

        [JsonPropertyName("maxX")]
        public float MaxX { get; set; }

        [JsonPropertyName("maxY")]
        public float MaxY { get; set; }

        [JsonPropertyName("minX")]
        public float MinX { get; set; }

        [JsonPropertyName("minY")]
        public float MinY { get; set; }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Aim/Utilities/Normalize.cs`:

```cs
namespace Tanya.Game.Apex.Feature.Aim.Utilities
{
    public static class Normalize
    {
        #region Statics

        public static float X(float x)
        {
            while (x > 89.0)
            {
                x -= 180;
            }

            while (x < -89.0)
            {
                x += 180;
            }

            return x;
        }

        public static float Y(float y)
        {
            while (y > 180)
            {
                y -= 360;
            }

            while (y < -180)
            {
                y += 360;
            }

            return y;
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Sense/Bootstrap.cs`:

```cs
using Microsoft.Extensions.DependencyInjection;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Feature.Sense
{
    public static class Bootstrap
    {
        #region Statics

        public static void ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton<Config>();
            services.AddTransient<IFeature, Feature>();
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Sense/Config.cs`:

```cs
using System.Text.Json.Serialization;
using Microsoft.Extensions.Configuration;
using Tanya.Core.Extensions;

namespace Tanya.Game.Apex.Feature.Sense
{
    public class Config
    {
        private readonly IConfigurationSection _config;

        #region Constructors

        public Config(IConfiguration config)
        {
            _config = config.GetSection(typeof(Config).Namespace);
        }

        #endregion

        #region Properties

        [JsonPropertyName("distance")]
        public int Distance => _config.GetProperty<int>();

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Sense/Feature.cs`:

```cs
using Tanya.Game.Apex.Core;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Feature.Sense
{
    public class Feature : IFeature
    {
        private readonly Config _config;

        #region Constructors

        public Feature(Config config)
        {
            _config = config;
        }

        #endregion

        #region Implementation of IFeature

        public void Tick(DateTime frameTime, State state)
        {
            if (state.Players.TryGetValue(state.LocalPlayer, out var localPlayer))
            {
                foreach (var (_, player) in state.Players)
                {
                    if (player.IsValid() && !player.IsSameTeam(localPlayer))
                    {
                        if (localPlayer.LocalOrigin.Distance(player.LocalOrigin) * Constants.UnitToMeter < _config.Distance)
                        {
                            player.GlowEnable = (byte)(player.Visible ? 5 : 7);
                            player.GlowThroughWalls = (byte)(player.Visible ? 1 : 2);
                        }
                        else if (player.GlowEnable is 5 or 7)
                        {
                            player.GlowEnable = 2;
                            player.GlowThroughWalls = 5;
                        }
                    }
                }
            }
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex.Feature.Sense/Tanya.Game.Apex.Feature.Sense.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\Tanya.Game.Apex.Core\Tanya.Game.Apex.Core.csproj" />
  </ItemGroup>
</Project>
```

`src/Tanya.Game.Apex/Bootstrap.cs`:

```cs
using Microsoft.Extensions.DependencyInjection;
using Tanya.Game.Apex.Services;

namespace Tanya.Game.Apex
{
    public static class Bootstrap
    {
        #region Statics

        public static void ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton<Config>();
            services.AddSingleton<DataService>();
            services.AddHostedService(x => x.GetRequiredService<DataService>());
            services.AddHostedService<LinuxService>();
            services.AddHostedService<WindowsService>();
            Feature.Aim.Bootstrap.ConfigureServices(services);
            Feature.Sense.Bootstrap.ConfigureServices(services);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Config.cs`:

```cs
using System.Text.Json.Serialization;
using Microsoft.Extensions.Configuration;
using Tanya.Core.Extensions;

namespace Tanya.Game.Apex
{
    public class Config
    {
        private readonly IConfigurationSection _config;

        #region Constructors

        public Config(IConfiguration configuration)
        {
            _config = configuration.GetSection(typeof(Config).Namespace);
        }

        #endregion

        #region Properties

        [JsonPropertyName("framesPerSecond")]
        public int FramesPerSecond => _config.GetProperty<int>();

        [JsonPropertyName("offsetsCheck")]
        public int OffsetsCheck => _config.GetProperty<int>();

        [JsonPropertyName("offsetsRefresh")]
        public int OffsetsRefresh => _config.GetProperty<int>();

        [JsonPropertyName("offsetsUrl")]
        public string OffsetsUrl => _config.GetProperty<string>();

        [JsonPropertyName("processRefresh")]
        public int ProcessRefresh => _config.GetProperty<int>();

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Models/Ini.cs`:

```cs
using System.Globalization;
using System.Text.RegularExpressions;

namespace Tanya.Game.Apex.Models
{
    public class Ini
    {
        private readonly Dictionary<string, Dictionary<string, string>> _values;

        #region Constructors

        private Ini()
        {
            _values = new Dictionary<string, Dictionary<string, string>>(StringComparer.InvariantCultureIgnoreCase);
        }

        public static Ini Create(string text)
        {
            var ini = new Ini();
            ini.Load(text);
            return ini;
        }

        #endregion

        #region Methods

        public uint Get(string name, string key)
        {
            if (!_values.TryGetValue(name, out var section))
            {
                throw new InvalidDataException();
            }

            if (!section.TryGetValue(key, out var value))
            {
                throw new InvalidDataException();
            }

            if (!uint.TryParse(Regex.Replace(value, "^0x", string.Empty), NumberStyles.HexNumber, null, out var offset))
            {
                throw new InvalidDataException();
            }

            return offset;
        }

        private void Load(string text)
        {
            var currentSection = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
            _values[string.Empty] = currentSection;

            foreach (var line in text.Split('\n').Select(x => x.Trim()).Where(x => !string.IsNullOrWhiteSpace(x)))
            {
                if (line.StartsWith(";"))
                {
                    continue;
                }

                if (line.StartsWith("[") && line.EndsWith("]"))
                {
                    currentSection = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
                    _values[line[1..^1]] = currentSection;
                    continue;
                }

                if (currentSection != null)
                {
                    var pair = line.Split('=', 2);
                    if (currentSection.ContainsKey(pair[0])) continue;
                    currentSection[pair[0]] = pair.Length == 2 ? pair[1] : string.Empty;
                }
            }
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Models/IniOffsets.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Models
{
    [JsonConverter(typeof(IniOffsetsSerializer))]
    public class IniOffsets : IOffsets
    {
        private readonly Ini _ini;

        #region Constructors

        private IniOffsets(Ini ini)
        {
            _ini = ini;
        }

        public static IniOffsets Create(string value)
        {
            return new IniOffsets(Ini.Create(value));
        }

        #endregion

        #region Overrides of object

        public override string ToString()
        {
            var options = new JsonSerializerOptions { WriteIndented = true };
            return JsonSerializer.Serialize(this, options);
        }

        #endregion

        #region Implementation of IOffsets Properties

        public uint ButtonInAttack => _ini.Get("Buttons", "in_attack");
        public uint ButtonInSpeed => _ini.Get("Buttons", "in_speed");
        public uint ButtonInZoom => _ini.Get("Buttons", "in_zoom");
        public uint CoreEntityList => _ini.Get("Miscellaneous", "cl_entitylist");
        public uint CoreLevelName => _ini.Get("Miscellaneous", "LevelName");
        public uint CoreLocalPlayer => _ini.Get("Miscellaneous", "LocalPlayer");
        public uint EntityLastVisibleTime => _ini.Get("Miscellaneous", "CPlayer!lastVisibleTime");
        public uint EntityLocalOrigin => _ini.Get("DataMap.CBaseViewModel", "m_localOrigin");
        public uint EntitySignifierName => _ini.Get("RecvTable.DT_BaseEntity", "m_iSignifierName");
        public uint PlayerBleedoutState => _ini.Get("RecvTable.DT_Player", "m_bleedoutState");
        public uint PlayerDuckState => _ini.Get("RecvTable.DT_Player", "m_duckState");
        public uint PlayerGlowEnable => _ini.Get("RecvTable.DT_HighlightSettings", "m_highlightServerContextID") + 0x8;
        public uint PlayerGlowThroughWall => _ini.Get("RecvTable.DT_HighlightSettings", "m_highlightServerContextID") + 0x10;
        public uint PlayerLifeState => _ini.Get("RecvTable.DT_Player", "m_lifeState");
        public uint PlayerName => _ini.Get("RecvTable.DT_BaseEntity", "m_iName");
        public uint PlayerTeamNum => _ini.Get("RecvTable.DT_BaseEntity", "m_iTeamNum");
        public uint PlayerVecPunchWeaponAngle => _ini.Get("DataMap.C_Player", "m_currentFrameLocalPlayer.m_vecPunchWeapon_Angle");
        public uint PlayerViewAngle => _ini.Get("DataMap.C_Player", "m_ammoPoolCapacity") - 0x14;

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Models/IniOffsetsSerializer.cs`:

```cs
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Models
{
    public class IniOffsetsSerializer : JsonConverter<IniOffsets>
    {
        private readonly IEnumerable<PropertyInfo> _properties;

        #region Constructors

        public IniOffsetsSerializer()
        {
            _properties = typeof(IOffsets).GetProperties(BindingFlags.Instance | BindingFlags.Public);
        }

        #endregion

        #region Methods

        private void Serialize(Utf8JsonWriter writer, IniOffsets offset)
        {
            foreach (var property in _properties)
            {
                var result = property.GetValue(offset);
                if (result is not uint value) throw new NotSupportedException();
                writer.WriteString(property.Name[..1].ToLower() + property.Name[1..], $"0x{value:X}");
            }
        }

        #endregion

        #region Overrides of JsonConverter<IniOffsets>

        public override IniOffsets Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            throw new NotSupportedException();
        }

        public override void Write(Utf8JsonWriter writer, IniOffsets offset, JsonSerializerOptions options)
        {
            writer.WriteStartObject();
            Serialize(writer, offset);
            writer.WriteEndObject();
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Runner.cs`:

```cs
using Tanya.Core;
using Tanya.Game.Apex.Core;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex
{
    public class Runner : IDisposable
    {
        private readonly CancellationTokenSource _cts;
        private readonly List<IFeature> _features;
        private readonly Looper _looper;
        private readonly State _state;

        #region Constructors

        private Runner(Config config, IEnumerable<IFeature> features, State state)
        {
            _cts = new CancellationTokenSource();
            _features = features.ToList();
            _looper = Looper.Create(TimeSpan.FromMilliseconds(1000f / config.FramesPerSecond));
            _state = state;
        }

        public static Runner Create(Config config, IEnumerable<IFeature> features, State state)
        {
            var runner = new Runner(config, features, state);
            Task.Factory.StartNew(runner.Process, TaskCreationOptions.LongRunning);
            return runner;
        }

        #endregion

        #region Methods

        private void Process()
        {
            var events = new[] { _looper, _cts.Token.WaitHandle };

            while (WaitHandle.WaitAny(events) == 0)
            {
                var frameTime = DateTime.UtcNow;
                _state.Update(frameTime);
                _features.ForEach(x => x.Tick(frameTime, _state));
            }
        }

        #endregion

        #region Implementation of IDisposable

        public void Dispose()
        {
            _cts.Cancel();
            _looper.Dispose();
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Services/DataService.cs`:

```cs
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Tanya.Game.Apex.Core.Interfaces;
using Tanya.Game.Apex.Models;

namespace Tanya.Game.Apex.Services
{
    public class DataService : IDisposable, IHostedService
    {
        private readonly Config _config;
        private readonly CancellationTokenSource _cts;
        private readonly HttpClient _http;
        private readonly ILogger<DataService> _logger;
        private readonly TaskCompletionSource _tcs;
        private IOffsets? _offsets;

        #region Constructors

        public DataService(Config config, ILogger<DataService> logger)
        {
            _config = config;
            _cts = new CancellationTokenSource();
            _http = new HttpClient();
            _logger = logger;
            _tcs = new TaskCompletionSource();
        }

        #endregion

        #region Methods

        public async Task<IOffsets> OffsetsAsync()
        {
            await _tcs.Task.ConfigureAwait(false);
            return _offsets ?? throw new OperationCanceledException();
        }

        private async Task FetchAsync()
        {
            var url = _config.OffsetsUrl;
            _logger.LogInformation("Fetching offsets: {0}", url);
            _offsets = IniOffsets.Create(await _http.GetStringAsync(url, _cts.Token).ConfigureAwait(false));
            _logger.LogInformation("Finished offsets: {0}", _offsets);
            _tcs.TrySetResult();
        }

        private async Task ProcessAsync()
        {
            var previousTime = DateTime.MinValue;
            var previousUrl = _config.OffsetsUrl;

            while (!_cts.IsCancellationRequested)
            {
                try
                {
                    if (previousUrl != _config.OffsetsUrl || previousTime + TimeSpan.FromMilliseconds(_config.OffsetsRefresh) < DateTime.UtcNow)
                    {
                        await FetchAsync().ConfigureAwait(false);
                        previousTime = DateTime.UtcNow;
                        previousUrl = _config.OffsetsUrl;
                    }
                    else
                    {
                        await Task.Delay(_config.OffsetsCheck, _cts.Token).ConfigureAwait(false);
                    }
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex.ToString());
                    await Task.Delay(_config.OffsetsCheck, _cts.Token).ConfigureAwait(false);
                }
            }
        }

        #endregion

        #region Implementation of IDisposable

        public void Dispose()
        {
            _http.Dispose();
            _tcs.TrySetCanceled();
            GC.SuppressFinalize(this);
        }

        #endregion

        #region Implementation of IHostedService

        public Task StartAsync(CancellationToken cancellationToken)
        {
            Task.Factory.StartNew(ProcessAsync, cancellationToken, TaskCreationOptions.LongRunning, TaskScheduler.Default);
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            _cts.Cancel();
            return Task.CompletedTask;
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Services/LinuxService.cs`:

```cs
using System.Collections.Concurrent;
using System.Runtime.InteropServices;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Tanya.Driver.Linux;
using Tanya.Game.Apex.Core;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Services
{
    public class LinuxService : IDisposable, IHostedService
    {
        private readonly Config _config;
        private readonly CancellationTokenSource _cts;
        private readonly DataService _dataService;
        private readonly Linux _linux;
        private readonly ILogger<LinuxService> _logger;
        private readonly ConcurrentDictionary<int, Runner> _runners;
        private readonly IServiceProvider _serviceProvider;

        #region Constructors

        public LinuxService(Config config, DataService dataService, Linux linux, ILogger<LinuxService> logger, IServiceProvider serviceProvider)
        {
            _config = config;
            _cts = new CancellationTokenSource();
            _dataService = dataService;
            _linux = linux;
            _logger = logger;
            _runners = new ConcurrentDictionary<int, Runner>();
            _serviceProvider = serviceProvider;
        }

        #endregion

        #region Methods

        private void Cleanup()
        {
            foreach (var (pid, _) in _runners)
            {
                if (_runners.TryRemove(pid, out var runner))
                {
                    runner.Dispose();
                }
            }
        }

        private async Task ProcessAsync()
        {
            IOffsets? previousOffsets = null;

            while (!_cts.IsCancellationRequested)
            {
                try
                {
                    var knownSet = new HashSet<int>();
                    var offsets = await _dataService.OffsetsAsync().ConfigureAwait(false);

                    if (previousOffsets == null || offsets != previousOffsets)
                    {
                        Cleanup();
                        previousOffsets = offsets;
                    }

                    await foreach (var process in _linux.ProcessesAsync().ConfigureAwait(false))
                    {
                        if (_runners.ContainsKey(process.Pid))
                        {
                            knownSet.Add(process.Pid);
                            continue;
                        }

                        if (process.Command.EndsWith("r5apex.exe", StringComparison.InvariantCultureIgnoreCase))
                        {
                            await foreach (var map in _linux.MapsAsync(process.Pid).ConfigureAwait(false))
                            {
                                if (map.Pathname.ToLower().EndsWith("r5apex.exe"))
                                {
                                    _runners.GetOrAdd(process.Pid, _ => Start(offsets, process.Pid, map.Start));
                                    knownSet.Add(process.Pid);
                                    break;
                                }
                            }
                        }
                    }

                    foreach (var (pid, _) in _runners)
                    {
                        if (!knownSet.Contains(pid) && _runners.TryRemove(pid, out var runner))
                        {
                            runner.Dispose();
                        }
                    }

                    await Task.Delay(_config.ProcessRefresh, _cts.Token).ConfigureAwait(false);
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex.ToString());
                    break;
                }
            }
        }

        private Runner Start(IOffsets offsets, int pid, ulong address)
        {
            using var scope = _serviceProvider.CreateScope();
            var driver = new LinuxDriver(pid);
            var features = scope.ServiceProvider.GetRequiredService<IEnumerable<IFeature>>();
            var logger = scope.ServiceProvider.GetRequiredService<ILogger<State>>();
            var state = new State(driver, logger, offsets, address);
            return Runner.Create(_config, features, state);
        }

        #endregion

        #region Implementation of IDisposable

        public void Dispose()
        {
            Cleanup();
            GC.SuppressFinalize(this);
        }

        #endregion

        #region Implementation of IHostedService

        public Task StartAsync(CancellationToken cancellationToken)
        {
            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Linux)) return Task.CompletedTask;
            Task.Factory.StartNew(ProcessAsync, cancellationToken, TaskCreationOptions.LongRunning, TaskScheduler.Default);
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            _cts.Cancel();
            return Task.CompletedTask;
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Services/WindowsService.cs`:

```cs
using System.Runtime.InteropServices;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Tanya.Driver;
using Tanya.Game.Apex.Core;
using Tanya.Game.Apex.Core.Interfaces;

namespace Tanya.Game.Apex.Services
{
    public class WindowsService : IDisposable, IHostedService
    {
        private readonly Config _config;
        private readonly CancellationTokenSource _cts;
        private readonly DataService _dataService;
        private readonly ILogger<WindowsService> _logger;
        private readonly IServiceProvider _serviceProvider;
        private Runner? _runner;

        #region Constructors

        public WindowsService(Config config, DataService dataService, ILogger<WindowsService> logger, IServiceProvider serviceProvider)
        {
            _config = config;
            _cts = new CancellationTokenSource();
            _dataService = dataService;
            _logger = logger;
            _serviceProvider = serviceProvider;
        }

        #endregion

        #region Methods

        private async Task ProcessAsync()
        {
            while (!_cts.IsCancellationRequested)
            {
                try
                {
                    using var scope = _serviceProvider.CreateScope();
                    var features = scope.ServiceProvider.GetRequiredService<IEnumerable<IFeature>>();
                    var logger = scope.ServiceProvider.GetRequiredService<ILogger<State>>();
                    var offsets = await _dataService.OffsetsAsync().ConfigureAwait(false);
                    var state = new State(EmptyDriver.Instance, logger, offsets, 0);
                    _runner = Runner.Create(_config, features, state);
                    return;
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex.ToString());
                    break;
                }
            }
        }

        #endregion

        #region Implementation of IDisposable

        public void Dispose()
        {
            _runner?.Dispose();
            GC.SuppressFinalize(this);
        }

        #endregion

        #region Implementation of IHostedService

        public Task StartAsync(CancellationToken cancellationToken)
        {
            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) return Task.CompletedTask;
            Task.Factory.StartNew(ProcessAsync, cancellationToken, TaskCreationOptions.LongRunning, TaskScheduler.Default);
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            _cts.Cancel();
            return Task.CompletedTask;
        }

        #endregion
    }
}
```

`src/Tanya.Game.Apex/Tanya.Game.Apex.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="6.0.1" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Tanya.Core\Tanya.Core.csproj" />
    <ProjectReference Include="..\Tanya.Driver\Tanya.Driver.csproj" />
    <ProjectReference Include="..\Tanya.Driver.Linux\Tanya.Driver.Linux.csproj" />
    <ProjectReference Include="..\Tanya.Game.Apex.Core\Tanya.Game.Apex.Core.csproj" />
    <ProjectReference Include="..\Tanya.Game.Apex.Feature.Aim\Tanya.Game.Apex.Feature.Aim.csproj" />
    <ProjectReference Include="..\Tanya.Game.Apex.Feature.Sense\Tanya.Game.Apex.Feature.Sense.csproj" />
  </ItemGroup>
</Project>
```

`src/Tanya.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32228.430
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Tanya", "Tanya\Tanya.csproj", "{89FD9867-9F4A-4C76-A06C-1D6FEE56ED13}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Tanya.Driver", "Tanya.Driver\Tanya.Driver.csproj", "{10C9A878-14AA-41A6-8AA8-43780DE4AC15}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Tanya.Core", "Tanya.Core\Tanya.Core.csproj", "{E7A72D65-FA5B-4D79-A3AB-0DFE7D00BECD}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Tanya.Driver.Linux", "Tanya.Driver.Linux\Tanya.Driver.Linux.csproj", "{26858C32-3B68-46FD-9C2E-1AA930B0B69E}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Tanya.Game.Apex.Feature.Sense", "Tanya.Game.Apex.Feature.Sense\Tanya.Game.Apex.Feature.Sense.csproj", "{DEC279D8-215A-4136-B715-FB19F9280503}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Tanya.Game.Apex", "Tanya.Game.Apex\Tanya.Game.Apex.csproj", "{0C086AF9-D01F-4530-8737-5969E6215F7C}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Tanya.Game.Apex.Core", "Tanya.Game.Apex.Core\Tanya.Game.Apex.Core.csproj", "{15EBAD73-19CA-4567-9DD4-84371A3DB229}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Tanya.Game.Apex.Feature.Aim", "Tanya.Game.Apex.Feature.Aim\Tanya.Game.Apex.Feature.Aim.csproj", "{A85CAAF1-168E-4DBE-82BA-F22D8F09584B}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Apex Legends", "Apex Legends", "{AA7B3467-4303-44C6-8D76-440086268FB5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{89FD9867-9F4A-4C76-A06C-1D6FEE56ED13}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{89FD9867-9F4A-4C76-A06C-1D6FEE56ED13}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{89FD9867-9F4A-4C76-A06C-1D6FEE56ED13}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{89FD9867-9F4A-4C76-A06C-1D6FEE56ED13}.Release|Any CPU.Build.0 = Release|Any CPU
		{10C9A878-14AA-41A6-8AA8-43780DE4AC15}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{10C9A878-14AA-41A6-8AA8-43780DE4AC15}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{10C9A878-14AA-41A6-8AA8-43780DE4AC15}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{10C9A878-14AA-41A6-8AA8-43780DE4AC15}.Release|Any CPU.Build.0 = Release|Any CPU
		{E7A72D65-FA5B-4D79-A3AB-0DFE7D00BECD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E7A72D65-FA5B-4D79-A3AB-0DFE7D00BECD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E7A72D65-FA5B-4D79-A3AB-0DFE7D00BECD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E7A72D65-FA5B-4D79-A3AB-0DFE7D00BECD}.Release|Any CPU.Build.0 = Release|Any CPU
		{26858C32-3B68-46FD-9C2E-1AA930B0B69E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{26858C32-3B68-46FD-9C2E-1AA930B0B69E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{26858C32-3B68-46FD-9C2E-1AA930B0B69E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{26858C32-3B68-46FD-9C2E-1AA930B0B69E}.Release|Any CPU.Build.0 = Release|Any CPU
		{DEC279D8-215A-4136-B715-FB19F9280503}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DEC279D8-215A-4136-B715-FB19F9280503}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DEC279D8-215A-4136-B715-FB19F9280503}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DEC279D8-215A-4136-B715-FB19F9280503}.Release|Any CPU.Build.0 = Release|Any CPU
		{0C086AF9-D01F-4530-8737-5969E6215F7C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0C086AF9-D01F-4530-8737-5969E6215F7C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0C086AF9-D01F-4530-8737-5969E6215F7C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0C086AF9-D01F-4530-8737-5969E6215F7C}.Release|Any CPU.Build.0 = Release|Any CPU
		{15EBAD73-19CA-4567-9DD4-84371A3DB229}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{15EBAD73-19CA-4567-9DD4-84371A3DB229}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{15EBAD73-19CA-4567-9DD4-84371A3DB229}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{15EBAD73-19CA-4567-9DD4-84371A3DB229}.Release|Any CPU.Build.0 = Release|Any CPU
		{A85CAAF1-168E-4DBE-82BA-F22D8F09584B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A85CAAF1-168E-4DBE-82BA-F22D8F09584B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A85CAAF1-168E-4DBE-82BA-F22D8F09584B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A85CAAF1-168E-4DBE-82BA-F22D8F09584B}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{DEC279D8-215A-4136-B715-FB19F9280503} = {AA7B3467-4303-44C6-8D76-440086268FB5}
		{0C086AF9-D01F-4530-8737-5969E6215F7C} = {AA7B3467-4303-44C6-8D76-440086268FB5}
		{15EBAD73-19CA-4567-9DD4-84371A3DB229} = {AA7B3467-4303-44C6-8D76-440086268FB5}
		{A85CAAF1-168E-4DBE-82BA-F22D8F09584B} = {AA7B3467-4303-44C6-8D76-440086268FB5}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {458936D3-F29B-4CD2-AB0A-0FF003EAAF97}
	EndGlobalSection
EndGlobal

```

`src/Tanya.sln.DotSettings`:

```DotSettings
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeInspection/Highlighting/InspectionSeverities/=ConvertToAutoProperty/@EntryIndexedValue">DO_NOT_SHOW</s:String>
	<s:String x:Key="/Default/CodeInspection/Highlighting/InspectionSeverities/=ConvertToAutoPropertyWhenPossible/@EntryIndexedValue">DO_NOT_SHOW</s:String>
	<s:String x:Key="/Default/CodeInspection/Highlighting/InspectionSeverities/=ConvertToPrimaryConstructor/@EntryIndexedValue">DO_NOT_SHOW</s:String>
	<s:String x:Key="/Default/CodeInspection/Highlighting/InspectionSeverities/=IdentifierTypo/@EntryIndexedValue">DO_NOT_SHOW</s:String>
	<s:String x:Key="/Default/CodeInspection/Highlighting/InspectionSeverities/=StringLiteralTypo/@EntryIndexedValue">DO_NOT_SHOW</s:String>
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpCodeStyle/BRACES_FOR_FOR/@EntryValue">RequiredForMultilineStatement</s:String>
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpCodeStyle/BRACES_FOR_FOREACH/@EntryValue">RequiredForMultilineStatement</s:String>
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpCodeStyle/BRACES_FOR_IFELSE/@EntryValue">RequiredForMultilineStatement</s:String>
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpCodeStyle/BRACES_FOR_WHILE/@EntryValue">Required</s:String>
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpCodeStyle/NAMESPACE_BODY/@EntryValue">BlockScoped</s:String>
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/PLACE_ACCESSORHOLDER_ATTRIBUTE_ON_SAME_LINE_EX/@EntryValue">NEVER</s:String>
	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/PLACE_ACCESSOR_ATTRIBUTE_ON_SAME_LINE_EX/@EntryValue">NEVER</s:String>
	<s:Int64 x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/WRAP_LIMIT/@EntryValue">160</s:Int64>
	<s:String x:Key="/Default/CodeStyle/CSharpFileLayoutPatterns/Pattern/@EntryValue">&lt;?xml version="1.0" encoding="utf-16"?&gt;&#xD;
&lt;Patterns xmlns="urn:schemas-jetbrains-com:member-reordering-patterns"&gt;&#xD;
  &lt;TypePattern DisplayName="Non-reorderable types"&gt;&#xD;
    &lt;TypePattern.Match&gt;&#xD;
      &lt;Or&gt;&#xD;
        &lt;And&gt;&#xD;
          &lt;Kind Is="Interface" /&gt;&#xD;
          &lt;Or&gt;&#xD;
            &lt;HasAttribute Name="System.Runtime.InteropServices.InterfaceTypeAttribute" /&gt;&#xD;
            &lt;HasAttribute Name="System.Runtime.InteropServices.ComImport" /&gt;&#xD;
          &lt;/Or&gt;&#xD;
        &lt;/And&gt;&#xD;
        &lt;Kind Is="Struct" /&gt;&#xD;
        &lt;HasAttribute Name="JetBrains.Annotations.NoReorderAttribute" /&gt;&#xD;
        &lt;HasAttribute Name="JetBrains.Annotations.NoReorder" /&gt;&#xD;
      &lt;/Or&gt;&#xD;
    &lt;/TypePattern.Match&gt;&#xD;
  &lt;/TypePattern&gt;&#xD;
  &lt;TypePattern DisplayName="xUnit.net Test Classes" RemoveRegions="All"&gt;&#xD;
    &lt;TypePattern.Match&gt;&#xD;
      &lt;And&gt;&#xD;
        &lt;Kind Is="Class" /&gt;&#xD;
        &lt;HasMember&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Kind Is="Method" /&gt;&#xD;
            &lt;HasAttribute Name="Xunit.FactAttribute" Inherited="True" /&gt;&#xD;
            &lt;HasAttribute Name="Xunit.TheoryAttribute" Inherited="True" /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/HasMember&gt;&#xD;
      &lt;/And&gt;&#xD;
    &lt;/TypePattern.Match&gt;&#xD;
    &lt;Entry DisplayName="Setup/Teardown Methods"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;Or&gt;&#xD;
          &lt;Kind Is="Constructor" /&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Kind Is="Method" /&gt;&#xD;
            &lt;ImplementsInterface Name="System.IDisposable" /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/Or&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Kind Order="Constructor" /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
    &lt;Entry DisplayName="All other members" /&gt;&#xD;
    &lt;Entry DisplayName="Test Methods" Priority="100"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;And&gt;&#xD;
          &lt;Kind Is="Method" /&gt;&#xD;
          &lt;HasAttribute Name="Xunit.FactAttribute" /&gt;&#xD;
          &lt;HasAttribute Name="Xunit.TheoryAttribute" /&gt;&#xD;
        &lt;/And&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Name /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
  &lt;/TypePattern&gt;&#xD;
  &lt;TypePattern DisplayName="NUnit Test Fixtures" RemoveRegions="All"&gt;&#xD;
    &lt;TypePattern.Match&gt;&#xD;
      &lt;And&gt;&#xD;
        &lt;Kind Is="Class" /&gt;&#xD;
        &lt;Or&gt;&#xD;
          &lt;HasAttribute Name="NUnit.Framework.TestFixtureAttribute" Inherited="True" /&gt;&#xD;
          &lt;HasAttribute Name="NUnit.Framework.TestFixtureSourceAttribute" Inherited="True" /&gt;&#xD;
          &lt;HasMember&gt;&#xD;
            &lt;And&gt;&#xD;
              &lt;Kind Is="Method" /&gt;&#xD;
              &lt;HasAttribute Name="NUnit.Framework.TestAttribute" /&gt;&#xD;
              &lt;HasAttribute Name="NUnit.Framework.TestCaseAttribute" /&gt;&#xD;
              &lt;HasAttribute Name="NUnit.Framework.TestCaseSourceAttribute" /&gt;&#xD;
            &lt;/And&gt;&#xD;
          &lt;/HasMember&gt;&#xD;
        &lt;/Or&gt;&#xD;
      &lt;/And&gt;&#xD;
    &lt;/TypePattern.Match&gt;&#xD;
    &lt;Entry DisplayName="Setup/Teardown Methods"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;And&gt;&#xD;
          &lt;Kind Is="Method" /&gt;&#xD;
          &lt;Or&gt;&#xD;
            &lt;HasAttribute Name="NUnit.Framework.SetUpAttribute" Inherited="True" /&gt;&#xD;
            &lt;HasAttribute Name="NUnit.Framework.TearDownAttribute" Inherited="True" /&gt;&#xD;
            &lt;HasAttribute Name="NUnit.Framework.TestFixtureSetUpAttribute" Inherited="True" /&gt;&#xD;
            &lt;HasAttribute Name="NUnit.Framework.TestFixtureTearDownAttribute" Inherited="True" /&gt;&#xD;
            &lt;HasAttribute Name="NUnit.Framework.OneTimeSetUpAttribute" Inherited="True" /&gt;&#xD;
            &lt;HasAttribute Name="NUnit.Framework.OneTimeTearDownAttribute" Inherited="True" /&gt;&#xD;
          &lt;/Or&gt;&#xD;
        &lt;/And&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
    &lt;/Entry&gt;&#xD;
    &lt;Entry DisplayName="All other members" /&gt;&#xD;
    &lt;Entry DisplayName="Test Methods" Priority="100"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;And&gt;&#xD;
          &lt;Kind Is="Method" /&gt;&#xD;
          &lt;HasAttribute Name="NUnit.Framework.TestAttribute" /&gt;&#xD;
          &lt;HasAttribute Name="NUnit.Framework.TestCaseAttribute" /&gt;&#xD;
          &lt;HasAttribute Name="NUnit.Framework.TestCaseSourceAttribute" /&gt;&#xD;
        &lt;/And&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Name /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
  &lt;/TypePattern&gt;&#xD;
  &lt;TypePattern DisplayName="Default Pattern" RemoveRegions="AllExceptGenerated"&gt;&#xD;
    &lt;Entry DisplayName="Public Delegates" Priority="100"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;And&gt;&#xD;
          &lt;Access Is="Public" /&gt;&#xD;
          &lt;Kind Is="Delegate" /&gt;&#xD;
        &lt;/And&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Access /&gt;&#xD;
        &lt;Name /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
    &lt;Entry DisplayName="Public Enums" Priority="100"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;And&gt;&#xD;
          &lt;Access Is="Public" /&gt;&#xD;
          &lt;Kind Is="Enum" /&gt;&#xD;
        &lt;/And&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Access /&gt;&#xD;
        &lt;Name /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
    &lt;Entry DisplayName="Static Fields and Constants"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;Or&gt;&#xD;
          &lt;Kind Is="Constant" /&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Kind Is="Field" /&gt;&#xD;
            &lt;Static /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/Or&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Access /&gt;&#xD;
        &lt;Name /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
    &lt;Entry DisplayName="Fields"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;And&gt;&#xD;
          &lt;Kind Is="Field" /&gt;&#xD;
          &lt;Not&gt;&#xD;
            &lt;Static /&gt;&#xD;
          &lt;/Not&gt;&#xD;
        &lt;/And&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Readonly /&gt;&#xD;
        &lt;Access /&gt;&#xD;
        &lt;Name /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
    &lt;Region Name="Abstracts"&gt;&#xD;
      &lt;Entry DisplayName="Abstract"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Or&gt;&#xD;
              &lt;Access Is="Private" /&gt;&#xD;
              &lt;Access Is="Protected" /&gt;&#xD;
            &lt;/Or&gt;&#xD;
            &lt;Abstract /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
      &lt;/Entry&gt;&#xD;
    &lt;/Region&gt;&#xD;
    &lt;Region Name="Constructors"&gt;&#xD;
      &lt;Entry DisplayName="Constructors"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;Kind Is="Constructor" /&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
        &lt;Entry.SortBy&gt;&#xD;
          &lt;Access /&gt;&#xD;
          &lt;Name /&gt;&#xD;
        &lt;/Entry.SortBy&gt;&#xD;
      &lt;/Entry&gt;&#xD;
      &lt;Entry DisplayName="Static Constructor"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Static /&gt;&#xD;
            &lt;Kind Is="Method" /&gt;&#xD;
            &lt;Name Is="Create.*" /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
        &lt;Entry.SortBy&gt;&#xD;
          &lt;Access /&gt;&#xD;
          &lt;Name /&gt;&#xD;
        &lt;/Entry.SortBy&gt;&#xD;
      &lt;/Entry&gt;&#xD;
    &lt;/Region&gt;&#xD;
    &lt;Region Name="Methods"&gt;&#xD;
      &lt;Entry DisplayName="Methods"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Not&gt;&#xD;
              &lt;Static /&gt;&#xD;
            &lt;/Not&gt;&#xD;
            &lt;Kind Is="Method" /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
        &lt;Entry.SortBy&gt;&#xD;
          &lt;Access /&gt;&#xD;
          &lt;Name /&gt;&#xD;
        &lt;/Entry.SortBy&gt;&#xD;
      &lt;/Entry&gt;&#xD;
    &lt;/Region&gt;&#xD;
    &lt;Region Name="Properties"&gt;&#xD;
      &lt;Entry DisplayName="Properties, Indexers"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;Or&gt;&#xD;
            &lt;Kind Is="Property" /&gt;&#xD;
            &lt;Kind Is="Indexer" /&gt;&#xD;
          &lt;/Or&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
        &lt;Entry.SortBy&gt;&#xD;
          &lt;Access /&gt;&#xD;
          &lt;Name /&gt;&#xD;
        &lt;/Entry.SortBy&gt;&#xD;
      &lt;/Entry&gt;&#xD;
    &lt;/Region&gt;&#xD;
    &lt;Region Name="Statics"&gt;&#xD;
      &lt;Entry DisplayName="Static Methods"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Static /&gt;&#xD;
            &lt;Kind Is="Method" /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
        &lt;Entry.SortBy&gt;&#xD;
          &lt;Access /&gt;&#xD;
          &lt;Name /&gt;&#xD;
        &lt;/Entry.SortBy&gt;&#xD;
      &lt;/Entry&gt;&#xD;
    &lt;/Region&gt;&#xD;
    &lt;Region Name="Overrides of ${Override}" Priority="100"&gt;&#xD;
      &lt;Region.GroupBy&gt;&#xD;
        &lt;Override /&gt;&#xD;
      &lt;/Region.GroupBy&gt;&#xD;
      &lt;Entry DisplayName="Overrides"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;Override /&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
        &lt;Entry.SortBy&gt;&#xD;
          &lt;Kind Is="Member" /&gt;&#xD;
          &lt;Access /&gt;&#xD;
          &lt;Name /&gt;&#xD;
        &lt;/Entry.SortBy&gt;&#xD;
      &lt;/Entry&gt;&#xD;
    &lt;/Region&gt;&#xD;
    &lt;Region Name="Implementation of ${ImplementsInterface}" Priority="100"&gt;&#xD;
      &lt;Region.GroupBy&gt;&#xD;
        &lt;ImplementsInterface /&gt;&#xD;
      &lt;/Region.GroupBy&gt;&#xD;
      &lt;Entry DisplayName="Methods"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Kind Is="Method" /&gt;&#xD;
            &lt;ImplementsInterface /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
        &lt;Entry.SortBy&gt;&#xD;
          &lt;ImplementsInterface /&gt;&#xD;
          &lt;Kind Is="Member" /&gt;&#xD;
          &lt;Access /&gt;&#xD;
          &lt;Name /&gt;&#xD;
        &lt;/Entry.SortBy&gt;&#xD;
      &lt;/Entry&gt;&#xD;
    &lt;/Region&gt;&#xD;
    &lt;Region Name="Implementation of ${ImplementsInterface} Properties" Priority="100"&gt;&#xD;
      &lt;Region.GroupBy&gt;&#xD;
        &lt;ImplementsInterface /&gt;&#xD;
      &lt;/Region.GroupBy&gt;&#xD;
      &lt;Entry DisplayName="Properties, Indexers"&gt;&#xD;
        &lt;Entry.Match&gt;&#xD;
          &lt;And&gt;&#xD;
            &lt;Or&gt;&#xD;
              &lt;Kind Is="Indexer" /&gt;&#xD;
              &lt;Kind Is="Property" /&gt;&#xD;
            &lt;/Or&gt;&#xD;
            &lt;ImplementsInterface /&gt;&#xD;
          &lt;/And&gt;&#xD;
        &lt;/Entry.Match&gt;&#xD;
        &lt;Entry.SortBy&gt;&#xD;
          &lt;ImplementsInterface /&gt;&#xD;
          &lt;Kind Is="Member" /&gt;&#xD;
          &lt;Access /&gt;&#xD;
          &lt;Name /&gt;&#xD;
        &lt;/Entry.SortBy&gt;&#xD;
      &lt;/Entry&gt;&#xD;
    &lt;/Region&gt;&#xD;
    &lt;Entry DisplayName="All other members"&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Access /&gt;&#xD;
        &lt;Name /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
    &lt;Entry DisplayName="Nested Types"&gt;&#xD;
      &lt;Entry.Match&gt;&#xD;
        &lt;Kind Is="Type" /&gt;&#xD;
      &lt;/Entry.Match&gt;&#xD;
      &lt;Entry.SortBy&gt;&#xD;
        &lt;Access /&gt;&#xD;
        &lt;Name /&gt;&#xD;
      &lt;/Entry.SortBy&gt;&#xD;
    &lt;/Entry&gt;&#xD;
  &lt;/TypePattern&gt;&#xD;
&lt;/Patterns&gt;</s:String>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ECSharpKeepExistingMigration/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ECSharpPlaceEmbeddedOnSameLineMigration/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ECSharpUseContinuousIndentInsideBracesMigration/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ESettingsUpgrade_002EAlwaysTreatStructAsNotReorderableMigration/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ESettingsUpgrade_002EMigrateBlankLinesAroundFieldToBlankLinesAroundProperty/@EntryIndexedValue">True</s:Boolean>
</wpf:ResourceDictionary>
```

`src/Tanya/Logging/Logger.cs`:

```cs
using Microsoft.Extensions.Logging;

namespace Tanya.Logging
{
    public class Logger : ILogger
    {
        private readonly string _name;
        private readonly LoggerWriter _writer;

        #region Constructors

        public Logger(string name, LoggerWriter writer)
        {
            _name = name;
            _writer = writer;
        }

        #endregion

        #region Implementation of ILogger

        public IDisposable BeginScope<TState>(TState state)
        {
            throw new NotSupportedException();
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return true;
        }

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
        {
            _writer.Enqueue($"[{DateTime.Now:s}] ({logLevel.ToString()[0]}) {_name} - {formatter(state, exception)}");
        }

        #endregion
    }
}
```

`src/Tanya/Logging/LoggerProvider.cs`:

```cs
using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;

namespace Tanya.Logging
{
    public class LoggerProvider : ILoggerProvider
    {
        private readonly ConcurrentDictionary<string, Logger> _loggers;
        private readonly LoggerWriter _writer;

        #region Constructors

        public LoggerProvider()
        {
            _loggers = new ConcurrentDictionary<string, Logger>(StringComparer.InvariantCultureIgnoreCase);
            _writer = LoggerWriter.Create();
        }

        #endregion

        #region Implementation of IDisposable

        public void Dispose()
        {
            _loggers.Clear();
            _writer.Dispose();
            GC.SuppressFinalize(this);
        }

        #endregion

        #region Implementation of ILoggerProvider

        public ILogger CreateLogger(string name)
        {
            return _loggers.GetOrAdd(name, _ => new Logger(name, _writer));
        }

        #endregion
    }
}
```

`src/Tanya/Logging/LoggerWriter.cs`:

```cs
using System.Collections.Concurrent;
using System.Diagnostics;

namespace Tanya.Logging
{
    public class LoggerWriter : IDisposable
    {
        private readonly CancellationTokenSource _cts;
        private readonly AutoResetEvent _event;
        private readonly ConcurrentQueue<string> _queue;

        #region Constructors

        private LoggerWriter()
        {
            _cts = new CancellationTokenSource();
            _event = new AutoResetEvent(false);
            _queue = new ConcurrentQueue<string>();
        }

        public static LoggerWriter Create()
        {
            var writer = new LoggerWriter();
            Task.Factory.StartNew(writer.WriteAsync, TaskCreationOptions.LongRunning);
            return writer;
        }

        #endregion

        #region Methods

        public void Enqueue(string value)
        {
            _queue.Enqueue(value);
            _event.Set();
        }

        private async Task WriteAsync()
        {
            await using var fileStream = File.Open("Tanya.log", FileMode.Append, FileAccess.Write, FileShare.ReadWrite);
            await using var writer = new StreamWriter(fileStream);

            var isDebugging = Debugger.IsAttached;
            var events = new[] { _event, _cts.Token.WaitHandle };

            while (WaitHandle.WaitAny(events) == 0)
            {
                while (_queue.TryDequeue(out var value))
                {
                    if (isDebugging) Console.WriteLine(value);
                    await writer.WriteLineAsync(value).ConfigureAwait(false);
                    await writer.FlushAsync().ConfigureAwait(false);
                }
            }
        }

        #endregion

        #region Implementation of IDisposable

        public void Dispose()
        {
            _cts.Cancel();
            _event.Dispose();
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}
```

`src/Tanya/Program.cs`:

```cs
using Microsoft.Extensions.Hosting;
using Tanya;

await Host.CreateDefaultBuilder(args)
    .UseSystemd()
    .ConfigureLogging(Startup.ConfigureLogging)
    .ConfigureServices(Startup.ConfigureServices)
    .RunConsoleAsync().ConfigureAwait(false);
```

`src/Tanya/Startup.cs`:

```cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Logging;
using Tanya.Driver.Linux;
using Tanya.Game.Apex;
using Tanya.Logging;

namespace Tanya
{
    public static class Startup
    {
        #region Statics

        public static void ConfigureLogging(ILoggingBuilder builder)
        {
            builder.ClearProviders();
            builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<ILoggerProvider, LoggerProvider>());
        }

        public static void ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton<Linux>();
            Bootstrap.ConfigureServices(services);
        }

        #endregion
    }
}
```

`src/Tanya/Tanya.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <OutputType>Exe</OutputType>
    <ServerGarbageCollection>false</ServerGarbageCollection>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="6.0.1" />
    <PackageReference Include="Microsoft.Extensions.Hosting.Systemd" Version="6.0.0" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Tanya.Core\Tanya.Core.csproj" />
    <ProjectReference Include="..\Tanya.Driver.Linux\Tanya.Driver.Linux.csproj" />
    <ProjectReference Include="..\Tanya.Driver\Tanya.Driver.csproj" />
    <ProjectReference Include="..\Tanya.Game.Apex\Tanya.Game.Apex.csproj" />
  </ItemGroup>
  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>
```

`src/Tanya/appsettings.json`:

```json
{
  "Tanya.Game.Apex": {
    "framesPerSecond": 30,
    "offsetsCheck": 5000,
    "offsetsRefresh": 3600000,
    "offsetsUrl": "https://pastebin.com/raw/y3XP9i2m",
    "processRefresh": 15000
  },
  "Tanya.Game.Apex.Feature.Aim": {
    "distance": 200,
    "lockTime": 300,
    "pitchAngle": 10,
    "pitchDeadzone": 15,
    "pitchSpeed": 0.3,
    "recoil": 0.95,
    "releaseTime": 300,
    "yawAngle": 30,
    "yawDeadzone": 5,
    "yawSpeed": 0.85
  },
  "Tanya.Game.Apex.Feature.Sense": {
    "distance": 200
  }
}
```