Project Path: arc_gmh5225_obj2shellcode_gd8jlkj5

Source Tree:

```txt
arc_gmh5225_obj2shellcode_gd8jlkj5
├── README.md
├── obj-shellcode
│   ├── bin
│   │   ├── obj-shellcode_Win32_Debug.exe
│   │   ├── payload.hpp
│   │   ├── payload_Debug_Win32.lib
│   │   ├── run_Debug_Win32.exe
│   │   └── shellcode-payload.bin
│   ├── include
│   │   ├── lib.h
│   │   ├── misc.hpp
│   │   ├── rang.hpp
│   │   ├── rang_impl.hpp
│   │   └── span.hpp
│   ├── obj-shellcode.sln
│   ├── obj-shellcode.vcxproj
│   ├── obj-shellcode.vcxproj.filters
│   ├── obj-shellcode.vcxproj.user
│   └── src
│       ├── lib.cpp
│       └── main.cpp
├── payload
│   ├── call-extern-demo.cpp
│   ├── framework.h
│   ├── lazy_importer.hpp
│   ├── payload.cpp
│   ├── payload.vcxproj
│   ├── payload.vcxproj.filters
│   ├── payload.vcxproj.user
│   ├── pch.cpp
│   ├── pch.h
│   ├── shellcode.h
│   └── xorstr.hpp
└── run
    ├── main.cpp
    ├── run.vcxproj
    ├── run.vcxproj.filters
    └── run.vcxproj.user

```

`README.md`:

```md
# obj2shellcode

基于[shellcode-factory](https://github.com/lainswork/shellcode-factory)

## 新增特性

支持编译32位shellcode

支持使用全局字符串（64位依旧不支持，重定位类型为IMAGE_REL_AMD64_ADDR64（１）)

## 注意事项(项目已经设置好)

- 编译payload时设置LAZY_IMPORTER_HARDENED_MODULE_CHECKS预定义宏,设置lazy_importer模块检查

-  32位shellcode需要自修补重定位,所以shellcode内存需要有可写权限

- 需要开启优化

- 32位 CHAR buf[512] = { 0 }会调用c库函数_memset, 64位使用rep指令
  所以32位不应这样初始化，需显示调用LI_FN(memset)或者使用宏SecureZeroMemory

## 文件说明

obj-shellcode: 解析并提取shellcode

payload：shellcode 编写模板

run：shellcode测试加载器

---------------------------------------分割线-------------------------------------------

# [shellcode-factory](https://github.com/lainswork/shellcode-factory)

## 一个简单`shellcode`生成框架，使用后可以变得开心。（开发中...）

[![LICENSE](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![](https://img.shields.io/badge/OS-any-brightgreen)]()
[![](https://img.shields.io/badge/compiler-any-brightgreen)]()

<br />

# shellcode特点

> 位置无关，在执行或注入前无需进行任何额外的处理。

> 简洁小巧，可以轻松的在不同的功能中实现通用的功能。

# 更新

> - 加入了DWM屏幕截图 demo
> - 更新了一些bug 现在框架能作为生产工具安全使用 

# 使用方法

```shell
// 确保你已经安装了VS2019或以上 Make sure u have installed Visual Studio 2019 or later version
// 打开PowerShell并进入一个为项目准备的文件夹,依次输入以下命令, Enter the following commands in PowerShell

> git clone https://github.com/lainswork/shellcode-factory.git

> cd shellcode-factory

> devenv shellcode-factory.sln /build "Debug|x64" /Project shellcode-generator

> cd ./x64/Debug

> .\shellcode-generator

// 现在你得到了 ./x64/Debug/payload.hpp     Now, u get ./x64/Debug/payload.hpp
```

> MessageBox演示

![image](https://user-images.githubusercontent.com/36320938/159157628-21b95fcc-cb2c-409f-ad04-dbb889efc735.png)

> dwm截屏演示

https://user-images.githubusercontent.com/46841563/159622629-b337380b-7ca2-4f3a-b043-d278be75a08f.mp4

# 起因与经过

21年中旬朋友在windows的dwm进程中发现一段异常执行的 "恶意代码",
在使用ida进行简单分析后得出结论：“该代码在dwm中 hook 相关渲染函数，恶意截取用户桌面画面”。
这段代码的来源指向了一款曾在2017年爆火网络的多人射击游戏，我们猜测其目的为：“截取用户游戏画面以判断用户是否在作弊”。
该shellcode引起了我的兴趣，它大概有如下特点：
|  data types | ranges  |
| ------- | ------- |
| .api  | 0x0000 - 0x1D00 |
| .text | 0x1D00 - 0x2100 |
| .data | 0x2100 - 0x5000 |

在这个shellcode中，存在一些只会被链接进exe的清单文件，我猜测：“该shellcode的开发者先使用编译器编译并链接了一个不带crt的exe
之后对该exe进行加壳，最后使用exe to shellcode类的工具生成该代码。”

# 反思

类似的 shellcode 的生成过程似乎不是很可靠 (将无意义的清单文件留存在shellcode中与我们编写shellcode的目的相背离)，好奇心驱使下，我搜寻了 windows 下 的 shellcode 编写方法,结果不如人意。  
有的人使用dll to shellcode框架或工具
有的人直接在c++代码中写下两个“标记函数”，之后将两个“标记函数”地址之间的bytes复制出来。
下面是一些常见的框架：

[Cobalt Strike 生成 shellcode](https://bbs.pediy.com/thread-271048.htm)

[MSVC 配合 Get-PEHeader生成shellcode](https://zeronohacker.com/1544.html)

[Win PE系列之导出表解析与ShellCode的编写及应用](https://bbs.pediy.com/thread-269753.htm)

[基于C++的shellcode框架](https://bbs.pediy.com/thread-268639.htm)

我的目标是建立一个可以满足如下条件的shellcode生成框架：
<<<<<<< HEAD

* 不要让我用二进制编辑器来手动提取bytes
* 它应该有扩展的可能性
* 生成的shellcode应该与位置无关，在使用时只需要进行： 映射-执行
* 要能使用全局变量（静态变量），因为我们可能使用静态字符串
* 尽可能的支持新的c++标准

我们可以选择从编译链接入手，但是徒手撸编译器太难了，撸个小链接器却很容易
=======

```sh
1.不要让我用二进制编辑器来手动提取bytes
2.它应该有扩展的可能性
3.生成的shellcode应该与位置无关，在使用时只需要进行： 映射-执行
4.要能使用全局变量（静态变量），因为我们可能使用静态字符串
5.尽可能的支持新的c++标准
```

# 原理

### coff

coff全称 通用对象文件格式(Common Object File Format)，我们常用的PE（exe，dll，sys，lib，obj）文件都属于coff，但我们这里要说的，是lib。  
当我们在VS中将编译目标设置为lib时，.lib文件其实是个.obj文件的文件包，其中包含了你编译的所有.obj文件（也就是我们c++源代码.cpp所编译后的文件）。

### obj

.obj是 coff的一种，obj文件中包含我们编写的源代码编译后的字节码，其中包含了极其详细的符号信息：每个函数的名称、函数的字节码、静态数据的字节码、重定位信息、等等。

### shellcode 链接方法

其实我们要做的事情很简单，将所有bytes从obj中提取出来，对相对寻址进行重定位就可以生成我们要的shellcode

# payload 代码

> 使用 SC_EXPORT 标志公开函数

```C++
SC_EXPORT 
DWORD ShellCodeEntryPoint(LPVOID lpParameter) {
    CHAR buf[256] = {0};
    LI_FN(sprintf)(buf, xorstr_( "函数%s 线程参数0x%p"), __FUNCDNAME__, lpParameter);
    LI_FN(MessageBoxA)(HWND(0), buf, xorstr_("来自shellcode的展示"), MB_OK);
    return 0;
}

SC_EXPORT 
DWORD ShellCodeEntryPoint2(LPVOID lpParameter) {
    CHAR buf[256] = {0};
    LI_FN(sprintf)(buf, xorstr_("函数%s 线程参数0x%p"), __FUNCDNAME__, lpParameter);
    LI_FN(MessageBoxA)(HWND(0), buf, xorstr_("来自shellcode的展示"), MB_OK);
    return 0;
}

SC_EXPORT
DWORD ShellCodeEntryPoint3(LPVOID lpParameter) {
    CHAR buf[256] = {0};
    LI_FN(sprintf)(buf,xorstr_( "函数%s 线程参数0x%p"), __FUNCDNAME__, lpParameter);
    LI_FN(MessageBoxA)(HWND(0), buf, xorstr_("来自shellcode的展示"), MB_OK);
    return 0;
}
```

> 使用 SC_EXPORT_DATA 公开全局变量 不要在 .h 中使用SC_EXPORT_DATA

```C++
SC_EXPORT_DATA(int, Xxxx)
```

> 使用内嵌函数 内嵌函数的具体规则请自己查询, 

```C++
//使用内嵌函数 这个东西只在本cpp起作用，不要写在.h里面 写在每个cpp的最开头部分
extern "C" {
#pragma function(memset)
void *__cdecl memset(void *dest, int value, size_t num) {
    __stosb(static_cast<unsigned char *>(dest), static_cast<unsigned char>(value), num);
    return dest;
}
#pragma function(memcpy)
void *__cdecl memcpy(void *dest, const void *src, size_t num) {
    __movsb(static_cast<unsigned char *>(dest), static_cast<const unsigned char *>(src), num);
    return dest;
}
}
```

##### 你可以在 payload 中做什么:

- 使用新标准的c++代码，包括但不限于初始化列表、Lamda表达式、模板函数

- 使用多个.cpp文件，这代表你可以将不同的代码写在不同的cpp中

- 使用字符串、全局变量、导出全局变量相对shellcode的偏移

- 使用面向对象与C++ STL模板

- 使用开源库[xorstr](https://github.com/JustasMasiulis/xorstr) ,加密常量字符串

##### 你无法在 payload 中使用什么:

- 不要使用全局初始化，因为shellcode不能进行 CRT init

- 无法直接调用 系统API（这将在本框架优化后解决），暂时的调用api方法是 使用lazy_importer

- 无法使用 __declspec(thread) Tls线程局部储存关键字（但可以使用windows apiTlsAlloc TlsSetValue TlsGetValue）来解决

- 异常 try catch (没啥用，请忽略)

- SDL检查(没啥用，请忽略)

- 基本运行时检查(没啥用，请忽略)

# 依赖

- [lazy_importer](https://github.com/JustasMasiulis/lazy_importer)
  
  # 优势

- 开启C++优化 /O1

- 开发方便
  
  # 缺陷:
  
  ### 该框架只支持 X64
  
  原因是目前没有好办法解决x86下的.data数据重定位问题，在x86下.data数据重定位类型为IMAGE_REL_I386_DIR32，意为"RVA 绝对虚拟地址"
  但是假如你不在代码中使用静态字符串或者全局变量，你仍然可以使用x86编译 shellcode-payload.lib，并用 x86 shellcode-generator.exe生成相应的代码

对x86的支持，后面可能会通过硬编码插入来解决

# Todo:

修改api导入策略，摆脱lazy_importer，实现可以在payload中直接使用api函数和crt函数的方法。

实现链接时混淆和虚拟化，这样我们可以将shellcode-generator(链接生成器)作为服务器功能，将payload.lib储存于服务器，每次执行shellcode获取都会生成完全不同的代码。（这个比较困难）

```mermaid
graph TB
    di{C/C++ project <br/> shellcode-payload.lib} --> sq[shellcode-generator.exe]

    sq[shellcode-generator.exe]--> e0((Vm/Obfuscator))-.->f0(shellcode 1)
    sq[shellcode-generator.exe]--> e1((Vm/Obfuscator))-.-> f1(shellcode 2)
    sq[shellcode-generator.exe]--> e2((Vm/Obfuscator))-.->f2(shellcode 3)
    sq[shellcode-generator.exe]--> e3((Vm/Obfuscator))-.-> f3(shellcode 4)
    sq[shellcode-generator.exe]--> e4((Vm/Obfuscator))-.->f4(shellcode 5)
    sq[shellcode-generator.exe]--> e5((Vm/Obfuscator))-.-> f..(shellcode ...)
```

```

`obj-shellcode/bin/payload.hpp`:

```hpp
#pragma once
#include <cstdint>
namespace shellcode
{
namespace rva
{
const size_t CaptureWidth = 0x4;
const size_t ShellcodeFunctionEntryPointExample = 0x14;
const size_t CaptureHeight = 0x8;
const size_t Seven00 = 0xc;
const size_t fix = 0xe35;

}

unsigned char payload [] = 
	{
	
0xde,0xc0,0xad,0xde,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x8b,0xec,0x81,0xec,0x0c,0x02,0x00,0x00,0xa1,0xdf,0x00,0x00,0x00,0x56,0x83,0xc0,0x03,0x50,0xff,0x75,0x08,0x68,0xe3,0x00,0x00,0x00,0xe8,0xe4,0x00,0x00,0x00,0x8d,0x85,0xf4,0xfd,0xff,0xff,0x68,0x00,0x02,0x00,0x00,0x50,0xe8,0x13,0x05,0x00,0x00,0x83,0xc4,0x14,0x8d,0x45,0x08,0x8d,0x4d,0xff,0x68,0x6e,
0x05,0x00,0x00,0x50,0x68,0x91,0x05,0x00,0x00,0x8d,0x85,0xf4,0xfd,0xff,0xff,0x50,0xe8,0x6f,0x05,0x00,0x00,0x83,0x65,0xf4,0x00,0x8d,0x45,0xf8,0x50,0x68,0xc9,0x06,0x00,0x00,0x8d,0x85,0xf4,0xfd,0xff,0xff,0xc7,0x45,0xf8,0x00,0x00,0x04,0x00,0x50,0x8d,0x45,0xf4,0x50,0x8d,0x4d,0xff,0xe8,0x58,0x06,0x00,0x00,0x68,0xea,0x07,0x00,0x00,0x68,0xee,0x07,0x00,0x00,0x8d,0x4d,0xff,0xe8,0x63,0x07,0x00,0x00,0x68,0xe2,
0x07,0x00,0x00,0xbe,0xf7,0x08,0x00,0x00,0x8d,0x4d,0xff,0x56,0xe8,0x59,0x08,0x00,0x00,0x68,0xe6,0x07,0x00,0x00,0x56,0x8d,0x4d,0xff,0xe8,0x1d,0x09,0x00,0x00,0xe8,0xea,0x09,0x00,0x00,0x6a,0x03,0x5e,0xe8,0x48,0x0b,0x00,0x00,0x83,0xee,0x01,0x75,0xf6,0x68,0x22,0x0d,0x00,0x00,0x8d,0x4d,0xff,0xe8,0x54,0x0c,0x00,0x00,0x33,0xc0,0x5e,0xc9,0xc3,0x69,0x00,0x00,0x00,0x5b,0x20,0x70,0x61,0x79,0x6c,0x6f,0x61,0x64,
0x20,0x5d,0x54,0x68,0x72,0x65,0x61,0x64,0x20,0x6c,0x70,0x50,0x61,0x72,0x61,0x6d,0x65,0x74,0x65,0x72,0x20,0x25,0x64,0x09,0x20,0x2d,0x2d,0x6c,0x69,0x6e,0x65,0x3a,0x20,0x25,0x30,0x35,0x64,0x20,0x0a,0x00,0x55,0x8b,0xec,0x81,0xec,0x0c,0x02,0x00,0x00,0x83,0x65,0xf4,0x00,0x8d,0x45,0xf8,0x50,0x8d,0x45,0xf4,0xc7,0x45,0xf8,0x00,0x02,0x00,0x00,0x50,0x8d,0x85,0xf4,0xfd,0xff,0xff,0x50,0x8d,0x4d,0xff,0xe8,0x2c,
0x00,0x00,0x00,0x8d,0x45,0x10,0x50,0x8d,0x45,0x0c,0x50,0x8d,0x45,0x08,0x50,0x8d,0x85,0xf4,0xfd,0xff,0xff,0x50,0x8d,0x4d,0xff,0xe8,0x2f,0x02,0x00,0x00,0x8d,0x85,0xf4,0xfd,0xff,0xff,0x50,0x8d,0x4d,0xff,0xe8,0x27,0x03,0x00,0x00,0xc9,0xc3,0x55,0x8b,0xec,0x56,0x57,0xe8,0x2f,0x00,0x00,0x00,0xff,0x75,0x10,0x8b,0xf8,0xe8,0xf2,0x01,0x00,0x00,0xff,0x75,0x0c,0x8b,0x30,0xe8,0xf0,0x01,0x00,0x00,0x59,0x59,0x56,
0x8b,0x08,0x51,0xff,0x75,0x08,0xe8,0xea,0x01,0x00,0x00,0x59,0x50,0xff,0xd7,0x83,0xc4,0x0c,0x5f,0x5e,0x5d,0xc2,0x0c,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0x9a,0x00,0x00,0x00,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0xa3,0x00,0x00,0x00,0x8d,0x4d,0xf0,0xe8,0xd4,0x00,0x00,0x00,0x84,0xc0,0x74,0x4e,
0x8d,0x4d,0xf0,0xe8,0xd1,0x00,0x00,0x00,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0x0c,0x6c,0x71,0x17,0x68,0x8b,0x78,0xf9,0x90,0xe8,0xc3,0x00,0x00,0x00,0x68,0x0c,0x6c,0x71,0x17,0x68,0x8b,0x78,0xf9,0x90,0x8b,0xf8,0xe8,0xba,0x00,0x00,0x00,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0xb2,0x00,0x00,0x00,0x50,0xe8,0xc6,0x00,0x00,0x00,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,
0xfc,0xe8,0x06,0x01,0x00,0x00,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0x01,0x01,0x00,0x00,0xeb,0xf0,0x56,0x8b,0xf1,0xe8,0x06,0x00,0x00,0x00,0x89,0x06,0x8b,0xc6,0x5e,0xc3,0xe8,0x04,0x00,0x00,0x00,0x8b,0x40,0x0c,0xc3,0xe8,0x04,0x00,0x00,0x00,0x8b,0x40,0x0c,0xc3,0x64,0xa1,0x30,0x00,0x00,0x00,0xc3,0x55,0x8b,0xec,0x53,0x56,0x8b,0xd9,0x57,0x8b,
0x7d,0x08,0x57,0x89,0x3b,0xe8,0x19,0x00,0x00,0x00,0x59,0x8b,0x50,0x78,0x8b,0x70,0x7c,0x89,0x73,0x08,0x8d,0x04,0x3a,0x5f,0x89,0x43,0x04,0x8b,0xc3,0x5e,0x5b,0x5d,0xc2,0x04,0x00,0x55,0x8b,0xec,0x8b,0x4d,0x08,0x8b,0x41,0x3c,0x03,0xc1,0x5d,0xc3,0x8b,0x41,0x04,0x3b,0x01,0x0f,0x95,0xc0,0xc3,0x8b,0x41,0x04,0x8b,0x40,0x18,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x0c,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,
0x55,0x8b,0xec,0x8b,0x41,0x04,0x8b,0x11,0x8b,0x48,0x20,0x8b,0x45,0x08,0x8d,0x04,0x81,0x8b,0x04,0x10,0x03,0xc2,0x5d,0xc2,0x04,0x00,0x55,0x8b,0xec,0x8b,0x55,0x0c,0x56,0x8b,0x75,0x08,0x8a,0x06,0x46,0x88,0x45,0x0c,0x84,0xc0,0x74,0x17,0xff,0x75,0x0c,0x52,0xe8,0x13,0x00,0x00,0x00,0x59,0x59,0x8a,0x0e,0x8b,0xd0,0x46,0x88,0x4d,0x0c,0x84,0xc9,0x75,0xe9,0x8b,0xc2,0x5e,0x5d,0xc3,0x55,0x8b,0xec,0x8a,0x4d,0x0c,
0x0f,0xbe,0xd1,0x80,0xe9,0x41,0x8b,0xc2,0x83,0xc8,0x20,0x80,0xf9,0x19,0x0f,0x47,0xc2,0x33,0x45,0x08,0x69,0xc0,0x93,0x01,0x00,0x01,0x5d,0xc3,0x56,0x8b,0xf1,0x8b,0x0e,0xe8,0x06,0x00,0x00,0x00,0x89,0x06,0xb0,0x01,0x5e,0xc3,0x8b,0x01,0xc3,0x55,0x8b,0xec,0x8b,0x51,0x04,0x8b,0x45,0x08,0x56,0x8b,0x31,0x8b,0x4a,0x24,0x8d,0x04,0x41,0x0f,0xb7,0x0c,0x30,0x8b,0x42,0x1c,0x8d,0x04,0x88,0x8b,0x04,0x30,0x03,0xc6,
0x5e,0x5d,0xc2,0x04,0x00,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x53,0x56,0x57,0xe8,0x3c,0x00,0x00,0x00,0xff,0x75,0x14,0x8b,0xd8,0xe8,0xda,0x00,0x00,0x00,0xff,0x75,0x10,0x8b,0x38,0xe8,0xd8,0x00,0x00,0x00,0xff,0x75,0x0c,0x8b,0x30,0xe8,0xd6,0x00,0x00,0x00,0x83,0xc4,0x0c,0x8b,0x00,0x57,0x56,0x50,0xff,0x75,
0x08,0xe8,0xbf,0xff,0xff,0xff,0x59,0x50,0xff,0xd3,0x83,0xc4,0x10,0x5f,0x5e,0x5b,0x5d,0xc2,0x10,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0x6e,0xfe,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0x77,0xfe,0xff,0xff,0x8d,0x4d,0xf0,0xe8,0xa8,0xfe,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,
0xa5,0xfe,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0x02,0x7c,0x74,0x9c,0x68,0x8c,0x84,0xb8,0xa0,0xe8,0x97,0xfe,0xff,0xff,0x68,0x02,0x7c,0x74,0x9c,0x68,0x8c,0x84,0xb8,0xa0,0x8b,0xf8,0xe8,0x8e,0xfe,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0x86,0xfe,0xff,0xff,0x50,0xe8,0x9a,0xfe,0xff,0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0xda,0xfe,
0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0xd5,0xfe,0xff,0xff,0xeb,0xf0,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x56,0xe8,0x13,0x00,0x00,0x00,0xff,0x75,0x08,0x8b,0xf0,0xe8,0xde,0xfe,0xff,0xff,0x59,0x50,0xff,0xd6,0x5e,0x5d,0xc2,0x04,0x00,
0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0x92,0xfd,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0x9b,0xfd,0xff,0xff,0x8d,0x4d,0xf0,0xe8,0xcc,0xfd,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,0xc9,0xfd,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0xcd,0x10,0x79,0xab,0x68,0x5d,0x4a,0xce,0x93,
0xe8,0xbb,0xfd,0xff,0xff,0x68,0xcd,0x10,0x79,0xab,0x68,0x5d,0x4a,0xce,0x93,0x8b,0xf8,0xe8,0xb2,0xfd,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0xaa,0xfd,0xff,0xff,0x50,0xe8,0xbe,0xfd,0xff,0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0xfe,0xfd,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,
0xf0,0xe8,0xf9,0xfd,0xff,0xff,0xeb,0xf0,0x55,0x8b,0xec,0x8b,0x55,0x0c,0x8b,0x45,0x08,0x8b,0xc8,0x85,0xd2,0x74,0x09,0xc6,0x01,0x00,0x41,0x83,0xea,0x01,0x75,0xf7,0x5d,0xc3,0x53,0x68,0x65,0x6c,0x6c,0x63,0x6f,0x64,0x65,0x46,0x75,0x6e,0x63,0x74,0x69,0x6f,0x6e,0x45,0x6e,0x74,0x72,0x79,0x50,0x6f,0x69,0x6e,0x74,0x45,0x78,0x61,0x6d,0x70,0x6c,0x65,0x00,0x48,0x65,0x6c,0x6c,0x6f,0x20,0x54,0x68,0x65,0x20,0x74,
0x68,0x72,0x65,0x61,0x64,0x20,0x70,0x61,0x72,0x61,0x6d,0x65,0x74,0x65,0x72,0x20,0x69,0x73,0x20,0x30,0x78,0x25,0x70,0x20,0x61,0x6e,0x64,0x20,0x54,0x68,0x65,0x20,0x66,0x75,0x6e,0x63,0x74,0x69,0x6f,0x6e,0x20,0x6e,0x61,0x6d,0x65,0x20,0x69,0x73,0x20,0x25,0x73,0x00,0x55,0x8b,0xec,0x56,0x57,0xe8,0x37,0x00,0x00,0x00,0xff,0x75,0x10,0x8b,0xf8,0xe8,0x9c,0xfe,0xff,0xff,0xff,0x75,0x14,0x8b,0x30,0xe8,0xcb,0x00,
0x00,0x00,0x59,0x59,0x50,0x56,0xff,0x75,0x0c,0xe8,0xc7,0x00,0x00,0x00,0x59,0x50,0xff,0x75,0x08,0xe8,0x7d,0xfd,0xff,0xff,0x59,0x50,0xff,0xd7,0x83,0xc4,0x10,0x5f,0x5e,0x5d,0xc2,0x10,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0x2d,0xfc,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0x36,0xfc,0xff,
0xff,0x8d,0x4d,0xf0,0xe8,0x67,0xfc,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,0x64,0xfc,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0x43,0x27,0x40,0x20,0x68,0x03,0x88,0x46,0x00,0xe8,0x56,0xfc,0xff,0xff,0x68,0x43,0x27,0x40,0x20,0x68,0x03,0x88,0x46,0x00,0x8b,0xf8,0xe8,0x4d,0xfc,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0x45,0xfc,0xff,0xff,0x50,0xe8,0x59,0xfc,0xff,
0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0x99,0xfc,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0x94,0xfc,0xff,0xff,0xeb,0xf0,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x44,0x69,0x73,0x70,0x6c,0x61,0x79,0x20,0x66,0x72,0x6f,0x6d,0x20,0x73,0x68,0x65,0x6c,0x6c,0x63,
0x6f,0x64,0x65,0x00,0x55,0x8b,0xec,0x53,0x56,0x57,0xe8,0x37,0x00,0x00,0x00,0xff,0x75,0x14,0x8b,0xd8,0xe8,0xd5,0x00,0x00,0x00,0xff,0x75,0x08,0x8b,0x30,0xe8,0xd3,0x00,0x00,0x00,0x59,0x59,0x56,0xff,0x75,0x10,0x8b,0x38,0xe8,0xce,0x00,0x00,0x00,0x59,0x50,0xff,0x75,0x0c,0xe8,0x6b,0xfc,0xff,0xff,0x59,0x50,0x57,0xff,0xd3,0x5f,0x5e,0x5b,0x5d,0xc2,0x10,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,
0x1c,0xfb,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0x25,0xfb,0xff,0xff,0x8d,0x4d,0xf0,0xe8,0x56,0xfb,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,0x53,0xfb,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0x0a,0x0e,0x32,0x7a,0x68,0xed,0xf7,0x56,0x90,0xe8,0x45,0xfb,0xff,0xff,0x68,0x0a,0x0e,0x32,0x7a,
0x68,0xed,0xf7,0x56,0x90,0x8b,0xf8,0xe8,0x3c,0xfb,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0x34,0xfb,0xff,0xff,0x50,0xe8,0x48,0xfb,0xff,0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0x88,0xfb,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0x83,0xfb,0xff,0xff,0xeb,0xf0,0x55,0x8b,
0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0xdf,0x08,0x00,0x00,0xea,0x08,0x00,0x00,0x41,0x41,0x41,0x00,0x67,0x6c,0x6f,0x62,0x61,0x6c,0x56,0x61,0x72,0x3a,0x20,0x25,0x64,0x0a,0x00,0x55,0x8b,0xec,0x56,0xe8,0x21,0x00,0x00,0x00,0xff,0x75,0x0c,0x8b,0xf0,0xe8,0xbf,0x00,0x00,0x00,0x59,0x8b,0x08,0x51,0xff,0x75,0x08,0xe8,0xbb,0x00,0x00,0x00,
0x59,0x50,0xff,0xd6,0x59,0x59,0x5e,0x5d,0xc2,0x08,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0x17,0xfa,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0x20,0xfa,0xff,0xff,0x8d,0x4d,0xf0,0xe8,0x51,0xfa,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,0x4e,0xfa,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,
0x40,0x68,0xf5,0x39,0x37,0xe9,0x68,0xfa,0xb3,0x38,0x0f,0xe8,0x40,0xfa,0xff,0xff,0x68,0xf5,0x39,0x37,0xe9,0x68,0xfa,0xb3,0x38,0x0f,0x8b,0xf8,0xe8,0x37,0xfa,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0x2f,0xfa,0xff,0xff,0x50,0xe8,0x43,0xfa,0xff,0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0x83,0xfa,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,
0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0x7e,0xfa,0xff,0xff,0xeb,0xf0,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x68,0x65,0x6c,0x6c,0x6f,0x77,0x6f,0x72,0x6c,0x64,0x00,0xc4,0xe3,0xba,0xc3,0xd6,0xd0,0xb9,0xfa,0xa3,0xba,0xa1,0xb7,0x00,0x67,0x6c,0x6f,0x62,0x61,0x6c,0x53,0x74,0x72,0x3a,0x20,0x25,0x73,0x0a,0x00,0x55,0x8b,0xec,0x56,0xe8,0x21,
0x00,0x00,0x00,0xff,0x75,0x0c,0x8b,0xf0,0xe8,0x6f,0xfb,0xff,0xff,0x59,0x8b,0x08,0x51,0xff,0x75,0x08,0xe8,0xb2,0xff,0xff,0xff,0x59,0x50,0xff,0xd6,0x59,0x59,0x5e,0x5d,0xc2,0x08,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0x0e,0xf9,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0x17,0xf9,0xff,0xff,
0x8d,0x4d,0xf0,0xe8,0x48,0xf9,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,0x45,0xf9,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0xfb,0x12,0x35,0xf8,0x68,0xa4,0x74,0x3c,0x58,0xe8,0x37,0xf9,0xff,0xff,0x68,0xfb,0x12,0x35,0xf8,0x68,0xa4,0x74,0x3c,0x58,0x8b,0xf8,0xe8,0x2e,0xf9,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0x26,0xf9,0xff,0xff,0x50,0xe8,0x3a,0xf9,0xff,0xff,
0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0x7a,0xf9,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0x75,0xf9,0xff,0xff,0xeb,0xf0,0x55,0x8b,0xec,0x56,0xe8,0x21,0x00,0x00,0x00,0xff,0x75,0x0c,0x8b,0xf0,0xe8,0x9d,0xfa,0xff,0xff,0x59,0x8b,0x08,0x51,0xff,0x75,0x08,0xe8,0xe0,0xfe,0xff,0xff,0x59,0x50,0xff,0xd6,0x59,
0x59,0x5e,0x5d,0xc2,0x08,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0x3c,0xf8,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0x45,0xf8,0xff,0xff,0x8d,0x4d,0xf0,0xe8,0x76,0xf8,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,0x73,0xf8,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0xad,0x96,0x3c,
0x77,0x68,0x52,0x3b,0xf7,0x69,0xe8,0x65,0xf8,0xff,0xff,0x68,0xad,0x96,0x3c,0x77,0x68,0x52,0x3b,0xf7,0x69,0x8b,0xf8,0xe8,0x5c,0xf8,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0x54,0xf8,0xff,0xff,0x50,0xe8,0x68,0xf8,0xff,0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0xa8,0xf8,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,
0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0xa3,0xf8,0xff,0xff,0xeb,0xf0,0x55,0x8b,0xec,0x83,0xec,0x0c,0x83,0x65,0xf4,0x00,0x8d,0x45,0xf8,0x50,0x68,0xd7,0x0a,0x00,0x00,0x68,0xef,0x0a,0x00,0x00,0x8d,0x45,0xf4,0xc7,0x45,0xf8,0x00,0x00,0x04,0x00,0x50,0x8d,0x4d,0xff,0xe8,0x41,0x00,0x00,0x00,0xc9,0xc3,0x44,0x69,0x73,0x70,0x6c,0x61,0x79,0x20,0x66,0x72,0x6f,0x6d,0x20,0x73,0x68,0x65,0x6c,0x6c,0x63,0x6f,0x64,
0x65,0x21,0x00,0x53,0x68,0x65,0x6c,0x6c,0x63,0x6f,0x64,0x65,0x20,0x46,0x75,0x6e,0x63,0x74,0x69,0x6f,0x6e,0x20,0x43,0x61,0x6c,0x6c,0x20,0x45,0x78,0x74,0x65,0x72,0x6e,0x20,0x45,0x78,0x61,0x6d,0x70,0x6c,0x65,0x00,0x55,0x8b,0xec,0x53,0x56,0x57,0xe8,0x37,0x00,0x00,0x00,0xff,0x75,0x14,0x8b,0xd8,0xe8,0x9f,0xfc,0xff,0xff,0xff,0x75,0x08,0x8b,0x30,0xe8,0x9d,0xfc,0xff,0xff,0x59,0x59,0x56,0xff,0x75,0x10,0x8b,
0x38,0xe8,0xbe,0x00,0x00,0x00,0x59,0x50,0xff,0x75,0x0c,0xe8,0xbc,0x00,0x00,0x00,0x59,0x50,0x57,0xff,0xd3,0x5f,0x5e,0x5b,0x5d,0xc2,0x10,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0xe6,0xf6,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0xef,0xf6,0xff,0xff,0x8d,0x4d,0xf0,0xe8,0x20,0xf7,0xff,0xff,
0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,0x1d,0xf7,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0x3d,0xc7,0xfa,0xe4,0x68,0x3c,0x11,0xf0,0x5b,0xe8,0x0f,0xf7,0xff,0xff,0x68,0x3d,0xc7,0xfa,0xe4,0x68,0x3c,0x11,0xf0,0x5b,0x8b,0xf8,0xe8,0x06,0xf7,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0xfe,0xf6,0xff,0xff,0x50,0xe8,0x12,0xf7,0xff,0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,
0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0x52,0xf7,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0x4d,0xf7,0xff,0xff,0xeb,0xf0,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x55,0x8b,0xec,0x51,0x51,0xa1,0x0c,0x00,0x00,0x00,0x8d,0x4d,0xff,0x89,0x45,0xf8,0x40,0xa3,0x0c,0x00,0x00,0x00,0x8d,0x45,0xf8,0x50,0x68,0x36,
0x0c,0x00,0x00,0xe8,0x14,0x00,0x00,0x00,0xc9,0xc3,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x76,0x61,0x6c,0x75,0x65,0x3a,0x20,0x25,0x64,0x0a,0x00,0x55,0x8b,0xec,0x56,0xe8,0x21,0x00,0x00,0x00,0xff,0x75,0x0c,0x8b,0xf0,0xe8,0x1e,0xf7,0xff,0xff,0x59,0x8b,0x08,0x51,0xff,0x75,0x08,0xe8,0xb3,0x00,0x00,0x00,0x59,0x50,0xff,0xd6,0x59,0x59,0x5e,0x5d,0xc2,0x08,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,
0xcc,0xf5,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0xd5,0xf5,0xff,0xff,0x8d,0x4d,0xf0,0xe8,0x06,0xf6,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,0xe8,0x03,0xf6,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0xb9,0x1e,0x31,0x71,0x68,0x16,0x41,0x50,0xcb,0xe8,0xf5,0xf5,0xff,0xff,0x68,0xb9,0x1e,0x31,0x71,
0x68,0x16,0x41,0x50,0xcb,0x8b,0xf8,0xe8,0xec,0xf5,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0xe4,0xf5,0xff,0xff,0x50,0xe8,0xf8,0xf5,0xff,0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0x38,0xf6,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0x33,0xf6,0xff,0xff,0xeb,0xf0,0x55,0x8b,
0xec,0x8b,0x45,0x08,0x5d,0xc3,0x6c,0x61,0x6d,0x62,0x64,0x61,0x20,0x74,0x65,0x73,0x74,0x00,0x55,0x8b,0xec,0x51,0x8d,0x45,0x08,0x50,0x68,0x47,0x0d,0x00,0x00,0x8d,0x4d,0xff,0xe8,0x14,0x00,0x00,0x00,0xc9,0xc2,0x04,0x00,0x6c,0x61,0x6d,0x62,0x64,0x61,0x20,0x73,0x74,0x72,0x3a,0x20,0x25,0x73,0x0a,0x00,0x55,0x8b,0xec,0x56,0xe8,0x21,0x00,0x00,0x00,0xff,0x75,0x0c,0x8b,0xf0,0xe8,0x1e,0xf7,0xff,0xff,0x59,0x8b,
0x08,0x51,0xff,0x75,0x08,0xe8,0xb3,0x00,0x00,0x00,0x59,0x50,0xff,0xd6,0x59,0x59,0x5e,0x5d,0xc2,0x08,0x00,0x55,0x8b,0xec,0x83,0xec,0x10,0x8d,0x4d,0xfc,0xe8,0xbd,0xf4,0xff,0xff,0x53,0x56,0x57,0x8b,0x45,0xfc,0x83,0x78,0x18,0x00,0x74,0x6c,0x66,0x83,0x78,0x24,0x00,0x74,0x65,0xff,0x70,0x18,0x8d,0x4d,0xf0,0xe8,0xc6,0xf4,0xff,0xff,0x8d,0x4d,0xf0,0xe8,0xf7,0xf4,0xff,0xff,0x84,0xc0,0x74,0x4e,0x8d,0x4d,0xf0,
0xe8,0xf4,0xf4,0xff,0xff,0x8b,0xf0,0x85,0xf6,0x74,0x40,0x68,0x09,0xce,0x71,0x80,0x68,0x46,0x31,0xac,0xe2,0xe8,0xe6,0xf4,0xff,0xff,0x68,0x09,0xce,0x71,0x80,0x68,0x46,0x31,0xac,0xe2,0x8b,0xf8,0xe8,0xdd,0xf4,0xff,0xff,0x83,0xc4,0x10,0x8b,0xd8,0x57,0x4e,0x8d,0x4d,0xf0,0x56,0xe8,0xd5,0xf4,0xff,0xff,0x50,0xe8,0xe9,0xf4,0xff,0xff,0x59,0x59,0x3b,0xc3,0x74,0x1b,0x85,0xf6,0x75,0xe5,0x8d,0x4d,0xfc,0xe8,0x29,
0xf5,0xff,0xff,0x84,0xc0,0x0f,0x85,0x7b,0xff,0xff,0xff,0x33,0xc0,0x5f,0x5e,0x5b,0xc9,0xc3,0x56,0x8d,0x4d,0xf0,0xe8,0x24,0xf5,0xff,0xff,0xeb,0xf0,0x55,0x8b,0xec,0x8b,0x45,0x08,0x5d,0xc3,0x56,0x57,0xe8,0x5b,0x00,0x00,0x00,0x8b,0xf0,0x80,0x3e,0xde,0x75,0x12,0x80,0x7e,0x01,0xc0,0x75,0x0c,0x80,0x7e,0x02,0xad,0x75,0x06,0x80,0x7e,0x03,0xde,0x74,0x03,0x4e,0xeb,0xe6,0xe8,0x3a,0x00,0x00,0x00,0x80,0x38,0xde,
0x75,0x12,0x80,0x78,0x01,0xc0,0x75,0x0c,0x80,0x78,0x02,0xad,0x75,0x06,0x80,0x78,0x03,0xde,0x74,0x03,0x40,0xeb,0xe6,0x8b,0x50,0x04,0x8d,0x78,0x08,0x85,0xd2,0x74,0x11,0x8b,0x0f,0x8d,0x46,0x04,0x8d,0x7f,0x04,0x01,0x44,0x31,0x04,0x83,0xea,0x01,0x75,0xef,0x5f,0x33,0xc0,0x5e,0xc3,0xe8,0x00,0x00,0x00,0x00,0x58,0xc3,0xde,0xc0,0xad,0xde,0x13,0x00,0x00,0x00,0x1a,0x00,0x00,0x00,0x27,0x00,0x00,0x00,0x4b,0x00,
0x00,0x00,0x51,0x00,0x00,0x00,0x6a,0x00,0x00,0x00,0x89,0x00,0x00,0x00,0x8e,0x00,0x00,0x00,0xe2,0x07,0x00,0x00,0xe6,0x07,0x00,0x00,0x9b,0x00,0x00,0x00,0xa0,0x00,0x00,0x00,0xae,0x00,0x00,0x00,0xb9,0x0a,0x00,0x00,0xbe,0x0a,0x00,0x00,0x16,0x0c,0x00,0x00,0x22,0x0c,0x00,0x00,0x2b,0x0c,0x00,0x00,0xce,0x00,0x00,0x00,0x37,0x0d,0x00,0x00,	};

};


```

`obj-shellcode/include/lib.h`:

```h
#pragma once

#include "span.hpp"
#include <Windows.h>
#include <stdint.h>
#include <string>
#include <vector>
#include <iostream>
#include <functional>
#include <unordered_map>

namespace weaponslib2{


	template <size_t N>
	constexpr bool same_str(const char* str, const char(&str_c)[N]) {
		return (strncmp(str, str_c, N - 1) == 0);
	}
	template <size_t N>
	constexpr bool same_str(const char(&str_c)[N], const char* str) {
		return (strncmp(str, str_c, N - 1) == 0);
	}

	inline
		std::vector<std::string> split_str(const std::string& s, char delim = ' ') {
		std::vector<std::string> tokens;
		auto string_find_first_not = [s, delim](size_t pos = 0) -> size_t {
			for (size_t i = pos; i < s.size(); i++) {
				if (s[i] != delim)
					return i;
			}
			return std::string::npos;
		};
		size_t lastPos = string_find_first_not(0);
		size_t pos = s.find(delim, lastPos);
		while (lastPos != std::string::npos) {
			tokens.emplace_back(s.substr(lastPos, pos - lastPos));
			lastPos = string_find_first_not(pos);
			pos = s.find(delim, lastPos);
		}
		return tokens;
	}


	class obj {
	
	public:
		obj(uint8_t* buffer, size_t size) :m_buffer(buffer), m_size(size) {};
		~obj() {};
		
		uint8_t* getBuffer() { return m_buffer; };

		std::tuple<uint8_t*, size_t>getInfo()
		{
			return { m_buffer,m_size };
		}

		std::vector<std::string>& exports();
		tcb::span<IMAGE_SYMBOL>& symbols();
		tcb::span<IMAGE_SECTION_HEADER>& sections();
		tcb::span<IMAGE_RELOCATION>& relocations(PIMAGE_SECTION_HEADER section_header);

		void walkSymbols(std::function<void(IMAGE_SYMBOL&)> _call);
		const char* getSymbolNameByImageSymble(IMAGE_SYMBOL& symbol);
		IMAGE_SYMBOL* getImageSymbleBySymbolName(std::string symName);

	private:
		size_t m_size;
		uint8_t* m_buffer;
		std::vector<std::string> m_exports;
		tcb::span<IMAGE_SYMBOL> m_symbols;
		tcb::span<IMAGE_SECTION_HEADER> m_sections;
		tcb::span<IMAGE_RELOCATION> empty_relocations;
		std::unordered_map<PIMAGE_SECTION_HEADER, tcb::span<IMAGE_RELOCATION>> m_relocations;
		const char* m_stringT = 0;
	};


	class lib {
	public:

		//lib(std::string&& path);
		lib(std::string path);
		~lib();

		bool isLib();
		std::vector<obj>& objs();

		void printobjs()
		{
			for (auto obj : m_objs)
			{
				auto info = obj.getInfo();
				std::cout << "obj address: " << std::hex << static_cast<void*>(std::get<uint8_t*>(info)) << " obj size: "<< std::get<size_t>(info) << std::endl;
			}
		}

	protected:
		void readLib(const std::string& file);

		uint8_t* getFirstObjSection();
		bool bImportlibraryFormat(uint8_t* pSect);
	private:
		std::vector<uint8_t> m_buffer;
		std::vector<obj> m_objs;
	};
}

```

`obj-shellcode/include/misc.hpp`:

```hpp
#pragma once
#include <fstream>
#include <cstdint>
#include <string>
#include <vector>
inline std::string &replace_all(std::string &str, const std::string &old_value, const std::string &new_value) {
    while (true) {
        std::string::size_type pos(0);
        if ((pos = str.find(old_value)) != std::string::npos)
            str.replace(pos, old_value.length(), new_value);
        else
            break;
    }
    return str;
}
inline void buffer_to_file_bin(unsigned char *buffer, size_t buffer_size, const std::string &filename) {
    std::ofstream file(filename, std::ios_base::out | std::ios_base::binary | std::ios_base::app);
    file.write((const char *)buffer, buffer_size);
    file.close();
}
inline void open_binary_file(const std::string &file, std::vector<uint8_t> &data) {
    std::ifstream fstr(file, std::ios::binary);
    fstr.unsetf(std::ios::skipws);
    fstr.seekg(0, std::ios::end);

    const auto file_size = fstr.tellg();

    fstr.seekg(NULL, std::ios::beg);
    data.reserve(static_cast<uint32_t>(file_size));
    data.insert(data.begin(), std::istream_iterator<uint8_t>(fstr), std::istream_iterator<uint8_t>());
}


```

`obj-shellcode/include/rang.hpp`:

```hpp
#ifndef RANG_DOT_HPP
#define RANG_DOT_HPP

#if defined(__unix__) || defined(__unix) || defined(__linux__)
#define OS_LINUX
#elif defined(WIN32) || defined(_WIN32) || defined(_WIN64)
#define OS_WIN
#elif defined(__APPLE__) || defined(__MACH__)
#define OS_MAC
#else
#error Unknown Platform
#endif

#if defined(OS_LINUX) || defined(OS_MAC)
#include <unistd.h>

#elif defined(OS_WIN)

#if defined(_WIN32_WINNT) && (_WIN32_WINNT < 0x0600)
#error                                                                         \
  "Please include rang.hpp before any windows system headers or set _WIN32_WINNT at least to _WIN32_WINNT_VISTA"
#elif !defined(_WIN32_WINNT)
#define _WIN32_WINNT _WIN32_WINNT_VISTA
#endif

#include <windows.h>
#include <io.h>
#include <memory>

// Only defined in windows 10 onwards, redefining in lower windows since it
// doesn't gets used in lower versions
// https://docs.microsoft.com/en-us/windows/console/getconsolemode
#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
#endif

#endif

#include <algorithm>
#include <atomic>
#include <cstdlib>
#include <cstring>
#include <iostream>

namespace rang {

/* For better compability with most of terminals do not use any style settings
 * except of reset, bold and reversed.
 * Note that on Windows terminals bold style is same as fgB color.
 */
enum class style {
    reset     = 0,
    bold      = 1,
    dim       = 2,
    italic    = 3,
    underline = 4,
    blink     = 5,
    rblink    = 6,
    reversed  = 7,
    conceal   = 8,
    crossed   = 9
};

enum class fg {
    black   = 30,
    red     = 31,
    green   = 32,
    yellow  = 33,
    blue    = 34,
    magenta = 35,
    cyan    = 36,
    gray    = 37,
    reset   = 39
};

enum class bg {
    black   = 40,
    red     = 41,
    green   = 42,
    yellow  = 43,
    blue    = 44,
    magenta = 45,
    cyan    = 46,
    gray    = 47,
    reset   = 49
};

enum class fgB {
    black   = 90,
    red     = 91,
    green   = 92,
    yellow  = 93,
    blue    = 94,
    magenta = 95,
    cyan    = 96,
    gray    = 97
};

enum class bgB {
    black   = 100,
    red     = 101,
    green   = 102,
    yellow  = 103,
    blue    = 104,
    magenta = 105,
    cyan    = 106,
    gray    = 107
};

enum class control {  // Behaviour of rang function calls
    Off   = 0,  // toggle off rang style/color calls
    Auto  = 1,  // (Default) autodect terminal and colorize if needed
    Force = 2  // force ansi color output to non terminal streams
};
// Use rang::setControlMode to set rang control mode

enum class winTerm {  // Windows Terminal Mode
    Auto   = 0,  // (Default) automatically detects wheter Ansi or Native API
    Ansi   = 1,  // Force use Ansi API
    Native = 2  // Force use Native API
};
// Use rang::setWinTermMode to explicitly set terminal API for Windows
// Calling rang::setWinTermMode have no effect on other OS

namespace rang_implementation {

    inline std::atomic<control> &controlMode() noexcept
    {
        static std::atomic<control> value(control::Auto);
        return value;
    }

    inline std::atomic<winTerm> &winTermMode() noexcept
    {
        static std::atomic<winTerm> termMode(winTerm::Auto);
        return termMode;
    }

    inline bool supportsColor() noexcept
    {
#if defined(OS_LINUX) || defined(OS_MAC)

        static const bool result = [] {
            const char *Terms[]
              = { "ansi",    "color",  "console", "cygwin", "gnome",
                  "konsole", "kterm",  "linux",   "msys",   "putty",
                  "rxvt",    "screen", "vt100",   "xterm" };

            const char *env_p = std::getenv("TERM");
            if (env_p == nullptr) {
                return false;
            }
            return std::any_of(std::begin(Terms), std::end(Terms),
                               [&](const char *term) {
                                   return std::strstr(env_p, term) != nullptr;
                               });
        }();

#elif defined(OS_WIN)
        // All windows versions support colors through native console methods
        static constexpr bool result = true;
#endif
        return result;
    }

#ifdef OS_WIN


    inline bool isMsysPty(int fd) noexcept
    {
        // Dynamic load for binary compability with old Windows
        const auto ptrGetFileInformationByHandleEx
          = reinterpret_cast<decltype(&GetFileInformationByHandleEx)>(
            GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")),
                           "GetFileInformationByHandleEx"));
        if (!ptrGetFileInformationByHandleEx) {
            return false;
        }

        HANDLE h = reinterpret_cast<HANDLE>(_get_osfhandle(fd));
        if (h == INVALID_HANDLE_VALUE) {
            return false;
        }

        // Check that it's a pipe:
        if (GetFileType(h) != FILE_TYPE_PIPE) {
            return false;
        }

        // POD type is binary compatible with FILE_NAME_INFO from WinBase.h
        // It have the same alignment and used to avoid UB in caller code
        struct MY_FILE_NAME_INFO {
            DWORD FileNameLength;
            WCHAR FileName[MAX_PATH];
        };

        auto pNameInfo = std::unique_ptr<MY_FILE_NAME_INFO>(
          new (std::nothrow) MY_FILE_NAME_INFO());
        if (!pNameInfo) {
            return false;
        }

        // Check pipe name is template of
        // {"cygwin-","msys-"}XXXXXXXXXXXXXXX-ptyX-XX
        if (!ptrGetFileInformationByHandleEx(h, FileNameInfo, pNameInfo.get(),
                                             sizeof(MY_FILE_NAME_INFO))) {
            return false;
        }
        std::wstring name(pNameInfo->FileName, pNameInfo->FileNameLength / sizeof(WCHAR));
        if ((name.find(L"msys-") == std::wstring::npos
             && name.find(L"cygwin-") == std::wstring::npos)
            || name.find(L"-pty") == std::wstring::npos) {
            return false;
        }

        return true;
    }

#endif

    inline bool isTerminal(const std::streambuf *osbuf) noexcept
    {
        using std::cerr;
        using std::clog;
        using std::cout;
#if defined(OS_LINUX) || defined(OS_MAC)
        if (osbuf == cout.rdbuf()) {
            static const bool cout_term = isatty(fileno(stdout)) != 0;
            return cout_term;
        } else if (osbuf == cerr.rdbuf() || osbuf == clog.rdbuf()) {
            static const bool cerr_term = isatty(fileno(stderr)) != 0;
            return cerr_term;
        }
#elif defined(OS_WIN)
        if (osbuf == cout.rdbuf()) {
            static const bool cout_term
              = (_isatty(_fileno(stdout)) || isMsysPty(_fileno(stdout)));
            return cout_term;
        } else if (osbuf == cerr.rdbuf() || osbuf == clog.rdbuf()) {
            static const bool cerr_term
              = (_isatty(_fileno(stderr)) || isMsysPty(_fileno(stderr)));
            return cerr_term;
        }
#endif
        return false;
    }

    template <typename T>
    using enableStd = typename std::enable_if<
      std::is_same<T, rang::style>::value || std::is_same<T, rang::fg>::value
        || std::is_same<T, rang::bg>::value || std::is_same<T, rang::fgB>::value
        || std::is_same<T, rang::bgB>::value,
      std::ostream &>::type;


#ifdef OS_WIN

    struct SGR {  // Select Graphic Rendition parameters for Windows console
        BYTE fgColor;  // foreground color (0-15) lower 3 rgb bits + intense bit
        BYTE bgColor;  // background color (0-15) lower 3 rgb bits + intense bit
        BYTE bold;  // emulated as FOREGROUND_INTENSITY bit
        BYTE underline;  // emulated as BACKGROUND_INTENSITY bit
        BOOLEAN inverse;  // swap foreground/bold & background/underline
        BOOLEAN conceal;  // set foreground/bold to background/underline
    };

    enum class AttrColor : BYTE {  // Color attributes for console screen buffer
        black   = 0,
        red     = 4,
        green   = 2,
        yellow  = 6,
        blue    = 1,
        magenta = 5,
        cyan    = 3,
        gray    = 7
    };

    inline HANDLE getConsoleHandle(const std::streambuf *osbuf) noexcept
    {
        if (osbuf == std::cout.rdbuf()) {
            static const HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
            return hStdout;
        } else if (osbuf == std::cerr.rdbuf() || osbuf == std::clog.rdbuf()) {
            static const HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);
            return hStderr;
        }
        return INVALID_HANDLE_VALUE;
    }

    inline bool setWinTermAnsiColors(const std::streambuf *osbuf) noexcept
    {
        HANDLE h = getConsoleHandle(osbuf);
        if (h == INVALID_HANDLE_VALUE) {
            return false;
        }
        DWORD dwMode = 0;
        if (!GetConsoleMode(h, &dwMode)) {
            return false;
        }
        dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
        if (!SetConsoleMode(h, dwMode)) {
            return false;
        }
        return true;
    }

    inline bool supportsAnsi(const std::streambuf *osbuf) noexcept
    {
        using std::cerr;
        using std::clog;
        using std::cout;
        if (osbuf == cout.rdbuf()) {
            static const bool cout_ansi
              = (isMsysPty(_fileno(stdout)) || setWinTermAnsiColors(osbuf));
            return cout_ansi;
        } else if (osbuf == cerr.rdbuf() || osbuf == clog.rdbuf()) {
            static const bool cerr_ansi
              = (isMsysPty(_fileno(stderr)) || setWinTermAnsiColors(osbuf));
            return cerr_ansi;
        }
        return false;
    }

    inline const SGR &defaultState() noexcept
    {
        static const SGR defaultSgr = []() -> SGR {
            CONSOLE_SCREEN_BUFFER_INFO info;
            WORD attrib = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
            if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                                           &info)
                || GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE),
                                              &info)) {
                attrib = info.wAttributes;
            }
            SGR sgr     = { 0, 0, 0, 0, FALSE, FALSE };
            sgr.fgColor = attrib & 0x0F;
            sgr.bgColor = (attrib & 0xF0) >> 4;
            return sgr;
        }();
        return defaultSgr;
    }

    inline BYTE ansi2attr(BYTE rgb) noexcept
    {
        static const AttrColor rev[8]
          = { AttrColor::black,  AttrColor::red,  AttrColor::green,
              AttrColor::yellow, AttrColor::blue, AttrColor::magenta,
              AttrColor::cyan,   AttrColor::gray };
        return static_cast<BYTE>(rev[rgb]);
    }

    inline void setWinSGR(rang::bg col, SGR &state) noexcept
    {
        if (col != rang::bg::reset) {
            state.bgColor = ansi2attr(static_cast<BYTE>(col) - 40);
        } else {
            state.bgColor = defaultState().bgColor;
        }
    }

    inline void setWinSGR(rang::fg col, SGR &state) noexcept
    {
        if (col != rang::fg::reset) {
            state.fgColor = ansi2attr(static_cast<BYTE>(col) - 30);
        } else {
            state.fgColor = defaultState().fgColor;
        }
    }

    inline void setWinSGR(rang::bgB col, SGR &state) noexcept
    {
        state.bgColor = (BACKGROUND_INTENSITY >> 4)
          | ansi2attr(static_cast<BYTE>(col) - 100);
    }

    inline void setWinSGR(rang::fgB col, SGR &state) noexcept
    {
        state.fgColor
          = FOREGROUND_INTENSITY | ansi2attr(static_cast<BYTE>(col) - 90);
    }

    inline void setWinSGR(rang::style style, SGR &state) noexcept
    {
        switch (style) {
            case rang::style::reset: state = defaultState(); break;
            case rang::style::bold: state.bold = FOREGROUND_INTENSITY; break;
            case rang::style::underline:
            case rang::style::blink:
                state.underline = BACKGROUND_INTENSITY;
                break;
            case rang::style::reversed: state.inverse = TRUE; break;
            case rang::style::conceal: state.conceal = TRUE; break;
            default: break;
        }
    }

    inline SGR &current_state() noexcept
    {
        static SGR state = defaultState();
        return state;
    }

    inline WORD SGR2Attr(const SGR &state) noexcept
    {
        WORD attrib = 0;
        if (state.conceal) {
            if (state.inverse) {
                attrib = (state.fgColor << 4) | state.fgColor;
                if (state.bold)
                    attrib |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
            } else {
                attrib = (state.bgColor << 4) | state.bgColor;
                if (state.underline)
                    attrib |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
            }
        } else if (state.inverse) {
            attrib = (state.fgColor << 4) | state.bgColor;
            if (state.bold) attrib |= BACKGROUND_INTENSITY;
            if (state.underline) attrib |= FOREGROUND_INTENSITY;
        } else {
            attrib = state.fgColor | (state.bgColor << 4) | state.bold
              | state.underline;
        }
        return attrib;
    }

    template <typename T>
    inline void setWinColorAnsi(std::ostream &os, T const value)
    {
        os << "\033[" << static_cast<int>(value) << "m";
    }

    template <typename T>
    inline void setWinColorNative(std::ostream &os, T const value)
    {
        const HANDLE h = getConsoleHandle(os.rdbuf());
        if (h != INVALID_HANDLE_VALUE) {
            setWinSGR(value, current_state());
            // Out all buffered text to console with previous settings:
            os.flush();
            SetConsoleTextAttribute(h, SGR2Attr(current_state()));
        }
    }

    template <typename T>
    inline enableStd<T> setColor(std::ostream &os, T const value)
    {
        if (winTermMode() == winTerm::Auto) {
            if (supportsAnsi(os.rdbuf())) {
                setWinColorAnsi(os, value);
            } else {
                setWinColorNative(os, value);
            }
        } else if (winTermMode() == winTerm::Ansi) {
            setWinColorAnsi(os, value);
        } else {
            setWinColorNative(os, value);
        }
        return os;
    }
#else
    template <typename T>
    inline enableStd<T> setColor(std::ostream &os, T const value)
    {
        return os << "\033[" << static_cast<int>(value) << "m";
    }
#endif
}  // namespace rang_implementation

template <typename T>
inline rang_implementation::enableStd<T> operator<<(std::ostream &os,
                                                    const T value)
{
    const control option = rang_implementation::controlMode();
    switch (option) {
        case control::Auto:
            return rang_implementation::supportsColor()
                && rang_implementation::isTerminal(os.rdbuf())
              ? rang_implementation::setColor(os, value)
              : os;
        case control::Force: return rang_implementation::setColor(os, value);
        default: return os;
    }
}

inline void setWinTermMode(const rang::winTerm value) noexcept
{
    rang_implementation::winTermMode() = value;
}

inline void setControlMode(const control value) noexcept
{
    rang_implementation::controlMode() = value;
}

}  // namespace rang

#undef OS_LINUX
#undef OS_WIN
#undef OS_MAC

#endif /* ifndef RANG_DOT_HPP */

```

`obj-shellcode/include/rang_impl.hpp`:

```hpp
#pragma once
#include "rang.hpp"
template <typename... Args>
void __DbgPrint(const char *identifier, rang::fg color, const char *format, Args... args) {

    char buffer[2500] = {'\0'};
    sprintf_s(buffer + strlen(buffer), 2500 - strlen(buffer), format, args...);
    sprintf_s(buffer + strlen(buffer), 2500 - strlen(buffer), "\n");
    std::cout << "[ " << rang::style::bold << color << identifier << rang::style::reset << rang::fg::reset << " ]"
              << buffer;
}

#define erro(...) __DbgPrint("erro", rang::fg::red, __VA_ARGS__)
#define info(...) __DbgPrint("info", rang::fg::blue, __VA_ARGS__)
#define important(...) __DbgPrint("important", rang::fg::magenta, __VA_ARGS__)
#define success(...) __DbgPrint("success", rang::fg::green, __VA_ARGS__)

#define ERO(...) erro(__VA_ARGS__)
#define INF(...) info( __VA_ARGS__)
#define IMP(...) important(__VA_ARGS__)
#define SUC(...) success(__VA_ARGS__)
```

`obj-shellcode/include/span.hpp`:

```hpp

/*
This is an implementation of C++20's std::span
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4820.pdf
*/

//          Copyright Tristan Brindle 2018.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../../LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)

#ifndef TCB_SPAN_HPP_INCLUDED
#define TCB_SPAN_HPP_INCLUDED

#include <array>
#include <cstddef>
#include <cstdint>
#include <type_traits>

#ifndef TCB_SPAN_NO_EXCEPTIONS
// Attempt to discover whether we're being compiled with exception support
#if !(defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND))
#define TCB_SPAN_NO_EXCEPTIONS
#endif
#endif

#ifndef TCB_SPAN_NO_EXCEPTIONS
#include <cstdio>
#include <stdexcept>
#endif

// Various feature test macros

#ifndef TCB_SPAN_NAMESPACE_NAME
#define TCB_SPAN_NAMESPACE_NAME tcb
#endif

#if __cplusplus >= 201703L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
#define TCB_SPAN_HAVE_CPP17
#endif

#if __cplusplus >= 201402L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
#define TCB_SPAN_HAVE_CPP14
#endif

namespace TCB_SPAN_NAMESPACE_NAME {

// Establish default contract checking behavior
#if !defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION) &&                          \
    !defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION) &&                      \
    !defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#if defined(NDEBUG) || !defined(TCB_SPAN_HAVE_CPP14)
#define TCB_SPAN_NO_CONTRACT_CHECKING
#else
#define TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION
#endif
#endif

#if defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION)
struct contract_violation_error : std::logic_error {
    explicit contract_violation_error(const char* msg) : std::logic_error(msg)
    {}
};

inline void contract_violation(const char* msg)
{
    throw contract_violation_error(msg);
}

#elif defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION)
[[noreturn]] inline void contract_violation(const char* /*unused*/)
{
    std::terminate();
}
#endif

#if !defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#define TCB_SPAN_STRINGIFY(cond) #cond
#define TCB_SPAN_EXPECT(cond)                                                  \
    cond ? (void) 0 : contract_violation("Expected " TCB_SPAN_STRINGIFY(cond))
#else
#define TCB_SPAN_EXPECT(cond)
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_inline_variables)
#define TCB_SPAN_INLINE_VAR inline
#else
#define TCB_SPAN_INLINE_VAR
#endif

#if defined(TCB_SPAN_HAVE_CPP14) ||                                            \
    (defined(__cpp_constexpr) && __cpp_constexpr >= 201304)
#define TCB_SPAN_HAVE_CPP14_CONSTEXPR
#endif

#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR)
#define TCB_SPAN_CONSTEXPR14 constexpr
#else
#define TCB_SPAN_CONSTEXPR14
#endif

#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR) &&                                  \
    (!defined(_MSC_VER) || _MSC_VER > 1900)
#define TCB_SPAN_CONSTEXPR_ASSIGN constexpr
#else
#define TCB_SPAN_CONSTEXPR_ASSIGN
#endif

#if defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#define TCB_SPAN_CONSTEXPR11 constexpr
#else
#define TCB_SPAN_CONSTEXPR11 TCB_SPAN_CONSTEXPR14
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_deduction_guides)
#define TCB_SPAN_HAVE_DEDUCTION_GUIDES
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_byte)
#define TCB_SPAN_HAVE_STD_BYTE
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_array_constexpr)
#define TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC
#endif

#if defined(TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC)
#define TCB_SPAN_ARRAY_CONSTEXPR constexpr
#else
#define TCB_SPAN_ARRAY_CONSTEXPR
#endif

#ifdef TCB_SPAN_HAVE_STD_BYTE
using byte = std::byte;
#else
using byte = unsigned char;
#endif

#if defined(TCB_SPAN_HAVE_CPP17)
#define TCB_SPAN_NODISCARD [[nodiscard]]
#else
#define TCB_SPAN_NODISCARD
#endif

TCB_SPAN_INLINE_VAR constexpr std::size_t dynamic_extent = SIZE_MAX;

template <typename ElementType, std::size_t Extent = dynamic_extent>
class span;

namespace detail {

template <typename E, std::size_t S>
struct span_storage {
    constexpr span_storage() noexcept = default;

    constexpr span_storage(E* p_ptr, std::size_t /*unused*/) noexcept
       : ptr(p_ptr)
    {}

    E* ptr = nullptr;
    static constexpr std::size_t size = S;
};

template <typename E>
struct span_storage<E, dynamic_extent> {
    constexpr span_storage() noexcept = default;

    constexpr span_storage(E* p_ptr, std::size_t p_size) noexcept
        : ptr(p_ptr), size(p_size)
    {}

    E* ptr = nullptr;
    std::size_t size = 0;
};

// Reimplementation of C++17 std::size() and std::data()
#if defined(TCB_SPAN_HAVE_CPP17) ||                                            \
    defined(__cpp_lib_nonmember_container_access)
using std::data;
using std::size;
#else
template <class C>
constexpr auto size(const C& c) -> decltype(c.size())
{
    return c.size();
}

template <class T, std::size_t N>
constexpr std::size_t size(const T (&)[N]) noexcept
{
    return N;
}

template <class C>
constexpr auto data(C& c) -> decltype(c.data())
{
    return c.data();
}

template <class C>
constexpr auto data(const C& c) -> decltype(c.data())
{
    return c.data();
}

template <class T, std::size_t N>
constexpr T* data(T (&array)[N]) noexcept
{
    return array;
}

template <class E>
constexpr const E* data(std::initializer_list<E> il) noexcept
{
    return il.begin();
}
#endif // TCB_SPAN_HAVE_CPP17

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_void_t)
using std::void_t;
#else
template <typename...>
using void_t = void;
#endif

template <typename T>
using uncvref_t =
    typename std::remove_cv<typename std::remove_reference<T>::type>::type;

template <typename>
struct is_span : std::false_type {};

template <typename T, std::size_t S>
struct is_span<span<T, S>> : std::true_type {};

template <typename>
struct is_std_array : std::false_type {};

template <typename T, std::size_t N>
struct is_std_array<std::array<T, N>> : std::true_type {};

template <typename, typename = void>
struct has_size_and_data : std::false_type {};

template <typename T>
struct has_size_and_data<T, void_t<decltype(detail::size(std::declval<T>())),
                                   decltype(detail::data(std::declval<T>()))>>
    : std::true_type {};

template <typename C, typename U = uncvref_t<C>>
struct is_container {
    static constexpr bool value =
        !is_span<U>::value && !is_std_array<U>::value &&
        !std::is_array<U>::value && has_size_and_data<C>::value;
};

template <typename T>
using remove_pointer_t = typename std::remove_pointer<T>::type;

template <typename, typename, typename = void>
struct is_container_element_type_compatible : std::false_type {};

template <typename T, typename E>
struct is_container_element_type_compatible<
    T, E,
    typename std::enable_if<
        !std::is_same<
            typename std::remove_cv<decltype(detail::data(std::declval<T>()))>::type,
            void>::value &&
        std::is_convertible<
            remove_pointer_t<decltype(detail::data(std::declval<T>()))> (*)[],
            E (*)[]>::value
        >::type>
    : std::true_type {};

template <typename, typename = size_t>
struct is_complete : std::false_type {};

template <typename T>
struct is_complete<T, decltype(sizeof(T))> : std::true_type {};

} // namespace detail

template <typename ElementType, std::size_t Extent>
class span {
    static_assert(std::is_object<ElementType>::value,
                  "A span's ElementType must be an object type (not a "
                  "reference type or void)");
    static_assert(detail::is_complete<ElementType>::value,
                  "A span's ElementType must be a complete type (not a forward "
                  "declaration)");
    static_assert(!std::is_abstract<ElementType>::value,
                  "A span's ElementType cannot be an abstract class type");

    using storage_type = detail::span_storage<ElementType, Extent>;

public:
    // constants and types
    using element_type = ElementType;
    using value_type = typename std::remove_cv<ElementType>::type;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using pointer = element_type*;
    using const_pointer = const element_type*;
    using reference = element_type&;
    using const_reference = const element_type&;
    using iterator = pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;

    static constexpr size_type extent = Extent;

    // [span.cons], span constructors, copy, assignment, and destructor
    template <
        std::size_t E = Extent,
        typename std::enable_if<(E == dynamic_extent || E <= 0), int>::type = 0>
    constexpr span() noexcept
    {}

    TCB_SPAN_CONSTEXPR11 span(pointer ptr, size_type count)
        : storage_(ptr, count)
    {
        TCB_SPAN_EXPECT(extent == dynamic_extent || count == extent);
    }

    TCB_SPAN_CONSTEXPR11 span(pointer first_elem, pointer last_elem)
        : storage_(first_elem, last_elem - first_elem)
    {
        TCB_SPAN_EXPECT(extent == dynamic_extent ||
                        last_elem - first_elem ==
                            static_cast<std::ptrdiff_t>(extent));
    }

    template <std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          element_type (&)[N], ElementType>::value,
                  int>::type = 0>
    constexpr span(element_type (&arr)[N]) noexcept : storage_(arr, N)
    {}

    template <std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          std::array<value_type, N>&, ElementType>::value,
                  int>::type = 0>
    TCB_SPAN_ARRAY_CONSTEXPR span(std::array<value_type, N>& arr) noexcept
        : storage_(arr.data(), N)
    {}

    template <std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          const std::array<value_type, N>&, ElementType>::value,
                  int>::type = 0>
    TCB_SPAN_ARRAY_CONSTEXPR span(const std::array<value_type, N>& arr) noexcept
        : storage_(arr.data(), N)
    {}

    template <
        typename Container, std::size_t E = Extent,
        typename std::enable_if<
            E == dynamic_extent && detail::is_container<Container>::value &&
                detail::is_container_element_type_compatible<
                    Container&, ElementType>::value,
            int>::type = 0>
    constexpr span(Container& cont)
        : storage_(detail::data(cont), detail::size(cont))
    {}

    template <
        typename Container, std::size_t E = Extent,
        typename std::enable_if<
            E == dynamic_extent && detail::is_container<Container>::value &&
                detail::is_container_element_type_compatible<
                    const Container&, ElementType>::value,
            int>::type = 0>
    constexpr span(const Container& cont)
        : storage_(detail::data(cont), detail::size(cont))
    {}

    constexpr span(const span& other) noexcept = default;

    template <typename OtherElementType, std::size_t OtherExtent,
              typename std::enable_if<
                  (Extent == OtherExtent || Extent == dynamic_extent) &&
                      std::is_convertible<OtherElementType (*)[],
                                          ElementType (*)[]>::value,
                  int>::type = 0>
    constexpr span(const span<OtherElementType, OtherExtent>& other) noexcept
        : storage_(other.data(), other.size())
    {}

    ~span() noexcept = default;

    TCB_SPAN_CONSTEXPR_ASSIGN span&
    operator=(const span& other) noexcept = default;

    // [span.sub], span subviews
    template <std::size_t Count>
    TCB_SPAN_CONSTEXPR11 span<element_type, Count> first() const
    {
        TCB_SPAN_EXPECT(Count <= size());
        return {data(), Count};
    }

    template <std::size_t Count>
    TCB_SPAN_CONSTEXPR11 span<element_type, Count> last() const
    {
        TCB_SPAN_EXPECT(Count <= size());
        return {data() + (size() - Count), Count};
    }

    template <std::size_t Offset, std::size_t Count = dynamic_extent>
    using subspan_return_t =
        span<ElementType, Count != dynamic_extent
                              ? Count
                              : (Extent != dynamic_extent ? Extent - Offset
                                                          : dynamic_extent)>;

    template <std::size_t Offset, std::size_t Count = dynamic_extent>
    TCB_SPAN_CONSTEXPR11 subspan_return_t<Offset, Count> subspan() const
    {
        TCB_SPAN_EXPECT(Offset <= size() &&
                        (Count == dynamic_extent || Offset + Count <= size()));
        return {data() + Offset,
                Count != dynamic_extent ? Count : size() - Offset};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    first(size_type count) const
    {
        TCB_SPAN_EXPECT(count <= size());
        return {data(), count};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    last(size_type count) const
    {
        TCB_SPAN_EXPECT(count <= size());
        return {data() + (size() - count), count};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    subspan(size_type offset, size_type count = dynamic_extent) const
    {
        TCB_SPAN_EXPECT(offset <= size() &&
                        (count == dynamic_extent || offset + count <= size()));
        return {data() + offset,
                count == dynamic_extent ? size() - offset : count};
    }

    // [span.obs], span observers
    constexpr size_type size() const noexcept { return storage_.size; }

    constexpr size_type size_bytes() const noexcept
    {
        return size() * sizeof(element_type);
    }

    TCB_SPAN_NODISCARD constexpr bool empty() const noexcept
    {
        return size() == 0;
    }

    // [span.elem], span element access
    TCB_SPAN_CONSTEXPR11 reference operator[](size_type idx) const
    {
        TCB_SPAN_EXPECT(idx < size());
        return *(data() + idx);
    }

    TCB_SPAN_CONSTEXPR11 reference front() const
    {
        TCB_SPAN_EXPECT(!empty());
        return *data();
    }

    TCB_SPAN_CONSTEXPR11 reference back() const
    {
        TCB_SPAN_EXPECT(!empty());
        return *(data() + (size() - 1));
    }

    constexpr pointer data() const noexcept { return storage_.ptr; }

    // [span.iterators], span iterator support
    constexpr iterator begin() const noexcept { return data(); }

    constexpr iterator end() const noexcept { return data() + size(); }

    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rbegin() const noexcept
    {
        return reverse_iterator(end());
    }

    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rend() const noexcept
    {
        return reverse_iterator(begin());
    }

private:
    storage_type storage_{};
};

#ifdef TCB_SPAN_HAVE_DEDUCTION_GUIDES

/* Deduction Guides */
template <class T, size_t N>
span(T (&)[N])->span<T, N>;

template <class T, size_t N>
span(std::array<T, N>&)->span<T, N>;

template <class T, size_t N>
span(const std::array<T, N>&)->span<const T, N>;

template <class Container>
span(Container&)->span<typename Container::value_type>;

template <class Container>
span(const Container&)->span<const typename Container::value_type>;

#endif // TCB_HAVE_DEDUCTION_GUIDES

template <typename ElementType, std::size_t Extent>
constexpr span<ElementType, Extent>
make_span(span<ElementType, Extent> s) noexcept
{
    return s;
}

template <typename T, std::size_t N>
constexpr span<T, N> make_span(T (&arr)[N]) noexcept
{
    return {arr};
}

template <typename T, std::size_t N>
TCB_SPAN_ARRAY_CONSTEXPR span<T, N> make_span(std::array<T, N>& arr) noexcept
{
    return {arr};
}

template <typename T, std::size_t N>
TCB_SPAN_ARRAY_CONSTEXPR span<const T, N>
make_span(const std::array<T, N>& arr) noexcept
{
    return {arr};
}

template <typename Container>
constexpr span<typename Container::value_type> make_span(Container& cont)
{
    return {cont};
}

template <typename Container>
constexpr span<const typename Container::value_type>
make_span(const Container& cont)
{
    return {cont};
}

template <typename ElementType, std::size_t Extent>
span<const byte, ((Extent == dynamic_extent) ? dynamic_extent
                                             : sizeof(ElementType) * Extent)>
as_bytes(span<ElementType, Extent> s) noexcept
{
    return {reinterpret_cast<const byte*>(s.data()), s.size_bytes()};
}

template <
    class ElementType, size_t Extent,
    typename std::enable_if<!std::is_const<ElementType>::value, int>::type = 0>
span<byte, ((Extent == dynamic_extent) ? dynamic_extent
                                       : sizeof(ElementType) * Extent)>
as_writable_bytes(span<ElementType, Extent> s) noexcept
{
    return {reinterpret_cast<byte*>(s.data()), s.size_bytes()};
}

template <std::size_t N, typename E, std::size_t S>
constexpr auto get(span<E, S> s) -> decltype(s[N])
{
    return s[N];
}

} // namespace TCB_SPAN_NAMESPACE_NAME

namespace std {

template <typename ElementType, size_t Extent>
class tuple_size<TCB_SPAN_NAMESPACE_NAME::span<ElementType, Extent>>
    : public integral_constant<size_t, Extent> {};

template <typename ElementType>
class tuple_size<TCB_SPAN_NAMESPACE_NAME::span<
    ElementType, TCB_SPAN_NAMESPACE_NAME::dynamic_extent>>; // not defined

template <size_t I, typename ElementType, size_t Extent>
class tuple_element<I, TCB_SPAN_NAMESPACE_NAME::span<ElementType, Extent>> {
public:
    static_assert(Extent != TCB_SPAN_NAMESPACE_NAME::dynamic_extent &&
                      I < Extent,
                  "");
    using type = ElementType;
};

} // end namespace std

#endif // TCB_SPAN_HPP_INCLUDED

```

`obj-shellcode/obj-shellcode.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.34301.259
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "obj-shellcode", "obj-shellcode.vcxproj", "{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "payload", "..\payload\payload.vcxproj", "{06A9CD95-127D-46DC-9A5E-E7966716D356}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "run", "..\run\run.vcxproj", "{C951E5DF-E51E-4A53-A896-35BA0B18BE67}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}.Debug|x64.ActiveCfg = Debug|x64
		{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}.Debug|x64.Build.0 = Debug|x64
		{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}.Debug|x86.ActiveCfg = Debug|Win32
		{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}.Debug|x86.Build.0 = Debug|Win32
		{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}.Release|x64.ActiveCfg = Release|x64
		{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}.Release|x64.Build.0 = Release|x64
		{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}.Release|x86.ActiveCfg = Release|Win32
		{B8A15FCD-D5EA-4DE7-8B55-CBD4CBC81F8E}.Release|x86.Build.0 = Release|Win32
		{06A9CD95-127D-46DC-9A5E-E7966716D356}.Debug|x64.ActiveCfg = Debug|x64
		{06A9CD95-127D-46DC-9A5E-E7966716D356}.Debug|x64.Build.0 = Debug|x64
		{06A9CD95-127D-46DC-9A5E-E7966716D356}.Debug|x86.ActiveCfg = Debug|Win32
		{06A9CD95-127D-46DC-9A5E-E7966716D356}.Debug|x86.Build.0 = Debug|Win32
		{06A9CD95-127D-46DC-9A5E-E7966716D356}.Release|x64.ActiveCfg = Release|x64
		{06A9CD95-127D-46DC-9A5E-E7966716D356}.Release|x64.Build.0 = Release|x64
		{06A9CD95-127D-46DC-9A5E-E7966716D356}.Release|x86.ActiveCfg = Release|Win32
		{06A9CD95-127D-46DC-9A5E-E7966716D356}.Release|x86.Build.0 = Release|Win32
		{C951E5DF-E51E-4A53-A896-35BA0B18BE67}.Debug|x64.ActiveCfg = Debug|x64
		{C951E5DF-E51E-4A53-A896-35BA0B18BE67}.Debug|x64.Build.0 = Debug|x64
		{C951E5DF-E51E-4A53-A896-35BA0B18BE67}.Debug|x86.ActiveCfg = Debug|Win32
		{C951E5DF-E51E-4A53-A896-35BA0B18BE67}.Debug|x86.Build.0 = Debug|Win32
		{C951E5DF-E51E-4A53-A896-35BA0B18BE67}.Release|x64.ActiveCfg = Release|x64
		{C951E5DF-E51E-4A53-A896-35BA0B18BE67}.Release|x64.Build.0 = Release|x64
		{C951E5DF-E51E-4A53-A896-35BA0B18BE67}.Release|x86.ActiveCfg = Release|Win32
		{C951E5DF-E51E-4A53-A896-35BA0B18BE67}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B8C3CE69-F042-448D-826C-06E5801737AE}
	EndGlobalSection
EndGlobal

```

`obj-shellcode/obj-shellcode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b8a15fcd-d5ea-4de7-8b55-cbd4cbc81f8e}</ProjectGuid>
    <RootNamespace>objshellcode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(solutiondir)bin\</OutDir>
    <IntDir>$(solutiondir)bin\intermediate\</IntDir>
    <TargetName>$(ProjectName)_$(Platform)_$(Configuration)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(solutiondir)bin\</OutDir>
    <IntDir>$(solutiondir)bin\intermediate\</IntDir>
    <TargetName>$(ProjectName)_$(Platform)_$(Configuration)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(solutiondir)bin\</OutDir>
    <IntDir>$(solutiondir)bin\intermediate\</IntDir>
    <TargetName>$(ProjectName)_$(Platform)_$(Configuration)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(solutiondir)bin\</OutDir>
    <IntDir>$(solutiondir)bin\intermediate\</IntDir>
    <TargetName>$(ProjectName)_$(Platform)_$(Configuration)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp14</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(solutiondir)include</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(solutiondir)include</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp14</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(solutiondir)include</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(solutiondir)include</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\lib.cpp" />
    <ClCompile Include="src\main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\lib.h" />
    <ClInclude Include="include\misc.hpp" />
    <ClInclude Include="include\rang.hpp" />
    <ClInclude Include="include\rang_impl.hpp" />
    <ClInclude Include="include\span.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`obj-shellcode/obj-shellcode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="src\lib.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\misc.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="include\rang.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="include\rang_impl.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="include\span.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="include\lib.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`obj-shellcode/obj-shellcode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerWorkingDirectory>$(ProjectDir)bin</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerWorkingDirectory>$(ProjectDir)bin</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerWorkingDirectory>$(ProjectDir)bin</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerWorkingDirectory>$(ProjectDir)bin</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`obj-shellcode/src/lib.cpp`:

```cpp
#include <fstream>
#include <regex>
#include "rang_impl.hpp"
#include "lib.h"


namespace weaponslib2{

	std::vector<std::string>& obj::exports()
	{
		if (m_exports.empty()) 
		{
			PIMAGE_FILE_HEADER obj = reinterpret_cast<PIMAGE_FILE_HEADER>(m_buffer);
			auto               symbols = this->symbols();
			auto               section_headers = this->sections();

			for (size_t idx = 0; idx < symbols.size(); idx++) 
			{
				auto& symbol = symbols[idx];

				if (symbol.SectionNumber > 0) 
				{
					auto& section = section_headers[static_cast<size_t>(symbol.SectionNumber) - 1];

					// IMAGE_SCN_LNK_INFO
					if (same_str((char*)section.Name, ".drectve")) 
					{
						const char* data = section.PointerToRawData + (char*)obj;
						auto strs = split_str(std::string(data, static_cast<size_t>(section.SizeOfRawData)), ' ');
						for (auto str : strs) 
						{
							// msvc /EXPORT:?main2@@YAHXZ
							// llvm /EXPORT:"?main2@@YAHXZ"
							std::smatch base_match;
							if (std::regex_match(str, base_match, std::regex("^(/EXPORT:)(.*?)|(\".*?\")"))) 
							{
								std::string export_name = base_match[2].str();
								
								if (std::regex_match(export_name, base_match, std::regex("^\"(.*?)\""))) 
									export_name = base_match[1].str();
								
								if (std::regex_match(export_name, base_match, std::regex("(.*?),DATA$"))) 
									export_name = base_match[1].str();

								m_exports.push_back(export_name);
							}
						}
					}
				}

				// NumberOfAuxSymbols 附加记录的数量。 也就是本 symbol 后面的附加symbol的数量
				if (symbol.NumberOfAuxSymbols)
					idx += symbol.NumberOfAuxSymbols;
			}
		}
		return m_exports;
	}

	tcb::span<IMAGE_SECTION_HEADER>& obj::sections() {
		if (m_sections.empty()) {
			PIMAGE_FILE_HEADER    obj = reinterpret_cast<PIMAGE_FILE_HEADER>(m_buffer);
			PIMAGE_SECTION_HEADER section_headers =
				reinterpret_cast<PIMAGE_SECTION_HEADER>((byte*)obj + sizeof IMAGE_FILE_HEADER);
			m_sections = tcb::span<IMAGE_SECTION_HEADER>(section_headers, static_cast<std::size_t>(obj->NumberOfSections));
		}
		return m_sections;
	}

	tcb::span<IMAGE_RELOCATION>& obj::relocations(PIMAGE_SECTION_HEADER section_header) {
		auto iter = m_relocations.find(section_header);
		if (iter != m_relocations.end()) {
			return iter->second;
		}
		else { 
			PIMAGE_FILE_HEADER obj = reinterpret_cast<PIMAGE_FILE_HEADER>(m_buffer);
			if (section_header->PointerToRelocations) {
				PIMAGE_RELOCATION reloc_dir = reinterpret_cast<PIMAGE_RELOCATION>(section_header->PointerToRelocations +
					reinterpret_cast<byte*>(obj));

				// 一种特殊情况，单个函数的依赖函数(重定位信息)超过 65535 时 ，这个 if 会生效
				// https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header
				if (section_header->NumberOfRelocations == 0xffff &&
					(section_header->Characteristics & IMAGE_SCN_LNK_NRELOC_OVFL)) {
					tcb::span<IMAGE_RELOCATION> relocation(reloc_dir, static_cast<std::size_t>(reloc_dir->RelocCount));
					m_relocations[section_header] = relocation;
					return m_relocations[section_header];
				}

				tcb::span<IMAGE_RELOCATION> relocation(reloc_dir, static_cast<std::size_t>(section_header->NumberOfRelocations));

				m_relocations[section_header] = relocation;
				return m_relocations[section_header];
			}
		}
		return empty_relocations;
	}

	tcb::span<IMAGE_SYMBOL>& obj::symbols()
	{
		if (m_symbols.empty()) {
			PIMAGE_FILE_HEADER obj = reinterpret_cast<PIMAGE_FILE_HEADER>(m_buffer);
			PIMAGE_SYMBOL      symbol_table = reinterpret_cast<PIMAGE_SYMBOL>(obj->PointerToSymbolTable + (byte*)obj);
			m_symbols = tcb::span<IMAGE_SYMBOL>(symbol_table, static_cast<std::size_t>(obj->NumberOfSymbols));
		}
		return m_symbols;
	}

	void obj::walkSymbols(std::function<void(IMAGE_SYMBOL&)> _call) {
		auto& symbols = this->symbols();
		// 遍历所有符号
		for (size_t idx = 0; idx < symbols.size(); idx++) {
			_call(symbols[idx]);
			if (symbols[idx].NumberOfAuxSymbols) {
				idx += symbols[idx].NumberOfAuxSymbols;
			}
		}
	}

	const char* obj::getSymbolNameByImageSymble(IMAGE_SYMBOL& symbol) {

		if (symbol.N.Name.Short != 0)
		{
			char name[9];
			memcpy(name, symbol.N.ShortName, 8);
			size_t length = strnlen(name, 8);
			name[length] = '\0';
			return _strdup(name);
		}
			
		else {
			if (!m_stringT) {
				PIMAGE_FILE_HEADER    obj = reinterpret_cast<PIMAGE_FILE_HEADER>(m_buffer);
				PIMAGE_SECTION_HEADER section_headers =
					reinterpret_cast<PIMAGE_SECTION_HEADER>((byte*)obj + sizeof IMAGE_FILE_HEADER);

				PIMAGE_SYMBOL symbol_table = reinterpret_cast<PIMAGE_SYMBOL>(obj->PointerToSymbolTable + (byte*)obj);

				m_stringT = reinterpret_cast<const char*>(reinterpret_cast<std::uintptr_t>(symbol_table) +
					(obj->NumberOfSymbols * sizeof IMAGE_SYMBOL));
			}
			return (m_stringT + symbol.N.Name.Long);
		}
	}

	IMAGE_SYMBOL* obj::getImageSymbleBySymbolName(std::string symName)
	{
		if (m_symbols.empty())
			this->symbols();

		for (size_t idx = 0; idx < m_symbols.size(); idx++)
		{
			auto& symbol = m_symbols[idx];
			const char* name = this->getSymbolNameByImageSymble(symbol);

			if (name == symName)
				return &symbol;

			if (symbol.NumberOfAuxSymbols)
				idx += symbol.NumberOfAuxSymbols;
		}

		return nullptr;
	}


	lib::lib(std::string path)
	{
		// 读取lib文件
		readLib(path);

		if (m_buffer.size() <= 0)
			ERO("lib initialize faild");
	}

	lib::~lib(){}


	std::vector<obj>& lib::objs()
	{
		m_objs.clear();

		uint8_t* buffer = m_buffer.data();
		size_t size = m_buffer.size();
		uint8_t* first = getFirstObjSection();

		if (first)
		{
			if (bImportlibraryFormat(first + sizeof(IMAGE_ARCHIVE_MEMBER_HEADER)))
				return m_objs;
		}
		else return m_objs;

		do
		{
			PIMAGE_ARCHIVE_MEMBER_HEADER pAME = (PIMAGE_ARCHIVE_MEMBER_HEADER)first;
			first += sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);//去掉头部，剩下的就是Obj(COFF格式)

			//注意：BYTE Size[10];要用atol((LPSTR)..)这种方法才能得到正确size
			size_t objSize = atol((LPSTR)pAME->Size);
			m_objs.push_back({ first, objSize });

			first += objSize;
			//注意：两个成员之间有可能是由\n隔开,《PE COFF 文件格式》中并没有提到
			if (*first == '\n')
				first++;

		} while (first < (buffer + size));

		return m_objs;
	}

	bool lib::isLib() {
		if (strncmp(reinterpret_cast<const char*>(m_buffer.data()), IMAGE_ARCHIVE_START, sizeof IMAGE_ARCHIVE_START - 1))
			return false;
		else
			return true;
	}

	void lib::readLib(const std::string& file)
	{
		std::ifstream fstr(file, std::ios::binary);
		fstr.unsetf(std::ios::skipws);
		fstr.seekg(0, std::ios::end);

		const auto file_size = fstr.tellg();

		fstr.seekg(NULL, std::ios::beg);
		m_buffer.reserve(static_cast<uint32_t>(file_size));
		m_buffer.insert(m_buffer.begin(), std::istream_iterator<uint8_t>(fstr), std::istream_iterator<uint8_t>());
	}

	bool lib::bImportlibraryFormat(uint8_t* pSect)
	{
		//通过判断其是否有短格式成员来判断其是否是导入库格式
		uint16_t Sig1 = *(uint16_t*)(pSect);
		uint16_t Sig2 = *(uint16_t*)(pSect + 2);
		if (Sig1 == IMAGE_FILE_MACHINE_UNKNOWN && Sig2 == 0xffff)
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	uint8_t* lib::getFirstObjSection()
	{
		int iCtrl = 0;
		//第一个链接器成员
		uint8_t* pSect = m_buffer.data() + IMAGE_ARCHIVE_START_SIZE;
		
		if (!pSect)return nullptr;
		
		while (pSect)
		{
			//第二个链接器成员
			if (memcmp(((PIMAGE_ARCHIVE_MEMBER_HEADER)pSect)->Name, IMAGE_ARCHIVE_LINKER_MEMBER, 16) == 0)
			{
				//Nothing
			}
			//第三个长名称成员
			else if (memcmp(((PIMAGE_ARCHIVE_MEMBER_HEADER)pSect)->Name, IMAGE_ARCHIVE_LONGNAMES_MEMBER, 16) == 0)//LONG Name
			{
				//Nothing
				//尽管长名称成员的头部必须存在，但它本身却可以为空。
			}
			else //First Obj Section
			{
				return pSect;
			}
			//注意BYTE Size[10];要用atol((LPSTR)..)这种方法才能得到正确size
			PIMAGE_ARCHIVE_MEMBER_HEADER pAME = (PIMAGE_ARCHIVE_MEMBER_HEADER)pSect;
			pSect += atol((LPSTR)pAME->Size) + sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);
			//两个成员之间有可能是由\n隔开
			if (*pSect == '\n') pSect++;

			iCtrl++;//防止遇到错误的Lib文件，而导致死循环
			if (iCtrl > 3)
			{
				break;
			}
		}
		return nullptr;
	}

}
```

`obj-shellcode/src/main.cpp`:

```cpp

#include "lib.h"
#include <string>
#include <iostream>
#include <iomanip> 
#include "misc.hpp"
#include "rang_impl.hpp"

using namespace weaponslib2;

constexpr char out_bin_name[] = { "shellcode-payload.bin" };
constexpr char out_hpp_name[] = { "payload" };

struct section_mapped_info {
    uint32_t maped_va;
    uint32_t maped_size; // maped_size 好像用不到 先留着吧
};

void recursive_lookup_relocations(std::vector<lib>& libs,
    std::tuple<PIMAGE_SYMBOL, obj*> sym,
    std::unordered_map<PIMAGE_SECTION_HEADER, section_mapped_info>& section_mapped,
    std::unordered_map<std::string, int>& sym_mapped,
    std::vector<uint8_t>& shellcodebytes,
    std::vector<uint32_t>& dir_offset);

void print_shellcode_hpp_file(std::string                                                    resource_name,
    std::unordered_map<std::string, int>& sym_mapped,
    std::vector<uint8_t>& shellcodebytes,
    std::unordered_map<std::string, std::tuple<PIMAGE_SYMBOL, weaponslib2::obj*>>& export_syms);

int main()
{
	// 读取lib
	//using namespace weaponslib2;
#ifdef _WIN64
    lib liber("payload_Debug_x64.lib");
#else
    lib liber("payload_Debug_Win32.lib");
#endif // _WIN64

    if (!liber.isLib())
    {
        ERO("lib format error");
        return -1;
    }
	else
		INF("lib format checked");

    std::vector<lib> libs;
    libs.push_back(liber);

    std::unordered_map<std::string, std::tuple<PIMAGE_SYMBOL, obj*>> export_syms;
    
    for (auto& lib : libs)
    {
        for (auto& obj : lib.objs())
        {
            for (auto& exp : obj.exports()) 
            {
                obj.walkSymbols([&](IMAGE_SYMBOL& Sym) {
                    // 找到对应导出名称的符号 PIMAGE_SYMBOL
                    if (exp == obj.getSymbolNameByImageSymble(Sym)) 
                    {
                        if (export_syms.find(exp) == export_syms.end()) {
                            export_syms.insert({ exp, {&Sym, &obj} });
                        }
                        else {
                            throw std::exception("Duplicate export symbol:\"%s\"");
                        }
                    }
                    });
            }
        }
    }

    std::vector<uint8_t>                                 shellcodebytes; //储存映射数据的内存
    std::unordered_map<PIMAGE_SECTION_HEADER, section_mapped_info> section_mapped; //所有被映射的节
    std::unordered_map<std::string, int>                           sym_mapped;     //所有被映射的符号
    std::vector<uint32_t>dir_offset;
   
    dir_offset.push_back(0xDEADC0DE);

    for (auto& exp : export_syms) 
        recursive_lookup_relocations(libs, exp.second, section_mapped, sym_mapped, shellcodebytes, dir_offset);

     for (auto& i : sym_mapped)
         INF("[ 0x%06x ] for %s", i.second, i.first.c_str());
    std::vector<uint8_t> combined;
    
    //写出 bin
#ifndef _WIN64
    std::vector<uint32_t> magic;
    magic.push_back(0xDEADC0DE);
    dir_offset.insert(dir_offset.begin() + 1, dir_offset.size() - 1);
    auto a_magic = tcb::span<uint8_t>((uint8_t*)magic.data(), magic.size() * sizeof(uint32_t));
    combined.insert(combined.end(), a_magic.begin(), a_magic.end());
    combined.insert(combined.end(), shellcodebytes.begin(), shellcodebytes.end());
    auto a_dir_offset = tcb::span<uint8_t>((uint8_t*)dir_offset.data(), dir_offset.size() * sizeof(uint32_t));
    combined.insert(combined.end(), a_dir_offset.begin(), a_dir_offset.end());

#else
    combined = std::move(shellcodebytes);
#endif // _WIN64
   
    IMP("----------");
    for (auto& exp : export_syms)
        IMP("Export at [ 0x%06x ] for %s", sym_mapped[exp.first], exp.first.c_str());
    IMP("----------");

    buffer_to_file_bin(combined.data(), combined.size(), out_bin_name);
    //写出 hpp
    print_shellcode_hpp_file(out_hpp_name, sym_mapped, combined, export_syms);

    SUC("shellcode generator success!");

	return 0;
}


void recursive_lookup_relocations(std::vector<lib>& libs,
    std::tuple<PIMAGE_SYMBOL, obj*> sym,
    std::unordered_map<PIMAGE_SECTION_HEADER, section_mapped_info>& section_mapped,
    std::unordered_map<std::string, int>& sym_mapped,
    std::vector<uint8_t>& shellcodebytes,
    std::vector<uint32_t>& dir_offset
    ) {

    // 获取符号名称
    const char* pSymName = std::get<obj*>(sym)->getSymbolNameByImageSymble(*std::get<PIMAGE_SYMBOL>(sym));

    if (sym_mapped.find(pSymName) != sym_mapped.end()) return;

    // 符号表示节或者存在于节中
    if (std::get<PIMAGE_SYMBOL>(sym)->SectionNumber > IMAGE_SYM_UNDEFINED)
    {
        auto ss = std::get<obj*>(sym)->sections();
        IMAGE_SECTION_HEADER& section = ss[static_cast<size_t>(std::get<PIMAGE_SYMBOL>(sym)->SectionNumber) - 1];
 
        // 此符号表示节名
        if (std::get<PIMAGE_SYMBOL>(sym)->Value == 0)
        {
            // 复制节到shellcode
            if (section_mapped.find(&section) == section_mapped.end())
            {
                size_t oldSize = shellcodebytes.size();
                shellcodebytes.resize(oldSize + section.SizeOfRawData, 0x00);
                sym_mapped[pSymName] = oldSize;

                memcpy(shellcodebytes.data() + oldSize,
                    static_cast<size_t>(section.PointerToRawData) + std::get<obj*>(sym)->getBuffer(),
                    section.SizeOfRawData);

                if (section.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA)
                    memset(shellcodebytes.data() + oldSize, 0x00, section.SizeOfRawData);

                section_mapped_info smi{};
                smi.maped_va = oldSize;
                smi.maped_size = section.SizeOfRawData;
                section_mapped[&section] = smi;
                //INF("符号:\"%s\" Va:0x%x/Size:0x%x ", pSymName, oldSize, section.SizeOfRawData);
            }
            // 节已经存在
            else
                sym_mapped[pSymName] = section_mapped[&section].maped_va;

            // 对节进行重定位
            // 遍历重定位表
            for (auto& reloca : std::get<obj*>(sym)->relocations(&section))
            {
                // 获取需要重定位符号
                auto& reloc_symbol = std::get<obj*>(sym)->symbols()[reloca.SymbolTableIndex];
                std::string reloc_name = std::get<obj*>(sym)->getSymbolNameByImageSymble(reloc_symbol);

                // 递归对重定位符号所在节进行重定位
                recursive_lookup_relocations(libs, { &reloc_symbol, std::get<obj*>(sym) }, section_mapped, sym_mapped, shellcodebytes,dir_offset);

                // INF("\t\t\t重定位符号:\"%s\" Va:0x%x", reloc_name.c_str(), sym_mapped[reloc_name]);
#ifdef _WIN64
                INF("reloc symbol name：%s, reloc type：%d", reloc_name.c_str(), reloca.Type);

                if (reloca.Type == IMAGE_REL_AMD64_REL32) {
                    *reinterpret_cast<int*>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                        sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                            (sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                }
                else if (reloca.Type == IMAGE_REL_AMD64_REL32_1) {
                    *reinterpret_cast<int*>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                        sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                            (1 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                }
                else if (reloca.Type == IMAGE_REL_AMD64_REL32_2) {
                    *reinterpret_cast<int*>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                        sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                            (2 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                }
                else if (reloca.Type == IMAGE_REL_AMD64_REL32_3) {
                    *reinterpret_cast<int*>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                        sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                            (3 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                }
                else if (reloca.Type == IMAGE_REL_AMD64_REL32_4) {
                    *reinterpret_cast<int*>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                        sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                            (4 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                }
                else if (reloca.Type == IMAGE_REL_AMD64_REL32_5) {
                    *reinterpret_cast<int*>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                        sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                            (5 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));

                }
#else
                if (reloca.Type == IMAGE_REL_I386_REL32)
                {
                    *reinterpret_cast<int*>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                        sym_mapped[pSymName]) = static_cast<int>(sym_mapped[reloc_name] -
                            (sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));;
                }

                else if (reloca.Type == IMAGE_REL_I386_DIR32)
                {
                    *reinterpret_cast<int*>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                        sym_mapped[pSymName]) = sym_mapped[reloc_name];
                    
                    uint32_t place = (uint32_t)(reloca.VirtualAddress + sym_mapped[pSymName]);
                    dir_offset.push_back(place);
                }

#endif // _WIN64
            }
        }

        // 此符号不表示节名，符号存在于节内
        else {
            // 通过value获取节内符号偏移
            if (section_mapped.find(&section) != section_mapped.end()) {
                auto section_maped_va = section_mapped[&section].maped_va;
                auto _sym_va = std::get<PIMAGE_SYMBOL>(sym)->Value;
                sym_mapped[pSymName] = section_maped_va + _sym_va;
                //IMP("静态数据\"%s\" Va:0x%x", pSymName, sym_mapped[pSymName]);
            }
            // 拷贝节到shellcode，但是还无法判断符号在节内偏移
            else {
                auto oldSize = shellcodebytes.size();
                shellcodebytes.resize(oldSize + section.SizeOfRawData, 0x00);

                memcpy(shellcodebytes.data() + oldSize,
                    static_cast<size_t>(section.PointerToRawData) + std::get<obj*>(sym)->getBuffer(),
                    section.SizeOfRawData);
                if (section.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
                    memset(shellcodebytes.data() + oldSize, 0x00, section.SizeOfRawData);
                }
                section_mapped_info smi{};
                smi.maped_va = oldSize;
                smi.maped_size = section.SizeOfRawData;
                section_mapped[&section] = smi;

                recursive_lookup_relocations(libs, { std::get<PIMAGE_SYMBOL>(sym), std::get<obj*>(sym) },
                    section_mapped, sym_mapped, shellcodebytes,dir_offset);
            }
        }

    }
    // 符号来自于外部引用
    else {
        if (std::get<PIMAGE_SYMBOL>(sym)->StorageClass == IMAGE_SYM_CLASS_EXTERNAL &&
            std::get<PIMAGE_SYMBOL>(sym)->Value > 0) {
            if (sym_mapped.find(pSymName) == sym_mapped.end()) {
                auto oldSize = shellcodebytes.size();
                shellcodebytes.resize(oldSize + std::get<PIMAGE_SYMBOL>(sym)->Value, 0x00);
                sym_mapped[pSymName] = oldSize;
                //IMP("External:\"%s\" Va:0x%x/Size:0x%x", pSymName, oldSize, std::get<PIMAGE_SYMBOL>(sym)->Value);
            }
        }
        else {

            //跨obj调用
            bool canResolve = false;
            for (auto& lib : libs) {
                for (auto& obj : lib.objs()) {
                    obj.walkSymbols([&](IMAGE_SYMBOL& Sym) {
                        if (strcmp(pSymName, obj.getSymbolNameByImageSymble(Sym)) == 0) {
                            if (Sym.SectionNumber > IMAGE_SYM_UNDEFINED ||
                                (Sym.StorageClass == IMAGE_SYM_CLASS_EXTERNAL && Sym.Value > 0)) {
                                canResolve = true;
                                recursive_lookup_relocations(libs, { &Sym, &obj }, section_mapped, sym_mapped, shellcodebytes,dir_offset);
                            }
                        }
                        });
                }
            }

            if (!canResolve) {
                ERO("Unresolved symbols \"%s\" ", pSymName);
                throw std::exception("Unresolved symbols");
            }
        }
    }
}

void print_shellcode_hpp_file(std::string                                                    resource_name,
    std::unordered_map<std::string, int>& sym_mapped,
    std::vector<uint8_t>& shellcodebytes,
    std::unordered_map<std::string, std::tuple<PIMAGE_SYMBOL, weaponslib2::obj*>>& export_syms) {
    //打开输出文件
    std::ofstream outFile;
    outFile.open(resource_name + ".hpp", std::ios::out);

    if (outFile.is_open()) {
        //输出头部信息
        outFile << "#pragma once" << std::endl;
        outFile << "#include <cstdint>" << std::endl;
        outFile << "namespace shellcode\n{" << std::endl;

        outFile << "namespace rva\n{" << std::endl;

        for (auto& iter : export_syms) {
#ifdef _M_IX86 // 32位模式下 编译器会在函数前面加一个 _
            uint32_t    maped_va = sym_mapped[iter.first];
            std::string exp = iter.first;
            if (exp.front() == '_') {
                exp.erase(exp.begin());
            }
            outFile << "const size_t " << exp << " = 0x" << std::hex << maped_va + 0x4 << ";\n";
#else
            outFile << "const size_t " << iter.first << " = 0x" << std::hex << sym_mapped[iter.first] << ";\n";
#endif // _M_IX86
        }
        outFile << "\n}\n" << std::endl;

        outFile << "unsigned char " + resource_name + " [] = " << std::endl;
        outFile << "\t{" << std::endl << "\t";

        for (size_t idx = 0; idx < shellcodebytes.size(); idx++) {
            if (idx % 80 == 0)
                outFile << "\n";
            uint8_t code_byte = shellcodebytes[idx];
            outFile << "0x" << std::hex << std::setw(2) << std::setfill('0') << (int)code_byte << ",";
        }

        outFile << "\t};" << std::endl;

        outFile << "\n};\n" << std::endl;
        outFile.close();
    }
    else {
        throw std::exception("Cannot open hpp file!");
    }
}

void recursive(const char* exp, obj& obj, tcb::span<IMAGE_SECTION_HEADER>& sections, std::vector<std::string>symname)
{
    auto it = std::find(symname.begin(), symname.end(), exp);

    if (it != symname.end())
        return;

    symname.push_back(exp);

    IMAGE_SYMBOL* img = obj.getImageSymbleBySymbolName(exp);

    IMP("-----------------------------------------------------------------------------");

    // 符号存在于某个节中
    if (img->SectionNumber > 0)
    {
        // 找到节头
        auto& sechdr = sections[img->SectionNumber - 0x1];

        // 获取节的重定位
        for (auto& reloc : obj.relocations(&sechdr))
        {
            // 重定位符号
            auto relocImageSymble = obj.symbols()[reloc.SymbolTableIndex];
            // 重定位符号名
            const char* relocSymbolName = obj.getSymbolNameByImageSymble(relocImageSymble);
            INF("节名：%s 重定位RVA: 0x%x 重定位到符号：%s 重定位类型：%d", sechdr.Name, reloc.VirtualAddress, relocSymbolName, reloc.Type);
            recursive(relocSymbolName, obj, sections, symname);
        }
    }

}
```

`payload/call-extern-demo.cpp`:

```cpp
#include "shellcode.h"


void ShellcodeFunctionCallExternExample(void) {

    //使用系统 API
    LI_FN(MessageBoxA)(HWND(0), "Shellcode Function Call Extern Example", xorstr_("Display from shellcode!"), MB_OK | MB_TOPMOST);

    return;
}
```

`payload/framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // 从 Windows 头文件中排除极少使用的内容

```

`payload/lazy_importer.hpp`:

```hpp
/*
 * Copyright 2018-2022 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// === FAQ === documentation is available at https://github.com/JustasMasiulis/lazy_importer
// * Code doesn't compile with errors about pointer conversion:
//  - Try using `nullptr` instead of `NULL` or call `get()` instead of using the overloaded operator()
// * Lazy importer can't find the function I want:
//   - Double check that the module in which it's located in is actually loaded
//   - Try #define LAZY_IMPORTER_CASE_INSENSITIVE
//     This will start using case insensitive comparison globally
//   - Try #define LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
//     This will enable forwarded export resolution globally instead of needing explicit `forwarded()` calls

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP


#define LI_FN(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<LAZY_IMPORTER_KHASH(name)>()

#ifndef LAZY_IMPORTER_CPP_FORWARD
#ifdef LAZY_IMPORTER_NO_CPP_FORWARD
#define LAZY_IMPORTER_CPP_FORWARD(t, v) v
#else
#include <utility>
#define LAZY_IMPORTER_CPP_FORWARD(t, v) std::forward<t>( v )
#endif
#endif

#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif


#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_CASE_SENSITIVITY false
#else
#define LAZY_IMPORTER_CASE_SENSITIVITY true
#endif

#define LAZY_IMPORTER_STRINGIZE(x) #x
#define LAZY_IMPORTER_STRINGIZE_EXPAND(x) LAZY_IMPORTER_STRINGIZE(x)

#define LAZY_IMPORTER_KHASH(str) ::li::detail::khash(str, \
    ::li::detail::khash_impl( __TIME__ __DATE__ LAZY_IMPORTER_STRINGIZE_EXPAND(__LINE__) LAZY_IMPORTER_STRINGIZE_EXPAND(__COUNTER__), 2166136261 ))

namespace li { namespace detail {

    namespace win {

        struct LIST_ENTRY_T {
            const char* Flink;
            const char* Blink;
        };

        struct UNICODE_STRING_T {
            unsigned short Length;
            unsigned short MaximumLength;
            wchar_t*       Buffer;
        };

        struct PEB_LDR_DATA_T {
            unsigned long Length;
            unsigned long Initialized;
            const char*   SsHandle;
            LIST_ENTRY_T  InLoadOrderModuleList;
        };

        struct PEB_T {
            unsigned char   Reserved1[2];
            unsigned char   BeingDebugged;
            unsigned char   Reserved2[1];
            const char*     Reserved3[2];
            PEB_LDR_DATA_T* Ldr;
        };

        struct LDR_DATA_TABLE_ENTRY_T {
            LIST_ENTRY_T InLoadOrderLinks;
            LIST_ENTRY_T InMemoryOrderLinks;
            LIST_ENTRY_T InInitializationOrderLinks;
            const char*  DllBase;
            const char*  EntryPoint;
            union {
                unsigned long SizeOfImage;
                const char*   _dummy;
            };
            UNICODE_STRING_T FullDllName;
            UNICODE_STRING_T BaseDllName;

            LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                                            load_order_next() const noexcept
            {
                return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                    InLoadOrderLinks.Flink);
            }
        };

        struct IMAGE_DOS_HEADER { // DOS .EXE header
            unsigned short e_magic; // Magic number
            unsigned short e_cblp; // Bytes on last page of file
            unsigned short e_cp; // Pages in file
            unsigned short e_crlc; // Relocations
            unsigned short e_cparhdr; // Size of header in paragraphs
            unsigned short e_minalloc; // Minimum extra paragraphs needed
            unsigned short e_maxalloc; // Maximum extra paragraphs needed
            unsigned short e_ss; // Initial (relative) SS value
            unsigned short e_sp; // Initial SP value
            unsigned short e_csum; // Checksum
            unsigned short e_ip; // Initial IP value
            unsigned short e_cs; // Initial (relative) CS value
            unsigned short e_lfarlc; // File address of relocation table
            unsigned short e_ovno; // Overlay number
            unsigned short e_res[4]; // Reserved words
            unsigned short e_oemid; // OEM identifier (for e_oeminfo)
            unsigned short e_oeminfo; // OEM information; e_oemid specific
            unsigned short e_res2[10]; // Reserved words
            long           e_lfanew; // File address of new exe header
        };

        struct IMAGE_FILE_HEADER {
            unsigned short Machine;
            unsigned short NumberOfSections;
            unsigned long  TimeDateStamp;
            unsigned long  PointerToSymbolTable;
            unsigned long  NumberOfSymbols;
            unsigned short SizeOfOptionalHeader;
            unsigned short Characteristics;
        };

        struct IMAGE_EXPORT_DIRECTORY {
            unsigned long  Characteristics;
            unsigned long  TimeDateStamp;
            unsigned short MajorVersion;
            unsigned short MinorVersion;
            unsigned long  Name;
            unsigned long  Base;
            unsigned long  NumberOfFunctions;
            unsigned long  NumberOfNames;
            unsigned long  AddressOfFunctions; // RVA from base of image
            unsigned long  AddressOfNames; // RVA from base of image
            unsigned long  AddressOfNameOrdinals; // RVA from base of image
        };

        struct IMAGE_DATA_DIRECTORY {
            unsigned long VirtualAddress;
            unsigned long Size;
        };

        struct IMAGE_OPTIONAL_HEADER64 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long long   ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long long   SizeOfStackReserve;
            unsigned long long   SizeOfStackCommit;
            unsigned long long   SizeOfHeapReserve;
            unsigned long long   SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_OPTIONAL_HEADER32 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long        BaseOfData;
            unsigned long        ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long        SizeOfStackReserve;
            unsigned long        SizeOfStackCommit;
            unsigned long        SizeOfHeapReserve;
            unsigned long        SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_NT_HEADERS {
            unsigned long     Signature;
            IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
            IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
            IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
        };

    } // namespace win

    struct forwarded_hashes {
       unsigned module_hash;
       unsigned function_hash;
    };

    // 64 bit integer where 32 bits are used for the hash offset
    // and remaining 32 bits are used for the hash computed using it
    using offset_hash_pair = unsigned long long;

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_hash(offset_hash_pair pair) noexcept { return ( pair & 0xFFFFFFFF ); }

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_offset(offset_hash_pair pair) noexcept { return ( pair >> 32 ); }

    template<bool CaseSensitive = LAZY_IMPORTER_CASE_SENSITIVITY>
    LAZY_IMPORTER_FORCEINLINE constexpr unsigned hash_single(unsigned value, char c) noexcept
    {
        return static_cast<unsigned int>(
            (value ^ ((CaseSensitive && c >= 'A' && c <= 'Z') ? (c | (1 << 5)) : c)) *
            static_cast<unsigned long long>(16777619));
    }

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned
        khash_impl(const char* str, unsigned value) noexcept
    {
        return (*str ? khash_impl(str + 1, hash_single(value, *str)) : value);
    }

    LAZY_IMPORTER_FORCEINLINE constexpr offset_hash_pair khash(
        const char* str, unsigned offset) noexcept
    {
        return ((offset_hash_pair{ offset } << 32) | khash_impl(str, offset));
    }

    template<class CharT = char>
    LAZY_IMPORTER_FORCEINLINE unsigned hash(const CharT* str, unsigned offset) noexcept
    {
        unsigned value = offset;

        for(;;) {
            char c = *str++;
            if(!c)
                return value;
            value = hash_single(value, c);
        }
    }

    LAZY_IMPORTER_FORCEINLINE unsigned hash(
       const win::UNICODE_STRING_T& str, unsigned offset) noexcept
    {
        auto       first = str.Buffer;
        const auto last  = first + (str.Length / sizeof(wchar_t));
        auto       value = offset;
        for(; first != last; ++first)
            value = hash_single(value, static_cast<char>(*first));

        return value;
    }

    LAZY_IMPORTER_FORCEINLINE forwarded_hashes hash_forwarded(
        const char* str, unsigned offset) noexcept
    {
        forwarded_hashes res{ offset, offset };

        for(; *str != '.'; ++str)
            res.module_hash = hash_single<true>(res.module_hash, *str);

        ++str;

        for(; *str; ++str)
            res.function_hash = hash_single(res.function_hash, *str);

        return res;
    }

    // some helper functions
    LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
    {
#if defined(_M_X64) || defined(__amd64__)
        return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
        return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
        return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
        return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
        return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
    }

    LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
    {
        return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
            base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
            base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
    }

    LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
    {
        return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
            ldr()->InLoadOrderModuleList.Flink);
    }

    struct exports_directory {
        const char*                        _base;
        const win::IMAGE_EXPORT_DIRECTORY* _ied;
        unsigned long                      _ied_size;

    public:
        using size_type = unsigned long;

        LAZY_IMPORTER_FORCEINLINE
        exports_directory(const char* base) noexcept : _base(base)
        {
            const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
            _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + ied_data_dir.VirtualAddress);
            _ied_size = ied_data_dir.Size;
        }

        LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
        {
            return reinterpret_cast<const char*>(_ied) != _base;
        }

        LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
        {
            return _ied->NumberOfNames;
        }

        LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
        {
            return _ied;
        }

        LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
        {
            return reinterpret_cast<const char*>(
                _base + reinterpret_cast<const unsigned long*>(
                            _base + _ied->AddressOfNames)[index]);
        }

        LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
        {
            const auto* const rva_table =
                reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

            const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                _base + _ied->AddressOfNameOrdinals);

            return _base + rva_table[ord_table[index]];
        }

        LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
            const char* export_address) const noexcept
        {
            const auto ui_ied = reinterpret_cast<const char*>(_ied);
            return (export_address > ui_ied && export_address < ui_ied + _ied_size);
        }
    };

    struct safe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
        value_type* value;
        value_type* head;

        LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
            : safe_module_enumerator(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE
        safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
            : value(ldr->load_order_next()), head(value)
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept
        {
            value = head->load_order_next();
        }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();

            return value != head && value->DllBase;
        }
    };

    struct unsafe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
        value_type value;

        LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
            : value(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();
            return true;
        }
    };

    // provides the cached functions which use Derive classes methods
    template<class Derived, class DefaultType = void*>
    class lazy_base {
    protected:
        // This function is needed because every templated function
        // with different args has its own static buffer
        LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
        {
            static void* value = nullptr;
            return value;
        }

    public:
        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
        {
            return Derived::template get<T, safe_module_enumerator>();
        }

        template<class T = DefaultType, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
        {
            auto& cached = _cache();
            if(!cached)
                cached = Derived::template get<void*, Enum>();

            return (T)(cached);
        }

        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
        {
            return cached<T, safe_module_enumerator>();
        }
    };

    template<offset_hash_pair OHP>
    struct lazy_module : lazy_base<lazy_module<OHP>> {
        template<class T = void*, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T get() noexcept
        {
            Enum e;
            do {
                if(hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }

        template<class T = void*, class Ldr>
        LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
        {
            safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
            do {
                if(hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }

        template<class T = void*, class Ldr>
        LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
        {
            auto& cached = lazy_base<lazy_module<OHP>>::_cache();
            if(!cached)
                cached = in(ldr);

            return (T)(cached);
        }
    };

    template<offset_hash_pair OHP, class T>
    struct lazy_function : lazy_base<lazy_function<OHP, T>, T> {
        using base_type = lazy_base<lazy_function<OHP, T>, T>;

        template<class... Args>
        LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
        {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
            return get()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#else
            return this->cached()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F get() noexcept
        {
            // for backwards compatability.
            // Before 2.0 it was only possible to resolve forwarded exports when
            // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
            return forwarded<F, Enum>();
#else

            Enum e;

            do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                if(!e.value->DllBase || !e.value->FullDllName.Length)
                    continue;
#endif

                const exports_directory exports(e.value->DllBase);

                if(exports) {
                    auto export_index = exports.size();
                    while(export_index--)
                        if(hash(exports.name(export_index), get_offset(OHP)) == get_hash(OHP))
                            return (F)(exports.address(export_index));
                }
            } while(e.next());
            return {};
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
        {
            detail::win::UNICODE_STRING_T name;
            forwarded_hashes              hashes{ 0, get_hash(OHP) };

            Enum e;
            do {
                name = e.value->BaseDllName;
                name.Length -= 8; // get rid of .dll extension

                if(!hashes.module_hash || hash(name, get_offset(OHP)) == hashes.module_hash) {
                    const exports_directory exports(e.value->DllBase);

                    if(exports) {
                        auto export_index = exports.size();
                        while(export_index--)
                            if(hash(exports.name(export_index), get_offset(OHP)) == hashes.function_hash) {
                                const auto addr = exports.address(export_index);

                                if(exports.is_forwarded(addr)) {
                                    hashes = hash_forwarded(
                                        reinterpret_cast<const char*>(addr),
                                        get_offset(OHP));

                                    e.reset();
                                    break;
                                }
                                return (F)(addr);
                            }
                    }
                }
            } while(e.next());
            return {};
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
        {
            return forwarded<F, safe_module_enumerator>();
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = forwarded<void*, Enum>();
            return (F)(value);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
        {
            return forwarded_cached<F, safe_module_enumerator>();
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
        {
            if(IsSafe && !m)
                return {};

            const exports_directory exports((const char*)(m));
            if(IsSafe && !exports)
                return {};

            for(unsigned long i{};; ++i) {
                if(IsSafe && i == exports.size())
                    break;

                if(hash(exports.name(i), get_offset(OHP)) == get_hash(OHP))
                    return (F)(exports.address(i));
            }
            return {};
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
        {
            return in<F, true>(m);
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = in<void*, IsSafe>(m);
            return (F)(value);
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
        {
            return in_cached<F, true>(m);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
        {
            return in<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
        {
            return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
        {
            return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
        {
            return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }
    };

}} // namespace li::detail

#endif // include guard

```

`payload/payload.cpp`:

```cpp
// payload.cpp : 定义静态库的函数。
//
#include "shellcode.h"
#include "xorstr.hpp"
#include "lazy_importer.hpp"
#include <string>
// TODO: 这是一个库函数示例

#ifndef _WIN64

__declspec(naked) uint8_t* getEip()
{
    __asm
    {
        call NEXT
        NEXT :
        pop eax
        ret
    }
}

SC_EXPORT DWORD fix(LPVOID lpParameter)
{
    uint8_t* eax = getEip();

    do
    {
        if (eax[0] != 0xDE ||
            eax[1] != 0xC0 ||
            eax[2] != 0xAD ||
            eax[3] != 0xDE
            )
        {
            eax--;
            continue;
        }
        else
            break;

    } while (true);

    uint8_t* base = eax;
    eax = getEip();

    do {
        if (eax[0] != 0xDE ||
            eax[1] != 0xC0 ||
            eax[2] != 0xAD ||
            eax[3] != 0xDE
            )
        {
            eax++;
            continue;
        }
        else
            break;

    } while (true);

    uint8_t* dir_rel = eax;
    uint32_t count = *(uint32_t*)(dir_rel + 0x4);

    dir_rel += 0x8;

    if (count > 0)
    {
        for (uint32_t i = 0; i < count; i++)
        {
            uint32_t* place = (uint32_t*)((*(uint32_t*)dir_rel) + base + 0x4);
            *place = (uint32_t)(*place + base + 0x4);
            dir_rel += 0x4;
        }
    }

    return 0;
}


#endif // 

extern void ShellcodeFunctionCallExternExample(void);
const char* globalStr = "helloworld";
const char* globalStr1 = "你好中国：》";
int globalVar = 0x414141;

SC_EXPORT_DATA(volatile unsigned int, CaptureWidth)
SC_EXPORT_DATA(volatile unsigned int, CaptureHeight)
#ifdef _WIN64
SC_EXPORT_DATA(volatile unsigned int, Eight000)
#else
SC_EXPORT_DATA(volatile unsigned int, Seven00)
#endif // _WIN64



void printStatic()
{
    static int sta = 0;
    LI_FN(printf)("static value: %d\n", sta++);
}


/* shallcode 入口示例 */
SC_EXPORT DWORD ShellcodeFunctionEntryPointExample(LPVOID lpParameter)
{

    // 调试输出
    DbgPrint("Thread lpParameter %d", lpParameter);

    // 使用 sprintf 、 字符串 、 以及编译器常量 
    /*
    32位 CHAR buf[512] = { 0 }会调用c库函数_memset, 64位使用rep指令
    所以32位不应这样初始化，需显示调用LI_FN(memset)或者使用宏SecureZeroMemory
    */
    CHAR buf[512];
    SecureZeroMemory(buf, sizeof(buf));
    LI_FN(sprintf)(buf, "Hello The thread parameter is 0x%p and The function name is %s", lpParameter, __FUNCTION__);

    //使用系统 API
    LI_FN(MessageBoxA)(HWND(0), buf,"Display from shellcode", MB_OK | MB_TOPMOST);

    LI_FN(printf)("globalVar: %d\n",globalVar);
    LI_FN(printf)("globalStr: %s\n",globalStr);
    LI_FN(printf)("globalStr: %s\n", globalStr1);

    // 跨.cpp调用函数 可以通过 extern，也可以通过在共同头文件中给出声明
    ShellcodeFunctionCallExternExample();

    int count = 0;

    do {
        printStatic();
        count++;
    } while (count < 3);

    auto a = [](const char* str)
    {
        LI_FN(printf)("lambda str: %s\n", str);
    };

    a("lambda test");

    return 0;
}

```

`payload/payload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{06a9cd95-127d-46dc-9a5e-e7966716d356}</ProjectGuid>
    <RootNamespace>payload</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>\bin\intermediate</IntDir>
    <TargetName>$(projectname)_$(configuration)_$(platform)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>\bin\intermediate</IntDir>
    <TargetName>$(projectname)_$(configuration)_$(platform)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>\bin\intermediate</IntDir>
    <TargetName>$(projectname)_$(configuration)_$(platform)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>\bin\intermediate</IntDir>
    <TargetName>$(projectname)_$(configuration)_$(platform)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>LAZY_IMPORTER_HARDENED_MODULE_CHECKS;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <SupportJustMyCode>false</SupportJustMyCode>
      <Optimization>MinSpace</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>LAZY_IMPORTER_HARDENED_MODULE_CHECKS;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <Optimization>MinSpace</Optimization>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <SupportJustMyCode>false</SupportJustMyCode>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <Optimization>MinSpace</Optimization>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="call-extern-demo.cpp" />
    <ClCompile Include="payload.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lazy_importer.hpp" />
    <ClInclude Include="shellcode.h" />
    <ClInclude Include="xorstr.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`payload/payload.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="payload.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="call-extern-demo.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lazy_importer.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="shellcode.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="xorstr.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`payload/payload.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`payload/pch.cpp`:

```cpp
// pch.cpp: 与预编译标头对应的源文件

#include "pch.h"

// 当使用预编译的头时，需要使用此源文件，编译才能成功。

```

`payload/pch.h`:

```h
// pch.h: 这是预编译标头文件。
// 下方列出的文件仅编译一次，提高了将来生成的生成性能。
// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。
// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。
// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。

#ifndef PCH_H
#define PCH_H

// 添加要在此处预编译的标头
#include "framework.h"

#endif //PCH_H

```

`payload/shellcode.h`:

```h
#pragma once
#include "lazy_importer.hpp"
#ifndef _M_IX86
#include "xorstr.hpp"
#else
#define xorstr_(str) (str)
#endif //

#include <Windows.h>
#include <cstdio>
#define SC_EXPORT extern "C" _declspec(dllexport)
#define SC_EXPORT_DATA(type, data)                                                                                     \
    extern "C" _declspec(dllexport) type data;                                                                         \
    type                                 data;

template <typename T, size_t N>
constexpr size_t ArrNum(T (&A)[N]) {
    return N;
}

template <typename... Args>
void __DbgPrint(const char *format, Args... args) {
    CHAR buf[512];
    LI_FN(memset)(buf, 0, sizeof(buf));
    LI_FN(sprintf)
    (buf, format, args...);
    LI_FN(OutputDebugStringA)(buf);
}

#ifdef _DEBUG
#define DbgPrint(format, ...) __DbgPrint("[ payload ]" format "\t --line: %05d \n", __VA_ARGS__, __LINE__)
#else
#define DbgPrint(format, ...)
#endif // _DEBUG


```

`payload/xorstr.hpp`:

```hpp
/*
 * Copyright 2017 - 2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP
#define JM_XORSTR_DISABLE_AVX_INTRINSICS
#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>
#include <type_traits>

#define xorstr(str) ::jm::xor_string([]() { return str; }, std::integral_constant<std::size_t, sizeof(str) / sizeof(*str)>{}, std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline)) inline
#endif

#if defined(__clang__) || defined(__GNUC__)
#define JM_XORSTR_LOAD_FROM_REG(x) ::jm::detail::load_from_reg(x)
#else
#define JM_XORSTR_LOAD_FROM_REG(x) (x)
#endif

namespace jm {

    namespace detail {

        template<std::size_t Size>
        XORSTR_FORCEINLINE constexpr std::size_t _buffer_size()
        {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<std::uint32_t Seed>
        XORSTR_FORCEINLINE constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for(char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        XORSTR_FORCEINLINE constexpr std::uint64_t key8()
        {
            constexpr auto first_part  = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // loads up to 8 characters of string into uint64 and xors it with the key
        template<std::size_t N, class CharT>
        XORSTR_FORCEINLINE constexpr std::uint64_t
        load_xored_str8(std::uint64_t key, std::size_t idx, const CharT* str) noexcept
        {
            using cast_type = typename std::make_unsigned<CharT>::type;
            constexpr auto value_size = sizeof(CharT);
            constexpr auto idx_offset = 8 / value_size;

            std::uint64_t value = key;
            for(std::size_t i = 0; i < idx_offset && i + idx * idx_offset < N; ++i)
                value ^=
                    (std::uint64_t{ static_cast<cast_type>(str[i + idx * idx_offset]) }
                     << ((i % idx_offset) * 8 * value_size));

            return value;
        }

        // forces compiler to use registers instead of stuffing constants in rdata
        XORSTR_FORCEINLINE std::uint64_t load_from_reg(std::uint64_t value) noexcept
        {
#if defined(__clang__) || defined(__GNUC__)
            asm("" : "=r"(value) : "0"(value) :);
#endif
            return value;
        }

        template<std::uint64_t V>
        struct uint64_v {
            constexpr static std::uint64_t value = V;
        };

    } // namespace detail

    template<class CharT, std::size_t Size, class Keys, class Indices>
    class xor_string;

    template<class CharT, std::size_t Size, std::uint64_t... Keys, std::size_t... Indices>
    class xor_string<CharT, Size, std::integer_sequence<std::uint64_t, Keys...>, std::index_sequence<Indices...>> {
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
        constexpr static inline std::uint64_t alignment = ((Size > 16) ? 32 : 16);    
#else
        constexpr static inline std::uint64_t alignment = 16;
#endif

        alignas(alignment) std::uint64_t _storage[sizeof...(Keys)];

    public:
        using value_type    = CharT;
        using size_type     = std::size_t;
        using pointer       = CharT*;
        using const_pointer = const CharT*;

        template<class L>
        XORSTR_FORCEINLINE xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) noexcept
            : _storage{ JM_XORSTR_LOAD_FROM_REG(detail::uint64_v<detail::load_xored_str8<Size>(Keys, Indices, l())>::value)... }
        {}

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return Size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
            std::uint64_t*    keys =
                (std::uint64_t*)JM_XORSTR_LOAD_FROM_REG((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr(sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                                  _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
        ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
            reinterpret_cast<__m128i*>(_storage) + Indices,
            _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                          _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer get() noexcept
        {
            return reinterpret_cast<pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer crypt_get() noexcept
        {
            // crypt() function inlined by hand, because MSVC linker chokes when you have a lot of strings
            // on 32 bit builds, so don't blame me for shit code :pepekms:
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
            std::uint64_t*    keys =
                (std::uint64_t*)JM_XORSTR_LOAD_FROM_REG((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr(sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                                  _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
        ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
            reinterpret_cast<__m128i*>(_storage) + Indices,
            _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                          _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
            return (pointer)(_storage);
        }
    };

    template<class L, std::size_t Size, std::size_t... Indices>
    xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) -> xor_string<
                std::remove_const_t<std::remove_reference_t<decltype(l()[0])>>,
                Size,
                std::integer_sequence<std::uint64_t, detail::key8<Indices>()...>,
                std::index_sequence<Indices...>>;

} // namespace jm

#endif // include guard

```

`run/main.cpp`:

```cpp
#ifdef _WIN64
#ifdef _DEBUG
#include "payload.hpp"
#else
#include "payload.hpp"
#endif
#else
#ifdef _DEBUG
#include "payload.hpp"
#else
#include "payload.hpp"
#endif
#endif // _WIN64

#include <stdio.h>
#include <Windows.h>
int main() {
    LoadLibraryA("user32.dll");
    LoadLibraryA("kernel32.dll");
    LoadLibraryA("KernelBase.dll");
    LoadLibraryA("msvcrt.dll");
    LoadLibraryA("gdi32.dll");

    auto shell_address = VirtualAlloc(0, sizeof(shellcode::payload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    memcpy(shell_address, shellcode::payload, sizeof(shellcode::payload));
    
    // 32位默认使用cdcel
    typedef DWORD(*RUNSHELLCODE)(
        LPVOID lpThreadParameter
        );
#ifndef _WIN64
    reinterpret_cast<RUNSHELLCODE>(reinterpret_cast<char*>(shell_address) +
        shellcode::rva::fix)((void*)0x9999999);
#endif // 

    reinterpret_cast<RUNSHELLCODE>(reinterpret_cast<char*>(shell_address) +
        shellcode::rva::ShellcodeFunctionEntryPointExample)((void*)0x9999999);

    //reinterpret_cast<LPTHREAD_START_ROUTINE>(reinterpret_cast<char *>(shell_address) +
    //                                         shellcode::rva::ShellCodeEntryPoint2)((void *)0x9999999);
    //reinterpret_cast<LPTHREAD_START_ROUTINE>(reinterpret_cast<char *>(shell_address) +
    //                                         shellcode::rva::ShellCodeEntryPoint3)((void *)0x9999999);

    return 0;
}
```

`run/run.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c951e5df-e51e-4a53-a896-35ba0b18be67}</ProjectGuid>
    <RootNamespace>run</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(solutiondir)bin\</OutDir>
    <IntDir>bin\intermediate</IntDir>
    <TargetName>$(projectname)_$(configuration)_$(platform)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(solutiondir)bin\</OutDir>
    <IntDir>bin\intermediate</IntDir>
    <TargetName>$(projectname)_$(configuration)_$(platform)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(solutiondir)bin\</OutDir>
    <IntDir>bin\intermediate</IntDir>
    <TargetName>$(projectname)_$(configuration)_$(platform)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(solutiondir)bin\</OutDir>
    <IntDir>bin\intermediate</IntDir>
    <TargetName>$(projectname)_$(configuration)_$(platform)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(solutiondir)bin\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(solutiondir)bin\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(solutiondir)bin\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(solutiondir)bin\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`run/run.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`run/run.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```