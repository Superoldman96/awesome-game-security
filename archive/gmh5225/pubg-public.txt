Project Path: arc_gmh5225_pubg-public_kdu9f7yz

Source Tree:

```txt
arc_gmh5225_pubg-public_kdu9f7yz
├── Address.h
├── Aimbot.h
├── BoneIdx.h
├── Decrypt.masm
├── Entitys.h
├── GNames.h
├── Howon.vcxproj
├── Howon.vcxproj.filters
├── Howon.vcxproj.user
├── Main.cpp
├── Proxy.h
├── Public.sln
├── README.md
├── SDK.h
├── Settings.h
├── Vector.h
├── XeDecrypt.cpp
├── XeDecrypt.h
├── Xors.h
├── defs.h
├── driver.cpp
├── driver.h
└── include.h

```

`Address.h`:

```h
#define __OFFSET__Decrypt 0x5f5ff28 //o
#define __OFFSET__UWorld 0x82cb1c0 //1

#define __OFFSET__GNames 0x83ec0d8 + 0x20 //o + 0x20
#define __OFFSET__PlayerController 0x40 //o
#define __OFFSET__Pawn 0x460 //? // 0x490
#define __OFFSET__LocalPlayer 0x8476a60 //o
#define __OFFSET__SpectateCount 0x1700 //o

#define __OFFSET__Level 0x948 //o
#define __OFFSET__Actors 0x1B0 //o
#define __OFFSET__ActorID 0x20 //o
#define __OFFSET__ActorTeam 0x1768 //o

#define __OFFSET__CameraManager 0x4a8 //o // -20 pawn and 88 pawn
#define __OFFSET__CameraCache_Loc 0x160C //o
#define __OFFSET__CameraCache_Rot 0x15FC //o
#define __OFFSET__CameraCache_FOV 0x1068 //o
#define __OFFSET__LastRenderTime 0x7A0 //o

//prediction
#define __OFFSET__WEAPONPROCESSOR 0xf50
#define __OFFSET__EquippedWeapons 0x2b8 //o
#define __OFFSET__WEAPONTRAJECTORYDATA 0xf58 //o
#define __OFFSET__TRAJECTORYCONFIG 0x118 // o
#define __OFFSET__ActorVelocity 0x364 // o

#define __OFFSET__Health 0xc18 //1 o
#define __OFFSET__GroggyHealth 0xbfc
#define __OFFSET__RootComponent 0x108 //1 o
#define __OFFSET_ROOTCOMPONENT_LOCATION __OFFSET__ComponentToWorld + 0x10 //0x21C //__OFFSET__ComponentToWorld + 10

#define __OFFSET__ActorMesh 0x548 //o //0x510
#define __OFFSET__UANIMINSTANCE 0xca0 //AnimInst o
#define __OFFSET__CONTROL_ROTATION_CP 0x6b8 //o
#define __OFFSET__RECOIL_ADS_ROTATION_CP 0x8dc //o
#define __OFFSET__LeanRight 0xc88 //o
#define __OFFSET__LeanLeft 0xc84 //o
#define __OFFSET__ComponentToWorld 0x2d0 //o
#define __OFFSET__BoneArray 0xaf8 //o
#define __OFFSET__ChunkSize 0x4104 //o

//car veloctiy
#define __OFFSET__VehicleRiderComponent 0x1968
#define __OFFSET__LastVehiclePawn 0x260
#define __OFFSET__SEATINDEX 0x228
#define __OFFSET__ReplicatedMovement 0x60

```

`Aimbot.h`:

```h
#pragma once
#include "include.h"

void AimBot_API(float X, float Y)
{
	float ScreenCenterX = (Width / 2);
	float ScreenCenterY = (Height / 2);
	float TargetX = 0;
	float TargetY = 0;

	if (X != 0)
	{
		if (X > ScreenCenterX)
		{
			TargetX = -(ScreenCenterX - X);
			TargetX /= AimSpeed;
			if (TargetX + ScreenCenterX > ScreenCenterX * 2) TargetX = 0;
		}

		if (X < ScreenCenterX)
		{
			TargetX = X - ScreenCenterX;
			TargetX /= AimSpeed;
			if (TargetX + ScreenCenterX < 0) TargetX = 0;
		}
	}

	if (Y != 0)
	{
		if (Y > ScreenCenterY)
		{
			TargetY = -(ScreenCenterY - Y);
			TargetY /= AimSpeed;
			if (TargetY + ScreenCenterY > ScreenCenterY * 2) TargetY = 0;
		}

		if (Y < ScreenCenterY)
		{
			TargetY = Y - ScreenCenterY;
			TargetY /= AimSpeed;
			if (TargetY + ScreenCenterY < 0) TargetY = 0;
		}
	}

	INPUT InputMouse = { 0 };
	InputMouse.type = INPUT_MOUSE;
	InputMouse.mi.dwFlags = MOUSEEVENTF_MOVE;
	if (abs((DWORD)TargetX * AimSpeed) > 1)
		InputMouse.mi.dx = (DWORD)TargetX;
	if (abs((DWORD)TargetY * AimSpeed) > 1)
		InputMouse.mi.dy = (DWORD)TargetY;

	SendInput(1, &InputMouse, sizeof(INPUT));

	return;
}
```

`BoneIdx.h`:

```h
#pragma once
#include "include.h"

enum EBoneIndex
{
	root = 0,
	pelvis = 1,
	spine_01 = 2,
	spine_02 = 3,
	spine_03 = 4,
	neck_01 = 5,
	Head = 6,
	face_root = 7,
	eyebrows_pos_root = 8,
	eyebrows_root = 9,
	eyebrows_r = 10,
	eyebrows_l = 11,
	eyebrow_l = 12,
	eyebrow_r = 13,
	forehead_root = 14,
	forehead = 15,
	jaw_pos_root = 16,
	jaw_root = 17,
	jaw = 18,
	mouth_down_pos_root = 19,
	mouth_down_root = 20,
	lip_bm_01 = 21,
	lip_bm_02 = 22,
	lip_br = 23,
	lip_bl = 24,
	jaw_01 = 25,
	jaw_02 = 26,
	cheek_pos_root = 27,
	cheek_root = 28,
	cheek_r = 29,
	cheek_l = 30,
	nose_side_root = 31,
	nose_side_r_01 = 32,
	nose_side_r_02 = 33,
	nose_side_l_01 = 34,
	nose_side_l_02 = 35,
	eye_pos_r_root = 36,
	eye_r_root = 37,
	eye_rot_r_root = 38,
	eye_lid_u_r = 39,
	eye_r = 40,
	eye_lid_b_r = 41,
	eye_pos_l_root = 42,
	eye_l_root = 43,
	eye_rot_l_root = 44,
	eye_lid_u_l = 45,
	eye_l = 46,
	eye_lid_b_l = 47,
	nose_pos_root = 48,
	nose = 49,
	mouth_up_pos_root = 50,
	mouth_up_root = 51,
	lip_ul = 52,
	lip_um_01 = 53,
	lip_um_02 = 54,
	lip_ur = 55,
	lip_l = 56,
	lip_r = 57,
	hair_root = 58,
	hair_b_01 = 59,
	hair_b_02 = 60,
	hair_l_01 = 61,
	hair_l_02 = 62,
	hair_r_01 = 63,
	hair_r_02 = 64,
	hair_f_02 = 65,
	hair_f_01 = 66,
	hair_b_pt_01 = 67,
	hair_b_pt_02 = 68,
	hair_b_pt_03 = 69,
	hair_b_pt_04 = 70,
	hair_b_pt_05 = 71,
	hair_l_pt_01 = 72,
	hair_l_pt_02 = 73,
	hair_l_pt_03 = 74,
	hair_l_pt_04 = 75,
	hair_l_pt_05 = 76,
	hair_r_pt_01 = 77,
	hair_r_pt_02 = 78,
	hair_r_pt_03 = 79,
	hair_r_pt_04 = 80,
	hair_r_pt_05 = 81,
	camera_fpp = 82,
	GunReferencePoint = 83,
	GunRef = 84,
	breast_l = 85,
	breast_r = 86,
	clavicle_l = 87,
	upperarm_l = 88,
	lowerarm_l = 89,
	hand_l = 90,
	thumb_01_l = 91,
	thumb_02_l = 92,
	thumb_03_l = 93,
	thumb_04_l_MBONLY = 94,
	index_01_l = 95,
	index_02_l = 96,
	index_03_l = 97,
	index_04_l_MBONLY = 98,
	middle_01_l = 99,
	middle_02_l = 100,
	middle_03_l = 101,
	middle_04_l_MBONLY = 102,
	ring_01_l = 103,
	ring_02_l = 104,
	ring_03_l = 105,
	ring_04_l_MBONLY = 106,
	pinky_01_l = 107,
	pinky_02_l = 108,
	pinky_03_l = 109,
	pinky_04_l_MBONLY = 110,
	item_l = 111,
	lowerarm_twist_01_l = 112,
	upperarm_twist_01_l = 113,
	clavicle_r = 114,
	upperarm_r = 115,
	lowerarm_r = 116,
	hand_r = 117,
	thumb_01_r = 118,
	thumb_02_r = 119,
	thumb_03_r = 120,
	thumb_04_r_MBONLY = 121,
	index_01_r = 122,
	index_02_r = 123,
	index_03_r = 124,
	index_04_r_MBONLY = 125,
	middle_01_r = 126,
	middle_02_r = 127,
	middle_03_r = 128,
	middle_04_r_MBONLY = 129,
	ring_01_r = 130,
	ring_02_r = 131,
	ring_03_r = 132,
	ring_04_r_MBONLY = 133,
	pinky_01_r = 134,
	pinky_02_r = 135,
	pinky_03_r = 136,
	pinky_04_r_MBONLY = 137,
	item_r = 138,
	lowerarm_twist_01_r = 139,
	upperarm_twist_01_r = 140,
	Backpack = 141,
	backpack_01 = 142,
	backpack_02 = 143,
	slot_primary = 144,
	slot_secondary = 145,
	slot_melee = 146,
	slot_throwable = 147,
	coat_l_01 = 148,
	coat_l_02 = 149,
	coat_l_03 = 150,
	coat_l_04 = 151,
	coat_fl_01 = 152,
	coat_fl_02 = 153,
	coat_fl_03 = 154,
	coat_fl_04 = 155,
	coat_b_01 = 156,
	coat_b_02 = 157,
	coat_b_03 = 158,
	coat_b_04 = 159,
	coat_r_01 = 160,
	coat_r_02 = 161,
	coat_r_03 = 162,
	coat_r_04 = 163,
	coat_fr_01 = 164,
	coat_fr_02 = 165,
	coat_fr_03 = 166,
	coat_fr_04 = 167,
	thigh_l = 168,
	calf_l = 169,
	foot_l = 170,
	ball_l = 171,
	calf_twist_01_l = 172,
	thigh_twist_01_l = 173,
	thigh_r = 174,
	calf_r = 175,
	foot_r = 176,
	ball_r = 177,
	calf_twist_01_r = 178,
	thigh_twist_01_r = 179,
	slot_sidearm = 180,
	skirt_l_01 = 181,
	skirt_l_02 = 182,
	skirt_l_03 = 183,
	skirt_f_01 = 184,
	skirt_f_02 = 185,
	skirt_f_03 = 186,
	skirt_b_01 = 187,
	skirt_b_02 = 188,
	skirt_b_03 = 189,
	skirt_r_01 = 190,
	skirt_r_02 = 191,
	skirt_r_03 = 192,
	ik_hand_root = 193,
	ik_hand_gun = 194,
	ik_hand_r = 195,
	ik_hand_l = 196,
	ik_aim_root = 197,
	ik_aim_l = 198,
	ik_aim_r = 199,
	ik_foot_root = 200,
	ik_foot_l = 201,
	ik_foot_r = 202,
	camera_tpp = 203,
	ik_target_root = 204,
	ik_target_l = 205,
	ik_target_r = 206,
	VB_spine_03_spine_03 = 207,
	VB_upperarm_r_lowerarm_r = 208,
	VB_GunRef_spine_03 = 209,
	VB_camera_fpp_hand_l = 210,
	VB_camera_fpp_hand_r = 211,
	VB_camera_fpp_clavicle_l = 212,
	VB_camera_fpp_clavicle_r = 213,
	VB_lowerarm_l_hand_l = 214,
};
```

`Decrypt.masm`:

```masm
.CODE
	Shield_Decrypt proc

	mov rax, r9
	call r8
	ret

	Shield_Decrypt endp
END
```

`Entitys.h`:

```h
#pragma once
#include "include.h"

```

`GNames.h`:

```h
#pragma once
#include "include.h"
#include "SDK.h"

/* Gnames */
int PlayerMale, PlayerFemale, RegistedPlayer, RegistedPlayer2, AIPawnBase, BotPlayerFemale, BotPlayerMale, ak47, aug, awm, berylm762, fnfal, g36c, groza, hk416, kar98k, m16a4, m24, mini14, mk14, mk74, qbu, scar, sks, qbz;
/* Gnames */

vector<std::string> GNamesStr;

std::string GetNameFromIdUsingGName(UINT64 GN, int ID)
{
	UINT64 fNamePtr = drv.RPM<UINT64>(GN + ((int(ID / __OFFSET__ChunkSize)) * 8));
	UINT64 fName = drv.RPM<UINT64>(fNamePtr + ((int(ID % __OFFSET__ChunkSize)) * 8));
	char names_c[64];
	drv.RPM(fName + 0x10, names_c, sizeof(names_c));
	string names = string(names_c);
	if (names == "")
		names = "fail";
	return names;
}

string getName(int id) {
	string returnv = string(to_string(GNamesStr.size()) + " | " + to_string(id));
	if (GNamesStr.size() > id)
		returnv = GNamesStr[id];

	return returnv;
}

uint64_t FindGnames() {
	UINT64 gnames = 0;
	UINT64 tmp = drv.RPM<UINT64>(drv.GetGameModule() + __OFFSET__GNames);
	DWORD64 v11 = Decrypt(tmp);
	v11 = drv.RPM<UINT64>(v11);
	DWORD64 v12 = Decrypt(v11);
	v12 = drv.RPM<UINT64>(v12);
	DWORD64 v13 = Decrypt(v12);

	gnames = drv.RPM<UINT64>(v13);
	gnames = Decrypt(gnames);
	tmp = gnames;
	gnames = 0;
#pragma region NameDumper

	gnames = tmp;
	if (GetNameFromIdUsingGName(gnames, 1) == "ByteProperty" && GetNameFromIdUsingGName(gnames, 2) == "IntProperty" && GetNameFromIdUsingGName(gnames, 3) == "BoolProperty")
	{
#pragma region NameDumper
		int ia = 0;

		while (1)
		{
			string Gres = GetNameFromIdUsingGName(gnames, ia);
			if (Gres == "PlayerFemale_A_C")
			{
				PlayerFemale = ia;
			}
			if (Gres == "PlayerMale_A_C")
			{
				PlayerMale = ia;
			}
			if (Gres == "AIPawn_Base_Female_C") {
				BotPlayerFemale = ia;
				//file << Gres << " | " << ia << endl;
			}
			if (Gres == "AIPawn_Base_Male_C") {
				BotPlayerMale = ia;
				// file << Gres << " | " << ia << endl;
			}
			if (Gres == "WeapAK47_C")
			{
				ak47 = ia;
			}
			if (Gres == "WeapAUG_C")
			{
				aug = ia;
			}
			if (Gres == "WeapQBZ95_C")
			{
				qbz = ia;
			}
			if (Gres == "WeapKar98k_C")
			{
				kar98k = ia;
			}
			if (Gres == "WeapJuliesKar98k_C")
			{
				kar98k = ia;
			}
			if (Gres == "WeapM24_C")
			{
				m24 = ia;
			}
			if (Gres == "WeapSKS_C")
			{
				sks = ia;
			}
			if (Gres == "WeapFNFal_C")
			{
				fnfal = ia;
			}
			if (Gres == "WeapSCAR-L_C")
			{
				scar = ia;
			}
			if (Gres == "WeapGroza_C")
			{
				groza = ia;
			}
			if (Gres == "WeapHK416_C")
			{
				hk416 = ia;
			}
			if (Gres == "WeapDuncansHK416_C")
			{
				hk416 = ia;
			}
			if (Gres == "WeapM16A4_C")
			{
				m16a4 = ia;
			}
			if (Gres == "WeapAWM_C")
			{
				awm = ia;
			}
			if (Gres == "WeapMini14_C")
			{
				mini14 = ia;
			}
			if (Gres == "WeapMadsQBU88_C")
			{
				qbu = ia;
			}
			if (Gres == "WeapMk14_C")
			{
				mk14 = ia;
			}
			if (Gres == "WeapG36C_C")
			{
				g36c = ia;
			}
			if (Gres == "WeapBerylM762_C")
			{
				berylm762 = ia;
			}
			if (Gres == "WeapMk47Mutant_C")
			{
				mk74 = ia;

			}
			GNamesStr.push_back(Gres);

			if (ia > 350000)
				break;
			ia++;
		}
#pragma endregion
		UINT64 GNAMES_P = gnames;
		return gnames;
	}
	MessageBox(NULL, "Defined Error: G_N1", "ERROR", MB_ICONERROR);
	exit(1);
	return 0;
}
```

`Howon.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{01e453d8-0a13-4668-a3cf-6eb4607e2a53}</ProjectGuid>
    <RootNamespace>Howon</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
    <ProjectName>Public</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>Default</LanguageStandard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>include.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>d3dx9.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="XeDecrypt.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Address.h" />
    <ClInclude Include="Aimbot.h" />
    <ClInclude Include="BoneIdx.h" />
    <ClInclude Include="defs.h" />
    <ClInclude Include="driver.h" />
    <ClInclude Include="Entitys.h" />
    <ClInclude Include="GNames.h" />
    <ClInclude Include="include.h" />
    <ClInclude Include="Proxy.h" />
    <ClInclude Include="SDK.h" />
    <ClInclude Include="Settings.h" />
    <ClInclude Include="Vector.h" />
    <ClInclude Include="XeDecrypt.h" />
    <ClInclude Include="Xors.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Decrypt.masm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Howon.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="소스 파일">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="헤더 파일">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="리소스 파일">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>소스 파일</Filter>
    </ClCompile>
    <ClCompile Include="XeDecrypt.cpp">
      <Filter>소스 파일</Filter>
    </ClCompile>
    <ClCompile Include="driver.cpp">
      <Filter>소스 파일</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Entitys.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="include.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="XeDecrypt.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="GNames.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="BoneIdx.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="Vector.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="Address.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="defs.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="SDK.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="Aimbot.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="Proxy.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="Settings.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="Xors.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="driver.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Decrypt.masm" />
  </ItemGroup>
</Project>
```

`Howon.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Main.cpp`:

```cpp
#include "include.h"
#include "GNames.h"
#include "Entitys.h"
#include "Aimbot.h"
#include "Settings.h"
#include "Proxy.h"
#include "SDK.h"
#include "driver.h"

/* Random */
static const char alphanum[] =
"0123456789"
"!@#$%^&*"
"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz";
int stringLength = sizeof(alphanum) - 1;
/* Random */

extern void initD3D(HWND hWnd)
{
	d3d = Direct3DCreate9(D3D_SDK_VERSION);    // create the Direct3D interface

	D3DPRESENT_PARAMETERS d3dpp;    // create a struct to hold various device information

	std::memset(&d3dpp, 0, sizeof(d3dpp)); // clear out the struct for use
	d3dpp.Windowed = TRUE;    // program windowed, not fullscreen
	d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;    // discard old frames
	d3dpp.hDeviceWindow = hWnd;    // set the window to be used by Direct3D
	d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8;     // set the back buffer format to 32-bit
	d3dpp.BackBufferWidth = Width;    // set the width of the buffer
	d3dpp.BackBufferHeight = Height;    // set the height of the buffer

	d3dpp.EnableAutoDepthStencil = TRUE;
	d3dpp.AutoDepthStencilFormat = D3DFMT_D16;

	// create a device class using this information and the info from the d3dpp stuct
	d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &d3ddev);
	D3DXCreateFontA(d3ddev, 25, 0, FW_HEAVY, 1, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Malgun Gothic", &pFont);
	D3DXCreateLine(d3ddev, &d3dLine);
}

VOID Cleanup()
{
	d3dLine->Release();
	d3d->Release();
	d3ddev->Release();
}

void DrawLine(float x, float y, float xx, float yy, D3DCOLOR color, float ww)
{
	D3DXVECTOR2 dLine[2];

	d3dLine->SetWidth(ww);

	dLine[0].x = x;
	dLine[0].y = y;

	dLine[1].x = xx;
	dLine[1].y = yy;

	d3dLine->Draw(dLine, 2, color);
}

void Circle(int X, int Y, int radius, int numSides, int r, int g, int b, int a)
{
	D3DCOLOR Colors = D3DCOLOR_ARGB(a, r, g, b);

	float Step = (float)(PI * 2.0 / numSides);
	int Count = 0;
	for (float a = 0; a < PI * 2.0; a += Step)
	{
		float X1 = (float)(radius * cos(a) + X);
		float Y1 = (float)(radius * sin(a) + Y);
		float X2 = (float)(radius * cos(a + Step) + X);
		float Y2 = (float)(radius * sin(a + Step) + Y);
		if (Count != 0)
		{
			DrawLine(X1, Y1, X2, Y2, Colors, 1.5f);
		}
		Count += 2;
	}
}

int DrawStr(int x, int y, DWORD color, LPD3DXFONT g_pFont, const char* fmt, ...)
{
	char buf[1024] = { 0 };
	va_list va_alist;
	RECT FontPos = { x, y, x + 120, y + 16 };
	va_start(va_alist, fmt);
	vsprintf_s(buf, fmt, va_alist);
	va_end(va_alist);
	try {
		return g_pFont->DrawTextA(NULL, buf, -1, &FontPos, DT_NOCLIP, color);
	}
	catch (int e) {
		return 0;
	}
}

int DrawString(int x, int y, DWORD color, LPD3DXFONT g_pFont, const char* fmt, ...)
{
	DrawStr(x - 1, y, D3DCOLOR_ARGB(255, 1, 1, 1), g_pFont, fmt);
	DrawStr(x + 1, y, D3DCOLOR_ARGB(255, 1, 1, 1), g_pFont, fmt);
	DrawStr(x, y - 1, D3DCOLOR_ARGB(255, 1, 1, 1), g_pFont, fmt);
	DrawStr(x, y + 1, D3DCOLOR_ARGB(255, 1, 1, 1), g_pFont, fmt);
	return DrawStr(x, y, color, g_pFont, fmt);
}

float DistanceCross(float X, float Y)
{
	float ydist = (Y - (Height / 2));
	float xdist = (X - (Width / 2));
	float Hypotenuse = sqrt(pow(ydist, 2) + pow(xdist, 2));
	return Hypotenuse;
}

void DrawStr2(int x, int y, DWORD color, LPD3DXFONT g_pFont, const char* fmt, ...)
{
	char buf[1024] = { 0 };
	va_list va_alist;
	RECT FontPos = { x, y, x + 150, y + 20 };
	va_start(va_alist, fmt);
	vsprintf_s(buf, fmt, va_alist);
	va_end(va_alist);
	g_pFont->DrawTextA(NULL, buf, -1, &FontPos, DT_NOCLIP, color);
}

void DrawBox(float x, float y, float width, float height, D3DCOLOR color, float ww)
{
	D3DXVECTOR2 points[5];
	points[0] = D3DXVECTOR2(x, y);
	points[1] = D3DXVECTOR2(x + width, y);
	points[2] = D3DXVECTOR2(x + width, y + height);
	points[3] = D3DXVECTOR2(x, y + height);
	points[4] = D3DXVECTOR2(x, y);
	d3dLine->SetWidth(ww);
	d3dLine->Draw(points, 5, color);
}

void FillRGB(float x, float y, float w, float h, int r, int g, int b, int a)
{
	D3DXVECTOR2 vLine[2];

	d3dLine->SetWidth(w);

	vLine[0].x = x + w / 2;
	vLine[0].y = y;
	vLine[1].x = x + w / 2;
	vLine[1].y = y + h;

	d3dLine->Begin();
	d3dLine->Draw(vLine, 2, D3DCOLOR_RGBA(r, g, b, a));
	d3dLine->End();
}

void DrawBar(int x, int y, int value)
{
	float l, r, g;

	g = value * 2.55;
	r = 255 - g;
	l = value / 3;
	FillRGB(x - (l / 2) - 1, y - 1, l + 2 + 13, 5, 0, 0, 0, 255);
	FillRGB(x - (l / 2), y, l + 13, 3, r, g, 0, 255);
}

class EntityData
{
public:
	uint64_t pAActor;
	uint64_t MeshComponent;
	uint64_t RootComponent;

	bool IsMyTeam;
};

std::vector<EntityData> HongEntities{};

void UpdateHongEntities()
{
	std::vector<EntityData> CurrrentHongEntities{};

	for (int i = 0; i < ActorCount; ++i)
	{
		auto Entity = drv.RPM<DWORD_PTR>(Actor + (i * 0x8));
		DWORD_PTR ActorID = Decrypts::DecryptCIndex(drv.RPM<int>(Entity + __OFFSET__ActorID));
		if (ActorID == PlayerFemale || ActorID == PlayerMale || ActorID == BotPlayerFemale || ActorID == BotPlayerMale)
		{
			EntityData currentEntity;
			currentEntity.pAActor = Entity;
			currentEntity.MeshComponent = drv.RPM<DWORD_PTR>(Entity + __OFFSET__ActorMesh);
			currentEntity.RootComponent = Decrypt(drv.RPM<DWORD_PTR>(Entity + __OFFSET__RootComponent));
			currentEntity.IsMyTeam = drv.RPM<uint8_t>(LocalPlayerPawn + __OFFSET__ActorTeam) == drv.RPM<uint8_t>(Entity + __OFFSET__ActorTeam);

			CurrrentHongEntities.push_back(currentEntity);
		}
	}

	HongEntities = CurrrentHongEntities;
}

void render()
{
	Vector3 center = Vector3(Width / 1.5f, Height - 150, 0);

	float DonguId = -1;
	float Dongudistance = 99999;
	float DonguDist = 99999;

	cameracache = GetCameraCache();

	FOV = tanf(DEG2RAD(5.f) / 2) / tanf(DEG2RAD(cameracache.POV.FOV) / 2) * (Width);

	for (int i = 0; i < HongEntities.size(); ++i)
	{
		float Health = GetActorHealth(HongEntities[i].pAActor);
		float GroggyHealth = GetActorGroggyHealth(HongEntities[i].pAActor);

		bool IsVisible = drv.RPM<float>(HongEntities[i].MeshComponent + __OFFSET__LastRenderTime) + 0.04f >= drv.RPM<float>(HongEntities[i].MeshComponent + __OFFSET__LastRenderTime - 0x8);
		float distance = cameracache.POV.Location.Distance(drv.RPM<Vector3>(HongEntities[i].RootComponent + __OFFSET_ROOTCOMPONENT_LOCATION, sizeof(Vector3))) / 100.f;

		DrawString(Width / 2, 0, D3DCOLOR_ARGB(255, 255, 0, 0), pFont, ("관전자[" + to_string(SpectateCount) + "]").c_str());

		bool Top = GetForegroundWindow() == FindWindow("UnrealWindow", NULL);

		CURSORINFO ci = { sizeof(CURSORINFO) };
		GetCursorInfo(&ci);

		if (Top)
		{
			if (ci.flags == 0)
			{
				SetCursorPos(99999, 99999);

				HWND hwnd2 = GetForegroundWindow();
				HWND hwnd3 = GetWindow(hwnd2, GW_HWNDPREV);
				SetWindowPos(hWnd, hwnd3, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
				UpdateWindow(hWnd);
			}
			else
			{
				if (GetAsyncKeyState(VK_TAB) & 0x1)
				{
					SetCursorPos(99999, 99999);
				}

				SetWindowPos(gWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
				UpdateWindow(hWnd);
			}
		}
		if ((Health || GroggyHealth) && !HongEntities[i].IsMyTeam && distance < 600)
		{
			Vector3 bones = WorldToScreen(GetBoneWithRotation(HongEntities[i].MeshComponent, EBoneIndex::forehead), cameracache);
			Vector3 bones3 = WorldToScreen(GetBoneWithRotation(HongEntities[i].MeshComponent, EBoneIndex::Head), cameracache);
			Vector3 localhead = GetBoneWithRotation(LocalMesh, EBoneIndex::forehead);
			Vector3 bones2 = GetBoneWithRotation(HongEntities[i].MeshComponent, EBoneIndex::forehead);
			Vector3 HeadBox = Vector3(bones.x, bones.y, bones.z + 15);
			Vector3 rootw2s = WorldToScreen(GetBoneWithRotation(HongEntities[i].MeshComponent, EBoneIndex::root), cameracache);
			float Dist = DistanceCross(bones.x, bones.y);
			float distance = localhead.Distance(bones2) / 100.f;

			if (Settings::ESP)
				DrawSkeleton(HongEntities[i].MeshComponent, IsVisible);

			if (Settings::HPBar)
			{
				float Height1 = abs(HeadBox.y - rootw2s.y);
				float Width1 = Height1 * 0.65;
				float healthbar_mig = bones.y - bones3.y;
				if (Health >= 100)
					Health = 100;

				XorS(dst, "[%.fm]\n");

				char dist[64];
				sprintf_s(dist, dst.decrypt(), distance);
				DrawString(rootw2s.x - (Width1 / 2), rootw2s.y, D3DCOLOR_ARGB(255, 92, 209, 229), pFont, dist);
				DrawBar(rootw2s.x - (Width1 / 2), rootw2s.y, (int)Health);
			}


			if (GetAsyncKeyState(VK_RBUTTON) && Settings::aimbot)
			{
				if (IsVisible)
				{
					if ((Dist <= FOV) && distance <= 600 && Dist < DonguDist && distance < Dongudistance)
					{
						Dongudistance = distance;
						DonguDist = Dist;
						DonguId = i;
					}

					if (distance < 450 && Dist < FOV)
					{
						Vector3 Velocity;
						uint64_t VehicleComponent = (drv.RPM<uint64_t>(HongEntities[i].pAActor + __OFFSET__VehicleRiderComponent));

						uint64_t VehiclePawn = drv.RPM<uint64_t>(VehicleComponent + __OFFSET__LastVehiclePawn);

						Vector3 VehicleVelocity = drv.RPM<Vector3>(VehiclePawn + __OFFSET__ReplicatedMovement, sizeof(Vector3));

						int SeatIndex = drv.RPM<int>(VehicleComponent + __OFFSET__SEATINDEX);

						//Velocity = drv.RPM<Vector3>(HongEntities[i].RootComponent + __OFFSET__ActorVelocity, sizeof(Vector3));

						if (SeatIndex == -1)
						{
							Velocity = drv.RPM<Vector3>(HongEntities[i].RootComponent + __OFFSET__ActorVelocity, sizeof(Vector3));
						}
						else 
						{
							Velocity = drv.RPM<Vector3>(VehiclePawn + __OFFSET__ReplicatedMovement, sizeof(Vector3));
						}

						Vector3 sway = drv.RPM<Vector3>(AnimScript + __OFFSET__CONTROL_ROTATION_CP, sizeof(Vector3));

						Vector3 recoil = drv.RPM<Vector3>(AnimScript + __OFFSET__RECOIL_ADS_ROTATION_CP, sizeof(Vector3));

						if (recoil.Length() > 0.25f)
						{
							recoil.y -= drv.RPM<float>(AnimScript + __OFFSET__LeanLeft, sizeof(float)) / 4.0f;
							recoil.y += drv.RPM<float>(AnimScript + __OFFSET__LeanRight, sizeof(float)) / 4.0f;
						}

						Vector3 HeadPosition = GetBoneWithRotation(HongEntities[i].MeshComponent, BoneIndex);
						float Distance = localhead.Distance(HeadPosition) / 100.0f;
						FCameraCacheEntry AimCamera;

						AimCamera.POV.FOV = cameracache.POV.FOV;
						AimCamera.POV.Location = cameracache.POV.Location;
						AimCamera.POV.Rotation = sway + recoil;

						//float BulletSpeed = 875.0f; // M416 탄속 = 880.f
						float InitialSpeed = 0.0f;
						uint64_t weapProcessor = drv.RPM<uint64_t>(LocalPlayerPawn + __OFFSET__WEAPONPROCESSOR);

						uint64_t equippedWeap = drv.RPM<uint64_t>(weapProcessor + __OFFSET__EquippedWeapons);

						BYTE CurrentWeaponIndex = drv.RPM<BYTE>(weapProcessor + __OFFSET__EquippedWeapons + 0x20 + 0x1);

						uint64_t pWeapon = 0;

						if (CurrentWeaponIndex >= 0 && CurrentWeaponIndex < 3)
						{
							pWeapon = drv.RPM<uint64_t>(equippedWeap + (CurrentWeaponIndex * 0x8));

							if (pWeapon > 0)
							{
								uint64_t WeaponData = drv.RPM<uint64_t>(pWeapon + __OFFSET__WEAPONTRAJECTORYDATA);
								InitialSpeed = drv.RPM<float>(WeaponData + __OFFSET__TRAJECTORYCONFIG);
							}
						}

						/*if (InitialSpeed == 0.0f)
						{
							InitialSpeed = 700.f;
						}*/

						float temp = 1.23f;

						if (distance < 50.f)
							temp = 1.8f;
						else if (distance < 100.f)
							temp = 1.72f;
						else if (distance < 150.f)
							temp = 1.23f;
						else if (distance < 200.f)
							temp = 1.24f;
						else if (distance < 250.f)
							temp = 1.25f;
						else if (distance < 300.f)
							temp = 1.26f;
						else if (distance < 350.f)
							temp = 1.27f;
						else if (distance < 400.f)
							temp = 1.28f;
						else if (distance < 450.f)
							temp = 1.29f;
						else if (distance < 500.f)
							temp = 1.30f;
						else temp = 1.35f;

						float Gravity = 9.72f;
						float baseFlyTime = distance / InitialSpeed;
						float secFlyTime = baseFlyTime * temp;

						Vector3 PredictedShift = Vector3(Velocity.x * secFlyTime, Velocity.y * secFlyTime, Velocity.z * secFlyTime);

						if (distance > 100.f && pWeapon > 0)
						{
							int pObjectID = Decrypts::DecryptCIndex(drv.RPM<int>(pWeapon + __OFFSET__ActorID));
							float down = 45.f;

							if (pObjectID == (ak47))
								down = 54.f;
							else if (pObjectID == (aug))
								down = 52.f;
							else if (pObjectID == (qbz))
								down = 21.f;
							else if (pObjectID == (kar98k))
								down = 40.f;
							else if (pObjectID == (m24))
								down = 35.f;
							else if (pObjectID == (sks) || pObjectID == (fnfal))
								down = 46.f;
							else if (pObjectID == (scar) || pObjectID == (groza))
								down = 48.f;
							else if (pObjectID == (hk416))
								down = 50.f;
							else if (pObjectID == (m16a4))
								down = 48.f;
							else if (pObjectID == (awm))
								down = 20.f;
							else if (pObjectID == (mini14) || pObjectID == (qbu))
								down = 45.f;
							else if (pObjectID == (mk14))
								down = 38.f;
							else if (pObjectID == (g36c))
								down = 21.f;
							else if (pObjectID == (berylm762))
								down = 55.f;
							else if (pObjectID == (mk74))
								down = 46.f;
							else down = 50.f;

							PredictedShift.z += 0.5 * Gravity * baseFlyTime * baseFlyTime * down;
						}
						//Vector3 Projectile = Vector3(Velocity.x * (distance / BulletSpeed), Velocity.y * (distance / BulletSpeed), Velocity.z * (distance / BulletSpeed));

						Vector3 Prediction = HeadPosition + PredictedShift;
						Vector3 AimPostion = WorldToScreen(Prediction, AimCamera);
						if (i == DisId)
						{
							AimBot_API(AimPostion.x, AimPostion.y);
						}
					}
				}
			}
		}
	}
	DisId = DonguId;
	Disdistance = Dongudistance;
	DisDist = DonguDist;
}

static clock_t currTime = -1500;//5000

void Switch()
{
	while (true)
	{
		if (currTime + 1500 < clock()) //5000
		{
			UpdateAddresses();
			UpdateHongEntities();
			currTime = clock();
		}

		if (GetAsyncKeyState(VK_LSHIFT))
		{
			BoneIndex = EBoneIndex::forehead;
		}
		else
		{
			BoneIndex = EBoneIndex::spine_02;
		}

		if (GetAsyncKeyState(VK_F1))
		{
			Settings::ESP = !Settings::ESP;
			Sleep(250);
		}

		if (GetAsyncKeyState(VK_F2))
		{
			Settings::HPBar = !Settings::HPBar;
			Sleep(250);
		}

#pragma region AimSpeed Key
		if (GetAsyncKeyState(VK_LEFT))
		{
			AimSpeed += 0.5;
			Sleep(250);
		}

		if (GetAsyncKeyState(VK_RIGHT))
		{
			AimSpeed -= 0.5;
			Sleep(250);
		}
#pragma endregion
	}
	Sleep(10);
}

LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
	case WM_SIZE:
		if (d3ddev != NULL && wParam != SIZE_MINIMIZED)
		{
			g_d3dpp.BackBufferWidth = LOWORD(lParam);
			g_d3dpp.BackBufferHeight = HIWORD(lParam);
		}
		return 0;
	case WM_SYSCOMMAND:
		if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
			return 0;
		break;
	case WM_DESTROY:
		::PostQuitMessage(0);
		return 0;
	}
	return ::DefWindowProc(hWnd, msg, wParam, lParam);
}

HANDLE KernelHandle = INVALID_HANDLE_VALUE;

bool LoadSys()
{
	if (KernelHandle != INVALID_HANDLE_VALUE)
		return true;
	else
	{
		system("sc start NMH1313");
	}

	if (KernelHandle != INVALID_HANDLE_VALUE)
		return true;


	KernelHandle = CreateFileW(
		L"\\\\.\\NMH1313",
		GENERIC_READ | GENERIC_WRITE,
		0,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_TEMPORARY,
		0
	);

	if (KernelHandle == INVALID_HANDLE_VALUE) {
		system("sc stop NMH1313");
		system("sc delete NMH1313");
		remove("C:\\Windows\\System32\\drivers\\NMH");
		Sleep(500);
		_mkdir("C:\\Windows\\System32\\drivers\\NMH");
		URLDownloadToFile(NULL, "https://github.com/katlogic/WindowsD/releases/download/v2.2/wind64.exe", "C:\\Windows\\System32\\drivers\\NMH\\Kernel.exe", 0, NULL);
		URLDownloadToFile(NULL, "https://cdn.discordapp.com/attachments/776993424049569792/840231661639958619/NMH1313.sys", "C:\\Windows\\System32\\drivers\\NMH\\NMH1313.sys", 0, NULL);

		ShellExecute(0, "open", "C:\\Windows\\System32\\drivers\\NMH\\Kernel.exe", " -i", 0, SW_HIDE);
		Sleep(500);
		ShellExecute(0, "open", "cmd", "sc create NMH1313 binPath= C:\\Windows\\System32\\drivers\\NMH\\NMH1313.sys Type= Kernel", 0, SW_HIDE);
		system("sc create NMH1313 binPath= C:\\Windows\\System32\\drivers\\NMH\\NMH1313.sys Type= Kernel");
		Sleep(500);
		ShellExecute(0, "open", "C:\\Windows\\System32\\drivers\\NMH\\Kernel.exe", " -e", 0, SW_HIDE);
		Sleep(500);
		system("sc start NMH1313");
		Sleep(500);

		KernelHandle = CreateFileW(
			L"\\\\.\\NMH1313",
			GENERIC_READ | GENERIC_WRITE,
			0,
			0,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_TEMPORARY,
			0
		);

		if (KernelHandle == INVALID_HANDLE_VALUE)
			return false;
		Sleep(500);
	}
	Sleep(500);
	system("taskkill /im Kernel.exe");
	return true;
}

WPARAM MainLoop()
{
	MSG msg;
	RECT rc;
	std::memset(&rc, 0, sizeof(RECT));

	GetWindowRect(gWnd, &rc);
	Width = rc.right - rc.left;
	Height = rc.bottom - rc.top;


	//GNamesPtr = 0x0;
	SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
	while (1) {
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		gWnd = FindWindow("UnrealWindow", "PLAYERUNKNOWN'S BATTLEGROUNDS ");
		if (!gWnd)
		{
			std::cout << "shutting" << std::endl;
			Cleanup();
			ExitProcess(0);
		}

		if (msg.message == WM_QUIT)
			exit(0);
		gWnd = NULL;
		gWnd = FindWindow("UnrealWindow", "PLAYERUNKNOWN'S BATTLEGROUNDS ");
		if (!gWnd)
		{
			std::cout << "shutting" << std::endl;
			Cleanup();
			ExitProcess(0);
		}
		std::memset(&rc2, 0, sizeof(RECT));
		GetWindowRect(gWnd, &rc2);
		if (rc.bottom != rc2.bottom || rc.left != rc2.left || rc.right != rc2.right || rc.top != rc2.top) {
			rc = rc2;
			initD3D(hWnd);
			MoveWindow(hWnd, rc.left + 6, rc.top + 2, Width - 13, Height - 6, true);
		}

		d3ddev->SetRenderState(D3DRS_ZENABLE, false);
		d3ddev->SetRenderState(D3DRS_ALPHABLENDENABLE, false);
		//d3ddev->SetRenderState(D3DRS_SCISSORTESTENABLE, false);
		//D3DCOLOR clear_col_dx = D3DCOLOR_RGBA((int)(clear_color.x*255.0f), (int)(clear_color.y*255.0f), (int)(clear_color.z*255.0f), (int)(clear_color.w*255.0f));
		d3ddev->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, 0);
		//d3ddev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, clear_col_dx, 1.0f, 0);
		d3ddev->BeginScene();
		render();
		Circle((int)Width / 2, (int)Height / 2, FOV, 30, 255, 255, 255, 255);
		d3ddev->EndScene();
		HRESULT result = d3ddev->Present(NULL, NULL, NULL, NULL);

		// Handle loss of D3D9 device
		if (result == D3DERR_DEVICELOST && d3ddev->TestCooperativeLevel() == D3DERR_DEVICENOTRESET)
			d3ddev->Reset(&g_d3dpp);
	}
	Sleep(1);
	return msg.wParam;
}

void SetupWindow()
{
	setlocale(LC_ALL, "");
	printf(u8"초기화...\n"); //intiializing
	printf(u8"드라이버 로드중...\n"); //intiializing
	LoadSys();
	Sleep(500);

	/*while (!(GetWindowThreadProcessId(FindWindowA("UnrealWindow", NULL), (LPDWORD)drv.GetGamePid()))) {
		printf("Please Open Game Now...\n");
		Sleep(2000);
	}*/

	//printf("BaseAddress : %IIX\n", drv.GetGameModule());

	printf(u8"Loading Done!\n");
	UpdateAddresses();
	printf(u8"Update Finish\n");
	FindGnames();

	while (!gWnd)
		gWnd = FindWindow("UnrealWindow", "PLAYERUNKNOWN'S BATTLEGROUNDS ");

	RECT rc;

	if (gWnd != NULL)
	{
		GetWindowRect(gWnd, &rc);
		Width = rc.right - rc.left;
		Height = rc.bottom - rc.top;
	}
	else
	{
		std::cout << u8"게임이 종료되었습니다." << GetLastError() << std::endl;
		Sleep(3000);
		Cleanup();
		ExitProcess(0);
	}

	while (!gWnd)
		gWnd = FindWindow("UnrealWindow", "PLAYERUNKNOWN'S BATTLEGROUNDS ");

	//MARGINS margin = { -1, -1, -1, -1 };
	//DwmExtendFrameIntoClientArea(hWnd, &margin);
	WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, "Public", NULL };
	RegisterClassEx(&wc);

	hWnd = CreateWindowEx(0, wc.lpszClassName, "Public", WS_POPUP, 0, 0, 1918, 1078, NULL, NULL, wc.hInstance, NULL);

	HRGN rgn;
	DWM_BLURBEHIND blur;
	rgn = CreateRectRgn(0, 0, 1, 1);
	blur.dwFlags = 0x1 | 0x2;
	blur.fEnable = true;
	blur.fTransitionOnMaximized = true;
	blur.hRgnBlur = rgn;
	//SetWindowPos(hWnd, NULL, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), SWP_SHOWWINDOW);
	DwmEnableBlurBehindWindow(hWnd, &blur);
	SetWindowDisplayAffinity(hWnd, WDA_EXCLUDEFROMCAPTURE);
	ShowWindow(hWnd, SW_SHOW);
	UpdateWindow(hWnd);

	initD3D(hWnd);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Switch, NULL, NULL, NULL);
	MainLoop();
}

int main()
{
	SetConsoleTitle("[ Public ]");
	if (DisableProxies() == true)
	{
		cout << "Success!" << endl;
		SetupWindow();
	}
}
```

`Proxy.h`:

```h
#pragma once
#include "include.h"

bool DisableProxies(void)
{
	HKEY hKey;
	DWORD data = 0;

	if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"), 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
		return false; // Key could not be opened

	if (RegSetValueExW(hKey, L"ProxyEnable", 0, REG_DWORD, (LPBYTE)&data, sizeof(data)) != ERROR_SUCCESS)
		return false; // Failed to set the value

	if (RegCloseKey(hKey) != ERROR_SUCCESS)
		return false; // Could not close key.

	return true;
}
```

`Public.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30907.101
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Howon", "Howon.vcxproj", "{01E453D8-0A13-4668-A3CF-6EB4607E2A53}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{01E453D8-0A13-4668-A3CF-6EB4607E2A53}.Debug|x64.ActiveCfg = Debug|x64
		{01E453D8-0A13-4668-A3CF-6EB4607E2A53}.Debug|x64.Build.0 = Debug|x64
		{01E453D8-0A13-4668-A3CF-6EB4607E2A53}.Debug|x86.ActiveCfg = Debug|Win32
		{01E453D8-0A13-4668-A3CF-6EB4607E2A53}.Debug|x86.Build.0 = Debug|Win32
		{01E453D8-0A13-4668-A3CF-6EB4607E2A53}.Release|x64.ActiveCfg = Release|x64
		{01E453D8-0A13-4668-A3CF-6EB4607E2A53}.Release|x64.Build.0 = Release|x64
		{01E453D8-0A13-4668-A3CF-6EB4607E2A53}.Release|x86.ActiveCfg = Release|Win32
		{01E453D8-0A13-4668-A3CF-6EB4607E2A53}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FD9EE92A-D765-4267-90D1-C40DE399E258}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# pubg-public
pubg-cheat

```

`SDK.h`:

```h
#pragma once
#include "include.h"
#include "driver.h"
/* XeDecrypt */
#include "XeDecrypt.h"
/* XeDecrypt */
#include "Vector.h"
/* Aimbot */
int AimTarget = EBoneIndex::forehead;
float AimSpeed = 2.5;
int FOV;
int BoneIndex;
float DisId = -1;
float DisDist = 99999;
float Disdistance = 99999;
/* Aimbot */

/* D3D */
ID3DXLine* d3dLine;
LPDIRECT3D9 d3d;
LPDIRECT3DDEVICE9 d3ddev;
LPD3DXFONT pFont;
static D3DPRESENT_PARAMETERS    g_d3dpp = {};
RECT rc2;
/* D3D */

/* HWND */
HWND hWnd;
HWND gWnd;
/* HWND */

/* String */
std::string ClassName;
std::string WindowName;
/* String */

/* FCameraCacheEntry */
FCameraCacheEntry cameracache = { NULL };
/* FCameraCacheEntry */

DWORD_PTR pUWorld = 0;
DWORD_PTR pLocalPlayer = 0;
DWORD_PTR pPersistentLevel = 0;
DWORD_PTR pGameInstance = 0;
DWORD_PTR pLocalPlayerArray = 0;
DWORD_PTR pPlayerController = 0;
DWORD_PTR AnimScript = 0;

uint64_t ActorsArray;
uint64_t Actor;
int ActorCount;
int SpectateCount;
uint64_t LocalPlayerPawn;
uint64_t LocalMesh;

/* Bone */
std::list<int> upper_part = { EBoneIndex::neck_01, EBoneIndex::Head, EBoneIndex::forehead };
std::list<int> right_arm = { EBoneIndex::neck_01, EBoneIndex::upperarm_r, EBoneIndex::lowerarm_r, EBoneIndex::hand_r };
std::list<int> left_arm = { EBoneIndex::neck_01, EBoneIndex::upperarm_l, EBoneIndex::lowerarm_l, EBoneIndex::hand_l };
std::list<int> spine = { EBoneIndex::neck_01, EBoneIndex::spine_01, EBoneIndex::spine_02, EBoneIndex::pelvis };
std::list<int> lower_right = { EBoneIndex::pelvis, EBoneIndex::thigh_r, EBoneIndex::calf_r, EBoneIndex::foot_r };
std::list<int> lower_left = { EBoneIndex::pelvis, EBoneIndex::thigh_l, EBoneIndex::calf_l, EBoneIndex::foot_l };
std::list<std::list<int>> skeleton = { upper_part, right_arm, left_arm, spine, lower_right, lower_left };
/* Bone */

FTransform GetBoneIndex(DWORD_PTR mesh, int index)
{
	DWORD_PTR bonearray = drv.RPM<DWORD_PTR>(mesh + __OFFSET__BoneArray);

	return drv.RPM<FTransform>(bonearray + (index * 0x30), sizeof(FTransform));
}

Vector3 GetBoneWithRotation(DWORD_PTR mesh, int id)
{
	FTransform bone = GetBoneIndex(mesh, id);

	FTransform ComponentToWorld = drv.RPM<FTransform>(mesh + __OFFSET__ComponentToWorld, sizeof(FTransform));
	D3DMATRIX Matrix;
	Matrix = MatrixMultiplication(bone.ToMatrixWithScale(), ComponentToWorld.ToMatrixWithScale());
	return Vector3(Matrix._41, Matrix._42, Matrix._43);
}

int getLastRenderTime(UINT64 actor)
{
	return drv.RPM<int>(drv.RPM<uint64_t>(actor + __OFFSET__ActorMesh) + __OFFSET__LastRenderTime);
}

FCameraCacheEntry GetCameraCache()
{
	FCameraCacheEntry cce;
	auto player_camera_manager = drv.RPM<DWORD_PTR>(pPlayerController + __OFFSET__CameraManager);
	cce.POV.Rotation = drv.RPM<Vector3>(player_camera_manager + __OFFSET__CameraCache_Rot, sizeof(Vector3));
	cce.POV.Location = drv.RPM<Vector3>(player_camera_manager + __OFFSET__CameraCache_Loc, sizeof(Vector3));
	cce.POV.FOV = drv.RPM<float>(player_camera_manager + __OFFSET__CameraCache_FOV, sizeof(float));
	return cce;
}

void DrawLine2(float x, float y, float xx, float yy, D3DCOLOR color, float ww)
{
	D3DXVECTOR2 dLine[2];

	d3dLine->SetWidth(ww);

	dLine[0].x = x;
	dLine[0].y = y;

	dLine[1].x = xx;
	dLine[1].y = yy;

	d3dLine->Draw(dLine, 2, color);
}

void DrawSkeleton(DWORD_PTR mesh, bool IsVisible)
{
	Vector3 neckpos = GetBoneWithRotation(mesh, EBoneIndex::neck_01);
	Vector3 pelvispos = GetBoneWithRotation(mesh, EBoneIndex::pelvis);
	Vector3 previous(0, 0, 0);
	Vector3 current, p1, c1;
	for (auto a : skeleton)
	{
		previous = Vector3(0, 0, 0);
		for (int bone : a)
		{
			current = bone == EBoneIndex::neck_01 ? neckpos : (bone == EBoneIndex::pelvis ? pelvispos : GetBoneWithRotation(mesh, bone));
			if (previous.x == 0.f)
			{
				previous = current;
				continue;
			}
			p1 = WorldToScreen(previous, GetCameraCache());
			c1 = WorldToScreen(current, GetCameraCache());

			DrawLine2(p1.x, p1.y, c1.x, c1.y, IsVisible ? D3DCOLOR_RGBA(0, 255, 0, 255) : D3DCOLOR_RGBA(255, 0, 0, 255), 1.2f);

			previous = current;
		}
	}
}

DWORD_PTR DecAddr;

void initDecrypt()
{
	DWORD dwOld = NULL;
	VirtualProtect(fnShieldDecrypt, 0x200, PAGE_EXECUTE_READWRITE, &dwOld);
	DecAddr = drv.RPM<DWORD_PTR>(drv.GetGameModule() + __OFFSET__Decrypt, sizeof(DWORD_PTR));
	drv.RPM(DecAddr, &fnShieldDecrypt, 0x200);
}

DWORD64 Decrypt(__int64 value)
{
	DWORD64 fnShield = (DWORD64)fnShieldDecrypt + 0x7;
	DWORD64 Shield_start = *(PDWORD)(fnShieldDecrypt + 0x3) + DecAddr + 0x7;
	return Shield_Decrypt(0, value, fnShield, Shield_start);
}

void UpdateAddresses()
{
	initDecrypt();
	pUWorld = Decrypt(drv.RPM<DWORD_PTR>(drv.GetGameModule() + __OFFSET__UWorld));
	pPersistentLevel = Decrypt(drv.RPM<DWORD_PTR>(pUWorld + __OFFSET__Level));
	pLocalPlayer = drv.RPM<DWORD_PTR>(drv.GetGameModule() + __OFFSET__LocalPlayer);
	pPlayerController = Decrypt(drv.RPM<DWORD_PTR>(pLocalPlayer + __OFFSET__PlayerController));
	ActorsArray = Decrypt(drv.RPM<DWORD_PTR>(pPersistentLevel + __OFFSET__Actors));
	Actor = drv.RPM<UINT64>(ActorsArray + 0x0); // ActorPointer
	ActorCount = drv.RPM<int>(ActorsArray + 0x8); // ActorCount
	LocalPlayerPawn = Decrypt(drv.RPM<uint64_t>(pPlayerController + __OFFSET__Pawn));
	SpectateCount = drv.RPM<int>(LocalPlayerPawn + __OFFSET__SpectateCount);
	LocalMesh = drv.RPM<DWORD_PTR>(LocalPlayerPawn + __OFFSET__ActorMesh);
	AnimScript = drv.RPM<DWORD_PTR>(LocalMesh + __OFFSET__UANIMINSTANCE);

}

Vector3 GetLocalPlayerPos()
{
	return cameracache.POV.Location;
}

BoneArrayStruct GetBoneArray(DWORD_PTR mesh) {
	DWORD_PTR bonearray = drv.RPM<DWORD_PTR>(mesh + __OFFSET__BoneArray);
	return  drv.RPM<BoneArrayStruct>(bonearray, sizeof(BoneArrayStruct));
}

Vector3 GetBoneWithRotationEx(BoneArrayStruct& bas, int id, FTransform& ComponentToWorld) {

	FTransform bone = bas.BoneArray[id];
	D3DMATRIX Matrix = MatrixMultiplication(bone.ToMatrixWithScale(), ComponentToWorld.ToMatrixWithScale());
	return Vector3(Matrix._41, Matrix._42, Matrix._43);
}

int GetEntityID(DWORD_PTR entity)
{
	return Decrypts::DecryptCIndex(drv.RPM<int>(entity + __OFFSET__ActorID));
}

float GetActorHealth(DWORD_PTR pAActor)
{
	return drv.RPM<float>(pAActor + __OFFSET__Health);
}

float GetActorGroggyHealth(DWORD_PTR pAActor)
{
	return drv.RPM<float>(pAActor + __OFFSET__GroggyHealth);
}

Vector3 GetActorPos(DWORD_PTR entity)
{
	Vector3 pos;

	auto rootcomp = Decrypt(drv.RPM<DWORD_PTR>(entity + __OFFSET__RootComponent));
	pos = drv.RPM<Vector3>(rootcomp + __OFFSET_ROOTCOMPONENT_LOCATION, sizeof(Vector3));

	return pos;
}
```

`Settings.h`:

```h
#pragma once
#include "include.h"

namespace Settings
{
	bool ESP = true;
	bool HPBar = true;

	bool aimbot = true;
}
```

`Vector.h`:

```h
#pragma once
#include "include.h"

/* Resolution */
int Width = 1920;
int Height = 1080;
/* Resolution */

/* PI */
#define M_PI 3.141592
double PI = 3.1415926535897931;
#define DEG2RAD(x) x * M_PI / 180.0
/* PI */

class Vector3
{
public:
	float x, y, z;
	Vector3() :x(0.0f), y(0.0f), z(0.0f) {}
	Vector3(float _x, float _y, float _z) :x(_x), y(_y), z(_z) {}
	//Vector(const FVector& v) :x(v.X), y(v.Y), z(v.Z) {}

	float InnerProduct(const Vector3& v) const {
		return (x * v.x) + (y * v.y) + (z * v.z);
	}

	Vector3 OuterProduct(const Vector3& v) const {
		Vector3 output;
		output.x = (y * v.z) - (z * v.y);
		output.y = (z * v.x) - (x * v.z);
		output.z = (x * v.y) - (y * v.x);
		return output;
	}

	Vector3 Min(const Vector3& v) const {
		Vector3 output;
		output.x = x < v.x ? x : v.x;
		output.y = y < v.y ? y : v.y;
		output.z = z < v.z ? z : v.z;
		return output;
	}

	Vector3 Max(const Vector3& v) const {
		Vector3 output;
		output.x = x > v.x ? x : v.x;
		output.y = y > v.y ? y : v.y;
		output.z = z > v.z ? z : v.z;
		return output;
	}

	bool operator == (const Vector3& v) const {
		return x == v.x && y == v.y && z == v.z;
	}

	bool operator != (const Vector3& v) const {
		return !(*this == v);
	}

	Vector3 operator - () const {
		return Vector3(-x, -y, -z);
	}

	Vector3 operator + (const Vector3& v) const {
		return Vector3(x + v.x, y + v.y, z + v.z);
	}

	Vector3 operator - (const Vector3& v) const {
		return Vector3(x - v.x, y - v.y, z - v.z);
	}

	Vector3 operator * (const float fValue) const {
		return Vector3(x * fValue, y * fValue, z * fValue);
	}

	void Normalize() {
		float factor = 1.0f / sqrtf(x * x + y * y + z * z);
		(*this) = (*this) * factor;
	}

	float Length() const {
		return sqrtf(x * x + y * y + z * z);
	}

	float Distance(const Vector3& v) const {
		return (v - *this).Length();
	}

	Vector3 operator ^ (const Vector3& v) const {
		return OuterProduct(v);
	}

	float operator * (const Vector3& v) const {
		return InnerProduct(v);
	}
};



struct FVector
{
	float                                              X;                                                        // 0x0000(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_SaveGame, CPF_IsPlainOldData)
	float                                              Y;                                                        // 0x0004(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_SaveGame, CPF_IsPlainOldData)
	float                                              Z;                                                        // 0x0008(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_SaveGame, CPF_IsPlainOldData)
	operator Vector3() { return Vector3(X, Y, Z); }
};


struct FQuat
{
	float x;
	float y;
	float z;
	float w;
};

D3DXMATRIX Matrix(Vector3 rot, Vector3 origin = Vector3(0, 0, 0))
{
	float radPitch = (rot.x * float(M_PI) / 180.f);
	float radYaw = (rot.y * float(M_PI) / 180.f);
	float radRoll = (rot.z * float(M_PI) / 180.f);

	float SP = sinf(radPitch);
	float CP = cosf(radPitch);
	float SY = sinf(radYaw);
	float CY = cosf(radYaw);
	float SR = sinf(radRoll);
	float CR = cosf(radRoll);

	D3DMATRIX matrix;
	matrix.m[0][0] = CP * CY;
	matrix.m[0][1] = CP * SY;
	matrix.m[0][2] = SP;
	matrix.m[0][3] = 0.f;

	matrix.m[1][0] = SR * SP * CY - CR * SY;
	matrix.m[1][1] = SR * SP * SY + CR * CY;
	matrix.m[1][2] = -SR * CP;
	matrix.m[1][3] = 0.f;

	matrix.m[2][0] = -(CR * SP * CY + SR * SY);
	matrix.m[2][1] = CY * SR - CR * SP * SY;
	matrix.m[2][2] = CR * CP;
	matrix.m[2][3] = 0.f;

	matrix.m[3][0] = origin.x;
	matrix.m[3][1] = origin.y;
	matrix.m[3][2] = origin.z;
	matrix.m[3][3] = 1.f;

	return matrix;
}

struct FTransform
{
	FQuat rot;
	Vector3 translation;
	char pad[4];
	Vector3 scale;
	char pad1[4];
	D3DMATRIX ToMatrixWithScale()
	{
		D3DMATRIX m;
		m._41 = translation.x;
		m._42 = translation.y;
		m._43 = translation.z;

		float x2 = rot.x + rot.x;
		float y2 = rot.y + rot.y;
		float z2 = rot.z + rot.z;

		float xx2 = rot.x * x2;
		float yy2 = rot.y * y2;
		float zz2 = rot.z * z2;
		m._11 = (1.0f - (yy2 + zz2)) * scale.x;
		m._22 = (1.0f - (xx2 + zz2)) * scale.y;
		m._33 = (1.0f - (xx2 + yy2)) * scale.z;

		float yz2 = rot.y * z2;
		float wx2 = rot.w * x2;
		m._32 = (yz2 - wx2) * scale.z;
		m._23 = (yz2 + wx2) * scale.y;

		float xy2 = rot.x * y2;
		float wz2 = rot.w * z2;
		m._21 = (xy2 - wz2) * scale.y;
		m._12 = (xy2 + wz2) * scale.x;

		float xz2 = rot.x * z2;
		float wy2 = rot.w * y2;
		m._31 = (xz2 + wy2) * scale.z;
		m._13 = (xz2 - wy2) * scale.x;

		m._14 = 0.0f;
		m._24 = 0.0f;
		m._34 = 0.0f;
		m._44 = 1.0f;

		return m;
	}
};

struct FMinimalViewInfo
{
	class Vector3                                     Location;                                                 // 0x0000(0x000C) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	class Vector3                                      Rotation;                                                 // 0x000C(0x000C) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              FOV;                                                      // 0x0018(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              OrthoWidth;                                               // 0x001C(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              OrthoNearClipPlane;                                       // 0x0020(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              OrthoFarClipPlane;                                        // 0x0024(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              AspectRatio;                                              // 0x0028(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
};

struct FCameraCacheEntry
{
	float                                              TimeStamp;                                                // 0x0000(0x0004) (CPF_ZeroConstructor, CPF_IsPlainOldData)
	unsigned char                                      UnknownData00[0xC];                                       // 0x0004(0x000C) MISSED OFFSET
	struct FMinimalViewInfo                            POV;                                                      // 0x0010(0x0530)
};

class Rotator
{
public:
	float yaw;
	float pitch;
	float roll;

	Rotator() : yaw(0.f), pitch(0.f), roll(0.f)
	{

	}

	Rotator(float _x, float _y, float _z) : yaw(_x), pitch(_y), roll(_z)
	{

	}
	~Rotator()
	{

	}
};

Vector3 WorldToScreen(Vector3 WorldLocation, FCameraCacheEntry CameraCacheL)
{
	Vector3 Screenlocation = Vector3(0, 0, 0);

	auto POV = CameraCacheL.POV;
	Vector3 Rotation = POV.Rotation; // FRotator

	D3DMATRIX tempMatrix = Matrix(Rotation); // Matrix

	Vector3 vAxisX, vAxisY, vAxisZ;

	vAxisX = Vector3(tempMatrix.m[0][0], tempMatrix.m[0][1], tempMatrix.m[0][2]);
	vAxisY = Vector3(tempMatrix.m[1][0], tempMatrix.m[1][1], tempMatrix.m[1][2]);
	vAxisZ = Vector3(tempMatrix.m[2][0], tempMatrix.m[2][1], tempMatrix.m[2][2]);

	Vector3 vDelta = WorldLocation - POV.Location;
	Vector3 vTransformed = Vector3(vDelta * vAxisY, vDelta * vAxisZ, vDelta * vAxisX);

	if (vTransformed.z < 1.f)
		vTransformed.z = 1.f;

	float FovAngle = POV.FOV;
	float ScreenCenterX = Width / 2.0f;
	float ScreenCenterY = Height / 2.0f;

	Screenlocation.x = ScreenCenterX + vTransformed.x * (ScreenCenterX / tanf(FovAngle * (float)M_PI / 360.f)) / vTransformed.z;
	Screenlocation.y = ScreenCenterY - vTransformed.y * (ScreenCenterX / tanf(FovAngle * (float)M_PI / 360.f)) / vTransformed.z;

	return Screenlocation;
}

D3DMATRIX MatrixMultiplication(D3DMATRIX pM1, D3DMATRIX pM2)
{
	D3DMATRIX pOut;
	pOut._11 = pM1._11 * pM2._11 + pM1._12 * pM2._21 + pM1._13 * pM2._31 + pM1._14 * pM2._41;
	pOut._12 = pM1._11 * pM2._12 + pM1._12 * pM2._22 + pM1._13 * pM2._32 + pM1._14 * pM2._42;
	pOut._13 = pM1._11 * pM2._13 + pM1._12 * pM2._23 + pM1._13 * pM2._33 + pM1._14 * pM2._43;
	pOut._14 = pM1._11 * pM2._14 + pM1._12 * pM2._24 + pM1._13 * pM2._34 + pM1._14 * pM2._44;
	pOut._21 = pM1._21 * pM2._11 + pM1._22 * pM2._21 + pM1._23 * pM2._31 + pM1._24 * pM2._41;
	pOut._22 = pM1._21 * pM2._12 + pM1._22 * pM2._22 + pM1._23 * pM2._32 + pM1._24 * pM2._42;
	pOut._23 = pM1._21 * pM2._13 + pM1._22 * pM2._23 + pM1._23 * pM2._33 + pM1._24 * pM2._43;
	pOut._24 = pM1._21 * pM2._14 + pM1._22 * pM2._24 + pM1._23 * pM2._34 + pM1._24 * pM2._44;
	pOut._31 = pM1._31 * pM2._11 + pM1._32 * pM2._21 + pM1._33 * pM2._31 + pM1._34 * pM2._41;
	pOut._32 = pM1._31 * pM2._12 + pM1._32 * pM2._22 + pM1._33 * pM2._32 + pM1._34 * pM2._42;
	pOut._33 = pM1._31 * pM2._13 + pM1._32 * pM2._23 + pM1._33 * pM2._33 + pM1._34 * pM2._43;
	pOut._34 = pM1._31 * pM2._14 + pM1._32 * pM2._24 + pM1._33 * pM2._34 + pM1._34 * pM2._44;
	pOut._41 = pM1._41 * pM2._11 + pM1._42 * pM2._21 + pM1._43 * pM2._31 + pM1._44 * pM2._41;
	pOut._42 = pM1._41 * pM2._12 + pM1._42 * pM2._22 + pM1._43 * pM2._32 + pM1._44 * pM2._42;
	pOut._43 = pM1._41 * pM2._13 + pM1._42 * pM2._23 + pM1._43 * pM2._33 + pM1._44 * pM2._43;
	pOut._44 = pM1._41 * pM2._14 + pM1._42 * pM2._24 + pM1._43 * pM2._34 + pM1._44 * pM2._44;

	return pOut;
}

struct BoneArrayStruct {
	FTransform BoneArray[198]; //198
};
```

`XeDecrypt.cpp`:

```cpp
#include "XeDecrypt.h"
namespace Decrypts
{
	DWORD DecryptCIndex(DWORD value)
	{
		/*DWORD v10 = _rotr(value ^ 0x9199156E, 0x06);
		DWORD result = v10 ^ (v10 << 0x10) ^ 0xEC4708C3;
		return result;*/

		return __ROL4__(value ^ 0x66FF60D8, 3) ^ (__ROL4__(value ^ 0x66FF60D8, 3) << 16) ^ 0xD3579094;
	}
}
```

`XeDecrypt.h`:

```h
#pragma once
#include "include.h"
/* Memory Unit */
#include "Memory.h"
/* Memory Unit */
using namespace std;
extern "C" DWORD64 Shield_Decrypt(__int64 seed, __int64 value, DWORD64 fnShield, DWORD64 ShieldStart);
static BYTE fnShieldDecrypt[0x200];
namespace Decrypts
{
	DWORD DecryptCIndex(DWORD value);
}
```

`Xors.h`:

```h
#pragma once

// Compile Time String Encryption
// Prevent strings from being stored in rdata/data
// Inline strings in .text and store these on the stack when decrypting
// After the string is decreypted and used, it disappears right away
// How to use: XorString("String")
// Purpose: Prevent generic scan to trigger in case hooks fail
// Initally wrote by LeFF (for malwares)

#define CompileTimeAsSeed       ((__TIME__[7] - '0') * 1  + (__TIME__[6] - '0') * 10  + \
                                (__TIME__[4] - '0') * 60   + (__TIME__[3] - '0') * 600 + \
                                (__TIME__[1] - '0') * 3600 + (__TIME__[0] - '0') * 36000)

template <int X> struct EnsureCompileTime {
    enum : int {
        Value = X
    };
};

constexpr int LinearCongruentGenerator(int Rounds) {
    return 1013904223 + 1664525 * ((Rounds > 0) ? LinearCongruentGenerator(Rounds - 1) : CompileTimeAsSeed & 0xFFFFFFFF);
}

#define Random() EnsureCompileTime<LinearCongruentGenerator(10)>::Value
#define RandomNumber(Min, Max) (Min + (Random() % (Max - Min + 1)))

template <int... Pack> struct IndexList {};

template <typename IndexList, int Right> struct Append;
template <int... Left, int Right> struct Append<IndexList<Left...>, Right> {
    typedef IndexList<Left..., Right> Result;
};

template <int N> struct ConstructIndexList {
    typedef typename Append<typename ConstructIndexList<N - 1>::Result, N - 1>::Result Result;
};
template <> struct ConstructIndexList<0> {
    typedef IndexList<> Result;
};

const char XORKEY = static_cast<char>(RandomNumber(0, 0xFF));
constexpr char EncryptCharacter(const char Character, int Index) {
    return Character ^ (XORKEY + Index);
}

template <typename IndexList> class CXorString;
template <int... Index> class CXorString<IndexList<Index...> > {
private:
    char Value[sizeof...(Index) + 1];
public:
    constexpr CXorString(const char* const String)
        : Value{ EncryptCharacter(String[Index], Index)... } {}

    char* decrypt() {
        for (int t = 0; t < sizeof...(Index); t++) {
            Value[t] = Value[t] ^ (XORKEY + t);
        }
        Value[sizeof...(Index)] = '\0';
        return Value;
    }

    char* get() {
        return Value;
    }
};

#define XorS(X, String) CXorString<ConstructIndexList<sizeof(String)-1>::Result> X(String)
#define XorString( String ) ( CXorString<ConstructIndexList<sizeof( String ) - 1>::Result>( String ).decrypt() )
```

`defs.h`:

```h
#pragma once
/*

   This file contains definitions used by the Hex-Rays decompiler output.
   It has type definitions and convenience macros to make the
   output more readable.

   Copyright (c) 2007-2018 Hex-Rays

*/

#ifndef HEXRAYS_DEFS_H
#define HEXRAYS_DEFS_H

#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif
typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types. They are used when the decompiler does not know
// anything about the type except its size.
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

// Non-standard boolean types. They are used when the decompiler can not use
// the standard "bool" type because of the size mistmatch but the possible
// values are only 0 and 1. See also 'BOOL' type below.
typedef int8 _BOOL1;
typedef int16 _BOOL2;
typedef int32 _BOOL4;
typedef int64 _BOOL8;

#ifndef _WINDOWS_
typedef int8 BYTE;
typedef int16 WORD;
typedef int32 DWORD;
typedef int32 LONG;
typedef int BOOL;       // uppercase BOOL is usually 4 bytes
#endif
typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

#define __pure          // pure function: always returns the same value, has no
                        // side effects

// Non-returning function
#if defined(__GNUC__)
#define __noreturn  __attribute__((noreturn))
#else
#define __noreturn  __declspec(noreturn)
#endif


#ifndef NULL
#define NULL 0
#endif

// Some convenience macros to make partial accesses nicer
#define LAST_IND(x,part_type)    (sizeof(x)/sizeof(part_type) - 1)
#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
#  define LOW_IND(x,part_type)   LAST_IND(x,part_type)
#  define HIGH_IND(x,part_type)  0
#else
#  define HIGH_IND(x,part_type)  LAST_IND(x,part_type)
#  define LOW_IND(x,part_type)   0
#endif
// first unsigned macros:
#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define DWORDn(x, n)  (*((_DWORD*)&(x)+n))

#define LOBYTE(x)  BYTEn(x,LOW_IND(x,_BYTE))
#define LOWORD(x)  WORDn(x,LOW_IND(x,_WORD))
#define LODWORD(x) DWORDn(x,LOW_IND(x,_DWORD))
#define HIBYTE(x)  BYTEn(x,HIGH_IND(x,_BYTE))
#define HIWORD(x)  WORDn(x,HIGH_IND(x,_WORD))
#define HIDWORD(x) DWORDn(x,HIGH_IND(x,_DWORD))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

// now signed macros (the same but with sign extension)
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SDWORDn(x, n)  (*((int32*)&(x)+n))

#define SLOBYTE(x)  SBYTEn(x,LOW_IND(x,int8))
#define SLOWORD(x)  SWORDn(x,LOW_IND(x,int16))
#define SLODWORD(x) SDWORDn(x,LOW_IND(x,int32))
#define SHIBYTE(x)  SBYTEn(x,HIGH_IND(x,int8))
#define SHIWORD(x)  SWORDn(x,HIGH_IND(x,int16))
#define SHIDWORD(x) SDWORDn(x,HIGH_IND(x,int32))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)

// Generate a pair of operands. S stands for 'signed'
#define __SPAIR16__(high, low)  (((int16)  (high) <<  8) | (uint8) (low))
#define __SPAIR32__(high, low)  (((int32)  (high) << 16) | (uint16)(low))
#define __SPAIR64__(high, low)  (((int64)  (high) << 32) | (uint32)(low))
#define __SPAIR128__(high, low) (((int128) (high) << 64) | (uint64)(low))
#define __PAIR16__(high, low)   (((uint16) (high) <<  8) | (uint8) (low))
#define __PAIR32__(high, low)   (((uint32) (high) << 16) | (uint16)(low))
#define __PAIR64__(high, low)   (((uint64) (high) << 32) | (uint32)(low))
#define __PAIR128__(high, low)  (((uint128)(high) << 64) | (uint64)(low))

// Helper functions to represent some assembly instructions.

#ifdef __cplusplus

// compile time assertion
#define __CASSERT_N0__(l) COMPILE_TIME_ASSERT_ ## l
#define __CASSERT_N1__(l) __CASSERT_N0__(l)
#define CASSERT(cnd) typedef char __CASSERT_N1__(__LINE__) [(cnd) ? 1 : -1]

// check that unsigned multiplication does not overflow
template<class T> bool is_mul_ok(T count, T elsize)
{
    CASSERT((T)(-1) > 0); // make sure T is unsigned
    if (elsize == 0 || count == 0)
        return true;
    return count <= ((T)(-1)) / elsize;
}

// multiplication that saturates (yields the biggest value) instead of overflowing
// such a construct is useful in "operator new[]"
template<class T> bool saturated_mul(T count, T elsize)
{
    return is_mul_ok(count, elsize) ? count * elsize : T(-1);
}

#include <stddef.h> // for size_t

// memcpy() with determined behavoir: it always copies
// from the start to the end of the buffer
// note: it copies byte by byte, so it is not equivalent to, for example, rep movsd
inline void* qmemcpy(void* dst, const void* src, size_t cnt)
{
    char* out = (char*)dst;
    const char* in = (const char*)src;
    while (cnt > 0)
    {
        *out++ = *in++;
        --cnt;
    }
    return dst;
}

// rotate left
template<class T> T __ROL__(T value, int count)
{
    const uint nbits = sizeof(T) * 8;

    if (count > 0)
    {
        count %= nbits;
        T high = value >> (nbits - count);
        if (T(-1) < 0) // signed value
            high &= ~((T(-1) << count));
        value <<= count;
        value |= high;
    }
    else
    {
        count = -count % nbits;
        T low = value << (nbits - count);
        value >>= count;
        value |= low;
    }
    return value;
}

inline uint8  __ROL1__(uint8  value, int count) { return __ROL__((uint8)value, count); }
inline uint16 __ROL2__(uint16 value, int count) { return __ROL__((uint16)value, count); }
inline uint32 __ROL4__(uint32 value, int count) { return __ROL__((uint32)value, count); }
inline uint64 __ROL8__(uint64 value, int count) { return __ROL__((uint64)value, count); }
inline uint8  __ROR1__(uint8  value, int count) { return __ROL__((uint8)value, -count); }
inline uint16 __ROR2__(uint16 value, int count) { return __ROL__((uint16)value, -count); }
inline uint32 __ROR4__(uint32 value, int count) { return __ROL__((uint32)value, -count); }
inline uint64 __ROR8__(uint64 value, int count) { return __ROL__((uint64)value, -count); }

// carry flag of left shift
template<class T> int8 __MKCSHL__(T value, uint count)
{
    const uint nbits = sizeof(T) * 8;
    count %= nbits;

    return (value >> (nbits - count)) & 1;
}

// carry flag of right shift
template<class T> int8 __MKCSHR__(T value, uint count)
{
    return (value >> (count - 1)) & 1;
}

// sign flag
template<class T> int8 __SETS__(T x)
{
    if (sizeof(T) == 1)
        return int8(x) < 0;
    if (sizeof(T) == 2)
        return int16(x) < 0;
    if (sizeof(T) == 4)
        return int32(x) < 0;
    return int64(x) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__(T x, U y)
{
    if (sizeof(T) < sizeof(U))
    {
        U x2 = x;
        int8 sx = __SETS__(x2);
        return (sx ^ __SETS__(y)) & (sx ^ __SETS__(U(x2 - y)));
    }
    else
    {
        T y2 = y;
        int8 sx = __SETS__(x);
        return (sx ^ __SETS__(y2)) & (sx ^ __SETS__(T(x - y2)));
    }
}

// overflow flag of addition (x+y)
template<class T, class U> int8 __OFADD__(T x, U y)
{
    if (sizeof(T) < sizeof(U))
    {
        U x2 = x;
        int8 sx = __SETS__(x2);
        return ((1 ^ sx) ^ __SETS__(y)) & (sx ^ __SETS__(U(x2 + y)));
    }
    else
    {
        T y2 = y;
        int8 sx = __SETS__(x);
        return ((1 ^ sx) ^ __SETS__(y2)) & (sx ^ __SETS__(T(x + y2)));
    }
}

// https://en.wikipedia.org/wiki/Carry_flag#Carry_flag_vs._borrow_flag
#if defined(__ARM__) || defined(__PPC__)
#define SUB_WITH_CARRY 1
#else
#define SUB_WITH_CARRY 0
#endif

// carry flag of subtraction (x-y)
template<class T, class U> int8 __CFSUB__(T x, U y)
{
    int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
    bool res;
    if (size == 1)
        res = uint8(x) < uint8(y);
    else if (size == 2)
        res = uint16(x) < uint16(y);
    else if (size == 4)
        res = uint32(x) < uint32(y);
    else
        res = uint64(x) < uint64(y);
#if SUB_WITH_CARRY
    res = !res;
#endif
    return res;
}

// carry flag of addition (x+y)
template<class T, class U> int8 __CFADD__(T x, U y)
{
    int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
    if (size == 1)
        return uint8(x) > uint8(x + y);
    if (size == 2)
        return uint16(x) > uint16(x + y);
    if (size == 4)
        return uint32(x) > uint32(x + y);
    return uint64(x) > uint64(x + y);
}

// carry flag of subtraction with carry
template<class T, class U> int8 __CFSUB__(T x, U y, int8 cf)
{
#if SUB_WITH_CARRY
    cf = !cf;
#endif
    return __CFADD__(y, cf) ^ __CFSUB(x, y + cf);
}

// overflow flag of subtraction with carry
template<class T, class U> int8 __OFSUB__(T x, U y, int8 cf)
{
#if SUB_WITH_CARRY
    cf = !cf;
#endif
    return __OFADD__(y, cf) ^ __OFSUB(x, y + cf);
}

inline int8   abs8(int8     x) { return x >= 0 ? x : -x; }
inline int16  abs16(int16   x) { return x >= 0 ? x : -x; }
inline int32  abs32(int32   x) { return x >= 0 ? x : -x; }
inline int64  abs64(int64   x) { return x >= 0 ? x : -x; }
//inline int128 abs128(int128 x) { return x >= 0 ? x : -x; }

#else // C++
// For C, we just provide macros, they are not quite correct.
#define __ROL__(x, y) __rotl__(x, y)      // Rotate left
#define __ROR__(x, y) __rotr__(x, y)      // Rotate right
#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x<<y)
#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x>>y)
#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)
#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)
#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)
#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)

#define abs8(x)   (int8)  ((int8)  (x) >= 0 ? (x) : -(x))
#define abs16(x)  (int16) ((int16) (x) >= 0 ? (x) : -(x))
#define abs32(x)  (int32) ((int32) (x) >= 0 ? (x) : -(x))
#define abs64(x)  (int64) ((int64) (x) >= 0 ? (x) : -(x))
#define abs128(x) (int128)((int128)(x) >= 0 ? (x) : -(x))

#endif // C++

#define __RCL__(x, y)    invalid_operation // Rotate left thru carry
#define __RCR__(x, y)    invalid_operation // Rotate right thru carry
#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL
#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR
#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)

#define _UNKNOWN char

#define ADJ(p) (__parentof(p) *)(p-__deltaof(p))

#endif

```

`driver.cpp`:

```cpp
#include "driver.h"
#include <stdio.h>

driver::driver()
{
	hDriver = CreateFileA("\\\\.\\NMH1313", GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Driver Install Failed\n");
	}
	else
	{
		printf("[!] Driver Install Successed\n");
	}
}


driver::~driver()
{
	if (hDriver != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hDriver);
		printf("[!] Driver UnInstall Successed\n");
	}
}

unsigned long long driver::GetGameModule()
{
	if (hDriver == INVALID_HANDLE_VALUE) return 0;
	unsigned long long readBuffer;
	unsigned long Bytes;
	_IOBUFFER ReadRequest
	{
		(unsigned long long) & readBuffer,
		(unsigned long long)0x0,
		sizeof(unsigned long long),
		(unsigned long)GetCurrentProcessId(),
		0
	};
	int stat = DeviceIoControl(
		hDriver,
		IOCTL_IO_MOUDLE,
		&ReadRequest,
		sizeof(ReadRequest),
		&ReadRequest,
		sizeof(ReadRequest),
		&Bytes,
		0);
	return stat ? readBuffer : 0;
}

unsigned long driver::GetGamePid()
{
	if (hDriver == INVALID_HANDLE_VALUE) return 0;
	unsigned long readBuffer;
	unsigned long Bytes;
	_IOBUFFER ReadRequest
	{
		(unsigned long long) & readBuffer,
		(unsigned long long)0x0,
		sizeof(unsigned long long),
		(unsigned long)GetCurrentProcessId(),
		0
	};
	int stat = DeviceIoControl(
		hDriver,
		IOCTL_IO_PID,
		&ReadRequest,
		sizeof(ReadRequest),
		&ReadRequest,
		sizeof(ReadRequest),
		&Bytes,
		0);
	return stat ? readBuffer : 0;
}

unsigned long long driver::GetImageSize()
{
	if (hDriver == INVALID_HANDLE_VALUE) return 0;
	unsigned long long readBuffer;
	unsigned long Bytes;
	_IOBUFFER ReadRequest
	{
		(unsigned long long) & readBuffer,
		(unsigned long long)0x0,
		sizeof(unsigned long long),
		(unsigned long)GetCurrentProcessId(),
		0
	};
	int stat = DeviceIoControl(
		hDriver,
		IOCTL_IO_IMAGESIZE,
		&ReadRequest,
		sizeof(ReadRequest),
		&ReadRequest,
		sizeof(ReadRequest),
		&Bytes,
		0);
	return stat ? readBuffer : 0;
}

driver drv;
```

`driver.h`:

```h
#pragma once
#include <Windows.h>
#include <winioctl.h>

//driver r/w struct
typedef struct _IOBUFFER
{
	unsigned long long UserBufferAdress;
	unsigned long long GameAddressOffset;
	unsigned long long Size;
	unsigned long      UserPID;
	unsigned long      GamePID;
} IOBUFFER, * PIOBUFFER;


#define IOCTL_IO_READ		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8001, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_IO_WRITE		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8012, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_IO_PID		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8023, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_IO_MOUDLE		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8034, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_IO_IMAGESIZE  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8045, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)


class driver
{
public:
	driver();
	~driver();

	unsigned long long GetGameModule();
	unsigned long GetGamePid();
	unsigned long long GetImageSize();

	template <typename T> inline T RPM(unsigned long long Addr);
	template <typename T> inline T RPM(unsigned long long Addr, unsigned long Size);
	template <typename T> inline bool RPM(unsigned long long Addr, T OuterBuffer, unsigned long Size);
	template <typename T> inline bool WPM(unsigned long long Addr, T value);
	template <typename T> inline bool WPM(unsigned long long Addr, T value, unsigned long Size);

protected:
	void* hDriver;

};

template<typename T>
inline T driver::RPM(unsigned long long Addr)
{
	T readBuffer = 0;

	unsigned long Bytes;
	_IOBUFFER ReadRequest
	{
		(unsigned long long) & readBuffer,
		(unsigned long long)Addr,
		sizeof(T),
		(unsigned long)GetCurrentProcessId(),
		0
	};
	DeviceIoControl(
		hDriver,
		IOCTL_IO_READ,
		&ReadRequest,
		sizeof(ReadRequest),
		&ReadRequest,
		sizeof(ReadRequest),
		&Bytes,
		0);
	return (T)readBuffer;
}

template<typename T>
inline T driver::RPM(unsigned long long Addr, unsigned long Size)
{
	T readBuffer = {};

	unsigned long Bytes;
	_IOBUFFER ReadRequest
	{
		(unsigned long long) & readBuffer,
		(unsigned long long)Addr,
		Size,
		(unsigned long)GetCurrentProcessId(),
		0
	};
	DeviceIoControl(
		hDriver,
		IOCTL_IO_READ,
		&ReadRequest,
		sizeof(ReadRequest),
		&ReadRequest,
		sizeof(ReadRequest),
		&Bytes,
		0);
	return (T)readBuffer;
}

template<typename T>
inline bool driver::RPM(unsigned long long Addr, T OuterBuffer, unsigned long Size)
{
	unsigned long Bytes;
	_IOBUFFER ReadRequest
	{
		(unsigned long long)OuterBuffer,
		(unsigned long long)Addr,
		Size,
		(unsigned long)GetCurrentProcessId(),
		0
	};
	return DeviceIoControl(
		hDriver,
		IOCTL_IO_READ,
		&ReadRequest,
		sizeof(ReadRequest),
		&ReadRequest,
		sizeof(ReadRequest),
		&Bytes,
		0);
}

template<typename T>
inline bool driver::WPM(unsigned long long Addr, T value)
{
	T writeBuffer = value;
	unsigned long Bytes;
	_IOBUFFER  WriteRequest
	{
		(unsigned long long) & writeBuffer,
		(unsigned long long)Addr,
		sizeof(T),
		(unsigned long)GetCurrentProcessId(),
		0
	};
	return DeviceIoControl(
		hDriver,
		IOCTL_IO_WRITE,
		&WriteRequest,
		sizeof(WriteRequest),
		&WriteRequest,
		sizeof(WriteRequest),
		&Bytes,
		0);
}

template<typename T>
inline bool driver::WPM(unsigned long long Addr, T value, unsigned long Size)
{
	unsigned long Bytes;
	_IOBUFFER  WriteRequest
	{
		(unsigned long long)value,
		(unsigned long long)Addr,
		Size,
		(unsigned long)GetCurrentProcessId(),
		0
	};

	return DeviceIoControl(
		hDriver,
		IOCTL_IO_WRITE,
		&WriteRequest,
		sizeof(WriteRequest),
		&WriteRequest,
		sizeof(WriteRequest),
		&Bytes,
		0);
}

extern driver drv;
```

`include.h`:

```h
#pragma once

/* VC C++ */
#include <Windows.h>
#include <winhttp.h>
#include <urlmon.h>
#include <shellapi.h>
#include <xstring>
#include <thread>
#include <chrono>
#include <functional>
#include <vector>
#include <iostream>
#include <fstream>
#include <string>
#include <list>
#include <direct.h>
#include <Dwmapi.h> 
#include <TlHelp32.h>
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib,"Dwmapi.lib")
/* VC C++ */

/* VC DircetX */
#include <d3dx9.h>
#include <d3d9.h>
#pragma comment(lib,"d3d9.lib")
#pragma comment(lib,"d3dx9.lib")
/* VC DircetX */

/* BoneIDX */
#include "BoneIdx.h"
/* BoneIDX */

/* Offsets & Address */
#include "Address.h"
/* Offsets & Address */

/* Xor */
#include "defs.h"
#include "Xors.h"
/* Xor */

using namespace std;
```